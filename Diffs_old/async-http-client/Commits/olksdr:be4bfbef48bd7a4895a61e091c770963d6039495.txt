diff --git a/MIGRATION.md b/MIGRATION.md
new file mode 100644
index 000000000..43781ca2c
--- /dev/null
+++ b/MIGRATION.md
@@ -0,0 +1,51 @@
+Migration Guide
+---------------
+
+## From 1.8 to 1.9
+
+AsyncHttpClient v1.9 is a preview of v2, so it comes with some breaking changes.
+
+* Target JDK7, drop support for JDK5 and JDK6
+* Rename many AsyncHttpClientConfig parameters:
+  * `maxTotalConnections` becomes `maxConnections`
+  * `maxConnectionPerHost` becomes `maxConnectionsPerHost`
+  * `connectionTimeOutInMs` becomes `connectTimeout`
+  * `webSocketIdleTimeoutInMs` becomes `webSocketTimeout`
+  * `idleConnectionInPoolTimeoutInMs` becomes `pooledConnectionIdleTimeout`
+  * `idleConnectionTimeoutInMs` becomes `readTimeout`
+  * `requestTimeoutInMs` becomes `requestTimeout`
+  * `maxConnectionLifeTimeInMs` becomes `connectionTTL`
+  * `redirectEnabled` becomes `followRedirect`
+  * `allowPoolingConnection` becomes `allowPoolingConnections`
+  * `allowSslConnectionPool` becomes `allowPoolingSslConnections`
+  * `connectionTimeout` becomes `connectTimeout`
+  * `compressionEnabled` becomes `compressionEnforced` (default true) so it's always enabled and can honor user defined Accept-Encoding
+  * `requestCompressionLevel` was dropped, as it wasn't working
+  * `SSLEngineFactory` was moved to Netty config as only Netty honors it
+  * `useRawUrl` becomes `disableUrlEncodingForBoundedRequests`, as it's only honored by bound requests
+  * `getAllowPoolingConnection` becomes `isAllowPoolingConnection`
+* Drop `PerRequestConfig`. `requestTimeOut` and `proxy` can now be directly set on the request.
+* Drop `java.net.URI` in favor of own `com.ning.http.client.uri.Uri`. You can use `toJavaNetURI` to convert.
+* Drop `Proxy.getURI` in favor of `getUrl`
+* Drop deprecated methods: `Request` and `RequestBuilderBase`'s `getReqType` in favor of `getMethod`, `Request.getLength` in favor of `getContentLength`
+* Drop deprecated `RealmBuilder.getDomain` in favor of `getNtlmDomain`
+* Rename `xxxParameter` (add, set, get...) into `xxxFormParam`
+* Rename `xxxQueryParameter` (add, set, get...) into `xxxQueryParam`
+* Merge `boolean Request.isRedirectEnabled` and `boolean isRedirectOverrideSet` are merged into `Boolean isRedirectEnabled`
+* Remove url parameter from `SignatureCalculator.calculateAndAddSignature`, as it can be fetched on the request parameter
+* Rename `com.ning.http.client.websocket` package into `com.ning.http.client.ws`
+* WebSocket Listeners now have to implement proper interfaces to be notified or fragment events: `WebSocketByteFragmentListener` and `WebSocketTextFragmentListener`
+* Rename WebSocket's `sendTextMessage` into `sendMessage` and `streamText` into `stream`
+* Rename NettyAsyncHttpProviderConfig's `handshakeTimeoutInMillis` into `handshakeTimeout`
+* Netty provider now creates SslEngines instances with proper hoststring and port.
+* Parts, Realm and ProxyServer now take a java.nio.Charset instead of a String charset name
+* New AsyncHandlerExtensions methods:
+  * `onOpenConnection`,
+  * `onConnectionOpen`,
+  * `onPoolConnection`,
+  * `onConnectionPooled`,
+  * `onSendRequest`,
+  * `onDnsResolved`,
+  * `onSslHandshakeCompleted`
+* Rename FluentCaseInsensitiveStringsMap and FluentStringsMap `replace` into `replaceWith` to not conflict with new JDK8 Map methods
+* execute no longer throws Exceptions, all of them are notified to the handler/future
diff --git a/README.md b/README.md
index f19c6e017..57cc2226a 100644
--- a/README.md
+++ b/README.md
@@ -1,16 +1,22 @@
-Async Http Client
------------------
+Async Http Client ([@AsyncHttpClient](https://twitter.com/AsyncHttpClient) on twitter)
+---------------------------------------------------
 
-Getting started [HTML](http://sonatype.github.com/async-http-client/) [PDF](http://is.gd/kexrN)
-                With [WebSockets](http://jfarcand.wordpress.com/2011/12/21/writing-websocket-clients-using-asynchttpclient/)
+[Javadoc](http://www.javadoc.io/doc/com.ning/async-http-client/)
 
-Async Http Client library purpose is to allow Java applications to easily execute HTTP requests and asynchronously process the HTTP responses. The library also supports the WebSocket Protocol. The Async HTTP Client library is simple to use. First, in order to add it to your Maven project, simply add this dependency:
+[Getting](https://jfarcand.wordpress.com/2010/12/21/going-asynchronous-using-asynchttpclient-the-basic/) [started](https://jfarcand.wordpress.com/2011/01/04/going-asynchronous-using-asynchttpclient-the-complex/), and use [WebSockets](http://jfarcand.wordpress.com/2011/12/21/writing-websocket-clients-using-asynchttpclient/)
+
+Async Http Client library purpose is to allow Java applications to easily execute HTTP requests and asynchronously process the HTTP responses.
+The library also supports the WebSocket Protocol. The Async HTTP Client library is simple to use.
+
+## Installation
+
+First, in order to add it to your Maven project, simply add this dependency:
 
 ```xml
 <dependency>
   <groupId>com.ning</groupId>
   <artifactId>async-http-client</artifactId>
-  <version>1.8.13</version>
+  <version>1.9.31</version>
 </dependency>
 ```
 
@@ -18,7 +24,41 @@ You can also download the artifact
 
 [Maven Search](http://search.maven.org)
 
-Then in your code you can simply do [Javadoc](http://asynchttpclient.github.io/async-http-client/apidocs/reference/packages.html)
+AHC is an abstraction layer that can work on top of the bare JDK, Netty and Grizzly.
+Note that the JDK implementation is very limited and you should **REALLY** use the other *real* providers.
+
+You then have to add the Netty or Grizzly jars in the classpath.
+
+For Netty:
+
+```xml
+<dependency>
+    <groupId>io.netty</groupId>
+    <artifactId>netty</artifactId>
+    <version>LATEST_NETTY_3_VERSION</version>
+</dependency>
+```
+
+For Grizzly:
+
+```xml
+<dependency>
+    <groupId>org.glassfish.grizzly</groupId>
+    <artifactId>connection-pool</artifactId>
+    <version>LATEST_GRIZZLY_VERSION</version>
+</dependency>
+<dependency>
+    <groupId>org.glassfish.grizzly</groupId>
+    <artifactId>grizzly-websockets</artifactId>
+    <version>LATEST_GRIZZLY_VERSION</version>
+</dependency>
+```
+
+Check [migration guide](MIGRATION.md) for migrating from 1.8 to 1.9.
+
+## Usage
+
+Then in your code you can simply do
 
 ```java
 import com.ning.http.client.*;
@@ -162,7 +202,7 @@ WebSocket websocket = c.prepareGet(getTargetUrl())
           }
 
           @Override
-          public void onClose(.WebSocket websocket) {
+          public void onClose(WebSocket websocket) {
               latch.countDown();
           }
 
@@ -185,10 +225,6 @@ Keep up to date on the library development by joining the Asynchronous HTTP Clie
 
 [Google Group](http://groups.google.com/group/asynchttpclient)
 
-or follow us on [Twitter](http://twitter.com/jfarcand)
-
-[![githalytics.com alpha](https://cruel-carlota.pagodabox.com/6433679063b2351599c6ca44a08246a2 "githalytics.com")](http://githalytics.com/AsyncHttpClient/async-http-client)
-
 ## Contributing
 
 Of course, Pull Requests are welcome.
diff --git a/api/pom.xml b/api/pom.xml
index 0f5b2bdff..a2dd56866 100644
--- a/api/pom.xml
+++ b/api/pom.xml
@@ -1,46 +1,54 @@
-<project xmlns="http://maven.apache.org/POM/4.0.0"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-    <parent>
-        <groupId>org.asynchttpclient</groupId>
-        <artifactId>async-http-client-project</artifactId>
-        <version>2.0.0-SNAPSHOT</version>
-    </parent>
-    <modelVersion>4.0.0</modelVersion>
-    <artifactId>async-http-client-api</artifactId>
-    <name>Asynchronous Http Client API</name>
-    <description>
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+	<parent>
+		<groupId>org.asynchttpclient</groupId>
+		<artifactId>async-http-client-project</artifactId>
+		<version>2.0.0-SNAPSHOT</version>
+	</parent>
+	<modelVersion>4.0.0</modelVersion>
+	<artifactId>async-http-client-api</artifactId>
+	<name>Asynchronous Http Client API</name>
+	<description>
         The Async Http Client (AHC) API classes.
     </description>
 
-    <build>
-        <plugins>
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-jar-plugin</artifactId>
-                <version>2.2</version>
-                <executions>
-                    <execution>
-                        <goals>
-                            <goal>test-jar</goal>
-                        </goals>
-                    </execution>
-                </executions>
-            </plugin>
-        </plugins>
-    </build>
+	<build>
+		<plugins>
+			<plugin>
+				<artifactId>maven-jar-plugin</artifactId>
+				<executions>
+					<execution>
+						<goals>
+							<goal>test-jar</goal>
+						</goals>
+					</execution>
+				</executions>
+			</plugin>
+			<plugin>
+				<artifactId>maven-antrun-plugin</artifactId>
+				<executions>
+					<execution>
+						<phase>process-classes</phase>
+						<goals>
+							<goal>run</goal>
+						</goals>
+					</execution>
+				</executions>
+				<configuration>
+					<tasks>
+						<delete>
+							<fileset dir="${project.build.outputDirectory}/org/asynchttpclient/netty" includes="NettyAsyncHttpProvider.*" />
+						</delete>
+					</tasks>
+				</configuration>
+			</plugin>
+		</plugins>
+	</build>
 
-    <dependencies>
-        <dependency>
-            <groupId>com.typesafe</groupId>
-            <artifactId>config</artifactId>
-            <version>1.2.1</version>
-        </dependency>
-        <dependency>
-            <groupId>org.slf4j</groupId>
-            <artifactId>slf4j-api</artifactId>
-            <version>1.7.6</version>
-        </dependency>
-    </dependencies>
-
-</project>
\ No newline at end of file
+	<dependencies>
+		<dependency>
+			<groupId>org.reactivestreams</groupId>
+			<artifactId>reactive-streams</artifactId>
+			<version>1.0.0</version>
+		</dependency>
+	</dependencies>
+</project>
diff --git a/api/src/main/java/org/asynchttpclient/AsyncCompletionHandler.java b/api/src/main/java/org/asynchttpclient/AsyncCompletionHandler.java
index b27a99dfb..1b8cf5318 100644
--- a/api/src/main/java/org/asynchttpclient/AsyncCompletionHandler.java
+++ b/api/src/main/java/org/asynchttpclient/AsyncCompletionHandler.java
@@ -16,44 +16,45 @@
  */
 package org.asynchttpclient;
 
+import org.asynchttpclient.handler.ProgressAsyncHandler;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 /**
  * An {@link AsyncHandler} augmented with an {@link #onCompleted(Response)} convenience method which gets called
  * when the {@link Response} processing is finished.  This class also implement the {@link ProgressAsyncHandler} callback,
- * all doing nothing except returning {@link org.asynchttpclient.AsyncHandler.STATE#CONTINUE}
+ * all doing nothing except returning {@link org.asynchttpclient.AsyncHandler.State#CONTINUE}
  *
  * @param <T> Type of the value that will be returned by the associated {@link java.util.concurrent.Future}
  */
 public abstract class AsyncCompletionHandler<T> implements AsyncHandler<T>, ProgressAsyncHandler<T> {
 
-    private final Logger log = LoggerFactory.getLogger(AsyncCompletionHandlerBase.class);
+    private static final Logger LOGGER = LoggerFactory.getLogger(AsyncCompletionHandler.class);
     private final Response.ResponseBuilder builder = new Response.ResponseBuilder();
 
     /**
      * {@inheritDoc}
      */
-    public STATE onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
+    public State onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
         builder.accumulate(content);
-        return STATE.CONTINUE;
+        return State.CONTINUE;
     }
 
     /**
      * {@inheritDoc}
      */
-    public STATE onStatusReceived(final HttpResponseStatus status) throws Exception {
+    public State onStatusReceived(final HttpResponseStatus status) throws Exception {
         builder.reset();
         builder.accumulate(status);
-        return STATE.CONTINUE;
+        return State.CONTINUE;
     }
 
     /**
      * {@inheritDoc}
      */
-    public STATE onHeadersReceived(final HttpResponseHeaders headers) throws Exception {
+    public State onHeadersReceived(final HttpResponseHeaders headers) throws Exception {
         builder.accumulate(headers);
-        return STATE.CONTINUE;
+        return State.CONTINUE;
     }
 
     /**
@@ -67,14 +68,11 @@ public final T onCompleted() throws Exception {
      * {@inheritDoc}
      */
     public void onThrowable(Throwable t) {
-        log.debug(t.getMessage(), t);
+        LOGGER.debug(t.getMessage(), t);
     }
 
     /**
      * Invoked once the HTTP response processing is finished.
-     * <p/>
-     * <p/>
-     * Gets always invoked as last callback method.
      *
      * @param response The {@link Response}
      * @return T Value that will be returned by the associated {@link java.util.concurrent.Future}
@@ -86,20 +84,20 @@ public void onThrowable(Throwable t) {
      * Invoked when the content (a {@link java.io.File}, {@link String} or {@link java.io.FileInputStream} has been fully
      * written on the I/O socket.
      *
-     * @return a {@link org.asynchttpclient.AsyncHandler.STATE} telling to CONTINUE or ABORT the current processing.
+     * @return a {@link org.asynchttpclient.AsyncHandler.State} telling to CONTINUE or ABORT the current processing.
      */
-    public STATE onHeaderWriteCompleted() {
-        return STATE.CONTINUE;
+    public State onHeadersWritten() {
+        return State.CONTINUE;
     }
 
     /**
      * Invoked when the content (a {@link java.io.File}, {@link String} or {@link java.io.FileInputStream} has been fully
      * written on the I/O socket.
      *
-     * @return a {@link org.asynchttpclient.AsyncHandler.STATE} telling to CONTINUE or ABORT the current processing.
+     * @return a {@link org.asynchttpclient.AsyncHandler.State} telling to CONTINUE or ABORT the current processing.
      */
-    public STATE onContentWriteCompleted() {
-        return STATE.CONTINUE;
+    public State onContentWritten() {
+        return State.CONTINUE;
     }
 
     /**
@@ -108,9 +106,9 @@ public STATE onContentWriteCompleted() {
      * @param amount  The amount of bytes to transfer
      * @param current The amount of bytes transferred
      * @param total   The total number of bytes transferred
-     * @return a {@link org.asynchttpclient.AsyncHandler.STATE} telling to CONTINUE or ABORT the current processing.
+     * @return a {@link org.asynchttpclient.AsyncHandler.State} telling to CONTINUE or ABORT the current processing.
      */
-    public STATE onContentWriteProgress(long amount, long current, long total) {
-        return STATE.CONTINUE;
+    public State onContentWriteProgress(long amount, long current, long total) {
+        return State.CONTINUE;
     }
 }
diff --git a/api/src/main/java/org/asynchttpclient/AsyncCompletionHandlerBase.java b/api/src/main/java/org/asynchttpclient/AsyncCompletionHandlerBase.java
index cd5f0a608..d14951605 100644
--- a/api/src/main/java/org/asynchttpclient/AsyncCompletionHandlerBase.java
+++ b/api/src/main/java/org/asynchttpclient/AsyncCompletionHandlerBase.java
@@ -23,7 +23,7 @@
  * Simple {@link AsyncHandler} of type {@link Response}
  */
 public class AsyncCompletionHandlerBase extends AsyncCompletionHandler<Response> {
-    private final Logger log = LoggerFactory.getLogger(AsyncCompletionHandlerBase.class);
+    private static final Logger LOGGER = LoggerFactory.getLogger(AsyncCompletionHandlerBase.class);
 
     /**
      * {@inheritDoc}
@@ -38,6 +38,6 @@ public Response onCompleted(Response response) throws Exception {
      */
     @Override
     public void onThrowable(Throwable t) {
-        log.debug(t.getMessage(), t);
+        LOGGER.debug(t.getMessage(), t);
     }
 }
diff --git a/api/src/main/java/org/asynchttpclient/AsyncHandler.java b/api/src/main/java/org/asynchttpclient/AsyncHandler.java
index 843868e3f..189ea3b86 100644
--- a/api/src/main/java/org/asynchttpclient/AsyncHandler.java
+++ b/api/src/main/java/org/asynchttpclient/AsyncHandler.java
@@ -15,6 +15,7 @@
  */
 package org.asynchttpclient;
 
+
 /**
  * An asynchronous handler or callback which gets invoked as soon as some data is available when
  * processing an asynchronous response.<br/>
@@ -26,7 +27,7 @@
  * <li>{@link #onCompleted()}, once the response has been fully read.</li>
  * </ol>
  * <p/>
- * Returning a {@link AsyncHandler.STATE#ABORT} from any of those callback methods will interrupt asynchronous response
+ * Returning a {@link AsyncHandler.State#ABORT} from any of those callback methods will interrupt asynchronous response
  * processing, after that only {@link #onCompleted()} is going to be called.
  * <p/>
  * <p/>
@@ -44,7 +45,7 @@
  */
 public interface AsyncHandler<T> {
 
-    public static enum STATE {
+    enum State {
 
         /**
          * Stop the processing.
@@ -73,29 +74,29 @@
      * Beware that, depending on the provider (Netty) this can be notified with empty body parts.
      *
      * @param bodyPart response's body part.
-     * @return a {@link STATE} telling to CONTINUE or ABORT the current processing.
+     * @return a {@link State} telling to CONTINUE or ABORT the current processing.
      * @throws Exception if something wrong happens
      */
-    STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception;
+    State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception;
 
     /**
      * Invoked as soon as the HTTP status line has been received
      *
      * @param responseStatus the status code and test of the response
-     * @return a {@link STATE} telling to CONTINUE or ABORT the current processing.
+     * @return a {@link State} telling to CONTINUE or ABORT the current processing.
      * @throws Exception if something wrong happens
      */
-    STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception;
+    State onStatusReceived(HttpResponseStatus responseStatus) throws Exception;
 
     /**
      * Invoked as soon as the HTTP headers has been received. Can potentially be invoked more than once if a broken server
      * sent trailing headers.
      *
      * @param headers the HTTP headers.
-     * @return a {@link STATE} telling to CONTINUE or ABORT the current processing.
+     * @return a {@link State} telling to CONTINUE or ABORT the current processing.
      * @throws Exception if something wrong happens
      */
-    STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception;
+    State onHeadersReceived(HttpResponseHeaders headers) throws Exception;
 
     /**
      * Invoked once the HTTP response processing is finished.
diff --git a/api/src/main/java/org/asynchttpclient/AsyncHttpClient.java b/api/src/main/java/org/asynchttpclient/AsyncHttpClient.java
index 45136c297..841592e66 100755
--- a/api/src/main/java/org/asynchttpclient/AsyncHttpClient.java
+++ b/api/src/main/java/org/asynchttpclient/AsyncHttpClient.java
@@ -17,7 +17,6 @@
 package org.asynchttpclient;
 
 import java.io.Closeable;
-import java.io.IOException;
 import java.util.concurrent.Future;
 
 /**
@@ -123,7 +122,7 @@
  *      Response r = f.get();
  * </pre></blockquote>
  * <p/>
- * An instance of this class will cache every HTTP 1.1 connections and close them when the {@link AsyncHttpClientConfig#getIdleConnectionTimeoutInMs()}
+ * An instance of this class will cache every HTTP 1.1 connections and close them when the {@link AsyncHttpClientConfig#getReadTimeout()}
  * expires. This object can hold many persistent connections to different host.
  */
 public interface AsyncHttpClient extends Closeable {
@@ -251,16 +250,14 @@
      * @param handler an instance of {@link AsyncHandler}
      * @param <T>     Type of the value that will be returned by the associated {@link java.util.concurrent.Future}
      * @return a {@link Future} of type T
-     * @throws IOException
      */
-    <T> ListenableFuture<T> executeRequest(Request request, AsyncHandler<T> handler) throws IOException;
+    <T> ListenableFuture<T> executeRequest(Request request, AsyncHandler<T> handler);
 
     /**
      * Execute an HTTP request.
      *
      * @param request {@link Request}
      * @return a {@link Future} of type Response
-     * @throws IOException
      */
-    ListenableFuture<Response> executeRequest(Request request) throws IOException;
+    ListenableFuture<Response> executeRequest(Request request);
 }
diff --git a/api/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java b/api/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java
index 12dcda85e..b8fd01525 100644
--- a/api/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java
+++ b/api/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java
@@ -15,7 +15,7 @@
  */
 package org.asynchttpclient;
 
-import static org.asynchttpclient.AsyncHttpClientConfigDefaults.*;
+import static org.asynchttpclient.config.AsyncHttpClientConfigDefaults.*;
 
 import java.io.IOException;
 import java.io.InputStream;
@@ -26,32 +26,32 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 
-import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLContext;
 
-import org.asynchttpclient.date.TimeConverter;
+import org.asynchttpclient.channel.SSLEngineFactory;
 import org.asynchttpclient.filter.IOExceptionFilter;
 import org.asynchttpclient.filter.RequestFilter;
 import org.asynchttpclient.filter.ResponseFilter;
-import org.asynchttpclient.util.DefaultHostnameVerifier;
+import org.asynchttpclient.proxy.ProxyServer;
+import org.asynchttpclient.proxy.ProxyServerSelector;
+import org.asynchttpclient.util.PrefixIncrementThreadFactory;
 import org.asynchttpclient.util.ProxyUtils;
 
 /**
- * Configuration class to use with a {@link AsyncHttpClient}. System property can be also used to configure this
- * object default behavior by doing:
+ * Configuration class to use with a {@link AsyncHttpClient}. System property
+ * can be also used to configure this object default behavior by doing:
  * <p/>
  * -Dorg.asynchttpclient.AsyncHttpClientConfig.nameOfTheProperty
  */
 public class AsyncHttpClientConfig {
 
-    protected final static String ASYNC_CLIENT = AsyncHttpClientConfig.class.getName() + ".";
     public final static String AHC_VERSION;
 
     static {
         InputStream is = null;
         Properties prop = new Properties();
         try {
-            is = AsyncHttpClientConfig.class.getResourceAsStream("version.properties");
+            is = AsyncHttpClientConfig.class.getResourceAsStream("/ahc-version.properties");
             prop.load(is);
         } catch (IOException e) {
             e.printStackTrace();
@@ -67,7 +67,9 @@
         AHC_VERSION = prop.getProperty("ahc.version", "UNKNOWN");
     }
 
-    protected int connectionTimeout;
+    protected String name;
+
+    protected int connectTimeout;
 
     protected int maxConnections;
     protected int maxConnectionsPerHost;
@@ -82,20 +84,17 @@
     protected int connectionTTL;
 
     protected SSLContext sslContext;
-    protected HostnameVerifier hostnameVerifier;
     protected boolean acceptAnyCertificate;
 
     protected boolean followRedirect;
     protected int maxRedirects;
-    protected boolean removeQueryParamOnRedirect;
     protected boolean strict302Handling;
 
     protected ProxyServerSelector proxyServerSelector;
-    protected boolean useRelativeURIsWithConnectProxies;
 
     protected boolean compressionEnforced;
     protected String userAgent;
-    protected ExecutorService applicationThreadPool;
+    protected ExecutorService executorService;
     protected Realm realm;
     protected List<RequestFilter> requestFilters;
     protected List<ResponseFilter> responseFilters;
@@ -103,18 +102,27 @@
     protected int maxRequestRetry;
     protected boolean disableUrlEncodingForBoundRequests;
     protected int ioThreadMultiplier;
-    protected TimeConverter timeConverter;
+    protected String[] enabledProtocols;
+    protected String[] enabledCipherSuites;
+    protected Integer sslSessionCacheSize;
+    protected Integer sslSessionTimeout;
+    protected int httpClientCodecMaxInitialLineLength = 4096;
+    protected int httpClientCodecMaxHeaderSize = 8192;
+    protected int httpClientCodecMaxChunkSize = 8192;
+    protected boolean disableZeroCopy;
+    protected long handshakeTimeout = 10000L;
+    protected SSLEngineFactory sslEngineFactory;
+    protected int chunkedFileChunkSize = 8192;
+    protected int webSocketMaxBufferSize = 128000000;
+    protected int webSocketMaxFrameSize = 10 * 1024;
+    protected boolean keepEncodingHeader = false;
     protected AsyncHttpProviderConfig<?, ?> providerConfig;
-    
-    // AHC 2 specific
-    protected boolean spdyEnabled;
-    protected int spdyInitialWindowSize;
-    protected int spdyMaxConcurrentStreams;
 
     protected AsyncHttpClientConfig() {
     }
 
-    private AsyncHttpClientConfig(int connectionTimeout,//
+    private AsyncHttpClientConfig(String name,//
+            int connectTimeout,//
             int maxConnections,//
             int maxConnectionsPerHost,//
             int requestTimeout,//
@@ -125,15 +133,12 @@ private AsyncHttpClientConfig(int connectionTimeout,//
             int idleConnectionInPoolTimeout,//
             int maxConnectionLifeTime,//
             SSLContext sslContext, //
-            HostnameVerifier hostnameVerifier,//
             boolean acceptAnyCertificate, //
             boolean followRedirect, //
             int maxRedirects, //
-            boolean removeQueryParamOnRedirect,//
             boolean strict302Handling, //
-            ExecutorService applicationThreadPool,//
+            ExecutorService executorService,//
             ProxyServerSelector proxyServerSelector, //
-            boolean useRelativeURIsWithConnectProxies, //
             boolean compressionEnforced, //
             String userAgent,//
             Realm realm,//
@@ -143,13 +148,24 @@ private AsyncHttpClientConfig(int connectionTimeout,//
             int maxRequestRetry, //
             boolean disableUrlEncodingForBoundRequests, //
             int ioThreadMultiplier, //
-            TimeConverter timeConverter,//
-            AsyncHttpProviderConfig<?, ?> providerConfig,//
-            boolean spdyEnabled, //
-            int spdyInitialWindowSize, //
-            int spdyMaxConcurrentStreams) {
-
-        this.connectionTimeout = connectionTimeout;
+            String[] enabledProtocols,//
+            String[] enabledCipherSuites,//
+            Integer sslSessionCacheSize,//
+            Integer sslSessionTimeout,//
+            int httpClientCodecMaxInitialLineLength,//
+            int httpClientCodecMaxHeaderSize,//
+            int httpClientCodecMaxChunkSize,//
+            boolean disableZeroCopy,//
+            long handshakeTimeout,//
+            SSLEngineFactory sslEngineFactory,//
+            int chunkedFileChunkSize,//
+            int webSocketMaxBufferSize,//
+            int webSocketMaxFrameSize,//
+            boolean keepEncodingHeader,//
+            AsyncHttpProviderConfig<?, ?> providerConfig) {
+
+        this.name = name;
+        this.connectTimeout = connectTimeout;
         this.maxConnections = maxConnections;
         this.maxConnectionsPerHost = maxConnectionsPerHost;
         this.requestTimeout = requestTimeout;
@@ -160,17 +176,22 @@ private AsyncHttpClientConfig(int connectionTimeout,//
         this.pooledConnectionIdleTimeout = idleConnectionInPoolTimeout;
         this.connectionTTL = maxConnectionLifeTime;
         this.sslContext = sslContext;
-        this.hostnameVerifier = hostnameVerifier;
         this.acceptAnyCertificate = acceptAnyCertificate;
         this.followRedirect = followRedirect;
         this.maxRedirects = maxRedirects;
-        this.removeQueryParamOnRedirect = removeQueryParamOnRedirect;
         this.strict302Handling = strict302Handling;
         this.proxyServerSelector = proxyServerSelector;
-        this.useRelativeURIsWithConnectProxies = useRelativeURIsWithConnectProxies;
         this.compressionEnforced = compressionEnforced;
         this.userAgent = userAgent;
-        this.applicationThreadPool = applicationThreadPool == null ? Executors.newCachedThreadPool() : applicationThreadPool;
+
+        if (executorService != null) {
+            this.executorService = executorService;
+        } else {
+            PrefixIncrementThreadFactory threadFactory = new PrefixIncrementThreadFactory(
+                    getNameOrDefault() + "-");
+            this.executorService = Executors.newCachedThreadPool(threadFactory);
+        }
+
         this.realm = realm;
         this.requestFilters = requestFilters;
         this.responseFilters = responseFilters;
@@ -178,73 +199,123 @@ private AsyncHttpClientConfig(int connectionTimeout,//
         this.maxRequestRetry = maxRequestRetry;
         this.disableUrlEncodingForBoundRequests = disableUrlEncodingForBoundRequests;
         this.ioThreadMultiplier = ioThreadMultiplier;
-        this.timeConverter = timeConverter;
+        this.enabledProtocols = enabledProtocols;
+        this.enabledCipherSuites = enabledCipherSuites;
+        this.sslSessionCacheSize = sslSessionCacheSize;
+        this.sslSessionTimeout = sslSessionTimeout;
         this.providerConfig = providerConfig;
-        this.spdyEnabled = spdyEnabled;
-        this.spdyInitialWindowSize = spdyInitialWindowSize;
-        this.spdyMaxConcurrentStreams = spdyMaxConcurrentStreams;
-        
+        this.httpClientCodecMaxInitialLineLength = httpClientCodecMaxInitialLineLength;
+        this.httpClientCodecMaxHeaderSize = httpClientCodecMaxHeaderSize;
+        this.httpClientCodecMaxChunkSize = httpClientCodecMaxChunkSize;
+        this.disableZeroCopy = disableZeroCopy;
+        this.handshakeTimeout = handshakeTimeout;
+        this.sslEngineFactory = sslEngineFactory;
+        this.chunkedFileChunkSize = chunkedFileChunkSize;
+        this.webSocketMaxBufferSize = webSocketMaxBufferSize;
+        this.webSocketMaxFrameSize = webSocketMaxFrameSize;
+        this.keepEncodingHeader = keepEncodingHeader;
+    }
+
+    /**
+     * Return the name of {@link AsyncHttpClient}, which is used for thread naming
+     * and debugging.
+     *
+     * @return the name.
+     */
+    public String getName() {
+        return name;
     }
 
     /**
-     * Return the maximum number of connections an {@link AsyncHttpClient} can handle.
+     * Return the name of {@link AsyncHttpClient}, or default string if name is null or empty.
      *
-     * @return the maximum number of connections an {@link AsyncHttpClient} can handle.
+     * @return the name.
+     */
+    public String getNameOrDefault() {
+        String r = name;
+        if (r == null || r.isEmpty()) {
+            r = defaultName();
+        }
+        if (r == null || r.isEmpty()) {
+            r = "AsyncHttpClient";
+        }
+        return r;
+    }
+
+    /**
+     * Return the maximum number of connections an {@link AsyncHttpClient} can
+     * handle.
+     *
+     * @return the maximum number of connections an {@link AsyncHttpClient} can
+     *         handle.
      */
     public int getMaxConnections() {
         return maxConnections;
     }
 
     /**
-     * Return the maximum number of connections per hosts an {@link AsyncHttpClient} can handle.
+     * Return the maximum number of connections per hosts an
+     * {@link AsyncHttpClient} can handle.
      *
-     * @return the maximum number of connections per host an {@link AsyncHttpClient} can handle.
+     * @return the maximum number of connections per host an
+     *         {@link AsyncHttpClient} can handle.
      */
     public int getMaxConnectionsPerHost() {
         return maxConnectionsPerHost;
     }
 
     /**
-     * Return the maximum time in millisecond an {@link AsyncHttpClient} can wait when connecting to a remote host
+     * Return the maximum time in millisecond an {@link AsyncHttpClient} can
+     * wait when connecting to a remote host
      *
-     * @return the maximum time in millisecond an {@link AsyncHttpClient} can wait when connecting to a remote host
+     * @return the maximum time in millisecond an {@link AsyncHttpClient} can
+     *         wait when connecting to a remote host
      */
-    public int getConnectionTimeout() {
-        return connectionTimeout;
+    public int getConnectTimeout() {
+        return connectTimeout;
     }
 
     /**
-     * Return the maximum time, in milliseconds, a {@link org.asynchttpclient.websocket.WebSocket} may be idle before being timed out.
-     * @return the maximum time, in milliseconds, a {@link org.asynchttpclient.websocket.WebSocket} may be idle before being timed out.
+     * Return the maximum time, in milliseconds, a
+     * {@link org.asynchttpclient.ws.WebSocket} may be idle before being timed
+     * out.
+     * 
+     * @return the maximum time, in milliseconds, a
+     *         {@link org.asynchttpclient.ws.WebSocket} may be idle before being
+     *         timed out.
      */
     public int getWebSocketTimeout() {
         return webSocketTimeout;
     }
 
     /**
-     * Return the maximum time in millisecond an {@link AsyncHttpClient} can stay idle.
+     * Return the maximum time in millisecond an {@link AsyncHttpClient} can
+     * stay idle.
      *
-     * @return the maximum time in millisecond an {@link AsyncHttpClient} can stay idle.
+     * @return the maximum time in millisecond an {@link AsyncHttpClient} can
+     *         stay idle.
      */
     public int getReadTimeout() {
         return readTimeout;
     }
 
     /**
-     * Return the maximum time in millisecond an {@link AsyncHttpClient} will keep connection
-     * in pool.
+     * Return the maximum time in millisecond an {@link AsyncHttpClient} will
+     * keep connection in pool.
      *
-     * @return the maximum time in millisecond an {@link AsyncHttpClient} will keep connection
-     *         in pool.
+     * @return the maximum time in millisecond an {@link AsyncHttpClient} will
+     *         keep connection in pool.
      */
     public int getPooledConnectionIdleTimeout() {
         return pooledConnectionIdleTimeout;
     }
 
     /**
-     * Return the maximum time in millisecond an {@link AsyncHttpClient} wait for a response
+     * Return the maximum time in millisecond an {@link AsyncHttpClient} waits
+     * until the response is completed.
      *
-     * @return the maximum time in millisecond an {@link AsyncHttpClient} wait for a response
+     * @return the maximum time in millisecond an {@link AsyncHttpClient} waits
+     *         until the response is completed.
      */
     public int getRequestTimeout() {
         return requestTimeout;
@@ -296,15 +367,16 @@ public boolean isCompressionEnforced() {
     }
 
     /**
-     * Return the {@link java.util.concurrent.ExecutorService} an {@link AsyncHttpClient} use for handling
-     * asynchronous response.
+     * Return the {@link java.util.concurrent.ExecutorService} an
+     * {@link AsyncHttpClient} use for handling asynchronous response.
      *
-     * @return the {@link java.util.concurrent.ExecutorService} an {@link AsyncHttpClient} use for handling
-     *         asynchronous response.  If no {@link ExecutorService} has been explicitly provided,
-     *         this method will return <code>null</code>
+     * @return the {@link java.util.concurrent.ExecutorService} an
+     *         {@link AsyncHttpClient} use for handling asynchronous response.
+     *         If no {@link ExecutorService} has been explicitly provided, this
+     *         method will return <code>null</code>
      */
-    public ExecutorService executorService() {
-        return applicationThreadPool;
+    public ExecutorService getExecutorService() {
+        return executorService;
     }
 
     /**
@@ -335,9 +407,9 @@ public SSLContext getSSLContext() {
     }
 
     /**
-     * Return the current {@link Realm}}
+     * Return the current {@link Realm}
      *
-     * @return the current {@link Realm}}
+     * @return the current {@link Realm}
      */
     public Realm getRealm() {
         return realm;
@@ -388,9 +460,11 @@ public boolean hasResponseFilters() {
     }
 
     /**
-     * Return the number of time the library will retry when an {@link java.io.IOException} is throw by the remote server
+     * Return the number of time the library will retry when an
+     * {@link java.io.IOException} is throw by the remote server
      *
-     * @return the number of time the library will retry when an {@link java.io.IOException} is throw by the remote server
+     * @return the number of time the library will retry when an
+     *         {@link java.io.IOException} is throw by the remote server
      */
     public int getMaxRequestRetry() {
         return maxRequestRetry;
@@ -412,45 +486,15 @@ public boolean isDisableUrlEncodingForBoundRequests() {
         return disableUrlEncodingForBoundRequests;
     }
 
-    /**
-     * @return whether or not SPDY is enabled.
-     */
-    public boolean isSpdyEnabled() {
-        return spdyEnabled;
-    }
-
-    /**
-     * @return the windows size new SPDY sessions should be initialized to.
-     */
-    public int getSpdyInitialWindowSize() {
-        return spdyInitialWindowSize;
-    }
-
-    /**
-     * @return the maximum number of concurrent streams over one SPDY session.
-     */
-    public int getSpdyMaxConcurrentStreams() {
-        return spdyMaxConcurrentStreams;
-    }
-
-    /**
-     * Return true if the query parameters will be stripped from the request when a redirect is requested.
-     *
-     * @return true if the query parameters will be stripped from the request when a redirect is requested.
-     */
-    public boolean isRemoveQueryParamOnRedirect() {
-        return removeQueryParamOnRedirect;
-    }
-
     /**
      * @return <code>true</code> if both the application and reaper thread pools
-     * haven't yet been shutdown.
+     *         haven't yet been shutdown.
      * @since 1.7.21
      */
     public boolean isValid() {
         boolean atpRunning = true;
         try {
-            atpRunning = applicationThreadPool.isShutdown();
+            atpRunning = executorService.isShutdown();
         } catch (Exception ignore) {
             // isShutdown() will thrown an exception in an EE7 environment
             // when using a ManagedExecutorService.
@@ -460,16 +504,8 @@ public boolean isValid() {
     }
 
     /**
-     * Return the {@link HostnameVerifier}
-     *
-     * @return the {@link HostnameVerifier}
-     */
-    public HostnameVerifier getHostnameVerifier() {
-        return hostnameVerifier;
-    }
-
-    /**
-     * @return number to multiply by availableProcessors() that will determine # of NioWorkers to use
+     * @return number to multiply by availableProcessors() that will determine #
+     *         of NioWorkers to use
      */
     public int getIoThreadMultiplier() {
         return ioThreadMultiplier;
@@ -479,12 +515,12 @@ public int getIoThreadMultiplier() {
      * <p>
      * In the case of a POST/Redirect/Get scenario where the server uses a 302
      * for the redirect, should AHC respond to the redirect with a GET or
-     * whatever the original method was.  Unless configured otherwise,
-     * for a 302, AHC, will use a GET for this case.
+     * whatever the original method was. Unless configured otherwise, for a 302,
+     * AHC, will use a GET for this case.
      * </p>
      *
-     * @return <code>true</code> if string 302 handling is to be used,
-     *  otherwise <code>false</code>.
+     * @return <code>true</code> if string 302 handling is to be used, otherwise
+     *         <code>false</code>.
      *
      * @since 1.7.2
      */
@@ -493,42 +529,95 @@ public boolean isStrict302Handling() {
     }
 
     /**
-     * @return<code>true</code> if AHC should use relative URIs instead of absolute ones when talking with a SSL proxy
-     * or WebSocket proxy, otherwise <code>false</code>.
-     *  
-     *  @since 1.8.13
+     * Return the maximum time in millisecond an {@link AsyncHttpClient} will
+     * keep connection in the pool, or -1 to keep connection while possible.
+     *
+     * @return the maximum time in millisecond an {@link AsyncHttpClient} will
+     *         keep connection in the pool, or -1 to keep connection while
+     *         possible.
+     */
+    public int getConnectionTTL() {
+        return connectionTTL;
+    }
+
+    public boolean isAcceptAnyCertificate() {
+        return acceptAnyCertificate;
+    }
+
+    /**
+     * since 1.9.0
      */
-    public boolean isUseRelativeURIsWithConnectProxies() {
-        return useRelativeURIsWithConnectProxies;
+    public String[] getEnabledProtocols() {
+        return enabledProtocols;
     }
 
     /**
-     * Return the maximum time in millisecond an {@link AsyncHttpClient} will keep connection in the pool, or -1 to keep connection while possible.
-     *
-     * @return the maximum time in millisecond an {@link AsyncHttpClient} will keep connection in the pool, or -1 to keep connection while possible.
+     * since 1.9.0
      */
-    public int getConnectionTTL() {
-        return connectionTTL;
+    public String[] getEnabledCipherSuites() {
+        return enabledCipherSuites;
     }
 
     /**
-     * @return the TimeConverter used for converting RFC2616Dates into time
-     *
-     * @since 2.0.0
+     * since 1.9.13
      */
-    public TimeConverter getTimeConverter() {
-        return timeConverter;
+    public Integer getSslSessionCacheSize() {
+        return sslSessionCacheSize;
     }
 
-    public boolean isAcceptAnyCertificate() {
-        return acceptAnyCertificate;
+    /**
+     * since 1.9.13
+     */
+    public Integer getSslSessionTimeout() {
+        return sslSessionTimeout;
+    }
+
+    public int getHttpClientCodecMaxInitialLineLength() {
+        return httpClientCodecMaxInitialLineLength;
+    }
+
+    public int getHttpClientCodecMaxHeaderSize() {
+        return httpClientCodecMaxHeaderSize;
+    }
+
+    public int getHttpClientCodecMaxChunkSize() {
+        return httpClientCodecMaxChunkSize;
+    }
+
+    public boolean isDisableZeroCopy() {
+        return disableZeroCopy;
+    }
+
+    public long getHandshakeTimeout() {
+        return handshakeTimeout;
+    }
+
+    public SSLEngineFactory getSslEngineFactory() {
+        return sslEngineFactory;
+    }
+
+    public int getChunkedFileChunkSize() {
+        return chunkedFileChunkSize;
+    }
+
+    public int getWebSocketMaxBufferSize() {
+        return webSocketMaxBufferSize;
+    }
+
+    public int getWebSocketMaxFrameSize() {
+        return webSocketMaxFrameSize;
+    }
+
+    public boolean isKeepEncodingHeader() {
+        return keepEncodingHeader;
     }
 
     /**
      * Builder for an {@link AsyncHttpClient}
      */
     public static class Builder {
-        private int connectionTimeout = defaultConnectionTimeout();
+        private String name = defaultName();
+        private int connectTimeout = defaultConnectTimeout();
         private int maxConnections = defaultMaxConnections();
         private int maxConnectionsPerHost = defaultMaxConnectionsPerHost();
         private int requestTimeout = defaultRequestTimeout();
@@ -539,41 +628,58 @@ public boolean isAcceptAnyCertificate() {
         private int pooledConnectionIdleTimeout = defaultPooledConnectionIdleTimeout();
         private int connectionTTL = defaultConnectionTTL();
         private SSLContext sslContext;
-        private HostnameVerifier hostnameVerifier;
         private boolean acceptAnyCertificate = defaultAcceptAnyCertificate();
         private boolean followRedirect = defaultFollowRedirect();
         private int maxRedirects = defaultMaxRedirects();
-        private boolean removeQueryParamOnRedirect = defaultRemoveQueryParamOnRedirect();
         private boolean strict302Handling = defaultStrict302Handling();
         private ProxyServerSelector proxyServerSelector = null;
         private boolean useProxySelector = defaultUseProxySelector();
         private boolean useProxyProperties = defaultUseProxyProperties();
-        private boolean useRelativeURIsWithConnectProxies = defaultUseRelativeURIsWithConnectProxies();
         private boolean compressionEnforced = defaultCompressionEnforced();
         private String userAgent = defaultUserAgent();
         private ExecutorService applicationThreadPool;
         private Realm realm;
-        private final List<RequestFilter> requestFilters = new LinkedList<RequestFilter>();
-        private final List<ResponseFilter> responseFilters = new LinkedList<ResponseFilter>();
-        private final List<IOExceptionFilter> ioExceptionFilters = new LinkedList<IOExceptionFilter>();
+        private final List<RequestFilter> requestFilters = new LinkedList<>();
+        private final List<ResponseFilter> responseFilters = new LinkedList<>();
+        private final List<IOExceptionFilter> ioExceptionFilters = new LinkedList<>();
         private int maxRequestRetry = defaultMaxRequestRetry();
         private boolean disableUrlEncodingForBoundRequests = defaultDisableUrlEncodingForBoundRequests();
         private int ioThreadMultiplier = defaultIoThreadMultiplier();
-        private TimeConverter timeConverter;
+        private String[] enabledProtocols = defaultEnabledProtocols();
+        private String[] enabledCipherSuites;
+        private Integer sslSessionCacheSize = defaultSslSessionCacheSize();
+        private Integer sslSessionTimeout = defaultSslSessionTimeout();
+        private int httpClientCodecMaxInitialLineLength = defaultHttpClientCodecMaxInitialLineLength();
+        private int httpClientCodecMaxHeaderSize = defaultHttpClientCodecMaxHeaderSize();
+        private int httpClientCodecMaxChunkSize = defaultHttpClientCodecMaxChunkSize();
+        private boolean disableZeroCopy = defaultDisableZeroCopy();
+        private long handshakeTimeout = defaultHandshakeTimeout();
+        private SSLEngineFactory sslEngineFactory;
+        private int chunkedFileChunkSize = defaultChunkedFileChunkSize();
+        private int webSocketMaxBufferSize = defaultWebSocketMaxBufferSize();
+        private int webSocketMaxFrameSize = defaultWebSocketMaxFrameSize();
+        private boolean keepEncodingHeader = defaultKeepEncodingHeader();
         private AsyncHttpProviderConfig<?, ?> providerConfig;
-        
-        // AHC 2
-        private boolean spdyEnabled = defaultSpdyEnabled();
-        private int spdyInitialWindowSize = defaultSpdyInitialWindowSize();
-        private int spdyMaxConcurrentStreams = defaultSpdyMaxConcurrentStreams();
-        
+
         public Builder() {
         }
 
         /**
-         * Set the maximum number of connections an {@link AsyncHttpClient} can handle.
+         * Set the name of {@link AsyncHttpClient}. That name is used for thread
+         * naming and can be used for debugging multiple {@link AsyncHttpClient}
+         * instance.
+         */
+        public Builder setName(String name) {
+            this.name = name;
+            return this;
+        }
+
+        /**
+         * Set the maximum number of connections an {@link AsyncHttpClient} can
+         * handle.
          *
-         * @param maxConnections the maximum number of connections an {@link AsyncHttpClient} can handle.
+         * @param maxConnections the maximum number of connections an
+         *            {@link AsyncHttpClient} can handle.
          * @return a {@link Builder}
          */
         public Builder setMaxConnections(int maxConnections) {
@@ -582,9 +688,12 @@ public Builder setMaxConnections(int maxConnections) {
         }
 
         /**
-         * Set the maximum number of connections per hosts an {@link AsyncHttpClient} can handle.
+         * Set the maximum number of connections per (scheme, host, port) an
+         * {@link AsyncHttpClient} can handle.
          *
-         * @param maxConnectionsPerHost the maximum number of connections per host an {@link AsyncHttpClient} can handle.
+         * @param maxConnectionsPerHost the maximum number of connections per
+         *            (scheme, host, port) an {@link AsyncHttpClient} can
+         *            handle.
          * @return a {@link Builder}
          */
         public Builder setMaxConnectionsPerHost(int maxConnectionsPerHost) {
@@ -593,21 +702,25 @@ public Builder setMaxConnectionsPerHost(int maxConnectionsPerHost) {
         }
 
         /**
-         * Set the maximum time in millisecond an {@link AsyncHttpClient} can wait when connecting to a remote host
+         * Set the maximum time in millisecond an {@link AsyncHttpClient} can
+         * wait when connecting to a remote host
          *
-         * @param connectionTimeout the maximum time in millisecond an {@link AsyncHttpClient} can wait when connecting to a remote host
+         * @param connectTimeout the maximum time in millisecond an
+         *            {@link AsyncHttpClient} can wait when connecting to a
+         *            remote host
          * @return a {@link Builder}
          */
-        public Builder setConnectionTimeout(int connectionTimeout) {
-            this.connectionTimeout = connectionTimeout;
+        public Builder setConnectTimeout(int connectTimeout) {
+            this.connectTimeout = connectTimeout;
             return this;
         }
 
         /**
-         * Set the maximum time in millisecond an {@link org.asynchttpclient.websocket.WebSocket} can stay idle.
+         * Set the maximum time in millisecond an
+         * {@link org.asynchttpclient.ws.WebSocket} can stay idle.
          *
-         * @param webSocketTimeout
-         *         the maximum time in millisecond an {@link org.asynchttpclient.websocket.WebSocket} can stay idle.
+         * @param webSocketTimeout the maximum time in millisecond an
+         *            {@link org.asynchttpclient.ws.WebSocket} can stay idle.
          * @return a {@link Builder}
          */
         public Builder setWebSocketTimeout(int webSocketTimeout) {
@@ -616,10 +729,11 @@ public Builder setWebSocketTimeout(int webSocketTimeout) {
         }
 
         /**
-         * Set the maximum time in millisecond an {@link AsyncHttpClient} can stay idle.
+         * Set the maximum time in millisecond an {@link AsyncHttpClient} can
+         * stay idle.
          *
-         * @param readTimeout
-         *         the maximum time in millisecond an {@link AsyncHttpClient} can stay idle.
+         * @param readTimeout the maximum time in millisecond an
+         *            {@link AsyncHttpClient} can stay idle.
          * @return a {@link Builder}
          */
         public Builder setReadTimeout(int readTimeout) {
@@ -628,12 +742,11 @@ public Builder setReadTimeout(int readTimeout) {
         }
 
         /**
-         * Set the maximum time in millisecond an {@link AsyncHttpClient} will keep connection
-         * idle in pool.
+         * Set the maximum time in millisecond an {@link AsyncHttpClient} will
+         * keep connection idle in pool.
          *
-         * @param pooledConnectionIdleTimeout
-         *         the maximum time in millisecond an {@link AsyncHttpClient} will keep connection
-         *         idle in pool.
+         * @param pooledConnectionIdleTimeout the maximum time in millisecond an
+         *            {@link AsyncHttpClient} will keep connection idle in pool.
          * @return a {@link Builder}
          */
         public Builder setPooledConnectionIdleTimeout(int pooledConnectionIdleTimeout) {
@@ -642,9 +755,12 @@ public Builder setPooledConnectionIdleTimeout(int pooledConnectionIdleTimeout) {
         }
 
         /**
-         * Set the maximum time in millisecond an {@link AsyncHttpClient} wait for a response
+         * Set the maximum time in millisecond an {@link AsyncHttpClient} waits
+         * until the response is completed.
          *
-         * @param requestTimeout the maximum time in millisecond an {@link AsyncHttpClient} wait for a response
+         * @param requestTimeout the maximum time in millisecond an
+         *            {@link AsyncHttpClient} waits until the response is
+         *            completed.
          * @return a {@link Builder}
          */
         public Builder setRequestTimeout(int requestTimeout) {
@@ -697,9 +813,11 @@ public Builder setUserAgent(String userAgent) {
         }
 
         /**
-         * Set true if connection can be pooled by a {@link ConnectionsPool}. Default is true.
+         * Set true if connection can be pooled by a {@link ConnectionsPool}.
+         * Default is true.
          *
-         * @param allowPoolingConnections true if connection can be pooled by a {@link ConnectionsPool}
+         * @param allowPoolingConnections true if connection can be pooled by a
+         *            {@link ConnectionsPool}
          * @return a {@link Builder}
          */
         public Builder setAllowPoolingConnections(boolean allowPoolingConnections) {
@@ -708,11 +826,13 @@ public Builder setAllowPoolingConnections(boolean allowPoolingConnections) {
         }
 
         /**
-         * Set the {@link java.util.concurrent.ExecutorService} an {@link AsyncHttpClient} use for handling
-         * asynchronous response.
+         * Set the {@link java.util.concurrent.ExecutorService} an
+         * {@link AsyncHttpClient} use for handling asynchronous response.
          *
-         * @param applicationThreadPool the {@link java.util.concurrent.ExecutorService} an {@link AsyncHttpClient} use for handling
-         *                              asynchronous response.
+         * @param applicationThreadPool the
+         *            {@link java.util.concurrent.ExecutorService} an
+         *            {@link AsyncHttpClient} use for handling asynchronous
+         *            response.
          * @return a {@link Builder}
          */
         public Builder setExecutorService(ExecutorService applicationThreadPool) {
@@ -721,7 +841,8 @@ public Builder setExecutorService(ExecutorService applicationThreadPool) {
         }
 
         /**
-         * Set an instance of {@link ProxyServerSelector} used by an {@link AsyncHttpClient}
+         * Set an instance of {@link ProxyServerSelector} used by an
+         * {@link AsyncHttpClient}
          *
          * @param proxyServerSelector instance of {@link ProxyServerSelector}
          * @return a {@link Builder}
@@ -732,7 +853,8 @@ public Builder setProxyServerSelector(ProxyServerSelector proxyServerSelector) {
         }
 
         /**
-         * Set an instance of {@link ProxyServer} used by an {@link AsyncHttpClient}
+         * Set an instance of {@link ProxyServer} used by an
+         * {@link AsyncHttpClient}
          *
          * @param proxyServer instance of {@link ProxyServer}
          * @return a {@link Builder}
@@ -765,7 +887,7 @@ public Builder setAsyncHttpClientProviderConfig(AsyncHttpProviderConfig<?, ?> pr
         }
 
         /**
-         * Set the {@link Realm}  that will be used for all requests.
+         * Set the {@link Realm} that will be used for all requests.
          *
          * @param realm the {@link Realm}
          * @return a {@link Builder}
@@ -776,7 +898,8 @@ public Builder setRealm(Realm realm) {
         }
 
         /**
-         * Add an {@link org.asynchttpclient.filter.RequestFilter} that will be invoked before {@link AsyncHttpClient#executeRequest(Request)}
+         * Add an {@link org.asynchttpclient.filter.RequestFilter} that will be
+         * invoked before {@link AsyncHttpClient#executeRequest(Request)}
          *
          * @param requestFilter {@link org.asynchttpclient.filter.RequestFilter}
          * @return this
@@ -787,7 +910,8 @@ public Builder addRequestFilter(RequestFilter requestFilter) {
         }
 
         /**
-         * Remove an {@link org.asynchttpclient.filter.RequestFilter} that will be invoked before {@link AsyncHttpClient#executeRequest(Request)}
+         * Remove an {@link org.asynchttpclient.filter.RequestFilter} that will
+         * be invoked before {@link AsyncHttpClient#executeRequest(Request)}
          *
          * @param requestFilter {@link org.asynchttpclient.filter.RequestFilter}
          * @return this
@@ -798,10 +922,12 @@ public Builder removeRequestFilter(RequestFilter requestFilter) {
         }
 
         /**
-         * Add an {@link org.asynchttpclient.filter.ResponseFilter} that will be invoked as soon as the response is
-         * received, and before {@link AsyncHandler#onStatusReceived(HttpResponseStatus)}.
+         * Add an {@link org.asynchttpclient.filter.ResponseFilter} that will be
+         * invoked as soon as the response is received, and before
+         * {@link AsyncHandler#onStatusReceived(HttpResponseStatus)}.
          *
-         * @param responseFilter an {@link org.asynchttpclient.filter.ResponseFilter}
+         * @param responseFilter an
+         *            {@link org.asynchttpclient.filter.ResponseFilter}
          * @return this
          */
         public Builder addResponseFilter(ResponseFilter responseFilter) {
@@ -810,10 +936,12 @@ public Builder addResponseFilter(ResponseFilter responseFilter) {
         }
 
         /**
-         * Remove an {@link org.asynchttpclient.filter.ResponseFilter} that will be invoked as soon as the response is
-         * received, and before {@link AsyncHandler#onStatusReceived(HttpResponseStatus)}.
+         * Remove an {@link org.asynchttpclient.filter.ResponseFilter} that will
+         * be invoked as soon as the response is received, and before
+         * {@link AsyncHandler#onStatusReceived(HttpResponseStatus)}.
          *
-         * @param responseFilter an {@link org.asynchttpclient.filter.ResponseFilter}
+         * @param responseFilter an
+         *            {@link org.asynchttpclient.filter.ResponseFilter}
          * @return this
          */
         public Builder removeResponseFilter(ResponseFilter responseFilter) {
@@ -822,10 +950,12 @@ public Builder removeResponseFilter(ResponseFilter responseFilter) {
         }
 
         /**
-         * Add an {@link org.asynchttpclient.filter.IOExceptionFilter} that will be invoked when an {@link java.io.IOException}
-         * occurs during the download/upload operations.
+         * Add an {@link org.asynchttpclient.filter.IOExceptionFilter} that will
+         * be invoked when an {@link java.io.IOException} occurs during the
+         * download/upload operations.
          *
-         * @param ioExceptionFilter an {@link org.asynchttpclient.filter.ResponseFilter}
+         * @param ioExceptionFilter an
+         *            {@link org.asynchttpclient.filter.ResponseFilter}
          * @return this
          */
         public Builder addIOExceptionFilter(IOExceptionFilter ioExceptionFilter) {
@@ -834,10 +964,12 @@ public Builder addIOExceptionFilter(IOExceptionFilter ioExceptionFilter) {
         }
 
         /**
-         * Remove an {@link org.asynchttpclient.filter.IOExceptionFilter} tthat will be invoked when an {@link java.io.IOException}
-         * occurs during the download/upload operations.
+         * Remove an {@link org.asynchttpclient.filter.IOExceptionFilter} tthat
+         * will be invoked when an {@link java.io.IOException} occurs during the
+         * download/upload operations.
          *
-         * @param ioExceptionFilter an {@link org.asynchttpclient.filter.ResponseFilter}
+         * @param ioExceptionFilter an
+         *            {@link org.asynchttpclient.filter.ResponseFilter}
          * @return this
          */
         public Builder removeIOExceptionFilter(IOExceptionFilter ioExceptionFilter) {
@@ -846,7 +978,8 @@ public Builder removeIOExceptionFilter(IOExceptionFilter ioExceptionFilter) {
         }
 
         /**
-         * Set the number of times a request will be retried when an {@link java.io.IOException} occurs because of a Network exception.
+         * Set the number of times a request will be retried when an
+         * {@link java.io.IOException} occurs because of a Network exception.
          *
          * @param maxRequestRetry the number of times a request will be retried
          * @return this
@@ -868,8 +1001,8 @@ public Builder setAllowPoolingSslConnections(boolean allowPoolingSslConnections)
         }
 
         /**
-         * Allows use unescaped URLs in requests
-         * useful for retrieving data from broken sites
+         * Allows use unescaped URLs in requests useful for retrieving data from
+         * broken sites
          *
          * @param disableUrlEncodingForBoundRequests
          * @return this
@@ -880,23 +1013,15 @@ public Builder setDisableUrlEncodingForBoundRequests(boolean disableUrlEncodingF
         }
 
         /**
-         * Set to false if you don't want the query parameters removed when a redirect occurs.
-         *
-         * @param removeQueryParamOnRedirect
-         * @return this
-         */
-        public Builder setRemoveQueryParamsOnRedirect(boolean removeQueryParamOnRedirect) {
-            this.removeQueryParamOnRedirect = removeQueryParamOnRedirect;
-            return this;
-        }
-
-        /**
-         * Sets whether AHC should use the default JDK ProxySelector to select a proxy server.
+         * Sets whether AHC should use the default JDK ProxySelector to select a
+         * proxy server.
          * <p/>
-         * If useProxySelector is set to <code>true</code> but {@link #setProxyServer(ProxyServer)}
-         * was used to explicitly set a proxy server, the latter is preferred.
+         * If useProxySelector is set to <code>true</code> but
+         * {@link #setProxyServer(ProxyServer)} was used to explicitly set a
+         * proxy server, the latter is preferred.
          * <p/>
-         * See http://docs.oracle.com/javase/7/docs/api/java/net/ProxySelector.html
+         * See http://docs.oracle.com/javase/7/docs/api/java/net/ProxySelector.
+         * html
          */
         public Builder setUseProxySelector(boolean useProxySelector) {
             this.useProxySelector = useProxySelector;
@@ -905,14 +1030,18 @@ public Builder setUseProxySelector(boolean useProxySelector) {
 
         /**
          * Sets whether AHC should use the default http.proxy* system properties
-         * to obtain proxy information.  This differs from {@link #setUseProxySelector(boolean)}
-         * in that AsyncHttpClient will use its own logic to handle the system properties,
-         * potentially supporting other protocols that the the JDK ProxySelector doesn't.
+         * to obtain proxy information. This differs from
+         * {@link #setUseProxySelector(boolean)} in that AsyncHttpClient will
+         * use its own logic to handle the system properties, potentially
+         * supporting other protocols that the the JDK ProxySelector doesn't.
          * <p/>
-         * If useProxyProperties is set to <code>true</code> but {@link #setUseProxySelector(boolean)}
-         * was also set to true, the latter is preferred.
+         * If useProxyProperties is set to <code>true</code> but
+         * {@link #setUseProxySelector(boolean)} was also set to true, the
+         * latter is preferred.
          * <p/>
-         * See http://download.oracle.com/javase/1.4.2/docs/guide/net/properties.html
+         * See
+         * http://download.oracle.com/javase/1.4.2/docs/guide/net/properties.
+         * html
          */
         public Builder setUseProxyProperties(boolean useProxyProperties) {
             this.useProxyProperties = useProxyProperties;
@@ -925,19 +1054,8 @@ public Builder setIOThreadMultiplier(int multiplier) {
         }
 
         /**
-         * Set the {@link HostnameVerifier}
-         *
-         * @param hostnameVerifier {@link HostnameVerifier}
-         * @return this
-         */
-        public Builder setHostnameVerifier(HostnameVerifier hostnameVerifier) {
-            this.hostnameVerifier = hostnameVerifier;
-            return this;
-        }
-
-        /**
-         * Configures this AHC instance to be strict in it's handling of 302 redirects
-         * in a POST/Redirect/GET situation.
+         * Configures this AHC instance to be strict in it's handling of 302
+         * redirects in a POST/Redirect/GET situation.
          *
          * @param strict302Handling strict handling
          *
@@ -951,9 +1069,11 @@ public Builder setStrict302Handling(final boolean strict302Handling) {
         }
 
         /**
-         * Set the maximum time in millisecond connection can be added to the pool for further reuse
+         * Set the maximum time in millisecond connection can be added to the
+         * pool for further reuse
          *
-         * @param connectionTTL the maximum time in millisecond connection can be added to the pool for further reuse
+         * @param connectionTTL the maximum time in millisecond connection can
+         *            be added to the pool for further reuse
          * @return a {@link Builder}
          */
         public Builder setConnectionTTL(int connectionTTL) {
@@ -961,83 +1081,91 @@ public Builder setConnectionTTL(int connectionTTL) {
             return this;
         }
 
-        /**
-         * Configures this AHC instance to use relative URIs instead of absolute ones when talking with a SSL or WebSocket proxy.
-         *
-         * @param useRelativeURIsWithConnectProxies
-         * @return this
-         *
-         * @since 1.7.2
-         */
-        public Builder setUseRelativeURIsWithConnectProxies(boolean useRelativeURIsWithConnectProxies) {
-            this.useRelativeURIsWithConnectProxies = useRelativeURIsWithConnectProxies;
+        public Builder setAcceptAnyCertificate(boolean acceptAnyCertificate) {
+            this.acceptAnyCertificate = acceptAnyCertificate;
             return this;
         }
 
-        /**
-         * Enables SPDY support.  Note that doing so, will currently disable WebSocket support
-         * for this client instance.  If not explicitly enabled, spdy will not be used.
-         *
-         * @param spdyEnabled configures spdy support.
-         *
-         * @return this
-         *
-         * @since 2.0
-         */
-        public Builder setSpdyEnabled(boolean spdyEnabled) {
-            this.spdyEnabled = spdyEnabled;
+        public Builder setEnabledProtocols(String[] enabledProtocols) {
+            this.enabledProtocols = enabledProtocols;
             return this;
         }
 
-        /**
-         * Configures the initial window size for the SPDY session.
-         *
-         * @param spdyInitialWindowSize the initial window size.
-         *
-         * @return this
-         *
-         * @since 2.0
-         */
-        public Builder setSpdyInitialWindowSize(int spdyInitialWindowSize) {
-            this.spdyInitialWindowSize = spdyInitialWindowSize;
+        public Builder setEnabledCipherSuites(String[] enabledCipherSuites) {
+            this.enabledCipherSuites = enabledCipherSuites;
             return this;
         }
 
-        /**
-         * Configures the maximum number of concurrent streams over a single
-         * SPDY session.
-         *
-         * @param spdyMaxConcurrentStreams the maximum number of concurrent
-         *                                 streams over a single SPDY session.
-         *
-         * @return this
-         *
-         * @since 2.0
-         */
-        public Builder setSpdyMaxConcurrentStreams(int spdyMaxConcurrentStreams) {
-            this.spdyMaxConcurrentStreams = spdyMaxConcurrentStreams;
+        public Builder setSslSessionCacheSize(Integer sslSessionCacheSize) {
+            this.sslSessionCacheSize = sslSessionCacheSize;
             return this;
         }
 
-        public Builder setTimeConverter(TimeConverter timeConverter) {
-            this.timeConverter = timeConverter;
+        public Builder setSslSessionTimeout(Integer sslSessionTimeout) {
+            this.sslSessionTimeout = sslSessionTimeout;
             return this;
         }
 
-        public Builder setAcceptAnyCertificate(boolean acceptAnyCertificate) {
-            this.acceptAnyCertificate = acceptAnyCertificate;
+        public Builder setHttpClientCodecMaxInitialLineLength(int httpClientCodecMaxInitialLineLength) {
+            this.httpClientCodecMaxInitialLineLength = httpClientCodecMaxInitialLineLength;
+            return this;
+        }
+
+        public Builder setHttpClientCodecMaxHeaderSize(int httpClientCodecMaxHeaderSize) {
+            this.httpClientCodecMaxHeaderSize = httpClientCodecMaxHeaderSize;
             return this;
         }
-        
+
+        public Builder setHttpClientCodecMaxChunkSize(int httpClientCodecMaxChunkSize) {
+            this.httpClientCodecMaxChunkSize = httpClientCodecMaxChunkSize;
+            return this;
+        }
+
+        public Builder setDisableZeroCopy(boolean disableZeroCopy) {
+            this.disableZeroCopy = disableZeroCopy;
+            return this;
+        }
+
+        public Builder setHandshakeTimeout(long handshakeTimeout) {
+            this.handshakeTimeout = handshakeTimeout;
+            return this;
+        }
+
+        public Builder setSslEngineFactory(SSLEngineFactory sslEngineFactory) {
+            this.sslEngineFactory = sslEngineFactory;
+            return this;
+        }
+
+        public Builder setChunkedFileChunkSize(int chunkedFileChunkSize) {
+            this.chunkedFileChunkSize = chunkedFileChunkSize;
+            return this;
+        }
+
+        public Builder setWebSocketMaxBufferSize(int webSocketMaxBufferSize) {
+            this.webSocketMaxBufferSize = webSocketMaxBufferSize;
+            return this;
+        }
+
+        public Builder setWebSocketMaxFrameSize(int webSocketMaxFrameSize) {
+            this.webSocketMaxFrameSize = webSocketMaxFrameSize;
+            return this;
+        }
+
+        public Builder setKeepEncodingHeader(boolean keepEncodingHeader) {
+            this.keepEncodingHeader = keepEncodingHeader;
+            return this;
+        }
+
         /**
-         * Create a config builder with values taken from the given prototype configuration.
+         * Create a config builder with values taken from the given prototype
+         * configuration.
          *
          * @param prototype the configuration to use as a prototype.
          */
         public Builder(AsyncHttpClientConfig prototype) {
+            name = prototype.getName();
             allowPoolingConnections = prototype.isAllowPoolingConnections();
-            providerConfig = prototype.getAsyncHttpProviderConfig();
-            connectionTimeout = prototype.getConnectionTimeout();
+            connectTimeout = prototype.getConnectTimeout();
             pooledConnectionIdleTimeout = prototype.getPooledConnectionIdleTimeout();
             readTimeout = prototype.getReadTimeout();
             maxConnectionsPerHost = prototype.getMaxConnectionsPerHost();
@@ -1051,7 +1179,7 @@ public Builder(AsyncHttpClientConfig prototype) {
             userAgent = prototype.getUserAgent();
             followRedirect = prototype.isFollowRedirect();
             compressionEnforced = prototype.isCompressionEnforced();
-            applicationThreadPool = prototype.executorService();
+            applicationThreadPool = prototype.getExecutorService();
 
             requestFilters.clear();
             responseFilters.clear();
@@ -1065,15 +1193,24 @@ public Builder(AsyncHttpClientConfig prototype) {
             ioThreadMultiplier = prototype.getIoThreadMultiplier();
             maxRequestRetry = prototype.getMaxRequestRetry();
             allowPoolingSslConnections = prototype.isAllowPoolingConnections();
-            removeQueryParamOnRedirect = prototype.isRemoveQueryParamOnRedirect();
-            hostnameVerifier = prototype.getHostnameVerifier();
             strict302Handling = prototype.isStrict302Handling();
-            timeConverter = prototype.timeConverter;
             acceptAnyCertificate = prototype.acceptAnyCertificate;
-            
-            spdyEnabled = prototype.isSpdyEnabled();
-            spdyInitialWindowSize = prototype.getSpdyInitialWindowSize();
-            spdyMaxConcurrentStreams = prototype.getSpdyMaxConcurrentStreams();
+            enabledProtocols = prototype.enabledProtocols;
+            enabledCipherSuites = prototype.enabledCipherSuites;
+            sslSessionCacheSize = prototype.sslSessionCacheSize;
+            sslSessionTimeout = prototype.sslSessionTimeout;
+            httpClientCodecMaxInitialLineLength = prototype.httpClientCodecMaxInitialLineLength;
+            httpClientCodecMaxHeaderSize = prototype.httpClientCodecMaxHeaderSize;
+            httpClientCodecMaxChunkSize = prototype.httpClientCodecMaxChunkSize;
+            disableZeroCopy = prototype.disableZeroCopy;
+            handshakeTimeout = prototype.handshakeTimeout;
+            sslEngineFactory = prototype.sslEngineFactory;
+            chunkedFileChunkSize = prototype.chunkedFileChunkSize;
+            webSocketMaxBufferSize = prototype.webSocketMaxBufferSize;
+            webSocketMaxFrameSize = prototype.webSocketMaxFrameSize;
+            keepEncodingHeader = prototype.keepEncodingHeader;
+
+            providerConfig = prototype.getAsyncHttpProviderConfig();
         }
 
         /**
@@ -1092,12 +1229,8 @@ public AsyncHttpClientConfig build() {
             if (proxyServerSelector == null)
                 proxyServerSelector = ProxyServerSelector.NO_PROXY_SELECTOR;
 
-            if (acceptAnyCertificate)
-                hostnameVerifier = null;
-            else if (hostnameVerifier == null)
-                hostnameVerifier = new DefaultHostnameVerifier();
-
-            return new AsyncHttpClientConfig(connectionTimeout,//
+            return new AsyncHttpClientConfig(name,//
+                    connectTimeout,//
                     maxConnections,//
                     maxConnectionsPerHost,//
                     requestTimeout,//
@@ -1108,15 +1241,12 @@ else if (hostnameVerifier == null)
                     pooledConnectionIdleTimeout,//
                     connectionTTL,//
                     sslContext, //
-                    hostnameVerifier,//
                     acceptAnyCertificate, //
                     followRedirect, //
                     maxRedirects, //
-                    removeQueryParamOnRedirect,//
                     strict302Handling, //
                     applicationThreadPool, //
                     proxyServerSelector, //
-                    useRelativeURIsWithConnectProxies, //
                     compressionEnforced, //
                     userAgent,//
                     realm,//
@@ -1126,11 +1256,21 @@ else if (hostnameVerifier == null)
                     maxRequestRetry, //
                     disableUrlEncodingForBoundRequests, //
                     ioThreadMultiplier, //
-                    timeConverter,//
-                    providerConfig, //
-                    spdyEnabled, //
-                    spdyInitialWindowSize, //
-                    spdyMaxConcurrentStreams);
+                    enabledProtocols, //
+                    enabledCipherSuites, //
+                    sslSessionCacheSize, //
+                    sslSessionTimeout, //
+                    httpClientCodecMaxInitialLineLength, //
+                    httpClientCodecMaxHeaderSize, //
+                    httpClientCodecMaxChunkSize, //
+                    disableZeroCopy, //
+                    handshakeTimeout, //
+                    sslEngineFactory, //
+                    chunkedFileChunkSize, //
+                    webSocketMaxBufferSize, //
+                    webSocketMaxFrameSize, //
+                    keepEncodingHeader, //
+                    providerConfig);
         }
     }
 }
diff --git a/api/src/main/java/org/asynchttpclient/AsyncHttpClientConfigDefaults.java b/api/src/main/java/org/asynchttpclient/AsyncHttpClientConfigDefaults.java
deleted file mode 100644
index 17b58c6c7..000000000
--- a/api/src/main/java/org/asynchttpclient/AsyncHttpClientConfigDefaults.java
+++ /dev/null
@@ -1,130 +0,0 @@
-/*
- * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient;
-
-import org.asynchttpclient.util.AsyncPropertiesHelper;
-import org.asynchttpclient.util.DefaultHostnameVerifier;
-
-import javax.net.ssl.HostnameVerifier;
-
-public final class AsyncHttpClientConfigDefaults {
-
-    private AsyncHttpClientConfigDefaults() {
-    }
-
-    public static final String ASYNC_CLIENT = AsyncHttpClientConfig.class.getName() + ".";
-
-    public static int defaultMaxConnections() {
-        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT + "maxConnections");
-    }
-
-    public static int defaultMaxConnectionsPerHost() {
-        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT + "maxConnectionsPerHost");
-    }
-
-    public static int defaultConnectionTimeout() {
-        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT + "connectionTimeout");
-    }
-
-    public static int defaultPooledConnectionIdleTimeout() {
-        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT + "pooledConnectionIdleTimeout");
-    }
-
-    public static int defaultReadTimeout() {
-        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT + "readTimeout");
-    }
-
-    public static int defaultRequestTimeout() {
-        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT + "requestTimeout");
-    }
-
-    public static int defaultWebSocketTimeout() {
-        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT + "webSocketTimeout");
-    }
-
-    public static int defaultConnectionTTL() {
-        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT + "connectionTTL");
-    }
-
-    public static boolean defaultFollowRedirect() {
-        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT + "followRedirect");
-    }
-
-    public static int defaultMaxRedirects() {
-        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT + "maxRedirects");
-    }
-
-    public static boolean defaultCompressionEnforced() {
-        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT + "compressionEnforced");
-    }
-
-    public static String defaultUserAgent() {
-        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getString(ASYNC_CLIENT + "userAgent");
-    }
-
-    public static int defaultIoThreadMultiplier() {
-        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT + "ioThreadMultiplier");
-    }
-
-    public static boolean defaultUseProxySelector() {
-        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT + "useProxySelector");
-    }
-
-    public static boolean defaultUseProxyProperties() {
-        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT + "useProxyProperties");
-    }
-
-    public static boolean defaultStrict302Handling() {
-        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT + "strict302Handling");
-    }
-
-    public static boolean defaultAllowPoolingConnections() {
-        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT + "allowPoolingConnections");
-    }
-
-    public static boolean defaultUseRelativeURIsWithConnectProxies() {
-        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT + "useRelativeURIsWithConnectProxies");
-    } 
-
-    public static int defaultMaxRequestRetry() {
-        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT + "maxRequestRetry");
-    }
-
-    public static boolean defaultAllowPoolingSslConnections() {
-        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT + "allowPoolingSslConnections");
-    }
-
-    public static boolean defaultDisableUrlEncodingForBoundRequests() {
-        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT + "disableUrlEncodingForBoundRequests");
-    }
-
-    public static boolean defaultRemoveQueryParamOnRedirect() {
-        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT + "removeQueryParamOnRedirect");
-    }
-
-    public static boolean defaultSpdyEnabled() {
-        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT + "spdyEnabled");
-    }
-
-    public static int defaultSpdyInitialWindowSize() {
-        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT + "spdyInitialWindowSize");
-    }
-
-    public static int defaultSpdyMaxConcurrentStreams() {
-        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT + "spdyMaxConcurrentStreams");
-    }
-    
-    public static boolean defaultAcceptAnyCertificate() {
-        return AsyncPropertiesHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT + "acceptAnyCertificate");
-    }
-}
diff --git a/api/src/main/java/org/asynchttpclient/AsyncHttpProvider.java b/api/src/main/java/org/asynchttpclient/AsyncHttpProvider.java
index 848249a6d..0bb74e800 100644
--- a/api/src/main/java/org/asynchttpclient/AsyncHttpProvider.java
+++ b/api/src/main/java/org/asynchttpclient/AsyncHttpProvider.java
@@ -16,7 +16,6 @@
 package org.asynchttpclient;
 
 import java.io.Closeable;
-import java.io.IOException;
 
 /**
  * Interface to be used when implementing custom asynchronous I/O HTTP client.
@@ -28,9 +27,8 @@
      *
      * @param handler an instance of {@link AsyncHandler}
      * @return a {@link ListenableFuture} of Type T.
-     * @throws IOException
      */
-    <T> ListenableFuture<T> execute(Request request, AsyncHandler<T> handler) throws IOException;
+    <T> ListenableFuture<T> execute(Request request, AsyncHandler<T> handler);
 
     /**
      * Close the current underlying TCP/HTTP connection.
diff --git a/api/src/main/java/org/asynchttpclient/BoundRequestBuilder.java b/api/src/main/java/org/asynchttpclient/BoundRequestBuilder.java
index 638450a20..be23756d1 100644
--- a/api/src/main/java/org/asynchttpclient/BoundRequestBuilder.java
+++ b/api/src/main/java/org/asynchttpclient/BoundRequestBuilder.java
@@ -12,14 +12,6 @@
  */
 package org.asynchttpclient;
 
-import org.asynchttpclient.cookie.Cookie;
-import org.asynchttpclient.multipart.Part;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.Collection;
-import java.util.List;
-import java.util.Map;
 
 public class BoundRequestBuilder extends RequestBuilderBase<BoundRequestBuilder> {
 
@@ -35,100 +27,11 @@ public BoundRequestBuilder(AsyncHttpClient client, Request prototype) {
         this.client = client;
     }
 
-    public <T> ListenableFuture<T> execute(AsyncHandler<T> handler) throws IOException {
+    public <T> ListenableFuture<T> execute(AsyncHandler<T> handler) {
         return client.executeRequest(build(), handler);
     }
 
-    public ListenableFuture<Response> execute() throws IOException {
+    public ListenableFuture<Response> execute() {
         return client.executeRequest(build(), new AsyncCompletionHandlerBase());
     }
-
-    // Note: For now we keep the delegates in place even though they are not
-    // needed
-    // since otherwise Clojure (and maybe other languages) won't be able to
-    // access these methods - see Clojure tickets 126 and 259
-
-    @Override
-    public BoundRequestBuilder addBodyPart(Part part) {
-        return super.addBodyPart(part);
-    }
-
-    @Override
-    public BoundRequestBuilder addCookie(Cookie cookie) {
-        return super.addCookie(cookie);
-    }
-
-    @Override
-    public BoundRequestBuilder addHeader(String name, String value) {
-        return super.addHeader(name, value);
-    }
-
-    @Override
-    public BoundRequestBuilder addFormParam(String key, String value) {
-        return super.addFormParam(key, value);
-    }
-
-    @Override
-    public BoundRequestBuilder addQueryParam(String name, String value) {
-        return super.addQueryParam(name, value);
-    }
-
-    @Override
-    public Request build() {
-        return super.build();
-    }
-
-    @Override
-    public BoundRequestBuilder setBody(byte[] data) {
-        return super.setBody(data);
-    }
-
-    @Override
-    public BoundRequestBuilder setBody(InputStream stream) {
-        return super.setBody(stream);
-    }
-
-    @Override
-    public BoundRequestBuilder setBody(String data) {
-        return super.setBody(data);
-    }
-
-    @Override
-    public BoundRequestBuilder setHeader(String name, String value) {
-        return super.setHeader(name, value);
-    }
-
-    @Override
-    public BoundRequestBuilder setHeaders(FluentCaseInsensitiveStringsMap headers) {
-        return super.setHeaders(headers);
-    }
-
-    @Override
-    public BoundRequestBuilder setHeaders(Map<String, Collection<String>> headers) {
-        return super.setHeaders(headers);
-    }
-
-    @Override
-    public BoundRequestBuilder setFormParams(Map<String, List<String>> params) {
-        return super.setFormParams(params);
-    }
-
-    @Override
-    public BoundRequestBuilder setFormParams(List<Param> params) {
-        return super.setFormParams(params);
-    }
-
-    @Override
-    public BoundRequestBuilder setUrl(String url) {
-        return super.setUrl(url);
-    }
-
-    @Override
-    public BoundRequestBuilder setVirtualHost(String virtualHost) {
-        return super.setVirtualHost(virtualHost);
-    }
-
-    public BoundRequestBuilder setSignatureCalculator(SignatureCalculator signatureCalculator) {
-        return super.setSignatureCalculator(signatureCalculator);
-    }
 }
diff --git a/api/src/main/java/org/asynchttpclient/ConnectionPoolPartitioning.java b/api/src/main/java/org/asynchttpclient/ConnectionPoolPartitioning.java
deleted file mode 100644
index 3d546e192..000000000
--- a/api/src/main/java/org/asynchttpclient/ConnectionPoolPartitioning.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package org.asynchttpclient;
-
-import org.asynchttpclient.uri.Uri;
-
-public interface ConnectionPoolPartitioning {
-
-    String getPartitionId(Uri uri, ProxyServer proxy);
-}
diff --git a/api/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java b/api/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java
index 63536a37c..92b65b0bc 100644
--- a/api/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java
+++ b/api/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java
@@ -16,30 +16,20 @@
  */
 package org.asynchttpclient;
 
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.atomic.AtomicBoolean;
+
 import org.asynchttpclient.filter.FilterContext;
 import org.asynchttpclient.filter.FilterException;
 import org.asynchttpclient.filter.RequestFilter;
-import org.asynchttpclient.resumable.ResumableAsyncHandler;
+import org.asynchttpclient.handler.resumable.ResumableAsyncHandler;
+import org.asynchttpclient.netty.NettyAsyncHttpProvider;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.io.IOException;
-import java.lang.reflect.InvocationTargetException;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.atomic.AtomicBoolean;
-
 public class DefaultAsyncHttpClient implements AsyncHttpClient {
 
-    /**
-     * Providers that will be searched for, on the classpath, in order when no
-     * provider is explicitly specified by the developer.
-     */
-    private static final String[] DEFAULT_PROVIDERS = {//
-    "org.asynchttpclient.providers.netty.NettyAsyncHttpProvider",/**/
-    "org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider"//
-    };
-
     private final AsyncHttpProvider httpProvider;
     private final AsyncHttpClientConfig config;
     private final static Logger logger = LoggerFactory.getLogger(DefaultAsyncHttpClient.class);
@@ -56,12 +46,6 @@
      * Create a new HTTP Asynchronous Client using the default {@link AsyncHttpClientConfig} configuration. The
      * default {@link AsyncHttpProvider} that will be used will be based on the classpath configuration.
      *
-     * The default providers will be searched for in this order:
-     * <ul>
-     *     <li>netty</li>
-     *     <li>grizzly</li>
-     * </ul>
-     *
      * If none of those providers are found, then the engine will throw an IllegalStateException.
      */
     public DefaultAsyncHttpClient() {
@@ -83,29 +67,10 @@ public DefaultAsyncHttpClient(AsyncHttpProvider provider) {
      * This configuration will be passed to the default {@link AsyncHttpProvider} that will be selected based on
      * the classpath configuration.
      *
-     * The default providers will be searched for in this order:
-     * <ul>
-     *     <li>netty</li>
-     *     <li>grizzly</li>
-     * </ul>
-     *
-     * If none of those providers are found, then the engine will throw an IllegalStateException.
-     *
      * @param config a {@link AsyncHttpClientConfig}
      */
     public DefaultAsyncHttpClient(AsyncHttpClientConfig config) {
-        this(loadDefaultProvider(DEFAULT_PROVIDERS, config), config);
-    }
-
-    /**
-     * Create a new HTTP Asynchronous Client using a {@link AsyncHttpClientConfig} configuration and
-     * and a AsyncHttpProvider class' name.
-     *
-     * @param config        a {@link AsyncHttpClientConfig}
-     * @param providerClass a {@link AsyncHttpProvider}
-     */
-    public DefaultAsyncHttpClient(String providerClass, AsyncHttpClientConfig config) {
-        this(loadProvider(providerClass, config), config);
+        this(new NettyAsyncHttpProvider(config), config);
     }
 
     /**
@@ -225,20 +190,27 @@ public BoundRequestBuilder prepareRequest(Request request) {
     }
 
     @Override
-    public <T> ListenableFuture<T> executeRequest(Request request, AsyncHandler<T> handler) throws IOException {
+    public <T> ListenableFuture<T> executeRequest(Request request, AsyncHandler<T> handler) {
 
-        FilterContext<T> fc = new FilterContext.FilterContextBuilder<T>().asyncHandler(handler).request(request).build();
-        fc = preProcessRequest(fc);
+        if (config.getRequestFilters().isEmpty()) {
+            return httpProvider.execute(request, handler);
 
-        return httpProvider.execute(fc.getRequest(), fc.getAsyncHandler());
+        } else {
+            FilterContext<T> fc = new FilterContext.FilterContextBuilder<T>().asyncHandler(handler).request(request).build();
+            try {
+                fc = preProcessRequest(fc);
+            } catch (Exception e) {
+                handler.onThrowable(e);
+                return new ListenableFuture.CompletedFailure<>("preProcessRequest failed", e);
+            }
+
+            return httpProvider.execute(fc.getRequest(), fc.getAsyncHandler());
+        }
     }
 
     @Override
-    public ListenableFuture<Response> executeRequest(Request request) throws IOException {
-        FilterContext<Response> fc = new FilterContext.FilterContextBuilder<Response>().asyncHandler(new AsyncCompletionHandlerBase())
-                .request(request).build();
-        fc = preProcessRequest(fc);
-        return httpProvider.execute(fc.getRequest(), fc.getAsyncHandler());
+    public ListenableFuture<Response> executeRequest(Request request) {
+        return executeRequest(request, new AsyncCompletionHandlerBase());
     }
 
     /**
@@ -247,17 +219,11 @@ public BoundRequestBuilder prepareRequest(Request request) {
      * @param fc {@link FilterContext}
      * @return {@link FilterContext}
      */
-    private <T> FilterContext<T> preProcessRequest(FilterContext<T> fc) throws IOException {
+    private <T> FilterContext<T> preProcessRequest(FilterContext<T> fc) throws FilterException {
         for (RequestFilter asyncFilter : config.getRequestFilters()) {
-            try {
-                fc = asyncFilter.filter(fc);
-                if (fc == null) {
-                    throw new NullPointerException("FilterContext is null");
-                }
-            } catch (FilterException e) {
-                IOException ex = new IOException();
-                ex.initCause(e);
-                throw ex;
+            fc = asyncFilter.filter(fc);
+            if (fc == null) {
+                throw new NullPointerException("FilterContext is null");
             }
         }
 
@@ -271,46 +237,10 @@ public BoundRequestBuilder prepareRequest(Request request) {
             builder.setHeader("Range", "bytes=" + request.getRangeOffset() + "-");
             request = builder.build();
         }
-        fc = new FilterContext.FilterContextBuilder<T>(fc).request(request).build();
+        fc = new FilterContext.FilterContextBuilder<>(fc).request(request).build();
         return fc;
     }
 
-    @SuppressWarnings("unchecked")
-    private static AsyncHttpProvider loadProvider(final String className, final AsyncHttpClientConfig config) {
-        try {
-            Class<AsyncHttpProvider> providerClass = (Class<AsyncHttpProvider>) Thread.currentThread().getContextClassLoader()
-                    .loadClass(className);
-            return providerClass.getDeclaredConstructor(new Class[] { AsyncHttpClientConfig.class }).newInstance(config);
-        } catch (Throwable t) {
-            if (t instanceof InvocationTargetException) {
-                final InvocationTargetException ite = (InvocationTargetException) t;
-                if (logger.isErrorEnabled()) {
-                    logger.error("Unable to instantiate provider {}.  Trying other providers.", className);
-                    logger.error(ite.getCause().toString(), ite.getCause());
-                }
-            }
-            // Let's try with another classloader
-            try {
-                Class<AsyncHttpProvider> providerClass = (Class<AsyncHttpProvider>) DefaultAsyncHttpClient.class.getClassLoader().loadClass(
-                        className);
-                return providerClass.getDeclaredConstructor(new Class[] { AsyncHttpClientConfig.class }).newInstance(config);
-            } catch (Throwable ignored) {
-            }
-        }
-        return null;
-    }
-
-    private static AsyncHttpProvider loadDefaultProvider(String[] providerClassNames, AsyncHttpClientConfig config) {
-        AsyncHttpProvider provider;
-        for (final String className : providerClassNames) {
-            provider = loadProvider(className, config);
-            if (provider != null) {
-                return provider;
-            }
-        }
-        throw new IllegalStateException("No providers found on the classpath");
-    }
-
     protected BoundRequestBuilder requestBuilder(String method, String url) {
         return new BoundRequestBuilder(this, method, config.isDisableUrlEncodingForBoundRequests()).setUrl(url).setSignatureCalculator(signatureCalculator);
     }
diff --git a/api/src/main/java/org/asynchttpclient/FluentCaseInsensitiveStringsMap.java b/api/src/main/java/org/asynchttpclient/FluentCaseInsensitiveStringsMap.java
index 10805d580..62d760a5d 100644
--- a/api/src/main/java/org/asynchttpclient/FluentCaseInsensitiveStringsMap.java
+++ b/api/src/main/java/org/asynchttpclient/FluentCaseInsensitiveStringsMap.java
@@ -38,8 +38,8 @@
  * original case in the appropriate methods (e.g. {@link FluentCaseInsensitiveStringsMap#keySet()}).
  */
 public class FluentCaseInsensitiveStringsMap implements Map<String, List<String>>, Iterable<Map.Entry<String, List<String>>> {
-    private final Map<String, List<String>> values = new LinkedHashMap<String, List<String>>();
-    private final Map<String, String> keyLookup = new LinkedHashMap<String, String>();
+    private final Map<String, List<String>> values = new LinkedHashMap<>();
+    private final Map<String, String> keyLookup = new LinkedHashMap<>();
 
     public FluentCaseInsensitiveStringsMap() {
     }
@@ -68,7 +68,7 @@ public FluentCaseInsensitiveStringsMap add(String key, String value) {
             List<String> curValues = null;
             if (realKey == null) {
                 keyLookup.put(lcKey, key);
-                curValues = new ArrayList<String>();
+                curValues = new ArrayList<>();
                 values.put(key, curValues);
             } else {
                 curValues = values.get(realKey);
@@ -104,7 +104,7 @@ public FluentCaseInsensitiveStringsMap add(String key, String... values) {
                 }
                 if (result == null) {
                     // lazy initialization
-                    result = new ArrayList<String>();
+                    result = new ArrayList<>();
                 }
                 result.add(value);
             }
@@ -137,7 +137,7 @@ public FluentCaseInsensitiveStringsMap add(String key, Collection<String> values
                 }
 
                 if (curValues == null) {
-                    curValues = new ArrayList<String>();
+                    curValues = new ArrayList<>();
                     this.values.put(realKey, curValues);
                 }
                 curValues.addAll(nonNullValues);
@@ -356,7 +356,7 @@ public void clear() {
      */
     @Override
     public Set<String> keySet() {
-        return new LinkedHashSet<String>(keyLookup.values());
+        return new LinkedHashSet<>(keyLookup.values());
     }
 
     /**
@@ -409,10 +409,8 @@ public boolean containsValue(Object value) {
     public String getFirstValue(String key) {
         List<String> values = get(key);
 
-        if (values == null) {
+        if (values.isEmpty()) {
             return null;
-        } else if (values.isEmpty()) {
-            return "";
         } else {
             return values.get(0);
         }
@@ -427,7 +425,7 @@ public String getFirstValue(String key) {
     public String getJoinedValue(String key, String delimiter) {
         List<String> values = get(key);
 
-        if (values == null) {
+        if (values.isEmpty()) {
             return null;
         } else if (values.size() == 1) {
             return values.get(0);
@@ -449,18 +447,13 @@ public String getJoinedValue(String key, String delimiter) {
      */
     @Override
     public List<String> get(Object key) {
-        if (key == null) {
-            return null;
-        }
+        if (key == null)
+            return Collections.emptyList();
 
         String lcKey = key.toString().toLowerCase(Locale.ENGLISH);
         String realKey = keyLookup.get(lcKey);
 
-        if (realKey == null) {
-            return null;
-        } else {
-            return values.get(realKey);
-        }
+        return realKey != null ? values.get(realKey) : Collections.<String> emptyList();
     }
 
     /**
diff --git a/api/src/main/java/org/asynchttpclient/FluentStringsMap.java b/api/src/main/java/org/asynchttpclient/FluentStringsMap.java
index 5dd3dd200..1c672e636 100644
--- a/api/src/main/java/org/asynchttpclient/FluentStringsMap.java
+++ b/api/src/main/java/org/asynchttpclient/FluentStringsMap.java
@@ -33,7 +33,7 @@
  * return this instance.
  */
 public class FluentStringsMap implements Map<String, List<String>>, Iterable<Map.Entry<String, List<String>>> {
-    private final Map<String, List<String>> values = new LinkedHashMap<String, List<String>>();
+    private final Map<String, List<String>> values = new LinkedHashMap<>();
 
     public FluentStringsMap() {
     }
@@ -59,7 +59,7 @@ public FluentStringsMap add(String key, String value) {
             List<String> curValues = values.get(key);
 
             if (curValues == null) {
-                curValues = new ArrayList<String>(1);
+                curValues = new ArrayList<>(1);
                 values.put(key, curValues);
             }
             curValues.add(value);
@@ -93,7 +93,7 @@ public FluentStringsMap add(String key, Collection<String> values) {
             List<String> curValues = this.values.get(key);
 
             if (curValues == null) {
-                this.values.put(key, new ArrayList<String>(values));
+                this.values.put(key, new ArrayList<>(values));
             } else {
                 curValues.addAll(values);
             }
@@ -154,7 +154,7 @@ public FluentStringsMap replaceWith(final String key, final Collection<String> v
             if (values == null) {
                 this.values.remove(key);
             } else {
-                this.values.put(key, new ArrayList<String>(values));
+                this.values.put(key, new ArrayList<>(values));
             }
         }
         return this;
@@ -404,7 +404,7 @@ public String getJoinedValue(String key, String delimiter) {
         if (values.isEmpty())
             return Collections.emptyList();
         else {
-            List<Param> params = new ArrayList<Param>(values.size());
+            List<Param> params = new ArrayList<>(values.size());
             for (Map.Entry<String, List<String>> entry : values.entrySet()) {
                 String name = entry.getKey();
                 for (String value: entry.getValue())
diff --git a/api/src/main/java/org/asynchttpclient/HttpResponseHeaders.java b/api/src/main/java/org/asynchttpclient/HttpResponseHeaders.java
index b573fd876..5ecc6898c 100644
--- a/api/src/main/java/org/asynchttpclient/HttpResponseHeaders.java
+++ b/api/src/main/java/org/asynchttpclient/HttpResponseHeaders.java
@@ -15,6 +15,7 @@
  */
 package org.asynchttpclient;
 
+
 /**
  * A class that represent the HTTP headers.
  */
diff --git a/api/src/main/java/org/asynchttpclient/HttpResponseStatus.java b/api/src/main/java/org/asynchttpclient/HttpResponseStatus.java
index c8388ab63..2d35bdc57 100644
--- a/api/src/main/java/org/asynchttpclient/HttpResponseStatus.java
+++ b/api/src/main/java/org/asynchttpclient/HttpResponseStatus.java
@@ -16,6 +16,7 @@
  */
 package org.asynchttpclient;
 
+import java.net.SocketAddress;
 import java.util.List;
 
 import org.asynchttpclient.uri.Uri;
@@ -44,8 +45,8 @@ public final Uri getUri() {
 
     /**
      * Prepare a {@link Response}
-     *
-     * @param headers   {@link HttpResponseHeaders}
+     * 
+     * @param headers {@link HttpResponseHeaders}
      * @param bodyParts list of {@link HttpResponseBodyPart}
      * @param config the client config
      * @return a {@link Response}
@@ -93,4 +94,20 @@ public final Uri getUri() {
      * @return protocol name + version
      */
     public abstract String getProtocolText();
+
+    /**
+     * Get remote address client initiated request to.
+     * 
+     * @return remote address client initiated request to, may be {@code null}
+     *         if asynchronous provider is unable to provide the remote address
+     */
+    public abstract SocketAddress getRemoteAddress();
+
+    /**
+     * Get local address client initiated request from.
+     * 
+     * @return local address client initiated request from, may be {@code null}
+     *         if asynchronous provider is unable to provide the local address
+     */
+    public abstract SocketAddress getLocalAddress();
 }
diff --git a/api/src/main/java/org/asynchttpclient/ListenableFuture.java b/api/src/main/java/org/asynchttpclient/ListenableFuture.java
index 8d2ca73dc..6b14f209a 100755
--- a/api/src/main/java/org/asynchttpclient/ListenableFuture.java
+++ b/api/src/main/java/org/asynchttpclient/ListenableFuture.java
@@ -30,8 +30,11 @@
  */
 package org.asynchttpclient;
 
+import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executor;
 import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
 
 /**
  * Extended {@link Future}
@@ -79,4 +82,60 @@
      *                              immediately but the executor rejected it.
      */
     ListenableFuture<V> addListener(Runnable listener, Executor exec);
+
+    class CompletedFailure<T> implements ListenableFuture<T>{
+
+        private final ExecutionException e;
+
+        public CompletedFailure(Throwable t) {
+            e = new ExecutionException(t);
+        }
+
+        public CompletedFailure(String message, Throwable t) {
+            e = new ExecutionException(message, t);
+        }
+
+        @Override
+        public boolean cancel(boolean mayInterruptIfRunning) {
+            return true;
+        }
+
+        @Override
+        public boolean isCancelled() {
+            return false;
+        }
+
+        @Override
+        public boolean isDone() {
+            return true;
+        }
+
+        @Override
+        public T get() throws InterruptedException, ExecutionException {
+            throw e;
+        }
+
+        @Override
+        public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
+            throw e;
+        }
+
+        @Override
+        public void done() {
+        }
+
+        @Override
+        public void abort(Throwable t) {
+        }
+
+        @Override
+        public void touch() {
+        }
+
+        @Override
+        public ListenableFuture<T> addListener(Runnable listener, Executor exec) {
+            exec.execute(listener);
+            return this;
+        }
+    }
 }
diff --git a/api/src/main/java/org/asynchttpclient/PerHostConnectionPoolPartitioning.java b/api/src/main/java/org/asynchttpclient/PerHostConnectionPoolPartitioning.java
deleted file mode 100644
index 0139a99fe..000000000
--- a/api/src/main/java/org/asynchttpclient/PerHostConnectionPoolPartitioning.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package org.asynchttpclient;
-
-import org.asynchttpclient.uri.Uri;
-import org.asynchttpclient.util.AsyncHttpProviderUtils;
-
-public enum PerHostConnectionPoolPartitioning implements ConnectionPoolPartitioning {
-
-    INSTANCE;
-
-    @Override
-    public String getPartitionId(Uri uri, ProxyServer proxyServer) {
-        String serverPart = AsyncHttpProviderUtils.getBaseUrl(uri);
-        return proxyServer != null ? proxyServer.getUrl() + serverPart : serverPart;
-    }
-}
diff --git a/api/src/main/java/org/asynchttpclient/Realm.java b/api/src/main/java/org/asynchttpclient/Realm.java
index 7906277b5..9123693b9 100644
--- a/api/src/main/java/org/asynchttpclient/Realm.java
+++ b/api/src/main/java/org/asynchttpclient/Realm.java
@@ -16,21 +16,26 @@
  */
 package org.asynchttpclient;
 
+import static java.nio.charset.StandardCharsets.ISO_8859_1;
+import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 
-import org.asynchttpclient.uri.Uri;
-import org.asynchttpclient.util.StandardCharsets;
-
 import java.nio.charset.Charset;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
+import java.util.concurrent.ThreadLocalRandom;
+
+import org.asynchttpclient.uri.Uri;
+import org.asynchttpclient.util.AuthenticatorUtils;
+import org.asynchttpclient.util.StringUtils;
 
 /**
  * This class is required when authentication is needed. The class support DIGEST and BASIC.
  */
 public class Realm {
 
-    private static final String NC = "00000001";
+    private static final String DEFAULT_NC = "00000001";
+    private static final String EMPTY_ENTITY_MD5 = "d41d8cd98f00b204e9800998ecf8427e";
 
     private final String principal;
     private final String password;
@@ -46,11 +51,9 @@
     private final Uri uri;
     private final String methodName;
     private final boolean usePreemptiveAuth;
-    private final String enc;
-    private final String host;
-    private final boolean messageType2Received;
-    private final String ntlmDomain;
     private final Charset charset;
+    private final String ntlmHost;
+    private final String ntlmDomain;
     private final boolean useAbsoluteURI;
     private final boolean omitQuery;
     private final boolean targetProxy;
@@ -60,8 +63,8 @@
     }
 
     private Realm(AuthScheme scheme, String principal, String password, String realmName, String nonce, String algorithm, String response,
-            String qop, String nc, String cnonce, Uri uri, String method, boolean usePreemptiveAuth, String ntlmDomain, String enc,
-            String host, boolean messageType2Received, String opaque, boolean useAbsoluteURI, boolean omitQuery, boolean targetProxy) {
+            String qop, String nc, String cnonce, Uri uri, String method, boolean usePreemptiveAuth, String ntlmDomain, Charset charset,
+            String host, String opaque, boolean useAbsoluteURI, boolean omitQuery, boolean targetProxy) {
 
         this.principal = principal;
         this.password = password;
@@ -78,10 +81,8 @@ private Realm(AuthScheme scheme, String principal, String password, String realm
         this.methodName = method;
         this.usePreemptiveAuth = usePreemptiveAuth;
         this.ntlmDomain = ntlmDomain;
-        this.enc = enc;
-        this.host = host;
-        this.messageType2Received = messageType2Received;
-        this.charset = enc != null ? Charset.forName(enc) : null;
+        this.ntlmHost = host;
+        this.charset = charset;
         this.useAbsoluteURI = useAbsoluteURI;
         this.omitQuery = omitQuery;
         this.targetProxy = targetProxy;
@@ -95,10 +96,6 @@ public String getPassword() {
         return password;
     }
 
-    public AuthScheme getAuthScheme() {
-        return scheme;
-    }
-
     public AuthScheme getScheme() {
 
         return scheme;
@@ -140,10 +137,6 @@ public Uri getUri() {
         return uri;
     }
 
-    public String getEncoding() {
-        return enc;
-    }
-
     public Charset getCharset() {
         return charset;
     }
@@ -176,11 +169,7 @@ public String getNtlmDomain() {
      * @return the NTLM host
      */
     public String getNtlmHost() {
-        return host;
-    }
-
-    public boolean isNtlmMessageType2Received() {
-        return messageType2Received;
+        return ntlmHost;
     }
 
     public boolean isUseAbsoluteURI() {
@@ -264,28 +253,38 @@ public int hashCode() {
         // This code is already Apache licenced.
         //
 
-        private String principal = "";
-        private String password = "";
+        private String principal;
+        private String password;
         private AuthScheme scheme = AuthScheme.NONE;
-        private String realmName = "";
-        private String nonce = "";
-        private String algorithm = "MD5";
-        private String response = "";
-        private String opaque = "";
-        private String qop = "auth";
-        private String nc = "00000001";
-        private String cnonce = "";
+        private String realmName;
+        private String nonce;
+        private String algorithm;
+        private String response;
+        private String opaque;
+        private String qop;
+        private String nc = DEFAULT_NC;
+        private String cnonce;
         private Uri uri;
         private String methodName = "GET";
         private boolean usePreemptive;
         private String ntlmDomain = System.getProperty("http.auth.ntlm.domain", "");
-        private String enc = StandardCharsets.UTF_8.name();
-        private String host = "localhost";
-        private boolean messageType2Received;
-        private boolean useAbsoluteURI = true;
+        private Charset charset = UTF_8;
+        private String ntlmHost = "localhost";
+        private boolean useAbsoluteURI = false;
         private boolean omitQuery;
         private boolean targetProxy;
 
+        private static final ThreadLocal<MessageDigest> digestThreadLocal = new ThreadLocal<MessageDigest>() {
+            @Override
+            protected MessageDigest initialValue() {
+                try {
+                    return MessageDigest.getInstance("MD5");
+                } catch (NoSuchAlgorithmException e) {
+                    throw new RuntimeException(e);
+                }
+            }
+        };
+
         public String getNtlmDomain() {
             return ntlmDomain;
         }
@@ -296,11 +295,11 @@ public RealmBuilder setNtlmDomain(String ntlmDomain) {
         }
 
         public String getNtlmHost() {
-            return host;
+            return ntlmHost;
         }
 
         public RealmBuilder setNtlmHost(String host) {
-            this.host = host;
+            this.ntlmHost = host;
             return this;
         }
 
@@ -381,7 +380,9 @@ public String getQop() {
         }
 
         public RealmBuilder setQop(String qop) {
-            this.qop = qop;
+            if (isNonEmpty(qop)) {
+                this.qop = qop;
+            }
             return this;
         }
 
@@ -421,11 +422,6 @@ public RealmBuilder setUsePreemptiveAuth(boolean usePreemptiveAuth) {
             return this;
         }
 
-        public RealmBuilder setNtlmMessageType2Received(boolean messageType2Received) {
-            this.messageType2Received = messageType2Received;
-            return this;
-        }
-
         public boolean isUseAbsoluteURI() {
             return useAbsoluteURI;
         }
@@ -452,6 +448,26 @@ public RealmBuilder setTargetProxy(boolean targetProxy) {
             this.targetProxy = targetProxy;
             return this;
         }
+        private String parseRawQop(String rawQop) {
+            String[] rawServerSupportedQops = rawQop.split(",");
+            String[] serverSupportedQops = new String[rawServerSupportedQops.length];
+            for (int i = 0; i < rawServerSupportedQops.length; i++) {
+                serverSupportedQops[i] = rawServerSupportedQops[i].trim();
+            }
+            
+            // prefer auth over auth-int
+            for (String rawServerSupportedQop: serverSupportedQops) {
+                if (rawServerSupportedQop.equals("auth"))
+                    return rawServerSupportedQop;
+            }
+            
+            for (String rawServerSupportedQop: serverSupportedQops) {
+                if (rawServerSupportedQop.equals("auth-int"))
+                    return rawServerSupportedQop;
+            }
+            
+            return null;
+        }
 
         public RealmBuilder parseWWWAuthenticateHeader(String headerLine) {
             setRealmName(match(headerLine, "realm"));
@@ -461,7 +477,12 @@ public RealmBuilder parseWWWAuthenticateHeader(String headerLine) {
                 setAlgorithm(algorithm);
             }
             setOpaque(match(headerLine, "opaque"));
-            setQop(match(headerLine, "qop"));
+
+            String rawQop = match(headerLine, "qop");
+            if (rawQop != null) {
+                setQop(parseRawQop(rawQop));
+            }
+
             if (isNonEmpty(getNonce())) {
                 setScheme(AuthScheme.DIGEST);
             } else {
@@ -474,6 +495,10 @@ public RealmBuilder parseProxyAuthenticateHeader(String headerLine) {
             setRealmName(match(headerLine, "realm"));
             setNonce(match(headerLine, "nonce"));
             setOpaque(match(headerLine, "opaque"));
+            String algorithm = match(headerLine, "algorithm");
+            if (isNonEmpty(algorithm)) {
+                setAlgorithm(algorithm);
+            }
             setQop(match(headerLine, "qop"));
             if (isNonEmpty(getNonce())) {
                 setScheme(AuthScheme.DIGEST);
@@ -485,36 +510,31 @@ public RealmBuilder parseProxyAuthenticateHeader(String headerLine) {
         }
 
         public RealmBuilder clone(Realm clone) {
-            setRealmName(clone.getRealmName());
-            setAlgorithm(clone.getAlgorithm());
-            setMethodName(clone.getMethodName());
-            setNc(clone.getNc());
-            setNonce(clone.getNonce());
-            setPassword(clone.getPassword());
-            setPrincipal(clone.getPrincipal());
-            setEncoding(clone.getEncoding());
-            setOpaque(clone.getOpaque());
-            setQop(clone.getQop());
-            setScheme(clone.getScheme());
-            setUri(clone.getUri());
-            setUsePreemptiveAuth(clone.getUsePreemptiveAuth());
-            setNtlmDomain(clone.getNtlmDomain());
-            setNtlmHost(clone.getNtlmHost());
-            setNtlmMessageType2Received(clone.isNtlmMessageType2Received());
-            setUseAbsoluteURI(clone.isUseAbsoluteURI());
-            setOmitQuery(clone.isOmitQuery());
-            setTargetProxy(clone.isTargetProxy());
-            return this;
-        }
-
-        private void newCnonce() {
-            try {
-                MessageDigest md = MessageDigest.getInstance("MD5");
-                byte[] b = md.digest(String.valueOf(System.currentTimeMillis()).getBytes(StandardCharsets.ISO_8859_1));
-                cnonce = toHexString(b);
-            } catch (Exception e) {
-                throw new SecurityException(e);
-            }
+            return setRealmName(clone.getRealmName())//
+                    .setAlgorithm(clone.getAlgorithm())//
+                    .setMethodName(clone.getMethodName())//
+                    .setNc(clone.getNc())//
+                    .setNonce(clone.getNonce())//
+                    .setPassword(clone.getPassword())//
+                    .setPrincipal(clone.getPrincipal())//
+                    .setCharset(clone.getCharset())//
+                    .setOpaque(clone.getOpaque())//
+                    .setQop(clone.getQop())//
+                    .setScheme(clone.getScheme())//
+                    .setUri(clone.getUri())//
+                    .setUsePreemptiveAuth(clone.getUsePreemptiveAuth())//
+                    .setNtlmDomain(clone.getNtlmDomain())//
+                    .setNtlmHost(clone.getNtlmHost())//
+                    .setUseAbsoluteURI(clone.isUseAbsoluteURI())//
+                    .setOmitQuery(clone.isOmitQuery())//
+                    .setTargetProxy(clone.isTargetProxy());
+        }
+
+        private void newCnonce(MessageDigest md) {
+            byte[] b = new byte[8];
+            ThreadLocalRandom.current().nextBytes(b);
+            b = md.digest(b);
+            cnonce = toHexString(b);
         }
 
         /**
@@ -522,12 +542,12 @@ private void newCnonce() {
          */
         private String match(String headerLine, String token) {
             if (headerLine == null) {
-                return "";
+                return null;
             }
 
             int match = headerLine.indexOf(token);
             if (match <= 0)
-                return "";
+                return null;
 
             // = to skip
             match += token.length() + 1;
@@ -537,60 +557,77 @@ private String match(String headerLine, String token) {
             return value.charAt(0) == '"' ? value.substring(1) : value;
         }
 
-        public String getEncoding() {
-            return enc;
+        public Charset getCharset() {
+            return charset;
         }
 
-        public RealmBuilder setEncoding(String enc) {
-            this.enc = enc;
+        public RealmBuilder setCharset(Charset charset) {
+            this.charset = charset;
             return this;
         }
 
-        private void newResponse() {
-            MessageDigest md = null;
-            try {
-                md = MessageDigest.getInstance("MD5");
-            } catch (NoSuchAlgorithmException e) {
-                throw new SecurityException(e);
+        private byte[] md5FromRecycledStringBuilder(StringBuilder sb, MessageDigest md) {
+            md.update(StringUtils.charSequence2ByteBuffer(sb, ISO_8859_1));
+            sb.setLength(0);
+            return md.digest();
+        }
+        
+        private byte[] secretDigest(StringBuilder sb, MessageDigest md) {
+            
+            sb.append(principal).append(':').append(realmName).append(':').append(password);
+            byte[] ha1 = md5FromRecycledStringBuilder(sb, md);
+
+            if (algorithm == null || algorithm.equals("MD5")) {
+                return ha1;
+            } else if ("MD5-sess".equals(algorithm)) {
+                appendBase16(sb, ha1);
+                sb.append(':').append(nonce).append(':').append(cnonce);
+                return md5FromRecycledStringBuilder(sb, md);
             }
-            md.update(new StringBuilder(principal).append(":")//
-                    .append(realmName).append(":")//
-                    .append(password).toString()//
-                    .getBytes(StandardCharsets.ISO_8859_1));
-            byte[] ha1 = md.digest();
-
-            md.reset();
-
-            // HA2 if qop is auth-int is methodName:url:md5(entityBody)
-            md.update(new StringBuilder(methodName).append(':')//
-                    .append(uri).toString()//
-                    .getBytes(StandardCharsets.ISO_8859_1));
-            byte[] ha2 = md.digest();
-
-            if (qop == null || qop.length() == 0) {
-                md.update(new StringBuilder(toBase16(ha1)).append(':')//
-                        .append(nonce).append(':')//
-                        .append(toBase16(ha2)).toString()//
-                        .getBytes(StandardCharsets.ISO_8859_1));
 
-            } else {
-                // qop ="auth" or "auth-int"
-                md.update(new StringBuilder(toBase16(ha1)).append(':')//
-                        .append(nonce).append(':')//
-                        .append(NC).append(':')//
-                        .append(cnonce).append(':')//
-                        .append(qop).append(':')//
-                        .append(toBase16(ha2)).toString()//
-                        .getBytes(StandardCharsets.ISO_8859_1));
-            }
+            throw new UnsupportedOperationException("Digest algorithm not supported: " + algorithm);
+        }
 
-            byte[] digest = md.digest();
+        private byte[] dataDigest(StringBuilder sb, String digestUri, MessageDigest md) {
+            
+            sb.append(methodName).append(':').append(digestUri);
+            if ("auth-int".equals(qop)) {
+                sb.append(':').append(EMPTY_ENTITY_MD5);
 
-            response = toHexString(digest);
+            } else if (qop != null && !qop.equals("auth")) {
+                throw new UnsupportedOperationException("Digest qop not supported: " + qop);
+            }
+            
+            return md5FromRecycledStringBuilder(sb, md);
+        }
+        
+        private void appendDataBase(StringBuilder sb) {
+            sb.append(':').append(nonce).append(':');
+            if ("auth".equals(qop) || "auth-int".equals(qop)) {
+                sb.append(nc).append(':').append(cnonce).append(':').append(qop).append(':');
+            }
+        }
+        
+        private void newResponse(MessageDigest md) {
+            // BEWARE: compute first as it used the cached StringBuilder
+            String digestUri = AuthenticatorUtils.computeRealmURI(uri, useAbsoluteURI, omitQuery);
+            
+            StringBuilder sb = StringUtils.stringBuilder();
+            
+            // WARNING: DON'T MOVE, BUFFER IS RECYCLED!!!!
+            byte[] secretDigest = secretDigest(sb, md);
+            byte[] dataDigest = dataDigest(sb, digestUri, md);
+            
+            appendBase16(sb, secretDigest);
+            appendDataBase(sb);
+            appendBase16(sb, dataDigest);
+            
+            byte[] responseDigest = md5FromRecycledStringBuilder(sb, md);
+            response = toHexString(responseDigest);
         }
 
         private static String toHexString(byte[] data) {
-            StringBuilder buffer = new StringBuilder();
+            StringBuilder buffer = StringUtils.stringBuilder();
             for (int i = 0; i < data.length; i++) {
                 buffer.append(Integer.toHexString((data[i] & 0xf0) >>> 4));
                 buffer.append(Integer.toHexString(data[i] & 0x0f));
@@ -598,9 +635,8 @@ private static String toHexString(byte[] data) {
             return buffer.toString();
         }
 
-        private static String toBase16(byte[] bytes) {
+        private static void appendBase16(StringBuilder buf, byte[] bytes) {
             int base = 16;
-            StringBuilder buf = new StringBuilder();
             for (byte b : bytes) {
                 int bi = 0xff & b;
                 int c = '0' + (bi / base) % base;
@@ -612,7 +648,6 @@ private static String toBase16(byte[] bytes) {
                     c = 'a' + (c - '0' - 10);
                 buf.append((char) c);
             }
-            return buf.toString();
         }
 
         /**
@@ -624,12 +659,13 @@ public Realm build() {
 
             // Avoid generating
             if (isNonEmpty(nonce)) {
-                newCnonce();
-                newResponse();
+                MessageDigest md = digestThreadLocal.get();
+                newCnonce(md);
+                newResponse(md);
             }
 
             return new Realm(scheme, principal, password, realmName, nonce, algorithm, response, qop, nc, cnonce, uri, methodName,
-                    usePreemptive, ntlmDomain, enc, host, messageType2Received, opaque, useAbsoluteURI, omitQuery, targetProxy);
+                    usePreemptive, ntlmDomain, charset, ntlmHost, opaque, useAbsoluteURI, omitQuery, targetProxy);
         }
     }
 }
diff --git a/api/src/main/java/org/asynchttpclient/Request.java b/api/src/main/java/org/asynchttpclient/Request.java
index d33e9d78b..99473eb99 100644
--- a/api/src/main/java/org/asynchttpclient/Request.java
+++ b/api/src/main/java/org/asynchttpclient/Request.java
@@ -16,16 +16,22 @@
  */
 package org.asynchttpclient;
 
-import org.asynchttpclient.cookie.Cookie;
-import org.asynchttpclient.multipart.Part;
-import org.asynchttpclient.uri.Uri;
-
 import java.io.File;
 import java.io.InputStream;
 import java.net.InetAddress;
+import java.nio.ByteBuffer;
+import java.nio.charset.Charset;
 import java.util.Collection;
 import java.util.List;
 
+import org.asynchttpclient.channel.NameResolver;
+import org.asynchttpclient.channel.pool.ConnectionPoolPartitioning;
+import org.asynchttpclient.cookie.Cookie;
+import org.asynchttpclient.proxy.ProxyServer;
+import org.asynchttpclient.request.body.generator.BodyGenerator;
+import org.asynchttpclient.request.body.multipart.Part;
+import org.asynchttpclient.uri.Uri;
+
 /**
  * The Request class can be used to construct HTTP request:
  * <blockquote><pre>
@@ -79,6 +85,11 @@
      */
     byte[] getByteData();
 
+    /**
+     * @return the current request's body as a composite of byte arrays
+     */
+    List<byte[]> getCompositeByteData();
+    
     /**
      * Return the current request's body as a string
      *
@@ -86,6 +97,13 @@
      */
     String getStringData();
 
+    /**
+     * Return the current request's body as a ByteBuffer
+     * 
+     * @return a ByteBuffer
+     */
+    ByteBuffer getByteBufferData();
+
     /**
      * Return the current request's body as an InputStream
      *
@@ -110,7 +128,7 @@
     /**
      * Return the current form parameters.
      *
-     * @return a {@link FluentStringsMap} of parameters.
+     * @return a {@link List<Param>} of parameters.
      */
     List<Param> getFormParams();
 
@@ -131,7 +149,7 @@
     /**
      * Return the query params.
      *
-     * @return {@link FluentStringsMap} of query string
+     * @return {@link List<Param>} of query string
      */
     List<Param> getQueryParams();
 
@@ -168,7 +186,7 @@
      * Overrides the config default value
      * @return the request timeout
      */
-    int getRequestTimeoutInMs();
+    int getRequestTimeout();
 
     /**
      * Return the HTTP Range header value, or
@@ -178,11 +196,13 @@
     long getRangeOffset();
 
     /**
-     * Return the encoding value used when encoding the request's body.
+     * Return the charset value used when decoding the request's body.
      *
-     * @return the encoding value used when encoding the request's body.
+     * @return the charset value used when decoding the request's body.
      */
-    String getBodyEncoding();
+    Charset getBodyCharset();
 
     ConnectionPoolPartitioning getConnectionPoolPartitioning();
+
+    NameResolver getNameResolver();
 }
diff --git a/api/src/main/java/org/asynchttpclient/RequestBuilder.java b/api/src/main/java/org/asynchttpclient/RequestBuilder.java
index b5d2e9144..eb4fb0878 100644
--- a/api/src/main/java/org/asynchttpclient/RequestBuilder.java
+++ b/api/src/main/java/org/asynchttpclient/RequestBuilder.java
@@ -15,14 +15,7 @@
  */
 package org.asynchttpclient;
 
-import java.io.InputStream;
-import java.util.Collection;
-import java.util.List;
-import java.util.Map;
-
-import org.asynchttpclient.cookie.Cookie;
-import org.asynchttpclient.multipart.Part;
-import org.asynchttpclient.util.QueryComputer;
+import org.asynchttpclient.util.UriEncoder;
 
 /**
  * Builder for a {@link Request}.
@@ -39,138 +32,19 @@ public RequestBuilder(String method) {
         super(RequestBuilder.class, method, false);
     }
 
-    public RequestBuilder(String method, boolean useRawUrl) {
-        super(RequestBuilder.class, method, useRawUrl);
+    public RequestBuilder(String method, boolean disableUrlEncoding) {
+        super(RequestBuilder.class, method, disableUrlEncoding);
     }
 
-    public RequestBuilder(String method, QueryComputer queryComputer) {
-        super(RequestBuilder.class, method, queryComputer);
+    public RequestBuilder(String method, UriEncoder uriEncoder) {
+        super(RequestBuilder.class, method, uriEncoder);
     }
 
     public RequestBuilder(Request prototype) {
         super(RequestBuilder.class, prototype);
     }
 
-    public RequestBuilder(Request prototype, QueryComputer queryComputer) {
-        super(RequestBuilder.class, prototype, queryComputer);
-    }
-    
-    // Note: For now we keep the delegates in place even though they are not needed
-    //       since otherwise Clojure (and maybe other languages) won't be able to
-    //       access these methods - see Clojure tickets 126 and 259
-
-    @Override
-    public RequestBuilder addBodyPart(Part part) {
-        return super.addBodyPart(part);
-    }
-
-    @Override
-    public RequestBuilder addCookie(Cookie cookie) {
-        return super.addCookie(cookie);
-    }
-
-    @Override
-    public RequestBuilder addHeader(String name, String value) {
-        return super.addHeader(name, value);
-    }
-
-    @Override
-    public RequestBuilder addFormParam(String key, String value) {
-        return super.addFormParam(key, value);
-    }
-
-    @Override
-    public RequestBuilder addQueryParam(String name, String value) {
-        return super.addQueryParam(name, value);
-    }
-
-    @Override
-    public RequestBuilder addQueryParams(List<Param> queryParams) {
-        return super.addQueryParams(queryParams);
-    }
-
-    @Override
-    public RequestBuilder setQueryParams(List<Param> params) {
-        return super.setQueryParams(params);
-    }
-
-    @Override
-    public RequestBuilder setQueryParams(Map<String, List<String>> params) {
-        return super.setQueryParams(params);
-    }
-
-    @Override
-    public Request build() {
-        return super.build();
-    }
-
-    @Override
-    public RequestBuilder setBody(byte[] data) {
-        return super.setBody(data);
-    }
-
-    @Override
-    public RequestBuilder setBody(InputStream stream) {
-        return super.setBody(stream);
-    }
-
-    @Override
-    public RequestBuilder setBody(String data) {
-        return super.setBody(data);
-    }
-
-    @Override
-    public RequestBuilder setHeader(String name, String value) {
-        return super.setHeader(name, value);
-    }
-
-    @Override
-    public RequestBuilder setHeaders(FluentCaseInsensitiveStringsMap headers) {
-        return super.setHeaders(headers);
-    }
-
-    @Override
-    public RequestBuilder setHeaders(Map<String, Collection<String>> headers) {
-        return super.setHeaders(headers);
-    }
-
-    @Override
-    public RequestBuilder setFormParams(List<Param> params) {
-        return super.setFormParams(params);
-    }
-
-    @Override
-    public RequestBuilder setFormParams(Map<String, List<String>> params) {
-        return super.setFormParams(params);
-    }
-
-    @Override
-    public RequestBuilder setMethod(String method) {
-        return super.setMethod(method);
-    }
-
-    @Override
-    public RequestBuilder setUrl(String url) {
-        return super.setUrl(url);
-    }
-
-    @Override
-    public RequestBuilder setProxyServer(ProxyServer proxyServer) {
-        return super.setProxyServer(proxyServer);
-    }
-
-    @Override
-    public RequestBuilder setVirtualHost(String virtualHost) {
-        return super.setVirtualHost(virtualHost);
-    }
-
-    @Override
-    public RequestBuilder setFollowRedirect(boolean followRedirect) {
-        return super.setFollowRedirect(followRedirect);
-    }
-
-    @Override
-    public RequestBuilder addOrReplaceCookie(Cookie c) {
-        return super.addOrReplaceCookie(c);
+    public RequestBuilder(Request prototype, UriEncoder uriEncoder) {
+        super(RequestBuilder.class, prototype, uriEncoder);
     }
 }
diff --git a/api/src/main/java/org/asynchttpclient/RequestBuilderBase.java b/api/src/main/java/org/asynchttpclient/RequestBuilderBase.java
index db70efff4..90d491b23 100644
--- a/api/src/main/java/org/asynchttpclient/RequestBuilderBase.java
+++ b/api/src/main/java/org/asynchttpclient/RequestBuilderBase.java
@@ -15,25 +15,34 @@
  */
 package org.asynchttpclient;
 
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.parseCharset;
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.validateSupportedScheme;
 import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 
-import org.asynchttpclient.cookie.Cookie;
-import org.asynchttpclient.multipart.Part;
-import org.asynchttpclient.uri.Uri;
-import org.asynchttpclient.util.AsyncHttpProviderUtils;
-import org.asynchttpclient.util.QueryComputer;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 import java.io.File;
 import java.io.InputStream;
 import java.net.InetAddress;
+import java.nio.ByteBuffer;
+import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 
+import org.asynchttpclient.channel.NameResolver;
+import org.asynchttpclient.channel.pool.ConnectionPoolPartitioning;
+import org.asynchttpclient.cookie.Cookie;
+import org.asynchttpclient.proxy.ProxyServer;
+import org.asynchttpclient.request.body.generator.BodyGenerator;
+import org.asynchttpclient.request.body.generator.ReactiveStreamsBodyGenerator;
+import org.asynchttpclient.request.body.multipart.Part;
+import org.asynchttpclient.uri.Uri;
+import org.asynchttpclient.util.UriEncoder;
+import org.reactivestreams.Publisher;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 /**
  * Builder for {@link Request}
  * 
@@ -52,7 +61,9 @@
         private FluentCaseInsensitiveStringsMap headers = new FluentCaseInsensitiveStringsMap();
         private ArrayList<Cookie> cookies;
         private byte[] byteData;
+        private List<byte[]> compositeByteData;
         private String stringData;
+        private ByteBuffer byteBufferData;
         private InputStream streamData;
         private BodyGenerator bodyGenerator;
         private List<Param> formParams;
@@ -63,10 +74,11 @@
         private Realm realm;
         private File file;
         private Boolean followRedirect;
-        private int requestTimeoutInMs;
+        private int requestTimeout;
         private long rangeOffset;
-        public String charset;
-        private ConnectionPoolPartitioning connectionPoolPartitioning = PerHostConnectionPoolPartitioning.INSTANCE;
+        public Charset charset;
+        private ConnectionPoolPartitioning connectionPoolPartitioning = ConnectionPoolPartitioning.PerHostConnectionPoolPartitioning.INSTANCE;
+        private NameResolver nameResolver = NameResolver.JdkNameResolver.INSTANCE;
         private List<Param> queryParams;
 
         public RequestImpl() {
@@ -79,23 +91,26 @@ public RequestImpl(Request prototype) {
                 this.address = prototype.getInetAddress();
                 this.localAddress = prototype.getLocalAddress();
                 this.headers = new FluentCaseInsensitiveStringsMap(prototype.getHeaders());
-                this.cookies = new ArrayList<Cookie>(prototype.getCookies());
+                this.cookies = new ArrayList<>(prototype.getCookies());
                 this.byteData = prototype.getByteData();
+                this.compositeByteData = prototype.getCompositeByteData();
                 this.stringData = prototype.getStringData();
+                this.byteBufferData = prototype.getByteBufferData();
                 this.streamData = prototype.getStreamData();
                 this.bodyGenerator = prototype.getBodyGenerator();
-                this.formParams = prototype.getFormParams() == null ? null : new ArrayList<Param>(prototype.getFormParams());
-                this.parts = prototype.getParts() == null ? null : new ArrayList<Part>(prototype.getParts());
+                this.formParams = prototype.getFormParams() == null ? null : new ArrayList<>(prototype.getFormParams());
+                this.parts = prototype.getParts() == null ? null : new ArrayList<>(prototype.getParts());
                 this.virtualHost = prototype.getVirtualHost();
                 this.length = prototype.getContentLength();
                 this.proxyServer = prototype.getProxyServer();
                 this.realm = prototype.getRealm();
                 this.file = prototype.getFile();
                 this.followRedirect = prototype.getFollowRedirect();
-                this.requestTimeoutInMs = prototype.getRequestTimeoutInMs();
+                this.requestTimeout = prototype.getRequestTimeout();
                 this.rangeOffset = prototype.getRangeOffset();
-                this.charset = prototype.getBodyEncoding();
+                this.charset = prototype.getBodyCharset();
                 this.connectionPoolPartitioning = prototype.getConnectionPoolPartitioning();
+                this.nameResolver = prototype.getNameResolver();
             }
         }
 
@@ -139,11 +154,21 @@ public FluentCaseInsensitiveStringsMap getHeaders() {
             return byteData;
         }
 
+        @Override
+        public List<byte[]> getCompositeByteData() {
+            return compositeByteData;
+        }
+
         @Override
         public String getStringData() {
             return stringData;
         }
 
+        @Override
+        public ByteBuffer getByteBufferData() {
+            return byteBufferData;
+        }
+
         @Override
         public InputStream getStreamData() {
             return streamData;
@@ -195,8 +220,8 @@ public Boolean getFollowRedirect() {
         }
 
         @Override
-        public int getRequestTimeoutInMs() {
-            return requestTimeoutInMs;
+        public int getRequestTimeout() {
+            return requestTimeout;
         }
 
         @Override
@@ -205,7 +230,7 @@ public long getRangeOffset() {
         }
 
         @Override
-        public String getBodyEncoding() {
+        public Charset getBodyCharset() {
             return charset;
         }
 
@@ -214,12 +239,17 @@ public ConnectionPoolPartitioning getConnectionPoolPartitioning() {
             return connectionPoolPartitioning;
         }
 
+        @Override
+        public NameResolver getNameResolver() {
+            return nameResolver;
+        }
+
         @Override
         public List<Param> getQueryParams() {
             if (queryParams == null)
                 // lazy load
                 if (isNonEmpty(uri.getQuery())) {
-                    queryParams = new ArrayList<Param>(1);
+                    queryParams = new ArrayList<>(1);
                     for (String queryStringParam : uri.getQuery().split("&")) {
                         int pos = queryStringParam.indexOf('=');
                         if (pos <= 0)
@@ -263,29 +293,29 @@ public String toString() {
 
     private final Class<T> derived;
     protected final RequestImpl request;
-    protected QueryComputer queryComputer;
-    protected List<Param> queryParams;
+    protected UriEncoder uriEncoder;
+    protected List<Param> rbQueryParams;
     protected SignatureCalculator signatureCalculator;
 
     protected RequestBuilderBase(Class<T> derived, String method, boolean disableUrlEncoding) {
-        this(derived, method, QueryComputer.queryComputer(disableUrlEncoding));
+        this(derived, method, UriEncoder.uriEncoder(disableUrlEncoding));
     }
 
-    protected RequestBuilderBase(Class<T> derived, String method, QueryComputer queryComputer) {
+    protected RequestBuilderBase(Class<T> derived, String method, UriEncoder uriEncoder) {
         this.derived = derived;
         request = new RequestImpl();
         request.method = method;
-        this.queryComputer = queryComputer;
+        this.uriEncoder = uriEncoder;
     }
 
     protected RequestBuilderBase(Class<T> derived, Request prototype) {
-        this(derived, prototype, QueryComputer.URL_ENCODING_ENABLED_QUERY_COMPUTER);
+        this(derived, prototype, UriEncoder.FIXING);
     }
 
-    protected RequestBuilderBase(Class<T> derived, Request prototype, QueryComputer queryComputer) {
+    protected RequestBuilderBase(Class<T> derived, Request prototype, UriEncoder uriEncoder) {
         this.derived = derived;
         request = new RequestImpl(prototype);
-        this.queryComputer = queryComputer;
+        this.uriEncoder = uriEncoder;
     }
     
     public T setUrl(String url) {
@@ -344,11 +374,11 @@ public T setContentLength(int length) {
 
     private void lazyInitCookies() {
         if (request.cookies == null)
-            request.cookies = new ArrayList<Cookie>(3);
+            request.cookies = new ArrayList<>(3);
     }
 
     public T setCookies(Collection<Cookie> cookies) {
-        request.cookies = new ArrayList<Cookie>(cookies);
+        request.cookies = new ArrayList<>(cookies);
         return derived.cast(this);
     }
 
@@ -384,7 +414,7 @@ public void resetCookies() {
     }
     
     public void resetQuery() {
-        queryParams = null;
+        rbQueryParams = null;
         request.uri = request.uri.withNewQuery(null);
     }
     
@@ -394,8 +424,11 @@ public void resetFormParams() {
 
     public void resetNonMultipartData() {
         request.byteData = null;
+        request.compositeByteData = null;
+        request.byteBufferData = null;
         request.stringData = null;
         request.streamData = null;
+        request.bodyGenerator = null;
         request.length = -1;
     }
 
@@ -408,47 +441,63 @@ public T setBody(File file) {
         return derived.cast(this);
     }
 
-    public T setBody(byte[] data) {
+    private void resetBody() {
         resetFormParams();
         resetNonMultipartData();
         resetMultipartData();
+    }
+
+    public T setBody(byte[] data) {
+        resetBody();
         request.byteData = data;
         return derived.cast(this);
     }
 
+    public T setBody(List<byte[]> data) {
+        resetBody();
+        request.compositeByteData = data;
+        return derived.cast(this);
+    }
+
     public T setBody(String data) {
-        resetFormParams();
-        resetNonMultipartData();
-        resetMultipartData();
+        resetBody();
         request.stringData = data;
         return derived.cast(this);
     }
 
+    public T setBody(ByteBuffer data) {
+        resetBody();
+        request.byteBufferData = data;
+        return derived.cast(this);
+    }
+    
     public T setBody(InputStream stream) {
-        resetFormParams();
-        resetNonMultipartData();
-        resetMultipartData();
+        resetBody();
         request.streamData = stream;
         return derived.cast(this);
     }
 
+    public T setBody(Publisher<ByteBuffer> publisher) {
+        return setBody(new ReactiveStreamsBodyGenerator(publisher));
+    }
+
     public T setBody(BodyGenerator bodyGenerator) {
         request.bodyGenerator = bodyGenerator;
         return derived.cast(this);
     }
 
     public T addQueryParam(String name, String value) {
-        if (queryParams == null)
-            queryParams = new ArrayList<Param>(1);
-        queryParams.add(new Param(name, value));
+        if (rbQueryParams == null)
+            rbQueryParams = new ArrayList<>(1);
+        rbQueryParams.add(new Param(name, value));
         return derived.cast(this);
     }
 
     public T addQueryParams(List<Param> params) {
-        if (queryParams == null)
-            queryParams = params;
+        if (rbQueryParams == null)
+            rbQueryParams = params;
         else
-            queryParams.addAll(params);
+            rbQueryParams.addAll(params);
         return derived.cast(this);
     }
 
@@ -456,7 +505,7 @@ public T addQueryParams(List<Param> params) {
         if (map == null)
             return null;
 
-        List<Param> params = new ArrayList<Param>(map.size());
+        List<Param> params = new ArrayList<>(map.size());
         for (Map.Entry<String, List<String>> entries : map.entrySet()) {
             String name = entries.getKey();
             for (String value : entries.getValue())
@@ -473,7 +522,7 @@ public T setQueryParams(List<Param> params) {
         // reset existing query
         if (isNonEmpty(request.uri.getQuery()))
             request.uri = request.uri.withNewQuery(null);
-        queryParams = params;
+        rbQueryParams = params;
         return derived.cast(this);
     }
     
@@ -481,7 +530,7 @@ public T addFormParam(String name, String value) {
         resetNonMultipartData();
         resetMultipartData();
         if (request.formParams == null)
-            request.formParams = new ArrayList<Param>(1);
+            request.formParams = new ArrayList<>(1);
         request.formParams.add(new Param(name, value));
         return derived.cast(this);
     }
@@ -500,7 +549,7 @@ public T addBodyPart(Part part) {
         resetFormParams();
         resetNonMultipartData();
         if (request.parts == null)
-            request.parts = new ArrayList<Part>();
+            request.parts = new ArrayList<>();
         request.parts.add(part);
         return derived.cast(this);
     }
@@ -520,8 +569,8 @@ public T setFollowRedirect(boolean followRedirect) {
         return derived.cast(this);
     }
 
-    public T setRequestTimeoutInMs(int requestTimeoutInMs) {
-        request.requestTimeoutInMs = requestTimeoutInMs;
+    public T setRequestTimeout(int requestTimeout) {
+        request.requestTimeout = requestTimeout;
         return derived.cast(this);
     }
 
@@ -535,7 +584,7 @@ public T setMethod(String method) {
         return derived.cast(this);
     }
 
-    public T setBodyEncoding(String charset) {
+    public T setBodyCharset(Charset charset) {
         request.charset = charset;
         return derived.cast(this);
     }
@@ -545,6 +594,11 @@ public T setConnectionPoolPartitioning(ConnectionPoolPartitioning connectionPool
         return derived.cast(this);
     }
 
+    public T setNameResolver(NameResolver nameResolver) {
+        request.nameResolver = nameResolver;
+        return derived.cast(this);
+    }
+
     public T setSignatureCalculator(SignatureCalculator signatureCalculator) {
         this.signatureCalculator = signatureCalculator;
         return derived.cast(this);
@@ -555,7 +609,10 @@ private void executeSignatureCalculator() {
          * (order does not matter with current implementation but may in future)
          */
         if (signatureCalculator != null) {
-            signatureCalculator.calculateAndAddSignature(request, this);
+            RequestBuilder rb = new RequestBuilder(request).setSignatureCalculator(null);
+            rb.rbQueryParams = this.rbQueryParams;
+            Request unsignedRequest = rb.build();
+            signatureCalculator.calculateAndAddSignature(unsignedRequest, this);
         }
     }
     
@@ -564,7 +621,7 @@ private void computeRequestCharset() {
             try {
                 final String contentType = request.headers.getFirstValue("Content-Type");
                 if (contentType != null) {
-                    final String charset = AsyncHttpProviderUtils.parseCharset(contentType);
+                    final Charset charset = parseCharset(contentType);
                     if (charset != null) {
                         // ensure that if charset is provided with the Content-Type header,
                         // we propagate that down to the charset of the Request object
@@ -597,18 +654,16 @@ private void computeFinalUri() {
         if (request.uri == null) {
             logger.debug("setUrl hasn't been invoked. Using {}", DEFAULT_REQUEST_URL);
             request.uri = DEFAULT_REQUEST_URL;
+        } else {
+            validateSupportedScheme(request.uri);
         }
 
-        AsyncHttpProviderUtils.validateSupportedScheme(request.uri);
-
-        String newQuery = queryComputer.computeFullQueryString(request.uri.getQuery(), queryParams);
-
-        request.uri = request.uri.withNewQuery(newQuery);
+        request.uri =  uriEncoder.encode(request.uri, rbQueryParams);
     }
 
     public Request build() {
-        computeFinalUri();
         executeSignatureCalculator();
+        computeFinalUri();
         computeRequestCharset();
         computeRequestLength();
         return request;
diff --git a/api/src/main/java/org/asynchttpclient/Response.java b/api/src/main/java/org/asynchttpclient/Response.java
index e018fb9e0..abbb401d1 100644
--- a/api/src/main/java/org/asynchttpclient/Response.java
+++ b/api/src/main/java/org/asynchttpclient/Response.java
@@ -21,7 +21,9 @@
 
 import java.io.IOException;
 import java.io.InputStream;
+import java.net.SocketAddress;
 import java.nio.ByteBuffer;
+import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -67,19 +69,6 @@
      */
     InputStream getResponseBodyAsStream() throws IOException;
 
-    /**
-     * Returns the first maxLength bytes of the response body as a string. Note that this does not check whether the content type is actually a textual one, but it will use the
-     * charset if present in the content type header.
-     * 
-     * @param maxLength
-     *            The maximum number of bytes to read
-     * @param charset
-     *            the charset to use when decoding the stream
-     * @return The response body
-     * @throws java.io.IOException
-     */
-    String getResponseBodyExcerpt(int maxLength, String charset) throws IOException;
-
     /**
      * Return the entire response body as a String.
      * 
@@ -88,18 +77,7 @@
      * @return the entire response body as a String.
      * @throws IOException
      */
-    String getResponseBody(String charset) throws IOException;
-
-    /**
-     * Returns the first maxLength bytes of the response body as a string. Note that this does not check whether the content type is actually a textual one, but it will use the
-     * charset if present in the content type header.
-     * 
-     * @param maxLength
-     *            The maximum number of bytes to read
-     * @return The response body
-     * @throws java.io.IOException
-     */
-    String getResponseBodyExcerpt(int maxLength) throws IOException;
+    String getResponseBody(Charset charset) throws IOException;
 
     /**
      * Return the entire response body as a String.
@@ -147,7 +125,7 @@
     boolean isRedirected();
 
     /**
-     * Subclasses SHOULD implement toString() in a way that identifies the request for logging.
+     * Subclasses SHOULD implement toString() in a way that identifies the response for logging.
      * 
      * @return The textual representation
      */
@@ -167,7 +145,7 @@
 
     /**
      * Return true if the response's headers has been computed by an {@link AsyncHandler} It will return false if the either
-     * {@link AsyncHandler#onStatusReceived(HttpResponseStatus)} or {@link AsyncHandler#onHeadersReceived(HttpResponseHeaders)} returned {@link AsyncHandler.STATE#ABORT}
+     * {@link AsyncHandler#onStatusReceived(HttpResponseStatus)} or {@link AsyncHandler#onHeadersReceived(HttpResponseHeaders)} returned {@link AsyncHandler.State#ABORT}
      * 
      * @return true if the response's headers has been computed by an {@link AsyncHandler}
      */
@@ -175,14 +153,30 @@
 
     /**
      * Return true if the response's body has been computed by an {@link AsyncHandler}. It will return false if the either {@link AsyncHandler#onStatusReceived(HttpResponseStatus)}
-     * or {@link AsyncHandler#onHeadersReceived(HttpResponseHeaders)} returned {@link AsyncHandler.STATE#ABORT}
+     * or {@link AsyncHandler#onHeadersReceived(HttpResponseHeaders)} returned {@link AsyncHandler.State#ABORT}
      * 
      * @return true if the response's body has been computed by an {@link AsyncHandler}
      */
     boolean hasResponseBody();
 
-    public static class ResponseBuilder {
-        private final List<HttpResponseBodyPart> bodyParts = new ArrayList<HttpResponseBodyPart>();
+    /**
+     * Get remote address client initiated request to.
+     * 
+     * @return remote address client initiated request to, may be {@code null}
+     *         if asynchronous provider is unable to provide the remote address
+     */
+    SocketAddress getRemoteAddress();
+
+    /**
+     * Get local address client initiated request from.
+     * 
+     * @return local address client initiated request from, may be {@code null}
+     *         if asynchronous provider is unable to provide the local address
+     */
+    SocketAddress getLocalAddress();
+    
+    class ResponseBuilder {
+        private final List<HttpResponseBodyPart> bodyParts = new ArrayList<>();
         private HttpResponseStatus status;
         private HttpResponseHeaders headers;
 
diff --git a/api/src/main/java/org/asynchttpclient/providers/ResponseBase.java b/api/src/main/java/org/asynchttpclient/ResponseBase.java
similarity index 66%
rename from api/src/main/java/org/asynchttpclient/providers/ResponseBase.java
rename to api/src/main/java/org/asynchttpclient/ResponseBase.java
index 52e9746b8..57fe6b0a8 100644
--- a/api/src/main/java/org/asynchttpclient/providers/ResponseBase.java
+++ b/api/src/main/java/org/asynchttpclient/ResponseBase.java
@@ -1,21 +1,18 @@
-package org.asynchttpclient.providers;
+package org.asynchttpclient;
 
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.*;
 import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 
-import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
-import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.HttpResponseHeaders;
-import org.asynchttpclient.HttpResponseStatus;
-import org.asynchttpclient.Response;
 import org.asynchttpclient.cookie.Cookie;
 import org.asynchttpclient.uri.Uri;
-import org.asynchttpclient.util.AsyncHttpProviderUtils;
 
+import java.io.IOException;
+import java.net.SocketAddress;
+import java.nio.charset.Charset;
 import java.util.Collections;
 import java.util.List;
 
 public abstract class ResponseBase implements Response {
-    protected final static String DEFAULT_CHARSET = "ISO-8859-1";
 
     protected final List<HttpResponseBodyPart> bodyParts;
     protected final HttpResponseHeaders headers;
@@ -30,12 +27,13 @@ protected ResponseBase(HttpResponseStatus status, HttpResponseHeaders headers, L
 
     protected abstract List<Cookie> buildCookies();
 
-    protected String calculateCharset(String charset) {
+    protected Charset calculateCharset(Charset charset) {
 
         if (charset == null) {
             String contentType = getContentType();
             if (contentType != null)
-                charset = AsyncHttpProviderUtils.parseCharset(contentType); // parseCharset can return null
+                charset = parseCharset(contentType); // parseCharset can return
+                                                     // null
         }
         return charset != null ? charset : DEFAULT_CHARSET;
     }
@@ -55,6 +53,16 @@ public final Uri getUri() {
         return status.getUri();
     }
 
+    @Override
+    public SocketAddress getRemoteAddress() {
+        return status.getRemoteAddress();
+    }
+
+    @Override
+    public SocketAddress getLocalAddress() {
+        return status.getLocalAddress();
+    }
+
     @Override
     public final String getContentType() {
         return headers != null ? getHeader("Content-Type") : null;
@@ -67,7 +75,7 @@ public final String getHeader(String name) {
 
     @Override
     public final List<String> getHeaders(String name) {
-        return headers != null ? getHeaders().get(name) : null;
+        return headers != null ? getHeaders().get(name) : Collections.<String> emptyList();
     }
 
     @Override
@@ -117,4 +125,18 @@ public boolean hasResponseHeaders() {
     public boolean hasResponseBody() {
         return isNonEmpty(bodyParts);
     }
+
+    @Override
+    public String toString() {
+        try {
+            return new StringBuilder()//
+                    .append(getClass().getSimpleName()).append(" {\n")//
+                    .append("\tstatusCode=").append(getStatusCode()).append("\n")//
+                    .append("\theaders=").append(getHeaders()).append("\n")//
+                    .append("\tbody=\n").append(getResponseBody()).append("\n")//
+                    .append("}").toString();
+        } catch (IOException e) {
+            throw new RuntimeException("IOException occurred while trying to print response body", e);
+        }
+    }
 }
diff --git a/api/src/main/java/org/asynchttpclient/SignatureCalculator.java b/api/src/main/java/org/asynchttpclient/SignatureCalculator.java
index 90339d8c5..d6e94a707 100644
--- a/api/src/main/java/org/asynchttpclient/SignatureCalculator.java
+++ b/api/src/main/java/org/asynchttpclient/SignatureCalculator.java
@@ -15,6 +15,8 @@
  */
 package org.asynchttpclient;
 
+
+
 /**
  * Interface that allows injecting signature calculator into
  * {@link RequestBuilder} so that signature calculation and inclusion can
diff --git a/api/src/main/java/org/asynchttpclient/channel/NameResolver.java b/api/src/main/java/org/asynchttpclient/channel/NameResolver.java
new file mode 100644
index 000000000..051641236
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/channel/NameResolver.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.channel;
+
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+
+public interface NameResolver {
+
+    InetAddress resolve(String name) throws UnknownHostException;
+
+    enum JdkNameResolver implements NameResolver {
+
+        INSTANCE;
+
+        @Override
+        public InetAddress resolve(String name) throws UnknownHostException {
+            return InetAddress.getByName(name);
+        }
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/channel/SSLEngineFactory.java b/api/src/main/java/org/asynchttpclient/channel/SSLEngineFactory.java
new file mode 100644
index 000000000..b2d7ddbf3
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/channel/SSLEngineFactory.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.channel;
+
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+
+import java.security.GeneralSecurityException;
+
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLEngine;
+import javax.net.ssl.SSLParameters;
+
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.util.SslUtils;
+
+/**
+ * Factory that creates an {@link SSLEngine} to be used for a single SSL connection.
+ */
+public interface SSLEngineFactory {
+
+    /**
+     * Creates new {@link SSLEngine}.
+     *
+     * @return new engine
+     * @throws GeneralSecurityException if the SSLEngine cannot be created
+     */
+    SSLEngine newSSLEngine(String peerHost, int peerPort) throws GeneralSecurityException;
+
+    class DefaultSSLEngineFactory implements SSLEngineFactory {
+
+        private final AsyncHttpClientConfig config;
+
+        public DefaultSSLEngineFactory(AsyncHttpClientConfig config) {
+            this.config = config;
+        }
+
+        @Override
+        public SSLEngine newSSLEngine(String peerHost, int peerPort) throws GeneralSecurityException {
+            SSLContext sslContext = SslUtils.getInstance().getSSLContext(config);
+
+            SSLEngine sslEngine = sslContext.createSSLEngine(peerHost, peerPort);
+            if (!config.isAcceptAnyCertificate()) {
+                SSLParameters params = sslEngine.getSSLParameters();
+                params.setEndpointIdentificationAlgorithm("HTTPS");
+                sslEngine.setSSLParameters(params);
+            }
+            sslEngine.setUseClientMode(true);
+
+            if (isNonEmpty(config.getEnabledProtocols()))
+                sslEngine.setEnabledProtocols(config.getEnabledProtocols());
+
+            if (isNonEmpty(config.getEnabledCipherSuites()))
+                sslEngine.setEnabledCipherSuites(config.getEnabledCipherSuites());
+
+            return sslEngine;
+        }
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/channel/pool/ConnectionPoolPartitioning.java b/api/src/main/java/org/asynchttpclient/channel/pool/ConnectionPoolPartitioning.java
new file mode 100644
index 000000000..c65775b42
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/channel/pool/ConnectionPoolPartitioning.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.channel.pool;
+
+import org.asynchttpclient.proxy.ProxyServer;
+import org.asynchttpclient.uri.Uri;
+import org.asynchttpclient.util.AsyncHttpProviderUtils;
+
+public interface ConnectionPoolPartitioning {
+
+    class ProxyPartitionKey {
+        private final String proxyUrl;
+        private final String targetHostBaseUrl;
+
+        public ProxyPartitionKey(String proxyUrl, String targetHostBaseUrl) {
+            this.proxyUrl = proxyUrl;
+            this.targetHostBaseUrl = targetHostBaseUrl;
+        }
+
+        @Override
+        public String toString() {
+            return new StringBuilder()//
+                    .append("ProxyPartitionKey(proxyUrl=").append(proxyUrl)//
+                    .append(", targetHostBaseUrl=").append(targetHostBaseUrl)//
+                    .toString();
+        }
+    }
+
+    Object getPartitionKey(Uri uri, String virtualHost, ProxyServer proxyServer);
+
+    enum PerHostConnectionPoolPartitioning implements ConnectionPoolPartitioning {
+
+        INSTANCE;
+
+        public Object getPartitionKey(Uri uri, String virtualHost, ProxyServer proxyServer) {
+            String targetHostBaseUrl = virtualHost != null ? virtualHost : AsyncHttpProviderUtils.getBaseUrl(uri);
+            return proxyServer != null ? new ProxyPartitionKey(proxyServer.getUrl(), targetHostBaseUrl) : targetHostBaseUrl;
+        }
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/SSLEngineFactory.java b/api/src/main/java/org/asynchttpclient/channel/pool/ConnectionStrategy.java
similarity index 60%
rename from api/src/main/java/org/asynchttpclient/SSLEngineFactory.java
rename to api/src/main/java/org/asynchttpclient/channel/pool/ConnectionStrategy.java
index a7152bbb4..5135ca6c8 100644
--- a/api/src/main/java/org/asynchttpclient/SSLEngineFactory.java
+++ b/api/src/main/java/org/asynchttpclient/channel/pool/ConnectionStrategy.java
@@ -11,21 +11,18 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient;
-
-import javax.net.ssl.SSLEngine;
-
-import java.security.GeneralSecurityException;
+package org.asynchttpclient.channel.pool;
 
 /**
- * Factory that creates an {@link SSLEngine} to be used for a single SSL connection.
+ * Provides an interface for decisions about HTTP connections.
  */
-public interface SSLEngineFactory {
+public interface ConnectionStrategy<REQUEST, RESPONSE> {
+
     /**
-     * Creates new {@link SSLEngine}.
-     *
-     * @return new engine
-     * @throws GeneralSecurityException if the SSLEngine cannot be created
+     * Determines whether the connection should be kept alive after this HTTP message exchange.
+     * @param request the HTTP request
+     * @param response the HTTP response
+     * @return true if the connection should be kept alive, false if it should be closed.
      */
-    SSLEngine newSSLEngine() throws GeneralSecurityException;
+    boolean keepAlive(REQUEST request, RESPONSE response);
 }
diff --git a/api/src/main/java/org/asynchttpclient/AsyncHttpClientConfigBean.java b/api/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigBean.java
similarity index 83%
rename from api/src/main/java/org/asynchttpclient/AsyncHttpClientConfigBean.java
rename to api/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigBean.java
index aa2a5c0d6..f5106a412 100644
--- a/api/src/main/java/org/asynchttpclient/AsyncHttpClientConfigBean.java
+++ b/api/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigBean.java
@@ -10,16 +10,20 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient;
+package org.asynchttpclient.config;
 
-import static org.asynchttpclient.AsyncHttpClientConfigDefaults.*;
+import static org.asynchttpclient.config.AsyncHttpClientConfigDefaults.*;
 
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.AsyncHttpProviderConfig;
+import org.asynchttpclient.Realm;
 import org.asynchttpclient.filter.IOExceptionFilter;
 import org.asynchttpclient.filter.RequestFilter;
 import org.asynchttpclient.filter.ResponseFilter;
+import org.asynchttpclient.proxy.ProxyServer;
+import org.asynchttpclient.proxy.ProxyServerSelector;
 import org.asynchttpclient.util.ProxyUtils;
 
-import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLContext;
 
 import java.util.LinkedList;
@@ -39,15 +43,16 @@ public AsyncHttpClientConfigBean() {
     }
 
     void configureFilters() {
-        requestFilters = new LinkedList<RequestFilter>();
-        responseFilters = new LinkedList<ResponseFilter>();
-        ioExceptionFilters = new LinkedList<IOExceptionFilter>();
+        requestFilters = new LinkedList<>();
+        responseFilters = new LinkedList<>();
+        ioExceptionFilters = new LinkedList<>();
     }
 
     void configureDefaults() {
         maxConnections = defaultMaxConnections();
         maxConnectionsPerHost = defaultMaxConnectionsPerHost();
-        connectionTimeout = defaultConnectionTimeout();
+        name = defaultName();
+        connectTimeout = defaultConnectTimeout();
         webSocketTimeout = defaultWebSocketTimeout();
         pooledConnectionIdleTimeout = defaultPooledConnectionIdleTimeout();
         readTimeout = defaultReadTimeout();
@@ -58,28 +63,24 @@ void configureDefaults() {
         compressionEnforced = defaultCompressionEnforced();
         userAgent = defaultUserAgent();
         allowPoolingConnections = defaultAllowPoolingConnections();
-        useRelativeURIsWithConnectProxies = defaultUseRelativeURIsWithConnectProxies();
         maxRequestRetry = defaultMaxRequestRetry();
         ioThreadMultiplier = defaultIoThreadMultiplier();
         allowPoolingSslConnections = defaultAllowPoolingSslConnections();
         disableUrlEncodingForBoundRequests = defaultDisableUrlEncodingForBoundRequests();
-        removeQueryParamOnRedirect = defaultRemoveQueryParamOnRedirect();
         strict302Handling = defaultStrict302Handling();
         acceptAnyCertificate = defaultAcceptAnyCertificate();
+        sslSessionCacheSize = defaultSslSessionCacheSize();
+        sslSessionTimeout = defaultSslSessionTimeout();
 
         if (defaultUseProxySelector()) {
             proxyServerSelector = ProxyUtils.getJdkDefaultProxyServerSelector();
         } else if (defaultUseProxyProperties()) {
             proxyServerSelector = ProxyUtils.createProxyServerSelector(System.getProperties());
         }
-        // AHC 2
-        spdyEnabled = defaultSpdyEnabled();
-        spdyInitialWindowSize = defaultSpdyInitialWindowSize();
-        spdyMaxConcurrentStreams = defaultSpdyMaxConcurrentStreams();
     }
 
     void configureExecutors() {
-        applicationThreadPool = Executors.newCachedThreadPool(new ThreadFactory() {
+        executorService = Executors.newCachedThreadPool(new ThreadFactory() {
             public Thread newThread(Runnable r) {
                 Thread t = new Thread(r, "AsyncHttpClient-Callback");
                 t.setDaemon(true);
@@ -88,6 +89,11 @@ public Thread newThread(Runnable r) {
         });
     }
 
+    public AsyncHttpClientConfigBean setName(String name) {
+        this.name = name;
+        return this;
+    }
+
     public AsyncHttpClientConfigBean setMaxTotalConnections(int maxConnections) {
         this.maxConnections = maxConnections;
         return this;
@@ -98,8 +104,8 @@ public AsyncHttpClientConfigBean setMaxConnectionsPerHost(int maxConnectionsPerH
         return this;
     }
 
-    public AsyncHttpClientConfigBean setConnectionTimeout(int connectionTimeout) {
-        this.connectionTimeout = connectionTimeout;
+    public AsyncHttpClientConfigBean setConnectTimeout(int connectTimeout) {
+        this.connectTimeout = connectTimeout;
         return this;
     }
 
@@ -154,10 +160,10 @@ public AsyncHttpClientConfigBean setAllowPoolingConnections(boolean allowPooling
     }
 
     public AsyncHttpClientConfigBean setApplicationThreadPool(ExecutorService applicationThreadPool) {
-        if (this.applicationThreadPool != null) {
-            this.applicationThreadPool.shutdownNow();
+        if (this.executorService != null) {
+            this.executorService.shutdownNow();
         }
-        this.applicationThreadPool = applicationThreadPool;
+        this.executorService = applicationThreadPool;
         return this;
     }
 
@@ -216,23 +222,23 @@ public AsyncHttpClientConfigBean setDisableUrlEncodingForBoundRequests(boolean d
         return this;
     }
 
-    public AsyncHttpClientConfigBean setRemoveQueryParamOnRedirect(boolean removeQueryParamOnRedirect) {
-        this.removeQueryParamOnRedirect = removeQueryParamOnRedirect;
+    public AsyncHttpClientConfigBean setIoThreadMultiplier(int ioThreadMultiplier) {
+        this.ioThreadMultiplier = ioThreadMultiplier;
         return this;
     }
 
-    public AsyncHttpClientConfigBean setHostnameVerifier(HostnameVerifier hostnameVerifier) {
-        this.hostnameVerifier = hostnameVerifier;
+    public AsyncHttpClientConfigBean setAcceptAnyCertificate(boolean acceptAnyCertificate) {
+        this.acceptAnyCertificate = acceptAnyCertificate;
         return this;
     }
 
-    public AsyncHttpClientConfigBean setIoThreadMultiplier(int ioThreadMultiplier) {
-        this.ioThreadMultiplier = ioThreadMultiplier;
+    public AsyncHttpClientConfigBean setSslSessionCacheSize(Integer sslSessionCacheSize) {
+        this.sslSessionCacheSize = sslSessionCacheSize;
         return this;
     }
 
-    public AsyncHttpClientConfigBean setAcceptAnyCertificate(boolean acceptAnyCertificate) {
-        this.acceptAnyCertificate = acceptAnyCertificate;
+    public AsyncHttpClientConfigBean setSslSessionTimeout(Integer sslSessionTimeout) {
+        this.sslSessionTimeout = sslSessionTimeout;
         return this;
     }
 }
diff --git a/api/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigDefaults.java b/api/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigDefaults.java
new file mode 100644
index 000000000..91e96df4a
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigDefaults.java
@@ -0,0 +1,157 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.config;
+
+public final class AsyncHttpClientConfigDefaults {
+
+    private AsyncHttpClientConfigDefaults() {
+    }
+
+    public static final String ASYNC_CLIENT_CONFIG_ROOT = "org.asynchttpclient.";
+
+    public static String defaultName() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getString(ASYNC_CLIENT_CONFIG_ROOT + "name");
+    }
+
+    public static int defaultMaxConnections() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "maxConnections");
+    }
+
+    public static int defaultMaxConnectionsPerHost() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "maxConnectionsPerHost");
+    }
+
+    public static int defaultConnectTimeout() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "connectTimeout");
+    }
+
+    public static int defaultPooledConnectionIdleTimeout() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "pooledConnectionIdleTimeout");
+    }
+
+    public static int defaultReadTimeout() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "readTimeout");
+    }
+
+    public static int defaultRequestTimeout() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "requestTimeout");
+    }
+
+    public static int defaultWebSocketTimeout() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "webSocketTimeout");
+    }
+
+    public static int defaultConnectionTTL() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "connectionTTL");
+    }
+
+    public static boolean defaultFollowRedirect() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "followRedirect");
+    }
+
+    public static int defaultMaxRedirects() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "maxRedirects");
+    }
+
+    public static boolean defaultCompressionEnforced() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "compressionEnforced");
+    }
+
+    public static String defaultUserAgent() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getString(ASYNC_CLIENT_CONFIG_ROOT + "userAgent");
+    }
+
+    public static int defaultIoThreadMultiplier() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "ioThreadMultiplier");
+    }
+    
+    public static String[] defaultEnabledProtocols() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getStringArray(ASYNC_CLIENT_CONFIG_ROOT + "enabledProtocols");
+    }
+
+    public static boolean defaultUseProxySelector() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "useProxySelector");
+    }
+
+    public static boolean defaultUseProxyProperties() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "useProxyProperties");
+    }
+
+    public static boolean defaultStrict302Handling() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "strict302Handling");
+    }
+
+    public static boolean defaultAllowPoolingConnections() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "allowPoolingConnections");
+    }
+
+    public static int defaultMaxRequestRetry() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "maxRequestRetry");
+    }
+
+    public static boolean defaultAllowPoolingSslConnections() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "allowPoolingSslConnections");
+    }
+
+    public static boolean defaultDisableUrlEncodingForBoundRequests() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "disableUrlEncodingForBoundRequests");
+    }
+
+    public static boolean defaultAcceptAnyCertificate() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "acceptAnyCertificate");
+    }
+
+    public static Integer defaultSslSessionCacheSize() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInteger(ASYNC_CLIENT_CONFIG_ROOT + "sslSessionCacheSize");
+    }
+
+    public static Integer defaultSslSessionTimeout() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInteger(ASYNC_CLIENT_CONFIG_ROOT + "sslSessionTimeout");
+    }
+    
+    public static int defaultHttpClientCodecMaxInitialLineLength() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "httpClientCodecMaxInitialLineLength");
+    }
+    
+    public static int defaultHttpClientCodecMaxHeaderSize() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "httpClientCodecMaxHeaderSize");
+    }
+    
+    public static int defaultHttpClientCodecMaxChunkSize() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "httpClientCodecMaxChunkSize");
+    }
+    
+    public static boolean defaultDisableZeroCopy() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "disableZeroCopy");
+    }
+    
+    public static long defaultHandshakeTimeout() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getLong(ASYNC_CLIENT_CONFIG_ROOT + "handshakeTimeout");
+    }
+    
+    public static int defaultChunkedFileChunkSize() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "chunkedFileChunkSize");
+    }
+    
+    public static int defaultWebSocketMaxBufferSize() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "webSocketMaxBufferSize");
+    }
+    
+    public static int defaultWebSocketMaxFrameSize() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "webSocketMaxFrameSize");
+    }
+    
+    public static boolean defaultKeepEncodingHeader() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "keepEncodingHeader");
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigHelper.java b/api/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigHelper.java
new file mode 100644
index 000000000..43bbe966c
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigHelper.java
@@ -0,0 +1,102 @@
+package org.asynchttpclient.config;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Properties;
+
+import org.asynchttpclient.internal.chmv8.ConcurrentHashMapV8;
+
+public class AsyncHttpClientConfigHelper {
+
+    private static volatile Config config;
+
+    public static Config getAsyncHttpClientConfig() {
+        if (config == null) {
+            config = new Config();
+        }
+
+        return config;
+    }
+
+    /**
+     * This method invalidates the property caches. So if a system property has
+     * been changed and the effect of this change is to be seen then call
+     * reloadProperties() and then getAsyncHttpClientConfig() to get the new
+     * property values.
+     */
+    public static void reloadProperties() {
+        if (config != null)
+            config.reload();
+    }
+
+    public static class Config {
+
+        public static final String DEFAULT_AHC_PROPERTIES = "ahc-default.properties";
+        public static final String CUSTOM_AHC_PROPERTIES = "ahc.properties";
+
+        private final ConcurrentHashMapV8<String, String> propsCache = new ConcurrentHashMapV8<String, String>();
+        private final Properties defaultProperties = parsePropertiesFile(DEFAULT_AHC_PROPERTIES);
+        private volatile Properties customProperties = parsePropertiesFile(CUSTOM_AHC_PROPERTIES);
+
+        public void reload() {
+            customProperties = parsePropertiesFile(CUSTOM_AHC_PROPERTIES);
+            propsCache.clear();
+        }
+
+        private Properties parsePropertiesFile(String file) {
+            Properties props = new Properties();
+            try (InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream(file)) {
+                if (is != null) {
+                    props.load(is);
+                }
+            } catch (IOException e) {
+                throw new IllegalArgumentException("Can't parse file", e);
+            }
+            return props;
+        }
+
+        public String getString(String key) {
+            return propsCache.computeIfAbsent(key, new ConcurrentHashMapV8.Fun<String, String>() {
+
+                @Override
+                public String apply(String key) {
+                    String value = System.getProperty(key);
+                    if (value == null) {
+                        value = (String) customProperties.getProperty(key);
+                    }
+                    if (value == null) {
+                        value = (String) defaultProperties.getProperty(key);
+                    }
+
+                    return value;
+                }
+            });
+        }
+
+        public String[] getStringArray(String key) {
+            String s = getString(key);
+            String[] rawArray = s.split(",");
+            String[] array = new String[rawArray.length];
+            for (int i = 0; i < rawArray.length; i++)
+                array[i] = rawArray[i].trim();
+            return array;
+        }
+        
+        public int getInt(String key) {
+            return Integer.parseInt(getString(key));
+        }
+
+        public long getLong(String key) {
+            return Long.parseLong(getString(key));
+        }
+        
+        public Integer getInteger(String key) {
+            String s = getString(key);
+            return s != null ? Integer.valueOf(s) : null;
+        }
+        
+        public boolean getBoolean(String key) {
+            return Boolean.parseBoolean(getString(key));
+        }
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/cookie/Cookie.java b/api/src/main/java/org/asynchttpclient/cookie/Cookie.java
index 66c366cfa..83d2e0ac4 100644
--- a/api/src/main/java/org/asynchttpclient/cookie/Cookie.java
+++ b/api/src/main/java/org/asynchttpclient/cookie/Cookie.java
@@ -14,14 +14,13 @@
 
 public class Cookie {
 
-    public static Cookie newValidCookie(String name, String value, String rawValue, String domain, String path, long expires, int maxAge,
-            boolean secure, boolean httpOnly) {
+    public static Cookie newValidCookie(String name, String value, boolean wrap, String domain, String path, long maxAge, boolean secure, boolean httpOnly) {
 
         if (name == null) {
             throw new NullPointerException("name");
         }
         name = name.trim();
-        if (name.isEmpty()) {
+        if (name.length() == 0) {
             throw new IllegalArgumentException("empty name");
         }
 
@@ -42,8 +41,7 @@ public static Cookie newValidCookie(String name, String value, String rawValue,
             case ',':
             case ';':
             case '=':
-                throw new IllegalArgumentException("name contains one of the following prohibited characters: " + "=,; \\t\\r\\n\\v\\f: "
-                        + name);
+                throw new IllegalArgumentException("name contains one of the following prohibited characters: " + "=,; \\t\\r\\n\\v\\f: " + name);
             }
         }
 
@@ -58,7 +56,7 @@ public static Cookie newValidCookie(String name, String value, String rawValue,
         domain = validateValue("domain", domain);
         path = validateValue("path", path);
 
-        return new Cookie(name, value, rawValue, domain, path, expires, maxAge, secure, httpOnly);
+        return new Cookie(name, value, wrap, domain, path, maxAge, secure, httpOnly);
     }
 
     private static String validateValue(String name, String value) {
@@ -66,7 +64,7 @@ private static String validateValue(String name, String value) {
             return null;
         }
         value = value.trim();
-        if (value.isEmpty()) {
+        if (value.length() == 0) {
             return null;
         }
 
@@ -78,8 +76,7 @@ private static String validateValue(String name, String value) {
             case '\f':
             case 0x0b:
             case ';':
-                throw new IllegalArgumentException(name + " contains one of the following prohibited characters: " + ";\\r\\n\\f\\v ("
-                        + value + ')');
+                throw new IllegalArgumentException(name + " contains one of the following prohibited characters: " + ";\\r\\n\\f\\v (" + value + ')');
             }
         }
         return value;
@@ -87,22 +84,19 @@ private static String validateValue(String name, String value) {
 
     private final String name;
     private final String value;
-    private final String rawValue;
+    private final boolean wrap;
     private final String domain;
     private final String path;
-    private long expires;
-    private final int maxAge;
+    private final long maxAge;
     private final boolean secure;
     private final boolean httpOnly;
 
-    public Cookie(String name, String value, String rawValue, String domain, String path, long expires, int maxAge, boolean secure,
-            boolean httpOnly) {
+    public Cookie(String name, String value, boolean wrap, String domain, String path, long maxAge, boolean secure, boolean httpOnly) {
         this.name = name;
         this.value = value;
-        this.rawValue = rawValue;
+        this.wrap = wrap;
         this.domain = domain;
         this.path = path;
-        this.expires = expires;
         this.maxAge = maxAge;
         this.secure = secure;
         this.httpOnly = httpOnly;
@@ -120,19 +114,15 @@ public String getValue() {
         return value;
     }
 
-    public String getRawValue() {
-        return rawValue;
+    public boolean isWrap() {
+        return wrap;
     }
 
     public String getPath() {
         return path;
     }
 
-    public long getExpires() {
-        return expires;
-    }
-
-    public int getMaxAge() {
+    public long getMaxAge() {
         return maxAge;
     }
 
@@ -148,8 +138,11 @@ public boolean isHttpOnly() {
     public String toString() {
         StringBuilder buf = new StringBuilder();
         buf.append(name);
-        buf.append("=");
-        buf.append(rawValue);
+        buf.append('=');
+        if (wrap)
+            buf.append('"').append(value).append('"');
+        else
+            buf.append(value);
         if (domain != null) {
             buf.append("; domain=");
             buf.append(domain);
@@ -158,14 +151,10 @@ public String toString() {
             buf.append("; path=");
             buf.append(path);
         }
-        if (expires >= 0) {
-            buf.append("; expires=");
-            buf.append(expires);
-        }
         if (maxAge >= 0) {
             buf.append("; maxAge=");
             buf.append(maxAge);
-            buf.append("s");
+            buf.append('s');
         }
         if (secure) {
             buf.append("; secure");
diff --git a/api/src/main/java/org/asynchttpclient/cookie/CookieDecoder.java b/api/src/main/java/org/asynchttpclient/cookie/CookieDecoder.java
index 949fb069c..24695595c 100644
--- a/api/src/main/java/org/asynchttpclient/cookie/CookieDecoder.java
+++ b/api/src/main/java/org/asynchttpclient/cookie/CookieDecoder.java
@@ -12,33 +12,36 @@
  */
 package org.asynchttpclient.cookie;
 
-import org.asynchttpclient.date.CalendarTimeConverter;
-import org.asynchttpclient.date.TimeConverter;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
-public class CookieDecoder {
+import java.nio.CharBuffer;
 
-    public static final TimeConverter DEFAULT_TIME_CONVERTER = new CalendarTimeConverter();
+import static org.asynchttpclient.cookie.CookieUtil.*;
 
-    public static Cookie decode(String header) {
-        return decode(header, DEFAULT_TIME_CONVERTER);
-    }
+public class CookieDecoder {
 
+    private static final Logger LOGGER = LoggerFactory.getLogger(CookieDecoder.class);
+    
     /**
      * Decodes the specified HTTP header value into {@link Cookie}.
      * 
      * @return the decoded {@link Cookie}
      */
-    public static Cookie decode(String header, TimeConverter timeConverter) {
+    public static Cookie decode(String header) {
 
-        if (timeConverter == null)
-            timeConverter = DEFAULT_TIME_CONVERTER;
+        if (header == null) {
+            throw new NullPointerException("header");
+        }
+
+        final int headerLen = header.length();
 
-        if (header.isEmpty())
+        if (headerLen == 0) {
             return null;
+        }
 
-        KeyValuePairsParser pairsParser = new KeyValuePairsParser(timeConverter);
+        CookieBuilder cookieBuilder = null;
 
-        final int headerLen = header.length();
         loop: for (int i = 0;;) {
 
             // Skip spaces and separators.
@@ -59,100 +62,35 @@ public static Cookie decode(String header, TimeConverter timeConverter) {
                 break;
             }
 
-            int newNameStart = i;
-            int newNameEnd = i;
-            String value;
-            String rawValue;
-            boolean first = true;
+            int nameBegin = i;
+            int nameEnd = i;
+            int valueStart = -1;
+            int valueEnd = -1;
 
-            if (i == headerLen) {
-                value = rawValue = null;
-            } else {
+            if (i != headerLen) {
                 keyValLoop: for (;;) {
 
                     char curChar = header.charAt(i);
                     if (curChar == ';') {
                         // NAME; (no value till ';')
-                        newNameEnd = i;
-                        value = rawValue = null;
-                        first = false;
+                        nameEnd = i;
+                        valueStart = valueEnd = -1;
                         break keyValLoop;
+
                     } else if (curChar == '=') {
                         // NAME=VALUE
-                        newNameEnd = i;
+                        nameEnd = i;
                         i++;
                         if (i == headerLen) {
                             // NAME= (empty value, i.e. nothing after '=')
-                            value = rawValue = "";
-                            first = false;
+                            valueStart = valueEnd = 0;
                             break keyValLoop;
                         }
 
-                        int newValueStart = i;
-                        char c = header.charAt(i);
-                        if (c == '"' || c == '\'') {
-                            // NAME="VALUE" or NAME='VALUE'
-                            StringBuilder newValueBuf = new StringBuilder(header.length() - i);
-
-                            int rawValueStart = i;
-                            int rawValueEnd = i;
-
-                            final char q = c;
-                            boolean hadBackslash = false;
-                            i++;
-                            for (;;) {
-                                if (i == headerLen) {
-                                    value = newValueBuf.toString();
-                                    // only need to compute raw value for cookie
-                                    // value which is at most in 2nd position
-                                    rawValue = first ? header.substring(rawValueStart, rawValueEnd) : null;
-                                    first = false;
-                                    break keyValLoop;
-                                }
-                                if (hadBackslash) {
-                                    hadBackslash = false;
-                                    c = header.charAt(i++);
-                                    rawValueEnd = i;
-                                    switch (c) {
-                                    case '\\':
-                                    case '"':
-                                    case '\'':
-                                        // Escape last backslash.
-                                        newValueBuf.setCharAt(newValueBuf.length() - 1, c);
-                                        break;
-                                    default:
-                                        // Do not escape last backslash.
-                                        newValueBuf.append(c);
-                                    }
-                                } else {
-                                    c = header.charAt(i++);
-                                    rawValueEnd = i;
-                                    if (c == q) {
-                                        value = newValueBuf.toString();
-                                        // only need to compute raw value for
-                                        // cookie value which is at most in 2nd
-                                        // position
-                                        rawValue = first ? header.substring(rawValueStart, rawValueEnd) : null;
-                                        first = false;
-                                        break keyValLoop;
-                                    }
-                                    newValueBuf.append(c);
-                                    if (c == '\\') {
-                                        hadBackslash = true;
-                                    }
-                                }
-                            }
-                        } else {
-                            // NAME=VALUE;
-                            int semiPos = header.indexOf(';', i);
-                            if (semiPos > 0) {
-                                value = rawValue = header.substring(newValueStart, semiPos);
-                                i = semiPos;
-                            } else {
-                                value = rawValue = header.substring(newValueStart);
-                                i = headerLen;
-                            }
-                        }
+                        valueStart = i;
+                        // NAME=VALUE;
+                        int semiPos = header.indexOf(';', i);
+                        valueEnd = i = semiPos > 0 ? semiPos : headerLen;
                         break keyValLoop;
                     } else {
                         i++;
@@ -160,16 +98,182 @@ public static Cookie decode(String header, TimeConverter timeConverter) {
 
                     if (i == headerLen) {
                         // NAME (no value till the end of string)
-                        newNameEnd = headerLen;
-                        first = false;
-                        value = rawValue = null;
+                        nameEnd = headerLen;
+                        valueStart = valueEnd = -1;
                         break;
                     }
                 }
             }
 
-            pairsParser.parseKeyValuePair(header, newNameStart, newNameEnd, value, rawValue);
+            if (valueEnd > 0 && header.charAt(valueEnd - 1) == ',') {
+                // old multiple cookies separator, skipping it
+                valueEnd--;
+            }
+
+            if (cookieBuilder == null) {
+                // cookie name-value pair
+                if (nameBegin == -1 || nameBegin == nameEnd) {
+                    LOGGER.debug("Skipping cookie with null name");
+                    return null;
+                }
+
+                if (valueStart == -1) {
+                    LOGGER.debug("Skipping cookie with null value");
+                    return null;
+                }
+
+                CharSequence wrappedValue = CharBuffer.wrap(header, valueStart, valueEnd);
+                CharSequence unwrappedValue = unwrapValue(wrappedValue);
+                if (unwrappedValue == null) {
+                    LOGGER.debug("Skipping cookie because starting quotes are not properly balanced in '{}'", unwrappedValue);
+                    return null;
+                }
+
+                final String name = header.substring(nameBegin, nameEnd);
+
+                final boolean wrap = unwrappedValue.length() != valueEnd - valueStart;
+
+                cookieBuilder = new CookieBuilder(name, unwrappedValue.toString(), wrap, header);
+
+            } else {
+                // cookie attribute
+                cookieBuilder.appendAttribute(nameBegin, nameEnd, valueStart, valueEnd);
+            }
+        }
+        return cookieBuilder.cookie();
+    }
+
+    private static class CookieBuilder {
+
+        private static final String PATH = "Path";
+
+        private static final String EXPIRES = "Expires";
+
+        private static final String MAX_AGE = "Max-Age";
+
+        private static final String DOMAIN = "Domain";
+
+        private static final String SECURE = "Secure";
+
+        private static final String HTTPONLY = "HTTPOnly";
+
+        private final String name;
+        private final String value;
+        private final boolean wrap;
+        private final String header;
+        private String domain;
+        private String path;
+        private long maxAge = Long.MIN_VALUE;
+        private int expiresStart;
+        private int expiresEnd;
+        private boolean secure;
+        private boolean httpOnly;
+
+        public CookieBuilder(String name, String value, boolean wrap, String header) {
+            this.name = name;
+            this.value = value;
+            this.wrap = wrap;
+            this.header = header;
+        }
+
+        public Cookie cookie() {
+            return new Cookie(name, value, wrap, domain, path, mergeMaxAgeAndExpires(), secure, httpOnly);
+        }
+
+        private long mergeMaxAgeAndExpires() {
+            // max age has precedence over expires
+            if (maxAge != Long.MIN_VALUE) {
+                return maxAge;
+            } else {
+                String expires = computeValue(expiresStart, expiresEnd);
+                if (expires != null) {
+                    long expiresMillis = computeExpires(expires);
+                    if (expiresMillis != Long.MIN_VALUE) {
+                        long maxAgeMillis = expiresMillis - System.currentTimeMillis();
+                        return maxAgeMillis / 1000 + (maxAgeMillis % 1000 != 0 ? 1 : 0);
+                    }
+                }
+            }
+            return Long.MIN_VALUE;
+        }
+        
+        /**
+         * Parse and store a key-value pair. First one is considered to be the
+         * cookie name/value. Unknown attribute names are silently discarded.
+         *
+         * @param keyStart
+         *            where the key starts in the header
+         * @param keyEnd
+         *            where the key ends in the header
+         * @param valueStart
+         *            where the value starts in the header
+         * @param valueEnd
+         *            where the value ends in the header
+         */
+        public void appendAttribute(int keyStart, int keyEnd, int valueStart, int valueEnd) {
+            setCookieAttribute(keyStart, keyEnd, valueStart, valueEnd);
+        }
+
+        private void setCookieAttribute(int keyStart, int keyEnd, int valueStart, int valueEnd) {
+
+            int length = keyEnd - keyStart;
+
+            if (length == 4) {
+                parse4(keyStart, valueStart, valueEnd);
+            } else if (length == 6) {
+                parse6(keyStart, valueStart, valueEnd);
+            } else if (length == 7) {
+                parse7(keyStart, valueStart, valueEnd);
+            } else if (length == 8) {
+                parse8(keyStart, valueStart, valueEnd);
+            }
+        }
+
+        private void parse4(int nameStart, int valueStart, int valueEnd) {
+            if (header.regionMatches(true, nameStart, PATH, 0, 4)) {
+                path = computeValue(valueStart, valueEnd);
+            }
+        }
+
+        private void parse6(int nameStart, int valueStart, int valueEnd) {
+            if (header.regionMatches(true, nameStart, DOMAIN, 0, 5)) {
+                domain = computeValue(valueStart, valueEnd);
+            } else if (header.regionMatches(true, nameStart, SECURE, 0, 5)) {
+                secure = true;
+            }
+        }
+
+        private void parse7(int nameStart, int valueStart, int valueEnd) {
+            if (header.regionMatches(true, nameStart, EXPIRES, 0, 7)) {
+                expiresStart = valueStart;
+                expiresEnd = valueEnd;
+            } else if (header.regionMatches(true, nameStart, MAX_AGE, 0, 7)) {
+                try {
+                    maxAge = Math.max(Integer.valueOf(computeValue(valueStart, valueEnd)), 0);
+                } catch (NumberFormatException e1) {
+                    // ignore failure to parse -> treat as session cookie
+                }
+            }
+        }
+
+        private void parse8(int nameStart, int valueStart, int valueEnd) {
+            if (header.regionMatches(true, nameStart, HTTPONLY, 0, 8)) {
+                httpOnly = true;
+            }
+        }
+
+        private String computeValue(int valueStart, int valueEnd) {
+            if (valueStart == -1 || valueStart == valueEnd) {
+                return null;
+            } else {
+                while (valueStart < valueEnd && header.charAt(valueStart) <= ' ') {
+                    valueStart++;
+                }
+                while (valueStart < valueEnd && (header.charAt(valueEnd - 1) <= ' ')) {
+                    valueEnd--;
+                }
+                return valueStart == valueEnd ? null : header.substring(valueStart, valueEnd);
+            }
         }
-        return pairsParser.cookie();
     }
 }
diff --git a/api/src/main/java/org/asynchttpclient/cookie/CookieEncoder.java b/api/src/main/java/org/asynchttpclient/cookie/CookieEncoder.java
index bf895f3a4..ab657edf1 100644
--- a/api/src/main/java/org/asynchttpclient/cookie/CookieEncoder.java
+++ b/api/src/main/java/org/asynchttpclient/cookie/CookieEncoder.java
@@ -12,6 +12,8 @@
  */
 package org.asynchttpclient.cookie;
 
+import org.asynchttpclient.util.StringUtils;
+
 import java.util.Collection;
 
 public final class CookieEncoder {
@@ -20,10 +22,10 @@ private CookieEncoder() {
     }
 
     public static String encode(Collection<Cookie> cookies) {
-        StringBuilder sb = new StringBuilder();
+        StringBuilder sb = StringUtils.stringBuilder();
 
         for (Cookie cookie : cookies) {
-            add(sb, cookie.getName(), cookie.getRawValue());
+            add(sb, cookie.getName(), cookie.getValue(), cookie.isWrap());
         }
 
         if (sb.length() > 0) {
@@ -32,7 +34,7 @@ public static String encode(Collection<Cookie> cookies) {
         return sb.toString();
     }
 
-    private static void add(StringBuilder sb, String name, String val) {
+    private static void add(StringBuilder sb, String name, String val, boolean wrap) {
 
         if (val == null) {
             val = "";
@@ -40,7 +42,10 @@ private static void add(StringBuilder sb, String name, String val) {
 
         sb.append(name);
         sb.append('=');
-        sb.append(val);
+        if (wrap)
+            sb.append('"').append(val).append('"');
+        else
+            sb.append(val);
         sb.append(';');
         sb.append(' ');
     }
diff --git a/api/src/main/java/org/asynchttpclient/cookie/CookieUtil.java b/api/src/main/java/org/asynchttpclient/cookie/CookieUtil.java
new file mode 100644
index 000000000..c1cad3817
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/cookie/CookieUtil.java
@@ -0,0 +1,111 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.cookie;
+
+import java.text.ParsePosition;
+import java.util.BitSet;
+import java.util.Date;
+
+public class CookieUtil {
+
+    private static final BitSet VALID_COOKIE_VALUE_OCTETS = validCookieValueOctets();
+
+    private static final BitSet VALID_COOKIE_NAME_OCTETS = validCookieNameOctets(VALID_COOKIE_VALUE_OCTETS);
+
+    // US-ASCII characters excluding CTLs, whitespace, DQUOTE, comma, semicolon, and backslash
+    private static BitSet validCookieValueOctets() {
+
+        BitSet bits = new BitSet(8);
+        for (int i = 35; i < 127; i++) {
+            // US-ASCII characters excluding CTLs (%x00-1F / %x7F)
+            bits.set(i);
+        }
+        bits.set('"', false);  // exclude DQUOTE = %x22
+        bits.set(',', false);  // exclude comma = %x2C
+        bits.set(';', false);  // exclude semicolon = %x3B
+        bits.set('\\', false); // exclude backslash = %x5C
+        return bits;
+    }
+
+    //    token          = 1*<any CHAR except CTLs or separators>
+    //    separators     = "(" | ")" | "<" | ">" | "@"
+    //                   | "," | ";" | ":" | "\" | <">
+    //                   | "/" | "[" | "]" | "?" | "="
+    //                   | "{" | "}" | SP | HT
+    private static BitSet validCookieNameOctets(BitSet validCookieValueOctets) {
+        BitSet bits = new BitSet(8);
+        bits.or(validCookieValueOctets);
+        bits.set('(', false);
+        bits.set(')', false);
+        bits.set('<', false);
+        bits.set('>', false);
+        bits.set('@', false);
+        bits.set(':', false);
+        bits.set('/', false);
+        bits.set('[', false);
+        bits.set(']', false);
+        bits.set('?', false);
+        bits.set('=', false);
+        bits.set('{', false);
+        bits.set('}', false);
+        bits.set(' ', false);
+        bits.set('\t', false);
+        return bits;
+    }
+    
+    static int firstInvalidCookieNameOctet(CharSequence cs) {
+        return firstInvalidOctet(cs, VALID_COOKIE_NAME_OCTETS);
+    }
+
+    static int firstInvalidCookieValueOctet(CharSequence cs) {
+        return firstInvalidOctet(cs, VALID_COOKIE_VALUE_OCTETS);
+    }
+
+    static int firstInvalidOctet(CharSequence cs, BitSet bits) {
+
+        for (int i = 0; i < cs.length(); i++) {
+            char c = cs.charAt(i);
+            if (!bits.get(c)) {
+                return i;
+            }
+        }
+        return -1;
+    }
+
+    static CharSequence unwrapValue(CharSequence cs) {
+        final int len = cs.length();
+        if (len > 0 && cs.charAt(0) == '"') {
+            if (len >= 2 && cs.charAt(len - 1) == '"') {
+                // properly balanced
+                return len == 2 ? "" : cs.subSequence(1, len - 1);
+            } else {
+                return null;
+            }
+        }
+        return cs;
+    }
+
+    static long computeExpires(String expires) {
+        if (expires != null) {
+            Date expiresDate = RFC2616DateParser.get().parse(expires, new ParsePosition(0));
+            if (expiresDate != null)
+                return expiresDate.getTime();
+        }
+        
+        return Long.MIN_VALUE;
+    }
+    
+    private CookieUtil() {
+        // Unused
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/cookie/KeyValuePairsParser.java b/api/src/main/java/org/asynchttpclient/cookie/KeyValuePairsParser.java
deleted file mode 100644
index 795de30a5..000000000
--- a/api/src/main/java/org/asynchttpclient/cookie/KeyValuePairsParser.java
+++ /dev/null
@@ -1,220 +0,0 @@
-/*
- * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.cookie;
-
-import org.asynchttpclient.date.RFC2616Date;
-import org.asynchttpclient.date.RFC2616DateParser;
-import org.asynchttpclient.date.TimeConverter;
-
-/**
- * A companion for CookieDecoder that parses key-value pairs (cookie name/value
- * and attributes).
- * 
- * @author slandelle
- */
-class KeyValuePairsParser {
-
-    private final TimeConverter timeBuilder;
-    private String name;
-    private String value;
-    private String rawValue;
-    private String domain;
-    private String path;
-    private long expires = -1L;
-    private int maxAge = -1;
-    private boolean secure;
-    private boolean httpOnly;
-
-    /**
-     * @param timeBuilder used for parsing expires attribute
-     */
-    public KeyValuePairsParser(TimeConverter timeBuilder) {
-        this.timeBuilder = timeBuilder;
-    }
-
-    public Cookie cookie() {
-        return name != null ? new Cookie(name, value, rawValue, domain, path, expires, maxAge, secure, httpOnly) : null;
-    }
-
-    /**
-     * Parse and store a key-value pair. First one is considered to be the
-     * cookie name/value. Unknown attribute names are silently discarded.
-     * 
-     * @param header the HTTP header
-     * @param keyStart where the key starts in the header
-     * @param keyEnd where the key ends in the header
-     * @param value the decoded value
-     * @param rawValue the raw value (only non null for cookie value)
-     */
-    public void parseKeyValuePair(String header, int keyStart, int keyEnd, String value, String rawValue) {
-
-        if (name == null)
-            setCookieNameValue(header, keyStart, keyEnd, value, rawValue);
-        else
-            setCookieAttribute(header, keyStart, keyEnd, value);
-    }
-
-    private void setCookieNameValue(String header, int keyStart, int keyEnd, String value, String rawValue) {
-        name = header.substring(keyStart, keyEnd);
-        this.value = value;
-        this.rawValue = rawValue;
-    }
-
-    private void setCookieAttribute(String header, int keyStart, int keyEnd, String value) {
-
-        int length = keyEnd - keyStart;
-
-        if (length == 4)
-            parse4(header, keyStart, value);
-        else if (length == 6)
-            parse6(header, keyStart, value);
-        else if (length == 7)
-            parse7(header, keyStart, value);
-        else if (length == 8)
-            parse8(header, keyStart, value);
-    }
-
-    private boolean isPath(char c0, char c1, char c2, char c3) {
-        return (c0 == 'P' || c0 == 'p') && //
-                (c1 == 'a' || c1 == 'A') && //
-                (c2 == 't' || c2 == 'T') && //
-                (c3 == 'h' || c3 == 'H');
-    }
-
-    private void parse4(String header, int nameStart, String value) {
-
-        char c0 = header.charAt(nameStart);
-        char c1 = header.charAt(nameStart + 1);
-        char c2 = header.charAt(nameStart + 2);
-        char c3 = header.charAt(nameStart + 3);
-
-        if (isPath(c0, c1, c2, c3))
-            path = value;
-    }
-
-    private boolean isDomain(char c0, char c1, char c2, char c3, char c4, char c5) {
-        return (c0 == 'D' || c0 == 'd') && //
-                (c1 == 'o' || c1 == 'O') && //
-                (c2 == 'm' || c2 == 'M') && //
-                (c3 == 'a' || c3 == 'A') && //
-                (c4 == 'i' || c4 == 'I') && //
-                (c5 == 'n' || c5 == 'N');
-    }
-
-    private boolean isSecure(char c0, char c1, char c2, char c3, char c4, char c5) {
-        return (c0 == 'S' || c0 == 's') && //
-                (c1 == 'e' || c1 == 'E') && //
-                (c2 == 'c' || c2 == 'C') && //
-                (c3 == 'u' || c3 == 'U') && //
-                (c4 == 'r' || c4 == 'R') && //
-                (c5 == 'e' || c5 == 'E');
-    }
-
-    private void parse6(String header, int nameStart, String value) {
-
-        char c0 = header.charAt(nameStart);
-        char c1 = header.charAt(nameStart + 1);
-        char c2 = header.charAt(nameStart + 2);
-        char c3 = header.charAt(nameStart + 3);
-        char c4 = header.charAt(nameStart + 4);
-        char c5 = header.charAt(nameStart + 5);
-
-        if (isDomain(c0, c1, c2, c3, c4, c5))
-            domain = value;
-        else if (isSecure(c0, c1, c2, c3, c4, c5))
-            secure = true;
-    }
-
-    private boolean isExpires(char c0, char c1, char c2, char c3, char c4, char c5, char c6) {
-        return (c0 == 'E' || c0 == 'e') && //
-                (c1 == 'x' || c1 == 'X') && //
-                (c2 == 'p' || c2 == 'P') && //
-                (c3 == 'i' || c3 == 'I') && //
-                (c4 == 'r' || c4 == 'R') && //
-                (c5 == 'e' || c5 == 'E') && //
-                (c6 == 's' || c6 == 'S');
-    }
-
-    private boolean isMaxAge(char c0, char c1, char c2, char c3, char c4, char c5, char c6) {
-        return (c0 == 'M' || c0 == 'm') && //
-                (c1 == 'a' || c1 == 'A') && //
-                (c2 == 'x' || c2 == 'X') && //
-                (c3 == '-') && //
-                (c4 == 'A' || c4 == 'a') && //
-                (c5 == 'g' || c5 == 'G') && //
-                (c6 == 'e' || c6 == 'E');
-    }
-
-    private void setExpire(String value) {
-
-        RFC2616Date dateElements = new RFC2616DateParser(value).parse();
-        if (dateElements != null) {
-            try {
-                expires = timeBuilder.toTime(dateElements);
-            } catch (Exception e1) {
-                // ignore failure to parse -> treat as session cookie
-            }
-        }
-    }
-
-    private void setMaxAge(String value) {
-        try {
-            maxAge = Math.max(Integer.valueOf(value), 0);
-        } catch (NumberFormatException e1) {
-            // ignore failure to parse -> treat as session cookie
-        }
-    }
-
-    private void parse7(String header, int nameStart, String value) {
-
-        char c0 = header.charAt(nameStart);
-        char c1 = header.charAt(nameStart + 1);
-        char c2 = header.charAt(nameStart + 2);
-        char c3 = header.charAt(nameStart + 3);
-        char c4 = header.charAt(nameStart + 4);
-        char c5 = header.charAt(nameStart + 5);
-        char c6 = header.charAt(nameStart + 6);
-
-        if (isExpires(c0, c1, c2, c3, c4, c5, c6))
-            setExpire(value);
-
-        else if (isMaxAge(c0, c1, c2, c3, c4, c5, c6))
-            setMaxAge(value);
-    }
-
-    private boolean isHttpOnly(char c0, char c1, char c2, char c3, char c4, char c5, char c6, char c7) {
-        return (c0 == 'H' || c0 == 'h') && //
-                (c1 == 't' || c1 == 'T') && //
-                (c2 == 't' || c2 == 'T') && //
-                (c3 == 'p' || c3 == 'P') && //
-                (c4 == 'O' || c4 == 'o') && //
-                (c5 == 'n' || c5 == 'N') && //
-                (c6 == 'l' || c6 == 'L') && //
-                (c7 == 'y' || c7 == 'Y');
-    }
-
-    private void parse8(String header, int nameStart, String value) {
-
-        char c0 = header.charAt(nameStart);
-        char c1 = header.charAt(nameStart + 1);
-        char c2 = header.charAt(nameStart + 2);
-        char c3 = header.charAt(nameStart + 3);
-        char c4 = header.charAt(nameStart + 4);
-        char c5 = header.charAt(nameStart + 5);
-        char c6 = header.charAt(nameStart + 6);
-        char c7 = header.charAt(nameStart + 7);
-
-        if (isHttpOnly(c0, c1, c2, c3, c4, c5, c6, c7))
-            httpOnly = true;
-    }
-}
diff --git a/api/src/main/java/org/asynchttpclient/cookie/RFC2616DateParser.java b/api/src/main/java/org/asynchttpclient/cookie/RFC2616DateParser.java
new file mode 100644
index 000000000..5e39fd6d6
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/cookie/RFC2616DateParser.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.cookie;
+
+import java.text.ParsePosition;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Locale;
+import java.util.TimeZone;
+
+/**
+ * A parser for <a href="http://tools.ietf.org/html/rfc2616#section-3.3">RFC2616
+ * Date format</a>.
+ * 
+ * @author slandelle
+ */
+@SuppressWarnings("serial")
+public class RFC2616DateParser extends SimpleDateFormat {
+
+    private final SimpleDateFormat format1 = new RFC2616DateParserObsolete1();
+    private final SimpleDateFormat format2 = new RFC2616DateParserObsolete2();
+
+    private static final ThreadLocal<RFC2616DateParser> DATE_FORMAT_HOLDER = new ThreadLocal<RFC2616DateParser>() {
+        @Override
+        protected RFC2616DateParser initialValue() {
+            return new RFC2616DateParser();
+        }
+    };
+
+    public static RFC2616DateParser get() {
+        return DATE_FORMAT_HOLDER.get();
+    }
+
+    /**
+     * Standard date format<p>
+     * Sun, 06 Nov 1994 08:49:37 GMT -> E, d MMM yyyy HH:mm:ss z
+     */
+    private RFC2616DateParser() {
+        super("E, dd MMM yyyy HH:mm:ss z", Locale.ENGLISH);
+        setTimeZone(TimeZone.getTimeZone("GMT"));
+    }
+
+    @Override
+    public Date parse(String text, ParsePosition pos) {
+        Date date = super.parse(text, pos);
+        if (date == null) {
+            date = format1.parse(text, pos);
+        }
+        if (date == null) {
+            date = format2.parse(text, pos);
+        }
+        return date;
+    }
+
+    /**
+     * First obsolete format<p>
+     * Sunday, 06-Nov-94 08:49:37 GMT -> E, d-MMM-y HH:mm:ss z
+     */
+    private static final class RFC2616DateParserObsolete1 extends SimpleDateFormat {
+        private static final long serialVersionUID = -3178072504225114298L;
+
+        RFC2616DateParserObsolete1() {
+            super("E, dd-MMM-yy HH:mm:ss z", Locale.ENGLISH);
+            setTimeZone(TimeZone.getTimeZone("GMT"));
+        }
+    }
+
+    /**
+     * Second obsolete format
+     * <p>
+     * Sun Nov 6 08:49:37 1994 -> EEE, MMM d HH:mm:ss yyyy
+     */
+    private static final class RFC2616DateParserObsolete2 extends SimpleDateFormat {
+        private static final long serialVersionUID = 3010674519968303714L;
+
+        RFC2616DateParserObsolete2() {
+            super("E MMM d HH:mm:ss yyyy", Locale.ENGLISH);
+            setTimeZone(TimeZone.getTimeZone("GMT"));
+        }
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/date/CalendarTimeConverter.java b/api/src/main/java/org/asynchttpclient/date/CalendarTimeConverter.java
deleted file mode 100644
index edc3061db..000000000
--- a/api/src/main/java/org/asynchttpclient/date/CalendarTimeConverter.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.date;
-
-import java.util.Calendar;
-import java.util.GregorianCalendar;
-import java.util.TimeZone;
-
-/**
- * Calendar based TimeConverter.
- * Note that a Joda-Time or DateTime based implementation would be more efficient, but AHC doesn't have a dependency to JodaTime.
- * 
- * @author slandelle
- */
-public class CalendarTimeConverter implements TimeConverter {
-
-    public static final TimeZone GMT = TimeZone.getTimeZone("GMT");
-
-    @Override
-    public long toTime(RFC2616Date dateElements) {
-
-        Calendar calendar = new GregorianCalendar(//
-                dateElements.year(), //
-                dateElements.month() - 1, // beware, Calendar use months from 0 to 11
-                dateElements.dayOfMonth(), //
-                dateElements.hour(), //
-                dateElements.minute(), //
-                dateElements.second());
-        calendar.setTimeZone(GMT);
-        return calendar.getTimeInMillis();
-    }
-}
diff --git a/api/src/main/java/org/asynchttpclient/date/RFC2616Date.java b/api/src/main/java/org/asynchttpclient/date/RFC2616Date.java
deleted file mode 100644
index 247870bd5..000000000
--- a/api/src/main/java/org/asynchttpclient/date/RFC2616Date.java
+++ /dev/null
@@ -1,144 +0,0 @@
-/*
- * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.date;
-
-/**
- * A placeholder for RFC2616 date elements
- * 
- * @author slandelle
- */
-public final class RFC2616Date {
-
-    private final int year;
-    // 1 to 12
-    private final int month;
-    private final int dayOfMonth;
-    private final int hour;
-    private final int minute;
-    private final int second;
-
-    public RFC2616Date(int year, int month, int dayOfMonth, int hour, int minute, int second) {
-        this.year = year;
-        this.month = month;
-        this.dayOfMonth = dayOfMonth;
-        this.hour = hour;
-        this.minute = minute;
-        this.second = second;
-    }
-
-    public int year() {
-        return year;
-    }
-
-    public int month() {
-        return month;
-    }
-
-    public int dayOfMonth() {
-        return dayOfMonth;
-    }
-
-    public int hour() {
-        return hour;
-    }
-
-    public int minute() {
-        return minute;
-    }
-
-    public int second() {
-        return second;
-    }
-
-    public static final class Builder {
-
-        private int dayOfMonth;
-        private int month;
-        private int year;
-        private int hour;
-        private int minute;
-        private int second;
-
-        public void setDayOfMonth(int dayOfMonth) {
-            this.dayOfMonth = dayOfMonth;
-        }
-
-        public void setJanuary() {
-            month = 1;
-        }
-
-        public void setFebruary() {
-            month = 2;
-        }
-
-        public void setMarch() {
-            month = 3;
-        }
-
-        public void setApril() {
-            month = 4;
-        }
-
-        public void setMay() {
-            month = 5;
-        }
-
-        public void setJune() {
-            month = 6;
-        }
-
-        public void setJuly() {
-            month = 7;
-        }
-
-        public void setAugust() {
-            month = 8;
-        }
-
-        public void setSeptember() {
-            month = 9;
-        }
-
-        public void setOctobre() {
-            month = 10;
-        }
-
-        public void setNovembre() {
-            month = 11;
-        }
-
-        public void setDecember() {
-            month = 12;
-        }
-
-        public void setYear(int year) {
-            this.year = year;
-        }
-
-        public void setHour(int hour) {
-            this.hour = hour;
-        }
-
-        public void setMinute(int minute) {
-            this.minute = minute;
-        }
-
-        public void setSecond(int second) {
-            this.second = second;
-        }
-
-        public RFC2616Date build() {
-            return new RFC2616Date(year, month, dayOfMonth, hour, minute, second);
-        }
-    }
-}
diff --git a/api/src/main/java/org/asynchttpclient/date/RFC2616DateParser.java b/api/src/main/java/org/asynchttpclient/date/RFC2616DateParser.java
deleted file mode 100644
index effc5168a..000000000
--- a/api/src/main/java/org/asynchttpclient/date/RFC2616DateParser.java
+++ /dev/null
@@ -1,434 +0,0 @@
-/*
- * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.date;
-
-import org.asynchttpclient.date.RFC2616Date.Builder;
-
-/**
- * A parser for <a href="http://tools.ietf.org/html/rfc2616#section-3.3">RFC2616
- * Date format</a>.
- * 
- * @author slandelle
- */
-public class RFC2616DateParser {
-
-    private final String string;
-    private final int offset;
-    private final int length;
-
-    /**
-     * @param string a string that will be fully parsed
-     */
-    public RFC2616DateParser(String string) {
-        this(string, 0, string.length());
-    }
-
-    /**
-     * @param string the string to be parsed
-     * @param offset the offset where to start parsing
-     * @param length the number of chars to parse
-     */
-    public RFC2616DateParser(String string, int offset, int length) {
-
-        if (string.length() + offset < length)
-            throw new IllegalArgumentException("String length doesn't match offset and length");
-
-        this.string = string;
-        this.offset = offset;
-        this.length = length;
-    }
-
-    private static class Tokens {
-        public final int[] starts;
-        public final int[] ends;
-        public final int length;
-
-        public Tokens(int[] starts, int[] ends, int length) {
-            this.starts = starts;
-            this.ends = ends;
-            this.length = length;
-        }
-    }
-
-    private Tokens tokenize() {
-
-        int[] starts = new int[8];
-        int[] ends = new int[8];
-        boolean inToken = false;
-        int tokenCount = 0;
-
-        int end = offset + length;
-        for (int i = offset; i < end; i++) {
-
-            char c = string.charAt(i);
-            if (c == ' ' || c == ',' || c == '-' || c == ':') {
-                if (inToken) {
-                    ends[tokenCount++] = i;
-                    inToken = false;
-                }
-            } else if (!inToken) {
-                starts[tokenCount] = i;
-                inToken = true;
-            }
-        }
-
-        // finish lastToken
-        if (inToken == true)
-            ends[tokenCount++] = end;
-
-        return new Tokens(starts, ends, tokenCount);
-    }
-
-    /**
-     * @param validate if validation is to be enabled of non-critical elements,
-     *            such as day of week and timezone
-     * @return null is the string is not a valid RFC2616 date
-     */
-    public RFC2616Date parse() {
-
-        Tokens tokens = tokenize();
-
-        if (tokens.length != 7 && tokens.length != 8)
-            return null;
-
-        // 1st token is ignored: ignore day of week
-        // 8th token is ignored: supposed to always be GMT
-
-        if (isDigit(string.charAt(tokens.starts[1])))
-            return buildDate(tokens);
-        else
-            return buildANSICDate(tokens);
-    }
-
-    private RFC2616Date buildDate(Tokens tokens) {
-
-        // Sun, 06 Nov 1994 08:49:37 GMT
-
-        Builder dateBuilder = new Builder();
-
-        if (isValidDayOfMonth(tokens.starts[1], tokens.ends[1], dateBuilder) && //
-                isValidMonth(tokens.starts[2], tokens.ends[2], dateBuilder) && //
-                isValidYear(tokens.starts[3], tokens.ends[3], dateBuilder) && //
-                isValidHour(tokens.starts[4], tokens.ends[4], dateBuilder) && //
-                isValidMinuteSecond(tokens.starts[5], tokens.ends[5], dateBuilder, true) && //
-                isValidMinuteSecond(tokens.starts[6], tokens.ends[6], dateBuilder, false)) {
-            return dateBuilder.build();
-        }
-
-        return null;
-    }
-
-    private RFC2616Date buildANSICDate(Tokens tokens) {
-
-        // Sun Nov 6 08:49:37 1994
-
-        Builder dateBuilder = new Builder();
-
-        if (isValidMonth(tokens.starts[1], tokens.ends[1], dateBuilder) && //
-                isValidDayOfMonth(tokens.starts[2], tokens.ends[2], dateBuilder) && //
-                isValidHour(tokens.starts[3], tokens.ends[3], dateBuilder) && //
-                isValidMinuteSecond(tokens.starts[4], tokens.ends[4], dateBuilder, true) && //
-                isValidMinuteSecond(tokens.starts[5], tokens.ends[5], dateBuilder, false) && //
-                isValidYear(tokens.starts[6], tokens.ends[6], dateBuilder)) {
-            return dateBuilder.build();
-        }
-
-        return null;
-    }
-
-    private boolean isValid1DigitDayOfMonth(char c0, Builder dateBuilder) {
-        if (isDigit(c0)) {
-            dateBuilder.setDayOfMonth(getNumericValue(c0));
-            return true;
-        }
-        return false;
-    }
-
-    private boolean isValid2DigitsDayOfMonth(char c0, char c1, Builder dateBuilder) {
-        if (isDigit(c0) && isDigit(c1)) {
-            int i0 = getNumericValue(c0);
-            int i1 = getNumericValue(c1);
-            int day = i0 * 10 + i1;
-            if (day <= 31) {
-                dateBuilder.setDayOfMonth(day);
-                return true;
-            }
-        }
-        return false;
-    }
-
-    private boolean isValidDayOfMonth(int start, int end, Builder dateBuilder) {
-
-        int tokenLength = end - start;
-
-        if (tokenLength == 1) {
-            char c0 = string.charAt(start);
-            return isValid1DigitDayOfMonth(c0, dateBuilder);
-
-        } else if (tokenLength == 2) {
-            char c0 = string.charAt(start);
-            char c1 = string.charAt(start + 1);
-            return isValid2DigitsDayOfMonth(c0, c1, dateBuilder);
-        }
-        return false;
-    }
-
-    private boolean isValidJanuaryJuneJuly(char c0, char c1, char c2, Builder dateBuilder) {
-        if (c0 == 'J' || c0 == 'j')
-            if (c1 == 'a' || c1 == 'A') {
-                if (c2 == 'n' || c2 == 'N') {
-                    dateBuilder.setJanuary();
-                    return true;
-                }
-            } else if (c1 == 'u' || c1 == 'U') {
-                if (c2 == 'n' || c2 == 'N') {
-                    dateBuilder.setJune();
-                    return true;
-                } else if (c2 == 'l' || c2 == 'L') {
-                    dateBuilder.setJuly();
-                    return true;
-                }
-            }
-        return false;
-    }
-
-    private boolean isValidFebruary(char c0, char c1, char c2, Builder dateBuilder) {
-        if ((c0 == 'F' || c0 == 'f') && (c1 == 'e' || c1 == 'E') && (c2 == 'b' || c2 == 'B')) {
-            dateBuilder.setFebruary();
-            return true;
-        }
-        return false;
-    }
-
-    private boolean isValidMarchMay(char c0, char c1, char c2, Builder dateBuilder) {
-        if ((c0 == 'M' || c0 == 'm') && (c1 == 'a' || c1 == 'A')) {
-            if (c2 == 'r' || c2 == 'R') {
-                dateBuilder.setMarch();
-                return true;
-            } else if (c2 == 'y' || c2 == 'M') {
-                dateBuilder.setMay();
-                return true;
-            }
-        }
-        return false;
-    }
-
-    private boolean isValidAprilAugust(char c0, char c1, char c2, Builder dateBuilder) {
-        if (c0 == 'A' || c0 == 'a')
-            if ((c1 == 'p' || c1 == 'P') && (c2 == 'r' || c2 == 'R')) {
-                dateBuilder.setApril();
-                return true;
-            } else if ((c1 == 'u' || c1 == 'U') && (c2 == 'g' || c2 == 'G')) {
-                dateBuilder.setAugust();
-                return true;
-            }
-        return false;
-    }
-
-    private boolean isValidSeptember(char c0, char c1, char c2, Builder dateBuilder) {
-        if ((c0 == 'S' || c0 == 's') && (c1 == 'e' || c1 == 'E') && (c2 == 'p' || c2 == 'P')) {
-            dateBuilder.setSeptember();
-            return true;
-        }
-        return false;
-    }
-
-    private boolean isValidOctober(char c0, char c1, char c2, Builder dateBuilder) {
-        if ((c0 == 'O' || c0 == 'o') && (c1 == 'c' || c1 == 'C') && (c2 == 't' || c2 == 'T')) {
-            dateBuilder.setOctobre();
-            return true;
-        }
-        return false;
-    }
-
-    private boolean isValidNovember(char c0, char c1, char c2, Builder dateBuilder) {
-        if ((c0 == 'N' || c0 == 'n') && (c1 == 'o' || c1 == 'O') && (c2 == 'v' || c2 == 'V')) {
-            dateBuilder.setNovembre();
-            return true;
-        }
-        return false;
-    }
-
-    private boolean isValidDecember(char c0, char c1, char c2, Builder dateBuilder) {
-        if (c0 == 'D' || c0 == 'd')
-            if (c1 == 'e' || c1 == 'E') {
-                if (c2 == 'c' || c2 == 'C') {
-                    dateBuilder.setDecember();
-                    return true;
-                }
-            }
-        return false;
-    }
-
-    private boolean isValidMonth(int start, int end, Builder dateBuilder) {
-
-        if (end - start != 3)
-            return false;
-
-        char c0 = string.charAt(start);
-        char c1 = string.charAt(start + 1);
-        char c2 = string.charAt(start + 2);
-
-        return isValidJanuaryJuneJuly(c0, c1, c2, dateBuilder) || //
-                isValidFebruary(c0, c1, c2, dateBuilder) || //
-                isValidMarchMay(c0, c1, c2, dateBuilder) || //
-                isValidAprilAugust(c0, c1, c2, dateBuilder) || //
-                isValidSeptember(c0, c1, c2, dateBuilder) || //
-                isValidOctober(c0, c1, c2, dateBuilder) || //
-                isValidNovember(c0, c1, c2, dateBuilder) || //
-                isValidDecember(c0, c1, c2, dateBuilder);
-    }
-
-    private boolean isValid2DigitsYear(char c0, char c1, Builder dateBuilder) {
-        if (isDigit(c0) && isDigit(c1)) {
-            int i0 = getNumericValue(c0);
-            int i1 = getNumericValue(c1);
-            int year = i0 * 10 + i1;
-            year = year < 70 ? year + 2000 : year + 1900;
-
-            return setValidYear(year, dateBuilder);
-        }
-        return false;
-    }
-
-    private boolean isValid4DigitsYear(char c0, char c1, char c2, char c3, Builder dateBuilder) {
-        if (isDigit(c0) && isDigit(c1) && isDigit(c2) && isDigit(c3)) {
-            int i0 = getNumericValue(c0);
-            int i1 = getNumericValue(c1);
-            int i2 = getNumericValue(c2);
-            int i3 = getNumericValue(c3);
-            int year = i0 * 1000 + i1 * 100 + i2 * 10 + i3;
-
-            return setValidYear(year, dateBuilder);
-        }
-        return false;
-    }
-
-    private boolean setValidYear(int year, Builder dateBuilder) {
-        if (year >= 1601) {
-            dateBuilder.setYear(year);
-            return true;
-        }
-        return false;
-    }
-
-    private boolean isValidYear(int start, int end, Builder dateBuilder) {
-
-        int length = end - start;
-
-        if (length == 2) {
-            char c0 = string.charAt(start);
-            char c1 = string.charAt(start + 1);
-            return isValid2DigitsYear(c0, c1, dateBuilder);
-
-        } else if (length == 4) {
-            char c0 = string.charAt(start);
-            char c1 = string.charAt(start + 1);
-            char c2 = string.charAt(start + 2);
-            char c3 = string.charAt(start + 3);
-            return isValid4DigitsYear(c0, c1, c2, c3, dateBuilder);
-        }
-
-        return false;
-    }
-
-    private boolean isValid1DigitHour(char c0, Builder dateBuilder) {
-        if (isDigit(c0)) {
-            int hour = getNumericValue(c0);
-            dateBuilder.setHour(hour);
-            return true;
-        }
-        return false;
-    }
-
-    private boolean isValid2DigitsHour(char c0, char c1, Builder dateBuilder) {
-        if (isDigit(c0) && isDigit(c1)) {
-            int i0 = getNumericValue(c0);
-            int i1 = getNumericValue(c1);
-            int hour = i0 * 10 + i1;
-            if (hour <= 24) {
-                dateBuilder.setHour(hour);
-                return true;
-            }
-        }
-        return false;
-    }
-
-    private boolean isValidHour(int start, int end, Builder dateBuilder) {
-
-        int length = end - start;
-
-        if (length == 1) {
-            char c0 = string.charAt(start);
-            return isValid1DigitHour(c0, dateBuilder);
-
-        } else if (length == 2) {
-            char c0 = string.charAt(start);
-            char c1 = string.charAt(start + 1);
-            return isValid2DigitsHour(c0, c1, dateBuilder);
-        }
-        return false;
-    }
-
-    private boolean isValid1DigitMinuteSecond(char c0, Builder dateBuilder, boolean minuteOrSecond) {
-        if (isDigit(c0)) {
-            int value = getNumericValue(c0);
-            if (minuteOrSecond)
-                dateBuilder.setMinute(value);
-            else
-                dateBuilder.setSecond(value);
-            return true;
-        }
-        return false;
-    }
-
-    private boolean isValid2DigitsMinuteSecond(char c0, char c1, Builder dateBuilder, boolean minuteOrSecond) {
-        if (isDigit(c0) && isDigit(c1)) {
-            int i0 = getNumericValue(c0);
-            int i1 = getNumericValue(c1);
-            int value = i0 * 10 + i1;
-            if (value <= 60) {
-                if (minuteOrSecond)
-                    dateBuilder.setMinute(value);
-                else
-                    dateBuilder.setSecond(value);
-                return true;
-            }
-        }
-        return false;
-    }
-
-    private boolean isValidMinuteSecond(int start, int end, Builder dateBuilder, boolean minuteOrSecond) {
-
-        int length = end - start;
-
-        if (length == 1) {
-            char c0 = string.charAt(start);
-            return isValid1DigitMinuteSecond(c0, dateBuilder, minuteOrSecond);
-
-        } else if (length == 2) {
-            char c0 = string.charAt(start);
-            char c1 = string.charAt(start + 1);
-            return isValid2DigitsMinuteSecond(c0, c1, dateBuilder, minuteOrSecond);
-        }
-        return false;
-    }
-
-    private boolean isDigit(char c) {
-        return c >= '0' && c <= '9';
-    }
-
-    private int getNumericValue(char c) {
-        return (int) c - 48;
-    }
-}
diff --git a/api/src/main/java/org/asynchttpclient/extra/AsyncHandlerWrapper.java b/api/src/main/java/org/asynchttpclient/extra/AsyncHandlerWrapper.java
index 3ce952727..7738990df 100644
--- a/api/src/main/java/org/asynchttpclient/extra/AsyncHandlerWrapper.java
+++ b/api/src/main/java/org/asynchttpclient/extra/AsyncHandlerWrapper.java
@@ -45,7 +45,7 @@ public void onThrowable(Throwable t) {
      * {@inheritDoc}
      */
     @Override
-    public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+    public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
         return asyncHandler.onBodyPartReceived(bodyPart);
     }
 
@@ -53,7 +53,7 @@ public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception
      * {@inheritDoc}
      */
     @Override
-    public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+    public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
         return asyncHandler.onStatusReceived(responseStatus);
     }
 
@@ -61,7 +61,7 @@ public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exceptio
      * {@inheritDoc}
      */
     @Override
-    public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
+    public State onHeadersReceived(HttpResponseHeaders headers) throws Exception {
         return asyncHandler.onHeadersReceived(headers);
     }
 
diff --git a/api/src/main/java/org/asynchttpclient/extra/ResumableRandomAccessFileListener.java b/api/src/main/java/org/asynchttpclient/extra/ResumableRandomAccessFileListener.java
index 7b0dd64b9..0faf10348 100644
--- a/api/src/main/java/org/asynchttpclient/extra/ResumableRandomAccessFileListener.java
+++ b/api/src/main/java/org/asynchttpclient/extra/ResumableRandomAccessFileListener.java
@@ -14,14 +14,14 @@
 
 import static org.asynchttpclient.util.MiscUtils.closeSilently;
 
-import org.asynchttpclient.resumable.ResumableListener;
+import org.asynchttpclient.handler.resumable.ResumableListener;
 
 import java.io.IOException;
 import java.io.RandomAccessFile;
 import java.nio.ByteBuffer;
 
 /**
- * A {@link org.asynchttpclient.resumable.ResumableListener} which use a {@link RandomAccessFile} for storing the received bytes.
+ * A {@link org.asynchttpclient.handler.resumable.ResumableListener} which use a {@link RandomAccessFile} for storing the received bytes.
  */
 public class ResumableRandomAccessFileListener implements ResumableListener {
     private final RandomAccessFile file;
diff --git a/api/src/main/java/org/asynchttpclient/extra/ThrottleRequestFilter.java b/api/src/main/java/org/asynchttpclient/extra/ThrottleRequestFilter.java
index 7dd44d34a..198fbbe61 100644
--- a/api/src/main/java/org/asynchttpclient/extra/ThrottleRequestFilter.java
+++ b/api/src/main/java/org/asynchttpclient/extra/ThrottleRequestFilter.java
@@ -61,7 +61,7 @@ public ThrottleRequestFilter(int maxConnections, int maxWait, boolean fair) {
             throw new FilterException(String.format("Interrupted Request %s with AsyncHandler %s", ctx.getRequest(), ctx.getAsyncHandler()));
         }
 
-        return new FilterContext.FilterContextBuilder<T>(ctx).asyncHandler(new AsyncHandlerWrapper<T>(ctx.getAsyncHandler(), available))
+        return new FilterContext.FilterContextBuilder<>(ctx).asyncHandler(new AsyncHandlerWrapper<>(ctx.getAsyncHandler(), available))
                 .build();
     }
 }
\ No newline at end of file
diff --git a/api/src/main/java/org/asynchttpclient/filter/FilterContext.java b/api/src/main/java/org/asynchttpclient/filter/FilterContext.java
index dfc6f9de2..286b19bd7 100644
--- a/api/src/main/java/org/asynchttpclient/filter/FilterContext.java
+++ b/api/src/main/java/org/asynchttpclient/filter/FilterContext.java
@@ -154,7 +154,7 @@ public Request getRequest() {
         }
 
         public FilterContext<T> build() {
-            return new FilterContext<T>(this);
+            return new FilterContext<>(this);
         }
     }
 
diff --git a/api/src/main/java/org/asynchttpclient/listenable/AbstractListenableFuture.java b/api/src/main/java/org/asynchttpclient/future/AbstractListenableFuture.java
similarity index 98%
rename from api/src/main/java/org/asynchttpclient/listenable/AbstractListenableFuture.java
rename to api/src/main/java/org/asynchttpclient/future/AbstractListenableFuture.java
index be0d81842..0cf69728d 100644
--- a/api/src/main/java/org/asynchttpclient/listenable/AbstractListenableFuture.java
+++ b/api/src/main/java/org/asynchttpclient/future/AbstractListenableFuture.java
@@ -26,12 +26,12 @@
  * limitations under the License.
  */
 
-package org.asynchttpclient.listenable;
-
-import org.asynchttpclient.ListenableFuture;
+package org.asynchttpclient.future;
 
 import java.util.concurrent.Executor;
 
+import org.asynchttpclient.ListenableFuture;
+
 /**
  * <p>An abstract base implementation of the listener support provided by
  * {@link ListenableFuture}. This class uses an {@link ExecutionList} to
diff --git a/api/src/main/java/org/asynchttpclient/listenable/ExecutionList.java b/api/src/main/java/org/asynchttpclient/future/ExecutionList.java
similarity index 98%
rename from api/src/main/java/org/asynchttpclient/listenable/ExecutionList.java
rename to api/src/main/java/org/asynchttpclient/future/ExecutionList.java
index 99347e792..50364f7bd 100644
--- a/api/src/main/java/org/asynchttpclient/listenable/ExecutionList.java
+++ b/api/src/main/java/org/asynchttpclient/future/ExecutionList.java
@@ -26,7 +26,7 @@
  * limitations under the License.
  */
 
-package org.asynchttpclient.listenable;
+package org.asynchttpclient.future;
 
 import java.util.Queue;
 import java.util.concurrent.Executor;
@@ -51,7 +51,7 @@
     private static final Logger log = Logger.getLogger(ExecutionList.class.getName());
 
     // The runnable,executor pairs to execute.
-    private final Queue<RunnableExecutorPair> runnables = new LinkedBlockingQueue<RunnableExecutorPair>();
+    private final Queue<RunnableExecutorPair> runnables = new LinkedBlockingQueue<>();
 
     // Boolean we use mark when execution has started.  Only accessed from within
     // synchronized blocks.
diff --git a/api/src/main/java/org/asynchttpclient/generators/InputStreamBodyGenerator.java b/api/src/main/java/org/asynchttpclient/generators/InputStreamBodyGenerator.java
deleted file mode 100644
index 34be273b9..000000000
--- a/api/src/main/java/org/asynchttpclient/generators/InputStreamBodyGenerator.java
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.generators;
-
-import org.asynchttpclient.Body;
-import org.asynchttpclient.BodyGenerator;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.nio.ByteBuffer;
-
-/**
- * A {@link BodyGenerator} which use an {@link InputStream} for reading bytes, without having to read the entire stream in memory.
- * <p/>
- * NOTE: The {@link InputStream} must support the {@link InputStream#mark} and {@link java.io.InputStream#reset()} operation. If not, mechanisms like authentication, redirect, or
- * resumable download will not works.
- */
-public class InputStreamBodyGenerator implements BodyGenerator {
-
-    private final InputStream inputStream;
-
-    public InputStreamBodyGenerator(InputStream inputStream) {
-        this.inputStream = inputStream;
-    }
-
-    public InputStream getInputStream() {
-        return inputStream;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public Body createBody() throws IOException {
-        return new InputStreamBody(inputStream);
-    }
-
-    private static class InputStreamBody implements Body {
-
-        private static final Logger LOGGER = LoggerFactory.getLogger(InputStreamBody.class);
-
-        private final InputStream inputStream;
-        private byte[] chunk;
-
-        private InputStreamBody(InputStream inputStream) {
-            this.inputStream = inputStream;
-            if (inputStream.markSupported()) {
-                inputStream.mark(0);
-            } else {
-                LOGGER.info("inputStream.markSupported() not supported. Some features will not work.");
-            }
-        }
-
-        public long getContentLength() {
-            return -1L;
-        }
-
-        public long read(ByteBuffer buffer) throws IOException {
-
-            // To be safe.
-            chunk = new byte[buffer.remaining() - 10];
-
-            int read = -1;
-            try {
-                read = inputStream.read(chunk);
-            } catch (IOException ex) {
-                LOGGER.warn("Unable to read", ex);
-            }
-
-            if (read > 0) {
-                buffer.put(chunk, 0, read);
-            } else {
-                if (inputStream.markSupported()) {
-                    inputStream.reset();
-                }
-            }
-            return read;
-        }
-
-        public void close() throws IOException {
-            inputStream.close();
-        }
-    }
-}
diff --git a/api/src/main/java/org/asynchttpclient/AsyncHandlerExtensions.java b/api/src/main/java/org/asynchttpclient/handler/AsyncHandlerExtensions.java
similarity index 53%
rename from api/src/main/java/org/asynchttpclient/AsyncHandlerExtensions.java
rename to api/src/main/java/org/asynchttpclient/handler/AsyncHandlerExtensions.java
index 1d81570b0..67bcdb1dc 100644
--- a/api/src/main/java/org/asynchttpclient/AsyncHandlerExtensions.java
+++ b/api/src/main/java/org/asynchttpclient/handler/AsyncHandlerExtensions.java
@@ -10,51 +10,76 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient;
+package org.asynchttpclient.handler;
+
+import java.net.InetAddress;
+
+import org.asynchttpclient.AsyncHandler;
 
 /**
  * This interface hosts new low level callback methods on {@link AsyncHandler}.
- * For now, those methods are in a dedicated interface in order not to break the existing API,
- * but could be merged into one of the existing ones in AHC 2.
+ * For now, those methods are in a dedicated interface in order not to break the
+ * existing API, but could be merged into one of the existing ones in AHC 2.
  * 
- * More additional hooks might come, such as:
- * <ul>
- *   <li>onConnectionClosed()</li>
- *   <li>onBytesSent(long numberOfBytes)</li>
- *   <li>onBytesReceived(long numberOfBytes)</li>
- * </ul>
  */
 public interface AsyncHandlerExtensions {
 
     /**
      * Notify the callback when trying to open a new connection.
      */
-    void onOpenConnection();
+    void onConnectionOpen();
 
     /**
      * Notify the callback when a new connection was successfully opened.
+     * 
+     * @param connection the connection
      */
-    void onConnectionOpen();
+    void onConnectionOpened(Object connection);
 
     /**
      * Notify the callback when trying to fetch a connection from the pool.
      */
-    void onPoolConnection();
+    void onConnectionPool();
+
+    /**
+     * Notify the callback when a new connection was successfully fetched from
+     * the pool.
+     * 
+     * @param connection the connection
+     */
+    void onConnectionPooled(Object connection);
 
     /**
-     * Notify the callback when a new connection was successfully fetched from the pool.
+     * Notify the callback when trying to offer a connection to the pool.
+     * 
+     * @param connection the connection
      */
-    void onConnectionPooled();
+    void onConnectionOffer(Object connection);
 
     /**
-     * Notify the callback when a request is being written on the wire.
-     * If the original request causes multiple requests to be sent, for example, because of authorization or retry,
-     * it will be notified multiple times.
+     * Notify the callback when a request is being written on the wire. If the
+     * original request causes multiple requests to be sent, for example,
+     * because of authorization or retry, it will be notified multiple times.
+     * 
+     * @param request the real request object as passed to the provider
      */
-    void onSendRequest();
+    void onRequestSend(Object request);
 
     /**
      * Notify the callback every time a request is being retried.
      */
     void onRetry();
+
+    /**
+     * Notify the callback after DNS resolution has completed.
+     * 
+     * @param address the resolved address
+     */
+    void onDnsResolved(InetAddress address);
+
+    /**
+     * Notify the callback when the SSL handshake performed to establish an
+     * HTTPS connection has been completed.
+     */
+    void onSslHandshakeCompleted();
 }
diff --git a/api/src/main/java/org/asynchttpclient/BodyDeferringAsyncHandler.java b/api/src/main/java/org/asynchttpclient/handler/BodyDeferringAsyncHandler.java
similarity index 94%
rename from api/src/main/java/org/asynchttpclient/BodyDeferringAsyncHandler.java
rename to api/src/main/java/org/asynchttpclient/handler/BodyDeferringAsyncHandler.java
index 4ab5b30be..b5d252c38 100644
--- a/api/src/main/java/org/asynchttpclient/BodyDeferringAsyncHandler.java
+++ b/api/src/main/java/org/asynchttpclient/handler/BodyDeferringAsyncHandler.java
@@ -10,7 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient;
+package org.asynchttpclient.handler;
 
 import java.io.FilterInputStream;
 import java.io.IOException;
@@ -21,6 +21,12 @@
 import java.util.concurrent.Future;
 import java.util.concurrent.Semaphore;
 
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.Response;
+
 /**
  * An AsyncHandler that returns Response (without body, so status code and
  * headers only) as fast as possible for inspection, but leaves you the option
@@ -72,6 +78,7 @@
  * </pre>
  */
 public class BodyDeferringAsyncHandler implements AsyncHandler<Response> {
+
     private final Response.ResponseBuilder responseBuilder = new Response.ResponseBuilder();
 
     private final CountDownLatch headersArrived = new CountDownLatch(1);
@@ -114,18 +121,18 @@ public void onThrowable(Throwable t) {
         }
     }
 
-    public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+    public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
         responseBuilder.reset();
         responseBuilder.accumulate(responseStatus);
-        return STATE.CONTINUE;
+        return State.CONTINUE;
     }
 
-    public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
+    public State onHeadersReceived(HttpResponseHeaders headers) throws Exception {
         responseBuilder.accumulate(headers);
-        return STATE.CONTINUE;
+        return State.CONTINUE;
     }
 
-    public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+    public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
         // body arrived, flush headers
         if (!responseSet) {
             response = responseBuilder.build();
@@ -134,7 +141,7 @@ public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception
         }
 
         bodyPart.writeTo(output);
-        return STATE.CONTINUE;
+        return State.CONTINUE;
     }
 
     protected void closeOut() throws IOException {
diff --git a/api/src/main/java/org/asynchttpclient/MaxRedirectException.java b/api/src/main/java/org/asynchttpclient/handler/MaxRedirectException.java
similarity index 74%
rename from api/src/main/java/org/asynchttpclient/MaxRedirectException.java
rename to api/src/main/java/org/asynchttpclient/handler/MaxRedirectException.java
index f39f70d90..e6ca7a51a 100644
--- a/api/src/main/java/org/asynchttpclient/MaxRedirectException.java
+++ b/api/src/main/java/org/asynchttpclient/handler/MaxRedirectException.java
@@ -14,7 +14,9 @@
  * under the License.
  *
  */
-package org.asynchttpclient;
+package org.asynchttpclient.handler;
+
+import org.asynchttpclient.AsyncHttpClientConfig;
 
 /**
  * Thrown when the {@link AsyncHttpClientConfig#getMaxRedirects()} has been reached.
@@ -22,19 +24,7 @@
 public class MaxRedirectException extends Exception {
     private static final long serialVersionUID = 1L;
 
-    public MaxRedirectException() {
-        super();
-    }
-
     public MaxRedirectException(String msg) {
-        super(msg);
-    }
-
-    public MaxRedirectException(Throwable cause) {
-        super(cause);
-    }
-
-    public MaxRedirectException(String message, Throwable cause) {
-        super(message, cause);
+        super(msg, null, true, false);
     }
-}
\ No newline at end of file
+}
diff --git a/api/src/main/java/org/asynchttpclient/ProgressAsyncHandler.java b/api/src/main/java/org/asynchttpclient/handler/ProgressAsyncHandler.java
similarity index 81%
rename from api/src/main/java/org/asynchttpclient/ProgressAsyncHandler.java
rename to api/src/main/java/org/asynchttpclient/handler/ProgressAsyncHandler.java
index bde0d5dd5..e46fcea10 100644
--- a/api/src/main/java/org/asynchttpclient/ProgressAsyncHandler.java
+++ b/api/src/main/java/org/asynchttpclient/handler/ProgressAsyncHandler.java
@@ -10,7 +10,10 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient;
+package org.asynchttpclient.handler;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.Request;
 
 /**
  * An extended {@link AsyncHandler} with two extra callback who get invoked during the content upload to a remote server.
@@ -22,17 +25,17 @@
      * Invoked when the content (a {@link java.io.File}, {@link String} or {@link java.io.FileInputStream} has been fully
      * written on the I/O socket.
      *
-     * @return a {@link AsyncHandler.STATE} telling to CONTINUE or ABORT the current processing.
+     * @return a {@link AsyncHandler.State} telling to CONTINUE or ABORT the current processing.
      */
-    STATE onHeaderWriteCompleted();
+    State onHeadersWritten();
 
     /**
      * Invoked when the content (a {@link java.io.File}, {@link String} or {@link java.io.FileInputStream} has been fully
      * written on the I/O socket.
      *
-     * @return a {@link AsyncHandler.STATE} telling to CONTINUE or ABORT the current processing.
+     * @return a {@link AsyncHandler.State} telling to CONTINUE or ABORT the current processing.
      */
-    STATE onContentWriteCompleted();
+    State onContentWritten();
 
     /**
      * Invoked when the I/O operation associated with the {@link Request} body wasn't fully written in a single I/O write
@@ -41,7 +44,7 @@
      * @param amount  The amount of bytes to transfer.
      * @param current The amount of bytes transferred
      * @param total   The total number of bytes transferred
-     * @return a {@link AsyncHandler.STATE} telling to CONTINUE or ABORT the current processing.
+     * @return a {@link AsyncHandler.State} telling to CONTINUE or ABORT the current processing.
      */
-    STATE onContentWriteProgress(long amount, long current, long total);
+    State onContentWriteProgress(long amount, long current, long total);
 }
diff --git a/api/src/main/java/org/asynchttpclient/handler/StreamedAsyncHandler.java b/api/src/main/java/org/asynchttpclient/handler/StreamedAsyncHandler.java
new file mode 100644
index 000000000..e05ff2ddf
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/handler/StreamedAsyncHandler.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.handler;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.reactivestreams.Publisher;
+
+/**
+ * AsyncHandler that uses reactive streams to handle the request.
+ */
+public interface StreamedAsyncHandler<T> extends AsyncHandler<T> {
+
+    /**
+     * Called when the body is received. May not be called if there's no body.
+     *
+     * @param publisher The publisher of response body parts.
+     * @return Whether to continue or abort.
+     */
+    State onStream(Publisher<HttpResponseBodyPart> publisher);
+}
diff --git a/api/src/main/java/org/asynchttpclient/listener/TransferCompletionHandler.java b/api/src/main/java/org/asynchttpclient/handler/TransferCompletionHandler.java
similarity index 84%
rename from api/src/main/java/org/asynchttpclient/listener/TransferCompletionHandler.java
rename to api/src/main/java/org/asynchttpclient/handler/TransferCompletionHandler.java
index b39930dff..e95000e9a 100644
--- a/api/src/main/java/org/asynchttpclient/listener/TransferCompletionHandler.java
+++ b/api/src/main/java/org/asynchttpclient/handler/TransferCompletionHandler.java
@@ -10,7 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.listener;
+package org.asynchttpclient.handler;
 
 import org.asynchttpclient.AsyncCompletionHandlerBase;
 import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
@@ -58,9 +58,13 @@
  */
 public class TransferCompletionHandler extends AsyncCompletionHandlerBase {
     private final static Logger logger = LoggerFactory.getLogger(TransferCompletionHandler.class);
-    private final ConcurrentLinkedQueue<TransferListener> listeners = new ConcurrentLinkedQueue<TransferListener>();
+    private final ConcurrentLinkedQueue<TransferListener> listeners = new ConcurrentLinkedQueue<>();
     private final boolean accumulateResponseBytes;
     private FluentCaseInsensitiveStringsMap headers;
+    // Netty 3 bug hack: last chunk is not notified, fixed in Netty 4
+    private boolean patchForNetty3;
+    private long expectedTotal;
+    private long seen;
 
     /**
      * Create a TransferCompletionHandler that will not accumulate bytes. The resulting {@link org.asynchttpclient.Response#getResponseBody()},
@@ -81,6 +85,10 @@ public TransferCompletionHandler(boolean accumulateResponseBytes) {
         this.accumulateResponseBytes = accumulateResponseBytes;
     }
 
+    public void patchForNetty3() {
+        this.patchForNetty3 = true;
+    }
+
     /**
      * Add a {@link TransferListener}
      * 
@@ -113,17 +121,22 @@ public TransferCompletionHandler removeTransferListener(TransferListener t) {
      */
     public void headers(FluentCaseInsensitiveStringsMap headers) {
         this.headers = headers;
+        if (patchForNetty3) {
+            String contentLength = headers.getFirstValue("Content-Length");
+            if (contentLength != null)
+                expectedTotal = Long.valueOf(contentLength);
+        }
     }
 
     @Override
-    public STATE onHeadersReceived(final HttpResponseHeaders headers) throws Exception {
+    public State onHeadersReceived(final HttpResponseHeaders headers) throws Exception {
         fireOnHeaderReceived(headers.getHeaders());
         return super.onHeadersReceived(headers);
     }
 
     @Override
-    public STATE onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
-        STATE s = STATE.CONTINUE;
+    public State onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
+        State s = State.CONTINUE;
         if (accumulateResponseBytes) {
             s = super.onBodyPartReceived(content);
         }
@@ -133,22 +146,32 @@ public STATE onBodyPartReceived(final HttpResponseBodyPart content) throws Excep
 
     @Override
     public Response onCompleted(Response response) throws Exception {
+        if (patchForNetty3) {
+            // some chunks weren't notified, probably the last one
+            if (seen < expectedTotal) {
+                // do once
+                fireOnBytesSent(expectedTotal - seen, expectedTotal, expectedTotal);
+            }
+        }
         fireOnEnd();
         return response;
     }
 
     @Override
-    public STATE onHeaderWriteCompleted() {
+    public State onHeadersWritten() {
         if (headers != null) {
             fireOnHeadersSent(headers);
         }
-        return STATE.CONTINUE;
+        return State.CONTINUE;
     }
 
     @Override
-    public STATE onContentWriteProgress(long amount, long current, long total) {
+    public State onContentWriteProgress(long amount, long current, long total) {
+        if (patchForNetty3) {
+            seen += amount;
+        }
         fireOnBytesSent(amount, current, total);
-        return STATE.CONTINUE;
+        return State.CONTINUE;
     }
 
     @Override
diff --git a/api/src/main/java/org/asynchttpclient/listener/TransferListener.java b/api/src/main/java/org/asynchttpclient/handler/TransferListener.java
similarity index 98%
rename from api/src/main/java/org/asynchttpclient/listener/TransferListener.java
rename to api/src/main/java/org/asynchttpclient/handler/TransferListener.java
index 1043b3c56..c544c4bbf 100644
--- a/api/src/main/java/org/asynchttpclient/listener/TransferListener.java
+++ b/api/src/main/java/org/asynchttpclient/handler/TransferListener.java
@@ -10,7 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.listener;
+package org.asynchttpclient.handler;
 
 import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
 
diff --git a/api/src/main/java/org/asynchttpclient/resumable/PropertiesBasedResumableProcessor.java b/api/src/main/java/org/asynchttpclient/handler/resumable/PropertiesBasedResumableProcessor.java
similarity index 88%
rename from api/src/main/java/org/asynchttpclient/resumable/PropertiesBasedResumableProcessor.java
rename to api/src/main/java/org/asynchttpclient/handler/resumable/PropertiesBasedResumableProcessor.java
index 030a95fb7..d02c44577 100644
--- a/api/src/main/java/org/asynchttpclient/resumable/PropertiesBasedResumableProcessor.java
+++ b/api/src/main/java/org/asynchttpclient/handler/resumable/PropertiesBasedResumableProcessor.java
@@ -10,8 +10,9 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.resumable;
+package org.asynchttpclient.handler.resumable;
 
+import static java.nio.charset.StandardCharsets.*;
 import static org.asynchttpclient.util.MiscUtils.closeSilently;
 
 import java.io.File;
@@ -21,19 +22,18 @@
 import java.util.Scanner;
 import java.util.concurrent.ConcurrentHashMap;
 
-import org.asynchttpclient.util.StandardCharsets;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 /**
- * A {@link org.asynchttpclient.resumable.ResumableAsyncHandler.ResumableProcessor} which use a properties file
+ * A {@link org.asynchttpclient.handler.resumable.ResumableAsyncHandler.ResumableProcessor} which use a properties file
  * to store the download index information.
  */
 public class PropertiesBasedResumableProcessor implements ResumableAsyncHandler.ResumableProcessor {
     private final static Logger log = LoggerFactory.getLogger(PropertiesBasedResumableProcessor.class);
     private final static File TMP = new File(System.getProperty("java.io.tmpdir"), "ahc");
     private final static String storeName = "ResumableAsyncHandler.properties";
-    private final ConcurrentHashMap<String, Long> properties = new ConcurrentHashMap<String, Long>();
+    private final ConcurrentHashMap<String, Long> properties = new ConcurrentHashMap<>();
 
     /**
      * {@inheritDoc}
@@ -76,7 +76,7 @@ public void save(Map<String, Long> map) {
             os = new FileOutputStream(f);
 
             for (Map.Entry<String, Long> e : properties.entrySet()) {
-                os.write(append(e).getBytes(StandardCharsets.UTF_8));
+                os.write(append(e).getBytes(UTF_8));
             }
             os.flush();
         } catch (Throwable e) {
@@ -88,7 +88,7 @@ public void save(Map<String, Long> map) {
     }
 
     private static String append(Map.Entry<String, Long> e) {
-        return new StringBuilder(e.getKey()).append("=").append(e.getValue()).append("\n").toString();
+        return new StringBuilder(e.getKey()).append('=').append(e.getValue()).append('\n').toString();
     }
 
     /**
@@ -98,7 +98,7 @@ private static String append(Map.Entry<String, Long> e) {
     public Map<String, Long> load() {
         Scanner scan = null;
         try {
-            scan = new Scanner(new File(TMP, storeName), StandardCharsets.UTF_8.name());
+            scan = new Scanner(new File(TMP, storeName), UTF_8.name());
             scan.useDelimiter("[=\n]");
 
             String key;
diff --git a/api/src/main/java/org/asynchttpclient/resumable/ResumableAsyncHandler.java b/api/src/main/java/org/asynchttpclient/handler/resumable/ResumableAsyncHandler.java
similarity index 91%
rename from api/src/main/java/org/asynchttpclient/resumable/ResumableAsyncHandler.java
rename to api/src/main/java/org/asynchttpclient/handler/resumable/ResumableAsyncHandler.java
index c7fd13d75..af6df16f5 100644
--- a/api/src/main/java/org/asynchttpclient/resumable/ResumableAsyncHandler.java
+++ b/api/src/main/java/org/asynchttpclient/handler/resumable/ResumableAsyncHandler.java
@@ -10,7 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.resumable;
+package org.asynchttpclient.handler.resumable;
 
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.HttpResponseBodyPart;
@@ -20,7 +20,7 @@
 import org.asynchttpclient.RequestBuilder;
 import org.asynchttpclient.Response;
 import org.asynchttpclient.Response.ResponseBuilder;
-import org.asynchttpclient.listener.TransferCompletionHandler;
+import org.asynchttpclient.handler.TransferCompletionHandler;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -34,7 +34,7 @@
 /**
  * An {@link AsyncHandler} which support resumable download, e.g when used with an {@link ResumableIOExceptionFilter},
  * this handler can resume the download operation at the point it was before the interruption occurred. This prevent having to
- * download the entire file again. It's the responsibility of the {@link org.asynchttpclient.resumable.ResumableAsyncHandler}
+ * download the entire file again. It's the responsibility of the {@link org.asynchttpclient.handler.resumable.ResumableAsyncHandler}
  * to track how many bytes has been transferred and to properly adjust the file's write position.
  * <p/>
  * In case of a JVM crash/shutdown, you can create an instance of this class and pass the last valid bytes position.
@@ -100,19 +100,19 @@ public ResumableAsyncHandler(ResumableProcessor resumableProcessor, boolean accu
      * {@inheritDoc}
      */
     @Override
-    public AsyncHandler.STATE onStatusReceived(final HttpResponseStatus status) throws Exception {
+    public AsyncHandler.State onStatusReceived(final HttpResponseStatus status) throws Exception {
         responseBuilder.accumulate(status);
         if (status.getStatusCode() == 200 || status.getStatusCode() == 206) {
             url = status.getUri().toUrl();
         } else {
-            return AsyncHandler.STATE.ABORT;
+            return AsyncHandler.State.ABORT;
         }
 
         if (decoratedAsyncHandler != null) {
             return decoratedAsyncHandler.onStatusReceived(status);
         }
 
-        return AsyncHandler.STATE.CONTINUE;
+        return AsyncHandler.State.CONTINUE;
     }
 
     /**
@@ -131,17 +131,17 @@ public void onThrowable(Throwable t) {
      * {@inheritDoc}
      */
     @Override
-    public AsyncHandler.STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+    public AsyncHandler.State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
 
         if (accumulateBody) {
             responseBuilder.accumulate(bodyPart);
         }
 
-        STATE state = STATE.CONTINUE;
+        State state = State.CONTINUE;
         try {
             resumableListener.onBytesReceived(bodyPart.getBodyByteBuffer());
         } catch (IOException ex) {
-            return AsyncHandler.STATE.ABORT;
+            return AsyncHandler.State.ABORT;
         }
 
         if (decoratedAsyncHandler != null) {
@@ -173,19 +173,19 @@ public Response onCompleted() throws Exception {
      * {@inheritDoc}
      */
     @Override
-    public AsyncHandler.STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
+    public AsyncHandler.State onHeadersReceived(HttpResponseHeaders headers) throws Exception {
         responseBuilder.accumulate(headers);
         String contentLengthHeader = headers.getHeaders().getFirstValue("Content-Length");
         if (contentLengthHeader != null) {
             if (Long.parseLong(contentLengthHeader) == -1L) {
-                return AsyncHandler.STATE.ABORT;
+                return AsyncHandler.State.ABORT;
             }
         }
 
         if (decoratedAsyncHandler != null) {
             return decoratedAsyncHandler.onHeadersReceived(headers);
         }
-        return AsyncHandler.STATE.CONTINUE;
+        return AsyncHandler.State.CONTINUE;
     }
 
     /**
@@ -208,7 +208,7 @@ public Request adjustRequestRange(Request request) {
         }
 
         RequestBuilder builder = new RequestBuilder(request);
-        if (request.getHeaders().get("Range") == null && byteTransferred.get() != 0) {
+        if (request.getHeaders().get("Range").isEmpty() && byteTransferred.get() != 0) {
             builder.setHeader("Range", "bytes=" + byteTransferred.get() + "-");
         }
         return builder.build();
@@ -227,7 +227,7 @@ public ResumableAsyncHandler setResumableListener(ResumableListener resumableLis
 
     private static class ResumableIndexThread extends Thread {
 
-        public final ConcurrentLinkedQueue<ResumableProcessor> resumableProcessors = new ConcurrentLinkedQueue<ResumableProcessor>();
+        public final ConcurrentLinkedQueue<ResumableProcessor> resumableProcessors = new ConcurrentLinkedQueue<>();
 
         public ResumableIndexThread() {
             Runtime.getRuntime().addShutdownHook(this);
@@ -247,7 +247,7 @@ public void run() {
     /**
      * An interface to implement in order to manage the way the incomplete file management are handled.
      */
-    public static interface ResumableProcessor {
+    public interface ResumableProcessor {
 
         /**
          * Associate a key with the number of bytes successfully transferred.
@@ -293,7 +293,7 @@ public void save(Map<String, Long> map) {
         }
 
         public Map<String, Long> load() {
-            return new HashMap<String, Long>();
+            return new HashMap<>();
         }
     }
 
diff --git a/api/src/main/java/org/asynchttpclient/resumable/ResumableIOExceptionFilter.java b/api/src/main/java/org/asynchttpclient/handler/resumable/ResumableIOExceptionFilter.java
similarity index 90%
rename from api/src/main/java/org/asynchttpclient/resumable/ResumableIOExceptionFilter.java
rename to api/src/main/java/org/asynchttpclient/handler/resumable/ResumableIOExceptionFilter.java
index 87868e35d..c87867499 100644
--- a/api/src/main/java/org/asynchttpclient/resumable/ResumableIOExceptionFilter.java
+++ b/api/src/main/java/org/asynchttpclient/handler/resumable/ResumableIOExceptionFilter.java
@@ -10,7 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.resumable;
+package org.asynchttpclient.handler.resumable;
 
 import org.asynchttpclient.Request;
 import org.asynchttpclient.filter.FilterContext;
@@ -26,7 +26,7 @@
 
             Request request = ResumableAsyncHandler.class.cast(ctx.getAsyncHandler()).adjustRequestRange(ctx.getRequest());
 
-            return new FilterContext.FilterContextBuilder<T>(ctx).request(request).replayRequest(true).build();
+            return new FilterContext.FilterContextBuilder<>(ctx).request(request).replayRequest(true).build();
         }
         return ctx;
     }
diff --git a/api/src/main/java/org/asynchttpclient/resumable/ResumableListener.java b/api/src/main/java/org/asynchttpclient/handler/resumable/ResumableListener.java
similarity index 96%
rename from api/src/main/java/org/asynchttpclient/resumable/ResumableListener.java
rename to api/src/main/java/org/asynchttpclient/handler/resumable/ResumableListener.java
index c8af9c656..9570c35b0 100644
--- a/api/src/main/java/org/asynchttpclient/resumable/ResumableListener.java
+++ b/api/src/main/java/org/asynchttpclient/handler/resumable/ResumableListener.java
@@ -10,7 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.resumable;
+package org.asynchttpclient.handler.resumable;
 
 import java.io.IOException;
 import java.nio.ByteBuffer;
diff --git a/api/src/main/java/org/asynchttpclient/internal/chmv8/ConcurrentHashMapV8.java b/api/src/main/java/org/asynchttpclient/internal/chmv8/ConcurrentHashMapV8.java
new file mode 100644
index 000000000..f27225f11
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/internal/chmv8/ConcurrentHashMapV8.java
@@ -0,0 +1,6207 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+/*
+ * Written by Doug Lea with assistance from members of JCP JSR-166
+ * Expert Group and released to the public domain, as explained at
+ * http://creativecommons.org/publicdomain/zero/1.0/
+ */
+
+package org.asynchttpclient.internal.chmv8;
+
+import java.io.ObjectStreamField;
+import java.io.Serializable;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.ConcurrentModificationException;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.Hashtable;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.NoSuchElementException;
+import java.util.Set;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.concurrent.locks.LockSupport;
+import java.util.concurrent.locks.ReentrantLock;
+
+/**
+ * A hash table supporting full concurrency of retrievals and
+ * high expected concurrency for updates. This class obeys the
+ * same functional specification as {@link java.util.Hashtable}, and
+ * includes versions of methods corresponding to each method of
+ * {@code Hashtable}. However, even though all operations are
+ * thread-safe, retrieval operations do <em>not</em> entail locking,
+ * and there is <em>not</em> any support for locking the entire table
+ * in a way that prevents all access.  This class is fully
+ * interoperable with {@code Hashtable} in programs that rely on its
+ * thread safety but not on its synchronization details.
+ *
+ * <p>Retrieval operations (including {@code get}) generally do not
+ * block, so may overlap with update operations (including {@code put}
+ * and {@code remove}). Retrievals reflect the results of the most
+ * recently <em>completed</em> update operations holding upon their
+ * onset. (More formally, an update operation for a given key bears a
+ * <em>happens-before</em> relation with any (non-null) retrieval for
+ * that key reporting the updated value.)  For aggregate operations
+ * such as {@code putAll} and {@code clear}, concurrent retrievals may
+ * reflect insertion or removal of only some entries.  Similarly,
+ * Iterators and Enumerations return elements reflecting the state of
+ * the hash table at some point at or since the creation of the
+ * iterator/enumeration.  They do <em>not</em> throw {@link
+ * ConcurrentModificationException}.  However, iterators are designed
+ * to be used by only one thread at a time.  Bear in mind that the
+ * results of aggregate status methods including {@code size}, {@code
+ * isEmpty}, and {@code containsValue} are typically useful only when
+ * a map is not undergoing concurrent updates in other threads.
+ * Otherwise the results of these methods reflect transient states
+ * that may be adequate for monitoring or estimation purposes, but not
+ * for program control.
+ *
+ * <p>The table is dynamically expanded when there are too many
+ * collisions (i.e., keys that have distinct hash codes but fall into
+ * the same slot modulo the table size), with the expected average
+ * effect of maintaining roughly two bins per mapping (corresponding
+ * to a 0.75 load factor threshold for resizing). There may be much
+ * variance around this average as mappings are added and removed, but
+ * overall, this maintains a commonly accepted time/space tradeoff for
+ * hash tables.  However, resizing this or any other kind of hash
+ * table may be a relatively slow operation. When possible, it is a
+ * good idea to provide a size estimate as an optional {@code
+ * initialCapacity} constructor argument. An additional optional
+ * {@code loadFactor} constructor argument provides a further means of
+ * customizing initial table capacity by specifying the table density
+ * to be used in calculating the amount of space to allocate for the
+ * given number of elements.  Also, for compatibility with previous
+ * versions of this class, constructors may optionally specify an
+ * expected {@code concurrencyLevel} as an additional hint for
+ * internal sizing.  Note that using many keys with exactly the same
+ * {@code hashCode()} is a sure way to slow down performance of any
+ * hash table. To ameliorate impact, when keys are {@link Comparable},
+ * this class may use comparison order among keys to help break ties.
+ *
+ * <p>A {@link Set} projection of a ConcurrentHashMapV8 may be created
+ * (using {@link #newKeySet()} or {@link #newKeySet(int)}), or viewed
+ * (using {@link #keySet(Object)} when only keys are of interest, and the
+ * mapped values are (perhaps transiently) not used or all take the
+ * same mapping value.
+ *
+ * <p>This class and its views and iterators implement all of the
+ * <em>optional</em> methods of the {@link Map} and {@link Iterator}
+ * interfaces.
+ *
+ * <p>Like {@link Hashtable} but unlike {@link HashMap}, this class
+ * does <em>not</em> allow {@code null} to be used as a key or value.
+ *
+ * <p>ConcurrentHashMapV8s support a set of sequential and parallel bulk
+ * operations that are designed
+ * to be safely, and often sensibly, applied even with maps that are
+ * being concurrently updated by other threads; for example, when
+ * computing a snapshot summary of the values in a shared registry.
+ * There are three kinds of operation, each with four forms, accepting
+ * functions with Keys, Values, Entries, and (Key, Value) arguments
+ * and/or return values. Because the elements of a ConcurrentHashMapV8
+ * are not ordered in any particular way, and may be processed in
+ * different orders in different parallel executions, the correctness
+ * of supplied functions should not depend on any ordering, or on any
+ * other objects or values that may transiently change while
+ * computation is in progress; and except for forEach actions, should
+ * ideally be side-effect-free. Bulk operations on {@link java.util.Map.Entry}
+ * objects do not support method {@code setValue}.
+ *
+ * <ul>
+ * <li> forEach: Perform a given action on each element.
+ * A variant form applies a given transformation on each element
+ * before performing the action.</li>
+ *
+ * <li> search: Return the first available non-null result of
+ * applying a given function on each element; skipping further
+ * search when a result is found.</li>
+ *
+ * <li> reduce: Accumulate each element.  The supplied reduction
+ * function cannot rely on ordering (more formally, it should be
+ * both associative and commutative).  There are five variants:
+ *
+ * <ul>
+ *
+ * <li> Plain reductions. (There is not a form of this method for
+ * (key, value) function arguments since there is no corresponding
+ * return type.)</li>
+ *
+ * <li> Mapped reductions that accumulate the results of a given
+ * function applied to each element.</li>
+ *
+ * <li> Reductions to scalar doubles, longs, and ints, using a
+ * given basis value.</li>
+ *
+ * </ul>
+ * </li>
+ * </ul>
+ *
+ * <p>These bulk operations accept a {@code parallelismThreshold}
+ * argument. Methods proceed sequentially if the current map size is
+ * estimated to be less than the given threshold. Using a value of
+ * {@code Long.MAX_VALUE} suppresses all parallelism.  Using a value
+ * of {@code 1} results in maximal parallelism by partitioning into
+ * enough subtasks to fully utilize the {@link
+ * ForkJoinPool#commonPool()} that is used for all parallel
+ * computations. Normally, you would initially choose one of these
+ * extreme values, and then measure performance of using in-between
+ * values that trade off overhead versus throughput.
+ *
+ * <p>The concurrency properties of bulk operations follow
+ * from those of ConcurrentHashMapV8: Any non-null result returned
+ * from {@code get(key)} and related access methods bears a
+ * happens-before relation with the associated insertion or
+ * update.  The result of any bulk operation reflects the
+ * composition of these per-element relations (but is not
+ * necessarily atomic with respect to the map as a whole unless it
+ * is somehow known to be quiescent).  Conversely, because keys
+ * and values in the map are never null, null serves as a reliable
+ * atomic indicator of the current lack of any result.  To
+ * maintain this property, null serves as an implicit basis for
+ * all non-scalar reduction operations. For the double, long, and
+ * int versions, the basis should be one that, when combined with
+ * any other value, returns that other value (more formally, it
+ * should be the identity element for the reduction). Most common
+ * reductions have these properties; for example, computing a sum
+ * with basis 0 or a minimum with basis MAX_VALUE.
+ *
+ * <p>Search and transformation functions provided as arguments
+ * should similarly return null to indicate the lack of any result
+ * (in which case it is not used). In the case of mapped
+ * reductions, this also enables transformations to serve as
+ * filters, returning null (or, in the case of primitive
+ * specializations, the identity basis) if the element should not
+ * be combined. You can create compound transformations and
+ * filterings by composing them yourself under this "null means
+ * there is nothing there now" rule before using them in search or
+ * reduce operations.
+ *
+ * <p>Methods accepting and/or returning Entry arguments maintain
+ * key-value associations. They may be useful for example when
+ * finding the key for the greatest value. Note that "plain" Entry
+ * arguments can be supplied using {@code new
+ * AbstractMap.SimpleEntry(k,v)}.
+ *
+ * <p>Bulk operations may complete abruptly, throwing an
+ * exception encountered in the application of a supplied
+ * function. Bear in mind when handling such exceptions that other
+ * concurrently executing functions could also have thrown
+ * exceptions, or would have done so if the first exception had
+ * not occurred.
+ *
+ * <p>Speedups for parallel compared to sequential forms are common
+ * but not guaranteed.  Parallel operations involving brief functions
+ * on small maps may execute more slowly than sequential forms if the
+ * underlying work to parallelize the computation is more expensive
+ * than the computation itself.  Similarly, parallelization may not
+ * lead to much actual parallelism if all processors are busy
+ * performing unrelated tasks.
+ *
+ * <p>All arguments to all task methods must be non-null.
+ *
+ * <p><em>jsr166e note: During transition, this class
+ * uses nested functional interfaces with different names but the
+ * same forms as those expected for JDK8.</em>
+ *
+ * <p>This class is a member of the
+ * <a href="{@docRoot}/../technotes/guides/collections/index.html">
+ * Java Collections Framework</a>.
+ *
+ * @since 1.5
+ * @author Doug Lea
+ * @param <K> the type of keys maintained by this map
+ * @param <V> the type of mapped values
+ */
+@SuppressWarnings("all")
+public class ConcurrentHashMapV8<K,V>
+        implements ConcurrentMap<K,V>, Serializable {
+    private static final long serialVersionUID = 7249069246763182397L;
+
+    /**
+     * An object for traversing and partitioning elements of a source.
+     * This interface provides a subset of the functionality of JDK8
+     * java.util.Spliterator.
+     */
+    public static interface ConcurrentHashMapSpliterator<T> {
+        /**
+         * If possible, returns a new spliterator covering
+         * approximately one half of the elements, which will not be
+         * covered by this spliterator. Returns null if cannot be
+         * split.
+         */
+        ConcurrentHashMapSpliterator<T> trySplit();
+        /**
+         * Returns an estimate of the number of elements covered by
+         * this Spliterator.
+         */
+        long estimateSize();
+
+        /** Applies the action to each untraversed element */
+        void forEachRemaining(Action<? super T> action);
+        /** If an element remains, applies the action and returns true. */
+        boolean tryAdvance(Action<? super T> action);
+    }
+
+    // Sams
+    /** Interface describing a void action of one argument */
+    public interface Action<A> { void apply(A a); }
+    /** Interface describing a void action of two arguments */
+    public interface BiAction<A,B> { void apply(A a, B b); }
+    /** Interface describing a function of one argument */
+    public interface Fun<A,T> { T apply(A a); }
+    /** Interface describing a function of two arguments */
+    public interface BiFun<A,B,T> { T apply(A a, B b); }
+    /** Interface describing a function mapping its argument to a double */
+    public interface ObjectToDouble<A> { double apply(A a); }
+    /** Interface describing a function mapping its argument to a long */
+    public interface ObjectToLong<A> { long apply(A a); }
+    /** Interface describing a function mapping its argument to an int */
+    public interface ObjectToInt<A> {int apply(A a); }
+    /** Interface describing a function mapping two arguments to a double */
+    public interface ObjectByObjectToDouble<A,B> { double apply(A a, B b); }
+    /** Interface describing a function mapping two arguments to a long */
+    public interface ObjectByObjectToLong<A,B> { long apply(A a, B b); }
+    /** Interface describing a function mapping two arguments to an int */
+    public interface ObjectByObjectToInt<A,B> {int apply(A a, B b); }
+    /** Interface describing a function mapping two doubles to a double */
+    public interface DoubleByDoubleToDouble { double apply(double a, double b); }
+    /** Interface describing a function mapping two longs to a long */
+    public interface LongByLongToLong { long apply(long a, long b); }
+    /** Interface describing a function mapping two ints to an int */
+    public interface IntByIntToInt { int apply(int a, int b); }
+
+    /*
+     * Overview:
+     *
+     * The primary design goal of this hash table is to maintain
+     * concurrent readability (typically method get(), but also
+     * iterators and related methods) while minimizing update
+     * contention. Secondary goals are to keep space consumption about
+     * the same or better than java.util.HashMap, and to support high
+     * initial insertion rates on an empty table by many threads.
+     *
+     * This map usually acts as a binned (bucketed) hash table.  Each
+     * key-value mapping is held in a Node.  Most nodes are instances
+     * of the basic Node class with hash, key, value, and next
+     * fields. However, various subclasses exist: TreeNodes are
+     * arranged in balanced trees, not lists.  TreeBins hold the roots
+     * of sets of TreeNodes. ForwardingNodes are placed at the heads
+     * of bins during resizing. ReservationNodes are used as
+     * placeholders while establishing values in computeIfAbsent and
+     * related methods.  The types TreeBin, ForwardingNode, and
+     * ReservationNode do not hold normal user keys, values, or
+     * hashes, and are readily distinguishable during search etc
+     * because they have negative hash fields and null key and value
+     * fields. (These special nodes are either uncommon or transient,
+     * so the impact of carrying around some unused fields is
+     * insignificant.)
+     *
+     * The table is lazily initialized to a power-of-two size upon the
+     * first insertion.  Each bin in the table normally contains a
+     * list of Nodes (most often, the list has only zero or one Node).
+     * Table accesses require volatile/atomic reads, writes, and
+     * CASes.  Because there is no other way to arrange this without
+     * adding further indirections, we use intrinsics
+     * (sun.misc.Unsafe) operations.
+     *
+     * We use the top (sign) bit of Node hash fields for control
+     * purposes -- it is available anyway because of addressing
+     * constraints.  Nodes with negative hash fields are specially
+     * handled or ignored in map methods.
+     *
+     * Insertion (via put or its variants) of the first node in an
+     * empty bin is performed by just CASing it to the bin.  This is
+     * by far the most common case for put operations under most
+     * key/hash distributions.  Other update operations (insert,
+     * delete, and replace) require locks.  We do not want to waste
+     * the space required to associate a distinct lock object with
+     * each bin, so instead use the first node of a bin list itself as
+     * a lock. Locking support for these locks relies on builtin
+     * "synchronized" monitors.
+     *
+     * Using the first node of a list as a lock does not by itself
+     * suffice though: When a node is locked, any update must first
+     * validate that it is still the first node after locking it, and
+     * retry if not. Because new nodes are always appended to lists,
+     * once a node is first in a bin, it remains first until deleted
+     * or the bin becomes invalidated (upon resizing).
+     *
+     * The main disadvantage of per-bin locks is that other update
+     * operations on other nodes in a bin list protected by the same
+     * lock can stall, for example when user equals() or mapping
+     * functions take a long time.  However, statistically, under
+     * random hash codes, this is not a common problem.  Ideally, the
+     * frequency of nodes in bins follows a Poisson distribution
+     * (http://en.wikipedia.org/wiki/Poisson_distribution) with a
+     * parameter of about 0.5 on average, given the resizing threshold
+     * of 0.75, although with a large variance because of resizing
+     * granularity. Ignoring variance, the expected occurrences of
+     * list size k are (exp(-0.5) * pow(0.5, k) / factorial(k)). The
+     * first values are:
+     *
+     * 0:    0.60653066
+     * 1:    0.30326533
+     * 2:    0.07581633
+     * 3:    0.01263606
+     * 4:    0.00157952
+     * 5:    0.00015795
+     * 6:    0.00001316
+     * 7:    0.00000094
+     * 8:    0.00000006
+     * more: less than 1 in ten million
+     *
+     * Lock contention probability for two threads accessing distinct
+     * elements is roughly 1 / (8 * #elements) under random hashes.
+     *
+     * Actual hash code distributions encountered in practice
+     * sometimes deviate significantly from uniform randomness.  This
+     * includes the case when N > (1<<30), so some keys MUST collide.
+     * Similarly for dumb or hostile usages in which multiple keys are
+     * designed to have identical hash codes or ones that differs only
+     * in masked-out high bits. So we use a secondary strategy that
+     * applies when the number of nodes in a bin exceeds a
+     * threshold. These TreeBins use a balanced tree to hold nodes (a
+     * specialized form of red-black trees), bounding search time to
+     * O(log N).  Each search step in a TreeBin is at least twice as
+     * slow as in a regular list, but given that N cannot exceed
+     * (1<<64) (before running out of addresses) this bounds search
+     * steps, lock hold times, etc, to reasonable constants (roughly
+     * 100 nodes inspected per operation worst case) so long as keys
+     * are Comparable (which is very common -- String, Long, etc).
+     * TreeBin nodes (TreeNodes) also maintain the same "next"
+     * traversal pointers as regular nodes, so can be traversed in
+     * iterators in the same way.
+     *
+     * The table is resized when occupancy exceeds a percentage
+     * threshold (nominally, 0.75, but see below).  Any thread
+     * noticing an overfull bin may assist in resizing after the
+     * initiating thread allocates and sets up the replacement
+     * array. However, rather than stalling, these other threads may
+     * proceed with insertions etc.  The use of TreeBins shields us
+     * from the worst case effects of overfilling while resizes are in
+     * progress.  Resizing proceeds by transferring bins, one by one,
+     * from the table to the next table. To enable concurrency, the
+     * next table must be (incrementally) prefilled with place-holders
+     * serving as reverse forwarders to the old table.  Because we are
+     * using power-of-two expansion, the elements from each bin must
+     * either stay at same index, or move with a power of two
+     * offset. We eliminate unnecessary node creation by catching
+     * cases where old nodes can be reused because their next fields
+     * won't change.  On average, only about one-sixth of them need
+     * cloning when a table doubles. The nodes they replace will be
+     * garbage collectable as soon as they are no longer referenced by
+     * any reader thread that may be in the midst of concurrently
+     * traversing table.  Upon transfer, the old table bin contains
+     * only a special forwarding node (with hash field "MOVED") that
+     * contains the next table as its key. On encountering a
+     * forwarding node, access and update operations restart, using
+     * the new table.
+     *
+     * Each bin transfer requires its bin lock, which can stall
+     * waiting for locks while resizing. However, because other
+     * threads can join in and help resize rather than contend for
+     * locks, average aggregate waits become shorter as resizing
+     * progresses.  The transfer operation must also ensure that all
+     * accessible bins in both the old and new table are usable by any
+     * traversal.  This is arranged by proceeding from the last bin
+     * (table.length - 1) up towards the first.  Upon seeing a
+     * forwarding node, traversals (see class Traverser) arrange to
+     * move to the new table without revisiting nodes.  However, to
+     * ensure that no intervening nodes are skipped, bin splitting can
+     * only begin after the associated reverse-forwarders are in
+     * place.
+     *
+     * The traversal scheme also applies to partial traversals of
+     * ranges of bins (via an alternate Traverser constructor)
+     * to support partitioned aggregate operations.  Also, read-only
+     * operations give up if ever forwarded to a null table, which
+     * provides support for shutdown-style clearing, which is also not
+     * currently implemented.
+     *
+     * Lazy table initialization minimizes footprint until first use,
+     * and also avoids resizings when the first operation is from a
+     * putAll, constructor with map argument, or deserialization.
+     * These cases attempt to override the initial capacity settings,
+     * but harmlessly fail to take effect in cases of races.
+     *
+     * The element count is maintained using a specialization of
+     * LongAdder. We need to incorporate a specialization rather than
+     * just use a LongAdder in order to access implicit
+     * contention-sensing that leads to creation of multiple
+     * CounterCells.  The counter mechanics avoid contention on
+     * updates but can encounter cache thrashing if read too
+     * frequently during concurrent access. To avoid reading so often,
+     * resizing under contention is attempted only upon adding to a
+     * bin already holding two or more nodes. Under uniform hash
+     * distributions, the probability of this occurring at threshold
+     * is around 13%, meaning that only about 1 in 8 puts check
+     * threshold (and after resizing, many fewer do so).
+     *
+     * TreeBins use a special form of comparison for search and
+     * related operations (which is the main reason we cannot use
+     * existing collections such as TreeMaps). TreeBins contain
+     * Comparable elements, but may contain others, as well as
+     * elements that are Comparable but not necessarily Comparable
+     * for the same T, so we cannot invoke compareTo among them. To
+     * handle this, the tree is ordered primarily by hash value, then
+     * by Comparable.compareTo order if applicable.  On lookup at a
+     * node, if elements are not comparable or compare as 0 then both
+     * left and right children may need to be searched in the case of
+     * tied hash values. (This corresponds to the full list search
+     * that would be necessary if all elements were non-Comparable and
+     * had tied hashes.)  The red-black balancing code is updated from
+     * pre-jdk-collections
+     * (http://gee.cs.oswego.edu/dl/classes/collections/RBCell.java)
+     * based in turn on Cormen, Leiserson, and Rivest "Introduction to
+     * Algorithms" (CLR).
+     *
+     * TreeBins also require an additional locking mechanism.  While
+     * list traversal is always possible by readers even during
+     * updates, tree traversal is not, mainly because of tree-rotations
+     * that may change the root node and/or its linkages.  TreeBins
+     * include a simple read-write lock mechanism parasitic on the
+     * main bin-synchronization strategy: Structural adjustments
+     * associated with an insertion or removal are already bin-locked
+     * (and so cannot conflict with other writers) but must wait for
+     * ongoing readers to finish. Since there can be only one such
+     * waiter, we use a simple scheme using a single "waiter" field to
+     * block writers.  However, readers need never block.  If the root
+     * lock is held, they proceed along the slow traversal path (via
+     * next-pointers) until the lock becomes available or the list is
+     * exhausted, whichever comes first. These cases are not fast, but
+     * maximize aggregate expected throughput.
+     *
+     * Maintaining API and serialization compatibility with previous
+     * versions of this class introduces several oddities. Mainly: We
+     * leave untouched but unused constructor arguments refering to
+     * concurrencyLevel. We accept a loadFactor constructor argument,
+     * but apply it only to initial table capacity (which is the only
+     * time that we can guarantee to honor it.) We also declare an
+     * unused "Segment" class that is instantiated in minimal form
+     * only when serializing.
+     *
+     * This file is organized to make things a little easier to follow
+     * while reading than they might otherwise: First the main static
+     * declarations and utilities, then fields, then main public
+     * methods (with a few factorings of multiple public methods into
+     * internal ones), then sizing methods, trees, traversers, and
+     * bulk operations.
+     */
+
+    /* ---------------- Constants -------------- */
+
+    /**
+     * The largest possible table capacity.  This value must be
+     * exactly 1<<30 to stay within Java array allocation and indexing
+     * bounds for power of two table sizes, and is further required
+     * because the top two bits of 32bit hash fields are used for
+     * control purposes.
+     */
+    private static final int MAXIMUM_CAPACITY = 1 << 30;
+
+    /**
+     * The default initial table capacity.  Must be a power of 2
+     * (i.e., at least 1) and at most MAXIMUM_CAPACITY.
+     */
+    private static final int DEFAULT_CAPACITY = 16;
+
+    /**
+     * The largest possible (non-power of two) array size.
+     * Needed by toArray and related methods.
+     */
+    static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
+
+    /**
+     * The default concurrency level for this table. Unused but
+     * defined for compatibility with previous versions of this class.
+     */
+    private static final int DEFAULT_CONCURRENCY_LEVEL = 16;
+
+    /**
+     * The load factor for this table. Overrides of this value in
+     * constructors affect only the initial table capacity.  The
+     * actual floating point value isn't normally used -- it is
+     * simpler to use expressions such as {@code n - (n >>> 2)} for
+     * the associated resizing threshold.
+     */
+    private static final float LOAD_FACTOR = 0.75f;
+
+    /**
+     * The bin count threshold for using a tree rather than list for a
+     * bin.  Bins are converted to trees when adding an element to a
+     * bin with at least this many nodes. The value must be greater
+     * than 2, and should be at least 8 to mesh with assumptions in
+     * tree removal about conversion back to plain bins upon
+     * shrinkage.
+     */
+    static final int TREEIFY_THRESHOLD = 8;
+
+    /**
+     * The bin count threshold for untreeifying a (split) bin during a
+     * resize operation. Should be less than TREEIFY_THRESHOLD, and at
+     * most 6 to mesh with shrinkage detection under removal.
+     */
+    static final int UNTREEIFY_THRESHOLD = 6;
+
+    /**
+     * The smallest table capacity for which bins may be treeified.
+     * (Otherwise the table is resized if too many nodes in a bin.)
+     * The value should be at least 4 * TREEIFY_THRESHOLD to avoid
+     * conflicts between resizing and treeification thresholds.
+     */
+    static final int MIN_TREEIFY_CAPACITY = 64;
+
+    /**
+     * Minimum number of rebinnings per transfer step. Ranges are
+     * subdivided to allow multiple resizer threads.  This value
+     * serves as a lower bound to avoid resizers encountering
+     * excessive memory contention.  The value should be at least
+     * DEFAULT_CAPACITY.
+     */
+    private static final int MIN_TRANSFER_STRIDE = 16;
+
+    /*
+     * Encodings for Node hash fields. See above for explanation.
+     */
+    static final int MOVED     = -1; // hash for forwarding nodes
+    static final int TREEBIN   = -2; // hash for roots of trees
+    static final int RESERVED  = -3; // hash for transient reservations
+    static final int HASH_BITS = 0x7fffffff; // usable bits of normal node hash
+
+    /** Number of CPUS, to place bounds on some sizings */
+    static final int NCPU = Runtime.getRuntime().availableProcessors();
+
+    /** For serialization compatibility. */
+    private static final ObjectStreamField[] serialPersistentFields = {
+            new ObjectStreamField("segments", Segment[].class),
+            new ObjectStreamField("segmentMask", Integer.TYPE),
+            new ObjectStreamField("segmentShift", Integer.TYPE)
+    };
+
+    /* ---------------- Nodes -------------- */
+
+    /**
+     * Key-value entry.  This class is never exported out as a
+     * user-mutable Map.Entry (i.e., one supporting setValue; see
+     * MapEntry below), but can be used for read-only traversals used
+     * in bulk tasks.  Subclasses of Node with a negative hash field
+     * are special, and contain null keys and values (but are never
+     * exported).  Otherwise, keys and vals are never null.
+     */
+    static class Node<K,V> implements Map.Entry<K,V> {
+        final int hash;
+        final K key;
+        volatile V val;
+        volatile Node<K,V> next;
+
+        Node(int hash, K key, V val, Node<K,V> next) {
+            this.hash = hash;
+            this.key = key;
+            this.val = val;
+            this.next = next;
+        }
+
+        public final K getKey()       { return key; }
+        public final V getValue()     { return val; }
+        public final int hashCode()   { return key.hashCode() ^ val.hashCode(); }
+        public final String toString(){ return key + "=" + val; }
+        public final V setValue(V value) {
+            throw new UnsupportedOperationException();
+        }
+
+        public final boolean equals(Object o) {
+            Object k, v, u; Map.Entry<?,?> e;
+            return ((o instanceof Map.Entry) &&
+                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
+                    (v = e.getValue()) != null &&
+                    (k == key || k.equals(key)) &&
+                    (v == (u = val) || v.equals(u)));
+        }
+
+        /**
+         * Virtualized support for map.get(); overridden in subclasses.
+         */
+        Node<K,V> find(int h, Object k) {
+            Node<K,V> e = this;
+            if (k != null) {
+                do {
+                    K ek;
+                    if (e.hash == h &&
+                            ((ek = e.key) == k || (ek != null && k.equals(ek))))
+                        return e;
+                } while ((e = e.next) != null);
+            }
+            return null;
+        }
+    }
+
+    /* ---------------- Static utilities -------------- */
+
+    /**
+     * Spreads (XORs) higher bits of hash to lower and also forces top
+     * bit to 0. Because the table uses power-of-two masking, sets of
+     * hashes that vary only in bits above the current mask will
+     * always collide. (Among known examples are sets of Float keys
+     * holding consecutive whole numbers in small tables.)  So we
+     * apply a transform that spreads the impact of higher bits
+     * downward. There is a tradeoff between speed, utility, and
+     * quality of bit-spreading. Because many common sets of hashes
+     * are already reasonably distributed (so don't benefit from
+     * spreading), and because we use trees to handle large sets of
+     * collisions in bins, we just XOR some shifted bits in the
+     * cheapest possible way to reduce systematic lossage, as well as
+     * to incorporate impact of the highest bits that would otherwise
+     * never be used in index calculations because of table bounds.
+     */
+    static final int spread(int h) {
+        return (h ^ (h >>> 16)) & HASH_BITS;
+    }
+
+    /**
+     * Returns a power of two table size for the given desired capacity.
+     * See Hackers Delight, sec 3.2
+     */
+    private static final int tableSizeFor(int c) {
+        int n = c - 1;
+        n |= n >>> 1;
+        n |= n >>> 2;
+        n |= n >>> 4;
+        n |= n >>> 8;
+        n |= n >>> 16;
+        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
+    }
+
+    /**
+     * Returns x's Class if it is of the form "class C implements
+     * Comparable<C>", else null.
+     */
+    static Class<?> comparableClassFor(Object x) {
+        if (x instanceof Comparable) {
+            Class<?> c; Type[] ts, as; Type t; ParameterizedType p;
+            if ((c = x.getClass()) == String.class) // bypass checks
+                return c;
+            if ((ts = c.getGenericInterfaces()) != null) {
+                for (int i = 0; i < ts.length; ++i) {
+                    if (((t = ts[i]) instanceof ParameterizedType) &&
+                            ((p = (ParameterizedType)t).getRawType() ==
+                                    Comparable.class) &&
+                            (as = p.getActualTypeArguments()) != null &&
+                            as.length == 1 && as[0] == c) // type arg is c
+                        return c;
+                }
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Returns k.compareTo(x) if x matches kc (k's screened comparable
+     * class), else 0.
+     */
+    @SuppressWarnings({"rawtypes","unchecked"}) // for cast to Comparable
+    static int compareComparables(Class<?> kc, Object k, Object x) {
+        return (x == null || x.getClass() != kc ? 0 :
+                ((Comparable)k).compareTo(x));
+    }
+
+    /* ---------------- Table element access -------------- */
+
+    /*
+     * Volatile access methods are used for table elements as well as
+     * elements of in-progress next table while resizing.  All uses of
+     * the tab arguments must be null checked by callers.  All callers
+     * also paranoically precheck that tab's length is not zero (or an
+     * equivalent check), thus ensuring that any index argument taking
+     * the form of a hash value anded with (length - 1) is a valid
+     * index.  Note that, to be correct wrt arbitrary concurrency
+     * errors by users, these checks must operate on local variables,
+     * which accounts for some odd-looking inline assignments below.
+     * Note that calls to setTabAt always occur within locked regions,
+     * and so in principle require only release ordering, not need
+     * full volatile semantics, but are currently coded as volatile
+     * writes to be conservative.
+     */
+
+    @SuppressWarnings("unchecked")
+    static final <K,V> Node<K,V> tabAt(Node<K,V>[] tab, int i) {
+        return (Node<K,V>)U.getObjectVolatile(tab, ((long)i << ASHIFT) + ABASE);
+    }
+
+    static final <K,V> boolean casTabAt(Node<K,V>[] tab, int i,
+                                        Node<K,V> c, Node<K,V> v) {
+        return U.compareAndSwapObject(tab, ((long)i << ASHIFT) + ABASE, c, v);
+    }
+
+    static final <K,V> void setTabAt(Node<K,V>[] tab, int i, Node<K,V> v) {
+        U.putObjectVolatile(tab, ((long)i << ASHIFT) + ABASE, v);
+    }
+
+    /* ---------------- Fields -------------- */
+
+    /**
+     * The array of bins. Lazily initialized upon first insertion.
+     * Size is always a power of two. Accessed directly by iterators.
+     */
+    transient volatile Node<K,V>[] table;
+
+    /**
+     * The next table to use; non-null only while resizing.
+     */
+    private transient volatile Node<K,V>[] nextTable;
+
+    /**
+     * Base counter value, used mainly when there is no contention,
+     * but also as a fallback during table initialization
+     * races. Updated via CAS.
+     */
+    private transient volatile long baseCount;
+
+    /**
+     * Table initialization and resizing control.  When negative, the
+     * table is being initialized or resized: -1 for initialization,
+     * else -(1 + the number of active resizing threads).  Otherwise,
+     * when table is null, holds the initial table size to use upon
+     * creation, or 0 for default. After initialization, holds the
+     * next element count value upon which to resize the table.
+     */
+    private transient volatile int sizeCtl;
+
+    /**
+     * The next table index (plus one) to split while resizing.
+     */
+    private transient volatile int transferIndex;
+
+    /**
+     * The least available table index to split while resizing.
+     */
+    private transient volatile int transferOrigin;
+
+    /**
+     * Spinlock (locked via CAS) used when resizing and/or creating CounterCells.
+     */
+    private transient volatile int cellsBusy;
+
+    /**
+     * Table of counter cells. When non-null, size is a power of 2.
+     */
+    private transient volatile CounterCell[] counterCells;
+
+    // views
+    private transient KeySetView<K,V> keySet;
+    private transient ValuesView<K,V> values;
+    private transient EntrySetView<K,V> entrySet;
+
+
+    /* ---------------- Public operations -------------- */
+
+    /**
+     * Creates a new, empty map with the default initial table size (16).
+     */
+    public ConcurrentHashMapV8() {
+    }
+
+    /**
+     * Creates a new, empty map with an initial table size
+     * accommodating the specified number of elements without the need
+     * to dynamically resize.
+     *
+     * @param initialCapacity The implementation performs internal
+     * sizing to accommodate this many elements.
+     * @throws IllegalArgumentException if the initial capacity of
+     * elements is negative
+     */
+    public ConcurrentHashMapV8(int initialCapacity) {
+        if (initialCapacity < 0)
+            throw new IllegalArgumentException();
+        int cap = ((initialCapacity >= (MAXIMUM_CAPACITY >>> 1)) ?
+                MAXIMUM_CAPACITY :
+                tableSizeFor(initialCapacity + (initialCapacity >>> 1) + 1));
+        this.sizeCtl = cap;
+    }
+
+    /**
+     * Creates a new map with the same mappings as the given map.
+     *
+     * @param m the map
+     */
+    public ConcurrentHashMapV8(Map<? extends K, ? extends V> m) {
+        this.sizeCtl = DEFAULT_CAPACITY;
+        putAll(m);
+    }
+
+    /**
+     * Creates a new, empty map with an initial table size based on
+     * the given number of elements ({@code initialCapacity}) and
+     * initial table density ({@code loadFactor}).
+     *
+     * @param initialCapacity the initial capacity. The implementation
+     * performs internal sizing to accommodate this many elements,
+     * given the specified load factor.
+     * @param loadFactor the load factor (table density) for
+     * establishing the initial table size
+     * @throws IllegalArgumentException if the initial capacity of
+     * elements is negative or the load factor is nonpositive
+     *
+     * @since 1.6
+     */
+    public ConcurrentHashMapV8(int initialCapacity, float loadFactor) {
+        this(initialCapacity, loadFactor, 1);
+    }
+
+    /**
+     * Creates a new, empty map with an initial table size based on
+     * the given number of elements ({@code initialCapacity}), table
+     * density ({@code loadFactor}), and number of concurrently
+     * updating threads ({@code concurrencyLevel}).
+     *
+     * @param initialCapacity the initial capacity. The implementation
+     * performs internal sizing to accommodate this many elements,
+     * given the specified load factor.
+     * @param loadFactor the load factor (table density) for
+     * establishing the initial table size
+     * @param concurrencyLevel the estimated number of concurrently
+     * updating threads. The implementation may use this value as
+     * a sizing hint.
+     * @throws IllegalArgumentException if the initial capacity is
+     * negative or the load factor or concurrencyLevel are
+     * nonpositive
+     */
+    public ConcurrentHashMapV8(int initialCapacity,
+                               float loadFactor, int concurrencyLevel) {
+        if (!(loadFactor > 0.0f) || initialCapacity < 0 || concurrencyLevel <= 0)
+            throw new IllegalArgumentException();
+        if (initialCapacity < concurrencyLevel)   // Use at least as many bins
+            initialCapacity = concurrencyLevel;   // as estimated threads
+        long size = (long)(1.0 + (long)initialCapacity / loadFactor);
+        int cap = (size >= (long)MAXIMUM_CAPACITY) ?
+                MAXIMUM_CAPACITY : tableSizeFor((int)size);
+        this.sizeCtl = cap;
+    }
+
+    // Original (since JDK1.2) Map methods
+
+    /**
+     * {@inheritDoc}
+     */
+    public int size() {
+        long n = sumCount();
+        return ((n < 0L) ? 0 :
+                (n > (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :
+                        (int)n);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public boolean isEmpty() {
+        return sumCount() <= 0L; // ignore transient negative values
+    }
+
+    /**
+     * Returns the value to which the specified key is mapped,
+     * or {@code null} if this map contains no mapping for the key.
+     *
+     * <p>More formally, if this map contains a mapping from a key
+     * {@code k} to a value {@code v} such that {@code key.equals(k)},
+     * then this method returns {@code v}; otherwise it returns
+     * {@code null}.  (There can be at most one such mapping.)
+     *
+     * @throws NullPointerException if the specified key is null
+     */
+    public V get(Object key) {
+        Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;
+        int h = spread(key.hashCode());
+        if ((tab = table) != null && (n = tab.length) > 0 &&
+                (e = tabAt(tab, (n - 1) & h)) != null) {
+            if ((eh = e.hash) == h) {
+                if ((ek = e.key) == key || (ek != null && key.equals(ek)))
+                    return e.val;
+            }
+            else if (eh < 0)
+                return (p = e.find(h, key)) != null ? p.val : null;
+            while ((e = e.next) != null) {
+                if (e.hash == h &&
+                        ((ek = e.key) == key || (ek != null && key.equals(ek))))
+                    return e.val;
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Tests if the specified object is a key in this table.
+     *
+     * @param  key possible key
+     * @return {@code true} if and only if the specified object
+     *         is a key in this table, as determined by the
+     *         {@code equals} method; {@code false} otherwise
+     * @throws NullPointerException if the specified key is null
+     */
+    public boolean containsKey(Object key) {
+        return get(key) != null;
+    }
+
+    /**
+     * Returns {@code true} if this map maps one or more keys to the
+     * specified value. Note: This method may require a full traversal
+     * of the map, and is much slower than method {@code containsKey}.
+     *
+     * @param value value whose presence in this map is to be tested
+     * @return {@code true} if this map maps one or more keys to the
+     *         specified value
+     * @throws NullPointerException if the specified value is null
+     */
+    public boolean containsValue(Object value) {
+        if (value == null)
+            throw new NullPointerException();
+        Node<K,V>[] t;
+        if ((t = table) != null) {
+            Traverser<K,V> it = new Traverser<K,V>(t, t.length, 0, t.length);
+            for (Node<K,V> p; (p = it.advance()) != null; ) {
+                V v;
+                if ((v = p.val) == value || (v != null && value.equals(v)))
+                    return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Maps the specified key to the specified value in this table.
+     * Neither the key nor the value can be null.
+     *
+     * <p>The value can be retrieved by calling the {@code get} method
+     * with a key that is equal to the original key.
+     *
+     * @param key key with which the specified value is to be associated
+     * @param value value to be associated with the specified key
+     * @return the previous value associated with {@code key}, or
+     *         {@code null} if there was no mapping for {@code key}
+     * @throws NullPointerException if the specified key or value is null
+     */
+    public V put(K key, V value) {
+        return putVal(key, value, false);
+    }
+
+    /** Implementation for put and putIfAbsent */
+    final V putVal(K key, V value, boolean onlyIfAbsent) {
+        if (key == null || value == null) throw new NullPointerException();
+        int hash = spread(key.hashCode());
+        int binCount = 0;
+        for (Node<K,V>[] tab = table;;) {
+            Node<K,V> f; int n, i, fh;
+            if (tab == null || (n = tab.length) == 0)
+                tab = initTable();
+            else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
+                if (casTabAt(tab, i, null,
+                        new Node<K,V>(hash, key, value, null)))
+                    break;                   // no lock when adding to empty bin
+            }
+            else if ((fh = f.hash) == MOVED)
+                tab = helpTransfer(tab, f);
+            else {
+                V oldVal = null;
+                synchronized (f) {
+                    if (tabAt(tab, i) == f) {
+                        if (fh >= 0) {
+                            binCount = 1;
+                            for (Node<K,V> e = f;; ++binCount) {
+                                K ek;
+                                if (e.hash == hash &&
+                                        ((ek = e.key) == key ||
+                                                (ek != null && key.equals(ek)))) {
+                                    oldVal = e.val;
+                                    if (!onlyIfAbsent)
+                                        e.val = value;
+                                    break;
+                                }
+                                Node<K,V> pred = e;
+                                if ((e = e.next) == null) {
+                                    pred.next = new Node<K,V>(hash, key,
+                                            value, null);
+                                    break;
+                                }
+                            }
+                        }
+                        else if (f instanceof TreeBin) {
+                            Node<K,V> p;
+                            binCount = 2;
+                            if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,
+                                    value)) != null) {
+                                oldVal = p.val;
+                                if (!onlyIfAbsent)
+                                    p.val = value;
+                            }
+                        }
+                    }
+                }
+                if (binCount != 0) {
+                    if (binCount >= TREEIFY_THRESHOLD)
+                        treeifyBin(tab, i);
+                    if (oldVal != null)
+                        return oldVal;
+                    break;
+                }
+            }
+        }
+        addCount(1L, binCount);
+        return null;
+    }
+
+    /**
+     * Copies all of the mappings from the specified map to this one.
+     * These mappings replace any mappings that this map had for any of the
+     * keys currently in the specified map.
+     *
+     * @param m mappings to be stored in this map
+     */
+    public void putAll(Map<? extends K, ? extends V> m) {
+        tryPresize(m.size());
+        for (Map.Entry<? extends K, ? extends V> e : m.entrySet())
+            putVal(e.getKey(), e.getValue(), false);
+    }
+
+    /**
+     * Removes the key (and its corresponding value) from this map.
+     * This method does nothing if the key is not in the map.
+     *
+     * @param  key the key that needs to be removed
+     * @return the previous value associated with {@code key}, or
+     *         {@code null} if there was no mapping for {@code key}
+     * @throws NullPointerException if the specified key is null
+     */
+    public V remove(Object key) {
+        return replaceNode(key, null, null);
+    }
+
+    /**
+     * Implementation for the four public remove/replace methods:
+     * Replaces node value with v, conditional upon match of cv if
+     * non-null.  If resulting value is null, delete.
+     */
+    final V replaceNode(Object key, V value, Object cv) {
+        int hash = spread(key.hashCode());
+        for (Node<K,V>[] tab = table;;) {
+            Node<K,V> f; int n, i, fh;
+            if (tab == null || (n = tab.length) == 0 ||
+                    (f = tabAt(tab, i = (n - 1) & hash)) == null)
+                break;
+            else if ((fh = f.hash) == MOVED)
+                tab = helpTransfer(tab, f);
+            else {
+                V oldVal = null;
+                boolean validated = false;
+                synchronized (f) {
+                    if (tabAt(tab, i) == f) {
+                        if (fh >= 0) {
+                            validated = true;
+                            for (Node<K,V> e = f, pred = null;;) {
+                                K ek;
+                                if (e.hash == hash &&
+                                        ((ek = e.key) == key ||
+                                                (ek != null && key.equals(ek)))) {
+                                    V ev = e.val;
+                                    if (cv == null || cv == ev ||
+                                            (ev != null && cv.equals(ev))) {
+                                        oldVal = ev;
+                                        if (value != null)
+                                            e.val = value;
+                                        else if (pred != null)
+                                            pred.next = e.next;
+                                        else
+                                            setTabAt(tab, i, e.next);
+                                    }
+                                    break;
+                                }
+                                pred = e;
+                                if ((e = e.next) == null)
+                                    break;
+                            }
+                        }
+                        else if (f instanceof TreeBin) {
+                            validated = true;
+                            TreeBin<K,V> t = (TreeBin<K,V>)f;
+                            TreeNode<K,V> r, p;
+                            if ((r = t.root) != null &&
+                                    (p = r.findTreeNode(hash, key, null)) != null) {
+                                V pv = p.val;
+                                if (cv == null || cv == pv ||
+                                        (pv != null && cv.equals(pv))) {
+                                    oldVal = pv;
+                                    if (value != null)
+                                        p.val = value;
+                                    else if (t.removeTreeNode(p))
+                                        setTabAt(tab, i, untreeify(t.first));
+                                }
+                            }
+                        }
+                    }
+                }
+                if (validated) {
+                    if (oldVal != null) {
+                        if (value == null)
+                            addCount(-1L, -1);
+                        return oldVal;
+                    }
+                    break;
+                }
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Removes all of the mappings from this map.
+     */
+    public void clear() {
+        long delta = 0L; // negative number of deletions
+        int i = 0;
+        Node<K,V>[] tab = table;
+        while (tab != null && i < tab.length) {
+            int fh;
+            Node<K,V> f = tabAt(tab, i);
+            if (f == null)
+                ++i;
+            else if ((fh = f.hash) == MOVED) {
+                tab = helpTransfer(tab, f);
+                i = 0; // restart
+            }
+            else {
+                synchronized (f) {
+                    if (tabAt(tab, i) == f) {
+                        Node<K,V> p = (fh >= 0 ? f :
+                                (f instanceof TreeBin) ?
+                                        ((TreeBin<K,V>)f).first : null);
+                        while (p != null) {
+                            --delta;
+                            p = p.next;
+                        }
+                        setTabAt(tab, i++, null);
+                    }
+                }
+            }
+        }
+        if (delta != 0L)
+            addCount(delta, -1);
+    }
+
+    /**
+     * Returns a {@link Set} view of the keys contained in this map.
+     * The set is backed by the map, so changes to the map are
+     * reflected in the set, and vice-versa. The set supports element
+     * removal, which removes the corresponding mapping from this map,
+     * via the {@code Iterator.remove}, {@code Set.remove},
+     * {@code removeAll}, {@code retainAll}, and {@code clear}
+     * operations.  It does not support the {@code add} or
+     * {@code addAll} operations.
+     *
+     * <p>The view's {@code iterator} is a "weakly consistent" iterator
+     * that will never throw {@link ConcurrentModificationException},
+     * and guarantees to traverse elements as they existed upon
+     * construction of the iterator, and may (but is not guaranteed to)
+     * reflect any modifications subsequent to construction.
+     *
+     * @return the set view
+     */
+    public KeySetView<K,V> keySet() {
+        KeySetView<K,V> ks;
+        return (ks = keySet) != null ? ks : (keySet = new KeySetView<K,V>(this, null));
+    }
+
+    /**
+     * Returns a {@link Collection} view of the values contained in this map.
+     * The collection is backed by the map, so changes to the map are
+     * reflected in the collection, and vice-versa.  The collection
+     * supports element removal, which removes the corresponding
+     * mapping from this map, via the {@code Iterator.remove},
+     * {@code Collection.remove}, {@code removeAll},
+     * {@code retainAll}, and {@code clear} operations.  It does not
+     * support the {@code add} or {@code addAll} operations.
+     *
+     * <p>The view's {@code iterator} is a "weakly consistent" iterator
+     * that will never throw {@link ConcurrentModificationException},
+     * and guarantees to traverse elements as they existed upon
+     * construction of the iterator, and may (but is not guaranteed to)
+     * reflect any modifications subsequent to construction.
+     *
+     * @return the collection view
+     */
+    public Collection<V> values() {
+        ValuesView<K,V> vs;
+        return (vs = values) != null ? vs : (values = new ValuesView<K,V>(this));
+    }
+
+    /**
+     * Returns a {@link Set} view of the mappings contained in this map.
+     * The set is backed by the map, so changes to the map are
+     * reflected in the set, and vice-versa.  The set supports element
+     * removal, which removes the corresponding mapping from the map,
+     * via the {@code Iterator.remove}, {@code Set.remove},
+     * {@code removeAll}, {@code retainAll}, and {@code clear}
+     * operations.
+     *
+     * <p>The view's {@code iterator} is a "weakly consistent" iterator
+     * that will never throw {@link ConcurrentModificationException},
+     * and guarantees to traverse elements as they existed upon
+     * construction of the iterator, and may (but is not guaranteed to)
+     * reflect any modifications subsequent to construction.
+     *
+     * @return the set view
+     */
+    public Set<Map.Entry<K,V>> entrySet() {
+        EntrySetView<K,V> es;
+        return (es = entrySet) != null ? es : (entrySet = new EntrySetView<K,V>(this));
+    }
+
+    /**
+     * Returns the hash code value for this {@link Map}, i.e.,
+     * the sum of, for each key-value pair in the map,
+     * {@code key.hashCode() ^ value.hashCode()}.
+     *
+     * @return the hash code value for this map
+     */
+    public int hashCode() {
+        int h = 0;
+        Node<K,V>[] t;
+        if ((t = table) != null) {
+            Traverser<K,V> it = new Traverser<K,V>(t, t.length, 0, t.length);
+            for (Node<K,V> p; (p = it.advance()) != null; )
+                h += p.key.hashCode() ^ p.val.hashCode();
+        }
+        return h;
+    }
+
+    /**
+     * Returns a string representation of this map.  The string
+     * representation consists of a list of key-value mappings (in no
+     * particular order) enclosed in braces ("{@code {}}").  Adjacent
+     * mappings are separated by the characters {@code ", "} (comma
+     * and space).  Each key-value mapping is rendered as the key
+     * followed by an equals sign ("{@code =}") followed by the
+     * associated value.
+     *
+     * @return a string representation of this map
+     */
+    public String toString() {
+        Node<K,V>[] t;
+        int f = (t = table) == null ? 0 : t.length;
+        Traverser<K,V> it = new Traverser<K,V>(t, f, 0, f);
+        StringBuilder sb = new StringBuilder();
+        sb.append('{');
+        Node<K,V> p;
+        if ((p = it.advance()) != null) {
+            for (;;) {
+                K k = p.key;
+                V v = p.val;
+                sb.append(k == this ? "(this Map)" : k);
+                sb.append('=');
+                sb.append(v == this ? "(this Map)" : v);
+                if ((p = it.advance()) == null)
+                    break;
+                sb.append(',').append(' ');
+            }
+        }
+        return sb.append('}').toString();
+    }
+
+    /**
+     * Compares the specified object with this map for equality.
+     * Returns {@code true} if the given object is a map with the same
+     * mappings as this map.  This operation may return misleading
+     * results if either map is concurrently modified during execution
+     * of this method.
+     *
+     * @param o object to be compared for equality with this map
+     * @return {@code true} if the specified object is equal to this map
+     */
+    public boolean equals(Object o) {
+        if (o != this) {
+            if (!(o instanceof Map))
+                return false;
+            Map<?,?> m = (Map<?,?>) o;
+            Node<K,V>[] t;
+            int f = (t = table) == null ? 0 : t.length;
+            Traverser<K,V> it = new Traverser<K,V>(t, f, 0, f);
+            for (Node<K,V> p; (p = it.advance()) != null; ) {
+                V val = p.val;
+                Object v = m.get(p.key);
+                if (v == null || (v != val && !v.equals(val)))
+                    return false;
+            }
+            for (Map.Entry<?,?> e : m.entrySet()) {
+                Object mk, mv, v;
+                if ((mk = e.getKey()) == null ||
+                        (mv = e.getValue()) == null ||
+                        (v = get(mk)) == null ||
+                        (mv != v && !mv.equals(v)))
+                    return false;
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Stripped-down version of helper class used in previous version,
+     * declared for the sake of serialization compatibility
+     */
+    static class Segment<K,V> extends ReentrantLock implements Serializable {
+        private static final long serialVersionUID = 2249069246763182397L;
+        final float loadFactor;
+        Segment(float lf) { this.loadFactor = lf; }
+    }
+
+    /**
+     * Saves the state of the {@code ConcurrentHashMapV8} instance to a
+     * stream (i.e., serializes it).
+     * @param s the stream
+     * @serialData
+     * the key (Object) and value (Object)
+     * for each key-value mapping, followed by a null pair.
+     * The key-value mappings are emitted in no particular order.
+     */
+    private void writeObject(java.io.ObjectOutputStream s)
+            throws java.io.IOException {
+        // For serialization compatibility
+        // Emulate segment calculation from previous version of this class
+        int sshift = 0;
+        int ssize = 1;
+        while (ssize < DEFAULT_CONCURRENCY_LEVEL) {
+            ++sshift;
+            ssize <<= 1;
+        }
+        int segmentShift = 32 - sshift;
+        int segmentMask = ssize - 1;
+        @SuppressWarnings("unchecked") Segment<K,V>[] segments = (Segment<K,V>[])
+                new Segment<?,?>[DEFAULT_CONCURRENCY_LEVEL];
+        for (int i = 0; i < segments.length; ++i)
+            segments[i] = new Segment<K,V>(LOAD_FACTOR);
+        s.putFields().put("segments", segments);
+        s.putFields().put("segmentShift", segmentShift);
+        s.putFields().put("segmentMask", segmentMask);
+        s.writeFields();
+
+        Node<K,V>[] t;
+        if ((t = table) != null) {
+            Traverser<K,V> it = new Traverser<K,V>(t, t.length, 0, t.length);
+            for (Node<K,V> p; (p = it.advance()) != null; ) {
+                s.writeObject(p.key);
+                s.writeObject(p.val);
+            }
+        }
+        s.writeObject(null);
+        s.writeObject(null);
+        segments = null; // throw away
+    }
+
+    /**
+     * Reconstitutes the instance from a stream (that is, deserializes it).
+     * @param s the stream
+     */
+    private void readObject(java.io.ObjectInputStream s)
+            throws java.io.IOException, ClassNotFoundException {
+        /*
+         * To improve performance in typical cases, we create nodes
+         * while reading, then place in table once size is known.
+         * However, we must also validate uniqueness and deal with
+         * overpopulated bins while doing so, which requires
+         * specialized versions of putVal mechanics.
+         */
+        sizeCtl = -1; // force exclusion for table construction
+        s.defaultReadObject();
+        long size = 0L;
+        Node<K,V> p = null;
+        for (;;) {
+            @SuppressWarnings("unchecked") K k = (K) s.readObject();
+            @SuppressWarnings("unchecked") V v = (V) s.readObject();
+            if (k != null && v != null) {
+                p = new Node<K,V>(spread(k.hashCode()), k, v, p);
+                ++size;
+            }
+            else
+                break;
+        }
+        if (size == 0L)
+            sizeCtl = 0;
+        else {
+            int n;
+            if (size >= (long)(MAXIMUM_CAPACITY >>> 1))
+                n = MAXIMUM_CAPACITY;
+            else {
+                int sz = (int)size;
+                n = tableSizeFor(sz + (sz >>> 1) + 1);
+            }
+            @SuppressWarnings({"rawtypes","unchecked"})
+            Node<K,V>[] tab = (Node<K,V>[])new Node[n];
+            int mask = n - 1;
+            long added = 0L;
+            while (p != null) {
+                boolean insertAtFront;
+                Node<K,V> next = p.next, first;
+                int h = p.hash, j = h & mask;
+                if ((first = tabAt(tab, j)) == null)
+                    insertAtFront = true;
+                else {
+                    K k = p.key;
+                    if (first.hash < 0) {
+                        TreeBin<K,V> t = (TreeBin<K,V>)first;
+                        if (t.putTreeVal(h, k, p.val) == null)
+                            ++added;
+                        insertAtFront = false;
+                    }
+                    else {
+                        int binCount = 0;
+                        insertAtFront = true;
+                        Node<K,V> q; K qk;
+                        for (q = first; q != null; q = q.next) {
+                            if (q.hash == h &&
+                                    ((qk = q.key) == k ||
+                                            (qk != null && k.equals(qk)))) {
+                                insertAtFront = false;
+                                break;
+                            }
+                            ++binCount;
+                        }
+                        if (insertAtFront && binCount >= TREEIFY_THRESHOLD) {
+                            insertAtFront = false;
+                            ++added;
+                            p.next = first;
+                            TreeNode<K,V> hd = null, tl = null;
+                            for (q = p; q != null; q = q.next) {
+                                TreeNode<K,V> t = new TreeNode<K,V>
+                                        (q.hash, q.key, q.val, null, null);
+                                if ((t.prev = tl) == null)
+                                    hd = t;
+                                else
+                                    tl.next = t;
+                                tl = t;
+                            }
+                            setTabAt(tab, j, new TreeBin<K,V>(hd));
+                        }
+                    }
+                }
+                if (insertAtFront) {
+                    ++added;
+                    p.next = first;
+                    setTabAt(tab, j, p);
+                }
+                p = next;
+            }
+            table = tab;
+            sizeCtl = n - (n >>> 2);
+            baseCount = added;
+        }
+    }
+
+    // ConcurrentMap methods
+
+    /**
+     * {@inheritDoc}
+     *
+     * @return the previous value associated with the specified key,
+     *         or {@code null} if there was no mapping for the key
+     * @throws NullPointerException if the specified key or value is null
+     */
+    public V putIfAbsent(K key, V value) {
+        return putVal(key, value, true);
+    }
+
+    /**
+     * {@inheritDoc}
+     *
+     * @throws NullPointerException if the specified key is null
+     */
+    public boolean remove(Object key, Object value) {
+        if (key == null)
+            throw new NullPointerException();
+        return value != null && replaceNode(key, null, value) != null;
+    }
+
+    /**
+     * {@inheritDoc}
+     *
+     * @throws NullPointerException if any of the arguments are null
+     */
+    public boolean replace(K key, V oldValue, V newValue) {
+        if (key == null || oldValue == null || newValue == null)
+            throw new NullPointerException();
+        return replaceNode(key, newValue, oldValue) != null;
+    }
+
+    /**
+     * {@inheritDoc}
+     *
+     * @return the previous value associated with the specified key,
+     *         or {@code null} if there was no mapping for the key
+     * @throws NullPointerException if the specified key or value is null
+     */
+    public V replace(K key, V value) {
+        if (key == null || value == null)
+            throw new NullPointerException();
+        return replaceNode(key, value, null);
+    }
+
+    // Overrides of JDK8+ Map extension method defaults
+
+    /**
+     * Returns the value to which the specified key is mapped, or the
+     * given default value if this map contains no mapping for the
+     * key.
+     *
+     * @param key the key whose associated value is to be returned
+     * @param defaultValue the value to return if this map contains
+     * no mapping for the given key
+     * @return the mapping for the key, if present; else the default value
+     * @throws NullPointerException if the specified key is null
+     */
+    public V getOrDefault(Object key, V defaultValue) {
+        V v;
+        return (v = get(key)) == null ? defaultValue : v;
+    }
+
+    public void forEach(BiAction<? super K, ? super V> action) {
+        if (action == null) throw new NullPointerException();
+        Node<K,V>[] t;
+        if ((t = table) != null) {
+            Traverser<K,V> it = new Traverser<K,V>(t, t.length, 0, t.length);
+            for (Node<K,V> p; (p = it.advance()) != null; ) {
+                action.apply(p.key, p.val);
+            }
+        }
+    }
+
+    public void replaceAll(BiFun<? super K, ? super V, ? extends V> function) {
+        if (function == null) throw new NullPointerException();
+        Node<K,V>[] t;
+        if ((t = table) != null) {
+            Traverser<K,V> it = new Traverser<K,V>(t, t.length, 0, t.length);
+            for (Node<K,V> p; (p = it.advance()) != null; ) {
+                V oldValue = p.val;
+                for (K key = p.key;;) {
+                    V newValue = function.apply(key, oldValue);
+                    if (newValue == null)
+                        throw new NullPointerException();
+                    if (replaceNode(key, newValue, oldValue) != null ||
+                            (oldValue = get(key)) == null)
+                        break;
+                }
+            }
+        }
+    }
+
+    /**
+     * If the specified key is not already associated with a value,
+     * attempts to compute its value using the given mapping function
+     * and enters it into this map unless {@code null}.  The entire
+     * method invocation is performed atomically, so the function is
+     * applied at most once per key.  Some attempted update operations
+     * on this map by other threads may be blocked while computation
+     * is in progress, so the computation should be short and simple,
+     * and must not attempt to update any other mappings of this map.
+     *
+     * @param key key with which the specified value is to be associated
+     * @param mappingFunction the function to compute a value
+     * @return the current (existing or computed) value associated with
+     *         the specified key, or null if the computed value is null
+     * @throws NullPointerException if the specified key or mappingFunction
+     *         is null
+     * @throws IllegalStateException if the computation detectably
+     *         attempts a recursive update to this map that would
+     *         otherwise never complete
+     * @throws RuntimeException or Error if the mappingFunction does so,
+     *         in which case the mapping is left unestablished
+     */
+    public V computeIfAbsent(K key, Fun<? super K, ? extends V> mappingFunction) {
+        if (key == null || mappingFunction == null)
+            throw new NullPointerException();
+        int h = spread(key.hashCode());
+        V val = null;
+        int binCount = 0;
+        for (Node<K,V>[] tab = table;;) {
+            Node<K,V> f; int n, i, fh;
+            if (tab == null || (n = tab.length) == 0)
+                tab = initTable();
+            else if ((f = tabAt(tab, i = (n - 1) & h)) == null) {
+                Node<K,V> r = new ReservationNode<K,V>();
+                synchronized (r) {
+                    if (casTabAt(tab, i, null, r)) {
+                        binCount = 1;
+                        Node<K,V> node = null;
+                        try {
+                            if ((val = mappingFunction.apply(key)) != null)
+                                node = new Node<K,V>(h, key, val, null);
+                        } finally {
+                            setTabAt(tab, i, node);
+                        }
+                    }
+                }
+                if (binCount != 0)
+                    break;
+            }
+            else if ((fh = f.hash) == MOVED)
+                tab = helpTransfer(tab, f);
+            else {
+                boolean added = false;
+                synchronized (f) {
+                    if (tabAt(tab, i) == f) {
+                        if (fh >= 0) {
+                            binCount = 1;
+                            for (Node<K,V> e = f;; ++binCount) {
+                                K ek; V ev;
+                                if (e.hash == h &&
+                                        ((ek = e.key) == key ||
+                                                (ek != null && key.equals(ek)))) {
+                                    val = e.val;
+                                    break;
+                                }
+                                Node<K,V> pred = e;
+                                if ((e = e.next) == null) {
+                                    if ((val = mappingFunction.apply(key)) != null) {
+                                        added = true;
+                                        pred.next = new Node<K,V>(h, key, val, null);
+                                    }
+                                    break;
+                                }
+                            }
+                        }
+                        else if (f instanceof TreeBin) {
+                            binCount = 2;
+                            TreeBin<K,V> t = (TreeBin<K,V>)f;
+                            TreeNode<K,V> r, p;
+                            if ((r = t.root) != null &&
+                                    (p = r.findTreeNode(h, key, null)) != null)
+                                val = p.val;
+                            else if ((val = mappingFunction.apply(key)) != null) {
+                                added = true;
+                                t.putTreeVal(h, key, val);
+                            }
+                        }
+                    }
+                }
+                if (binCount != 0) {
+                    if (binCount >= TREEIFY_THRESHOLD)
+                        treeifyBin(tab, i);
+                    if (!added)
+                        return val;
+                    break;
+                }
+            }
+        }
+        if (val != null)
+            addCount(1L, binCount);
+        return val;
+    }
+
+    /**
+     * If the value for the specified key is present, attempts to
+     * compute a new mapping given the key and its current mapped
+     * value.  The entire method invocation is performed atomically.
+     * Some attempted update operations on this map by other threads
+     * may be blocked while computation is in progress, so the
+     * computation should be short and simple, and must not attempt to
+     * update any other mappings of this map.
+     *
+     * @param key key with which a value may be associated
+     * @param remappingFunction the function to compute a value
+     * @return the new value associated with the specified key, or null if none
+     * @throws NullPointerException if the specified key or remappingFunction
+     *         is null
+     * @throws IllegalStateException if the computation detectably
+     *         attempts a recursive update to this map that would
+     *         otherwise never complete
+     * @throws RuntimeException or Error if the remappingFunction does so,
+     *         in which case the mapping is unchanged
+     */
+    public V computeIfPresent(K key, BiFun<? super K, ? super V, ? extends V> remappingFunction) {
+        if (key == null || remappingFunction == null)
+            throw new NullPointerException();
+        int h = spread(key.hashCode());
+        V val = null;
+        int delta = 0;
+        int binCount = 0;
+        for (Node<K,V>[] tab = table;;) {
+            Node<K,V> f; int n, i, fh;
+            if (tab == null || (n = tab.length) == 0)
+                tab = initTable();
+            else if ((f = tabAt(tab, i = (n - 1) & h)) == null)
+                break;
+            else if ((fh = f.hash) == MOVED)
+                tab = helpTransfer(tab, f);
+            else {
+                synchronized (f) {
+                    if (tabAt(tab, i) == f) {
+                        if (fh >= 0) {
+                            binCount = 1;
+                            for (Node<K,V> e = f, pred = null;; ++binCount) {
+                                K ek;
+                                if (e.hash == h &&
+                                        ((ek = e.key) == key ||
+                                                (ek != null && key.equals(ek)))) {
+                                    val = remappingFunction.apply(key, e.val);
+                                    if (val != null)
+                                        e.val = val;
+                                    else {
+                                        delta = -1;
+                                        Node<K,V> en = e.next;
+                                        if (pred != null)
+                                            pred.next = en;
+                                        else
+                                            setTabAt(tab, i, en);
+                                    }
+                                    break;
+                                }
+                                pred = e;
+                                if ((e = e.next) == null)
+                                    break;
+                            }
+                        }
+                        else if (f instanceof TreeBin) {
+                            binCount = 2;
+                            TreeBin<K,V> t = (TreeBin<K,V>)f;
+                            TreeNode<K,V> r, p;
+                            if ((r = t.root) != null &&
+                                    (p = r.findTreeNode(h, key, null)) != null) {
+                                val = remappingFunction.apply(key, p.val);
+                                if (val != null)
+                                    p.val = val;
+                                else {
+                                    delta = -1;
+                                    if (t.removeTreeNode(p))
+                                        setTabAt(tab, i, untreeify(t.first));
+                                }
+                            }
+                        }
+                    }
+                }
+                if (binCount != 0)
+                    break;
+            }
+        }
+        if (delta != 0)
+            addCount((long)delta, binCount);
+        return val;
+    }
+
+    /**
+     * Attempts to compute a mapping for the specified key and its
+     * current mapped value (or {@code null} if there is no current
+     * mapping). The entire method invocation is performed atomically.
+     * Some attempted update operations on this map by other threads
+     * may be blocked while computation is in progress, so the
+     * computation should be short and simple, and must not attempt to
+     * update any other mappings of this Map.
+     *
+     * @param key key with which the specified value is to be associated
+     * @param remappingFunction the function to compute a value
+     * @return the new value associated with the specified key, or null if none
+     * @throws NullPointerException if the specified key or remappingFunction
+     *         is null
+     * @throws IllegalStateException if the computation detectably
+     *         attempts a recursive update to this map that would
+     *         otherwise never complete
+     * @throws RuntimeException or Error if the remappingFunction does so,
+     *         in which case the mapping is unchanged
+     */
+    public V compute(K key,
+                     BiFun<? super K, ? super V, ? extends V> remappingFunction) {
+        if (key == null || remappingFunction == null)
+            throw new NullPointerException();
+        int h = spread(key.hashCode());
+        V val = null;
+        int delta = 0;
+        int binCount = 0;
+        for (Node<K,V>[] tab = table;;) {
+            Node<K,V> f; int n, i, fh;
+            if (tab == null || (n = tab.length) == 0)
+                tab = initTable();
+            else if ((f = tabAt(tab, i = (n - 1) & h)) == null) {
+                Node<K,V> r = new ReservationNode<K,V>();
+                synchronized (r) {
+                    if (casTabAt(tab, i, null, r)) {
+                        binCount = 1;
+                        Node<K,V> node = null;
+                        try {
+                            if ((val = remappingFunction.apply(key, null)) != null) {
+                                delta = 1;
+                                node = new Node<K,V>(h, key, val, null);
+                            }
+                        } finally {
+                            setTabAt(tab, i, node);
+                        }
+                    }
+                }
+                if (binCount != 0)
+                    break;
+            }
+            else if ((fh = f.hash) == MOVED)
+                tab = helpTransfer(tab, f);
+            else {
+                synchronized (f) {
+                    if (tabAt(tab, i) == f) {
+                        if (fh >= 0) {
+                            binCount = 1;
+                            for (Node<K,V> e = f, pred = null;; ++binCount) {
+                                K ek;
+                                if (e.hash == h &&
+                                        ((ek = e.key) == key ||
+                                                (ek != null && key.equals(ek)))) {
+                                    val = remappingFunction.apply(key, e.val);
+                                    if (val != null)
+                                        e.val = val;
+                                    else {
+                                        delta = -1;
+                                        Node<K,V> en = e.next;
+                                        if (pred != null)
+                                            pred.next = en;
+                                        else
+                                            setTabAt(tab, i, en);
+                                    }
+                                    break;
+                                }
+                                pred = e;
+                                if ((e = e.next) == null) {
+                                    val = remappingFunction.apply(key, null);
+                                    if (val != null) {
+                                        delta = 1;
+                                        pred.next =
+                                                new Node<K,V>(h, key, val, null);
+                                    }
+                                    break;
+                                }
+                            }
+                        }
+                        else if (f instanceof TreeBin) {
+                            binCount = 1;
+                            TreeBin<K,V> t = (TreeBin<K,V>)f;
+                            TreeNode<K,V> r, p;
+                            if ((r = t.root) != null)
+                                p = r.findTreeNode(h, key, null);
+                            else
+                                p = null;
+                            V pv = (p == null) ? null : p.val;
+                            val = remappingFunction.apply(key, pv);
+                            if (val != null) {
+                                if (p != null)
+                                    p.val = val;
+                                else {
+                                    delta = 1;
+                                    t.putTreeVal(h, key, val);
+                                }
+                            }
+                            else if (p != null) {
+                                delta = -1;
+                                if (t.removeTreeNode(p))
+                                    setTabAt(tab, i, untreeify(t.first));
+                            }
+                        }
+                    }
+                }
+                if (binCount != 0) {
+                    if (binCount >= TREEIFY_THRESHOLD)
+                        treeifyBin(tab, i);
+                    break;
+                }
+            }
+        }
+        if (delta != 0)
+            addCount((long)delta, binCount);
+        return val;
+    }
+
+    /**
+     * If the specified key is not already associated with a
+     * (non-null) value, associates it with the given value.
+     * Otherwise, replaces the value with the results of the given
+     * remapping function, or removes if {@code null}. The entire
+     * method invocation is performed atomically.  Some attempted
+     * update operations on this map by other threads may be blocked
+     * while computation is in progress, so the computation should be
+     * short and simple, and must not attempt to update any other
+     * mappings of this Map.
+     *
+     * @param key key with which the specified value is to be associated
+     * @param value the value to use if absent
+     * @param remappingFunction the function to recompute a value if present
+     * @return the new value associated with the specified key, or null if none
+     * @throws NullPointerException if the specified key or the
+     *         remappingFunction is null
+     * @throws RuntimeException or Error if the remappingFunction does so,
+     *         in which case the mapping is unchanged
+     */
+    public V merge(K key, V value, BiFun<? super V, ? super V, ? extends V> remappingFunction) {
+        if (key == null || value == null || remappingFunction == null)
+            throw new NullPointerException();
+        int h = spread(key.hashCode());
+        V val = null;
+        int delta = 0;
+        int binCount = 0;
+        for (Node<K,V>[] tab = table;;) {
+            Node<K,V> f; int n, i, fh;
+            if (tab == null || (n = tab.length) == 0)
+                tab = initTable();
+            else if ((f = tabAt(tab, i = (n - 1) & h)) == null) {
+                if (casTabAt(tab, i, null, new Node<K,V>(h, key, value, null))) {
+                    delta = 1;
+                    val = value;
+                    break;
+                }
+            }
+            else if ((fh = f.hash) == MOVED)
+                tab = helpTransfer(tab, f);
+            else {
+                synchronized (f) {
+                    if (tabAt(tab, i) == f) {
+                        if (fh >= 0) {
+                            binCount = 1;
+                            for (Node<K,V> e = f, pred = null;; ++binCount) {
+                                K ek;
+                                if (e.hash == h &&
+                                        ((ek = e.key) == key ||
+                                                (ek != null && key.equals(ek)))) {
+                                    val = remappingFunction.apply(e.val, value);
+                                    if (val != null)
+                                        e.val = val;
+                                    else {
+                                        delta = -1;
+                                        Node<K,V> en = e.next;
+                                        if (pred != null)
+                                            pred.next = en;
+                                        else
+                                            setTabAt(tab, i, en);
+                                    }
+                                    break;
+                                }
+                                pred = e;
+                                if ((e = e.next) == null) {
+                                    delta = 1;
+                                    val = value;
+                                    pred.next =
+                                            new Node<K,V>(h, key, val, null);
+                                    break;
+                                }
+                            }
+                        }
+                        else if (f instanceof TreeBin) {
+                            binCount = 2;
+                            TreeBin<K,V> t = (TreeBin<K,V>)f;
+                            TreeNode<K,V> r = t.root;
+                            TreeNode<K,V> p = (r == null) ? null :
+                                    r.findTreeNode(h, key, null);
+                            val = (p == null) ? value :
+                                    remappingFunction.apply(p.val, value);
+                            if (val != null) {
+                                if (p != null)
+                                    p.val = val;
+                                else {
+                                    delta = 1;
+                                    t.putTreeVal(h, key, val);
+                                }
+                            }
+                            else if (p != null) {
+                                delta = -1;
+                                if (t.removeTreeNode(p))
+                                    setTabAt(tab, i, untreeify(t.first));
+                            }
+                        }
+                    }
+                }
+                if (binCount != 0) {
+                    if (binCount >= TREEIFY_THRESHOLD)
+                        treeifyBin(tab, i);
+                    break;
+                }
+            }
+        }
+        if (delta != 0)
+            addCount((long)delta, binCount);
+        return val;
+    }
+
+    // Hashtable legacy methods
+
+    /**
+     * Legacy method testing if some key maps into the specified value
+     * in this table.  This method is identical in functionality to
+     * {@link #containsValue(Object)}, and exists solely to ensure
+     * full compatibility with class {@link java.util.Hashtable},
+     * which supported this method prior to introduction of the
+     * Java Collections framework.
+     *
+     * @param  value a value to search for
+     * @return {@code true} if and only if some key maps to the
+     *         {@code value} argument in this table as
+     *         determined by the {@code equals} method;
+     *         {@code false} otherwise
+     * @throws NullPointerException if the specified value is null
+     */
+    @Deprecated public boolean contains(Object value) {
+        return containsValue(value);
+    }
+
+    /**
+     * Returns an enumeration of the keys in this table.
+     *
+     * @return an enumeration of the keys in this table
+     * @see #keySet()
+     */
+    public Enumeration<K> keys() {
+        Node<K,V>[] t;
+        int f = (t = table) == null ? 0 : t.length;
+        return new KeyIterator<K,V>(t, f, 0, f, this);
+    }
+
+    /**
+     * Returns an enumeration of the values in this table.
+     *
+     * @return an enumeration of the values in this table
+     * @see #values()
+     */
+    public Enumeration<V> elements() {
+        Node<K,V>[] t;
+        int f = (t = table) == null ? 0 : t.length;
+        return new ValueIterator<K,V>(t, f, 0, f, this);
+    }
+
+    // ConcurrentHashMapV8-only methods
+
+    /**
+     * Returns the number of mappings. This method should be used
+     * instead of {@link #size} because a ConcurrentHashMapV8 may
+     * contain more mappings than can be represented as an int. The
+     * value returned is an estimate; the actual count may differ if
+     * there are concurrent insertions or removals.
+     *
+     * @return the number of mappings
+     * @since 1.8
+     */
+    public long mappingCount() {
+        long n = sumCount();
+        return (n < 0L) ? 0L : n; // ignore transient negative values
+    }
+
+    /**
+     * Creates a new {@link Set} backed by a ConcurrentHashMapV8
+     * from the given type to {@code Boolean.TRUE}.
+     *
+     * @return the new set
+     * @since 1.8
+     */
+    public static <K> KeySetView<K,Boolean> newKeySet() {
+        return new KeySetView<K,Boolean>
+                (new ConcurrentHashMapV8<K,Boolean>(), Boolean.TRUE);
+    }
+
+    /**
+     * Creates a new {@link Set} backed by a ConcurrentHashMapV8
+     * from the given type to {@code Boolean.TRUE}.
+     *
+     * @param initialCapacity The implementation performs internal
+     * sizing to accommodate this many elements.
+     * @throws IllegalArgumentException if the initial capacity of
+     * elements is negative
+     * @return the new set
+     * @since 1.8
+     */
+    public static <K> KeySetView<K,Boolean> newKeySet(int initialCapacity) {
+        return new KeySetView<K,Boolean>
+                (new ConcurrentHashMapV8<K,Boolean>(initialCapacity), Boolean.TRUE);
+    }
+
+    /**
+     * Returns a {@link Set} view of the keys in this map, using the
+     * given common mapped value for any additions (i.e., {@link
+     * Collection#add} and {@link Collection#addAll(Collection)}).
+     * This is of course only appropriate if it is acceptable to use
+     * the same value for all additions from this view.
+     *
+     * @param mappedValue the mapped value to use for any additions
+     * @return the set view
+     * @throws NullPointerException if the mappedValue is null
+     */
+    public KeySetView<K,V> keySet(V mappedValue) {
+        if (mappedValue == null)
+            throw new NullPointerException();
+        return new KeySetView<K,V>(this, mappedValue);
+    }
+
+    /* ---------------- Special Nodes -------------- */
+
+    /**
+     * A node inserted at head of bins during transfer operations.
+     */
+    static final class ForwardingNode<K,V> extends Node<K,V> {
+        final Node<K,V>[] nextTable;
+        ForwardingNode(Node<K,V>[] tab) {
+            super(MOVED, null, null, null);
+            this.nextTable = tab;
+        }
+
+        Node<K,V> find(int h, Object k) {
+            // loop to avoid arbitrarily deep recursion on forwarding nodes
+            outer: for (Node<K,V>[] tab = nextTable;;) {
+                Node<K,V> e; int n;
+                if (k == null || tab == null || (n = tab.length) == 0 ||
+                        (e = tabAt(tab, (n - 1) & h)) == null)
+                    return null;
+                for (;;) {
+                    int eh; K ek;
+                    if ((eh = e.hash) == h &&
+                            ((ek = e.key) == k || (ek != null && k.equals(ek))))
+                        return e;
+                    if (eh < 0) {
+                        if (e instanceof ForwardingNode) {
+                            tab = ((ForwardingNode<K,V>)e).nextTable;
+                            continue outer;
+                        }
+                        else
+                            return e.find(h, k);
+                    }
+                    if ((e = e.next) == null)
+                        return null;
+                }
+            }
+        }
+    }
+
+    /**
+     * A place-holder node used in computeIfAbsent and compute
+     */
+    static final class ReservationNode<K,V> extends Node<K,V> {
+        ReservationNode() {
+            super(RESERVED, null, null, null);
+        }
+
+        Node<K,V> find(int h, Object k) {
+            return null;
+        }
+    }
+
+    /* ---------------- Table Initialization and Resizing -------------- */
+
+    /**
+     * Initializes table, using the size recorded in sizeCtl.
+     */
+    private final Node<K,V>[] initTable() {
+        Node<K,V>[] tab; int sc;
+        while ((tab = table) == null || tab.length == 0) {
+            if ((sc = sizeCtl) < 0)
+                Thread.yield(); // lost initialization race; just spin
+            else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
+                try {
+                    if ((tab = table) == null || tab.length == 0) {
+                        int n = (sc > 0) ? sc : DEFAULT_CAPACITY;
+                        @SuppressWarnings({"rawtypes","unchecked"})
+                        Node<K,V>[] nt = (Node<K,V>[])new Node[n];
+                        table = tab = nt;
+                        sc = n - (n >>> 2);
+                    }
+                } finally {
+                    sizeCtl = sc;
+                }
+                break;
+            }
+        }
+        return tab;
+    }
+
+    /**
+     * Adds to count, and if table is too small and not already
+     * resizing, initiates transfer. If already resizing, helps
+     * perform transfer if work is available.  Rechecks occupancy
+     * after a transfer to see if another resize is already needed
+     * because resizings are lagging additions.
+     *
+     * @param x the count to add
+     * @param check if <0, don't check resize, if <= 1 only check if uncontended
+     */
+    private final void addCount(long x, int check) {
+        CounterCell[] as; long b, s;
+        if ((as = counterCells) != null ||
+                !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) {
+            CounterHashCode hc; CounterCell a; long v; int m;
+            boolean uncontended = true;
+            if ((hc = threadCounterHashCode.get()) == null ||
+                    as == null || (m = as.length - 1) < 0 ||
+                    (a = as[m & hc.code]) == null ||
+                    !(uncontended =
+                            U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) {
+                fullAddCount(x, hc, uncontended);
+                return;
+            }
+            if (check <= 1)
+                return;
+            s = sumCount();
+        }
+        if (check >= 0) {
+            Node<K,V>[] tab, nt; int sc;
+            while (s >= (long)(sc = sizeCtl) && (tab = table) != null &&
+                    tab.length < MAXIMUM_CAPACITY) {
+                if (sc < 0) {
+                    if (sc == -1 || transferIndex <= transferOrigin ||
+                            (nt = nextTable) == null)
+                        break;
+                    if (U.compareAndSwapInt(this, SIZECTL, sc, sc - 1))
+                        transfer(tab, nt);
+                }
+                else if (U.compareAndSwapInt(this, SIZECTL, sc, -2))
+                    transfer(tab, null);
+                s = sumCount();
+            }
+        }
+    }
+
+    /**
+     * Helps transfer if a resize is in progress.
+     */
+    final Node<K,V>[] helpTransfer(Node<K,V>[] tab, Node<K,V> f) {
+        Node<K,V>[] nextTab; int sc;
+        if ((f instanceof ForwardingNode) &&
+                (nextTab = ((ForwardingNode<K,V>)f).nextTable) != null) {
+            if (nextTab == nextTable && tab == table &&
+                    transferIndex > transferOrigin && (sc = sizeCtl) < -1 &&
+                    U.compareAndSwapInt(this, SIZECTL, sc, sc - 1))
+                transfer(tab, nextTab);
+            return nextTab;
+        }
+        return table;
+    }
+
+    /**
+     * Tries to presize table to accommodate the given number of elements.
+     *
+     * @param size number of elements (doesn't need to be perfectly accurate)
+     */
+    private final void tryPresize(int size) {
+        int c = (size >= (MAXIMUM_CAPACITY >>> 1)) ? MAXIMUM_CAPACITY :
+                tableSizeFor(size + (size >>> 1) + 1);
+        int sc;
+        while ((sc = sizeCtl) >= 0) {
+            Node<K,V>[] tab = table; int n;
+            if (tab == null || (n = tab.length) == 0) {
+                n = (sc > c) ? sc : c;
+                if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
+                    try {
+                        if (table == tab) {
+                            @SuppressWarnings({"rawtypes","unchecked"})
+                            Node<K,V>[] nt = (Node<K,V>[])new Node[n];
+                            table = nt;
+                            sc = n - (n >>> 2);
+                        }
+                    } finally {
+                        sizeCtl = sc;
+                    }
+                }
+            }
+            else if (c <= sc || n >= MAXIMUM_CAPACITY)
+                break;
+            else if (tab == table &&
+                    U.compareAndSwapInt(this, SIZECTL, sc, -2))
+                transfer(tab, null);
+        }
+    }
+
+    /**
+     * Moves and/or copies the nodes in each bin to new table. See
+     * above for explanation.
+     */
+    private final void transfer(Node<K,V>[] tab, Node<K,V>[] nextTab) {
+        int n = tab.length, stride;
+        if ((stride = (NCPU > 1) ? (n >>> 3) / NCPU : n) < MIN_TRANSFER_STRIDE)
+            stride = MIN_TRANSFER_STRIDE; // subdivide range
+        if (nextTab == null) {            // initiating
+            try {
+                @SuppressWarnings({"rawtypes","unchecked"})
+                Node<K,V>[] nt = (Node<K,V>[])new Node[n << 1];
+                nextTab = nt;
+            } catch (Throwable ex) {      // try to cope with OOME
+                sizeCtl = Integer.MAX_VALUE;
+                return;
+            }
+            nextTable = nextTab;
+            transferOrigin = n;
+            transferIndex = n;
+            ForwardingNode<K,V> rev = new ForwardingNode<K,V>(tab);
+            for (int k = n; k > 0;) {    // progressively reveal ready slots
+                int nextk = (k > stride) ? k - stride : 0;
+                for (int m = nextk; m < k; ++m)
+                    nextTab[m] = rev;
+                for (int m = n + nextk; m < n + k; ++m)
+                    nextTab[m] = rev;
+                U.putOrderedInt(this, TRANSFERORIGIN, k = nextk);
+            }
+        }
+        int nextn = nextTab.length;
+        ForwardingNode<K,V> fwd = new ForwardingNode<K,V>(nextTab);
+        boolean advance = true;
+        boolean finishing = false; // to ensure sweep before committing nextTab
+        for (int i = 0, bound = 0;;) {
+            int nextIndex, nextBound, fh; Node<K,V> f;
+            while (advance) {
+                if (--i >= bound || finishing)
+                    advance = false;
+                else if ((nextIndex = transferIndex) <= transferOrigin) {
+                    i = -1;
+                    advance = false;
+                }
+                else if (U.compareAndSwapInt
+                        (this, TRANSFERINDEX, nextIndex,
+                                nextBound = (nextIndex > stride ?
+                                        nextIndex - stride : 0))) {
+                    bound = nextBound;
+                    i = nextIndex - 1;
+                    advance = false;
+                }
+            }
+            if (i < 0 || i >= n || i + n >= nextn) {
+                if (finishing) {
+                    nextTable = null;
+                    table = nextTab;
+                    sizeCtl = (n << 1) - (n >>> 1);
+                    return;
+                }
+                for (int sc;;) {
+                    if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, ++sc)) {
+                        if (sc != -1)
+                            return;
+                        finishing = advance = true;
+                        i = n; // recheck before commit
+                        break;
+                    }
+                }
+            }
+            else if ((f = tabAt(tab, i)) == null) {
+                if (casTabAt(tab, i, null, fwd)) {
+                    setTabAt(nextTab, i, null);
+                    setTabAt(nextTab, i + n, null);
+                    advance = true;
+                }
+            }
+            else if ((fh = f.hash) == MOVED)
+                advance = true; // already processed
+            else {
+                synchronized (f) {
+                    if (tabAt(tab, i) == f) {
+                        Node<K,V> ln, hn;
+                        if (fh >= 0) {
+                            int runBit = fh & n;
+                            Node<K,V> lastRun = f;
+                            for (Node<K,V> p = f.next; p != null; p = p.next) {
+                                int b = p.hash & n;
+                                if (b != runBit) {
+                                    runBit = b;
+                                    lastRun = p;
+                                }
+                            }
+                            if (runBit == 0) {
+                                ln = lastRun;
+                                hn = null;
+                            }
+                            else {
+                                hn = lastRun;
+                                ln = null;
+                            }
+                            for (Node<K,V> p = f; p != lastRun; p = p.next) {
+                                int ph = p.hash; K pk = p.key; V pv = p.val;
+                                if ((ph & n) == 0)
+                                    ln = new Node<K,V>(ph, pk, pv, ln);
+                                else
+                                    hn = new Node<K,V>(ph, pk, pv, hn);
+                            }
+                            setTabAt(nextTab, i, ln);
+                            setTabAt(nextTab, i + n, hn);
+                            setTabAt(tab, i, fwd);
+                            advance = true;
+                        }
+                        else if (f instanceof TreeBin) {
+                            TreeBin<K,V> t = (TreeBin<K,V>)f;
+                            TreeNode<K,V> lo = null, loTail = null;
+                            TreeNode<K,V> hi = null, hiTail = null;
+                            int lc = 0, hc = 0;
+                            for (Node<K,V> e = t.first; e != null; e = e.next) {
+                                int h = e.hash;
+                                TreeNode<K,V> p = new TreeNode<K,V>
+                                        (h, e.key, e.val, null, null);
+                                if ((h & n) == 0) {
+                                    if ((p.prev = loTail) == null)
+                                        lo = p;
+                                    else
+                                        loTail.next = p;
+                                    loTail = p;
+                                    ++lc;
+                                }
+                                else {
+                                    if ((p.prev = hiTail) == null)
+                                        hi = p;
+                                    else
+                                        hiTail.next = p;
+                                    hiTail = p;
+                                    ++hc;
+                                }
+                            }
+                            ln = (lc <= UNTREEIFY_THRESHOLD) ? untreeify(lo) :
+                                    (hc != 0) ? new TreeBin<K,V>(lo) : t;
+                            hn = (hc <= UNTREEIFY_THRESHOLD) ? untreeify(hi) :
+                                    (lc != 0) ? new TreeBin<K,V>(hi) : t;
+                            setTabAt(nextTab, i, ln);
+                            setTabAt(nextTab, i + n, hn);
+                            setTabAt(tab, i, fwd);
+                            advance = true;
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    /* ---------------- Conversion from/to TreeBins -------------- */
+
+    /**
+     * Replaces all linked nodes in bin at given index unless table is
+     * too small, in which case resizes instead.
+     */
+    private final void treeifyBin(Node<K,V>[] tab, int index) {
+        Node<K,V> b; int n, sc;
+        if (tab != null) {
+            if ((n = tab.length) < MIN_TREEIFY_CAPACITY) {
+                if (tab == table && (sc = sizeCtl) >= 0 &&
+                        U.compareAndSwapInt(this, SIZECTL, sc, -2))
+                    transfer(tab, null);
+            }
+            else if ((b = tabAt(tab, index)) != null && b.hash >= 0) {
+                synchronized (b) {
+                    if (tabAt(tab, index) == b) {
+                        TreeNode<K,V> hd = null, tl = null;
+                        for (Node<K,V> e = b; e != null; e = e.next) {
+                            TreeNode<K,V> p =
+                                    new TreeNode<K,V>(e.hash, e.key, e.val,
+                                            null, null);
+                            if ((p.prev = tl) == null)
+                                hd = p;
+                            else
+                                tl.next = p;
+                            tl = p;
+                        }
+                        setTabAt(tab, index, new TreeBin<K,V>(hd));
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Returns a list on non-TreeNodes replacing those in given list.
+     */
+    static <K,V> Node<K,V> untreeify(Node<K,V> b) {
+        Node<K,V> hd = null, tl = null;
+        for (Node<K,V> q = b; q != null; q = q.next) {
+            Node<K,V> p = new Node<K,V>(q.hash, q.key, q.val, null);
+            if (tl == null)
+                hd = p;
+            else
+                tl.next = p;
+            tl = p;
+        }
+        return hd;
+    }
+
+    /* ---------------- TreeNodes -------------- */
+
+    /**
+     * Nodes for use in TreeBins
+     */
+    static final class TreeNode<K,V> extends Node<K,V> {
+        TreeNode<K,V> parent;  // red-black tree links
+        TreeNode<K,V> left;
+        TreeNode<K,V> right;
+        TreeNode<K,V> prev;    // needed to unlink next upon deletion
+        boolean red;
+
+        TreeNode(int hash, K key, V val, Node<K,V> next,
+                 TreeNode<K,V> parent) {
+            super(hash, key, val, next);
+            this.parent = parent;
+        }
+
+        Node<K,V> find(int h, Object k) {
+            return findTreeNode(h, k, null);
+        }
+
+        /**
+         * Returns the TreeNode (or null if not found) for the given key
+         * starting at given root.
+         */
+        final TreeNode<K,V> findTreeNode(int h, Object k, Class<?> kc) {
+            if (k != null) {
+                TreeNode<K,V> p = this;
+                do  {
+                    int ph, dir; K pk; TreeNode<K,V> q;
+                    TreeNode<K,V> pl = p.left, pr = p.right;
+                    if ((ph = p.hash) > h)
+                        p = pl;
+                    else if (ph < h)
+                        p = pr;
+                    else if ((pk = p.key) == k || (pk != null && k.equals(pk)))
+                        return p;
+                    else if (pl == null && pr == null)
+                        break;
+                    else if ((kc != null ||
+                            (kc = comparableClassFor(k)) != null) &&
+                            (dir = compareComparables(kc, k, pk)) != 0)
+                        p = (dir < 0) ? pl : pr;
+                    else if (pl == null)
+                        p = pr;
+                    else if (pr == null ||
+                            (q = pr.findTreeNode(h, k, kc)) == null)
+                        p = pl;
+                    else
+                        return q;
+                } while (p != null);
+            }
+            return null;
+        }
+    }
+
+    /* ---------------- TreeBins -------------- */
+
+    /**
+     * TreeNodes used at the heads of bins. TreeBins do not hold user
+     * keys or values, but instead point to list of TreeNodes and
+     * their root. They also maintain a parasitic read-write lock
+     * forcing writers (who hold bin lock) to wait for readers (who do
+     * not) to complete before tree restructuring operations.
+     */
+    static final class TreeBin<K,V> extends Node<K,V> {
+        TreeNode<K,V> root;
+        volatile TreeNode<K,V> first;
+        volatile Thread waiter;
+        volatile int lockState;
+        // values for lockState
+        static final int WRITER = 1; // set while holding write lock
+        static final int WAITER = 2; // set when waiting for write lock
+        static final int READER = 4; // increment value for setting read lock
+
+        /**
+         * Creates bin with initial set of nodes headed by b.
+         */
+        TreeBin(TreeNode<K,V> b) {
+            super(TREEBIN, null, null, null);
+            this.first = b;
+            TreeNode<K,V> r = null;
+            for (TreeNode<K,V> x = b, next; x != null; x = next) {
+                next = (TreeNode<K,V>)x.next;
+                x.left = x.right = null;
+                if (r == null) {
+                    x.parent = null;
+                    x.red = false;
+                    r = x;
+                }
+                else {
+                    Object key = x.key;
+                    int hash = x.hash;
+                    Class<?> kc = null;
+                    for (TreeNode<K,V> p = r;;) {
+                        int dir, ph;
+                        if ((ph = p.hash) > hash)
+                            dir = -1;
+                        else if (ph < hash)
+                            dir = 1;
+                        else if ((kc != null ||
+                                (kc = comparableClassFor(key)) != null))
+                            dir = compareComparables(kc, key, p.key);
+                        else
+                            dir = 0;
+                        TreeNode<K,V> xp = p;
+                        if ((p = (dir <= 0) ? p.left : p.right) == null) {
+                            x.parent = xp;
+                            if (dir <= 0)
+                                xp.left = x;
+                            else
+                                xp.right = x;
+                            r = balanceInsertion(r, x);
+                            break;
+                        }
+                    }
+                }
+            }
+            this.root = r;
+        }
+
+        /**
+         * Acquires write lock for tree restructuring.
+         */
+        private final void lockRoot() {
+            if (!U.compareAndSwapInt(this, LOCKSTATE, 0, WRITER))
+                contendedLock(); // offload to separate method
+        }
+
+        /**
+         * Releases write lock for tree restructuring.
+         */
+        private final void unlockRoot() {
+            lockState = 0;
+        }
+
+        /**
+         * Possibly blocks awaiting root lock.
+         */
+        private final void contendedLock() {
+            boolean waiting = false;
+            for (int s;;) {
+                if (((s = lockState) & WRITER) == 0) {
+                    if (U.compareAndSwapInt(this, LOCKSTATE, s, WRITER)) {
+                        if (waiting)
+                            waiter = null;
+                        return;
+                    }
+                }
+                else if ((s & WAITER) == 0) {
+                    if (U.compareAndSwapInt(this, LOCKSTATE, s, s | WAITER)) {
+                        waiting = true;
+                        waiter = Thread.currentThread();
+                    }
+                }
+                else if (waiting)
+                    LockSupport.park(this);
+            }
+        }
+
+        /**
+         * Returns matching node or null if none. Tries to search
+         * using tree comparisons from root, but continues linear
+         * search when lock not available.
+         */
+        final Node<K,V> find(int h, Object k) {
+            if (k != null) {
+                for (Node<K,V> e = first; e != null; e = e.next) {
+                    int s; K ek;
+                    if (((s = lockState) & (WAITER|WRITER)) != 0) {
+                        if (e.hash == h &&
+                                ((ek = e.key) == k || (ek != null && k.equals(ek))))
+                            return e;
+                    }
+                    else if (U.compareAndSwapInt(this, LOCKSTATE, s,
+                            s + READER)) {
+                        TreeNode<K,V> r, p;
+                        try {
+                            p = ((r = root) == null ? null :
+                                    r.findTreeNode(h, k, null));
+                        } finally {
+                            Thread w;
+                            int ls;
+                            do {} while (!U.compareAndSwapInt
+                                    (this, LOCKSTATE,
+                                            ls = lockState, ls - READER));
+                            if (ls == (READER|WAITER) && (w = waiter) != null)
+                                LockSupport.unpark(w);
+                        }
+                        return p;
+                    }
+                }
+            }
+            return null;
+        }
+
+        /**
+         * Finds or adds a node.
+         * @return null if added
+         */
+        final TreeNode<K,V> putTreeVal(int h, K k, V v) {
+            Class<?> kc = null;
+            for (TreeNode<K,V> p = root;;) {
+                int dir, ph; K pk; TreeNode<K,V> q, pr;
+                if (p == null) {
+                    first = root = new TreeNode<K,V>(h, k, v, null, null);
+                    break;
+                }
+                else if ((ph = p.hash) > h)
+                    dir = -1;
+                else if (ph < h)
+                    dir = 1;
+                else if ((pk = p.key) == k || (pk != null && k.equals(pk)))
+                    return p;
+                else if ((kc == null &&
+                        (kc = comparableClassFor(k)) == null) ||
+                        (dir = compareComparables(kc, k, pk)) == 0) {
+                    if (p.left == null)
+                        dir = 1;
+                    else if ((pr = p.right) == null ||
+                            (q = pr.findTreeNode(h, k, kc)) == null)
+                        dir = -1;
+                    else
+                        return q;
+                }
+                TreeNode<K,V> xp = p;
+                if ((p = (dir < 0) ? p.left : p.right) == null) {
+                    TreeNode<K,V> x, f = first;
+                    first = x = new TreeNode<K,V>(h, k, v, f, xp);
+                    if (f != null)
+                        f.prev = x;
+                    if (dir < 0)
+                        xp.left = x;
+                    else
+                        xp.right = x;
+                    if (!xp.red)
+                        x.red = true;
+                    else {
+                        lockRoot();
+                        try {
+                            root = balanceInsertion(root, x);
+                        } finally {
+                            unlockRoot();
+                        }
+                    }
+                    break;
+                }
+            }
+            assert checkInvariants(root);
+            return null;
+        }
+
+        /**
+         * Removes the given node, that must be present before this
+         * call.  This is messier than typical red-black deletion code
+         * because we cannot swap the contents of an interior node
+         * with a leaf successor that is pinned by "next" pointers
+         * that are accessible independently of lock. So instead we
+         * swap the tree linkages.
+         *
+         * @return true if now too small, so should be untreeified
+         */
+        final boolean removeTreeNode(TreeNode<K,V> p) {
+            TreeNode<K,V> next = (TreeNode<K,V>)p.next;
+            TreeNode<K,V> pred = p.prev;  // unlink traversal pointers
+            TreeNode<K,V> r, rl;
+            if (pred == null)
+                first = next;
+            else
+                pred.next = next;
+            if (next != null)
+                next.prev = pred;
+            if (first == null) {
+                root = null;
+                return true;
+            }
+            if ((r = root) == null || r.right == null || // too small
+                    (rl = r.left) == null || rl.left == null)
+                return true;
+            lockRoot();
+            try {
+                TreeNode<K,V> replacement;
+                TreeNode<K,V> pl = p.left;
+                TreeNode<K,V> pr = p.right;
+                if (pl != null && pr != null) {
+                    TreeNode<K,V> s = pr, sl;
+                    while ((sl = s.left) != null) // find successor
+                        s = sl;
+                    boolean c = s.red; s.red = p.red; p.red = c; // swap colors
+                    TreeNode<K,V> sr = s.right;
+                    TreeNode<K,V> pp = p.parent;
+                    if (s == pr) { // p was s's direct parent
+                        p.parent = s;
+                        s.right = p;
+                    }
+                    else {
+                        TreeNode<K,V> sp = s.parent;
+                        if ((p.parent = sp) != null) {
+                            if (s == sp.left)
+                                sp.left = p;
+                            else
+                                sp.right = p;
+                        }
+                        if ((s.right = pr) != null)
+                            pr.parent = s;
+                    }
+                    p.left = null;
+                    if ((p.right = sr) != null)
+                        sr.parent = p;
+                    if ((s.left = pl) != null)
+                        pl.parent = s;
+                    if ((s.parent = pp) == null)
+                        r = s;
+                    else if (p == pp.left)
+                        pp.left = s;
+                    else
+                        pp.right = s;
+                    if (sr != null)
+                        replacement = sr;
+                    else
+                        replacement = p;
+                }
+                else if (pl != null)
+                    replacement = pl;
+                else if (pr != null)
+                    replacement = pr;
+                else
+                    replacement = p;
+                if (replacement != p) {
+                    TreeNode<K,V> pp = replacement.parent = p.parent;
+                    if (pp == null)
+                        r = replacement;
+                    else if (p == pp.left)
+                        pp.left = replacement;
+                    else
+                        pp.right = replacement;
+                    p.left = p.right = p.parent = null;
+                }
+
+                root = (p.red) ? r : balanceDeletion(r, replacement);
+
+                if (p == replacement) {  // detach pointers
+                    TreeNode<K,V> pp;
+                    if ((pp = p.parent) != null) {
+                        if (p == pp.left)
+                            pp.left = null;
+                        else if (p == pp.right)
+                            pp.right = null;
+                        p.parent = null;
+                    }
+                }
+            } finally {
+                unlockRoot();
+            }
+            assert checkInvariants(root);
+            return false;
+        }
+
+        /* ------------------------------------------------------------ */
+        // Red-black tree methods, all adapted from CLR
+
+        static <K,V> TreeNode<K,V> rotateLeft(TreeNode<K,V> root,
+                                              TreeNode<K,V> p) {
+            TreeNode<K,V> r, pp, rl;
+            if (p != null && (r = p.right) != null) {
+                if ((rl = p.right = r.left) != null)
+                    rl.parent = p;
+                if ((pp = r.parent = p.parent) == null)
+                    (root = r).red = false;
+                else if (pp.left == p)
+                    pp.left = r;
+                else
+                    pp.right = r;
+                r.left = p;
+                p.parent = r;
+            }
+            return root;
+        }
+
+        static <K,V> TreeNode<K,V> rotateRight(TreeNode<K,V> root,
+                                               TreeNode<K,V> p) {
+            TreeNode<K,V> l, pp, lr;
+            if (p != null && (l = p.left) != null) {
+                if ((lr = p.left = l.right) != null)
+                    lr.parent = p;
+                if ((pp = l.parent = p.parent) == null)
+                    (root = l).red = false;
+                else if (pp.right == p)
+                    pp.right = l;
+                else
+                    pp.left = l;
+                l.right = p;
+                p.parent = l;
+            }
+            return root;
+        }
+
+        static <K,V> TreeNode<K,V> balanceInsertion(TreeNode<K,V> root,
+                                                    TreeNode<K,V> x) {
+            x.red = true;
+            for (TreeNode<K,V> xp, xpp, xppl, xppr;;) {
+                if ((xp = x.parent) == null) {
+                    x.red = false;
+                    return x;
+                }
+                else if (!xp.red || (xpp = xp.parent) == null)
+                    return root;
+                if (xp == (xppl = xpp.left)) {
+                    if ((xppr = xpp.right) != null && xppr.red) {
+                        xppr.red = false;
+                        xp.red = false;
+                        xpp.red = true;
+                        x = xpp;
+                    }
+                    else {
+                        if (x == xp.right) {
+                            root = rotateLeft(root, x = xp);
+                            xpp = (xp = x.parent) == null ? null : xp.parent;
+                        }
+                        if (xp != null) {
+                            xp.red = false;
+                            if (xpp != null) {
+                                xpp.red = true;
+                                root = rotateRight(root, xpp);
+                            }
+                        }
+                    }
+                }
+                else {
+                    if (xppl != null && xppl.red) {
+                        xppl.red = false;
+                        xp.red = false;
+                        xpp.red = true;
+                        x = xpp;
+                    }
+                    else {
+                        if (x == xp.left) {
+                            root = rotateRight(root, x = xp);
+                            xpp = (xp = x.parent) == null ? null : xp.parent;
+                        }
+                        if (xp != null) {
+                            xp.red = false;
+                            if (xpp != null) {
+                                xpp.red = true;
+                                root = rotateLeft(root, xpp);
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        static <K,V> TreeNode<K,V> balanceDeletion(TreeNode<K,V> root,
+                                                   TreeNode<K,V> x) {
+            for (TreeNode<K,V> xp, xpl, xpr;;)  {
+                if (x == null || x == root)
+                    return root;
+                else if ((xp = x.parent) == null) {
+                    x.red = false;
+                    return x;
+                }
+                else if (x.red) {
+                    x.red = false;
+                    return root;
+                }
+                else if ((xpl = xp.left) == x) {
+                    if ((xpr = xp.right) != null && xpr.red) {
+                        xpr.red = false;
+                        xp.red = true;
+                        root = rotateLeft(root, xp);
+                        xpr = (xp = x.parent) == null ? null : xp.right;
+                    }
+                    if (xpr == null)
+                        x = xp;
+                    else {
+                        TreeNode<K,V> sl = xpr.left, sr = xpr.right;
+                        if ((sr == null || !sr.red) &&
+                                (sl == null || !sl.red)) {
+                            xpr.red = true;
+                            x = xp;
+                        }
+                        else {
+                            if (sr == null || !sr.red) {
+                                if (sl != null)
+                                    sl.red = false;
+                                xpr.red = true;
+                                root = rotateRight(root, xpr);
+                                xpr = (xp = x.parent) == null ?
+                                        null : xp.right;
+                            }
+                            if (xpr != null) {
+                                xpr.red = (xp == null) ? false : xp.red;
+                                if ((sr = xpr.right) != null)
+                                    sr.red = false;
+                            }
+                            if (xp != null) {
+                                xp.red = false;
+                                root = rotateLeft(root, xp);
+                            }
+                            x = root;
+                        }
+                    }
+                }
+                else { // symmetric
+                    if (xpl != null && xpl.red) {
+                        xpl.red = false;
+                        xp.red = true;
+                        root = rotateRight(root, xp);
+                        xpl = (xp = x.parent) == null ? null : xp.left;
+                    }
+                    if (xpl == null)
+                        x = xp;
+                    else {
+                        TreeNode<K,V> sl = xpl.left, sr = xpl.right;
+                        if ((sl == null || !sl.red) &&
+                                (sr == null || !sr.red)) {
+                            xpl.red = true;
+                            x = xp;
+                        }
+                        else {
+                            if (sl == null || !sl.red) {
+                                if (sr != null)
+                                    sr.red = false;
+                                xpl.red = true;
+                                root = rotateLeft(root, xpl);
+                                xpl = (xp = x.parent) == null ?
+                                        null : xp.left;
+                            }
+                            if (xpl != null) {
+                                xpl.red = (xp == null) ? false : xp.red;
+                                if ((sl = xpl.left) != null)
+                                    sl.red = false;
+                            }
+                            if (xp != null) {
+                                xp.red = false;
+                                root = rotateRight(root, xp);
+                            }
+                            x = root;
+                        }
+                    }
+                }
+            }
+        }
+
+        /**
+         * Recursive invariant check
+         */
+        static <K,V> boolean checkInvariants(TreeNode<K,V> t) {
+            TreeNode<K,V> tp = t.parent, tl = t.left, tr = t.right,
+                    tb = t.prev, tn = (TreeNode<K,V>)t.next;
+            if (tb != null && tb.next != t)
+                return false;
+            if (tn != null && tn.prev != t)
+                return false;
+            if (tp != null && t != tp.left && t != tp.right)
+                return false;
+            if (tl != null && (tl.parent != t || tl.hash > t.hash))
+                return false;
+            if (tr != null && (tr.parent != t || tr.hash < t.hash))
+                return false;
+            if (t.red && tl != null && tl.red && tr != null && tr.red)
+                return false;
+            if (tl != null && !checkInvariants(tl))
+                return false;
+            if (tr != null && !checkInvariants(tr))
+                return false;
+            return true;
+        }
+
+        private static final sun.misc.Unsafe U;
+        private static final long LOCKSTATE;
+        static {
+            try {
+                U = getUnsafe();
+                Class<?> k = TreeBin.class;
+                LOCKSTATE = U.objectFieldOffset
+                        (k.getDeclaredField("lockState"));
+            } catch (Exception e) {
+                throw new Error(e);
+            }
+        }
+    }
+
+    /* ----------------Table Traversal -------------- */
+
+    /**
+     * Encapsulates traversal for methods such as containsValue; also
+     * serves as a base class for other iterators and spliterators.
+     *
+     * Method advance visits once each still-valid node that was
+     * reachable upon iterator construction. It might miss some that
+     * were added to a bin after the bin was visited, which is OK wrt
+     * consistency guarantees. Maintaining this property in the face
+     * of possible ongoing resizes requires a fair amount of
+     * bookkeeping state that is difficult to optimize away amidst
+     * volatile accesses.  Even so, traversal maintains reasonable
+     * throughput.
+     *
+     * Normally, iteration proceeds bin-by-bin traversing lists.
+     * However, if the table has been resized, then all future steps
+     * must traverse both the bin at the current index as well as at
+     * (index + baseSize); and so on for further resizings. To
+     * paranoically cope with potential sharing by users of iterators
+     * across threads, iteration terminates if a bounds checks fails
+     * for a table read.
+     */
+    static class Traverser<K,V> {
+        Node<K,V>[] tab;        // current table; updated if resized
+        Node<K,V> next;         // the next entry to use
+        int index;              // index of bin to use next
+        int baseIndex;          // current index of initial table
+        int baseLimit;          // index bound for initial table
+        final int baseSize;     // initial table size
+
+        Traverser(Node<K,V>[] tab, int size, int index, int limit) {
+            this.tab = tab;
+            this.baseSize = size;
+            this.baseIndex = this.index = index;
+            this.baseLimit = limit;
+            this.next = null;
+        }
+
+        /**
+         * Advances if possible, returning next valid node, or null if none.
+         */
+        final Node<K,V> advance() {
+            Node<K,V> e;
+            if ((e = next) != null)
+                e = e.next;
+            for (;;) {
+                Node<K,V>[] t; int i, n; K ek;  // must use locals in checks
+                if (e != null)
+                    return next = e;
+                if (baseIndex >= baseLimit || (t = tab) == null ||
+                        (n = t.length) <= (i = index) || i < 0)
+                    return next = null;
+                if ((e = tabAt(t, index)) != null && e.hash < 0) {
+                    if (e instanceof ForwardingNode) {
+                        tab = ((ForwardingNode<K,V>)e).nextTable;
+                        e = null;
+                        continue;
+                    }
+                    else if (e instanceof TreeBin)
+                        e = ((TreeBin<K,V>)e).first;
+                    else
+                        e = null;
+                }
+                if ((index += baseSize) >= n)
+                    index = ++baseIndex;    // visit upper slots if present
+            }
+        }
+    }
+
+    /**
+     * Base of key, value, and entry Iterators. Adds fields to
+     * Traverser to support iterator.remove.
+     */
+    static class BaseIterator<K,V> extends Traverser<K,V> {
+        final ConcurrentHashMapV8<K,V> map;
+        Node<K,V> lastReturned;
+        BaseIterator(Node<K,V>[] tab, int size, int index, int limit,
+                     ConcurrentHashMapV8<K,V> map) {
+            super(tab, size, index, limit);
+            this.map = map;
+            advance();
+        }
+
+        public final boolean hasNext() { return next != null; }
+        public final boolean hasMoreElements() { return next != null; }
+
+        public final void remove() {
+            Node<K,V> p;
+            if ((p = lastReturned) == null)
+                throw new IllegalStateException();
+            lastReturned = null;
+            map.replaceNode(p.key, null, null);
+        }
+    }
+
+    static final class KeyIterator<K,V> extends BaseIterator<K,V>
+            implements Iterator<K>, Enumeration<K> {
+        KeyIterator(Node<K,V>[] tab, int index, int size, int limit,
+                    ConcurrentHashMapV8<K,V> map) {
+            super(tab, index, size, limit, map);
+        }
+
+        public final K next() {
+            Node<K,V> p;
+            if ((p = next) == null)
+                throw new NoSuchElementException();
+            K k = p.key;
+            lastReturned = p;
+            advance();
+            return k;
+        }
+
+        public final K nextElement() { return next(); }
+    }
+
+    static final class ValueIterator<K,V> extends BaseIterator<K,V>
+            implements Iterator<V>, Enumeration<V> {
+        ValueIterator(Node<K,V>[] tab, int index, int size, int limit,
+                      ConcurrentHashMapV8<K,V> map) {
+            super(tab, index, size, limit, map);
+        }
+
+        public final V next() {
+            Node<K,V> p;
+            if ((p = next) == null)
+                throw new NoSuchElementException();
+            V v = p.val;
+            lastReturned = p;
+            advance();
+            return v;
+        }
+
+        public final V nextElement() { return next(); }
+    }
+
+    static final class EntryIterator<K,V> extends BaseIterator<K,V>
+            implements Iterator<Map.Entry<K,V>> {
+        EntryIterator(Node<K,V>[] tab, int index, int size, int limit,
+                      ConcurrentHashMapV8<K,V> map) {
+            super(tab, index, size, limit, map);
+        }
+
+        public final Map.Entry<K,V> next() {
+            Node<K,V> p;
+            if ((p = next) == null)
+                throw new NoSuchElementException();
+            K k = p.key;
+            V v = p.val;
+            lastReturned = p;
+            advance();
+            return new MapEntry<K,V>(k, v, map);
+        }
+    }
+
+    /**
+     * Exported Entry for EntryIterator
+     */
+    static final class MapEntry<K,V> implements Map.Entry<K,V> {
+        final K key; // non-null
+        V val;       // non-null
+        final ConcurrentHashMapV8<K,V> map;
+        MapEntry(K key, V val, ConcurrentHashMapV8<K,V> map) {
+            this.key = key;
+            this.val = val;
+            this.map = map;
+        }
+        public K getKey()        { return key; }
+        public V getValue()      { return val; }
+        public int hashCode()    { return key.hashCode() ^ val.hashCode(); }
+        public String toString() { return key + "=" + val; }
+
+        public boolean equals(Object o) {
+            Object k, v; Map.Entry<?,?> e;
+            return ((o instanceof Map.Entry) &&
+                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
+                    (v = e.getValue()) != null &&
+                    (k == key || k.equals(key)) &&
+                    (v == val || v.equals(val)));
+        }
+
+        /**
+         * Sets our entry's value and writes through to the map. The
+         * value to return is somewhat arbitrary here. Since we do not
+         * necessarily track asynchronous changes, the most recent
+         * "previous" value could be different from what we return (or
+         * could even have been removed, in which case the put will
+         * re-establish). We do not and cannot guarantee more.
+         */
+        public V setValue(V value) {
+            if (value == null) throw new NullPointerException();
+            V v = val;
+            val = value;
+            map.put(key, value);
+            return v;
+        }
+    }
+
+    static final class KeySpliterator<K,V> extends Traverser<K,V>
+            implements ConcurrentHashMapSpliterator<K> {
+        long est;               // size estimate
+        KeySpliterator(Node<K,V>[] tab, int size, int index, int limit,
+                       long est) {
+            super(tab, size, index, limit);
+            this.est = est;
+        }
+
+        public ConcurrentHashMapSpliterator<K> trySplit() {
+            int i, f, h;
+            return (h = ((i = baseIndex) + (f = baseLimit)) >>> 1) <= i ? null :
+                    new KeySpliterator<K,V>(tab, baseSize, baseLimit = h,
+                            f, est >>>= 1);
+        }
+
+        public void forEachRemaining(Action<? super K> action) {
+            if (action == null) throw new NullPointerException();
+            for (Node<K,V> p; (p = advance()) != null;)
+                action.apply(p.key);
+        }
+
+        public boolean tryAdvance(Action<? super K> action) {
+            if (action == null) throw new NullPointerException();
+            Node<K,V> p;
+            if ((p = advance()) == null)
+                return false;
+            action.apply(p.key);
+            return true;
+        }
+
+        public long estimateSize() { return est; }
+
+    }
+
+    static final class ValueSpliterator<K,V> extends Traverser<K,V>
+            implements ConcurrentHashMapSpliterator<V> {
+        long est;               // size estimate
+        ValueSpliterator(Node<K,V>[] tab, int size, int index, int limit,
+                         long est) {
+            super(tab, size, index, limit);
+            this.est = est;
+        }
+
+        public ConcurrentHashMapSpliterator<V> trySplit() {
+            int i, f, h;
+            return (h = ((i = baseIndex) + (f = baseLimit)) >>> 1) <= i ? null :
+                    new ValueSpliterator<K,V>(tab, baseSize, baseLimit = h,
+                            f, est >>>= 1);
+        }
+
+        public void forEachRemaining(Action<? super V> action) {
+            if (action == null) throw new NullPointerException();
+            for (Node<K,V> p; (p = advance()) != null;)
+                action.apply(p.val);
+        }
+
+        public boolean tryAdvance(Action<? super V> action) {
+            if (action == null) throw new NullPointerException();
+            Node<K,V> p;
+            if ((p = advance()) == null)
+                return false;
+            action.apply(p.val);
+            return true;
+        }
+
+        public long estimateSize() { return est; }
+
+    }
+
+    static final class EntrySpliterator<K,V> extends Traverser<K,V>
+            implements ConcurrentHashMapSpliterator<Map.Entry<K,V>> {
+        final ConcurrentHashMapV8<K,V> map; // To export MapEntry
+        long est;               // size estimate
+        EntrySpliterator(Node<K,V>[] tab, int size, int index, int limit,
+                         long est, ConcurrentHashMapV8<K,V> map) {
+            super(tab, size, index, limit);
+            this.map = map;
+            this.est = est;
+        }
+
+        public ConcurrentHashMapSpliterator<Map.Entry<K,V>> trySplit() {
+            int i, f, h;
+            return (h = ((i = baseIndex) + (f = baseLimit)) >>> 1) <= i ? null :
+                    new EntrySpliterator<K,V>(tab, baseSize, baseLimit = h,
+                            f, est >>>= 1, map);
+        }
+
+        public void forEachRemaining(Action<? super Map.Entry<K,V>> action) {
+            if (action == null) throw new NullPointerException();
+            for (Node<K,V> p; (p = advance()) != null; )
+                action.apply(new MapEntry<K,V>(p.key, p.val, map));
+        }
+
+        public boolean tryAdvance(Action<? super Map.Entry<K,V>> action) {
+            if (action == null) throw new NullPointerException();
+            Node<K,V> p;
+            if ((p = advance()) == null)
+                return false;
+            action.apply(new MapEntry<K,V>(p.key, p.val, map));
+            return true;
+        }
+
+        public long estimateSize() { return est; }
+
+    }
+
+    // Parallel bulk operations
+
+    /**
+     * Computes initial batch value for bulk tasks. The returned value
+     * is approximately exp2 of the number of times (minus one) to
+     * split task by two before executing leaf action. This value is
+     * faster to compute and more convenient to use as a guide to
+     * splitting than is the depth, since it is used while dividing by
+     * two anyway.
+     */
+    final int batchFor(long b) {
+        long n;
+        if (b == Long.MAX_VALUE || (n = sumCount()) <= 1L || n < b)
+            return 0;
+        int sp = ForkJoinPool.getCommonPoolParallelism() << 2; // slack of 4
+        return (b <= 0L || (n /= b) >= sp) ? sp : (int)n;
+    }
+
+    /**
+     * Performs the given action for each (key, value).
+     *
+     * @param parallelismThreshold the (estimated) number of elements
+     * needed for this operation to be executed in parallel
+     * @param action the action
+     * @since 1.8
+     */
+    public void forEach(long parallelismThreshold,
+                        BiAction<? super K,? super V> action) {
+        if (action == null) throw new NullPointerException();
+        new ForEachMappingTask<K,V>
+                (null, batchFor(parallelismThreshold), 0, 0, table,
+                        action).invoke();
+    }
+
+    /**
+     * Performs the given action for each non-null transformation
+     * of each (key, value).
+     *
+     * @param parallelismThreshold the (estimated) number of elements
+     * needed for this operation to be executed in parallel
+     * @param transformer a function returning the transformation
+     * for an element, or null if there is no transformation (in
+     * which case the action is not applied)
+     * @param action the action
+     * @since 1.8
+     */
+    public <U> void forEach(long parallelismThreshold,
+                            BiFun<? super K, ? super V, ? extends U> transformer,
+                            Action<? super U> action) {
+        if (transformer == null || action == null)
+            throw new NullPointerException();
+        new ForEachTransformedMappingTask<K,V,U>
+                (null, batchFor(parallelismThreshold), 0, 0, table,
+                        transformer, action).invoke();
+    }
+
+    /**
+     * Returns a non-null result from applying the given search
+     * function on each (key, value), or null if none.  Upon
+     * success, further element processing is suppressed and the
+     * results of any other parallel invocations of the search
+     * function are ignored.
+     *
+     * @param parallelismThreshold the (estimated) number of elements
+     * needed for this operation to be executed in parallel
+     * @param searchFunction a function returning a non-null
+     * result on success, else null
+     * @return a non-null result from applying the given search
+     * function on each (key, value), or null if none
+     * @since 1.8
+     */
+    public <U> U search(long parallelismThreshold,
+                        BiFun<? super K, ? super V, ? extends U> searchFunction) {
+        if (searchFunction == null) throw new NullPointerException();
+        return new SearchMappingsTask<K,V,U>
+                (null, batchFor(parallelismThreshold), 0, 0, table,
+                        searchFunction, new AtomicReference<U>()).invoke();
+    }
+
+    /**
+     * Returns the result of accumulating the given transformation
+     * of all (key, value) pairs using the given reducer to
+     * combine values, or null if none.
+     *
+     * @param parallelismThreshold the (estimated) number of elements
+     * needed for this operation to be executed in parallel
+     * @param transformer a function returning the transformation
+     * for an element, or null if there is no transformation (in
+     * which case it is not combined)
+     * @param reducer a commutative associative combining function
+     * @return the result of accumulating the given transformation
+     * of all (key, value) pairs
+     * @since 1.8
+     */
+    public <U> U reduce(long parallelismThreshold,
+                        BiFun<? super K, ? super V, ? extends U> transformer,
+                        BiFun<? super U, ? super U, ? extends U> reducer) {
+        if (transformer == null || reducer == null)
+            throw new NullPointerException();
+        return new MapReduceMappingsTask<K,V,U>
+                (null, batchFor(parallelismThreshold), 0, 0, table,
+                        null, transformer, reducer).invoke();
+    }
+
+    /**
+     * Returns the result of accumulating the given transformation
+     * of all (key, value) pairs using the given reducer to
+     * combine values, and the given basis as an identity value.
+     *
+     * @param parallelismThreshold the (estimated) number of elements
+     * needed for this operation to be executed in parallel
+     * @param transformer a function returning the transformation
+     * for an element
+     * @param basis the identity (initial default value) for the reduction
+     * @param reducer a commutative associative combining function
+     * @return the result of accumulating the given transformation
+     * of all (key, value) pairs
+     * @since 1.8
+     */
+    public double reduceToDouble(long parallelismThreshold,
+                                 ObjectByObjectToDouble<? super K, ? super V> transformer,
+                                 double basis,
+                                 DoubleByDoubleToDouble reducer) {
+        if (transformer == null || reducer == null)
+            throw new NullPointerException();
+        return new MapReduceMappingsToDoubleTask<K,V>
+                (null, batchFor(parallelismThreshold), 0, 0, table,
+                        null, transformer, basis, reducer).invoke();
+    }
+
+    /**
+     * Returns the result of accumulating the given transformation
+     * of all (key, value) pairs using the given reducer to
+     * combine values, and the given basis as an identity value.
+     *
+     * @param parallelismThreshold the (estimated) number of elements
+     * needed for this operation to be executed in parallel
+     * @param transformer a function returning the transformation
+     * for an element
+     * @param basis the identity (initial default value) for the reduction
+     * @param reducer a commutative associative combining function
+     * @return the result of accumulating the given transformation
+     * of all (key, value) pairs
+     * @since 1.8
+     */
+    public long reduceToLong(long parallelismThreshold,
+                             ObjectByObjectToLong<? super K, ? super V> transformer,
+                             long basis,
+                             LongByLongToLong reducer) {
+        if (transformer == null || reducer == null)
+            throw new NullPointerException();
+        return new MapReduceMappingsToLongTask<K,V>
+                (null, batchFor(parallelismThreshold), 0, 0, table,
+                        null, transformer, basis, reducer).invoke();
+    }
+
+    /**
+     * Returns the result of accumulating the given transformation
+     * of all (key, value) pairs using the given reducer to
+     * combine values, and the given basis as an identity value.
+     *
+     * @param parallelismThreshold the (estimated) number of elements
+     * needed for this operation to be executed in parallel
+     * @param transformer a function returning the transformation
+     * for an element
+     * @param basis the identity (initial default value) for the reduction
+     * @param reducer a commutative associative combining function
+     * @return the result of accumulating the given transformation
+     * of all (key, value) pairs
+     * @since 1.8
+     */
+    public int reduceToInt(long parallelismThreshold,
+                           ObjectByObjectToInt<? super K, ? super V> transformer,
+                           int basis,
+                           IntByIntToInt reducer) {
+        if (transformer == null || reducer == null)
+            throw new NullPointerException();
+        return new MapReduceMappingsToIntTask<K,V>
+                (null, batchFor(parallelismThreshold), 0, 0, table,
+                        null, transformer, basis, reducer).invoke();
+    }
+
+    /**
+     * Performs the given action for each key.
+     *
+     * @param parallelismThreshold the (estimated) number of elements
+     * needed for this operation to be executed in parallel
+     * @param action the action
+     * @since 1.8
+     */
+    public void forEachKey(long parallelismThreshold,
+                           Action<? super K> action) {
+        if (action == null) throw new NullPointerException();
+        new ForEachKeyTask<K,V>
+                (null, batchFor(parallelismThreshold), 0, 0, table,
+                        action).invoke();
+    }
+
+    /**
+     * Performs the given action for each non-null transformation
+     * of each key.
+     *
+     * @param parallelismThreshold the (estimated) number of elements
+     * needed for this operation to be executed in parallel
+     * @param transformer a function returning the transformation
+     * for an element, or null if there is no transformation (in
+     * which case the action is not applied)
+     * @param action the action
+     * @since 1.8
+     */
+    public <U> void forEachKey(long parallelismThreshold,
+                               Fun<? super K, ? extends U> transformer,
+                               Action<? super U> action) {
+        if (transformer == null || action == null)
+            throw new NullPointerException();
+        new ForEachTransformedKeyTask<K,V,U>
+                (null, batchFor(parallelismThreshold), 0, 0, table,
+                        transformer, action).invoke();
+    }
+
+    /**
+     * Returns a non-null result from applying the given search
+     * function on each key, or null if none. Upon success,
+     * further element processing is suppressed and the results of
+     * any other parallel invocations of the search function are
+     * ignored.
+     *
+     * @param parallelismThreshold the (estimated) number of elements
+     * needed for this operation to be executed in parallel
+     * @param searchFunction a function returning a non-null
+     * result on success, else null
+     * @return a non-null result from applying the given search
+     * function on each key, or null if none
+     * @since 1.8
+     */
+    public <U> U searchKeys(long parallelismThreshold,
+                            Fun<? super K, ? extends U> searchFunction) {
+        if (searchFunction == null) throw new NullPointerException();
+        return new SearchKeysTask<K,V,U>
+                (null, batchFor(parallelismThreshold), 0, 0, table,
+                        searchFunction, new AtomicReference<U>()).invoke();
+    }
+
+    /**
+     * Returns the result of accumulating all keys using the given
+     * reducer to combine values, or null if none.
+     *
+     * @param parallelismThreshold the (estimated) number of elements
+     * needed for this operation to be executed in parallel
+     * @param reducer a commutative associative combining function
+     * @return the result of accumulating all keys using the given
+     * reducer to combine values, or null if none
+     * @since 1.8
+     */
+    public K reduceKeys(long parallelismThreshold,
+                        BiFun<? super K, ? super K, ? extends K> reducer) {
+        if (reducer == null) throw new NullPointerException();
+        return new ReduceKeysTask<K,V>
+                (null, batchFor(parallelismThreshold), 0, 0, table,
+                        null, reducer).invoke();
+    }
+
+    /**
+     * Returns the result of accumulating the given transformation
+     * of all keys using the given reducer to combine values, or
+     * null if none.
+     *
+     * @param parallelismThreshold the (estimated) number of elements
+     * needed for this operation to be executed in parallel
+     * @param transformer a function returning the transformation
+     * for an element, or null if there is no transformation (in
+     * which case it is not combined)
+     * @param reducer a commutative associative combining function
+     * @return the result of accumulating the given transformation
+     * of all keys
+     * @since 1.8
+     */
+    public <U> U reduceKeys(long parallelismThreshold,
+                            Fun<? super K, ? extends U> transformer,
+                            BiFun<? super U, ? super U, ? extends U> reducer) {
+        if (transformer == null || reducer == null)
+            throw new NullPointerException();
+        return new MapReduceKeysTask<K,V,U>
+                (null, batchFor(parallelismThreshold), 0, 0, table,
+                        null, transformer, reducer).invoke();
+    }
+
+    /**
+     * Returns the result of accumulating the given transformation
+     * of all keys using the given reducer to combine values, and
+     * the given basis as an identity value.
+     *
+     * @param parallelismThreshold the (estimated) number of elements
+     * needed for this operation to be executed in parallel
+     * @param transformer a function returning the transformation
+     * for an element
+     * @param basis the identity (initial default value) for the reduction
+     * @param reducer a commutative associative combining function
+     * @return the result of accumulating the given transformation
+     * of all keys
+     * @since 1.8
+     */
+    public double reduceKeysToDouble(long parallelismThreshold,
+                                     ObjectToDouble<? super K> transformer,
+                                     double basis,
+                                     DoubleByDoubleToDouble reducer) {
+        if (transformer == null || reducer == null)
+            throw new NullPointerException();
+        return new MapReduceKeysToDoubleTask<K,V>
+                (null, batchFor(parallelismThreshold), 0, 0, table,
+                        null, transformer, basis, reducer).invoke();
+    }
+
+    /**
+     * Returns the result of accumulating the given transformation
+     * of all keys using the given reducer to combine values, and
+     * the given basis as an identity value.
+     *
+     * @param parallelismThreshold the (estimated) number of elements
+     * needed for this operation to be executed in parallel
+     * @param transformer a function returning the transformation
+     * for an element
+     * @param basis the identity (initial default value) for the reduction
+     * @param reducer a commutative associative combining function
+     * @return the result of accumulating the given transformation
+     * of all keys
+     * @since 1.8
+     */
+    public long reduceKeysToLong(long parallelismThreshold,
+                                 ObjectToLong<? super K> transformer,
+                                 long basis,
+                                 LongByLongToLong reducer) {
+        if (transformer == null || reducer == null)
+            throw new NullPointerException();
+        return new MapReduceKeysToLongTask<K,V>
+                (null, batchFor(parallelismThreshold), 0, 0, table,
+                        null, transformer, basis, reducer).invoke();
+    }
+
+    /**
+     * Returns the result of accumulating the given transformation
+     * of all keys using the given reducer to combine values, and
+     * the given basis as an identity value.
+     *
+     * @param parallelismThreshold the (estimated) number of elements
+     * needed for this operation to be executed in parallel
+     * @param transformer a function returning the transformation
+     * for an element
+     * @param basis the identity (initial default value) for the reduction
+     * @param reducer a commutative associative combining function
+     * @return the result of accumulating the given transformation
+     * of all keys
+     * @since 1.8
+     */
+    public int reduceKeysToInt(long parallelismThreshold,
+                               ObjectToInt<? super K> transformer,
+                               int basis,
+                               IntByIntToInt reducer) {
+        if (transformer == null || reducer == null)
+            throw new NullPointerException();
+        return new MapReduceKeysToIntTask<K,V>
+                (null, batchFor(parallelismThreshold), 0, 0, table,
+                        null, transformer, basis, reducer).invoke();
+    }
+
+    /**
+     * Performs the given action for each value.
+     *
+     * @param parallelismThreshold the (estimated) number of elements
+     * needed for this operation to be executed in parallel
+     * @param action the action
+     * @since 1.8
+     */
+    public void forEachValue(long parallelismThreshold,
+                             Action<? super V> action) {
+        if (action == null)
+            throw new NullPointerException();
+        new ForEachValueTask<K,V>
+                (null, batchFor(parallelismThreshold), 0, 0, table,
+                        action).invoke();
+    }
+
+    /**
+     * Performs the given action for each non-null transformation
+     * of each value.
+     *
+     * @param parallelismThreshold the (estimated) number of elements
+     * needed for this operation to be executed in parallel
+     * @param transformer a function returning the transformation
+     * for an element, or null if there is no transformation (in
+     * which case the action is not applied)
+     * @param action the action
+     * @since 1.8
+     */
+    public <U> void forEachValue(long parallelismThreshold,
+                                 Fun<? super V, ? extends U> transformer,
+                                 Action<? super U> action) {
+        if (transformer == null || action == null)
+            throw new NullPointerException();
+        new ForEachTransformedValueTask<K,V,U>
+                (null, batchFor(parallelismThreshold), 0, 0, table,
+                        transformer, action).invoke();
+    }
+
+    /**
+     * Returns a non-null result from applying the given search
+     * function on each value, or null if none.  Upon success,
+     * further element processing is suppressed and the results of
+     * any other parallel invocations of the search function are
+     * ignored.
+     *
+     * @param parallelismThreshold the (estimated) number of elements
+     * needed for this operation to be executed in parallel
+     * @param searchFunction a function returning a non-null
+     * result on success, else null
+     * @return a non-null result from applying the given search
+     * function on each value, or null if none
+     * @since 1.8
+     */
+    public <U> U searchValues(long parallelismThreshold,
+                              Fun<? super V, ? extends U> searchFunction) {
+        if (searchFunction == null) throw new NullPointerException();
+        return new SearchValuesTask<K,V,U>
+                (null, batchFor(parallelismThreshold), 0, 0, table,
+                        searchFunction, new AtomicReference<U>()).invoke();
+    }
+
+    /**
+     * Returns the result of accumulating all values using the
+     * given reducer to combine values, or null if none.
+     *
+     * @param parallelismThreshold the (estimated) number of elements
+     * needed for this operation to be executed in parallel
+     * @param reducer a commutative associative combining function
+     * @return the result of accumulating all values
+     * @since 1.8
+     */
+    public V reduceValues(long parallelismThreshold,
+                          BiFun<? super V, ? super V, ? extends V> reducer) {
+        if (reducer == null) throw new NullPointerException();
+        return new ReduceValuesTask<K,V>
+                (null, batchFor(parallelismThreshold), 0, 0, table,
+                        null, reducer).invoke();
+    }
+
+    /**
+     * Returns the result of accumulating the given transformation
+     * of all values using the given reducer to combine values, or
+     * null if none.
+     *
+     * @param parallelismThreshold the (estimated) number of elements
+     * needed for this operation to be executed in parallel
+     * @param transformer a function returning the transformation
+     * for an element, or null if there is no transformation (in
+     * which case it is not combined)
+     * @param reducer a commutative associative combining function
+     * @return the result of accumulating the given transformation
+     * of all values
+     * @since 1.8
+     */
+    public <U> U reduceValues(long parallelismThreshold,
+                              Fun<? super V, ? extends U> transformer,
+                              BiFun<? super U, ? super U, ? extends U> reducer) {
+        if (transformer == null || reducer == null)
+            throw new NullPointerException();
+        return new MapReduceValuesTask<K,V,U>
+                (null, batchFor(parallelismThreshold), 0, 0, table,
+                        null, transformer, reducer).invoke();
+    }
+
+    /**
+     * Returns the result of accumulating the given transformation
+     * of all values using the given reducer to combine values,
+     * and the given basis as an identity value.
+     *
+     * @param parallelismThreshold the (estimated) number of elements
+     * needed for this operation to be executed in parallel
+     * @param transformer a function returning the transformation
+     * for an element
+     * @param basis the identity (initial default value) for the reduction
+     * @param reducer a commutative associative combining function
+     * @return the result of accumulating the given transformation
+     * of all values
+     * @since 1.8
+     */
+    public double reduceValuesToDouble(long parallelismThreshold,
+                                       ObjectToDouble<? super V> transformer,
+                                       double basis,
+                                       DoubleByDoubleToDouble reducer) {
+        if (transformer == null || reducer == null)
+            throw new NullPointerException();
+        return new MapReduceValuesToDoubleTask<K,V>
+                (null, batchFor(parallelismThreshold), 0, 0, table,
+                        null, transformer, basis, reducer).invoke();
+    }
+
+    /**
+     * Returns the result of accumulating the given transformation
+     * of all values using the given reducer to combine values,
+     * and the given basis as an identity value.
+     *
+     * @param parallelismThreshold the (estimated) number of elements
+     * needed for this operation to be executed in parallel
+     * @param transformer a function returning the transformation
+     * for an element
+     * @param basis the identity (initial default value) for the reduction
+     * @param reducer a commutative associative combining function
+     * @return the result of accumulating the given transformation
+     * of all values
+     * @since 1.8
+     */
+    public long reduceValuesToLong(long parallelismThreshold,
+                                   ObjectToLong<? super V> transformer,
+                                   long basis,
+                                   LongByLongToLong reducer) {
+        if (transformer == null || reducer == null)
+            throw new NullPointerException();
+        return new MapReduceValuesToLongTask<K,V>
+                (null, batchFor(parallelismThreshold), 0, 0, table,
+                        null, transformer, basis, reducer).invoke();
+    }
+
+    /**
+     * Returns the result of accumulating the given transformation
+     * of all values using the given reducer to combine values,
+     * and the given basis as an identity value.
+     *
+     * @param parallelismThreshold the (estimated) number of elements
+     * needed for this operation to be executed in parallel
+     * @param transformer a function returning the transformation
+     * for an element
+     * @param basis the identity (initial default value) for the reduction
+     * @param reducer a commutative associative combining function
+     * @return the result of accumulating the given transformation
+     * of all values
+     * @since 1.8
+     */
+    public int reduceValuesToInt(long parallelismThreshold,
+                                 ObjectToInt<? super V> transformer,
+                                 int basis,
+                                 IntByIntToInt reducer) {
+        if (transformer == null || reducer == null)
+            throw new NullPointerException();
+        return new MapReduceValuesToIntTask<K,V>
+                (null, batchFor(parallelismThreshold), 0, 0, table,
+                        null, transformer, basis, reducer).invoke();
+    }
+
+    /**
+     * Performs the given action for each entry.
+     *
+     * @param parallelismThreshold the (estimated) number of elements
+     * needed for this operation to be executed in parallel
+     * @param action the action
+     * @since 1.8
+     */
+    public void forEachEntry(long parallelismThreshold,
+                             Action<? super Map.Entry<K,V>> action) {
+        if (action == null) throw new NullPointerException();
+        new ForEachEntryTask<K,V>(null, batchFor(parallelismThreshold), 0, 0, table,
+                action).invoke();
+    }
+
+    /**
+     * Performs the given action for each non-null transformation
+     * of each entry.
+     *
+     * @param parallelismThreshold the (estimated) number of elements
+     * needed for this operation to be executed in parallel
+     * @param transformer a function returning the transformation
+     * for an element, or null if there is no transformation (in
+     * which case the action is not applied)
+     * @param action the action
+     * @since 1.8
+     */
+    public <U> void forEachEntry(long parallelismThreshold,
+                                 Fun<Map.Entry<K,V>, ? extends U> transformer,
+                                 Action<? super U> action) {
+        if (transformer == null || action == null)
+            throw new NullPointerException();
+        new ForEachTransformedEntryTask<K,V,U>
+                (null, batchFor(parallelismThreshold), 0, 0, table,
+                        transformer, action).invoke();
+    }
+
+    /**
+     * Returns a non-null result from applying the given search
+     * function on each entry, or null if none.  Upon success,
+     * further element processing is suppressed and the results of
+     * any other parallel invocations of the search function are
+     * ignored.
+     *
+     * @param parallelismThreshold the (estimated) number of elements
+     * needed for this operation to be executed in parallel
+     * @param searchFunction a function returning a non-null
+     * result on success, else null
+     * @return a non-null result from applying the given search
+     * function on each entry, or null if none
+     * @since 1.8
+     */
+    public <U> U searchEntries(long parallelismThreshold,
+                               Fun<Map.Entry<K,V>, ? extends U> searchFunction) {
+        if (searchFunction == null) throw new NullPointerException();
+        return new SearchEntriesTask<K,V,U>
+                (null, batchFor(parallelismThreshold), 0, 0, table,
+                        searchFunction, new AtomicReference<U>()).invoke();
+    }
+
+    /**
+     * Returns the result of accumulating all entries using the
+     * given reducer to combine values, or null if none.
+     *
+     * @param parallelismThreshold the (estimated) number of elements
+     * needed for this operation to be executed in parallel
+     * @param reducer a commutative associative combining function
+     * @return the result of accumulating all entries
+     * @since 1.8
+     */
+    public Map.Entry<K,V> reduceEntries(long parallelismThreshold,
+                                        BiFun<Map.Entry<K,V>, Map.Entry<K,V>, ? extends Map.Entry<K,V>> reducer) {
+        if (reducer == null) throw new NullPointerException();
+        return new ReduceEntriesTask<K,V>
+                (null, batchFor(parallelismThreshold), 0, 0, table,
+                        null, reducer).invoke();
+    }
+
+    /**
+     * Returns the result of accumulating the given transformation
+     * of all entries using the given reducer to combine values,
+     * or null if none.
+     *
+     * @param parallelismThreshold the (estimated) number of elements
+     * needed for this operation to be executed in parallel
+     * @param transformer a function returning the transformation
+     * for an element, or null if there is no transformation (in
+     * which case it is not combined)
+     * @param reducer a commutative associative combining function
+     * @return the result of accumulating the given transformation
+     * of all entries
+     * @since 1.8
+     */
+    public <U> U reduceEntries(long parallelismThreshold,
+                               Fun<Map.Entry<K,V>, ? extends U> transformer,
+                               BiFun<? super U, ? super U, ? extends U> reducer) {
+        if (transformer == null || reducer == null)
+            throw new NullPointerException();
+        return new MapReduceEntriesTask<K,V,U>
+                (null, batchFor(parallelismThreshold), 0, 0, table,
+                        null, transformer, reducer).invoke();
+    }
+
+    /**
+     * Returns the result of accumulating the given transformation
+     * of all entries using the given reducer to combine values,
+     * and the given basis as an identity value.
+     *
+     * @param parallelismThreshold the (estimated) number of elements
+     * needed for this operation to be executed in parallel
+     * @param transformer a function returning the transformation
+     * for an element
+     * @param basis the identity (initial default value) for the reduction
+     * @param reducer a commutative associative combining function
+     * @return the result of accumulating the given transformation
+     * of all entries
+     * @since 1.8
+     */
+    public double reduceEntriesToDouble(long parallelismThreshold,
+                                        ObjectToDouble<Map.Entry<K,V>> transformer,
+                                        double basis,
+                                        DoubleByDoubleToDouble reducer) {
+        if (transformer == null || reducer == null)
+            throw new NullPointerException();
+        return new MapReduceEntriesToDoubleTask<K,V>
+                (null, batchFor(parallelismThreshold), 0, 0, table,
+                        null, transformer, basis, reducer).invoke();
+    }
+
+    /**
+     * Returns the result of accumulating the given transformation
+     * of all entries using the given reducer to combine values,
+     * and the given basis as an identity value.
+     *
+     * @param parallelismThreshold the (estimated) number of elements
+     * needed for this operation to be executed in parallel
+     * @param transformer a function returning the transformation
+     * for an element
+     * @param basis the identity (initial default value) for the reduction
+     * @param reducer a commutative associative combining function
+     * @return the result of accumulating the given transformation
+     * of all entries
+     * @since 1.8
+     */
+    public long reduceEntriesToLong(long parallelismThreshold,
+                                    ObjectToLong<Map.Entry<K,V>> transformer,
+                                    long basis,
+                                    LongByLongToLong reducer) {
+        if (transformer == null || reducer == null)
+            throw new NullPointerException();
+        return new MapReduceEntriesToLongTask<K,V>
+                (null, batchFor(parallelismThreshold), 0, 0, table,
+                        null, transformer, basis, reducer).invoke();
+    }
+
+    /**
+     * Returns the result of accumulating the given transformation
+     * of all entries using the given reducer to combine values,
+     * and the given basis as an identity value.
+     *
+     * @param parallelismThreshold the (estimated) number of elements
+     * needed for this operation to be executed in parallel
+     * @param transformer a function returning the transformation
+     * for an element
+     * @param basis the identity (initial default value) for the reduction
+     * @param reducer a commutative associative combining function
+     * @return the result of accumulating the given transformation
+     * of all entries
+     * @since 1.8
+     */
+    public int reduceEntriesToInt(long parallelismThreshold,
+                                  ObjectToInt<Map.Entry<K,V>> transformer,
+                                  int basis,
+                                  IntByIntToInt reducer) {
+        if (transformer == null || reducer == null)
+            throw new NullPointerException();
+        return new MapReduceEntriesToIntTask<K,V>
+                (null, batchFor(parallelismThreshold), 0, 0, table,
+                        null, transformer, basis, reducer).invoke();
+    }
+
+
+    /* ----------------Views -------------- */
+
+    /**
+     * Base class for views.
+     */
+    abstract static class CollectionView<K,V,E>
+            implements Collection<E>, java.io.Serializable {
+        private static final long serialVersionUID = 7249069246763182397L;
+        final ConcurrentHashMapV8<K,V> map;
+        CollectionView(ConcurrentHashMapV8<K,V> map)  { this.map = map; }
+
+        /**
+         * Returns the map backing this view.
+         *
+         * @return the map backing this view
+         */
+        public ConcurrentHashMapV8<K,V> getMap() { return map; }
+
+        /**
+         * Removes all of the elements from this view, by removing all
+         * the mappings from the map backing this view.
+         */
+        public final void clear()      { map.clear(); }
+        public final int size()        { return map.size(); }
+        public final boolean isEmpty() { return map.isEmpty(); }
+
+        // implementations below rely on concrete classes supplying these
+        // abstract methods
+        /**
+         * Returns a "weakly consistent" iterator that will never
+         * throw {@link ConcurrentModificationException}, and
+         * guarantees to traverse elements as they existed upon
+         * construction of the iterator, and may (but is not
+         * guaranteed to) reflect any modifications subsequent to
+         * construction.
+         */
+        public abstract Iterator<E> iterator();
+        public abstract boolean contains(Object o);
+        public abstract boolean remove(Object o);
+
+        private static final String oomeMsg = "Required array size too large";
+
+        public final Object[] toArray() {
+            long sz = map.mappingCount();
+            if (sz > MAX_ARRAY_SIZE)
+                throw new OutOfMemoryError(oomeMsg);
+            int n = (int)sz;
+            Object[] r = new Object[n];
+            int i = 0;
+            for (E e : this) {
+                if (i == n) {
+                    if (n >= MAX_ARRAY_SIZE)
+                        throw new OutOfMemoryError(oomeMsg);
+                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
+                        n = MAX_ARRAY_SIZE;
+                    else
+                        n += (n >>> 1) + 1;
+                    r = Arrays.copyOf(r, n);
+                }
+                r[i++] = e;
+            }
+            return (i == n) ? r : Arrays.copyOf(r, i);
+        }
+
+        @SuppressWarnings("unchecked")
+        public final <T> T[] toArray(T[] a) {
+            long sz = map.mappingCount();
+            if (sz > MAX_ARRAY_SIZE)
+                throw new OutOfMemoryError(oomeMsg);
+            int m = (int)sz;
+            T[] r = (a.length >= m) ? a :
+                    (T[])java.lang.reflect.Array
+                            .newInstance(a.getClass().getComponentType(), m);
+            int n = r.length;
+            int i = 0;
+            for (E e : this) {
+                if (i == n) {
+                    if (n >= MAX_ARRAY_SIZE)
+                        throw new OutOfMemoryError(oomeMsg);
+                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
+                        n = MAX_ARRAY_SIZE;
+                    else
+                        n += (n >>> 1) + 1;
+                    r = Arrays.copyOf(r, n);
+                }
+                r[i++] = (T)e;
+            }
+            if (a == r && i < n) {
+                r[i] = null; // null-terminate
+                return r;
+            }
+            return (i == n) ? r : Arrays.copyOf(r, i);
+        }
+
+        /**
+         * Returns a string representation of this collection.
+         * The string representation consists of the string representations
+         * of the collection's elements in the order they are returned by
+         * its iterator, enclosed in square brackets ({@code "[]"}).
+         * Adjacent elements are separated by the characters {@code ", "}
+         * (comma and space).  Elements are converted to strings as by
+         * {@link String#valueOf(Object)}.
+         *
+         * @return a string representation of this collection
+         */
+        public final String toString() {
+            StringBuilder sb = new StringBuilder();
+            sb.append('[');
+            Iterator<E> it = iterator();
+            if (it.hasNext()) {
+                for (;;) {
+                    Object e = it.next();
+                    sb.append(e == this ? "(this Collection)" : e);
+                    if (!it.hasNext())
+                        break;
+                    sb.append(',').append(' ');
+                }
+            }
+            return sb.append(']').toString();
+        }
+
+        public final boolean containsAll(Collection<?> c) {
+            if (c != this) {
+                for (Object e : c) {
+                    if (e == null || !contains(e))
+                        return false;
+                }
+            }
+            return true;
+        }
+
+        public final boolean removeAll(Collection<?> c) {
+            boolean modified = false;
+            for (Iterator<E> it = iterator(); it.hasNext();) {
+                if (c.contains(it.next())) {
+                    it.remove();
+                    modified = true;
+                }
+            }
+            return modified;
+        }
+
+        public final boolean retainAll(Collection<?> c) {
+            boolean modified = false;
+            for (Iterator<E> it = iterator(); it.hasNext();) {
+                if (!c.contains(it.next())) {
+                    it.remove();
+                    modified = true;
+                }
+            }
+            return modified;
+        }
+
+    }
+
+    /**
+     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in
+     * which additions may optionally be enabled by mapping to a
+     * common value.  This class cannot be directly instantiated.
+     * See {@link #keySet() keySet()},
+     * {@link #keySet(Object) keySet(V)},
+     * {@link #newKeySet() newKeySet()},
+     * {@link #newKeySet(int) newKeySet(int)}.
+     *
+     * @since 1.8
+     */
+    public static class KeySetView<K,V> extends CollectionView<K,V,K>
+            implements Set<K>, java.io.Serializable {
+        private static final long serialVersionUID = 7249069246763182397L;
+        private final V value;
+        KeySetView(ConcurrentHashMapV8<K,V> map, V value) {  // non-public
+            super(map);
+            this.value = value;
+        }
+
+        /**
+         * Returns the default mapped value for additions,
+         * or {@code null} if additions are not supported.
+         *
+         * @return the default mapped value for additions, or {@code null}
+         * if not supported
+         */
+        public V getMappedValue() { return value; }
+
+        /**
+         * {@inheritDoc}
+         * @throws NullPointerException if the specified key is null
+         */
+        public boolean contains(Object o) { return map.containsKey(o); }
+
+        /**
+         * Removes the key from this map view, by removing the key (and its
+         * corresponding value) from the backing map.  This method does
+         * nothing if the key is not in the map.
+         *
+         * @param  o the key to be removed from the backing map
+         * @return {@code true} if the backing map contained the specified key
+         * @throws NullPointerException if the specified key is null
+         */
+        public boolean remove(Object o) { return map.remove(o) != null; }
+
+        /**
+         * @return an iterator over the keys of the backing map
+         */
+        public Iterator<K> iterator() {
+            Node<K,V>[] t;
+            ConcurrentHashMapV8<K,V> m = map;
+            int f = (t = m.table) == null ? 0 : t.length;
+            return new KeyIterator<K,V>(t, f, 0, f, m);
+        }
+
+        /**
+         * Adds the specified key to this set view by mapping the key to
+         * the default mapped value in the backing map, if defined.
+         *
+         * @param e key to be added
+         * @return {@code true} if this set changed as a result of the call
+         * @throws NullPointerException if the specified key is null
+         * @throws UnsupportedOperationException if no default mapped value
+         * for additions was provided
+         */
+        public boolean add(K e) {
+            V v;
+            if ((v = value) == null)
+                throw new UnsupportedOperationException();
+            return map.putVal(e, v, true) == null;
+        }
+
+        /**
+         * Adds all of the elements in the specified collection to this set,
+         * as if by calling {@link #add} on each one.
+         *
+         * @param c the elements to be inserted into this set
+         * @return {@code true} if this set changed as a result of the call
+         * @throws NullPointerException if the collection or any of its
+         * elements are {@code null}
+         * @throws UnsupportedOperationException if no default mapped value
+         * for additions was provided
+         */
+        public boolean addAll(Collection<? extends K> c) {
+            boolean added = false;
+            V v;
+            if ((v = value) == null)
+                throw new UnsupportedOperationException();
+            for (K e : c) {
+                if (map.putVal(e, v, true) == null)
+                    added = true;
+            }
+            return added;
+        }
+
+        public int hashCode() {
+            int h = 0;
+            for (K e : this)
+                h += e.hashCode();
+            return h;
+        }
+
+        public boolean equals(Object o) {
+            Set<?> c;
+            return ((o instanceof Set) &&
+                    ((c = (Set<?>)o) == this ||
+                            (containsAll(c) && c.containsAll(this))));
+        }
+
+        public ConcurrentHashMapSpliterator<K> spliterator166() {
+            Node<K,V>[] t;
+            ConcurrentHashMapV8<K,V> m = map;
+            long n = m.sumCount();
+            int f = (t = m.table) == null ? 0 : t.length;
+            return new KeySpliterator<K,V>(t, f, 0, f, n < 0L ? 0L : n);
+        }
+
+        public void forEach(Action<? super K> action) {
+            if (action == null) throw new NullPointerException();
+            Node<K,V>[] t;
+            if ((t = map.table) != null) {
+                Traverser<K,V> it = new Traverser<K,V>(t, t.length, 0, t.length);
+                for (Node<K,V> p; (p = it.advance()) != null; )
+                    action.apply(p.key);
+            }
+        }
+    }
+
+    /**
+     * A view of a ConcurrentHashMapV8 as a {@link Collection} of
+     * values, in which additions are disabled. This class cannot be
+     * directly instantiated. See {@link #values()}.
+     */
+    static final class ValuesView<K,V> extends CollectionView<K,V,V>
+            implements Collection<V>, java.io.Serializable {
+        private static final long serialVersionUID = 2249069246763182397L;
+        ValuesView(ConcurrentHashMapV8<K,V> map) { super(map); }
+        public final boolean contains(Object o) {
+            return map.containsValue(o);
+        }
+
+        public final boolean remove(Object o) {
+            if (o != null) {
+                for (Iterator<V> it = iterator(); it.hasNext();) {
+                    if (o.equals(it.next())) {
+                        it.remove();
+                        return true;
+                    }
+                }
+            }
+            return false;
+        }
+
+        public final Iterator<V> iterator() {
+            ConcurrentHashMapV8<K,V> m = map;
+            Node<K,V>[] t;
+            int f = (t = m.table) == null ? 0 : t.length;
+            return new ValueIterator<K,V>(t, f, 0, f, m);
+        }
+
+        public final boolean add(V e) {
+            throw new UnsupportedOperationException();
+        }
+        public final boolean addAll(Collection<? extends V> c) {
+            throw new UnsupportedOperationException();
+        }
+
+        public ConcurrentHashMapSpliterator<V> spliterator166() {
+            Node<K,V>[] t;
+            ConcurrentHashMapV8<K,V> m = map;
+            long n = m.sumCount();
+            int f = (t = m.table) == null ? 0 : t.length;
+            return new ValueSpliterator<K,V>(t, f, 0, f, n < 0L ? 0L : n);
+        }
+
+        public void forEach(Action<? super V> action) {
+            if (action == null) throw new NullPointerException();
+            Node<K,V>[] t;
+            if ((t = map.table) != null) {
+                Traverser<K,V> it = new Traverser<K,V>(t, t.length, 0, t.length);
+                for (Node<K,V> p; (p = it.advance()) != null; )
+                    action.apply(p.val);
+            }
+        }
+    }
+
+    /**
+     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)
+     * entries.  This class cannot be directly instantiated. See
+     * {@link #entrySet()}.
+     */
+    static final class EntrySetView<K,V> extends CollectionView<K,V,Map.Entry<K,V>>
+            implements Set<Map.Entry<K,V>>, java.io.Serializable {
+        private static final long serialVersionUID = 2249069246763182397L;
+        EntrySetView(ConcurrentHashMapV8<K,V> map) { super(map); }
+
+        public boolean contains(Object o) {
+            Object k, v, r; Map.Entry<?,?> e;
+            return ((o instanceof Map.Entry) &&
+                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
+                    (r = map.get(k)) != null &&
+                    (v = e.getValue()) != null &&
+                    (v == r || v.equals(r)));
+        }
+
+        public boolean remove(Object o) {
+            Object k, v; Map.Entry<?,?> e;
+            return ((o instanceof Map.Entry) &&
+                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
+                    (v = e.getValue()) != null &&
+                    map.remove(k, v));
+        }
+
+        /**
+         * @return an iterator over the entries of the backing map
+         */
+        public Iterator<Map.Entry<K,V>> iterator() {
+            ConcurrentHashMapV8<K,V> m = map;
+            Node<K,V>[] t;
+            int f = (t = m.table) == null ? 0 : t.length;
+            return new EntryIterator<K,V>(t, f, 0, f, m);
+        }
+
+        public boolean add(Entry<K,V> e) {
+            return map.putVal(e.getKey(), e.getValue(), false) == null;
+        }
+
+        public boolean addAll(Collection<? extends Entry<K,V>> c) {
+            boolean added = false;
+            for (Entry<K,V> e : c) {
+                if (add(e))
+                    added = true;
+            }
+            return added;
+        }
+
+        public final int hashCode() {
+            int h = 0;
+            Node<K,V>[] t;
+            if ((t = map.table) != null) {
+                Traverser<K,V> it = new Traverser<K,V>(t, t.length, 0, t.length);
+                for (Node<K,V> p; (p = it.advance()) != null; ) {
+                    h += p.hashCode();
+                }
+            }
+            return h;
+        }
+
+        public final boolean equals(Object o) {
+            Set<?> c;
+            return ((o instanceof Set) &&
+                    ((c = (Set<?>)o) == this ||
+                            (containsAll(c) && c.containsAll(this))));
+        }
+
+        public ConcurrentHashMapSpliterator<Map.Entry<K,V>> spliterator166() {
+            Node<K,V>[] t;
+            ConcurrentHashMapV8<K,V> m = map;
+            long n = m.sumCount();
+            int f = (t = m.table) == null ? 0 : t.length;
+            return new EntrySpliterator<K,V>(t, f, 0, f, n < 0L ? 0L : n, m);
+        }
+
+        public void forEach(Action<? super Map.Entry<K,V>> action) {
+            if (action == null) throw new NullPointerException();
+            Node<K,V>[] t;
+            if ((t = map.table) != null) {
+                Traverser<K,V> it = new Traverser<K,V>(t, t.length, 0, t.length);
+                for (Node<K,V> p; (p = it.advance()) != null; )
+                    action.apply(new MapEntry<K,V>(p.key, p.val, map));
+            }
+        }
+
+    }
+
+    // -------------------------------------------------------
+
+    /**
+     * Base class for bulk tasks. Repeats some fields and code from
+     * class Traverser, because we need to subclass CountedCompleter.
+     */
+    abstract static class BulkTask<K,V,R> extends CountedCompleter<R> {
+        Node<K,V>[] tab;        // same as Traverser
+        Node<K,V> next;
+        int index;
+        int baseIndex;
+        int baseLimit;
+        final int baseSize;
+        int batch;              // split control
+
+        BulkTask(BulkTask<K,V,?> par, int b, int i, int f, Node<K,V>[] t) {
+            super(par);
+            this.batch = b;
+            this.index = this.baseIndex = i;
+            if ((this.tab = t) == null)
+                this.baseSize = this.baseLimit = 0;
+            else if (par == null)
+                this.baseSize = this.baseLimit = t.length;
+            else {
+                this.baseLimit = f;
+                this.baseSize = par.baseSize;
+            }
+        }
+
+        /**
+         * Same as Traverser version
+         */
+        final Node<K,V> advance() {
+            Node<K,V> e;
+            if ((e = next) != null)
+                e = e.next;
+            for (;;) {
+                Node<K,V>[] t; int i, n; K ek;  // must use locals in checks
+                if (e != null)
+                    return next = e;
+                if (baseIndex >= baseLimit || (t = tab) == null ||
+                        (n = t.length) <= (i = index) || i < 0)
+                    return next = null;
+                if ((e = tabAt(t, index)) != null && e.hash < 0) {
+                    if (e instanceof ForwardingNode) {
+                        tab = ((ForwardingNode<K,V>)e).nextTable;
+                        e = null;
+                        continue;
+                    }
+                    else if (e instanceof TreeBin)
+                        e = ((TreeBin<K,V>)e).first;
+                    else
+                        e = null;
+                }
+                if ((index += baseSize) >= n)
+                    index = ++baseIndex;    // visit upper slots if present
+            }
+        }
+    }
+
+    /*
+     * Task classes. Coded in a regular but ugly format/style to
+     * simplify checks that each variant differs in the right way from
+     * others. The null screenings exist because compilers cannot tell
+     * that we've already null-checked task arguments, so we force
+     * simplest hoisted bypass to help avoid convoluted traps.
+     */
+    @SuppressWarnings("serial")
+    static final class ForEachKeyTask<K,V>
+            extends BulkTask<K,V,Void> {
+        final Action<? super K> action;
+        ForEachKeyTask
+                (BulkTask<K,V,?> p, int b, int i, int f, Node<K,V>[] t,
+                 Action<? super K> action) {
+            super(p, b, i, f, t);
+            this.action = action;
+        }
+        public final void compute() {
+            final Action<? super K> action;
+            if ((action = this.action) != null) {
+                for (int i = baseIndex, f, h; batch > 0 &&
+                        (h = ((f = baseLimit) + i) >>> 1) > i;) {
+                    addToPendingCount(1);
+                    new ForEachKeyTask<K,V>
+                            (this, batch >>>= 1, baseLimit = h, f, tab,
+                                    action).fork();
+                }
+                for (Node<K,V> p; (p = advance()) != null;)
+                    action.apply(p.key);
+                propagateCompletion();
+            }
+        }
+    }
+
+    @SuppressWarnings("serial")
+    static final class ForEachValueTask<K,V>
+            extends BulkTask<K,V,Void> {
+        final Action<? super V> action;
+        ForEachValueTask
+                (BulkTask<K,V,?> p, int b, int i, int f, Node<K,V>[] t,
+                 Action<? super V> action) {
+            super(p, b, i, f, t);
+            this.action = action;
+        }
+        public final void compute() {
+            final Action<? super V> action;
+            if ((action = this.action) != null) {
+                for (int i = baseIndex, f, h; batch > 0 &&
+                        (h = ((f = baseLimit) + i) >>> 1) > i;) {
+                    addToPendingCount(1);
+                    new ForEachValueTask<K,V>
+                            (this, batch >>>= 1, baseLimit = h, f, tab,
+                                    action).fork();
+                }
+                for (Node<K,V> p; (p = advance()) != null;)
+                    action.apply(p.val);
+                propagateCompletion();
+            }
+        }
+    }
+
+    @SuppressWarnings("serial")
+    static final class ForEachEntryTask<K,V>
+            extends BulkTask<K,V,Void> {
+        final Action<? super Entry<K,V>> action;
+        ForEachEntryTask
+                (BulkTask<K,V,?> p, int b, int i, int f, Node<K,V>[] t,
+                 Action<? super Entry<K,V>> action) {
+            super(p, b, i, f, t);
+            this.action = action;
+        }
+        public final void compute() {
+            final Action<? super Entry<K,V>> action;
+            if ((action = this.action) != null) {
+                for (int i = baseIndex, f, h; batch > 0 &&
+                        (h = ((f = baseLimit) + i) >>> 1) > i;) {
+                    addToPendingCount(1);
+                    new ForEachEntryTask<K,V>
+                            (this, batch >>>= 1, baseLimit = h, f, tab,
+                                    action).fork();
+                }
+                for (Node<K,V> p; (p = advance()) != null; )
+                    action.apply(p);
+                propagateCompletion();
+            }
+        }
+    }
+
+    @SuppressWarnings("serial")
+    static final class ForEachMappingTask<K,V>
+            extends BulkTask<K,V,Void> {
+        final BiAction<? super K, ? super V> action;
+        ForEachMappingTask
+                (BulkTask<K,V,?> p, int b, int i, int f, Node<K,V>[] t,
+                 BiAction<? super K,? super V> action) {
+            super(p, b, i, f, t);
+            this.action = action;
+        }
+        public final void compute() {
+            final BiAction<? super K, ? super V> action;
+            if ((action = this.action) != null) {
+                for (int i = baseIndex, f, h; batch > 0 &&
+                        (h = ((f = baseLimit) + i) >>> 1) > i;) {
+                    addToPendingCount(1);
+                    new ForEachMappingTask<K,V>
+                            (this, batch >>>= 1, baseLimit = h, f, tab,
+                                    action).fork();
+                }
+                for (Node<K,V> p; (p = advance()) != null; )
+                    action.apply(p.key, p.val);
+                propagateCompletion();
+            }
+        }
+    }
+
+    @SuppressWarnings("serial")
+    static final class ForEachTransformedKeyTask<K,V,U>
+            extends BulkTask<K,V,Void> {
+        final Fun<? super K, ? extends U> transformer;
+        final Action<? super U> action;
+        ForEachTransformedKeyTask
+                (BulkTask<K,V,?> p, int b, int i, int f, Node<K,V>[] t,
+                 Fun<? super K, ? extends U> transformer, Action<? super U> action) {
+            super(p, b, i, f, t);
+            this.transformer = transformer; this.action = action;
+        }
+        public final void compute() {
+            final Fun<? super K, ? extends U> transformer;
+            final Action<? super U> action;
+            if ((transformer = this.transformer) != null &&
+                    (action = this.action) != null) {
+                for (int i = baseIndex, f, h; batch > 0 &&
+                        (h = ((f = baseLimit) + i) >>> 1) > i;) {
+                    addToPendingCount(1);
+                    new ForEachTransformedKeyTask<K,V,U>
+                            (this, batch >>>= 1, baseLimit = h, f, tab,
+                                    transformer, action).fork();
+                }
+                for (Node<K,V> p; (p = advance()) != null; ) {
+                    U u;
+                    if ((u = transformer.apply(p.key)) != null)
+                        action.apply(u);
+                }
+                propagateCompletion();
+            }
+        }
+    }
+
+    @SuppressWarnings("serial")
+    static final class ForEachTransformedValueTask<K,V,U>
+            extends BulkTask<K,V,Void> {
+        final Fun<? super V, ? extends U> transformer;
+        final Action<? super U> action;
+        ForEachTransformedValueTask
+                (BulkTask<K,V,?> p, int b, int i, int f, Node<K,V>[] t,
+                 Fun<? super V, ? extends U> transformer, Action<? super U> action) {
+            super(p, b, i, f, t);
+            this.transformer = transformer; this.action = action;
+        }
+        public final void compute() {
+            final Fun<? super V, ? extends U> transformer;
+            final Action<? super U> action;
+            if ((transformer = this.transformer) != null &&
+                    (action = this.action) != null) {
+                for (int i = baseIndex, f, h; batch > 0 &&
+                        (h = ((f = baseLimit) + i) >>> 1) > i;) {
+                    addToPendingCount(1);
+                    new ForEachTransformedValueTask<K,V,U>
+                            (this, batch >>>= 1, baseLimit = h, f, tab,
+                                    transformer, action).fork();
+                }
+                for (Node<K,V> p; (p = advance()) != null; ) {
+                    U u;
+                    if ((u = transformer.apply(p.val)) != null)
+                        action.apply(u);
+                }
+                propagateCompletion();
+            }
+        }
+    }
+
+    @SuppressWarnings("serial")
+    static final class ForEachTransformedEntryTask<K,V,U>
+            extends BulkTask<K,V,Void> {
+        final Fun<Map.Entry<K,V>, ? extends U> transformer;
+        final Action<? super U> action;
+        ForEachTransformedEntryTask
+                (BulkTask<K,V,?> p, int b, int i, int f, Node<K,V>[] t,
+                 Fun<Map.Entry<K,V>, ? extends U> transformer, Action<? super U> action) {
+            super(p, b, i, f, t);
+            this.transformer = transformer; this.action = action;
+        }
+        public final void compute() {
+            final Fun<Map.Entry<K,V>, ? extends U> transformer;
+            final Action<? super U> action;
+            if ((transformer = this.transformer) != null &&
+                    (action = this.action) != null) {
+                for (int i = baseIndex, f, h; batch > 0 &&
+                        (h = ((f = baseLimit) + i) >>> 1) > i;) {
+                    addToPendingCount(1);
+                    new ForEachTransformedEntryTask<K,V,U>
+                            (this, batch >>>= 1, baseLimit = h, f, tab,
+                                    transformer, action).fork();
+                }
+                for (Node<K,V> p; (p = advance()) != null; ) {
+                    U u;
+                    if ((u = transformer.apply(p)) != null)
+                        action.apply(u);
+                }
+                propagateCompletion();
+            }
+        }
+    }
+
+    @SuppressWarnings("serial")
+    static final class ForEachTransformedMappingTask<K,V,U>
+            extends BulkTask<K,V,Void> {
+        final BiFun<? super K, ? super V, ? extends U> transformer;
+        final Action<? super U> action;
+        ForEachTransformedMappingTask
+                (BulkTask<K,V,?> p, int b, int i, int f, Node<K,V>[] t,
+                 BiFun<? super K, ? super V, ? extends U> transformer,
+                 Action<? super U> action) {
+            super(p, b, i, f, t);
+            this.transformer = transformer; this.action = action;
+        }
+        public final void compute() {
+            final BiFun<? super K, ? super V, ? extends U> transformer;
+            final Action<? super U> action;
+            if ((transformer = this.transformer) != null &&
+                    (action = this.action) != null) {
+                for (int i = baseIndex, f, h; batch > 0 &&
+                        (h = ((f = baseLimit) + i) >>> 1) > i;) {
+                    addToPendingCount(1);
+                    new ForEachTransformedMappingTask<K,V,U>
+                            (this, batch >>>= 1, baseLimit = h, f, tab,
+                                    transformer, action).fork();
+                }
+                for (Node<K,V> p; (p = advance()) != null; ) {
+                    U u;
+                    if ((u = transformer.apply(p.key, p.val)) != null)
+                        action.apply(u);
+                }
+                propagateCompletion();
+            }
+        }
+    }
+
+    @SuppressWarnings("serial")
+    static final class SearchKeysTask<K,V,U>
+            extends BulkTask<K,V,U> {
+        final Fun<? super K, ? extends U> searchFunction;
+        final AtomicReference<U> result;
+        SearchKeysTask
+                (BulkTask<K,V,?> p, int b, int i, int f, Node<K,V>[] t,
+                 Fun<? super K, ? extends U> searchFunction,
+                 AtomicReference<U> result) {
+            super(p, b, i, f, t);
+            this.searchFunction = searchFunction; this.result = result;
+        }
+        public final U getRawResult() { return result.get(); }
+        public final void compute() {
+            final Fun<? super K, ? extends U> searchFunction;
+            final AtomicReference<U> result;
+            if ((searchFunction = this.searchFunction) != null &&
+                    (result = this.result) != null) {
+                for (int i = baseIndex, f, h; batch > 0 &&
+                        (h = ((f = baseLimit) + i) >>> 1) > i;) {
+                    if (result.get() != null)
+                        return;
+                    addToPendingCount(1);
+                    new SearchKeysTask<K,V,U>
+                            (this, batch >>>= 1, baseLimit = h, f, tab,
+                                    searchFunction, result).fork();
+                }
+                while (result.get() == null) {
+                    U u;
+                    Node<K,V> p;
+                    if ((p = advance()) == null) {
+                        propagateCompletion();
+                        break;
+                    }
+                    if ((u = searchFunction.apply(p.key)) != null) {
+                        if (result.compareAndSet(null, u))
+                            quietlyCompleteRoot();
+                        break;
+                    }
+                }
+            }
+        }
+    }
+
+    @SuppressWarnings("serial")
+    static final class SearchValuesTask<K,V,U>
+            extends BulkTask<K,V,U> {
+        final Fun<? super V, ? extends U> searchFunction;
+        final AtomicReference<U> result;
+        SearchValuesTask
+                (BulkTask<K,V,?> p, int b, int i, int f, Node<K,V>[] t,
+                 Fun<? super V, ? extends U> searchFunction,
+                 AtomicReference<U> result) {
+            super(p, b, i, f, t);
+            this.searchFunction = searchFunction; this.result = result;
+        }
+        public final U getRawResult() { return result.get(); }
+        public final void compute() {
+            final Fun<? super V, ? extends U> searchFunction;
+            final AtomicReference<U> result;
+            if ((searchFunction = this.searchFunction) != null &&
+                    (result = this.result) != null) {
+                for (int i = baseIndex, f, h; batch > 0 &&
+                        (h = ((f = baseLimit) + i) >>> 1) > i;) {
+                    if (result.get() != null)
+                        return;
+                    addToPendingCount(1);
+                    new SearchValuesTask<K,V,U>
+                            (this, batch >>>= 1, baseLimit = h, f, tab,
+                                    searchFunction, result).fork();
+                }
+                while (result.get() == null) {
+                    U u;
+                    Node<K,V> p;
+                    if ((p = advance()) == null) {
+                        propagateCompletion();
+                        break;
+                    }
+                    if ((u = searchFunction.apply(p.val)) != null) {
+                        if (result.compareAndSet(null, u))
+                            quietlyCompleteRoot();
+                        break;
+                    }
+                }
+            }
+        }
+    }
+
+    @SuppressWarnings("serial")
+    static final class SearchEntriesTask<K,V,U>
+            extends BulkTask<K,V,U> {
+        final Fun<Entry<K,V>, ? extends U> searchFunction;
+        final AtomicReference<U> result;
+        SearchEntriesTask
+                (BulkTask<K,V,?> p, int b, int i, int f, Node<K,V>[] t,
+                 Fun<Entry<K,V>, ? extends U> searchFunction,
+                 AtomicReference<U> result) {
+            super(p, b, i, f, t);
+            this.searchFunction = searchFunction; this.result = result;
+        }
+        public final U getRawResult() { return result.get(); }
+        public final void compute() {
+            final Fun<Entry<K,V>, ? extends U> searchFunction;
+            final AtomicReference<U> result;
+            if ((searchFunction = this.searchFunction) != null &&
+                    (result = this.result) != null) {
+                for (int i = baseIndex, f, h; batch > 0 &&
+                        (h = ((f = baseLimit) + i) >>> 1) > i;) {
+                    if (result.get() != null)
+                        return;
+                    addToPendingCount(1);
+                    new SearchEntriesTask<K,V,U>
+                            (this, batch >>>= 1, baseLimit = h, f, tab,
+                                    searchFunction, result).fork();
+                }
+                while (result.get() == null) {
+                    U u;
+                    Node<K,V> p;
+                    if ((p = advance()) == null) {
+                        propagateCompletion();
+                        break;
+                    }
+                    if ((u = searchFunction.apply(p)) != null) {
+                        if (result.compareAndSet(null, u))
+                            quietlyCompleteRoot();
+                        return;
+                    }
+                }
+            }
+        }
+    }
+
+    @SuppressWarnings("serial")
+    static final class SearchMappingsTask<K,V,U>
+            extends BulkTask<K,V,U> {
+        final BiFun<? super K, ? super V, ? extends U> searchFunction;
+        final AtomicReference<U> result;
+        SearchMappingsTask
+                (BulkTask<K,V,?> p, int b, int i, int f, Node<K,V>[] t,
+                 BiFun<? super K, ? super V, ? extends U> searchFunction,
+                 AtomicReference<U> result) {
+            super(p, b, i, f, t);
+            this.searchFunction = searchFunction; this.result = result;
+        }
+        public final U getRawResult() { return result.get(); }
+        public final void compute() {
+            final BiFun<? super K, ? super V, ? extends U> searchFunction;
+            final AtomicReference<U> result;
+            if ((searchFunction = this.searchFunction) != null &&
+                    (result = this.result) != null) {
+                for (int i = baseIndex, f, h; batch > 0 &&
+                        (h = ((f = baseLimit) + i) >>> 1) > i;) {
+                    if (result.get() != null)
+                        return;
+                    addToPendingCount(1);
+                    new SearchMappingsTask<K,V,U>
+                            (this, batch >>>= 1, baseLimit = h, f, tab,
+                                    searchFunction, result).fork();
+                }
+                while (result.get() == null) {
+                    U u;
+                    Node<K,V> p;
+                    if ((p = advance()) == null) {
+                        propagateCompletion();
+                        break;
+                    }
+                    if ((u = searchFunction.apply(p.key, p.val)) != null) {
+                        if (result.compareAndSet(null, u))
+                            quietlyCompleteRoot();
+                        break;
+                    }
+                }
+            }
+        }
+    }
+
+    @SuppressWarnings("serial")
+    static final class ReduceKeysTask<K,V>
+            extends BulkTask<K,V,K> {
+        final BiFun<? super K, ? super K, ? extends K> reducer;
+        K result;
+        ReduceKeysTask<K,V> rights, nextRight;
+        ReduceKeysTask
+                (BulkTask<K,V,?> p, int b, int i, int f, Node<K,V>[] t,
+                 ReduceKeysTask<K,V> nextRight,
+                 BiFun<? super K, ? super K, ? extends K> reducer) {
+            super(p, b, i, f, t); this.nextRight = nextRight;
+            this.reducer = reducer;
+        }
+        public final K getRawResult() { return result; }
+        public final void compute() {
+            final BiFun<? super K, ? super K, ? extends K> reducer;
+            if ((reducer = this.reducer) != null) {
+                for (int i = baseIndex, f, h; batch > 0 &&
+                        (h = ((f = baseLimit) + i) >>> 1) > i;) {
+                    addToPendingCount(1);
+                    (rights = new ReduceKeysTask<K,V>
+                            (this, batch >>>= 1, baseLimit = h, f, tab,
+                                    rights, reducer)).fork();
+                }
+                K r = null;
+                for (Node<K,V> p; (p = advance()) != null; ) {
+                    K u = p.key;
+                    r = (r == null) ? u : u == null ? r : reducer.apply(r, u);
+                }
+                result = r;
+                CountedCompleter<?> c;
+                for (c = firstComplete(); c != null; c = c.nextComplete()) {
+                    @SuppressWarnings("unchecked") ReduceKeysTask<K,V>
+                            t = (ReduceKeysTask<K,V>)c,
+                            s = t.rights;
+                    while (s != null) {
+                        K tr, sr;
+                        if ((sr = s.result) != null)
+                            t.result = (((tr = t.result) == null) ? sr :
+                                    reducer.apply(tr, sr));
+                        s = t.rights = s.nextRight;
+                    }
+                }
+            }
+        }
+    }
+
+    @SuppressWarnings("serial")
+    static final class ReduceValuesTask<K,V>
+            extends BulkTask<K,V,V> {
+        final BiFun<? super V, ? super V, ? extends V> reducer;
+        V result;
+        ReduceValuesTask<K,V> rights, nextRight;
+        ReduceValuesTask
+                (BulkTask<K,V,?> p, int b, int i, int f, Node<K,V>[] t,
+                 ReduceValuesTask<K,V> nextRight,
+                 BiFun<? super V, ? super V, ? extends V> reducer) {
+            super(p, b, i, f, t); this.nextRight = nextRight;
+            this.reducer = reducer;
+        }
+        public final V getRawResult() { return result; }
+        public final void compute() {
+            final BiFun<? super V, ? super V, ? extends V> reducer;
+            if ((reducer = this.reducer) != null) {
+                for (int i = baseIndex, f, h; batch > 0 &&
+                        (h = ((f = baseLimit) + i) >>> 1) > i;) {
+                    addToPendingCount(1);
+                    (rights = new ReduceValuesTask<K,V>
+                            (this, batch >>>= 1, baseLimit = h, f, tab,
+                                    rights, reducer)).fork();
+                }
+                V r = null;
+                for (Node<K,V> p; (p = advance()) != null; ) {
+                    V v = p.val;
+                    r = (r == null) ? v : reducer.apply(r, v);
+                }
+                result = r;
+                CountedCompleter<?> c;
+                for (c = firstComplete(); c != null; c = c.nextComplete()) {
+                    @SuppressWarnings("unchecked") ReduceValuesTask<K,V>
+                            t = (ReduceValuesTask<K,V>)c,
+                            s = t.rights;
+                    while (s != null) {
+                        V tr, sr;
+                        if ((sr = s.result) != null)
+                            t.result = (((tr = t.result) == null) ? sr :
+                                    reducer.apply(tr, sr));
+                        s = t.rights = s.nextRight;
+                    }
+                }
+            }
+        }
+    }
+
+    @SuppressWarnings("serial")
+    static final class ReduceEntriesTask<K,V>
+            extends BulkTask<K,V,Map.Entry<K,V>> {
+        final BiFun<Map.Entry<K,V>, Map.Entry<K,V>, ? extends Map.Entry<K,V>> reducer;
+        Map.Entry<K,V> result;
+        ReduceEntriesTask<K,V> rights, nextRight;
+        ReduceEntriesTask
+                (BulkTask<K,V,?> p, int b, int i, int f, Node<K,V>[] t,
+                 ReduceEntriesTask<K,V> nextRight,
+                 BiFun<Entry<K,V>, Map.Entry<K,V>, ? extends Map.Entry<K,V>> reducer) {
+            super(p, b, i, f, t); this.nextRight = nextRight;
+            this.reducer = reducer;
+        }
+        public final Map.Entry<K,V> getRawResult() { return result; }
+        public final void compute() {
+            final BiFun<Map.Entry<K,V>, Map.Entry<K,V>, ? extends Map.Entry<K,V>> reducer;
+            if ((reducer = this.reducer) != null) {
+                for (int i = baseIndex, f, h; batch > 0 &&
+                        (h = ((f = baseLimit) + i) >>> 1) > i;) {
+                    addToPendingCount(1);
+                    (rights = new ReduceEntriesTask<K,V>
+                            (this, batch >>>= 1, baseLimit = h, f, tab,
+                                    rights, reducer)).fork();
+                }
+                Map.Entry<K,V> r = null;
+                for (Node<K,V> p; (p = advance()) != null; )
+                    r = (r == null) ? p : reducer.apply(r, p);
+                result = r;
+                CountedCompleter<?> c;
+                for (c = firstComplete(); c != null; c = c.nextComplete()) {
+                    @SuppressWarnings("unchecked") ReduceEntriesTask<K,V>
+                            t = (ReduceEntriesTask<K,V>)c,
+                            s = t.rights;
+                    while (s != null) {
+                        Map.Entry<K,V> tr, sr;
+                        if ((sr = s.result) != null)
+                            t.result = (((tr = t.result) == null) ? sr :
+                                    reducer.apply(tr, sr));
+                        s = t.rights = s.nextRight;
+                    }
+                }
+            }
+        }
+    }
+
+    @SuppressWarnings("serial")
+    static final class MapReduceKeysTask<K,V,U>
+            extends BulkTask<K,V,U> {
+        final Fun<? super K, ? extends U> transformer;
+        final BiFun<? super U, ? super U, ? extends U> reducer;
+        U result;
+        MapReduceKeysTask<K,V,U> rights, nextRight;
+        MapReduceKeysTask
+                (BulkTask<K,V,?> p, int b, int i, int f, Node<K,V>[] t,
+                 MapReduceKeysTask<K,V,U> nextRight,
+                 Fun<? super K, ? extends U> transformer,
+                 BiFun<? super U, ? super U, ? extends U> reducer) {
+            super(p, b, i, f, t); this.nextRight = nextRight;
+            this.transformer = transformer;
+            this.reducer = reducer;
+        }
+        public final U getRawResult() { return result; }
+        public final void compute() {
+            final Fun<? super K, ? extends U> transformer;
+            final BiFun<? super U, ? super U, ? extends U> reducer;
+            if ((transformer = this.transformer) != null &&
+                    (reducer = this.reducer) != null) {
+                for (int i = baseIndex, f, h; batch > 0 &&
+                        (h = ((f = baseLimit) + i) >>> 1) > i;) {
+                    addToPendingCount(1);
+                    (rights = new MapReduceKeysTask<K,V,U>
+                            (this, batch >>>= 1, baseLimit = h, f, tab,
+                                    rights, transformer, reducer)).fork();
+                }
+                U r = null;
+                for (Node<K,V> p; (p = advance()) != null; ) {
+                    U u;
+                    if ((u = transformer.apply(p.key)) != null)
+                        r = (r == null) ? u : reducer.apply(r, u);
+                }
+                result = r;
+                CountedCompleter<?> c;
+                for (c = firstComplete(); c != null; c = c.nextComplete()) {
+                    @SuppressWarnings("unchecked") MapReduceKeysTask<K,V,U>
+                            t = (MapReduceKeysTask<K,V,U>)c,
+                            s = t.rights;
+                    while (s != null) {
+                        U tr, sr;
+                        if ((sr = s.result) != null)
+                            t.result = (((tr = t.result) == null) ? sr :
+                                    reducer.apply(tr, sr));
+                        s = t.rights = s.nextRight;
+                    }
+                }
+            }
+        }
+    }
+
+    @SuppressWarnings("serial")
+    static final class MapReduceValuesTask<K,V,U>
+            extends BulkTask<K,V,U> {
+        final Fun<? super V, ? extends U> transformer;
+        final BiFun<? super U, ? super U, ? extends U> reducer;
+        U result;
+        MapReduceValuesTask<K,V,U> rights, nextRight;
+        MapReduceValuesTask
+                (BulkTask<K,V,?> p, int b, int i, int f, Node<K,V>[] t,
+                 MapReduceValuesTask<K,V,U> nextRight,
+                 Fun<? super V, ? extends U> transformer,
+                 BiFun<? super U, ? super U, ? extends U> reducer) {
+            super(p, b, i, f, t); this.nextRight = nextRight;
+            this.transformer = transformer;
+            this.reducer = reducer;
+        }
+        public final U getRawResult() { return result; }
+        public final void compute() {
+            final Fun<? super V, ? extends U> transformer;
+            final BiFun<? super U, ? super U, ? extends U> reducer;
+            if ((transformer = this.transformer) != null &&
+                    (reducer = this.reducer) != null) {
+                for (int i = baseIndex, f, h; batch > 0 &&
+                        (h = ((f = baseLimit) + i) >>> 1) > i;) {
+                    addToPendingCount(1);
+                    (rights = new MapReduceValuesTask<K,V,U>
+                            (this, batch >>>= 1, baseLimit = h, f, tab,
+                                    rights, transformer, reducer)).fork();
+                }
+                U r = null;
+                for (Node<K,V> p; (p = advance()) != null; ) {
+                    U u;
+                    if ((u = transformer.apply(p.val)) != null)
+                        r = (r == null) ? u : reducer.apply(r, u);
+                }
+                result = r;
+                CountedCompleter<?> c;
+                for (c = firstComplete(); c != null; c = c.nextComplete()) {
+                    @SuppressWarnings("unchecked") MapReduceValuesTask<K,V,U>
+                            t = (MapReduceValuesTask<K,V,U>)c,
+                            s = t.rights;
+                    while (s != null) {
+                        U tr, sr;
+                        if ((sr = s.result) != null)
+                            t.result = (((tr = t.result) == null) ? sr :
+                                    reducer.apply(tr, sr));
+                        s = t.rights = s.nextRight;
+                    }
+                }
+            }
+        }
+    }
+
+    @SuppressWarnings("serial")
+    static final class MapReduceEntriesTask<K,V,U>
+            extends BulkTask<K,V,U> {
+        final Fun<Map.Entry<K,V>, ? extends U> transformer;
+        final BiFun<? super U, ? super U, ? extends U> reducer;
+        U result;
+        MapReduceEntriesTask<K,V,U> rights, nextRight;
+        MapReduceEntriesTask
+                (BulkTask<K,V,?> p, int b, int i, int f, Node<K,V>[] t,
+                 MapReduceEntriesTask<K,V,U> nextRight,
+                 Fun<Map.Entry<K,V>, ? extends U> transformer,
+                 BiFun<? super U, ? super U, ? extends U> reducer) {
+            super(p, b, i, f, t); this.nextRight = nextRight;
+            this.transformer = transformer;
+            this.reducer = reducer;
+        }
+        public final U getRawResult() { return result; }
+        public final void compute() {
+            final Fun<Map.Entry<K,V>, ? extends U> transformer;
+            final BiFun<? super U, ? super U, ? extends U> reducer;
+            if ((transformer = this.transformer) != null &&
+                    (reducer = this.reducer) != null) {
+                for (int i = baseIndex, f, h; batch > 0 &&
+                        (h = ((f = baseLimit) + i) >>> 1) > i;) {
+                    addToPendingCount(1);
+                    (rights = new MapReduceEntriesTask<K,V,U>
+                            (this, batch >>>= 1, baseLimit = h, f, tab,
+                                    rights, transformer, reducer)).fork();
+                }
+                U r = null;
+                for (Node<K,V> p; (p = advance()) != null; ) {
+                    U u;
+                    if ((u = transformer.apply(p)) != null)
+                        r = (r == null) ? u : reducer.apply(r, u);
+                }
+                result = r;
+                CountedCompleter<?> c;
+                for (c = firstComplete(); c != null; c = c.nextComplete()) {
+                    @SuppressWarnings("unchecked") MapReduceEntriesTask<K,V,U>
+                            t = (MapReduceEntriesTask<K,V,U>)c,
+                            s = t.rights;
+                    while (s != null) {
+                        U tr, sr;
+                        if ((sr = s.result) != null)
+                            t.result = (((tr = t.result) == null) ? sr :
+                                    reducer.apply(tr, sr));
+                        s = t.rights = s.nextRight;
+                    }
+                }
+            }
+        }
+    }
+
+    @SuppressWarnings("serial")
+    static final class MapReduceMappingsTask<K,V,U>
+            extends BulkTask<K,V,U> {
+        final BiFun<? super K, ? super V, ? extends U> transformer;
+        final BiFun<? super U, ? super U, ? extends U> reducer;
+        U result;
+        MapReduceMappingsTask<K,V,U> rights, nextRight;
+        MapReduceMappingsTask
+                (BulkTask<K,V,?> p, int b, int i, int f, Node<K,V>[] t,
+                 MapReduceMappingsTask<K,V,U> nextRight,
+                 BiFun<? super K, ? super V, ? extends U> transformer,
+                 BiFun<? super U, ? super U, ? extends U> reducer) {
+            super(p, b, i, f, t); this.nextRight = nextRight;
+            this.transformer = transformer;
+            this.reducer = reducer;
+        }
+        public final U getRawResult() { return result; }
+        public final void compute() {
+            final BiFun<? super K, ? super V, ? extends U> transformer;
+            final BiFun<? super U, ? super U, ? extends U> reducer;
+            if ((transformer = this.transformer) != null &&
+                    (reducer = this.reducer) != null) {
+                for (int i = baseIndex, f, h; batch > 0 &&
+                        (h = ((f = baseLimit) + i) >>> 1) > i;) {
+                    addToPendingCount(1);
+                    (rights = new MapReduceMappingsTask<K,V,U>
+                            (this, batch >>>= 1, baseLimit = h, f, tab,
+                                    rights, transformer, reducer)).fork();
+                }
+                U r = null;
+                for (Node<K,V> p; (p = advance()) != null; ) {
+                    U u;
+                    if ((u = transformer.apply(p.key, p.val)) != null)
+                        r = (r == null) ? u : reducer.apply(r, u);
+                }
+                result = r;
+                CountedCompleter<?> c;
+                for (c = firstComplete(); c != null; c = c.nextComplete()) {
+                    @SuppressWarnings("unchecked") MapReduceMappingsTask<K,V,U>
+                            t = (MapReduceMappingsTask<K,V,U>)c,
+                            s = t.rights;
+                    while (s != null) {
+                        U tr, sr;
+                        if ((sr = s.result) != null)
+                            t.result = (((tr = t.result) == null) ? sr :
+                                    reducer.apply(tr, sr));
+                        s = t.rights = s.nextRight;
+                    }
+                }
+            }
+        }
+    }
+
+    @SuppressWarnings("serial")
+    static final class MapReduceKeysToDoubleTask<K,V>
+            extends BulkTask<K,V,Double> {
+        final ObjectToDouble<? super K> transformer;
+        final DoubleByDoubleToDouble reducer;
+        final double basis;
+        double result;
+        MapReduceKeysToDoubleTask<K,V> rights, nextRight;
+        MapReduceKeysToDoubleTask
+                (BulkTask<K,V,?> p, int b, int i, int f, Node<K,V>[] t,
+                 MapReduceKeysToDoubleTask<K,V> nextRight,
+                 ObjectToDouble<? super K> transformer,
+                 double basis,
+                 DoubleByDoubleToDouble reducer) {
+            super(p, b, i, f, t); this.nextRight = nextRight;
+            this.transformer = transformer;
+            this.basis = basis; this.reducer = reducer;
+        }
+        public final Double getRawResult() { return result; }
+        public final void compute() {
+            final ObjectToDouble<? super K> transformer;
+            final DoubleByDoubleToDouble reducer;
+            if ((transformer = this.transformer) != null &&
+                    (reducer = this.reducer) != null) {
+                double r = this.basis;
+                for (int i = baseIndex, f, h; batch > 0 &&
+                        (h = ((f = baseLimit) + i) >>> 1) > i;) {
+                    addToPendingCount(1);
+                    (rights = new MapReduceKeysToDoubleTask<K,V>
+                            (this, batch >>>= 1, baseLimit = h, f, tab,
+                                    rights, transformer, r, reducer)).fork();
+                }
+                for (Node<K,V> p; (p = advance()) != null; )
+                    r = reducer.apply(r, transformer.apply(p.key));
+                result = r;
+                CountedCompleter<?> c;
+                for (c = firstComplete(); c != null; c = c.nextComplete()) {
+                    @SuppressWarnings("unchecked") MapReduceKeysToDoubleTask<K,V>
+                            t = (MapReduceKeysToDoubleTask<K,V>)c,
+                            s = t.rights;
+                    while (s != null) {
+                        t.result = reducer.apply(t.result, s.result);
+                        s = t.rights = s.nextRight;
+                    }
+                }
+            }
+        }
+    }
+
+    @SuppressWarnings("serial")
+    static final class MapReduceValuesToDoubleTask<K,V>
+            extends BulkTask<K,V,Double> {
+        final ObjectToDouble<? super V> transformer;
+        final DoubleByDoubleToDouble reducer;
+        final double basis;
+        double result;
+        MapReduceValuesToDoubleTask<K,V> rights, nextRight;
+        MapReduceValuesToDoubleTask
+                (BulkTask<K,V,?> p, int b, int i, int f, Node<K,V>[] t,
+                 MapReduceValuesToDoubleTask<K,V> nextRight,
+                 ObjectToDouble<? super V> transformer,
+                 double basis,
+                 DoubleByDoubleToDouble reducer) {
+            super(p, b, i, f, t); this.nextRight = nextRight;
+            this.transformer = transformer;
+            this.basis = basis; this.reducer = reducer;
+        }
+        public final Double getRawResult() { return result; }
+        public final void compute() {
+            final ObjectToDouble<? super V> transformer;
+            final DoubleByDoubleToDouble reducer;
+            if ((transformer = this.transformer) != null &&
+                    (reducer = this.reducer) != null) {
+                double r = this.basis;
+                for (int i = baseIndex, f, h; batch > 0 &&
+                        (h = ((f = baseLimit) + i) >>> 1) > i;) {
+                    addToPendingCount(1);
+                    (rights = new MapReduceValuesToDoubleTask<K,V>
+                            (this, batch >>>= 1, baseLimit = h, f, tab,
+                                    rights, transformer, r, reducer)).fork();
+                }
+                for (Node<K,V> p; (p = advance()) != null; )
+                    r = reducer.apply(r, transformer.apply(p.val));
+                result = r;
+                CountedCompleter<?> c;
+                for (c = firstComplete(); c != null; c = c.nextComplete()) {
+                    @SuppressWarnings("unchecked") MapReduceValuesToDoubleTask<K,V>
+                            t = (MapReduceValuesToDoubleTask<K,V>)c,
+                            s = t.rights;
+                    while (s != null) {
+                        t.result = reducer.apply(t.result, s.result);
+                        s = t.rights = s.nextRight;
+                    }
+                }
+            }
+        }
+    }
+
+    @SuppressWarnings("serial")
+    static final class MapReduceEntriesToDoubleTask<K,V>
+            extends BulkTask<K,V,Double> {
+        final ObjectToDouble<Map.Entry<K,V>> transformer;
+        final DoubleByDoubleToDouble reducer;
+        final double basis;
+        double result;
+        MapReduceEntriesToDoubleTask<K,V> rights, nextRight;
+        MapReduceEntriesToDoubleTask
+                (BulkTask<K,V,?> p, int b, int i, int f, Node<K,V>[] t,
+                 MapReduceEntriesToDoubleTask<K,V> nextRight,
+                 ObjectToDouble<Map.Entry<K,V>> transformer,
+                 double basis,
+                 DoubleByDoubleToDouble reducer) {
+            super(p, b, i, f, t); this.nextRight = nextRight;
+            this.transformer = transformer;
+            this.basis = basis; this.reducer = reducer;
+        }
+        public final Double getRawResult() { return result; }
+        public final void compute() {
+            final ObjectToDouble<Map.Entry<K,V>> transformer;
+            final DoubleByDoubleToDouble reducer;
+            if ((transformer = this.transformer) != null &&
+                    (reducer = this.reducer) != null) {
+                double r = this.basis;
+                for (int i = baseIndex, f, h; batch > 0 &&
+                        (h = ((f = baseLimit) + i) >>> 1) > i;) {
+                    addToPendingCount(1);
+                    (rights = new MapReduceEntriesToDoubleTask<K,V>
+                            (this, batch >>>= 1, baseLimit = h, f, tab,
+                                    rights, transformer, r, reducer)).fork();
+                }
+                for (Node<K,V> p; (p = advance()) != null; )
+                    r = reducer.apply(r, transformer.apply(p));
+                result = r;
+                CountedCompleter<?> c;
+                for (c = firstComplete(); c != null; c = c.nextComplete()) {
+                    @SuppressWarnings("unchecked") MapReduceEntriesToDoubleTask<K,V>
+                            t = (MapReduceEntriesToDoubleTask<K,V>)c,
+                            s = t.rights;
+                    while (s != null) {
+                        t.result = reducer.apply(t.result, s.result);
+                        s = t.rights = s.nextRight;
+                    }
+                }
+            }
+        }
+    }
+
+    @SuppressWarnings("serial")
+    static final class MapReduceMappingsToDoubleTask<K,V>
+            extends BulkTask<K,V,Double> {
+        final ObjectByObjectToDouble<? super K, ? super V> transformer;
+        final DoubleByDoubleToDouble reducer;
+        final double basis;
+        double result;
+        MapReduceMappingsToDoubleTask<K,V> rights, nextRight;
+        MapReduceMappingsToDoubleTask
+                (BulkTask<K,V,?> p, int b, int i, int f, Node<K,V>[] t,
+                 MapReduceMappingsToDoubleTask<K,V> nextRight,
+                 ObjectByObjectToDouble<? super K, ? super V> transformer,
+                 double basis,
+                 DoubleByDoubleToDouble reducer) {
+            super(p, b, i, f, t); this.nextRight = nextRight;
+            this.transformer = transformer;
+            this.basis = basis; this.reducer = reducer;
+        }
+        public final Double getRawResult() { return result; }
+        public final void compute() {
+            final ObjectByObjectToDouble<? super K, ? super V> transformer;
+            final DoubleByDoubleToDouble reducer;
+            if ((transformer = this.transformer) != null &&
+                    (reducer = this.reducer) != null) {
+                double r = this.basis;
+                for (int i = baseIndex, f, h; batch > 0 &&
+                        (h = ((f = baseLimit) + i) >>> 1) > i;) {
+                    addToPendingCount(1);
+                    (rights = new MapReduceMappingsToDoubleTask<K,V>
+                            (this, batch >>>= 1, baseLimit = h, f, tab,
+                                    rights, transformer, r, reducer)).fork();
+                }
+                for (Node<K,V> p; (p = advance()) != null; )
+                    r = reducer.apply(r, transformer.apply(p.key, p.val));
+                result = r;
+                CountedCompleter<?> c;
+                for (c = firstComplete(); c != null; c = c.nextComplete()) {
+                    @SuppressWarnings("unchecked") MapReduceMappingsToDoubleTask<K,V>
+                            t = (MapReduceMappingsToDoubleTask<K,V>)c,
+                            s = t.rights;
+                    while (s != null) {
+                        t.result = reducer.apply(t.result, s.result);
+                        s = t.rights = s.nextRight;
+                    }
+                }
+            }
+        }
+    }
+
+    @SuppressWarnings("serial")
+    static final class MapReduceKeysToLongTask<K,V>
+            extends BulkTask<K,V,Long> {
+        final ObjectToLong<? super K> transformer;
+        final LongByLongToLong reducer;
+        final long basis;
+        long result;
+        MapReduceKeysToLongTask<K,V> rights, nextRight;
+        MapReduceKeysToLongTask
+                (BulkTask<K,V,?> p, int b, int i, int f, Node<K,V>[] t,
+                 MapReduceKeysToLongTask<K,V> nextRight,
+                 ObjectToLong<? super K> transformer,
+                 long basis,
+                 LongByLongToLong reducer) {
+            super(p, b, i, f, t); this.nextRight = nextRight;
+            this.transformer = transformer;
+            this.basis = basis; this.reducer = reducer;
+        }
+        public final Long getRawResult() { return result; }
+        public final void compute() {
+            final ObjectToLong<? super K> transformer;
+            final LongByLongToLong reducer;
+            if ((transformer = this.transformer) != null &&
+                    (reducer = this.reducer) != null) {
+                long r = this.basis;
+                for (int i = baseIndex, f, h; batch > 0 &&
+                        (h = ((f = baseLimit) + i) >>> 1) > i;) {
+                    addToPendingCount(1);
+                    (rights = new MapReduceKeysToLongTask<K,V>
+                            (this, batch >>>= 1, baseLimit = h, f, tab,
+                                    rights, transformer, r, reducer)).fork();
+                }
+                for (Node<K,V> p; (p = advance()) != null; )
+                    r = reducer.apply(r, transformer.apply(p.key));
+                result = r;
+                CountedCompleter<?> c;
+                for (c = firstComplete(); c != null; c = c.nextComplete()) {
+                    @SuppressWarnings("unchecked") MapReduceKeysToLongTask<K,V>
+                            t = (MapReduceKeysToLongTask<K,V>)c,
+                            s = t.rights;
+                    while (s != null) {
+                        t.result = reducer.apply(t.result, s.result);
+                        s = t.rights = s.nextRight;
+                    }
+                }
+            }
+        }
+    }
+
+    @SuppressWarnings("serial")
+    static final class MapReduceValuesToLongTask<K,V>
+            extends BulkTask<K,V,Long> {
+        final ObjectToLong<? super V> transformer;
+        final LongByLongToLong reducer;
+        final long basis;
+        long result;
+        MapReduceValuesToLongTask<K,V> rights, nextRight;
+        MapReduceValuesToLongTask
+                (BulkTask<K,V,?> p, int b, int i, int f, Node<K,V>[] t,
+                 MapReduceValuesToLongTask<K,V> nextRight,
+                 ObjectToLong<? super V> transformer,
+                 long basis,
+                 LongByLongToLong reducer) {
+            super(p, b, i, f, t); this.nextRight = nextRight;
+            this.transformer = transformer;
+            this.basis = basis; this.reducer = reducer;
+        }
+        public final Long getRawResult() { return result; }
+        public final void compute() {
+            final ObjectToLong<? super V> transformer;
+            final LongByLongToLong reducer;
+            if ((transformer = this.transformer) != null &&
+                    (reducer = this.reducer) != null) {
+                long r = this.basis;
+                for (int i = baseIndex, f, h; batch > 0 &&
+                        (h = ((f = baseLimit) + i) >>> 1) > i;) {
+                    addToPendingCount(1);
+                    (rights = new MapReduceValuesToLongTask<K,V>
+                            (this, batch >>>= 1, baseLimit = h, f, tab,
+                                    rights, transformer, r, reducer)).fork();
+                }
+                for (Node<K,V> p; (p = advance()) != null; )
+                    r = reducer.apply(r, transformer.apply(p.val));
+                result = r;
+                CountedCompleter<?> c;
+                for (c = firstComplete(); c != null; c = c.nextComplete()) {
+                    @SuppressWarnings("unchecked") MapReduceValuesToLongTask<K,V>
+                            t = (MapReduceValuesToLongTask<K,V>)c,
+                            s = t.rights;
+                    while (s != null) {
+                        t.result = reducer.apply(t.result, s.result);
+                        s = t.rights = s.nextRight;
+                    }
+                }
+            }
+        }
+    }
+
+    @SuppressWarnings("serial")
+    static final class MapReduceEntriesToLongTask<K,V>
+            extends BulkTask<K,V,Long> {
+        final ObjectToLong<Map.Entry<K,V>> transformer;
+        final LongByLongToLong reducer;
+        final long basis;
+        long result;
+        MapReduceEntriesToLongTask<K,V> rights, nextRight;
+        MapReduceEntriesToLongTask
+                (BulkTask<K,V,?> p, int b, int i, int f, Node<K,V>[] t,
+                 MapReduceEntriesToLongTask<K,V> nextRight,
+                 ObjectToLong<Map.Entry<K,V>> transformer,
+                 long basis,
+                 LongByLongToLong reducer) {
+            super(p, b, i, f, t); this.nextRight = nextRight;
+            this.transformer = transformer;
+            this.basis = basis; this.reducer = reducer;
+        }
+        public final Long getRawResult() { return result; }
+        public final void compute() {
+            final ObjectToLong<Map.Entry<K,V>> transformer;
+            final LongByLongToLong reducer;
+            if ((transformer = this.transformer) != null &&
+                    (reducer = this.reducer) != null) {
+                long r = this.basis;
+                for (int i = baseIndex, f, h; batch > 0 &&
+                        (h = ((f = baseLimit) + i) >>> 1) > i;) {
+                    addToPendingCount(1);
+                    (rights = new MapReduceEntriesToLongTask<K,V>
+                            (this, batch >>>= 1, baseLimit = h, f, tab,
+                                    rights, transformer, r, reducer)).fork();
+                }
+                for (Node<K,V> p; (p = advance()) != null; )
+                    r = reducer.apply(r, transformer.apply(p));
+                result = r;
+                CountedCompleter<?> c;
+                for (c = firstComplete(); c != null; c = c.nextComplete()) {
+                    @SuppressWarnings("unchecked") MapReduceEntriesToLongTask<K,V>
+                            t = (MapReduceEntriesToLongTask<K,V>)c,
+                            s = t.rights;
+                    while (s != null) {
+                        t.result = reducer.apply(t.result, s.result);
+                        s = t.rights = s.nextRight;
+                    }
+                }
+            }
+        }
+    }
+
+    @SuppressWarnings("serial")
+    static final class MapReduceMappingsToLongTask<K,V>
+            extends BulkTask<K,V,Long> {
+        final ObjectByObjectToLong<? super K, ? super V> transformer;
+        final LongByLongToLong reducer;
+        final long basis;
+        long result;
+        MapReduceMappingsToLongTask<K,V> rights, nextRight;
+        MapReduceMappingsToLongTask
+                (BulkTask<K,V,?> p, int b, int i, int f, Node<K,V>[] t,
+                 MapReduceMappingsToLongTask<K,V> nextRight,
+                 ObjectByObjectToLong<? super K, ? super V> transformer,
+                 long basis,
+                 LongByLongToLong reducer) {
+            super(p, b, i, f, t); this.nextRight = nextRight;
+            this.transformer = transformer;
+            this.basis = basis; this.reducer = reducer;
+        }
+        public final Long getRawResult() { return result; }
+        public final void compute() {
+            final ObjectByObjectToLong<? super K, ? super V> transformer;
+            final LongByLongToLong reducer;
+            if ((transformer = this.transformer) != null &&
+                    (reducer = this.reducer) != null) {
+                long r = this.basis;
+                for (int i = baseIndex, f, h; batch > 0 &&
+                        (h = ((f = baseLimit) + i) >>> 1) > i;) {
+                    addToPendingCount(1);
+                    (rights = new MapReduceMappingsToLongTask<K,V>
+                            (this, batch >>>= 1, baseLimit = h, f, tab,
+                                    rights, transformer, r, reducer)).fork();
+                }
+                for (Node<K,V> p; (p = advance()) != null; )
+                    r = reducer.apply(r, transformer.apply(p.key, p.val));
+                result = r;
+                CountedCompleter<?> c;
+                for (c = firstComplete(); c != null; c = c.nextComplete()) {
+                    @SuppressWarnings("unchecked") MapReduceMappingsToLongTask<K,V>
+                            t = (MapReduceMappingsToLongTask<K,V>)c,
+                            s = t.rights;
+                    while (s != null) {
+                        t.result = reducer.apply(t.result, s.result);
+                        s = t.rights = s.nextRight;
+                    }
+                }
+            }
+        }
+    }
+
+    @SuppressWarnings("serial")
+    static final class MapReduceKeysToIntTask<K,V>
+            extends BulkTask<K,V,Integer> {
+        final ObjectToInt<? super K> transformer;
+        final IntByIntToInt reducer;
+        final int basis;
+        int result;
+        MapReduceKeysToIntTask<K,V> rights, nextRight;
+        MapReduceKeysToIntTask
+                (BulkTask<K,V,?> p, int b, int i, int f, Node<K,V>[] t,
+                 MapReduceKeysToIntTask<K,V> nextRight,
+                 ObjectToInt<? super K> transformer,
+                 int basis,
+                 IntByIntToInt reducer) {
+            super(p, b, i, f, t); this.nextRight = nextRight;
+            this.transformer = transformer;
+            this.basis = basis; this.reducer = reducer;
+        }
+        public final Integer getRawResult() { return result; }
+        public final void compute() {
+            final ObjectToInt<? super K> transformer;
+            final IntByIntToInt reducer;
+            if ((transformer = this.transformer) != null &&
+                    (reducer = this.reducer) != null) {
+                int r = this.basis;
+                for (int i = baseIndex, f, h; batch > 0 &&
+                        (h = ((f = baseLimit) + i) >>> 1) > i;) {
+                    addToPendingCount(1);
+                    (rights = new MapReduceKeysToIntTask<K,V>
+                            (this, batch >>>= 1, baseLimit = h, f, tab,
+                                    rights, transformer, r, reducer)).fork();
+                }
+                for (Node<K,V> p; (p = advance()) != null; )
+                    r = reducer.apply(r, transformer.apply(p.key));
+                result = r;
+                CountedCompleter<?> c;
+                for (c = firstComplete(); c != null; c = c.nextComplete()) {
+                    @SuppressWarnings("unchecked") MapReduceKeysToIntTask<K,V>
+                            t = (MapReduceKeysToIntTask<K,V>)c,
+                            s = t.rights;
+                    while (s != null) {
+                        t.result = reducer.apply(t.result, s.result);
+                        s = t.rights = s.nextRight;
+                    }
+                }
+            }
+        }
+    }
+
+    @SuppressWarnings("serial")
+    static final class MapReduceValuesToIntTask<K,V>
+            extends BulkTask<K,V,Integer> {
+        final ObjectToInt<? super V> transformer;
+        final IntByIntToInt reducer;
+        final int basis;
+        int result;
+        MapReduceValuesToIntTask<K,V> rights, nextRight;
+        MapReduceValuesToIntTask
+                (BulkTask<K,V,?> p, int b, int i, int f, Node<K,V>[] t,
+                 MapReduceValuesToIntTask<K,V> nextRight,
+                 ObjectToInt<? super V> transformer,
+                 int basis,
+                 IntByIntToInt reducer) {
+            super(p, b, i, f, t); this.nextRight = nextRight;
+            this.transformer = transformer;
+            this.basis = basis; this.reducer = reducer;
+        }
+        public final Integer getRawResult() { return result; }
+        public final void compute() {
+            final ObjectToInt<? super V> transformer;
+            final IntByIntToInt reducer;
+            if ((transformer = this.transformer) != null &&
+                    (reducer = this.reducer) != null) {
+                int r = this.basis;
+                for (int i = baseIndex, f, h; batch > 0 &&
+                        (h = ((f = baseLimit) + i) >>> 1) > i;) {
+                    addToPendingCount(1);
+                    (rights = new MapReduceValuesToIntTask<K,V>
+                            (this, batch >>>= 1, baseLimit = h, f, tab,
+                                    rights, transformer, r, reducer)).fork();
+                }
+                for (Node<K,V> p; (p = advance()) != null; )
+                    r = reducer.apply(r, transformer.apply(p.val));
+                result = r;
+                CountedCompleter<?> c;
+                for (c = firstComplete(); c != null; c = c.nextComplete()) {
+                    @SuppressWarnings("unchecked") MapReduceValuesToIntTask<K,V>
+                            t = (MapReduceValuesToIntTask<K,V>)c,
+                            s = t.rights;
+                    while (s != null) {
+                        t.result = reducer.apply(t.result, s.result);
+                        s = t.rights = s.nextRight;
+                    }
+                }
+            }
+        }
+    }
+
+    @SuppressWarnings("serial")
+    static final class MapReduceEntriesToIntTask<K,V>
+            extends BulkTask<K,V,Integer> {
+        final ObjectToInt<Map.Entry<K,V>> transformer;
+        final IntByIntToInt reducer;
+        final int basis;
+        int result;
+        MapReduceEntriesToIntTask<K,V> rights, nextRight;
+        MapReduceEntriesToIntTask
+                (BulkTask<K,V,?> p, int b, int i, int f, Node<K,V>[] t,
+                 MapReduceEntriesToIntTask<K,V> nextRight,
+                 ObjectToInt<Map.Entry<K,V>> transformer,
+                 int basis,
+                 IntByIntToInt reducer) {
+            super(p, b, i, f, t); this.nextRight = nextRight;
+            this.transformer = transformer;
+            this.basis = basis; this.reducer = reducer;
+        }
+        public final Integer getRawResult() { return result; }
+        public final void compute() {
+            final ObjectToInt<Map.Entry<K,V>> transformer;
+            final IntByIntToInt reducer;
+            if ((transformer = this.transformer) != null &&
+                    (reducer = this.reducer) != null) {
+                int r = this.basis;
+                for (int i = baseIndex, f, h; batch > 0 &&
+                        (h = ((f = baseLimit) + i) >>> 1) > i;) {
+                    addToPendingCount(1);
+                    (rights = new MapReduceEntriesToIntTask<K,V>
+                            (this, batch >>>= 1, baseLimit = h, f, tab,
+                                    rights, transformer, r, reducer)).fork();
+                }
+                for (Node<K,V> p; (p = advance()) != null; )
+                    r = reducer.apply(r, transformer.apply(p));
+                result = r;
+                CountedCompleter<?> c;
+                for (c = firstComplete(); c != null; c = c.nextComplete()) {
+                    @SuppressWarnings("unchecked") MapReduceEntriesToIntTask<K,V>
+                            t = (MapReduceEntriesToIntTask<K,V>)c,
+                            s = t.rights;
+                    while (s != null) {
+                        t.result = reducer.apply(t.result, s.result);
+                        s = t.rights = s.nextRight;
+                    }
+                }
+            }
+        }
+    }
+
+    @SuppressWarnings("serial")
+    static final class MapReduceMappingsToIntTask<K,V>
+            extends BulkTask<K,V,Integer> {
+        final ObjectByObjectToInt<? super K, ? super V> transformer;
+        final IntByIntToInt reducer;
+        final int basis;
+        int result;
+        MapReduceMappingsToIntTask<K,V> rights, nextRight;
+        MapReduceMappingsToIntTask
+                (BulkTask<K,V,?> p, int b, int i, int f, Node<K,V>[] t,
+                 MapReduceMappingsToIntTask<K,V> nextRight,
+                 ObjectByObjectToInt<? super K, ? super V> transformer,
+                 int basis,
+                 IntByIntToInt reducer) {
+            super(p, b, i, f, t); this.nextRight = nextRight;
+            this.transformer = transformer;
+            this.basis = basis; this.reducer = reducer;
+        }
+        public final Integer getRawResult() { return result; }
+        public final void compute() {
+            final ObjectByObjectToInt<? super K, ? super V> transformer;
+            final IntByIntToInt reducer;
+            if ((transformer = this.transformer) != null &&
+                    (reducer = this.reducer) != null) {
+                int r = this.basis;
+                for (int i = baseIndex, f, h; batch > 0 &&
+                        (h = ((f = baseLimit) + i) >>> 1) > i;) {
+                    addToPendingCount(1);
+                    (rights = new MapReduceMappingsToIntTask<K,V>
+                            (this, batch >>>= 1, baseLimit = h, f, tab,
+                                    rights, transformer, r, reducer)).fork();
+                }
+                for (Node<K,V> p; (p = advance()) != null; )
+                    r = reducer.apply(r, transformer.apply(p.key, p.val));
+                result = r;
+                CountedCompleter<?> c;
+                for (c = firstComplete(); c != null; c = c.nextComplete()) {
+                    @SuppressWarnings("unchecked") MapReduceMappingsToIntTask<K,V>
+                            t = (MapReduceMappingsToIntTask<K,V>)c,
+                            s = t.rights;
+                    while (s != null) {
+                        t.result = reducer.apply(t.result, s.result);
+                        s = t.rights = s.nextRight;
+                    }
+                }
+            }
+        }
+    }
+
+    /* ---------------- Counters -------------- */
+
+    // Adapted from LongAdder and Striped64.
+    // See their internal docs for explanation.
+
+    // A padded cell for distributing counts
+    static final class CounterCell {
+        volatile long p0, p1, p2, p3, p4, p5, p6;
+        volatile long value;
+        volatile long q0, q1, q2, q3, q4, q5, q6;
+        CounterCell(long x) { value = x; }
+    }
+
+    /**
+     * Holder for the thread-local hash code determining which
+     * CounterCell to use. The code is initialized via the
+     * counterHashCodeGenerator, but may be moved upon collisions.
+     */
+    static final class CounterHashCode {
+        int code;
+    }
+
+    /**
+     * Generates initial value for per-thread CounterHashCodes.
+     */
+    static final AtomicInteger counterHashCodeGenerator = new AtomicInteger();
+
+    /**
+     * Increment for counterHashCodeGenerator. See class ThreadLocal
+     * for explanation.
+     */
+    static final int SEED_INCREMENT = 0x61c88647;
+
+    /**
+     * Per-thread counter hash codes. Shared across all instances.
+     */
+    static final ThreadLocal<CounterHashCode> threadCounterHashCode =
+            new ThreadLocal<CounterHashCode>();
+
+
+    final long sumCount() {
+        CounterCell[] as = counterCells; CounterCell a;
+        long sum = baseCount;
+        if (as != null) {
+            for (int i = 0; i < as.length; ++i) {
+                if ((a = as[i]) != null)
+                    sum += a.value;
+            }
+        }
+        return sum;
+    }
+
+    // See LongAdder version for explanation
+    private final void fullAddCount(long x, CounterHashCode hc,
+                                    boolean wasUncontended) {
+        int h;
+        if (hc == null) {
+            hc = new CounterHashCode();
+            int s = counterHashCodeGenerator.addAndGet(SEED_INCREMENT);
+            h = hc.code = (s == 0) ? 1 : s; // Avoid zero
+            threadCounterHashCode.set(hc);
+        }
+        else
+            h = hc.code;
+        boolean collide = false;                // True if last slot nonempty
+        for (;;) {
+            CounterCell[] as; CounterCell a; int n; long v;
+            if ((as = counterCells) != null && (n = as.length) > 0) {
+                if ((a = as[(n - 1) & h]) == null) {
+                    if (cellsBusy == 0) {            // Try to attach new Cell
+                        CounterCell r = new CounterCell(x); // Optimistic create
+                        if (cellsBusy == 0 &&
+                                U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) {
+                            boolean created = false;
+                            try {               // Recheck under lock
+                                CounterCell[] rs; int m, j;
+                                if ((rs = counterCells) != null &&
+                                        (m = rs.length) > 0 &&
+                                        rs[j = (m - 1) & h] == null) {
+                                    rs[j] = r;
+                                    created = true;
+                                }
+                            } finally {
+                                cellsBusy = 0;
+                            }
+                            if (created)
+                                break;
+                            continue;           // Slot is now non-empty
+                        }
+                    }
+                    collide = false;
+                }
+                else if (!wasUncontended)       // CAS already known to fail
+                    wasUncontended = true;      // Continue after rehash
+                else if (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))
+                    break;
+                else if (counterCells != as || n >= NCPU)
+                    collide = false;            // At max size or stale
+                else if (!collide)
+                    collide = true;
+                else if (cellsBusy == 0 &&
+                        U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) {
+                    try {
+                        if (counterCells == as) {// Expand table unless stale
+                            CounterCell[] rs = new CounterCell[n << 1];
+                            for (int i = 0; i < n; ++i)
+                                rs[i] = as[i];
+                            counterCells = rs;
+                        }
+                    } finally {
+                        cellsBusy = 0;
+                    }
+                    collide = false;
+                    continue;                   // Retry with expanded table
+                }
+                h ^= h << 13;                   // Rehash
+                h ^= h >>> 17;
+                h ^= h << 5;
+            }
+            else if (cellsBusy == 0 && counterCells == as &&
+                    U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) {
+                boolean init = false;
+                try {                           // Initialize table
+                    if (counterCells == as) {
+                        CounterCell[] rs = new CounterCell[2];
+                        rs[h & 1] = new CounterCell(x);
+                        counterCells = rs;
+                        init = true;
+                    }
+                } finally {
+                    cellsBusy = 0;
+                }
+                if (init)
+                    break;
+            }
+            else if (U.compareAndSwapLong(this, BASECOUNT, v = baseCount, v + x))
+                break;                          // Fall back on using base
+        }
+        hc.code = h;                            // Record index for next time
+    }
+
+    // Unsafe mechanics
+    private static final sun.misc.Unsafe U;
+    private static final long SIZECTL;
+    private static final long TRANSFERINDEX;
+    private static final long TRANSFERORIGIN;
+    private static final long BASECOUNT;
+    private static final long CELLSBUSY;
+    private static final long CELLVALUE;
+    private static final long ABASE;
+    private static final int ASHIFT;
+
+    static {
+        try {
+            U = getUnsafe();
+            Class<?> k = ConcurrentHashMapV8.class;
+            SIZECTL = U.objectFieldOffset
+                    (k.getDeclaredField("sizeCtl"));
+            TRANSFERINDEX = U.objectFieldOffset
+                    (k.getDeclaredField("transferIndex"));
+            TRANSFERORIGIN = U.objectFieldOffset
+                    (k.getDeclaredField("transferOrigin"));
+            BASECOUNT = U.objectFieldOffset
+                    (k.getDeclaredField("baseCount"));
+            CELLSBUSY = U.objectFieldOffset
+                    (k.getDeclaredField("cellsBusy"));
+            Class<?> ck = CounterCell.class;
+            CELLVALUE = U.objectFieldOffset
+                    (ck.getDeclaredField("value"));
+            Class<?> ak = Node[].class;
+            ABASE = U.arrayBaseOffset(ak);
+            int scale = U.arrayIndexScale(ak);
+            if ((scale & (scale - 1)) != 0)
+                throw new Error("data type scale not a power of two");
+            ASHIFT = 31 - Integer.numberOfLeadingZeros(scale);
+        } catch (Exception e) {
+            throw new Error(e);
+        }
+    }
+
+    /**
+     * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.
+     * Replace with a simple call to Unsafe.getUnsafe when integrating
+     * into a jdk.
+     *
+     * @return a sun.misc.Unsafe
+     */
+    private static sun.misc.Unsafe getUnsafe() {
+        try {
+            return sun.misc.Unsafe.getUnsafe();
+        } catch (SecurityException tryReflectionInstead) {}
+        try {
+            return java.security.AccessController.doPrivileged
+                    (new java.security.PrivilegedExceptionAction<sun.misc.Unsafe>() {
+                        public sun.misc.Unsafe run() throws Exception {
+                            Class<sun.misc.Unsafe> k = sun.misc.Unsafe.class;
+                            for (java.lang.reflect.Field f : k.getDeclaredFields()) {
+                                f.setAccessible(true);
+                                Object x = f.get(null);
+                                if (k.isInstance(x))
+                                    return k.cast(x);
+                            }
+                            throw new NoSuchFieldError("the Unsafe");
+                        }});
+        } catch (java.security.PrivilegedActionException e) {
+            throw new RuntimeException("Could not initialize intrinsics",
+                    e.getCause());
+        }
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/internal/chmv8/CountedCompleter.java b/api/src/main/java/org/asynchttpclient/internal/chmv8/CountedCompleter.java
new file mode 100644
index 000000000..50eaf4af3
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/internal/chmv8/CountedCompleter.java
@@ -0,0 +1,769 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+/*
+ * Written by Doug Lea with assistance from members of JCP JSR-166
+ * Expert Group and released to the public domain, as explained at
+ * http://creativecommons.org/publicdomain/zero/1.0/
+ */
+
+package org.asynchttpclient.internal.chmv8;
+
+import java.util.concurrent.RecursiveAction;
+
+/**
+ * A {@link ForkJoinTask} with a completion action performed when
+ * triggered and there are no remaining pending actions.
+ * CountedCompleters are in general more robust in the
+ * presence of subtask stalls and blockage than are other forms of
+ * ForkJoinTasks, but are less intuitive to program.  Uses of
+ * CountedCompleter are similar to those of other completion based
+ * components (such as {@link java.nio.channels.CompletionHandler})
+ * except that multiple <em>pending</em> completions may be necessary
+ * to trigger the completion action {@link #onCompletion(CountedCompleter)},
+ * not just one.
+ * Unless initialized otherwise, the {@linkplain #getPendingCount pending
+ * count} starts at zero, but may be (atomically) changed using
+ * methods {@link #setPendingCount}, {@link #addToPendingCount}, and
+ * {@link #compareAndSetPendingCount}. Upon invocation of {@link
+ * #tryComplete}, if the pending action count is nonzero, it is
+ * decremented; otherwise, the completion action is performed, and if
+ * this completer itself has a completer, the process is continued
+ * with its completer.  As is the case with related synchronization
+ * components such as {@link java.util.concurrent.Phaser Phaser} and
+ * {@link java.util.concurrent.Semaphore Semaphore}, these methods
+ * affect only internal counts; they do not establish any further
+ * internal bookkeeping. In particular, the identities of pending
+ * tasks are not maintained. As illustrated below, you can create
+ * subclasses that do record some or all pending tasks or their
+ * results when needed.  As illustrated below, utility methods
+ * supporting customization of completion traversals are also
+ * provided. However, because CountedCompleters provide only basic
+ * synchronization mechanisms, it may be useful to create further
+ * abstract subclasses that maintain linkages, fields, and additional
+ * support methods appropriate for a set of related usages.
+ *
+ * <p>A concrete CountedCompleter class must define method {@link
+ * #compute}, that should in most cases (as illustrated below), invoke
+ * {@code tryComplete()} once before returning. The class may also
+ * optionally override method {@link #onCompletion(CountedCompleter)}
+ * to perform an action upon normal completion, and method
+ * {@link #onExceptionalCompletion(Throwable, CountedCompleter)} to
+ * perform an action upon any exception.
+ *
+ * <p>CountedCompleters most often do not bear results, in which case
+ * they are normally declared as {@code CountedCompleter<Void>}, and
+ * will always return {@code null} as a result value.  In other cases,
+ * you should override method {@link #getRawResult} to provide a
+ * result from {@code join(), invoke()}, and related methods.  In
+ * general, this method should return the value of a field (or a
+ * function of one or more fields) of the CountedCompleter object that
+ * holds the result upon completion. Method {@link #setRawResult} by
+ * default plays no role in CountedCompleters.  It is possible, but
+ * rarely applicable, to override this method to maintain other
+ * objects or fields holding result data.
+ *
+ * <p>A CountedCompleter that does not itself have a completer (i.e.,
+ * one for which {@link #getCompleter} returns {@code null}) can be
+ * used as a regular ForkJoinTask with this added functionality.
+ * However, any completer that in turn has another completer serves
+ * only as an internal helper for other computations, so its own task
+ * status (as reported in methods such as {@link ForkJoinTask#isDone})
+ * is arbitrary; this status changes only upon explicit invocations of
+ * {@link #complete}, {@link ForkJoinTask#cancel},
+ * {@link ForkJoinTask#completeExceptionally(Throwable)} or upon
+ * exceptional completion of method {@code compute}. Upon any
+ * exceptional completion, the exception may be relayed to a task's
+ * completer (and its completer, and so on), if one exists and it has
+ * not otherwise already completed. Similarly, cancelling an internal
+ * CountedCompleter has only a local effect on that completer, so is
+ * not often useful.
+ *
+ * <p><b>Sample Usages.</b>
+ *
+ * <p><b>Parallel recursive decomposition.</b> CountedCompleters may
+ * be arranged in trees similar to those often used with {@link
+ * RecursiveAction}s, although the constructions involved in setting
+ * them up typically vary. Here, the completer of each task is its
+ * parent in the computation tree. Even though they entail a bit more
+ * bookkeeping, CountedCompleters may be better choices when applying
+ * a possibly time-consuming operation (that cannot be further
+ * subdivided) to each element of an array or collection; especially
+ * when the operation takes a significantly different amount of time
+ * to complete for some elements than others, either because of
+ * intrinsic variation (for example I/O) or auxiliary effects such as
+ * garbage collection.  Because CountedCompleters provide their own
+ * continuations, other threads need not block waiting to perform
+ * them.
+ *
+ * <p>For example, here is an initial version of a class that uses
+ * divide-by-two recursive decomposition to divide work into single
+ * pieces (leaf tasks). Even when work is split into individual calls,
+ * tree-based techniques are usually preferable to directly forking
+ * leaf tasks, because they reduce inter-thread communication and
+ * improve load balancing. In the recursive case, the second of each
+ * pair of subtasks to finish triggers completion of its parent
+ * (because no result combination is performed, the default no-op
+ * implementation of method {@code onCompletion} is not overridden).
+ * A static utility method sets up the base task and invokes it
+ * (here, implicitly using the {@link ForkJoinPool#commonPool()}).
+ *
+ * <pre> {@code
+ * class MyOperation<E> { void apply(E e) { ... }  }
+ *
+ * class ForEach<E> extends CountedCompleter<Void> {
+ *
+ *   public static <E> void forEach(E[] array, MyOperation<E> op) {
+ *     new ForEach<E>(null, array, op, 0, array.length).invoke();
+ *   }
+ *
+ *   final E[] array; final MyOperation<E> op; final int lo, hi;
+ *   ForEach(CountedCompleter<?> p, E[] array, MyOperation<E> op, int lo, int hi) {
+ *     super(p);
+ *     this.array = array; this.op = op; this.lo = lo; this.hi = hi;
+ *   }
+ *
+ *   public void compute() { // version 1
+ *     if (hi - lo >= 2) {
+ *       int mid = (lo + hi) >>> 1;
+ *       setPendingCount(2); // must set pending count before fork
+ *       new ForEach(this, array, op, mid, hi).fork(); // right child
+ *       new ForEach(this, array, op, lo, mid).fork(); // left child
+ *     }
+ *     else if (hi > lo)
+ *       op.apply(array[lo]);
+ *     tryComplete();
+ *   }
+ * }}</pre>
+ *
+ * This design can be improved by noticing that in the recursive case,
+ * the task has nothing to do after forking its right task, so can
+ * directly invoke its left task before returning. (This is an analog
+ * of tail recursion removal.)  Also, because the task returns upon
+ * executing its left task (rather than falling through to invoke
+ * {@code tryComplete}) the pending count is set to one:
+ *
+ * <pre> {@code
+ * class ForEach<E> ...
+ *   public void compute() { // version 2
+ *     if (hi - lo >= 2) {
+ *       int mid = (lo + hi) >>> 1;
+ *       setPendingCount(1); // only one pending
+ *       new ForEach(this, array, op, mid, hi).fork(); // right child
+ *       new ForEach(this, array, op, lo, mid).compute(); // direct invoke
+ *     }
+ *     else {
+ *       if (hi > lo)
+ *         op.apply(array[lo]);
+ *       tryComplete();
+ *     }
+ *   }
+ * }</pre>
+ *
+ * As a further improvement, notice that the left task need not even exist.
+ * Instead of creating a new one, we can iterate using the original task,
+ * and add a pending count for each fork.  Additionally, because no task
+ * in this tree implements an {@link #onCompletion(CountedCompleter)} method,
+ * {@code tryComplete()} can be replaced with {@link #propagateCompletion}.
+ *
+ * <pre> {@code
+ * class ForEach<E> ...
+ *   public void compute() { // version 3
+ *     int l = lo,  h = hi;
+ *     while (h - l >= 2) {
+ *       int mid = (l + h) >>> 1;
+ *       addToPendingCount(1);
+ *       new ForEach(this, array, op, mid, h).fork(); // right child
+ *       h = mid;
+ *     }
+ *     if (h > l)
+ *       op.apply(array[l]);
+ *     propagateCompletion();
+ *   }
+ * }</pre>
+ *
+ * Additional improvements of such classes might entail precomputing
+ * pending counts so that they can be established in constructors,
+ * specializing classes for leaf steps, subdividing by say, four,
+ * instead of two per iteration, and using an adaptive threshold
+ * instead of always subdividing down to single elements.
+ *
+ * <p><b>Searching.</b> A tree of CountedCompleters can search for a
+ * value or property in different parts of a data structure, and
+ * report a result in an {@link
+ * java.util.concurrent.atomic.AtomicReference AtomicReference} as
+ * soon as one is found. The others can poll the result to avoid
+ * unnecessary work. (You could additionally {@linkplain #cancel
+ * cancel} other tasks, but it is usually simpler and more efficient
+ * to just let them notice that the result is set and if so skip
+ * further processing.)  Illustrating again with an array using full
+ * partitioning (again, in practice, leaf tasks will almost always
+ * process more than one element):
+ *
+ * <pre> {@code
+ * class Searcher<E> extends CountedCompleter<E> {
+ *   final E[] array; final AtomicReference<E> result; final int lo, hi;
+ *   Searcher(CountedCompleter<?> p, E[] array, AtomicReference<E> result, int lo, int hi) {
+ *     super(p);
+ *     this.array = array; this.result = result; this.lo = lo; this.hi = hi;
+ *   }
+ *   public E getRawResult() { return result.get(); }
+ *   public void compute() { // similar to ForEach version 3
+ *     int l = lo,  h = hi;
+ *     while (result.get() == null && h >= l) {
+ *       if (h - l >= 2) {
+ *         int mid = (l + h) >>> 1;
+ *         addToPendingCount(1);
+ *         new Searcher(this, array, result, mid, h).fork();
+ *         h = mid;
+ *       }
+ *       else {
+ *         E x = array[l];
+ *         if (matches(x) && result.compareAndSet(null, x))
+ *           quietlyCompleteRoot(); // root task is now joinable
+ *         break;
+ *       }
+ *     }
+ *     tryComplete(); // normally complete whether or not found
+ *   }
+ *   boolean matches(E e) { ... } // return true if found
+ *
+ *   public static <E> E search(E[] array) {
+ *       return new Searcher<E>(null, array, new AtomicReference<E>(), 0, array.length).invoke();
+ *   }
+ * }}</pre>
+ *
+ * In this example, as well as others in which tasks have no other
+ * effects except to compareAndSet a common result, the trailing
+ * unconditional invocation of {@code tryComplete} could be made
+ * conditional ({@code if (result.get() == null) tryComplete();})
+ * because no further bookkeeping is required to manage completions
+ * once the root task completes.
+ *
+ * <p><b>Recording subtasks.</b> CountedCompleter tasks that combine
+ * results of multiple subtasks usually need to access these results
+ * in method {@link #onCompletion(CountedCompleter)}. As illustrated in the following
+ * class (that performs a simplified form of map-reduce where mappings
+ * and reductions are all of type {@code E}), one way to do this in
+ * divide and conquer designs is to have each subtask record its
+ * sibling, so that it can be accessed in method {@code onCompletion}.
+ * This technique applies to reductions in which the order of
+ * combining left and right results does not matter; ordered
+ * reductions require explicit left/right designations.  Variants of
+ * other streamlinings seen in the above examples may also apply.
+ *
+ * <pre> {@code
+ * class MyMapper<E> { E apply(E v) {  ...  } }
+ * class MyReducer<E> { E apply(E x, E y) {  ...  } }
+ * class MapReducer<E> extends CountedCompleter<E> {
+ *   final E[] array; final MyMapper<E> mapper;
+ *   final MyReducer<E> reducer; final int lo, hi;
+ *   MapReducer<E> sibling;
+ *   E result;
+ *   MapReducer(CountedCompleter<?> p, E[] array, MyMapper<E> mapper,
+ *              MyReducer<E> reducer, int lo, int hi) {
+ *     super(p);
+ *     this.array = array; this.mapper = mapper;
+ *     this.reducer = reducer; this.lo = lo; this.hi = hi;
+ *   }
+ *   public void compute() {
+ *     if (hi - lo >= 2) {
+ *       int mid = (lo + hi) >>> 1;
+ *       MapReducer<E> left = new MapReducer(this, array, mapper, reducer, lo, mid);
+ *       MapReducer<E> right = new MapReducer(this, array, mapper, reducer, mid, hi);
+ *       left.sibling = right;
+ *       right.sibling = left;
+ *       setPendingCount(1); // only right is pending
+ *       right.fork();
+ *       left.compute();     // directly execute left
+ *     }
+ *     else {
+ *       if (hi > lo)
+ *           result = mapper.apply(array[lo]);
+ *       tryComplete();
+ *     }
+ *   }
+ *   public void onCompletion(CountedCompleter<?> caller) {
+ *     if (caller != this) {
+ *       MapReducer<E> child = (MapReducer<E>)caller;
+ *       MapReducer<E> sib = child.sibling;
+ *       if (sib == null || sib.result == null)
+ *         result = child.result;
+ *       else
+ *         result = reducer.apply(child.result, sib.result);
+ *     }
+ *   }
+ *   public E getRawResult() { return result; }
+ *
+ *   public static <E> E mapReduce(E[] array, MyMapper<E> mapper, MyReducer<E> reducer) {
+ *     return new MapReducer<E>(null, array, mapper, reducer,
+ *                              0, array.length).invoke();
+ *   }
+ * }}</pre>
+ *
+ * Here, method {@code onCompletion} takes a form common to many
+ * completion designs that combine results. This callback-style method
+ * is triggered once per task, in either of the two different contexts
+ * in which the pending count is, or becomes, zero: (1) by a task
+ * itself, if its pending count is zero upon invocation of {@code
+ * tryComplete}, or (2) by any of its subtasks when they complete and
+ * decrement the pending count to zero. The {@code caller} argument
+ * distinguishes cases.  Most often, when the caller is {@code this},
+ * no action is necessary. Otherwise the caller argument can be used
+ * (usually via a cast) to supply a value (and/or links to other
+ * values) to be combined.  Assuming proper use of pending counts, the
+ * actions inside {@code onCompletion} occur (once) upon completion of
+ * a task and its subtasks. No additional synchronization is required
+ * within this method to ensure thread safety of accesses to fields of
+ * this task or other completed tasks.
+ *
+ * <p><b>Completion Traversals</b>. If using {@code onCompletion} to
+ * process completions is inapplicable or inconvenient, you can use
+ * methods {@link #firstComplete} and {@link #nextComplete} to create
+ * custom traversals.  For example, to define a MapReducer that only
+ * splits out right-hand tasks in the form of the third ForEach
+ * example, the completions must cooperatively reduce along
+ * unexhausted subtask links, which can be done as follows:
+ *
+ * <pre> {@code
+ * class MapReducer<E> extends CountedCompleter<E> { // version 2
+ *   final E[] array; final MyMapper<E> mapper;
+ *   final MyReducer<E> reducer; final int lo, hi;
+ *   MapReducer<E> forks, next; // record subtask forks in list
+ *   E result;
+ *   MapReducer(CountedCompleter<?> p, E[] array, MyMapper<E> mapper,
+ *              MyReducer<E> reducer, int lo, int hi, MapReducer<E> next) {
+ *     super(p);
+ *     this.array = array; this.mapper = mapper;
+ *     this.reducer = reducer; this.lo = lo; this.hi = hi;
+ *     this.next = next;
+ *   }
+ *   public void compute() {
+ *     int l = lo,  h = hi;
+ *     while (h - l >= 2) {
+ *       int mid = (l + h) >>> 1;
+ *       addToPendingCount(1);
+ *       (forks = new MapReducer(this, array, mapper, reducer, mid, h, forks)).fork();
+ *       h = mid;
+ *     }
+ *     if (h > l)
+ *       result = mapper.apply(array[l]);
+ *     // process completions by reducing along and advancing subtask links
+ *     for (CountedCompleter<?> c = firstComplete(); c != null; c = c.nextComplete()) {
+ *       for (MapReducer t = (MapReducer)c, s = t.forks;  s != null; s = t.forks = s.next)
+ *         t.result = reducer.apply(t.result, s.result);
+ *     }
+ *   }
+ *   public E getRawResult() { return result; }
+ *
+ *   public static <E> E mapReduce(E[] array, MyMapper<E> mapper, MyReducer<E> reducer) {
+ *     return new MapReducer<E>(null, array, mapper, reducer,
+ *                              0, array.length, null).invoke();
+ *   }
+ * }}</pre>
+ *
+ * <p><b>Triggers.</b> Some CountedCompleters are themselves never
+ * forked, but instead serve as bits of plumbing in other designs;
+ * including those in which the completion of one or more async tasks
+ * triggers another async task. For example:
+ *
+ * <pre> {@code
+ * class HeaderBuilder extends CountedCompleter<...> { ... }
+ * class BodyBuilder extends CountedCompleter<...> { ... }
+ * class PacketSender extends CountedCompleter<...> {
+ *   PacketSender(...) { super(null, 1); ... } // trigger on second completion
+ *   public void compute() { } // never called
+ *   public void onCompletion(CountedCompleter<?> caller) { sendPacket(); }
+ * }
+ * // sample use:
+ * PacketSender p = new PacketSender();
+ * new HeaderBuilder(p, ...).fork();
+ * new BodyBuilder(p, ...).fork();
+ * }</pre>
+ *
+ * @since 1.8
+ * @author Doug Lea
+ */
+@SuppressWarnings("all")
+public abstract class CountedCompleter<T> extends ForkJoinTask<T> {
+    private static final long serialVersionUID = 5232453752276485070L;
+
+    /** This task's completer, or null if none */
+    final CountedCompleter<?> completer;
+    /** The number of pending tasks until completion */
+    volatile int pending;
+
+    /**
+     * Creates a new CountedCompleter with the given completer
+     * and initial pending count.
+     *
+     * @param completer this task's completer, or {@code null} if none
+     * @param initialPendingCount the initial pending count
+     */
+    protected CountedCompleter(CountedCompleter<?> completer,
+                               int initialPendingCount) {
+        this.completer = completer;
+        this.pending = initialPendingCount;
+    }
+
+    /**
+     * Creates a new CountedCompleter with the given completer
+     * and an initial pending count of zero.
+     *
+     * @param completer this task's completer, or {@code null} if none
+     */
+    protected CountedCompleter(CountedCompleter<?> completer) {
+        this.completer = completer;
+    }
+
+    /**
+     * Creates a new CountedCompleter with no completer
+     * and an initial pending count of zero.
+     */
+    protected CountedCompleter() {
+        this.completer = null;
+    }
+
+    /**
+     * The main computation performed by this task.
+     */
+    public abstract void compute();
+
+    /**
+     * Performs an action when method {@link #tryComplete} is invoked
+     * and the pending count is zero, or when the unconditional
+     * method {@link #complete} is invoked.  By default, this method
+     * does nothing. You can distinguish cases by checking the
+     * identity of the given caller argument. If not equal to {@code
+     * this}, then it is typically a subtask that may contain results
+     * (and/or links to other results) to combine.
+     *
+     * @param caller the task invoking this method (which may
+     * be this task itself)
+     */
+    public void onCompletion(CountedCompleter<?> caller) {
+    }
+
+    /**
+     * Performs an action when method {@link
+     * #completeExceptionally(Throwable)} is invoked or method {@link
+     * #compute} throws an exception, and this task has not already
+     * otherwise completed normally. On entry to this method, this task
+     * {@link ForkJoinTask#isCompletedAbnormally}.  The return value
+     * of this method controls further propagation: If {@code true}
+     * and this task has a completer that has not completed, then that
+     * completer is also completed exceptionally, with the same
+     * exception as this completer.  The default implementation of
+     * this method does nothing except return {@code true}.
+     *
+     * @param ex the exception
+     * @param caller the task invoking this method (which may
+     * be this task itself)
+     * @return {@code true} if this exception should be propagated to this
+     * task's completer, if one exists
+     */
+    public boolean onExceptionalCompletion(Throwable ex, CountedCompleter<?> caller) {
+        return true;
+    }
+
+    /**
+     * Returns the completer established in this task's constructor,
+     * or {@code null} if none.
+     *
+     * @return the completer
+     */
+    public final CountedCompleter<?> getCompleter() {
+        return completer;
+    }
+
+    /**
+     * Returns the current pending count.
+     *
+     * @return the current pending count
+     */
+    public final int getPendingCount() {
+        return pending;
+    }
+
+    /**
+     * Sets the pending count to the given value.
+     *
+     * @param count the count
+     */
+    public final void setPendingCount(int count) {
+        pending = count;
+    }
+
+    /**
+     * Adds (atomically) the given value to the pending count.
+     *
+     * @param delta the value to add
+     */
+    public final void addToPendingCount(int delta) {
+        int c;
+        do {} while (!U.compareAndSwapInt(this, PENDING, c = pending, c+delta));
+    }
+
+    /**
+     * Sets (atomically) the pending count to the given count only if
+     * it currently holds the given expected value.
+     *
+     * @param expected the expected value
+     * @param count the new value
+     * @return {@code true} if successful
+     */
+    public final boolean compareAndSetPendingCount(int expected, int count) {
+        return U.compareAndSwapInt(this, PENDING, expected, count);
+    }
+
+    /**
+     * If the pending count is nonzero, (atomically) decrements it.
+     *
+     * @return the initial (undecremented) pending count holding on entry
+     * to this method
+     */
+    public final int decrementPendingCountUnlessZero() {
+        int c;
+        do {} while ((c = pending) != 0 &&
+                !U.compareAndSwapInt(this, PENDING, c, c - 1));
+        return c;
+    }
+
+    /**
+     * Returns the root of the current computation; i.e., this
+     * task if it has no completer, else its completer's root.
+     *
+     * @return the root of the current computation
+     */
+    public final CountedCompleter<?> getRoot() {
+        CountedCompleter<?> a = this, p;
+        while ((p = a.completer) != null)
+            a = p;
+        return a;
+    }
+
+    /**
+     * If the pending count is nonzero, decrements the count;
+     * otherwise invokes {@link #onCompletion(CountedCompleter)}
+     * and then similarly tries to complete this task's completer,
+     * if one exists, else marks this task as complete.
+     */
+    public final void tryComplete() {
+        CountedCompleter<?> a = this, s = a;
+        for (int c;;) {
+            if ((c = a.pending) == 0) {
+                a.onCompletion(s);
+                if ((a = (s = a).completer) == null) {
+                    s.quietlyComplete();
+                    return;
+                }
+            }
+            else if (U.compareAndSwapInt(a, PENDING, c, c - 1))
+                return;
+        }
+    }
+
+    /**
+     * Equivalent to {@link #tryComplete} but does not invoke {@link
+     * #onCompletion(CountedCompleter)} along the completion path:
+     * If the pending count is nonzero, decrements the count;
+     * otherwise, similarly tries to complete this task's completer, if
+     * one exists, else marks this task as complete. This method may be
+     * useful in cases where {@code onCompletion} should not, or need
+     * not, be invoked for each completer in a computation.
+     */
+    public final void propagateCompletion() {
+        CountedCompleter<?> a = this, s = a;
+        for (int c;;) {
+            if ((c = a.pending) == 0) {
+                if ((a = (s = a).completer) == null) {
+                    s.quietlyComplete();
+                    return;
+                }
+            }
+            else if (U.compareAndSwapInt(a, PENDING, c, c - 1))
+                return;
+        }
+    }
+
+    /**
+     * Regardless of pending count, invokes
+     * {@link #onCompletion(CountedCompleter)}, marks this task as
+     * complete and further triggers {@link #tryComplete} on this
+     * task's completer, if one exists.  The given rawResult is
+     * used as an argument to {@link #setRawResult} before invoking
+     * {@link #onCompletion(CountedCompleter)} or marking this task
+     * as complete; its value is meaningful only for classes
+     * overriding {@code setRawResult}.  This method does not modify
+     * the pending count.
+     *
+     * <p>This method may be useful when forcing completion as soon as
+     * any one (versus all) of several subtask results are obtained.
+     * However, in the common (and recommended) case in which {@code
+     * setRawResult} is not overridden, this effect can be obtained
+     * more simply using {@code quietlyCompleteRoot();}.
+     *
+     * @param rawResult the raw result
+     */
+    public void complete(T rawResult) {
+        CountedCompleter<?> p;
+        setRawResult(rawResult);
+        onCompletion(this);
+        quietlyComplete();
+        if ((p = completer) != null)
+            p.tryComplete();
+    }
+
+
+    /**
+     * If this task's pending count is zero, returns this task;
+     * otherwise decrements its pending count and returns {@code
+     * null}. This method is designed to be used with {@link
+     * #nextComplete} in completion traversal loops.
+     *
+     * @return this task, if pending count was zero, else {@code null}
+     */
+    public final CountedCompleter<?> firstComplete() {
+        for (int c;;) {
+            if ((c = pending) == 0)
+                return this;
+            else if (U.compareAndSwapInt(this, PENDING, c, c - 1))
+                return null;
+        }
+    }
+
+    /**
+     * If this task does not have a completer, invokes {@link
+     * ForkJoinTask#quietlyComplete} and returns {@code null}.  Or, if
+     * the completer's pending count is non-zero, decrements that
+     * pending count and returns {@code null}.  Otherwise, returns the
+     * completer.  This method can be used as part of a completion
+     * traversal loop for homogeneous task hierarchies:
+     *
+     * <pre> {@code
+     * for (CountedCompleter<?> c = firstComplete();
+     *      c != null;
+     *      c = c.nextComplete()) {
+     *   // ... process c ...
+     * }}</pre>
+     *
+     * @return the completer, or {@code null} if none
+     */
+    public final CountedCompleter<?> nextComplete() {
+        CountedCompleter<?> p;
+        if ((p = completer) != null)
+            return p.firstComplete();
+        else {
+            quietlyComplete();
+            return null;
+        }
+    }
+
+    /**
+     * Equivalent to {@code getRoot().quietlyComplete()}.
+     */
+    public final void quietlyCompleteRoot() {
+        for (CountedCompleter<?> a = this, p;;) {
+            if ((p = a.completer) == null) {
+                a.quietlyComplete();
+                return;
+            }
+            a = p;
+        }
+    }
+
+    /**
+     * Supports ForkJoinTask exception propagation.
+     */
+    void internalPropagateException(Throwable ex) {
+        CountedCompleter<?> a = this, s = a;
+        while (a.onExceptionalCompletion(ex, s) &&
+                (a = (s = a).completer) != null && a.status >= 0 &&
+                a.recordExceptionalCompletion(ex) == EXCEPTIONAL)
+            ;
+    }
+
+    /**
+     * Implements execution conventions for CountedCompleters.
+     */
+    protected final boolean exec() {
+        compute();
+        return false;
+    }
+
+    /**
+     * Returns the result of the computation. By default
+     * returns {@code null}, which is appropriate for {@code Void}
+     * actions, but in other cases should be overridden, almost
+     * always to return a field or function of a field that
+     * holds the result upon completion.
+     *
+     * @return the result of the computation
+     */
+    public T getRawResult() { return null; }
+
+    /**
+     * A method that result-bearing CountedCompleters may optionally
+     * use to help maintain result data.  By default, does nothing.
+     * Overrides are not recommended. However, if this method is
+     * overridden to update existing objects or fields, then it must
+     * in general be defined to be thread-safe.
+     */
+    protected void setRawResult(T t) { }
+
+    // Unsafe mechanics
+    private static final sun.misc.Unsafe U;
+    private static final long PENDING;
+    static {
+        try {
+            U = getUnsafe();
+            PENDING = U.objectFieldOffset
+                    (CountedCompleter.class.getDeclaredField("pending"));
+        } catch (Exception e) {
+            throw new Error(e);
+        }
+    }
+
+    /**
+     * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.
+     * Replace with a simple call to Unsafe.getUnsafe when integrating
+     * into a jdk.
+     *
+     * @return a sun.misc.Unsafe
+     */
+    private static sun.misc.Unsafe getUnsafe() {
+        try {
+            return sun.misc.Unsafe.getUnsafe();
+        } catch (SecurityException tryReflectionInstead) {}
+        try {
+            return java.security.AccessController.doPrivileged
+                    (new java.security.PrivilegedExceptionAction<sun.misc.Unsafe>() {
+                        public sun.misc.Unsafe run() throws Exception {
+                            Class<sun.misc.Unsafe> k = sun.misc.Unsafe.class;
+                            for (java.lang.reflect.Field f : k.getDeclaredFields()) {
+                                f.setAccessible(true);
+                                Object x = f.get(null);
+                                if (k.isInstance(x))
+                                    return k.cast(x);
+                            }
+                            throw new NoSuchFieldError("the Unsafe");
+                        }});
+        } catch (java.security.PrivilegedActionException e) {
+            throw new RuntimeException("Could not initialize intrinsics",
+                    e.getCause());
+        }
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/internal/chmv8/ForkJoinPool.java b/api/src/main/java/org/asynchttpclient/internal/chmv8/ForkJoinPool.java
new file mode 100644
index 000000000..88d539e03
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/internal/chmv8/ForkJoinPool.java
@@ -0,0 +1,3358 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+/*
+ * Written by Doug Lea with assistance from members of JCP JSR-166
+ * Expert Group and released to the public domain, as explained at
+ * http://creativecommons.org/publicdomain/zero/1.0/
+ */
+
+package org.asynchttpclient.internal.chmv8;
+
+import java.lang.Thread.UncaughtExceptionHandler;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.AbstractExecutorService;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Future;
+import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.RunnableFuture;
+import java.util.concurrent.ThreadLocalRandom;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * An {@link ExecutorService} for running {@link ForkJoinTask}s.
+ * A {@code ForkJoinPool} provides the entry point for submissions
+ * from non-{@code ForkJoinTask} clients, as well as management and
+ * monitoring operations.
+ *
+ * <p>A {@code ForkJoinPool} differs from other kinds of {@link
+ * ExecutorService} mainly by virtue of employing
+ * <em>work-stealing</em>: all threads in the pool attempt to find and
+ * execute tasks submitted to the pool and/or created by other active
+ * tasks (eventually blocking waiting for work if none exist). This
+ * enables efficient processing when most tasks spawn other subtasks
+ * (as do most {@code ForkJoinTask}s), as well as when many small
+ * tasks are submitted to the pool from external clients.  Especially
+ * when setting <em>asyncMode</em> to true in constructors, {@code
+ * ForkJoinPool}s may also be appropriate for use with event-style
+ * tasks that are never joined.
+ *
+ * <p>A static {@link #commonPool()} is available and appropriate for
+ * most applications. The common pool is used by any ForkJoinTask that
+ * is not explicitly submitted to a specified pool. Using the common
+ * pool normally reduces resource usage (its threads are slowly
+ * reclaimed during periods of non-use, and reinstated upon subsequent
+ * use).
+ *
+ * <p>For applications that require separate or custom pools, a {@code
+ * ForkJoinPool} may be constructed with a given target parallelism
+ * level; by default, equal to the number of available processors. The
+ * pool attempts to maintain enough active (or available) threads by
+ * dynamically adding, suspending, or resuming internal worker
+ * threads, even if some tasks are stalled waiting to join others.
+ * However, no such adjustments are guaranteed in the face of blocked
+ * I/O or other unmanaged synchronization. The nested {@link
+ * ManagedBlocker} interface enables extension of the kinds of
+ * synchronization accommodated.
+ *
+ * <p>In addition to execution and lifecycle control methods, this
+ * class provides status check methods (for example
+ * {@link #getStealCount}) that are intended to aid in developing,
+ * tuning, and monitoring fork/join applications. Also, method
+ * {@link #toString} returns indications of pool state in a
+ * convenient form for informal monitoring.
+ *
+ * <p>As is the case with other ExecutorServices, there are three
+ * main task execution methods summarized in the following table.
+ * These are designed to be used primarily by clients not already
+ * engaged in fork/join computations in the current pool.  The main
+ * forms of these methods accept instances of {@code ForkJoinTask},
+ * but overloaded forms also allow mixed execution of plain {@code
+ * Runnable}- or {@code Callable}- based activities as well.  However,
+ * tasks that are already executing in a pool should normally instead
+ * use the within-computation forms listed in the table unless using
+ * async event-style tasks that are not usually joined, in which case
+ * there is little difference among choice of methods.
+ *
+ * <table BORDER CELLPADDING=3 CELLSPACING=1>
+ * <caption>Summary of task execution methods</caption>
+ *  <tr>
+ *    <td></td>
+ *    <td ALIGN=CENTER> <b>Call from non-fork/join clients</b></td>
+ *    <td ALIGN=CENTER> <b>Call from within fork/join computations</b></td>
+ *  </tr>
+ *  <tr>
+ *    <td> <b>Arrange async execution</b></td>
+ *    <td> {@link #execute(ForkJoinTask)}</td>
+ *    <td> {@link ForkJoinTask#fork}</td>
+ *  </tr>
+ *  <tr>
+ *    <td> <b>Await and obtain result</b></td>
+ *    <td> {@link #invoke(ForkJoinTask)}</td>
+ *    <td> {@link ForkJoinTask#invoke}</td>
+ *  </tr>
+ *  <tr>
+ *    <td> <b>Arrange exec and obtain Future</b></td>
+ *    <td> {@link #submit(ForkJoinTask)}</td>
+ *    <td> {@link ForkJoinTask#fork} (ForkJoinTasks <em>are</em> Futures)</td>
+ *  </tr>
+ * </table>
+ *
+ * <p>The common pool is by default constructed with default
+ * parameters, but these may be controlled by setting three
+ * {@linkplain System#getProperty system properties}:
+ * <ul>
+ * <li>{@code java.util.concurrent.ForkJoinPool.common.parallelism}
+ * - the parallelism level, a non-negative integer
+ * <li>{@code java.util.concurrent.ForkJoinPool.common.threadFactory}
+ * - the class name of a {@link ForkJoinWorkerThreadFactory}
+ * <li>{@code java.util.concurrent.ForkJoinPool.common.exceptionHandler}
+ * - the class name of a {@link UncaughtExceptionHandler}
+ * </ul>
+ * The system class loader is used to load these classes.
+ * Upon any error in establishing these settings, default parameters
+ * are used. It is possible to disable or limit the use of threads in
+ * the common pool by setting the parallelism property to zero, and/or
+ * using a factory that may return {@code null}.
+ *
+ * <p><b>Implementation notes</b>: This implementation restricts the
+ * maximum number of running threads to 32767. Attempts to create
+ * pools with greater than the maximum number result in
+ * {@code IllegalArgumentException}.
+ *
+ * <p>This implementation rejects submitted tasks (that is, by throwing
+ * {@link RejectedExecutionException}) only when the pool is shut down
+ * or internal resources have been exhausted.
+ *
+ * @since 1.7
+ * @author Doug Lea
+ */
+@SuppressWarnings("all")
+public class ForkJoinPool extends AbstractExecutorService {
+
+    /*
+     * Implementation Overview
+     *
+     * This class and its nested classes provide the main
+     * functionality and control for a set of worker threads:
+     * Submissions from non-FJ threads enter into submission queues.
+     * Workers take these tasks and typically split them into subtasks
+     * that may be stolen by other workers.  Preference rules give
+     * first priority to processing tasks from their own queues (LIFO
+     * or FIFO, depending on mode), then to randomized FIFO steals of
+     * tasks in other queues.
+     *
+     * WorkQueues
+     * ==========
+     *
+     * Most operations occur within work-stealing queues (in nested
+     * class WorkQueue).  These are special forms of Deques that
+     * support only three of the four possible end-operations -- push,
+     * pop, and poll (aka steal), under the further constraints that
+     * push and pop are called only from the owning thread (or, as
+     * extended here, under a lock), while poll may be called from
+     * other threads.  (If you are unfamiliar with them, you probably
+     * want to read Herlihy and Shavit's book "The Art of
+     * Multiprocessor programming", chapter 16 describing these in
+     * more detail before proceeding.)  The main work-stealing queue
+     * design is roughly similar to those in the papers "Dynamic
+     * Circular Work-Stealing Deque" by Chase and Lev, SPAA 2005
+     * (http://research.sun.com/scalable/pubs/index.html) and
+     * "Idempotent work stealing" by Michael, Saraswat, and Vechev,
+     * PPoPP 2009 (http://portal.acm.org/citation.cfm?id=1504186).
+     * See also "Correct and Efficient Work-Stealing for Weak Memory
+     * Models" by Le, Pop, Cohen, and Nardelli, PPoPP 2013
+     * (http://www.di.ens.fr/~zappa/readings/ppopp13.pdf) for an
+     * analysis of memory ordering (atomic, volatile etc) issues.  The
+     * main differences ultimately stem from GC requirements that we
+     * null out taken slots as soon as we can, to maintain as small a
+     * footprint as possible even in programs generating huge numbers
+     * of tasks. To accomplish this, we shift the CAS arbitrating pop
+     * vs poll (steal) from being on the indices ("base" and "top") to
+     * the slots themselves.  So, both a successful pop and poll
+     * mainly entail a CAS of a slot from non-null to null.  Because
+     * we rely on CASes of references, we do not need tag bits on base
+     * or top.  They are simple ints as used in any circular
+     * array-based queue (see for example ArrayDeque).  Updates to the
+     * indices must still be ordered in a way that guarantees that top
+     * == base means the queue is empty, but otherwise may err on the
+     * side of possibly making the queue appear nonempty when a push,
+     * pop, or poll have not fully committed. Note that this means
+     * that the poll operation, considered individually, is not
+     * wait-free. One thief cannot successfully continue until another
+     * in-progress one (or, if previously empty, a push) completes.
+     * However, in the aggregate, we ensure at least probabilistic
+     * non-blockingness.  If an attempted steal fails, a thief always
+     * chooses a different random victim target to try next. So, in
+     * order for one thief to progress, it suffices for any
+     * in-progress poll or new push on any empty queue to
+     * complete. (This is why we normally use method pollAt and its
+     * variants that try once at the apparent base index, else
+     * consider alternative actions, rather than method poll.)
+     *
+     * This approach also enables support of a user mode in which local
+     * task processing is in FIFO, not LIFO order, simply by using
+     * poll rather than pop.  This can be useful in message-passing
+     * frameworks in which tasks are never joined.  However neither
+     * mode considers affinities, loads, cache localities, etc, so
+     * rarely provide the best possible performance on a given
+     * machine, but portably provide good throughput by averaging over
+     * these factors.  (Further, even if we did try to use such
+     * information, we do not usually have a basis for exploiting it.
+     * For example, some sets of tasks profit from cache affinities,
+     * but others are harmed by cache pollution effects.)
+     *
+     * WorkQueues are also used in a similar way for tasks submitted
+     * to the pool. We cannot mix these tasks in the same queues used
+     * for work-stealing (this would contaminate lifo/fifo
+     * processing). Instead, we randomly associate submission queues
+     * with submitting threads, using a form of hashing.  The
+     * Submitter probe value serves as a hash code for
+     * choosing existing queues, and may be randomly repositioned upon
+     * contention with other submitters.  In essence, submitters act
+     * like workers except that they are restricted to executing local
+     * tasks that they submitted (or in the case of CountedCompleters,
+     * others with the same root task).  However, because most
+     * shared/external queue operations are more expensive than
+     * internal, and because, at steady state, external submitters
+     * will compete for CPU with workers, ForkJoinTask.join and
+     * related methods disable them from repeatedly helping to process
+     * tasks if all workers are active.  Insertion of tasks in shared
+     * mode requires a lock (mainly to protect in the case of
+     * resizing) but we use only a simple spinlock (using bits in
+     * field qlock), because submitters encountering a busy queue move
+     * on to try or create other queues -- they block only when
+     * creating and registering new queues.
+     *
+     * Management
+     * ==========
+     *
+     * The main throughput advantages of work-stealing stem from
+     * decentralized control -- workers mostly take tasks from
+     * themselves or each other. We cannot negate this in the
+     * implementation of other management responsibilities. The main
+     * tactic for avoiding bottlenecks is packing nearly all
+     * essentially atomic control state into two volatile variables
+     * that are by far most often read (not written) as status and
+     * consistency checks.
+     *
+     * Field "ctl" contains 64 bits holding all the information needed
+     * to atomically decide to add, inactivate, enqueue (on an event
+     * queue), dequeue, and/or re-activate workers.  To enable this
+     * packing, we restrict maximum parallelism to (1<<15)-1 (which is
+     * far in excess of normal operating range) to allow ids, counts,
+     * and their negations (used for thresholding) to fit into 16bit
+     * fields.
+     *
+     * Field "plock" is a form of sequence lock with a saturating
+     * shutdown bit (similarly for per-queue "qlocks"), mainly
+     * protecting updates to the workQueues array, as well as to
+     * enable shutdown.  When used as a lock, it is normally only very
+     * briefly held, so is nearly always available after at most a
+     * brief spin, but we use a monitor-based backup strategy to
+     * block when needed.
+     *
+     * Recording WorkQueues.  WorkQueues are recorded in the
+     * "workQueues" array that is created upon first use and expanded
+     * if necessary.  Updates to the array while recording new workers
+     * and unrecording terminated ones are protected from each other
+     * by a lock but the array is otherwise concurrently readable, and
+     * accessed directly.  To simplify index-based operations, the
+     * array size is always a power of two, and all readers must
+     * tolerate null slots. Worker queues are at odd indices. Shared
+     * (submission) queues are at even indices, up to a maximum of 64
+     * slots, to limit growth even if array needs to expand to add
+     * more workers. Grouping them together in this way simplifies and
+     * speeds up task scanning.
+     *
+     * All worker thread creation is on-demand, triggered by task
+     * submissions, replacement of terminated workers, and/or
+     * compensation for blocked workers. However, all other support
+     * code is set up to work with other policies.  To ensure that we
+     * do not hold on to worker references that would prevent GC, ALL
+     * accesses to workQueues are via indices into the workQueues
+     * array (which is one source of some of the messy code
+     * constructions here). In essence, the workQueues array serves as
+     * a weak reference mechanism. Thus for example the wait queue
+     * field of ctl stores indices, not references.  Access to the
+     * workQueues in associated methods (for example signalWork) must
+     * both index-check and null-check the IDs. All such accesses
+     * ignore bad IDs by returning out early from what they are doing,
+     * since this can only be associated with termination, in which
+     * case it is OK to give up.  All uses of the workQueues array
+     * also check that it is non-null (even if previously
+     * non-null). This allows nulling during termination, which is
+     * currently not necessary, but remains an option for
+     * resource-revocation-based shutdown schemes. It also helps
+     * reduce JIT issuance of uncommon-trap code, which tends to
+     * unnecessarily complicate control flow in some methods.
+     *
+     * Event Queuing. Unlike HPC work-stealing frameworks, we cannot
+     * let workers spin indefinitely scanning for tasks when none can
+     * be found immediately, and we cannot start/resume workers unless
+     * there appear to be tasks available.  On the other hand, we must
+     * quickly prod them into action when new tasks are submitted or
+     * generated. In many usages, ramp-up time to activate workers is
+     * the main limiting factor in overall performance (this is
+     * compounded at program start-up by JIT compilation and
+     * allocation). So we try to streamline this as much as possible.
+     * We park/unpark workers after placing in an event wait queue
+     * when they cannot find work. This "queue" is actually a simple
+     * Treiber stack, headed by the "id" field of ctl, plus a 15bit
+     * counter value (that reflects the number of times a worker has
+     * been inactivated) to avoid ABA effects (we need only as many
+     * version numbers as worker threads). Successors are held in
+     * field WorkQueue.nextWait.  Queuing deals with several intrinsic
+     * races, mainly that a task-producing thread can miss seeing (and
+     * signalling) another thread that gave up looking for work but
+     * has not yet entered the wait queue. We solve this by requiring
+     * a full sweep of all workers (via repeated calls to method
+     * scan()) both before and after a newly waiting worker is added
+     * to the wait queue.  Because enqueued workers may actually be
+     * rescanning rather than waiting, we set and clear the "parker"
+     * field of WorkQueues to reduce unnecessary calls to unpark.
+     * (This requires a secondary recheck to avoid missed signals.)
+     * Note the unusual conventions about Thread.interrupts
+     * surrounding parking and other blocking: Because interrupts are
+     * used solely to alert threads to check termination, which is
+     * checked anyway upon blocking, we clear status (using
+     * Thread.interrupted) before any call to park, so that park does
+     * not immediately return due to status being set via some other
+     * unrelated call to interrupt in user code.
+     *
+     * Signalling.  We create or wake up workers only when there
+     * appears to be at least one task they might be able to find and
+     * execute.  When a submission is added or another worker adds a
+     * task to a queue that has fewer than two tasks, they signal
+     * waiting workers (or trigger creation of new ones if fewer than
+     * the given parallelism level -- signalWork).  These primary
+     * signals are buttressed by others whenever other threads remove
+     * a task from a queue and notice that there are other tasks there
+     * as well.  So in general, pools will be over-signalled. On most
+     * platforms, signalling (unpark) overhead time is noticeably
+     * long, and the time between signalling a thread and it actually
+     * making progress can be very noticeably long, so it is worth
+     * offloading these delays from critical paths as much as
+     * possible. Additionally, workers spin-down gradually, by staying
+     * alive so long as they see the ctl state changing.  Similar
+     * stability-sensing techniques are also used before blocking in
+     * awaitJoin and helpComplete.
+     *
+     * Trimming workers. To release resources after periods of lack of
+     * use, a worker starting to wait when the pool is quiescent will
+     * time out and terminate if the pool has remained quiescent for a
+     * given period -- a short period if there are more threads than
+     * parallelism, longer as the number of threads decreases. This
+     * will slowly propagate, eventually terminating all workers after
+     * periods of non-use.
+     *
+     * Shutdown and Termination. A call to shutdownNow atomically sets
+     * a plock bit and then (non-atomically) sets each worker's
+     * qlock status, cancels all unprocessed tasks, and wakes up
+     * all waiting workers.  Detecting whether termination should
+     * commence after a non-abrupt shutdown() call requires more work
+     * and bookkeeping. We need consensus about quiescence (i.e., that
+     * there is no more work). The active count provides a primary
+     * indication but non-abrupt shutdown still requires a rechecking
+     * scan for any workers that are inactive but not queued.
+     *
+     * Joining Tasks
+     * =============
+     *
+     * Any of several actions may be taken when one worker is waiting
+     * to join a task stolen (or always held) by another.  Because we
+     * are multiplexing many tasks on to a pool of workers, we can't
+     * just let them block (as in Thread.join).  We also cannot just
+     * reassign the joiner's run-time stack with another and replace
+     * it later, which would be a form of "continuation", that even if
+     * possible is not necessarily a good idea since we sometimes need
+     * both an unblocked task and its continuation to progress.
+     * Instead we combine two tactics:
+     *
+     *   Helping: Arranging for the joiner to execute some task that it
+     *      would be running if the steal had not occurred.
+     *
+     *   Compensating: Unless there are already enough live threads,
+     *      method tryCompensate() may create or re-activate a spare
+     *      thread to compensate for blocked joiners until they unblock.
+     *
+     * A third form (implemented in tryRemoveAndExec) amounts to
+     * helping a hypothetical compensator: If we can readily tell that
+     * a possible action of a compensator is to steal and execute the
+     * task being joined, the joining thread can do so directly,
+     * without the need for a compensation thread (although at the
+     * expense of larger run-time stacks, but the tradeoff is
+     * typically worthwhile).
+     *
+     * The ManagedBlocker extension API can't use helping so relies
+     * only on compensation in method awaitBlocker.
+     *
+     * The algorithm in tryHelpStealer entails a form of "linear"
+     * helping: Each worker records (in field currentSteal) the most
+     * recent task it stole from some other worker. Plus, it records
+     * (in field currentJoin) the task it is currently actively
+     * joining. Method tryHelpStealer uses these markers to try to
+     * find a worker to help (i.e., steal back a task from and execute
+     * it) that could hasten completion of the actively joined task.
+     * In essence, the joiner executes a task that would be on its own
+     * local deque had the to-be-joined task not been stolen. This may
+     * be seen as a conservative variant of the approach in Wagner &
+     * Calder "Leapfrogging: a portable technique for implementing
+     * efficient futures" SIGPLAN Notices, 1993
+     * (http://portal.acm.org/citation.cfm?id=155354). It differs in
+     * that: (1) We only maintain dependency links across workers upon
+     * steals, rather than use per-task bookkeeping.  This sometimes
+     * requires a linear scan of workQueues array to locate stealers,
+     * but often doesn't because stealers leave hints (that may become
+     * stale/wrong) of where to locate them.  It is only a hint
+     * because a worker might have had multiple steals and the hint
+     * records only one of them (usually the most current).  Hinting
+     * isolates cost to when it is needed, rather than adding to
+     * per-task overhead.  (2) It is "shallow", ignoring nesting and
+     * potentially cyclic mutual steals.  (3) It is intentionally
+     * racy: field currentJoin is updated only while actively joining,
+     * which means that we miss links in the chain during long-lived
+     * tasks, GC stalls etc (which is OK since blocking in such cases
+     * is usually a good idea).  (4) We bound the number of attempts
+     * to find work (see MAX_HELP) and fall back to suspending the
+     * worker and if necessary replacing it with another.
+     *
+     * Helping actions for CountedCompleters are much simpler: Method
+     * helpComplete can take and execute any task with the same root
+     * as the task being waited on. However, this still entails some
+     * traversal of completer chains, so is less efficient than using
+     * CountedCompleters without explicit joins.
+     *
+     * It is impossible to keep exactly the target parallelism number
+     * of threads running at any given time.  Determining the
+     * existence of conservatively safe helping targets, the
+     * availability of already-created spares, and the apparent need
+     * to create new spares are all racy, so we rely on multiple
+     * retries of each.  Compensation in the apparent absence of
+     * helping opportunities is challenging to control on JVMs, where
+     * GC and other activities can stall progress of tasks that in
+     * turn stall out many other dependent tasks, without us being
+     * able to determine whether they will ever require compensation.
+     * Even though work-stealing otherwise encounters little
+     * degradation in the presence of more threads than cores,
+     * aggressively adding new threads in such cases entails risk of
+     * unwanted positive feedback control loops in which more threads
+     * cause more dependent stalls (as well as delayed progress of
+     * unblocked threads to the point that we know they are available)
+     * leading to more situations requiring more threads, and so
+     * on. This aspect of control can be seen as an (analytically
+     * intractable) game with an opponent that may choose the worst
+     * (for us) active thread to stall at any time.  We take several
+     * precautions to bound losses (and thus bound gains), mainly in
+     * methods tryCompensate and awaitJoin.
+     *
+     * Common Pool
+     * ===========
+     *
+     * The static common pool always exists after static
+     * initialization.  Since it (or any other created pool) need
+     * never be used, we minimize initial construction overhead and
+     * footprint to the setup of about a dozen fields, with no nested
+     * allocation. Most bootstrapping occurs within method
+     * fullExternalPush during the first submission to the pool.
+     *
+     * When external threads submit to the common pool, they can
+     * perform subtask processing (see externalHelpJoin and related
+     * methods).  This caller-helps policy makes it sensible to set
+     * common pool parallelism level to one (or more) less than the
+     * total number of available cores, or even zero for pure
+     * caller-runs.  We do not need to record whether external
+     * submissions are to the common pool -- if not, externalHelpJoin
+     * returns quickly (at the most helping to signal some common pool
+     * workers). These submitters would otherwise be blocked waiting
+     * for completion, so the extra effort (with liberally sprinkled
+     * task status checks) in inapplicable cases amounts to an odd
+     * form of limited spin-wait before blocking in ForkJoinTask.join.
+     *
+     * Style notes
+     * ===========
+     *
+     * There is a lot of representation-level coupling among classes
+     * ForkJoinPool, ForkJoinWorkerThread, and ForkJoinTask.  The
+     * fields of WorkQueue maintain data structures managed by
+     * ForkJoinPool, so are directly accessed.  There is little point
+     * trying to reduce this, since any associated future changes in
+     * representations will need to be accompanied by algorithmic
+     * changes anyway. Several methods intrinsically sprawl because
+     * they must accumulate sets of consistent reads of volatiles held
+     * in local variables.  Methods signalWork() and scan() are the
+     * main bottlenecks, so are especially heavily
+     * micro-optimized/mangled.  There are lots of inline assignments
+     * (of form "while ((local = field) != 0)") which are usually the
+     * simplest way to ensure the required read orderings (which are
+     * sometimes critical). This leads to a "C"-like style of listing
+     * declarations of these locals at the heads of methods or blocks.
+     * There are several occurrences of the unusual "do {} while
+     * (!cas...)"  which is the simplest way to force an update of a
+     * CAS'ed variable. There are also other coding oddities (including
+     * several unnecessary-looking hoisted null checks) that help
+     * some methods perform reasonably even when interpreted (not
+     * compiled).
+     *
+     * The order of declarations in this file is:
+     * (1) Static utility functions
+     * (2) Nested (static) classes
+     * (3) Static fields
+     * (4) Fields, along with constants used when unpacking some of them
+     * (5) Internal control methods
+     * (6) Callbacks and other support for ForkJoinTask methods
+     * (7) Exported methods
+     * (8) Static block initializing statics in minimally dependent order
+     */
+
+    // Static utilities
+
+    /**
+     * If there is a security manager, makes sure caller has
+     * permission to modify threads.
+     */
+    private static void checkPermission() {
+        SecurityManager security = System.getSecurityManager();
+        if (security != null)
+            security.checkPermission(modifyThreadPermission);
+    }
+
+    // Nested classes
+
+    /**
+     * Factory for creating new {@link ForkJoinWorkerThread}s.
+     * A {@code ForkJoinWorkerThreadFactory} must be defined and used
+     * for {@code ForkJoinWorkerThread} subclasses that extend base
+     * functionality or initialize threads with different contexts.
+     */
+    public static interface ForkJoinWorkerThreadFactory {
+        /**
+         * Returns a new worker thread operating in the given pool.
+         *
+         * @param pool the pool this thread works in
+         * @throws NullPointerException if the pool is null
+         * @return the new worker thread
+         */
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool);
+    }
+
+    /**
+     * Default ForkJoinWorkerThreadFactory implementation; creates a
+     * new ForkJoinWorkerThread.
+     */
+    static final class DefaultForkJoinWorkerThreadFactory
+            implements ForkJoinWorkerThreadFactory {
+        public final ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            return new ForkJoinWorkerThread(pool);
+        }
+    }
+
+    /**
+     * Class for artificial tasks that are used to replace the target
+     * of local joins if they are removed from an interior queue slot
+     * in WorkQueue.tryRemoveAndExec. We don't need the proxy to
+     * actually do anything beyond having a unique identity.
+     */
+    static final class EmptyTask extends ForkJoinTask<Void> {
+        private static final long serialVersionUID = -7721805057305804111L;
+        EmptyTask() { status = ForkJoinTask.NORMAL; } // force done
+        public final Void getRawResult() { return null; }
+        public final void setRawResult(Void x) {}
+        public final boolean exec() { return true; }
+    }
+
+    /**
+     * Queues supporting work-stealing as well as external task
+     * submission. See above for main rationale and algorithms.
+     * Implementation relies heavily on "Unsafe" intrinsics
+     * and selective use of "volatile":
+     *
+     * Field "base" is the index (mod array.length) of the least valid
+     * queue slot, which is always the next position to steal (poll)
+     * from if nonempty. Reads and writes require volatile orderings
+     * but not CAS, because updates are only performed after slot
+     * CASes.
+     *
+     * Field "top" is the index (mod array.length) of the next queue
+     * slot to push to or pop from. It is written only by owner thread
+     * for push, or under lock for external/shared push, and accessed
+     * by other threads only after reading (volatile) base.  Both top
+     * and base are allowed to wrap around on overflow, but (top -
+     * base) (or more commonly -(base - top) to force volatile read of
+     * base before top) still estimates size. The lock ("qlock") is
+     * forced to -1 on termination, causing all further lock attempts
+     * to fail. (Note: we don't need CAS for termination state because
+     * upon pool shutdown, all shared-queues will stop being used
+     * anyway.)  Nearly all lock bodies are set up so that exceptions
+     * within lock bodies are "impossible" (modulo JVM errors that
+     * would cause failure anyway.)
+     *
+     * The array slots are read and written using the emulation of
+     * volatiles/atomics provided by Unsafe. Insertions must in
+     * general use putOrderedObject as a form of releasing store to
+     * ensure that all writes to the task object are ordered before
+     * its publication in the queue.  All removals entail a CAS to
+     * null.  The array is always a power of two. To ensure safety of
+     * Unsafe array operations, all accesses perform explicit null
+     * checks and implicit bounds checks via power-of-two masking.
+     *
+     * In addition to basic queuing support, this class contains
+     * fields described elsewhere to control execution. It turns out
+     * to work better memory-layout-wise to include them in this class
+     * rather than a separate class.
+     *
+     * Performance on most platforms is very sensitive to placement of
+     * instances of both WorkQueues and their arrays -- we absolutely
+     * do not want multiple WorkQueue instances or multiple queue
+     * arrays sharing cache lines. (It would be best for queue objects
+     * and their arrays to share, but there is nothing available to
+     * help arrange that). The @Contended annotation alerts JVMs to
+     * try to keep instances apart.
+     */
+    static final class WorkQueue {
+        /**
+         * Capacity of work-stealing queue array upon initialization.
+         * Must be a power of two; at least 4, but should be larger to
+         * reduce or eliminate cacheline sharing among queues.
+         * Currently, it is much larger, as a partial workaround for
+         * the fact that JVMs often place arrays in locations that
+         * share GC bookkeeping (especially cardmarks) such that
+         * per-write accesses encounter serious memory contention.
+         */
+        static final int INITIAL_QUEUE_CAPACITY = 1 << 13;
+
+        /**
+         * Maximum size for queue arrays. Must be a power of two less
+         * than or equal to 1 << (31 - width of array entry) to ensure
+         * lack of wraparound of index calculations, but defined to a
+         * value a bit less than this to help users trap runaway
+         * programs before saturating systems.
+         */
+        static final int MAXIMUM_QUEUE_CAPACITY = 1 << 26; // 64M
+
+        // Heuristic padding to ameliorate unfortunate memory placements
+        volatile long pad00, pad01, pad02, pad03, pad04, pad05, pad06;
+
+        volatile int eventCount;   // encoded inactivation count; < 0 if inactive
+        int nextWait;              // encoded record of next event waiter
+        int nsteals;               // number of steals
+        int hint;                  // steal index hint
+        short poolIndex;           // index of this queue in pool
+        final short mode;          // 0: lifo, > 0: fifo, < 0: shared
+        volatile int qlock;        // 1: locked, -1: terminate; else 0
+        volatile int base;         // index of next slot for poll
+        int top;                   // index of next slot for push
+        ForkJoinTask<?>[] array;   // the elements (initially unallocated)
+        final ForkJoinPool pool;   // the containing pool (may be null)
+        final ForkJoinWorkerThread owner; // owning thread or null if shared
+        volatile Thread parker;    // == owner during call to park; else null
+        volatile ForkJoinTask<?> currentJoin;  // task being joined in awaitJoin
+        ForkJoinTask<?> currentSteal; // current non-local task being executed
+
+        volatile Object pad10, pad11, pad12, pad13, pad14, pad15, pad16, pad17;
+        volatile Object pad18, pad19, pad1a, pad1b, pad1c, pad1d;
+
+        WorkQueue(ForkJoinPool pool, ForkJoinWorkerThread owner, int mode,
+                  int seed) {
+            this.pool = pool;
+            this.owner = owner;
+            this.mode = (short)mode;
+            this.hint = seed; // store initial seed for runWorker
+            // Place indices in the center of array (that is not yet allocated)
+            base = top = INITIAL_QUEUE_CAPACITY >>> 1;
+        }
+
+        /**
+         * Returns the approximate number of tasks in the queue.
+         */
+        final int queueSize() {
+            int n = base - top;       // non-owner callers must read base first
+            return (n >= 0) ? 0 : -n; // ignore transient negative
+        }
+
+        /**
+         * Provides a more accurate estimate of whether this queue has
+         * any tasks than does queueSize, by checking whether a
+         * near-empty queue has at least one unclaimed task.
+         */
+        final boolean isEmpty() {
+            ForkJoinTask<?>[] a; int m, s;
+            int n = base - (s = top);
+            return (n >= 0 ||
+                    (n == -1 &&
+                            ((a = array) == null ||
+                                    (m = a.length - 1) < 0 ||
+                                    U.getObject
+                                            (a, (long)((m & (s - 1)) << ASHIFT) + ABASE) == null)));
+        }
+
+        /**
+         * Pushes a task. Call only by owner in unshared queues.  (The
+         * shared-queue version is embedded in method externalPush.)
+         *
+         * @param task the task. Caller must ensure non-null.
+         * @throws RejectedExecutionException if array cannot be resized
+         */
+        final void push(ForkJoinTask<?> task) {
+            ForkJoinTask<?>[] a; ForkJoinPool p;
+            int s = top, n;
+            if ((a = array) != null) {    // ignore if queue removed
+                int m = a.length - 1;
+                U.putOrderedObject(a, ((m & s) << ASHIFT) + ABASE, task);
+                if ((n = (top = s + 1) - base) <= 2)
+                    (p = pool).signalWork(p.workQueues, this);
+                else if (n >= m)
+                    growArray();
+            }
+        }
+
+        /**
+         * Initializes or doubles the capacity of array. Call either
+         * by owner or with lock held -- it is OK for base, but not
+         * top, to move while resizings are in progress.
+         */
+        final ForkJoinTask<?>[] growArray() {
+            ForkJoinTask<?>[] oldA = array;
+            int size = oldA != null ? oldA.length << 1 : INITIAL_QUEUE_CAPACITY;
+            if (size > MAXIMUM_QUEUE_CAPACITY)
+                throw new RejectedExecutionException("Queue capacity exceeded");
+            int oldMask, t, b;
+            ForkJoinTask<?>[] a = array = new ForkJoinTask<?>[size];
+            if (oldA != null && (oldMask = oldA.length - 1) >= 0 &&
+                    (t = top) - (b = base) > 0) {
+                int mask = size - 1;
+                do {
+                    ForkJoinTask<?> x;
+                    int oldj = ((b & oldMask) << ASHIFT) + ABASE;
+                    int j    = ((b &    mask) << ASHIFT) + ABASE;
+                    x = (ForkJoinTask<?>)U.getObjectVolatile(oldA, oldj);
+                    if (x != null &&
+                            U.compareAndSwapObject(oldA, oldj, x, null))
+                        U.putObjectVolatile(a, j, x);
+                } while (++b != t);
+            }
+            return a;
+        }
+
+        /**
+         * Takes next task, if one exists, in LIFO order.  Call only
+         * by owner in unshared queues.
+         */
+        final ForkJoinTask<?> pop() {
+            ForkJoinTask<?>[] a; ForkJoinTask<?> t; int m;
+            if ((a = array) != null && (m = a.length - 1) >= 0) {
+                for (int s; (s = top - 1) - base >= 0;) {
+                    long j = ((m & s) << ASHIFT) + ABASE;
+                    if ((t = (ForkJoinTask<?>)U.getObject(a, j)) == null)
+                        break;
+                    if (U.compareAndSwapObject(a, j, t, null)) {
+                        top = s;
+                        return t;
+                    }
+                }
+            }
+            return null;
+        }
+
+        /**
+         * Takes a task in FIFO order if b is base of queue and a task
+         * can be claimed without contention. Specialized versions
+         * appear in ForkJoinPool methods scan and tryHelpStealer.
+         */
+        final ForkJoinTask<?> pollAt(int b) {
+            ForkJoinTask<?> t; ForkJoinTask<?>[] a;
+            if ((a = array) != null) {
+                int j = (((a.length - 1) & b) << ASHIFT) + ABASE;
+                if ((t = (ForkJoinTask<?>)U.getObjectVolatile(a, j)) != null &&
+                        base == b && U.compareAndSwapObject(a, j, t, null)) {
+                    U.putOrderedInt(this, QBASE, b + 1);
+                    return t;
+                }
+            }
+            return null;
+        }
+
+        /**
+         * Takes next task, if one exists, in FIFO order.
+         */
+        final ForkJoinTask<?> poll() {
+            ForkJoinTask<?>[] a; int b; ForkJoinTask<?> t;
+            while ((b = base) - top < 0 && (a = array) != null) {
+                int j = (((a.length - 1) & b) << ASHIFT) + ABASE;
+                t = (ForkJoinTask<?>)U.getObjectVolatile(a, j);
+                if (t != null) {
+                    if (U.compareAndSwapObject(a, j, t, null)) {
+                        U.putOrderedInt(this, QBASE, b + 1);
+                        return t;
+                    }
+                }
+                else if (base == b) {
+                    if (b + 1 == top)
+                        break;
+                    Thread.yield(); // wait for lagging update (very rare)
+                }
+            }
+            return null;
+        }
+
+        /**
+         * Takes next task, if one exists, in order specified by mode.
+         */
+        final ForkJoinTask<?> nextLocalTask() {
+            return mode == 0 ? pop() : poll();
+        }
+
+        /**
+         * Returns next task, if one exists, in order specified by mode.
+         */
+        final ForkJoinTask<?> peek() {
+            ForkJoinTask<?>[] a = array; int m;
+            if (a == null || (m = a.length - 1) < 0)
+                return null;
+            int i = mode == 0 ? top - 1 : base;
+            int j = ((i & m) << ASHIFT) + ABASE;
+            return (ForkJoinTask<?>)U.getObjectVolatile(a, j);
+        }
+
+        /**
+         * Pops the given task only if it is at the current top.
+         * (A shared version is available only via FJP.tryExternalUnpush)
+         */
+        final boolean tryUnpush(ForkJoinTask<?> t) {
+            ForkJoinTask<?>[] a; int s;
+            if ((a = array) != null && (s = top) != base &&
+                    U.compareAndSwapObject
+                            (a, (((a.length - 1) & --s) << ASHIFT) + ABASE, t, null)) {
+                top = s;
+                return true;
+            }
+            return false;
+        }
+
+        /**
+         * Removes and cancels all known tasks, ignoring any exceptions.
+         */
+        final void cancelAll() {
+            ForkJoinTask.cancelIgnoringExceptions(currentJoin);
+            ForkJoinTask.cancelIgnoringExceptions(currentSteal);
+            for (ForkJoinTask<?> t; (t = poll()) != null; )
+                ForkJoinTask.cancelIgnoringExceptions(t);
+        }
+
+        // Specialized execution methods
+
+        /**
+         * Polls and runs tasks until empty.
+         */
+        final void pollAndExecAll() {
+            for (ForkJoinTask<?> t; (t = poll()) != null;)
+                t.doExec();
+        }
+
+        /**
+         * Executes a top-level task and any local tasks remaining
+         * after execution.
+         */
+        final void runTask(ForkJoinTask<?> task) {
+            if ((currentSteal = task) != null) {
+                task.doExec();
+                ForkJoinTask<?>[] a = array;
+                int md = mode;
+                ++nsteals;
+                currentSteal = null;
+                if (md != 0)
+                    pollAndExecAll();
+                else if (a != null) {
+                    int s, m = a.length - 1;
+                    while ((s = top - 1) - base >= 0) {
+                        long i = ((m & s) << ASHIFT) + ABASE;
+                        ForkJoinTask<?> t = (ForkJoinTask<?>)U.getObject(a, i);
+                        if (t == null)
+                            break;
+                        if (U.compareAndSwapObject(a, i, t, null)) {
+                            top = s;
+                            t.doExec();
+                        }
+                    }
+                }
+            }
+        }
+
+        /**
+         * If present, removes from queue and executes the given task,
+         * or any other cancelled task. Returns (true) on any CAS
+         * or consistency check failure so caller can retry.
+         *
+         * @return false if no progress can be made, else true
+         */
+        final boolean tryRemoveAndExec(ForkJoinTask<?> task) {
+            boolean stat;
+            ForkJoinTask<?>[] a; int m, s, b, n;
+            if (task != null && (a = array) != null && (m = a.length - 1) >= 0 &&
+                    (n = (s = top) - (b = base)) > 0) {
+                boolean removed = false, empty = true;
+                stat = true;
+                for (ForkJoinTask<?> t;;) {           // traverse from s to b
+                    long j = ((--s & m) << ASHIFT) + ABASE;
+                    t = (ForkJoinTask<?>)U.getObject(a, j);
+                    if (t == null)                    // inconsistent length
+                        break;
+                    else if (t == task) {
+                        if (s + 1 == top) {           // pop
+                            if (!U.compareAndSwapObject(a, j, task, null))
+                                break;
+                            top = s;
+                            removed = true;
+                        }
+                        else if (base == b)           // replace with proxy
+                            removed = U.compareAndSwapObject(a, j, task,
+                                    new EmptyTask());
+                        break;
+                    }
+                    else if (t.status >= 0)
+                        empty = false;
+                    else if (s + 1 == top) {          // pop and throw away
+                        if (U.compareAndSwapObject(a, j, t, null))
+                            top = s;
+                        break;
+                    }
+                    if (--n == 0) {
+                        if (!empty && base == b)
+                            stat = false;
+                        break;
+                    }
+                }
+                if (removed)
+                    task.doExec();
+            }
+            else
+                stat = false;
+            return stat;
+        }
+
+        /**
+         * Tries to poll for and execute the given task or any other
+         * task in its CountedCompleter computation.
+         */
+        final boolean pollAndExecCC(CountedCompleter<?> root) {
+            ForkJoinTask<?>[] a; int b; Object o; CountedCompleter<?> t, r;
+            if ((b = base) - top < 0 && (a = array) != null) {
+                long j = (((a.length - 1) & b) << ASHIFT) + ABASE;
+                if ((o = U.getObjectVolatile(a, j)) == null)
+                    return true; // retry
+                if (o instanceof CountedCompleter) {
+                    for (t = (CountedCompleter<?>)o, r = t;;) {
+                        if (r == root) {
+                            if (base == b &&
+                                    U.compareAndSwapObject(a, j, t, null)) {
+                                U.putOrderedInt(this, QBASE, b + 1);
+                                t.doExec();
+                            }
+                            return true;
+                        }
+                        else if ((r = r.completer) == null)
+                            break; // not part of root computation
+                    }
+                }
+            }
+            return false;
+        }
+
+        /**
+         * Tries to pop and execute the given task or any other task
+         * in its CountedCompleter computation.
+         */
+        final boolean externalPopAndExecCC(CountedCompleter<?> root) {
+            ForkJoinTask<?>[] a; int s; Object o; CountedCompleter<?> t, r;
+            if (base - (s = top) < 0 && (a = array) != null) {
+                long j = (((a.length - 1) & (s - 1)) << ASHIFT) + ABASE;
+                if ((o = U.getObject(a, j)) instanceof CountedCompleter) {
+                    for (t = (CountedCompleter<?>)o, r = t;;) {
+                        if (r == root) {
+                            if (U.compareAndSwapInt(this, QLOCK, 0, 1)) {
+                                if (top == s && array == a &&
+                                        U.compareAndSwapObject(a, j, t, null)) {
+                                    top = s - 1;
+                                    qlock = 0;
+                                    t.doExec();
+                                }
+                                else
+                                    qlock = 0;
+                            }
+                            return true;
+                        }
+                        else if ((r = r.completer) == null)
+                            break;
+                    }
+                }
+            }
+            return false;
+        }
+
+        /**
+         * Internal version
+         */
+        final boolean internalPopAndExecCC(CountedCompleter<?> root) {
+            ForkJoinTask<?>[] a; int s; Object o; CountedCompleter<?> t, r;
+            if (base - (s = top) < 0 && (a = array) != null) {
+                long j = (((a.length - 1) & (s - 1)) << ASHIFT) + ABASE;
+                if ((o = U.getObject(a, j)) instanceof CountedCompleter) {
+                    for (t = (CountedCompleter<?>)o, r = t;;) {
+                        if (r == root) {
+                            if (U.compareAndSwapObject(a, j, t, null)) {
+                                top = s - 1;
+                                t.doExec();
+                            }
+                            return true;
+                        }
+                        else if ((r = r.completer) == null)
+                            break;
+                    }
+                }
+            }
+            return false;
+        }
+
+        /**
+         * Returns true if owned and not known to be blocked.
+         */
+        final boolean isApparentlyUnblocked() {
+            Thread wt; Thread.State s;
+            return (eventCount >= 0 &&
+                    (wt = owner) != null &&
+                    (s = wt.getState()) != Thread.State.BLOCKED &&
+                    s != Thread.State.WAITING &&
+                    s != Thread.State.TIMED_WAITING);
+        }
+
+        // Unsafe mechanics
+        private static final sun.misc.Unsafe U;
+        private static final long QBASE;
+        private static final long QLOCK;
+        private static final int ABASE;
+        private static final int ASHIFT;
+        static {
+            try {
+                U = getUnsafe();
+                Class<?> k = WorkQueue.class;
+                Class<?> ak = ForkJoinTask[].class;
+                QBASE = U.objectFieldOffset
+                        (k.getDeclaredField("base"));
+                QLOCK = U.objectFieldOffset
+                        (k.getDeclaredField("qlock"));
+                ABASE = U.arrayBaseOffset(ak);
+                int scale = U.arrayIndexScale(ak);
+                if ((scale & (scale - 1)) != 0)
+                    throw new Error("data type scale not a power of two");
+                ASHIFT = 31 - Integer.numberOfLeadingZeros(scale);
+            } catch (Exception e) {
+                throw new Error(e);
+            }
+        }
+    }
+
+    // static fields (initialized in static initializer below)
+
+    /**
+     * Per-thread submission bookkeeping. Shared across all pools
+     * to reduce ThreadLocal pollution and because random motion
+     * to avoid contention in one pool is likely to hold for others.
+     * Lazily initialized on first submission (but null-checked
+     * in other contexts to avoid unnecessary initialization).
+     */
+    static final ThreadLocal<Submitter> submitters;
+
+    /**
+     * Creates a new ForkJoinWorkerThread. This factory is used unless
+     * overridden in ForkJoinPool constructors.
+     */
+    public static final ForkJoinWorkerThreadFactory
+            defaultForkJoinWorkerThreadFactory;
+
+    /**
+     * Permission required for callers of methods that may start or
+     * kill threads.
+     */
+    private static final RuntimePermission modifyThreadPermission;
+
+    /**
+     * Common (static) pool. Non-null for public use unless a static
+     * construction exception, but internal usages null-check on use
+     * to paranoically avoid potential initialization circularities
+     * as well as to simplify generated code.
+     */
+    static final ForkJoinPool common;
+
+    /**
+     * Common pool parallelism. To allow simpler use and management
+     * when common pool threads are disabled, we allow the underlying
+     * common.parallelism field to be zero, but in that case still report
+     * parallelism as 1 to reflect resulting caller-runs mechanics.
+     */
+    static final int commonParallelism;
+
+    /**
+     * Sequence number for creating workerNamePrefix.
+     */
+    private static int poolNumberSequence;
+
+    /**
+     * Returns the next sequence number. We don't expect this to
+     * ever contend, so use simple builtin sync.
+     */
+    private static final synchronized int nextPoolId() {
+        return ++poolNumberSequence;
+    }
+
+    // static constants
+
+    /**
+     * Initial timeout value (in nanoseconds) for the thread
+     * triggering quiescence to park waiting for new work. On timeout,
+     * the thread will instead try to shrink the number of
+     * workers. The value should be large enough to avoid overly
+     * aggressive shrinkage during most transient stalls (long GCs
+     * etc).
+     */
+    private static final long IDLE_TIMEOUT      = 2000L * 1000L * 1000L; // 2sec
+
+    /**
+     * Timeout value when there are more threads than parallelism level
+     */
+    private static final long FAST_IDLE_TIMEOUT =  200L * 1000L * 1000L;
+
+    /**
+     * Tolerance for idle timeouts, to cope with timer undershoots
+     */
+    private static final long TIMEOUT_SLOP = 2000000L;
+
+    /**
+     * The maximum stolen->joining link depth allowed in method
+     * tryHelpStealer.  Must be a power of two.  Depths for legitimate
+     * chains are unbounded, but we use a fixed constant to avoid
+     * (otherwise unchecked) cycles and to bound staleness of
+     * traversal parameters at the expense of sometimes blocking when
+     * we could be helping.
+     */
+    private static final int MAX_HELP = 64;
+
+    /**
+     * Increment for seed generators. See class ThreadLocal for
+     * explanation.
+     */
+    private static final int SEED_INCREMENT = 0x61c88647;
+
+    /*
+     * Bits and masks for control variables
+     *
+     * Field ctl is a long packed with:
+     * AC: Number of active running workers minus target parallelism (16 bits)
+     * TC: Number of total workers minus target parallelism (16 bits)
+     * ST: true if pool is terminating (1 bit)
+     * EC: the wait count of top waiting thread (15 bits)
+     * ID: poolIndex of top of Treiber stack of waiters (16 bits)
+     *
+     * When convenient, we can extract the upper 32 bits of counts and
+     * the lower 32 bits of queue state, u = (int)(ctl >>> 32) and e =
+     * (int)ctl.  The ec field is never accessed alone, but always
+     * together with id and st. The offsets of counts by the target
+     * parallelism and the positionings of fields makes it possible to
+     * perform the most common checks via sign tests of fields: When
+     * ac is negative, there are not enough active workers, when tc is
+     * negative, there are not enough total workers, and when e is
+     * negative, the pool is terminating.  To deal with these possibly
+     * negative fields, we use casts in and out of "short" and/or
+     * signed shifts to maintain signedness.
+     *
+     * When a thread is queued (inactivated), its eventCount field is
+     * set negative, which is the only way to tell if a worker is
+     * prevented from executing tasks, even though it must continue to
+     * scan for them to avoid queuing races. Note however that
+     * eventCount updates lag releases so usage requires care.
+     *
+     * Field plock is an int packed with:
+     * SHUTDOWN: true if shutdown is enabled (1 bit)
+     * SEQ:  a sequence lock, with PL_LOCK bit set if locked (30 bits)
+     * SIGNAL: set when threads may be waiting on the lock (1 bit)
+     *
+     * The sequence number enables simple consistency checks:
+     * Staleness of read-only operations on the workQueues array can
+     * be checked by comparing plock before vs after the reads.
+     */
+
+    // bit positions/shifts for fields
+    private static final int  AC_SHIFT   = 48;
+    private static final int  TC_SHIFT   = 32;
+    private static final int  ST_SHIFT   = 31;
+    private static final int  EC_SHIFT   = 16;
+
+    // bounds
+    private static final int  SMASK      = 0xffff;  // short bits
+    private static final int  MAX_CAP    = 0x7fff;  // max #workers - 1
+    private static final int  EVENMASK   = 0xfffe;  // even short bits
+    private static final int  SQMASK     = 0x007e;  // max 64 (even) slots
+    private static final int  SHORT_SIGN = 1 << 15;
+    private static final int  INT_SIGN   = 1 << 31;
+
+    // masks
+    private static final long STOP_BIT   = 0x0001L << ST_SHIFT;
+    private static final long AC_MASK    = ((long)SMASK) << AC_SHIFT;
+    private static final long TC_MASK    = ((long)SMASK) << TC_SHIFT;
+
+    // units for incrementing and decrementing
+    private static final long TC_UNIT    = 1L << TC_SHIFT;
+    private static final long AC_UNIT    = 1L << AC_SHIFT;
+
+    // masks and units for dealing with u = (int)(ctl >>> 32)
+    private static final int  UAC_SHIFT  = AC_SHIFT - 32;
+    private static final int  UTC_SHIFT  = TC_SHIFT - 32;
+    private static final int  UAC_MASK   = SMASK << UAC_SHIFT;
+    private static final int  UTC_MASK   = SMASK << UTC_SHIFT;
+    private static final int  UAC_UNIT   = 1 << UAC_SHIFT;
+    private static final int  UTC_UNIT   = 1 << UTC_SHIFT;
+
+    // masks and units for dealing with e = (int)ctl
+    private static final int E_MASK      = 0x7fffffff; // no STOP_BIT
+    private static final int E_SEQ       = 1 << EC_SHIFT;
+
+    // plock bits
+    private static final int SHUTDOWN    = 1 << 31;
+    private static final int PL_LOCK     = 2;
+    private static final int PL_SIGNAL   = 1;
+    private static final int PL_SPINS    = 1 << 8;
+
+    // access mode for WorkQueue
+    static final int LIFO_QUEUE          =  0;
+    static final int FIFO_QUEUE          =  1;
+    static final int SHARED_QUEUE        = -1;
+
+    // Heuristic padding to ameliorate unfortunate memory placements
+    volatile long pad00, pad01, pad02, pad03, pad04, pad05, pad06;
+
+    // Instance fields
+    volatile long stealCount;                  // collects worker counts
+    volatile long ctl;                         // main pool control
+    volatile int plock;                        // shutdown status and seqLock
+    volatile int indexSeed;                    // worker/submitter index seed
+    final short parallelism;                   // parallelism level
+    final short mode;                          // LIFO/FIFO
+    WorkQueue[] workQueues;                    // main registry
+    final ForkJoinWorkerThreadFactory factory;
+    final UncaughtExceptionHandler ueh;        // per-worker UEH
+    final String workerNamePrefix;             // to create worker name string
+
+    volatile Object pad10, pad11, pad12, pad13, pad14, pad15, pad16, pad17;
+    volatile Object pad18, pad19, pad1a, pad1b;
+
+    /**
+     * Acquires the plock lock to protect worker array and related
+     * updates. This method is called only if an initial CAS on plock
+     * fails. This acts as a spinlock for normal cases, but falls back
+     * to builtin monitor to block when (rarely) needed. This would be
+     * a terrible idea for a highly contended lock, but works fine as
+     * a more conservative alternative to a pure spinlock.
+     */
+    private int acquirePlock() {
+        int spins = PL_SPINS, ps, nps;
+        for (;;) {
+            if (((ps = plock) & PL_LOCK) == 0 &&
+                    U.compareAndSwapInt(this, PLOCK, ps, nps = ps + PL_LOCK))
+                return nps;
+            else if (spins >= 0) {
+                if (ThreadLocalRandom.current().nextInt() >= 0)
+                    --spins;
+            }
+            else if (U.compareAndSwapInt(this, PLOCK, ps, ps | PL_SIGNAL)) {
+                synchronized (this) {
+                    if ((plock & PL_SIGNAL) != 0) {
+                        try {
+                            wait();
+                        } catch (InterruptedException ie) {
+                            try {
+                                Thread.currentThread().interrupt();
+                            } catch (SecurityException ignore) {
+                            }
+                        }
+                    }
+                    else
+                        notifyAll();
+                }
+            }
+        }
+    }
+
+    /**
+     * Unlocks and signals any thread waiting for plock. Called only
+     * when CAS of seq value for unlock fails.
+     */
+    private void releasePlock(int ps) {
+        plock = ps;
+        synchronized (this) { notifyAll(); }
+    }
+
+    /**
+     * Tries to create and start one worker if fewer than target
+     * parallelism level exist. Adjusts counts etc on failure.
+     */
+    private void tryAddWorker() {
+        long c; int u, e;
+        while ((u = (int)((c = ctl) >>> 32)) < 0 &&
+                (u & SHORT_SIGN) != 0 && (e = (int)c) >= 0) {
+            long nc = ((long)(((u + UTC_UNIT) & UTC_MASK) |
+                    ((u + UAC_UNIT) & UAC_MASK)) << 32) | (long)e;
+            if (U.compareAndSwapLong(this, CTL, c, nc)) {
+                ForkJoinWorkerThreadFactory fac;
+                Throwable ex = null;
+                ForkJoinWorkerThread wt = null;
+                try {
+                    if ((fac = factory) != null &&
+                            (wt = fac.newThread(this)) != null) {
+                        wt.start();
+                        break;
+                    }
+                } catch (Throwable rex) {
+                    ex = rex;
+                }
+                deregisterWorker(wt, ex);
+                break;
+            }
+        }
+    }
+
+    //  Registering and deregistering workers
+
+    /**
+     * Callback from ForkJoinWorkerThread to establish and record its
+     * WorkQueue. To avoid scanning bias due to packing entries in
+     * front of the workQueues array, we treat the array as a simple
+     * power-of-two hash table using per-thread seed as hash,
+     * expanding as needed.
+     *
+     * @param wt the worker thread
+     * @return the worker's queue
+     */
+    final WorkQueue registerWorker(ForkJoinWorkerThread wt) {
+        UncaughtExceptionHandler handler; WorkQueue[] ws; int s, ps;
+        wt.setDaemon(true);
+        if ((handler = ueh) != null)
+            wt.setUncaughtExceptionHandler(handler);
+        do {} while (!U.compareAndSwapInt(this, INDEXSEED, s = indexSeed,
+                s += SEED_INCREMENT) ||
+                s == 0); // skip 0
+        WorkQueue w = new WorkQueue(this, wt, mode, s);
+        if (((ps = plock) & PL_LOCK) != 0 ||
+                !U.compareAndSwapInt(this, PLOCK, ps, ps += PL_LOCK))
+            ps = acquirePlock();
+        int nps = (ps & SHUTDOWN) | ((ps + PL_LOCK) & ~SHUTDOWN);
+        try {
+            if ((ws = workQueues) != null) {    // skip if shutting down
+                int n = ws.length, m = n - 1;
+                int r = (s << 1) | 1;           // use odd-numbered indices
+                if (ws[r &= m] != null) {       // collision
+                    int probes = 0;             // step by approx half size
+                    int step = (n <= 4) ? 2 : ((n >>> 1) & EVENMASK) + 2;
+                    while (ws[r = (r + step) & m] != null) {
+                        if (++probes >= n) {
+                            workQueues = ws = Arrays.copyOf(ws, n <<= 1);
+                            m = n - 1;
+                            probes = 0;
+                        }
+                    }
+                }
+                w.poolIndex = (short)r;
+                w.eventCount = r; // volatile write orders
+                ws[r] = w;
+            }
+        } finally {
+            if (!U.compareAndSwapInt(this, PLOCK, ps, nps))
+                releasePlock(nps);
+        }
+        wt.setName(workerNamePrefix.concat(Integer.toString(w.poolIndex >>> 1)));
+        return w;
+    }
+
+    /**
+     * Final callback from terminating worker, as well as upon failure
+     * to construct or start a worker.  Removes record of worker from
+     * array, and adjusts counts. If pool is shutting down, tries to
+     * complete termination.
+     *
+     * @param wt the worker thread, or null if construction failed
+     * @param ex the exception causing failure, or null if none
+     */
+    final void deregisterWorker(ForkJoinWorkerThread wt, Throwable ex) {
+        WorkQueue w = null;
+        if (wt != null && (w = wt.workQueue) != null) {
+            int ps; long sc;
+            w.qlock = -1;                // ensure set
+            do {} while (!U.compareAndSwapLong(this, STEALCOUNT,
+                    sc = stealCount,
+                    sc + w.nsteals));
+            if (((ps = plock) & PL_LOCK) != 0 ||
+                    !U.compareAndSwapInt(this, PLOCK, ps, ps += PL_LOCK))
+                ps = acquirePlock();
+            int nps = (ps & SHUTDOWN) | ((ps + PL_LOCK) & ~SHUTDOWN);
+            try {
+                int idx = w.poolIndex;
+                WorkQueue[] ws = workQueues;
+                if (ws != null && idx >= 0 && idx < ws.length && ws[idx] == w)
+                    ws[idx] = null;
+            } finally {
+                if (!U.compareAndSwapInt(this, PLOCK, ps, nps))
+                    releasePlock(nps);
+            }
+        }
+
+        long c;                          // adjust ctl counts
+        do {} while (!U.compareAndSwapLong
+                (this, CTL, c = ctl, (((c - AC_UNIT) & AC_MASK) |
+                        ((c - TC_UNIT) & TC_MASK) |
+                        (c & ~(AC_MASK|TC_MASK)))));
+
+        if (!tryTerminate(false, false) && w != null && w.array != null) {
+            w.cancelAll();               // cancel remaining tasks
+            WorkQueue[] ws; WorkQueue v; Thread p; int u, i, e;
+            while ((u = (int)((c = ctl) >>> 32)) < 0 && (e = (int)c) >= 0) {
+                if (e > 0) {             // activate or create replacement
+                    if ((ws = workQueues) == null ||
+                            (i = e & SMASK) >= ws.length ||
+                            (v = ws[i]) == null)
+                        break;
+                    long nc = (((long)(v.nextWait & E_MASK)) |
+                            ((long)(u + UAC_UNIT) << 32));
+                    if (v.eventCount != (e | INT_SIGN))
+                        break;
+                    if (U.compareAndSwapLong(this, CTL, c, nc)) {
+                        v.eventCount = (e + E_SEQ) & E_MASK;
+                        if ((p = v.parker) != null)
+                            U.unpark(p);
+                        break;
+                    }
+                }
+                else {
+                    if ((short)u < 0)
+                        tryAddWorker();
+                    break;
+                }
+            }
+        }
+        if (ex == null)                     // help clean refs on way out
+            ForkJoinTask.helpExpungeStaleExceptions();
+        else                                // rethrow
+            ForkJoinTask.rethrow(ex);
+    }
+
+    // Submissions
+
+    /**
+     * Per-thread records for threads that submit to pools. Currently
+     * holds only pseudo-random seed / index that is used to choose
+     * submission queues in method externalPush. In the future, this may
+     * also incorporate a means to implement different task rejection
+     * and resubmission policies.
+     *
+     * Seeds for submitters and workers/workQueues work in basically
+     * the same way but are initialized and updated using slightly
+     * different mechanics. Both are initialized using the same
+     * approach as in class ThreadLocal, where successive values are
+     * unlikely to collide with previous values. Seeds are then
+     * randomly modified upon collisions using xorshifts, which
+     * requires a non-zero seed.
+     */
+    static final class Submitter {
+        int seed;
+        Submitter(int s) { seed = s; }
+    }
+
+    /**
+     * Unless shutting down, adds the given task to a submission queue
+     * at submitter's current queue index (modulo submission
+     * range). Only the most common path is directly handled in this
+     * method. All others are relayed to fullExternalPush.
+     *
+     * @param task the task. Caller must ensure non-null.
+     */
+    final void externalPush(ForkJoinTask<?> task) {
+        Submitter z = submitters.get();
+        WorkQueue q; int r, m, s, n, am; ForkJoinTask<?>[] a;
+        int ps = plock;
+        WorkQueue[] ws = workQueues;
+        if (z != null && ps > 0 && ws != null && (m = (ws.length - 1)) >= 0 &&
+                (q = ws[m & (r = z.seed) & SQMASK]) != null && r != 0 &&
+                U.compareAndSwapInt(q, QLOCK, 0, 1)) { // lock
+            if ((a = q.array) != null &&
+                    (am = a.length - 1) > (n = (s = q.top) - q.base)) {
+                int j = ((am & s) << ASHIFT) + ABASE;
+                U.putOrderedObject(a, j, task);
+                q.top = s + 1;                     // push on to deque
+                q.qlock = 0;
+                if (n <= 1)
+                    signalWork(ws, q);
+                return;
+            }
+            q.qlock = 0;
+        }
+        fullExternalPush(task);
+    }
+
+    /**
+     * Full version of externalPush. This method is called, among
+     * other times, upon the first submission of the first task to the
+     * pool, so must perform secondary initialization.  It also
+     * detects first submission by an external thread by looking up
+     * its ThreadLocal, and creates a new shared queue if the one at
+     * index if empty or contended. The plock lock body must be
+     * exception-free (so no try/finally) so we optimistically
+     * allocate new queues outside the lock and throw them away if
+     * (very rarely) not needed.
+     *
+     * Secondary initialization occurs when plock is zero, to create
+     * workQueue array and set plock to a valid value.  This lock body
+     * must also be exception-free. Because the plock seq value can
+     * eventually wrap around zero, this method harmlessly fails to
+     * reinitialize if workQueues exists, while still advancing plock.
+     */
+    private void fullExternalPush(ForkJoinTask<?> task) {
+        int r = 0; // random index seed
+        for (Submitter z = submitters.get();;) {
+            WorkQueue[] ws; WorkQueue q; int ps, m, k;
+            if (z == null) {
+                if (U.compareAndSwapInt(this, INDEXSEED, r = indexSeed,
+                        r += SEED_INCREMENT) && r != 0)
+                    submitters.set(z = new Submitter(r));
+            }
+            else if (r == 0) {                  // move to a different index
+                r = z.seed;
+                r ^= r << 13;                   // same xorshift as WorkQueues
+                r ^= r >>> 17;
+                z.seed = r ^= (r << 5);
+            }
+            if ((ps = plock) < 0)
+                throw new RejectedExecutionException();
+            else if (ps == 0 || (ws = workQueues) == null ||
+                    (m = ws.length - 1) < 0) { // initialize workQueues
+                int p = parallelism;            // find power of two table size
+                int n = (p > 1) ? p - 1 : 1;    // ensure at least 2 slots
+                n |= n >>> 1; n |= n >>> 2;  n |= n >>> 4;
+                n |= n >>> 8; n |= n >>> 16; n = (n + 1) << 1;
+                WorkQueue[] nws = ((ws = workQueues) == null || ws.length == 0 ?
+                        new WorkQueue[n] : null);
+                if (((ps = plock) & PL_LOCK) != 0 ||
+                        !U.compareAndSwapInt(this, PLOCK, ps, ps += PL_LOCK))
+                    ps = acquirePlock();
+                if (((ws = workQueues) == null || ws.length == 0) && nws != null)
+                    workQueues = nws;
+                int nps = (ps & SHUTDOWN) | ((ps + PL_LOCK) & ~SHUTDOWN);
+                if (!U.compareAndSwapInt(this, PLOCK, ps, nps))
+                    releasePlock(nps);
+            }
+            else if ((q = ws[k = r & m & SQMASK]) != null) {
+                if (q.qlock == 0 && U.compareAndSwapInt(q, QLOCK, 0, 1)) {
+                    ForkJoinTask<?>[] a = q.array;
+                    int s = q.top;
+                    boolean submitted = false;
+                    try {                      // locked version of push
+                        if ((a != null && a.length > s + 1 - q.base) ||
+                                (a = q.growArray()) != null) {   // must presize
+                            int j = (((a.length - 1) & s) << ASHIFT) + ABASE;
+                            U.putOrderedObject(a, j, task);
+                            q.top = s + 1;
+                            submitted = true;
+                        }
+                    } finally {
+                        q.qlock = 0;  // unlock
+                    }
+                    if (submitted) {
+                        signalWork(ws, q);
+                        return;
+                    }
+                }
+                r = 0; // move on failure
+            }
+            else if (((ps = plock) & PL_LOCK) == 0) { // create new queue
+                q = new WorkQueue(this, null, SHARED_QUEUE, r);
+                q.poolIndex = (short)k;
+                if (((ps = plock) & PL_LOCK) != 0 ||
+                        !U.compareAndSwapInt(this, PLOCK, ps, ps += PL_LOCK))
+                    ps = acquirePlock();
+                if ((ws = workQueues) != null && k < ws.length && ws[k] == null)
+                    ws[k] = q;
+                int nps = (ps & SHUTDOWN) | ((ps + PL_LOCK) & ~SHUTDOWN);
+                if (!U.compareAndSwapInt(this, PLOCK, ps, nps))
+                    releasePlock(nps);
+            }
+            else
+                r = 0;
+        }
+    }
+
+    // Maintaining ctl counts
+
+    /**
+     * Increments active count; mainly called upon return from blocking.
+     */
+    final void incrementActiveCount() {
+        long c;
+        do {} while (!U.compareAndSwapLong
+                (this, CTL, c = ctl, ((c & ~AC_MASK) |
+                        ((c & AC_MASK) + AC_UNIT))));
+    }
+
+    /**
+     * Tries to create or activate a worker if too few are active.
+     *
+     * @param ws the worker array to use to find signallees
+     * @param q if non-null, the queue holding tasks to be processed
+     */
+    final void signalWork(WorkQueue[] ws, WorkQueue q) {
+        for (;;) {
+            long c; int e, u, i; WorkQueue w; Thread p;
+            if ((u = (int)((c = ctl) >>> 32)) >= 0)
+                break;
+            if ((e = (int)c) <= 0) {
+                if ((short)u < 0)
+                    tryAddWorker();
+                break;
+            }
+            if (ws == null || ws.length <= (i = e & SMASK) ||
+                    (w = ws[i]) == null)
+                break;
+            long nc = (((long)(w.nextWait & E_MASK)) |
+                    ((long)(u + UAC_UNIT)) << 32);
+            int ne = (e + E_SEQ) & E_MASK;
+            if (w.eventCount == (e | INT_SIGN) &&
+                    U.compareAndSwapLong(this, CTL, c, nc)) {
+                w.eventCount = ne;
+                if ((p = w.parker) != null)
+                    U.unpark(p);
+                break;
+            }
+            if (q != null && q.base >= q.top)
+                break;
+        }
+    }
+
+    // Scanning for tasks
+
+    /**
+     * Top-level runloop for workers, called by ForkJoinWorkerThread.run.
+     */
+    final void runWorker(WorkQueue w) {
+        w.growArray(); // allocate queue
+        for (int r = w.hint; scan(w, r) == 0; ) {
+            r ^= r << 13; r ^= r >>> 17; r ^= r << 5; // xorshift
+        }
+    }
+
+    /**
+     * Scans for and, if found, runs one task, else possibly
+     * inactivates the worker. This method operates on single reads of
+     * volatile state and is designed to be re-invoked continuously,
+     * in part because it returns upon detecting inconsistencies,
+     * contention, or state changes that indicate possible success on
+     * re-invocation.
+     *
+     * The scan searches for tasks across queues starting at a random
+     * index, checking each at least twice.  The scan terminates upon
+     * either finding a non-empty queue, or completing the sweep. If
+     * the worker is not inactivated, it takes and runs a task from
+     * this queue. Otherwise, if not activated, it tries to activate
+     * itself or some other worker by signalling. On failure to find a
+     * task, returns (for retry) if pool state may have changed during
+     * an empty scan, or tries to inactivate if active, else possibly
+     * blocks or terminates via method awaitWork.
+     *
+     * @param w the worker (via its WorkQueue)
+     * @param r a random seed
+     * @return worker qlock status if would have waited, else 0
+     */
+    private final int scan(WorkQueue w, int r) {
+        WorkQueue[] ws; int m;
+        long c = ctl;                            // for consistency check
+        if ((ws = workQueues) != null && (m = ws.length - 1) >= 0 && w != null) {
+            for (int j = m + m + 1, ec = w.eventCount;;) {
+                WorkQueue q; int b, e; ForkJoinTask<?>[] a; ForkJoinTask<?> t;
+                if ((q = ws[(r - j) & m]) != null &&
+                        (b = q.base) - q.top < 0 && (a = q.array) != null) {
+                    long i = (((a.length - 1) & b) << ASHIFT) + ABASE;
+                    if ((t = ((ForkJoinTask<?>)
+                            U.getObjectVolatile(a, i))) != null) {
+                        if (ec < 0)
+                            helpRelease(c, ws, w, q, b);
+                        else if (q.base == b &&
+                                U.compareAndSwapObject(a, i, t, null)) {
+                            U.putOrderedInt(q, QBASE, b + 1);
+                            if ((b + 1) - q.top < 0)
+                                signalWork(ws, q);
+                            w.runTask(t);
+                        }
+                    }
+                    break;
+                }
+                else if (--j < 0) {
+                    if ((ec | (e = (int)c)) < 0) // inactive or terminating
+                        return awaitWork(w, c, ec);
+                    else if (ctl == c) {         // try to inactivate and enqueue
+                        long nc = (long)ec | ((c - AC_UNIT) & (AC_MASK|TC_MASK));
+                        w.nextWait = e;
+                        w.eventCount = ec | INT_SIGN;
+                        if (!U.compareAndSwapLong(this, CTL, c, nc))
+                            w.eventCount = ec;   // back out
+                    }
+                    break;
+                }
+            }
+        }
+        return 0;
+    }
+
+    /**
+     * A continuation of scan(), possibly blocking or terminating
+     * worker w. Returns without blocking if pool state has apparently
+     * changed since last invocation.  Also, if inactivating w has
+     * caused the pool to become quiescent, checks for pool
+     * termination, and, so long as this is not the only worker, waits
+     * for event for up to a given duration.  On timeout, if ctl has
+     * not changed, terminates the worker, which will in turn wake up
+     * another worker to possibly repeat this process.
+     *
+     * @param w the calling worker
+     * @param c the ctl value on entry to scan
+     * @param ec the worker's eventCount on entry to scan
+     */
+    private final int awaitWork(WorkQueue w, long c, int ec) {
+        int stat, ns; long parkTime, deadline;
+        if ((stat = w.qlock) >= 0 && w.eventCount == ec && ctl == c &&
+                !Thread.interrupted()) {
+            int e = (int)c;
+            int u = (int)(c >>> 32);
+            int d = (u >> UAC_SHIFT) + parallelism; // active count
+
+            if (e < 0 || (d <= 0 && tryTerminate(false, false)))
+                stat = w.qlock = -1;          // pool is terminating
+            else if ((ns = w.nsteals) != 0) { // collect steals and retry
+                long sc;
+                w.nsteals = 0;
+                do {} while (!U.compareAndSwapLong(this, STEALCOUNT,
+                        sc = stealCount, sc + ns));
+            }
+            else {
+                long pc = ((d > 0 || ec != (e | INT_SIGN)) ? 0L :
+                        ((long)(w.nextWait & E_MASK)) | // ctl to restore
+                                ((long)(u + UAC_UNIT)) << 32);
+                if (pc != 0L) {               // timed wait if last waiter
+                    int dc = -(short)(c >>> TC_SHIFT);
+                    parkTime = (dc < 0 ? FAST_IDLE_TIMEOUT:
+                            (dc + 1) * IDLE_TIMEOUT);
+                    deadline = System.nanoTime() + parkTime - TIMEOUT_SLOP;
+                }
+                else
+                    parkTime = deadline = 0L;
+                if (w.eventCount == ec && ctl == c) {
+                    Thread wt = Thread.currentThread();
+                    U.putObject(wt, PARKBLOCKER, this);
+                    w.parker = wt;            // emulate LockSupport.park
+                    if (w.eventCount == ec && ctl == c)
+                        U.park(false, parkTime);  // must recheck before park
+                    w.parker = null;
+                    U.putObject(wt, PARKBLOCKER, null);
+                    if (parkTime != 0L && ctl == c &&
+                            deadline - System.nanoTime() <= 0L &&
+                            U.compareAndSwapLong(this, CTL, c, pc))
+                        stat = w.qlock = -1;  // shrink pool
+                }
+            }
+        }
+        return stat;
+    }
+
+    /**
+     * Possibly releases (signals) a worker. Called only from scan()
+     * when a worker with apparently inactive status finds a non-empty
+     * queue. This requires revalidating all of the associated state
+     * from caller.
+     */
+    private final void helpRelease(long c, WorkQueue[] ws, WorkQueue w,
+                                   WorkQueue q, int b) {
+        WorkQueue v; int e, i; Thread p;
+        if (w != null && w.eventCount < 0 && (e = (int)c) > 0 &&
+                ws != null && ws.length > (i = e & SMASK) &&
+                (v = ws[i]) != null && ctl == c) {
+            long nc = (((long)(v.nextWait & E_MASK)) |
+                    ((long)((int)(c >>> 32) + UAC_UNIT)) << 32);
+            int ne = (e + E_SEQ) & E_MASK;
+            if (q != null && q.base == b && w.eventCount < 0 &&
+                    v.eventCount == (e | INT_SIGN) &&
+                    U.compareAndSwapLong(this, CTL, c, nc)) {
+                v.eventCount = ne;
+                if ((p = v.parker) != null)
+                    U.unpark(p);
+            }
+        }
+    }
+
+    /**
+     * Tries to locate and execute tasks for a stealer of the given
+     * task, or in turn one of its stealers, Traces currentSteal ->
+     * currentJoin links looking for a thread working on a descendant
+     * of the given task and with a non-empty queue to steal back and
+     * execute tasks from. The first call to this method upon a
+     * waiting join will often entail scanning/search, (which is OK
+     * because the joiner has nothing better to do), but this method
+     * leaves hints in workers to speed up subsequent calls. The
+     * implementation is very branchy to cope with potential
+     * inconsistencies or loops encountering chains that are stale,
+     * unknown, or so long that they are likely cyclic.
+     *
+     * @param joiner the joining worker
+     * @param task the task to join
+     * @return 0 if no progress can be made, negative if task
+     * known complete, else positive
+     */
+    private int tryHelpStealer(WorkQueue joiner, ForkJoinTask<?> task) {
+        int stat = 0, steps = 0;                    // bound to avoid cycles
+        if (task != null && joiner != null &&
+                joiner.base - joiner.top >= 0) {        // hoist checks
+            restart: for (;;) {
+                ForkJoinTask<?> subtask = task;     // current target
+                for (WorkQueue j = joiner, v;;) {   // v is stealer of subtask
+                    WorkQueue[] ws; int m, s, h;
+                    if ((s = task.status) < 0) {
+                        stat = s;
+                        break restart;
+                    }
+                    if ((ws = workQueues) == null || (m = ws.length - 1) <= 0)
+                        break restart;              // shutting down
+                    if ((v = ws[h = (j.hint | 1) & m]) == null ||
+                            v.currentSteal != subtask) {
+                        for (int origin = h;;) {    // find stealer
+                            if (((h = (h + 2) & m) & 15) == 1 &&
+                                    (subtask.status < 0 || j.currentJoin != subtask))
+                                continue restart;   // occasional staleness check
+                            if ((v = ws[h]) != null &&
+                                    v.currentSteal == subtask) {
+                                j.hint = h;        // save hint
+                                break;
+                            }
+                            if (h == origin)
+                                break restart;      // cannot find stealer
+                        }
+                    }
+                    for (;;) { // help stealer or descend to its stealer
+                        ForkJoinTask[] a; int b;
+                        if (subtask.status < 0)     // surround probes with
+                            continue restart;       //   consistency checks
+                        if ((b = v.base) - v.top < 0 && (a = v.array) != null) {
+                            int i = (((a.length - 1) & b) << ASHIFT) + ABASE;
+                            ForkJoinTask<?> t =
+                                    (ForkJoinTask<?>)U.getObjectVolatile(a, i);
+                            if (subtask.status < 0 || j.currentJoin != subtask ||
+                                    v.currentSteal != subtask)
+                                continue restart;   // stale
+                            stat = 1;               // apparent progress
+                            if (v.base == b) {
+                                if (t == null)
+                                    break restart;
+                                if (U.compareAndSwapObject(a, i, t, null)) {
+                                    U.putOrderedInt(v, QBASE, b + 1);
+                                    ForkJoinTask<?> ps = joiner.currentSteal;
+                                    int jt = joiner.top;
+                                    do {
+                                        joiner.currentSteal = t;
+                                        t.doExec(); // clear local tasks too
+                                    } while (task.status >= 0 &&
+                                            joiner.top != jt &&
+                                            (t = joiner.pop()) != null);
+                                    joiner.currentSteal = ps;
+                                    break restart;
+                                }
+                            }
+                        }
+                        else {                      // empty -- try to descend
+                            ForkJoinTask<?> next = v.currentJoin;
+                            if (subtask.status < 0 || j.currentJoin != subtask ||
+                                    v.currentSteal != subtask)
+                                continue restart;   // stale
+                            else if (next == null || ++steps == MAX_HELP)
+                                break restart;      // dead-end or maybe cyclic
+                            else {
+                                subtask = next;
+                                j = v;
+                                break;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        return stat;
+    }
+
+    /**
+     * Analog of tryHelpStealer for CountedCompleters. Tries to steal
+     * and run tasks within the target's computation.
+     *
+     * @param task the task to join
+     */
+    private int helpComplete(WorkQueue joiner, CountedCompleter<?> task) {
+        WorkQueue[] ws; int m;
+        int s = 0;
+        if ((ws = workQueues) != null && (m = ws.length - 1) >= 0 &&
+                joiner != null && task != null) {
+            int j = joiner.poolIndex;
+            int scans = m + m + 1;
+            long c = 0L;              // for stability check
+            for (int k = scans; ; j += 2) {
+                WorkQueue q;
+                if ((s = task.status) < 0)
+                    break;
+                else if (joiner.internalPopAndExecCC(task))
+                    k = scans;
+                else if ((s = task.status) < 0)
+                    break;
+                else if ((q = ws[j & m]) != null && q.pollAndExecCC(task))
+                    k = scans;
+                else if (--k < 0) {
+                    if (c == (c = ctl))
+                        break;
+                    k = scans;
+                }
+            }
+        }
+        return s;
+    }
+
+    /**
+     * Tries to decrement active count (sometimes implicitly) and
+     * possibly release or create a compensating worker in preparation
+     * for blocking. Fails on contention or termination. Otherwise,
+     * adds a new thread if no idle workers are available and pool
+     * may become starved.
+     *
+     * @param c the assumed ctl value
+     */
+    final boolean tryCompensate(long c) {
+        WorkQueue[] ws = workQueues;
+        int pc = parallelism, e = (int)c, m, tc;
+        if (ws != null && (m = ws.length - 1) >= 0 && e >= 0 && ctl == c) {
+            WorkQueue w = ws[e & m];
+            if (e != 0 && w != null) {
+                Thread p;
+                long nc = ((long)(w.nextWait & E_MASK) |
+                        (c & (AC_MASK|TC_MASK)));
+                int ne = (e + E_SEQ) & E_MASK;
+                if (w.eventCount == (e | INT_SIGN) &&
+                        U.compareAndSwapLong(this, CTL, c, nc)) {
+                    w.eventCount = ne;
+                    if ((p = w.parker) != null)
+                        U.unpark(p);
+                    return true;   // replace with idle worker
+                }
+            }
+            else if ((tc = (short)(c >>> TC_SHIFT)) >= 0 &&
+                    (int)(c >> AC_SHIFT) + pc > 1) {
+                long nc = ((c - AC_UNIT) & AC_MASK) | (c & ~AC_MASK);
+                if (U.compareAndSwapLong(this, CTL, c, nc))
+                    return true;   // no compensation
+            }
+            else if (tc + pc < MAX_CAP) {
+                long nc = ((c + TC_UNIT) & TC_MASK) | (c & ~TC_MASK);
+                if (U.compareAndSwapLong(this, CTL, c, nc)) {
+                    ForkJoinWorkerThreadFactory fac;
+                    Throwable ex = null;
+                    ForkJoinWorkerThread wt = null;
+                    try {
+                        if ((fac = factory) != null &&
+                                (wt = fac.newThread(this)) != null) {
+                            wt.start();
+                            return true;
+                        }
+                    } catch (Throwable rex) {
+                        ex = rex;
+                    }
+                    deregisterWorker(wt, ex); // clean up and return false
+                }
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Helps and/or blocks until the given task is done.
+     *
+     * @param joiner the joining worker
+     * @param task the task
+     * @return task status on exit
+     */
+    final int awaitJoin(WorkQueue joiner, ForkJoinTask<?> task) {
+        int s = 0;
+        if (task != null && (s = task.status) >= 0 && joiner != null) {
+            ForkJoinTask<?> prevJoin = joiner.currentJoin;
+            joiner.currentJoin = task;
+            do {} while (joiner.tryRemoveAndExec(task) && // process local tasks
+                    (s = task.status) >= 0);
+            if (s >= 0 && (task instanceof CountedCompleter))
+                s = helpComplete(joiner, (CountedCompleter<?>)task);
+            long cc = 0;        // for stability checks
+            while (s >= 0 && (s = task.status) >= 0) {
+                if ((s = tryHelpStealer(joiner, task)) == 0 &&
+                        (s = task.status) >= 0) {
+                    if (!tryCompensate(cc))
+                        cc = ctl;
+                    else {
+                        if (task.trySetSignal() && (s = task.status) >= 0) {
+                            synchronized (task) {
+                                if (task.status >= 0) {
+                                    try {                // see ForkJoinTask
+                                        task.wait();     //  for explanation
+                                    } catch (InterruptedException ie) {
+                                    }
+                                }
+                                else
+                                    task.notifyAll();
+                            }
+                        }
+                        long c; // reactivate
+                        do {} while (!U.compareAndSwapLong
+                                (this, CTL, c = ctl,
+                                        ((c & ~AC_MASK) |
+                                                ((c & AC_MASK) + AC_UNIT))));
+                    }
+                }
+            }
+            joiner.currentJoin = prevJoin;
+        }
+        return s;
+    }
+
+    /**
+     * Stripped-down variant of awaitJoin used by timed joins. Tries
+     * to help join only while there is continuous progress. (Caller
+     * will then enter a timed wait.)
+     *
+     * @param joiner the joining worker
+     * @param task the task
+     */
+    final void helpJoinOnce(WorkQueue joiner, ForkJoinTask<?> task) {
+        int s;
+        if (joiner != null && task != null && (s = task.status) >= 0) {
+            ForkJoinTask<?> prevJoin = joiner.currentJoin;
+            joiner.currentJoin = task;
+            do {} while (joiner.tryRemoveAndExec(task) && // process local tasks
+                    (s = task.status) >= 0);
+            if (s >= 0) {
+                if (task instanceof CountedCompleter)
+                    helpComplete(joiner, (CountedCompleter<?>)task);
+                do {} while (task.status >= 0 &&
+                        tryHelpStealer(joiner, task) > 0);
+            }
+            joiner.currentJoin = prevJoin;
+        }
+    }
+
+    /**
+     * Returns a (probably) non-empty steal queue, if one is found
+     * during a scan, else null.  This method must be retried by
+     * caller if, by the time it tries to use the queue, it is empty.
+     */
+    private WorkQueue findNonEmptyStealQueue() {
+        int r = ThreadLocalRandom.current().nextInt();
+        for (;;) {
+            int ps = plock, m; WorkQueue[] ws; WorkQueue q;
+            if ((ws = workQueues) != null && (m = ws.length - 1) >= 0) {
+                for (int j = (m + 1) << 2; j >= 0; --j) {
+                    if ((q = ws[(((r - j) << 1) | 1) & m]) != null &&
+                            q.base - q.top < 0)
+                        return q;
+                }
+            }
+            if (plock == ps)
+                return null;
+        }
+    }
+
+    /**
+     * Runs tasks until {@code isQuiescent()}. We piggyback on
+     * active count ctl maintenance, but rather than blocking
+     * when tasks cannot be found, we rescan until all others cannot
+     * find tasks either.
+     */
+    final void helpQuiescePool(WorkQueue w) {
+        ForkJoinTask<?> ps = w.currentSteal;
+        for (boolean active = true;;) {
+            long c; WorkQueue q; ForkJoinTask<?> t; int b;
+            while ((t = w.nextLocalTask()) != null)
+                t.doExec();
+            if ((q = findNonEmptyStealQueue()) != null) {
+                if (!active) {      // re-establish active count
+                    active = true;
+                    do {} while (!U.compareAndSwapLong
+                            (this, CTL, c = ctl,
+                                    ((c & ~AC_MASK) |
+                                            ((c & AC_MASK) + AC_UNIT))));
+                }
+                if ((b = q.base) - q.top < 0 && (t = q.pollAt(b)) != null) {
+                    (w.currentSteal = t).doExec();
+                    w.currentSteal = ps;
+                }
+            }
+            else if (active) {       // decrement active count without queuing
+                long nc = ((c = ctl) & ~AC_MASK) | ((c & AC_MASK) - AC_UNIT);
+                if ((int)(nc >> AC_SHIFT) + parallelism == 0)
+                    break;          // bypass decrement-then-increment
+                if (U.compareAndSwapLong(this, CTL, c, nc))
+                    active = false;
+            }
+            else if ((int)((c = ctl) >> AC_SHIFT) + parallelism <= 0 &&
+                    U.compareAndSwapLong
+                            (this, CTL, c, ((c & ~AC_MASK) |
+                                    ((c & AC_MASK) + AC_UNIT))))
+                break;
+        }
+    }
+
+    /**
+     * Gets and removes a local or stolen task for the given worker.
+     *
+     * @return a task, if available
+     */
+    final ForkJoinTask<?> nextTaskFor(WorkQueue w) {
+        for (ForkJoinTask<?> t;;) {
+            WorkQueue q; int b;
+            if ((t = w.nextLocalTask()) != null)
+                return t;
+            if ((q = findNonEmptyStealQueue()) == null)
+                return null;
+            if ((b = q.base) - q.top < 0 && (t = q.pollAt(b)) != null)
+                return t;
+        }
+    }
+
+    /**
+     * Returns a cheap heuristic guide for task partitioning when
+     * programmers, frameworks, tools, or languages have little or no
+     * idea about task granularity.  In essence by offering this
+     * method, we ask users only about tradeoffs in overhead vs
+     * expected throughput and its variance, rather than how finely to
+     * partition tasks.
+     *
+     * In a steady state strict (tree-structured) computation, each
+     * thread makes available for stealing enough tasks for other
+     * threads to remain active. Inductively, if all threads play by
+     * the same rules, each thread should make available only a
+     * constant number of tasks.
+     *
+     * The minimum useful constant is just 1. But using a value of 1
+     * would require immediate replenishment upon each steal to
+     * maintain enough tasks, which is infeasible.  Further,
+     * partitionings/granularities of offered tasks should minimize
+     * steal rates, which in general means that threads nearer the top
+     * of computation tree should generate more than those nearer the
+     * bottom. In perfect steady state, each thread is at
+     * approximately the same level of computation tree. However,
+     * producing extra tasks amortizes the uncertainty of progress and
+     * diffusion assumptions.
+     *
+     * So, users will want to use values larger (but not much larger)
+     * than 1 to both smooth over transient shortages and hedge
+     * against uneven progress; as traded off against the cost of
+     * extra task overhead. We leave the user to pick a threshold
+     * value to compare with the results of this call to guide
+     * decisions, but recommend values such as 3.
+     *
+     * When all threads are active, it is on average OK to estimate
+     * surplus strictly locally. In steady-state, if one thread is
+     * maintaining say 2 surplus tasks, then so are others. So we can
+     * just use estimated queue length.  However, this strategy alone
+     * leads to serious mis-estimates in some non-steady-state
+     * conditions (ramp-up, ramp-down, other stalls). We can detect
+     * many of these by further considering the number of "idle"
+     * threads, that are known to have zero queued tasks, so
+     * compensate by a factor of (#idle/#active) threads.
+     *
+     * Note: The approximation of #busy workers as #active workers is
+     * not very good under current signalling scheme, and should be
+     * improved.
+     */
+    static int getSurplusQueuedTaskCount() {
+        Thread t; ForkJoinWorkerThread wt; ForkJoinPool pool; WorkQueue q;
+        if (((t = Thread.currentThread()) instanceof ForkJoinWorkerThread)) {
+            int p = (pool = (wt = (ForkJoinWorkerThread)t).pool).parallelism;
+            int n = (q = wt.workQueue).top - q.base;
+            int a = (int)(pool.ctl >> AC_SHIFT) + p;
+            return n - (a > (p >>>= 1) ? 0 :
+                    a > (p >>>= 1) ? 1 :
+                            a > (p >>>= 1) ? 2 :
+                                    a > (p >>>= 1) ? 4 :
+                                            8);
+        }
+        return 0;
+    }
+
+    //  Termination
+
+    /**
+     * Possibly initiates and/or completes termination.  The caller
+     * triggering termination runs three passes through workQueues:
+     * (0) Setting termination status, followed by wakeups of queued
+     * workers; (1) cancelling all tasks; (2) interrupting lagging
+     * threads (likely in external tasks, but possibly also blocked in
+     * joins).  Each pass repeats previous steps because of potential
+     * lagging thread creation.
+     *
+     * @param now if true, unconditionally terminate, else only
+     * if no work and no active workers
+     * @param enable if true, enable shutdown when next possible
+     * @return true if now terminating or terminated
+     */
+    private boolean tryTerminate(boolean now, boolean enable) {
+        int ps;
+        if (this == common)                        // cannot shut down
+            return false;
+        if ((ps = plock) >= 0) {                   // enable by setting plock
+            if (!enable)
+                return false;
+            if ((ps & PL_LOCK) != 0 ||
+                    !U.compareAndSwapInt(this, PLOCK, ps, ps += PL_LOCK))
+                ps = acquirePlock();
+            int nps = ((ps + PL_LOCK) & ~SHUTDOWN) | SHUTDOWN;
+            if (!U.compareAndSwapInt(this, PLOCK, ps, nps))
+                releasePlock(nps);
+        }
+        for (long c;;) {
+            if (((c = ctl) & STOP_BIT) != 0) {     // already terminating
+                if ((short)(c >>> TC_SHIFT) + parallelism <= 0) {
+                    synchronized (this) {
+                        notifyAll();               // signal when 0 workers
+                    }
+                }
+                return true;
+            }
+            if (!now) {                            // check if idle & no tasks
+                WorkQueue[] ws; WorkQueue w;
+                if ((int)(c >> AC_SHIFT) + parallelism > 0)
+                    return false;
+                if ((ws = workQueues) != null) {
+                    for (int i = 0; i < ws.length; ++i) {
+                        if ((w = ws[i]) != null &&
+                                (!w.isEmpty() ||
+                                        ((i & 1) != 0 && w.eventCount >= 0))) {
+                            signalWork(ws, w);
+                            return false;
+                        }
+                    }
+                }
+            }
+            if (U.compareAndSwapLong(this, CTL, c, c | STOP_BIT)) {
+                for (int pass = 0; pass < 3; ++pass) {
+                    WorkQueue[] ws; WorkQueue w; Thread wt;
+                    if ((ws = workQueues) != null) {
+                        int n = ws.length;
+                        for (int i = 0; i < n; ++i) {
+                            if ((w = ws[i]) != null) {
+                                w.qlock = -1;
+                                if (pass > 0) {
+                                    w.cancelAll();
+                                    if (pass > 1 && (wt = w.owner) != null) {
+                                        if (!wt.isInterrupted()) {
+                                            try {
+                                                wt.interrupt();
+                                            } catch (Throwable ignore) {
+                                            }
+                                        }
+                                        U.unpark(wt);
+                                    }
+                                }
+                            }
+                        }
+                        // Wake up workers parked on event queue
+                        int i, e; long cc; Thread p;
+                        while ((e = (int)(cc = ctl) & E_MASK) != 0 &&
+                                (i = e & SMASK) < n && i >= 0 &&
+                                (w = ws[i]) != null) {
+                            long nc = ((long)(w.nextWait & E_MASK) |
+                                    ((cc + AC_UNIT) & AC_MASK) |
+                                    (cc & (TC_MASK|STOP_BIT)));
+                            if (w.eventCount == (e | INT_SIGN) &&
+                                    U.compareAndSwapLong(this, CTL, cc, nc)) {
+                                w.eventCount = (e + E_SEQ) & E_MASK;
+                                w.qlock = -1;
+                                if ((p = w.parker) != null)
+                                    U.unpark(p);
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    // external operations on common pool
+
+    /**
+     * Returns common pool queue for a thread that has submitted at
+     * least one task.
+     */
+    static WorkQueue commonSubmitterQueue() {
+        Submitter z; ForkJoinPool p; WorkQueue[] ws; int m, r;
+        return ((z = submitters.get()) != null &&
+                (p = common) != null &&
+                (ws = p.workQueues) != null &&
+                (m = ws.length - 1) >= 0) ?
+                ws[m & z.seed & SQMASK] : null;
+    }
+
+    /**
+     * Tries to pop the given task from submitter's queue in common pool.
+     */
+    final boolean tryExternalUnpush(ForkJoinTask<?> task) {
+        WorkQueue joiner; ForkJoinTask<?>[] a; int m, s;
+        Submitter z = submitters.get();
+        WorkQueue[] ws = workQueues;
+        boolean popped = false;
+        if (z != null && ws != null && (m = ws.length - 1) >= 0 &&
+                (joiner = ws[z.seed & m & SQMASK]) != null &&
+                joiner.base != (s = joiner.top) &&
+                (a = joiner.array) != null) {
+            long j = (((a.length - 1) & (s - 1)) << ASHIFT) + ABASE;
+            if (U.getObject(a, j) == task &&
+                    U.compareAndSwapInt(joiner, QLOCK, 0, 1)) {
+                if (joiner.top == s && joiner.array == a &&
+                        U.compareAndSwapObject(a, j, task, null)) {
+                    joiner.top = s - 1;
+                    popped = true;
+                }
+                joiner.qlock = 0;
+            }
+        }
+        return popped;
+    }
+
+    final int externalHelpComplete(CountedCompleter<?> task) {
+        WorkQueue joiner; int m, j;
+        Submitter z = submitters.get();
+        WorkQueue[] ws = workQueues;
+        int s = 0;
+        if (z != null && ws != null && (m = ws.length - 1) >= 0 &&
+                (joiner = ws[(j = z.seed) & m & SQMASK]) != null && task != null) {
+            int scans = m + m + 1;
+            long c = 0L;             // for stability check
+            j |= 1;                  // poll odd queues
+            for (int k = scans; ; j += 2) {
+                WorkQueue q;
+                if ((s = task.status) < 0)
+                    break;
+                else if (joiner.externalPopAndExecCC(task))
+                    k = scans;
+                else if ((s = task.status) < 0)
+                    break;
+                else if ((q = ws[j & m]) != null && q.pollAndExecCC(task))
+                    k = scans;
+                else if (--k < 0) {
+                    if (c == (c = ctl))
+                        break;
+                    k = scans;
+                }
+            }
+        }
+        return s;
+    }
+
+    // Exported methods
+
+    // Constructors
+
+    /**
+     * Creates a {@code ForkJoinPool} with parallelism equal to {@link
+     * java.lang.Runtime#availableProcessors}, using the {@linkplain
+     * #defaultForkJoinWorkerThreadFactory default thread factory},
+     * no UncaughtExceptionHandler, and non-async LIFO processing mode.
+     *
+     * @throws SecurityException if a security manager exists and
+     *         the caller is not permitted to modify threads
+     *         because it does not hold {@link
+     *         java.lang.RuntimePermission}{@code ("modifyThread")}
+     */
+    public ForkJoinPool() {
+        this(Math.min(MAX_CAP, Runtime.getRuntime().availableProcessors()),
+                defaultForkJoinWorkerThreadFactory, null, false);
+    }
+
+    /**
+     * Creates a {@code ForkJoinPool} with the indicated parallelism
+     * level, the {@linkplain
+     * #defaultForkJoinWorkerThreadFactory default thread factory},
+     * no UncaughtExceptionHandler, and non-async LIFO processing mode.
+     *
+     * @param parallelism the parallelism level
+     * @throws IllegalArgumentException if parallelism less than or
+     *         equal to zero, or greater than implementation limit
+     * @throws SecurityException if a security manager exists and
+     *         the caller is not permitted to modify threads
+     *         because it does not hold {@link
+     *         java.lang.RuntimePermission}{@code ("modifyThread")}
+     */
+    public ForkJoinPool(int parallelism) {
+        this(parallelism, defaultForkJoinWorkerThreadFactory, null, false);
+    }
+
+    /**
+     * Creates a {@code ForkJoinPool} with the given parameters.
+     *
+     * @param parallelism the parallelism level. For default value,
+     * use {@link java.lang.Runtime#availableProcessors}.
+     * @param factory the factory for creating new threads. For default value,
+     * use {@link #defaultForkJoinWorkerThreadFactory}.
+     * @param handler the handler for internal worker threads that
+     * terminate due to unrecoverable errors encountered while executing
+     * tasks. For default value, use {@code null}.
+     * @param asyncMode if true,
+     * establishes local first-in-first-out scheduling mode for forked
+     * tasks that are never joined. This mode may be more appropriate
+     * than default locally stack-based mode in applications in which
+     * worker threads only process event-style asynchronous tasks.
+     * For default value, use {@code false}.
+     * @throws IllegalArgumentException if parallelism less than or
+     *         equal to zero, or greater than implementation limit
+     * @throws NullPointerException if the factory is null
+     * @throws SecurityException if a security manager exists and
+     *         the caller is not permitted to modify threads
+     *         because it does not hold {@link
+     *         java.lang.RuntimePermission}{@code ("modifyThread")}
+     */
+    public ForkJoinPool(int parallelism,
+                        ForkJoinWorkerThreadFactory factory,
+                        UncaughtExceptionHandler handler,
+                        boolean asyncMode) {
+        this(checkParallelism(parallelism),
+                checkFactory(factory),
+                handler,
+                (asyncMode ? FIFO_QUEUE : LIFO_QUEUE),
+                "ForkJoinPool-" + nextPoolId() + "-worker-");
+        checkPermission();
+    }
+
+    private static int checkParallelism(int parallelism) {
+        if (parallelism <= 0 || parallelism > MAX_CAP)
+            throw new IllegalArgumentException();
+        return parallelism;
+    }
+
+    private static ForkJoinWorkerThreadFactory checkFactory
+            (ForkJoinWorkerThreadFactory factory) {
+        if (factory == null)
+            throw new NullPointerException();
+        return factory;
+    }
+
+    /**
+     * Creates a {@code ForkJoinPool} with the given parameters, without
+     * any security checks or parameter validation.  Invoked directly by
+     * makeCommonPool.
+     */
+    private ForkJoinPool(int parallelism,
+                         ForkJoinWorkerThreadFactory factory,
+                         UncaughtExceptionHandler handler,
+                         int mode,
+                         String workerNamePrefix) {
+        this.workerNamePrefix = workerNamePrefix;
+        this.factory = factory;
+        this.ueh = handler;
+        this.mode = (short)mode;
+        this.parallelism = (short)parallelism;
+        long np = (long)(-parallelism); // offset ctl counts
+        this.ctl = ((np << AC_SHIFT) & AC_MASK) | ((np << TC_SHIFT) & TC_MASK);
+    }
+
+    /**
+     * Returns the common pool instance. This pool is statically
+     * constructed; its run state is unaffected by attempts to {@link
+     * #shutdown} or {@link #shutdownNow}. However this pool and any
+     * ongoing processing are automatically terminated upon program
+     * {@link System#exit}.  Any program that relies on asynchronous
+     * task processing to complete before program termination should
+     * invoke {@code commonPool().}{@link #awaitQuiescence awaitQuiescence},
+     * before exit.
+     *
+     * @return the common pool instance
+     * @since 1.8
+     */
+    public static ForkJoinPool commonPool() {
+        // assert common != null : "static init error";
+        return common;
+    }
+
+    // Execution methods
+
+    /**
+     * Performs the given task, returning its result upon completion.
+     * If the computation encounters an unchecked Exception or Error,
+     * it is rethrown as the outcome of this invocation.  Rethrown
+     * exceptions behave in the same way as regular exceptions, but,
+     * when possible, contain stack traces (as displayed for example
+     * using {@code ex.printStackTrace()}) of both the current thread
+     * as well as the thread actually encountering the exception;
+     * minimally only the latter.
+     *
+     * @param task the task
+     * @return the task's result
+     * @throws NullPointerException if the task is null
+     * @throws RejectedExecutionException if the task cannot be
+     *         scheduled for execution
+     */
+    public <T> T invoke(ForkJoinTask<T> task) {
+        if (task == null)
+            throw new NullPointerException();
+        externalPush(task);
+        return task.join();
+    }
+
+    /**
+     * Arranges for (asynchronous) execution of the given task.
+     *
+     * @param task the task
+     * @throws NullPointerException if the task is null
+     * @throws RejectedExecutionException if the task cannot be
+     *         scheduled for execution
+     */
+    public void execute(ForkJoinTask<?> task) {
+        if (task == null)
+            throw new NullPointerException();
+        externalPush(task);
+    }
+
+    // AbstractExecutorService methods
+
+    /**
+     * @throws NullPointerException if the task is null
+     * @throws RejectedExecutionException if the task cannot be
+     *         scheduled for execution
+     */
+    public void execute(Runnable task) {
+        if (task == null)
+            throw new NullPointerException();
+        ForkJoinTask<?> job;
+        if (task instanceof ForkJoinTask<?>) // avoid re-wrap
+            job = (ForkJoinTask<?>) task;
+        else
+            job = new ForkJoinTask.RunnableExecuteAction(task);
+        externalPush(job);
+    }
+
+    /**
+     * Submits a ForkJoinTask for execution.
+     *
+     * @param task the task to submit
+     * @return the task
+     * @throws NullPointerException if the task is null
+     * @throws RejectedExecutionException if the task cannot be
+     *         scheduled for execution
+     */
+    public <T> ForkJoinTask<T> submit(ForkJoinTask<T> task) {
+        if (task == null)
+            throw new NullPointerException();
+        externalPush(task);
+        return task;
+    }
+
+    /**
+     * @throws NullPointerException if the task is null
+     * @throws RejectedExecutionException if the task cannot be
+     *         scheduled for execution
+     */
+    public <T> ForkJoinTask<T> submit(Callable<T> task) {
+        ForkJoinTask<T> job = new ForkJoinTask.AdaptedCallable<T>(task);
+        externalPush(job);
+        return job;
+    }
+
+    /**
+     * @throws NullPointerException if the task is null
+     * @throws RejectedExecutionException if the task cannot be
+     *         scheduled for execution
+     */
+    public <T> ForkJoinTask<T> submit(Runnable task, T result) {
+        ForkJoinTask<T> job = new ForkJoinTask.AdaptedRunnable<T>(task, result);
+        externalPush(job);
+        return job;
+    }
+
+    /**
+     * @throws NullPointerException if the task is null
+     * @throws RejectedExecutionException if the task cannot be
+     *         scheduled for execution
+     */
+    public ForkJoinTask<?> submit(Runnable task) {
+        if (task == null)
+            throw new NullPointerException();
+        ForkJoinTask<?> job;
+        if (task instanceof ForkJoinTask<?>) // avoid re-wrap
+            job = (ForkJoinTask<?>) task;
+        else
+            job = new ForkJoinTask.AdaptedRunnableAction(task);
+        externalPush(job);
+        return job;
+    }
+
+    /**
+     * @throws NullPointerException       {@inheritDoc}
+     * @throws RejectedExecutionException {@inheritDoc}
+     */
+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) {
+        // In previous versions of this class, this method constructed
+        // a task to run ForkJoinTask.invokeAll, but now external
+        // invocation of multiple tasks is at least as efficient.
+        ArrayList<Future<T>> futures = new ArrayList<Future<T>>(tasks.size());
+
+        boolean done = false;
+        try {
+            for (Callable<T> t : tasks) {
+                ForkJoinTask<T> f = new ForkJoinTask.AdaptedCallable<T>(t);
+                futures.add(f);
+                externalPush(f);
+            }
+            for (int i = 0, size = futures.size(); i < size; i++)
+                ((ForkJoinTask<?>)futures.get(i)).quietlyJoin();
+            done = true;
+            return futures;
+        } finally {
+            if (!done)
+                for (int i = 0, size = futures.size(); i < size; i++)
+                    futures.get(i).cancel(false);
+        }
+    }
+
+    /**
+     * Returns the factory used for constructing new workers.
+     *
+     * @return the factory used for constructing new workers
+     */
+    public ForkJoinWorkerThreadFactory getFactory() {
+        return factory;
+    }
+
+    /**
+     * Returns the handler for internal worker threads that terminate
+     * due to unrecoverable errors encountered while executing tasks.
+     *
+     * @return the handler, or {@code null} if none
+     */
+    public UncaughtExceptionHandler getUncaughtExceptionHandler() {
+        return ueh;
+    }
+
+    /**
+     * Returns the targeted parallelism level of this pool.
+     *
+     * @return the targeted parallelism level of this pool
+     */
+    public int getParallelism() {
+        int par;
+        return ((par = parallelism) > 0) ? par : 1;
+    }
+
+    /**
+     * Returns the targeted parallelism level of the common pool.
+     *
+     * @return the targeted parallelism level of the common pool
+     * @since 1.8
+     */
+    public static int getCommonPoolParallelism() {
+        return commonParallelism;
+    }
+
+    /**
+     * Returns the number of worker threads that have started but not
+     * yet terminated.  The result returned by this method may differ
+     * from {@link #getParallelism} when threads are created to
+     * maintain parallelism when others are cooperatively blocked.
+     *
+     * @return the number of worker threads
+     */
+    public int getPoolSize() {
+        return parallelism + (short)(ctl >>> TC_SHIFT);
+    }
+
+    /**
+     * Returns {@code true} if this pool uses local first-in-first-out
+     * scheduling mode for forked tasks that are never joined.
+     *
+     * @return {@code true} if this pool uses async mode
+     */
+    public boolean getAsyncMode() {
+        return mode == FIFO_QUEUE;
+    }
+
+    /**
+     * Returns an estimate of the number of worker threads that are
+     * not blocked waiting to join tasks or for other managed
+     * synchronization. This method may overestimate the
+     * number of running threads.
+     *
+     * @return the number of worker threads
+     */
+    public int getRunningThreadCount() {
+        int rc = 0;
+        WorkQueue[] ws; WorkQueue w;
+        if ((ws = workQueues) != null) {
+            for (int i = 1; i < ws.length; i += 2) {
+                if ((w = ws[i]) != null && w.isApparentlyUnblocked())
+                    ++rc;
+            }
+        }
+        return rc;
+    }
+
+    /**
+     * Returns an estimate of the number of threads that are currently
+     * stealing or executing tasks. This method may overestimate the
+     * number of active threads.
+     *
+     * @return the number of active threads
+     */
+    public int getActiveThreadCount() {
+        int r = parallelism + (int)(ctl >> AC_SHIFT);
+        return (r <= 0) ? 0 : r; // suppress momentarily negative values
+    }
+
+    /**
+     * Returns {@code true} if all worker threads are currently idle.
+     * An idle worker is one that cannot obtain a task to execute
+     * because none are available to steal from other threads, and
+     * there are no pending submissions to the pool. This method is
+     * conservative; it might not return {@code true} immediately upon
+     * idleness of all threads, but will eventually become true if
+     * threads remain inactive.
+     *
+     * @return {@code true} if all threads are currently idle
+     */
+    public boolean isQuiescent() {
+        return parallelism + (int)(ctl >> AC_SHIFT) <= 0;
+    }
+
+    /**
+     * Returns an estimate of the total number of tasks stolen from
+     * one thread's work queue by another. The reported value
+     * underestimates the actual total number of steals when the pool
+     * is not quiescent. This value may be useful for monitoring and
+     * tuning fork/join programs: in general, steal counts should be
+     * high enough to keep threads busy, but low enough to avoid
+     * overhead and contention across threads.
+     *
+     * @return the number of steals
+     */
+    public long getStealCount() {
+        long count = stealCount;
+        WorkQueue[] ws; WorkQueue w;
+        if ((ws = workQueues) != null) {
+            for (int i = 1; i < ws.length; i += 2) {
+                if ((w = ws[i]) != null)
+                    count += w.nsteals;
+            }
+        }
+        return count;
+    }
+
+    /**
+     * Returns an estimate of the total number of tasks currently held
+     * in queues by worker threads (but not including tasks submitted
+     * to the pool that have not begun executing). This value is only
+     * an approximation, obtained by iterating across all threads in
+     * the pool. This method may be useful for tuning task
+     * granularities.
+     *
+     * @return the number of queued tasks
+     */
+    public long getQueuedTaskCount() {
+        long count = 0;
+        WorkQueue[] ws; WorkQueue w;
+        if ((ws = workQueues) != null) {
+            for (int i = 1; i < ws.length; i += 2) {
+                if ((w = ws[i]) != null)
+                    count += w.queueSize();
+            }
+        }
+        return count;
+    }
+
+    /**
+     * Returns an estimate of the number of tasks submitted to this
+     * pool that have not yet begun executing.  This method may take
+     * time proportional to the number of submissions.
+     *
+     * @return the number of queued submissions
+     */
+    public int getQueuedSubmissionCount() {
+        int count = 0;
+        WorkQueue[] ws; WorkQueue w;
+        if ((ws = workQueues) != null) {
+            for (int i = 0; i < ws.length; i += 2) {
+                if ((w = ws[i]) != null)
+                    count += w.queueSize();
+            }
+        }
+        return count;
+    }
+
+    /**
+     * Returns {@code true} if there are any tasks submitted to this
+     * pool that have not yet begun executing.
+     *
+     * @return {@code true} if there are any queued submissions
+     */
+    public boolean hasQueuedSubmissions() {
+        WorkQueue[] ws; WorkQueue w;
+        if ((ws = workQueues) != null) {
+            for (int i = 0; i < ws.length; i += 2) {
+                if ((w = ws[i]) != null && !w.isEmpty())
+                    return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Removes and returns the next unexecuted submission if one is
+     * available.  This method may be useful in extensions to this
+     * class that re-assign work in systems with multiple pools.
+     *
+     * @return the next submission, or {@code null} if none
+     */
+    protected ForkJoinTask<?> pollSubmission() {
+        WorkQueue[] ws; WorkQueue w; ForkJoinTask<?> t;
+        if ((ws = workQueues) != null) {
+            for (int i = 0; i < ws.length; i += 2) {
+                if ((w = ws[i]) != null && (t = w.poll()) != null)
+                    return t;
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Removes all available unexecuted submitted and forked tasks
+     * from scheduling queues and adds them to the given collection,
+     * without altering their execution status. These may include
+     * artificially generated or wrapped tasks. This method is
+     * designed to be invoked only when the pool is known to be
+     * quiescent. Invocations at other times may not remove all
+     * tasks. A failure encountered while attempting to add elements
+     * to collection {@code c} may result in elements being in
+     * neither, either or both collections when the associated
+     * exception is thrown.  The behavior of this operation is
+     * undefined if the specified collection is modified while the
+     * operation is in progress.
+     *
+     * @param c the collection to transfer elements into
+     * @return the number of elements transferred
+     */
+    protected int drainTasksTo(Collection<? super ForkJoinTask<?>> c) {
+        int count = 0;
+        WorkQueue[] ws; WorkQueue w; ForkJoinTask<?> t;
+        if ((ws = workQueues) != null) {
+            for (int i = 0; i < ws.length; ++i) {
+                if ((w = ws[i]) != null) {
+                    while ((t = w.poll()) != null) {
+                        c.add(t);
+                        ++count;
+                    }
+                }
+            }
+        }
+        return count;
+    }
+
+    /**
+     * Returns a string identifying this pool, as well as its state,
+     * including indications of run state, parallelism level, and
+     * worker and task counts.
+     *
+     * @return a string identifying this pool, as well as its state
+     */
+    public String toString() {
+        // Use a single pass through workQueues to collect counts
+        long qt = 0L, qs = 0L; int rc = 0;
+        long st = stealCount;
+        long c = ctl;
+        WorkQueue[] ws; WorkQueue w;
+        if ((ws = workQueues) != null) {
+            for (int i = 0; i < ws.length; ++i) {
+                if ((w = ws[i]) != null) {
+                    int size = w.queueSize();
+                    if ((i & 1) == 0)
+                        qs += size;
+                    else {
+                        qt += size;
+                        st += w.nsteals;
+                        if (w.isApparentlyUnblocked())
+                            ++rc;
+                    }
+                }
+            }
+        }
+        int pc = parallelism;
+        int tc = pc + (short)(c >>> TC_SHIFT);
+        int ac = pc + (int)(c >> AC_SHIFT);
+        if (ac < 0) // ignore transient negative
+            ac = 0;
+        String level;
+        if ((c & STOP_BIT) != 0)
+            level = (tc == 0) ? "Terminated" : "Terminating";
+        else
+            level = plock < 0 ? "Shutting down" : "Running";
+        return super.toString() +
+                "[" + level +
+                ", parallelism = " + pc +
+                ", size = " + tc +
+                ", active = " + ac +
+                ", running = " + rc +
+                ", steals = " + st +
+                ", tasks = " + qt +
+                ", submissions = " + qs +
+                "]";
+    }
+
+    /**
+     * Possibly initiates an orderly shutdown in which previously
+     * submitted tasks are executed, but no new tasks will be
+     * accepted. Invocation has no effect on execution state if this
+     * is the {@link #commonPool()}, and no additional effect if
+     * already shut down.  Tasks that are in the process of being
+     * submitted concurrently during the course of this method may or
+     * may not be rejected.
+     *
+     * @throws SecurityException if a security manager exists and
+     *         the caller is not permitted to modify threads
+     *         because it does not hold {@link
+     *         java.lang.RuntimePermission}{@code ("modifyThread")}
+     */
+    public void shutdown() {
+        checkPermission();
+        tryTerminate(false, true);
+    }
+
+    /**
+     * Possibly attempts to cancel and/or stop all tasks, and reject
+     * all subsequently submitted tasks.  Invocation has no effect on
+     * execution state if this is the {@link #commonPool()}, and no
+     * additional effect if already shut down. Otherwise, tasks that
+     * are in the process of being submitted or executed concurrently
+     * during the course of this method may or may not be
+     * rejected. This method cancels both existing and unexecuted
+     * tasks, in order to permit termination in the presence of task
+     * dependencies. So the method always returns an empty list
+     * (unlike the case for some other Executors).
+     *
+     * @return an empty list
+     * @throws SecurityException if a security manager exists and
+     *         the caller is not permitted to modify threads
+     *         because it does not hold {@link
+     *         java.lang.RuntimePermission}{@code ("modifyThread")}
+     */
+    public List<Runnable> shutdownNow() {
+        checkPermission();
+        tryTerminate(true, true);
+        return Collections.emptyList();
+    }
+
+    /**
+     * Returns {@code true} if all tasks have completed following shut down.
+     *
+     * @return {@code true} if all tasks have completed following shut down
+     */
+    public boolean isTerminated() {
+        long c = ctl;
+        return ((c & STOP_BIT) != 0L &&
+                (short)(c >>> TC_SHIFT) + parallelism <= 0);
+    }
+
+    /**
+     * Returns {@code true} if the process of termination has
+     * commenced but not yet completed.  This method may be useful for
+     * debugging. A return of {@code true} reported a sufficient
+     * period after shutdown may indicate that submitted tasks have
+     * ignored or suppressed interruption, or are waiting for I/O,
+     * causing this executor not to properly terminate. (See the
+     * advisory notes for class {@link ForkJoinTask} stating that
+     * tasks should not normally entail blocking operations.  But if
+     * they do, they must abort them on interrupt.)
+     *
+     * @return {@code true} if terminating but not yet terminated
+     */
+    public boolean isTerminating() {
+        long c = ctl;
+        return ((c & STOP_BIT) != 0L &&
+                (short)(c >>> TC_SHIFT) + parallelism > 0);
+    }
+
+    /**
+     * Returns {@code true} if this pool has been shut down.
+     *
+     * @return {@code true} if this pool has been shut down
+     */
+    public boolean isShutdown() {
+        return plock < 0;
+    }
+
+    /**
+     * Blocks until all tasks have completed execution after a
+     * shutdown request, or the timeout occurs, or the current thread
+     * is interrupted, whichever happens first. Because the {@link
+     * #commonPool()} never terminates until program shutdown, when
+     * applied to the common pool, this method is equivalent to {@link
+     * #awaitQuiescence(long, TimeUnit)} but always returns {@code false}.
+     *
+     * @param timeout the maximum time to wait
+     * @param unit the time unit of the timeout argument
+     * @return {@code true} if this executor terminated and
+     *         {@code false} if the timeout elapsed before termination
+     * @throws InterruptedException if interrupted while waiting
+     */
+    public boolean awaitTermination(long timeout, TimeUnit unit)
+            throws InterruptedException {
+        if (Thread.interrupted())
+            throw new InterruptedException();
+        if (this == common) {
+            awaitQuiescence(timeout, unit);
+            return false;
+        }
+        long nanos = unit.toNanos(timeout);
+        if (isTerminated())
+            return true;
+        if (nanos <= 0L)
+            return false;
+        long deadline = System.nanoTime() + nanos;
+        synchronized (this) {
+            for (;;) {
+                if (isTerminated())
+                    return true;
+                if (nanos <= 0L)
+                    return false;
+                long millis = TimeUnit.NANOSECONDS.toMillis(nanos);
+                wait(millis > 0L ? millis : 1L);
+                nanos = deadline - System.nanoTime();
+            }
+        }
+    }
+
+    /**
+     * If called by a ForkJoinTask operating in this pool, equivalent
+     * in effect to {@link ForkJoinTask#helpQuiesce}. Otherwise,
+     * waits and/or attempts to assist performing tasks until this
+     * pool {@link #isQuiescent} or the indicated timeout elapses.
+     *
+     * @param timeout the maximum time to wait
+     * @param unit the time unit of the timeout argument
+     * @return {@code true} if quiescent; {@code false} if the
+     * timeout elapsed.
+     */
+    public boolean awaitQuiescence(long timeout, TimeUnit unit) {
+        long nanos = unit.toNanos(timeout);
+        ForkJoinWorkerThread wt;
+        Thread thread = Thread.currentThread();
+        if ((thread instanceof ForkJoinWorkerThread) &&
+                (wt = (ForkJoinWorkerThread)thread).pool == this) {
+            helpQuiescePool(wt.workQueue);
+            return true;
+        }
+        long startTime = System.nanoTime();
+        WorkQueue[] ws;
+        int r = 0, m;
+        boolean found = true;
+        while (!isQuiescent() && (ws = workQueues) != null &&
+                (m = ws.length - 1) >= 0) {
+            if (!found) {
+                if ((System.nanoTime() - startTime) > nanos)
+                    return false;
+                Thread.yield(); // cannot block
+            }
+            found = false;
+            for (int j = (m + 1) << 2; j >= 0; --j) {
+                ForkJoinTask<?> t; WorkQueue q; int b;
+                if ((q = ws[r++ & m]) != null && (b = q.base) - q.top < 0) {
+                    found = true;
+                    if ((t = q.pollAt(b)) != null)
+                        t.doExec();
+                    break;
+                }
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Waits and/or attempts to assist performing tasks indefinitely
+     * until the {@link #commonPool()} {@link #isQuiescent}.
+     */
+    static void quiesceCommonPool() {
+        common.awaitQuiescence(Long.MAX_VALUE, TimeUnit.NANOSECONDS);
+    }
+
+    /**
+     * Interface for extending managed parallelism for tasks running
+     * in {@link ForkJoinPool}s.
+     *
+     * <p>A {@code ManagedBlocker} provides two methods.  Method
+     * {@code isReleasable} must return {@code true} if blocking is
+     * not necessary. Method {@code block} blocks the current thread
+     * if necessary (perhaps internally invoking {@code isReleasable}
+     * before actually blocking). These actions are performed by any
+     * thread invoking {@link ForkJoinPool#managedBlock(ManagedBlocker)}.
+     * The unusual methods in this API accommodate synchronizers that
+     * may, but don't usually, block for long periods. Similarly, they
+     * allow more efficient internal handling of cases in which
+     * additional workers may be, but usually are not, needed to
+     * ensure sufficient parallelism.  Toward this end,
+     * implementations of method {@code isReleasable} must be amenable
+     * to repeated invocation.
+     *
+     * <p>For example, here is a ManagedBlocker based on a
+     * ReentrantLock:
+     *  <pre> {@code
+     * class ManagedLocker implements ManagedBlocker {
+     *   final ReentrantLock lock;
+     *   boolean hasLock = false;
+     *   ManagedLocker(ReentrantLock lock) { this.lock = lock; }
+     *   public boolean block() {
+     *     if (!hasLock)
+     *       lock.lock();
+     *     return true;
+     *   }
+     *   public boolean isReleasable() {
+     *     return hasLock || (hasLock = lock.tryLock());
+     *   }
+     * }}</pre>
+     *
+     * <p>Here is a class that possibly blocks waiting for an
+     * item on a given queue:
+     *  <pre> {@code
+     * class QueueTaker<E> implements ManagedBlocker {
+     *   final BlockingQueue<E> queue;
+     *   volatile E item = null;
+     *   QueueTaker(BlockingQueue<E> q) { this.queue = q; }
+     *   public boolean block() throws InterruptedException {
+     *     if (item == null)
+     *       item = queue.take();
+     *     return true;
+     *   }
+     *   public boolean isReleasable() {
+     *     return item != null || (item = queue.poll()) != null;
+     *   }
+     *   public E getItem() { // call after pool.managedBlock completes
+     *     return item;
+     *   }
+     * }}</pre>
+     */
+    public static interface ManagedBlocker {
+        /**
+         * Possibly blocks the current thread, for example waiting for
+         * a lock or condition.
+         *
+         * @return {@code true} if no additional blocking is necessary
+         * (i.e., if isReleasable would return true)
+         * @throws InterruptedException if interrupted while waiting
+         * (the method is not required to do so, but is allowed to)
+         */
+        boolean block() throws InterruptedException;
+
+        /**
+         * Returns {@code true} if blocking is unnecessary.
+         * @return {@code true} if blocking is unnecessary
+         */
+        boolean isReleasable();
+    }
+
+    /**
+     * Blocks in accord with the given blocker.  If the current thread
+     * is a {@link ForkJoinWorkerThread}, this method possibly
+     * arranges for a spare thread to be activated if necessary to
+     * ensure sufficient parallelism while the current thread is blocked.
+     *
+     * <p>If the caller is not a {@link ForkJoinTask}, this method is
+     * behaviorally equivalent to
+     *  <pre> {@code
+     * while (!blocker.isReleasable())
+     *   if (blocker.block())
+     *     return;
+     * }</pre>
+     *
+     * If the caller is a {@code ForkJoinTask}, then the pool may
+     * first be expanded to ensure parallelism, and later adjusted.
+     *
+     * @param blocker the blocker
+     * @throws InterruptedException if blocker.block did so
+     */
+    public static void managedBlock(ManagedBlocker blocker)
+            throws InterruptedException {
+        Thread t = Thread.currentThread();
+        if (t instanceof ForkJoinWorkerThread) {
+            ForkJoinPool p = ((ForkJoinWorkerThread)t).pool;
+            while (!blocker.isReleasable()) {
+                if (p.tryCompensate(p.ctl)) {
+                    try {
+                        do {} while (!blocker.isReleasable() &&
+                                !blocker.block());
+                    } finally {
+                        p.incrementActiveCount();
+                    }
+                    break;
+                }
+            }
+        }
+        else {
+            do {} while (!blocker.isReleasable() &&
+                    !blocker.block());
+        }
+    }
+
+    // AbstractExecutorService overrides.  These rely on undocumented
+    // fact that ForkJoinTask.adapt returns ForkJoinTasks that also
+    // implement RunnableFuture.
+
+    protected <T> RunnableFuture<T> newTaskFor(Runnable runnable, T value) {
+        return new ForkJoinTask.AdaptedRunnable<T>(runnable, value);
+    }
+
+    protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {
+        return new ForkJoinTask.AdaptedCallable<T>(callable);
+    }
+
+    // Unsafe mechanics
+    private static final sun.misc.Unsafe U;
+    private static final long CTL;
+    private static final long PARKBLOCKER;
+    private static final int ABASE;
+    private static final int ASHIFT;
+    private static final long STEALCOUNT;
+    private static final long PLOCK;
+    private static final long INDEXSEED;
+    private static final long QBASE;
+    private static final long QLOCK;
+
+    static {
+        // initialize field offsets for CAS etc
+        try {
+            U = getUnsafe();
+            Class<?> k = ForkJoinPool.class;
+            CTL = U.objectFieldOffset
+                    (k.getDeclaredField("ctl"));
+            STEALCOUNT = U.objectFieldOffset
+                    (k.getDeclaredField("stealCount"));
+            PLOCK = U.objectFieldOffset
+                    (k.getDeclaredField("plock"));
+            INDEXSEED = U.objectFieldOffset
+                    (k.getDeclaredField("indexSeed"));
+            Class<?> tk = Thread.class;
+            PARKBLOCKER = U.objectFieldOffset
+                    (tk.getDeclaredField("parkBlocker"));
+            Class<?> wk = WorkQueue.class;
+            QBASE = U.objectFieldOffset
+                    (wk.getDeclaredField("base"));
+            QLOCK = U.objectFieldOffset
+                    (wk.getDeclaredField("qlock"));
+            Class<?> ak = ForkJoinTask[].class;
+            ABASE = U.arrayBaseOffset(ak);
+            int scale = U.arrayIndexScale(ak);
+            if ((scale & (scale - 1)) != 0)
+                throw new Error("data type scale not a power of two");
+            ASHIFT = 31 - Integer.numberOfLeadingZeros(scale);
+        } catch (Exception e) {
+            throw new Error(e);
+        }
+
+        submitters = new ThreadLocal<Submitter>();
+        defaultForkJoinWorkerThreadFactory =
+                new DefaultForkJoinWorkerThreadFactory();
+        modifyThreadPermission = new RuntimePermission("modifyThread");
+
+        common = java.security.AccessController.doPrivileged
+                (new java.security.PrivilegedAction<ForkJoinPool>() {
+                    public ForkJoinPool run() { return makeCommonPool(); }});
+        int par = common.parallelism; // report 1 even if threads disabled
+        commonParallelism = par > 0 ? par : 1;
+    }
+
+    /**
+     * Creates and returns the common pool, respecting user settings
+     * specified via system properties.
+     */
+    private static ForkJoinPool makeCommonPool() {
+        int parallelism = -1;
+        ForkJoinWorkerThreadFactory factory
+                = defaultForkJoinWorkerThreadFactory;
+        UncaughtExceptionHandler handler = null;
+        try {  // ignore exceptions in accessing/parsing properties
+            String pp = System.getProperty
+                    ("java.util.concurrent.ForkJoinPool.common.parallelism");
+            String fp = System.getProperty
+                    ("java.util.concurrent.ForkJoinPool.common.threadFactory");
+            String hp = System.getProperty
+                    ("java.util.concurrent.ForkJoinPool.common.exceptionHandler");
+            if (pp != null)
+                parallelism = Integer.parseInt(pp);
+            if (fp != null)
+                factory = ((ForkJoinWorkerThreadFactory)ClassLoader.
+                        getSystemClassLoader().loadClass(fp).newInstance());
+            if (hp != null)
+                handler = ((UncaughtExceptionHandler)ClassLoader.
+                        getSystemClassLoader().loadClass(hp).newInstance());
+        } catch (Exception ignore) {
+        }
+
+        if (parallelism < 0 && // default 1 less than #cores
+                (parallelism = Runtime.getRuntime().availableProcessors() - 1) < 0)
+            parallelism = 0;
+        if (parallelism > MAX_CAP)
+            parallelism = MAX_CAP;
+        return new ForkJoinPool(parallelism, factory, handler, LIFO_QUEUE,
+                "ForkJoinPool.commonPool-worker-");
+    }
+
+    /**
+     * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.
+     * Replace with a simple call to Unsafe.getUnsafe when integrating
+     * into a jdk.
+     *
+     * @return a sun.misc.Unsafe
+     */
+    private static sun.misc.Unsafe getUnsafe() {
+        try {
+            return sun.misc.Unsafe.getUnsafe();
+        } catch (SecurityException tryReflectionInstead) {}
+        try {
+            return java.security.AccessController.doPrivileged
+                    (new java.security.PrivilegedExceptionAction<sun.misc.Unsafe>() {
+                        public sun.misc.Unsafe run() throws Exception {
+                            Class<sun.misc.Unsafe> k = sun.misc.Unsafe.class;
+                            for (java.lang.reflect.Field f : k.getDeclaredFields()) {
+                                f.setAccessible(true);
+                                Object x = f.get(null);
+                                if (k.isInstance(x))
+                                    return k.cast(x);
+                            }
+                            throw new NoSuchFieldError("the Unsafe");
+                        }});
+        } catch (java.security.PrivilegedActionException e) {
+            throw new RuntimeException("Could not initialize intrinsics",
+                    e.getCause());
+        }
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/internal/chmv8/ForkJoinTask.java b/api/src/main/java/org/asynchttpclient/internal/chmv8/ForkJoinTask.java
new file mode 100644
index 000000000..0eb8d96ae
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/internal/chmv8/ForkJoinTask.java
@@ -0,0 +1,1560 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+/*
+ * Written by Doug Lea with assistance from members of JCP JSR-166
+ * Expert Group and released to the public domain, as explained at
+ * http://creativecommons.org/publicdomain/zero/1.0/
+ */
+
+package org.asynchttpclient.internal.chmv8;
+
+import java.io.Serializable;
+import java.lang.ref.ReferenceQueue;
+import java.lang.ref.WeakReference;
+import java.lang.reflect.Constructor;
+import java.util.Collection;
+import java.util.List;
+import java.util.RandomAccess;
+import java.util.concurrent.Callable;
+import java.util.concurrent.CancellationException;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import java.util.concurrent.Phaser;
+import java.util.concurrent.RecursiveAction;
+import java.util.concurrent.RecursiveTask;
+import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.RunnableFuture;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.locks.ReentrantLock;
+
+/**
+ * Abstract base class for tasks that run within a {@link ForkJoinPool}.
+ * A {@code ForkJoinTask} is a thread-like entity that is much
+ * lighter weight than a normal thread.  Huge numbers of tasks and
+ * subtasks may be hosted by a small number of actual threads in a
+ * ForkJoinPool, at the price of some usage limitations.
+ *
+ * <p>A "main" {@code ForkJoinTask} begins execution when it is
+ * explicitly submitted to a {@link ForkJoinPool}, or, if not already
+ * engaged in a ForkJoin computation, commenced in the {@link
+ * ForkJoinPool#commonPool()} via {@link #fork}, {@link #invoke}, or
+ * related methods.  Once started, it will usually in turn start other
+ * subtasks.  As indicated by the name of this class, many programs
+ * using {@code ForkJoinTask} employ only methods {@link #fork} and
+ * {@link #join}, or derivatives such as {@link
+ * #invokeAll(ForkJoinTask...) invokeAll}.  However, this class also
+ * provides a number of other methods that can come into play in
+ * advanced usages, as well as extension mechanics that allow support
+ * of new forms of fork/join processing.
+ *
+ * <p>A {@code ForkJoinTask} is a lightweight form of {@link Future}.
+ * The efficiency of {@code ForkJoinTask}s stems from a set of
+ * restrictions (that are only partially statically enforceable)
+ * reflecting their main use as computational tasks calculating pure
+ * functions or operating on purely isolated objects.  The primary
+ * coordination mechanisms are {@link #fork}, that arranges
+ * asynchronous execution, and {@link #join}, that doesn't proceed
+ * until the task's result has been computed.  Computations should
+ * ideally avoid {@code synchronized} methods or blocks, and should
+ * minimize other blocking synchronization apart from joining other
+ * tasks or using synchronizers such as Phasers that are advertised to
+ * cooperate with fork/join scheduling. Subdividable tasks should also
+ * not perform blocking I/O, and should ideally access variables that
+ * are completely independent of those accessed by other running
+ * tasks. These guidelines are loosely enforced by not permitting
+ * checked exceptions such as {@code IOExceptions} to be
+ * thrown. However, computations may still encounter unchecked
+ * exceptions, that are rethrown to callers attempting to join
+ * them. These exceptions may additionally include {@link
+ * RejectedExecutionException} stemming from internal resource
+ * exhaustion, such as failure to allocate internal task
+ * queues. Rethrown exceptions behave in the same way as regular
+ * exceptions, but, when possible, contain stack traces (as displayed
+ * for example using {@code ex.printStackTrace()}) of both the thread
+ * that initiated the computation as well as the thread actually
+ * encountering the exception; minimally only the latter.
+ *
+ * <p>It is possible to define and use ForkJoinTasks that may block,
+ * but doing do requires three further considerations: (1) Completion
+ * of few if any <em>other</em> tasks should be dependent on a task
+ * that blocks on external synchronization or I/O. Event-style async
+ * tasks that are never joined (for example, those subclassing {@link
+ * CountedCompleter}) often fall into this category.  (2) To minimize
+ * resource impact, tasks should be small; ideally performing only the
+ * (possibly) blocking action. (3) Unless the {@link
+ * ForkJoinPool.ManagedBlocker} API is used, or the number of possibly
+ * blocked tasks is known to be less than the pool's {@link
+ * ForkJoinPool#getParallelism} level, the pool cannot guarantee that
+ * enough threads will be available to ensure progress or good
+ * performance.
+ *
+ * <p>The primary method for awaiting completion and extracting
+ * results of a task is {@link #join}, but there are several variants:
+ * The {@link Future#get} methods support interruptible and/or timed
+ * waits for completion and report results using {@code Future}
+ * conventions. Method {@link #invoke} is semantically
+ * equivalent to {@code fork(); join()} but always attempts to begin
+ * execution in the current thread. The "<em>quiet</em>" forms of
+ * these methods do not extract results or report exceptions. These
+ * may be useful when a set of tasks are being executed, and you need
+ * to delay processing of results or exceptions until all complete.
+ * Method {@code invokeAll} (available in multiple versions)
+ * performs the most common form of parallel invocation: forking a set
+ * of tasks and joining them all.
+ *
+ * <p>In the most typical usages, a fork-join pair act like a call
+ * (fork) and return (join) from a parallel recursive function. As is
+ * the case with other forms of recursive calls, returns (joins)
+ * should be performed innermost-first. For example, {@code a.fork();
+ * b.fork(); b.join(); a.join();} is likely to be substantially more
+ * efficient than joining {@code a} before {@code b}.
+ *
+ * <p>The execution status of tasks may be queried at several levels
+ * of detail: {@link #isDone} is true if a task completed in any way
+ * (including the case where a task was cancelled without executing);
+ * {@link #isCompletedNormally} is true if a task completed without
+ * cancellation or encountering an exception; {@link #isCancelled} is
+ * true if the task was cancelled (in which case {@link #getException}
+ * returns a {@link java.util.concurrent.CancellationException}); and
+ * {@link #isCompletedAbnormally} is true if a task was either
+ * cancelled or encountered an exception, in which case {@link
+ * #getException} will return either the encountered exception or
+ * {@link java.util.concurrent.CancellationException}.
+ *
+ * <p>The ForkJoinTask class is not usually directly subclassed.
+ * Instead, you subclass one of the abstract classes that support a
+ * particular style of fork/join processing, typically {@link
+ * RecursiveAction} for most computations that do not return results,
+ * {@link RecursiveTask} for those that do, and {@link
+ * CountedCompleter} for those in which completed actions trigger
+ * other actions.  Normally, a concrete ForkJoinTask subclass declares
+ * fields comprising its parameters, established in a constructor, and
+ * then defines a {@code compute} method that somehow uses the control
+ * methods supplied by this base class.
+ *
+ * <p>Method {@link #join} and its variants are appropriate for use
+ * only when completion dependencies are acyclic; that is, the
+ * parallel computation can be described as a directed acyclic graph
+ * (DAG). Otherwise, executions may encounter a form of deadlock as
+ * tasks cyclically wait for each other.  However, this framework
+ * supports other methods and techniques (for example the use of
+ * {@link Phaser}, {@link #helpQuiesce}, and {@link #complete}) that
+ * may be of use in constructing custom subclasses for problems that
+ * are not statically structured as DAGs. To support such usages, a
+ * ForkJoinTask may be atomically <em>tagged</em> with a {@code short}
+ * value using {@link #setForkJoinTaskTag} or {@link
+ * #compareAndSetForkJoinTaskTag} and checked using {@link
+ * #getForkJoinTaskTag}. The ForkJoinTask implementation does not use
+ * these {@code protected} methods or tags for any purpose, but they
+ * may be of use in the construction of specialized subclasses.  For
+ * example, parallel graph traversals can use the supplied methods to
+ * avoid revisiting nodes/tasks that have already been processed.
+ * (Method names for tagging are bulky in part to encourage definition
+ * of methods that reflect their usage patterns.)
+ *
+ * <p>Most base support methods are {@code final}, to prevent
+ * overriding of implementations that are intrinsically tied to the
+ * underlying lightweight task scheduling framework.  Developers
+ * creating new basic styles of fork/join processing should minimally
+ * implement {@code protected} methods {@link #exec}, {@link
+ * #setRawResult}, and {@link #getRawResult}, while also introducing
+ * an abstract computational method that can be implemented in its
+ * subclasses, possibly relying on other {@code protected} methods
+ * provided by this class.
+ *
+ * <p>ForkJoinTasks should perform relatively small amounts of
+ * computation. Large tasks should be split into smaller subtasks,
+ * usually via recursive decomposition. As a very rough rule of thumb,
+ * a task should perform more than 100 and less than 10000 basic
+ * computational steps, and should avoid indefinite looping. If tasks
+ * are too big, then parallelism cannot improve throughput. If too
+ * small, then memory and internal task maintenance overhead may
+ * overwhelm processing.
+ *
+ * <p>This class provides {@code adapt} methods for {@link Runnable}
+ * and {@link Callable}, that may be of use when mixing execution of
+ * {@code ForkJoinTasks} with other kinds of tasks. When all tasks are
+ * of this form, consider using a pool constructed in <em>asyncMode</em>.
+ *
+ * <p>ForkJoinTasks are {@code Serializable}, which enables them to be
+ * used in extensions such as remote execution frameworks. It is
+ * sensible to serialize tasks only before or after, but not during,
+ * execution. Serialization is not relied on during execution itself.
+ *
+ * @since 1.7
+ * @author Doug Lea
+ */
+@SuppressWarnings("all")
+public abstract class ForkJoinTask<V> implements Future<V>, Serializable {
+
+    /*
+     * See the internal documentation of class ForkJoinPool for a
+     * general implementation overview.  ForkJoinTasks are mainly
+     * responsible for maintaining their "status" field amidst relays
+     * to methods in ForkJoinWorkerThread and ForkJoinPool.
+     *
+     * The methods of this class are more-or-less layered into
+     * (1) basic status maintenance
+     * (2) execution and awaiting completion
+     * (3) user-level methods that additionally report results.
+     * This is sometimes hard to see because this file orders exported
+     * methods in a way that flows well in javadocs.
+     */
+
+    /*
+     * The status field holds run control status bits packed into a
+     * single int to minimize footprint and to ensure atomicity (via
+     * CAS).  Status is initially zero, and takes on nonnegative
+     * values until completed, upon which status (anded with
+     * DONE_MASK) holds value NORMAL, CANCELLED, or EXCEPTIONAL. Tasks
+     * undergoing blocking waits by other threads have the SIGNAL bit
+     * set.  Completion of a stolen task with SIGNAL set awakens any
+     * waiters via notifyAll. Even though suboptimal for some
+     * purposes, we use basic builtin wait/notify to take advantage of
+     * "monitor inflation" in JVMs that we would otherwise need to
+     * emulate to avoid adding further per-task bookkeeping overhead.
+     * We want these monitors to be "fat", i.e., not use biasing or
+     * thin-lock techniques, so use some odd coding idioms that tend
+     * to avoid them, mainly by arranging that every synchronized
+     * block performs a wait, notifyAll or both.
+     *
+     * These control bits occupy only (some of) the upper half (16
+     * bits) of status field. The lower bits are used for user-defined
+     * tags.
+     */
+
+    /** The run status of this task */
+    volatile int status; // accessed directly by pool and workers
+    static final int DONE_MASK   = 0xf0000000;  // mask out non-completion bits
+    static final int NORMAL      = 0xf0000000;  // must be negative
+    static final int CANCELLED   = 0xc0000000;  // must be < NORMAL
+    static final int EXCEPTIONAL = 0x80000000;  // must be < CANCELLED
+    static final int SIGNAL      = 0x00010000;  // must be >= 1 << 16
+    static final int SMASK       = 0x0000ffff;  // short bits for tags
+
+    /**
+     * Marks completion and wakes up threads waiting to join this
+     * task.
+     *
+     * @param completion one of NORMAL, CANCELLED, EXCEPTIONAL
+     * @return completion status on exit
+     */
+    private int setCompletion(int completion) {
+        for (int s;;) {
+            if ((s = status) < 0)
+                return s;
+            if (U.compareAndSwapInt(this, STATUS, s, s | completion)) {
+                if ((s >>> 16) != 0)
+                    synchronized (this) { notifyAll(); }
+                return completion;
+            }
+        }
+    }
+
+    /**
+     * Primary execution method for stolen tasks. Unless done, calls
+     * exec and records status if completed, but doesn't wait for
+     * completion otherwise.
+     *
+     * @return status on exit from this method
+     */
+    final int doExec() {
+        int s; boolean completed;
+        if ((s = status) >= 0) {
+            try {
+                completed = exec();
+            } catch (Throwable rex) {
+                return setExceptionalCompletion(rex);
+            }
+            if (completed)
+                s = setCompletion(NORMAL);
+        }
+        return s;
+    }
+
+    /**
+     * Tries to set SIGNAL status unless already completed. Used by
+     * ForkJoinPool. Other variants are directly incorporated into
+     * externalAwaitDone etc.
+     *
+     * @return true if successful
+     */
+    final boolean trySetSignal() {
+        int s = status;
+        return s >= 0 && U.compareAndSwapInt(this, STATUS, s, s | SIGNAL);
+    }
+
+    /**
+     * Blocks a non-worker-thread until completion.
+     * @return status upon completion
+     */
+    private int externalAwaitDone() {
+        int s;
+        ForkJoinPool cp = ForkJoinPool.common;
+        if ((s = status) >= 0) {
+            if (cp != null) {
+                if (this instanceof CountedCompleter)
+                    s = cp.externalHelpComplete((CountedCompleter<?>)this);
+                else if (cp.tryExternalUnpush(this))
+                    s = doExec();
+            }
+            if (s >= 0 && (s = status) >= 0) {
+                boolean interrupted = false;
+                do {
+                    if (U.compareAndSwapInt(this, STATUS, s, s | SIGNAL)) {
+                        synchronized (this) {
+                            if (status >= 0) {
+                                try {
+                                    wait();
+                                } catch (InterruptedException ie) {
+                                    interrupted = true;
+                                }
+                            }
+                            else
+                                notifyAll();
+                        }
+                    }
+                } while ((s = status) >= 0);
+                if (interrupted)
+                    Thread.currentThread().interrupt();
+            }
+        }
+        return s;
+    }
+
+    /**
+     * Blocks a non-worker-thread until completion or interruption.
+     */
+    private int externalInterruptibleAwaitDone() throws InterruptedException {
+        int s;
+        ForkJoinPool cp = ForkJoinPool.common;
+        if (Thread.interrupted())
+            throw new InterruptedException();
+        if ((s = status) >= 0 && cp != null) {
+            if (this instanceof CountedCompleter)
+                cp.externalHelpComplete((CountedCompleter<?>)this);
+            else if (cp.tryExternalUnpush(this))
+                doExec();
+        }
+        while ((s = status) >= 0) {
+            if (U.compareAndSwapInt(this, STATUS, s, s | SIGNAL)) {
+                synchronized (this) {
+                    if (status >= 0)
+                        wait();
+                    else
+                        notifyAll();
+                }
+            }
+        }
+        return s;
+    }
+
+
+    /**
+     * Implementation for join, get, quietlyJoin. Directly handles
+     * only cases of already-completed, external wait, and
+     * unfork+exec.  Others are relayed to ForkJoinPool.awaitJoin.
+     *
+     * @return status upon completion
+     */
+    private int doJoin() {
+        int s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;
+        return (s = status) < 0 ? s :
+                ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ?
+                        (w = (wt = (ForkJoinWorkerThread)t).workQueue).
+                                tryUnpush(this) && (s = doExec()) < 0 ? s :
+                                wt.pool.awaitJoin(w, this) :
+                        externalAwaitDone();
+    }
+
+    /**
+     * Implementation for invoke, quietlyInvoke.
+     *
+     * @return status upon completion
+     */
+    private int doInvoke() {
+        int s; Thread t; ForkJoinWorkerThread wt;
+        return (s = doExec()) < 0 ? s :
+                ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ?
+                        (wt = (ForkJoinWorkerThread)t).pool.awaitJoin(wt.workQueue, this) :
+                        externalAwaitDone();
+    }
+
+    // Exception table support
+
+    /**
+     * Table of exceptions thrown by tasks, to enable reporting by
+     * callers. Because exceptions are rare, we don't directly keep
+     * them with task objects, but instead use a weak ref table.  Note
+     * that cancellation exceptions don't appear in the table, but are
+     * instead recorded as status values.
+     *
+     * Note: These statics are initialized below in static block.
+     */
+    private static final ExceptionNode[] exceptionTable;
+    private static final ReentrantLock exceptionTableLock;
+    private static final ReferenceQueue<Object> exceptionTableRefQueue;
+
+    /**
+     * Fixed capacity for exceptionTable.
+     */
+    private static final int EXCEPTION_MAP_CAPACITY = 32;
+
+    /**
+     * Key-value nodes for exception table.  The chained hash table
+     * uses identity comparisons, full locking, and weak references
+     * for keys. The table has a fixed capacity because it only
+     * maintains task exceptions long enough for joiners to access
+     * them, so should never become very large for sustained
+     * periods. However, since we do not know when the last joiner
+     * completes, we must use weak references and expunge them. We do
+     * so on each operation (hence full locking). Also, some thread in
+     * any ForkJoinPool will call helpExpungeStaleExceptions when its
+     * pool becomes isQuiescent.
+     */
+    static final class ExceptionNode extends WeakReference<ForkJoinTask<?>> {
+        final Throwable ex;
+        ExceptionNode next;
+        final long thrower;  // use id not ref to avoid weak cycles
+        ExceptionNode(ForkJoinTask<?> task, Throwable ex, ExceptionNode next) {
+            super(task, exceptionTableRefQueue);
+            this.ex = ex;
+            this.next = next;
+            this.thrower = Thread.currentThread().getId();
+        }
+    }
+
+    /**
+     * Records exception and sets status.
+     *
+     * @return status on exit
+     */
+    final int recordExceptionalCompletion(Throwable ex) {
+        int s;
+        if ((s = status) >= 0) {
+            int h = System.identityHashCode(this);
+            final ReentrantLock lock = exceptionTableLock;
+            lock.lock();
+            try {
+                expungeStaleExceptions();
+                ExceptionNode[] t = exceptionTable;
+                int i = h & (t.length - 1);
+                for (ExceptionNode e = t[i]; ; e = e.next) {
+                    if (e == null) {
+                        t[i] = new ExceptionNode(this, ex, t[i]);
+                        break;
+                    }
+                    if (e.get() == this) // already present
+                        break;
+                }
+            } finally {
+                lock.unlock();
+            }
+            s = setCompletion(EXCEPTIONAL);
+        }
+        return s;
+    }
+
+    /**
+     * Records exception and possibly propagates.
+     *
+     * @return status on exit
+     */
+    private int setExceptionalCompletion(Throwable ex) {
+        int s = recordExceptionalCompletion(ex);
+        if ((s & DONE_MASK) == EXCEPTIONAL)
+            internalPropagateException(ex);
+        return s;
+    }
+
+    /**
+     * Hook for exception propagation support for tasks with completers.
+     */
+    void internalPropagateException(Throwable ex) {
+    }
+
+    /**
+     * Cancels, ignoring any exceptions thrown by cancel. Used during
+     * worker and pool shutdown. Cancel is spec'ed not to throw any
+     * exceptions, but if it does anyway, we have no recourse during
+     * shutdown, so guard against this case.
+     */
+    static final void cancelIgnoringExceptions(ForkJoinTask<?> t) {
+        if (t != null && t.status >= 0) {
+            try {
+                t.cancel(false);
+            } catch (Throwable ignore) {
+            }
+        }
+    }
+
+    /**
+     * Removes exception node and clears status.
+     */
+    private void clearExceptionalCompletion() {
+        int h = System.identityHashCode(this);
+        final ReentrantLock lock = exceptionTableLock;
+        lock.lock();
+        try {
+            ExceptionNode[] t = exceptionTable;
+            int i = h & (t.length - 1);
+            ExceptionNode e = t[i];
+            ExceptionNode pred = null;
+            while (e != null) {
+                ExceptionNode next = e.next;
+                if (e.get() == this) {
+                    if (pred == null)
+                        t[i] = next;
+                    else
+                        pred.next = next;
+                    break;
+                }
+                pred = e;
+                e = next;
+            }
+            expungeStaleExceptions();
+            status = 0;
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /**
+     * Returns a rethrowable exception for the given task, if
+     * available. To provide accurate stack traces, if the exception
+     * was not thrown by the current thread, we try to create a new
+     * exception of the same type as the one thrown, but with the
+     * recorded exception as its cause. If there is no such
+     * constructor, we instead try to use a no-arg constructor,
+     * followed by initCause, to the same effect. If none of these
+     * apply, or any fail due to other exceptions, we return the
+     * recorded exception, which is still correct, although it may
+     * contain a misleading stack trace.
+     *
+     * @return the exception, or null if none
+     */
+    private Throwable getThrowableException() {
+        if ((status & DONE_MASK) != EXCEPTIONAL)
+            return null;
+        int h = System.identityHashCode(this);
+        ExceptionNode e;
+        final ReentrantLock lock = exceptionTableLock;
+        lock.lock();
+        try {
+            expungeStaleExceptions();
+            ExceptionNode[] t = exceptionTable;
+            e = t[h & (t.length - 1)];
+            while (e != null && e.get() != this)
+                e = e.next;
+        } finally {
+            lock.unlock();
+        }
+        Throwable ex;
+        if (e == null || (ex = e.ex) == null)
+            return null;
+        if (false && e.thrower != Thread.currentThread().getId()) {
+            Class<? extends Throwable> ec = ex.getClass();
+            try {
+                Constructor<?> noArgCtor = null;
+                Constructor<?>[] cs = ec.getConstructors();// public ctors only
+                for (int i = 0; i < cs.length; ++i) {
+                    Constructor<?> c = cs[i];
+                    Class<?>[] ps = c.getParameterTypes();
+                    if (ps.length == 0)
+                        noArgCtor = c;
+                    else if (ps.length == 1 && ps[0] == Throwable.class)
+                        return (Throwable)(c.newInstance(ex));
+                }
+                if (noArgCtor != null) {
+                    Throwable wx = (Throwable)(noArgCtor.newInstance());
+                    wx.initCause(ex);
+                    return wx;
+                }
+            } catch (Exception ignore) {
+            }
+        }
+        return ex;
+    }
+
+    /**
+     * Poll stale refs and remove them. Call only while holding lock.
+     */
+    private static void expungeStaleExceptions() {
+        for (Object x; (x = exceptionTableRefQueue.poll()) != null;) {
+            if (x instanceof ExceptionNode) {
+                ForkJoinTask<?> key = ((ExceptionNode)x).get();
+                ExceptionNode[] t = exceptionTable;
+                int i = System.identityHashCode(key) & (t.length - 1);
+                ExceptionNode e = t[i];
+                ExceptionNode pred = null;
+                while (e != null) {
+                    ExceptionNode next = e.next;
+                    if (e == x) {
+                        if (pred == null)
+                            t[i] = next;
+                        else
+                            pred.next = next;
+                        break;
+                    }
+                    pred = e;
+                    e = next;
+                }
+            }
+        }
+    }
+
+    /**
+     * If lock is available, poll stale refs and remove them.
+     * Called from ForkJoinPool when pools become quiescent.
+     */
+    static final void helpExpungeStaleExceptions() {
+        final ReentrantLock lock = exceptionTableLock;
+        if (lock.tryLock()) {
+            try {
+                expungeStaleExceptions();
+            } finally {
+                lock.unlock();
+            }
+        }
+    }
+
+    /**
+     * A version of "sneaky throw" to relay exceptions
+     */
+    static void rethrow(Throwable ex) {
+        if (ex != null)
+            ForkJoinTask.<RuntimeException>uncheckedThrow(ex);
+    }
+
+    /**
+     * The sneaky part of sneaky throw, relying on generics
+     * limitations to evade compiler complaints about rethrowing
+     * unchecked exceptions
+     */
+    @SuppressWarnings("unchecked") static <T extends Throwable>
+    void uncheckedThrow(Throwable t) throws T {
+        throw (T)t; // rely on vacuous cast
+    }
+
+    /**
+     * Throws exception, if any, associated with the given status.
+     */
+    private void reportException(int s) {
+        if (s == CANCELLED)
+            throw new CancellationException();
+        if (s == EXCEPTIONAL)
+            rethrow(getThrowableException());
+    }
+
+    // public methods
+
+    /**
+     * Arranges to asynchronously execute this task in the pool the
+     * current task is running in, if applicable, or using the {@link
+     * ForkJoinPool#commonPool()} if not {@link #inForkJoinPool}.  While
+     * it is not necessarily enforced, it is a usage error to fork a
+     * task more than once unless it has completed and been
+     * reinitialized.  Subsequent modifications to the state of this
+     * task or any data it operates on are not necessarily
+     * consistently observable by any thread other than the one
+     * executing it unless preceded by a call to {@link #join} or
+     * related methods, or a call to {@link #isDone} returning {@code
+     * true}.
+     *
+     * @return {@code this}, to simplify usage
+     */
+    public final ForkJoinTask<V> fork() {
+        Thread t;
+        if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread)
+            ((ForkJoinWorkerThread)t).workQueue.push(this);
+        else
+            ForkJoinPool.common.externalPush(this);
+        return this;
+    }
+
+    /**
+     * Returns the result of the computation when it {@link #isDone is
+     * done}.  This method differs from {@link #get()} in that
+     * abnormal completion results in {@code RuntimeException} or
+     * {@code Error}, not {@code ExecutionException}, and that
+     * interrupts of the calling thread do <em>not</em> cause the
+     * method to abruptly return by throwing {@code
+     * InterruptedException}.
+     *
+     * @return the computed result
+     */
+    public final V join() {
+        int s;
+        if ((s = doJoin() & DONE_MASK) != NORMAL)
+            reportException(s);
+        return getRawResult();
+    }
+
+    /**
+     * Commences performing this task, awaits its completion if
+     * necessary, and returns its result, or throws an (unchecked)
+     * {@code RuntimeException} or {@code Error} if the underlying
+     * computation did so.
+     *
+     * @return the computed result
+     */
+    public final V invoke() {
+        int s;
+        if ((s = doInvoke() & DONE_MASK) != NORMAL)
+            reportException(s);
+        return getRawResult();
+    }
+
+    /**
+     * Forks the given tasks, returning when {@code isDone} holds for
+     * each task or an (unchecked) exception is encountered, in which
+     * case the exception is rethrown. If more than one task
+     * encounters an exception, then this method throws any one of
+     * these exceptions. If any task encounters an exception, the
+     * other may be cancelled. However, the execution status of
+     * individual tasks is not guaranteed upon exceptional return. The
+     * status of each task may be obtained using {@link
+     * #getException()} and related methods to check if they have been
+     * cancelled, completed normally or exceptionally, or left
+     * unprocessed.
+     *
+     * @param t1 the first task
+     * @param t2 the second task
+     * @throws NullPointerException if any task is null
+     */
+    public static void invokeAll(ForkJoinTask<?> t1, ForkJoinTask<?> t2) {
+        int s1, s2;
+        t2.fork();
+        if ((s1 = t1.doInvoke() & DONE_MASK) != NORMAL)
+            t1.reportException(s1);
+        if ((s2 = t2.doJoin() & DONE_MASK) != NORMAL)
+            t2.reportException(s2);
+    }
+
+    /**
+     * Forks the given tasks, returning when {@code isDone} holds for
+     * each task or an (unchecked) exception is encountered, in which
+     * case the exception is rethrown. If more than one task
+     * encounters an exception, then this method throws any one of
+     * these exceptions. If any task encounters an exception, others
+     * may be cancelled. However, the execution status of individual
+     * tasks is not guaranteed upon exceptional return. The status of
+     * each task may be obtained using {@link #getException()} and
+     * related methods to check if they have been cancelled, completed
+     * normally or exceptionally, or left unprocessed.
+     *
+     * @param tasks the tasks
+     * @throws NullPointerException if any task is null
+     */
+    public static void invokeAll(ForkJoinTask<?>... tasks) {
+        Throwable ex = null;
+        int last = tasks.length - 1;
+        for (int i = last; i >= 0; --i) {
+            ForkJoinTask<?> t = tasks[i];
+            if (t == null) {
+                if (ex == null)
+                    ex = new NullPointerException();
+            }
+            else if (i != 0)
+                t.fork();
+            else if (t.doInvoke() < NORMAL && ex == null)
+                ex = t.getException();
+        }
+        for (int i = 1; i <= last; ++i) {
+            ForkJoinTask<?> t = tasks[i];
+            if (t != null) {
+                if (ex != null)
+                    t.cancel(false);
+                else if (t.doJoin() < NORMAL)
+                    ex = t.getException();
+            }
+        }
+        if (ex != null)
+            rethrow(ex);
+    }
+
+    /**
+     * Forks all tasks in the specified collection, returning when
+     * {@code isDone} holds for each task or an (unchecked) exception
+     * is encountered, in which case the exception is rethrown. If
+     * more than one task encounters an exception, then this method
+     * throws any one of these exceptions. If any task encounters an
+     * exception, others may be cancelled. However, the execution
+     * status of individual tasks is not guaranteed upon exceptional
+     * return. The status of each task may be obtained using {@link
+     * #getException()} and related methods to check if they have been
+     * cancelled, completed normally or exceptionally, or left
+     * unprocessed.
+     *
+     * @param tasks the collection of tasks
+     * @return the tasks argument, to simplify usage
+     * @throws NullPointerException if tasks or any element are null
+     */
+    public static <T extends ForkJoinTask<?>> Collection<T> invokeAll(Collection<T> tasks) {
+        if (!(tasks instanceof RandomAccess) || !(tasks instanceof List<?>)) {
+            invokeAll(tasks.toArray(new ForkJoinTask<?>[tasks.size()]));
+            return tasks;
+        }
+        @SuppressWarnings("unchecked")
+        List<? extends ForkJoinTask<?>> ts =
+                (List<? extends ForkJoinTask<?>>) tasks;
+        Throwable ex = null;
+        int last = ts.size() - 1;
+        for (int i = last; i >= 0; --i) {
+            ForkJoinTask<?> t = ts.get(i);
+            if (t == null) {
+                if (ex == null)
+                    ex = new NullPointerException();
+            }
+            else if (i != 0)
+                t.fork();
+            else if (t.doInvoke() < NORMAL && ex == null)
+                ex = t.getException();
+        }
+        for (int i = 1; i <= last; ++i) {
+            ForkJoinTask<?> t = ts.get(i);
+            if (t != null) {
+                if (ex != null)
+                    t.cancel(false);
+                else if (t.doJoin() < NORMAL)
+                    ex = t.getException();
+            }
+        }
+        if (ex != null)
+            rethrow(ex);
+        return tasks;
+    }
+
+    /**
+     * Attempts to cancel execution of this task. This attempt will
+     * fail if the task has already completed or could not be
+     * cancelled for some other reason. If successful, and this task
+     * has not started when {@code cancel} is called, execution of
+     * this task is suppressed. After this method returns
+     * successfully, unless there is an intervening call to {@link
+     * #reinitialize}, subsequent calls to {@link #isCancelled},
+     * {@link #isDone}, and {@code cancel} will return {@code true}
+     * and calls to {@link #join} and related methods will result in
+     * {@code CancellationException}.
+     *
+     * <p>This method may be overridden in subclasses, but if so, must
+     * still ensure that these properties hold. In particular, the
+     * {@code cancel} method itself must not throw exceptions.
+     *
+     * <p>This method is designed to be invoked by <em>other</em>
+     * tasks. To terminate the current task, you can just return or
+     * throw an unchecked exception from its computation method, or
+     * invoke {@link #completeExceptionally(Throwable)}.
+     *
+     * @param mayInterruptIfRunning this value has no effect in the
+     * default implementation because interrupts are not used to
+     * control cancellation.
+     *
+     * @return {@code true} if this task is now cancelled
+     */
+    public boolean cancel(boolean mayInterruptIfRunning) {
+        return (setCompletion(CANCELLED) & DONE_MASK) == CANCELLED;
+    }
+
+    public final boolean isDone() {
+        return status < 0;
+    }
+
+    public final boolean isCancelled() {
+        return (status & DONE_MASK) == CANCELLED;
+    }
+
+    /**
+     * Returns {@code true} if this task threw an exception or was cancelled.
+     *
+     * @return {@code true} if this task threw an exception or was cancelled
+     */
+    public final boolean isCompletedAbnormally() {
+        return status < NORMAL;
+    }
+
+    /**
+     * Returns {@code true} if this task completed without throwing an
+     * exception and was not cancelled.
+     *
+     * @return {@code true} if this task completed without throwing an
+     * exception and was not cancelled
+     */
+    public final boolean isCompletedNormally() {
+        return (status & DONE_MASK) == NORMAL;
+    }
+
+    /**
+     * Returns the exception thrown by the base computation, or a
+     * {@code CancellationException} if cancelled, or {@code null} if
+     * none or if the method has not yet completed.
+     *
+     * @return the exception, or {@code null} if none
+     */
+    public final Throwable getException() {
+        int s = status & DONE_MASK;
+        return ((s >= NORMAL)    ? null :
+                (s == CANCELLED) ? new CancellationException() :
+                        getThrowableException());
+    }
+
+    /**
+     * Completes this task abnormally, and if not already aborted or
+     * cancelled, causes it to throw the given exception upon
+     * {@code join} and related operations. This method may be used
+     * to induce exceptions in asynchronous tasks, or to force
+     * completion of tasks that would not otherwise complete.  Its use
+     * in other situations is discouraged.  This method is
+     * overridable, but overridden versions must invoke {@code super}
+     * implementation to maintain guarantees.
+     *
+     * @param ex the exception to throw. If this exception is not a
+     * {@code RuntimeException} or {@code Error}, the actual exception
+     * thrown will be a {@code RuntimeException} with cause {@code ex}.
+     */
+    public void completeExceptionally(Throwable ex) {
+        setExceptionalCompletion((ex instanceof RuntimeException) ||
+                (ex instanceof Error) ? ex :
+                new RuntimeException(ex));
+    }
+
+    /**
+     * Completes this task, and if not already aborted or cancelled,
+     * returning the given value as the result of subsequent
+     * invocations of {@code join} and related operations. This method
+     * may be used to provide results for asynchronous tasks, or to
+     * provide alternative handling for tasks that would not otherwise
+     * complete normally. Its use in other situations is
+     * discouraged. This method is overridable, but overridden
+     * versions must invoke {@code super} implementation to maintain
+     * guarantees.
+     *
+     * @param value the result value for this task
+     */
+    public void complete(V value) {
+        try {
+            setRawResult(value);
+        } catch (Throwable rex) {
+            setExceptionalCompletion(rex);
+            return;
+        }
+        setCompletion(NORMAL);
+    }
+
+    /**
+     * Completes this task normally without setting a value. The most
+     * recent value established by {@link #setRawResult} (or {@code
+     * null} by default) will be returned as the result of subsequent
+     * invocations of {@code join} and related operations.
+     *
+     * @since 1.8
+     */
+    public final void quietlyComplete() {
+        setCompletion(NORMAL);
+    }
+
+    /**
+     * Waits if necessary for the computation to complete, and then
+     * retrieves its result.
+     *
+     * @return the computed result
+     * @throws CancellationException if the computation was cancelled
+     * @throws ExecutionException if the computation threw an
+     * exception
+     * @throws InterruptedException if the current thread is not a
+     * member of a ForkJoinPool and was interrupted while waiting
+     */
+    public final V get() throws InterruptedException, ExecutionException {
+        int s = (Thread.currentThread() instanceof ForkJoinWorkerThread) ?
+                doJoin() : externalInterruptibleAwaitDone();
+        Throwable ex;
+        if ((s &= DONE_MASK) == CANCELLED)
+            throw new CancellationException();
+        if (s == EXCEPTIONAL && (ex = getThrowableException()) != null)
+            throw new ExecutionException(ex);
+        return getRawResult();
+    }
+
+    /**
+     * Waits if necessary for at most the given time for the computation
+     * to complete, and then retrieves its result, if available.
+     *
+     * @param timeout the maximum time to wait
+     * @param unit the time unit of the timeout argument
+     * @return the computed result
+     * @throws CancellationException if the computation was cancelled
+     * @throws ExecutionException if the computation threw an
+     * exception
+     * @throws InterruptedException if the current thread is not a
+     * member of a ForkJoinPool and was interrupted while waiting
+     * @throws TimeoutException if the wait timed out
+     */
+    public final V get(long timeout, TimeUnit unit)
+            throws InterruptedException, ExecutionException, TimeoutException {
+        if (Thread.interrupted())
+            throw new InterruptedException();
+        // Messy in part because we measure in nanosecs, but wait in millisecs
+        int s; long ms;
+        long ns = unit.toNanos(timeout);
+        ForkJoinPool cp;
+        if ((s = status) >= 0 && ns > 0L) {
+            long deadline = System.nanoTime() + ns;
+            ForkJoinPool p = null;
+            ForkJoinPool.WorkQueue w = null;
+            Thread t = Thread.currentThread();
+            if (t instanceof ForkJoinWorkerThread) {
+                ForkJoinWorkerThread wt = (ForkJoinWorkerThread)t;
+                p = wt.pool;
+                w = wt.workQueue;
+                p.helpJoinOnce(w, this); // no retries on failure
+            }
+            else if ((cp = ForkJoinPool.common) != null) {
+                if (this instanceof CountedCompleter)
+                    cp.externalHelpComplete((CountedCompleter<?>)this);
+                else if (cp.tryExternalUnpush(this))
+                    doExec();
+            }
+            boolean canBlock = false;
+            boolean interrupted = false;
+            try {
+                while ((s = status) >= 0) {
+                    if (w != null && w.qlock < 0)
+                        cancelIgnoringExceptions(this);
+                    else if (!canBlock) {
+                        if (p == null || p.tryCompensate(p.ctl))
+                            canBlock = true;
+                    }
+                    else {
+                        if ((ms = TimeUnit.NANOSECONDS.toMillis(ns)) > 0L &&
+                                U.compareAndSwapInt(this, STATUS, s, s | SIGNAL)) {
+                            synchronized (this) {
+                                if (status >= 0) {
+                                    try {
+                                        wait(ms);
+                                    } catch (InterruptedException ie) {
+                                        if (p == null)
+                                            interrupted = true;
+                                    }
+                                }
+                                else
+                                    notifyAll();
+                            }
+                        }
+                        if ((s = status) < 0 || interrupted ||
+                                (ns = deadline - System.nanoTime()) <= 0L)
+                            break;
+                    }
+                }
+            } finally {
+                if (p != null && canBlock)
+                    p.incrementActiveCount();
+            }
+            if (interrupted)
+                throw new InterruptedException();
+        }
+        if ((s &= DONE_MASK) != NORMAL) {
+            Throwable ex;
+            if (s == CANCELLED)
+                throw new CancellationException();
+            if (s != EXCEPTIONAL)
+                throw new TimeoutException();
+            if ((ex = getThrowableException()) != null)
+                throw new ExecutionException(ex);
+        }
+        return getRawResult();
+    }
+
+    /**
+     * Joins this task, without returning its result or throwing its
+     * exception. This method may be useful when processing
+     * collections of tasks when some have been cancelled or otherwise
+     * known to have aborted.
+     */
+    public final void quietlyJoin() {
+        doJoin();
+    }
+
+    /**
+     * Commences performing this task and awaits its completion if
+     * necessary, without returning its result or throwing its
+     * exception.
+     */
+    public final void quietlyInvoke() {
+        doInvoke();
+    }
+
+    /**
+     * Possibly executes tasks until the pool hosting the current task
+     * {@link ForkJoinPool#isQuiescent is quiescent}. This method may
+     * be of use in designs in which many tasks are forked, but none
+     * are explicitly joined, instead executing them until all are
+     * processed.
+     */
+    public static void helpQuiesce() {
+        Thread t;
+        if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) {
+            ForkJoinWorkerThread wt = (ForkJoinWorkerThread)t;
+            wt.pool.helpQuiescePool(wt.workQueue);
+        }
+        else
+            ForkJoinPool.quiesceCommonPool();
+    }
+
+    /**
+     * Resets the internal bookkeeping state of this task, allowing a
+     * subsequent {@code fork}. This method allows repeated reuse of
+     * this task, but only if reuse occurs when this task has either
+     * never been forked, or has been forked, then completed and all
+     * outstanding joins of this task have also completed. Effects
+     * under any other usage conditions are not guaranteed.
+     * This method may be useful when executing
+     * pre-constructed trees of subtasks in loops.
+     *
+     * <p>Upon completion of this method, {@code isDone()} reports
+     * {@code false}, and {@code getException()} reports {@code
+     * null}. However, the value returned by {@code getRawResult} is
+     * unaffected. To clear this value, you can invoke {@code
+     * setRawResult(null)}.
+     */
+    public void reinitialize() {
+        if ((status & DONE_MASK) == EXCEPTIONAL)
+            clearExceptionalCompletion();
+        else
+            status = 0;
+    }
+
+    /**
+     * Returns the pool hosting the current task execution, or null
+     * if this task is executing outside of any ForkJoinPool.
+     *
+     * @see #inForkJoinPool
+     * @return the pool, or {@code null} if none
+     */
+    public static ForkJoinPool getPool() {
+        Thread t = Thread.currentThread();
+        return (t instanceof ForkJoinWorkerThread) ?
+                ((ForkJoinWorkerThread) t).pool : null;
+    }
+
+    /**
+     * Returns {@code true} if the current thread is a {@link
+     * ForkJoinWorkerThread} executing as a ForkJoinPool computation.
+     *
+     * @return {@code true} if the current thread is a {@link
+     * ForkJoinWorkerThread} executing as a ForkJoinPool computation,
+     * or {@code false} otherwise
+     */
+    public static boolean inForkJoinPool() {
+        return Thread.currentThread() instanceof ForkJoinWorkerThread;
+    }
+
+    /**
+     * Tries to unschedule this task for execution. This method will
+     * typically (but is not guaranteed to) succeed if this task is
+     * the most recently forked task by the current thread, and has
+     * not commenced executing in another thread.  This method may be
+     * useful when arranging alternative local processing of tasks
+     * that could have been, but were not, stolen.
+     *
+     * @return {@code true} if unforked
+     */
+    public boolean tryUnfork() {
+        Thread t;
+        return (((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ?
+                ((ForkJoinWorkerThread)t).workQueue.tryUnpush(this) :
+                ForkJoinPool.common.tryExternalUnpush(this));
+    }
+
+    /**
+     * Returns an estimate of the number of tasks that have been
+     * forked by the current worker thread but not yet executed. This
+     * value may be useful for heuristic decisions about whether to
+     * fork other tasks.
+     *
+     * @return the number of tasks
+     */
+    public static int getQueuedTaskCount() {
+        Thread t; ForkJoinPool.WorkQueue q;
+        if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread)
+            q = ((ForkJoinWorkerThread)t).workQueue;
+        else
+            q = ForkJoinPool.commonSubmitterQueue();
+        return (q == null) ? 0 : q.queueSize();
+    }
+
+    /**
+     * Returns an estimate of how many more locally queued tasks are
+     * held by the current worker thread than there are other worker
+     * threads that might steal them, or zero if this thread is not
+     * operating in a ForkJoinPool. This value may be useful for
+     * heuristic decisions about whether to fork other tasks. In many
+     * usages of ForkJoinTasks, at steady state, each worker should
+     * aim to maintain a small constant surplus (for example, 3) of
+     * tasks, and to process computations locally if this threshold is
+     * exceeded.
+     *
+     * @return the surplus number of tasks, which may be negative
+     */
+    public static int getSurplusQueuedTaskCount() {
+        return ForkJoinPool.getSurplusQueuedTaskCount();
+    }
+
+    // Extension methods
+
+    /**
+     * Returns the result that would be returned by {@link #join}, even
+     * if this task completed abnormally, or {@code null} if this task
+     * is not known to have been completed.  This method is designed
+     * to aid debugging, as well as to support extensions. Its use in
+     * any other context is discouraged.
+     *
+     * @return the result, or {@code null} if not completed
+     */
+    public abstract V getRawResult();
+
+    /**
+     * Forces the given value to be returned as a result.  This method
+     * is designed to support extensions, and should not in general be
+     * called otherwise.
+     *
+     * @param value the value
+     */
+    protected abstract void setRawResult(V value);
+
+    /**
+     * Immediately performs the base action of this task and returns
+     * true if, upon return from this method, this task is guaranteed
+     * to have completed normally. This method may return false
+     * otherwise, to indicate that this task is not necessarily
+     * complete (or is not known to be complete), for example in
+     * asynchronous actions that require explicit invocations of
+     * completion methods. This method may also throw an (unchecked)
+     * exception to indicate abnormal exit. This method is designed to
+     * support extensions, and should not in general be called
+     * otherwise.
+     *
+     * @return {@code true} if this task is known to have completed normally
+     */
+    protected abstract boolean exec();
+
+    /**
+     * Returns, but does not unschedule or execute, a task queued by
+     * the current thread but not yet executed, if one is immediately
+     * available. There is no guarantee that this task will actually
+     * be polled or executed next. Conversely, this method may return
+     * null even if a task exists but cannot be accessed without
+     * contention with other threads.  This method is designed
+     * primarily to support extensions, and is unlikely to be useful
+     * otherwise.
+     *
+     * @return the next task, or {@code null} if none are available
+     */
+    protected static ForkJoinTask<?> peekNextLocalTask() {
+        Thread t; ForkJoinPool.WorkQueue q;
+        if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread)
+            q = ((ForkJoinWorkerThread)t).workQueue;
+        else
+            q = ForkJoinPool.commonSubmitterQueue();
+        return (q == null) ? null : q.peek();
+    }
+
+    /**
+     * Unschedules and returns, without executing, the next task
+     * queued by the current thread but not yet executed, if the
+     * current thread is operating in a ForkJoinPool.  This method is
+     * designed primarily to support extensions, and is unlikely to be
+     * useful otherwise.
+     *
+     * @return the next task, or {@code null} if none are available
+     */
+    protected static ForkJoinTask<?> pollNextLocalTask() {
+        Thread t;
+        return ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ?
+                ((ForkJoinWorkerThread)t).workQueue.nextLocalTask() :
+                null;
+    }
+
+    /**
+     * If the current thread is operating in a ForkJoinPool,
+     * unschedules and returns, without executing, the next task
+     * queued by the current thread but not yet executed, if one is
+     * available, or if not available, a task that was forked by some
+     * other thread, if available. Availability may be transient, so a
+     * {@code null} result does not necessarily imply quiescence of
+     * the pool this task is operating in.  This method is designed
+     * primarily to support extensions, and is unlikely to be useful
+     * otherwise.
+     *
+     * @return a task, or {@code null} if none are available
+     */
+    protected static ForkJoinTask<?> pollTask() {
+        Thread t; ForkJoinWorkerThread wt;
+        return ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ?
+                (wt = (ForkJoinWorkerThread)t).pool.nextTaskFor(wt.workQueue) :
+                null;
+    }
+
+    // tag operations
+
+    /**
+     * Returns the tag for this task.
+     *
+     * @return the tag for this task
+     * @since 1.8
+     */
+    public final short getForkJoinTaskTag() {
+        return (short)status;
+    }
+
+    /**
+     * Atomically sets the tag value for this task.
+     *
+     * @param tag the tag value
+     * @return the previous value of the tag
+     * @since 1.8
+     */
+    public final short setForkJoinTaskTag(short tag) {
+        for (int s;;) {
+            if (U.compareAndSwapInt(this, STATUS, s = status,
+                    (s & ~SMASK) | (tag & SMASK)))
+                return (short)s;
+        }
+    }
+
+    /**
+     * Atomically conditionally sets the tag value for this task.
+     * Among other applications, tags can be used as visit markers
+     * in tasks operating on graphs, as in methods that check: {@code
+     * if (task.compareAndSetForkJoinTaskTag((short)0, (short)1))}
+     * before processing, otherwise exiting because the node has
+     * already been visited.
+     *
+     * @param e the expected tag value
+     * @param tag the new tag value
+     * @return {@code true} if successful; i.e., the current value was
+     * equal to e and is now tag.
+     * @since 1.8
+     */
+    public final boolean compareAndSetForkJoinTaskTag(short e, short tag) {
+        for (int s;;) {
+            if ((short)(s = status) != e)
+                return false;
+            if (U.compareAndSwapInt(this, STATUS, s,
+                    (s & ~SMASK) | (tag & SMASK)))
+                return true;
+        }
+    }
+
+    /**
+     * Adaptor for Runnables. This implements RunnableFuture
+     * to be compliant with AbstractExecutorService constraints
+     * when used in ForkJoinPool.
+     */
+    static final class AdaptedRunnable<T> extends ForkJoinTask<T>
+            implements RunnableFuture<T> {
+        final Runnable runnable;
+        T result;
+        AdaptedRunnable(Runnable runnable, T result) {
+            if (runnable == null) throw new NullPointerException();
+            this.runnable = runnable;
+            this.result = result; // OK to set this even before completion
+        }
+        public final T getRawResult() { return result; }
+        public final void setRawResult(T v) { result = v; }
+        public final boolean exec() { runnable.run(); return true; }
+        public final void run() { invoke(); }
+        private static final long serialVersionUID = 5232453952276885070L;
+    }
+
+    /**
+     * Adaptor for Runnables without results
+     */
+    static final class AdaptedRunnableAction extends ForkJoinTask<Void>
+            implements RunnableFuture<Void> {
+        final Runnable runnable;
+        AdaptedRunnableAction(Runnable runnable) {
+            if (runnable == null) throw new NullPointerException();
+            this.runnable = runnable;
+        }
+        public final Void getRawResult() { return null; }
+        public final void setRawResult(Void v) { }
+        public final boolean exec() { runnable.run(); return true; }
+        public final void run() { invoke(); }
+        private static final long serialVersionUID = 5232453952276885070L;
+    }
+
+    /**
+     * Adaptor for Runnables in which failure forces worker exception
+     */
+    static final class RunnableExecuteAction extends ForkJoinTask<Void> {
+        final Runnable runnable;
+        RunnableExecuteAction(Runnable runnable) {
+            if (runnable == null) throw new NullPointerException();
+            this.runnable = runnable;
+        }
+        public final Void getRawResult() { return null; }
+        public final void setRawResult(Void v) { }
+        public final boolean exec() { runnable.run(); return true; }
+        void internalPropagateException(Throwable ex) {
+            rethrow(ex); // rethrow outside exec() catches.
+        }
+        private static final long serialVersionUID = 5232453952276885070L;
+    }
+
+    /**
+     * Adaptor for Callables
+     */
+    static final class AdaptedCallable<T> extends ForkJoinTask<T>
+            implements RunnableFuture<T> {
+        final Callable<? extends T> callable;
+        T result;
+        AdaptedCallable(Callable<? extends T> callable) {
+            if (callable == null) throw new NullPointerException();
+            this.callable = callable;
+        }
+        public final T getRawResult() { return result; }
+        public final void setRawResult(T v) { result = v; }
+        public final boolean exec() {
+            try {
+                result = callable.call();
+                return true;
+            } catch (Error err) {
+                throw err;
+            } catch (RuntimeException rex) {
+                throw rex;
+            } catch (Exception ex) {
+                throw new RuntimeException(ex);
+            }
+        }
+        public final void run() { invoke(); }
+        private static final long serialVersionUID = 2838392045355241008L;
+    }
+
+    /**
+     * Returns a new {@code ForkJoinTask} that performs the {@code run}
+     * method of the given {@code Runnable} as its action, and returns
+     * a null result upon {@link #join}.
+     *
+     * @param runnable the runnable action
+     * @return the task
+     */
+    public static ForkJoinTask<?> adapt(Runnable runnable) {
+        return new AdaptedRunnableAction(runnable);
+    }
+
+    /**
+     * Returns a new {@code ForkJoinTask} that performs the {@code run}
+     * method of the given {@code Runnable} as its action, and returns
+     * the given result upon {@link #join}.
+     *
+     * @param runnable the runnable action
+     * @param result the result upon completion
+     * @return the task
+     */
+    public static <T> ForkJoinTask<T> adapt(Runnable runnable, T result) {
+        return new AdaptedRunnable<T>(runnable, result);
+    }
+
+    /**
+     * Returns a new {@code ForkJoinTask} that performs the {@code call}
+     * method of the given {@code Callable} as its action, and returns
+     * its result upon {@link #join}, translating any checked exceptions
+     * encountered into {@code RuntimeException}.
+     *
+     * @param callable the callable action
+     * @return the task
+     */
+    public static <T> ForkJoinTask<T> adapt(Callable<? extends T> callable) {
+        return new AdaptedCallable<T>(callable);
+    }
+
+    // Serialization support
+
+    private static final long serialVersionUID = -7721805057305804111L;
+
+    /**
+     * Saves this task to a stream (that is, serializes it).
+     *
+     * @serialData the current run status and the exception thrown
+     * during execution, or {@code null} if none
+     */
+    private void writeObject(java.io.ObjectOutputStream s)
+            throws java.io.IOException {
+        s.defaultWriteObject();
+        s.writeObject(getException());
+    }
+
+    /**
+     * Reconstitutes this task from a stream (that is, deserializes it).
+     */
+    private void readObject(java.io.ObjectInputStream s)
+            throws java.io.IOException, ClassNotFoundException {
+        s.defaultReadObject();
+        Object ex = s.readObject();
+        if (ex != null)
+            setExceptionalCompletion((Throwable)ex);
+    }
+
+    // Unsafe mechanics
+    private static final sun.misc.Unsafe U;
+    private static final long STATUS;
+
+    static {
+        exceptionTableLock = new ReentrantLock();
+        exceptionTableRefQueue = new ReferenceQueue<Object>();
+        exceptionTable = new ExceptionNode[EXCEPTION_MAP_CAPACITY];
+        try {
+            U = getUnsafe();
+            Class<?> k = ForkJoinTask.class;
+            STATUS = U.objectFieldOffset
+                    (k.getDeclaredField("status"));
+        } catch (Exception e) {
+            throw new Error(e);
+        }
+    }
+
+    /**
+     * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.
+     * Replace with a simple call to Unsafe.getUnsafe when integrating
+     * into a jdk.
+     *
+     * @return a sun.misc.Unsafe
+     */
+    private static sun.misc.Unsafe getUnsafe() {
+        try {
+            return sun.misc.Unsafe.getUnsafe();
+        } catch (SecurityException tryReflectionInstead) {}
+        try {
+            return java.security.AccessController.doPrivileged
+                    (new java.security.PrivilegedExceptionAction<sun.misc.Unsafe>() {
+                        public sun.misc.Unsafe run() throws Exception {
+                            Class<sun.misc.Unsafe> k = sun.misc.Unsafe.class;
+                            for (java.lang.reflect.Field f : k.getDeclaredFields()) {
+                                f.setAccessible(true);
+                                Object x = f.get(null);
+                                if (k.isInstance(x))
+                                    return k.cast(x);
+                            }
+                            throw new NoSuchFieldError("the Unsafe");
+                        }});
+        } catch (java.security.PrivilegedActionException e) {
+            throw new RuntimeException("Could not initialize intrinsics",
+                    e.getCause());
+        }
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/internal/chmv8/ForkJoinWorkerThread.java b/api/src/main/java/org/asynchttpclient/internal/chmv8/ForkJoinWorkerThread.java
new file mode 100644
index 000000000..27c8a1eda
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/internal/chmv8/ForkJoinWorkerThread.java
@@ -0,0 +1,140 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+/*
+ * Written by Doug Lea with assistance from members of JCP JSR-166
+ * Expert Group and released to the public domain, as explained at
+ * http://creativecommons.org/publicdomain/zero/1.0/
+ */
+
+package org.asynchttpclient.internal.chmv8;
+
+
+/**
+ * A thread managed by a {@link ForkJoinPool}, which executes
+ * {@link ForkJoinTask}s.
+ * This class is subclassable solely for the sake of adding
+ * functionality -- there are no overridable methods dealing with
+ * scheduling or execution.  However, you can override initialization
+ * and termination methods surrounding the main task processing loop.
+ * If you do create such a subclass, you will also need to supply a
+ * custom {@link ForkJoinPool.ForkJoinWorkerThreadFactory} to
+ * {@linkplain ForkJoinPool#ForkJoinPool use it} in a {@code ForkJoinPool}.
+ *
+ * @since 1.7
+ * @author Doug Lea
+ */
+@SuppressWarnings("all")
+public class ForkJoinWorkerThread extends Thread {
+    /*
+     * ForkJoinWorkerThreads are managed by ForkJoinPools and perform
+     * ForkJoinTasks. For explanation, see the internal documentation
+     * of class ForkJoinPool.
+     *
+     * This class just maintains links to its pool and WorkQueue.  The
+     * pool field is set immediately upon construction, but the
+     * workQueue field is not set until a call to registerWorker
+     * completes. This leads to a visibility race, that is tolerated
+     * by requiring that the workQueue field is only accessed by the
+     * owning thread.
+     */
+
+    final ForkJoinPool pool;                // the pool this thread works in
+    final ForkJoinPool.WorkQueue workQueue; // work-stealing mechanics
+
+    /**
+     * Creates a ForkJoinWorkerThread operating in the given pool.
+     *
+     * @param pool the pool this thread works in
+     * @throws NullPointerException if pool is null
+     */
+    protected ForkJoinWorkerThread(ForkJoinPool pool) {
+        // Use a placeholder until a useful name can be set in registerWorker
+        super("aForkJoinWorkerThread");
+        this.pool = pool;
+        this.workQueue = pool.registerWorker(this);
+    }
+
+    /**
+     * Returns the pool hosting this thread.
+     *
+     * @return the pool
+     */
+    public ForkJoinPool getPool() {
+        return pool;
+    }
+
+    /**
+     * Returns the unique index number of this thread in its pool.
+     * The returned value ranges from zero to the maximum number of
+     * threads (minus one) that may exist in the pool, and does not
+     * change during the lifetime of the thread.  This method may be
+     * useful for applications that track status or collect results
+     * per-worker-thread rather than per-task.
+     *
+     * @return the index number
+     */
+    public int getPoolIndex() {
+        return workQueue.poolIndex >>> 1; // ignore odd/even tag bit
+    }
+
+    /**
+     * Initializes internal state after construction but before
+     * processing any tasks. If you override this method, you must
+     * invoke {@code super.onStart()} at the beginning of the method.
+     * Initialization requires care: Most fields must have legal
+     * default values, to ensure that attempted accesses from other
+     * threads work correctly even before this thread starts
+     * processing tasks.
+     */
+    protected void onStart() {
+    }
+
+    /**
+     * Performs cleanup associated with termination of this worker
+     * thread.  If you override this method, you must invoke
+     * {@code super.onTermination} at the end of the overridden method.
+     *
+     * @param exception the exception causing this thread to abort due
+     * to an unrecoverable error, or {@code null} if completed normally
+     */
+    protected void onTermination(Throwable exception) {
+    }
+
+    /**
+     * This method is required to be public, but should never be
+     * called explicitly. It performs the main run loop to execute
+     * {@link ForkJoinTask}s.
+     */
+    public void run() {
+        Throwable exception = null;
+        try {
+            onStart();
+            pool.runWorker(workQueue);
+        } catch (Throwable ex) {
+            exception = ex;
+        } finally {
+            try {
+                onTermination(exception);
+            } catch (Throwable ex) {
+                if (exception == null)
+                    exception = ex;
+            } finally {
+                pool.deregisterWorker(this, exception);
+            }
+        }
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/internal/chmv8/LongAdder.java b/api/src/main/java/org/asynchttpclient/internal/chmv8/LongAdder.java
new file mode 100644
index 000000000..67bf25c2b
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/internal/chmv8/LongAdder.java
@@ -0,0 +1,217 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+/*
+ * Written by Doug Lea with assistance from members of JCP JSR-166
+ * Expert Group and released to the public domain, as explained at
+ * http://creativecommons.org/publicdomain/zero/1.0/
+ */
+
+package org.asynchttpclient.internal.chmv8;
+
+import java.io.Serializable;
+import java.util.concurrent.atomic.AtomicLong;
+
+/**
+ * One or more variables that together maintain an initially zero
+ * {@code long} sum.  When updates (method {@link #add}) are contended
+ * across threads, the set of variables may grow dynamically to reduce
+ * contention. Method {@link #sum} (or, equivalently, {@link
+ * #longValue}) returns the current total combined across the
+ * variables maintaining the sum.
+ *
+ * <p>This class is usually preferable to {@link AtomicLong} when
+ * multiple threads update a common sum that is used for purposes such
+ * as collecting statistics, not for fine-grained synchronization
+ * control.  Under low update contention, the two classes have similar
+ * characteristics. But under high contention, expected throughput of
+ * this class is significantly higher, at the expense of higher space
+ * consumption.
+ *
+ * <p>This class extends {@link Number}, but does <em>not</em> define
+ * methods such as {@code equals}, {@code hashCode} and {@code
+ * compareTo} because instances are expected to be mutated, and so are
+ * not useful as collection keys.
+ *
+ * <p><em>jsr166e note: This class is targeted to be placed in
+ * java.util.concurrent.atomic.</em>
+ *
+ * @since 1.8
+ * @author Doug Lea
+ */
+@SuppressWarnings("all")
+public class LongAdder extends Striped64 implements Serializable {
+    private static final long serialVersionUID = 7249069246863182397L;
+
+    /**
+     * Version of plus for use in retryUpdate
+     */
+    final long fn(long v, long x) { return v + x; }
+
+    /**
+     * Creates a new adder with initial sum of zero.
+     */
+    public LongAdder() {
+    }
+
+    /**
+     * Adds the given value.
+     *
+     * @param x the value to add
+     */
+    public void add(long x) {
+        Cell[] as; long b, v; HashCode hc; Cell a; int n;
+        if ((as = cells) != null || !casBase(b = base, b + x)) {
+            boolean uncontended = true;
+            int h = (hc = threadHashCode.get()).code;
+            if (as == null || (n = as.length) < 1 ||
+                    (a = as[(n - 1) & h]) == null ||
+                    !(uncontended = a.cas(v = a.value, v + x)))
+                retryUpdate(x, hc, uncontended);
+        }
+    }
+
+    /**
+     * Equivalent to {@code add(1)}.
+     */
+    public void increment() {
+        add(1L);
+    }
+
+    /**
+     * Equivalent to {@code add(-1)}.
+     */
+    public void decrement() {
+        add(-1L);
+    }
+
+    /**
+     * Returns the current sum.  The returned value is <em>NOT</em> an
+     * atomic snapshot; invocation in the absence of concurrent
+     * updates returns an accurate result, but concurrent updates that
+     * occur while the sum is being calculated might not be
+     * incorporated.
+     *
+     * @return the sum
+     */
+    public long sum() {
+        long sum = base;
+        Cell[] as = cells;
+        if (as != null) {
+            int n = as.length;
+            for (int i = 0; i < n; ++i) {
+                Cell a = as[i];
+                if (a != null)
+                    sum += a.value;
+            }
+        }
+        return sum;
+    }
+
+    /**
+     * Resets variables maintaining the sum to zero.  This method may
+     * be a useful alternative to creating a new adder, but is only
+     * effective if there are no concurrent updates.  Because this
+     * method is intrinsically racy, it should only be used when it is
+     * known that no threads are concurrently updating.
+     */
+    public void reset() {
+        internalReset(0L);
+    }
+
+    /**
+     * Equivalent in effect to {@link #sum} followed by {@link
+     * #reset}. This method may apply for example during quiescent
+     * points between multithreaded computations.  If there are
+     * updates concurrent with this method, the returned value is
+     * <em>not</em> guaranteed to be the final value occurring before
+     * the reset.
+     *
+     * @return the sum
+     */
+    public long sumThenReset() {
+        long sum = base;
+        Cell[] as = cells;
+        base = 0L;
+        if (as != null) {
+            int n = as.length;
+            for (int i = 0; i < n; ++i) {
+                Cell a = as[i];
+                if (a != null) {
+                    sum += a.value;
+                    a.value = 0L;
+                }
+            }
+        }
+        return sum;
+    }
+
+    /**
+     * Returns the String representation of the {@link #sum}.
+     * @return the String representation of the {@link #sum}
+     */
+    public String toString() {
+        return Long.toString(sum());
+    }
+
+    /**
+     * Equivalent to {@link #sum}.
+     *
+     * @return the sum
+     */
+    public long longValue() {
+        return sum();
+    }
+
+    /**
+     * Returns the {@link #sum} as an {@code int} after a narrowing
+     * primitive conversion.
+     */
+    public int intValue() {
+        return (int)sum();
+    }
+
+    /**
+     * Returns the {@link #sum} as a {@code float}
+     * after a widening primitive conversion.
+     */
+    public float floatValue() {
+        return (float)sum();
+    }
+
+    /**
+     * Returns the {@link #sum} as a {@code double} after a widening
+     * primitive conversion.
+     */
+    public double doubleValue() {
+        return (double)sum();
+    }
+
+    private void writeObject(java.io.ObjectOutputStream s)
+            throws java.io.IOException {
+        s.defaultWriteObject();
+        s.writeLong(sum());
+    }
+
+    private void readObject(java.io.ObjectInputStream s)
+            throws java.io.IOException, ClassNotFoundException {
+        s.defaultReadObject();
+        busy = 0;
+        cells = null;
+        base = s.readLong();
+    }
+
+}
diff --git a/api/src/main/java/org/asynchttpclient/internal/chmv8/Striped64.java b/api/src/main/java/org/asynchttpclient/internal/chmv8/Striped64.java
new file mode 100644
index 000000000..84e99d541
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/internal/chmv8/Striped64.java
@@ -0,0 +1,359 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+/*
+ * Written by Doug Lea with assistance from members of JCP JSR-166
+ * Expert Group and released to the public domain, as explained at
+ * http://creativecommons.org/publicdomain/zero/1.0/
+ */
+
+package org.asynchttpclient.internal.chmv8;
+
+import java.util.Random;
+
+/**
+ * A package-local class holding common representation and mechanics
+ * for classes supporting dynamic striping on 64bit values. The class
+ * extends Number so that concrete subclasses must publicly do so.
+ */
+@SuppressWarnings("all")
+abstract class Striped64 extends Number {
+    /*
+     * This class maintains a lazily-initialized table of atomically
+     * updated variables, plus an extra "base" field. The table size
+     * is a power of two. Indexing uses masked per-thread hash codes.
+     * Nearly all declarations in this class are package-private,
+     * accessed directly by subclasses.
+     *
+     * Table entries are of class Cell; a variant of AtomicLong padded
+     * to reduce cache contention on most processors. Padding is
+     * overkill for most Atomics because they are usually irregularly
+     * scattered in memory and thus don't interfere much with each
+     * other. But Atomic objects residing in arrays will tend to be
+     * placed adjacent to each other, and so will most often share
+     * cache lines (with a huge negative performance impact) without
+     * this precaution.
+     *
+     * In part because Cells are relatively large, we avoid creating
+     * them until they are needed.  When there is no contention, all
+     * updates are made to the base field.  Upon first contention (a
+     * failed CAS on base update), the table is initialized to size 2.
+     * The table size is doubled upon further contention until
+     * reaching the nearest power of two greater than or equal to the
+     * number of CPUS. Table slots remain empty (null) until they are
+     * needed.
+     *
+     * A single spinlock ("busy") is used for initializing and
+     * resizing the table, as well as populating slots with new Cells.
+     * There is no need for a blocking lock; when the lock is not
+     * available, threads try other slots (or the base).  During these
+     * retries, there is increased contention and reduced locality,
+     * which is still better than alternatives.
+     *
+     * Per-thread hash codes are initialized to random values.
+     * Contention and/or table collisions are indicated by failed
+     * CASes when performing an update operation (see method
+     * retryUpdate). Upon a collision, if the table size is less than
+     * the capacity, it is doubled in size unless some other thread
+     * holds the lock. If a hashed slot is empty, and lock is
+     * available, a new Cell is created. Otherwise, if the slot
+     * exists, a CAS is tried.  Retries proceed by "double hashing",
+     * using a secondary hash (Marsaglia XorShift) to try to find a
+     * free slot.
+     *
+     * The table size is capped because, when there are more threads
+     * than CPUs, supposing that each thread were bound to a CPU,
+     * there would exist a perfect hash function mapping threads to
+     * slots that eliminates collisions. When we reach capacity, we
+     * search for this mapping by randomly varying the hash codes of
+     * colliding threads.  Because search is random, and collisions
+     * only become known via CAS failures, convergence can be slow,
+     * and because threads are typically not bound to CPUS forever,
+     * may not occur at all. However, despite these limitations,
+     * observed contention rates are typically low in these cases.
+     *
+     * It is possible for a Cell to become unused when threads that
+     * once hashed to it terminate, as well as in the case where
+     * doubling the table causes no thread to hash to it under
+     * expanded mask.  We do not try to detect or remove such cells,
+     * under the assumption that for long-running instances, observed
+     * contention levels will recur, so the cells will eventually be
+     * needed again; and for short-lived ones, it does not matter.
+     */
+
+    /**
+     * Padded variant of AtomicLong supporting only raw accesses plus CAS.
+     * The value field is placed between pads, hoping that the JVM doesn't
+     * reorder them.
+     *
+     * JVM intrinsics note: It would be possible to use a release-only
+     * form of CAS here, if it were provided.
+     */
+    static final class Cell {
+        volatile long p0, p1, p2, p3, p4, p5, p6;
+        volatile long value;
+        volatile long q0, q1, q2, q3, q4, q5, q6;
+        Cell(long x) { value = x; }
+
+        final boolean cas(long cmp, long val) {
+            return UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val);
+        }
+
+        // Unsafe mechanics
+        private static final sun.misc.Unsafe UNSAFE;
+        private static final long valueOffset;
+        static {
+            try {
+                UNSAFE = getUnsafe();
+                Class<?> ak = Cell.class;
+                valueOffset = UNSAFE.objectFieldOffset
+                        (ak.getDeclaredField("value"));
+            } catch (Exception e) {
+                throw new Error(e);
+            }
+        }
+
+    }
+
+    /**
+     * Holder for the thread-local hash code. The code is initially
+     * random, but may be set to a different value upon collisions.
+     */
+    static final class HashCode {
+        static final Random rng = new Random();
+        int code;
+        HashCode() {
+            int h = rng.nextInt(); // Avoid zero to allow xorShift rehash
+            code = (h == 0) ? 1 : h;
+        }
+    }
+
+    /**
+     * The corresponding ThreadLocal class
+     */
+    static final class ThreadHashCode extends ThreadLocal<HashCode> {
+        public HashCode initialValue() { return new HashCode(); }
+    }
+
+    /**
+     * Static per-thread hash codes. Shared across all instances to
+     * reduce ThreadLocal pollution and because adjustments due to
+     * collisions in one table are likely to be appropriate for
+     * others.
+     */
+    static final ThreadHashCode threadHashCode = new ThreadHashCode();
+
+    /** Number of CPUS, to place bound on table size */
+    static final int NCPU = Runtime.getRuntime().availableProcessors();
+
+    /**
+     * Table of cells. When non-null, size is a power of 2.
+     */
+    transient volatile Cell[] cells;
+
+    /**
+     * Base value, used mainly when there is no contention, but also as
+     * a fallback during table initialization races. Updated via CAS.
+     */
+    transient volatile long base;
+
+    /**
+     * Spinlock (locked via CAS) used when resizing and/or creating Cells.
+     */
+    transient volatile int busy;
+
+    /**
+     * Package-private default constructor
+     */
+    Striped64() {
+    }
+
+    /**
+     * CASes the base field.
+     */
+    final boolean casBase(long cmp, long val) {
+        return UNSAFE.compareAndSwapLong(this, baseOffset, cmp, val);
+    }
+
+    /**
+     * CASes the busy field from 0 to 1 to acquire lock.
+     */
+    final boolean casBusy() {
+        return UNSAFE.compareAndSwapInt(this, busyOffset, 0, 1);
+    }
+
+    /**
+     * Computes the function of current and new value. Subclasses
+     * should open-code this update function for most uses, but the
+     * virtualized form is needed within retryUpdate.
+     *
+     * @param currentValue the current value (of either base or a cell)
+     * @param newValue the argument from a user update call
+     * @return result of the update function
+     */
+    abstract long fn(long currentValue, long newValue);
+
+    /**
+     * Handles cases of updates involving initialization, resizing,
+     * creating new Cells, and/or contention. See above for
+     * explanation. This method suffers the usual non-modularity
+     * problems of optimistic retry code, relying on rechecked sets of
+     * reads.
+     *
+     * @param x the value
+     * @param hc the hash code holder
+     * @param wasUncontended false if CAS failed before call
+     */
+    final void retryUpdate(long x, HashCode hc, boolean wasUncontended) {
+        int h = hc.code;
+        boolean collide = false;                // True if last slot nonempty
+        for (;;) {
+            Cell[] as; Cell a; int n; long v;
+            if ((as = cells) != null && (n = as.length) > 0) {
+                if ((a = as[(n - 1) & h]) == null) {
+                    if (busy == 0) {            // Try to attach new Cell
+                        Cell r = new Cell(x);   // Optimistically create
+                        if (busy == 0 && casBusy()) {
+                            boolean created = false;
+                            try {               // Recheck under lock
+                                Cell[] rs; int m, j;
+                                if ((rs = cells) != null &&
+                                        (m = rs.length) > 0 &&
+                                        rs[j = (m - 1) & h] == null) {
+                                    rs[j] = r;
+                                    created = true;
+                                }
+                            } finally {
+                                busy = 0;
+                            }
+                            if (created)
+                                break;
+                            continue;           // Slot is now non-empty
+                        }
+                    }
+                    collide = false;
+                }
+                else if (!wasUncontended)       // CAS already known to fail
+                    wasUncontended = true;      // Continue after rehash
+                else if (a.cas(v = a.value, fn(v, x)))
+                    break;
+                else if (n >= NCPU || cells != as)
+                    collide = false;            // At max size or stale
+                else if (!collide)
+                    collide = true;
+                else if (busy == 0 && casBusy()) {
+                    try {
+                        if (cells == as) {      // Expand table unless stale
+                            Cell[] rs = new Cell[n << 1];
+                            for (int i = 0; i < n; ++i)
+                                rs[i] = as[i];
+                            cells = rs;
+                        }
+                    } finally {
+                        busy = 0;
+                    }
+                    collide = false;
+                    continue;                   // Retry with expanded table
+                }
+                h ^= h << 13;                   // Rehash
+                h ^= h >>> 17;
+                h ^= h << 5;
+            }
+            else if (busy == 0 && cells == as && casBusy()) {
+                boolean init = false;
+                try {                           // Initialize table
+                    if (cells == as) {
+                        Cell[] rs = new Cell[2];
+                        rs[h & 1] = new Cell(x);
+                        cells = rs;
+                        init = true;
+                    }
+                } finally {
+                    busy = 0;
+                }
+                if (init)
+                    break;
+            }
+            else if (casBase(v = base, fn(v, x)))
+                break;                          // Fall back on using base
+        }
+        hc.code = h;                            // Record index for next time
+    }
+
+
+    /**
+     * Sets base and all cells to the given value.
+     */
+    final void internalReset(long initialValue) {
+        Cell[] as = cells;
+        base = initialValue;
+        if (as != null) {
+            int n = as.length;
+            for (int i = 0; i < n; ++i) {
+                Cell a = as[i];
+                if (a != null)
+                    a.value = initialValue;
+            }
+        }
+    }
+
+    // Unsafe mechanics
+    private static final sun.misc.Unsafe UNSAFE;
+    private static final long baseOffset;
+    private static final long busyOffset;
+    static {
+        try {
+            UNSAFE = getUnsafe();
+            Class<?> sk = Striped64.class;
+            baseOffset = UNSAFE.objectFieldOffset
+                    (sk.getDeclaredField("base"));
+            busyOffset = UNSAFE.objectFieldOffset
+                    (sk.getDeclaredField("busy"));
+        } catch (Exception e) {
+            throw new Error(e);
+        }
+    }
+
+    /**
+     * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.
+     * Replace with a simple call to Unsafe.getUnsafe when integrating
+     * into a jdk.
+     *
+     * @return a sun.misc.Unsafe
+     */
+    private static sun.misc.Unsafe getUnsafe() {
+        try {
+            return sun.misc.Unsafe.getUnsafe();
+        } catch (SecurityException tryReflectionInstead) {}
+        try {
+            return java.security.AccessController.doPrivileged
+                    (new java.security.PrivilegedExceptionAction<sun.misc.Unsafe>() {
+                        public sun.misc.Unsafe run() throws Exception {
+                            Class<sun.misc.Unsafe> k = sun.misc.Unsafe.class;
+                            for (java.lang.reflect.Field f : k.getDeclaredFields()) {
+                                f.setAccessible(true);
+                                Object x = f.get(null);
+                                if (k.isInstance(x))
+                                    return k.cast(x);
+                            }
+                            throw new NoSuchFieldError("the Unsafe");
+                        }});
+        } catch (java.security.PrivilegedActionException e) {
+            throw new RuntimeException("Could not initialize intrinsics",
+                    e.getCause());
+        }
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/DiscardEvent.java b/api/src/main/java/org/asynchttpclient/netty/DiscardEvent.java
old mode 100755
new mode 100644
similarity index 74%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/DiscardEvent.java
rename to api/src/main/java/org/asynchttpclient/netty/DiscardEvent.java
index a8590efa7..a66557ad2
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/DiscardEvent.java
+++ b/api/src/main/java/org/asynchttpclient/netty/DiscardEvent.java
@@ -3,18 +3,19 @@
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the Apache License Version 2.0 is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty;
 
 /**
- * Simple marker for stopping publishing bytes.
+ * Simple marker for stopping publishing bytes
  */
 public enum DiscardEvent {
-    INSTANCE;
+    INSTANCE
 }
diff --git a/api/src/main/java/org/asynchttpclient/netty/NettyAsyncHttpProvider.java b/api/src/main/java/org/asynchttpclient/netty/NettyAsyncHttpProvider.java
new file mode 100644
index 000000000..e91a1d17c
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/netty/NettyAsyncHttpProvider.java
@@ -0,0 +1,24 @@
+package org.asynchttpclient.netty;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.AsyncHttpProvider;
+import org.asynchttpclient.ListenableFuture;
+import org.asynchttpclient.Request;
+
+public class NettyAsyncHttpProvider implements AsyncHttpProvider {
+
+    public NettyAsyncHttpProvider(AsyncHttpClientConfig config) {
+        throw new UnsupportedOperationException("This implementation is just a stub");
+    }
+    
+    @Override
+    public <T> ListenableFuture<T> execute(Request request, AsyncHandler<T> handler) {
+        throw new UnsupportedOperationException("This implementation is just a stub");
+    }
+
+    @Override
+    public void close() {
+        throw new UnsupportedOperationException("This implementation is just a stub");
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/pool/ChannelPoolPartitionSelector.java b/api/src/main/java/org/asynchttpclient/netty/channel/pool/ChannelPoolPartitionSelector.java
similarity index 88%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/pool/ChannelPoolPartitionSelector.java
rename to api/src/main/java/org/asynchttpclient/netty/channel/pool/ChannelPoolPartitionSelector.java
index 9f76db0bc..ea39a8ef9 100644
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/pool/ChannelPoolPartitionSelector.java
+++ b/api/src/main/java/org/asynchttpclient/netty/channel/pool/ChannelPoolPartitionSelector.java
@@ -11,9 +11,9 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty.channel.pool;
+package org.asynchttpclient.netty.channel.pool;
 
 public interface ChannelPoolPartitionSelector {
 
-   boolean select(String partitionId); 
+   boolean select(Object partitionKey); 
 }
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/future/StackTraceInspector.java b/api/src/main/java/org/asynchttpclient/netty/future/StackTraceInspector.java
similarity index 67%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/future/StackTraceInspector.java
rename to api/src/main/java/org/asynchttpclient/netty/future/StackTraceInspector.java
index f4a658976..c02c638ae 100755
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/future/StackTraceInspector.java
+++ b/api/src/main/java/org/asynchttpclient/netty/future/StackTraceInspector.java
@@ -10,7 +10,10 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty.future;
+package org.asynchttpclient.netty.future;
+
+import java.io.IOException;
+import java.nio.channels.ClosedChannelException;
 
 public class StackTraceInspector {
 
@@ -25,17 +28,21 @@ private static boolean exceptionInMethod(Throwable t, String className, String m
         return false;
     }
 
-    private static boolean abortOnConnectCloseException(Throwable t) {
+    private static boolean recoverOnConnectCloseException(Throwable t) {
         return exceptionInMethod(t, "sun.nio.ch.SocketChannelImpl", "checkConnect")
-                || (t.getCause() != null && abortOnConnectCloseException(t.getCause()));
+                || (t.getCause() != null && recoverOnConnectCloseException(t.getCause()));
     }
 
-    public static boolean abortOnDisconnectException(Throwable t) {
-        return exceptionInMethod(t, "io.netty.handler.ssl.SslHandler", "disconnect")
-                || (t.getCause() != null && abortOnConnectCloseException(t.getCause()));
+    public static boolean recoverOnNettyDisconnectException(Throwable t) {
+        return t instanceof ClosedChannelException
+                || exceptionInMethod(t, "io.netty.handler.ssl.SslHandler", "disconnect")
+                || (t.getCause() != null && recoverOnConnectCloseException(t.getCause()));
     }
 
-    public static boolean abortOnReadOrWriteException(Throwable t) {
+    public static boolean recoverOnReadOrWriteException(Throwable t) {
+
+        if (t instanceof IOException && "Connection reset by peer".equalsIgnoreCase(t.getMessage()))
+            return true;
 
         try {
             for (StackTraceElement element : t.getStackTrace()) {
@@ -48,7 +55,7 @@ public static boolean abortOnReadOrWriteException(Throwable t) {
         }
 
         if (t.getCause() != null)
-            return abortOnReadOrWriteException(t.getCause());
+            return recoverOnReadOrWriteException(t.getCause());
 
         return false;
     }
diff --git a/api/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactoryBase.java b/api/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactoryBase.java
new file mode 100644
index 000000000..2a4077092
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactoryBase.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.request;
+
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.getAuthority;
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.getNonEmptyPath;
+import static org.asynchttpclient.util.HttpUtils.useProxyConnect;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.proxy.ProxyServer;
+import org.asynchttpclient.uri.Uri;
+
+public abstract class NettyRequestFactoryBase {
+
+    protected final AsyncHttpClientConfig config;
+
+    public NettyRequestFactoryBase(AsyncHttpClientConfig config) {
+        this.config = config;
+    }
+
+    protected String requestUri(Uri uri, ProxyServer proxyServer, boolean connect) {
+        if (connect)
+            return getAuthority(uri);
+
+        else if (proxyServer != null && !useProxyConnect(uri))
+            return uri.toUrl();
+
+        else {
+            String path = getNonEmptyPath(uri);
+            if (isNonEmpty(uri.getQuery()))
+                return path + "?" + uri.getQuery();
+            else
+                return path;
+        }
+    }
+
+    protected String connectionHeader(boolean allowConnectionPooling, boolean http11) {
+        if (allowConnectionPooling)
+            return "keep-alive";
+        else if (http11)
+            return "close";
+        else
+            return null;
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/ntlm/NTLMEngine.java b/api/src/main/java/org/asynchttpclient/ntlm/NTLMEngine.java
deleted file mode 100644
index 687759f75..000000000
--- a/api/src/main/java/org/asynchttpclient/ntlm/NTLMEngine.java
+++ /dev/null
@@ -1,1284 +0,0 @@
-/*
- * ====================================================================
- *
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Apache Software Foundation.  For more
- * information on the Apache Software Foundation, please see
- * <http://www.apache.org/>.
- *
- */
-
-package org.asynchttpclient.ntlm;
-
-import org.asynchttpclient.util.Base64;
-import org.asynchttpclient.util.StandardCharsets;
-
-import javax.crypto.Cipher;
-import javax.crypto.spec.SecretKeySpec;
-
-import java.io.UnsupportedEncodingException;
-import java.security.Key;
-import java.security.MessageDigest;
-import java.util.Arrays;
-import java.util.Locale;
-
-/**
- * Provides an implementation for NTLMv1, NTLMv2, and NTLM2 Session forms of the NTLM
- * authentication protocol.
- *
- * @since 4.1
- */
-public class NTLMEngine {
-
-    // Flags we use
-    protected final static int FLAG_UNICODE_ENCODING = 0x00000001;
-    protected final static int FLAG_TARGET_DESIRED = 0x00000004;
-    protected final static int FLAG_NEGOTIATE_SIGN = 0x00000010;
-    protected final static int FLAG_NEGOTIATE_SEAL = 0x00000020;
-    protected final static int FLAG_NEGOTIATE_NTLM = 0x00000200;
-    protected final static int FLAG_NEGOTIATE_ALWAYS_SIGN = 0x00008000;
-    protected final static int FLAG_NEGOTIATE_NTLM2 = 0x00080000;
-    protected final static int FLAG_NEGOTIATE_128 = 0x20000000;
-    protected final static int FLAG_NEGOTIATE_KEY_EXCH = 0x40000000;
-
-    /**
-     * Secure random generator
-     */
-    private static final java.security.SecureRandom RND_GEN;
-
-    static {
-        java.security.SecureRandom rnd = null;
-        try {
-            rnd = java.security.SecureRandom.getInstance("SHA1PRNG");
-        } catch (Exception ignored) {
-        }
-        RND_GEN = rnd;
-    }
-
-    /**
-     * Character encoding
-     */
-    static final String DEFAULT_CHARSET = "ASCII";
-
-    /**
-     * The character set to use for encoding the credentials
-     */
-    private String credentialCharset = DEFAULT_CHARSET;
-
-    private static final byte[] NTLMSSP_BYTES = "NTLMSSP".getBytes(StandardCharsets.US_ASCII);
-    private static final byte[] MAGIC_CONSTANT = "KGS!@#$%".getBytes(StandardCharsets.US_ASCII);
-
-    /**
-     * The signature string as bytes in the default encoding
-     */
-    private static byte[] SIGNATURE;
-
-    static {
-        byte[] bytesWithoutNull = new byte[0];
-        bytesWithoutNull = NTLMSSP_BYTES;
-        SIGNATURE = new byte[bytesWithoutNull.length + 1];
-        System.arraycopy(bytesWithoutNull, 0, SIGNATURE, 0, bytesWithoutNull.length);
-        SIGNATURE[bytesWithoutNull.length] = (byte) 0x00;
-    }
-
-    public static final NTLMEngine INSTANCE = new NTLMEngine();
-
-    /**
-     * Returns the response for the given message.
-     *
-     * @param message  the message that was received from the server.
-     * @param username the username to authenticate with.
-     * @param password the password to authenticate with.
-     * @param host     The host.
-     * @param domain   the NT domain to authenticate in.
-     * @return The response.
-     * @throws NTLMEngineException If the messages cannot be retrieved.
-     */
-    final String getResponseFor(String message, String username, String password, String host, String domain) throws NTLMEngineException {
-
-        final String response;
-        if (message == null || message.trim().length() == 0) {
-            response = getType1Message(host, domain);
-        } else {
-            Type2Message t2m = new Type2Message(message);
-            response = getType3Message(username, password, host, domain, t2m.getChallenge(), t2m.getFlags(), t2m.getTarget(),
-                    t2m.getTargetInfo());
-        }
-        return response;
-    }
-
-    /**
-     * Creates the first message (type 1 message) in the NTLM authentication
-     * sequence. This message includes the user name, domain and host for the
-     * authentication session.
-     *
-     * @param host   the computer name of the host requesting authentication.
-     * @param domain The domain to authenticate with.
-     * @return String the message to add to the HTTP request header.
-     */
-    String getType1Message(String host, String domain) throws NTLMEngineException {
-        try {
-            return new Type1Message(domain, host).getResponse();
-        } catch (UnsupportedEncodingException e) {
-            throw new NTLMEngineException("Unsupported encoding", e);
-        }
-    }
-
-    /**
-     * Creates the type 3 message using the given server nonce. The type 3
-     * message includes all the information for authentication, host, domain,
-     * username and the result of encrypting the nonce sent by the server using
-     * the user's password as the key.
-     *
-     * @param user     The user name. This should not include the domain name.
-     * @param password The password.
-     * @param host     The host that is originating the authentication request.
-     * @param domain   The domain to authenticate within.
-     * @param nonce    the 8 byte array the server sent.
-     * @return The type 3 message.
-     * @throws NTLMEngineException If {@encrypt(byte[],byte[])} fails.
-     */
-    String getType3Message(String user, String password, String host, String domain, byte[] nonce, int type2Flags, String target,
-            byte[] targetInformation) throws NTLMEngineException {
-        try {
-            return new Type3Message(domain, host, user, password, nonce, type2Flags, target, targetInformation).getResponse();
-        } catch (UnsupportedEncodingException e) {
-            throw new NTLMEngineException("Unsupported encoding", e);
-        }
-    }
-
-    /**
-     * @return Returns the credentialCharset.
-     */
-    String getCredentialCharset() {
-        return credentialCharset;
-    }
-
-    /**
-     * @param credentialCharset The credentialCharset to set.
-     */
-    void setCredentialCharset(String credentialCharset) {
-        this.credentialCharset = credentialCharset;
-    }
-
-    /**
-     * Strip dot suffix from a name
-     */
-    private static String stripDotSuffix(String value) {
-        int index = value.indexOf(".");
-        if (index != -1)
-            return value.substring(0, index);
-        return value;
-    }
-
-    /**
-     * Convert host to standard form
-     */
-    private static String convertHost(String host) {
-        return stripDotSuffix(host);
-    }
-
-    /**
-     * Convert domain to standard form
-     */
-    private static String convertDomain(String domain) {
-        return stripDotSuffix(domain);
-    }
-
-    private static int readULong(byte[] src, int index) throws NTLMEngineException {
-        if (src.length < index + 4)
-            throw new NTLMEngineException("NTLM authentication - buffer too small for DWORD");
-        return (src[index] & 0xff) | ((src[index + 1] & 0xff) << 8) | ((src[index + 2] & 0xff) << 16) | ((src[index + 3] & 0xff) << 24);
-    }
-
-    private static int readUShort(byte[] src, int index) throws NTLMEngineException {
-        if (src.length < index + 2)
-            throw new NTLMEngineException("NTLM authentication - buffer too small for WORD");
-        return (src[index] & 0xff) | ((src[index + 1] & 0xff) << 8);
-    }
-
-    private static byte[] readSecurityBuffer(byte[] src, int index) throws NTLMEngineException {
-        int length = readUShort(src, index);
-        int offset = readULong(src, index + 4);
-        if (src.length < offset + length)
-            throw new NTLMEngineException("NTLM authentication - buffer too small for data item");
-        byte[] buffer = new byte[length];
-        System.arraycopy(src, offset, buffer, 0, length);
-        return buffer;
-    }
-
-    /**
-     * Calculate a challenge block
-     */
-    private static byte[] makeRandomChallenge() throws NTLMEngineException {
-        if (RND_GEN == null) {
-            throw new NTLMEngineException("Random generator not available");
-        }
-        byte[] rval = new byte[8];
-        synchronized (RND_GEN) {
-            RND_GEN.nextBytes(rval);
-        }
-        return rval;
-    }
-
-    /**
-     * Calculate an NTLM2 challenge block
-     */
-    private static byte[] makeNTLM2RandomChallenge() throws NTLMEngineException {
-        if (RND_GEN == null) {
-            throw new NTLMEngineException("Random generator not available");
-        }
-        byte[] rval = new byte[24];
-        synchronized (RND_GEN) {
-            RND_GEN.nextBytes(rval);
-        }
-        // 8-byte challenge, padded with zeros to 24 bytes.
-        Arrays.fill(rval, 8, 24, (byte) 0x00);
-        return rval;
-    }
-
-    /**
-     * Calculates the LM Response for the given challenge, using the specified
-     * password.
-     *
-     * @param password  The user's password.
-     * @param challenge The Type 2 challenge from the server.
-     * @return The LM Response.
-     */
-    static byte[] getLMResponse(String password, byte[] challenge) throws NTLMEngineException {
-        byte[] lmHash = lmHash(password);
-        return lmResponse(lmHash, challenge);
-    }
-
-    /**
-     * Calculates the NTLM Response for the given challenge, using the specified
-     * password.
-     *
-     * @param password  The user's password.
-     * @param challenge The Type 2 challenge from the server.
-     * @return The NTLM Response.
-     */
-    static byte[] getNTLMResponse(String password, byte[] challenge) throws NTLMEngineException {
-        byte[] ntlmHash = ntlmHash(password);
-        return lmResponse(ntlmHash, challenge);
-    }
-
-    /**
-     * Calculates the NTLMv2 Response for the given challenge, using the
-     * specified authentication target, username, password, target information
-     * block, and client challenge.
-     *
-     * @param target            The authentication target (i.e., domain).
-     * @param user              The username.
-     * @param password          The user's password.
-     * @param targetInformation The target information block from the Type 2 message.
-     * @param challenge         The Type 2 challenge from the server.
-     * @param clientChallenge   The random 8-byte client challenge.
-     * @return The NTLMv2 Response.
-     */
-    static byte[] getNTLMv2Response(String target, String user, String password, byte[] challenge, byte[] clientChallenge,
-            byte[] targetInformation) throws NTLMEngineException {
-        byte[] ntlmv2Hash = ntlmv2Hash(target, user, password);
-        byte[] blob = createBlob(clientChallenge, targetInformation);
-        return lmv2Response(ntlmv2Hash, challenge, blob);
-    }
-
-    /**
-     * Calculates the LMv2 Response for the given challenge, using the specified
-     * authentication target, username, password, and client challenge.
-     *
-     * @param target          The authentication target (i.e., domain).
-     * @param user            The username.
-     * @param password        The user's password.
-     * @param challenge       The Type 2 challenge from the server.
-     * @param clientChallenge The random 8-byte client challenge.
-     * @return The LMv2 Response.
-     */
-    static byte[] getLMv2Response(String target, String user, String password, byte[] challenge, byte[] clientChallenge)
-            throws NTLMEngineException {
-        byte[] ntlmv2Hash = ntlmv2Hash(target, user, password);
-        return lmv2Response(ntlmv2Hash, challenge, clientChallenge);
-    }
-
-    /**
-     * Calculates the NTLM2 Session Response for the given challenge, using the
-     * specified password and client challenge.
-     *
-     * @param password        The user's password.
-     * @param challenge       The Type 2 challenge from the server.
-     * @param clientChallenge The random 8-byte client challenge.
-     * @return The NTLM2 Session Response. This is placed in the NTLM response
-     *         field of the Type 3 message; the LM response field contains the
-     *         client challenge, null-padded to 24 bytes.
-     */
-    static byte[] getNTLM2SessionResponse(String password, byte[] challenge, byte[] clientChallenge) throws NTLMEngineException {
-        try {
-            byte[] ntlmHash = ntlmHash(password);
-
-            // Look up MD5 algorithm (was necessary on jdk 1.4.2)
-            // This used to be needed, but java 1.5.0_07 includes the MD5
-            // algorithm (finally)
-            // Class x = Class.forName("gnu.crypto.hash.MD5");
-            // Method updateMethod = x.getMethod("update",new
-            // Class[]{byte[].class});
-            // Method digestMethod = x.getMethod("digest",new Class[0]);
-            // Object mdInstance = x.newInstance();
-            // updateMethod.invoke(mdInstance,new Object[]{challenge});
-            // updateMethod.invoke(mdInstance,new Object[]{clientChallenge});
-            // byte[] digest = (byte[])digestMethod.invoke(mdInstance,new
-            // Object[0]);
-
-            MessageDigest md5 = MessageDigest.getInstance("MD5");
-            md5.update(challenge);
-            md5.update(clientChallenge);
-            byte[] digest = md5.digest();
-
-            byte[] sessionHash = new byte[8];
-            System.arraycopy(digest, 0, sessionHash, 0, 8);
-            return lmResponse(ntlmHash, sessionHash);
-        } catch (Exception e) {
-            if (e instanceof NTLMEngineException)
-                throw (NTLMEngineException) e;
-            throw new NTLMEngineException(e.getMessage(), e);
-        }
-    }
-
-    /**
-     * Creates the LM Hash of the user's password.
-     *
-     * @param password The password.
-     * @return The LM Hash of the given password, used in the calculation of the
-     *         LM Response.
-     */
-    private static byte[] lmHash(String password) throws NTLMEngineException {
-        try {
-            byte[] oemPassword = password.toUpperCase(Locale.ENGLISH).getBytes(StandardCharsets.US_ASCII);
-            int length = Math.min(oemPassword.length, 14);
-            byte[] keyBytes = new byte[14];
-            System.arraycopy(oemPassword, 0, keyBytes, 0, length);
-            Key lowKey = createDESKey(keyBytes, 0);
-            Key highKey = createDESKey(keyBytes, 7);
-            Cipher des = Cipher.getInstance("DES/ECB/NoPadding");
-            des.init(Cipher.ENCRYPT_MODE, lowKey);
-            byte[] lowHash = des.doFinal(MAGIC_CONSTANT);
-            des.init(Cipher.ENCRYPT_MODE, highKey);
-            byte[] highHash = des.doFinal(MAGIC_CONSTANT);
-            byte[] lmHash = new byte[16];
-            System.arraycopy(lowHash, 0, lmHash, 0, 8);
-            System.arraycopy(highHash, 0, lmHash, 8, 8);
-            return lmHash;
-        } catch (Exception e) {
-            throw new NTLMEngineException(e.getMessage(), e);
-        }
-    }
-
-    /**
-     * Creates the NTLM Hash of the user's password.
-     *
-     * @param password The password.
-     * @return The NTLM Hash of the given password, used in the calculation of
-     *         the NTLM Response and the NTLMv2 and LMv2 Hashes.
-     */
-    private static byte[] ntlmHash(String password) throws NTLMEngineException {
-        byte[] unicodePassword = password.getBytes(StandardCharsets.UNICODE_LITTLE_UNMARKED);
-        MD4 md4 = new MD4();
-        md4.update(unicodePassword);
-        return md4.getOutput();
-    }
-
-    /**
-     * Creates the NTLMv2 Hash of the user's password.
-     *
-     * @param target   The authentication target (i.e., domain).
-     * @param user     The username.
-     * @param password The password.
-     * @return The NTLMv2 Hash, used in the calculation of the NTLMv2 and LMv2
-     *         Responses.
-     */
-    private static byte[] ntlmv2Hash(String target, String user, String password) throws NTLMEngineException {
-        byte[] ntlmHash = ntlmHash(password);
-        HMACMD5 hmacMD5 = new HMACMD5(ntlmHash);
-        // Upper case username, mixed case target!!
-        hmacMD5.update(user.toUpperCase(Locale.ENGLISH).getBytes(StandardCharsets.UNICODE_LITTLE_UNMARKED));
-        hmacMD5.update(target.getBytes(StandardCharsets.UNICODE_LITTLE_UNMARKED));
-        return hmacMD5.getOutput();
-    }
-
-    /**
-     * Creates the LM Response from the given hash and Type 2 challenge.
-     *
-     * @param hash      The LM or NTLM Hash.
-     * @param challenge The server challenge from the Type 2 message.
-     * @return The response (either LM or NTLM, depending on the provided hash).
-     */
-    private static byte[] lmResponse(byte[] hash, byte[] challenge) throws NTLMEngineException {
-        try {
-            byte[] keyBytes = new byte[21];
-            System.arraycopy(hash, 0, keyBytes, 0, 16);
-            Key lowKey = createDESKey(keyBytes, 0);
-            Key middleKey = createDESKey(keyBytes, 7);
-            Key highKey = createDESKey(keyBytes, 14);
-            Cipher des = Cipher.getInstance("DES/ECB/NoPadding");
-            des.init(Cipher.ENCRYPT_MODE, lowKey);
-            byte[] lowResponse = des.doFinal(challenge);
-            des.init(Cipher.ENCRYPT_MODE, middleKey);
-            byte[] middleResponse = des.doFinal(challenge);
-            des.init(Cipher.ENCRYPT_MODE, highKey);
-            byte[] highResponse = des.doFinal(challenge);
-            byte[] lmResponse = new byte[24];
-            System.arraycopy(lowResponse, 0, lmResponse, 0, 8);
-            System.arraycopy(middleResponse, 0, lmResponse, 8, 8);
-            System.arraycopy(highResponse, 0, lmResponse, 16, 8);
-            return lmResponse;
-        } catch (Exception e) {
-            throw new NTLMEngineException(e.getMessage(), e);
-        }
-    }
-
-    /**
-     * Creates the LMv2 Response from the given hash, client data, and Type 2
-     * challenge.
-     *
-     * @param hash       The NTLMv2 Hash.
-     * @param clientData The client data (blob or client challenge).
-     * @param challenge  The server challenge from the Type 2 message.
-     * @return The response (either NTLMv2 or LMv2, depending on the client
-     *         data).
-     */
-    private static byte[] lmv2Response(byte[] hash, byte[] challenge, byte[] clientData) throws NTLMEngineException {
-        HMACMD5 hmacMD5 = new HMACMD5(hash);
-        hmacMD5.update(challenge);
-        hmacMD5.update(clientData);
-        byte[] mac = hmacMD5.getOutput();
-        byte[] lmv2Response = new byte[mac.length + clientData.length];
-        System.arraycopy(mac, 0, lmv2Response, 0, mac.length);
-        System.arraycopy(clientData, 0, lmv2Response, mac.length, clientData.length);
-        return lmv2Response;
-    }
-
-    /**
-     * Creates the NTLMv2 blob from the given target information block and
-     * client challenge.
-     *
-     * @param targetInformation The target information block from the Type 2 message.
-     * @param clientChallenge   The random 8-byte client challenge.
-     * @return The blob, used in the calculation of the NTLMv2 Response.
-     */
-    private static byte[] createBlob(byte[] clientChallenge, byte[] targetInformation) {
-        byte[] blobSignature = new byte[] { (byte) 0x01, (byte) 0x01, (byte) 0x00, (byte) 0x00 };
-        byte[] reserved = new byte[] { (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00 };
-        byte[] unknown1 = new byte[] { (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00 };
-        long time = System.currentTimeMillis();
-        time += 11644473600000l; // milliseconds from January 1, 1601 -> epoch.
-        time *= 10000; // tenths of a microsecond.
-        // convert to little-endian byte array.
-        byte[] timestamp = new byte[8];
-        for (int i = 0; i < 8; i++) {
-            timestamp[i] = (byte) time;
-            time >>>= 8;
-        }
-        byte[] blob = new byte[blobSignature.length + reserved.length + timestamp.length + 8 + unknown1.length + targetInformation.length];
-        int offset = 0;
-        System.arraycopy(blobSignature, 0, blob, offset, blobSignature.length);
-        offset += blobSignature.length;
-        System.arraycopy(reserved, 0, blob, offset, reserved.length);
-        offset += reserved.length;
-        System.arraycopy(timestamp, 0, blob, offset, timestamp.length);
-        offset += timestamp.length;
-        System.arraycopy(clientChallenge, 0, blob, offset, 8);
-        offset += 8;
-        System.arraycopy(unknown1, 0, blob, offset, unknown1.length);
-        offset += unknown1.length;
-        System.arraycopy(targetInformation, 0, blob, offset, targetInformation.length);
-        return blob;
-    }
-
-    /**
-     * Creates a DES encryption key from the given key material.
-     *
-     * @param bytes  A byte array containing the DES key material.
-     * @param offset The offset in the given byte array at which the 7-byte key
-     *               material starts.
-     * @return A DES encryption key created from the key material starting at
-     *         the specified offset in the given byte array.
-     */
-    private static Key createDESKey(byte[] bytes, int offset) {
-        byte[] keyBytes = new byte[7];
-        System.arraycopy(bytes, offset, keyBytes, 0, 7);
-        byte[] material = new byte[8];
-        material[0] = keyBytes[0];
-        material[1] = (byte) (keyBytes[0] << 7 | (keyBytes[1] & 0xff) >>> 1);
-        material[2] = (byte) (keyBytes[1] << 6 | (keyBytes[2] & 0xff) >>> 2);
-        material[3] = (byte) (keyBytes[2] << 5 | (keyBytes[3] & 0xff) >>> 3);
-        material[4] = (byte) (keyBytes[3] << 4 | (keyBytes[4] & 0xff) >>> 4);
-        material[5] = (byte) (keyBytes[4] << 3 | (keyBytes[5] & 0xff) >>> 5);
-        material[6] = (byte) (keyBytes[5] << 2 | (keyBytes[6] & 0xff) >>> 6);
-        material[7] = (byte) (keyBytes[6] << 1);
-        oddParity(material);
-        return new SecretKeySpec(material, "DES");
-    }
-
-    /**
-     * Applies odd parity to the given byte array.
-     *
-     * @param bytes The data whose parity bits are to be adjusted for odd parity.
-     */
-    private static void oddParity(byte[] bytes) {
-        for (int i = 0; i < bytes.length; i++) {
-            byte b = bytes[i];
-            boolean needsParity = (((b >>> 7) ^ (b >>> 6) ^ (b >>> 5) ^ (b >>> 4) ^ (b >>> 3) ^ (b >>> 2) ^ (b >>> 1)) & 0x01) == 0;
-            if (needsParity) {
-                bytes[i] |= (byte) 0x01;
-            } else {
-                bytes[i] &= (byte) 0xfe;
-            }
-        }
-    }
-
-    /**
-     * NTLM message generation, base class
-     */
-    static class NTLMMessage {
-        /**
-         * The current response
-         */
-        private byte[] messageContents = null;
-
-        /**
-         * The current output position
-         */
-        private int currentOutputPosition = 0;
-
-        /**
-         * Constructor to use when message contents are not yet known
-         */
-        NTLMMessage() {
-        }
-
-        /**
-         * Constructor to use when message contents are known
-         */
-        NTLMMessage(String messageBody, int expectedType) throws NTLMEngineException {
-            messageContents = Base64.decode(messageBody);
-
-            // Look for NTLM message
-            if (messageContents.length < SIGNATURE.length)
-                throw new NTLMEngineException("NTLM message decoding error - packet too short");
-            int i = 0;
-            while (i < SIGNATURE.length) {
-                if (messageContents[i] != SIGNATURE[i])
-                    throw new NTLMEngineException("NTLM message expected - instead got unrecognized bytes");
-                i++;
-            }
-
-            // Check to be sure there's a type 2 message indicator next
-            int type = readULong(SIGNATURE.length);
-            if (type != expectedType)
-                throw new NTLMEngineException("NTLM type " + Integer.toString(expectedType) + " message expected - instead got type "
-                        + Integer.toString(type));
-
-            currentOutputPosition = messageContents.length;
-        }
-
-        /**
-         * Get the length of the signature and flags, so calculations can adjust
-         * offsets accordingly.
-         */
-        protected int getPreambleLength() {
-            return SIGNATURE.length + 4;
-        }
-
-        /**
-         * Get the message length
-         */
-        protected int getMessageLength() {
-            return currentOutputPosition;
-        }
-
-        /**
-         * Read a byte from a position within the message buffer
-         */
-        protected byte readByte(int position) throws NTLMEngineException {
-            if (messageContents.length < position + 1)
-                throw new NTLMEngineException("NTLM: Message too short");
-            return messageContents[position];
-        }
-
-        /**
-         * Read a bunch of bytes from a position in the message buffer
-         */
-        protected void readBytes(byte[] buffer, int position) throws NTLMEngineException {
-            if (messageContents.length < position + buffer.length)
-                throw new NTLMEngineException("NTLM: Message too short");
-            System.arraycopy(messageContents, position, buffer, 0, buffer.length);
-        }
-
-        /**
-         * Read a ushort from a position within the message buffer
-         */
-        protected int readUShort(int position) throws NTLMEngineException {
-            return NTLMEngine.readUShort(messageContents, position);
-        }
-
-        /**
-         * Read a ulong from a position within the message buffer
-         */
-        protected int readULong(int position) throws NTLMEngineException {
-            return NTLMEngine.readULong(messageContents, position);
-        }
-
-        /**
-         * Read a security buffer from a position within the message buffer
-         */
-        protected byte[] readSecurityBuffer(int position) throws NTLMEngineException {
-            return NTLMEngine.readSecurityBuffer(messageContents, position);
-        }
-
-        /**
-         * Prepares the object to create a response of the given length.
-         *
-         * @param maxlength the maximum length of the response to prepare, not
-         *                  including the type and the signature (which this method
-         *                  adds).
-         */
-        protected void prepareResponse(int maxlength, int messageType) {
-            messageContents = new byte[maxlength];
-            currentOutputPosition = 0;
-            addBytes(SIGNATURE);
-            addULong(messageType);
-        }
-
-        /**
-         * Adds the given byte to the response.
-         *
-         * @param b the byte to add.
-         */
-        protected void addByte(byte b) {
-            messageContents[currentOutputPosition] = b;
-            currentOutputPosition++;
-        }
-
-        /**
-         * Adds the given bytes to the response.
-         *
-         * @param bytes the bytes to add.
-         */
-        protected void addBytes(byte[] bytes) {
-            for (int i = 0; i < bytes.length; i++) {
-                messageContents[currentOutputPosition] = bytes[i];
-                currentOutputPosition++;
-            }
-        }
-
-        /**
-         * Adds a USHORT to the response
-         */
-        protected void addUShort(int value) {
-            addByte((byte) (value & 0xff));
-            addByte((byte) (value >> 8 & 0xff));
-        }
-
-        /**
-         * Adds a ULong to the response
-         */
-        protected void addULong(int value) {
-            addByte((byte) (value & 0xff));
-            addByte((byte) (value >> 8 & 0xff));
-            addByte((byte) (value >> 16 & 0xff));
-            addByte((byte) (value >> 24 & 0xff));
-        }
-
-        /**
-         * Returns the response that has been generated after shrinking the
-         * array if required and base64 encodes the response.
-         *
-         * @return The response as above.
-         */
-        String getResponse() throws UnsupportedEncodingException {
-            byte[] resp;
-            if (messageContents.length > currentOutputPosition) {
-                byte[] tmp = new byte[currentOutputPosition];
-                for (int i = 0; i < currentOutputPosition; i++) {
-                    tmp[i] = messageContents[i];
-                }
-                resp = tmp;
-            } else {
-                resp = messageContents;
-            }
-            return Base64.encode(resp);
-        }
-
-    }
-
-    /**
-     * Type 1 message assembly class
-     */
-    static class Type1Message extends NTLMMessage {
-        protected byte[] hostBytes;
-        protected byte[] domainBytes;
-
-        /**
-         * Constructor. Include the arguments the message will need
-         */
-        Type1Message(String domain, String host) throws NTLMEngineException {
-            super();
-            // Strip off domain name from the host!
-            host = convertHost(host);
-            // Use only the base domain name!
-            domain = convertDomain(domain);
-
-            hostBytes = host.getBytes(StandardCharsets.UNICODE_LITTLE_UNMARKED);
-            domainBytes = domain.toUpperCase(Locale.ENGLISH).getBytes(StandardCharsets.UNICODE_LITTLE_UNMARKED);
-        }
-
-        /**
-         * Getting the response involves building the message before returning
-         * it
-         */
-        @Override
-        String getResponse() throws UnsupportedEncodingException {
-            // Now, build the message. Calculate its length first, including
-            // signature or type.
-            int finalLength = 32 + hostBytes.length + domainBytes.length;
-
-            // Set up the response. This will initialize the signature, message
-            // type, and flags.
-            prepareResponse(finalLength, 1);
-
-            // Flags. These are the complete set of flags we support.
-            addULong(FLAG_NEGOTIATE_NTLM | FLAG_NEGOTIATE_NTLM2 | FLAG_NEGOTIATE_SIGN | FLAG_NEGOTIATE_SEAL |
-            /*
-             * FLAG_NEGOTIATE_ALWAYS_SIGN | FLAG_NEGOTIATE_KEY_EXCH |
-             */
-            FLAG_UNICODE_ENCODING | FLAG_TARGET_DESIRED | FLAG_NEGOTIATE_128);
-
-            // Domain length (two times).
-            addUShort(domainBytes.length);
-            addUShort(domainBytes.length);
-
-            // Domain offset.
-            addULong(hostBytes.length + 32);
-
-            // Host length (two times).
-            addUShort(hostBytes.length);
-            addUShort(hostBytes.length);
-
-            // Host offset (always 32).
-            addULong(32);
-
-            // Host String.
-            addBytes(hostBytes);
-
-            // Domain String.
-            addBytes(domainBytes);
-
-            return super.getResponse();
-        }
-
-    }
-
-    /**
-     * Type 2 message class
-     */
-    static class Type2Message extends NTLMMessage {
-        protected byte[] challenge;
-        protected String target;
-        protected byte[] targetInfo;
-        protected int flags;
-
-        Type2Message(String message) throws NTLMEngineException {
-            super(message, 2);
-
-            // Parse out the rest of the info we need from the message
-            // The nonce is the 8 bytes starting from the byte in position 24.
-            challenge = new byte[8];
-            readBytes(challenge, 24);
-
-            flags = readULong(20);
-            if ((flags & FLAG_UNICODE_ENCODING) == 0)
-                throw new NTLMEngineException("NTLM type 2 message has flags that make no sense: " + Integer.toString(flags));
-            // Do the target!
-            target = null;
-            // The TARGET_DESIRED flag is said to not have understood semantics
-            // in Type2 messages, so use the length of the packet to decide
-            // how to proceed instead
-            if (getMessageLength() >= 12 + 8) {
-                byte[] bytes = readSecurityBuffer(12);
-                if (bytes.length != 0) {
-                    target = new String(bytes, StandardCharsets.UNICODE_LITTLE_UNMARKED);
-                }
-            }
-
-            // Do the target info!
-            targetInfo = null;
-            // TARGET_DESIRED flag cannot be relied on, so use packet length
-            if (getMessageLength() >= 40 + 8) {
-                byte[] bytes = readSecurityBuffer(40);
-                if (bytes.length != 0) {
-                    targetInfo = bytes;
-                }
-            }
-        }
-
-        /**
-         * Retrieve the challenge
-         */
-        byte[] getChallenge() {
-            return challenge;
-        }
-
-        /**
-         * Retrieve the target
-         */
-        String getTarget() {
-            return target;
-        }
-
-        /**
-         * Retrieve the target info
-         */
-        byte[] getTargetInfo() {
-            return targetInfo;
-        }
-
-        /**
-         * Retrieve the response flags
-         */
-        int getFlags() {
-            return flags;
-        }
-
-    }
-
-    /**
-     * Type 3 message assembly class
-     */
-    static class Type3Message extends NTLMMessage {
-        // Response flags from the type2 message
-        protected int type2Flags;
-
-        protected byte[] domainBytes;
-        protected byte[] hostBytes;
-        protected byte[] userBytes;
-
-        protected byte[] lmResp;
-        protected byte[] ntResp;
-
-        /**
-         * Constructor. Pass the arguments we will need
-         */
-        Type3Message(String domain, String host, String user, String password, byte[] nonce, int type2Flags, String target,
-                byte[] targetInformation) throws NTLMEngineException {
-            // Save the flags
-            this.type2Flags = type2Flags;
-
-            // Strip off domain name from the host!
-            host = convertHost(host);
-            // Use only the base domain name!
-            domain = convertDomain(domain);
-
-            // Use the new code to calculate the responses, including v2 if that
-            // seems warranted.
-            try {
-                if (targetInformation != null && target != null) {
-                    byte[] clientChallenge = makeRandomChallenge();
-                    ntResp = getNTLMv2Response(target, user, password, nonce, clientChallenge, targetInformation);
-                    lmResp = getLMv2Response(target, user, password, nonce, clientChallenge);
-                } else {
-                    if ((type2Flags & FLAG_NEGOTIATE_NTLM2) != 0) {
-                        // NTLM2 session stuff is requested
-                        byte[] clientChallenge = makeNTLM2RandomChallenge();
-
-                        ntResp = getNTLM2SessionResponse(password, nonce, clientChallenge);
-                        lmResp = clientChallenge;
-
-                        // All the other flags we send (signing, sealing, key
-                        // exchange) are supported, but they don't do anything
-                        // at all in an
-                        // NTLM2 context! So we're done at this point.
-                    } else {
-                        ntResp = getNTLMResponse(password, nonce);
-                        lmResp = getLMResponse(password, nonce);
-                    }
-                }
-            } catch (NTLMEngineException e) {
-                // This likely means we couldn't find the MD4 hash algorithm -
-                // fail back to just using LM
-                ntResp = new byte[0];
-                lmResp = getLMResponse(password, nonce);
-            }
-
-            domainBytes = domain.toUpperCase(Locale.ENGLISH).getBytes(StandardCharsets.UNICODE_LITTLE_UNMARKED);
-            hostBytes = host.getBytes(StandardCharsets.UNICODE_LITTLE_UNMARKED);
-            userBytes = user.getBytes(StandardCharsets.UNICODE_LITTLE_UNMARKED);
-        }
-
-        /**
-         * Assemble the response
-         */
-        @Override
-        String getResponse() throws UnsupportedEncodingException {
-            int ntRespLen = ntResp.length;
-            int lmRespLen = lmResp.length;
-
-            int domainLen = domainBytes.length;
-            int hostLen = hostBytes.length;
-            int userLen = userBytes.length;
-
-            // Calculate the layout within the packet
-            int lmRespOffset = 64;
-            int ntRespOffset = lmRespOffset + lmRespLen;
-            int domainOffset = ntRespOffset + ntRespLen;
-            int userOffset = domainOffset + domainLen;
-            int hostOffset = userOffset + userLen;
-            int finalLength = hostOffset + hostLen;
-
-            // Start the response. Length includes signature and type
-            prepareResponse(finalLength, 3);
-
-            // LM Resp Length (twice)
-            addUShort(lmRespLen);
-            addUShort(lmRespLen);
-
-            // LM Resp Offset
-            addULong(lmRespOffset);
-
-            // NT Resp Length (twice)
-            addUShort(ntRespLen);
-            addUShort(ntRespLen);
-
-            // NT Resp Offset
-            addULong(ntRespOffset);
-
-            // Domain length (twice)
-            addUShort(domainLen);
-            addUShort(domainLen);
-
-            // Domain offset.
-            addULong(domainOffset);
-
-            // User Length (twice)
-            addUShort(userLen);
-            addUShort(userLen);
-
-            // User offset
-            addULong(userOffset);
-
-            // Host length (twice)
-            addUShort(hostLen);
-            addUShort(hostLen);
-
-            // Host offset
-            addULong(hostOffset);
-
-            // 4 bytes of zeros - not sure what this is
-            addULong(0);
-
-            // Message length
-            addULong(finalLength);
-
-            // Flags. Currently: NEGOTIATE_NTLM + UNICODE_ENCODING +
-            // TARGET_DESIRED + NEGOTIATE_128
-            addULong(FLAG_NEGOTIATE_NTLM | FLAG_UNICODE_ENCODING | FLAG_TARGET_DESIRED | FLAG_NEGOTIATE_128
-                    | (type2Flags & FLAG_NEGOTIATE_NTLM2) | (type2Flags & FLAG_NEGOTIATE_SIGN) | (type2Flags & FLAG_NEGOTIATE_SEAL)
-                    | (type2Flags & FLAG_NEGOTIATE_KEY_EXCH) | (type2Flags & FLAG_NEGOTIATE_ALWAYS_SIGN));
-
-            // Add the actual data
-            addBytes(lmResp);
-            addBytes(ntResp);
-            addBytes(domainBytes);
-            addBytes(userBytes);
-            addBytes(hostBytes);
-
-            return super.getResponse();
-        }
-    }
-
-    static void writeULong(byte[] buffer, int value, int offset) {
-        buffer[offset] = (byte) (value & 0xff);
-        buffer[offset + 1] = (byte) (value >> 8 & 0xff);
-        buffer[offset + 2] = (byte) (value >> 16 & 0xff);
-        buffer[offset + 3] = (byte) (value >> 24 & 0xff);
-    }
-
-    static int F(int x, int y, int z) {
-        return ((x & y) | (~x & z));
-    }
-
-    static int G(int x, int y, int z) {
-        return ((x & y) | (x & z) | (y & z));
-    }
-
-    static int H(int x, int y, int z) {
-        return (x ^ y ^ z);
-    }
-
-    static int rotintlft(int val, int numbits) {
-        return ((val << numbits) | (val >>> (32 - numbits)));
-    }
-
-    /**
-     * Cryptography support - MD4. The following class was based loosely on the
-     * RFC and on code found at http://www.cs.umd.edu/~harry/jotp/src/md.java.
-     * Code correctness was verified by looking at MD4.java from the jcifs
-     * library (http://jcifs.samba.org). It was massaged extensively to the
-     * final form found here by Karl Wright (kwright@metacarta.com).
-     */
-    static class MD4 {
-        protected int A = 0x67452301;
-        protected int B = 0xefcdab89;
-        protected int C = 0x98badcfe;
-        protected int D = 0x10325476;
-        protected long count = 0L;
-        protected byte[] dataBuffer = new byte[64];
-
-        MD4() {
-        }
-
-        void update(byte[] input) {
-            // We always deal with 512 bits at a time. Correspondingly, there is
-            // a buffer 64 bytes long that we write data into until it gets
-            // full.
-            int curBufferPos = (int) (count & 63L);
-            int inputIndex = 0;
-            while (input.length - inputIndex + curBufferPos >= dataBuffer.length) {
-                // We have enough data to do the next step. Do a partial copy
-                // and a transform, updating inputIndex and curBufferPos
-                // accordingly
-                int transferAmt = dataBuffer.length - curBufferPos;
-                System.arraycopy(input, inputIndex, dataBuffer, curBufferPos, transferAmt);
-                count += transferAmt;
-                curBufferPos = 0;
-                inputIndex += transferAmt;
-                processBuffer();
-            }
-
-            // If there's anything left, copy it into the buffer and leave it.
-            // We know there's not enough left to process.
-            if (inputIndex < input.length) {
-                int transferAmt = input.length - inputIndex;
-                System.arraycopy(input, inputIndex, dataBuffer, curBufferPos, transferAmt);
-                count += transferAmt;
-            }
-        }
-
-        byte[] getOutput() {
-            // Feed pad/length data into engine. This must round out the input
-            // to a multiple of 512 bits.
-            int bufferIndex = (int) (count & 63L);
-            int padLen = (bufferIndex < 56) ? (56 - bufferIndex) : (120 - bufferIndex);
-            byte[] postBytes = new byte[padLen + 8];
-            // Leading 0x80, specified amount of zero padding, then length in
-            // bits.
-            postBytes[0] = (byte) 0x80;
-            // Fill out the last 8 bytes with the length
-            for (int i = 0; i < 8; i++) {
-                postBytes[padLen + i] = (byte) ((count * 8) >>> (8 * i));
-            }
-
-            // Update the engine
-            update(postBytes);
-
-            // Calculate final result
-            byte[] result = new byte[16];
-            writeULong(result, A, 0);
-            writeULong(result, B, 4);
-            writeULong(result, C, 8);
-            writeULong(result, D, 12);
-            return result;
-        }
-
-        protected void processBuffer() {
-            // Convert current buffer to 16 ulongs
-            int[] d = new int[16];
-
-            for (int i = 0; i < 16; i++) {
-                d[i] = (dataBuffer[i * 4] & 0xff) + ((dataBuffer[i * 4 + 1] & 0xff) << 8) + ((dataBuffer[i * 4 + 2] & 0xff) << 16)
-                        + ((dataBuffer[i * 4 + 3] & 0xff) << 24);
-            }
-
-            // Do a round of processing
-            int AA = A;
-            int BB = B;
-            int CC = C;
-            int DD = D;
-            round1(d);
-            round2(d);
-            round3(d);
-            A += AA;
-            B += BB;
-            C += CC;
-            D += DD;
-
-        }
-
-        protected void round1(int[] d) {
-            A = rotintlft((A + F(B, C, D) + d[0]), 3);
-            D = rotintlft((D + F(A, B, C) + d[1]), 7);
-            C = rotintlft((C + F(D, A, B) + d[2]), 11);
-            B = rotintlft((B + F(C, D, A) + d[3]), 19);
-
-            A = rotintlft((A + F(B, C, D) + d[4]), 3);
-            D = rotintlft((D + F(A, B, C) + d[5]), 7);
-            C = rotintlft((C + F(D, A, B) + d[6]), 11);
-            B = rotintlft((B + F(C, D, A) + d[7]), 19);
-
-            A = rotintlft((A + F(B, C, D) + d[8]), 3);
-            D = rotintlft((D + F(A, B, C) + d[9]), 7);
-            C = rotintlft((C + F(D, A, B) + d[10]), 11);
-            B = rotintlft((B + F(C, D, A) + d[11]), 19);
-
-            A = rotintlft((A + F(B, C, D) + d[12]), 3);
-            D = rotintlft((D + F(A, B, C) + d[13]), 7);
-            C = rotintlft((C + F(D, A, B) + d[14]), 11);
-            B = rotintlft((B + F(C, D, A) + d[15]), 19);
-        }
-
-        protected void round2(int[] d) {
-            A = rotintlft((A + G(B, C, D) + d[0] + 0x5a827999), 3);
-            D = rotintlft((D + G(A, B, C) + d[4] + 0x5a827999), 5);
-            C = rotintlft((C + G(D, A, B) + d[8] + 0x5a827999), 9);
-            B = rotintlft((B + G(C, D, A) + d[12] + 0x5a827999), 13);
-
-            A = rotintlft((A + G(B, C, D) + d[1] + 0x5a827999), 3);
-            D = rotintlft((D + G(A, B, C) + d[5] + 0x5a827999), 5);
-            C = rotintlft((C + G(D, A, B) + d[9] + 0x5a827999), 9);
-            B = rotintlft((B + G(C, D, A) + d[13] + 0x5a827999), 13);
-
-            A = rotintlft((A + G(B, C, D) + d[2] + 0x5a827999), 3);
-            D = rotintlft((D + G(A, B, C) + d[6] + 0x5a827999), 5);
-            C = rotintlft((C + G(D, A, B) + d[10] + 0x5a827999), 9);
-            B = rotintlft((B + G(C, D, A) + d[14] + 0x5a827999), 13);
-
-            A = rotintlft((A + G(B, C, D) + d[3] + 0x5a827999), 3);
-            D = rotintlft((D + G(A, B, C) + d[7] + 0x5a827999), 5);
-            C = rotintlft((C + G(D, A, B) + d[11] + 0x5a827999), 9);
-            B = rotintlft((B + G(C, D, A) + d[15] + 0x5a827999), 13);
-
-        }
-
-        protected void round3(int[] d) {
-            A = rotintlft((A + H(B, C, D) + d[0] + 0x6ed9eba1), 3);
-            D = rotintlft((D + H(A, B, C) + d[8] + 0x6ed9eba1), 9);
-            C = rotintlft((C + H(D, A, B) + d[4] + 0x6ed9eba1), 11);
-            B = rotintlft((B + H(C, D, A) + d[12] + 0x6ed9eba1), 15);
-
-            A = rotintlft((A + H(B, C, D) + d[2] + 0x6ed9eba1), 3);
-            D = rotintlft((D + H(A, B, C) + d[10] + 0x6ed9eba1), 9);
-            C = rotintlft((C + H(D, A, B) + d[6] + 0x6ed9eba1), 11);
-            B = rotintlft((B + H(C, D, A) + d[14] + 0x6ed9eba1), 15);
-
-            A = rotintlft((A + H(B, C, D) + d[1] + 0x6ed9eba1), 3);
-            D = rotintlft((D + H(A, B, C) + d[9] + 0x6ed9eba1), 9);
-            C = rotintlft((C + H(D, A, B) + d[5] + 0x6ed9eba1), 11);
-            B = rotintlft((B + H(C, D, A) + d[13] + 0x6ed9eba1), 15);
-
-            A = rotintlft((A + H(B, C, D) + d[3] + 0x6ed9eba1), 3);
-            D = rotintlft((D + H(A, B, C) + d[11] + 0x6ed9eba1), 9);
-            C = rotintlft((C + H(D, A, B) + d[7] + 0x6ed9eba1), 11);
-            B = rotintlft((B + H(C, D, A) + d[15] + 0x6ed9eba1), 15);
-
-        }
-
-    }
-
-    /**
-     * Cryptography support - HMACMD5 - algorithmically based on various web
-     * resources by Karl Wright
-     */
-    static class HMACMD5 {
-        protected byte[] ipad;
-        protected byte[] opad;
-        protected MessageDigest md5;
-
-        HMACMD5(byte[] key) throws NTLMEngineException {
-            try {
-                md5 = MessageDigest.getInstance("MD5");
-            } catch (Exception ex) {
-                // Umm, the algorithm doesn't exist - throw an
-                // NTLMEngineException!
-                throw new NTLMEngineException("Error getting md5 message digest implementation: " + ex.getMessage(), ex);
-            }
-
-            // Initialize the pad buffers with the key
-            ipad = new byte[64];
-            opad = new byte[64];
-
-            int keyLength = key.length;
-            if (keyLength > 64) {
-                // Use MD5 of the key instead, as described in RFC 2104
-                md5.update(key);
-                key = md5.digest();
-                keyLength = key.length;
-            }
-            int i = 0;
-            while (i < keyLength) {
-                ipad[i] = (byte) (key[i] ^ (byte) 0x36);
-                opad[i] = (byte) (key[i] ^ (byte) 0x5c);
-                i++;
-            }
-            while (i < 64) {
-                ipad[i] = (byte) 0x36;
-                opad[i] = (byte) 0x5c;
-                i++;
-            }
-
-            // Very important: update the digest with the ipad buffer
-            md5.reset();
-            md5.update(ipad);
-
-        }
-
-        /**
-         * Grab the current digest. This is the "answer".
-         */
-        byte[] getOutput() {
-            byte[] digest = md5.digest();
-            md5.update(opad);
-            return md5.digest(digest);
-        }
-
-        /**
-         * Update by adding a complete array
-         */
-        void update(byte[] input) {
-            md5.update(input);
-        }
-
-        /**
-         * Update the algorithm
-         */
-        void update(byte[] input, int offset, int length) {
-            md5.update(input, offset, length);
-        }
-
-    }
-
-    public String generateType1Msg(final String domain, final String workstation) throws NTLMEngineException {
-        return getType1Message(workstation, domain);
-    }
-
-    public String generateType3Msg(final String username, final String password, final String domain, final String workstation,
-            final String challenge) throws NTLMEngineException {
-        Type2Message t2m = new Type2Message(challenge);
-        return getType3Message(username, password, workstation, domain, t2m.getChallenge(), t2m.getFlags(), t2m.getTarget(),
-                t2m.getTargetInfo());
-    }
-
-}
diff --git a/api/src/main/java/org/asynchttpclient/ntlm/NtlmEngine.java b/api/src/main/java/org/asynchttpclient/ntlm/NtlmEngine.java
new file mode 100644
index 000000000..167de1226
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/ntlm/NtlmEngine.java
@@ -0,0 +1,1532 @@
+/*
+ * ====================================================================
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+// fork from Apache HttpComponents
+package org.asynchttpclient.ntlm;
+
+import static java.nio.charset.StandardCharsets.US_ASCII;
+
+import java.io.UnsupportedEncodingException;
+import java.nio.charset.Charset;
+import java.nio.charset.UnsupportedCharsetException;
+import java.security.Key;
+import java.security.MessageDigest;
+import java.util.Arrays;
+import java.util.Locale;
+
+import javax.crypto.Cipher;
+import javax.crypto.spec.SecretKeySpec;
+
+import org.asynchttpclient.util.Base64;
+
+/**
+ * Provides an implementation for NTLMv1, NTLMv2, and NTLM2 Session forms of the NTLM
+ * authentication protocol.
+ *
+ * @since 4.1
+ */
+public final class NtlmEngine {
+
+    public static final NtlmEngine INSTANCE = new NtlmEngine();
+
+    /** Unicode encoding */
+    private static final Charset UNICODE_LITTLE_UNMARKED;
+
+    static {
+        Charset c;
+        try {
+            c = Charset.forName("UnicodeLittleUnmarked");
+        } catch (UnsupportedCharsetException e) {
+            c = null;
+        }
+        UNICODE_LITTLE_UNMARKED = c;
+    }
+
+    private static final byte[] MAGIC_CONSTANT = "KGS!@#$%".getBytes(US_ASCII);
+
+    // Flags we use; descriptions according to:
+    // http://davenport.sourceforge.net/ntlm.html
+    // and
+    // http://msdn.microsoft.com/en-us/library/cc236650%28v=prot.20%29.aspx
+    private static final int FLAG_REQUEST_UNICODE_ENCODING = 0x00000001; // Unicode string encoding requested
+    private static final int FLAG_REQUEST_TARGET = 0x00000004; // Requests target field
+    private static final int FLAG_REQUEST_SIGN = 0x00000010; // Requests all messages have a signature attached, in NEGOTIATE message.
+    private static final int FLAG_REQUEST_SEAL = 0x00000020; // Request key exchange for message confidentiality in NEGOTIATE message.  MUST be used in conjunction with 56BIT.
+    private static final int FLAG_REQUEST_LAN_MANAGER_KEY = 0x00000080; // Request Lan Manager key instead of user session key
+    private static final int FLAG_REQUEST_NTLMv1 = 0x00000200; // Request NTLMv1 security.  MUST be set in NEGOTIATE and CHALLENGE both
+    private static final int FLAG_DOMAIN_PRESENT = 0x00001000; // Domain is present in message
+    private static final int FLAG_WORKSTATION_PRESENT = 0x00002000; // Workstation is present in message
+    private static final int FLAG_REQUEST_ALWAYS_SIGN = 0x00008000; // Requests a signature block on all messages.  Overridden by REQUEST_SIGN and REQUEST_SEAL.
+    private static final int FLAG_REQUEST_NTLM2_SESSION = 0x00080000; // From server in challenge, requesting NTLM2 session security
+    private static final int FLAG_REQUEST_VERSION = 0x02000000; // Request protocol version
+    private static final int FLAG_TARGETINFO_PRESENT = 0x00800000; // From server in challenge message, indicating targetinfo is present
+    private static final int FLAG_REQUEST_128BIT_KEY_EXCH = 0x20000000; // Request explicit 128-bit key exchange
+    private static final int FLAG_REQUEST_EXPLICIT_KEY_EXCH = 0x40000000; // Request explicit key exchange
+    private static final int FLAG_REQUEST_56BIT_ENCRYPTION = 0x80000000; // Must be used in conjunction with SEAL
+
+    /** Secure random generator */
+    private static final java.security.SecureRandom RND_GEN;
+    static {
+        java.security.SecureRandom rnd = null;
+        try {
+            rnd = java.security.SecureRandom.getInstance("SHA1PRNG");
+        } catch (final Exception ignore) {
+        }
+        RND_GEN = rnd;
+    }
+
+    /** The signature string as bytes in the default encoding */
+    private static final byte[] SIGNATURE;
+
+    static {
+        final byte[] bytesWithoutNull = "NTLMSSP".getBytes(US_ASCII);
+        SIGNATURE = new byte[bytesWithoutNull.length + 1];
+        System.arraycopy(bytesWithoutNull, 0, SIGNATURE, 0, bytesWithoutNull.length);
+        SIGNATURE[bytesWithoutNull.length] = (byte) 0x00;
+    }
+
+    private static final String TYPE_1_MESSAGE = new Type1Message().getResponse();
+
+    /**
+     * Creates the type 3 message using the given server nonce. The type 3
+     * message includes all the information for authentication, host, domain,
+     * username and the result of encrypting the nonce sent by the server using
+     * the user's password as the key.
+     *
+     * @param user
+     *            The user name. This should not include the domain name.
+     * @param password
+     *            The password.
+     * @param host
+     *            The host that is originating the authentication request.
+     * @param domain
+     *            The domain to authenticate within.
+     * @param nonce
+     *            the 8 byte array the server sent.
+     * @return The type 3 message.
+     * @throws NtlmEngineException
+     *             If {@encrypt(byte[],byte[])} fails.
+     */
+    private String getType3Message(final String user, final String password, final String host, final String domain, final byte[] nonce,
+            final int type2Flags, final String target, final byte[] targetInformation) throws NtlmEngineException {
+        return new Type3Message(domain, host, user, password, nonce, type2Flags, target, targetInformation).getResponse();
+    }
+
+    /** Strip dot suffix from a name */
+    private static String stripDotSuffix(final String value) {
+        if (value == null) {
+            return null;
+        }
+        final int index = value.indexOf(".");
+        if (index != -1) {
+            return value.substring(0, index);
+        }
+        return value;
+    }
+
+    /** Convert host to standard form */
+    private static String convertHost(final String host) {
+        return stripDotSuffix(host);
+    }
+
+    /** Convert domain to standard form */
+    private static String convertDomain(final String domain) {
+        return stripDotSuffix(domain);
+    }
+
+    private static int readULong(final byte[] src, final int index) throws NtlmEngineException {
+        if (src.length < index + 4) {
+            throw new NtlmEngineException("NTLM authentication - buffer too small for DWORD");
+        }
+        return (src[index] & 0xff) | ((src[index + 1] & 0xff) << 8) | ((src[index + 2] & 0xff) << 16) | ((src[index + 3] & 0xff) << 24);
+    }
+
+    private static int readUShort(final byte[] src, final int index) throws NtlmEngineException {
+        if (src.length < index + 2) {
+            throw new NtlmEngineException("NTLM authentication - buffer too small for WORD");
+        }
+        return (src[index] & 0xff) | ((src[index + 1] & 0xff) << 8);
+    }
+
+    private static byte[] readSecurityBuffer(final byte[] src, final int index) throws NtlmEngineException {
+        final int length = readUShort(src, index);
+        final int offset = readULong(src, index + 4);
+        if (src.length < offset + length) {
+            throw new NtlmEngineException("NTLM authentication - buffer too small for data item");
+        }
+        final byte[] buffer = new byte[length];
+        System.arraycopy(src, offset, buffer, 0, length);
+        return buffer;
+    }
+
+    /** Calculate a challenge block */
+    private static byte[] makeRandomChallenge() throws NtlmEngineException {
+        if (RND_GEN == null) {
+            throw new NtlmEngineException("Random generator not available");
+        }
+        final byte[] rval = new byte[8];
+        synchronized (RND_GEN) {
+            RND_GEN.nextBytes(rval);
+        }
+        return rval;
+    }
+
+    /** Calculate a 16-byte secondary key */
+    private static byte[] makeSecondaryKey() throws NtlmEngineException {
+        if (RND_GEN == null) {
+            throw new NtlmEngineException("Random generator not available");
+        }
+        final byte[] rval = new byte[16];
+        synchronized (RND_GEN) {
+            RND_GEN.nextBytes(rval);
+        }
+        return rval;
+    }
+
+    private static class CipherGen {
+
+        protected final String domain;
+        protected final String user;
+        protected final String password;
+        protected final byte[] challenge;
+        protected final String target;
+        protected final byte[] targetInformation;
+
+        // Information we can generate but may be passed in (for testing)
+        protected byte[] clientChallenge;
+        protected byte[] clientChallenge2;
+        protected byte[] secondaryKey;
+        protected byte[] timestamp;
+
+        // Stuff we always generate
+        protected byte[] lmHash = null;
+        protected byte[] lmResponse = null;
+        protected byte[] ntlmHash = null;
+        protected byte[] ntlmResponse = null;
+        protected byte[] ntlmv2Hash = null;
+        protected byte[] lmv2Hash = null;
+        protected byte[] lmv2Response = null;
+        protected byte[] ntlmv2Blob = null;
+        protected byte[] ntlmv2Response = null;
+        protected byte[] ntlm2SessionResponse = null;
+        protected byte[] lm2SessionResponse = null;
+        protected byte[] lmUserSessionKey = null;
+        protected byte[] ntlmUserSessionKey = null;
+        protected byte[] ntlmv2UserSessionKey = null;
+        protected byte[] ntlm2SessionResponseUserSessionKey = null;
+        protected byte[] lanManagerSessionKey = null;
+
+        public CipherGen(final String domain, final String user, final String password, final byte[] challenge, final String target,
+                final byte[] targetInformation, final byte[] clientChallenge, final byte[] clientChallenge2, final byte[] secondaryKey,
+                final byte[] timestamp) {
+            this.domain = domain;
+            this.target = target;
+            this.user = user;
+            this.password = password;
+            this.challenge = challenge;
+            this.targetInformation = targetInformation;
+            this.clientChallenge = clientChallenge;
+            this.clientChallenge2 = clientChallenge2;
+            this.secondaryKey = secondaryKey;
+            this.timestamp = timestamp;
+        }
+
+        public CipherGen(final String domain, final String user, final String password, final byte[] challenge, final String target,
+                final byte[] targetInformation) {
+            this(domain, user, password, challenge, target, targetInformation, null, null, null, null);
+        }
+
+        /** Calculate and return client challenge */
+        public byte[] getClientChallenge() throws NtlmEngineException {
+            if (clientChallenge == null) {
+                clientChallenge = makeRandomChallenge();
+            }
+            return clientChallenge;
+        }
+
+        /** Calculate and return second client challenge */
+        public byte[] getClientChallenge2() throws NtlmEngineException {
+            if (clientChallenge2 == null) {
+                clientChallenge2 = makeRandomChallenge();
+            }
+            return clientChallenge2;
+        }
+
+        /** Calculate and return random secondary key */
+        public byte[] getSecondaryKey() throws NtlmEngineException {
+            if (secondaryKey == null) {
+                secondaryKey = makeSecondaryKey();
+            }
+            return secondaryKey;
+        }
+
+        /** Calculate and return the LMHash */
+        public byte[] getLMHash() throws NtlmEngineException {
+            if (lmHash == null) {
+                lmHash = lmHash(password);
+            }
+            return lmHash;
+        }
+
+        /** Calculate and return the LMResponse */
+        public byte[] getLMResponse() throws NtlmEngineException {
+            if (lmResponse == null) {
+                lmResponse = lmResponse(getLMHash(), challenge);
+            }
+            return lmResponse;
+        }
+
+        /** Calculate and return the NTLMHash */
+        public byte[] getNTLMHash() throws NtlmEngineException {
+            if (ntlmHash == null) {
+                ntlmHash = ntlmHash(password);
+            }
+            return ntlmHash;
+        }
+
+        /** Calculate and return the NTLMResponse */
+        public byte[] getNTLMResponse() throws NtlmEngineException {
+            if (ntlmResponse == null) {
+                ntlmResponse = lmResponse(getNTLMHash(), challenge);
+            }
+            return ntlmResponse;
+        }
+
+        /** Calculate the LMv2 hash */
+        public byte[] getLMv2Hash() throws NtlmEngineException {
+            if (lmv2Hash == null) {
+                lmv2Hash = lmv2Hash(domain, user, getNTLMHash());
+            }
+            return lmv2Hash;
+        }
+
+        /** Calculate the NTLMv2 hash */
+        public byte[] getNTLMv2Hash() throws NtlmEngineException {
+            if (ntlmv2Hash == null) {
+                ntlmv2Hash = ntlmv2Hash(domain, user, getNTLMHash());
+            }
+            return ntlmv2Hash;
+        }
+
+        /** Calculate a timestamp */
+        public byte[] getTimestamp() {
+            if (timestamp == null) {
+                long time = System.currentTimeMillis();
+                time += 11644473600000l; // milliseconds from January 1, 1601 -> epoch.
+                time *= 10000; // tenths of a microsecond.
+                // convert to little-endian byte array.
+                timestamp = new byte[8];
+                for (int i = 0; i < 8; i++) {
+                    timestamp[i] = (byte) time;
+                    time >>>= 8;
+                }
+            }
+            return timestamp;
+        }
+
+        /** Calculate the NTLMv2Blob */
+        public byte[] getNTLMv2Blob() throws NtlmEngineException {
+            if (ntlmv2Blob == null) {
+                ntlmv2Blob = createBlob(getClientChallenge2(), targetInformation, getTimestamp());
+            }
+            return ntlmv2Blob;
+        }
+
+        /** Calculate the NTLMv2Response */
+        public byte[] getNTLMv2Response() throws NtlmEngineException {
+            if (ntlmv2Response == null) {
+                ntlmv2Response = lmv2Response(getNTLMv2Hash(), challenge, getNTLMv2Blob());
+            }
+            return ntlmv2Response;
+        }
+
+        /** Calculate the LMv2Response */
+        public byte[] getLMv2Response() throws NtlmEngineException {
+            if (lmv2Response == null) {
+                lmv2Response = lmv2Response(getLMv2Hash(), challenge, getClientChallenge());
+            }
+            return lmv2Response;
+        }
+
+        /** Get NTLM2SessionResponse */
+        public byte[] getNTLM2SessionResponse() throws NtlmEngineException {
+            if (ntlm2SessionResponse == null) {
+                ntlm2SessionResponse = ntlm2SessionResponse(getNTLMHash(), challenge, getClientChallenge());
+            }
+            return ntlm2SessionResponse;
+        }
+
+        /** Calculate and return LM2 session response */
+        public byte[] getLM2SessionResponse() throws NtlmEngineException {
+            if (lm2SessionResponse == null) {
+                final byte[] clntChallenge = getClientChallenge();
+                lm2SessionResponse = new byte[24];
+                System.arraycopy(clntChallenge, 0, lm2SessionResponse, 0, clntChallenge.length);
+                Arrays.fill(lm2SessionResponse, clntChallenge.length, lm2SessionResponse.length, (byte) 0x00);
+            }
+            return lm2SessionResponse;
+        }
+
+        /** Get LMUserSessionKey */
+        public byte[] getLMUserSessionKey() throws NtlmEngineException {
+            if (lmUserSessionKey == null) {
+                lmUserSessionKey = new byte[16];
+                System.arraycopy(getLMHash(), 0, lmUserSessionKey, 0, 8);
+                Arrays.fill(lmUserSessionKey, 8, 16, (byte) 0x00);
+            }
+            return lmUserSessionKey;
+        }
+
+        /** Get NTLMUserSessionKey */
+        public byte[] getNTLMUserSessionKey() throws NtlmEngineException {
+            if (ntlmUserSessionKey == null) {
+                final MD4 md4 = new MD4();
+                md4.update(getNTLMHash());
+                ntlmUserSessionKey = md4.getOutput();
+            }
+            return ntlmUserSessionKey;
+        }
+
+        /** GetNTLMv2UserSessionKey */
+        public byte[] getNTLMv2UserSessionKey() throws NtlmEngineException {
+            if (ntlmv2UserSessionKey == null) {
+                final byte[] ntlmv2hash = getNTLMv2Hash();
+                final byte[] truncatedResponse = new byte[16];
+                System.arraycopy(getNTLMv2Response(), 0, truncatedResponse, 0, 16);
+                ntlmv2UserSessionKey = hmacMD5(truncatedResponse, ntlmv2hash);
+            }
+            return ntlmv2UserSessionKey;
+        }
+
+        /** Get NTLM2SessionResponseUserSessionKey */
+        public byte[] getNTLM2SessionResponseUserSessionKey() throws NtlmEngineException {
+            if (ntlm2SessionResponseUserSessionKey == null) {
+                final byte[] ntlm2SessionResponseNonce = getLM2SessionResponse();
+                final byte[] sessionNonce = new byte[challenge.length + ntlm2SessionResponseNonce.length];
+                System.arraycopy(challenge, 0, sessionNonce, 0, challenge.length);
+                System.arraycopy(ntlm2SessionResponseNonce, 0, sessionNonce, challenge.length, ntlm2SessionResponseNonce.length);
+                ntlm2SessionResponseUserSessionKey = hmacMD5(sessionNonce, getNTLMUserSessionKey());
+            }
+            return ntlm2SessionResponseUserSessionKey;
+        }
+
+        /** Get LAN Manager session key */
+        public byte[] getLanManagerSessionKey() throws NtlmEngineException {
+            if (lanManagerSessionKey == null) {
+                try {
+                    final byte[] keyBytes = new byte[14];
+                    System.arraycopy(getLMHash(), 0, keyBytes, 0, 8);
+                    Arrays.fill(keyBytes, 8, keyBytes.length, (byte) 0xbd);
+                    final Key lowKey = createDESKey(keyBytes, 0);
+                    final Key highKey = createDESKey(keyBytes, 7);
+                    final byte[] truncatedResponse = new byte[8];
+                    System.arraycopy(getLMResponse(), 0, truncatedResponse, 0, truncatedResponse.length);
+                    Cipher des = Cipher.getInstance("DES/ECB/NoPadding");
+                    des.init(Cipher.ENCRYPT_MODE, lowKey);
+                    final byte[] lowPart = des.doFinal(truncatedResponse);
+                    des = Cipher.getInstance("DES/ECB/NoPadding");
+                    des.init(Cipher.ENCRYPT_MODE, highKey);
+                    final byte[] highPart = des.doFinal(truncatedResponse);
+                    lanManagerSessionKey = new byte[16];
+                    System.arraycopy(lowPart, 0, lanManagerSessionKey, 0, lowPart.length);
+                    System.arraycopy(highPart, 0, lanManagerSessionKey, lowPart.length, highPart.length);
+                } catch (final Exception e) {
+                    throw new NtlmEngineException(e.getMessage(), e);
+                }
+            }
+            return lanManagerSessionKey;
+        }
+    }
+
+    /** Calculates HMAC-MD5 */
+    private static byte[] hmacMD5(final byte[] value, final byte[] key) throws NtlmEngineException {
+        final HMACMD5 hmacMD5 = new HMACMD5(key);
+        hmacMD5.update(value);
+        return hmacMD5.getOutput();
+    }
+
+    /** Calculates RC4 */
+    private static byte[] RC4(final byte[] value, final byte[] key) throws NtlmEngineException {
+        try {
+            final Cipher rc4 = Cipher.getInstance("RC4");
+            rc4.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key, "RC4"));
+            return rc4.doFinal(value);
+        } catch (final Exception e) {
+            throw new NtlmEngineException(e.getMessage(), e);
+        }
+    }
+
+    /**
+     * Calculates the NTLM2 Session Response for the given challenge, using the
+     * specified password and client challenge.
+     *
+     * @return The NTLM2 Session Response. This is placed in the NTLM response
+     *         field of the Type 3 message; the LM response field contains the
+     *         client challenge, null-padded to 24 bytes.
+     */
+    private static byte[] ntlm2SessionResponse(final byte[] ntlmHash, final byte[] challenge, final byte[] clientChallenge)
+            throws NtlmEngineException {
+        try {
+            // Look up MD5 algorithm (was necessary on jdk 1.4.2)
+            // This used to be needed, but java 1.5.0_07 includes the MD5
+            // algorithm (finally)
+            // Class x = Class.forName("gnu.crypto.hash.MD5");
+            // Method updateMethod = x.getMethod("update",new
+            // Class[]{byte[].class});
+            // Method digestMethod = x.getMethod("digest",new Class[0]);
+            // Object mdInstance = x.newInstance();
+            // updateMethod.invoke(mdInstance,new Object[]{challenge});
+            // updateMethod.invoke(mdInstance,new Object[]{clientChallenge});
+            // byte[] digest = (byte[])digestMethod.invoke(mdInstance,new
+            // Object[0]);
+
+            final MessageDigest md5 = MessageDigest.getInstance("MD5");
+            md5.update(challenge);
+            md5.update(clientChallenge);
+            final byte[] digest = md5.digest();
+
+            final byte[] sessionHash = new byte[8];
+            System.arraycopy(digest, 0, sessionHash, 0, 8);
+            return lmResponse(ntlmHash, sessionHash);
+        } catch (final Exception e) {
+            if (e instanceof NtlmEngineException) {
+                throw (NtlmEngineException) e;
+            }
+            throw new NtlmEngineException(e.getMessage(), e);
+        }
+    }
+
+    /**
+     * Creates the LM Hash of the user's password.
+     *
+     * @param password
+     *            The password.
+     *
+     * @return The LM Hash of the given password, used in the calculation of the
+     *         LM Response.
+     */
+    private static byte[] lmHash(final String password) throws NtlmEngineException {
+        try {
+            final byte[] oemPassword = password.toUpperCase(Locale.ROOT).getBytes(US_ASCII);
+            final int length = Math.min(oemPassword.length, 14);
+            final byte[] keyBytes = new byte[14];
+            System.arraycopy(oemPassword, 0, keyBytes, 0, length);
+            final Key lowKey = createDESKey(keyBytes, 0);
+            final Key highKey = createDESKey(keyBytes, 7);
+            final Cipher des = Cipher.getInstance("DES/ECB/NoPadding");
+            des.init(Cipher.ENCRYPT_MODE, lowKey);
+            final byte[] lowHash = des.doFinal(MAGIC_CONSTANT);
+            des.init(Cipher.ENCRYPT_MODE, highKey);
+            final byte[] highHash = des.doFinal(MAGIC_CONSTANT);
+            final byte[] lmHash = new byte[16];
+            System.arraycopy(lowHash, 0, lmHash, 0, 8);
+            System.arraycopy(highHash, 0, lmHash, 8, 8);
+            return lmHash;
+        } catch (final Exception e) {
+            throw new NtlmEngineException(e.getMessage(), e);
+        }
+    }
+
+    /**
+     * Creates the NTLM Hash of the user's password.
+     *
+     * @param password
+     *            The password.
+     *
+     * @return The NTLM Hash of the given password, used in the calculation of
+     *         the NTLM Response and the NTLMv2 and LMv2 Hashes.
+     */
+    private static byte[] ntlmHash(final String password) throws NtlmEngineException {
+        if (UNICODE_LITTLE_UNMARKED == null) {
+            throw new NtlmEngineException("Unicode not supported");
+        }
+        final byte[] unicodePassword = password.getBytes(UNICODE_LITTLE_UNMARKED);
+        final MD4 md4 = new MD4();
+        md4.update(unicodePassword);
+        return md4.getOutput();
+    }
+
+    /**
+     * Creates the LMv2 Hash of the user's password.
+     *
+     * @return The LMv2 Hash, used in the calculation of the NTLMv2 and LMv2
+     *         Responses.
+     */
+    private static byte[] lmv2Hash(final String domain, final String user, final byte[] ntlmHash) throws NtlmEngineException {
+        if (UNICODE_LITTLE_UNMARKED == null) {
+            throw new NtlmEngineException("Unicode not supported");
+        }
+        final HMACMD5 hmacMD5 = new HMACMD5(ntlmHash);
+        // Upper case username, upper case domain!
+        hmacMD5.update(user.toUpperCase(Locale.ROOT).getBytes(UNICODE_LITTLE_UNMARKED));
+        if (domain != null) {
+            hmacMD5.update(domain.toUpperCase(Locale.ROOT).getBytes(UNICODE_LITTLE_UNMARKED));
+        }
+        return hmacMD5.getOutput();
+    }
+
+    /**
+     * Creates the NTLMv2 Hash of the user's password.
+     *
+     * @return The NTLMv2 Hash, used in the calculation of the NTLMv2 and LMv2
+     *         Responses.
+     */
+    private static byte[] ntlmv2Hash(final String domain, final String user, final byte[] ntlmHash) throws NtlmEngineException {
+        if (UNICODE_LITTLE_UNMARKED == null) {
+            throw new NtlmEngineException("Unicode not supported");
+        }
+        final HMACMD5 hmacMD5 = new HMACMD5(ntlmHash);
+        // Upper case username, mixed case target!!
+        hmacMD5.update(user.toUpperCase(Locale.ROOT).getBytes(UNICODE_LITTLE_UNMARKED));
+        if (domain != null) {
+            hmacMD5.update(domain.getBytes(UNICODE_LITTLE_UNMARKED));
+        }
+        return hmacMD5.getOutput();
+    }
+
+    /**
+     * Creates the LM Response from the given hash and Type 2 challenge.
+     *
+     * @param hash
+     *            The LM or NTLM Hash.
+     * @param challenge
+     *            The server challenge from the Type 2 message.
+     *
+     * @return The response (either LM or NTLM, depending on the provided hash).
+     */
+    private static byte[] lmResponse(final byte[] hash, final byte[] challenge) throws NtlmEngineException {
+        try {
+            final byte[] keyBytes = new byte[21];
+            System.arraycopy(hash, 0, keyBytes, 0, 16);
+            final Key lowKey = createDESKey(keyBytes, 0);
+            final Key middleKey = createDESKey(keyBytes, 7);
+            final Key highKey = createDESKey(keyBytes, 14);
+            final Cipher des = Cipher.getInstance("DES/ECB/NoPadding");
+            des.init(Cipher.ENCRYPT_MODE, lowKey);
+            final byte[] lowResponse = des.doFinal(challenge);
+            des.init(Cipher.ENCRYPT_MODE, middleKey);
+            final byte[] middleResponse = des.doFinal(challenge);
+            des.init(Cipher.ENCRYPT_MODE, highKey);
+            final byte[] highResponse = des.doFinal(challenge);
+            final byte[] lmResponse = new byte[24];
+            System.arraycopy(lowResponse, 0, lmResponse, 0, 8);
+            System.arraycopy(middleResponse, 0, lmResponse, 8, 8);
+            System.arraycopy(highResponse, 0, lmResponse, 16, 8);
+            return lmResponse;
+        } catch (final Exception e) {
+            throw new NtlmEngineException(e.getMessage(), e);
+        }
+    }
+
+    /**
+     * Creates the LMv2 Response from the given hash, client data, and Type 2
+     * challenge.
+     *
+     * @param hash
+     *            The NTLMv2 Hash.
+     * @param clientData
+     *            The client data (blob or client challenge).
+     * @param challenge
+     *            The server challenge from the Type 2 message.
+     *
+     * @return The response (either NTLMv2 or LMv2, depending on the client
+     *         data).
+     */
+    private static byte[] lmv2Response(final byte[] hash, final byte[] challenge, final byte[] clientData) throws NtlmEngineException {
+        final HMACMD5 hmacMD5 = new HMACMD5(hash);
+        hmacMD5.update(challenge);
+        hmacMD5.update(clientData);
+        final byte[] mac = hmacMD5.getOutput();
+        final byte[] lmv2Response = new byte[mac.length + clientData.length];
+        System.arraycopy(mac, 0, lmv2Response, 0, mac.length);
+        System.arraycopy(clientData, 0, lmv2Response, mac.length, clientData.length);
+        return lmv2Response;
+    }
+
+    /**
+     * Creates the NTLMv2 blob from the given target information block and
+     * client challenge.
+     *
+     * @param targetInformation
+     *            The target information block from the Type 2 message.
+     * @param clientChallenge
+     *            The random 8-byte client challenge.
+     *
+     * @return The blob, used in the calculation of the NTLMv2 Response.
+     */
+    private static byte[] createBlob(final byte[] clientChallenge, final byte[] targetInformation, final byte[] timestamp) {
+        final byte[] blobSignature = new byte[] { (byte) 0x01, (byte) 0x01, (byte) 0x00, (byte) 0x00 };
+        final byte[] reserved = new byte[] { (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00 };
+        final byte[] unknown1 = new byte[] { (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00 };
+        final byte[] unknown2 = new byte[] { (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00 };
+        final byte[] blob = new byte[blobSignature.length + reserved.length + timestamp.length + 8 + unknown1.length
+                + targetInformation.length + unknown2.length];
+        int offset = 0;
+        System.arraycopy(blobSignature, 0, blob, offset, blobSignature.length);
+        offset += blobSignature.length;
+        System.arraycopy(reserved, 0, blob, offset, reserved.length);
+        offset += reserved.length;
+        System.arraycopy(timestamp, 0, blob, offset, timestamp.length);
+        offset += timestamp.length;
+        System.arraycopy(clientChallenge, 0, blob, offset, 8);
+        offset += 8;
+        System.arraycopy(unknown1, 0, blob, offset, unknown1.length);
+        offset += unknown1.length;
+        System.arraycopy(targetInformation, 0, blob, offset, targetInformation.length);
+        offset += targetInformation.length;
+        System.arraycopy(unknown2, 0, blob, offset, unknown2.length);
+        offset += unknown2.length;
+        return blob;
+    }
+
+    /**
+     * Creates a DES encryption key from the given key material.
+     *
+     * @param bytes
+     *            A byte array containing the DES key material.
+     * @param offset
+     *            The offset in the given byte array at which the 7-byte key
+     *            material starts.
+     *
+     * @return A DES encryption key created from the key material starting at
+     *         the specified offset in the given byte array.
+     */
+    private static Key createDESKey(final byte[] bytes, final int offset) {
+        final byte[] keyBytes = new byte[7];
+        System.arraycopy(bytes, offset, keyBytes, 0, 7);
+        final byte[] material = new byte[8];
+        material[0] = keyBytes[0];
+        material[1] = (byte) (keyBytes[0] << 7 | (keyBytes[1] & 0xff) >>> 1);
+        material[2] = (byte) (keyBytes[1] << 6 | (keyBytes[2] & 0xff) >>> 2);
+        material[3] = (byte) (keyBytes[2] << 5 | (keyBytes[3] & 0xff) >>> 3);
+        material[4] = (byte) (keyBytes[3] << 4 | (keyBytes[4] & 0xff) >>> 4);
+        material[5] = (byte) (keyBytes[4] << 3 | (keyBytes[5] & 0xff) >>> 5);
+        material[6] = (byte) (keyBytes[5] << 2 | (keyBytes[6] & 0xff) >>> 6);
+        material[7] = (byte) (keyBytes[6] << 1);
+        oddParity(material);
+        return new SecretKeySpec(material, "DES");
+    }
+
+    /**
+     * Applies odd parity to the given byte array.
+     *
+     * @param bytes
+     *            The data whose parity bits are to be adjusted for odd parity.
+     */
+    private static void oddParity(final byte[] bytes) {
+        for (int i = 0; i < bytes.length; i++) {
+            final byte b = bytes[i];
+            final boolean needsParity = (((b >>> 7) ^ (b >>> 6) ^ (b >>> 5) ^ (b >>> 4) ^ (b >>> 3) ^ (b >>> 2) ^ (b >>> 1)) & 0x01) == 0;
+            if (needsParity) {
+                bytes[i] |= (byte) 0x01;
+            } else {
+                bytes[i] &= (byte) 0xfe;
+            }
+        }
+    }
+
+    /** NTLM message generation, base class */
+    private static class NTLMMessage {
+        /** The current response */
+        private byte[] messageContents = null;
+
+        /** The current output position */
+        private int currentOutputPosition = 0;
+
+        /** Constructor to use when message contents are not yet known */
+        NTLMMessage() {
+        }
+
+        /** Constructor to use when message contents are known */
+        NTLMMessage(final String messageBody, final int expectedType) throws NtlmEngineException {
+            messageContents = Base64.decode(messageBody);
+            // Look for NTLM message
+            if (messageContents.length < SIGNATURE.length) {
+                throw new NtlmEngineException("NTLM message decoding error - packet too short");
+            }
+            int i = 0;
+            while (i < SIGNATURE.length) {
+                if (messageContents[i] != SIGNATURE[i]) {
+                    throw new NtlmEngineException("NTLM message expected - instead got unrecognized bytes");
+                }
+                i++;
+            }
+
+            // Check to be sure there's a type 2 message indicator next
+            final int type = readULong(SIGNATURE.length);
+            if (type != expectedType) {
+                throw new NtlmEngineException("NTLM type " + Integer.toString(expectedType) + " message expected - instead got type "
+                        + Integer.toString(type));
+            }
+
+            currentOutputPosition = messageContents.length;
+        }
+
+        /**
+         * Get the length of the signature and flags, so calculations can adjust
+         * offsets accordingly.
+         */
+        protected int getPreambleLength() {
+            return SIGNATURE.length + 4;
+        }
+
+        /** Get the message length */
+        protected int getMessageLength() {
+            return currentOutputPosition;
+        }
+
+        /** Read a byte from a position within the message buffer */
+        protected byte readByte(final int position) throws NtlmEngineException {
+            if (messageContents.length < position + 1) {
+                throw new NtlmEngineException("NTLM: Message too short");
+            }
+            return messageContents[position];
+        }
+
+        /** Read a bunch of bytes from a position in the message buffer */
+        protected void readBytes(final byte[] buffer, final int position) throws NtlmEngineException {
+            if (messageContents.length < position + buffer.length) {
+                throw new NtlmEngineException("NTLM: Message too short");
+            }
+            System.arraycopy(messageContents, position, buffer, 0, buffer.length);
+        }
+
+        /** Read a ushort from a position within the message buffer */
+        protected int readUShort(final int position) throws NtlmEngineException {
+            return NtlmEngine.readUShort(messageContents, position);
+        }
+
+        /** Read a ulong from a position within the message buffer */
+        protected int readULong(final int position) throws NtlmEngineException {
+            return NtlmEngine.readULong(messageContents, position);
+        }
+
+        /** Read a security buffer from a position within the message buffer */
+        protected byte[] readSecurityBuffer(final int position) throws NtlmEngineException {
+            return NtlmEngine.readSecurityBuffer(messageContents, position);
+        }
+
+        /**
+         * Prepares the object to create a response of the given length.
+         *
+         * @param maxlength
+         *            the maximum length of the response to prepare, not
+         *            including the type and the signature (which this method
+         *            adds).
+         */
+        protected void prepareResponse(final int maxlength, final int messageType) {
+            messageContents = new byte[maxlength];
+            currentOutputPosition = 0;
+            addBytes(SIGNATURE);
+            addULong(messageType);
+        }
+
+        /**
+         * Adds the given byte to the response.
+         *
+         * @param b
+         *            the byte to add.
+         */
+        protected void addByte(final byte b) {
+            messageContents[currentOutputPosition] = b;
+            currentOutputPosition++;
+        }
+
+        /**
+         * Adds the given bytes to the response.
+         *
+         * @param bytes
+         *            the bytes to add.
+         */
+        protected void addBytes(final byte[] bytes) {
+            if (bytes == null) {
+                return;
+            }
+            for (final byte b : bytes) {
+                messageContents[currentOutputPosition] = b;
+                currentOutputPosition++;
+            }
+        }
+
+        /** Adds a USHORT to the response */
+        protected void addUShort(final int value) {
+            addByte((byte) (value & 0xff));
+            addByte((byte) (value >> 8 & 0xff));
+        }
+
+        /** Adds a ULong to the response */
+        protected void addULong(final int value) {
+            addByte((byte) (value & 0xff));
+            addByte((byte) (value >> 8 & 0xff));
+            addByte((byte) (value >> 16 & 0xff));
+            addByte((byte) (value >> 24 & 0xff));
+        }
+
+        /**
+         * Returns the response that has been generated after shrinking the
+         * array if required and base64 encodes the response.
+         *
+         * @return The response as above.
+         */
+        String getResponse() {
+            final byte[] resp;
+            if (messageContents.length > currentOutputPosition) {
+                final byte[] tmp = new byte[currentOutputPosition];
+                System.arraycopy(messageContents, 0, tmp, 0, currentOutputPosition);
+                resp = tmp;
+            } else {
+                resp = messageContents;
+            }
+            return Base64.encode(resp);
+        }
+
+    }
+
+    /** Type 1 message assembly class */
+    private static class Type1Message extends NTLMMessage {
+
+        /**
+         * Getting the response involves building the message before returning
+         * it
+         */
+        @Override
+        String getResponse() {
+            // Now, build the message. Calculate its length first, including
+            // signature or type.
+            final int finalLength = 32 + 8;
+
+            // Set up the response. This will initialize the signature, message
+            // type, and flags.
+            prepareResponse(finalLength, 1);
+
+            // Flags. These are the complete set of flags we support.
+            addULong(
+            //FLAG_WORKSTATION_PRESENT |
+            //FLAG_DOMAIN_PRESENT |
+
+            // Required flags
+            //FLAG_REQUEST_LAN_MANAGER_KEY |
+            FLAG_REQUEST_NTLMv1 | FLAG_REQUEST_NTLM2_SESSION |
+
+            // Protocol version request
+                    FLAG_REQUEST_VERSION |
+
+                    // Recommended privacy settings
+                    FLAG_REQUEST_ALWAYS_SIGN |
+                    //FLAG_REQUEST_SEAL |
+                    //FLAG_REQUEST_SIGN |
+
+                    // These must be set according to documentation, based on use of SEAL above
+                    FLAG_REQUEST_128BIT_KEY_EXCH | FLAG_REQUEST_56BIT_ENCRYPTION |
+                    //FLAG_REQUEST_EXPLICIT_KEY_EXCH |
+
+                    FLAG_REQUEST_UNICODE_ENCODING);
+
+            // Domain length (two times).
+            addUShort(0);
+            addUShort(0);
+
+            // Domain offset.
+            addULong(finalLength);
+
+            // Host length (two times).
+            addUShort(0);
+            addUShort(0);
+
+            // Host offset (always 32 + 8).
+            addULong(finalLength);
+
+            // Version
+            addUShort(0x0105);
+            // Build
+            addULong(2600);
+            // NTLM revision
+            addUShort(0x0f00);
+
+            return super.getResponse();
+        }
+    }
+
+    /** Type 2 message class */
+    static class Type2Message extends NTLMMessage {
+        protected byte[] challenge;
+        protected String target;
+        protected byte[] targetInfo;
+        protected int flags;
+
+        Type2Message(final String message) throws NtlmEngineException {
+            super(message, 2);
+
+            // Type 2 message is laid out as follows:
+            // First 8 bytes: NTLMSSP[0]
+            // Next 4 bytes: Ulong, value 2
+            // Next 8 bytes, starting at offset 12: target field (2 ushort lengths, 1 ulong offset)
+            // Next 4 bytes, starting at offset 20: Flags, e.g. 0x22890235
+            // Next 8 bytes, starting at offset 24: Challenge
+            // Next 8 bytes, starting at offset 32: ??? (8 bytes of zeros)
+            // Next 8 bytes, starting at offset 40: targetinfo field (2 ushort lengths, 1 ulong offset)
+            // Next 2 bytes, major/minor version number (e.g. 0x05 0x02)
+            // Next 8 bytes, build number
+            // Next 2 bytes, protocol version number (e.g. 0x00 0x0f)
+            // Next, various text fields, and a ushort of value 0 at the end
+
+            // Parse out the rest of the info we need from the message
+            // The nonce is the 8 bytes starting from the byte in position 24.
+            challenge = new byte[8];
+            readBytes(challenge, 24);
+
+            flags = readULong(20);
+
+            if ((flags & FLAG_REQUEST_UNICODE_ENCODING) == 0) {
+                throw new NtlmEngineException("NTLM type 2 message indicates no support for Unicode. Flags are: " + Integer.toString(flags));
+            }
+
+            // Do the target!
+            target = null;
+            // The TARGET_DESIRED flag is said to not have understood semantics
+            // in Type2 messages, so use the length of the packet to decide
+            // how to proceed instead
+            if (getMessageLength() >= 12 + 8) {
+                final byte[] bytes = readSecurityBuffer(12);
+                if (bytes.length != 0) {
+                    try {
+                        target = new String(bytes, "UnicodeLittleUnmarked");
+                    } catch (final UnsupportedEncodingException e) {
+                        throw new NtlmEngineException(e.getMessage(), e);
+                    }
+                }
+            }
+
+            // Do the target info!
+            targetInfo = null;
+            // TARGET_DESIRED flag cannot be relied on, so use packet length
+            if (getMessageLength() >= 40 + 8) {
+                final byte[] bytes = readSecurityBuffer(40);
+                if (bytes.length != 0) {
+                    targetInfo = bytes;
+                }
+            }
+        }
+
+        /** Retrieve the challenge */
+        byte[] getChallenge() {
+            return challenge;
+        }
+
+        /** Retrieve the target */
+        String getTarget() {
+            return target;
+        }
+
+        /** Retrieve the target info */
+        byte[] getTargetInfo() {
+            return targetInfo;
+        }
+
+        /** Retrieve the response flags */
+        int getFlags() {
+            return flags;
+        }
+
+    }
+
+    /** Type 3 message assembly class */
+    static class Type3Message extends NTLMMessage {
+        // Response flags from the type2 message
+        protected int type2Flags;
+
+        protected byte[] domainBytes;
+        protected byte[] hostBytes;
+        protected byte[] userBytes;
+
+        protected byte[] lmResp;
+        protected byte[] ntResp;
+        protected byte[] sessionKey;
+
+        /** Constructor. Pass the arguments we will need */
+        Type3Message(final String domain, final String host, final String user, final String password, final byte[] nonce,
+                final int type2Flags, final String target, final byte[] targetInformation) throws NtlmEngineException {
+            // Save the flags
+            this.type2Flags = type2Flags;
+
+            // Strip off domain name from the host!
+            final String unqualifiedHost = convertHost(host);
+            // Use only the base domain name!
+            final String unqualifiedDomain = convertDomain(domain);
+
+            // Create a cipher generator class.  Use domain BEFORE it gets modified!
+            final CipherGen gen = new CipherGen(unqualifiedDomain, user, password, nonce, target, targetInformation);
+
+            // Use the new code to calculate the responses, including v2 if that
+            // seems warranted.
+            byte[] userSessionKey;
+            try {
+                // This conditional may not work on Windows Server 2008 R2 and above, where it has not yet
+                // been tested
+                if (((type2Flags & FLAG_TARGETINFO_PRESENT) != 0) && targetInformation != null && target != null) {
+                    // NTLMv2
+                    ntResp = gen.getNTLMv2Response();
+                    lmResp = gen.getLMv2Response();
+                    if ((type2Flags & FLAG_REQUEST_LAN_MANAGER_KEY) != 0) {
+                        userSessionKey = gen.getLanManagerSessionKey();
+                    } else {
+                        userSessionKey = gen.getNTLMv2UserSessionKey();
+                    }
+                } else {
+                    // NTLMv1
+                    if ((type2Flags & FLAG_REQUEST_NTLM2_SESSION) != 0) {
+                        // NTLM2 session stuff is requested
+                        ntResp = gen.getNTLM2SessionResponse();
+                        lmResp = gen.getLM2SessionResponse();
+                        if ((type2Flags & FLAG_REQUEST_LAN_MANAGER_KEY) != 0) {
+                            userSessionKey = gen.getLanManagerSessionKey();
+                        } else {
+                            userSessionKey = gen.getNTLM2SessionResponseUserSessionKey();
+                        }
+                    } else {
+                        ntResp = gen.getNTLMResponse();
+                        lmResp = gen.getLMResponse();
+                        if ((type2Flags & FLAG_REQUEST_LAN_MANAGER_KEY) != 0) {
+                            userSessionKey = gen.getLanManagerSessionKey();
+                        } else {
+                            userSessionKey = gen.getNTLMUserSessionKey();
+                        }
+                    }
+                }
+            } catch (final NtlmEngineException e) {
+                // This likely means we couldn't find the MD4 hash algorithm -
+                // fail back to just using LM
+                ntResp = new byte[0];
+                lmResp = gen.getLMResponse();
+                if ((type2Flags & FLAG_REQUEST_LAN_MANAGER_KEY) != 0) {
+                    userSessionKey = gen.getLanManagerSessionKey();
+                } else {
+                    userSessionKey = gen.getLMUserSessionKey();
+                }
+            }
+
+            if ((type2Flags & FLAG_REQUEST_SIGN) != 0) {
+                if ((type2Flags & FLAG_REQUEST_EXPLICIT_KEY_EXCH) != 0) {
+                    sessionKey = RC4(gen.getSecondaryKey(), userSessionKey);
+                } else {
+                    sessionKey = userSessionKey;
+                }
+            } else {
+                sessionKey = null;
+            }
+            if (UNICODE_LITTLE_UNMARKED == null) {
+                throw new NtlmEngineException("Unicode not supported");
+            }
+            hostBytes = unqualifiedHost != null ? unqualifiedHost.getBytes(UNICODE_LITTLE_UNMARKED) : null;
+            domainBytes = unqualifiedDomain != null ? unqualifiedDomain.toUpperCase(Locale.ROOT).getBytes(UNICODE_LITTLE_UNMARKED) : null;
+            userBytes = user.getBytes(UNICODE_LITTLE_UNMARKED);
+        }
+
+        /** Assemble the response */
+        @Override
+        String getResponse() {
+            final int ntRespLen = ntResp.length;
+            final int lmRespLen = lmResp.length;
+
+            final int domainLen = domainBytes != null ? domainBytes.length : 0;
+            final int hostLen = hostBytes != null ? hostBytes.length : 0;
+            final int userLen = userBytes.length;
+            final int sessionKeyLen;
+            if (sessionKey != null) {
+                sessionKeyLen = sessionKey.length;
+            } else {
+                sessionKeyLen = 0;
+            }
+
+            // Calculate the layout within the packet
+            final int lmRespOffset = 72; // allocate space for the version
+            final int ntRespOffset = lmRespOffset + lmRespLen;
+            final int domainOffset = ntRespOffset + ntRespLen;
+            final int userOffset = domainOffset + domainLen;
+            final int hostOffset = userOffset + userLen;
+            final int sessionKeyOffset = hostOffset + hostLen;
+            final int finalLength = sessionKeyOffset + sessionKeyLen;
+
+            // Start the response. Length includes signature and type
+            prepareResponse(finalLength, 3);
+
+            // LM Resp Length (twice)
+            addUShort(lmRespLen);
+            addUShort(lmRespLen);
+
+            // LM Resp Offset
+            addULong(lmRespOffset);
+
+            // NT Resp Length (twice)
+            addUShort(ntRespLen);
+            addUShort(ntRespLen);
+
+            // NT Resp Offset
+            addULong(ntRespOffset);
+
+            // Domain length (twice)
+            addUShort(domainLen);
+            addUShort(domainLen);
+
+            // Domain offset.
+            addULong(domainOffset);
+
+            // User Length (twice)
+            addUShort(userLen);
+            addUShort(userLen);
+
+            // User offset
+            addULong(userOffset);
+
+            // Host length (twice)
+            addUShort(hostLen);
+            addUShort(hostLen);
+
+            // Host offset
+            addULong(hostOffset);
+
+            // Session key length (twice)
+            addUShort(sessionKeyLen);
+            addUShort(sessionKeyLen);
+
+            // Session key offset
+            addULong(sessionKeyOffset);
+
+            // Flags.
+            addULong(
+            //FLAG_WORKSTATION_PRESENT |
+            //FLAG_DOMAIN_PRESENT |
+
+            // Required flags
+            (type2Flags & FLAG_REQUEST_LAN_MANAGER_KEY)
+                    | (type2Flags & FLAG_REQUEST_NTLMv1)
+                    | (type2Flags & FLAG_REQUEST_NTLM2_SESSION)
+                    |
+
+                    // Protocol version request
+                    FLAG_REQUEST_VERSION
+                    |
+
+                    // Recommended privacy settings
+                    (type2Flags & FLAG_REQUEST_ALWAYS_SIGN) | (type2Flags & FLAG_REQUEST_SEAL)
+                    | (type2Flags & FLAG_REQUEST_SIGN)
+                    |
+
+                    // These must be set according to documentation, based on use of SEAL above
+                    (type2Flags & FLAG_REQUEST_128BIT_KEY_EXCH) | (type2Flags & FLAG_REQUEST_56BIT_ENCRYPTION)
+                    | (type2Flags & FLAG_REQUEST_EXPLICIT_KEY_EXCH) |
+
+                    (type2Flags & FLAG_TARGETINFO_PRESENT) | (type2Flags & FLAG_REQUEST_UNICODE_ENCODING)
+                    | (type2Flags & FLAG_REQUEST_TARGET));
+
+            // Version
+            addUShort(0x0105);
+            // Build
+            addULong(2600);
+            // NTLM revision
+            addUShort(0x0f00);
+
+            // Add the actual data
+            addBytes(lmResp);
+            addBytes(ntResp);
+            addBytes(domainBytes);
+            addBytes(userBytes);
+            addBytes(hostBytes);
+            if (sessionKey != null) {
+                addBytes(sessionKey);
+            }
+
+            return super.getResponse();
+        }
+    }
+
+    static void writeULong(final byte[] buffer, final int value, final int offset) {
+        buffer[offset] = (byte) (value & 0xff);
+        buffer[offset + 1] = (byte) (value >> 8 & 0xff);
+        buffer[offset + 2] = (byte) (value >> 16 & 0xff);
+        buffer[offset + 3] = (byte) (value >> 24 & 0xff);
+    }
+
+    static int F(final int x, final int y, final int z) {
+        return ((x & y) | (~x & z));
+    }
+
+    static int G(final int x, final int y, final int z) {
+        return ((x & y) | (x & z) | (y & z));
+    }
+
+    static int H(final int x, final int y, final int z) {
+        return (x ^ y ^ z);
+    }
+
+    static int rotintlft(final int val, final int numbits) {
+        return ((val << numbits) | (val >>> (32 - numbits)));
+    }
+
+    /**
+     * Cryptography support - MD4. The following class was based loosely on the
+     * RFC and on code found at http://www.cs.umd.edu/~harry/jotp/src/md.java.
+     * Code correctness was verified by looking at MD4.java from the jcifs
+     * library (http://jcifs.samba.org). It was massaged extensively to the
+     * final form found here by Karl Wright (kwright@metacarta.com).
+     */
+    static class MD4 {
+        protected int A = 0x67452301;
+        protected int B = 0xefcdab89;
+        protected int C = 0x98badcfe;
+        protected int D = 0x10325476;
+        protected long count = 0L;
+        protected byte[] dataBuffer = new byte[64];
+
+        MD4() {
+        }
+
+        void update(final byte[] input) {
+            // We always deal with 512 bits at a time. Correspondingly, there is
+            // a buffer 64 bytes long that we write data into until it gets
+            // full.
+            int curBufferPos = (int) (count & 63L);
+            int inputIndex = 0;
+            while (input.length - inputIndex + curBufferPos >= dataBuffer.length) {
+                // We have enough data to do the next step. Do a partial copy
+                // and a transform, updating inputIndex and curBufferPos
+                // accordingly
+                final int transferAmt = dataBuffer.length - curBufferPos;
+                System.arraycopy(input, inputIndex, dataBuffer, curBufferPos, transferAmt);
+                count += transferAmt;
+                curBufferPos = 0;
+                inputIndex += transferAmt;
+                processBuffer();
+            }
+
+            // If there's anything left, copy it into the buffer and leave it.
+            // We know there's not enough left to process.
+            if (inputIndex < input.length) {
+                final int transferAmt = input.length - inputIndex;
+                System.arraycopy(input, inputIndex, dataBuffer, curBufferPos, transferAmt);
+                count += transferAmt;
+                curBufferPos += transferAmt;
+            }
+        }
+
+        byte[] getOutput() {
+            // Feed pad/length data into engine. This must round out the input
+            // to a multiple of 512 bits.
+            final int bufferIndex = (int) (count & 63L);
+            final int padLen = (bufferIndex < 56) ? (56 - bufferIndex) : (120 - bufferIndex);
+            final byte[] postBytes = new byte[padLen + 8];
+            // Leading 0x80, specified amount of zero padding, then length in
+            // bits.
+            postBytes[0] = (byte) 0x80;
+            // Fill out the last 8 bytes with the length
+            for (int i = 0; i < 8; i++) {
+                postBytes[padLen + i] = (byte) ((count * 8) >>> (8 * i));
+            }
+
+            // Update the engine
+            update(postBytes);
+
+            // Calculate final result
+            final byte[] result = new byte[16];
+            writeULong(result, A, 0);
+            writeULong(result, B, 4);
+            writeULong(result, C, 8);
+            writeULong(result, D, 12);
+            return result;
+        }
+
+        protected void processBuffer() {
+            // Convert current buffer to 16 ulongs
+            final int[] d = new int[16];
+
+            for (int i = 0; i < 16; i++) {
+                d[i] = (dataBuffer[i * 4] & 0xff) + ((dataBuffer[i * 4 + 1] & 0xff) << 8) + ((dataBuffer[i * 4 + 2] & 0xff) << 16)
+                        + ((dataBuffer[i * 4 + 3] & 0xff) << 24);
+            }
+
+            // Do a round of processing
+            final int AA = A;
+            final int BB = B;
+            final int CC = C;
+            final int DD = D;
+            round1(d);
+            round2(d);
+            round3(d);
+            A += AA;
+            B += BB;
+            C += CC;
+            D += DD;
+
+        }
+
+        protected void round1(final int[] d) {
+            A = rotintlft((A + F(B, C, D) + d[0]), 3);
+            D = rotintlft((D + F(A, B, C) + d[1]), 7);
+            C = rotintlft((C + F(D, A, B) + d[2]), 11);
+            B = rotintlft((B + F(C, D, A) + d[3]), 19);
+
+            A = rotintlft((A + F(B, C, D) + d[4]), 3);
+            D = rotintlft((D + F(A, B, C) + d[5]), 7);
+            C = rotintlft((C + F(D, A, B) + d[6]), 11);
+            B = rotintlft((B + F(C, D, A) + d[7]), 19);
+
+            A = rotintlft((A + F(B, C, D) + d[8]), 3);
+            D = rotintlft((D + F(A, B, C) + d[9]), 7);
+            C = rotintlft((C + F(D, A, B) + d[10]), 11);
+            B = rotintlft((B + F(C, D, A) + d[11]), 19);
+
+            A = rotintlft((A + F(B, C, D) + d[12]), 3);
+            D = rotintlft((D + F(A, B, C) + d[13]), 7);
+            C = rotintlft((C + F(D, A, B) + d[14]), 11);
+            B = rotintlft((B + F(C, D, A) + d[15]), 19);
+        }
+
+        protected void round2(final int[] d) {
+            A = rotintlft((A + G(B, C, D) + d[0] + 0x5a827999), 3);
+            D = rotintlft((D + G(A, B, C) + d[4] + 0x5a827999), 5);
+            C = rotintlft((C + G(D, A, B) + d[8] + 0x5a827999), 9);
+            B = rotintlft((B + G(C, D, A) + d[12] + 0x5a827999), 13);
+
+            A = rotintlft((A + G(B, C, D) + d[1] + 0x5a827999), 3);
+            D = rotintlft((D + G(A, B, C) + d[5] + 0x5a827999), 5);
+            C = rotintlft((C + G(D, A, B) + d[9] + 0x5a827999), 9);
+            B = rotintlft((B + G(C, D, A) + d[13] + 0x5a827999), 13);
+
+            A = rotintlft((A + G(B, C, D) + d[2] + 0x5a827999), 3);
+            D = rotintlft((D + G(A, B, C) + d[6] + 0x5a827999), 5);
+            C = rotintlft((C + G(D, A, B) + d[10] + 0x5a827999), 9);
+            B = rotintlft((B + G(C, D, A) + d[14] + 0x5a827999), 13);
+
+            A = rotintlft((A + G(B, C, D) + d[3] + 0x5a827999), 3);
+            D = rotintlft((D + G(A, B, C) + d[7] + 0x5a827999), 5);
+            C = rotintlft((C + G(D, A, B) + d[11] + 0x5a827999), 9);
+            B = rotintlft((B + G(C, D, A) + d[15] + 0x5a827999), 13);
+
+        }
+
+        protected void round3(final int[] d) {
+            A = rotintlft((A + H(B, C, D) + d[0] + 0x6ed9eba1), 3);
+            D = rotintlft((D + H(A, B, C) + d[8] + 0x6ed9eba1), 9);
+            C = rotintlft((C + H(D, A, B) + d[4] + 0x6ed9eba1), 11);
+            B = rotintlft((B + H(C, D, A) + d[12] + 0x6ed9eba1), 15);
+
+            A = rotintlft((A + H(B, C, D) + d[2] + 0x6ed9eba1), 3);
+            D = rotintlft((D + H(A, B, C) + d[10] + 0x6ed9eba1), 9);
+            C = rotintlft((C + H(D, A, B) + d[6] + 0x6ed9eba1), 11);
+            B = rotintlft((B + H(C, D, A) + d[14] + 0x6ed9eba1), 15);
+
+            A = rotintlft((A + H(B, C, D) + d[1] + 0x6ed9eba1), 3);
+            D = rotintlft((D + H(A, B, C) + d[9] + 0x6ed9eba1), 9);
+            C = rotintlft((C + H(D, A, B) + d[5] + 0x6ed9eba1), 11);
+            B = rotintlft((B + H(C, D, A) + d[13] + 0x6ed9eba1), 15);
+
+            A = rotintlft((A + H(B, C, D) + d[3] + 0x6ed9eba1), 3);
+            D = rotintlft((D + H(A, B, C) + d[11] + 0x6ed9eba1), 9);
+            C = rotintlft((C + H(D, A, B) + d[7] + 0x6ed9eba1), 11);
+            B = rotintlft((B + H(C, D, A) + d[15] + 0x6ed9eba1), 15);
+        }
+    }
+
+    /**
+     * Cryptography support - HMACMD5 - algorithmically based on various web
+     * resources by Karl Wright
+     */
+    private static class HMACMD5 {
+        protected byte[] ipad;
+        protected byte[] opad;
+        protected MessageDigest md5;
+
+        HMACMD5(final byte[] input) throws NtlmEngineException {
+            byte[] key = input;
+            try {
+                md5 = MessageDigest.getInstance("MD5");
+            } catch (final Exception ex) {
+                // Umm, the algorithm doesn't exist - throw an
+                // NTLMEngineException!
+                throw new NtlmEngineException("Error getting md5 message digest implementation: " + ex.getMessage(), ex);
+            }
+
+            // Initialize the pad buffers with the key
+            ipad = new byte[64];
+            opad = new byte[64];
+
+            int keyLength = key.length;
+            if (keyLength > 64) {
+                // Use MD5 of the key instead, as described in RFC 2104
+                md5.update(key);
+                key = md5.digest();
+                keyLength = key.length;
+            }
+            int i = 0;
+            while (i < keyLength) {
+                ipad[i] = (byte) (key[i] ^ (byte) 0x36);
+                opad[i] = (byte) (key[i] ^ (byte) 0x5c);
+                i++;
+            }
+            while (i < 64) {
+                ipad[i] = (byte) 0x36;
+                opad[i] = (byte) 0x5c;
+                i++;
+            }
+
+            // Very important: update the digest with the ipad buffer
+            md5.reset();
+            md5.update(ipad);
+
+        }
+
+        /** Grab the current digest. This is the "answer". */
+        byte[] getOutput() {
+            final byte[] digest = md5.digest();
+            md5.update(opad);
+            return md5.digest(digest);
+        }
+
+        /** Update by adding a complete array */
+        void update(final byte[] input) {
+            md5.update(input);
+        }
+    }
+
+    /**
+     * Creates the first message (type 1 message) in the NTLM authentication
+     * sequence. This message includes the user name, domain and host for the
+     * authentication session.
+     *
+     * @return String the message to add to the HTTP request header.
+     */    
+    public String generateType1Msg() {
+        return TYPE_1_MESSAGE;
+    }
+
+    public String generateType3Msg(final String username, final String password, final String domain, final String workstation,
+            final String challenge) throws NtlmEngineException {
+        final Type2Message t2m = new Type2Message(challenge);
+        return getType3Message(username, password, workstation, domain, t2m.getChallenge(), t2m.getFlags(), t2m.getTarget(),
+                t2m.getTargetInfo());
+    }
+
+}
\ No newline at end of file
diff --git a/api/src/main/java/org/asynchttpclient/ntlm/NTLMEngineException.java b/api/src/main/java/org/asynchttpclient/ntlm/NtlmEngineException.java
similarity index 88%
rename from api/src/main/java/org/asynchttpclient/ntlm/NTLMEngineException.java
rename to api/src/main/java/org/asynchttpclient/ntlm/NtlmEngineException.java
index a7fd1da9f..23f005ebf 100644
--- a/api/src/main/java/org/asynchttpclient/ntlm/NTLMEngineException.java
+++ b/api/src/main/java/org/asynchttpclient/ntlm/NtlmEngineException.java
@@ -26,25 +26,20 @@
 
 package org.asynchttpclient.ntlm;
 
+
 /**
  * Signals NTLM protocol failure.
- *
- * @since 4.0
  */
-public class NTLMEngineException extends Exception {
+public class NtlmEngineException extends RuntimeException {
 
     private static final long serialVersionUID = 6027981323731768824L;
 
-    public NTLMEngineException() {
-        super();
-    }
-
     /**
      * Creates a new NTLMEngineException with the specified message.
      *
      * @param message the exception detail message
      */
-    public NTLMEngineException(String message) {
+    public NtlmEngineException(String message) {
         super(message);
     }
 
@@ -55,7 +50,7 @@ public NTLMEngineException(String message) {
      * @param cause   the <tt>Throwable</tt> that caused this exception, or <tt>null</tt>
      *                if the cause is unavailable, unknown, or not a <tt>Throwable</tt>
      */
-    public NTLMEngineException(String message, Throwable cause) {
+    public NtlmEngineException(String message, Throwable cause) {
         super(message, cause);
     }
 
diff --git a/api/src/main/java/org/asynchttpclient/ntlm/NtlmUtils.java b/api/src/main/java/org/asynchttpclient/ntlm/NtlmUtils.java
new file mode 100644
index 000000000..797f5a6aa
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/ntlm/NtlmUtils.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.ntlm;
+
+import java.util.List;
+
+public final class NtlmUtils {
+
+    private NtlmUtils() {
+    }
+
+    public static String getNTLM(List<String> authenticateHeaders) {
+        if (authenticateHeaders != null) {
+            for (String authenticateHeader: authenticateHeaders) {
+                if (authenticateHeader.startsWith("NTLM"))
+                    return authenticateHeader;
+            }
+        }
+
+        return null;
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/oauth/OAuthSignatureCalculator.java b/api/src/main/java/org/asynchttpclient/oauth/OAuthSignatureCalculator.java
index 86d860141..c7835883c 100644
--- a/api/src/main/java/org/asynchttpclient/oauth/OAuthSignatureCalculator.java
+++ b/api/src/main/java/org/asynchttpclient/oauth/OAuthSignatureCalculator.java
@@ -16,21 +16,23 @@
  */
 package org.asynchttpclient.oauth;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.ThreadLocalRandom;
+
 import org.asynchttpclient.Param;
 import org.asynchttpclient.Request;
 import org.asynchttpclient.RequestBuilderBase;
 import org.asynchttpclient.SignatureCalculator;
 import org.asynchttpclient.uri.Uri;
 import org.asynchttpclient.util.Base64;
-import org.asynchttpclient.util.StandardCharsets;
-import org.asynchttpclient.util.UTF8UrlEncoder;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Random;
+import org.asynchttpclient.util.StringUtils;
+import org.asynchttpclient.util.Utf8UrlEncoder;
 
 /**
  * Simple OAuth signature calculator that can used for constructing client signatures
@@ -56,13 +58,11 @@
     private static final String OAUTH_VERSION_1_0 = "1.0";
     private static final String OAUTH_SIGNATURE_METHOD = "HMAC-SHA1";
 
-    /**
-     * To generate Nonce, need some (pseudo)randomness; no need for
-     * secure variant here.
-     */
-    protected final Random random;
-
-    protected final byte[] nonceBuffer = new byte[16];
+    protected static final ThreadLocal<byte[]> NONCE_BUFFER = new ThreadLocal<byte[]>() {
+        protected byte[] initialValue() {
+            return new byte[16];
+        }
+    };
 
     protected final ThreadSafeHMAC mac;
 
@@ -78,82 +78,108 @@ public OAuthSignatureCalculator(ConsumerKey consumerAuth, RequestToken userAuth)
         mac = new ThreadSafeHMAC(consumerAuth, userAuth);
         this.consumerAuth = consumerAuth;
         this.userAuth = userAuth;
-        random = new Random(System.identityHashCode(this) + System.currentTimeMillis());
     }
 
-    //@Override // silly 1.5; doesn't allow this for interfaces
-
+    @Override
     public void calculateAndAddSignature(Request request, RequestBuilderBase<?> requestBuilder) {
         String nonce = generateNonce();
-        long timestamp = System.currentTimeMillis() / 1000L;
+        long timestamp = generateTimestamp();
         String signature = calculateSignature(request.getMethod(), request.getUri(), timestamp, nonce, request.getFormParams(), request.getQueryParams());
         String headerValue = constructAuthHeader(signature, nonce, timestamp);
         requestBuilder.setHeader(HEADER_AUTHORIZATION, headerValue);
     }
 
-    /**
-     * Method for calculating OAuth signature using HMAC/SHA-1 method.
-     */
-    public String calculateSignature(String method, Uri uri, long oauthTimestamp, String nonce,
-                                     List<Param> formParams, List<Param> queryParams) {
-        StringBuilder signedText = new StringBuilder(100);
-        signedText.append(method); // POST / GET etc (nothing to URL encode)
-        signedText.append('&');
-
+    private String baseUrl(Uri uri) {
         /* 07-Oct-2010, tatu: URL may contain default port number; if so, need to extract
          *   from base URL.
          */
         String scheme = uri.getScheme();
+
+        StringBuilder sb = StringUtils.stringBuilder();
+        sb.append(scheme).append("://").append(uri.getHost());
+        
         int port = uri.getPort();
-        if (scheme.equals("http"))
+        if (scheme.equals("http")) {
             if (port == 80)
                 port = -1;
-        else if (scheme.equals("https"))
+        } else if (scheme.equals("https")) {
             if (port == 443)
                 port = -1;
-        
-        StringBuilder sb = new StringBuilder().append(scheme).append("://").append(uri.getHost());
+        }
+
         if (port != -1)
             sb.append(':').append(port);
+
         if (isNonEmpty(uri.getPath()))
             sb.append(uri.getPath());
         
-        String baseURL = sb.toString();
-        UTF8UrlEncoder.appendEncoded(signedText, baseURL);
+        return sb.toString();
+    }
 
+    private String encodedParams(long oauthTimestamp, String nonce, List<Param> formParams, List<Param> queryParams) {
         /**
          * List of all query and form parameters added to this request; needed
          * for calculating request signature
          */
-        OAuthParameterSet allParameters = new OAuthParameterSet();
+        int allParametersSize = 5
+                + (userAuth.getKey() != null ? 1 : 0)
+                + (formParams != null ? formParams.size() : 0)
+                + (queryParams != null ? queryParams.size() : 0);
+        OAuthParameterSet allParameters = new OAuthParameterSet(allParametersSize);
 
         // start with standard OAuth parameters we need
-        allParameters.add(KEY_OAUTH_CONSUMER_KEY, consumerAuth.getKey());
-        allParameters.add(KEY_OAUTH_NONCE, nonce);
+        allParameters.add(KEY_OAUTH_CONSUMER_KEY, Utf8UrlEncoder.encodeQueryElement(consumerAuth.getKey()));
+        allParameters.add(KEY_OAUTH_NONCE, Utf8UrlEncoder.encodeQueryElement(nonce));
         allParameters.add(KEY_OAUTH_SIGNATURE_METHOD, OAUTH_SIGNATURE_METHOD);
         allParameters.add(KEY_OAUTH_TIMESTAMP, String.valueOf(oauthTimestamp));
         if (userAuth.getKey() != null) {
-            allParameters.add(KEY_OAUTH_TOKEN, userAuth.getKey());
+            allParameters.add(KEY_OAUTH_TOKEN, Utf8UrlEncoder.encodeQueryElement(userAuth.getKey()));
         }
         allParameters.add(KEY_OAUTH_VERSION, OAUTH_VERSION_1_0);
 
         if (formParams != null) {
             for (Param param : formParams) {
-                allParameters.add(param.getName(), param.getValue());
+                // formParams are not already encoded
+                allParameters.add(Utf8UrlEncoder.encodeQueryElement(param.getName()), Utf8UrlEncoder.encodeQueryElement(param.getValue()));
             }
         }
         if (queryParams != null) {
             for (Param param : queryParams) {
+             // queryParams are already encoded
                 allParameters.add(param.getName(), param.getValue());
             }
         }
-        String encodedParams = allParameters.sortAndConcat();
+        return allParameters.sortAndConcat();
+    }
+
+    StringBuilder signatureBaseString(String method, Uri uri, long oauthTimestamp, String nonce,
+                                     List<Param> formParams, List<Param> queryParams) {
+        
+        // beware: must generate first as we're using pooled StringBuilder
+        String baseUrl = baseUrl(uri);
+        String encodedParams = encodedParams(oauthTimestamp, nonce, formParams, queryParams);
+
+        StringBuilder sb = StringUtils.stringBuilder();
+        sb.append(method); // POST / GET etc (nothing to URL encode)
+        sb.append('&');
+        Utf8UrlEncoder.encodeAndAppendQueryElement(sb, baseUrl);
+
 
         // and all that needs to be URL encoded (... again!)
-        signedText.append('&');
-        UTF8UrlEncoder.appendEncoded(signedText, encodedParams);
+        sb.append('&');
+        Utf8UrlEncoder.encodeAndAppendQueryElement(sb, encodedParams);
+        return sb;
+    }
+    
+    /**
+     * Method for calculating OAuth signature using HMAC/SHA-1 method.
+     */
+    public String calculateSignature(String method, Uri uri, long oauthTimestamp, String nonce,
+                                     List<Param> formParams, List<Param> queryParams) {
 
-        byte[] rawBase = signedText.toString().getBytes(StandardCharsets.UTF_8);
+        StringBuilder sb = signatureBaseString(method, uri, oauthTimestamp, nonce, formParams, queryParams);
+
+        ByteBuffer rawBase = StringUtils.charSequence2ByteBuffer(sb, UTF_8);
         byte[] rawSignature = mac.digest(rawBase);
         // and finally, base64 encoded... phew!
         return Base64.encode(rawSignature);
@@ -162,8 +188,8 @@ else if (scheme.equals("https"))
     /**
      * Method used for constructing
      */
-    public String constructAuthHeader(String signature, String nonce, long oauthTimestamp) {
-        StringBuilder sb = new StringBuilder(200);
+    private String constructAuthHeader(String signature, String nonce, long oauthTimestamp) {
+        StringBuilder sb = StringUtils.stringBuilder();
         sb.append("OAuth ");
         sb.append(KEY_OAUTH_CONSUMER_KEY).append("=\"").append(consumerAuth.getKey()).append("\", ");
         if (userAuth.getKey() != null) {
@@ -173,20 +199,25 @@ public String constructAuthHeader(String signature, String nonce, long oauthTime
 
         // careful: base64 has chars that need URL encoding:
         sb.append(KEY_OAUTH_SIGNATURE).append("=\"");
-        UTF8UrlEncoder.appendEncoded(sb, signature).append("\", ");
+        Utf8UrlEncoder.encodeAndAppendQueryElement(sb, signature).append("\", ");
         sb.append(KEY_OAUTH_TIMESTAMP).append("=\"").append(oauthTimestamp).append("\", ");
 
         // also: nonce may contain things that need URL encoding (esp. when using base64):
         sb.append(KEY_OAUTH_NONCE).append("=\"");
-        UTF8UrlEncoder.appendEncoded(sb, nonce);
+        Utf8UrlEncoder.encodeAndAppendQueryElement(sb, nonce);
         sb.append("\", ");
 
         sb.append(KEY_OAUTH_VERSION).append("=\"").append(OAUTH_VERSION_1_0).append("\"");
         return sb.toString();
     }
 
-    private synchronized String generateNonce() {
-        random.nextBytes(nonceBuffer);
+    protected long generateTimestamp() {
+        return System.currentTimeMillis() / 1000L;
+    }
+
+    protected String generateNonce() {
+        byte[] nonceBuffer = NONCE_BUFFER.get();
+        ThreadLocalRandom.current().nextBytes(nonceBuffer);
         // let's use base64 encoding over hex, slightly more compact than hex or decimals
         return Base64.encode(nonceBuffer);
 //      return String.valueOf(Math.abs(random.nextLong()));
@@ -201,14 +232,14 @@ private synchronized String generateNonce() {
      * when it would occur it'd be harder to track down.
      */
     final static class OAuthParameterSet {
-        final private ArrayList<Parameter> allParameters = new ArrayList<Parameter>();
+        private final ArrayList<Parameter> allParameters;
 
-        public OAuthParameterSet() {
+        public OAuthParameterSet(int size) {
+            allParameters = new ArrayList<>(size);
         }
 
         public OAuthParameterSet add(String key, String value) {
-            Parameter p = new Parameter(UTF8UrlEncoder.encode(key), UTF8UrlEncoder.encode(value));
-            allParameters.add(p);
+            allParameters.add(new Parameter(key, value));
             return this;
         }
 
@@ -248,8 +279,7 @@ public String value() {
             return value;
         }
 
-        //@Override // silly 1.5; doesn't allow this for interfaces
-
+        @Override
         public int compareTo(Parameter other) {
             int diff = key.compareTo(other.key);
             if (diff == 0) {
diff --git a/api/src/main/java/org/asynchttpclient/oauth/ThreadSafeHMAC.java b/api/src/main/java/org/asynchttpclient/oauth/ThreadSafeHMAC.java
old mode 100644
new mode 100755
index 028020f75..6b4defc9e
--- a/api/src/main/java/org/asynchttpclient/oauth/ThreadSafeHMAC.java
+++ b/api/src/main/java/org/asynchttpclient/oauth/ThreadSafeHMAC.java
@@ -16,12 +16,16 @@
  */
 package org.asynchttpclient.oauth;
 
-import org.asynchttpclient.util.StandardCharsets;
-import org.asynchttpclient.util.UTF8UrlEncoder;
+import static java.nio.charset.StandardCharsets.UTF_8;
+
+import java.nio.ByteBuffer;
 
 import javax.crypto.Mac;
 import javax.crypto.spec.SecretKeySpec;
 
+import org.asynchttpclient.util.StringUtils;
+import org.asynchttpclient.util.Utf8UrlEncoder;
+
 /**
  * Since cloning (of MAC instances)  is not necessarily supported on all platforms
  * (and specifically seems to fail on MacOS), let's wrap synchronization/reuse details here.
@@ -37,8 +41,13 @@
     private final Mac mac;
 
     public ThreadSafeHMAC(ConsumerKey consumerAuth, RequestToken userAuth) {
-        byte[] keyBytes = (UTF8UrlEncoder.encode(consumerAuth.getSecret()) + "&" + UTF8UrlEncoder.encode(userAuth.getSecret()))
-                .getBytes(StandardCharsets.UTF_8);
+        StringBuilder sb = StringUtils.stringBuilder();
+        Utf8UrlEncoder.encodeAndAppendQueryElement(sb, consumerAuth.getSecret());
+        sb.append('&');
+        if(userAuth != null && userAuth.getSecret() != null) {
+            Utf8UrlEncoder.encodeAndAppendQueryElement(sb, userAuth.getSecret());
+        }
+        byte[] keyBytes = StringUtils.charSequence2Bytes(sb, UTF_8);
         SecretKeySpec signingKey = new SecretKeySpec(keyBytes, HMAC_SHA1_ALGORITHM);
 
         // Get an hmac_sha1 instance and initialize with the signing key
@@ -51,8 +60,9 @@ public ThreadSafeHMAC(ConsumerKey consumerAuth, RequestToken userAuth) {
 
     }
 
-    public synchronized byte[] digest(byte[] message) {
+    public synchronized byte[] digest(ByteBuffer message) {
         mac.reset();
-        return mac.doFinal(message);
+        mac.update(message);
+        return mac.doFinal();
     }
 }
diff --git a/api/src/main/java/org/asynchttpclient/ProxyServer.java b/api/src/main/java/org/asynchttpclient/proxy/ProxyServer.java
similarity index 72%
rename from api/src/main/java/org/asynchttpclient/ProxyServer.java
rename to api/src/main/java/org/asynchttpclient/proxy/ProxyServer.java
index 3c6a5ff42..487c3b06f 100644
--- a/api/src/main/java/org/asynchttpclient/ProxyServer.java
+++ b/api/src/main/java/org/asynchttpclient/proxy/ProxyServer.java
@@ -14,15 +14,18 @@
  * under the License.
  *
  */
-package org.asynchttpclient;
+package org.asynchttpclient.proxy;
 
-import org.asynchttpclient.util.StandardCharsets;
+import static java.nio.charset.StandardCharsets.UTF_8;
 
 import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 
+import org.asynchttpclient.Realm;
+import org.asynchttpclient.Realm.AuthScheme;
+
 /**
  * Represents a proxy server.
  */
@@ -33,7 +36,7 @@
 
         private final String protocol;
 
-        private Protocol(final String protocol) {
+        Protocol(final String protocol) {
             this.protocol = protocol;
         }
 
@@ -47,16 +50,18 @@ public String toString() {
         }
     }
 
-    private final List<String> nonProxyHosts = new ArrayList<String>();
+    private final List<String> nonProxyHosts = new ArrayList<>();
     private final Protocol protocol;
     private final String host;
     private final String principal;
     private final String password;
     private final int port;
     private final String url;
-    private String encoding = StandardCharsets.UTF_8.name();
-    private Charset charset = StandardCharsets.UTF_8;
+    private Charset charset = UTF_8;
     private String ntlmDomain = System.getProperty("http.auth.ntlm.domain", "");
+    private String ntlmHost;
+    private AuthScheme scheme = AuthScheme.BASIC;
+    private boolean forceHttp10 = false;
 
     public ProxyServer(final Protocol protocol, final String host, final int port, String principal, String password) {
         this.protocol = protocol;
@@ -79,12 +84,17 @@ public ProxyServer(final String host, final int port) {
         this(Protocol.HTTP, host, port, null, null);
     }
 
-    public Protocol getProtocol() {
-        return protocol;
+    public Realm.RealmBuilder realmBuilder() {
+        return new Realm.RealmBuilder()//
+        .setNtlmDomain(ntlmDomain)
+        .setNtlmHost(ntlmHost)
+        .setPrincipal(principal)
+        .setPassword(password)
+        .setScheme(scheme);
     }
 
-    public String getProtocolAsString() {
-        return protocol.toString();
+    public Protocol getProtocol() {
+        return protocol;
     }
 
     public String getHost() {
@@ -103,16 +113,11 @@ public String getPassword() {
         return password;
     }
 
-    public ProxyServer setEncoding(String encoding) {
-        this.encoding = encoding;
-        this.charset = Charset.forName(encoding);
+    public ProxyServer setCharset(Charset charset) {
+        this.charset = charset;
         return this;
     }
 
-    public String getEncoding() {
-        return encoding;
-    }
-
     public Charset getCharset() {
         return charset;
     }
@@ -144,6 +149,30 @@ public String getNtlmDomain() {
         return ntlmDomain;
     }
 
+    public AuthScheme getScheme() {
+        return scheme;
+    }
+
+    public void setScheme(AuthScheme scheme) {
+        this.scheme = scheme;
+    }
+
+    public String getNtlmHost() {
+        return ntlmHost;
+    }
+
+    public void setNtlmHost(String ntlmHost) {
+        this.ntlmHost = ntlmHost;
+    }
+    
+    public boolean isForceHttp10() {
+        return forceHttp10;
+    }
+
+    public void setForceHttp10(boolean forceHttp10) {
+        this.forceHttp10 = forceHttp10;
+    }
+
     @Override
     public String toString() {
         return url;
diff --git a/api/src/main/java/org/asynchttpclient/ProxyServerSelector.java b/api/src/main/java/org/asynchttpclient/proxy/ProxyServerSelector.java
similarity index 82%
rename from api/src/main/java/org/asynchttpclient/ProxyServerSelector.java
rename to api/src/main/java/org/asynchttpclient/proxy/ProxyServerSelector.java
index 241f8086c..dc93a979c 100644
--- a/api/src/main/java/org/asynchttpclient/ProxyServerSelector.java
+++ b/api/src/main/java/org/asynchttpclient/proxy/ProxyServerSelector.java
@@ -1,4 +1,4 @@
-package org.asynchttpclient;
+package org.asynchttpclient.proxy;
 
 import org.asynchttpclient.uri.Uri;
 
@@ -18,7 +18,7 @@
     /**
      * A selector that always selects no proxy.
      */
-    static final ProxyServerSelector NO_PROXY_SELECTOR = new ProxyServerSelector() {
+    ProxyServerSelector NO_PROXY_SELECTOR = new ProxyServerSelector() {
         @Override
         public ProxyServer select(Uri uri) {
             return null;
diff --git a/api/src/main/java/org/asynchttpclient/Body.java b/api/src/main/java/org/asynchttpclient/request/body/Body.java
similarity index 78%
rename from api/src/main/java/org/asynchttpclient/Body.java
rename to api/src/main/java/org/asynchttpclient/request/body/Body.java
index 422e365e2..69252c5ad 100644
--- a/api/src/main/java/org/asynchttpclient/Body.java
+++ b/api/src/main/java/org/asynchttpclient/request/body/Body.java
@@ -11,7 +11,7 @@
 * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
 */
 
-package org.asynchttpclient;
+package org.asynchttpclient.request.body;
 
 import java.io.Closeable;
 import java.io.IOException;
@@ -22,6 +22,24 @@
  */
 public interface Body extends Closeable {
 
+    enum State {
+
+        /**
+         * There's something to read
+         */
+        Continue,
+
+        /**
+         * There's nothing to read and input has to suspend
+         */
+        Suspend,
+
+        /**
+         * There's nothing to read and input has to stop
+         */
+        Stop;
+    }
+
     /**
      * Gets the length of the body.
      *
@@ -37,5 +55,5 @@
      * @throws IOException If the chunk could not be read.
      */
     // FIXME introduce a visitor pattern so that Netty can pass a pooled buffer
-    long read(ByteBuffer buffer) throws IOException;
+    State read(ByteBuffer buffer) throws IOException;
 }
diff --git a/api/src/main/java/org/asynchttpclient/RandomAccessBody.java b/api/src/main/java/org/asynchttpclient/request/body/RandomAccessBody.java
similarity index 97%
rename from api/src/main/java/org/asynchttpclient/RandomAccessBody.java
rename to api/src/main/java/org/asynchttpclient/request/body/RandomAccessBody.java
index fa74e9e68..7dbf616c9 100644
--- a/api/src/main/java/org/asynchttpclient/RandomAccessBody.java
+++ b/api/src/main/java/org/asynchttpclient/request/body/RandomAccessBody.java
@@ -11,7 +11,7 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package org.asynchttpclient;
+package org.asynchttpclient.request.body;
 
 import java.io.IOException;
 import java.nio.channels.WritableByteChannel;
diff --git a/api/src/main/java/org/asynchttpclient/BodyGenerator.java b/api/src/main/java/org/asynchttpclient/request/body/generator/BodyGenerator.java
similarity index 87%
rename from api/src/main/java/org/asynchttpclient/BodyGenerator.java
rename to api/src/main/java/org/asynchttpclient/request/body/generator/BodyGenerator.java
index 9d9261876..4b20ee978 100644
--- a/api/src/main/java/org/asynchttpclient/BodyGenerator.java
+++ b/api/src/main/java/org/asynchttpclient/request/body/generator/BodyGenerator.java
@@ -11,9 +11,9 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package org.asynchttpclient;
+package org.asynchttpclient.request.body.generator;
 
-import java.io.IOException;
+import org.asynchttpclient.request.body.Body;
 
 /**
  * Creates a request body.
@@ -26,7 +26,6 @@
      * needs to be resend after an authentication challenge of a redirect.
      *
      * @return The request body, never {@code null}.
-     * @throws IOException If the body could not be created.
      */
-    Body createBody() throws IOException;
+    Body createBody();
 }
diff --git a/api/src/main/java/org/asynchttpclient/generators/ByteArrayBodyGenerator.java b/api/src/main/java/org/asynchttpclient/request/body/generator/ByteArrayBodyGenerator.java
similarity index 81%
rename from api/src/main/java/org/asynchttpclient/generators/ByteArrayBodyGenerator.java
rename to api/src/main/java/org/asynchttpclient/request/body/generator/ByteArrayBodyGenerator.java
index f1e0a9775..0f7c02c27 100644
--- a/api/src/main/java/org/asynchttpclient/generators/ByteArrayBodyGenerator.java
+++ b/api/src/main/java/org/asynchttpclient/request/body/generator/ByteArrayBodyGenerator.java
@@ -10,18 +10,17 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.generators;
-
-import org.asynchttpclient.Body;
-import org.asynchttpclient.BodyGenerator;
+package org.asynchttpclient.request.body.generator;
 
 import java.io.IOException;
 import java.nio.ByteBuffer;
 
+import org.asynchttpclient.request.body.Body;
+
 /**
  * A {@link BodyGenerator} backed by a byte array.
  */
-public class ByteArrayBodyGenerator implements BodyGenerator {
+public final class ByteArrayBodyGenerator implements BodyGenerator {
 
     private final byte[] bytes;
 
@@ -37,22 +36,21 @@ public long getContentLength() {
             return bytes.length;
         }
 
-        public long read(ByteBuffer byteBuffer) throws IOException {
+        public State read(ByteBuffer byteBuffer) throws IOException {
 
             if (eof) {
-                return -1;
+                return State.Stop;
             }
 
             final int remaining = bytes.length - lastPosition;
             if (remaining <= byteBuffer.capacity()) {
                 byteBuffer.put(bytes, lastPosition, remaining);
                 eof = true;
-                return remaining;
             } else {
                 byteBuffer.put(bytes, lastPosition, byteBuffer.capacity());
                 lastPosition = lastPosition + byteBuffer.capacity();
-                return byteBuffer.capacity();
             }
+            return State.Continue;
         }
 
         public void close() throws IOException {
@@ -65,7 +63,7 @@ public void close() throws IOException {
      * {@inheritDoc}
      */
     @Override
-    public Body createBody() throws IOException {
+    public Body createBody() {
         return new ByteBody();
     }
 }
diff --git a/api/src/main/java/org/asynchttpclient/request/body/generator/FeedableBodyGenerator.java b/api/src/main/java/org/asynchttpclient/request/body/generator/FeedableBodyGenerator.java
new file mode 100644
index 000000000..d735396b5
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/request/body/generator/FeedableBodyGenerator.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.request.body.generator;
+
+import java.nio.ByteBuffer;
+
+/**
+ * {@link BodyGenerator} which may return just part of the payload at the time handler is requesting it.
+ * If it happens, PartialBodyGenerator becomes responsible for finishing payload transferring asynchronously.
+ */
+public interface FeedableBodyGenerator extends BodyGenerator {
+    void feed(ByteBuffer buffer, boolean isLast);
+
+    void writeChunkBoundaries();
+
+    void setListener(FeedListener listener);
+
+    interface FeedListener {
+        void onContentAdded();
+        void onError(Throwable t);
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/generators/FileBodyGenerator.java b/api/src/main/java/org/asynchttpclient/request/body/generator/FileBodyGenerator.java
similarity index 50%
rename from api/src/main/java/org/asynchttpclient/generators/FileBodyGenerator.java
rename to api/src/main/java/org/asynchttpclient/request/body/generator/FileBodyGenerator.java
index dd97ec217..acbe38981 100644
--- a/api/src/main/java/org/asynchttpclient/generators/FileBodyGenerator.java
+++ b/api/src/main/java/org/asynchttpclient/request/body/generator/FileBodyGenerator.java
@@ -10,23 +10,16 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.generators;
-
-import org.asynchttpclient.BodyGenerator;
-import org.asynchttpclient.RandomAccessBody;
+package org.asynchttpclient.request.body.generator;
 
 import java.io.File;
-import java.io.IOException;
-import java.io.RandomAccessFile;
-import java.nio.ByteBuffer;
-import java.nio.channels.FileChannel;
-import java.nio.channels.WritableByteChannel;
+
+import org.asynchttpclient.request.body.RandomAccessBody;
 
 /**
  * Creates a request body from the contents of a file.
  */
-//Not used by Netty
-public class FileBodyGenerator implements BodyGenerator {
+public final class FileBodyGenerator implements BodyGenerator {
 
     private final File file;
     private final long regionSeek;
@@ -61,41 +54,7 @@ public long getRegionSeek() {
      * {@inheritDoc}
      */
     @Override
-    public RandomAccessBody createBody() throws IOException {
-        return new FileBody(file, regionSeek, regionLength);
-    }
-
-    private static class FileBody implements RandomAccessBody {
-
-        private final RandomAccessFile raf;
-
-        private final FileChannel channel;
-
-        private final long length;
-
-        private FileBody(File file, long regionSeek, long regionLength) throws IOException {
-            raf = new RandomAccessFile(file, "r");
-            channel = raf.getChannel();
-            length = regionLength;
-            if (regionSeek > 0) {
-                raf.seek(regionSeek);
-            }
-        }
-
-        public long getContentLength() {
-            return length;
-        }
-
-        public long read(ByteBuffer buffer) throws IOException {
-            return channel.read(buffer);
-        }
-
-        public long transferTo(long position, WritableByteChannel target) throws IOException {
-            return channel.transferTo(position, length, target);
-        }
-
-        public void close() throws IOException {
-            raf.close();
-        }
+    public RandomAccessBody createBody() {
+        throw new UnsupportedOperationException("FileBodyGenerator.createBody isn't used, Netty direclt sends the file");
     }
 }
diff --git a/api/src/main/java/org/asynchttpclient/request/body/generator/InputStreamBodyGenerator.java b/api/src/main/java/org/asynchttpclient/request/body/generator/InputStreamBodyGenerator.java
new file mode 100644
index 000000000..3eb0e1570
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/request/body/generator/InputStreamBodyGenerator.java
@@ -0,0 +1,129 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.request.body.generator;
+
+import org.asynchttpclient.request.body.Body;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+
+/**
+ * A {@link BodyGenerator} which use an {@link InputStream} for reading bytes, without having to read the entire stream in memory.
+ * <p/>
+ * NOTE: The {@link InputStream} must support the {@link InputStream#mark} and {@link java.io.InputStream#reset()} operation. If not, mechanisms like authentication, redirect, or
+ * resumable download will not works.
+ */
+public final class InputStreamBodyGenerator implements BodyGenerator {
+
+    private final static byte[] END_PADDING = "\r\n".getBytes();
+    private final static byte[] ZERO = "0".getBytes();
+    private static final Logger LOGGER = LoggerFactory.getLogger(InputStreamBody.class);
+    private final InputStream inputStream;
+    private boolean patchNetty3ChunkingIssue = false;
+
+    public InputStreamBodyGenerator(InputStream inputStream) {
+        this.inputStream = inputStream;
+    }
+
+    public InputStream getInputStream() {
+        return inputStream;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Body createBody() {
+        return new InputStreamBody(inputStream);
+    }
+
+    private class InputStreamBody implements Body {
+
+        private final InputStream inputStream;
+        private boolean eof = false;
+        private int endDataCount = 0;
+        private byte[] chunk;
+
+        private InputStreamBody(InputStream inputStream) {
+            this.inputStream = inputStream;
+        }
+
+        public long getContentLength() {
+            return -1L;
+        }
+
+        public State read(ByteBuffer buffer) throws IOException {
+
+            // To be safe.
+            chunk = new byte[buffer.remaining() - 10];
+
+            int read = -1;
+            boolean write = false;
+            try {
+                read = inputStream.read(chunk);
+            } catch (IOException ex) {
+                LOGGER.warn("Unable to read", ex);
+            }
+
+            if (patchNetty3ChunkingIssue) {
+                if (read >= 0) {
+                    // Netty 3.2.3 doesn't support chunking encoding properly, so we chunk encoding ourself.
+                    buffer.put(Integer.toHexString(read).getBytes());
+                    // Chunking is separated by "<bytesreads>\r\n"
+                    buffer.put(END_PADDING);
+                    buffer.put(chunk, 0, read);
+                    // Was missing the final chunk \r\n.
+                    buffer.put(END_PADDING);
+                    write = true;
+
+                } else if (!eof) {
+                    // read == -1)
+                    // Since we are chunked, we must output extra bytes before considering the input stream closed.
+                    // chunking requires to end the chunking:
+                    // - A Terminating chunk of  "0\r\n".getBytes(),
+                    // - Then a separate packet of "\r\n".getBytes()
+                    endDataCount++;
+    
+                    if (endDataCount == 1)
+                        buffer.put(ZERO);
+                    else if (endDataCount == 2)
+                        eof = true;
+    
+                    buffer.put(END_PADDING);
+                    write = true;
+                }
+            } else if (read > 0) {
+                buffer.put(chunk, 0, read);
+                write = true;
+            }
+            return write ? State.Continue : State.Stop;
+        }
+
+        public void close() throws IOException {
+            inputStream.close();
+        }
+    }
+
+    /**
+     * HACK: This is required because Netty has issues with chunking.
+     *
+     * @param patchNettyChunkingIssue
+     */
+    public void patchNetty3ChunkingIssue(boolean patchNetty3ChunkingIssue) {
+        this.patchNetty3ChunkingIssue = patchNetty3ChunkingIssue;
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/request/body/generator/ReactiveStreamsBodyGenerator.java b/api/src/main/java/org/asynchttpclient/request/body/generator/ReactiveStreamsBodyGenerator.java
new file mode 100644
index 000000000..ade089562
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/request/body/generator/ReactiveStreamsBodyGenerator.java
@@ -0,0 +1,149 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.request.body.generator;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicReference;
+
+import org.asynchttpclient.request.body.Body;
+import org.reactivestreams.Publisher;
+import org.reactivestreams.Subscriber;
+import org.reactivestreams.Subscription;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class ReactiveStreamsBodyGenerator implements FeedableBodyGenerator {
+    private static final ByteBuffer EMPTY = ByteBuffer.wrap("".getBytes());
+
+    private final Publisher<ByteBuffer> publisher;
+    private final FeedableBodyGenerator feedableBodyGenerator;
+    private final AtomicReference<FeedListener> feedListener = new AtomicReference<>(null);
+
+    public ReactiveStreamsBodyGenerator(Publisher<ByteBuffer> publisher) {
+        this.publisher = publisher;
+        this.feedableBodyGenerator = new SimpleFeedableBodyGenerator();
+    }
+
+    public Publisher<ByteBuffer> getPublisher() {
+        return this.publisher;
+    }
+
+    @Override
+    public void feed(ByteBuffer buffer, boolean isLast) {
+        feedableBodyGenerator.feed(buffer, isLast);
+    }
+
+    @Override
+    public void writeChunkBoundaries() {
+        feedableBodyGenerator.writeChunkBoundaries();
+    }
+
+    @Override
+    public void setListener(FeedListener listener) {
+        feedListener.set(listener);
+        feedableBodyGenerator.setListener(listener);
+    }
+
+    @Override
+    public Body createBody() {
+        return new StreamedBody(publisher, feedableBodyGenerator);
+    }
+
+    private class StreamedBody implements Body {
+        private final AtomicBoolean initialized = new AtomicBoolean(false);
+
+        private final SimpleSubscriber subscriber;
+        private final Body body;
+
+        public StreamedBody(Publisher<ByteBuffer> publisher, FeedableBodyGenerator bodyGenerator) {
+            this.body = bodyGenerator.createBody();
+            this.subscriber = new SimpleSubscriber(bodyGenerator);
+        }
+
+        @Override
+        public void close() throws IOException {
+            body.close();
+        }
+
+        @Override
+        public long getContentLength() {
+            return body.getContentLength();
+        }
+
+        @Override
+        public State read(ByteBuffer buffer) throws IOException {
+            if(initialized.compareAndSet(false, true))
+                publisher.subscribe(subscriber);
+
+            return body.read(buffer);
+        }
+    }
+
+    private class SimpleSubscriber implements Subscriber<ByteBuffer> {
+
+        private final Logger LOGGER = LoggerFactory.getLogger(SimpleSubscriber.class);
+
+        private final FeedableBodyGenerator feeder;
+        private volatile Subscription subscription;
+
+        public SimpleSubscriber(FeedableBodyGenerator feeder) {
+            this.feeder = feeder;
+        }
+
+        @Override
+        public void onSubscribe(Subscription s) {
+            if (s == null) throw null;
+
+            // If someone has made a mistake and added this Subscriber multiple times, let's handle it gracefully
+            if (this.subscription != null) { 
+                s.cancel(); // Cancel the additional subscription
+            }
+            else {
+              subscription = s;
+              subscription.request(Long.MAX_VALUE);
+            }
+        }
+
+        @Override
+        public void onNext(ByteBuffer t) {
+            if (t == null) throw null;
+            try {
+                feeder.feed(t, false);
+            } catch (Exception e) {
+                LOGGER.error("Exception occurred while processing element in stream.", e);
+                subscription.cancel();
+            }
+        }
+
+        @Override
+        public void onError(Throwable t) {
+            if (t == null) throw null;
+            LOGGER.debug("Error occurred while consuming body stream.", t);
+            FeedListener listener = feedListener.get();
+            if(listener != null) listener.onError(t);
+        }
+
+        @Override
+        public void onComplete() {
+            try {
+              feeder.feed(EMPTY, true);
+            } 
+            catch (Exception e) {
+                LOGGER.info("Ignoring exception occurred while completing stream processing.", e);
+                this.subscription.cancel();
+            }
+        }
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/request/body/generator/SimpleFeedableBodyGenerator.java b/api/src/main/java/org/asynchttpclient/request/body/generator/SimpleFeedableBodyGenerator.java
new file mode 100755
index 000000000..9569bac5f
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/request/body/generator/SimpleFeedableBodyGenerator.java
@@ -0,0 +1,171 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.request.body.generator;
+
+import static java.nio.charset.StandardCharsets.US_ASCII;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedQueue;
+
+import org.asynchttpclient.request.body.Body;
+
+public final class SimpleFeedableBodyGenerator implements FeedableBodyGenerator, BodyGenerator {
+    private final static byte[] END_PADDING = "\r\n".getBytes(US_ASCII);
+    private final static byte[] ZERO = "0".getBytes(US_ASCII);
+    private final static ByteBuffer EMPTY_BUFFER = ByteBuffer.allocate(0);
+    private final Queue<BodyPart> queue = new ConcurrentLinkedQueue<>();
+    private FeedListener listener;
+
+    // must be set to true when using Netty 3 where native chunking is broken
+    private boolean writeChunkBoundaries = false;
+
+    @Override
+    public Body createBody() {
+        return new PushBody();
+    }
+
+    @Override
+    public void feed(final ByteBuffer buffer, final boolean isLast) {
+        queue.offer(new BodyPart(buffer, isLast));
+        if (listener != null) {
+            listener.onContentAdded();
+        }
+    }
+
+    @Override
+    public void setListener(FeedListener listener) {
+        this.listener = listener;
+    }
+
+    @Override
+    public void writeChunkBoundaries() {
+        this.writeChunkBoundaries = true;
+    }
+
+    public final class PushBody implements Body {
+
+        private State state = State.Continue;
+
+        @Override
+        public long getContentLength() {
+            return -1;
+        }
+
+        @Override
+        public State read(final ByteBuffer buffer) throws IOException {
+            switch (state) {
+                case Continue:
+                    return readNextPart(buffer);
+                case Stop:
+                    return State.Stop;
+                default:
+                    throw new IllegalStateException("Illegal process state.");
+            }
+        }
+
+        private State readNextPart(ByteBuffer buffer) throws IOException {
+            State res = State.Suspend;
+            while (buffer.hasRemaining() && state != State.Stop) {
+                BodyPart nextPart = queue.peek();
+                if (nextPart == null) {
+                    // Nothing in the queue. suspend stream if nothing was read. (reads == 0)
+                    return res;
+                } else if (!nextPart.buffer.hasRemaining() && !nextPart.isLast) {
+                    // skip empty buffers
+                    queue.remove();
+                } else {
+                    res = State.Continue;
+                    readBodyPart(buffer, nextPart);
+                }
+            }
+            return res;
+        }
+
+        private void readBodyPart(ByteBuffer buffer, BodyPart part) {
+            part.initBoundaries();
+            move(buffer, part.size);
+            move(buffer, part.buffer);
+            move(buffer, part.endPadding);
+
+            if (!part.buffer.hasRemaining() && !part.endPadding.hasRemaining()) {
+                if (part.isLast) {
+                    state = State.Stop;
+                }
+                queue.remove();
+            }
+        }
+
+        @Override
+        public void close() {
+        }
+    }
+
+    private void move(ByteBuffer destination, ByteBuffer source) {
+        int size = Math.min(destination.remaining(), source.remaining());
+        if (size > 0) {
+            ByteBuffer slice = source.slice();
+            slice.limit(size);
+            destination.put(slice);
+            source.position(source.position() + size);
+        }
+    }
+
+    private final class BodyPart {
+        private final boolean isLast;
+        private ByteBuffer size = null;
+        private final ByteBuffer buffer;
+        private ByteBuffer endPadding = null;
+
+        public BodyPart(final ByteBuffer buffer, final boolean isLast) {
+            this.buffer = buffer;
+            this.isLast = isLast;
+        }
+
+        private void initBoundaries() {
+            if(size == null && endPadding == null) {
+                if (SimpleFeedableBodyGenerator.this.writeChunkBoundaries) {
+                    if(buffer.hasRemaining()) {
+                        final byte[] sizeAsHex = Integer.toHexString(buffer.remaining()).getBytes(US_ASCII);
+                        size = ByteBuffer.allocate(sizeAsHex.length + END_PADDING.length);
+                        size.put(sizeAsHex);
+                        size.put(END_PADDING);
+                        size.flip();
+                    } else {
+                        size = EMPTY_BUFFER;
+                    }
+
+                    if(isLast) {
+                        endPadding = ByteBuffer.allocate(END_PADDING.length * 3 + ZERO.length);
+                        if(buffer.hasRemaining()) {
+                            endPadding.put(END_PADDING);
+                        }
+
+                        //add last empty
+                        endPadding.put(ZERO);
+                        endPadding.put(END_PADDING);
+                        endPadding.put(END_PADDING);
+                        endPadding.flip();
+                    } else {
+                        endPadding = ByteBuffer.wrap(END_PADDING);
+                    }
+                } else {
+                    size = EMPTY_BUFFER;
+                    endPadding = EMPTY_BUFFER;
+                }
+            }
+        }
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/multipart/AbstractFilePart.java b/api/src/main/java/org/asynchttpclient/request/body/multipart/AbstractFilePart.java
similarity index 93%
rename from api/src/main/java/org/asynchttpclient/multipart/AbstractFilePart.java
rename to api/src/main/java/org/asynchttpclient/request/body/multipart/AbstractFilePart.java
index c3a253360..9ebe0e821 100644
--- a/api/src/main/java/org/asynchttpclient/multipart/AbstractFilePart.java
+++ b/api/src/main/java/org/asynchttpclient/request/body/multipart/AbstractFilePart.java
@@ -10,9 +10,9 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.multipart;
+package org.asynchttpclient.request.body.multipart;
 
-import static org.asynchttpclient.util.StandardCharsets.US_ASCII;
+import static java.nio.charset.StandardCharsets.*;
 
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
@@ -69,7 +69,7 @@ protected void visitDispositionHeader(PartVisitor visitor) throws IOException {
         if (fileName != null) {
             visitor.withBytes(FILE_NAME_BYTES);
             visitor.withByte(QUOTE_BYTE);
-            visitor.withBytes(fileName.getBytes(US_ASCII));
+            visitor.withBytes(fileName.getBytes(getCharset() != null ? getCharset() : US_ASCII));
             visitor.withByte(QUOTE_BYTE);
         }
     }
@@ -82,7 +82,8 @@ protected void visitDispositionHeader(PartVisitor visitor) throws IOException {
         visitContentTypeHeader(visitor);
         visitTransferEncodingHeader(visitor);
         visitContentIdHeader(visitor);
-        visitEndOfHeader(visitor);
+        visitCustomHeaders(visitor);
+        visitEndOfHeaders(visitor);
 
         return out.toByteArray();
     }
diff --git a/api/src/main/java/org/asynchttpclient/multipart/ByteArrayPart.java b/api/src/main/java/org/asynchttpclient/request/body/multipart/ByteArrayPart.java
similarity index 98%
rename from api/src/main/java/org/asynchttpclient/multipart/ByteArrayPart.java
rename to api/src/main/java/org/asynchttpclient/request/body/multipart/ByteArrayPart.java
index f3dc0f11c..c81f609a5 100644
--- a/api/src/main/java/org/asynchttpclient/multipart/ByteArrayPart.java
+++ b/api/src/main/java/org/asynchttpclient/request/body/multipart/ByteArrayPart.java
@@ -10,7 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.multipart;
+package org.asynchttpclient.request.body.multipart;
 
 import java.io.IOException;
 import java.io.OutputStream;
diff --git a/api/src/main/java/org/asynchttpclient/multipart/CounterPartVisitor.java b/api/src/main/java/org/asynchttpclient/request/body/multipart/CounterPartVisitor.java
similarity index 95%
rename from api/src/main/java/org/asynchttpclient/multipart/CounterPartVisitor.java
rename to api/src/main/java/org/asynchttpclient/request/body/multipart/CounterPartVisitor.java
index dc7b82216..b3ec0e558 100644
--- a/api/src/main/java/org/asynchttpclient/multipart/CounterPartVisitor.java
+++ b/api/src/main/java/org/asynchttpclient/request/body/multipart/CounterPartVisitor.java
@@ -10,7 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.multipart;
+package org.asynchttpclient.request.body.multipart;
 
 import java.io.IOException;
 
diff --git a/api/src/main/java/org/asynchttpclient/multipart/FilePart.java b/api/src/main/java/org/asynchttpclient/request/body/multipart/FilePart.java
similarity index 99%
rename from api/src/main/java/org/asynchttpclient/multipart/FilePart.java
rename to api/src/main/java/org/asynchttpclient/request/body/multipart/FilePart.java
index 359ec21f7..7e74b732e 100644
--- a/api/src/main/java/org/asynchttpclient/multipart/FilePart.java
+++ b/api/src/main/java/org/asynchttpclient/request/body/multipart/FilePart.java
@@ -10,7 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.multipart;
+package org.asynchttpclient.request.body.multipart;
 
 import java.io.File;
 import java.io.FileInputStream;
diff --git a/api/src/main/java/org/asynchttpclient/multipart/FilePartStallHandler.java b/api/src/main/java/org/asynchttpclient/request/body/multipart/FilePartStallHandler.java
similarity index 96%
rename from api/src/main/java/org/asynchttpclient/multipart/FilePartStallHandler.java
rename to api/src/main/java/org/asynchttpclient/request/body/multipart/FilePartStallHandler.java
index ed8972302..386dffd13 100644
--- a/api/src/main/java/org/asynchttpclient/multipart/FilePartStallHandler.java
+++ b/api/src/main/java/org/asynchttpclient/request/body/multipart/FilePartStallHandler.java
@@ -10,7 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.multipart;
+package org.asynchttpclient.request.body.multipart;
 
 import java.util.Timer;
 import java.util.TimerTask;
diff --git a/api/src/main/java/org/asynchttpclient/multipart/FileUploadStalledException.java b/api/src/main/java/org/asynchttpclient/request/body/multipart/FileUploadStalledException.java
similarity index 94%
rename from api/src/main/java/org/asynchttpclient/multipart/FileUploadStalledException.java
rename to api/src/main/java/org/asynchttpclient/request/body/multipart/FileUploadStalledException.java
index 031f9354a..8dcf9c777 100644
--- a/api/src/main/java/org/asynchttpclient/multipart/FileUploadStalledException.java
+++ b/api/src/main/java/org/asynchttpclient/request/body/multipart/FileUploadStalledException.java
@@ -10,7 +10,7 @@
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
 */
-package org.asynchttpclient.multipart;
+package org.asynchttpclient.request.body.multipart;
 
 import java.io.IOException;
 
diff --git a/api/src/main/java/org/asynchttpclient/multipart/MultipartBody.java b/api/src/main/java/org/asynchttpclient/request/body/multipart/MultipartBody.java
similarity index 95%
rename from api/src/main/java/org/asynchttpclient/multipart/MultipartBody.java
rename to api/src/main/java/org/asynchttpclient/request/body/multipart/MultipartBody.java
index 1b732b939..b5e622cfe 100644
--- a/api/src/main/java/org/asynchttpclient/multipart/MultipartBody.java
+++ b/api/src/main/java/org/asynchttpclient/request/body/multipart/MultipartBody.java
@@ -10,9 +10,9 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.multipart;
+package org.asynchttpclient.request.body.multipart;
 
-import org.asynchttpclient.RandomAccessBody;
+import org.asynchttpclient.request.body.RandomAccessBody;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -32,7 +32,7 @@
     private final long contentLength;
     private final String contentType;
     private final List<Part> parts;
-    private final List<RandomAccessFile> pendingOpenFiles = new ArrayList<RandomAccessFile>();
+    private final List<RandomAccessFile> pendingOpenFiles = new ArrayList<>();
 
     private boolean transfertDone = false;
 
@@ -68,6 +68,10 @@ public String getContentType() {
         return contentType;
     }
 
+    public byte[] getBoundary() {
+        return boundary;
+    }
+
     // RandomAccessBody API, suited for HTTP but not for HTTPS
     public long transferTo(long position, WritableByteChannel target) throws IOException {
 
@@ -89,14 +93,14 @@ public long transferTo(long position, WritableByteChannel target) throws IOExcep
     }
 
     // Regular Body API
-    public long read(ByteBuffer buffer) throws IOException {
+    public State read(ByteBuffer buffer) throws IOException {
         try {
             int overallLength = 0;
 
             int maxLength = buffer.remaining();
 
             if (currentPart == parts.size() && transfertDone) {
-                return -1;
+                return State.Stop;
             }
 
             boolean full = false;
@@ -169,11 +173,11 @@ public long read(ByteBuffer buffer) throws IOException {
                     }
                 }
             }
-            return overallLength;
+            return transfertDone ? State.Continue : State.Stop;
 
         } catch (Exception e) {
             LOGGER.error("Read exception", e);
-            return 0;
+            return State.Stop;
         }
     }
 
diff --git a/api/src/main/java/org/asynchttpclient/multipart/MultipartUtils.java b/api/src/main/java/org/asynchttpclient/request/body/multipart/MultipartUtils.java
similarity index 92%
rename from api/src/main/java/org/asynchttpclient/multipart/MultipartUtils.java
rename to api/src/main/java/org/asynchttpclient/request/body/multipart/MultipartUtils.java
index d1f3ace5d..9b232e2e4 100644
--- a/api/src/main/java/org/asynchttpclient/multipart/MultipartUtils.java
+++ b/api/src/main/java/org/asynchttpclient/request/body/multipart/MultipartUtils.java
@@ -13,17 +13,13 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package org.asynchttpclient.multipart;
+package org.asynchttpclient.request.body.multipart;
 
-import static org.asynchttpclient.multipart.Part.CRLF_BYTES;
-import static org.asynchttpclient.multipart.Part.EXTRA_BYTES;
+import static java.nio.charset.StandardCharsets.US_ASCII;
+import static org.asynchttpclient.request.body.multipart.Part.CRLF_BYTES;
+import static org.asynchttpclient.request.body.multipart.Part.EXTRA_BYTES;
 import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 
-import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
-import org.asynchttpclient.util.StandardCharsets;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.nio.ByteBuffer;
@@ -35,6 +31,11 @@
 import java.util.Random;
 import java.util.Set;
 
+import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
+import org.asynchttpclient.util.StringUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 public class MultipartUtils {
 
     private static final Logger LOGGER = LoggerFactory.getLogger(MultipartUtils.class);
@@ -48,7 +49,7 @@
      * The pool of ASCII chars to be used for generating a multipart boundary.
      */
     private static byte[] MULTIPART_CHARS = "-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
-            .getBytes(StandardCharsets.US_ASCII);
+            .getBytes(US_ASCII);
 
     private MultipartUtils() {
     }
@@ -74,7 +75,7 @@ public static MultipartBody newMultipartBody(List<Part> parts, FluentCaseInsensi
                 // boundary defined in existing Content-Type
                 contentType = contentTypeHeader;
                 multipartBoundary = (contentTypeHeader.substring(boundaryLocation + "boundary=".length()).trim())
-                        .getBytes(StandardCharsets.US_ASCII);
+                        .getBytes(US_ASCII);
             } else {
                 // generate boundary and append it to existing Content-Type
                 multipartBoundary = generateMultipartBoundary();
@@ -100,10 +101,10 @@ public static MultipartBody newMultipartBody(List<Part> parts, FluentCaseInsensi
     }
 
     private static String computeContentType(String base, byte[] multipartBoundary) {
-        StringBuilder buffer = new StringBuilder(base);
+        StringBuilder buffer = StringUtils.stringBuilder().append(base);
         if (!base.endsWith(";"))
-            buffer.append(";");
-        return buffer.append(" boundary=").append(new String(multipartBoundary, StandardCharsets.US_ASCII)).toString();
+            buffer.append(';');
+        return buffer.append(" boundary=").append(new String(multipartBoundary, US_ASCII)).toString();
     }
 
     public static long writeBytesToChannel(WritableByteChannel target, byte[] bytes) throws IOException {
diff --git a/api/src/main/java/org/asynchttpclient/multipart/OutputStreamPartVisitor.java b/api/src/main/java/org/asynchttpclient/request/body/multipart/OutputStreamPartVisitor.java
similarity index 95%
rename from api/src/main/java/org/asynchttpclient/multipart/OutputStreamPartVisitor.java
rename to api/src/main/java/org/asynchttpclient/request/body/multipart/OutputStreamPartVisitor.java
index 518962f8d..849e41d28 100644
--- a/api/src/main/java/org/asynchttpclient/multipart/OutputStreamPartVisitor.java
+++ b/api/src/main/java/org/asynchttpclient/request/body/multipart/OutputStreamPartVisitor.java
@@ -13,7 +13,7 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package org.asynchttpclient.multipart;
+package org.asynchttpclient.request.body.multipart;
 
 import java.io.IOException;
 import java.io.OutputStream;
diff --git a/api/src/main/java/org/asynchttpclient/multipart/Part.java b/api/src/main/java/org/asynchttpclient/request/body/multipart/Part.java
similarity index 97%
rename from api/src/main/java/org/asynchttpclient/multipart/Part.java
rename to api/src/main/java/org/asynchttpclient/request/body/multipart/Part.java
index 4a5a2d90b..4c439ed64 100644
--- a/api/src/main/java/org/asynchttpclient/multipart/Part.java
+++ b/api/src/main/java/org/asynchttpclient/request/body/multipart/Part.java
@@ -10,9 +10,9 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.multipart;
+package org.asynchttpclient.request.body.multipart;
 
-import static org.asynchttpclient.util.StandardCharsets.US_ASCII;
+import static java.nio.charset.StandardCharsets.*;
 
 import java.io.IOException;
 import java.io.OutputStream;
diff --git a/api/src/main/java/org/asynchttpclient/multipart/PartBase.java b/api/src/main/java/org/asynchttpclient/request/body/multipart/PartBase.java
similarity index 86%
rename from api/src/main/java/org/asynchttpclient/multipart/PartBase.java
rename to api/src/main/java/org/asynchttpclient/request/body/multipart/PartBase.java
index a241df72a..b0ba8110f 100644
--- a/api/src/main/java/org/asynchttpclient/multipart/PartBase.java
+++ b/api/src/main/java/org/asynchttpclient/request/body/multipart/PartBase.java
@@ -10,13 +10,18 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.multipart;
+package org.asynchttpclient.request.body.multipart;
 
-import static org.asynchttpclient.util.StandardCharsets.US_ASCII;
+import static java.nio.charset.StandardCharsets.US_ASCII;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 
 import java.io.IOException;
 import java.io.OutputStream;
 import java.nio.charset.Charset;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.asynchttpclient.Param;
 
 public abstract class PartBase implements Part {
 
@@ -50,6 +55,11 @@
      */
     private String dispositionType;
 
+    /**
+     * Additional part headers
+     */
+    private List<Param> customHeaders;
+
     /**
      * Constructor.
      * 
@@ -116,7 +126,17 @@ protected void visitContentIdHeader(PartVisitor visitor) throws IOException {
         }
     }
 
-    protected void visitEndOfHeader(PartVisitor visitor) throws IOException {
+    protected void visitCustomHeaders(PartVisitor visitor) throws IOException {
+        if (isNonEmpty(customHeaders)) {
+            for (Param param: customHeaders) {
+                visitor.withBytes(CRLF_BYTES);
+                visitor.withBytes(param.getName().getBytes(US_ASCII));
+                visitor.withBytes(param.getValue().getBytes(US_ASCII));
+            }
+        }
+    }
+
+    protected void visitEndOfHeaders(PartVisitor visitor) throws IOException {
         visitor.withBytes(CRLF_BYTES);
         visitor.withBytes(CRLF_BYTES);
     }
@@ -148,7 +168,8 @@ public void write(OutputStream out, byte[] boundary) throws IOException {
         visitContentTypeHeader(visitor);
         visitTransferEncodingHeader(visitor);
         visitContentIdHeader(visitor);
-        visitEndOfHeader(visitor);
+        visitCustomHeaders(visitor);
+        visitEndOfHeaders(visitor);
         sendData(visitor.getOutputStream());
         visitEnd(visitor);
     }
@@ -172,7 +193,8 @@ public long length(byte[] boundary) {
                 visitContentTypeHeader(visitor);
                 visitTransferEncodingHeader(visitor);
                 visitContentIdHeader(visitor);
-                visitEndOfHeader(visitor);
+                visitCustomHeaders(visitor);
+                visitEndOfHeaders(visitor);
                 visitEnd(visitor);
                 return dataLength + visitor.getCount();
             }
@@ -227,4 +249,11 @@ public String getDispositionType() {
     public void setDispositionType(String dispositionType) {
         this.dispositionType = dispositionType;
     }
+
+    public void addCustomHeader(String name, String value) {
+        if (customHeaders == null) {
+            customHeaders = new ArrayList<Param>(2);
+        }
+        customHeaders.add(new Param(name, value));
+    }
 }
diff --git a/api/src/main/java/org/asynchttpclient/multipart/PartVisitor.java b/api/src/main/java/org/asynchttpclient/request/body/multipart/PartVisitor.java
similarity index 94%
rename from api/src/main/java/org/asynchttpclient/multipart/PartVisitor.java
rename to api/src/main/java/org/asynchttpclient/request/body/multipart/PartVisitor.java
index a7b8b8449..0ab6a86ae 100644
--- a/api/src/main/java/org/asynchttpclient/multipart/PartVisitor.java
+++ b/api/src/main/java/org/asynchttpclient/request/body/multipart/PartVisitor.java
@@ -10,7 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.multipart;
+package org.asynchttpclient.request.body.multipart;
 
 import java.io.IOException;
 
diff --git a/api/src/main/java/org/asynchttpclient/multipart/StringPart.java b/api/src/main/java/org/asynchttpclient/request/body/multipart/StringPart.java
similarity index 64%
rename from api/src/main/java/org/asynchttpclient/multipart/StringPart.java
rename to api/src/main/java/org/asynchttpclient/request/body/multipart/StringPart.java
index eb6b90b32..e41faac95 100644
--- a/api/src/main/java/org/asynchttpclient/multipart/StringPart.java
+++ b/api/src/main/java/org/asynchttpclient/request/body/multipart/StringPart.java
@@ -10,7 +10,9 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.multipart;
+package org.asynchttpclient.request.body.multipart;
+
+import static java.nio.charset.StandardCharsets.*;
 
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
@@ -18,8 +20,6 @@
 import java.nio.channels.WritableByteChannel;
 import java.nio.charset.Charset;
 
-import org.asynchttpclient.util.StandardCharsets;
-
 public class StringPart extends PartBase {
 
     /**
@@ -30,7 +30,7 @@
     /**
      * Default charset of string parameters
      */
-    public static final Charset DEFAULT_CHARSET = StandardCharsets.US_ASCII;
+    public static final Charset DEFAULT_CHARSET = US_ASCII;
 
     /**
      * Default transfer encoding of string parameters
@@ -41,36 +41,47 @@
      * Contents of this StringPart.
      */
     private final byte[] content;
+    private final String value;
 
     private static Charset charsetOrDefault(Charset charset) {
         return charset == null ? DEFAULT_CHARSET : charset;
     }
+    
+    private static String contentTypeOrDefault(String contentType) {
+        return contentType == null ? DEFAULT_CONTENT_TYPE : contentType;
+    }
+    
+    private static String transferEncodingOrDefault(String transferEncoding) {
+        return transferEncoding == null ? DEFAULT_TRANSFER_ENCODING : transferEncoding;
+    }
+    
+    public StringPart(String name, String value) {
+        this(name, value, null);
+    }
 
-    public StringPart(String name, String value, Charset charset) {
-        this(name, value, charset, null);
+    public StringPart(String name, String value, String contentType) {
+        this(name, value, contentType, null);
     }
 
-    /**
-     * Constructor.
-     * 
-     * @param name
-     *            The name of the part
-     * @param value
-     *            the string to post
-     * @param charset
-     *            the charset to be used to encode the string, if <code>null</code> the {@link #DEFAULT_CHARSET default} is used
-     * @param contentId
-     *            the content id
-     */
-    public StringPart(String name, String value, Charset charset, String contentId) {
+    public StringPart(String name, String value, String contentType, Charset charset) {
+        this(name, value, contentType, charset, null);
+    }
+
+    public StringPart(String name, String value, String contentType, Charset charset, String contentId) {
+        this(name, value, contentType, charset, contentId, null);
+    }
 
-        super(name, DEFAULT_CONTENT_TYPE, charsetOrDefault(charset), DEFAULT_TRANSFER_ENCODING, contentId);
+    public StringPart(String name, String value, String contentType, Charset charset, String contentId, String transferEncoding) {
+        super(name, contentTypeOrDefault(contentType), charsetOrDefault(charset), contentId, transferEncodingOrDefault(transferEncoding));
         if (value == null)
             throw new NullPointerException("value");
+
         if (value.indexOf(0) != -1)
             // See RFC 2048, 2.8. "8bit Data"
             throw new IllegalArgumentException("NULs may not be present in string parts");
-        content = value.getBytes(charsetOrDefault(charset));
+
+        content = value.getBytes(getCharset());
+        this.value = value;
     }
 
     /**
@@ -104,4 +115,8 @@ protected long getDataLength() {
     public long write(WritableByteChannel target, byte[] boundary) throws IOException {
         return MultipartUtils.writeBytesToChannel(target, getBytes(boundary));
     }
+
+    public String getValue() {
+        return value;
+    }
 }
diff --git a/api/src/main/java/org/asynchttpclient/simple/SimpleAHCTransferListener.java b/api/src/main/java/org/asynchttpclient/simple/SimpleAHCTransferListener.java
index a22d7a4e3..a9aa16eb2 100644
--- a/api/src/main/java/org/asynchttpclient/simple/SimpleAHCTransferListener.java
+++ b/api/src/main/java/org/asynchttpclient/simple/SimpleAHCTransferListener.java
@@ -13,7 +13,6 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-import org.asynchttpclient.SimpleAsyncHttpClient;
 import org.asynchttpclient.uri.Uri;
 
 /**
@@ -21,7 +20,7 @@
  * <p/>
  * Note: This listener does not cover requests failing before a connection is
  * established. For error handling, see
- * {@link org.asynchttpclient.SimpleAsyncHttpClient.Builder#setDefaultThrowableHandler(org.asynchttpclient.ThrowableHandler)}
+ * {@link org.asynchttpclient.simple.SimpleAsyncHttpClient.Builder#setDefaultThrowableHandler(org.asynchttpclient.ThrowableHandler)}
  *
  * @author Benjamin Hanzelmann
  */
diff --git a/api/src/main/java/org/asynchttpclient/SimpleAsyncHttpClient.java b/api/src/main/java/org/asynchttpclient/simple/SimpleAsyncHttpClient.java
similarity index 93%
rename from api/src/main/java/org/asynchttpclient/SimpleAsyncHttpClient.java
rename to api/src/main/java/org/asynchttpclient/simple/SimpleAsyncHttpClient.java
index dd502a9c7..ef9ea74e5 100644
--- a/api/src/main/java/org/asynchttpclient/SimpleAsyncHttpClient.java
+++ b/api/src/main/java/org/asynchttpclient/simple/SimpleAsyncHttpClient.java
@@ -10,12 +10,13 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient;
+package org.asynchttpclient.simple;
 
 import static org.asynchttpclient.util.MiscUtils.closeSilently;
 
 import java.io.Closeable;
 import java.io.IOException;
+import java.nio.charset.Charset;
 import java.util.Collection;
 import java.util.List;
 import java.util.Map;
@@ -24,12 +25,29 @@
 
 import javax.net.ssl.SSLContext;
 
+import org.asynchttpclient.AsyncCompletionHandlerBase;
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.DefaultAsyncHttpClient;
+import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.Param;
+import org.asynchttpclient.Realm;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.Response;
 import org.asynchttpclient.cookie.Cookie;
-import org.asynchttpclient.multipart.Part;
-import org.asynchttpclient.resumable.ResumableAsyncHandler;
-import org.asynchttpclient.resumable.ResumableIOExceptionFilter;
-import org.asynchttpclient.simple.HeaderMap;
-import org.asynchttpclient.simple.SimpleAHCTransferListener;
+import org.asynchttpclient.handler.ProgressAsyncHandler;
+import org.asynchttpclient.handler.resumable.ResumableAsyncHandler;
+import org.asynchttpclient.handler.resumable.ResumableIOExceptionFilter;
+import org.asynchttpclient.proxy.ProxyServer;
+import org.asynchttpclient.request.body.generator.BodyGenerator;
+import org.asynchttpclient.request.body.multipart.Part;
+import org.asynchttpclient.simple.consumer.BodyConsumer;
+import org.asynchttpclient.simple.consumer.ResumableBodyConsumer;
 import org.asynchttpclient.uri.Uri;
 
 /**
@@ -72,11 +90,9 @@
     private final ErrorDocumentBehaviour errorDocumentBehaviour;
     private final SimpleAHCTransferListener listener;
     private final boolean derived;
-    private final String providerClass;
 
     private SimpleAsyncHttpClient(AsyncHttpClientConfig config, RequestBuilder requestBuilder, ThrowableHandler defaultThrowableHandler,
-            ErrorDocumentBehaviour errorDocumentBehaviour, boolean resumeEnabled, AsyncHttpClient ahc, SimpleAHCTransferListener listener,
-            String providerClass) {
+            ErrorDocumentBehaviour errorDocumentBehaviour, boolean resumeEnabled, AsyncHttpClient ahc, SimpleAHCTransferListener listener) {
         this.config = config;
         this.requestBuilder = requestBuilder;
         this.defaultThrowableHandler = defaultThrowableHandler;
@@ -84,7 +100,6 @@ private SimpleAsyncHttpClient(AsyncHttpClientConfig config, RequestBuilder reque
         this.errorDocumentBehaviour = errorDocumentBehaviour;
         this.asyncHttpClient = ahc;
         this.listener = listener;
-        this.providerClass = providerClass;
 
         this.derived = ahc != null;
     }
@@ -297,10 +312,7 @@ private RequestBuilder rebuildRequest(Request rb) {
     private AsyncHttpClient asyncHttpClient() {
         synchronized (config) {
             if (asyncHttpClient == null) {
-                if (providerClass == null)
-                    asyncHttpClient = new DefaultAsyncHttpClient(config);
-                else
-                    asyncHttpClient = new DefaultAsyncHttpClient(providerClass, config);
+                asyncHttpClient = new DefaultAsyncHttpClient(config);
             }
         }
         return asyncHttpClient;
@@ -418,7 +430,6 @@ public DerivedBuilder derive() {
         private ErrorDocumentBehaviour errorDocumentBehaviour = ErrorDocumentBehaviour.WRITE;
         private AsyncHttpClient ahc = null;
         private SimpleAHCTransferListener listener = null;
-        private String providerClass = null;
 
         public Builder() {
             requestBuilder = new RequestBuilder("GET", false);
@@ -508,8 +519,8 @@ public Builder setMaxConnectionsPerHost(int defaultMaxConnectionsPerHost) {
             return this;
         }
 
-        public Builder setConnectionTimeout(int connectionTimeuot) {
-            configBuilder.setConnectionTimeout(connectionTimeuot);
+        public Builder setConnectTimeout(int connectTimeuot) {
+            configBuilder.setConnectTimeout(connectTimeuot);
             return this;
         }
 
@@ -583,8 +594,8 @@ public Builder setRealmUsePreemptiveAuth(boolean usePreemptiveAuth) {
             return this;
         }
 
-        public Builder setRealmEnconding(String enc) {
-            realm().setEncoding(enc);
+        public Builder setRealmCharset(Charset charset) {
+            realm().setCharset(charset);
             return this;
         }
 
@@ -663,11 +674,6 @@ public Builder setMaxRequestRetry(int maxRequestRetry) {
             return this;
         }
 
-        public Builder setProviderClass(String providerClass) {
-            this.providerClass = providerClass;
-            return this;
-        }
-
         public Builder setAcceptAnyCertificate(boolean acceptAnyCertificate) {
             configBuilder.setAcceptAnyCertificate(acceptAnyCertificate);
             return this;
@@ -686,7 +692,7 @@ public SimpleAsyncHttpClient build() {
             configBuilder.addIOExceptionFilter(new ResumableIOExceptionFilter());
 
             SimpleAsyncHttpClient sc = new SimpleAsyncHttpClient(configBuilder.build(), requestBuilder, defaultThrowableHandler,
-                    errorDocumentBehaviour, enableResumableDownload, ahc, listener, providerClass);
+                    errorDocumentBehaviour, enableResumableDownload, ahc, listener);
 
             return sc;
         }
@@ -701,15 +707,15 @@ public ResumableBodyConsumerAsyncHandler(long byteTransferred, ProgressAsyncHand
             this.delegate = delegate;
         }
 
-        public AsyncHandler.STATE onHeaderWriteCompleted() {
-            return delegate.onHeaderWriteCompleted();
+        public AsyncHandler.State onHeadersWritten() {
+            return delegate.onHeadersWritten();
         }
 
-        public AsyncHandler.STATE onContentWriteCompleted() {
-            return delegate.onContentWriteCompleted();
+        public AsyncHandler.State onContentWritten() {
+            return delegate.onContentWritten();
         }
 
-        public AsyncHandler.STATE onContentWriteProgress(long amount, long current, long total) {
+        public AsyncHandler.State onContentWriteProgress(long amount, long current, long total) {
             return delegate.onContentWriteProgress(amount, current, total);
         }
     }
@@ -752,10 +758,10 @@ public void onThrowable(Throwable t) {
         /**
          * {@inheritDoc}
          */
-        public STATE onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
+        public State onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
             fireReceived(content);
             if (omitBody) {
-                return STATE.CONTINUE;
+                return State.CONTINUE;
             }
 
             if (!accumulateBody && bodyConsumer != null) {
@@ -763,7 +769,7 @@ public STATE onBodyPartReceived(final HttpResponseBodyPart content) throws Excep
             } else {
                 return super.onBodyPartReceived(content);
             }
-            return STATE.CONTINUE;
+            return State.CONTINUE;
         }
 
         /**
@@ -782,7 +788,7 @@ private void closeConsumer() {
         }
 
         @Override
-        public STATE onStatusReceived(HttpResponseStatus status) throws Exception {
+        public State onStatusReceived(HttpResponseStatus status) throws Exception {
             fireStatus(status);
 
             if (isErrorStatus(status)) {
@@ -805,7 +811,7 @@ private boolean isErrorStatus(HttpResponseStatus status) {
         }
 
         @Override
-        public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
+        public State onHeadersReceived(HttpResponseHeaders headers) throws Exception {
             calculateTotal(headers);
 
             fireHeaders(headers);
@@ -824,7 +830,7 @@ private void calculateTotal(HttpResponseHeaders headers) {
         }
 
         @Override
-        public STATE onContentWriteProgress(long amount, long current, long total) {
+        public State onContentWriteProgress(long amount, long current, long total) {
             fireSent(uri, amount, current, total);
             return super.onContentWriteProgress(amount, current, total);
         }
diff --git a/api/src/main/java/org/asynchttpclient/ThrowableHandler.java b/api/src/main/java/org/asynchttpclient/simple/ThrowableHandler.java
similarity index 95%
rename from api/src/main/java/org/asynchttpclient/ThrowableHandler.java
rename to api/src/main/java/org/asynchttpclient/simple/ThrowableHandler.java
index 1bc28ea82..020db9bc3 100644
--- a/api/src/main/java/org/asynchttpclient/ThrowableHandler.java
+++ b/api/src/main/java/org/asynchttpclient/simple/ThrowableHandler.java
@@ -11,7 +11,8 @@
 * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
 */
 
-package org.asynchttpclient;
+package org.asynchttpclient.simple;
+
 
 /**
  * Simple {@link Throwable} handler to be used with {@link SimpleAsyncHttpClient}
diff --git a/api/src/main/java/org/asynchttpclient/consumers/AppendableBodyConsumer.java b/api/src/main/java/org/asynchttpclient/simple/consumer/AppendableBodyConsumer.java
similarity index 81%
rename from api/src/main/java/org/asynchttpclient/consumers/AppendableBodyConsumer.java
rename to api/src/main/java/org/asynchttpclient/simple/consumer/AppendableBodyConsumer.java
index 6f84d57f6..fa9657566 100644
--- a/api/src/main/java/org/asynchttpclient/consumers/AppendableBodyConsumer.java
+++ b/api/src/main/java/org/asynchttpclient/simple/consumer/AppendableBodyConsumer.java
@@ -10,14 +10,14 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.consumers;
+package org.asynchttpclient.simple.consumer;
 
-import org.asynchttpclient.BodyConsumer;
-import org.asynchttpclient.util.StandardCharsets;
+import static java.nio.charset.StandardCharsets.UTF_8;
 
 import java.io.Closeable;
 import java.io.IOException;
 import java.nio.ByteBuffer;
+import java.nio.charset.Charset;
 
 /**
  * An {@link Appendable} customer for {@link ByteBuffer}
@@ -25,22 +25,22 @@
 public class AppendableBodyConsumer implements BodyConsumer {
 
     private final Appendable appendable;
-    private final String encoding;
+    private final Charset charset;
 
-    public AppendableBodyConsumer(Appendable appendable, String encoding) {
+    public AppendableBodyConsumer(Appendable appendable, Charset charset) {
         this.appendable = appendable;
-        this.encoding = encoding;
+        this.charset = charset;
     }
 
     public AppendableBodyConsumer(Appendable appendable) {
         this.appendable = appendable;
-        this.encoding = StandardCharsets.UTF_8.name();
+        this.charset = UTF_8;
     }
 
     @Override
     public void consume(ByteBuffer byteBuffer) throws IOException {
         appendable
-                .append(new String(byteBuffer.array(), byteBuffer.arrayOffset() + byteBuffer.position(), byteBuffer.remaining(), encoding));
+                .append(new String(byteBuffer.array(), byteBuffer.arrayOffset() + byteBuffer.position(), byteBuffer.remaining(), charset));
     }
 
     @Override
diff --git a/api/src/main/java/org/asynchttpclient/BodyConsumer.java b/api/src/main/java/org/asynchttpclient/simple/consumer/BodyConsumer.java
similarity index 91%
rename from api/src/main/java/org/asynchttpclient/BodyConsumer.java
rename to api/src/main/java/org/asynchttpclient/simple/consumer/BodyConsumer.java
index 190c586ae..4aede5263 100644
--- a/api/src/main/java/org/asynchttpclient/BodyConsumer.java
+++ b/api/src/main/java/org/asynchttpclient/simple/consumer/BodyConsumer.java
@@ -11,12 +11,14 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package org.asynchttpclient;
+package org.asynchttpclient.simple.consumer;
 
 import java.io.Closeable;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 
+import org.asynchttpclient.simple.SimpleAsyncHttpClient;
+
 /**
  * A simple API to be used with the {@link SimpleAsyncHttpClient} class in order to process response's bytes.
  */
diff --git a/api/src/main/java/org/asynchttpclient/consumers/ByteBufferBodyConsumer.java b/api/src/main/java/org/asynchttpclient/simple/consumer/ByteBufferBodyConsumer.java
similarity index 94%
rename from api/src/main/java/org/asynchttpclient/consumers/ByteBufferBodyConsumer.java
rename to api/src/main/java/org/asynchttpclient/simple/consumer/ByteBufferBodyConsumer.java
index a8b4c748e..9ebcf75d8 100644
--- a/api/src/main/java/org/asynchttpclient/consumers/ByteBufferBodyConsumer.java
+++ b/api/src/main/java/org/asynchttpclient/simple/consumer/ByteBufferBodyConsumer.java
@@ -10,9 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.consumers;
-
-import org.asynchttpclient.BodyConsumer;
+package org.asynchttpclient.simple.consumer;
 
 import java.io.IOException;
 import java.nio.ByteBuffer;
diff --git a/api/src/main/java/org/asynchttpclient/consumers/FileBodyConsumer.java b/api/src/main/java/org/asynchttpclient/simple/consumer/FileBodyConsumer.java
similarity index 95%
rename from api/src/main/java/org/asynchttpclient/consumers/FileBodyConsumer.java
rename to api/src/main/java/org/asynchttpclient/simple/consumer/FileBodyConsumer.java
index 5677dfdd1..fd03e110a 100644
--- a/api/src/main/java/org/asynchttpclient/consumers/FileBodyConsumer.java
+++ b/api/src/main/java/org/asynchttpclient/simple/consumer/FileBodyConsumer.java
@@ -10,9 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.consumers;
-
-import org.asynchttpclient.ResumableBodyConsumer;
+package org.asynchttpclient.simple.consumer;
 
 import java.io.IOException;
 import java.io.RandomAccessFile;
diff --git a/api/src/main/java/org/asynchttpclient/consumers/OutputStreamBodyConsumer.java b/api/src/main/java/org/asynchttpclient/simple/consumer/OutputStreamBodyConsumer.java
similarity index 94%
rename from api/src/main/java/org/asynchttpclient/consumers/OutputStreamBodyConsumer.java
rename to api/src/main/java/org/asynchttpclient/simple/consumer/OutputStreamBodyConsumer.java
index 65f8f85cc..de3a02d5b 100644
--- a/api/src/main/java/org/asynchttpclient/consumers/OutputStreamBodyConsumer.java
+++ b/api/src/main/java/org/asynchttpclient/simple/consumer/OutputStreamBodyConsumer.java
@@ -10,9 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.consumers;
-
-import org.asynchttpclient.BodyConsumer;
+package org.asynchttpclient.simple.consumer;
 
 import java.io.IOException;
 import java.io.OutputStream;
diff --git a/api/src/main/java/org/asynchttpclient/ResumableBodyConsumer.java b/api/src/main/java/org/asynchttpclient/simple/consumer/ResumableBodyConsumer.java
similarity index 96%
rename from api/src/main/java/org/asynchttpclient/ResumableBodyConsumer.java
rename to api/src/main/java/org/asynchttpclient/simple/consumer/ResumableBodyConsumer.java
index 42e71536c..a45ca05f1 100644
--- a/api/src/main/java/org/asynchttpclient/ResumableBodyConsumer.java
+++ b/api/src/main/java/org/asynchttpclient/simple/consumer/ResumableBodyConsumer.java
@@ -11,7 +11,7 @@
 * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
 */
 
-package org.asynchttpclient;
+package org.asynchttpclient.simple.consumer;
 
 import java.io.IOException;
 
diff --git a/api/src/main/java/org/asynchttpclient/spnego/SpnegoEngine.java b/api/src/main/java/org/asynchttpclient/spnego/SpnegoEngine.java
index dc371e029..205bc4bbe 100644
--- a/api/src/main/java/org/asynchttpclient/spnego/SpnegoEngine.java
+++ b/api/src/main/java/org/asynchttpclient/spnego/SpnegoEngine.java
@@ -78,7 +78,7 @@ public static SpnegoEngine instance() {
         return instance;
     }
 
-    public String generateToken(String server) throws Throwable {
+    public String generateToken(String server) throws SpnegoEngineException {
         GSSContext gssContext = null;
         byte[] token = null; // base64 decoded challenge
         Oid negotiationOid = null;
@@ -140,7 +140,7 @@ public String generateToken(String server) throws Throwable {
 
             token = gssContext.initSecContext(token, 0, token.length);
             if (token == null) {
-                throw new Exception("GSS security context initialization failed");
+                throw new SpnegoEngineException("GSS security context initialization failed");
             }
 
             /*
@@ -159,16 +159,16 @@ public String generateToken(String server) throws Throwable {
         } catch (GSSException gsse) {
             log.error("generateToken", gsse);
             if (gsse.getMajor() == GSSException.DEFECTIVE_CREDENTIAL || gsse.getMajor() == GSSException.CREDENTIALS_EXPIRED)
-                throw new Exception(gsse.getMessage(), gsse);
+                throw new SpnegoEngineException(gsse.getMessage(), gsse);
             if (gsse.getMajor() == GSSException.NO_CRED)
-                throw new Exception(gsse.getMessage(), gsse);
+                throw new SpnegoEngineException(gsse.getMessage(), gsse);
             if (gsse.getMajor() == GSSException.DEFECTIVE_TOKEN || gsse.getMajor() == GSSException.DUPLICATE_TOKEN
                     || gsse.getMajor() == GSSException.OLD_TOKEN)
-                throw new Exception(gsse.getMessage(), gsse);
+                throw new SpnegoEngineException(gsse.getMessage(), gsse);
             // other error
-            throw new Exception(gsse.getMessage());
+            throw new SpnegoEngineException(gsse.getMessage());
         } catch (IOException ex) {
-            throw new Exception(ex.getMessage());
+            throw new SpnegoEngineException(ex.getMessage());
         }
     }
 }
diff --git a/api/src/main/java/org/asynchttpclient/spnego/SpnegoEngineException.java b/api/src/main/java/org/asynchttpclient/spnego/SpnegoEngineException.java
new file mode 100644
index 000000000..d7e89dff9
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/spnego/SpnegoEngineException.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.spnego;
+
+/**
+ * Signals SPNEGO protocol failure.
+ */
+public class SpnegoEngineException extends RuntimeException {
+
+    private static final long serialVersionUID = -3123799505052881438L;
+
+    public SpnegoEngineException(String message) {
+        super(message);
+    }
+
+    public SpnegoEngineException(String message, Throwable cause) {
+        super(message, cause);
+    }
+}
\ No newline at end of file
diff --git a/api/src/main/java/org/asynchttpclient/uri/Uri.java b/api/src/main/java/org/asynchttpclient/uri/Uri.java
index 4eb455957..ccd304682 100644
--- a/api/src/main/java/org/asynchttpclient/uri/Uri.java
+++ b/api/src/main/java/org/asynchttpclient/uri/Uri.java
@@ -16,6 +16,7 @@
 import java.net.URISyntaxException;
 
 import org.asynchttpclient.util.MiscUtils;
+import org.asynchttpclient.util.StringUtils;
 
 public class Uri {
     
@@ -93,7 +94,7 @@ public URI toJavaNetURI() throws URISyntaxException {
 
     public String toUrl() {
         if (url == null) {
-            StringBuilder sb = new StringBuilder();
+            StringBuilder sb = StringUtils.stringBuilder();
             sb.append(scheme).append("://");
             if (userInfo != null)
                 sb.append(userInfo).append('@');
@@ -104,14 +105,14 @@ public String toUrl() {
                 sb.append(path);
             if (query != null)
                 sb.append('?').append(query);
-
             url = sb.toString();
+            sb.setLength(0);
         }
         return url;
     }
 
     public String toRelativeUrl() {
-        StringBuilder sb = new StringBuilder();
+        StringBuilder sb = StringUtils.stringBuilder();
         if (MiscUtils.isNonEmpty(path))
             sb.append(path);
         else
diff --git a/api/src/main/java/org/asynchttpclient/uri/UriParser.java b/api/src/main/java/org/asynchttpclient/uri/UriParser.java
index 505bf78b6..a480a96fd 100644
--- a/api/src/main/java/org/asynchttpclient/uri/UriParser.java
+++ b/api/src/main/java/org/asynchttpclient/uri/UriParser.java
@@ -212,6 +212,8 @@ private void removeEmbedded2Dots() {
                 if (end >= 0 && path.indexOf("/../", end) != 0) {
                     path = path.substring(0, end) + path.substring(i + 3);
                     i = 0;
+                } else if (end == 0) {
+                    break;
                 }
             } else
                 i = i + 3;
diff --git a/api/src/main/java/org/asynchttpclient/util/AsyncHttpProviderUtils.java b/api/src/main/java/org/asynchttpclient/util/AsyncHttpProviderUtils.java
index 93ed28262..9d7470452 100644
--- a/api/src/main/java/org/asynchttpclient/util/AsyncHttpProviderUtils.java
+++ b/api/src/main/java/org/asynchttpclient/util/AsyncHttpProviderUtils.java
@@ -12,15 +12,16 @@
  */
 package org.asynchttpclient.util;
 
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+import static java.nio.charset.StandardCharsets.ISO_8859_1;
+import static org.asynchttpclient.util.MiscUtils.*;
 
 import java.io.IOException;
-import java.io.UnsupportedEncodingException;
+import java.nio.ByteBuffer;
 import java.nio.charset.Charset;
 import java.util.List;
 
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.Param;
 import org.asynchttpclient.Request;
 import org.asynchttpclient.uri.Uri;
 
@@ -29,77 +30,39 @@
  */
 public class AsyncHttpProviderUtils {
 
-    public static final IOException REMOTELY_CLOSED_EXCEPTION = new IOException("Remotely Closed");
+    public static final IOException REMOTELY_CLOSED_EXCEPTION = buildStaticIOException("Remotely closed");
+    public static final IOException CHANNEL_CLOSED_EXCEPTION = buildStaticIOException("Channel closed");
 
-    static {
-        REMOTELY_CLOSED_EXCEPTION.setStackTrace(new StackTraceElement[] {});
-    }
-
-    private final static byte[] NO_BYTES = new byte[0];
-
-    public final static Charset DEFAULT_CHARSET = StandardCharsets.ISO_8859_1;
+    public final static Charset DEFAULT_CHARSET = ISO_8859_1;
 
     public static final void validateSupportedScheme(Uri uri) {
         final String scheme = uri.getScheme();
-        if (scheme == null || !scheme.equalsIgnoreCase("http") && !scheme.equalsIgnoreCase("https") && !scheme.equalsIgnoreCase("ws")
-                && !scheme.equalsIgnoreCase("wss")) {
-            throw new IllegalArgumentException("The URI scheme, of the URI " + uri
-                    + ", must be equal (ignoring case) to 'http', 'https', 'ws', or 'wss'");
+        if (scheme == null || !scheme.equalsIgnoreCase("http") && !scheme.equalsIgnoreCase("https") && !scheme.equalsIgnoreCase("ws") && !scheme.equalsIgnoreCase("wss")) {
+            throw new IllegalArgumentException("The URI scheme, of the URI " + uri + ", must be equal (ignoring case) to 'http', 'https', 'ws', or 'wss'");
         }
     }
 
-    /**
-     * @param bodyParts NON EMPTY body part
-     * @param maxLen
-     * @return
-     * @throws UnsupportedEncodingException
-     */
-    public final static byte[] contentToBytes(List<HttpResponseBodyPart> bodyParts, int maxLen) throws UnsupportedEncodingException {
-        final int partCount = bodyParts.size();
-        if (partCount == 0) {
-            return NO_BYTES;
-        }
-        if (partCount == 1) {
-            byte[] chunk = bodyParts.get(0).getBodyPartBytes();
-            if (chunk.length <= maxLen) {
-                return chunk;
-            }
-            byte[] result = new byte[maxLen];
-            System.arraycopy(chunk, 0, result, 0, maxLen);
-            return result;
-        }
-        int size = 0;
-        byte[] result = new byte[maxLen];
-        for (HttpResponseBodyPart part : bodyParts) {
-            byte[] chunk = part.getBodyPartBytes();
-            int amount = Math.min(maxLen - size, chunk.length);
-            System.arraycopy(chunk, 0, result, size, amount);
-            size += amount;
-            if (size == maxLen) {
-                return result;
-            }
-        }
-        if (size < maxLen) {
-            byte[] old = result;
-            result = new byte[old.length];
-            System.arraycopy(old, 0, result, 0, old.length);
-        }
-        return result;
-    }
-
     public final static String getBaseUrl(Uri uri) {
         return uri.getScheme() + "://" + getAuthority(uri);
     }
 
     public final static String getAuthority(Uri uri) {
-        int port = uri.getPort() != -1? uri.getPort() : getDefaultPort(uri);
+        int port = uri.getPort() != -1 ? uri.getPort() : getExplicitPort(uri);
         return uri.getHost() + ":" + port;
     }
 
-    public final static int getDefaultPort(Uri uri) {
+    public final static boolean isSameBase(Uri uri1, Uri uri2) {
+        return uri1.getScheme().equals(uri2.getScheme()) && uri1.getHost().equals(uri2.getHost()) && getExplicitPort(uri1) == getExplicitPort(uri2);
+    }
+
+    public static final int getSchemeDefaultPort(String scheme) {
+        return scheme.equals("http") || scheme.equals("ws") ? 80 : 443;
+    }
+
+    public static final int getExplicitPort(Uri uri) {
         int port = uri.getPort();
         if (port == -1)
-            port = uri.getScheme().equals("http") || uri.getScheme().equals("ws") ? 80 : 443;
+            port = getSchemeDefaultPort(uri.getScheme());
         return port;
     }
 
@@ -112,7 +75,7 @@ public final static String getNonEmptyPath(Uri uri) {
         return isNonEmpty(uri.getPath()) ? uri.getPath() : "/";
     }
 
-    public static String parseCharset(String contentType) {
+    public static Charset parseCharset(String contentType) {
         for (String part : contentType.split(";")) {
             if (part.trim().startsWith("charset=")) {
                 String[] val = part.split("=");
@@ -123,22 +86,52 @@ public static String parseCharset(String contentType) {
                     // not correct, but client should be able to handle
                     // it (all browsers do, Grizzly strips it by default)
                     // This is a poor man's trim("\"").trim("'")
-                    return charset.replaceAll("\"", "").replaceAll("'", "");
+                    String charsetName = charset.replaceAll("\"", "").replaceAll("'", "");
+                    return Charset.forName(charsetName);
                 }
             }
         }
         return null;
     }
 
-    public static String keepAliveHeaderValue(AsyncHttpClientConfig config) {
-        return config.isAllowPoolingConnections() ? "keep-alive" : "close";
-    }
-
     public static int requestTimeout(AsyncHttpClientConfig config, Request request) {
-        return request.getRequestTimeoutInMs() != 0 ? request.getRequestTimeoutInMs() : config.getRequestTimeout();
+        return request.getRequestTimeout() != 0 ? request.getRequestTimeout() : config.getRequestTimeout();
     }
 
     public static boolean followRedirect(AsyncHttpClientConfig config, Request request) {
-        return request.getFollowRedirect() != null? request.getFollowRedirect().booleanValue() : config.isFollowRedirect();
+        return request.getFollowRedirect() != null ? request.getFollowRedirect().booleanValue() : config.isFollowRedirect();
+    }
+
+    private static StringBuilder urlEncodeFormParams0(List<Param> params) {
+        StringBuilder sb = StringUtils.stringBuilder();
+        for (Param param : params) {
+            encodeAndAppendFormParam(sb, param.getName(), param.getValue());
+        }
+        sb.setLength(sb.length() - 1);
+        return sb;
+    }
+
+    public static ByteBuffer urlEncodeFormParams(List<Param> params, Charset charset) {
+        return StringUtils.charSequence2ByteBuffer(urlEncodeFormParams0(params), charset);
+    }
+
+    private static void encodeAndAppendFormParam(final StringBuilder sb, final CharSequence name, final CharSequence value) {
+        Utf8UrlEncoder.encodeAndAppendFormElement(sb, name);
+        if (value != null) {
+            sb.append('=');
+            Utf8UrlEncoder.encodeAndAppendFormElement(sb, value);
+        }
+        sb.append('&');
+    }
+
+    public static String hostHeader(Request request, Uri uri) {
+        String virtualHost = request.getVirtualHost();
+        if (virtualHost != null)
+            return virtualHost;
+        else {
+            String host = uri.getHost();
+            int port = uri.getPort();
+            return port == -1 || port == getSchemeDefaultPort(uri.getScheme()) ? host : host + ":" + port;
+        }
     }
 }
diff --git a/api/src/main/java/org/asynchttpclient/util/AsyncPropertiesHelper.java b/api/src/main/java/org/asynchttpclient/util/AsyncPropertiesHelper.java
deleted file mode 100644
index e46c2d113..000000000
--- a/api/src/main/java/org/asynchttpclient/util/AsyncPropertiesHelper.java
+++ /dev/null
@@ -1,25 +0,0 @@
-package org.asynchttpclient.util;
-
-import com.typesafe.config.Config;
-import com.typesafe.config.ConfigFactory;
-
-public class AsyncPropertiesHelper {
-    
-    public static final String ASYNC_HTTP_CLIENT_IMPL_PROPERTIES_FILE = "ahc.properties";
-    public static final String DEFAULTAHC_PROPERTIES = "ahc-default.properties";
-    
-    public static Config getAsyncHttpClientConfig(){
-        return ConfigFactory.load(ASYNC_HTTP_CLIENT_IMPL_PROPERTIES_FILE)
-                .withFallback(ConfigFactory.load(DEFAULTAHC_PROPERTIES));
-    }
-    
-    /**
-     * This method invalidates the property caches. So if a system property has been changed and the
-     * effect of this change is to be seen then call reloadProperties() and then getAsyncHttpClientConfig() 
-     * to get the new property values.
-     */
-    public static void reloadProperties(){
-        ConfigFactory.invalidateCaches();
-    }
-
-}
diff --git a/api/src/main/java/org/asynchttpclient/util/AuthenticatorUtils.java b/api/src/main/java/org/asynchttpclient/util/AuthenticatorUtils.java
index 13074fb80..796e115da 100644
--- a/api/src/main/java/org/asynchttpclient/util/AuthenticatorUtils.java
+++ b/api/src/main/java/org/asynchttpclient/util/AuthenticatorUtils.java
@@ -12,59 +12,77 @@
  */
 package org.asynchttpclient.util;
 
+import static java.nio.charset.StandardCharsets.ISO_8859_1;
+import static org.asynchttpclient.ntlm.NtlmUtils.getNTLM;
 import static org.asynchttpclient.util.AsyncHttpProviderUtils.getNonEmptyPath;
 import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 
-import org.asynchttpclient.ProxyServer;
+import java.nio.charset.Charset;
+import java.util.List;
+
 import org.asynchttpclient.Realm;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.Realm.AuthScheme;
+import org.asynchttpclient.ntlm.NtlmEngine;
+import org.asynchttpclient.proxy.ProxyServer;
+import org.asynchttpclient.spnego.SpnegoEngine;
 import org.asynchttpclient.uri.Uri;
 
-import java.security.NoSuchAlgorithmException;
-
 public final class AuthenticatorUtils {
 
+    private static final String PROXY_AUTHORIZATION_HEADER = "Proxy-Authorization";
+
     public static String computeBasicAuthentication(Realm realm) {
-        String s = realm.getPrincipal() + ":" + realm.getPassword();
-        return "Basic " + Base64.encode(s.getBytes(realm.getCharset()));
+        return computeBasicAuthentication(realm.getPrincipal(), realm.getPassword(), realm.getCharset());
     }
 
     public static String computeBasicAuthentication(ProxyServer proxyServer) {
-        String s = proxyServer.getPrincipal() + ":" + proxyServer.getPassword();
-        return "Basic " + Base64.encode(s.getBytes(proxyServer.getCharset()));
+        return computeBasicAuthentication(proxyServer.getPrincipal(), proxyServer.getPassword(), proxyServer.getCharset());
     }
 
-    private static String computeRealmURI(Realm realm) {
-        if (realm.isTargetProxy()) {
-            return "/";
+    private static String computeBasicAuthentication(String principal, String password, Charset charset) {
+        String s = principal + ":" + password;
+        return "Basic " + Base64.encode(s.getBytes(charset));
+    }
+
+    public static String computeRealmURI(Realm realm) {
+        return computeRealmURI(realm.getUri(), realm.isUseAbsoluteURI(), realm.isOmitQuery());
+    }
+
+    public static String computeRealmURI(Uri uri, boolean useAbsoluteURI, boolean omitQuery) {
+        if (useAbsoluteURI) {
+            return omitQuery && MiscUtils.isNonEmpty(uri.getQuery()) ? uri.withNewQuery(null).toUrl() : uri.toUrl();
         } else {
-            Uri uri = realm.getUri();
-            if (realm.isUseAbsoluteURI()) {
-                return realm.isOmitQuery() && MiscUtils.isNonEmpty(uri.getQuery()) ? uri.withNewQuery(null).toUrl() : uri.toUrl();
-            } else {
-                String path = getNonEmptyPath(uri);
-                return realm.isOmitQuery() || !MiscUtils.isNonEmpty(uri.getQuery()) ? path : path + "?" + uri.getQuery();
-            }
+            String path = getNonEmptyPath(uri);
+            return omitQuery || !MiscUtils.isNonEmpty(uri.getQuery()) ? path : path + "?" + uri.getQuery();
         }
     }
 
-    public static String computeDigestAuthentication(Realm realm) throws NoSuchAlgorithmException {
+    private static String computeDigestAuthentication(Realm realm) {
 
         StringBuilder builder = new StringBuilder().append("Digest ");
         append(builder, "username", realm.getPrincipal(), true);
         append(builder, "realm", realm.getRealmName(), true);
         append(builder, "nonce", realm.getNonce(), true);
         append(builder, "uri", computeRealmURI(realm), true);
-        append(builder, "algorithm", realm.getAlgorithm(), false);
+        if (isNonEmpty(realm.getAlgorithm()))
+            append(builder, "algorithm", realm.getAlgorithm(), false);
 
         append(builder, "response", realm.getResponse(), true);
-        if (isNonEmpty(realm.getOpaque()))
+
+        if (realm.getOpaque() != null)
             append(builder, "opaque", realm.getOpaque(), true);
-        append(builder, "qop", realm.getQop(), false);
-        append(builder, "nc", realm.getNc(), false);
-        append(builder, "cnonce", realm.getCnonce(), true);
+
+        if (realm.getQop() != null) {
+            append(builder, "qop", realm.getQop(), false);
+            // nc and cnonce only sent if server sent qop
+            append(builder, "nc", realm.getNc(), false);
+            append(builder, "cnonce", realm.getCnonce(), true);
+        }
         builder.setLength(builder.length() - 2); // remove tailing ", "
 
-        return new String(builder.toString().getBytes(StandardCharsets.ISO_8859_1));
+        // FIXME isn't there a more efficient way?
+        return new String(StringUtils.charSequence2Bytes(builder, ISO_8859_1));
     }
 
     private static StringBuilder append(StringBuilder builder, String name, String value, boolean quoted) {
@@ -76,4 +94,118 @@ private static StringBuilder append(StringBuilder builder, String name, String v
 
         return builder.append(", ");
     }
+
+    private static List<String> getProxyAuthorizationHeader(Request request) {
+        return request.getHeaders().get(PROXY_AUTHORIZATION_HEADER);
+    }
+
+    public static String perConnectionProxyAuthorizationHeader(Request request, ProxyServer proxyServer, boolean connect) {
+        String proxyAuthorization = null;
+
+        if (connect) {
+            List<String> auth = getProxyAuthorizationHeader(request);
+            String ntlmHeader = getNTLM(auth);
+            if (ntlmHeader != null) {
+                proxyAuthorization = ntlmHeader;
+            }
+
+        } else if (proxyServer != null && proxyServer.getPrincipal() != null && isNonEmpty(proxyServer.getNtlmDomain())) {
+            List<String> auth = getProxyAuthorizationHeader(request);
+            if (getNTLM(auth) == null) {
+                String msg = NtlmEngine.INSTANCE.generateType1Msg();
+                proxyAuthorization = "NTLM " + msg;
+            }
+        }
+
+        return proxyAuthorization;
+    }
+    
+    public static String perRequestProxyAuthorizationHeader(Request request, ProxyServer proxyServer, Realm realm, boolean connect) {
+
+        String proxyAuthorization = null;
+
+        if (!connect && proxyServer != null && proxyServer.getPrincipal() != null && proxyServer.getScheme() == AuthScheme.BASIC) {
+            proxyAuthorization = computeBasicAuthentication(proxyServer);
+        } else if (realm != null && realm.getUsePreemptiveAuth() && realm.isTargetProxy()) {
+
+            switch (realm.getScheme()) {
+            case BASIC:
+                proxyAuthorization = computeBasicAuthentication(realm);
+                break;
+            case DIGEST:
+                if (isNonEmpty(realm.getNonce()))
+                    proxyAuthorization = computeDigestAuthentication(realm);
+                break;
+            case NTLM:
+            case KERBEROS:
+            case SPNEGO:
+                // NTLM, KERBEROS and SPNEGO are only set on the first request,
+                // see firstRequestOnlyAuthorizationHeader
+            case NONE:
+                break;
+            default:
+                throw new IllegalStateException("Invalid Authentication " + realm);
+            }
+        }
+
+        return proxyAuthorization;
+    }
+
+    public static String perConnectionAuthorizationHeader(Request request, ProxyServer proxyServer, Realm realm) {
+        String authorizationHeader = null;
+
+        if (realm != null && realm.getUsePreemptiveAuth()) {
+            switch (realm.getScheme()) {
+            case NTLM:
+                String msg = NtlmEngine.INSTANCE.generateType1Msg();
+                authorizationHeader = "NTLM " + msg;
+                break;
+            case KERBEROS:
+            case SPNEGO:
+                String host;
+                if (proxyServer != null)
+                    host = proxyServer.getHost();
+                else if (request.getVirtualHost() != null)
+                    host = request.getVirtualHost();
+                else
+                    host = request.getUri().getHost();
+
+                authorizationHeader = "Negotiate " + SpnegoEngine.instance().generateToken(host);
+                break;
+            default:
+                break;
+            }
+        }
+
+        return authorizationHeader;
+    }
+
+    public static String perRequestAuthorizationHeader(Request request, Realm realm) {
+
+        String authorizationHeader = null;
+
+        if (realm != null && realm.getUsePreemptiveAuth()) {
+
+            switch (realm.getScheme()) {
+            case BASIC:
+                authorizationHeader = computeBasicAuthentication(realm);
+                break;
+            case DIGEST:
+                if (isNonEmpty(realm.getNonce()))
+                    authorizationHeader = computeDigestAuthentication(realm);
+                break;
+            case NTLM:
+            case KERBEROS:
+            case SPNEGO:
+                // NTLM, KERBEROS and SPNEGO are only set on the first request,
+                // see firstRequestOnlyAuthorizationHeader
+            case NONE:
+                break;
+            default:
+                throw new IllegalStateException("Invalid Authentication " + realm);
+            }
+        }
+
+        return authorizationHeader;
+    }
 }
diff --git a/api/src/main/java/org/asynchttpclient/util/DefaultHostnameVerifier.java b/api/src/main/java/org/asynchttpclient/util/DefaultHostnameVerifier.java
deleted file mode 100644
index 35f188ca9..000000000
--- a/api/src/main/java/org/asynchttpclient/util/DefaultHostnameVerifier.java
+++ /dev/null
@@ -1,142 +0,0 @@
-/*
- * To the extent possible under law, Kevin Locke has waived all copyright and
- * related or neighboring rights to this work.
- * <p/>
- * A legal description of this waiver is available in <a href="https://gist.github.com/kevinoid/3829665">LICENSE.txt</a>
- */
-package org.asynchttpclient.util;
-
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSession;
-import javax.security.auth.kerberos.KerberosPrincipal;
-import java.security.Principal;
-import java.security.cert.Certificate;
-import java.security.cert.CertificateException;
-import java.security.cert.X509Certificate;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-/**
- * Uses the internal HostnameChecker to verify the server's hostname matches with the
- * certificate.  This is a requirement for HTTPS, but the raw SSLEngine does not have
- * this functionality.  As such, it has to be added in manually.  For a more complete
- * description of hostname verification and why it's important,
- * please read
- * <a href="http://tersesystems.com/2014/03/23/fixing-hostname-verification/">Fixing
- * Hostname Verification</a>.
- * <p/>
- * This code is based on Kevin Locke's <a href="http://kevinlocke.name/bits/2012/10/03/ssl-certificate-verification-in-dispatch-and-asynchttpclient/">guide</a> .
- * <p/>
- */
-public class DefaultHostnameVerifier implements HostnameVerifier {
-
-    private HostnameChecker checker;
-
-    private HostnameVerifier extraHostnameVerifier;
-
-    // Logger to log exceptions.
-    private static final Logger log = Logger.getLogger(DefaultHostnameVerifier.class.getName());
-
-    /**
-     * A hostname verifier that uses the {{sun.security.util.HostnameChecker}} under the hood.
-     */
-    public DefaultHostnameVerifier() {
-        this.checker = new ProxyHostnameChecker();
-    }
-
-    /**
-     * A hostname verifier that takes an external hostname checker.  Useful for testing.
-     *
-     * @param checker a hostnamechecker.
-     */
-    public DefaultHostnameVerifier(HostnameChecker checker) {
-        this.checker = checker;
-    }
-
-    /**
-     * A hostname verifier that falls back to another hostname verifier if not found.
-     *
-     * @param extraHostnameVerifier another hostname verifier.
-     */
-    public DefaultHostnameVerifier(HostnameVerifier extraHostnameVerifier) {
-        this.checker = new ProxyHostnameChecker();
-        this.extraHostnameVerifier = extraHostnameVerifier;
-    }
-
-    /**
-     * A hostname verifier with a hostname checker, that falls back to another hostname verifier if not found.
-     *
-     * @param checker a custom HostnameChecker.
-     * @param extraHostnameVerifier another hostname verifier.
-     */
-    public DefaultHostnameVerifier(HostnameChecker checker, HostnameVerifier extraHostnameVerifier) {
-        this.checker = checker;
-        this.extraHostnameVerifier = extraHostnameVerifier;
-    }
-
-    /**
-     * Matches the hostname against the peer certificate in the session.
-     *
-     * @param hostname the IP address or hostname of the expected server.
-     * @param session  the SSL session containing the certificates with the ACTUAL hostname/ipaddress.
-     * @return true if the hostname matches, false otherwise.
-     */
-    private boolean hostnameMatches(String hostname, SSLSession session) {
-        log.log(Level.FINE, "hostname = {0}, session = {1}", new Object[] { hostname, Base64.encode(session.getId()) });
-
-        try {
-            final Certificate[] peerCertificates = session.getPeerCertificates();
-            if (peerCertificates.length == 0) {
-                log.log(Level.FINE, "No peer certificates");
-                return false;
-            }
-
-            if (peerCertificates[0] instanceof X509Certificate) {
-                X509Certificate peerCertificate = (X509Certificate) peerCertificates[0];
-                log.log(Level.FINE, "peerCertificate = {0}", peerCertificate);
-                try {
-                    checker.match(hostname, peerCertificate);
-                    // Certificate matches hostname if no exception is thrown.
-                    return true;
-                } catch (CertificateException ex) {
-                    log.log(Level.FINE, "Certificate does not match hostname", ex);
-                }
-            } else {
-                log.log(Level.FINE, "Peer does not have any certificates or they aren't X.509");
-            }
-            return false;
-        } catch (SSLPeerUnverifiedException ex) {
-            log.log(Level.FINE, "Not using certificates for peers, try verifying the principal");
-            try {
-                Principal peerPrincipal = session.getPeerPrincipal();
-                log.log(Level.FINE, "peerPrincipal = {0}", peerPrincipal);
-                if (peerPrincipal instanceof KerberosPrincipal) {
-                    return checker.match(hostname, (KerberosPrincipal) peerPrincipal);
-                } else {
-                    log.log(Level.FINE, "Can't verify principal, not Kerberos");
-                }
-            } catch (SSLPeerUnverifiedException ex2) {
-                // Can't verify principal, no principal
-                log.log(Level.FINE, "Can't verify principal, no principal", ex2);
-            }
-            return false;
-        }
-    }
-
-    /**
-     * Verifies the hostname against the peer certificates in a session.  Falls back to extraHostnameVerifier if
-     * there is no match.
-     *
-     * @param hostname the IP address or hostname of the expected server.
-     * @param session  the SSL session containing the certificates with the ACTUAL hostname/ipaddress.
-     * @return true if the hostname matches, false otherwise.
-     */
-    public boolean verify(String hostname, SSLSession session) {
-        if (hostnameMatches(hostname, session)) {
-            return true;
-        } else {
-            return extraHostnameVerifier != null && extraHostnameVerifier.verify(hostname, session);
-        }
-    }
-}
diff --git a/api/src/main/java/org/asynchttpclient/util/HostnameChecker.java b/api/src/main/java/org/asynchttpclient/util/HostnameChecker.java
deleted file mode 100644
index a25bb467e..000000000
--- a/api/src/main/java/org/asynchttpclient/util/HostnameChecker.java
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Copyright (c) Will Sargent. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.util;
-
-import java.security.Principal;
-import java.security.cert.CertificateException;
-import java.security.cert.X509Certificate;
-
-/**
- * Hostname checker interface.
- */
-public interface HostnameChecker {
-
-    void match(String hostname, X509Certificate peerCertificate) throws CertificateException;
-
-    boolean match(String hostname, Principal principal);
-}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/util/HttpUtils.java b/api/src/main/java/org/asynchttpclient/util/HttpUtils.java
old mode 100755
new mode 100644
similarity index 64%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/util/HttpUtils.java
rename to api/src/main/java/org/asynchttpclient/util/HttpUtils.java
index 78b5a09a3..306a7a9fc
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/util/HttpUtils.java
+++ b/api/src/main/java/org/asynchttpclient/util/HttpUtils.java
@@ -3,41 +3,34 @@
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the Apache License Version 2.0 is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty.util;
-
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
-
-import java.util.List;
+package org.asynchttpclient.util;
 
 import org.asynchttpclient.uri.Uri;
 
 public final class HttpUtils {
 
-    public static final String HTTPS = "https";
     public static final String HTTP = "http";
-    public static final String WEBSOCKET = "ws";
-    public static final String WEBSOCKET_SSL = "wss";
+    public static final String HTTPS = "https";
+    public static final String WS = "ws";
+    public static final String WSS = "wss";
 
     private HttpUtils() {
     }
 
-    public static boolean isNTLM(List<String> auth) {
-        return isNonEmpty(auth) && auth.get(0).startsWith("NTLM");
-    }
-
     public static boolean isWebSocket(String scheme) {
-        return WEBSOCKET.equals(scheme) || WEBSOCKET_SSL.equals(scheme);
+        return WS.equals(scheme) || WSS.equalsIgnoreCase(scheme);
     }
 
     public static boolean isSecure(String scheme) {
-        return HTTPS.equals(scheme) || WEBSOCKET_SSL.equals(scheme);
+        return HTTPS.equals(scheme) || WSS.equals(scheme);
     }
 
     public static boolean isSecure(Uri uri) {
diff --git a/api/src/main/java/org/asynchttpclient/util/MiscUtils.java b/api/src/main/java/org/asynchttpclient/util/MiscUtils.java
index 55b5ba12c..75de53468 100644
--- a/api/src/main/java/org/asynchttpclient/util/MiscUtils.java
+++ b/api/src/main/java/org/asynchttpclient/util/MiscUtils.java
@@ -58,4 +58,10 @@ public static void closeSilently(Closeable closeable) {
             } catch (IOException e) {
             }
     }
+
+    public static IOException buildStaticIOException(String message) {
+        IOException ioe = new IOException(message);
+        ioe.setStackTrace(new StackTraceElement[] {});
+        return ioe;
+    }
 }
diff --git a/api/src/main/java/org/asynchttpclient/util/PrefixIncrementThreadFactory.java b/api/src/main/java/org/asynchttpclient/util/PrefixIncrementThreadFactory.java
new file mode 100644
index 000000000..199bf733f
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/util/PrefixIncrementThreadFactory.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.util;
+
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * Thread factory that generates thread names by adding incrementing number
+ * to the specified prefix.
+ *
+ * @author Stepan Koltsov
+ */
+public class PrefixIncrementThreadFactory implements ThreadFactory {
+    private final String namePrefix;
+    private final AtomicInteger threadNumber = new AtomicInteger();
+
+    public PrefixIncrementThreadFactory(String namePrefix) {
+        if (namePrefix == null || namePrefix.isEmpty()) {
+            throw new IllegalArgumentException("namePrefix must not be empty");
+        }
+        this.namePrefix = namePrefix;
+    }
+
+    public Thread newThread(Runnable r) {
+        return new Thread(r, namePrefix + threadNumber.incrementAndGet());
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/util/ProxyHostnameChecker.java b/api/src/main/java/org/asynchttpclient/util/ProxyHostnameChecker.java
deleted file mode 100644
index 379691129..000000000
--- a/api/src/main/java/org/asynchttpclient/util/ProxyHostnameChecker.java
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * Copyright (c) Will Sargent. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.util;
-
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.security.Principal;
-import java.security.cert.CertificateException;
-import java.security.cert.X509Certificate;
-
-/**
- * A HostnameChecker proxy.
- */
-public class ProxyHostnameChecker implements HostnameChecker {
-
-    public final static byte TYPE_TLS = 1;
-
-    private final Object checker = getHostnameChecker();
-
-    public ProxyHostnameChecker() {
-    }
-
-    private Object getHostnameChecker() {
-        final ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
-        try {
-            @SuppressWarnings("unchecked")
-            final Class<Object> hostnameCheckerClass = (Class<Object>) classLoader.loadClass("sun.security.util.HostnameChecker");
-            final Method instanceMethod = hostnameCheckerClass.getMethod("getInstance", Byte.TYPE);
-            return instanceMethod.invoke(null, TYPE_TLS);
-        } catch (ClassNotFoundException e) {
-            throw new IllegalStateException(e);
-        } catch (NoSuchMethodException e) {
-            throw new IllegalStateException(e);
-        } catch (InvocationTargetException e) {
-            throw new IllegalStateException(e);
-        } catch (IllegalAccessException e) {
-            throw new IllegalStateException(e);
-        }
-    }
-
-    public void match(String hostname, X509Certificate peerCertificate) throws CertificateException {
-        try {
-            final Class<?> hostnameCheckerClass = checker.getClass();
-            final Method checkMethod = hostnameCheckerClass.getMethod("match", String.class, X509Certificate.class);
-            checkMethod.invoke(checker, hostname, peerCertificate);
-        } catch (NoSuchMethodException e) {
-            throw new IllegalStateException(e);
-        } catch (InvocationTargetException e) {
-            Throwable t = e.getCause();
-            if (t instanceof CertificateException) {
-                throw (CertificateException) t;
-            } else {
-                throw new IllegalStateException(e);
-            }
-        } catch (IllegalAccessException e) {
-            throw new IllegalStateException(e);
-        }
-    }
-
-    public boolean match(String hostname, Principal principal) {
-        try {
-            final Class<?> hostnameCheckerClass = checker.getClass();
-            final Method checkMethod = hostnameCheckerClass.getMethod("match", String.class, Principal.class);
-            return (Boolean) checkMethod.invoke(null, hostname, principal);
-        } catch (NoSuchMethodException e) {
-            throw new IllegalStateException(e);
-        } catch (InvocationTargetException e) {
-            throw new IllegalStateException(e);
-        } catch (IllegalAccessException e) {
-            throw new IllegalStateException(e);
-        }
-    }
-
-}
diff --git a/api/src/main/java/org/asynchttpclient/util/ProxyUtils.java b/api/src/main/java/org/asynchttpclient/util/ProxyUtils.java
index af66f040c..221f0317c 100644
--- a/api/src/main/java/org/asynchttpclient/util/ProxyUtils.java
+++ b/api/src/main/java/org/asynchttpclient/util/ProxyUtils.java
@@ -15,10 +15,10 @@
 import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.ProxyServer;
-import org.asynchttpclient.ProxyServer.Protocol;
-import org.asynchttpclient.ProxyServerSelector;
 import org.asynchttpclient.Request;
+import org.asynchttpclient.proxy.ProxyServer;
+import org.asynchttpclient.proxy.ProxyServerSelector;
+import org.asynchttpclient.proxy.ProxyServer.Protocol;
 import org.asynchttpclient.uri.Uri;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
diff --git a/api/src/main/java/org/asynchttpclient/util/SslUtils.java b/api/src/main/java/org/asynchttpclient/util/SslUtils.java
index becb9ed94..5d31125d1 100644
--- a/api/src/main/java/org/asynchttpclient/util/SslUtils.java
+++ b/api/src/main/java/org/asynchttpclient/util/SslUtils.java
@@ -15,16 +15,17 @@
  */
 package org.asynchttpclient.util;
 
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.X509TrustManager;
-
-import java.io.IOException;
 import java.security.GeneralSecurityException;
 import java.security.KeyManagementException;
 import java.security.NoSuchAlgorithmException;
 import java.security.SecureRandom;
 
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.X509TrustManager;
+
+import org.asynchttpclient.AsyncHttpClientConfig;
+
 /**
  * This class is a copy of http://github.com/sonatype/wagon-ning/raw/master/src/main/java/org/apache/maven/wagon/providers/http/SslUtils.java
  */
@@ -65,7 +66,16 @@ public static SslUtils getInstance() {
         return SingletonHolder.instance;
     }
 
-    public SSLContext getSSLContext(boolean acceptAnyCertificate) throws GeneralSecurityException, IOException {
-        return acceptAnyCertificate? looseTrustManagerSSLContext: SSLContext.getDefault();
+    public SSLContext getSSLContext(AsyncHttpClientConfig config) throws GeneralSecurityException {
+        SSLContext sslContext = config.getSSLContext();
+
+        if (sslContext == null) {
+            sslContext = config.isAcceptAnyCertificate() ? looseTrustManagerSSLContext : SSLContext.getDefault();
+            if (config.getSslSessionCacheSize() != null)
+                sslContext.getClientSessionContext().setSessionCacheSize(config.getSslSessionCacheSize());
+            if (config.getSslSessionTimeout() != null)
+                sslContext.getClientSessionContext().setSessionTimeout(config.getSslSessionTimeout());
+        }
+        return sslContext;
     }
 }
diff --git a/api/src/main/java/org/asynchttpclient/util/StandardCharsets.java b/api/src/main/java/org/asynchttpclient/util/StandardCharsets.java
deleted file mode 100644
index 13eb64a40..000000000
--- a/api/src/main/java/org/asynchttpclient/util/StandardCharsets.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package org.asynchttpclient.util;
-
-import java.nio.charset.Charset;
-
-public final class StandardCharsets {
-
-    public static final Charset US_ASCII = Charset.forName("US-ASCII");
-    public static final Charset UTF_8 = Charset.forName("UTF-8");
-    public static final Charset ISO_8859_1 = Charset.forName("ISO-8859-1");
-    public static final Charset UNICODE_LITTLE_UNMARKED = Charset.forName("UnicodeLittleUnmarked");
-
-    private StandardCharsets() {
-    }
-}
diff --git a/api/src/main/java/org/asynchttpclient/util/StringUtils.java b/api/src/main/java/org/asynchttpclient/util/StringUtils.java
new file mode 100644
index 000000000..10234d87a
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/util/StringUtils.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.util;
+
+import java.nio.ByteBuffer;
+import java.nio.CharBuffer;
+import java.nio.charset.Charset;
+
+public final class StringUtils {
+
+    private static final ThreadLocal<StringBuilder> STRING_BUILDERS = new ThreadLocal<StringBuilder>() {
+        protected StringBuilder initialValue() {
+            return new StringBuilder(512);
+        };
+    };
+
+    /**
+     * BEWARE: MUSN'T APPEND TO ITSELF!
+     * @return a pooled StringBuilder
+     */
+    public static StringBuilder stringBuilder() {
+        StringBuilder sb = STRING_BUILDERS.get();
+        sb.setLength(0);
+        return sb;
+    }
+    
+    private StringUtils() {
+        // unused
+    }
+
+    public static ByteBuffer charSequence2ByteBuffer(CharSequence cs, Charset charset) {
+        return charset.encode(CharBuffer.wrap(cs));
+    }
+
+    public static byte[] byteBuffer2ByteArray(ByteBuffer bb) {
+        byte[] rawBase = new byte[bb.remaining()];
+        bb.get(rawBase);
+        return rawBase;
+    }
+
+    public static byte[] charSequence2Bytes(CharSequence sb, Charset charset) {
+        ByteBuffer bb = charSequence2ByteBuffer(sb, charset);
+        return byteBuffer2ByteArray(bb);
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/util/UTF8UrlEncoder.java b/api/src/main/java/org/asynchttpclient/util/UTF8UrlEncoder.java
deleted file mode 100644
index 78cb74d9e..000000000
--- a/api/src/main/java/org/asynchttpclient/util/UTF8UrlEncoder.java
+++ /dev/null
@@ -1,100 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package org.asynchttpclient.util;
-
-/**
- * Convenience class that encapsulates details of "percent encoding"
- * (as per RFC-3986, see [http://www.ietf.org/rfc/rfc3986.txt]).
- */
-public class UTF8UrlEncoder {
-    private static final boolean encodeSpaceUsingPlus = System.getProperty("com.UTF8UrlEncoder.encodeSpaceUsingPlus") != null;
-
-    /**
-     * Encoding table used for figuring out ascii characters that must be escaped
-     * (all non-Ascii characters need to be encoded anyway)
-     */
-    private final static boolean[] SAFE_ASCII = new boolean[128];
-
-    static {
-        for (int i = 'a'; i <= 'z'; ++i) {
-            SAFE_ASCII[i] = true;
-        }
-        for (int i = 'A'; i <= 'Z'; ++i) {
-            SAFE_ASCII[i] = true;
-        }
-        for (int i = '0'; i <= '9'; ++i) {
-            SAFE_ASCII[i] = true;
-        }
-        SAFE_ASCII['-'] = true;
-        SAFE_ASCII['.'] = true;
-        SAFE_ASCII['_'] = true;
-        SAFE_ASCII['~'] = true;
-    }
-
-    private static final char[] HEX = "0123456789ABCDEF".toCharArray();
-
-    private UTF8UrlEncoder() {
-    }
-
-    public static String encode(String input) {
-        StringBuilder sb = new StringBuilder(input.length() + 16);
-        appendEncoded(sb, input);
-        return sb.toString();
-    }
-
-    public static StringBuilder appendEncoded(StringBuilder sb, CharSequence input) {
-        int c;
-        for (int i = 0; i < input.length(); i+= Character.charCount(c)) {
-            c = Character.codePointAt(input, i);
-            if (c <= 127)
-                if (SAFE_ASCII[c])
-                    sb.append((char) c);
-                else
-                    appendSingleByteEncoded(sb, c);
-            else
-                appendMultiByteEncoded(sb, c);
-        }
-        return sb;
-    }
-
-    private final static void appendSingleByteEncoded(StringBuilder sb, int value) {
-
-        if (encodeSpaceUsingPlus && value == 32) {
-            sb.append('+');
-            return;
-        }
-
-        sb.append('%');
-        sb.append(HEX[value >> 4]);
-        sb.append(HEX[value & 0xF]);
-    }
-
-    private final static void appendMultiByteEncoded(StringBuilder sb, int value) {
-        if (value < 0x800) {
-            appendSingleByteEncoded(sb, (0xc0 | (value >> 6)));
-            appendSingleByteEncoded(sb, (0x80 | (value & 0x3f)));
-        } else if (value < 0x10000) {
-            appendSingleByteEncoded(sb, (0xe0 | (value >> 12)));
-            appendSingleByteEncoded(sb, (0x80 | ((value >> 6) & 0x3f)));
-            appendSingleByteEncoded(sb, (0x80 | (value & 0x3f)));
-        } else {
-            appendSingleByteEncoded(sb, (0xf0 | (value >> 18)));
-            appendSingleByteEncoded(sb, (0x80 | (value >> 12) & 0x3f));
-            appendSingleByteEncoded(sb, (0x80 | (value >> 6) & 0x3f));
-            appendSingleByteEncoded(sb, (0x80 | (value & 0x3f)));
-        }
-    }
-}
diff --git a/api/src/main/java/org/asynchttpclient/util/QueryComputer.java b/api/src/main/java/org/asynchttpclient/util/UriEncoder.java
similarity index 53%
rename from api/src/main/java/org/asynchttpclient/util/QueryComputer.java
rename to api/src/main/java/org/asynchttpclient/util/UriEncoder.java
index 1480dd479..42b6a429a 100644
--- a/api/src/main/java/org/asynchttpclient/util/QueryComputer.java
+++ b/api/src/main/java/org/asynchttpclient/util/UriEncoder.java
@@ -12,112 +12,105 @@
  */
 package org.asynchttpclient.util;
 
-import java.util.List;
-
 import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+import static org.asynchttpclient.util.Utf8UrlEncoder.encodeAndAppendQuery;
 
 import org.asynchttpclient.Param;
+import org.asynchttpclient.uri.Uri;
 
-public enum QueryComputer {
+import java.util.List;
 
-    URL_ENCODING_ENABLED_QUERY_COMPUTER {
+public enum UriEncoder {
 
-        private final void encodeAndAppendQueryParam(final StringBuilder sb, final CharSequence name, final CharSequence value) {
-            UTF8UrlEncoder.appendEncoded(sb, name);
+    FIXING {
+
+        public String encodePath(String path) {
+            return Utf8UrlEncoder.encodePath(path);
+        }
+
+        private void encodeAndAppendQueryParam(final StringBuilder sb, final CharSequence name, final CharSequence value) {
+            Utf8UrlEncoder.encodeAndAppendQueryElement(sb, name);
             if (value != null) {
                 sb.append('=');
-                UTF8UrlEncoder.appendEncoded(sb, value);
+                Utf8UrlEncoder.encodeAndAppendQueryElement(sb, value);
             }
             sb.append('&');
         }
 
-        private final void encodeAndAppendQueryParams(final StringBuilder sb, final List<Param> queryParams) {
+        private void encodeAndAppendQueryParams(final StringBuilder sb, final List<Param> queryParams) {
             for (Param param : queryParams)
                 encodeAndAppendQueryParam(sb, param.getName(), param.getValue());
         }
-        
-        // FIXME this could be improved: remove split
-        private final void encodeAndAppendQuery(final StringBuilder sb, final String query) {
-            int pos;
-            for (String queryParamString : query.split("&")) {
-                pos = queryParamString.indexOf('=');
-                if (pos <= 0) {
-                    CharSequence decodedName = UTF8UrlDecoder.decode(queryParamString);
-                    encodeAndAppendQueryParam(sb, decodedName, null);
-                } else {
-                    CharSequence decodedName = UTF8UrlDecoder.decode(queryParamString, 0, pos);
-                    int valueStart = pos + 1;
-                    CharSequence decodedValue = UTF8UrlDecoder.decode(queryParamString, valueStart, queryParamString.length() - valueStart);
-                    encodeAndAppendQueryParam(sb, decodedName, decodedValue);
-                }
-            }
-        }
-        
-        protected final String withQueryWithParams(final String query, final List<Param> queryParams) {
+
+        protected String withQueryWithParams(final String query, final List<Param> queryParams) {
             // concatenate encoded query + encoded query params
-            StringBuilder sb = new StringBuilder(query.length() + queryParams.size() * 16);
+            StringBuilder sb = StringUtils.stringBuilder();
             encodeAndAppendQuery(sb, query);
+            sb.append('&');
             encodeAndAppendQueryParams(sb, queryParams);
             sb.setLength(sb.length() - 1);
             return sb.toString();
         }
 
-        protected final String withQueryWithoutParams(final String query) {
+        protected String withQueryWithoutParams(final String query) {
             // encode query
-            StringBuilder sb = new StringBuilder(query.length() + 6);
+            StringBuilder sb = StringUtils.stringBuilder();
             encodeAndAppendQuery(sb, query);
-            sb.setLength(sb.length() - 1);
             return sb.toString();
         }
 
-        protected final String withoutQueryWithParams(final List<Param> queryParams) {
+        protected String withoutQueryWithParams(final List<Param> queryParams) {
             // concatenate encoded query params
-            StringBuilder sb = new StringBuilder(queryParams.size() * 16);
+            StringBuilder sb = StringUtils.stringBuilder();
             encodeAndAppendQueryParams(sb, queryParams);
             sb.setLength(sb.length() - 1);
             return sb.toString();
         }
     }, //
 
-    URL_ENCODING_DISABLED_QUERY_COMPUTER {
+    RAW {
 
-        private final void appendRawQueryParam(StringBuilder sb, String name, String value) {
+        public String encodePath(String path) {
+            return path;
+        }
+
+        private void appendRawQueryParam(StringBuilder sb, String name, String value) {
             sb.append(name);
             if (value != null)
                 sb.append('=').append(value);
             sb.append('&');
         }
-        
-        private final void appendRawQueryParams(final StringBuilder sb, final List<Param> queryParams) {
+
+        private void appendRawQueryParams(final StringBuilder sb, final List<Param> queryParams) {
             for (Param param : queryParams)
                 appendRawQueryParam(sb, param.getName(), param.getValue());
         }
-        
-        protected final String withQueryWithParams(final String query, final List<Param> queryParams) {
+
+        protected String withQueryWithParams(final String query, final List<Param> queryParams) {
             // concatenate raw query + raw query params
-            StringBuilder sb = new StringBuilder(query.length() + queryParams.size() * 16);
+            StringBuilder sb = StringUtils.stringBuilder();
             sb.append(query);
             appendRawQueryParams(sb, queryParams);
             sb.setLength(sb.length() - 1);
             return sb.toString();
         }
 
-        protected final String withQueryWithoutParams(final String query) {
+        protected String withQueryWithoutParams(final String query) {
             // return raw query as is
             return query;
         }
 
-        protected final String withoutQueryWithParams(final List<Param> queryParams) {
+        protected String withoutQueryWithParams(final List<Param> queryParams) {
             // concatenate raw queryParams
-            StringBuilder sb = new StringBuilder(queryParams.size() * 16);
+            StringBuilder sb = StringUtils.stringBuilder();
             appendRawQueryParams(sb, queryParams);
             sb.setLength(sb.length() - 1);
             return sb.toString();
         }
     };
 
-    public static QueryComputer queryComputer(boolean disableUrlEncoding) {
-        return disableUrlEncoding ? URL_ENCODING_DISABLED_QUERY_COMPUTER : URL_ENCODING_ENABLED_QUERY_COMPUTER;
+    public static UriEncoder uriEncoder(boolean disableUrlEncoding) {
+        return disableUrlEncoding ? RAW : FIXING;
     }
 
     protected abstract String withQueryWithParams(final String query, final List<Param> queryParams);
@@ -134,7 +127,20 @@ private final String withoutQuery(final List<Param> queryParams) {
         return isNonEmpty(queryParams) ? withoutQueryWithParams(queryParams) : null;
     }
 
-    public final String computeFullQueryString(final String query, final List<Param> queryParams) {
+    public Uri encode(Uri uri, List<Param> queryParams) {
+        String newPath = encodePath(uri.getPath());
+        String newQuery = encodeQuery(uri.getQuery(), queryParams);
+        return new Uri(uri.getScheme(),//
+                uri.getUserInfo(),//
+                uri.getHost(),//
+                uri.getPort(),//
+                newPath,//
+                newQuery);
+    }
+
+    protected abstract String encodePath(String path);
+
+    private final String encodeQuery(final String query, final List<Param> queryParams) {
         return isNonEmpty(query) ? withQuery(query, queryParams) : withoutQuery(queryParams);
     }
 }
diff --git a/api/src/main/java/org/asynchttpclient/util/UTF8UrlDecoder.java b/api/src/main/java/org/asynchttpclient/util/Utf8UrlDecoder.java
similarity index 97%
rename from api/src/main/java/org/asynchttpclient/util/UTF8UrlDecoder.java
rename to api/src/main/java/org/asynchttpclient/util/Utf8UrlDecoder.java
index 7184aea11..6a4c04cfc 100644
--- a/api/src/main/java/org/asynchttpclient/util/UTF8UrlDecoder.java
+++ b/api/src/main/java/org/asynchttpclient/util/Utf8UrlDecoder.java
@@ -12,9 +12,9 @@
  */
 package org.asynchttpclient.util;
 
-public final class UTF8UrlDecoder {
+public final class Utf8UrlDecoder {
 
-    private UTF8UrlDecoder() {
+    private Utf8UrlDecoder() {
     }
 
     private static StringBuilder initSb(StringBuilder sb, String s, int i, int offset, int length) {
diff --git a/api/src/main/java/org/asynchttpclient/util/Utf8UrlEncoder.java b/api/src/main/java/org/asynchttpclient/util/Utf8UrlEncoder.java
new file mode 100644
index 000000000..a1e0e6b85
--- /dev/null
+++ b/api/src/main/java/org/asynchttpclient/util/Utf8UrlEncoder.java
@@ -0,0 +1,179 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package org.asynchttpclient.util;
+
+import java.util.BitSet;
+
+/**
+ * Convenience class that encapsulates details of "percent encoding"
+ * (as per RFC-3986, see [http://www.ietf.org/rfc/rfc3986.txt]).
+ */
+public final class Utf8UrlEncoder {
+
+    /**
+     * Encoding table used for figuring out ascii characters that must be escaped
+     * (all non-Ascii characters need to be encoded anyway)
+     */
+    public final static BitSet RFC3986_UNRESERVED_CHARS = new BitSet(256);
+    public final static BitSet RFC3986_RESERVED_CHARS = new BitSet(256);
+    public final static BitSet RFC3986_SUBDELIM_CHARS = new BitSet(256);
+    public final static BitSet RFC3986_PCHARS = new BitSet(256);
+    public final static BitSet BUILT_PATH_UNTOUCHED_CHARS = new BitSet(256);
+    public final static BitSet BUILT_QUERY_UNTOUCHED_CHARS = new BitSet(256);
+    // http://www.w3.org/TR/html5/forms.html#application/x-www-form-urlencoded-encoding-algorithm
+    public final static BitSet FORM_URL_ENCODED_SAFE_CHARS = new BitSet(256);
+
+    static {
+        for (int i = 'a'; i <= 'z'; ++i) {
+            RFC3986_UNRESERVED_CHARS.set(i);
+            FORM_URL_ENCODED_SAFE_CHARS.set(i);
+        }
+        for (int i = 'A'; i <= 'Z'; ++i) {
+            RFC3986_UNRESERVED_CHARS.set(i);
+            FORM_URL_ENCODED_SAFE_CHARS.set(i);
+        }
+        for (int i = '0'; i <= '9'; ++i) {
+            RFC3986_UNRESERVED_CHARS.set(i);
+            FORM_URL_ENCODED_SAFE_CHARS.set(i);
+        }
+        RFC3986_UNRESERVED_CHARS.set('-');
+        RFC3986_UNRESERVED_CHARS.set('.');
+        RFC3986_UNRESERVED_CHARS.set('_');
+        RFC3986_UNRESERVED_CHARS.set('~');
+
+        RFC3986_SUBDELIM_CHARS.set('!');
+        RFC3986_SUBDELIM_CHARS.set('$');
+        RFC3986_SUBDELIM_CHARS.set('&');
+        RFC3986_SUBDELIM_CHARS.set('\'');
+        RFC3986_SUBDELIM_CHARS.set('(');
+        RFC3986_SUBDELIM_CHARS.set(')');
+        RFC3986_SUBDELIM_CHARS.set('*');
+        RFC3986_SUBDELIM_CHARS.set('+');
+        RFC3986_SUBDELIM_CHARS.set(',');
+        RFC3986_SUBDELIM_CHARS.set(';');
+        RFC3986_SUBDELIM_CHARS.set('=');
+        
+        FORM_URL_ENCODED_SAFE_CHARS.set('-');
+        FORM_URL_ENCODED_SAFE_CHARS.set('.');
+        FORM_URL_ENCODED_SAFE_CHARS.set('_');
+        FORM_URL_ENCODED_SAFE_CHARS.set('*');
+
+        RFC3986_RESERVED_CHARS.set('!');
+        RFC3986_RESERVED_CHARS.set('*');
+        RFC3986_RESERVED_CHARS.set('\'');
+        RFC3986_RESERVED_CHARS.set('(');
+        RFC3986_RESERVED_CHARS.set(')');
+        RFC3986_RESERVED_CHARS.set(';');
+        RFC3986_RESERVED_CHARS.set(':');
+        RFC3986_RESERVED_CHARS.set('@');
+        RFC3986_RESERVED_CHARS.set('&');
+        RFC3986_RESERVED_CHARS.set('=');
+        RFC3986_RESERVED_CHARS.set('+');
+        RFC3986_RESERVED_CHARS.set('$');
+        RFC3986_RESERVED_CHARS.set(',');
+        RFC3986_RESERVED_CHARS.set('/');
+        RFC3986_RESERVED_CHARS.set('?');
+        RFC3986_RESERVED_CHARS.set('#');
+        RFC3986_RESERVED_CHARS.set('[');
+        RFC3986_RESERVED_CHARS.set(']');
+
+        RFC3986_PCHARS.or(RFC3986_UNRESERVED_CHARS);
+        RFC3986_PCHARS.or(RFC3986_SUBDELIM_CHARS);
+        RFC3986_PCHARS.set(':');
+        RFC3986_PCHARS.set('@');
+
+        BUILT_PATH_UNTOUCHED_CHARS.or(RFC3986_PCHARS);
+        BUILT_PATH_UNTOUCHED_CHARS.set('%');
+        BUILT_PATH_UNTOUCHED_CHARS.set('/');
+
+        BUILT_QUERY_UNTOUCHED_CHARS.or(RFC3986_PCHARS);
+        BUILT_QUERY_UNTOUCHED_CHARS.set('%');
+        BUILT_QUERY_UNTOUCHED_CHARS.set('/');
+        BUILT_QUERY_UNTOUCHED_CHARS.set('?');
+    }
+
+    private static final char[] HEX = "0123456789ABCDEF".toCharArray();
+
+    private Utf8UrlEncoder() {
+    }
+
+    public static String encodePath(String input) {
+        StringBuilder sb = new StringBuilder(input.length() + 6);
+        appendEncoded(sb, input, BUILT_PATH_UNTOUCHED_CHARS, false);
+        return sb.toString();
+    }
+    
+    public static StringBuilder encodeAndAppendQuery(StringBuilder sb, String query) {
+        return appendEncoded(sb, query, BUILT_QUERY_UNTOUCHED_CHARS, false);
+    }
+
+    public static String encodeQueryElement(String input) {
+        StringBuilder sb = new StringBuilder(input.length() + 6);
+        encodeAndAppendQueryElement(sb, input);
+        return sb.toString();
+    }
+
+    public static StringBuilder encodeAndAppendQueryElement(StringBuilder sb, CharSequence input) {
+        return appendEncoded(sb, input, RFC3986_UNRESERVED_CHARS, false);
+    }
+
+    public static StringBuilder encodeAndAppendFormElement(StringBuilder sb, CharSequence input) {
+        return appendEncoded(sb, input, FORM_URL_ENCODED_SAFE_CHARS, true);
+    }
+
+    private static StringBuilder appendEncoded(StringBuilder sb, CharSequence input, BitSet dontNeedEncoding, boolean encodeSpaceAsPlus) {
+        int c;
+        for (int i = 0; i < input.length(); i+= Character.charCount(c)) {
+            c = Character.codePointAt(input, i);
+            if (c <= 127)
+                if (dontNeedEncoding.get(c))
+                    sb.append((char) c);
+                else
+                    appendSingleByteEncoded(sb, c, encodeSpaceAsPlus);
+            else
+                appendMultiByteEncoded(sb, c);
+        }
+        return sb;
+    }
+
+    private final static void appendSingleByteEncoded(StringBuilder sb, int value, boolean encodeSpaceAsPlus) {
+
+        if (value == ' ' && encodeSpaceAsPlus) {
+            sb.append('+');
+            return;
+        }
+
+        sb.append('%');
+        sb.append(HEX[value >> 4]);
+        sb.append(HEX[value & 0xF]);
+    }
+
+    private final static void appendMultiByteEncoded(StringBuilder sb, int value) {
+        if (value < 0x800) {
+            appendSingleByteEncoded(sb, (0xc0 | (value >> 6)), false);
+            appendSingleByteEncoded(sb, (0x80 | (value & 0x3f)), false);
+        } else if (value < 0x10000) {
+            appendSingleByteEncoded(sb, (0xe0 | (value >> 12)), false);
+            appendSingleByteEncoded(sb, (0x80 | ((value >> 6) & 0x3f)), false);
+            appendSingleByteEncoded(sb, (0x80 | (value & 0x3f)), false);
+        } else {
+            appendSingleByteEncoded(sb, (0xf0 | (value >> 18)), false);
+            appendSingleByteEncoded(sb, (0x80 | (value >> 12) & 0x3f), false);
+            appendSingleByteEncoded(sb, (0x80 | (value >> 6) & 0x3f), false);
+            appendSingleByteEncoded(sb, (0x80 | (value & 0x3f)), false);
+        }
+    }
+}
diff --git a/api/src/main/java/org/asynchttpclient/webdav/WebDavCompletionHandlerBase.java b/api/src/main/java/org/asynchttpclient/webdav/WebDavCompletionHandlerBase.java
index f28986f7c..ca11a3e59 100644
--- a/api/src/main/java/org/asynchttpclient/webdav/WebDavCompletionHandlerBase.java
+++ b/api/src/main/java/org/asynchttpclient/webdav/WebDavCompletionHandlerBase.java
@@ -15,7 +15,9 @@
 
 import java.io.IOException;
 import java.io.InputStream;
+import java.net.SocketAddress;
 import java.nio.ByteBuffer;
+import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -56,27 +58,27 @@
      * {@inheritDoc}
      */
     @Override
-    public final STATE onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
+    public final State onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
         bodies.add(content);
-        return STATE.CONTINUE;
+        return State.CONTINUE;
     }
 
     /**
      * {@inheritDoc}
      */
     @Override
-    public final STATE onStatusReceived(final HttpResponseStatus status) throws Exception {
+    public final State onStatusReceived(final HttpResponseStatus status) throws Exception {
         this.status = status;
-        return STATE.CONTINUE;
+        return State.CONTINUE;
     }
 
     /**
      * {@inheritDoc}
      */
     @Override
-    public final STATE onHeadersReceived(final HttpResponseHeaders headers) throws Exception {
+    public final State onHeadersReceived(final HttpResponseHeaders headers) throws Exception {
         this.headers = headers;
-        return STATE.CONTINUE;
+        return State.CONTINUE;
     }
 
     /**
@@ -159,20 +161,10 @@ public InputStream getResponseBodyAsStream() throws IOException {
                 }
 
                 @Override
-                public String getResponseBodyExcerpt(int maxLength, String charset) throws IOException {
-                    return wrappedResponse.getResponseBodyExcerpt(maxLength, charset);
-                }
-
-                @Override
-                public String getResponseBody(String charset) throws IOException {
+                public String getResponseBody(Charset charset) throws IOException {
                     return wrappedResponse.getResponseBody(charset);
                 }
 
-                @Override
-                public String getResponseBodyExcerpt(int maxLength) throws IOException {
-                    return wrappedResponse.getResponseBodyExcerpt(maxLength);
-                }
-
                 @Override
                 public String getResponseBody() throws IOException {
                     return wrappedResponse.getResponseBody();
@@ -227,6 +219,16 @@ public boolean hasResponseHeaders() {
                 public boolean hasResponseBody() {
                     return wrappedResponse.hasResponseBody();
                 }
+
+                @Override
+                public SocketAddress getRemoteAddress() {
+                    return wrappedResponse.getRemoteAddress();
+                }
+
+                @Override
+                public SocketAddress getLocalAddress() {
+                    return wrappedResponse.getLocalAddress();
+                }
             };
         }
 
@@ -259,6 +261,16 @@ public int getProtocolMinorVersion() {
         public String getProtocolText() {
             return wrapped.getStatusText();
         }
+
+        @Override
+        public SocketAddress getRemoteAddress() {
+            return wrapped.getRemoteAddress();
+        }
+        
+        @Override
+        public SocketAddress getLocalAddress() {
+            return wrapped.getLocalAddress();
+        }
     }
 
     private Document readXMLResponse(InputStream stream) {
diff --git a/api/src/main/java/org/asynchttpclient/webdav/WebDavResponse.java b/api/src/main/java/org/asynchttpclient/webdav/WebDavResponse.java
index 5f89a62cc..b34ee1eed 100644
--- a/api/src/main/java/org/asynchttpclient/webdav/WebDavResponse.java
+++ b/api/src/main/java/org/asynchttpclient/webdav/WebDavResponse.java
@@ -14,7 +14,9 @@
 
 import java.io.IOException;
 import java.io.InputStream;
+import java.net.SocketAddress;
 import java.nio.ByteBuffer;
+import java.nio.charset.Charset;
 import java.util.List;
 
 import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
@@ -57,19 +59,11 @@ public InputStream getResponseBodyAsStream() throws IOException {
         return response.getResponseBodyAsStream();
     }
 
-    public String getResponseBodyExcerpt(int maxLength) throws IOException {
-        return response.getResponseBodyExcerpt(maxLength);
-    }
-
-    public String getResponseBodyExcerpt(int maxLength, String charset) throws IOException {
-        return response.getResponseBodyExcerpt(maxLength, charset);
-    }
-
     public String getResponseBody() throws IOException {
         return response.getResponseBody();
     }
 
-    public String getResponseBody(String charset) throws IOException {
+    public String getResponseBody(Charset charset) throws IOException {
         return response.getResponseBody(charset);
     }
 
@@ -113,6 +107,14 @@ public boolean hasResponseBody() {
         return response.hasResponseBody();
     }
 
+    public SocketAddress getRemoteAddress() {
+        return response.getRemoteAddress();
+    }
+
+    public SocketAddress getLocalAddress() {
+        return response.getLocalAddress();
+    }
+
     public Document getBodyAsXML() {
         return document;
     }
diff --git a/api/src/main/java/org/asynchttpclient/websocket/DefaultWebSocketListener.java b/api/src/main/java/org/asynchttpclient/ws/DefaultWebSocketListener.java
similarity index 98%
rename from api/src/main/java/org/asynchttpclient/websocket/DefaultWebSocketListener.java
rename to api/src/main/java/org/asynchttpclient/ws/DefaultWebSocketListener.java
index 7e465acff..f95dcdbf6 100644
--- a/api/src/main/java/org/asynchttpclient/websocket/DefaultWebSocketListener.java
+++ b/api/src/main/java/org/asynchttpclient/ws/DefaultWebSocketListener.java
@@ -11,7 +11,7 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package org.asynchttpclient.websocket;
+package org.asynchttpclient.ws;
 
 /**
  * Default WebSocketListener implementation.  Most methods are no-ops.  This 
diff --git a/api/src/main/java/org/asynchttpclient/UpgradeHandler.java b/api/src/main/java/org/asynchttpclient/ws/UpgradeHandler.java
similarity index 85%
rename from api/src/main/java/org/asynchttpclient/UpgradeHandler.java
rename to api/src/main/java/org/asynchttpclient/ws/UpgradeHandler.java
index e541e6745..288e5ecf0 100644
--- a/api/src/main/java/org/asynchttpclient/UpgradeHandler.java
+++ b/api/src/main/java/org/asynchttpclient/ws/UpgradeHandler.java
@@ -10,10 +10,13 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient;
+package org.asynchttpclient.ws;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpProvider;
 
 /**
- * Invoked when an {@link AsyncHandler.STATE#UPGRADE} is returned. Currently the library only support {@link org.asynchttpclient.websocket.WebSocket}
+ * Invoked when an {@link AsyncHandler.State#UPGRADE} is returned. Currently the library only support {@link org.asynchttpclient.ws.WebSocket}
  * as type.
  *
  * @param <T>
diff --git a/api/src/main/java/org/asynchttpclient/websocket/WebSocket.java b/api/src/main/java/org/asynchttpclient/ws/WebSocket.java
similarity index 72%
rename from api/src/main/java/org/asynchttpclient/websocket/WebSocket.java
rename to api/src/main/java/org/asynchttpclient/ws/WebSocket.java
index 321cffaf3..b8513dfc0 100644
--- a/api/src/main/java/org/asynchttpclient/websocket/WebSocket.java
+++ b/api/src/main/java/org/asynchttpclient/ws/WebSocket.java
@@ -10,17 +10,35 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.websocket;
+package org.asynchttpclient.ws;
 
 import java.io.Closeable;
+import java.net.SocketAddress;
 
 /**
  * A Websocket client
  */
 public interface WebSocket extends Closeable {
 
+    /**
+     * Get remote address client initiated request to.
+     * 
+     * @return remote address client initiated request to, may be {@code null}
+     *         if asynchronous provider is unable to provide the remote address
+     */
+    SocketAddress getRemoteAddress();
+
+    /**
+     * Get local address client initiated request from.
+     * 
+     * @return local address client initiated request from, may be {@code null}
+     *         if asynchronous provider is unable to provide the local address
+     */
+    SocketAddress getLocalAddress();
+
     /**
      * Send a byte message.
+     * 
      * @param message a byte message
      * @return this
      */
@@ -30,25 +48,26 @@
      * Allows streaming of multiple binary fragments.
      * 
      * @param fragment binary fragment.
-     * @param last     flag indicating whether or not this is the last fragment.
-     *             
+     * @param last flag indicating whether or not this is the last fragment.
+     * 
      * @return this.
      */
     WebSocket stream(byte[] fragment, boolean last);
 
     /**
      * Allows streaming of multiple binary fragments.
-     *
+     * 
      * @param fragment binary fragment.
-     * @param offset   starting offset.
-     * @param len      length.
-     * @param last     flag indicating whether or not this is the last fragment.
+     * @param offset starting offset.
+     * @param len length.
+     * @param last flag indicating whether or not this is the last fragment.
      * @return this.
      */
     WebSocket stream(byte[] fragment, int offset, int len, boolean last);
 
     /**
      * Send a text message
+     * 
      * @param message a text message
      * @return this.
      */
@@ -56,9 +75,9 @@
 
     /**
      * Allows streaming of multiple text fragments.
-     *
+     * 
      * @param fragment text fragment.
-     * @param last     flag indicating whether or not this is the last fragment.
+     * @param last flag indicating whether or not this is the last fragment.
      * @return this.
      */
     WebSocket stream(String fragment, boolean last);
@@ -66,9 +85,9 @@
     /**
      * Send a <code>ping</ping> with an optional payload
      * (limited to 125 bytes or less).
-     *
+     * 
      * @param payload the ping payload.
-     *
+     * 
      * @return this.
      */
     WebSocket sendPing(byte[] payload);
@@ -76,7 +95,7 @@
     /**
      * Send a <code>ping</ping> with an optional payload
      * (limited to 125 bytes or less).
-     *
+     * 
      * @param payload the pong payload.
      * @return this.
      */
@@ -84,6 +103,7 @@
 
     /**
      * Add a {@link WebSocketListener}
+     * 
      * @param l a {@link WebSocketListener}
      * @return this
      */
@@ -91,6 +111,7 @@
 
     /**
      * Add a {@link WebSocketListener}
+     * 
      * @param l a {@link WebSocketListener}
      * @return this
      */
@@ -98,7 +119,7 @@
 
     /**
      * Returns <code>true</code> if the WebSocket is open/connected.
-     *
+     * 
      * @return <code>true</code> if the WebSocket is open/connected.
      */
     boolean isOpen();
@@ -108,4 +129,3 @@
      */
     void close();
 }
-
diff --git a/api/src/main/java/org/asynchttpclient/websocket/WebSocketByteFragmentListener.java b/api/src/main/java/org/asynchttpclient/ws/WebSocketByteFragmentListener.java
similarity index 96%
rename from api/src/main/java/org/asynchttpclient/websocket/WebSocketByteFragmentListener.java
rename to api/src/main/java/org/asynchttpclient/ws/WebSocketByteFragmentListener.java
index 9988115b2..2b751c52f 100644
--- a/api/src/main/java/org/asynchttpclient/websocket/WebSocketByteFragmentListener.java
+++ b/api/src/main/java/org/asynchttpclient/ws/WebSocketByteFragmentListener.java
@@ -11,7 +11,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.websocket;
+package org.asynchttpclient.ws;
 
 import org.asynchttpclient.HttpResponseBodyPart;
 
diff --git a/api/src/main/java/org/asynchttpclient/websocket/WebSocketByteListener.java b/api/src/main/java/org/asynchttpclient/ws/WebSocketByteListener.java
similarity index 96%
rename from api/src/main/java/org/asynchttpclient/websocket/WebSocketByteListener.java
rename to api/src/main/java/org/asynchttpclient/ws/WebSocketByteListener.java
index 99fb4cede..bbe47bce1 100644
--- a/api/src/main/java/org/asynchttpclient/websocket/WebSocketByteListener.java
+++ b/api/src/main/java/org/asynchttpclient/ws/WebSocketByteListener.java
@@ -10,7 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.websocket;
+package org.asynchttpclient.ws;
 
 /**
  * A {@link WebSocketListener} for bytes
diff --git a/api/src/main/java/org/asynchttpclient/websocket/WebSocketCloseCodeReasonListener.java b/api/src/main/java/org/asynchttpclient/ws/WebSocketCloseCodeReasonListener.java
similarity index 96%
rename from api/src/main/java/org/asynchttpclient/websocket/WebSocketCloseCodeReasonListener.java
rename to api/src/main/java/org/asynchttpclient/ws/WebSocketCloseCodeReasonListener.java
index ad1b25f0b..97821779f 100644
--- a/api/src/main/java/org/asynchttpclient/websocket/WebSocketCloseCodeReasonListener.java
+++ b/api/src/main/java/org/asynchttpclient/ws/WebSocketCloseCodeReasonListener.java
@@ -10,7 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.websocket;
+package org.asynchttpclient.ws;
 
 /**
  * Extend the normal close listener with one that support the WebSocket's code and reason.
diff --git a/api/src/main/java/org/asynchttpclient/websocket/WebSocketListener.java b/api/src/main/java/org/asynchttpclient/ws/WebSocketListener.java
similarity index 97%
rename from api/src/main/java/org/asynchttpclient/websocket/WebSocketListener.java
rename to api/src/main/java/org/asynchttpclient/ws/WebSocketListener.java
index 6c8b7fbc2..3816df8d8 100644
--- a/api/src/main/java/org/asynchttpclient/websocket/WebSocketListener.java
+++ b/api/src/main/java/org/asynchttpclient/ws/WebSocketListener.java
@@ -10,7 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.websocket;
+package org.asynchttpclient.ws;
 
 /**
  * A generic {@link WebSocketListener} for WebSocket events. Use the appropriate listener for receiving message bytes.
diff --git a/api/src/main/java/org/asynchttpclient/websocket/WebSocketPingListener.java b/api/src/main/java/org/asynchttpclient/ws/WebSocketPingListener.java
similarity index 96%
rename from api/src/main/java/org/asynchttpclient/websocket/WebSocketPingListener.java
rename to api/src/main/java/org/asynchttpclient/ws/WebSocketPingListener.java
index 0567c90c2..24cb8d6c9 100644
--- a/api/src/main/java/org/asynchttpclient/websocket/WebSocketPingListener.java
+++ b/api/src/main/java/org/asynchttpclient/ws/WebSocketPingListener.java
@@ -10,7 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.websocket;
+package org.asynchttpclient.ws;
 
 /**
  * A WebSocket's Ping Listener
diff --git a/api/src/main/java/org/asynchttpclient/websocket/WebSocketPongListener.java b/api/src/main/java/org/asynchttpclient/ws/WebSocketPongListener.java
similarity index 96%
rename from api/src/main/java/org/asynchttpclient/websocket/WebSocketPongListener.java
rename to api/src/main/java/org/asynchttpclient/ws/WebSocketPongListener.java
index a27e93bfd..74a8d9f90 100644
--- a/api/src/main/java/org/asynchttpclient/websocket/WebSocketPongListener.java
+++ b/api/src/main/java/org/asynchttpclient/ws/WebSocketPongListener.java
@@ -10,7 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.websocket;
+package org.asynchttpclient.ws;
 
 /**
  * A WebSocket's Pong Listener
diff --git a/api/src/main/java/org/asynchttpclient/websocket/WebSocketTextFragmentListener.java b/api/src/main/java/org/asynchttpclient/ws/WebSocketTextFragmentListener.java
similarity index 96%
rename from api/src/main/java/org/asynchttpclient/websocket/WebSocketTextFragmentListener.java
rename to api/src/main/java/org/asynchttpclient/ws/WebSocketTextFragmentListener.java
index a71f9364b..6f0f33ee4 100644
--- a/api/src/main/java/org/asynchttpclient/websocket/WebSocketTextFragmentListener.java
+++ b/api/src/main/java/org/asynchttpclient/ws/WebSocketTextFragmentListener.java
@@ -11,7 +11,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.websocket;
+package org.asynchttpclient.ws;
 
 import org.asynchttpclient.HttpResponseBodyPart;
 
diff --git a/api/src/main/java/org/asynchttpclient/websocket/WebSocketTextListener.java b/api/src/main/java/org/asynchttpclient/ws/WebSocketTextListener.java
similarity index 96%
rename from api/src/main/java/org/asynchttpclient/websocket/WebSocketTextListener.java
rename to api/src/main/java/org/asynchttpclient/ws/WebSocketTextListener.java
index 7f8242c74..7ba81c25d 100644
--- a/api/src/main/java/org/asynchttpclient/websocket/WebSocketTextListener.java
+++ b/api/src/main/java/org/asynchttpclient/ws/WebSocketTextListener.java
@@ -10,7 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.websocket;
+package org.asynchttpclient.ws;
 
 /**
  * A {@link WebSocketListener} for text message
diff --git a/api/src/main/java/org/asynchttpclient/websocket/WebSocketUpgradeHandler.java b/api/src/main/java/org/asynchttpclient/ws/WebSocketUpgradeHandler.java
similarity index 90%
rename from api/src/main/java/org/asynchttpclient/websocket/WebSocketUpgradeHandler.java
rename to api/src/main/java/org/asynchttpclient/ws/WebSocketUpgradeHandler.java
index b612c9b0a..06af655e1 100644
--- a/api/src/main/java/org/asynchttpclient/websocket/WebSocketUpgradeHandler.java
+++ b/api/src/main/java/org/asynchttpclient/ws/WebSocketUpgradeHandler.java
@@ -10,7 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.websocket;
+package org.asynchttpclient.ws;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -20,7 +20,6 @@
 import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.HttpResponseHeaders;
 import org.asynchttpclient.HttpResponseStatus;
-import org.asynchttpclient.UpgradeHandler;
 
 /**
  * An {@link AsyncHandler} which is able to execute WebSocket upgrade. Use the Builder for configuring WebSocket options.
@@ -55,20 +54,20 @@ public boolean touchSuccess() {
      * {@inheritDoc}
      */
     @Override
-    public final STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-        return STATE.CONTINUE;
+    public final State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+        return State.CONTINUE;
     }
 
     /**
      * {@inheritDoc}
      */
     @Override
-    public final STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+    public final State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
         status = responseStatus.getStatusCode();
         if (responseStatus.getStatusCode() == 101) {
-            return STATE.UPGRADE;
+            return State.UPGRADE;
         } else {
-            return STATE.ABORT;
+            return State.ABORT;
         }
     }
 
@@ -76,8 +75,8 @@ public final STATE onStatusReceived(HttpResponseStatus responseStatus) throws Ex
      * {@inheritDoc}
      */
     @Override
-    public final STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
-        return STATE.CONTINUE;
+    public final State onHeadersReceived(HttpResponseHeaders headers) throws Exception {
+        return State.CONTINUE;
     }
 
     /**
@@ -91,11 +90,11 @@ public final WebSocket onCompleted() throws Exception {
             for (WebSocketListener listener : listeners) {
                 listener.onError(e);
             }
-            return null;
+            throw e;
         }
 
         if (webSocket == null) {
-            throw new IllegalStateException("WebSocket is null");
+            throw new NullPointerException("webSocket");
         }
         return webSocket;
     }
@@ -147,7 +146,7 @@ public final void onClose(WebSocket webSocket, int status, String reasonPhrase)
      */
     public final static class Builder {
 
-        private List<WebSocketListener> listeners = new ArrayList<WebSocketListener>();
+        private List<WebSocketListener> listeners = new ArrayList<>();
 
         /**
          * Add a {@link WebSocketListener} that will be added to the {@link WebSocket}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/ws/WebSocketUtils.java b/api/src/main/java/org/asynchttpclient/ws/WebSocketUtils.java
old mode 100755
new mode 100644
similarity index 93%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/ws/WebSocketUtils.java
rename to api/src/main/java/org/asynchttpclient/ws/WebSocketUtils.java
index c308edaea..ee8b96882
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/ws/WebSocketUtils.java
+++ b/api/src/main/java/org/asynchttpclient/ws/WebSocketUtils.java
@@ -11,17 +11,15 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty.ws;
-
-import org.asynchttpclient.util.Base64;
-import org.asynchttpclient.util.StandardCharsets;
+package org.asynchttpclient.ws;
 
 import java.io.UnsupportedEncodingException;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 
-public final class WebSocketUtils {
+import org.asynchttpclient.util.Base64;
 
+public final class WebSocketUtils {
     public static final String MAGIC_GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
 
     public static String getKey() {
@@ -31,7 +29,7 @@ public static String getKey() {
 
     public static String getAcceptKey(String key) throws UnsupportedEncodingException {
         String acceptSeed = key + MAGIC_GUID;
-        byte[] sha1 = sha1(acceptSeed.getBytes(StandardCharsets.US_ASCII));
+        byte[] sha1 = sha1(acceptSeed.getBytes("US-ASCII"));
         return base64Encode(sha1);
     }
 
@@ -70,4 +68,6 @@ public static String base64Encode(byte[] bytes) {
     public static int createRandomNumber(int min, int max) {
         return (int) (Math.random() * max + min);
     }
+
 }
+
diff --git a/api/src/main/resources/ahc-default.properties b/api/src/main/resources/ahc-default.properties
index 9ea9756cf..122eff830 100644
--- a/api/src/main/resources/ahc-default.properties
+++ b/api/src/main/resources/ahc-default.properties
@@ -1,27 +1,34 @@
-org.asynchttpclient.AsyncHttpClientConfig.maxConnections=-1
-org.asynchttpclient.AsyncHttpClientConfig.maxConnectionsPerHost=-1
-org.asynchttpclient.AsyncHttpClientConfig.connectionTimeout=60000
-org.asynchttpclient.AsyncHttpClientConfig.pooledConnectionIdleTimeout=60000
-org.asynchttpclient.AsyncHttpClientConfig.readTimeout=60000
-org.asynchttpclient.AsyncHttpClientConfig.requestTimeout=60000
-org.asynchttpclient.AsyncHttpClientConfig.webSocketTimeout=900000
-org.asynchttpclient.AsyncHttpClientConfig.connectionTTL=-1
-org.asynchttpclient.AsyncHttpClientConfig.followRedirect=false
-org.asynchttpclient.AsyncHttpClientConfig.maxRedirects=5
-org.asynchttpclient.AsyncHttpClientConfig.compressionEnforced=false
-org.asynchttpclient.AsyncHttpClientConfig.userAgent=NING/1.0
-org.asynchttpclient.AsyncHttpClientConfig.ioThreadMultiplier=2
-org.asynchttpclient.AsyncHttpClientConfig.useProxySelector=false
-org.asynchttpclient.AsyncHttpClientConfig.useProxyProperties=false
-org.asynchttpclient.AsyncHttpClientConfig.strict302Handling=false
-org.asynchttpclient.AsyncHttpClientConfig.allowPoolingConnections=true
-org.asynchttpclient.AsyncHttpClientConfig.useRelativeURIsWithConnectProxies=true
-org.asynchttpclient.AsyncHttpClientConfig.requestCompressionLevel=-1
-org.asynchttpclient.AsyncHttpClientConfig.maxRequestRetry=5
-org.asynchttpclient.AsyncHttpClientConfig.allowPoolingSslConnections=true
-org.asynchttpclient.AsyncHttpClientConfig.disableUrlEncodingForBoundRequests=false
-org.asynchttpclient.AsyncHttpClientConfig.removeQueryParamOnRedirect=true
-org.asynchttpclient.AsyncHttpClientConfig.spdyEnabled=false
-org.asynchttpclient.AsyncHttpClientConfig.spdyInitialWindowSize=10485760
-org.asynchttpclient.AsyncHttpClientConfig.spdyMaxConcurrentStreams=100
-org.asynchttpclient.AsyncHttpClientConfig.acceptAnyCertificate=false
\ No newline at end of file
+org.asynchttpclient.name=AsyncHttpClient
+org.asynchttpclient.maxConnections=-1
+org.asynchttpclient.maxConnectionsPerHost=-1
+org.asynchttpclient.connectTimeout=5000
+org.asynchttpclient.pooledConnectionIdleTimeout=60000
+org.asynchttpclient.readTimeout=60000
+org.asynchttpclient.requestTimeout=60000
+org.asynchttpclient.webSocketTimeout=900000
+org.asynchttpclient.connectionTTL=-1
+org.asynchttpclient.followRedirect=false
+org.asynchttpclient.maxRedirects=5
+org.asynchttpclient.compressionEnforced=false
+org.asynchttpclient.userAgent=NING/1.0
+org.asynchttpclient.ioThreadMultiplier=2
+org.asynchttpclient.enabledProtocols=TLSv1.2, TLSv1.1, TLSv1
+org.asynchttpclient.useProxySelector=false
+org.asynchttpclient.useProxyProperties=false
+org.asynchttpclient.strict302Handling=false
+org.asynchttpclient.allowPoolingConnections=true
+org.asynchttpclient.requestCompressionLevel=-1
+org.asynchttpclient.maxRequestRetry=5
+org.asynchttpclient.allowPoolingSslConnections=true
+org.asynchttpclient.disableUrlEncodingForBoundRequests=false
+org.asynchttpclient.removeQueryParamOnRedirect=true
+org.asynchttpclient.acceptAnyCertificate=false
+org.asynchttpclient.httpClientCodecMaxInitialLineLength=4096
+org.asynchttpclient.httpClientCodecMaxHeaderSize=8192
+org.asynchttpclient.httpClientCodecMaxChunkSize=8192
+org.asynchttpclient.disableZeroCopy=false
+org.asynchttpclient.handshakeTimeout=10000
+org.asynchttpclient.chunkedFileChunkSize=8192
+org.asynchttpclient.webSocketMaxBufferSize=128000000
+org.asynchttpclient.webSocketMaxFrameSize=10240
+org.asynchttpclient.keepEncodingHeader=false
diff --git a/api/src/main/resources/org/asynchttpclient/version.properties b/api/src/main/resources/ahc-version.properties
similarity index 100%
rename from api/src/main/resources/org/asynchttpclient/version.properties
rename to api/src/main/resources/ahc-version.properties
diff --git a/api/src/test/java/org/asynchttpclient/async/AbstractBasicHttpsTest.java b/api/src/test/java/org/asynchttpclient/AbstractBasicHttpsTest.java
similarity index 85%
rename from api/src/test/java/org/asynchttpclient/async/AbstractBasicHttpsTest.java
rename to api/src/test/java/org/asynchttpclient/AbstractBasicHttpsTest.java
index e95112a70..1b8a624dc 100644
--- a/api/src/test/java/org/asynchttpclient/async/AbstractBasicHttpsTest.java
+++ b/api/src/test/java/org/asynchttpclient/AbstractBasicHttpsTest.java
@@ -13,10 +13,10 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient;
 
-import static org.asynchttpclient.async.util.TestUtils.findFreePort;
-import static org.asynchttpclient.async.util.TestUtils.newJettyHttpsServer;
+import static org.asynchttpclient.test.TestUtils.findFreePort;
+import static org.asynchttpclient.test.TestUtils.newJettyHttpsServer;
 
 import org.testng.annotations.BeforeClass;
 
diff --git a/api/src/test/java/org/asynchttpclient/async/AbstractBasicTest.java b/api/src/test/java/org/asynchttpclient/AbstractBasicTest.java
similarity index 76%
rename from api/src/test/java/org/asynchttpclient/async/AbstractBasicTest.java
rename to api/src/test/java/org/asynchttpclient/AbstractBasicTest.java
index 224b24eb9..b2a439323 100644
--- a/api/src/test/java/org/asynchttpclient/async/AbstractBasicTest.java
+++ b/api/src/test/java/org/asynchttpclient/AbstractBasicTest.java
@@ -13,22 +13,15 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient;
 
-import static org.asynchttpclient.async.util.TestUtils.addHttpConnector;
-import static org.asynchttpclient.async.util.TestUtils.findFreePort;
-import static org.asynchttpclient.async.util.TestUtils.newJettyHttpServer;
+import static org.asynchttpclient.test.TestUtils.addHttpConnector;
+import static org.asynchttpclient.test.TestUtils.findFreePort;
+import static org.asynchttpclient.test.TestUtils.newJettyHttpServer;
 import static org.testng.Assert.fail;
 
-import org.asynchttpclient.AsyncCompletionHandler;
-import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.HttpResponseHeaders;
-import org.asynchttpclient.HttpResponseStatus;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.async.util.EchoHandler;
+import org.asynchttpclient.test.EchoHandler;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.slf4j.Logger;
@@ -79,7 +72,6 @@ public AbstractHandler configureHandler() throws Exception {
     }
 
     public static class AsyncCompletionHandlerAdapter extends AsyncCompletionHandler<Response> {
-        public Runnable runnable;
 
         @Override
         public Response onCompleted(Response response) throws Exception {
@@ -102,18 +94,18 @@ public void onThrowable(Throwable t) {
         }
 
         @Override
-        public STATE onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
-            return STATE.CONTINUE;
+        public State onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
+            return State.CONTINUE;
         }
 
         @Override
-        public STATE onStatusReceived(final HttpResponseStatus responseStatus) throws Exception {
-            return STATE.CONTINUE;
+        public State onStatusReceived(final HttpResponseStatus responseStatus) throws Exception {
+            return State.CONTINUE;
         }
 
         @Override
-        public STATE onHeadersReceived(final HttpResponseHeaders headers) throws Exception {
-            return STATE.CONTINUE;
+        public State onHeadersReceived(final HttpResponseHeaders headers) throws Exception {
+            return State.CONTINUE;
         }
 
         @Override
diff --git a/api/src/test/java/org/asynchttpclient/AsyncHttpClientDefaultsTest.java b/api/src/test/java/org/asynchttpclient/AsyncHttpClientDefaultsTest.java
index 67034b7cb..f3617f482 100644
--- a/api/src/test/java/org/asynchttpclient/AsyncHttpClientDefaultsTest.java
+++ b/api/src/test/java/org/asynchttpclient/AsyncHttpClientDefaultsTest.java
@@ -1,6 +1,9 @@
 package org.asynchttpclient;
 
-import org.asynchttpclient.util.AsyncPropertiesHelper;
+import static org.asynchttpclient.config.AsyncHttpClientConfigDefaults.ASYNC_CLIENT_CONFIG_ROOT;
+
+import org.asynchttpclient.config.AsyncHttpClientConfigDefaults;
+import org.asynchttpclient.config.AsyncHttpClientConfigHelper;
 import org.testng.Assert;
 import org.testng.annotations.Test;
 
@@ -8,8 +11,7 @@
 
 @Test
 public class AsyncHttpClientDefaultsTest {
-    public static final String ASYNC_CLIENT = AsyncHttpClientConfig.class.getName() + ".";
-    
+
     public void testDefaultMaxTotalConnections() {
         Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultMaxConnections(),-1);
         testIntegerSystemProperty("maxConnections", "defaultMaxConnections", "100");
@@ -20,32 +22,32 @@ public void testDefaultMaxConnectionPerHost() {
         testIntegerSystemProperty("maxConnectionsPerHost", "defaultMaxConnectionsPerHost", "100");
     }
 
-    public void testDefaultConnectionTimeOutInMs() {
-        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultConnectionTimeout(), 60 * 1000);
-        testIntegerSystemProperty("connectionTimeout", "defaultConnectionTimeout", "100");
+    public void testDefaultConnectTimeOut() {
+        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultConnectTimeout(), 5 * 1000);
+        testIntegerSystemProperty("connectTimeout", "defaultConnectTimeout", "100");
     }
 
-    public void testDefaultIdleConnectionInPoolTimeoutInMs() {
+    public void testDefaultPooledConnectionIdleTimeout() {
         Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultPooledConnectionIdleTimeout(), 60 * 1000);
         testIntegerSystemProperty("pooledConnectionIdleTimeout", "defaultPooledConnectionIdleTimeout", "100");
     }
 
-    public void testDefaultIdleConnectionTimeoutInMs() {
+    public void testDefaultReadTimeout() {
         Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultReadTimeout(), 60 * 1000);
         testIntegerSystemProperty("readTimeout", "defaultReadTimeout", "100");
     }
 
-    public void testDefaultRequestTimeoutInMs() {
+    public void testDefaultRequestTimeout() {
         Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultRequestTimeout(), 60 * 1000);
         testIntegerSystemProperty("requestTimeout", "defaultRequestTimeout", "100");
     }
 
-    public void testDefaultWebSocketIdleTimeoutInMs() {
+    public void testDefaultWebSocketTimeout() {
         Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultWebSocketTimeout(), 15 * 60 * 1000);
         testIntegerSystemProperty("webSocketTimeout", "defaultWebSocketTimeout", "100");
     }
 
-    public void testDefaultMaxConnectionLifeTimeInMs() {
+    public void testDefaultConnectionTTL() {
         Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultConnectionTTL(), -1);
         testIntegerSystemProperty("connectionTTL", "defaultConnectionTTL", "100");
     }
@@ -95,17 +97,12 @@ public void testDefaultAllowPoolingConnection() {
        testBooleanSystemProperty("allowPoolingConnections", "defaultAllowPoolingConnections", "false");
     }
 
-    public void testDefaultUseRelativeURIsWithConnectProxies() {
-       Assert.assertTrue(AsyncHttpClientConfigDefaults.defaultUseRelativeURIsWithConnectProxies());
-       testBooleanSystemProperty("useRelativeURIsWithConnectProxies", "defaultUseRelativeURIsWithConnectProxies", "false");
-    }
-
     public void testDefaultMaxRequestRetry() {
         Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultMaxRequestRetry(), 5);
         testIntegerSystemProperty("maxRequestRetry", "defaultMaxRequestRetry", "100");
     }
 
-    public void testDefaultAllowSslConnectionPool() {
+    public void testDefaultAllowPoolingSslConnections() {
        Assert.assertTrue(AsyncHttpClientConfigDefaults.defaultAllowPoolingSslConnections());
        testBooleanSystemProperty("allowPoolingSslConnections", "defaultAllowPoolingSslConnections", "false");
     }
@@ -115,35 +112,15 @@ public void testDefaultDisableUrlEncodingForBoundRequests() {
         testBooleanSystemProperty("disableUrlEncodingForBoundRequests", "defaultDisableUrlEncodingForBoundRequests", "true");
     }
 
-    public void testDefaultRemoveQueryParamOnRedirect() {
-       Assert.assertTrue(AsyncHttpClientConfigDefaults.defaultRemoveQueryParamOnRedirect());
-       testBooleanSystemProperty("removeQueryParamOnRedirect", "defaultRemoveQueryParamOnRedirect", "false");
-    }
-
-    public void testDefaultSpdyEnabled() {
-        Assert.assertFalse(AsyncHttpClientConfigDefaults.defaultSpdyEnabled());
-        testBooleanSystemProperty("spdyEnabled", "defaultSpdyEnabled", "true");
-    }
-
-    public void testDefaultSpdyInitialWindowSize() {
-        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultSpdyInitialWindowSize(), 10 * 1024 * 1024);
-        testIntegerSystemProperty("spdyInitialWindowSize", "defaultSpdyInitialWindowSize", "100");
-    }
-
-    public void testDefaultSpdyMaxConcurrentStreams() {
-        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultSpdyMaxConcurrentStreams(), 100);
-        testIntegerSystemProperty("spdyMaxConcurrentStreams", "defaultSpdyMaxConcurrentStreams", "100");
-    }
-    
     public void testDefaultAcceptAnyCertificate() {
        Assert.assertFalse(AsyncHttpClientConfigDefaults.defaultAcceptAnyCertificate());
        testBooleanSystemProperty("acceptAnyCertificate", "defaultAcceptAnyCertificate", "true");
     }
     
     private void testIntegerSystemProperty(String propertyName,String methodName,String value){
-        String previous = System.getProperty(ASYNC_CLIENT + propertyName);
-        System.setProperty(ASYNC_CLIENT + propertyName, value);
-        AsyncPropertiesHelper.reloadProperties();
+        String previous = System.getProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName);
+        System.setProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName, value);
+        AsyncHttpClientConfigHelper.reloadProperties();
         try {
             Method method = AsyncHttpClientConfigDefaults.class.getMethod(methodName, new Class[]{});
             Assert.assertEquals(method.invoke(null, new Object[]{}),Integer.parseInt(value));
@@ -151,15 +128,15 @@ private void testIntegerSystemProperty(String propertyName,String methodName,Str
             Assert.fail("Couldn't find or execute method : " + methodName,e);
         } 
         if(previous != null)
-            System.setProperty(ASYNC_CLIENT + propertyName, previous);
+            System.setProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName, previous);
         else
-            System.clearProperty(ASYNC_CLIENT + propertyName);
+            System.clearProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName);
     }
     
     private void testBooleanSystemProperty(String propertyName,String methodName,String value){
-        String previous = System.getProperty(ASYNC_CLIENT + propertyName);
-        System.setProperty(ASYNC_CLIENT + propertyName, value);
-        AsyncPropertiesHelper.reloadProperties();
+        String previous = System.getProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName);
+        System.setProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName, value);
+        AsyncHttpClientConfigHelper.reloadProperties();
         try {
             Method method = AsyncHttpClientConfigDefaults.class.getMethod(methodName, new Class[]{});
             Assert.assertEquals(method.invoke(null, new Object[]{}),Boolean.parseBoolean(value));
@@ -167,15 +144,15 @@ private void testBooleanSystemProperty(String propertyName,String methodName,Str
             Assert.fail("Couldn't find or execute method : " + methodName,e);
         } 
         if(previous != null)
-            System.setProperty(ASYNC_CLIENT + propertyName, previous);
+            System.setProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName, previous);
         else
-            System.clearProperty(ASYNC_CLIENT + propertyName);
+            System.clearProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName);
     }
     
     private void testStringSystemProperty(String propertyName,String methodName,String value){
-        String previous = System.getProperty(ASYNC_CLIENT + propertyName);
-        System.setProperty(ASYNC_CLIENT + propertyName, value);
-        AsyncPropertiesHelper.reloadProperties();
+        String previous = System.getProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName);
+        System.setProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName, value);
+        AsyncHttpClientConfigHelper.reloadProperties();
         try {
             Method method = AsyncHttpClientConfigDefaults.class.getMethod(methodName, new Class[]{});
             Assert.assertEquals(method.invoke(null, new Object[]{}),value);
@@ -183,8 +160,8 @@ private void testStringSystemProperty(String propertyName,String methodName,Stri
             Assert.fail("Couldn't find or execute method : " + methodName,e);
         } 
         if(previous != null)
-            System.setProperty(ASYNC_CLIENT + propertyName, previous);
+            System.setProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName, previous);
         else
-            System.clearProperty(ASYNC_CLIENT + propertyName);
+            System.clearProperty(ASYNC_CLIENT_CONFIG_ROOT + propertyName);
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/AsyncProvidersBasicTest.java b/api/src/test/java/org/asynchttpclient/AsyncProvidersBasicTest.java
similarity index 84%
rename from api/src/test/java/org/asynchttpclient/async/AsyncProvidersBasicTest.java
rename to api/src/test/java/org/asynchttpclient/AsyncProvidersBasicTest.java
index e82db71a1..b63816e4a 100755
--- a/api/src/test/java/org/asynchttpclient/async/AsyncProvidersBasicTest.java
+++ b/api/src/test/java/org/asynchttpclient/AsyncProvidersBasicTest.java
@@ -13,10 +13,11 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient;
 
-import static org.asynchttpclient.async.util.TestUtils.TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET;
-import static org.asynchttpclient.async.util.TestUtils.findFreePort;
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.asynchttpclient.test.TestUtils.TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET;
+import static org.asynchttpclient.test.TestUtils.findFreePort;
 import static org.asynchttpclient.util.DateUtils.millisTime;
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertNotNull;
@@ -24,29 +25,12 @@
 import static org.testng.Assert.assertTrue;
 import static org.testng.Assert.fail;
 
-import org.asynchttpclient.AsyncCompletionHandler;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.AsyncHttpClientConfig.Builder;
-import org.asynchttpclient.AsyncHttpClientConfigBean;
-import org.asynchttpclient.AsyncHttpProviderConfig;
-import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
-import org.asynchttpclient.MaxRedirectException;
-import org.asynchttpclient.ProxyServer;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.RequestBuilder;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.cookie.Cookie;
-import org.asynchttpclient.multipart.Part;
-import org.asynchttpclient.multipart.StringPart;
-import org.asynchttpclient.util.StandardCharsets;
-import org.testng.annotations.Test;
-
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.net.ConnectException;
 import java.net.HttpURLConnection;
 import java.net.URL;
+import java.net.UnknownHostException;
 import java.nio.channels.UnresolvedAddressException;
 import java.util.Arrays;
 import java.util.HashMap;
@@ -62,18 +46,27 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 
-public abstract class AsyncProvidersBasicTest extends AbstractBasicTest {
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpProviderConfig;
+import org.asynchttpclient.AsyncHttpClientConfig.Builder;
+import org.asynchttpclient.config.AsyncHttpClientConfigBean;
+import org.asynchttpclient.cookie.Cookie;
+import org.asynchttpclient.handler.MaxRedirectException;
+import org.asynchttpclient.proxy.ProxyServer;
+import org.asynchttpclient.request.body.multipart.Part;
+import org.asynchttpclient.request.body.multipart.StringPart;
+import org.asynchttpclient.test.EventCollectingHandler;
+import org.testng.annotations.Test;
 
-  protected abstract String acceptEncodingHeader();
+public abstract class AsyncProvidersBasicTest extends AbstractBasicTest {
 
   protected abstract AsyncHttpProviderConfig<?, ?> getProviderConfig();
 
     @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncProviderEncodingTest() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             Request request = new RequestBuilder("GET").setUrl(getTargetUrl() + "?q=+%20x").build();
-            assertEquals(request.getUrl(), getTargetUrl() + "?q=%20%20x");
+            assertEquals(request.getUrl(), getTargetUrl() + "?q=+%20x");
 
             String url = client.executeRequest(request, new AsyncCompletionHandler<String>() {
                 @Override
@@ -88,16 +81,13 @@ public void onThrowable(Throwable t) {
                 }
 
             }).get();
-            assertEquals(url, getTargetUrl() + "?q=%20%20x");
-        } finally {
-            client.close();
+            assertEquals(url, getTargetUrl() + "?q=+%20x");
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncProviderEncodingTest2() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             Request request = new RequestBuilder("GET").setUrl(getTargetUrl() + "").addQueryParam("q", "a b").build();
 
             String url = client.executeRequest(request, new AsyncCompletionHandler<String>() {
@@ -114,15 +104,12 @@ public void onThrowable(Throwable t) {
 
             }).get();
             assertEquals(url, getTargetUrl() + "?q=a%20b");
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
     public void emptyRequestURI() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             Request request = new RequestBuilder("GET").setUrl(getTargetUrl()).build();
 
             String url = client.executeRequest(request, new AsyncCompletionHandler<String>() {
@@ -139,19 +126,16 @@ public void onThrowable(Throwable t) {
 
             }).get();
             assertEquals(url, getTargetUrl());
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncProviderContentLenghtGETTest() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
         final HttpURLConnection connection = (HttpURLConnection) new URL(getTargetUrl()).openConnection();
         connection.connect();
         final int ct = connection.getContentLength();
         connection.disconnect();
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             final CountDownLatch l = new CountDownLatch(1);
 
             Request request = new RequestBuilder("GET").setUrl(getTargetUrl()).build();
@@ -186,15 +170,12 @@ public void onThrowable(Throwable t) {
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
                 fail("Timeout out");
             }
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncContentTypeGETTest() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             final CountDownLatch l = new CountDownLatch(1);
             Request request = new RequestBuilder("GET").setUrl(getTargetUrl()).build();
             client.executeRequest(request, new AsyncCompletionHandlerAdapter() {
@@ -213,15 +194,12 @@ public Response onCompleted(Response response) throws Exception {
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
                 fail("Timeout out");
             }
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncHeaderGETTest() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             final CountDownLatch l = new CountDownLatch(1);
             Request request = new RequestBuilder("GET").setUrl(getTargetUrl()).build();
             client.executeRequest(request, new AsyncCompletionHandlerAdapter() {
@@ -241,15 +219,12 @@ public Response onCompleted(Response response) throws Exception {
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
                 fail("Timeout out");
             }
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncHeaderPOSTTest() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             final CountDownLatch l = new CountDownLatch(1);
             FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
             h.add("Test1", "Test1");
@@ -278,20 +253,17 @@ public Response onCompleted(Response response) throws Exception {
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
                 fail("Timeout out");
             }
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncParamPOSTTest() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             final CountDownLatch l = new CountDownLatch(1);
             FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
             h.add("Content-Type", "application/x-www-form-urlencoded");
 
-            Map<String, List<String>> m = new HashMap<String, List<String>>();
+            Map<String, List<String>> m = new HashMap<>();
             for (int i = 0; i < 5; i++) {
                 m.put("param_" + i, Arrays.asList("value_" + i));
             }
@@ -315,15 +287,12 @@ public Response onCompleted(Response response) throws Exception {
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
                 fail("Timeout out");
             }
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncStatusHEADTest() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             final CountDownLatch l = new CountDownLatch(1);
             Request request = new RequestBuilder("HEAD").setUrl(getTargetUrl()).build();
             Response response = client.executeRequest(request, new AsyncCompletionHandlerAdapter() {
@@ -349,16 +318,13 @@ public Response onCompleted(Response response) throws Exception {
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
                 fail("Timeout out");
             }
-        } finally {
-            client.close();
         }
     }
 
     // TODO: fix test
     @Test(groups = { "standalone", "default_provider", "async" }, enabled = false)
     public void asyncStatusHEADContentLenghtTest() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeout(120 * 1000).build());
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeout(120 * 1000).build())) {
             final CountDownLatch l = new CountDownLatch(1);
             Request request = new RequestBuilder("HEAD").setUrl(getTargetUrl()).build();
 
@@ -384,26 +350,19 @@ public void onThrowable(Throwable t) {
             if (!l.await(10 * 5 * 1000, TimeUnit.SECONDS)) {
                 fail("Timeout out");
             }
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "online", "default_provider", "async" }, expectedExceptions = { NullPointerException.class })
     public void asyncNullSchemeTest() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             client.prepareGet("www.sun.com").execute();
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncDoGetTransferEncodingTest() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             final CountDownLatch l = new CountDownLatch(1);
 
             client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
@@ -423,15 +382,12 @@ public Response onCompleted(Response response) throws Exception {
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
                 fail("Timeout out");
             }
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncDoGetHeadersTest() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             final CountDownLatch l = new CountDownLatch(1);
             FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
             h.add("Test1", "Test1");
@@ -457,15 +413,12 @@ public Response onCompleted(Response response) throws Exception {
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
                 fail("Timeout out");
             }
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncDoGetCookieTest() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             final CountDownLatch l = new CountDownLatch(1);
             FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
             h.add("Test1", "Test1");
@@ -474,7 +427,7 @@ public void asyncDoGetCookieTest() throws Exception {
             h.add("Test4", "Test4");
             h.add("Test5", "Test5");
 
-            final Cookie coo = Cookie.newValidCookie("foo", "value", "value", "/", "/", -1L, -1, false, false);
+            final Cookie coo = Cookie.newValidCookie("foo", "value", false, "/", "/", Long.MIN_VALUE, false, false);
             client.prepareGet(getTargetUrl()).setHeaders(h).addCookie(coo).execute(new AsyncCompletionHandlerAdapter() {
 
                 @Override
@@ -494,15 +447,12 @@ public Response onCompleted(Response response) throws Exception {
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
                 fail("Timeout out");
             }
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncDoPostDefaultContentType() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             final CountDownLatch l = new CountDownLatch(1);
             client.preparePost(getTargetUrl()).addFormParam("foo", "bar").execute(new AsyncCompletionHandlerAdapter() {
 
@@ -522,26 +472,20 @@ public Response onCompleted(Response response) throws Exception {
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
                 fail("Timeout out");
             }
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncDoPostBodyIsoTest() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             Response response = client.preparePost(getTargetUrl()).addHeader("X-ISO", "true").setBody("\u017D\u017D\u017D\u017D\u017D\u017D").execute().get();
             assertEquals(response.getResponseBody().getBytes("ISO-8859-1"), "\u017D\u017D\u017D\u017D\u017D\u017D".getBytes("ISO-8859-1"));
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncDoPostBytesTest() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             final CountDownLatch l = new CountDownLatch(1);
             FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
             h.add("Content-Type", "application/x-www-form-urlencoded");
@@ -572,15 +516,12 @@ public Response onCompleted(Response response) throws Exception {
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
                 fail("Timeout out");
             }
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncDoPostInputStreamTest() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             final CountDownLatch l = new CountDownLatch(1);
             FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
             h.add("Content-Type", "application/x-www-form-urlencoded");
@@ -611,15 +552,12 @@ public Response onCompleted(Response response) throws Exception {
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
                 fail("Timeout out");
             }
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncDoPutInputStreamTest() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             final CountDownLatch l = new CountDownLatch(1);
             FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
             h.add("Content-Type", "application/x-www-form-urlencoded");
@@ -648,18 +586,15 @@ public Response onCompleted(Response response) throws Exception {
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
                 fail("Timeout out");
             }
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncDoPostMultiPartTest() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             final CountDownLatch l = new CountDownLatch(1);
 
-            Part p = new StringPart("foo", "bar", StandardCharsets.UTF_8);
+            Part p = new StringPart("foo", "bar");
 
             client.preparePost(getTargetUrl()).addBodyPart(p).execute(new AsyncCompletionHandlerAdapter() {
 
@@ -669,8 +604,7 @@ public Response onCompleted(Response response) throws Exception {
                         String xContentType = response.getHeader("X-Content-Type");
                         String boundary = xContentType.substring((xContentType.indexOf("boundary") + "boundary".length() + 1));
 
-                        String s = response.getResponseBodyExcerpt(boundary.length() + "--".length()).substring("--".length());
-                        assertEquals(boundary, s);
+                        assertTrue(response.getResponseBody().regionMatches(false, "--".length(), boundary, 0, boundary.length()));
                     } finally {
                         l.countDown();
                     }
@@ -680,15 +614,13 @@ public Response onCompleted(Response response) throws Exception {
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
                 fail("Timeout out");
             }
-        } finally {
-            client.close();
         }
     }
     
     @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncDoPostBasicGZIPTest() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        try {
+        AsyncHttpClientConfig cf = new AsyncHttpClientConfig.Builder().setCompressionEnforced(true).build();
+        try (AsyncHttpClient client = getAsyncHttpClient(cf)) {
             final CountDownLatch l = new CountDownLatch(1);
             FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
             h.add("Content-Type", "application/x-www-form-urlencoded");
@@ -704,7 +636,7 @@ public void asyncDoPostBasicGZIPTest() throws Exception {
                 public Response onCompleted(Response response) throws Exception {
                     try {
                         assertEquals(response.getStatusCode(), 200);
-                        assertEquals(response.getHeader("X-Accept-Encoding"), acceptEncodingHeader());
+                        assertEquals(response.getHeader("X-Accept-Encoding"), "gzip,deflate");
                     } finally {
                         l.countDown();
                     }
@@ -715,15 +647,12 @@ public Response onCompleted(Response response) throws Exception {
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
                 fail("Timeout out");
             }
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncDoPostProxyTest() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setProxyServer(new ProxyServer("127.0.0.1", port2)).build());
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setProxyServer(new ProxyServer("127.0.0.1", port2)).build())) {
             FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
             h.add("Content-Type", "application/x-www-form-urlencoded");
             StringBuilder sb = new StringBuilder();
@@ -745,19 +674,16 @@ public void onThrowable(Throwable t) {
 
             assertEquals(response.getStatusCode(), 200);
             assertEquals(response.getHeader("X-Connection"), "keep-alive");
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncRequestVirtualServerPOSTTest() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
             h.add("Content-Type", "application/x-www-form-urlencoded");
 
-            Map<String, List<String>> m = new HashMap<String, List<String>>();
+            Map<String, List<String>> m = new HashMap<>();
             for (int i = 0; i < 5; i++) {
                 m.put("param_" + i, Arrays.asList("value_" + i));
             }
@@ -771,15 +697,12 @@ public void asyncRequestVirtualServerPOSTTest() throws Exception {
             } else {
                 assertEquals(response.getHeader("X-Host"), "127.0.0.1:" + port1);
             }
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncDoPutTest() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
             h.add("Content-Type", "application/x-www-form-urlencoded");
             StringBuilder sb = new StringBuilder();
@@ -791,15 +714,12 @@ public void asyncDoPutTest() throws Exception {
             Response response = client.preparePut(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter()).get();
 
             assertEquals(response.getStatusCode(), 200);
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncDoPostLatchBytesTest() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
             final CountDownLatch l = new CountDownLatch(1);
             FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
             h.add("Content-Type", "application/x-www-form-urlencoded");
@@ -828,15 +748,12 @@ public Response onCompleted(Response response) throws Exception {
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
                 fail("Timeout out");
             }
-        } finally {
-            c.close();
         }
     }
 
-    @Test(groups = { "standalone", "default_provider", "async" })
+    @Test(groups = { "standalone", "default_provider", "async" }, expectedExceptions = { CancellationException.class })
     public void asyncDoPostDelayCancelTest() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
             h.add("Content-Type", "application/x-www-form-urlencoded");
             h.add("LockThread", "true");
@@ -849,17 +766,13 @@ public void onThrowable(Throwable t) {
                 }
             });
             future.cancel(true);
-            Response response = future.get(TIMEOUT, TimeUnit.SECONDS);
-            assertNull(response);
-        } finally {
-            client.close();
+            future.get(TIMEOUT, TimeUnit.SECONDS);
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncDoPostDelayBytesTest() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
             h.add("Content-Type", "application/x-www-form-urlencoded");
             h.add("LockThread", "true");
@@ -884,16 +797,12 @@ public void onThrowable(Throwable t) {
             } catch (IllegalStateException ex) {
                 assertTrue(false);
             }
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncDoPostNullBytesTest() throws Exception {
-
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
             h.add("Content-Type", "application/x-www-form-urlencoded");
             StringBuilder sb = new StringBuilder();
@@ -907,15 +816,12 @@ public void asyncDoPostNullBytesTest() throws Exception {
             Response response = future.get();
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 200);
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncDoPostListenerBytesTest() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
             h.add("Content-Type", "application/x-www-form-urlencoded");
             StringBuilder sb = new StringBuilder();
@@ -941,15 +847,12 @@ public Response onCompleted(Response response) throws Exception {
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
                 fail("Latch time out");
             }
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncConnectInvalidFuture() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             int dummyPort = findFreePort();
             final AtomicInteger count = new AtomicInteger();
             for (int i = 0; i < 20; i++) {
@@ -969,15 +872,12 @@ public void onThrowable(Throwable t) {
                 }
             }
             assertEquals(count.get(), 20);
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncConnectInvalidPortFuture() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             int dummyPort = findFreePort();
             try {
                 Response response = client.preparePost(String.format("http://127.0.0.1:%d/", dummyPort)).execute(new AsyncCompletionHandlerAdapter() {
@@ -993,15 +893,12 @@ public void onThrowable(Throwable t) {
                     fail("Should have been caused by ConnectException, not by " + cause.getClass().getName());
                 }
             }
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncConnectInvalidPort() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             // pick a random unused local port
             int port = findFreePort();
 
@@ -1016,15 +913,12 @@ public void onThrowable(Throwable t) {
             } catch (ExecutionException ex) {
                 assertEquals(ex.getCause().getClass(), ConnectException.class);
             }
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncConnectInvalidHandlerPort() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             final CountDownLatch l = new CountDownLatch(1);
             int port = findFreePort();
 
@@ -1042,42 +936,36 @@ public void onThrowable(Throwable t) {
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
                 fail("Timed out");
             }
-        } finally {
-            client.close();
         }
     }
 
-    @Test(groups = { "online", "default_provider", "async" })
-    public void asyncConnectInvalidHandlerHost() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+    @Test(groups = { "online", "default_provider", "async" }, expectedExceptions = { ConnectException.class, UnresolvedAddressException.class, UnknownHostException.class })
+    public void asyncConnectInvalidHandlerHost() throws Throwable {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
+
+            final AtomicReference<Throwable> e = new AtomicReference<>();
             final CountDownLatch l = new CountDownLatch(1);
 
             client.prepareGet("http://null.apache.org:9999/").execute(new AsyncCompletionHandlerAdapter() {
                 @Override
                 public void onThrowable(Throwable t) {
-                    if (t != null) {
-                        if (t.getClass().equals(ConnectException.class)) {
-                            l.countDown();
-                        } else if (t.getClass().equals(UnresolvedAddressException.class)) {
-                            l.countDown();
-                        }
-                    }
+                    e.set(t);
+                    l.countDown();
                 }
             });
 
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
                 fail("Timed out");
             }
-        } finally {
-            client.close();
+
+            assertNotNull(e.get());
+            throw e.get();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncConnectInvalidFuturePort() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             final AtomicBoolean called = new AtomicBoolean(false);
             final AtomicBoolean rightCause = new AtomicBoolean(false);
             // pick a random unused local port
@@ -1099,15 +987,12 @@ public void onThrowable(Throwable t) {
             }
             assertTrue(called.get(), "onThrowable should get called.");
             assertTrue(rightCause.get(), "onThrowable should get called with ConnectionException");
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncContentLenghtGETTest() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             Response response = client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
 
                 @Override
@@ -1118,33 +1003,12 @@ public void onThrowable(Throwable t) {
 
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 200);
-        } finally {
-            client.close();
-        }
-    }
-
-    @Test(groups = { "standalone", "default_provider", "async" })
-    public void asyncResponseBodyTooLarge() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
-            Response response = client.preparePost(getTargetUrl()).setBody("0123456789").execute(new AsyncCompletionHandlerAdapter() {
-
-                @Override
-                public void onThrowable(Throwable t) {
-                    fail("Unexpected exception", t);
-                }
-            }).get();
-
-            assertNotNull(response.getResponseBodyExcerpt(Integer.MAX_VALUE));
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncResponseEmptyBody() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             Response response = client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
 
                 @Override
@@ -1154,15 +1018,12 @@ public void onThrowable(Throwable t) {
             }).get();
 
             assertEquals(response.getResponseBody(), "");
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "asyncAPI" })
     public void asyncAPIContentLenghtGETTest() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             // Use a l in case the assert fail
             final CountDownLatch l = new CountDownLatch(1);
 
@@ -1186,15 +1047,12 @@ public void onThrowable(Throwable t) {
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
                 fail("Timed out");
             }
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "asyncAPI" })
     public void asyncAPIHandlerExceptionTest() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             // Use a l in case the assert fail
             final CountDownLatch l = new CountDownLatch(1);
 
@@ -1219,15 +1077,12 @@ public void onThrowable(Throwable t) {
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
                 fail("Timed out");
             }
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncDoGetDelayHandlerTest() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeout(5 * 1000).build());
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeout(5 * 1000).build())) {
             FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
             h.add("LockThread", "true");
 
@@ -1263,15 +1118,12 @@ public void onThrowable(Throwable t) {
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
                 fail("Timed out");
             }
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncDoGetQueryStringTest() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             // Use a l in case the assert fail
             final CountDownLatch l = new CountDownLatch(1);
 
@@ -1296,15 +1148,12 @@ public Response onCompleted(Response response) throws Exception {
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
                 fail("Timed out");
             }
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncDoGetKeepAliveHandlerTest() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             // Use a l in case the assert fail
             final CountDownLatch l = new CountDownLatch(2);
 
@@ -1334,15 +1183,12 @@ public Response onCompleted(Response response) throws Exception {
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
                 fail("Timed out");
             }
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "online", "default_provider", "async" })
     public void asyncDoGetMaxRedirectTest() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(new Builder().setMaxRedirects(0).setFollowRedirect(true).build());
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(new Builder().setMaxRedirects(0).setFollowRedirect(true).build())) {
             // Use a l in case the assert fail
             final CountDownLatch l = new CountDownLatch(1);
 
@@ -1370,15 +1216,12 @@ public void onThrowable(Throwable t) {
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
                 fail("Timed out");
             }
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "online", "default_provider", "async" })
     public void asyncDoGetNestedTest() throws Exception {
-        final AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             // FIXME find a proper website that redirects the same number of times whatever the language
             // Use a l in case the assert fail
             final CountDownLatch l = new CountDownLatch(2);
@@ -1413,81 +1256,62 @@ public void onThrowable(Throwable t) {
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
                 fail("Timed out");
             }
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "online", "default_provider", "async" })
     public void asyncDoGetStreamAndBodyTest() throws Exception {
-        final AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             Response response = client.prepareGet("http://www.lemonde.fr").execute().get();
             assertEquals(response.getStatusCode(), 200);
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "online", "default_provider", "async" })
     public void asyncUrlWithoutPathTest() throws Exception {
-        final AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             Response response = client.prepareGet("http://www.lemonde.fr").execute().get();
             assertEquals(response.getStatusCode(), 200);
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "default_provider", "async" })
     public void optionsTest() throws Exception {
-        final AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             Response response = client.prepareOptions(getTargetUrl()).execute().get();
 
             assertEquals(response.getStatusCode(), 200);
             assertEquals(response.getHeader("Allow"), "GET,HEAD,POST,OPTIONS,TRACE");
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "online", "default_provider" })
     public void testAwsS3() throws Exception {
-        final AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             Response response = client.prepareGet("http://test.s3.amazonaws.com/").execute().get();
             if (response.getResponseBody() == null || response.getResponseBody().equals("")) {
                 fail("No response Body");
             } else {
                 assertEquals(response.getStatusCode(), 403);
             }
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "online", "default_provider" })
     public void testAsyncHttpProviderConfig() throws Exception {
-
-        final AsyncHttpClient client = getAsyncHttpClient(new Builder().setAsyncHttpClientProviderConfig(getProviderConfig()).build());
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(new Builder().setAsyncHttpClientProviderConfig(getProviderConfig()).build())) {
             Response response = client.prepareGet("http://test.s3.amazonaws.com/").execute().get();
             if (response.getResponseBody() == null || response.getResponseBody().equals("")) {
                 fail("No response Body");
             } else {
                 assertEquals(response.getStatusCode(), 403);
             }
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void idleRequestTimeoutTest() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setPooledConnectionIdleTimeout(5000).setRequestTimeout(10000).build());
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setPooledConnectionIdleTimeout(5000).setRequestTimeout(10000).build())) {
             FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
             h.add("Content-Type", "application/x-www-form-urlencoded");
             h.add("LockThread", "true");
@@ -1502,23 +1326,19 @@ public void idleRequestTimeoutTest() throws Exception {
                 assertNotNull(ex.getCause());
                 assertTrue(elapsedTime >= 10000 && elapsedTime <= 25000);
             }
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" })
     public void asyncDoPostCancelTest() throws Exception {
-
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
             h.add("Content-Type", "application/x-www-form-urlencoded");
             h.add("LockThread", "true");
             StringBuilder sb = new StringBuilder();
             sb.append("LockThread=true");
 
-            final AtomicReference<CancellationException> ex = new AtomicReference<CancellationException>();
+            final AtomicReference<CancellationException> ex = new AtomicReference<>();
             ex.set(null);
             try {
                 Future<Response> future = client.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
@@ -1538,63 +1358,71 @@ public void onThrowable(Throwable t) {
                 fail();
             }
             assertNotNull(ex.get());
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void getShouldAllowBody() throws IOException {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             client.prepareGet(getTargetUrl()).setBody("Boo!").execute();
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" }, expectedExceptions = { NullPointerException.class })
     public void invalidUri() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             client.prepareGet(String.format("http:127.0.0.1:%d/foo/test", port1)).build();
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void asyncHttpClientConfigBeanTest() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfigBean().setUserAgent("test"));
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfigBean().setUserAgent("test"))) {
             Response response = client.executeRequest(client.prepareGet(getTargetUrl()).build()).get();
             assertEquals(200, response.getStatusCode());
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "default_provider", "async" })
     public void bodyAsByteTest() throws Exception {
-        final AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             Response response = client.prepareGet(getTargetUrl()).execute().get();
             assertEquals(response.getStatusCode(), 200);
             assertEquals(response.getResponseBodyAsBytes(), new byte[] {});
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "default_provider", "async" })
     public void mirrorByteTest() throws Exception {
-        final AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             Response response = client.preparePost(getTargetUrl()).setBody("MIRROR").execute().get();
             assertEquals(response.getStatusCode(), 200);
-            assertEquals(new String(response.getResponseBodyAsBytes(), StandardCharsets.UTF_8), "MIRROR");
-        } finally {
-            client.close();
+            assertEquals(new String(response.getResponseBodyAsBytes(), UTF_8), "MIRROR");
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider", "async" })
+    public void testNewConnectionEventsFired() throws Exception {
+        Request request = new RequestBuilder("GET").setUrl("http://127.0.0.1:" + port1 + "/Test").build();
+
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
+            EventCollectingHandler handler = new EventCollectingHandler();
+            client.executeRequest(request, handler).get(3, TimeUnit.SECONDS);
+            handler.waitForCompletion(3, TimeUnit.SECONDS);
+
+            List<String> expectedEvents = Arrays.asList(
+                    "ConnectionPool",
+                    "ConnectionOpen",
+                    "DnsResolved",
+                    "ConnectionOpened",
+                    "RequestSend",
+                    "HeadersWritten",
+                    "StatusReceived",
+                    "HeadersReceived",
+                    "ConnectionOffer",
+                    "Completed");
+
+            assertEquals(handler.firedEvents, expectedEvents, "Got " + Arrays.toString(handler.firedEvents.toArray()));
         }
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/AsyncStreamHandlerTest.java b/api/src/test/java/org/asynchttpclient/AsyncStreamHandlerTest.java
similarity index 78%
rename from api/src/test/java/org/asynchttpclient/async/AsyncStreamHandlerTest.java
rename to api/src/test/java/org/asynchttpclient/AsyncStreamHandlerTest.java
index 4bd4d6fe6..23df3502e 100644
--- a/api/src/test/java/org/asynchttpclient/async/AsyncStreamHandlerTest.java
+++ b/api/src/test/java/org/asynchttpclient/AsyncStreamHandlerTest.java
@@ -13,24 +13,16 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient;
 
-import static org.asynchttpclient.async.util.TestUtils.TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET;
+import static org.asynchttpclient.test.TestUtils.TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET;
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertNotNull;
 import static org.testng.Assert.assertNull;
 import static org.testng.Assert.assertTrue;
 import static org.testng.Assert.fail;
 
-import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.BoundRequestBuilder;
-import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
-import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.HttpResponseHeaders;
-import org.asynchttpclient.HttpResponseStatus;
-import org.asynchttpclient.Response;
 import org.testng.annotations.Test;
 
 import java.util.Arrays;
@@ -48,17 +40,16 @@
     @Test(groups = { "standalone", "default_provider" })
     public void asyncStreamGETTest() throws Exception {
         final CountDownLatch l = new CountDownLatch(1);
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        final AtomicReference<FluentCaseInsensitiveStringsMap> responseHeaders = new AtomicReference<FluentCaseInsensitiveStringsMap>();
-        final AtomicReference<Throwable> throwable = new AtomicReference<Throwable>();
-        try {
+        final AtomicReference<FluentCaseInsensitiveStringsMap> responseHeaders = new AtomicReference<>();
+        final AtomicReference<Throwable> throwable = new AtomicReference<>();
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
             c.prepareGet(getTargetUrl()).execute(new AsyncHandlerAdapter() {
 
                 @Override
-                public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
+                public State onHeadersReceived(HttpResponseHeaders content) throws Exception {
                     try {
                         responseHeaders.set(content.getHeaders());
-                        return STATE.ABORT;
+                        return State.ABORT;
                     } finally {
                         l.countDown();
                     }
@@ -82,19 +73,15 @@ public void onThrowable(Throwable t) {
             assertNotNull(h, "No response headers");
             assertEquals(h.getJoinedValue("content-type", ", "), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET, "Unexpected content-type");
             assertNull(throwable.get(), "Unexpected exception");
-            
-        } finally {
-            c.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void asyncStreamPOSTTest() throws Exception {
 
-        final AtomicReference<FluentCaseInsensitiveStringsMap> responseHeaders = new AtomicReference<FluentCaseInsensitiveStringsMap>();
+        final AtomicReference<FluentCaseInsensitiveStringsMap> responseHeaders = new AtomicReference<>();
 
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
             Future<String> f = c.preparePost(getTargetUrl())//
                     .setHeader("Content-Type", "application/x-www-form-urlencoded")//
                     .addFormParam("param_1", "value_1")//
@@ -102,15 +89,15 @@ public void asyncStreamPOSTTest() throws Exception {
                 private StringBuilder builder = new StringBuilder();
 
                 @Override
-                public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
+                public State onHeadersReceived(HttpResponseHeaders content) throws Exception {
                     responseHeaders.set(content.getHeaders());
-                    return STATE.CONTINUE;
+                    return State.CONTINUE;
                 }
 
                 @Override
-                public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+                public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
                     builder.append(new String(content.getBodyPartBytes()));
-                    return STATE.CONTINUE;
+                    return State.CONTINUE;
                 }
 
                 @Override
@@ -124,37 +111,32 @@ public String onCompleted() throws Exception {
             assertNotNull(h);
             assertEquals(h.getJoinedValue("content-type", ", "), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
             assertEquals(responseBody, RESPONSE);
-            
-        } finally {
-            c.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void asyncStreamInterruptTest() throws Exception {
         final CountDownLatch l = new CountDownLatch(1);
-
-        AsyncHttpClient c = getAsyncHttpClient(null);
         
-        final AtomicReference<FluentCaseInsensitiveStringsMap> responseHeaders = new AtomicReference<FluentCaseInsensitiveStringsMap>();
+        final AtomicReference<FluentCaseInsensitiveStringsMap> responseHeaders = new AtomicReference<>();
         final AtomicBoolean bodyReceived = new AtomicBoolean(false);
-        final AtomicReference<Throwable> throwable = new AtomicReference<Throwable>();
-        try {
+        final AtomicReference<Throwable> throwable = new AtomicReference<>();
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
             c.preparePost(getTargetUrl())//
             .setHeader("Content-Type", "application/x-www-form-urlencoded")//
             .addFormParam("param_1", "value_1")//
             .execute(new AsyncHandlerAdapter() {
 
                 @Override
-                public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
+                public State onHeadersReceived(HttpResponseHeaders content) throws Exception {
                     responseHeaders.set(content.getHeaders());
-                    return STATE.ABORT;
+                    return State.ABORT;
                 }
 
                 @Override
-                public STATE onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
+                public State onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
                     bodyReceived.set(true);
-                    return STATE.ABORT;
+                    return State.ABORT;
                 }
 
                 @Override
@@ -170,31 +152,27 @@ public void onThrowable(Throwable t) {
             assertNotNull(h, "Should receive non null headers");
             assertEquals(h.getJoinedValue("content-type", ", ").toLowerCase(Locale.ENGLISH), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET.toLowerCase(Locale.ENGLISH), "Unexpected content-type");
             assertNull(throwable.get(), "Should get an exception");
-            
-        } finally {
-            c.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void asyncStreamFutureTest() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        final AtomicReference<FluentCaseInsensitiveStringsMap> responseHeaders = new AtomicReference<FluentCaseInsensitiveStringsMap>();
-        final AtomicReference<Throwable> throwable = new AtomicReference<Throwable>();
-        try {
+        final AtomicReference<FluentCaseInsensitiveStringsMap> responseHeaders = new AtomicReference<>();
+        final AtomicReference<Throwable> throwable = new AtomicReference<>();
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
             Future<String> f = c.preparePost(getTargetUrl()).addFormParam("param_1", "value_1").execute(new AsyncHandlerAdapter() {
                 private StringBuilder builder = new StringBuilder();
 
                 @Override
-                public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
+                public State onHeadersReceived(HttpResponseHeaders content) throws Exception {
                     responseHeaders.set(content.getHeaders());
-                    return STATE.CONTINUE;
+                    return State.CONTINUE;
                 }
 
                 @Override
-                public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+                public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
                     builder.append(new String(content.getBodyPartBytes()));
-                    return STATE.CONTINUE;
+                    return State.CONTINUE;
                 }
 
                 @Override
@@ -215,9 +193,6 @@ public void onThrowable(Throwable t) {
             assertNotNull(responseBody, "No response body");
             assertEquals(responseBody.trim(), RESPONSE, "Unexpected response body");
             assertNull(throwable.get(), "Unexpected exception");
-
-        } finally {
-            c.close();
         }
     }
 
@@ -225,12 +200,11 @@ public void onThrowable(Throwable t) {
     public void asyncStreamThrowableRefusedTest() throws Exception {
 
         final CountDownLatch l = new CountDownLatch(1);
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
             c.prepareGet(getTargetUrl()).execute(new AsyncHandlerAdapter() {
 
                 @Override
-                public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
+                public State onHeadersReceived(HttpResponseHeaders content) throws Exception {
                     throw new RuntimeException("FOO");
                 }
 
@@ -249,17 +223,14 @@ public void onThrowable(Throwable t) {
             if (!l.await(10, TimeUnit.SECONDS)) {
                 fail("Timed out");
             }
-        } finally {
-            c.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void asyncStreamReusePOSTTest() throws Exception {
 
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        final AtomicReference<FluentCaseInsensitiveStringsMap> responseHeaders = new AtomicReference<FluentCaseInsensitiveStringsMap>();
-        try {
+        final AtomicReference<FluentCaseInsensitiveStringsMap> responseHeaders = new AtomicReference<>();
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
             BoundRequestBuilder rb = c.preparePost(getTargetUrl())//
                     .setHeader("Content-Type", "application/x-www-form-urlencoded")
                     .addFormParam("param_1", "value_1");
@@ -268,15 +239,15 @@ public void asyncStreamReusePOSTTest() throws Exception {
                 private StringBuilder builder = new StringBuilder();
 
                 @Override
-                public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
+                public State onHeadersReceived(HttpResponseHeaders content) throws Exception {
                     responseHeaders.set(content.getHeaders());
-                    return STATE.CONTINUE;
+                    return State.CONTINUE;
                 }
 
                 @Override
-                public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+                public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
                     builder.append(new String(content.getBodyPartBytes()));
-                    return STATE.CONTINUE;
+                    return State.CONTINUE;
                 }
 
                 @Override
@@ -299,15 +270,15 @@ public String onCompleted() throws Exception {
                 private StringBuilder builder = new StringBuilder();
 
                 @Override
-                public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
+                public State onHeadersReceived(HttpResponseHeaders content) throws Exception {
                     responseHeaders.set(content.getHeaders());
-                    return STATE.CONTINUE;
+                    return State.CONTINUE;
                 }
 
                 @Override
-                public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+                public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
                     builder.append(new String(content.getBodyPartBytes()));
-                    return STATE.CONTINUE;
+                    return State.CONTINUE;
                 }
 
                 @Override
@@ -322,28 +293,25 @@ public String onCompleted() throws Exception {
             assertEquals(h.getJoinedValue("content-type", ", ").toLowerCase(Locale.ENGLISH), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET.toLowerCase(Locale.ENGLISH), "Unexpected content-type");
             assertNotNull(r, "No response body");
             assertEquals(r.trim(), RESPONSE, "Unexpected response body");
-        } finally {
-            c.close();
         }
     }
 
     @Test(groups = { "online", "default_provider" })
     public void asyncStream302RedirectWithBody() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirect(true).build());
-        final AtomicReference<Integer> statusCode = new AtomicReference<Integer>(0);
-        final AtomicReference<FluentCaseInsensitiveStringsMap> responseHeaders = new AtomicReference<FluentCaseInsensitiveStringsMap>();
-        try {
+        final AtomicReference<Integer> statusCode = new AtomicReference<>(0);
+        final AtomicReference<FluentCaseInsensitiveStringsMap> responseHeaders = new AtomicReference<>();
+        try (AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirect(true).build())) {
             Future<String> f = c.prepareGet("http://google.com/").execute(new AsyncHandlerAdapter() {
 
-                public STATE onStatusReceived(HttpResponseStatus status) throws Exception {
+                public State onStatusReceived(HttpResponseStatus status) throws Exception {
                     statusCode.set(status.getStatusCode());
-                    return STATE.CONTINUE;
+                    return State.CONTINUE;
                 }
 
                 @Override
-                public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
+                public State onHeadersReceived(HttpResponseHeaders content) throws Exception {
                     responseHeaders.set(content.getHeaders());
-                    return STATE.CONTINUE;
+                    return State.CONTINUE;
                 }
 
                 @Override
@@ -365,8 +333,6 @@ public String onCompleted() throws Exception {
             // non-ISO-8859-1 using countries that have "localized" google, like google.hr, google.rs, google.cz, google.sk etc.
             //
             // assertEquals(h.getJoinedValue("content-type", ", "), "text/html; charset=ISO-8859-1");
-        } finally {
-            c.close();
         }
     }
 
@@ -377,8 +343,7 @@ public void asyncStreamJustStatusLine() throws Exception {
         final int OTHER = 2;
         final boolean[] whatCalled = new boolean[] { false, false, false };
         final CountDownLatch latch = new CountDownLatch(1);
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             Future<Integer> statusCode = client.prepareGet(getTargetUrl()).execute(new AsyncHandler<Integer>() {
                 private int status = -1;
 
@@ -389,25 +354,25 @@ public void onThrowable(Throwable t) {
                 }
 
                 @Override
-                public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+                public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
                     whatCalled[OTHER] = true;
                     latch.countDown();
-                    return STATE.ABORT;
+                    return State.ABORT;
                 }
 
                 @Override
-                public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+                public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
                     whatCalled[STATUS] = true;
                     status = responseStatus.getStatusCode();
                     latch.countDown();
-                    return STATE.ABORT;
+                    return State.ABORT;
                 }
 
                 @Override
-                public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
+                public State onHeadersReceived(HttpResponseHeaders headers) throws Exception {
                     whatCalled[OTHER] = true;
                     latch.countDown();
-                    return STATE.ABORT;
+                    return State.ABORT;
                 }
 
                 @Override
@@ -434,24 +399,21 @@ public Integer onCompleted() throws Exception {
             if (whatCalled[OTHER]) {
                 fail("Other method of AsyncHandler got called.");
             }
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "online", "default_provider" })
     public void asyncOptionsTest() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        final AtomicReference<FluentCaseInsensitiveStringsMap> responseHeaders = new AtomicReference<FluentCaseInsensitiveStringsMap>();
+        final AtomicReference<FluentCaseInsensitiveStringsMap> responseHeaders = new AtomicReference<>();
 
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
             final String[] expected = { "GET", "HEAD", "OPTIONS", "POST", "TRACE" };
             Future<String> f = c.prepareOptions("http://www.apache.org/").execute(new AsyncHandlerAdapter() {
 
                 @Override
-                public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
+                public State onHeadersReceived(HttpResponseHeaders content) throws Exception {
                     responseHeaders.set(content.getHeaders());
-                    return STATE.ABORT;
+                    return State.ABORT;
                 }
 
                 @Override
@@ -468,41 +430,37 @@ public String onCompleted() throws Exception {
             assertEquals(values.length, expected.length);
             Arrays.sort(values);
             assertEquals(values, expected);
-            
-        } finally {
-            c.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void closeConnectionTest() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
             Response r = c.prepareGet(getTargetUrl()).execute(new AsyncHandler<Response>() {
 
                 private Response.ResponseBuilder builder = new Response.ResponseBuilder();
 
-                public STATE onHeadersReceived(HttpResponseHeaders content) throws Exception {
+                public State onHeadersReceived(HttpResponseHeaders content) throws Exception {
                     builder.accumulate(content);
-                    return STATE.CONTINUE;
+                    return State.CONTINUE;
                 }
 
                 public void onThrowable(Throwable t) {
                 }
 
-                public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+                public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
                     builder.accumulate(content);
 
                     if (content.isLast()) {
                         content.markUnderlyingConnectionAsToBeClosed();
                     }
-                    return STATE.CONTINUE;
+                    return State.CONTINUE;
                 }
 
-                public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+                public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
                     builder.accumulate(responseStatus);
 
-                    return STATE.CONTINUE;
+                    return State.CONTINUE;
                 }
 
                 public Response onCompleted() throws Exception {
@@ -512,8 +470,6 @@ public Response onCompleted() throws Exception {
 
             assertNotNull(r);
             assertEquals(r.getStatusCode(), 200);
-        } finally {
-            c.close();
         }
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/AsyncStreamLifecycleTest.java b/api/src/test/java/org/asynchttpclient/AsyncStreamLifecycleTest.java
similarity index 89%
rename from api/src/test/java/org/asynchttpclient/async/AsyncStreamLifecycleTest.java
rename to api/src/test/java/org/asynchttpclient/AsyncStreamLifecycleTest.java
index 8e702da2d..a1658db11 100644
--- a/api/src/test/java/org/asynchttpclient/async/AsyncStreamLifecycleTest.java
+++ b/api/src/test/java/org/asynchttpclient/AsyncStreamLifecycleTest.java
@@ -13,18 +13,14 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient;
 
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertFalse;
 import static org.testng.Assert.assertTrue;
 import static org.testng.Assert.fail;
 
-import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.HttpResponseHeaders;
-import org.asynchttpclient.HttpResponseStatus;
 import org.eclipse.jetty.continuation.Continuation;
 import org.eclipse.jetty.continuation.ContinuationSupport;
 import org.eclipse.jetty.server.Request;
@@ -104,10 +100,9 @@ public void run() {
 
     @Test(groups = { "standalone", "default_provider" })
     public void testStream() throws IOException {
-        AsyncHttpClient ahc = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient ahc = getAsyncHttpClient(null)) {
             final AtomicBoolean err = new AtomicBoolean(false);
-            final LinkedBlockingQueue<String> queue = new LinkedBlockingQueue<String>();
+            final LinkedBlockingQueue<String> queue = new LinkedBlockingQueue<>();
             final AtomicBoolean status = new AtomicBoolean(false);
             final AtomicInteger headers = new AtomicInteger(0);
             final CountDownLatch latch = new CountDownLatch(1);
@@ -117,25 +112,25 @@ public void onThrowable(Throwable t) {
                     err.set(true);
                 }
 
-                public STATE onBodyPartReceived(HttpResponseBodyPart e) throws Exception {
+                public State onBodyPartReceived(HttpResponseBodyPart e) throws Exception {
                     if (e.length() != 0) {
                         String s = new String(e.getBodyPartBytes());
                         logger.info("got part: {}", s);
                         queue.put(s);
                     }
-                    return STATE.CONTINUE;
+                    return State.CONTINUE;
                 }
 
-                public STATE onStatusReceived(HttpResponseStatus e) throws Exception {
+                public State onStatusReceived(HttpResponseStatus e) throws Exception {
                     status.set(true);
-                    return STATE.CONTINUE;
+                    return State.CONTINUE;
                 }
 
-                public STATE onHeadersReceived(HttpResponseHeaders e) throws Exception {
+                public State onHeadersReceived(HttpResponseHeaders e) throws Exception {
                     if (headers.incrementAndGet() == 2) {
                         throw new Exception("Analyze this.");
                     }
-                    return STATE.CONTINUE;
+                    return State.CONTINUE;
                 }
 
                 public Object onCompleted() throws Exception {
@@ -154,8 +149,6 @@ public Object onCompleted() throws Exception {
             assertTrue(queue.contains("part2"));
             assertTrue(status.get());
             assertEquals(headers.get(), 1);
-        } finally {
-            ahc.close();
         }
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/AuthTimeoutTest.java b/api/src/test/java/org/asynchttpclient/AuthTimeoutTest.java
similarity index 78%
rename from api/src/test/java/org/asynchttpclient/async/AuthTimeoutTest.java
rename to api/src/test/java/org/asynchttpclient/AuthTimeoutTest.java
index 13d54d417..8f38e3266 100644
--- a/api/src/test/java/org/asynchttpclient/async/AuthTimeoutTest.java
+++ b/api/src/test/java/org/asynchttpclient/AuthTimeoutTest.java
@@ -10,25 +10,22 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.async;
-
-import static org.asynchttpclient.async.util.TestUtils.ADMIN;
-import static org.asynchttpclient.async.util.TestUtils.USER;
-import static org.asynchttpclient.async.util.TestUtils.addBasicAuthHandler;
-import static org.asynchttpclient.async.util.TestUtils.addDigestAuthHandler;
-import static org.asynchttpclient.async.util.TestUtils.findFreePort;
-import static org.asynchttpclient.async.util.TestUtils.newJettyHttpServer;
+package org.asynchttpclient;
+
+import static java.nio.charset.StandardCharsets.*;
+import static org.asynchttpclient.test.TestUtils.ADMIN;
+import static org.asynchttpclient.test.TestUtils.USER;
+import static org.asynchttpclient.test.TestUtils.addBasicAuthHandler;
+import static org.asynchttpclient.test.TestUtils.addDigestAuthHandler;
+import static org.asynchttpclient.test.TestUtils.findFreePort;
+import static org.asynchttpclient.test.TestUtils.newJettyHttpServer;
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertNotNull;
 import static org.testng.Assert.fail;
 
 import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.BoundRequestBuilder;
 import org.asynchttpclient.Realm;
-import org.asynchttpclient.Response;
 import org.asynchttpclient.util.AsyncHttpProviderUtils;
-import org.asynchttpclient.util.StandardCharsets;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.handler.AbstractHandler;
@@ -56,11 +53,11 @@ public void setUpGlobal() throws Exception {
         port2 = findFreePort();
 
         server = newJettyHttpServer(port1);
-        addBasicAuthHandler(server, false, configureHandler());
+        addBasicAuthHandler(server, configureHandler());
         server.start();
 
         server2 = newJettyHttpServer(port2);
-        addDigestAuthHandler(server2, true, configureHandler());
+        addDigestAuthHandler(server2, configureHandler());
         server2.start();
 
         logger.info("Local HTTP server started successfully");
@@ -80,8 +77,8 @@ public void handle(String s, Request r, HttpServletRequest request, HttpServletR
             OutputStream out = response.getOutputStream();
             if (request.getHeader("X-Content") != null) {
                 String content = request.getHeader("X-Content");
-                response.setHeader("Content-Length", String.valueOf(content.getBytes(StandardCharsets.UTF_8).length));
-                out.write(content.substring(1).getBytes(StandardCharsets.UTF_8));
+                response.setHeader("Content-Length", String.valueOf(content.getBytes(UTF_8).length));
+                out.write(content.substring(1).getBytes(UTF_8));
             } else {
                 response.setStatus(200);
             }
@@ -92,113 +89,89 @@ public void handle(String s, Request r, HttpServletRequest request, HttpServletR
 
     @Test(groups = { "standalone", "default_provider" }, enabled = false)
     public void basicAuthTimeoutTest() throws Exception {
-        AsyncHttpClient client = newClient();
-        try {
+        try (AsyncHttpClient client = newClient()) {
             Future<Response> f = execute(client, server, false);
             f.get();
             fail("expected timeout");
         } catch (Exception e) {
             inspectException(e);
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" }, enabled = false)
     public void basicPreemptiveAuthTimeoutTest() throws Exception {
-        AsyncHttpClient client = newClient();
-        try {
+        try (AsyncHttpClient client = newClient()) {
             Future<Response> f = execute(client, server, true);
             f.get();
             fail("expected timeout");
         } catch (Exception e) {
             inspectException(e);
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" }, enabled = false)
     public void digestAuthTimeoutTest() throws Exception {
-        AsyncHttpClient client = newClient();
-        try {
+        try (AsyncHttpClient client = newClient()) {
             Future<Response> f = execute(client, server2, false);
             f.get();
             fail("expected timeout");
         } catch (Exception e) {
             inspectException(e);
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" }, enabled = false)
     public void digestPreemptiveAuthTimeoutTest() throws Exception {
-        AsyncHttpClient client = newClient();
-        try {
+        try (AsyncHttpClient client = newClient()) {
             Future<Response> f = execute(client, server2, true);
             f.get();
             fail("expected timeout");
         } catch (Exception e) {
             inspectException(e);
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" }, enabled = false)
     public void basicFutureAuthTimeoutTest() throws Exception {
-        AsyncHttpClient client = newClient();
-        try {
+        try (AsyncHttpClient client = newClient()) {
             Future<Response> f = execute(client, server, false);
             f.get(1, TimeUnit.SECONDS);
             fail("expected timeout");
         } catch (Exception e) {
             inspectException(e);
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" }, enabled = false)
     public void basicFuturePreemptiveAuthTimeoutTest() throws Exception {
-        AsyncHttpClient client = newClient();
-        try {
+        try (AsyncHttpClient client = newClient()) {
             Future<Response> f = execute(client, server, true);
             f.get(1, TimeUnit.SECONDS);
             fail("expected timeout");
         } catch (Exception e) {
             inspectException(e);
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" }, enabled = false)
     public void digestFutureAuthTimeoutTest() throws Exception {
-        AsyncHttpClient client = newClient();
-        try {
+        try (AsyncHttpClient client = newClient()) {
             Future<Response> f = execute(client, server2, false);
             f.get(1, TimeUnit.SECONDS);
             fail("expected timeout");
         } catch (Exception e) {
             inspectException(e);
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" }, enabled = false)
     public void digestFuturePreemptiveAuthTimeoutTest() throws Exception {
-        AsyncHttpClient client = newClient();
-        try {
+        try (AsyncHttpClient client = newClient()) {
             Future<Response> f = execute(client, server2, true);
             f.get(1, TimeUnit.SECONDS);
             fail("expected timeout");
         } catch (Exception e) {
             inspectException(e);
-        } finally {
-            client.close();
         }
     }
 
@@ -211,7 +184,7 @@ protected void inspectException(Throwable t) {
     }
 
     private AsyncHttpClient newClient() {
-        return getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setPooledConnectionIdleTimeout(2000).setConnectionTimeout(20000).setRequestTimeout(2000).build());
+        return getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setPooledConnectionIdleTimeout(2000).setConnectTimeout(20000).setRequestTimeout(2000).build());
     }
 
     protected Future<Response> execute(AsyncHttpClient client, Server server, boolean preemptive) throws IOException {
diff --git a/api/src/test/java/org/asynchttpclient/async/BasicAuthTest.java b/api/src/test/java/org/asynchttpclient/BasicAuthTest.java
similarity index 73%
rename from api/src/test/java/org/asynchttpclient/async/BasicAuthTest.java
rename to api/src/test/java/org/asynchttpclient/BasicAuthTest.java
index 958361c6b..810c2c43b 100644
--- a/api/src/test/java/org/asynchttpclient/async/BasicAuthTest.java
+++ b/api/src/test/java/org/asynchttpclient/BasicAuthTest.java
@@ -13,33 +13,26 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package org.asynchttpclient.async;
-
-import static org.asynchttpclient.async.util.TestUtils.ADMIN;
-import static org.asynchttpclient.async.util.TestUtils.SIMPLE_TEXT_FILE;
-import static org.asynchttpclient.async.util.TestUtils.SIMPLE_TEXT_FILE_STRING;
-import static org.asynchttpclient.async.util.TestUtils.USER;
-import static org.asynchttpclient.async.util.TestUtils.addBasicAuthHandler;
-import static org.asynchttpclient.async.util.TestUtils.addDigestAuthHandler;
-import static org.asynchttpclient.async.util.TestUtils.findFreePort;
-import static org.asynchttpclient.async.util.TestUtils.newJettyHttpServer;
+package org.asynchttpclient;
+
+import static java.nio.charset.StandardCharsets.*;
+import static org.asynchttpclient.test.TestUtils.ADMIN;
+import static org.asynchttpclient.test.TestUtils.SIMPLE_TEXT_FILE;
+import static org.asynchttpclient.test.TestUtils.SIMPLE_TEXT_FILE_STRING;
+import static org.asynchttpclient.test.TestUtils.USER;
+import static org.asynchttpclient.test.TestUtils.addBasicAuthHandler;
+import static org.asynchttpclient.test.TestUtils.addDigestAuthHandler;
+import static org.asynchttpclient.test.TestUtils.findFreePort;
+import static org.asynchttpclient.test.TestUtils.newJettyHttpServer;
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertNotNull;
 
-import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.BoundRequestBuilder;
-import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.HttpResponseHeaders;
-import org.asynchttpclient.HttpResponseStatus;
 import org.asynchttpclient.Realm;
 import org.asynchttpclient.Realm.AuthScheme;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.SimpleAsyncHttpClient;
-import org.asynchttpclient.consumers.AppendableBodyConsumer;
-import org.asynchttpclient.generators.InputStreamBodyGenerator;
-import org.asynchttpclient.util.StandardCharsets;
+import org.asynchttpclient.request.body.generator.InputStreamBodyGenerator;
+import org.asynchttpclient.simple.SimpleAsyncHttpClient;
+import org.asynchttpclient.simple.consumer.AppendableBodyConsumer;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.handler.AbstractHandler;
@@ -68,8 +61,6 @@
     private Server serverNoAuth;
     private int portNoAuth;
 
-    public abstract String getProviderClass();
-
     @BeforeClass(alwaysRun = true)
     @Override
     public void setUpGlobal() throws Exception {
@@ -78,11 +69,11 @@ public void setUpGlobal() throws Exception {
         portNoAuth = findFreePort();
 
         server = newJettyHttpServer(port1);
-        addBasicAuthHandler(server, false, configureHandler());
+        addBasicAuthHandler(server, configureHandler());
         server.start();
 
         server2 = newJettyHttpServer(port2);
-        addDigestAuthHandler(server2, true, new RedirectHandler());
+        addDigestAuthHandler(server2, new RedirectHandler());
         server2.start();
 
         // need noAuth server to verify the preemptive auth mode (see basicAuthTetPreemtiveTest) 
@@ -126,25 +117,24 @@ public AbstractHandler configureHandler() throws Exception {
         public void handle(String s, Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
 
             LOGGER.info("request: " + request.getRequestURI());
-            if ("/uff".equals(request.getRequestURI())) {
 
+            if ("/uff".equals(request.getRequestURI())) {
                 LOGGER.info("redirect to /bla");
                 response.setStatus(302);
+                response.setContentLength(0);
                 response.setHeader("Location", "/bla");
-                response.getOutputStream().flush();
-                response.getOutputStream().close();
-
-                return;
 
             } else {
                 LOGGER.info("got redirected" + request.getRequestURI());
+                response.setStatus(200);
                 response.addHeader("X-Auth", request.getHeader("Authorization"));
                 response.addHeader("X-Content-Length", String.valueOf(request.getContentLength()));
-                response.setStatus(200);
-                response.getOutputStream().write("content".getBytes(StandardCharsets.UTF_8));
-                response.getOutputStream().flush();
-                response.getOutputStream().close();
+                byte[] b = "content".getBytes(UTF_8);
+                response.setContentLength(b.length);
+                response.getOutputStream().write(b);
             }
+            response.getOutputStream().flush();
+            response.getOutputStream().close();
         }
     }
 
@@ -154,25 +144,27 @@ public void handle(String s, Request r, HttpServletRequest request, HttpServletR
 
             if (request.getHeader("X-401") != null) {
                 response.setStatus(401);
-                response.getOutputStream().flush();
-                response.getOutputStream().close();
-
-                return;
-            }
-            response.addHeader("X-Auth", request.getHeader("Authorization"));
-            response.addHeader("X-Content-Length", String.valueOf(request.getContentLength()));
-            response.setStatus(200);
+                response.setContentLength(0);
 
-            int size = 10 * 1024;
-            if (request.getContentLength() > 0) {
-                size = request.getContentLength();
-            }
-            byte[] bytes = new byte[size];
-            if (bytes.length > 0) {
-                int read = request.getInputStream().read(bytes);
-                if (read > 0) {
-                    response.getOutputStream().write(bytes, 0, read);
+            } else {
+                response.addHeader("X-Auth", request.getHeader("Authorization"));
+                response.addHeader("X-Content-Length", String.valueOf(request.getContentLength()));
+                response.setStatus(200);
+    
+                int size = 10 * 1024;
+                if (request.getContentLength() > 0) {
+                    size = request.getContentLength();
+                }
+                byte[] bytes = new byte[size];
+                int contentLength = 0;
+                if (bytes.length > 0) {
+                    int read = request.getInputStream().read(bytes);
+                    if (read > 0) {
+                        contentLength = read;
+                        response.getOutputStream().write(bytes, 0, read);
+                    }
                 }
+                response.setContentLength(contentLength);
             }
             response.getOutputStream().flush();
             response.getOutputStream().close();
@@ -181,8 +173,7 @@ public void handle(String s, Request r, HttpServletRequest request, HttpServletR
 
     @Test(groups = { "standalone", "default_provider" })
     public void basicAuthTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             Future<Response> f = client.prepareGet(getTargetUrl())//
                     .setRealm((new Realm.RealmBuilder()).setPrincipal(USER).setPassword(ADMIN).build())//
                     .execute();
@@ -190,15 +181,12 @@ public void basicAuthTest() throws IOException, ExecutionException, TimeoutExcep
             assertNotNull(resp);
             assertNotNull(resp.getHeader("X-Auth"));
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void redirectAndBasicAuthTest() throws Exception, ExecutionException, TimeoutException, InterruptedException {
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirect(true).setMaxRedirects(10).build());
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirect(true).setMaxRedirects(10).build())) {
             Future<Response> f = client.prepareGet(getTargetUrl2())//
                     .setRealm((new Realm.RealmBuilder()).setPrincipal(USER).setPassword(ADMIN).build())//
                     .execute();
@@ -206,16 +194,12 @@ public void redirectAndBasicAuthTest() throws Exception, ExecutionException, Tim
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
             assertNotNull(resp);
             assertNotNull(resp.getHeader("X-Auth"));
-
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void basic401Test() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             BoundRequestBuilder r = client.prepareGet(getTargetUrl())//
                     .setHeader("X-401", "401")//
                     .setRealm((new Realm.RealmBuilder()).setPrincipal(USER).setPassword(ADMIN).build());
@@ -228,21 +212,21 @@ public void onThrowable(Throwable t) {
 
                 }
 
-                public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-                    return STATE.CONTINUE;
+                public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+                    return State.CONTINUE;
                 }
 
-                public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+                public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
                     this.status = responseStatus;
 
                     if (status.getStatusCode() != 200) {
-                        return STATE.ABORT;
+                        return State.ABORT;
                     }
-                    return STATE.CONTINUE;
+                    return State.CONTINUE;
                 }
 
-                public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
-                    return STATE.CONTINUE;
+                public State onHeadersReceived(HttpResponseHeaders headers) throws Exception {
+                    return State.CONTINUE;
                 }
 
                 public Integer onCompleted() throws Exception {
@@ -252,15 +236,12 @@ public Integer onCompleted() throws Exception {
             Integer statusCode = f.get(10, TimeUnit.SECONDS);
             assertNotNull(statusCode);
             assertEquals(statusCode.intValue(), 401);
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void basicAuthTestPreemtiveTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
         	// send the request to the no-auth endpoint to be able to verify the auth header is
         	// really sent preemptively for the initial call.
             Future<Response> f = client.prepareGet(getTargetUrlNoAuth())//
@@ -271,15 +252,12 @@ public void basicAuthTestPreemtiveTest() throws IOException, ExecutionException,
             assertNotNull(resp);
             assertNotNull(resp.getHeader("X-Auth"));
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void basicAuthNegativeTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             Future<Response> f = client.prepareGet(getTargetUrl())//
                     .setRealm((new Realm.RealmBuilder()).setPrincipal("fake").setPassword(ADMIN).build())//
                     .execute();
@@ -287,15 +265,12 @@ public void basicAuthNegativeTest() throws IOException, ExecutionException, Time
             Response resp = f.get(3, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), 401);
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void basicAuthInputStreamTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             Future<Response> f = client.preparePost(getTargetUrl())//
                     .setBody(new ByteArrayInputStream("test".getBytes()))//
                     .setRealm((new Realm.RealmBuilder()).setPrincipal(USER).setPassword(ADMIN).build())//
@@ -306,15 +281,12 @@ public void basicAuthInputStreamTest() throws IOException, ExecutionException, T
             assertNotNull(resp.getHeader("X-Auth"));
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
             assertEquals(resp.getResponseBody(), "test");
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void basicAuthFileTest() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             Future<Response> f = client.preparePost(getTargetUrl())//
                     .setBody(SIMPLE_TEXT_FILE)//
                     .setRealm((new Realm.RealmBuilder()).setPrincipal(USER).setPassword(ADMIN).build())//
@@ -325,15 +297,12 @@ public void basicAuthFileTest() throws Exception {
             assertNotNull(resp.getHeader("X-Auth"));
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
             assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void basicAuthAsyncConfigTest() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRealm((new Realm.RealmBuilder()).setPrincipal(USER).setPassword(ADMIN).build()).build());
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRealm((new Realm.RealmBuilder()).setPrincipal(USER).setPassword(ADMIN).build()).build())) {
             Future<Response> f = client.preparePost(getTargetUrl())//
                     .setBody(SIMPLE_TEXT_FILE_STRING)//
                     .execute();
@@ -343,15 +312,12 @@ public void basicAuthAsyncConfigTest() throws Exception {
             assertNotNull(resp.getHeader("X-Auth"));
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
             assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void basicAuthFileNoKeepAliveTest() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setAllowPoolingConnections(false).build());
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setAllowPoolingConnections(false).build())) {
 
             Future<Response> f = client.preparePost(getTargetUrl())//
                     .setBody(SIMPLE_TEXT_FILE)//
@@ -363,17 +329,14 @@ public void basicAuthFileNoKeepAliveTest() throws Exception {
             assertNotNull(resp.getHeader("X-Auth"));
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
             assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void stringBuilderBodyConsumerTest() throws Exception {
 
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setProviderClass(getProviderClass()).setRealmPrincipal(USER).setRealmPassword(ADMIN)
-                .setUrl(getTargetUrl()).setHeader("Content-Type", "text/html").build();
-        try {
+        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setRealmPrincipal(USER).setRealmPassword(ADMIN)
+                .setUrl(getTargetUrl()).setHeader("Content-Type", "text/html").build()) {
             StringBuilder s = new StringBuilder();
             Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())), new AppendableBodyConsumer(s));
 
@@ -382,15 +345,12 @@ public void stringBuilderBodyConsumerTest() throws Exception {
             assertEquals(s.toString(), MY_MESSAGE);
             assertEquals(response.getStatusCode(), HttpServletResponse.SC_OK);
             assertNotNull(response.getHeader("X-Auth"));
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void noneAuthTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             BoundRequestBuilder r = client.prepareGet(getTargetUrl()).setRealm((new Realm.RealmBuilder()).setPrincipal(USER).setPassword(ADMIN).build());
 
             Future<Response> f = r.execute();
@@ -398,8 +358,6 @@ public void noneAuthTest() throws IOException, ExecutionException, TimeoutExcept
             assertNotNull(resp);
             assertNotNull(resp.getHeader("X-Auth"));
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        } finally {
-            client.close();
         }
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/BasicHttpsTest.java b/api/src/test/java/org/asynchttpclient/BasicHttpsTest.java
similarity index 51%
rename from api/src/test/java/org/asynchttpclient/async/BasicHttpsTest.java
rename to api/src/test/java/org/asynchttpclient/BasicHttpsTest.java
index 9f13a7b51..770157f64 100644
--- a/api/src/test/java/org/asynchttpclient/async/BasicHttpsTest.java
+++ b/api/src/test/java/org/asynchttpclient/BasicHttpsTest.java
@@ -13,30 +13,25 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient;
 
-import static org.asynchttpclient.async.util.TestUtils.SIMPLE_TEXT_FILE;
-import static org.asynchttpclient.async.util.TestUtils.SIMPLE_TEXT_FILE_STRING;
-import static org.asynchttpclient.async.util.TestUtils.createSSLContext;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-import static org.testng.Assert.assertTrue;
+import static org.asynchttpclient.test.TestUtils.SIMPLE_TEXT_FILE;
+import static org.asynchttpclient.test.TestUtils.SIMPLE_TEXT_FILE_STRING;
+import static org.asynchttpclient.test.TestUtils.createSSLContext;
+import static org.testng.Assert.*;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig.Builder;
-import org.asynchttpclient.Response;
-import org.testng.Assert;
+import org.asynchttpclient.test.EventCollectingHandler;
 import org.testng.annotations.Test;
 
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLHandshakeException;
-import javax.net.ssl.SSLSession;
 import javax.servlet.http.HttpServletResponse;
 
-import java.io.IOException;
-import java.net.ConnectException;
+import java.util.Arrays;
+import java.util.List;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 public abstract class BasicHttpsTest extends AbstractBasicHttpsTest {
@@ -48,21 +43,17 @@ protected String getTargetUrl() {
     @Test(groups = { "standalone", "default_provider" })
     public void zeroCopyPostTest() throws Exception {
 
-        final AsyncHttpClient client = getAsyncHttpClient(new Builder().setSSLContext(createSSLContext(new AtomicBoolean(true))).build());
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(new Builder().setSSLContext(createSSLContext(new AtomicBoolean(true))).build())) {
             Response resp = client.preparePost(getTargetUrl()).setBody(SIMPLE_TEXT_FILE).setHeader("Content-Type", "text/html").execute().get();
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
             assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void multipleSSLRequestsTest() throws Exception {
-        final AsyncHttpClient c = getAsyncHttpClient(new Builder().setSSLContext(createSSLContext(new AtomicBoolean(true))).build());
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(new Builder().setSSLContext(createSSLContext(new AtomicBoolean(true))).build())) {
             String body = "hello there";
 
             // once
@@ -74,15 +65,12 @@ public void multipleSSLRequestsTest() throws Exception {
             response = c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
 
             assertEquals(response.getResponseBody(), body);
-        } finally {
-            c.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void multipleSSLWithoutCacheTest() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(new Builder().setSSLContext(createSSLContext(new AtomicBoolean(true))).setAllowPoolingSslConnections(false).build());
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(new Builder().setSSLContext(createSSLContext(new AtomicBoolean(true))).setAllowPoolingSslConnections(false).build())) {
             String body = "hello there";
             c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute();
 
@@ -91,70 +79,66 @@ public void multipleSSLWithoutCacheTest() throws Exception {
             Response response = c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute().get();
 
             assertEquals(response.getResponseBody(), body);
-        } finally {
-            c.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void reconnectsAfterFailedCertificationPath() throws Exception {
-        AtomicBoolean trusted = new AtomicBoolean(false);
-        AsyncHttpClient c = getAsyncHttpClient(new Builder().setSSLContext(createSSLContext(trusted)).build());
-        try {
+        
+        AtomicBoolean trust = new AtomicBoolean(false);
+        try (AsyncHttpClient client = getAsyncHttpClient(new Builder().setSSLContext(createSSLContext(trust)).build())) {
             String body = "hello there";
 
             // first request fails because server certificate is rejected
             Throwable cause = null;
             try {
-                c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
+                client.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
             } catch (final ExecutionException e) {
                 cause = e.getCause();
-                if (cause instanceof ConnectException) {
-                    //assertNotNull(cause.getCause());
-                    assertTrue(cause.getCause() instanceof SSLHandshakeException, "Expected an SSLHandshakeException, got a " + cause.getCause());
-                } else {
-                   assertTrue(cause instanceof IOException, "Expected an IOException, got a " + cause);
-                }
             }
             assertNotNull(cause);
 
-            trusted.set(true);
-
             // second request should succeed
-            Response response = c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
+            trust.set(true);
+            Response response = client.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
 
             assertEquals(response.getResponseBody(), body);
-        } finally {
-            c.close();
         }
     }
 
-    @Test(timeOut = 5000)
-    public void failInstantlyIfHostNamesDiffer() throws Exception {
-        AsyncHttpClient client = null;
-
-        try {
-            final Builder builder = new Builder().setHostnameVerifier(new HostnameVerifier() {
-
-                public boolean verify(String arg0, SSLSession arg1) {
-                    return false;
-                }
-            }).setRequestTimeout(20000);
-
-            client = getAsyncHttpClient(builder.build());
+    @Test(timeOut = 2000, expectedExceptions = { Exception.class } )
+    public void failInstantlyIfNotAllowedSelfSignedCertificate() throws Throwable {
 
+        try (AsyncHttpClient client = getAsyncHttpClient(new Builder().setRequestTimeout(2000).build())) {
             try {
-            client.prepareGet("https://github.com/AsyncHttpClient/async-http-client/issues/355").execute().get(TIMEOUT, TimeUnit.SECONDS);
-            
-            Assert.assertTrue(false, "Shouldn't be here: should get an Exception");
+                client.prepareGet(getTargetUrl()).execute().get(TIMEOUT, TimeUnit.SECONDS);
             } catch (ExecutionException e) {
-                Assert.assertTrue(e.getCause() instanceof ConnectException, "Cause should be a ConnectException");
-            } catch (Exception e) {
-                Assert.assertTrue(false, "Shouldn't be here: should get a ConnectException wrapping a ConnectException");
+                throw e.getCause() != null ? e.getCause() : e;
             }
-            
-        } finally {
-            client.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void testNormalEventsFired() throws InterruptedException, TimeoutException, ExecutionException {
+        try (AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setSSLContext(createSSLContext(new AtomicBoolean(true))).build())) {
+            EventCollectingHandler handler = new EventCollectingHandler();
+            client.preparePost(getTargetUrl()).setBody("whatever").execute(handler).get(3, TimeUnit.SECONDS);
+            handler.waitForCompletion(3, TimeUnit.SECONDS);
+
+            List<String> expectedEvents = Arrays.asList(
+                    "ConnectionPool",
+                    "ConnectionOpen",
+                    "DnsResolved",
+                    "SslHandshakeCompleted",
+                    "ConnectionOpened",
+                    "RequestSend",
+                    "HeadersWritten",
+                    "StatusReceived",
+                    "HeadersReceived",
+                    "ConnectionOffer",
+                    "Completed");
+
+            assertEquals(handler.firedEvents, expectedEvents, "Got " + Arrays.toString(handler.firedEvents.toArray()));
         }
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/ByteBufferCapacityTest.java b/api/src/test/java/org/asynchttpclient/ByteBufferCapacityTest.java
similarity index 91%
rename from api/src/test/java/org/asynchttpclient/async/ByteBufferCapacityTest.java
rename to api/src/test/java/org/asynchttpclient/ByteBufferCapacityTest.java
index 7223357ba..0bf29de2b 100644
--- a/api/src/test/java/org/asynchttpclient/async/ByteBufferCapacityTest.java
+++ b/api/src/test/java/org/asynchttpclient/ByteBufferCapacityTest.java
@@ -10,16 +10,14 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient;
 
-import static org.asynchttpclient.async.util.TestUtils.createTempFile;
+import static org.asynchttpclient.test.TestUtils.createTempFile;
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertNotNull;
 import static org.testng.Assert.fail;
 
 import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.Response;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.Test;
@@ -75,15 +73,14 @@ public AbstractHandler configureHandler() throws Exception {
 
     @Test(groups = { "standalone", "default_provider" })
     public void basicByteBufferTest() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
             File largeFile = createTempFile(1024 * 100 * 10);
             final AtomicInteger byteReceived = new AtomicInteger();
 
             try {
                 Response response = c.preparePut(getTargetUrl()).setBody(largeFile).execute(new AsyncCompletionHandlerAdapter() {
                     @Override
-                    public STATE onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
+                    public State onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
                         byteReceived.addAndGet(content.getBodyByteBuffer().capacity());
                         return super.onBodyPartReceived(content);
                     }
@@ -98,8 +95,6 @@ public STATE onBodyPartReceived(final HttpResponseBodyPart content) throws Excep
             } catch (IOException ex) {
                 fail("Should have timed out");
             }
-        } finally {
-            c.close();
         }
     }
 
diff --git a/api/src/test/java/org/asynchttpclient/async/ComplexClientTest.java b/api/src/test/java/org/asynchttpclient/ComplexClientTest.java
similarity index 86%
rename from api/src/test/java/org/asynchttpclient/async/ComplexClientTest.java
rename to api/src/test/java/org/asynchttpclient/ComplexClientTest.java
index 7ecc68efb..adf55bee2 100644
--- a/api/src/test/java/org/asynchttpclient/async/ComplexClientTest.java
+++ b/api/src/test/java/org/asynchttpclient/ComplexClientTest.java
@@ -13,12 +13,11 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient;
 
 import static org.testng.Assert.assertEquals;
 
 import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.Response;
 import org.testng.annotations.Test;
 
 import java.util.concurrent.TimeUnit;
@@ -27,8 +26,7 @@
 
     @Test(groups = { "standalone", "default_provider" })
     public void multipleRequestsTest() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
             String body = "hello there";
 
             // once
@@ -40,22 +38,15 @@ public void multipleRequestsTest() throws Exception {
             response = c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
 
             assertEquals(response.getResponseBody(), body);
-        } finally {
-            c.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void urlWithoutSlashTest() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
             String body = "hello there";
-
             Response response = c.preparePost(String.format("http://127.0.0.1:%d/foo/test", port1)).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
-
             assertEquals(response.getResponseBody(), body);
-        } finally {
-            c.close();
         }
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/DigestAuthTest.java b/api/src/test/java/org/asynchttpclient/DigestAuthTest.java
similarity index 83%
rename from api/src/test/java/org/asynchttpclient/async/DigestAuthTest.java
rename to api/src/test/java/org/asynchttpclient/DigestAuthTest.java
index 2753c6062..9952c6d82 100644
--- a/api/src/test/java/org/asynchttpclient/async/DigestAuthTest.java
+++ b/api/src/test/java/org/asynchttpclient/DigestAuthTest.java
@@ -10,19 +10,18 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient;
 
-import static org.asynchttpclient.async.util.TestUtils.ADMIN;
-import static org.asynchttpclient.async.util.TestUtils.USER;
-import static org.asynchttpclient.async.util.TestUtils.addDigestAuthHandler;
-import static org.asynchttpclient.async.util.TestUtils.findFreePort;
-import static org.asynchttpclient.async.util.TestUtils.newJettyHttpServer;
+import static org.asynchttpclient.test.TestUtils.ADMIN;
+import static org.asynchttpclient.test.TestUtils.USER;
+import static org.asynchttpclient.test.TestUtils.addDigestAuthHandler;
+import static org.asynchttpclient.test.TestUtils.findFreePort;
+import static org.asynchttpclient.test.TestUtils.newJettyHttpServer;
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertNotNull;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.Realm;
-import org.asynchttpclient.Response;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.BeforeClass;
@@ -46,7 +45,7 @@ public void setUpGlobal() throws Exception {
         port1 = findFreePort();
 
         server = newJettyHttpServer(port1);
-        addDigestAuthHandler(server, false, configureHandler());
+        addDigestAuthHandler(server, configureHandler());
         server.start();
         logger.info("Local HTTP server started successfully");
     }
@@ -68,8 +67,7 @@ public AbstractHandler configureHandler() throws Exception {
 
     @Test(groups = { "standalone", "default_provider" })
     public void digestAuthTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             Future<Response> f = client.prepareGet("http://127.0.0.1:" + port1 + "/")//
                     .setRealm(new Realm.RealmBuilder().setPrincipal(USER).setPassword(ADMIN).setRealmName("MyRealm").setScheme(Realm.AuthScheme.DIGEST).build())//
                     .execute();
@@ -77,15 +75,12 @@ public void digestAuthTest() throws IOException, ExecutionException, TimeoutExce
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
             assertNotNull(resp.getHeader("X-Auth"));
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void digestAuthTestWithoutScheme() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             Future<Response> f = client.prepareGet("http://127.0.0.1:" + port1 + "/")//
                     .setRealm(new Realm.RealmBuilder().setPrincipal(USER).setPassword(ADMIN).setRealmName("MyRealm").build())//
                     .execute();
@@ -93,23 +88,18 @@ public void digestAuthTestWithoutScheme() throws IOException, ExecutionException
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
             assertNotNull(resp.getHeader("X-Auth"));
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void digestAuthNegativeTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             Future<Response> f = client.prepareGet("http://127.0.0.1:" + port1 + "/")//
                     .setRealm(new Realm.RealmBuilder().setPrincipal("fake").setPassword(ADMIN).setScheme(Realm.AuthScheme.DIGEST).build())//
                     .execute();
             Response resp = f.get(20, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), 401);
-        } finally {
-            client.close();
         }
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/ErrorResponseTest.java b/api/src/test/java/org/asynchttpclient/ErrorResponseTest.java
similarity index 88%
rename from api/src/test/java/org/asynchttpclient/async/ErrorResponseTest.java
rename to api/src/test/java/org/asynchttpclient/ErrorResponseTest.java
index 4759564cf..3a3120f92 100644
--- a/api/src/test/java/org/asynchttpclient/async/ErrorResponseTest.java
+++ b/api/src/test/java/org/asynchttpclient/ErrorResponseTest.java
@@ -14,14 +14,13 @@
  * under the License.
  *
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient;
 
+import static java.nio.charset.StandardCharsets.*;
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertNotNull;
 
 import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.util.StandardCharsets;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.Test;
@@ -52,7 +51,7 @@ public void handle(String s, Request r, HttpServletRequest request, HttpServletR
             response.setContentType("text/plain");
             response.setStatus(400);
             OutputStream out = response.getOutputStream();
-            out.write(BAD_REQUEST_STR.getBytes(StandardCharsets.UTF_8));
+            out.write(BAD_REQUEST_STR.getBytes(UTF_8));
             out.flush();
         }
     }
@@ -64,15 +63,12 @@ public AbstractHandler configureHandler() throws Exception {
 
     @Test(groups = { "standalone", "default_provider" })
     public void testQueryParameters() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             Future<Response> f = client.prepareGet("http://127.0.0.1:" + port1 + "/foo").addHeader("Accepts", "*/*").execute();
             Response resp = f.get(3, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), 400);
             assertEquals(resp.getResponseBody(), BAD_REQUEST_STR);
-        } finally {
-            client.close();
         }
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/Expect100ContinueTest.java b/api/src/test/java/org/asynchttpclient/Expect100ContinueTest.java
similarity index 88%
rename from api/src/test/java/org/asynchttpclient/async/Expect100ContinueTest.java
rename to api/src/test/java/org/asynchttpclient/Expect100ContinueTest.java
index cb9694a81..3c0cb0ade 100644
--- a/api/src/test/java/org/asynchttpclient/async/Expect100ContinueTest.java
+++ b/api/src/test/java/org/asynchttpclient/Expect100ContinueTest.java
@@ -13,15 +13,14 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient;
 
-import static org.asynchttpclient.async.util.TestUtils.SIMPLE_TEXT_FILE;
-import static org.asynchttpclient.async.util.TestUtils.SIMPLE_TEXT_FILE_STRING;
+import static org.asynchttpclient.test.TestUtils.SIMPLE_TEXT_FILE;
+import static org.asynchttpclient.test.TestUtils.SIMPLE_TEXT_FILE_STRING;
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertNotNull;
 
 import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.Response;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.Test;
@@ -63,15 +62,12 @@ public AbstractHandler configureHandler() throws Exception {
 
     @Test(groups = { "standalone", "default_provider" })
     public void Expect100Continue() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             Future<Response> f = client.preparePut("http://127.0.0.1:" + port1 + "/").setHeader("Expect", "100-continue").setBody(SIMPLE_TEXT_FILE).execute();
             Response resp = f.get();
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
             assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
-        } finally {
-            client.close();
         }
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/FluentCaseInsensitiveStringsMapTest.java b/api/src/test/java/org/asynchttpclient/FluentCaseInsensitiveStringsMapTest.java
similarity index 87%
rename from api/src/test/java/org/asynchttpclient/async/FluentCaseInsensitiveStringsMapTest.java
rename to api/src/test/java/org/asynchttpclient/FluentCaseInsensitiveStringsMapTest.java
index aac30159b..710c2e401 100644
--- a/api/src/test/java/org/asynchttpclient/async/FluentCaseInsensitiveStringsMapTest.java
+++ b/api/src/test/java/org/asynchttpclient/FluentCaseInsensitiveStringsMapTest.java
@@ -13,7 +13,7 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient;
 
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertNull;
@@ -45,7 +45,7 @@ public void normalTest() {
         map.add("foo", "bar");
         map.add("baz", Arrays.asList("foo", "bar"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -61,7 +61,7 @@ public void nameCaseTest() {
         map.add("fOO", "bAr");
         map.add("Baz", Arrays.asList("fOo", "bar"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("fOO", "Baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("fOO", "Baz")));
 
         assertEquals(map.getFirstValue("fOO"), "bAr");
         assertEquals(map.getJoinedValue("fOO", ", "), "bAr");
@@ -92,7 +92,7 @@ public void sameKeyMultipleTimesTest() {
         map.add("Foo", Arrays.asList("bar"));
         map.add("fOO", "bla", "blubb");
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo")));
 
         assertEquals(map.getFirstValue("foo"), "baz,foo");
         assertEquals(map.getJoinedValue("foo", ", "), "baz,foo, bar, bla, blubb");
@@ -111,7 +111,7 @@ public void emptyValueTest() {
 
         map.add("foo", "");
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo")));
         assertEquals(map.getFirstValue("foo"), "");
         assertEquals(map.getJoinedValue("foo", ", "), "");
         assertEquals(map.get("foo"), Arrays.asList(""));
@@ -130,7 +130,7 @@ public void nullValueTest() {
 
     @Test
     public void mapConstructorTest() {
-        Map<String, Collection<String>> headerMap = new LinkedHashMap<String, Collection<String>>();
+        Map<String, Collection<String>> headerMap = new LinkedHashMap<>();
 
         headerMap.put("foo", Arrays.asList("baz,foo"));
         headerMap.put("baz", Arrays.asList("bar"));
@@ -142,7 +142,7 @@ public void mapConstructorTest() {
         headerMap.remove("bar");
         headerMap.remove("baz");
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz", "bar")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz", "bar")));
         assertEquals(map.getFirstValue("foo"), "baz,foo");
         assertEquals(map.getJoinedValue("foo", ", "), "baz,foo");
         assertEquals(map.get("foo"), Arrays.asList("baz,foo"));
@@ -176,7 +176,7 @@ public void copyConstructorTest() {
         srcHeaders.delete("baz");
         assertTrue(srcHeaders.keySet().isEmpty());
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz", "bar")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz", "bar")));
         assertEquals(map.getFirstValue("foo"), "baz,foo");
         assertEquals(map.getJoinedValue("foo", ", "), "baz,foo");
         assertEquals(map.get("foo"), Arrays.asList("baz,foo"));
@@ -202,7 +202,7 @@ public void deleteTest() {
         map.add("foo", "bar");
         map.add("baz", Arrays.asList("foo", "bar"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -212,13 +212,13 @@ public void deleteTest() {
 
         map.delete("bAz");
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
         assertNull(map.getFirstValue("baz"));
         assertNull(map.getJoinedValue("baz", ", "));
-        assertNull(map.get("baz"));
+        assertTrue(map.get("baz").isEmpty());
     }
 
     @Test
@@ -228,7 +228,7 @@ public void deleteUndefinedKeyTest() {
         map.add("foo", "bar");
         map.add("baz", Arrays.asList("foo", "bar"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -238,7 +238,7 @@ public void deleteUndefinedKeyTest() {
 
         map.delete("bar");
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -254,7 +254,7 @@ public void deleteNullTest() {
         map.add("foo", "bar");
         map.add("baz", Arrays.asList("foo", "bar"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -264,7 +264,7 @@ public void deleteNullTest() {
 
         map.delete(null);
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -280,7 +280,7 @@ public void deleteAllArrayTest() {
         map.add("foo", "bar");
         map.add("baz", Arrays.asList("foo", "bar"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -290,13 +290,13 @@ public void deleteAllArrayTest() {
 
         map.deleteAll("bAz", "Boo");
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
         assertNull(map.getFirstValue("baz"));
         assertNull(map.getJoinedValue("baz", ", "));
-        assertNull(map.get("baz"));
+        assertTrue(map.get("baz").isEmpty());
     }
 
     @Test
@@ -306,7 +306,7 @@ public void deleteAllCollectionTest() {
         map.add("foo", "bar");
         map.add("baz", Arrays.asList("foo", "bar"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -319,10 +319,10 @@ public void deleteAllCollectionTest() {
         assertEquals(map.keySet(), Collections.<String> emptyList());
         assertNull(map.getFirstValue("foo"));
         assertNull(map.getJoinedValue("foo", ", "));
-        assertNull(map.get("foo"));
+        assertTrue(map.get("foo").isEmpty());
         assertNull(map.getFirstValue("baz"));
         assertNull(map.getJoinedValue("baz", ", "));
-        assertNull(map.get("baz"));
+        assertTrue(map.get("baz").isEmpty());
     }
 
     @Test
@@ -332,7 +332,7 @@ public void deleteAllNullArrayTest() {
         map.add("foo", "bar");
         map.add("baz", Arrays.asList("foo", "bar"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -342,7 +342,7 @@ public void deleteAllNullArrayTest() {
 
         map.deleteAll((String[]) null);
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -358,7 +358,7 @@ public void deleteAllNullCollectionTest() {
         map.add("foo", "bar");
         map.add("baz", Arrays.asList("foo", "bar"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -368,7 +368,7 @@ public void deleteAllNullCollectionTest() {
 
         map.deleteAll((Collection<String>) null);
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -384,7 +384,7 @@ public void replaceTest() {
         map.add("foo", "bar");
         map.add("baz", Arrays.asList("foo", "bar"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -394,7 +394,7 @@ public void replaceTest() {
 
         map.replaceWith("Foo", "blub", "bla");
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("Foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("Foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "blub");
         assertEquals(map.getJoinedValue("foo", ", "), "blub, bla");
         assertEquals(map.get("foo"), Arrays.asList("blub", "bla"));
@@ -410,7 +410,7 @@ public void replaceUndefinedTest() {
         map.add("foo", "bar");
         map.add("baz", Arrays.asList("foo", "bar"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -420,7 +420,7 @@ public void replaceUndefinedTest() {
 
         map.replaceWith("bar", Arrays.asList("blub"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz", "bar")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz", "bar")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -439,7 +439,7 @@ public void replaceNullTest() {
         map.add("foo", "bar");
         map.add("baz", Arrays.asList("foo", "bar"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -449,7 +449,7 @@ public void replaceNullTest() {
 
         map.replaceWith(null, Arrays.asList("blub"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -465,7 +465,7 @@ public void replaceValueWithNullTest() {
         map.add("foo", "bar");
         map.add("baz", Arrays.asList("foo", "bar"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -475,13 +475,13 @@ public void replaceValueWithNullTest() {
 
         map.replaceWith("baZ", (Collection<String>) null);
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
         assertNull(map.getFirstValue("baz"));
         assertNull(map.getJoinedValue("baz", ", "));
-        assertNull(map.get("baz"));
+        assertTrue(map.get("baz").isEmpty());
     }
 
     @Test
@@ -492,7 +492,7 @@ public void replaceAllMapTest1() {
         map.add("bar", "foo, bar", "baz");
         map.add("baz", Arrays.asList("foo", "bar"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "bar", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "bar", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -505,7 +505,7 @@ public void replaceAllMapTest1() {
 
         map.replaceAll(new FluentCaseInsensitiveStringsMap().add("Bar", "baz").add("Boo", "blub", "bla"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "Bar", "baz", "Boo")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "Bar", "baz", "Boo")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -528,7 +528,7 @@ public void replaceAllTest2() {
         map.add("bar", "foo, bar", "baz");
         map.add("baz", Arrays.asList("foo", "bar"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "bar", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "bar", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -539,16 +539,16 @@ public void replaceAllTest2() {
         assertEquals(map.getJoinedValue("baz", ", "), "foo, bar");
         assertEquals(map.get("baz"), Arrays.asList("foo", "bar"));
 
-        LinkedHashMap<String, Collection<String>> newValues = new LinkedHashMap<String, Collection<String>>();
+        LinkedHashMap<String, Collection<String>> newValues = new LinkedHashMap<>();
 
         newValues.put("Bar", Arrays.asList("baz"));
         newValues.put("Foo", null);
         map.replaceAll(newValues);
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("Bar", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("Bar", "baz")));
         assertNull(map.getFirstValue("foo"));
         assertNull(map.getJoinedValue("foo", ", "));
-        assertNull(map.get("foo"));
+        assertTrue(map.get("foo").isEmpty());
         assertEquals(map.getFirstValue("bar"), "baz");
         assertEquals(map.getJoinedValue("bar", ", "), "baz");
         assertEquals(map.get("bar"), Arrays.asList("baz"));
@@ -565,7 +565,7 @@ public void replaceAllNullTest1() {
         map.add("bar", "foo, bar", "baz");
         map.add("baz", Arrays.asList("foo", "bar"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "bar", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "bar", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -578,7 +578,7 @@ public void replaceAllNullTest1() {
 
         map.replaceAll((FluentCaseInsensitiveStringsMap) null);
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "bar", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "bar", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -598,7 +598,7 @@ public void replaceAllNullTest2() {
         map.add("bar", "foo, bar", "baz");
         map.add("baz", Arrays.asList("foo", "bar"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "bar", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "bar", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -611,7 +611,7 @@ public void replaceAllNullTest2() {
 
         map.replaceAll((Map<String, Collection<String>>) null);
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "bar", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "bar", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
diff --git a/api/src/test/java/org/asynchttpclient/async/FluentStringsMapTest.java b/api/src/test/java/org/asynchttpclient/FluentStringsMapTest.java
similarity index 86%
rename from api/src/test/java/org/asynchttpclient/async/FluentStringsMapTest.java
rename to api/src/test/java/org/asynchttpclient/FluentStringsMapTest.java
index 46a436d94..9d9797d3e 100644
--- a/api/src/test/java/org/asynchttpclient/async/FluentStringsMapTest.java
+++ b/api/src/test/java/org/asynchttpclient/FluentStringsMapTest.java
@@ -13,7 +13,7 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient;
 
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertNull;
@@ -45,7 +45,7 @@ public void normalTest() {
         map.add("fOO", "bAr");
         map.add("Baz", Arrays.asList("fOo", "bar"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("fOO", "Baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("fOO", "Baz")));
 
         assertEquals(map.getFirstValue("fOO"), "bAr");
         assertEquals(map.getJoinedValue("fOO", ", "), "bAr");
@@ -69,7 +69,7 @@ public void addNullTest() {
         map.add("fOO", "bAr");
         map.add(null, Arrays.asList("fOo", "bar"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("fOO")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("fOO")));
 
         assertEquals(map.getFirstValue("fOO"), "bAr");
         assertEquals(map.getJoinedValue("fOO", ", "), "bAr");
@@ -92,7 +92,7 @@ public void sameKeyMultipleTimesTest() {
         map.add("foo", "bla", "blubb");
         map.add("fOO", "duh");
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "fOO")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "fOO")));
 
         assertEquals(map.getFirstValue("foo"), "baz,foo");
         assertEquals(map.getJoinedValue("foo", ", "), "baz,foo, bar, bla, blubb");
@@ -108,7 +108,7 @@ public void emptyValueTest() {
 
         map.add("foo", "");
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo")));
         assertEquals(map.getFirstValue("foo"), "");
         assertEquals(map.getJoinedValue("foo", ", "), "");
         assertEquals(map.get("foo"), Arrays.asList(""));
@@ -127,7 +127,7 @@ public void nullValueTest() {
 
     @Test
     public void mapConstructorTest() {
-        Map<String, Collection<String>> headerMap = new LinkedHashMap<String, Collection<String>>();
+        Map<String, Collection<String>> headerMap = new LinkedHashMap<>();
 
         headerMap.put("foo", Arrays.asList("baz,foo"));
         headerMap.put("baz", Arrays.asList("bar"));
@@ -139,7 +139,7 @@ public void mapConstructorTest() {
         headerMap.remove("bar");
         headerMap.remove("baz");
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz", "bar")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz", "bar")));
         assertEquals(map.getFirstValue("foo"), "baz,foo");
         assertEquals(map.getJoinedValue("foo", ", "), "baz,foo");
         assertEquals(map.get("foo"), Arrays.asList("baz,foo"));
@@ -173,7 +173,7 @@ public void copyConstructorTest() {
         srcHeaders.delete("baz");
         assertTrue(srcHeaders.keySet().isEmpty());
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz", "bar")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz", "bar")));
         assertEquals(map.getFirstValue("foo"), "baz,foo");
         assertEquals(map.getJoinedValue("foo", ", "), "baz,foo");
         assertEquals(map.get("foo"), Arrays.asList("baz,foo"));
@@ -199,7 +199,7 @@ public void deleteTest() {
         map.add("foo", "bar");
         map.add("baz", Arrays.asList("foo", "bar"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -209,7 +209,7 @@ public void deleteTest() {
 
         map.delete("baz");
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -225,7 +225,7 @@ public void deleteTestDifferentCase() {
         map.add("foo", "bar");
         map.add("baz", Arrays.asList("foo", "bar"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -235,7 +235,7 @@ public void deleteTestDifferentCase() {
 
         map.delete("bAz");
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -251,7 +251,7 @@ public void deleteUndefinedKeyTest() {
         map.add("foo", "bar");
         map.add("baz", Arrays.asList("foo", "bar"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -261,7 +261,7 @@ public void deleteUndefinedKeyTest() {
 
         map.delete("bar");
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -277,7 +277,7 @@ public void deleteNullTest() {
         map.add("foo", "bar");
         map.add("baz", Arrays.asList("foo", "bar"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -287,7 +287,7 @@ public void deleteNullTest() {
 
         map.delete(null);
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -303,7 +303,7 @@ public void deleteAllArrayTest() {
         map.add("foo", "bar");
         map.add("baz", Arrays.asList("foo", "bar"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -313,7 +313,7 @@ public void deleteAllArrayTest() {
 
         map.deleteAll("baz", "Boo");
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -329,7 +329,7 @@ public void deleteAllArrayDifferentCaseTest() {
         map.add("foo", "bar");
         map.add("baz", Arrays.asList("foo", "bar"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -339,7 +339,7 @@ public void deleteAllArrayDifferentCaseTest() {
 
         map.deleteAll("Foo", "baz");
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -355,7 +355,7 @@ public void deleteAllCollectionTest() {
         map.add("foo", "bar");
         map.add("baz", Arrays.asList("foo", "bar"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -381,7 +381,7 @@ public void deleteAllCollectionDifferentCaseTest() {
         map.add("foo", "bar");
         map.add("baz", Arrays.asList("foo", "bar"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -391,7 +391,7 @@ public void deleteAllCollectionDifferentCaseTest() {
 
         map.deleteAll(Arrays.asList("bAz", "fOO"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -407,7 +407,7 @@ public void deleteAllNullArrayTest() {
         map.add("foo", "bar");
         map.add("baz", Arrays.asList("foo", "bar"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -417,7 +417,7 @@ public void deleteAllNullArrayTest() {
 
         map.deleteAll((String[]) null);
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -433,7 +433,7 @@ public void deleteAllNullCollectionTest() {
         map.add("foo", "bar");
         map.add("baz", Arrays.asList("foo", "bar"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -443,7 +443,7 @@ public void deleteAllNullCollectionTest() {
 
         map.deleteAll((Collection<String>) null);
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -459,7 +459,7 @@ public void replaceArrayTest() {
         map.add("foo", "bar");
         map.add("baz", Arrays.asList("foo", "bar"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -469,7 +469,7 @@ public void replaceArrayTest() {
 
         map.replaceWith("foo", "blub", "bla");
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "blub");
         assertEquals(map.getJoinedValue("foo", ", "), "blub, bla");
         assertEquals(map.get("foo"), Arrays.asList("blub", "bla"));
@@ -485,7 +485,7 @@ public void replaceCollectionTest() {
         map.add("foo", "bar");
         map.add("baz", Arrays.asList("foo", "bar"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -495,7 +495,7 @@ public void replaceCollectionTest() {
 
         map.replaceWith("foo", Arrays.asList("blub", "bla"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "blub");
         assertEquals(map.getJoinedValue("foo", ", "), "blub, bla");
         assertEquals(map.get("foo"), Arrays.asList("blub", "bla"));
@@ -511,7 +511,7 @@ public void replaceDifferentCaseTest() {
         map.add("foo", "bar");
         map.add("baz", Arrays.asList("foo", "bar"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -521,7 +521,7 @@ public void replaceDifferentCaseTest() {
 
         map.replaceWith("Foo", Arrays.asList("blub", "bla"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz", "Foo")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz", "Foo")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -540,7 +540,7 @@ public void replaceUndefinedTest() {
         map.add("foo", "bar");
         map.add("baz", Arrays.asList("foo", "bar"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -550,7 +550,7 @@ public void replaceUndefinedTest() {
 
         map.replaceWith("bar", Arrays.asList("blub"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz", "bar")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz", "bar")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -569,7 +569,7 @@ public void replaceNullTest() {
         map.add("foo", "bar");
         map.add("baz", Arrays.asList("foo", "bar"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -579,7 +579,7 @@ public void replaceNullTest() {
 
         map.replaceWith(null, Arrays.asList("blub"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -595,7 +595,7 @@ public void replaceValueWithNullTest() {
         map.add("foo", "bar");
         map.add("baz", Arrays.asList("foo", "bar"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -605,7 +605,7 @@ public void replaceValueWithNullTest() {
 
         map.replaceWith("baz", (Collection<String>) null);
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -622,7 +622,7 @@ public void replaceAllMapTest1() {
         map.add("bar", "foo, bar", "baz");
         map.add("baz", Arrays.asList("foo", "bar"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "bar", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "bar", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -635,7 +635,7 @@ public void replaceAllMapTest1() {
 
         map.replaceAll(new FluentStringsMap().add("bar", "baz").add("Foo", "blub", "bla"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "bar", "baz", "Foo")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "bar", "baz", "Foo")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -658,7 +658,7 @@ public void replaceAllTest2() {
         map.add("bar", "foo, bar", "baz");
         map.add("baz", Arrays.asList("foo", "bar"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "bar", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "bar", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -669,13 +669,13 @@ public void replaceAllTest2() {
         assertEquals(map.getJoinedValue("baz", ", "), "foo, bar");
         assertEquals(map.get("baz"), Arrays.asList("foo", "bar"));
 
-        LinkedHashMap<String, Collection<String>> newValues = new LinkedHashMap<String, Collection<String>>();
+        LinkedHashMap<String, Collection<String>> newValues = new LinkedHashMap<>();
 
         newValues.put("bar", Arrays.asList("baz"));
         newValues.put("foo", null);
         map.replaceAll(newValues);
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("bar", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("bar", "baz")));
         assertNull(map.getFirstValue("foo"));
         assertNull(map.getJoinedValue("foo", ", "));
         assertNull(map.get("foo"));
@@ -695,7 +695,7 @@ public void replaceAllNullTest1() {
         map.add("bar", "foo, bar", "baz");
         map.add("baz", Arrays.asList("foo", "bar"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "bar", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "bar", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -708,7 +708,7 @@ public void replaceAllNullTest1() {
 
         map.replaceAll((FluentStringsMap) null);
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "bar", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "bar", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -728,7 +728,7 @@ public void replaceAllNullTest2() {
         map.add("bar", "foo, bar", "baz");
         map.add("baz", Arrays.asList("foo", "bar"));
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "bar", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "bar", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
@@ -741,7 +741,7 @@ public void replaceAllNullTest2() {
 
         map.replaceAll((Map<String, Collection<String>>) null);
 
-        assertEquals(map.keySet(), new LinkedHashSet<String>(Arrays.asList("foo", "bar", "baz")));
+        assertEquals(map.keySet(), new LinkedHashSet<>(Arrays.asList("foo", "bar", "baz")));
         assertEquals(map.getFirstValue("foo"), "bar");
         assertEquals(map.getJoinedValue("foo", ", "), "bar");
         assertEquals(map.get("foo"), Arrays.asList("bar"));
diff --git a/api/src/test/java/org/asynchttpclient/async/FollowingThreadTest.java b/api/src/test/java/org/asynchttpclient/FollowingThreadTest.java
similarity index 78%
rename from api/src/test/java/org/asynchttpclient/async/FollowingThreadTest.java
rename to api/src/test/java/org/asynchttpclient/FollowingThreadTest.java
index 2897d772e..774ab9fe0 100644
--- a/api/src/test/java/org/asynchttpclient/async/FollowingThreadTest.java
+++ b/api/src/test/java/org/asynchttpclient/FollowingThreadTest.java
@@ -13,14 +13,9 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient;
 
-import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.HttpResponseHeaders;
-import org.asynchttpclient.HttpResponseStatus;
 import org.testng.annotations.Test;
 
 import java.io.IOException;
@@ -50,27 +45,26 @@ public void testFollowRedirect() throws IOException, ExecutionException, Timeout
 
                     public void run() {
                         final CountDownLatch l = new CountDownLatch(1);
-                        final AsyncHttpClient ahc = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirect(true).build());
-                        try {
+                        try (AsyncHttpClient ahc = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirect(true).build())) {
                             ahc.prepareGet("http://www.google.com/").execute(new AsyncHandler<Integer>() {
 
                                 public void onThrowable(Throwable t) {
                                     t.printStackTrace();
                                 }
 
-                                public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+                                public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
                                     System.out.println(new String(bodyPart.getBodyPartBytes()));
-                                    return STATE.CONTINUE;
+                                    return State.CONTINUE;
                                 }
 
-                                public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+                                public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
                                     status = responseStatus.getStatusCode();
                                     System.out.println(responseStatus.getStatusText());
-                                    return STATE.CONTINUE;
+                                    return State.CONTINUE;
                                 }
 
-                                public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
-                                    return STATE.CONTINUE;
+                                public State onHeadersReceived(HttpResponseHeaders headers) throws Exception {
+                                    return State.CONTINUE;
                                 }
 
                                 public Integer onCompleted() throws Exception {
@@ -83,7 +77,6 @@ public Integer onCompleted() throws Exception {
                         } catch (Exception e) {
                             e.printStackTrace();
                         } finally {
-                            ahc.close();
                             countDown.countDown();
                         }
                     }
diff --git a/api/src/test/java/org/asynchttpclient/async/Head302Test.java b/api/src/test/java/org/asynchttpclient/Head302Test.java
similarity index 90%
rename from api/src/test/java/org/asynchttpclient/async/Head302Test.java
rename to api/src/test/java/org/asynchttpclient/Head302Test.java
index 4ef5b2e3e..c0eb0697f 100644
--- a/api/src/test/java/org/asynchttpclient/async/Head302Test.java
+++ b/api/src/test/java/org/asynchttpclient/Head302Test.java
@@ -13,15 +13,11 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient;
 
 import static org.testng.Assert.fail;
 
-import org.asynchttpclient.AsyncCompletionHandlerBase;
 import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.RequestBuilder;
-import org.asynchttpclient.Response;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.Test;
 
@@ -68,8 +64,7 @@ public AbstractHandler configureHandler() throws Exception {
 
     @Test(groups = { "standalone", "default_provider" })
     public void testHEAD302() throws IOException, BrokenBarrierException, InterruptedException, ExecutionException, TimeoutException {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             final CountDownLatch l = new CountDownLatch(1);
             Request request = new RequestBuilder("HEAD").setUrl("http://127.0.0.1:" + port1 + "/Test").build();
 
@@ -84,8 +79,6 @@ public Response onCompleted(Response response) throws Exception {
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
                 fail("Timeout out");
             }
-        } finally {
-            client.close();
         }
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/HttpToHttpsRedirectTest.java b/api/src/test/java/org/asynchttpclient/HttpToHttpsRedirectTest.java
similarity index 87%
rename from api/src/test/java/org/asynchttpclient/async/HttpToHttpsRedirectTest.java
rename to api/src/test/java/org/asynchttpclient/HttpToHttpsRedirectTest.java
index f186cbb3d..ff1b240cc 100644
--- a/api/src/test/java/org/asynchttpclient/async/HttpToHttpsRedirectTest.java
+++ b/api/src/test/java/org/asynchttpclient/HttpToHttpsRedirectTest.java
@@ -13,18 +13,16 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient;
 
-import static org.asynchttpclient.async.util.TestUtils.TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET;
-import static org.asynchttpclient.async.util.TestUtils.addHttpsConnector;
-import static org.asynchttpclient.async.util.TestUtils.findFreePort;
-import static org.asynchttpclient.async.util.TestUtils.newJettyHttpServer;
+import static org.asynchttpclient.test.TestUtils.TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET;
+import static org.asynchttpclient.test.TestUtils.addHttpsConnector;
+import static org.asynchttpclient.test.TestUtils.findFreePort;
+import static org.asynchttpclient.test.TestUtils.newJettyHttpServer;
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertNotNull;
 
 import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.Response;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.BeforeClass;
@@ -40,6 +38,7 @@
 
 public abstract class HttpToHttpsRedirectTest extends AbstractBasicTest {
 
+    // FIXME super NOT threadsafe!!!
     private final AtomicBoolean redirectDone = new AtomicBoolean(false);
 
     private class Relative302Handler extends AbstractHandler {
@@ -101,14 +100,11 @@ public void httpToHttpsRedirect() throws Exception {
                 .setFollowRedirect(true)//
                 .setAcceptAnyCertificate(true)//
                 .build();
-        AsyncHttpClient c = getAsyncHttpClient(cg);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(cg)) {
             Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", getTargetUrl2()).execute().get();
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 200);
             assertEquals(response.getHeader("X-httpToHttps"), "PASS");
-        } finally {
-            c.close();
         }
     }
 
@@ -121,8 +117,7 @@ public void httpToHttpsProperConfig() throws Exception {
                 .setFollowRedirect(true)//
                 .setAcceptAnyCertificate(true)//
                 .build();
-        AsyncHttpClient c = getAsyncHttpClient(cg);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(cg)) {
             Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", getTargetUrl2() + "/test2").execute().get();
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 200);
@@ -133,8 +128,6 @@ public void httpToHttpsProperConfig() throws Exception {
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 200);
             assertEquals(response.getHeader("X-httpToHttps"), "PASS");
-        } finally {
-            c.close();
         }
     }
 
@@ -147,14 +140,11 @@ public void relativeLocationUrl() throws Exception {
                 .setFollowRedirect(true)//
                 .setAcceptAnyCertificate(true)//
                 .build();
-        AsyncHttpClient c = getAsyncHttpClient(cg);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(cg)) {
             Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", "/foo/test").execute().get();
             assertNotNull(response);
-            assertEquals(response.getStatusCode(), 302);
+            assertEquals(response.getStatusCode(), 200);
             assertEquals(response.getUri().toString(), getTargetUrl());
-        } finally {
-            c.close();
         }
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/IdleStateHandlerTest.java b/api/src/test/java/org/asynchttpclient/IdleStateHandlerTest.java
similarity index 87%
rename from api/src/test/java/org/asynchttpclient/async/IdleStateHandlerTest.java
rename to api/src/test/java/org/asynchttpclient/IdleStateHandlerTest.java
index cefa7083a..7d1283a9e 100644
--- a/api/src/test/java/org/asynchttpclient/async/IdleStateHandlerTest.java
+++ b/api/src/test/java/org/asynchttpclient/IdleStateHandlerTest.java
@@ -13,14 +13,13 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient;
 
-import static org.asynchttpclient.async.util.TestUtils.findFreePort;
-import static org.asynchttpclient.async.util.TestUtils.newJettyHttpServer;
+import static org.asynchttpclient.test.TestUtils.findFreePort;
+import static org.asynchttpclient.test.TestUtils.newJettyHttpServer;
 import static org.testng.Assert.fail;
 
 import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.BeforeClass;
@@ -62,14 +61,11 @@ public void setUpGlobal() throws Exception {
     @Test(groups = { "online", "default_provider" })
     public void idleStateTest() throws Exception {
         AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setPooledConnectionIdleTimeout(10 * 1000).build();
-        AsyncHttpClient c = getAsyncHttpClient(cg);
 
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(cg)) {
             c.prepareGet(getTargetUrl()).execute().get();
         } catch (ExecutionException e) {
             fail("Should allow to finish processing request.", e);
-        } finally {
-            c.close();
         }
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/ListenableFutureTest.java b/api/src/test/java/org/asynchttpclient/ListenableFutureTest.java
similarity index 93%
rename from api/src/test/java/org/asynchttpclient/async/ListenableFutureTest.java
rename to api/src/test/java/org/asynchttpclient/ListenableFutureTest.java
index 3109ebf96..540438ad2 100644
--- a/api/src/test/java/org/asynchttpclient/async/ListenableFutureTest.java
+++ b/api/src/test/java/org/asynchttpclient/ListenableFutureTest.java
@@ -10,7 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient;
 
 import static org.testng.Assert.assertEquals;
 
@@ -30,8 +30,7 @@
     @Test(groups = { "standalone", "default_provider" })
     public void testListenableFuture() throws Exception {
         final AtomicInteger statusCode = new AtomicInteger(500);
-        AsyncHttpClient ahc = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient ahc = getAsyncHttpClient(null)) {
             final CountDownLatch latch = new CountDownLatch(1);
             final ListenableFuture<Response> future = ahc.prepareGet(getTargetUrl()).execute();
             future.addListener(new Runnable() {
@@ -50,8 +49,6 @@ public void run() {
 
             latch.await(10, TimeUnit.SECONDS);
             assertEquals(statusCode.get(), 200);
-        } finally {
-            ahc.close();
         }
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/MultipleHeaderTest.java b/api/src/test/java/org/asynchttpclient/MultipleHeaderTest.java
similarity index 85%
rename from api/src/test/java/org/asynchttpclient/async/MultipleHeaderTest.java
rename to api/src/test/java/org/asynchttpclient/MultipleHeaderTest.java
index d7c1d99ac..d4cf2b2f1 100644
--- a/api/src/test/java/org/asynchttpclient/async/MultipleHeaderTest.java
+++ b/api/src/test/java/org/asynchttpclient/MultipleHeaderTest.java
@@ -10,20 +10,14 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient;
 
-import static org.asynchttpclient.async.util.TestUtils.findFreePort;
+import static org.asynchttpclient.test.TestUtils.findFreePort;
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertNotNull;
 import static org.testng.Assert.fail;
 
-import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.HttpResponseHeaders;
-import org.asynchttpclient.HttpResponseStatus;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.RequestBuilder;
 import org.testng.annotations.AfterClass;
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
@@ -99,8 +93,7 @@ public void tearDownGlobal() throws Exception {
     public void testMultipleOtherHeaders() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         final String[] xffHeaders = new String[] { null, null };
 
-        AsyncHttpClient ahc = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient ahc = getAsyncHttpClient(null)) {
             Request req = new RequestBuilder("GET").setUrl("http://localhost:" + port1 + "/MultiOther").build();
             final CountDownLatch latch = new CountDownLatch(1);
             ahc.executeRequest(req, new AsyncHandler<Void>() {
@@ -108,21 +101,21 @@ public void onThrowable(Throwable t) {
                     t.printStackTrace(System.out);
                 }
 
-                public STATE onBodyPartReceived(HttpResponseBodyPart objectHttpResponseBodyPart) throws Exception {
-                    return STATE.CONTINUE;
+                public State onBodyPartReceived(HttpResponseBodyPart objectHttpResponseBodyPart) throws Exception {
+                    return State.CONTINUE;
                 }
 
-                public STATE onStatusReceived(HttpResponseStatus objectHttpResponseStatus) throws Exception {
-                    return STATE.CONTINUE;
+                public State onStatusReceived(HttpResponseStatus objectHttpResponseStatus) throws Exception {
+                    return State.CONTINUE;
                 }
 
-                public STATE onHeadersReceived(HttpResponseHeaders response) throws Exception {
+                public State onHeadersReceived(HttpResponseHeaders response) throws Exception {
                     int i = 0;
                     for (String header : response.getHeaders().get("X-Forwarded-For")) {
                         xffHeaders[i++] = header;
                     }
                     latch.countDown();
-                    return STATE.CONTINUE;
+                    return State.CONTINUE;
                 }
 
                 public Void onCompleted() throws Exception {
@@ -142,8 +135,6 @@ public Void onCompleted() throws Exception {
                 assertEquals(xffHeaders[1], "abc");
                 assertEquals(xffHeaders[0], "def");
             }
-        } finally {
-            ahc.close();
         }
     }
 
@@ -151,8 +142,7 @@ public Void onCompleted() throws Exception {
     public void testMultipleEntityHeaders() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         final String[] clHeaders = new String[] { null, null };
 
-        AsyncHttpClient ahc = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient ahc = getAsyncHttpClient(null)) {
             Request req = new RequestBuilder("GET").setUrl("http://localhost:" + port1 + "/MultiEnt").build();
             final CountDownLatch latch = new CountDownLatch(1);
             ahc.executeRequest(req, new AsyncHandler<Void>() {
@@ -160,15 +150,15 @@ public void onThrowable(Throwable t) {
                     t.printStackTrace(System.out);
                 }
 
-                public STATE onBodyPartReceived(HttpResponseBodyPart objectHttpResponseBodyPart) throws Exception {
-                    return STATE.CONTINUE;
+                public State onBodyPartReceived(HttpResponseBodyPart objectHttpResponseBodyPart) throws Exception {
+                    return State.CONTINUE;
                 }
 
-                public STATE onStatusReceived(HttpResponseStatus objectHttpResponseStatus) throws Exception {
-                    return STATE.CONTINUE;
+                public State onStatusReceived(HttpResponseStatus objectHttpResponseStatus) throws Exception {
+                    return State.CONTINUE;
                 }
 
-                public STATE onHeadersReceived(HttpResponseHeaders response) throws Exception {
+                public State onHeadersReceived(HttpResponseHeaders response) throws Exception {
                     try {
                         int i = 0;
                         for (String header : response.getHeaders().get("Content-Length")) {
@@ -177,7 +167,7 @@ public STATE onHeadersReceived(HttpResponseHeaders response) throws Exception {
                     } finally {
                         latch.countDown();
                     }
-                    return STATE.CONTINUE;
+                    return State.CONTINUE;
                 }
 
                 public Void onCompleted() throws Exception {
@@ -199,8 +189,6 @@ public Void onCompleted() throws Exception {
                 assertEquals(clHeaders[0], "1");
                 assertEquals(clHeaders[1], "2");
             }
-        } finally {
-            ahc.close();
         }
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/NoNullResponseTest.java b/api/src/test/java/org/asynchttpclient/NoNullResponseTest.java
similarity index 81%
rename from api/src/test/java/org/asynchttpclient/async/NoNullResponseTest.java
rename to api/src/test/java/org/asynchttpclient/NoNullResponseTest.java
index a83cd979f..de59d6755 100644
--- a/api/src/test/java/org/asynchttpclient/async/NoNullResponseTest.java
+++ b/api/src/test/java/org/asynchttpclient/NoNullResponseTest.java
@@ -14,14 +14,11 @@
  * under the License.
  *
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient;
 
 import static org.testng.Assert.assertNotNull;
 
 import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.BoundRequestBuilder;
-import org.asynchttpclient.Response;
 import org.testng.annotations.Test;
 
 import javax.net.ssl.SSLContext;
@@ -37,8 +34,11 @@
 
     @Test(invocationCount = 4, groups = { "online", "default_provider" })
     public void multipleSslRequestsWithDelayAndKeepAlive() throws Exception {
-        final AsyncHttpClient client = create();
-        try {
+
+        AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder().setFollowRedirect(true).setSSLContext(getSSLContext()).setAllowPoolingConnections(true).setConnectTimeout(10000)
+                .setPooledConnectionIdleTimeout(60000).setRequestTimeout(10000).setMaxConnectionsPerHost(-1).setMaxConnections(-1).build();
+
+        try (AsyncHttpClient client = getAsyncHttpClient(config)) {
             final BoundRequestBuilder builder = client.prepareGet(GOOGLE_HTTPS_URL);
             final Response response1 = builder.execute().get();
             Thread.sleep(4000);
@@ -50,17 +50,9 @@ public void multipleSslRequestsWithDelayAndKeepAlive() throws Exception {
             }
             assertNotNull(response1);
             assertNotNull(response2);
-        } finally {
-            client.close();
         }
     }
 
-    private AsyncHttpClient create() throws GeneralSecurityException {
-        final AsyncHttpClientConfig.Builder configBuilder = new AsyncHttpClientConfig.Builder().setFollowRedirect(true).setSSLContext(getSSLContext()).setAllowPoolingConnections(true).setConnectionTimeout(10000)
-                .setPooledConnectionIdleTimeout(60000).setRequestTimeout(10000).setMaxConnectionsPerHost(-1).setMaxConnections(-1);
-        return getAsyncHttpClient(configBuilder.build());
-    }
-
     private SSLContext getSSLContext() throws GeneralSecurityException {
         final SSLContext sslContext = SSLContext.getInstance("TLS");
         sslContext.init(null, new TrustManager[] { new MockTrustManager() }, null);
diff --git a/api/src/test/java/org/asynchttpclient/async/NonAsciiContentLengthTest.java b/api/src/test/java/org/asynchttpclient/NonAsciiContentLengthTest.java
similarity index 77%
rename from api/src/test/java/org/asynchttpclient/async/NonAsciiContentLengthTest.java
rename to api/src/test/java/org/asynchttpclient/NonAsciiContentLengthTest.java
index b47b52394..84584059b 100644
--- a/api/src/test/java/org/asynchttpclient/async/NonAsciiContentLengthTest.java
+++ b/api/src/test/java/org/asynchttpclient/NonAsciiContentLengthTest.java
@@ -10,16 +10,14 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient;
 
-import static org.asynchttpclient.async.util.TestUtils.findFreePort;
-import static org.asynchttpclient.async.util.TestUtils.newJettyHttpServer;
+import static java.nio.charset.StandardCharsets.*;
+import static org.asynchttpclient.test.TestUtils.findFreePort;
+import static org.asynchttpclient.test.TestUtils.newJettyHttpServer;
 import static org.testng.Assert.assertEquals;
 
 import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.BoundRequestBuilder;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.util.StandardCharsets;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.BeforeClass;
@@ -48,23 +46,17 @@ public void handle(String target, Request baseRequest, HttpServletRequest reques
                 byte[] b = new byte[MAX_BODY_SIZE];
                 int offset = 0;
                 int numBytesRead;
-                ServletInputStream is = request.getInputStream();
-                try {
+                try (ServletInputStream is = request.getInputStream()) {
                     while ((numBytesRead = is.read(b, offset, MAX_BODY_SIZE - offset)) != -1) {
                         offset += numBytesRead;
                     }
-                } finally {
-                    is.close();
                 }
                 assertEquals(request.getContentLength(), offset);
                 response.setStatus(200);
                 response.setCharacterEncoding(request.getCharacterEncoding());
                 response.setContentLength(request.getContentLength());
-                ServletOutputStream os = response.getOutputStream();
-                try {
+                try (ServletOutputStream os = response.getOutputStream()) {
                     os.write(b, 0, offset);
-                } finally {
-                    os.close();
                 }
             }
         });
@@ -78,15 +70,12 @@ public void testNonAsciiContentLength() throws Exception {
     }
 
     protected void execute(String body) throws IOException, InterruptedException, ExecutionException {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
-            BoundRequestBuilder r = client.preparePost(getTargetUrl()).setBody(body).setBodyEncoding(StandardCharsets.UTF_8.name());
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
+            BoundRequestBuilder r = client.preparePost(getTargetUrl()).setBody(body).setBodyCharset(UTF_8);
             Future<Response> f = r.execute();
             Response resp = f.get();
             assertEquals(resp.getStatusCode(), 200);
-            assertEquals(body, resp.getResponseBody(StandardCharsets.UTF_8.name()));
-        } finally {
-            client.close();
+            assertEquals(body, resp.getResponseBody(UTF_8));
         }
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/ParamEncodingTest.java b/api/src/test/java/org/asynchttpclient/ParamEncodingTest.java
similarity index 95%
rename from api/src/test/java/org/asynchttpclient/async/ParamEncodingTest.java
rename to api/src/test/java/org/asynchttpclient/ParamEncodingTest.java
index 4b5027f9a..e5b31f8b7 100644
--- a/api/src/test/java/org/asynchttpclient/async/ParamEncodingTest.java
+++ b/api/src/test/java/org/asynchttpclient/ParamEncodingTest.java
@@ -13,7 +13,7 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient;
 
 import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 import static org.testng.Assert.assertEquals;
@@ -59,15 +59,12 @@ public void handle(String s, Request r, HttpServletRequest request, HttpServletR
     public void testParameters() throws IOException, ExecutionException, TimeoutException, InterruptedException {
 
         String value = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKQLMNOPQRSTUVWXYZ1234567809`~!@#$%^&*()_+-=,.<>/?;:'\"[]{}\\| ";
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             Future<Response> f = client.preparePost("http://127.0.0.1:" + port1).addFormParam("test", value).execute();
             Response resp = f.get(10, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
             assertEquals(resp.getHeader("X-Param"), value.trim());
-        } finally {
-            client.close();
         }
     }
 
diff --git a/api/src/test/java/org/asynchttpclient/async/PerRequestRelative302Test.java b/api/src/test/java/org/asynchttpclient/PerRequestRelative302Test.java
similarity index 87%
rename from api/src/test/java/org/asynchttpclient/async/PerRequestRelative302Test.java
rename to api/src/test/java/org/asynchttpclient/PerRequestRelative302Test.java
index 8b34bd40f..500389d06 100644
--- a/api/src/test/java/org/asynchttpclient/async/PerRequestRelative302Test.java
+++ b/api/src/test/java/org/asynchttpclient/PerRequestRelative302Test.java
@@ -13,11 +13,11 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient;
 
-import static org.asynchttpclient.async.util.TestUtils.TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET;
-import static org.asynchttpclient.async.util.TestUtils.findFreePort;
-import static org.asynchttpclient.async.util.TestUtils.newJettyHttpServer;
+import static org.asynchttpclient.test.TestUtils.TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET;
+import static org.asynchttpclient.test.TestUtils.findFreePort;
+import static org.asynchttpclient.test.TestUtils.newJettyHttpServer;
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertNotNull;
 import static org.testng.Assert.assertTrue;
@@ -33,8 +33,6 @@
 import javax.servlet.http.HttpServletResponse;
 
 import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.Response;
 import org.asynchttpclient.uri.Uri;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
@@ -43,6 +41,7 @@
 
 public abstract class PerRequestRelative302Test extends AbstractBasicTest {
 
+ // FIXME super NOT threadsafe!!!
     private final AtomicBoolean isSet = new AtomicBoolean(false);
 
     private class Relative302Handler extends AbstractHandler {
@@ -92,8 +91,7 @@ public void runAllSequentiallyBecauseNotThreadSafe() throws Exception {
     // @Test(groups = { "online", "default_provider" })
     public void redirected302Test() throws Exception {
         isSet.getAndSet(false);
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
             Response response = c.prepareGet(getTargetUrl()).setFollowRedirect(true).setHeader("X-redirect", "http://www.microsoft.com/").execute().get();
 
             assertNotNull(response);
@@ -103,8 +101,6 @@ public void redirected302Test() throws Exception {
             String baseUrl = getBaseUrl(response.getUri());
 
             assertTrue(baseUrl.matches(anyMicrosoftPage), "response does not show redirection to " + anyMicrosoftPage);
-        } finally {
-            c.close();
         }
     }
 
@@ -112,14 +108,10 @@ public void redirected302Test() throws Exception {
     public void notRedirected302Test() throws Exception {
         isSet.getAndSet(false);
         AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setFollowRedirect(true).build();
-        AsyncHttpClient c = getAsyncHttpClient(cg);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(cg)) {
             Response response = c.prepareGet(getTargetUrl()).setFollowRedirect(false).setHeader("X-redirect", "http://www.microsoft.com/").execute().get();
-
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 302);
-        } finally {
-            c.close();
         }
     }
 
@@ -143,8 +135,7 @@ private static int getPort(Uri uri) {
     // @Test(groups = { "standalone", "default_provider" })
     public void redirected302InvalidTest() throws Exception {
         isSet.getAndSet(false);
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
             // If the test hit a proxy, no ConnectException will be thrown and instead of 404 will be returned.
             Response response = c.preparePost(getTargetUrl()).setFollowRedirect(true).setHeader("X-redirect", String.format("http://127.0.0.1:%d/", port2)).execute().get();
 
@@ -152,8 +143,6 @@ public void redirected302InvalidTest() throws Exception {
             assertEquals(response.getStatusCode(), 404);
         } catch (ExecutionException ex) {
             assertEquals(ex.getCause().getClass(), ConnectException.class);
-        } finally {
-            c.close();
         }
     }
 
@@ -161,14 +150,11 @@ public void redirected302InvalidTest() throws Exception {
     public void relativeLocationUrl() throws Exception {
         isSet.getAndSet(false);
 
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
             Response response = c.preparePost(getTargetUrl()).setFollowRedirect(true).setHeader("X-redirect", "/foo/test").execute().get();
             assertNotNull(response);
-            assertEquals(response.getStatusCode(), 302);
+            assertEquals(response.getStatusCode(), 200);
             assertEquals(response.getUri().toString(), getTargetUrl());
-        } finally {
-            c.close();
         }
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/PerRequestTimeoutTest.java b/api/src/test/java/org/asynchttpclient/PerRequestTimeoutTest.java
similarity index 86%
rename from api/src/test/java/org/asynchttpclient/async/PerRequestTimeoutTest.java
rename to api/src/test/java/org/asynchttpclient/PerRequestTimeoutTest.java
index 9063a8f87..e8e8c2add 100644
--- a/api/src/test/java/org/asynchttpclient/async/PerRequestTimeoutTest.java
+++ b/api/src/test/java/org/asynchttpclient/PerRequestTimeoutTest.java
@@ -13,7 +13,7 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient;
 
 import static org.asynchttpclient.util.DateUtils.millisTime;
 import static org.testng.Assert.assertEquals;
@@ -22,11 +22,7 @@
 import static org.testng.Assert.assertTrue;
 import static org.testng.Assert.fail;
 
-import org.asynchttpclient.AsyncCompletionHandler;
 import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.Response;
 import org.eclipse.jetty.continuation.Continuation;
 import org.eclipse.jetty.continuation.ContinuationSupport;
 import org.eclipse.jetty.server.Request;
@@ -96,9 +92,8 @@ public void run() {
 
     @Test(groups = { "standalone", "default_provider" })
     public void testRequestTimeout() throws IOException {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
-            Future<Response> responseFuture = client.prepareGet(getTargetUrl()).setRequestTimeoutInMs(100).execute();
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
+            Future<Response> responseFuture = client.prepareGet(getTargetUrl()).setRequestTimeout(100).execute();
             Response response = responseFuture.get(2000, TimeUnit.MILLISECONDS);
             assertNull(response);
         } catch (InterruptedException e) {
@@ -108,16 +103,13 @@ public void testRequestTimeout() throws IOException {
             checkTimeoutMessage(e.getCause().getMessage());
         } catch (TimeoutException e) {
             fail("Timeout.", e);
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void testGlobalDefaultPerRequestInfiniteTimeout() throws IOException {
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeout(100).build());
-        try {
-            Future<Response> responseFuture = client.prepareGet(getTargetUrl()).setRequestTimeoutInMs(-1).execute();
+        try (AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeout(100).build())) {
+            Future<Response> responseFuture = client.prepareGet(getTargetUrl()).setRequestTimeout(-1).execute();
             Response response = responseFuture.get();
             assertNotNull(response);
         } catch (InterruptedException e) {
@@ -125,15 +117,12 @@ public void testGlobalDefaultPerRequestInfiniteTimeout() throws IOException {
         } catch (ExecutionException e) {
             assertTrue(e.getCause() instanceof TimeoutException);
             checkTimeoutMessage(e.getCause().getMessage());
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void testGlobalRequestTimeout() throws IOException {
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeout(100).build());
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeout(100).build())) {
             Future<Response> responseFuture = client.prepareGet(getTargetUrl()).execute();
             Response response = responseFuture.get(2000, TimeUnit.MILLISECONDS);
             assertNull(response);
@@ -144,8 +133,6 @@ public void testGlobalRequestTimeout() throws IOException {
             checkTimeoutMessage(e.getCause().getMessage());
         } catch (TimeoutException e) {
             fail("Timeout.", e);
-        } finally {
-            client.close();
         }
     }
 
@@ -153,8 +140,7 @@ public void testGlobalRequestTimeout() throws IOException {
     public void testGlobalIdleTimeout() throws IOException {
         final long times[] = new long[] { -1, -1 };
 
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setPooledConnectionIdleTimeout(2000).build());
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setPooledConnectionIdleTimeout(2000).build())) {
             Future<Response> responseFuture = client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandler<Response>() {
                 @Override
                 public Response onCompleted(Response response) throws Exception {
@@ -162,7 +148,7 @@ public Response onCompleted(Response response) throws Exception {
                 }
 
                 @Override
-                public STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+                public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
                     times[0] = millisTime();
                     return super.onBodyPartReceived(content);
                 }
@@ -181,8 +167,6 @@ public void onThrowable(Throwable t) {
         } catch (ExecutionException e) {
             logger.info(String.format("\n@%dms Last body part received\n@%dms Connection killed\n %dms difference.", times[0], times[1], (times[1] - times[0])));
             fail("Timeouted on idle.", e);
-        } finally {
-            client.close();
         }
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/PostRedirectGetTest.java b/api/src/test/java/org/asynchttpclient/PostRedirectGetTest.java
similarity index 88%
rename from api/src/test/java/org/asynchttpclient/async/PostRedirectGetTest.java
rename to api/src/test/java/org/asynchttpclient/PostRedirectGetTest.java
index 306db3efe..990525912 100644
--- a/api/src/test/java/org/asynchttpclient/async/PostRedirectGetTest.java
+++ b/api/src/test/java/org/asynchttpclient/PostRedirectGetTest.java
@@ -11,17 +11,12 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package org.asynchttpclient.async;
+package org.asynchttpclient;
 
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.fail;
 
-import org.asynchttpclient.AsyncCompletionHandler;
 import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.RequestBuilder;
-import org.asynchttpclient.Response;
 import org.asynchttpclient.filter.FilterContext;
 import org.asynchttpclient.filter.FilterException;
 import org.asynchttpclient.filter.ResponseFilter;
@@ -47,27 +42,27 @@ public AbstractHandler configureHandler() throws Exception {
 
     // ------------------------------------------------------------ Test Methods
 
-    @Test(groups = { "standalone", "post_redirect_get" })
+    @Test(groups = { "standalone", "post_redirect_get" }, enabled = false)
     public void postRedirectGet302Test() throws Exception {
         doTestPositive(302);
     }
 
-    @Test(groups = { "standalone", "post_redirect_get" })
+    @Test(groups = { "standalone", "post_redirect_get" }, enabled = false)
     public void postRedirectGet302StrictTest() throws Exception {
         doTestNegative(302, true);
     }
 
-    @Test(groups = { "standalone", "post_redirect_get" })
+    @Test(groups = { "standalone", "post_redirect_get" }, enabled = false)
     public void postRedirectGet303Test() throws Exception {
         doTestPositive(303);
     }
 
-    @Test(groups = { "standalone", "post_redirect_get" })
+    @Test(groups = { "standalone", "post_redirect_get" }, enabled = false)
     public void postRedirectGet301Test() throws Exception {
         doTestNegative(301, false);
     }
 
-    @Test(groups = { "standalone", "post_redirect_get" })
+    @Test(groups = { "standalone", "post_redirect_get" }, enabled = false)
     public void postRedirectGet307Test() throws Exception {
         doTestNegative(307, false);
     }
@@ -75,7 +70,8 @@ public void postRedirectGet307Test() throws Exception {
     // --------------------------------------------------------- Private Methods
 
     private void doTestNegative(final int status, boolean strict) throws Exception {
-        AsyncHttpClient p = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirect(true).setStrict302Handling(strict).addResponseFilter(new ResponseFilter() {
+
+        AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder().setFollowRedirect(true).setStrict302Handling(strict).addResponseFilter(new ResponseFilter() {
             @Override
             public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
                 // pass on the x-expect-get and remove the x-redirect
@@ -85,8 +81,9 @@ private void doTestNegative(final int status, boolean strict) throws Exception {
                 ctx.getRequest().getHeaders().remove("x-redirect");
                 return ctx;
             }
-        }).build());
-        try {
+        }).build();
+
+        try (AsyncHttpClient p = getAsyncHttpClient(config)) {
             Request request = new RequestBuilder("POST").setUrl(getTargetUrl()).addFormParam("q", "a b").addHeader("x-redirect", +status + "@" + "http://localhost:" + port1 + "/foo/bar/baz").addHeader("x-negative", "true").build();
             Future<Integer> responseFuture = p.executeRequest(request, new AsyncCompletionHandler<Integer>() {
 
@@ -104,13 +101,12 @@ public void onThrowable(Throwable t) {
             });
             int statusCode = responseFuture.get();
             assertEquals(statusCode, 200);
-        } finally {
-            p.close();
         }
     }
 
     private void doTestPositive(final int status) throws Exception {
-        AsyncHttpClient p = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirect(true).addResponseFilter(new ResponseFilter() {
+
+        AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder().setFollowRedirect(true).addResponseFilter(new ResponseFilter() {
             @Override
             public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
                 // pass on the x-expect-get and remove the x-redirect
@@ -120,8 +116,9 @@ private void doTestPositive(final int status) throws Exception {
                 ctx.getRequest().getHeaders().remove("x-redirect");
                 return ctx;
             }
-        }).build());
-        try {
+        }).build();
+
+        try (AsyncHttpClient p = getAsyncHttpClient(config)) {
             Request request = new RequestBuilder("POST").setUrl(getTargetUrl()).addFormParam("q", "a b").addHeader("x-redirect", +status + "@" + "http://localhost:" + port1 + "/foo/bar/baz").build();
             Future<Integer> responseFuture = p.executeRequest(request, new AsyncCompletionHandler<Integer>() {
 
@@ -139,8 +136,6 @@ public void onThrowable(Throwable t) {
             });
             int statusCode = responseFuture.get();
             assertEquals(statusCode, 200);
-        } finally {
-            p.close();
         }
     }
 
diff --git a/api/src/test/java/org/asynchttpclient/async/PostWithQSTest.java b/api/src/test/java/org/asynchttpclient/PostWithQSTest.java
similarity index 87%
rename from api/src/test/java/org/asynchttpclient/async/PostWithQSTest.java
rename to api/src/test/java/org/asynchttpclient/PostWithQSTest.java
index f5bb67215..82d8d41f1 100644
--- a/api/src/test/java/org/asynchttpclient/async/PostWithQSTest.java
+++ b/api/src/test/java/org/asynchttpclient/PostWithQSTest.java
@@ -13,16 +13,13 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient;
 
 import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertNotNull;
 
-import org.asynchttpclient.AsyncCompletionHandlerBase;
 import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.HttpResponseStatus;
-import org.asynchttpclient.Response;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.Test;
@@ -73,25 +70,21 @@ public void handle(String s, Request r, HttpServletRequest request, HttpServletR
 
     @Test(groups = { "standalone", "default_provider" })
     public void postWithQS() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/?a=b").setBody("abc".getBytes()).execute();
             Response resp = f.get(3, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void postWithNulParamQS() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/?a=").setBody("abc".getBytes()).execute(new AsyncCompletionHandlerBase() {
 
                 @Override
-                public STATE onStatusReceived(final HttpResponseStatus status) throws Exception {
+                public State onStatusReceived(final HttpResponseStatus status) throws Exception {
                     if (!status.getUri().toUrl().equals("http://127.0.0.1:" + port1 + "/?a=")) {
                         throw new IOException(status.getUri().toUrl());
                     }
@@ -102,19 +95,16 @@ public STATE onStatusReceived(final HttpResponseStatus status) throws Exception
             Response resp = f.get(3, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void postWithNulParamsQS() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/?a=b&c&d=e").setBody("abc".getBytes()).execute(new AsyncCompletionHandlerBase() {
 
                 @Override
-                public STATE onStatusReceived(final HttpResponseStatus status) throws Exception {
+                public State onStatusReceived(final HttpResponseStatus status) throws Exception {
                     if (!status.getUri().toUrl().equals("http://127.0.0.1:" + port1 + "/?a=b&c&d=e")) {
                         throw new IOException("failed to parse the query properly");
                     }
@@ -125,19 +115,16 @@ public STATE onStatusReceived(final HttpResponseStatus status) throws Exception
             Response resp = f.get(3, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void postWithEmptyParamsQS() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/?a=b&c=&d=e").setBody("abc".getBytes()).execute(new AsyncCompletionHandlerBase() {
 
                 @Override
-                public STATE onStatusReceived(final HttpResponseStatus status) throws Exception {
+                public State onStatusReceived(final HttpResponseStatus status) throws Exception {
                     if (!status.getUri().toUrl().equals("http://127.0.0.1:" + port1 + "/?a=b&c=&d=e")) {
                         throw new IOException("failed to parse the query properly");
                     }
@@ -148,8 +135,6 @@ public STATE onStatusReceived(final HttpResponseStatus status) throws Exception
             Response resp = f.get(3, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-        } finally {
-            client.close();
         }
     }
 
diff --git a/api/src/test/java/org/asynchttpclient/async/QueryParametersTest.java b/api/src/test/java/org/asynchttpclient/QueryParametersTest.java
similarity index 87%
rename from api/src/test/java/org/asynchttpclient/async/QueryParametersTest.java
rename to api/src/test/java/org/asynchttpclient/QueryParametersTest.java
index 6bbd6c80a..7b86302ae 100644
--- a/api/src/test/java/org/asynchttpclient/async/QueryParametersTest.java
+++ b/api/src/test/java/org/asynchttpclient/QueryParametersTest.java
@@ -13,15 +13,15 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient;
 
+import static java.nio.charset.StandardCharsets.*;
 import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertNotNull;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.Response;
-import org.asynchttpclient.util.StandardCharsets;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.slf4j.LoggerFactory;
@@ -72,16 +72,13 @@ public AbstractHandler configureHandler() throws Exception {
 
     @Test(groups = { "standalone", "default_provider" })
     public void testQueryParameters() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             Future<Response> f = client.prepareGet("http://127.0.0.1:" + port1).addQueryParam("a", "1").addQueryParam("b", "2").execute();
             Response resp = f.get(3, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
             assertEquals(resp.getHeader("a"), "1");
             assertEquals(resp.getHeader("b"), "2");
-        } finally {
-            client.close();
         }
     }
 
@@ -90,28 +87,22 @@ public void testUrlRequestParametersEncoding() throws IOException, ExecutionExce
         String URL = getTargetUrl() + "?q=";
         String REQUEST_PARAM = "github github \ngithub";
 
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
-            String requestUrl2 = URL + URLEncoder.encode(REQUEST_PARAM, StandardCharsets.UTF_8.name());
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
+            String requestUrl2 = URL + URLEncoder.encode(REQUEST_PARAM, UTF_8.name());
             LoggerFactory.getLogger(QueryParametersTest.class).info("Executing request [{}] ...", requestUrl2);
             Response response = client.prepareGet(requestUrl2).execute().get();
-            String s = URLDecoder.decode(response.getHeader("q"), StandardCharsets.UTF_8.name());
+            String s = URLDecoder.decode(response.getHeader("q"), UTF_8.name());
             assertEquals(s, REQUEST_PARAM);
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void urlWithColonTest() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
             String query = "test:colon:";
             Response response = c.prepareGet(String.format("http://127.0.0.1:%d/foo/test/colon?q=%s", port1, query)).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
 
-            assertEquals(response.getHeader("q"), URLEncoder.encode(query, StandardCharsets.UTF_8.name()));
-        } finally {
-            c.close();
+            assertEquals(response.getHeader("q"), query);
         }
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/RC10KTest.java b/api/src/test/java/org/asynchttpclient/RC10KTest.java
similarity index 80%
rename from api/src/test/java/org/asynchttpclient/async/RC10KTest.java
rename to api/src/test/java/org/asynchttpclient/RC10KTest.java
index e3a199305..96c6a648d 100644
--- a/api/src/test/java/org/asynchttpclient/async/RC10KTest.java
+++ b/api/src/test/java/org/asynchttpclient/RC10KTest.java
@@ -13,19 +13,14 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient;
 
-import static org.asynchttpclient.async.util.TestUtils.findFreePort;
-import static org.asynchttpclient.async.util.TestUtils.newJettyHttpServer;
+import static org.asynchttpclient.test.TestUtils.findFreePort;
+import static org.asynchttpclient.test.TestUtils.newJettyHttpServer;
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertNotNull;
 
-import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.HttpResponseHeaders;
-import org.asynchttpclient.HttpResponseStatus;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.handler.AbstractHandler;
@@ -54,7 +49,7 @@
     private static final int C10K = 1000;
     private static final String ARG_HEADER = "Arg";
     private static final int SRV_COUNT = 10;
-    protected List<Server> servers = new ArrayList<Server>(SRV_COUNT);
+    protected List<Server> servers = new ArrayList<>(SRV_COUNT);
     private int[] ports;
 
     @BeforeClass(alwaysRun = true)
@@ -99,9 +94,8 @@ public void handle(String s, Request r, HttpServletRequest req, HttpServletRespo
 
     @Test(timeOut = 10 * 60 * 1000, groups = "scalability")
     public void rc10kProblem() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        AsyncHttpClient ahc = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setMaxConnectionsPerHost(C10K).setAllowPoolingConnections(true).build());
-        try {
-            List<Future<Integer>> resps = new ArrayList<Future<Integer>>(C10K);
+        try (AsyncHttpClient ahc = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setMaxConnectionsPerHost(C10K).setAllowPoolingConnections(true).build())) {
+            List<Future<Integer>> resps = new ArrayList<>(C10K);
             int i = 0;
             while (i < C10K) {
                 resps.add(ahc.prepareGet(String.format("http://127.0.0.1:%d/%d", ports[i % SRV_COUNT], i)).execute(new MyAsyncHandler(i++)));
@@ -112,8 +106,6 @@ public void rc10kProblem() throws IOException, ExecutionException, TimeoutExcept
                 assertNotNull(resp);
                 assertEquals(resp.intValue(), i++);
             }
-        } finally {
-            ahc.close();
         }
     }
 
@@ -129,20 +121,20 @@ public void onThrowable(Throwable t) {
             logger.warn("onThrowable called.", t);
         }
 
-        public STATE onBodyPartReceived(HttpResponseBodyPart event) throws Exception {
+        public State onBodyPartReceived(HttpResponseBodyPart event) throws Exception {
             String s = new String(event.getBodyPartBytes());
             result.compareAndSet(-1, new Integer(s.trim().equals("") ? "-1" : s));
-            return STATE.CONTINUE;
+            return State.CONTINUE;
         }
 
-        public STATE onStatusReceived(HttpResponseStatus event) throws Exception {
+        public State onStatusReceived(HttpResponseStatus event) throws Exception {
             assertEquals(event.getStatusCode(), 200);
-            return STATE.CONTINUE;
+            return State.CONTINUE;
         }
 
-        public STATE onHeadersReceived(HttpResponseHeaders event) throws Exception {
+        public State onHeadersReceived(HttpResponseHeaders event) throws Exception {
             assertEquals(event.getHeaders().getJoinedValue(ARG_HEADER, ", "), arg);
-            return STATE.CONTINUE;
+            return State.CONTINUE;
         }
 
         public Integer onCompleted() throws Exception {
diff --git a/api/src/test/java/org/asynchttpclient/RealmTest.java b/api/src/test/java/org/asynchttpclient/RealmTest.java
index 5433765b2..26c40e8c8 100644
--- a/api/src/test/java/org/asynchttpclient/RealmTest.java
+++ b/api/src/test/java/org/asynchttpclient/RealmTest.java
@@ -12,12 +12,12 @@
  */
 package org.asynchttpclient;
 
+import static java.nio.charset.StandardCharsets.*;
 import static org.testng.Assert.assertEquals;
 
 import org.asynchttpclient.Realm.AuthScheme;
 import org.asynchttpclient.Realm.RealmBuilder;
 import org.asynchttpclient.uri.Uri;
-import org.asynchttpclient.util.StandardCharsets;
 import org.testng.annotations.Test;
 
 import java.math.BigInteger;
@@ -28,7 +28,7 @@
     public void testClone() {
         RealmBuilder builder = new RealmBuilder();
         builder.setPrincipal("user").setPassword("pass");
-        builder.setEncoding(StandardCharsets.UTF_8.name()).setUsePreemptiveAuth(true);
+        builder.setCharset(UTF_16).setUsePreemptiveAuth(true);
         builder.setRealmName("realm").setAlgorithm("algo");
         builder.setScheme(AuthScheme.BASIC);
         Realm orig = builder.build();
@@ -36,11 +36,11 @@ public void testClone() {
         Realm clone = new RealmBuilder().clone(orig).build();
         assertEquals(clone.getPrincipal(), orig.getPrincipal());
         assertEquals(clone.getPassword(), orig.getPassword());
-        assertEquals(clone.getEncoding(), orig.getEncoding());
+        assertEquals(clone.getCharset(), orig.getCharset());
         assertEquals(clone.getUsePreemptiveAuth(), orig.getUsePreemptiveAuth());
         assertEquals(clone.getRealmName(), orig.getRealmName());
         assertEquals(clone.getAlgorithm(), orig.getAlgorithm());
-        assertEquals(clone.getAuthScheme(), orig.getAuthScheme());
+        assertEquals(clone.getScheme(), orig.getScheme());
     }
 
     @Test(groups = "fast")
@@ -73,7 +73,7 @@ private void testOldDigest(String qop) {
         Realm orig = builder.build();
 
         String ha1 = getMd5(user + ":" + realm + ":" + pass);
-        String ha2 = getMd5(method + ":" + uri);
+        String ha2 = getMd5(method + ":" + uri.getPath());
         String expectedResponse = getMd5(ha1 + ":" + nonce + ":" + ha2);
 
         assertEquals(expectedResponse, orig.getResponse());
@@ -101,7 +101,7 @@ public void testStrongDigest() {
         String nc = orig.getNc();
         String cnonce = orig.getCnonce();
         String ha1 = getMd5(user + ":" + realm + ":" + pass);
-        String ha2 = getMd5(method + ":" + uri);
+        String ha2 = getMd5(method + ":" + uri.getPath());
         String expectedResponse = getMd5(ha1 + ":" + nonce + ":" + nc + ":" + cnonce + ":" + qop + ":" + ha2);
 
         assertEquals(expectedResponse, orig.getResponse());
diff --git a/api/src/test/java/org/asynchttpclient/RedirectBodyTest.java b/api/src/test/java/org/asynchttpclient/RedirectBodyTest.java
new file mode 100644
index 000000000..85e07e0d0
--- /dev/null
+++ b/api/src/test/java/org/asynchttpclient/RedirectBodyTest.java
@@ -0,0 +1,98 @@
+package org.asynchttpclient;
+
+import static org.testng.Assert.*;
+
+import java.io.IOException;
+import java.util.concurrent.TimeUnit;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.apache.commons.io.IOUtils;
+import org.asynchttpclient.AsyncHttpClientConfig.Builder;
+import org.asynchttpclient.filter.FilterContext;
+import org.asynchttpclient.filter.FilterException;
+import org.asynchttpclient.filter.ResponseFilter;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
+
+public abstract class RedirectBodyTest extends AbstractBasicTest {
+
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new AbstractHandler() {
+            @Override
+            public void handle(String pathInContext, Request request, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
+
+                String redirectHeader = httpRequest.getHeader("X-REDIRECT");
+                if (redirectHeader != null) {
+                    httpResponse.setStatus(Integer.valueOf(redirectHeader));
+                    httpResponse.setContentLength(0);
+                    httpResponse.setHeader("Location", getTargetUrl());
+
+                } else {
+                    httpResponse.setStatus(200);
+                    int len = request.getContentLength();
+                    httpResponse.setContentLength(len);
+                    if (len > 0) {
+                        byte[] buffer = new byte[len];
+                        IOUtils.read(request.getInputStream(), buffer);
+                        httpResponse.getOutputStream().write(buffer);
+                    }
+                }
+                httpResponse.getOutputStream().flush();
+                httpResponse.getOutputStream().close();
+            }
+        };
+    }
+
+    private ResponseFilter redirectOnce = new ResponseFilter() {
+        @Override
+        public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
+            ctx.getRequest().getHeaders().remove("X-REDIRECT");
+            return ctx;
+        }
+    };
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void regular301LosesBody() throws Exception {
+        try (AsyncHttpClient c = getAsyncHttpClient(new Builder().setFollowRedirect(true).addResponseFilter(redirectOnce).build())) {
+            String body = "hello there";
+
+            Response response = c.preparePost(getTargetUrl()).setBody(body).setHeader("X-REDIRECT", "301").execute().get(TIMEOUT, TimeUnit.SECONDS);
+            assertEquals(response.getResponseBody(), "");
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void regular302LosesBody() throws Exception {
+        try (AsyncHttpClient c = getAsyncHttpClient(new Builder().setFollowRedirect(true).addResponseFilter(redirectOnce).build())) {
+            String body = "hello there";
+
+            Response response = c.preparePost(getTargetUrl()).setBody(body).setHeader("X-REDIRECT", "302").execute().get(TIMEOUT, TimeUnit.SECONDS);
+            assertEquals(response.getResponseBody(), "");
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void regular302StrictKeepsBody() throws Exception {
+        try (AsyncHttpClient c = getAsyncHttpClient(new Builder().setFollowRedirect(true).setStrict302Handling(true).addResponseFilter(redirectOnce).build())) {
+            String body = "hello there";
+
+            Response response = c.preparePost(getTargetUrl()).setBody(body).setHeader("X-REDIRECT", "302").execute().get(TIMEOUT, TimeUnit.SECONDS);
+            assertEquals(response.getResponseBody(), body);
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void regular307KeepsBody() throws Exception {
+        try (AsyncHttpClient c = getAsyncHttpClient(new Builder().setFollowRedirect(true).addResponseFilter(redirectOnce).build())) {
+            String body = "hello there";
+
+            Response response = c.preparePost(getTargetUrl()).setBody(body).setHeader("X-REDIRECT", "307").execute().get(TIMEOUT, TimeUnit.SECONDS);
+            assertEquals(response.getResponseBody(), body);
+        }
+    }
+}
diff --git a/api/src/test/java/org/asynchttpclient/async/RedirectConnectionUsageTest.java b/api/src/test/java/org/asynchttpclient/RedirectConnectionUsageTest.java
similarity index 88%
rename from api/src/test/java/org/asynchttpclient/async/RedirectConnectionUsageTest.java
rename to api/src/test/java/org/asynchttpclient/RedirectConnectionUsageTest.java
index 26bfbfc2f..fed3418b4 100644
--- a/api/src/test/java/org/asynchttpclient/async/RedirectConnectionUsageTest.java
+++ b/api/src/test/java/org/asynchttpclient/RedirectConnectionUsageTest.java
@@ -13,19 +13,14 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient;
 
-import static org.asynchttpclient.async.util.TestUtils.findFreePort;
-import static org.asynchttpclient.async.util.TestUtils.newJettyHttpServer;
+import static org.asynchttpclient.test.TestUtils.findFreePort;
+import static org.asynchttpclient.test.TestUtils.newJettyHttpServer;
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertNotNull;
 
 import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.ListenableFuture;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.RequestBuilder;
-import org.asynchttpclient.Response;
 import org.eclipse.jetty.servlet.ServletContextHandler;
 import org.eclipse.jetty.servlet.ServletHolder;
 import org.testng.annotations.BeforeClass;
@@ -77,13 +72,12 @@ public void testGetRedirectFinalUrl() throws Exception {
                 .setAllowPoolingConnections(true)//
                 .setMaxConnectionsPerHost(1)//
                 .setMaxConnections(1)//
-                .setConnectionTimeout(1000)//
+                .setConnectTimeout(1000)//
                 .setRequestTimeout(1000)//
                 .setFollowRedirect(true)//
                 .build();
 
-        AsyncHttpClient c = getAsyncHttpClient(config);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(config)) {
             Request r = new RequestBuilder("GET").setUrl(servletEndpointRedirectUrl).build();
 
             ListenableFuture<Response> response = c.executeRequest(r);
@@ -91,9 +85,6 @@ public void testGetRedirectFinalUrl() throws Exception {
             res = response.get();
             assertNotNull(res.getResponseBody());
             assertEquals(res.getUri().toString(), BASE_URL + "/overthere");
-
-        } finally {
-            c.close();
         }
     }
 
diff --git a/api/src/test/java/org/asynchttpclient/async/Relative302Test.java b/api/src/test/java/org/asynchttpclient/Relative302Test.java
similarity index 87%
rename from api/src/test/java/org/asynchttpclient/async/Relative302Test.java
rename to api/src/test/java/org/asynchttpclient/Relative302Test.java
index f36e1eb4a..2b5bd03f6 100644
--- a/api/src/test/java/org/asynchttpclient/async/Relative302Test.java
+++ b/api/src/test/java/org/asynchttpclient/Relative302Test.java
@@ -13,11 +13,11 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient;
 
-import static org.asynchttpclient.async.util.TestUtils.TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET;
-import static org.asynchttpclient.async.util.TestUtils.findFreePort;
-import static org.asynchttpclient.async.util.TestUtils.newJettyHttpServer;
+import static org.asynchttpclient.test.TestUtils.TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET;
+import static org.asynchttpclient.test.TestUtils.findFreePort;
+import static org.asynchttpclient.test.TestUtils.newJettyHttpServer;
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertNotNull;
 import static org.testng.Assert.assertTrue;
@@ -34,8 +34,6 @@
 import javax.servlet.http.HttpServletResponse;
 
 import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.Response;
 import org.asynchttpclient.uri.Uri;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
@@ -50,6 +48,7 @@
         public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException, ServletException {
 
             String param;
+            httpResponse.setStatus(200);
             httpResponse.setContentType(TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
             Enumeration<?> e = httpRequest.getHeaderNames();
             while (e.hasMoreElements()) {
@@ -58,12 +57,10 @@ public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServ
                 if (param.startsWith("X-redirect") && !isSet.getAndSet(true)) {
                     httpResponse.addHeader("Location", httpRequest.getHeader(param));
                     httpResponse.setStatus(302);
-                    httpResponse.getOutputStream().flush();
-                    httpResponse.getOutputStream().close();
-                    return;
+                    break;
                 }
             }
-            httpResponse.setStatus(200);
+            httpResponse.setContentLength(0);
             httpResponse.getOutputStream().flush();
             httpResponse.getOutputStream().close();
         }
@@ -91,19 +88,14 @@ public void testAllSequentiallyBecauseNotThreadSafe() throws Exception {
     public void redirected302Test() throws Exception {
         isSet.getAndSet(false);
         AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setFollowRedirect(true).build();
-        AsyncHttpClient c = getAsyncHttpClient(cg);
 
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(cg)) {
             Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", "http://www.google.com/").execute().get();
-
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 200);
 
             String baseUrl = getBaseUrl(response.getUri());
-
             assertTrue(baseUrl.startsWith("http://www.google."), "response does not show redirection to a google subdomain, got " + baseUrl);
-        } finally {
-            c.close();
         }
     }
 
@@ -111,18 +103,15 @@ public void redirected302Test() throws Exception {
     public void redirected302InvalidTest() throws Exception {
         isSet.getAndSet(false);
         AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setFollowRedirect(true).build();
-        AsyncHttpClient c = getAsyncHttpClient(cg);
 
         // If the test hit a proxy, no ConnectException will be thrown and instead of 404 will be returned.
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(cg)) {
             Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", String.format("http://127.0.0.1:%d/", port2)).execute().get();
 
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 404);
         } catch (ExecutionException ex) {
             assertEquals(ex.getCause().getClass(), ConnectException.class);
-        } finally {
-            c.close();
         }
     }
 
@@ -131,8 +120,7 @@ public void absolutePathRedirectTest() throws Exception {
         isSet.getAndSet(false);
 
         AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setFollowRedirect(true).build();
-        AsyncHttpClient c = getAsyncHttpClient(cg);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(cg)) {
             String redirectTarget = "/bar/test";
             String destinationUrl = new URI(getTargetUrl()).resolve(redirectTarget).toString();
 
@@ -142,8 +130,6 @@ public void absolutePathRedirectTest() throws Exception {
             assertEquals(response.getUri().toString(), destinationUrl);
 
             logger.debug("{} was redirected to {}", redirectTarget, destinationUrl);
-        } finally {
-            c.close();
         }
     }
 
@@ -152,8 +138,7 @@ public void relativePathRedirectTest() throws Exception {
         isSet.getAndSet(false);
 
         AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setFollowRedirect(true).build();
-        AsyncHttpClient c = getAsyncHttpClient(cg);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(cg)) {
             String redirectTarget = "bar/test1";
             String destinationUrl = new URI(getTargetUrl()).resolve(redirectTarget).toString();
 
@@ -163,8 +148,6 @@ public void relativePathRedirectTest() throws Exception {
             assertEquals(response.getUri().toString(), destinationUrl);
 
             logger.debug("{} was redirected to {}", redirectTarget, destinationUrl);
-        } finally {
-            c.close();
         }
     }
 
diff --git a/api/src/test/java/org/asynchttpclient/async/RemoteSiteTest.java b/api/src/test/java/org/asynchttpclient/RemoteSiteTest.java
similarity index 66%
rename from api/src/test/java/org/asynchttpclient/async/RemoteSiteTest.java
rename to api/src/test/java/org/asynchttpclient/RemoteSiteTest.java
index 7e8ad5f21..aac9a3f97 100644
--- a/api/src/test/java/org/asynchttpclient/async/RemoteSiteTest.java
+++ b/api/src/test/java/org/asynchttpclient/RemoteSiteTest.java
@@ -13,25 +13,17 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient;
 
+import static java.nio.charset.StandardCharsets.*;
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertNotNull;
 import static org.testng.Assert.assertTrue;
 import static org.testng.Assert.fail;
 
 import org.apache.commons.io.IOUtils;
-import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.HttpResponseHeaders;
-import org.asynchttpclient.HttpResponseStatus;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.RequestBuilder;
-import org.asynchttpclient.Response;
 import org.asynchttpclient.cookie.Cookie;
-import org.asynchttpclient.util.StandardCharsets;
 import org.testng.annotations.Test;
 
 import java.io.InputStream;
@@ -53,82 +45,63 @@
 
     @Test(groups = { "online", "default_provider" })
     public void testGoogleCom() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeout(10000).build());
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeout(10000).build())) {
             Response response = c.prepareGet("http://www.google.com/").execute().get(10, TimeUnit.SECONDS);
             assertNotNull(response);
-        } finally {
-            c.close();
         }
     }
 
     @Test(groups = { "online", "default_provider" })
     public void testMailGoogleCom() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeout(10000).build());
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeout(10000).build())) {
             Response response = c.prepareGet("http://mail.google.com/").execute().get(10, TimeUnit.SECONDS);
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 200);
-        } finally {
-            c.close();
         }
     }
 
     @Test(groups = { "online", "default_provider" }, enabled = false)
     // FIXME
     public void testMicrosoftCom() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeout(10000).build());
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeout(10000).build())) {
             Response response = c.prepareGet("http://microsoft.com/").execute().get(10, TimeUnit.SECONDS);
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 301);
-        } finally {
-            c.close();
         }
     }
 
     @Test(groups = { "online", "default_provider" }, enabled = false)
     // FIXME
     public void testWwwMicrosoftCom() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeout(10000).build());
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeout(10000).build())) {
             Response response = c.prepareGet("http://www.microsoft.com/").execute().get(10, TimeUnit.SECONDS);
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 302);
-        } finally {
-            c.close();
         }
     }
 
     @Test(groups = { "online", "default_provider" }, enabled = false)
     // FIXME
     public void testUpdateMicrosoftCom() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeout(10000).build());
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeout(10000).build())) {
             Response response = c.prepareGet("http://update.microsoft.com/").execute().get(10, TimeUnit.SECONDS);
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 302);
-        } finally {
-            c.close();
         }
     }
 
     @Test(groups = { "online", "default_provider" })
     public void testGoogleComWithTimeout() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeout(10000).build());
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeout(10000).build())) {
             Response response = c.prepareGet("http://google.com/").execute().get(10, TimeUnit.SECONDS);
             assertNotNull(response);
             assertTrue(response.getStatusCode() == 301 || response.getStatusCode() == 302);
-        } finally {
-            c.close();
         }
     }
 
     @Test(groups = { "online", "default_provider" })
     public void asyncStatusHEADContentLenghtTest() throws Exception {
-        AsyncHttpClient p = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirect(true).build());
-        try {
+        try (AsyncHttpClient p = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirect(true).build())) {
             final CountDownLatch l = new CountDownLatch(1);
             Request request = new RequestBuilder("HEAD").setUrl("http://www.google.com/").build();
 
@@ -147,8 +120,6 @@ public Response onCompleted(Response response) throws Exception {
             if (!l.await(5, TimeUnit.SECONDS)) {
                 fail("Timeout out");
             }
-        } finally {
-            p.close();
         }
     }
 
@@ -157,8 +128,7 @@ public void invalidStreamTest2() throws Exception {
         AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder().setRequestTimeout(10000).setFollowRedirect(true)
                 .setAllowPoolingConnections(false).setMaxRedirects(6).build();
 
-        AsyncHttpClient c = getAsyncHttpClient(config);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(config)) {
             Response response = c.prepareGet("http://bit.ly/aUjTtG").execute().get();
             if (response != null) {
                 System.out.println(response);
@@ -167,52 +137,29 @@ public void invalidStreamTest2() throws Exception {
             t.printStackTrace();
             assertNotNull(t.getCause());
             assertEquals(t.getCause().getMessage(), "invalid version format: ICY");
-        } finally {
-            c.close();
         }
     }
 
     @Test(groups = { "online", "default_provider" })
     public void asyncFullBodyProperlyRead() throws Exception {
-        final AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             Response r = client.prepareGet("http://www.cyberpresse.ca/").execute().get();
 
             InputStream stream = r.getResponseBodyAsStream();
             int contentLength = Integer.valueOf(r.getHeader("Content-Length"));
 
             assertEquals(contentLength, IOUtils.toByteArray(stream).length);
-        } finally {
-            client.close();
         }
     }
 
-    @Test(groups = { "online", "default_provider" })
+    // FIXME Get a 302 in France...
+    @Test(groups = { "online", "default_provider" }, enabled = false)
     public void testUrlRequestParametersEncoding() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
-            String requestUrl2 = URL + URLEncoder.encode(REQUEST_PARAM, StandardCharsets.UTF_8.name());
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
+            String requestUrl2 = URL + URLEncoder.encode(REQUEST_PARAM, UTF_8.name());
             logger.info(String.format("Executing request [%s] ...", requestUrl2));
             Response response = client.prepareGet(requestUrl2).execute().get();
-            assertEquals(response.getStatusCode(), 301);
-        } finally {
-            client.close();
-        }
-    }
-
-    /**
-     * See https://issues.sonatype.org/browse/AHC-61
-     * 
-     * @throws Exception
-     */
-    @Test(groups = { "online", "default_provider" })
-    public void testAHC60() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
-            Response response = client.prepareGet("http://www.meetup.com/stackoverflow/Mountain-View-CA/").execute().get();
-            assertEquals(response.getStatusCode(), 200);
-        } finally {
-            client.close();
+            assertEquals(response.getStatusCode(), 302);
         }
     }
 
@@ -220,56 +167,33 @@ public void testAHC60() throws Exception {
     public void stripQueryStringTest() throws Exception {
 
         AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setFollowRedirect(true).build();
-        AsyncHttpClient c = getAsyncHttpClient(cg);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(cg)) {
             Response response = c.prepareGet("http://www.freakonomics.com/?p=55846").execute().get();
 
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 200);
-        } finally {
-            c.close();
-        }
-    }
-
-    @Test(groups = { "online", "default_provider" })
-    public void stripQueryStringNegativeTest() throws Exception {
-
-        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setRemoveQueryParamsOnRedirect(false).setFollowRedirect(true)
-                .build();
-        AsyncHttpClient c = getAsyncHttpClient(cg);
-        try {
-            Response response = c.prepareGet("http://www.freakonomics.com/?p=55846").execute().get();
-
-            assertNotNull(response);
-            assertEquals(response.getStatusCode(), 301);
-        } finally {
-            c.close();
         }
     }
 
     @Test(groups = { "online", "default_provider" })
     public void evilCoookieTest() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
             RequestBuilder builder2 = new RequestBuilder("GET");
             builder2.setFollowRedirect(true);
             builder2.setUrl("http://www.google.com/");
             builder2.addHeader("Content-Type", "text/plain");
-            builder2.addCookie(new Cookie("evilcookie", "test", "test", ".google.com", "/", -1L, 10, false, false));
+            builder2.addCookie(new Cookie("evilcookie", "test", false, ".google.com", "/", Long.MIN_VALUE, false, false));
             Request request2 = builder2.build();
             Response response = c.executeRequest(request2).get();
 
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 200);
-        } finally {
-            c.close();
         }
     }
 
     @Test(groups = { "online", "default_provider" }, enabled = false)
     public void testAHC62Com() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirect(true).build());
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirect(true).build())) {
             Response response = c.prepareGet("http://api.crunchbase.com/v/1/financial-organization/kinsey-hills-group.js")
                     .execute(new AsyncHandler<Response>() {
 
@@ -279,21 +203,21 @@ public void onThrowable(Throwable t) {
                             t.printStackTrace();
                         }
 
-                        public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+                        public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
                             System.out.println(bodyPart.getBodyPartBytes().length);
                             builder.accumulate(bodyPart);
 
-                            return STATE.CONTINUE;
+                            return State.CONTINUE;
                         }
 
-                        public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+                        public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
                             builder.accumulate(responseStatus);
-                            return STATE.CONTINUE;
+                            return State.CONTINUE;
                         }
 
-                        public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
+                        public State onHeadersReceived(HttpResponseHeaders headers) throws Exception {
                             builder.accumulate(headers);
-                            return STATE.CONTINUE;
+                            return State.CONTINUE;
                         }
 
                         public Response onCompleted() throws Exception {
@@ -302,8 +226,6 @@ public Response onCompleted() throws Exception {
                     }).get(10, TimeUnit.SECONDS);
             assertNotNull(response);
             assertTrue(response.getResponseBody().length() >= 3870);
-        } finally {
-            c.close();
         }
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/RequestBuilderTest.java b/api/src/test/java/org/asynchttpclient/RequestBuilderTest.java
similarity index 96%
rename from api/src/test/java/org/asynchttpclient/async/RequestBuilderTest.java
rename to api/src/test/java/org/asynchttpclient/RequestBuilderTest.java
index 073bb5b18..bc2c64a87 100644
--- a/api/src/test/java/org/asynchttpclient/async/RequestBuilderTest.java
+++ b/api/src/test/java/org/asynchttpclient/RequestBuilderTest.java
@@ -13,8 +13,9 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.testng.Assert.assertEquals;
 
 import java.io.IOException;
@@ -117,8 +118,8 @@ public void testPercentageEncodedUserInfo() {
     @Test(groups = {"standalone", "default_provider"})
     public void testContentTypeCharsetToBodyEncoding() {
         final Request req = new RequestBuilder("GET").setHeader("Content-Type", "application/json; charset=utf-8").build();
-        assertEquals(req.getBodyEncoding(), "utf-8");
+        assertEquals(req.getBodyCharset(), UTF_8);
         final Request req2 = new RequestBuilder("GET").setHeader("Content-Type", "application/json; charset=\"utf-8\"").build();
-        assertEquals(req2.getBodyEncoding(), "utf-8");
+        assertEquals(req2.getBodyCharset(), UTF_8);
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/RetryRequestTest.java b/api/src/test/java/org/asynchttpclient/RetryRequestTest.java
similarity index 92%
rename from api/src/test/java/org/asynchttpclient/async/RetryRequestTest.java
rename to api/src/test/java/org/asynchttpclient/RetryRequestTest.java
index 8706232a2..e68b9b6a9 100644
--- a/api/src/test/java/org/asynchttpclient/async/RetryRequestTest.java
+++ b/api/src/test/java/org/asynchttpclient/RetryRequestTest.java
@@ -10,14 +10,13 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient;
 
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertNotNull;
 import static org.testng.Assert.fail;
 
 import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.util.AsyncHttpProviderUtils;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
@@ -73,8 +72,7 @@ public AbstractHandler configureHandler() throws Exception {
 
     @Test(groups = { "standalone", "default_provider" })
     public void testMaxRetry() throws Exception {
-        AsyncHttpClient ahc = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setMaxRequestRetry(0).build());
-        try {
+        try (AsyncHttpClient ahc = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setMaxRequestRetry(0).build())) {
             ahc.executeRequest(ahc.prepareGet(getTargetUrl()).build()).get();
             fail();
         } catch (Exception t) {
@@ -83,8 +81,6 @@ public void testMaxRetry() throws Exception {
             if (t.getCause() != AsyncHttpProviderUtils.REMOTELY_CLOSED_EXCEPTION) {
                 fail();
             }
-        } finally {
-            ahc.close();
         }
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/ThreadNameTest.java b/api/src/test/java/org/asynchttpclient/ThreadNameTest.java
new file mode 100644
index 000000000..9453a164a
--- /dev/null
+++ b/api/src/test/java/org/asynchttpclient/ThreadNameTest.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient;
+
+import java.util.Arrays;
+import java.util.Random;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+
+import org.testng.Assert;
+import org.testng.annotations.Test;
+
+/**
+ * Tests configured client name is used for thread names.
+ *
+ * @author Stepan Koltsov
+ */
+public abstract class ThreadNameTest extends AbstractBasicTest {
+
+    private static Thread[] getThreads() {
+        int count = Thread.activeCount() + 1;
+        for (;;) {
+            Thread[] threads = new Thread[count];
+            int filled = Thread.enumerate(threads);
+            if (filled < threads.length) {
+                return Arrays.copyOf(threads, filled);
+            }
+
+            count *= 2;
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void testQueryParameters() throws Exception {
+        String name = "ahc-" + (new Random().nextLong() & 0x7fffffffffffffffL);
+        AsyncHttpClientConfig.Builder config = new AsyncHttpClientConfig.Builder();
+        config.setName(name);
+        try (AsyncHttpClient client = getAsyncHttpClient(config.build())) {
+            Future<Response> f = client.prepareGet("http://127.0.0.1:" + port1 + "/").execute();
+            f.get(3, TimeUnit.SECONDS);
+
+            // We cannot assert that all threads are created with specified name,
+            // so we checking that at least one thread is.
+            boolean found = false;
+            for (Thread thread : getThreads()) {
+                if (thread.getName().startsWith(name)) {
+                    found = true;
+                    break;
+                }
+            }
+
+            Assert.assertTrue(found, "must found threads starting with random string " + name);
+        }
+    }
+}
diff --git a/api/src/test/java/org/asynchttpclient/async/ChunkingTest.java b/api/src/test/java/org/asynchttpclient/async/ChunkingTest.java
deleted file mode 100644
index 0566ecdba..000000000
--- a/api/src/test/java/org/asynchttpclient/async/ChunkingTest.java
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.async;
-
-import static org.asynchttpclient.async.util.TestUtils.LARGE_IMAGE_BYTES;
-import static org.asynchttpclient.async.util.TestUtils.LARGE_IMAGE_FILE;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertTrue;
-import static org.testng.FileAssert.fail;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.RequestBuilder;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.generators.InputStreamBodyGenerator;
-import org.testng.annotations.Test;
-
-import java.io.BufferedInputStream;
-import java.io.FileInputStream;
-
-/**
- * Test that the url fetcher is able to communicate via a proxy
- * 
- * @author dominict
- */
-abstract public class ChunkingTest extends AbstractBasicTest {
-    // So we can just test the returned data is the image,
-    // and doesn't contain the chunked delimeters.
-
-    /**
-     * Tests that the custom chunked stream result in success and content returned that is unchunked
-     */
-    @Test()
-    public void testCustomChunking() throws Exception {
-        AsyncHttpClientConfig.Builder bc = new AsyncHttpClientConfig.Builder();
-
-        bc.setAllowPoolingConnections(true);
-        bc.setMaxConnectionsPerHost(1);
-        bc.setMaxConnections(1);
-        bc.setConnectionTimeout(1000);
-        bc.setRequestTimeout(1000);
-        bc.setFollowRedirect(true);
-
-        AsyncHttpClient c = getAsyncHttpClient(bc.build());
-        try {
-
-            RequestBuilder builder = new RequestBuilder("POST");
-            builder.setUrl(getTargetUrl());
-            // made buff in stream big enough to mark.
-            builder.setBody(new InputStreamBodyGenerator(new BufferedInputStream(new FileInputStream(LARGE_IMAGE_FILE), 400000)));
-
-            Request r = builder.build();
-
-            Response response = c.executeRequest(r).get();
-            if (500 == response.getStatusCode()) {
-                StringBuilder sb = new StringBuilder();
-                sb.append("==============\n");
-                sb.append("500 response from call\n");
-                sb.append("Headers:" + response.getHeaders() + "\n");
-                sb.append("==============\n");
-                logger.debug(sb.toString());
-                assertEquals(response.getStatusCode(), 500, "Should have 500 status code");
-                assertTrue(response.getHeader("X-Exception").contains("invalid.chunk.length"), "Should have failed due to chunking");
-                fail("HARD Failing the test due to provided InputStreamBodyGenerator, chunking incorrectly:" + response.getHeader("X-Exception"));
-            } else {
-                assertEquals(response.getResponseBodyAsBytes(), LARGE_IMAGE_BYTES);
-            }
-        } finally {
-            c.close();
-        }
-    }
-}
diff --git a/api/src/test/java/org/asynchttpclient/async/HostnameVerifierTest.java b/api/src/test/java/org/asynchttpclient/async/HostnameVerifierTest.java
deleted file mode 100644
index 083b2da0f..000000000
--- a/api/src/test/java/org/asynchttpclient/async/HostnameVerifierTest.java
+++ /dev/null
@@ -1,231 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.async;
-
-import static org.asynchttpclient.async.util.TestUtils.SIMPLE_TEXT_FILE;
-import static org.asynchttpclient.async.util.TestUtils.SIMPLE_TEXT_FILE_STRING;
-import static org.asynchttpclient.async.util.TestUtils.TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET;
-import static org.asynchttpclient.async.util.TestUtils.createSSLContext;
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-import static org.testng.Assert.fail;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig.Builder;
-import org.asynchttpclient.Response;
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-import org.testng.annotations.Test;
-
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLSession;
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import java.io.IOException;
-import java.net.ConnectException;
-import java.util.Enumeration;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
-import java.util.concurrent.atomic.AtomicBoolean;
-
-public abstract class HostnameVerifierTest extends AbstractBasicHttpsTest {
-
-    protected final Logger log = LoggerFactory.getLogger(HostnameVerifierTest.class);
-
-    public static class EchoHandler extends AbstractHandler {
-
-        @Override
-        public void handle(String pathInContext, Request r, HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws ServletException, IOException {
-
-            httpResponse.setContentType(TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
-            Enumeration<?> e = httpRequest.getHeaderNames();
-            String param;
-            while (e.hasMoreElements()) {
-                param = e.nextElement().toString();
-
-                if (param.startsWith("LockThread")) {
-                    try {
-                        Thread.sleep(40 * 1000);
-                    } catch (InterruptedException ex) { // nothing to do here
-                    }
-                }
-
-                httpResponse.addHeader("X-" + param, httpRequest.getHeader(param));
-            }
-
-            Enumeration<?> i = httpRequest.getParameterNames();
-
-            StringBuilder requestBody = new StringBuilder();
-            while (i.hasMoreElements()) {
-                param = i.nextElement().toString();
-                httpResponse.addHeader("X-" + param, httpRequest.getParameter(param));
-                requestBody.append(param);
-                requestBody.append("_");
-            }
-
-            String pathInfo = httpRequest.getPathInfo();
-            if (pathInfo != null)
-                httpResponse.addHeader("X-pathInfo", pathInfo);
-
-            String queryString = httpRequest.getQueryString();
-            if (queryString != null)
-                httpResponse.addHeader("X-queryString", queryString);
-
-            httpResponse.addHeader("X-KEEP-ALIVE", httpRequest.getRemoteAddr() + ":" + httpRequest.getRemotePort());
-
-            javax.servlet.http.Cookie[] cs = httpRequest.getCookies();
-            if (cs != null) {
-                for (javax.servlet.http.Cookie c : cs) {
-                    httpResponse.addCookie(c);
-                }
-            }
-
-            if (requestBody.length() > 0) {
-                httpResponse.getOutputStream().write(requestBody.toString().getBytes());
-            }
-
-            int size = 10 * 1024;
-            if (httpRequest.getContentLength() > 0) {
-                size = httpRequest.getContentLength();
-            }
-            byte[] bytes = new byte[size];
-            int pos = 0;
-            if (bytes.length > 0) {
-                int read = 0;
-                while (read != -1) {
-                    read = httpRequest.getInputStream().read(bytes, pos, bytes.length - pos);
-                    pos += read;
-                }
-
-                httpResponse.getOutputStream().write(bytes);
-            }
-
-            httpResponse.setStatus(200);
-            httpResponse.getOutputStream().flush();
-            httpResponse.getOutputStream().close();
-
-        }
-    }
-
-    protected String getTargetUrl() {
-        return String.format("https://127.0.0.1:%d/foo/test", port1);
-    }
-
-    public AbstractHandler configureHandler() throws Exception {
-        return new EchoHandler();
-    }
-
-    @Test(groups = { "standalone", "default_provider" })
-    public void positiveHostnameVerifierTest() throws Exception {
-
-        final AsyncHttpClient client = getAsyncHttpClient(new Builder().setHostnameVerifier(new PositiveHostVerifier()).setSSLContext(createSSLContext(new AtomicBoolean(true))).build());
-        try {
-            Future<Response> f = client.preparePost(getTargetUrl()).setBody(SIMPLE_TEXT_FILE).setHeader("Content-Type", "text/html").execute();
-            Response resp = f.get();
-            assertNotNull(resp);
-            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
-        } finally {
-            client.close();
-        }
-    }
-
-    @Test(groups = { "standalone", "default_provider" })
-    public void negativeHostnameVerifierTest() throws Exception {
-
-        final AsyncHttpClient client = getAsyncHttpClient(new Builder().setHostnameVerifier(new NegativeHostVerifier()).setSSLContext(createSSLContext(new AtomicBoolean(true))).build());
-        try {
-            try {
-                client.preparePost(getTargetUrl()).setBody(SIMPLE_TEXT_FILE).setHeader("Content-Type", "text/html").execute().get();
-                fail("ConnectException expected");
-            } catch (ExecutionException ex) {
-                assertEquals(ex.getCause().getClass(), ConnectException.class);
-            }
-        } finally {
-            client.close();
-        }
-    }
-
-    @Test(groups = { "standalone", "default_provider" })
-    public void remoteIDHostnameVerifierTest() throws Exception {
-
-        final AsyncHttpClient client = getAsyncHttpClient(new Builder().setHostnameVerifier(new CheckHost("bouette")).setSSLContext(createSSLContext(new AtomicBoolean(true))).build());
-        try {
-            client.preparePost(getTargetUrl()).setBody(SIMPLE_TEXT_FILE).setHeader("Content-Type", "text/html").execute().get();
-            fail("ConnectException expected");
-        } catch (ExecutionException ex) {
-            assertEquals(ex.getCause().getClass(), ConnectException.class);
-        } finally {
-            client.close();
-        }
-    }
-
-    @Test(groups = { "standalone", "default_provider" })
-    public void remoteNegHostnameVerifierTest() throws Exception {
-        // request is made to 127.0.0.1, but cert presented for localhost - this should fail
-        final AsyncHttpClient client = getAsyncHttpClient(new Builder().setHostnameVerifier(new CheckHost("localhost")).setSSLContext(createSSLContext(new AtomicBoolean(true))).build());
-        try {
-            client.preparePost(getTargetUrl()).setBody(SIMPLE_TEXT_FILE).setHeader("Content-Type", "text/html").execute().get();
-            fail("ConnectException expected");
-        } catch (ExecutionException ex) {
-            assertEquals(ex.getCause().getClass(), ConnectException.class);
-        } finally {
-            client.close();
-        }
-    }
-
-    @Test(groups = { "standalone", "default_provider" })
-    public void remotePosHostnameVerifierTest() throws Exception {
-
-        final AsyncHttpClient client = getAsyncHttpClient(new Builder().setHostnameVerifier(new CheckHost("127.0.0.1")).setSSLContext(createSSLContext(new AtomicBoolean(true))).build());
-        try {
-            Response resp = client.preparePost(getTargetUrl()).setBody(SIMPLE_TEXT_FILE).setHeader("Content-Type", "text/html").execute().get();
-            assertNotNull(resp);
-            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
-        } finally {
-            client.close();
-        }
-    }
-
-    public static class PositiveHostVerifier implements HostnameVerifier {
-
-        public boolean verify(String s, SSLSession sslSession) {
-            return true;
-        }
-    }
-
-    public static class NegativeHostVerifier implements HostnameVerifier {
-
-        public boolean verify(String s, SSLSession sslSession) {
-            return false;
-        }
-    }
-
-    public static class CheckHost implements HostnameVerifier {
-
-        private final String hostName;
-
-        public CheckHost(String hostName) {
-            this.hostName = hostName;
-        }
-
-        public boolean verify(String s, SSLSession sslSession) {
-            return s != null && s.equalsIgnoreCase(hostName);
-        }
-    }
-}
diff --git a/api/src/test/java/org/asynchttpclient/async/MaxTotalConnectionTest.java b/api/src/test/java/org/asynchttpclient/async/MaxTotalConnectionTest.java
deleted file mode 100644
index d12b98c61..000000000
--- a/api/src/test/java/org/asynchttpclient/async/MaxTotalConnectionTest.java
+++ /dev/null
@@ -1,130 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License. You may obtain a copy of the License at:
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package org.asynchttpclient.async;
-
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertTrue;
-import static org.testng.Assert.fail;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.Response;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-import org.testng.annotations.Test;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
-
-public abstract class MaxTotalConnectionTest extends AbstractBasicTest {
-    protected final Logger log = LoggerFactory.getLogger(AbstractBasicTest.class);
-
-    @Test(groups = { "standalone", "default_provider" })
-    public void testMaxTotalConnectionsExceedingException() {
-        String[] urls = new String[] { "http://google.com", "http://github.com/" };
-
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setConnectionTimeout(1000).setRequestTimeout(5000).setAllowPoolingConnections(false).setMaxConnections(1).setMaxConnectionsPerHost(1).build());
-        try {
-            boolean caughtError = false;
-            for (int i = 0; i < urls.length; i++) {
-                try {
-                    client.prepareGet(urls[i]).execute();
-                } catch (IOException e) {
-                    // assert that 2nd request fails, because maxTotalConnections=1
-                    assertEquals(i, 1);
-                    caughtError = true;
-                }
-            }
-            assertTrue(caughtError);
-        } finally {
-            client.close();
-        }
-    }
-
-    @Test
-    public void testMaxTotalConnections() {
-        String[] urls = new String[] { "http://google.com", "http://lenta.ru" };
-
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setConnectionTimeout(1000).setRequestTimeout(5000).setAllowPoolingConnections(false).setMaxConnections(2).setMaxConnectionsPerHost(1).build());
-        try {
-            for (String url : urls) {
-                try {
-                    client.prepareGet(url).execute();
-                } catch (IOException e) {
-                    fail("Smth wrong with connections handling!");
-                }
-            }
-        } finally {
-            client.close();
-        }
-    }
-
-    /**
-     * JFA: Disable this test for 1.2.0 release as it can easily fail because a request may complete before the second one is made, hence failing. The issue occurs frequently on Linux.
-     */
-    @Test(enabled = false)
-    public void testMaxTotalConnectionsCorrectExceptionHandling() {
-        String[] urls = new String[] { "http://google.com", "http://github.com/" };
-
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setConnectionTimeout(1000).setRequestTimeout(5000).setAllowPoolingConnections(false).setMaxConnections(1).setMaxConnectionsPerHost(1).build());
-        try {
-            List<Future<Response>> futures = new ArrayList<Future<Response>>();
-            boolean caughtError = false;
-            for (int i = 0; i < urls.length; i++) {
-                try {
-                    Future<Response> future = client.prepareGet(urls[i]).execute();
-                    if (future != null) {
-                        futures.add(future);
-                    }
-                } catch (IOException e) {
-                    // assert that 2nd request fails, because maxTotalConnections=1
-                    assertEquals(i, 1);
-                    caughtError = true;
-                }
-            }
-            assertTrue(caughtError);
-
-            // get results of executed requests
-            for (Future<Response> future : futures) {
-                try {
-                    /* Response res = */future.get();
-                } catch (InterruptedException e) {
-                    log.error("Error!", e);
-                } catch (ExecutionException e) {
-                    log.error("Error!", e);
-                }
-            }
-
-            // try to execute once again, expecting that 1 connection is released
-            caughtError = false;
-            for (int i = 0; i < urls.length; i++) {
-                try {
-                    client.prepareGet(urls[i]).execute();
-                } catch (IOException e) {
-                    // assert that 2nd request fails, because maxTotalConnections=1
-                    assertEquals(i, 1);
-                    caughtError = true;
-                }
-            }
-            assertTrue(caughtError);
-        } finally {
-            client.close();
-        }
-    }
-}
diff --git a/api/src/test/java/org/asynchttpclient/async/MaxConnectionsInThreads.java b/api/src/test/java/org/asynchttpclient/channel/MaxConnectionsInThreads.java
similarity index 59%
rename from api/src/test/java/org/asynchttpclient/async/MaxConnectionsInThreads.java
rename to api/src/test/java/org/asynchttpclient/channel/MaxConnectionsInThreads.java
index 4f626fd3f..73c42fc85 100644
--- a/api/src/test/java/org/asynchttpclient/async/MaxConnectionsInThreads.java
+++ b/api/src/test/java/org/asynchttpclient/channel/MaxConnectionsInThreads.java
@@ -14,14 +14,29 @@
  * under the License.
  *
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient.channel;
 
-import static org.asynchttpclient.async.util.TestUtils.findFreePort;
-import static org.asynchttpclient.async.util.TestUtils.newJettyHttpServer;
-import static org.testng.Assert.assertTrue;
+import static org.asynchttpclient.test.TestUtils.findFreePort;
+import static org.asynchttpclient.test.TestUtils.newJettyHttpServer;
+import static org.testng.Assert.assertEquals;
 
+import java.io.IOException;
+import java.io.OutputStream;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.asynchttpclient.AbstractBasicTest;
+import org.asynchttpclient.AsyncCompletionHandlerBase;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Response;
 import org.eclipse.jetty.servlet.ServletContextHandler;
 import org.eclipse.jetty.servlet.ServletHolder;
 import org.slf4j.Logger;
@@ -29,95 +44,75 @@
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServlet;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import java.io.IOException;
-import java.io.OutputStream;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.util.ArrayList;
-import java.util.List;
-
 abstract public class MaxConnectionsInThreads extends AbstractBasicTest {
 
     // FIXME weird
     private static URI servletEndpointUri;
 
     @Test(groups = { "online", "default_provider" })
-    public void testMaxConnectionsWithinThreads() {
+    public void testMaxConnectionsWithinThreads() throws InterruptedException {
 
         String[] urls = new String[] { servletEndpointUri.toString(), servletEndpointUri.toString() };
 
-        final AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setConnectionTimeout(1000).setRequestTimeout(5000)
-                .setAllowPoolingConnections(true).setMaxConnections(1).setMaxConnectionsPerHost(1).build());
+        AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder().setConnectTimeout(1000).setRequestTimeout(5000).setAllowPoolingConnections(true)//
+                .setMaxConnections(1).setMaxConnectionsPerHost(1).build();
 
-        try {
-            final Boolean[] caughtError = new Boolean[] { Boolean.FALSE };
-            List<Thread> ts = new ArrayList<Thread>();
+        final CountDownLatch inThreadsLatch = new CountDownLatch(2);
+        final AtomicInteger failedCount = new AtomicInteger();
+        
+        try (AsyncHttpClient client = getAsyncHttpClient(config)) {
             for (int i = 0; i < urls.length; i++) {
                 final String url = urls[i];
                 Thread t = new Thread() {
                     public void run() {
-                        try {
-                            client.prepareGet(url).execute();
-                        } catch (IOException e) {
-                            // assert that 2nd request fails, because maxTotalConnections=1
-                            // logger.debug(i);
-                            caughtError[0] = true;
-                            logger.error("Exception ", e);
-                        }
+                        client.prepareGet(url).execute(new AsyncCompletionHandlerBase() {
+                            @Override
+                            public Response onCompleted(Response response) throws Exception {
+                                Response r = super.onCompleted(response);
+                                inThreadsLatch.countDown();
+                                return r;
+                            }
+                            
+                            @Override
+                            public void onThrowable(Throwable t) {
+                                super.onThrowable(t);
+                                failedCount.incrementAndGet();
+                                inThreadsLatch.countDown();
+                            }
+                        });
                     }
                 };
                 t.start();
-                ts.add(t);
-            }
-
-            for (Thread t : ts) {
-                try {
-                    t.join();
-                } catch (InterruptedException e) {
-                    logger.error("Exception ", e);
-                }
             }
 
-            // Let the threads finish
-            try {
-                Thread.sleep(4500);
-            } catch (InterruptedException e1) {
-                // TODO Auto-generated catch block
-                e1.printStackTrace();
-            }
+            inThreadsLatch.await();
 
-            assertTrue(caughtError[0], "Max Connections should have been reached");
+            assertEquals(failedCount.get(), 1, "Max Connections should have been reached when launching from concurrent threads");
 
-            boolean errorInNotThread = false;
+            final CountDownLatch notInThreadsLatch = new CountDownLatch(2);
+            failedCount.set(0);
             for (int i = 0; i < urls.length; i++) {
                 final String url = urls[i];
-                try {
-                    client.prepareGet(url).execute();
-                    // client.prepareGet(url).execute();
-                } catch (IOException e) {
-                    // assert that 2nd request fails, because maxTotalConnections=1
-                    // logger.debug(i);
-                    errorInNotThread = true;
-                    System.err.println("============");
-                    e.printStackTrace();
-                    System.err.println("============");
-                }
-            }
-            // Let the request finish
-            try {
-                Thread.sleep(2500);
-            } catch (InterruptedException e1) {
-                // TODO Auto-generated catch block
-                e1.printStackTrace();
+                client.prepareGet(url).execute(new AsyncCompletionHandlerBase() {
+                    @Override
+                    public Response onCompleted(Response response) throws Exception {
+                        Response r = super.onCompleted(response);
+                        notInThreadsLatch.countDown();
+                        return r;
+                    }
+                    
+                    @Override
+                    public void onThrowable(Throwable t) {
+                        super.onThrowable(t);
+                        failedCount.incrementAndGet();
+                        notInThreadsLatch.countDown();
+                    }
+                });
             }
-            assertTrue(errorInNotThread, "Max Connections should have been reached");
-        } finally {
-            client.close();
+            
+            notInThreadsLatch.await();
+            
+            assertEquals(failedCount.get(), 1, "Max Connections should have been reached when launching from main thread");
         }
     }
 
diff --git a/api/src/test/java/org/asynchttpclient/channel/MaxTotalConnectionTest.java b/api/src/test/java/org/asynchttpclient/channel/MaxTotalConnectionTest.java
new file mode 100644
index 000000000..53eba836f
--- /dev/null
+++ b/api/src/test/java/org/asynchttpclient/channel/MaxTotalConnectionTest.java
@@ -0,0 +1,108 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package org.asynchttpclient.channel;
+
+import static org.testng.Assert.*;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
+
+import org.asynchttpclient.AbstractBasicTest;
+import org.asynchttpclient.AsyncCompletionHandlerBase;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.ListenableFuture;
+import org.asynchttpclient.Response;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.testng.Assert;
+import org.testng.annotations.Test;
+
+public abstract class MaxTotalConnectionTest extends AbstractBasicTest {
+    protected final Logger log = LoggerFactory.getLogger(AbstractBasicTest.class);
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void testMaxTotalConnectionsExceedingException() throws IOException {
+        String[] urls = new String[] { "http://google.com", "http://github.com/" };
+
+        AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder().setConnectTimeout(1000)
+                .setRequestTimeout(5000).setAllowPoolingConnections(false).setMaxConnections(1).setMaxConnectionsPerHost(1)
+                .build();
+
+        try (AsyncHttpClient client = getAsyncHttpClient(config)) {
+            List<ListenableFuture<Response>> futures = new ArrayList<>();
+            for (int i = 0; i < urls.length; i++) {
+                futures.add(client.prepareGet(urls[i]).execute());
+            }
+            
+            boolean caughtError = false;
+            int i;
+            for (i = 0; i < urls.length; i++) {
+                try {
+                    futures.get(i).get();
+                } catch (Exception e) {
+                    // assert that 2nd request fails, because maxTotalConnections=1
+                    caughtError = true;
+                    break;
+                }
+            }
+
+            Assert.assertEquals(1, i);
+            Assert.assertTrue(caughtError);
+        }
+    }
+
+    @Test
+    public void testMaxTotalConnections() throws InterruptedException {
+        String[] urls = new String[] { "http://google.com", "http://lenta.ru" };
+
+        final CountDownLatch latch = new CountDownLatch(2);
+        final AtomicReference<Throwable> ex = new AtomicReference<>();
+        final AtomicReference<String> failedUrl = new AtomicReference<>();
+
+        AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder().setConnectTimeout(1000).setRequestTimeout(5000)
+                .setAllowPoolingConnections(false).setMaxConnections(2).setMaxConnectionsPerHost(1).build();
+
+        try (AsyncHttpClient client = getAsyncHttpClient(config)) {
+            for (String url : urls) {
+                final String thisUrl = url;
+                client.prepareGet(url).execute(new AsyncCompletionHandlerBase() {
+                    @Override
+                    public Response onCompleted(Response response) throws Exception {
+                        Response r = super.onCompleted(response);
+                        latch.countDown();
+                        return r;
+                    }
+
+                    @Override
+                    public void onThrowable(Throwable t) {
+                        super.onThrowable(t);
+                        ex.set(t);
+                        failedUrl.set(thisUrl);
+                        latch.countDown();
+                    }
+                });
+            }
+
+            latch.await();
+            assertNull(ex.get());
+            assertNull(failedUrl.get());
+        }
+    }
+}
diff --git a/api/src/test/java/org/asynchttpclient/async/ConnectionPoolTest.java b/api/src/test/java/org/asynchttpclient/channel/pool/ConnectionPoolTest.java
similarity index 68%
rename from api/src/test/java/org/asynchttpclient/async/ConnectionPoolTest.java
rename to api/src/test/java/org/asynchttpclient/channel/pool/ConnectionPoolTest.java
index 86ea33b6d..8ccfc017d 100644
--- a/api/src/test/java/org/asynchttpclient/async/ConnectionPoolTest.java
+++ b/api/src/test/java/org/asynchttpclient/channel/pool/ConnectionPoolTest.java
@@ -13,37 +13,44 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient.channel.pool;
 
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertNotNull;
 import static org.testng.Assert.assertNull;
 import static org.testng.Assert.fail;
 
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.AsyncCompletionHandler;
 import org.asynchttpclient.AsyncCompletionHandlerBase;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.ListenableFuture;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
 import org.asynchttpclient.Response;
+import org.asynchttpclient.test.EventCollectingHandler;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.testng.annotations.Test;
 
-import java.io.IOException;
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-
 public abstract class ConnectionPoolTest extends AbstractBasicTest {
     protected final Logger log = LoggerFactory.getLogger(AbstractBasicTest.class);
 
     @Test(groups = { "standalone", "default_provider" })
     public void testMaxTotalConnections() {
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setAllowPoolingConnections(true).setMaxConnections(1).build());
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setAllowPoolingConnections(true).setMaxConnections(1).build())) {
             String url = getTargetUrl();
             int i;
             Exception exception = null;
@@ -57,48 +64,43 @@ public void testMaxTotalConnections() {
                 }
             }
             assertNull(exception);
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
-    public void testMaxTotalConnectionsException() {
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setAllowPoolingConnections(true).setMaxConnections(1).build());
-        try {
+    public void testMaxTotalConnectionsException() throws IOException {
+        try (AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setAllowPoolingConnections(true).setMaxConnections(1).build())) {
             String url = getTargetUrl();
-            int i;
+
+            List<ListenableFuture<Response>> futures = new ArrayList<>();
+            for (int i = 0; i < 5; i++) {
+                log.info("{} requesting url [{}]...", i, url);
+                futures.add(client.prepareGet(url).execute());
+            }
+            
             Exception exception = null;
-            for (i = 0; i < 20; i++) {
+            for (ListenableFuture<Response> future : futures) {
                 try {
-                    log.info("{} requesting url [{}]...", i, url);
-
-                    if (i < 5) {
-                        client.prepareGet(url).execute().get();
-                    } else {
-                        client.prepareGet(url).execute();
-                    }
+                    future.get();
                 } catch (Exception ex) {
                     exception = ex;
                     break;
                 }
             }
+
             assertNotNull(exception);
-            assertNotNull(exception.getMessage());
-            assertEquals(exception.getMessage(), "Too many connections 1");
-        } finally {
-            client.close();
+            assertNotNull(exception.getCause());
+            assertEquals(exception.getCause().getMessage(), "Too many connections 1");
         }
     }
 
     @Test(groups = { "standalone", "default_provider", "async" }, enabled = true, invocationCount = 10, alwaysRun = true)
     public void asyncDoGetKeepAliveHandlerTest_channelClosedDoesNotFail() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             // Use a l in case the assert fail
             final CountDownLatch l = new CountDownLatch(2);
 
-            final Map<String, Boolean> remoteAddresses = new ConcurrentHashMap<String, Boolean>();
+            final Map<String, Boolean> remoteAddresses = new ConcurrentHashMap<>();
 
             AsyncCompletionHandler<Response> handler = new AsyncCompletionHandlerAdapter() {
 
@@ -125,16 +127,13 @@ public Response onCompleted(Response response) throws Exception {
             }
 
             assertEquals(remoteAddresses.size(), 2);
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void multipleMaxConnectionOpenTest() throws Exception {
-        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setAllowPoolingConnections(true).setConnectionTimeout(5000).setMaxConnections(1).build();
-        AsyncHttpClient c = getAsyncHttpClient(cg);
-        try {
+        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setAllowPoolingConnections(true).setConnectTimeout(5000).setMaxConnections(1).build();
+        try (AsyncHttpClient c = getAsyncHttpClient(cg)) {
             String body = "hello there";
 
             // once
@@ -152,17 +151,15 @@ public void multipleMaxConnectionOpenTest() throws Exception {
                 exception = ex;
             }
             assertNotNull(exception);
-            assertEquals(exception.getMessage(), "Too many connections 1");
-        } finally {
-            c.close();
+            assertNotNull(exception.getCause());
+            assertEquals(exception.getCause().getMessage(), "Too many connections 1");
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void multipleMaxConnectionOpenTestWithQuery() throws Exception {
-        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setAllowPoolingConnections(true).setConnectionTimeout(5000).setMaxConnections(1).build();
-        AsyncHttpClient c = getAsyncHttpClient(cg);
-        try {
+        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setAllowPoolingConnections(true).setConnectTimeout(5000).setMaxConnections(1).build();
+        try (AsyncHttpClient c = getAsyncHttpClient(cg)) {
             String body = "hello there";
 
             // once
@@ -181,8 +178,6 @@ public void multipleMaxConnectionOpenTestWithQuery() throws Exception {
             assertNull(exception);
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 200);
-        } finally {
-            c.close();
         }
     }
 
@@ -196,8 +191,7 @@ public void multipleMaxConnectionOpenTestWithQuery() throws Exception {
     public void win7DisconnectTest() throws Exception {
         final AtomicInteger count = new AtomicInteger(0);
 
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             AsyncCompletionHandler<Response> handler = new AsyncCompletionHandlerAdapter() {
 
                 @Override
@@ -220,15 +214,12 @@ public Response onCompleted(Response response) throws Exception {
                 assertEquals(ex.getCause().getClass(), IOException.class);
                 assertEquals(count.get(), 1);
             }
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void asyncHandlerOnThrowableTest() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             final AtomicInteger count = new AtomicInteger();
             final String THIS_IS_NOT_FOR_YOU = "This is not for you";
             final CountDownLatch latch = new CountDownLatch(16);
@@ -257,8 +248,54 @@ public Response onCompleted(Response response) throws Exception {
             }
             latch.await(TIMEOUT, TimeUnit.SECONDS);
             assertEquals(count.get(), 0);
-        } finally {
-            client.close();
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void nonPoolableConnectionReleaseSemaphoresTest() throws Throwable {
+
+        AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder()
+        .setMaxConnections(6)
+        .setMaxConnectionsPerHost(3)
+        .build();
+
+        Request request = new RequestBuilder().setUrl(getTargetUrl()).setHeader("Connection", "close").build();
+
+        try (AsyncHttpClient client = getAsyncHttpClient(config)) {
+            client.executeRequest(request).get();
+            Thread.sleep(1000);
+            client.executeRequest(request).get();
+            Thread.sleep(1000);
+            client.executeRequest(request).get();
+            Thread.sleep(1000);
+            client.executeRequest(request).get();
+        }
+    }
+    
+    @Test(groups = { "standalone", "default_provider" })
+    public void testPooledEventsFired() throws Exception {
+        Request request = new RequestBuilder("GET").setUrl("http://127.0.0.1:" + port1 + "/Test").build();
+
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
+            EventCollectingHandler firstHandler = new EventCollectingHandler();
+            client.executeRequest(request, firstHandler).get(3, TimeUnit.SECONDS);
+            firstHandler.waitForCompletion(3, TimeUnit.SECONDS);
+
+            EventCollectingHandler secondHandler = new EventCollectingHandler();
+            client.executeRequest(request, secondHandler).get(3, TimeUnit.SECONDS);
+            secondHandler.waitForCompletion(3, TimeUnit.SECONDS);
+
+            List<String> expectedEvents = Arrays.asList(
+                    "ConnectionPool",
+                    "ConnectionPooled",
+                    "RequestSend",
+                    "HeadersWritten",
+                    "StatusReceived",
+                    "HeadersReceived",
+                    "ConnectionOffer",
+                    "Completed");
+
+            assertEquals(secondHandler.firedEvents, expectedEvents, "Got " + Arrays.toString(secondHandler.firedEvents.toArray()));
         }
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/cookie/CookieDecoderTest.java b/api/src/test/java/org/asynchttpclient/cookie/CookieDecoderTest.java
index f14aaf0b7..9c5f735b1 100644
--- a/api/src/test/java/org/asynchttpclient/cookie/CookieDecoderTest.java
+++ b/api/src/test/java/org/asynchttpclient/cookie/CookieDecoderTest.java
@@ -14,6 +14,7 @@
 
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertNull;
 
 import org.testng.annotations.Test;
 
@@ -24,7 +25,7 @@ public void testDecodeUnquoted() {
         Cookie cookie = CookieDecoder.decode("foo=value; domain=/; path=/");
         assertNotNull(cookie);
         assertEquals(cookie.getValue(), "value");
-        assertEquals(cookie.getRawValue(), "value");
+        assertEquals(cookie.isWrap(), false);
         assertEquals(cookie.getDomain(), "/");
         assertEquals(cookie.getPath(), "/");
     }
@@ -34,14 +35,20 @@ public void testDecodeQuoted() {
         Cookie cookie = CookieDecoder.decode("ALPHA=\"VALUE1\"; Domain=docs.foo.com; Path=/accounts; Expires=Wed, 05 Feb 2014 07:37:38 GMT; Secure; HttpOnly");
         assertNotNull(cookie);
         assertEquals(cookie.getValue(), "VALUE1");
-        assertEquals(cookie.getRawValue(), "\"VALUE1\"");
+        assertEquals(cookie.isWrap(), true);
     }
 
     @Test(groups = "fast")
     public void testDecodeQuotedContainingEscapedQuote() {
         Cookie cookie = CookieDecoder.decode("ALPHA=\"VALUE1\\\"\"; Domain=docs.foo.com; Path=/accounts; Expires=Wed, 05 Feb 2014 07:37:38 GMT; Secure; HttpOnly");
         assertNotNull(cookie);
-        assertEquals(cookie.getValue(), "VALUE1\"");
-        assertEquals(cookie.getRawValue(), "\"VALUE1\\\"\"");
+        assertEquals(cookie.getValue(), "VALUE1\\\"");
+        assertEquals(cookie.isWrap(), true);
+    }
+
+    @Test(groups = "fast")
+    public void testIgnoreEmptyDomain() {
+        Cookie cookie = CookieDecoder.decode("sessionid=OTY4ZDllNTgtYjU3OC00MWRjLTkzMWMtNGUwNzk4MTY0MTUw;Domain=;Path=/");
+        assertNull(cookie.getDomain());
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/cookie/RFC2616DateParserTest.java b/api/src/test/java/org/asynchttpclient/cookie/RFC2616DateParserTest.java
new file mode 100644
index 000000000..72dd77069
--- /dev/null
+++ b/api/src/test/java/org/asynchttpclient/cookie/RFC2616DateParserTest.java
@@ -0,0 +1,112 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.cookie;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+
+import org.testng.annotations.Test;
+
+import java.text.ParseException;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.GregorianCalendar;
+import java.util.TimeZone;
+
+/**
+ * See http://tools.ietf.org/html/rfc2616#section-3.3
+ * 
+ * @author slandelle
+ */
+public class RFC2616DateParserTest {
+
+    @Test(groups = "fast")
+    public void testRFC822() throws ParseException {
+        Date date = RFC2616DateParser.get().parse("Sun, 06 Nov 1994 08:49:37 GMT");
+        assertNotNull(date);
+
+        Calendar cal = GregorianCalendar.getInstance(TimeZone.getTimeZone("GMT"));
+        cal.setTime(date);
+        assertEquals(cal.get(Calendar.DAY_OF_WEEK), Calendar.SUNDAY);
+        assertEquals(cal.get(Calendar.DAY_OF_MONTH), 6);
+        assertEquals(cal.get(Calendar.MONTH), Calendar.NOVEMBER);
+        assertEquals(cal.get(Calendar.YEAR), 1994);
+        assertEquals(cal.get(Calendar.HOUR), 8);
+        assertEquals(cal.get(Calendar.MINUTE), 49);
+        assertEquals(cal.get(Calendar.SECOND), 37);
+    }
+
+    @Test(groups = "fast")
+    public void testRFC822SingleDigitDayOfMonth() throws ParseException {
+        Date date = RFC2616DateParser.get().parse("Sun, 6 Nov 1994 08:49:37 GMT");
+        assertNotNull(date);
+
+        Calendar cal = GregorianCalendar.getInstance(TimeZone.getTimeZone("GMT"));
+        cal.setTime(date);
+        assertEquals(cal.get(Calendar.DAY_OF_WEEK), Calendar.SUNDAY);
+        assertEquals(cal.get(Calendar.DAY_OF_MONTH), 6);
+        assertEquals(cal.get(Calendar.MONTH), Calendar.NOVEMBER);
+        assertEquals(cal.get(Calendar.YEAR), 1994);
+        assertEquals(cal.get(Calendar.HOUR), 8);
+        assertEquals(cal.get(Calendar.MINUTE), 49);
+        assertEquals(cal.get(Calendar.SECOND), 37);
+    }
+
+    @Test(groups = "fast")
+    public void testRFC822SingleDigitHour() throws ParseException {
+        Date date = RFC2616DateParser.get().parse("Sun, 6 Nov 1994 8:49:37 GMT");
+        assertNotNull(date);
+
+        Calendar cal = GregorianCalendar.getInstance(TimeZone.getTimeZone("GMT"));
+        cal.setTime(date);
+        assertEquals(cal.get(Calendar.DAY_OF_WEEK), Calendar.SUNDAY);
+        assertEquals(cal.get(Calendar.DAY_OF_MONTH), 6);
+        assertEquals(cal.get(Calendar.MONTH), Calendar.NOVEMBER);
+        assertEquals(cal.get(Calendar.YEAR), 1994);
+        assertEquals(cal.get(Calendar.HOUR), 8);
+        assertEquals(cal.get(Calendar.MINUTE), 49);
+        assertEquals(cal.get(Calendar.SECOND), 37);
+    }
+
+    @Test(groups = "fast")
+    public void testRFC850() throws ParseException {
+        Date date = RFC2616DateParser.get().parse("Sunday, 06-Nov-94 08:49:37 GMT");
+        assertNotNull(date);
+        
+        Calendar cal = GregorianCalendar.getInstance(TimeZone.getTimeZone("GMT"));
+        cal.setTime(date);
+        assertEquals(cal.get(Calendar.DAY_OF_WEEK), Calendar.SUNDAY);
+        assertEquals(cal.get(Calendar.DAY_OF_MONTH), 6);
+        assertEquals(cal.get(Calendar.MONTH), Calendar.NOVEMBER);
+        assertEquals(cal.get(Calendar.YEAR), 1994);
+        assertEquals(cal.get(Calendar.HOUR), 8);
+        assertEquals(cal.get(Calendar.MINUTE), 49);
+        assertEquals(cal.get(Calendar.SECOND), 37);
+    }
+
+    @Test(groups = "fast")
+    public void testANSIC() throws ParseException {
+        Date date = RFC2616DateParser.get().parse("Sun Nov  6 08:49:37 1994");
+        assertNotNull(date);
+
+        Calendar cal = GregorianCalendar.getInstance(TimeZone.getTimeZone("GMT"));
+        cal.setTime(date);
+        assertEquals(cal.get(Calendar.DAY_OF_WEEK), Calendar.SUNDAY);
+        assertEquals(cal.get(Calendar.DAY_OF_MONTH), 6);
+        assertEquals(cal.get(Calendar.MONTH), Calendar.NOVEMBER);
+        assertEquals(cal.get(Calendar.YEAR), 1994);
+        assertEquals(cal.get(Calendar.HOUR), 8);
+        assertEquals(cal.get(Calendar.MINUTE), 49);
+        assertEquals(cal.get(Calendar.SECOND), 37);
+    }
+}
diff --git a/api/src/test/java/org/asynchttpclient/date/RFC2616DateParserTest.java b/api/src/test/java/org/asynchttpclient/date/RFC2616DateParserTest.java
deleted file mode 100644
index ed171f692..000000000
--- a/api/src/test/java/org/asynchttpclient/date/RFC2616DateParserTest.java
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.date;
-
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-
-import org.testng.annotations.Test;
-
-/**
- * See http://tools.ietf.org/html/rfc2616#section-3.3
- * 
- * @author slandelle
- */
-public class RFC2616DateParserTest {
-
-    @Test(groups = "fast")
-    public void testRFC822() {
-        RFC2616Date date = new RFC2616DateParser("Sun, 06 Nov 1994 08:49:37 GMT").parse();
-        assertNotNull(date);
-        assertEquals(date.dayOfMonth(), 6);
-        assertEquals(date.month(), 11);
-        assertEquals(date.year(), 1994);
-        assertEquals(date.hour(), 8);
-        assertEquals(date.minute(), 49);
-        assertEquals(date.second(), 37);
-    }
-
-    @Test(groups = "fast")
-    public void testRFC822SingleDigitDayOfMonth() {
-        RFC2616Date date = new RFC2616DateParser("Sun, 6 Nov 1994 08:49:37 GMT").parse();
-        assertNotNull(date);
-        assertEquals(date.dayOfMonth(), 6);
-    }
-
-    @Test(groups = "fast")
-    public void testRFC822TwoDigitsYear() {
-        RFC2616Date date = new RFC2616DateParser("Sun, 6 Nov 94 08:49:37 GMT").parse();
-        assertNotNull(date);
-        assertEquals(date.year(), 1994);
-    }
-
-    @Test(groups = "fast")
-    public void testRFC822SingleDigitHour() {
-        RFC2616Date date = new RFC2616DateParser("Sun, 6 Nov 1994 8:49:37 GMT").parse();
-        assertNotNull(date);
-        assertEquals(date.hour(), 8);
-    }
-
-    @Test(groups = "fast")
-    public void testRFC822SingleDigitMinute() {
-        RFC2616Date date = new RFC2616DateParser("Sun, 6 Nov 1994 08:9:37 GMT").parse();
-        assertNotNull(date);
-        assertEquals(date.minute(), 9);
-    }
-
-    @Test(groups = "fast")
-    public void testRFC822SingleDigitSecond() {
-        RFC2616Date date = new RFC2616DateParser("Sun, 6 Nov 1994 08:49:7 GMT").parse();
-        assertNotNull(date);
-        assertEquals(date.second(), 7);
-    }
-
-    @Test(groups = "fast")
-    public void testRFC6265() {
-        RFC2616Date date = new RFC2616DateParser("Sun, 06 Nov 1994 08:49:37").parse();
-        assertNotNull(date);
-        assertEquals(date.dayOfMonth(), 6);
-        assertEquals(date.month(), 11);
-        assertEquals(date.year(), 1994);
-        assertEquals(date.hour(), 8);
-        assertEquals(date.minute(), 49);
-        assertEquals(date.second(), 37);
-    }
-
-    @Test(groups = "fast")
-    public void testRFC850() {
-        RFC2616Date date = new RFC2616DateParser("Sunday, 06-Nov-94 08:49:37 GMT").parse();
-        assertNotNull(date);
-        assertEquals(date.dayOfMonth(), 6);
-        assertEquals(date.month(), 11);
-        assertEquals(date.year(), 1994);
-        assertEquals(date.hour(), 8);
-        assertEquals(date.minute(), 49);
-        assertEquals(date.second(), 37);
-    }
-
-    @Test(groups = "fast")
-    public void testANSIC() {
-        RFC2616Date date = new RFC2616DateParser("Sun Nov  6 08:49:37 1994").parse();
-        assertNotNull(date);
-        assertEquals(date.dayOfMonth(), 6);
-        assertEquals(date.month(), 11);
-        assertEquals(date.year(), 1994);
-        assertEquals(date.hour(), 8);
-        assertEquals(date.minute(), 49);
-        assertEquals(date.second(), 37);
-    }
-}
diff --git a/api/src/test/java/org/asynchttpclient/async/FilterTest.java b/api/src/test/java/org/asynchttpclient/filter/FilterTest.java
similarity index 82%
rename from api/src/test/java/org/asynchttpclient/async/FilterTest.java
rename to api/src/test/java/org/asynchttpclient/filter/FilterTest.java
index 58f4c44d9..54791c1bc 100644
--- a/api/src/test/java/org/asynchttpclient/async/FilterTest.java
+++ b/api/src/test/java/org/asynchttpclient/filter/FilterTest.java
@@ -10,12 +10,23 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient.filter;
 
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-import static org.testng.Assert.fail;
+import static org.testng.Assert.*;
 
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Enumeration;
+import java.util.List;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.Request;
@@ -28,17 +39,6 @@
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.Test;
 
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Enumeration;
-import java.util.List;
-import java.util.concurrent.Future;
-import java.util.concurrent.atomic.AtomicBoolean;
-
 public abstract class FilterTest extends AbstractBasicTest {
 
     private static class BasicHandler extends AbstractHandler {
@@ -72,13 +72,10 @@ public void basicTest() throws Exception {
         AsyncHttpClientConfig.Builder b = new AsyncHttpClientConfig.Builder();
         b.addRequestFilter(new ThrottleRequestFilter(100));
 
-        AsyncHttpClient c = getAsyncHttpClient(b.build());
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(b.build())) {
             Response response = c.preparePost(getTargetUrl()).execute().get();
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 200);
-        } finally {
-            c.close();
         }
     }
 
@@ -87,9 +84,8 @@ public void loadThrottleTest() throws Exception {
         AsyncHttpClientConfig.Builder b = new AsyncHttpClientConfig.Builder();
         b.addRequestFilter(new ThrottleRequestFilter(10));
 
-        AsyncHttpClient c = getAsyncHttpClient(b.build());
-        try {
-            List<Future<Response>> futures = new ArrayList<Future<Response>>();
+        try (AsyncHttpClient c = getAsyncHttpClient(b.build())) {
+            List<Future<Response>> futures = new ArrayList<>();
             for (int i = 0; i < 200; i++) {
                 futures.add(c.preparePost(getTargetUrl()).execute());
             }
@@ -99,8 +95,6 @@ public void loadThrottleTest() throws Exception {
                 assertNotNull(f.get());
                 assertEquals(r.getStatusCode(), 200);
             }
-        } finally {
-            c.close();
         }
     }
 
@@ -108,16 +102,12 @@ public void loadThrottleTest() throws Exception {
     public void maxConnectionsText() throws Exception {
         AsyncHttpClientConfig.Builder b = new AsyncHttpClientConfig.Builder();
         b.addRequestFilter(new ThrottleRequestFilter(0, 1000));
-        AsyncHttpClient c = getAsyncHttpClient(b.build());
 
-        try {
-            /* Response response = */c.preparePost(getTargetUrl()).execute().get();
+        try (AsyncHttpClient c = getAsyncHttpClient(b.build())) {
+            c.preparePost(getTargetUrl()).execute().get();
             fail("Should have timed out");
-        } catch (IOException ex) {
-            assertNotNull(ex);
-            assertEquals(ex.getCause().getClass(), FilterException.class);
-        } finally {
-            c.close();
+        } catch (ExecutionException ex) {
+            assertTrue(ex.getCause() instanceof FilterException);
         }
     }
 
@@ -126,23 +116,17 @@ public void basicResponseFilterTest() throws Exception {
         AsyncHttpClientConfig.Builder b = new AsyncHttpClientConfig.Builder();
         b.addResponseFilter(new ResponseFilter() {
 
-            // @Override
+            @Override
             public <T> FilterContext<T> filter(FilterContext<T> ctx) throws FilterException {
                 return ctx;
             }
 
         });
-        AsyncHttpClient c = getAsyncHttpClient(b.build());
 
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(b.build())) {
             Response response = c.preparePost(getTargetUrl()).execute().get();
-
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 200);
-        } catch (IOException ex) {
-            fail("Should have timed out");
-        } finally {
-            c.close();
         }
     }
 
@@ -163,18 +147,12 @@ public void replayResponseFilterTest() throws Exception {
             }
 
         });
-        AsyncHttpClient c = getAsyncHttpClient(b.build());
 
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(b.build())) {
             Response response = c.preparePost(getTargetUrl()).execute().get();
-
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 200);
             assertEquals(response.getHeader("X-Replay"), "true");
-        } catch (IOException ex) {
-            fail("Should have timed out");
-        } finally {
-            c.close();
         }
     }
 
@@ -195,18 +173,12 @@ public void replayStatusCodeResponseFilterTest() throws Exception {
             }
 
         });
-        AsyncHttpClient c = getAsyncHttpClient(b.build());
 
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(b.build())) {
             Response response = c.preparePost(getTargetUrl()).execute().get();
-
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 200);
             assertEquals(response.getHeader("X-Replay"), "true");
-        } catch (IOException ex) {
-            fail("Should have timed out");
-        } finally {
-            c.close();
         }
     }
 
@@ -228,18 +200,12 @@ public void replayHeaderResponseFilterTest() throws Exception {
             }
 
         });
-        AsyncHttpClient c = getAsyncHttpClient(b.build());
 
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(b.build())) {
             Response response = c.preparePost(getTargetUrl()).addHeader("Ping", "Pong").execute().get();
-
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 200);
             assertEquals(response.getHeader("Ping"), "Pong");
-        } catch (IOException ex) {
-            fail("Should have timed out");
-        } finally {
-            c.close();
         }
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/BodyDeferringAsyncHandlerTest.java b/api/src/test/java/org/asynchttpclient/handler/BodyDeferringAsyncHandlerTest.java
similarity index 91%
rename from api/src/test/java/org/asynchttpclient/async/BodyDeferringAsyncHandlerTest.java
rename to api/src/test/java/org/asynchttpclient/handler/BodyDeferringAsyncHandlerTest.java
index baf91d11e..5b64a0d7a 100644
--- a/api/src/test/java/org/asynchttpclient/async/BodyDeferringAsyncHandlerTest.java
+++ b/api/src/test/java/org/asynchttpclient/handler/BodyDeferringAsyncHandlerTest.java
@@ -10,22 +10,23 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient.handler;
 
 import static org.apache.commons.io.IOUtils.copy;
-import static org.asynchttpclient.async.util.TestUtils.findFreePort;
+import static org.asynchttpclient.test.TestUtils.findFreePort;
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertNotEquals;
 import static org.testng.Assert.assertNotNull;
 import static org.testng.Assert.assertTrue;
 import static org.testng.Assert.fail;
 
+import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.BodyDeferringAsyncHandler;
-import org.asynchttpclient.BodyDeferringAsyncHandler.BodyDeferringInputStream;
 import org.asynchttpclient.BoundRequestBuilder;
 import org.asynchttpclient.Response;
+import org.asynchttpclient.handler.BodyDeferringAsyncHandler;
+import org.asynchttpclient.handler.BodyDeferringAsyncHandler.BodyDeferringInputStream;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.Test;
@@ -114,8 +115,7 @@ public AsyncHttpClientConfig getAsyncHttpClientConfig() {
 
     @Test(groups = { "standalone", "default_provider" })
     public void deferredSimple() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        AsyncHttpClient client = getAsyncHttpClient(getAsyncHttpClientConfig());
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(getAsyncHttpClientConfig())) {
             BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/deferredSimple");
 
             CountingOutputStream cos = new CountingOutputStream();
@@ -134,15 +134,12 @@ public void deferredSimple() throws IOException, ExecutionException, TimeoutExce
             f.get();
             // it all should be here now
             assertEquals(cos.getByteCount(), HALF_GIG);
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" }, enabled = false)
     public void deferredSimpleWithFailure() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        AsyncHttpClient client = getAsyncHttpClient(getAsyncHttpClientConfig());
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(getAsyncHttpClientConfig())) {
             BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/deferredSimpleWithFailure").addHeader("X-FAIL-TRANSFER",
                     Boolean.TRUE.toString());
 
@@ -167,15 +164,12 @@ public void deferredSimpleWithFailure() throws IOException, ExecutionException,
             }
             // it's incomplete, there was an error
             assertNotEquals(cos.getByteCount(), HALF_GIG);
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void deferredInputStreamTrick() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        AsyncHttpClient client = getAsyncHttpClient(getAsyncHttpClientConfig());
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(getAsyncHttpClientConfig())) {
             BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/deferredInputStreamTrick");
 
             PipedOutputStream pos = new PipedOutputStream();
@@ -203,16 +197,12 @@ public void deferredInputStreamTrick() throws IOException, ExecutionException, T
             // BodyDeferringInputStream does all.
             // it all should be here now
             assertEquals(cos.getByteCount(), HALF_GIG);
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void deferredInputStreamTrickWithFailure() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        AsyncHttpClient client = getAsyncHttpClient(getAsyncHttpClientConfig());
-
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(getAsyncHttpClientConfig())) {
             BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/deferredInputStreamTrickWithFailure").addHeader("X-FAIL-TRANSFER",
                     Boolean.TRUE.toString());
             PipedOutputStream pos = new PipedOutputStream();
@@ -240,16 +230,13 @@ public void deferredInputStreamTrickWithFailure() throws IOException, ExecutionE
             } catch (IOException e) {
                 // good!
             }
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void testConnectionRefused() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         int newPortWithoutAnyoneListening = findFreePort();
-        AsyncHttpClient client = getAsyncHttpClient(getAsyncHttpClientConfig());
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(getAsyncHttpClientConfig())) {
             BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + newPortWithoutAnyoneListening + "/testConnectionRefused");
 
             CountingOutputStream cos = new CountingOutputStream();
@@ -261,8 +248,6 @@ public void testConnectionRefused() throws IOException, ExecutionException, Time
             } catch (IOException e) {
                 // good
             }
-        } finally {
-            client.close();
         }
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/resumable/MapResumableProcessor.java b/api/src/test/java/org/asynchttpclient/handler/resumable/MapResumableProcessor.java
similarity index 74%
rename from api/src/test/java/org/asynchttpclient/resumable/MapResumableProcessor.java
rename to api/src/test/java/org/asynchttpclient/handler/resumable/MapResumableProcessor.java
index 3dbf4e827..1f43328b5 100644
--- a/api/src/test/java/org/asynchttpclient/resumable/MapResumableProcessor.java
+++ b/api/src/test/java/org/asynchttpclient/handler/resumable/MapResumableProcessor.java
@@ -1,6 +1,6 @@
-package org.asynchttpclient.resumable;
+package org.asynchttpclient.handler.resumable;
 
-import org.asynchttpclient.resumable.ResumableAsyncHandler.ResumableProcessor;
+import org.asynchttpclient.handler.resumable.ResumableAsyncHandler.ResumableProcessor;
 
 import java.util.HashMap;
 import java.util.Map;
@@ -11,7 +11,7 @@
 public class MapResumableProcessor
         implements ResumableProcessor {
 
-    Map<String, Long> map = new HashMap<String, Long>();
+    Map<String, Long> map = new HashMap<>();
 
     public void put(String key, long transferredBytes) {
         map.put(key, transferredBytes);
diff --git a/api/src/test/java/org/asynchttpclient/resumable/PropertiesBasedResumableProcesserTest.java b/api/src/test/java/org/asynchttpclient/handler/resumable/PropertiesBasedResumableProcesserTest.java
similarity index 91%
rename from api/src/test/java/org/asynchttpclient/resumable/PropertiesBasedResumableProcesserTest.java
rename to api/src/test/java/org/asynchttpclient/handler/resumable/PropertiesBasedResumableProcesserTest.java
index b5de1de8c..bd672f026 100644
--- a/api/src/test/java/org/asynchttpclient/resumable/PropertiesBasedResumableProcesserTest.java
+++ b/api/src/test/java/org/asynchttpclient/handler/resumable/PropertiesBasedResumableProcesserTest.java
@@ -1,4 +1,4 @@
-package org.asynchttpclient.resumable;
+package org.asynchttpclient.handler.resumable;
 
 /*
  * Copyright (c) 2010 Sonatype, Inc. All rights reserved.
@@ -15,6 +15,7 @@
 
 import static org.testng.Assert.assertEquals;
 
+import org.asynchttpclient.handler.resumable.PropertiesBasedResumableProcessor;
 import org.testng.annotations.Test;
 
 import java.util.Map;
diff --git a/api/src/test/java/org/asynchttpclient/resumable/ResumableAsyncHandlerTest.java b/api/src/test/java/org/asynchttpclient/handler/resumable/ResumableAsyncHandlerTest.java
similarity index 93%
rename from api/src/test/java/org/asynchttpclient/resumable/ResumableAsyncHandlerTest.java
rename to api/src/test/java/org/asynchttpclient/handler/resumable/ResumableAsyncHandlerTest.java
index b8dbcbab0..93387259b 100644
--- a/api/src/test/java/org/asynchttpclient/resumable/ResumableAsyncHandlerTest.java
+++ b/api/src/test/java/org/asynchttpclient/handler/resumable/ResumableAsyncHandlerTest.java
@@ -1,4 +1,4 @@
-package org.asynchttpclient.resumable;
+package org.asynchttpclient.handler.resumable;
 
 /*
  * Copyright (c) 2010 Sonatype, Inc. All rights reserved.
@@ -18,6 +18,7 @@
 
 import org.asynchttpclient.Request;
 import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.handler.resumable.ResumableAsyncHandler;
 import org.testng.annotations.Test;
 
 /**
diff --git a/api/src/test/java/org/asynchttpclient/ntlm/NtlmTest.java b/api/src/test/java/org/asynchttpclient/ntlm/NtlmTest.java
new file mode 100644
index 000000000..c3b0d4db9
--- /dev/null
+++ b/api/src/test/java/org/asynchttpclient/ntlm/NtlmTest.java
@@ -0,0 +1,103 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.ntlm;
+
+import java.io.IOException;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.asynchttpclient.AbstractBasicTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Realm;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.Realm.AuthScheme;
+import org.asynchttpclient.Realm.RealmBuilder;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.Assert;
+import org.testng.annotations.Test;
+
+public abstract class NtlmTest extends AbstractBasicTest {
+
+    public static class NTLMHandler extends AbstractHandler {
+
+        @Override
+        public void handle(String pathInContext, org.eclipse.jetty.server.Request request, HttpServletRequest httpRequest,
+                HttpServletResponse httpResponse) throws IOException, ServletException {
+
+            String authorization = httpRequest.getHeader("Authorization");
+            if (authorization == null) {
+                httpResponse.setStatus(401);
+                httpResponse.setHeader("WWW-Authenticate", "NTLM");
+
+            } else if (authorization.equals("NTLM TlRMTVNTUAABAAAAAYIIogAAAAAoAAAAAAAAACgAAAAFASgKAAAADw==")) {
+                httpResponse.setStatus(401);
+                httpResponse.setHeader("WWW-Authenticate", "NTLM TlRMTVNTUAACAAAAAAAAACgAAAABggAAU3J2Tm9uY2UAAAAAAAAAAA==");
+
+            } else if (authorization
+                    .equals("NTLM TlRMTVNTUAADAAAAGAAYAEgAAAAYABgAYAAAABQAFAB4AAAADAAMAIwAAAASABIAmAAAAAAAAACqAAAAAYIAAgUBKAoAAAAPrYfKbe/jRoW5xDxHeoxC1gBmfWiS5+iX4OAN4xBKG/IFPwfH3agtPEia6YnhsADTVQBSAFMAQQAtAE0ASQBOAE8AUgBaAGEAcABoAG8AZABMAGkAZwBoAHQAQwBpAHQAeQA=")) {
+                httpResponse.setStatus(200);
+            } else {
+                httpResponse.setStatus(401);
+            }
+
+            httpResponse.setContentLength(0);
+            httpResponse.getOutputStream().flush();
+            httpResponse.getOutputStream().close();
+        }
+    }
+
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new NTLMHandler();
+    }
+
+    private RealmBuilder realmBuilderBase() {
+        return new Realm.RealmBuilder()//
+                .setScheme(AuthScheme.NTLM)//
+                .setNtlmDomain("Ursa-Minor")//
+                .setNtlmHost("LightCity")//
+                .setPrincipal("Zaphod")//
+                .setPassword("Beeblebrox");
+    }
+
+    private void ntlmAuthTest(RealmBuilder realmBuilder) throws IOException, InterruptedException, ExecutionException {
+
+        AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder().setRealm(realmBuilder.build()).build();
+
+        try (AsyncHttpClient client = getAsyncHttpClient(config)) {
+            Request request = new RequestBuilder("GET").setUrl(getTargetUrl()).build();
+            Future<Response> responseFuture = client.executeRequest(request);
+            int status = responseFuture.get().getStatusCode();
+            Assert.assertEquals(status, 200);
+        }
+    }
+
+    @Test
+    public void lazyNTLMAuthTest() throws IOException, InterruptedException, ExecutionException {
+        ntlmAuthTest(realmBuilderBase());
+    }
+
+    @Test
+    public void preemptiveNTLMAuthTest() throws IOException, InterruptedException, ExecutionException {
+        ntlmAuthTest(realmBuilderBase().setUsePreemptiveAuth(true));
+    }
+}
+
diff --git a/api/src/test/java/org/asynchttpclient/oauth/OAuthSignatureCalculatorTest.java b/api/src/test/java/org/asynchttpclient/oauth/OAuthSignatureCalculatorTest.java
new file mode 100644
index 000000000..0cff66ed4
--- /dev/null
+++ b/api/src/test/java/org/asynchttpclient/oauth/OAuthSignatureCalculatorTest.java
@@ -0,0 +1,329 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package org.asynchttpclient.oauth;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.fail;
+
+import java.io.UnsupportedEncodingException;
+import java.net.URLDecoder;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import org.asynchttpclient.Param;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.uri.Uri;
+import org.testng.annotations.Test;
+
+/**
+ * Tests the OAuth signature behavior.
+ *
+ * See <a href=
+ * "https://oauth.googlecode.com/svn/code/javascript/example/signature.html"
+ * >Signature Tester</a> for an online oauth signature checker.
+ *
+ */
+public class OAuthSignatureCalculatorTest {
+    private static final String CONSUMER_KEY = "dpf43f3p2l4k3l03";
+
+    private static final String CONSUMER_SECRET = "kd94hf93k423kf44";
+
+    public static final String TOKEN_KEY = "nnch734d00sl2jdk";
+
+    public static final String TOKEN_SECRET = "pfkkdhi9sl3r4s00";
+
+    public static final String NONCE = "kllo9940pd9333jh";
+
+    final static long TIMESTAMP = 1191242096;
+
+    private static class StaticOAuthSignatureCalculator extends OAuthSignatureCalculator {
+
+        private final long timestamp;
+        private final String nonce;
+
+        public StaticOAuthSignatureCalculator(ConsumerKey consumerAuth, RequestToken userAuth, long timestamp, String nonce) {
+            super(consumerAuth, userAuth);
+            this.timestamp = timestamp;
+            this.nonce = nonce;
+        }
+
+        @Override
+        protected long generateTimestamp() {
+            return timestamp;
+        }
+
+        @Override
+        protected String generateNonce() {
+            return nonce;
+        }
+    }
+
+    // sample from RFC https://tools.ietf.org/html/rfc5849#section-3.4.1
+    private void testSignatureBaseString(Request request) {
+        ConsumerKey consumer = new ConsumerKey("9djdj82h48djs9d2", CONSUMER_SECRET);
+        RequestToken user = new RequestToken("kkk9d7dh3k39sjv7", TOKEN_SECRET);
+        OAuthSignatureCalculator calc = new OAuthSignatureCalculator(consumer, user);
+
+        String signatureBaseString = calc.signatureBaseString(//
+                request.getMethod(),//
+                request.getUri(),//
+                137131201,//
+                "7d8f3e4a",//
+                request.getFormParams(),//
+                request.getQueryParams()).toString();
+
+        assertEquals(signatureBaseString, "POST&" //
+                + "http%3A%2F%2Fexample.com%2Frequest" //
+                + "&a2%3Dr%2520b%26"//
+                + "a3%3D2%2520q%26" + "a3%3Da%26"//
+                + "b5%3D%253D%25253D%26"//
+                + "c%2540%3D%26"//
+                + "c2%3D%26"//
+                + "oauth_consumer_key%3D9djdj82h48djs9d2%26"//
+                + "oauth_nonce%3D7d8f3e4a%26"//
+                + "oauth_signature_method%3DHMAC-SHA1%26"//
+                + "oauth_timestamp%3D137131201%26"//
+                + "oauth_token%3Dkkk9d7dh3k39sjv7%26"//
+                + "oauth_version%3D1.0");
+    }
+
+    // fork above test with an OAuth token that requires encoding
+    private void testSignatureBaseStringWithEncodableOAuthToken(Request request) {
+        ConsumerKey consumer = new ConsumerKey("9djdj82h48djs9d2", CONSUMER_SECRET);
+        RequestToken user = new RequestToken("kkk9d7dh3k39sjv7", TOKEN_SECRET);
+        OAuthSignatureCalculator calc = new OAuthSignatureCalculator(consumer, user);
+
+        String signatureBaseString = calc.signatureBaseString(//
+                request.getMethod(),//
+                request.getUri(),//
+                137131201,//
+                "ZLc92RAkooZcIO/0cctl0Q==",//
+                request.getFormParams(),//
+                request.getQueryParams()).toString();
+
+        assertEquals(signatureBaseString, "POST&" //
+                + "http%3A%2F%2Fexample.com%2Frequest" //
+                + "&a2%3Dr%2520b%26"//
+                + "a3%3D2%2520q%26" + "a3%3Da%26"//
+                + "b5%3D%253D%25253D%26"//
+                + "c%2540%3D%26"//
+                + "c2%3D%26"//
+                + "oauth_consumer_key%3D9djdj82h48djs9d2%26"//
+                + "oauth_nonce%3DZLc92RAkooZcIO%252F0cctl0Q%253D%253D%26"//
+                + "oauth_signature_method%3DHMAC-SHA1%26"//
+                + "oauth_timestamp%3D137131201%26"//
+                + "oauth_token%3Dkkk9d7dh3k39sjv7%26"//
+                + "oauth_version%3D1.0");
+    }
+
+    @Test(groups = "fast")
+    public void testSignatureBaseStringWithProperlyEncodedUri() {
+
+        Request request = new RequestBuilder("POST")//
+                .setUrl("http://example.com/request?b5=%3D%253D&a3=a&c%40=&a2=r%20b")//
+                .addFormParam("c2", "")//
+                .addFormParam("a3", "2 q")//
+                .build();
+
+        testSignatureBaseString(request);
+        testSignatureBaseStringWithEncodableOAuthToken(request);
+    }
+
+    @Test(groups = "fast")
+    public void testSignatureBaseStringWithRawUri() {
+
+        // note: @ is legal so don't decode it into %40 because it won't be
+        // encoded back
+        // note: we don't know how to fix a = that should have been encoded as
+        // %3D but who would be stupid enough to do that?
+        Request request = new RequestBuilder("POST")//
+                .setUrl("http://example.com/request?b5=%3D%253D&a3=a&c%40=&a2=r b")//
+                .addFormParam("c2", "")//
+                .addFormParam("a3", "2 q")//
+                .build();
+
+        testSignatureBaseString(request);
+        testSignatureBaseStringWithEncodableOAuthToken(request);
+    }
+
+    // based on the reference test case from
+    // http://oauth.pbwiki.com/TestCases
+    @Test(groups = "fast")
+    public void testGetCalculateSignature() {
+        ConsumerKey consumer = new ConsumerKey(CONSUMER_KEY, CONSUMER_SECRET);
+        RequestToken user = new RequestToken(TOKEN_KEY, TOKEN_SECRET);
+        OAuthSignatureCalculator calc = new OAuthSignatureCalculator(consumer, user);
+        List<Param> queryParams = new ArrayList<>();
+        queryParams.add(new Param("file", "vacation.jpg"));
+        queryParams.add(new Param("size", "original"));
+        String url = "http://photos.example.net/photos";
+        String sig = calc.calculateSignature("GET", Uri.create(url), TIMESTAMP, NONCE, null, queryParams);
+
+        assertEquals(sig, "tR3+Ty81lMeYAr/Fid0kMTYa/WM=");
+    }
+
+    @Test(groups = "fast")
+    public void testPostCalculateSignature() {
+        ConsumerKey consumer = new ConsumerKey(CONSUMER_KEY, CONSUMER_SECRET);
+        RequestToken user = new RequestToken(TOKEN_KEY, TOKEN_SECRET);
+        OAuthSignatureCalculator calc = new StaticOAuthSignatureCalculator(consumer, user, TIMESTAMP, NONCE);
+
+        List<Param> formParams = new ArrayList<Param>();
+        formParams.add(new Param("file", "vacation.jpg"));
+        formParams.add(new Param("size", "original"));
+        String url = "http://photos.example.net/photos";
+        final Request req = new RequestBuilder("POST")//
+                .setUri(Uri.create(url))//
+                .setFormParams(formParams)//
+                .setSignatureCalculator(calc)//
+                .build();
+
+        // From the signature tester, POST should look like:
+        // normalized parameters:
+        // file=vacation.jpg&oauth_consumer_key=dpf43f3p2l4k3l03&oauth_nonce=kllo9940pd9333jh&oauth_signature_method=HMAC-SHA1&oauth_timestamp=1191242096&oauth_token=nnch734d00sl2jdk&oauth_version=1.0&size=original
+        // signature base string:
+        // POST&http%3A%2F%2Fphotos.example.net%2Fphotos&file%3Dvacation.jpg%26oauth_consumer_key%3Ddpf43f3p2l4k3l03%26oauth_nonce%3Dkllo9940pd9333jh%26oauth_signature_method%3DHMAC-SHA1%26oauth_timestamp%3D1191242096%26oauth_token%3Dnnch734d00sl2jdk%26oauth_version%3D1.0%26size%3Doriginal
+        // signature: wPkvxykrw+BTdCcGqKr+3I+PsiM=
+        // header: OAuth
+        // realm="",oauth_version="1.0",oauth_consumer_key="dpf43f3p2l4k3l03",oauth_token="nnch734d00sl2jdk",oauth_timestamp="1191242096",oauth_nonce="kllo9940pd9333jh",oauth_signature_method="HMAC-SHA1",oauth_signature="wPkvxykrw%2BBTdCcGqKr%2B3I%2BPsiM%3D"
+
+        String authHeader = req.getHeaders().get("Authorization").get(0);
+        Matcher m = Pattern.compile("oauth_signature=\"(.+?)\"").matcher(authHeader);
+        assertEquals(m.find(), true);
+        String encodedSig = m.group(1);
+        String sig = null;
+        try {
+            sig = URLDecoder.decode(encodedSig, "UTF-8");
+        } catch (UnsupportedEncodingException e) {
+            fail("bad encoding", e);
+        }
+
+        assertEquals(sig, "wPkvxykrw+BTdCcGqKr+3I+PsiM=");
+    }
+
+    @Test(groups = "fast")
+    public void testGetWithRequestBuilder() {
+        ConsumerKey consumer = new ConsumerKey(CONSUMER_KEY, CONSUMER_SECRET);
+        RequestToken user = new RequestToken(TOKEN_KEY, TOKEN_SECRET);
+        OAuthSignatureCalculator calc = new StaticOAuthSignatureCalculator(consumer, user, TIMESTAMP, NONCE);
+
+        List<Param> queryParams = new ArrayList<Param>();
+        queryParams.add(new Param("file", "vacation.jpg"));
+        queryParams.add(new Param("size", "original"));
+        String url = "http://photos.example.net/photos";
+
+        final Request req = new RequestBuilder("GET")//
+                .setUri(Uri.create(url))//
+                .setQueryParams(queryParams)//
+                .setSignatureCalculator(calc)//
+                .build();
+
+        final List<Param> params = req.getQueryParams();
+        assertEquals(params.size(), 2);
+
+        // From the signature tester, the URL should look like:
+        // normalized parameters:
+        // file=vacation.jpg&oauth_consumer_key=dpf43f3p2l4k3l03&oauth_nonce=kllo9940pd9333jh&oauth_signature_method=HMAC-SHA1&oauth_timestamp=1191242096&oauth_token=nnch734d00sl2jdk&oauth_version=1.0&size=original
+        // signature base string:
+        // GET&http%3A%2F%2Fphotos.example.net%2Fphotos&file%3Dvacation.jpg%26oauth_consumer_key%3Ddpf43f3p2l4k3l03%26oauth_nonce%3Dkllo9940pd9333jh%26oauth_signature_method%3DHMAC-SHA1%26oauth_timestamp%3D1191242096%26oauth_token%3Dnnch734d00sl2jdk%26oauth_version%3D1.0%26size%3Doriginal
+        // signature: tR3+Ty81lMeYAr/Fid0kMTYa/WM=
+        // Authorization header: OAuth
+        // realm="",oauth_version="1.0",oauth_consumer_key="dpf43f3p2l4k3l03",oauth_token="nnch734d00sl2jdk",oauth_timestamp="1191242096",oauth_nonce="kllo9940pd9333jh",oauth_signature_method="HMAC-SHA1",oauth_signature="tR3%2BTy81lMeYAr%2FFid0kMTYa%2FWM%3D"
+
+        String authHeader = req.getHeaders().get("Authorization").get(0);
+        Matcher m = Pattern.compile("oauth_signature=\"(.+?)\"").matcher(authHeader);
+        assertEquals(m.find(), true);
+        String encodedSig = m.group(1);
+        String sig = null;
+        try {
+            sig = URLDecoder.decode(encodedSig, "UTF-8");
+        } catch (UnsupportedEncodingException e) {
+            fail("bad encoding", e);
+        }
+
+        assertEquals(sig, "tR3+Ty81lMeYAr/Fid0kMTYa/WM=");
+        assertEquals(req.getUrl(), "http://photos.example.net/photos?file=vacation.jpg&size=original");
+    }
+
+    @Test(groups = "fast")
+    public void testGetWithRequestBuilderAndQuery() {
+        ConsumerKey consumer = new ConsumerKey(CONSUMER_KEY, CONSUMER_SECRET);
+        RequestToken user = new RequestToken(TOKEN_KEY, TOKEN_SECRET);
+        OAuthSignatureCalculator calc = new StaticOAuthSignatureCalculator(consumer, user, TIMESTAMP, NONCE);
+
+        String url = "http://photos.example.net/photos?file=vacation.jpg&size=original";
+
+        final Request req = new RequestBuilder("GET")//
+                .setUri(Uri.create(url))//
+                .setSignatureCalculator(calc)//
+                .build();
+
+        final List<Param> params = req.getQueryParams();
+        assertEquals(params.size(), 2);
+
+        // From the signature tester, the URL should look like:
+        //normalized parameters: file=vacation.jpg&oauth_consumer_key=dpf43f3p2l4k3l03&oauth_nonce=kllo9940pd9333jh&oauth_signature_method=HMAC-SHA1&oauth_timestamp=1191242096&oauth_token=nnch734d00sl2jdk&oauth_version=1.0&size=original
+        //signature base string: GET&http%3A%2F%2Fphotos.example.net%2Fphotos&file%3Dvacation.jpg%26oauth_consumer_key%3Ddpf43f3p2l4k3l03%26oauth_nonce%3Dkllo9940pd9333jh%26oauth_signature_method%3DHMAC-SHA1%26oauth_timestamp%3D1191242096%26oauth_token%3Dnnch734d00sl2jdk%26oauth_version%3D1.0%26size%3Doriginal
+        //signature: tR3+Ty81lMeYAr/Fid0kMTYa/WM=
+        //Authorization header: OAuth realm="",oauth_version="1.0",oauth_consumer_key="dpf43f3p2l4k3l03",oauth_token="nnch734d00sl2jdk",oauth_timestamp="1191242096",oauth_nonce="kllo9940pd9333jh",oauth_signature_method="HMAC-SHA1",oauth_signature="tR3%2BTy81lMeYAr%2FFid0kMTYa%2FWM%3D"
+
+        String authHeader = req.getHeaders().get("Authorization").get(0);
+        Matcher m = Pattern.compile("oauth_signature=\"(.+?)\"").matcher(authHeader);
+        assertEquals(m.find(), true);
+        String encodedSig = m.group(1);
+        String sig = null;
+        try {
+            sig = URLDecoder.decode(encodedSig, "UTF-8");
+        } catch (UnsupportedEncodingException e) {
+            fail("bad encoding", e);
+        }
+
+        assertEquals(sig, "tR3+Ty81lMeYAr/Fid0kMTYa/WM=");
+        assertEquals(req.getUrl(), "http://photos.example.net/photos?file=vacation.jpg&size=original");
+    }
+
+    @Test(groups = "fast")
+    public void testWithNullRequestToken() {
+      String url = "http://photos.example.net/photos?file=vacation.jpg&size=original";
+      ConsumerKey consumer = new ConsumerKey("9djdj82h48djs9d2", CONSUMER_SECRET);
+      RequestToken user = new RequestToken(null, null);
+      OAuthSignatureCalculator calc = new OAuthSignatureCalculator(consumer, user);
+
+      final Request request = new RequestBuilder("GET")//
+          .setUri(Uri.create(url))//
+          .setSignatureCalculator(calc)//
+          .build();
+
+      String signatureBaseString = calc.signatureBaseString(//
+          request.getMethod(),//
+          request.getUri(),//
+          137131201,//
+          "ZLc92RAkooZcIO/0cctl0Q==",//
+          request.getFormParams(),//
+          request.getQueryParams()).toString();
+
+      assertEquals(signatureBaseString, "GET&" + //
+          "http%3A%2F%2Fphotos.example.net%2Fphotos&file%3Dvacation.jpg%26" + //
+          "oauth_consumer_key%3D9djdj82h48djs9d2%26" + //
+          "oauth_nonce%3DZLc92RAkooZcIO%252F0cctl0Q%253D%253D%26" + //
+          "oauth_signature_method%3DHMAC-SHA1%26" + //
+          "oauth_timestamp%3D137131201%26" + //
+          "oauth_version%3D1.0%26size%3Doriginal");
+    }
+}
diff --git a/api/src/test/java/org/asynchttpclient/oauth/TestSignatureCalculator.java b/api/src/test/java/org/asynchttpclient/oauth/TestSignatureCalculator.java
deleted file mode 100644
index b3c696dc4..000000000
--- a/api/src/test/java/org/asynchttpclient/oauth/TestSignatureCalculator.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package org.asynchttpclient.oauth;
-
-import static org.testng.Assert.assertEquals;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.asynchttpclient.Param;
-import org.asynchttpclient.uri.Uri;
-import org.testng.annotations.Test;
-
-public class TestSignatureCalculator {
-    private static final String CONSUMER_KEY = "dpf43f3p2l4k3l03";
-
-    private static final String CONSUMER_SECRET = "kd94hf93k423kf44";
-
-    public static final String TOKEN_KEY = "nnch734d00sl2jdk";
-
-    public static final String TOKEN_SECRET = "pfkkdhi9sl3r4s00";
-
-    public static final String NONCE = "kllo9940pd9333jh";
-
-    final static long TIMESTAMP = 1191242096;
-
-    // based on the reference test case from
-    // http://oauth.pbwiki.com/TestCases
-    @Test(groups = "fast")
-    public void test() {
-        ConsumerKey consumer = new ConsumerKey(CONSUMER_KEY, CONSUMER_SECRET);
-        RequestToken user = new RequestToken(TOKEN_KEY, TOKEN_SECRET);
-        OAuthSignatureCalculator calc = new OAuthSignatureCalculator(consumer, user);
-        List<Param> queryParams = new ArrayList<Param>();
-        queryParams.add(new Param("file", "vacation.jpg"));
-        queryParams.add(new Param("size", "original"));
-        String url = "http://photos.example.net/photos";
-        String sig = calc.calculateSignature("GET", Uri.create(url), TIMESTAMP, NONCE, null, queryParams);
-
-        assertEquals(sig, "tR3+Ty81lMeYAr/Fid0kMTYa/WM=");
-    }
-}
diff --git a/api/src/test/java/org/asynchttpclient/async/ProxyTest.java b/api/src/test/java/org/asynchttpclient/proxy/ProxyTest.java
similarity index 56%
rename from api/src/test/java/org/asynchttpclient/async/ProxyTest.java
rename to api/src/test/java/org/asynchttpclient/proxy/ProxyTest.java
index 3e5220d69..8519808c6 100644
--- a/api/src/test/java/org/asynchttpclient/async/ProxyTest.java
+++ b/api/src/test/java/org/asynchttpclient/proxy/ProxyTest.java
@@ -13,25 +13,13 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient.proxy;
 
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertFalse;
 import static org.testng.Assert.assertNotNull;
 import static org.testng.Assert.fail;
 
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.ProxyServer;
-import org.asynchttpclient.Response;
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
 import java.io.IOException;
 import java.net.ConnectException;
 import java.net.InetSocketAddress;
@@ -47,6 +35,22 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.asynchttpclient.AbstractBasicTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.config.AsyncHttpClientConfigDefaults;
+import org.asynchttpclient.config.AsyncHttpClientConfigHelper;
+import org.asynchttpclient.proxy.ProxyServer;
+import org.asynchttpclient.util.ProxyUtils;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
+
 /**
  * Proxy usage tests.
  * 
@@ -73,80 +77,64 @@ public AbstractHandler configureHandler() throws Exception {
 
     @Test(groups = { "standalone", "default_provider" })
     public void testRequestLevelProxy() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             String target = "http://127.0.0.1:1234/";
             Future<Response> f = client.prepareGet(target).setProxyServer(new ProxyServer("127.0.0.1", port1)).execute();
             Response resp = f.get(3, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
             assertEquals(resp.getHeader("target"), "/");
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void testGlobalProxy() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClientConfig cfg = new AsyncHttpClientConfig.Builder().setProxyServer(new ProxyServer("127.0.0.1", port1)).build();
-        AsyncHttpClient client = getAsyncHttpClient(cfg);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(cfg)) {
             String target = "http://127.0.0.1:1234/";
             Future<Response> f = client.prepareGet(target).execute();
             Response resp = f.get(3, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
             assertEquals(resp.getHeader("target"), "/");
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void testBothProxies() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClientConfig cfg = new AsyncHttpClientConfig.Builder().setProxyServer(new ProxyServer("127.0.0.1", port1 - 1)).build();
-        AsyncHttpClient client = getAsyncHttpClient(cfg);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(cfg)) {
             String target = "http://127.0.0.1:1234/";
             Future<Response> f = client.prepareGet(target).setProxyServer(new ProxyServer("127.0.0.1", port1)).execute();
             Response resp = f.get(3, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
             assertEquals(resp.getHeader("target"), "/");
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void testNonProxyHosts() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         AsyncHttpClientConfig cfg = new AsyncHttpClientConfig.Builder().setProxyServer(new ProxyServer("127.0.0.1", port1 - 1)).build();
-        AsyncHttpClient client = getAsyncHttpClient(cfg);
-        try {
-
+        try (AsyncHttpClient client = getAsyncHttpClient(cfg)) {
             String target = "http://127.0.0.1:1234/";
             client.prepareGet(target).setProxyServer(new ProxyServer("127.0.0.1", port1).addNonProxyHost("127.0.0.1")).execute().get();
             assertFalse(true);
         } catch (Throwable e) {
             assertNotNull(e.getCause());
             assertEquals(e.getCause().getClass(), ConnectException.class);
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void testNonProxyHostIssue202() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             String target = "http://127.0.0.1:" + port1 + "/";
             Future<Response> f = client.prepareGet(target).setProxyServer(new ProxyServer("127.0.0.1", port1 - 1).addNonProxyHost("127.0.0.1")).execute();
             Response resp = f.get(3, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
             assertEquals(resp.getHeader("target"), "/");
-        } finally {
-            client.close();
         }
     }
 
@@ -161,38 +149,31 @@ public void runSequentiallyBecauseNotThreadSafe() throws Exception {
 
     // @Test(groups = { "standalone", "default_provider" })
     public void testProxyProperties() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        Properties originalProps = System.getProperties();
-        try {
-            Properties props = new Properties();
-            props.putAll(originalProps);
+        // FIXME not threadsafe!
+        Properties originalProps = new Properties();
+        originalProps.putAll(System.getProperties());
+        System.setProperty(ProxyUtils.PROXY_HOST, "127.0.0.1");
+        System.setProperty(ProxyUtils.PROXY_PORT, String.valueOf(port1));
+        System.setProperty(ProxyUtils.PROXY_NONPROXYHOSTS, "localhost");
+        AsyncHttpClientConfigHelper.reloadProperties();
 
-            // FIXME most likely non threadsafe!
-            System.setProperties(props);
+        AsyncHttpClientConfig cfg = new AsyncHttpClientConfig.Builder().setUseProxyProperties(true).build();
 
-            System.setProperty("http.proxyHost", "127.0.0.1");
-            System.setProperty("http.proxyPort", String.valueOf(port1));
-            System.setProperty("http.nonProxyHosts", "localhost");
+        try (AsyncHttpClient client = getAsyncHttpClient(cfg)) {
+            String target = "http://127.0.0.1:1234/";
+            Future<Response> f = client.prepareGet(target).execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getHeader("target"), "/");
 
-            AsyncHttpClientConfig cfg = new AsyncHttpClientConfig.Builder().setUseProxyProperties(true).build();
-            AsyncHttpClient client = getAsyncHttpClient(cfg);
+            target = "http://localhost:1234/";
+            f = client.prepareGet(target).execute();
             try {
-                String target = "http://127.0.0.1:1234/";
-                Future<Response> f = client.prepareGet(target).execute();
-                Response resp = f.get(3, TimeUnit.SECONDS);
-                assertNotNull(resp);
-                assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-                assertEquals(resp.getHeader("target"), "/");
-
-                target = "http://localhost:1234/";
-                f = client.prepareGet(target).execute();
-                try {
-                    resp = f.get(3, TimeUnit.SECONDS);
-                    fail("should not be able to connect");
-                } catch (ExecutionException e) {
-                    // ok, no proxy used
-                }
-            } finally {
-                client.close();
+                resp = f.get(3, TimeUnit.SECONDS);
+                fail("should not be able to connect");
+            } catch (ExecutionException e) {
+                // ok, no proxy used
             }
         } finally {
             System.setProperties(originalProps);
@@ -201,30 +182,22 @@ public void testProxyProperties() throws IOException, ExecutionException, Timeou
 
     // @Test(groups = { "standalone", "default_provider" })
     public void testIgnoreProxyPropertiesByDefault() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        Properties originalProps = System.getProperties();
-        try {
-            Properties props = new Properties();
-            props.putAll(originalProps);
-
-            // FIXME not threadsafe!
-            System.setProperties(props);
-
-            System.setProperty("http.proxyHost", "127.0.0.1");
-            System.setProperty("http.proxyPort", String.valueOf(port1));
-            System.setProperty("http.nonProxyHosts", "localhost");
-
-            AsyncHttpClient client = getAsyncHttpClient(null);
+        // FIXME not threadsafe!
+        Properties originalProps = new Properties();
+        originalProps.putAll(System.getProperties());
+        System.setProperty(ProxyUtils.PROXY_HOST, "127.0.0.1");
+        System.setProperty(ProxyUtils.PROXY_PORT, String.valueOf(port1));
+        System.setProperty(ProxyUtils.PROXY_NONPROXYHOSTS, "localhost");
+        AsyncHttpClientConfigHelper.reloadProperties();
+
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
+            String target = "http://127.0.0.1:1234/";
+            Future<Response> f = client.prepareGet(target).execute();
             try {
-                String target = "http://127.0.0.1:1234/";
-                Future<Response> f = client.prepareGet(target).execute();
-                try {
-                    f.get(3, TimeUnit.SECONDS);
-                    fail("should not be able to connect");
-                } catch (ExecutionException e) {
-                    // ok, no proxy used
-                }
-            } finally {
-                client.close();
+                f.get(3, TimeUnit.SECONDS);
+                fail("should not be able to connect");
+            } catch (ExecutionException e) {
+                // ok, no proxy used
             }
         } finally {
             System.setProperties(originalProps);
@@ -233,38 +206,30 @@ public void testIgnoreProxyPropertiesByDefault() throws IOException, ExecutionEx
 
     // @Test(groups = { "standalone", "default_provider" })
     public void testProxyActivationProperty() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        Properties originalProps = System.getProperties();
-        try {
-            Properties props = new Properties();
-            props.putAll(originalProps);
-
-            // FIXME not threadsafe!
-            System.setProperties(props);
-
-            System.setProperty("http.proxyHost", "127.0.0.1");
-            System.setProperty("http.proxyPort", String.valueOf(port1));
-            System.setProperty("http.nonProxyHosts", "localhost");
-            System.setProperty("org.asynchttpclient.AsyncHttpClientConfig.useProxyProperties", "true");
+        // FIXME not threadsafe!
+        Properties originalProps = new Properties();
+        originalProps.putAll(System.getProperties());
+        System.setProperty(ProxyUtils.PROXY_HOST, "127.0.0.1");
+        System.setProperty(ProxyUtils.PROXY_PORT, String.valueOf(port1));
+        System.setProperty(ProxyUtils.PROXY_NONPROXYHOSTS, "localhost");
+        System.setProperty(AsyncHttpClientConfigDefaults.ASYNC_CLIENT_CONFIG_ROOT + "useProxyProperties", "true");
+        AsyncHttpClientConfigHelper.reloadProperties();
+
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
+            String target = "http://127.0.0.1:1234/";
+            Future<Response> f = client.prepareGet(target).execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getHeader("target"), "/");
 
-            AsyncHttpClient client = getAsyncHttpClient(null);
+            target = "http://localhost:1234/";
+            f = client.prepareGet(target).execute();
             try {
-                String target = "http://127.0.0.1:1234/";
-                Future<Response> f = client.prepareGet(target).execute();
-                Response resp = f.get(3, TimeUnit.SECONDS);
-                assertNotNull(resp);
-                assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-                assertEquals(resp.getHeader("target"), "/");
-
-                target = "http://localhost:1234/";
-                f = client.prepareGet(target).execute();
-                try {
-                    resp = f.get(3, TimeUnit.SECONDS);
-                    fail("should not be able to connect");
-                } catch (ExecutionException e) {
-                    // ok, no proxy used
-                }
-            } finally {
-                client.close();
+                resp = f.get(3, TimeUnit.SECONDS);
+                fail("should not be able to connect");
+            } catch (ExecutionException e) {
+                // ok, no proxy used
             }
         } finally {
             System.setProperties(originalProps);
@@ -273,31 +238,23 @@ public void testProxyActivationProperty() throws IOException, ExecutionException
 
     // @Test(groups = { "standalone", "default_provider" })
     public void testWildcardNonProxyHosts() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        Properties originalProps = System.getProperties();
-        try {
-            Properties props = new Properties();
-            props.putAll(originalProps);
-
-            // FIXME not threadsafe!
-            System.setProperties(props);
-
-            System.setProperty("http.proxyHost", "127.0.0.1");
-            System.setProperty("http.proxyPort", String.valueOf(port1));
-            System.setProperty("http.nonProxyHosts", "127.*");
-
-            AsyncHttpClientConfig cfg = new AsyncHttpClientConfig.Builder().setUseProxyProperties(true).build();
-            AsyncHttpClient client = getAsyncHttpClient(cfg);
+        // FIXME not threadsafe!
+        Properties originalProps = new Properties();
+        originalProps.putAll(System.getProperties());
+        System.setProperty(ProxyUtils.PROXY_HOST, "127.0.0.1");
+        System.setProperty(ProxyUtils.PROXY_PORT, String.valueOf(port1));
+        System.setProperty(ProxyUtils.PROXY_NONPROXYHOSTS, "127.*");
+        AsyncHttpClientConfigHelper.reloadProperties();
+
+        AsyncHttpClientConfig cfg = new AsyncHttpClientConfig.Builder().setUseProxyProperties(true).build();
+        try (AsyncHttpClient client = getAsyncHttpClient(cfg)) {
+            String target = "http://127.0.0.1:1234/";
+            Future<Response> f = client.prepareGet(target).execute();
             try {
-                String target = "http://127.0.0.1:1234/";
-                Future<Response> f = client.prepareGet(target).execute();
-                try {
-                    f.get(3, TimeUnit.SECONDS);
-                    fail("should not be able to connect");
-                } catch (ExecutionException e) {
-                    // ok, no proxy used
-                }
-            } finally {
-                client.close();
+                f.get(3, TimeUnit.SECONDS);
+                fail("should not be able to connect");
+            } catch (ExecutionException e) {
+                // ok, no proxy used
             }
         } finally {
             System.setProperties(originalProps);
@@ -307,7 +264,6 @@ public void testWildcardNonProxyHosts() throws IOException, ExecutionException,
     // @Test(groups = { "standalone", "default_provider" })
     public void testUseProxySelector() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         ProxySelector originalProxySelector = ProxySelector.getDefault();
-        try {
             ProxySelector.setDefault(new ProxySelector() {
                 public List<Proxy> select(URI uri) {
                     if (uri.getHost().equals("127.0.0.1")) {
@@ -321,26 +277,22 @@ public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
                 }
             });
 
-            AsyncHttpClientConfig cfg = new AsyncHttpClientConfig.Builder().setUseProxySelector(true).build();
-            AsyncHttpClient client = getAsyncHttpClient(cfg);
-            try {
-                String target = "http://127.0.0.1:1234/";
-                Future<Response> f = client.prepareGet(target).execute();
-                Response resp = f.get(3, TimeUnit.SECONDS);
-                assertNotNull(resp);
-                assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-                assertEquals(resp.getHeader("target"), "/");
+        AsyncHttpClientConfig cfg = new AsyncHttpClientConfig.Builder().setUseProxySelector(true).build();
+        try (AsyncHttpClient client = getAsyncHttpClient(cfg)) {
+            String target = "http://127.0.0.1:1234/";
+            Future<Response> f = client.prepareGet(target).execute();
+            Response resp = f.get(3, TimeUnit.SECONDS);
+            assertNotNull(resp);
+            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+            assertEquals(resp.getHeader("target"), "/");
 
-                target = "http://localhost:1234/";
-                f = client.prepareGet(target).execute();
-                try {
-                    f.get(3, TimeUnit.SECONDS);
-                    fail("should not be able to connect");
-                } catch (ExecutionException e) {
-                    // ok, no proxy used
-                }
-            } finally {
-                client.close();
+            target = "http://localhost:1234/";
+            f = client.prepareGet(target).execute();
+            try {
+                f.get(3, TimeUnit.SECONDS);
+                fail("should not be able to connect");
+            } catch (ExecutionException e) {
+                // ok, no proxy used
             }
         } finally {
             // FIXME not threadsafe
diff --git a/api/src/test/java/org/asynchttpclient/async/ProxyTunnellingTest.java b/api/src/test/java/org/asynchttpclient/proxy/ProxyTunnellingTest.java
similarity index 84%
rename from api/src/test/java/org/asynchttpclient/async/ProxyTunnellingTest.java
rename to api/src/test/java/org/asynchttpclient/proxy/ProxyTunnellingTest.java
index 203f52a26..2d6b13a1b 100644
--- a/api/src/test/java/org/asynchttpclient/async/ProxyTunnellingTest.java
+++ b/api/src/test/java/org/asynchttpclient/proxy/ProxyTunnellingTest.java
@@ -10,21 +10,22 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient.proxy;
 
-import static org.asynchttpclient.async.util.TestUtils.findFreePort;
-import static org.asynchttpclient.async.util.TestUtils.newJettyHttpServer;
-import static org.asynchttpclient.async.util.TestUtils.newJettyHttpsServer;
+import static org.asynchttpclient.test.TestUtils.findFreePort;
+import static org.asynchttpclient.test.TestUtils.newJettyHttpServer;
+import static org.asynchttpclient.test.TestUtils.newJettyHttpsServer;
 import static org.testng.Assert.assertEquals;
 
+import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.AsyncCompletionHandlerBase;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.ProxyServer;
 import org.asynchttpclient.RequestBuilder;
 import org.asynchttpclient.Response;
-import org.asynchttpclient.SimpleAsyncHttpClient;
-import org.asynchttpclient.async.util.EchoHandler;
+import org.asynchttpclient.proxy.ProxyServer;
+import org.asynchttpclient.simple.SimpleAsyncHttpClient;
+import org.asynchttpclient.test.EchoHandler;
 import org.eclipse.jetty.proxy.ConnectHandler;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.handler.AbstractHandler;
@@ -44,8 +45,6 @@
 
     private Server server2;
 
-    public abstract String getProviderClass();
-
     public AbstractHandler configureHandler() throws Exception {
         return new ConnectHandler();
     }
@@ -82,8 +81,7 @@ public void testRequestProxy() throws IOException, InterruptedException, Executi
         .setAcceptAnyCertificate(true)//
         .build();
 
-        AsyncHttpClient asyncHttpClient = getAsyncHttpClient(config);
-        try {
+        try (AsyncHttpClient asyncHttpClient = getAsyncHttpClient(config)) {
             RequestBuilder rb = new RequestBuilder("GET").setProxyServer(ps).setUrl(getTargetUrl2());
             Future<Response> responseFuture = asyncHttpClient.executeRequest(rb.build(), new AsyncCompletionHandlerBase() {
 
@@ -100,8 +98,6 @@ public Response onCompleted(Response response) throws Exception {
             Response r = responseFuture.get();
             assertEquals(r.getStatusCode(), 200);
             assertEquals(r.getHeader("X-Connection"), "keep-alive");
-        } finally {
-            asyncHttpClient.close();
         }
     }
 
@@ -112,8 +108,7 @@ public void testConfigProxy() throws IOException, InterruptedException, Executio
                 .setProxyServer(new ProxyServer(ProxyServer.Protocol.HTTPS, "127.0.0.1", port1))//
                 .setAcceptAnyCertificate(true)//
                 .build();
-        AsyncHttpClient asyncHttpClient = getAsyncHttpClient(config);
-        try {
+        try (AsyncHttpClient asyncHttpClient = getAsyncHttpClient(config)) {
             Future<Response> responseFuture = asyncHttpClient.executeRequest(new RequestBuilder("GET").setUrl(getTargetUrl2()).build(), new AsyncCompletionHandlerBase() {
 
                 public void onThrowable(Throwable t) {
@@ -129,16 +124,13 @@ public Response onCompleted(Response response) throws Exception {
             Response r = responseFuture.get();
             assertEquals(r.getStatusCode(), 200);
             assertEquals(r.getHeader("X-Connection"), "keep-alive");
-        } finally {
-            asyncHttpClient.close();
         }
     }
 
     @Test(groups = { "online", "default_provider" })
     public void testSimpleAHCConfigProxy() throws IOException, InterruptedException, ExecutionException, TimeoutException {
 
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
-                .setProviderClass(getProviderClass())//
+        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
                 .setProxyProtocol(ProxyServer.Protocol.HTTPS)//
                 .setProxyHost("127.0.0.1")//
                 .setProxyPort(port1)//
@@ -146,14 +138,11 @@ public void testSimpleAHCConfigProxy() throws IOException, InterruptedException,
                 .setUrl(getTargetUrl2())//
                 .setAcceptAnyCertificate(true)//
                 .setHeader("Content-Type", "text/html")//
-                .build();
-        try {
+                .build()) {
             Response r = client.get().get();
 
             assertEquals(r.getStatusCode(), 200);
             assertEquals(r.getHeader("X-Connection"), "keep-alive");
-        } finally {
-            client.close();
         }
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/util/ProxyUtilsTest.java b/api/src/test/java/org/asynchttpclient/proxy/ProxyUtilsTest.java
similarity index 94%
rename from api/src/test/java/org/asynchttpclient/util/ProxyUtilsTest.java
rename to api/src/test/java/org/asynchttpclient/proxy/ProxyUtilsTest.java
index fdcb8884b..ae15c3ac6 100644
--- a/api/src/test/java/org/asynchttpclient/util/ProxyUtilsTest.java
+++ b/api/src/test/java/org/asynchttpclient/proxy/ProxyUtilsTest.java
@@ -10,14 +10,15 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.util;
+package org.asynchttpclient.proxy;
 
 import static org.testng.Assert.assertFalse;
 import static org.testng.Assert.assertTrue;
 
-import org.asynchttpclient.ProxyServer;
 import org.asynchttpclient.Request;
 import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.proxy.ProxyServer;
+import org.asynchttpclient.util.ProxyUtils;
 import org.testng.annotations.Test;
 
 public class ProxyUtilsTest {
diff --git a/api/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsTest.java b/api/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsTest.java
new file mode 100644
index 000000000..0aa87058f
--- /dev/null
+++ b/api/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsTest.java
@@ -0,0 +1,263 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.reactivestreams;
+
+import static org.asynchttpclient.test.TestUtils.LARGE_IMAGE_BYTES;
+import static org.testng.Assert.assertEquals;
+
+import java.io.ByteArrayOutputStream;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+
+import org.asynchttpclient.AbstractBasicTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.ListenableFuture;
+import org.asynchttpclient.handler.StreamedAsyncHandler;
+import org.reactivestreams.Publisher;
+import org.reactivestreams.Subscriber;
+import org.reactivestreams.Subscription;
+import org.testng.annotations.Test;
+
+public abstract class ReactiveStreamsTest extends AbstractBasicTest {
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void streamedResponseTest() throws Throwable {
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
+
+            ListenableFuture<SimpleStreamedAsyncHandler> future = c.preparePost(getTargetUrl())
+                    .setBody(LARGE_IMAGE_BYTES)
+                    .execute(new SimpleStreamedAsyncHandler());
+
+            assertEquals(future.get().getBytes(), LARGE_IMAGE_BYTES);
+
+            // Run it again to check that the pipeline is in a good state
+            future = c.preparePost(getTargetUrl())
+                    .setBody(LARGE_IMAGE_BYTES)
+                    .execute(new SimpleStreamedAsyncHandler());
+
+            assertEquals(future.get().getBytes(), LARGE_IMAGE_BYTES);
+
+            // Make sure a regular request still works
+            assertEquals(c.preparePost(getTargetUrl())
+                    .setBody("Hello")
+                    .execute().get().getResponseBody(), "Hello");
+
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void cancelStreamedResponseTest() throws Throwable {
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
+
+            // Cancel immediately
+            c.preparePost(getTargetUrl())
+                    .setBody(LARGE_IMAGE_BYTES)
+                    .execute(new CancellingStreamedAsyncProvider(0)).get();
+
+            // Cancel after 1 element
+            c.preparePost(getTargetUrl())
+                    .setBody(LARGE_IMAGE_BYTES)
+                    .execute(new CancellingStreamedAsyncProvider(1)).get();
+
+            // Cancel after 10 elements
+            c.preparePost(getTargetUrl())
+                    .setBody(LARGE_IMAGE_BYTES)
+                    .execute(new CancellingStreamedAsyncProvider(10)).get();
+
+            // Make sure a regular request works
+            assertEquals(c.preparePost(getTargetUrl())
+                    .setBody("Hello")
+                    .execute().get().getResponseBody(), "Hello");
+
+        }
+    }
+
+    static protected class SimpleStreamedAsyncHandler implements StreamedAsyncHandler<SimpleStreamedAsyncHandler>{
+        private final SimpleSubscriber<HttpResponseBodyPart> subscriber;
+
+        public SimpleStreamedAsyncHandler() {
+            this(new SimpleSubscriber<HttpResponseBodyPart>());
+        }
+
+        public SimpleStreamedAsyncHandler(SimpleSubscriber<HttpResponseBodyPart> subscriber) {
+            this.subscriber = subscriber;
+        }
+        @Override
+        public State onStream(Publisher<HttpResponseBodyPart> publisher) {
+            publisher.subscribe(subscriber);
+            return State.CONTINUE;
+        }
+
+        @Override
+        public void onThrowable(Throwable t) {
+            throw new AssertionError(t);
+        }
+
+        @Override
+        public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+            throw new AssertionError("Should not have received body part");
+        }
+
+        @Override
+        public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+            return State.CONTINUE;
+        }
+
+        @Override
+        public State onHeadersReceived(HttpResponseHeaders headers) throws Exception {
+            return State.CONTINUE;
+        }
+
+        @Override
+        public SimpleStreamedAsyncHandler onCompleted() throws Exception {
+            return this;
+        }
+
+        public byte[] getBytes() throws Throwable {
+            List<HttpResponseBodyPart> bodyParts = subscriber.getElements();
+            ByteArrayOutputStream bytes = new ByteArrayOutputStream();
+            for (HttpResponseBodyPart part : bodyParts) {
+                part.writeTo(bytes);
+            }
+            return bytes.toByteArray();
+        }
+    }
+
+    /**
+     * Simple subscriber that requests and buffers one element at a time.
+     */
+    static protected class SimpleSubscriber<T> implements Subscriber<T> {
+        private volatile Subscription subscription;
+        private volatile Throwable error;
+        private final List<T> elements = Collections.synchronizedList(new ArrayList<T>());
+        private final CountDownLatch latch = new CountDownLatch(1);
+
+        @Override
+        public void onSubscribe(Subscription subscription) {
+            this.subscription = subscription;
+            subscription.request(1);
+        }
+
+        @Override
+        public void onNext(T t) {
+            elements.add(t);
+            subscription.request(1);
+        }
+
+        @Override
+        public void onError(Throwable error) {
+            this.error = error;
+            latch.countDown();
+        }
+
+        @Override
+        public void onComplete() {
+            latch.countDown();
+        }
+
+        public List<T> getElements() throws Throwable {
+            latch.await();
+            if (error != null) {
+                throw error;
+            } else {
+                return elements;
+            }
+        }
+    }
+
+    static class CancellingStreamedAsyncProvider implements StreamedAsyncHandler<CancellingStreamedAsyncProvider> {
+        private final int cancelAfter;
+
+        public CancellingStreamedAsyncProvider(int cancelAfter) {
+            this.cancelAfter = cancelAfter;
+        }
+
+        @Override
+        public State onStream(Publisher<HttpResponseBodyPart> publisher) {
+            publisher.subscribe(new CancellingSubscriber<HttpResponseBodyPart>(cancelAfter));
+            return State.CONTINUE;
+        }
+
+        @Override
+        public void onThrowable(Throwable t) {
+            throw new AssertionError(t);
+        }
+
+        @Override
+        public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+            throw new AssertionError("Should not have received body part");
+        }
+
+        @Override
+        public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+            return State.CONTINUE;
+        }
+
+        @Override
+        public State onHeadersReceived(HttpResponseHeaders headers) throws Exception {
+            return State.CONTINUE;
+        }
+
+        @Override
+        public CancellingStreamedAsyncProvider onCompleted() throws Exception {
+            return this;
+        }
+    }
+
+    /**
+     * Simple subscriber that cancels after receiving n elements.
+     */
+    static class CancellingSubscriber<T> implements Subscriber<T> {
+        private final int cancelAfter;
+
+        public CancellingSubscriber(int cancelAfter) {
+            this.cancelAfter = cancelAfter;
+        }
+
+        private volatile Subscription subscription;
+        private volatile int count;
+
+        @Override
+        public void onSubscribe(Subscription subscription) {
+            this.subscription = subscription;
+            if (cancelAfter == 0) {
+                subscription.cancel();
+            } else {
+                subscription.request(1);
+            }
+        }
+
+        @Override
+        public void onNext(T t) {
+            count++;
+            if (count == cancelAfter) {
+                subscription.cancel();
+            } else {
+                subscription.request(1);
+            }
+        }
+
+        @Override
+        public void onError(Throwable error) {
+        }
+
+        @Override
+        public void onComplete() {
+        }
+    }
+}
diff --git a/api/src/test/java/org/asynchttpclient/async/BodyChunkTest.java b/api/src/test/java/org/asynchttpclient/request/body/BodyChunkTest.java
similarity index 87%
rename from api/src/test/java/org/asynchttpclient/async/BodyChunkTest.java
rename to api/src/test/java/org/asynchttpclient/request/body/BodyChunkTest.java
index 727e0d67a..41d2729b5 100644
--- a/api/src/test/java/org/asynchttpclient/async/BodyChunkTest.java
+++ b/api/src/test/java/org/asynchttpclient/request/body/BodyChunkTest.java
@@ -13,15 +13,16 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient.request.body;
 
 import static org.testng.Assert.assertEquals;
 
+import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.RequestBuilder;
 import org.asynchttpclient.Response;
-import org.asynchttpclient.generators.InputStreamBodyGenerator;
+import org.asynchttpclient.request.body.generator.InputStreamBodyGenerator;
 import org.testng.annotations.Test;
 
 import java.io.ByteArrayInputStream;
@@ -35,14 +36,12 @@
     public void negativeContentTypeTest() throws Exception {
 
         AsyncHttpClientConfig.Builder confbuilder = new AsyncHttpClientConfig.Builder();
-        confbuilder = confbuilder.setConnectionTimeout(100);
+        confbuilder = confbuilder.setConnectTimeout(100);
         confbuilder = confbuilder.setMaxConnections(50);
         confbuilder = confbuilder.setRequestTimeout(5 * 60 * 1000); // 5 minutes
 
         // Create client
-        AsyncHttpClient client = getAsyncHttpClient(confbuilder.build());
-        try {
-
+        try (AsyncHttpClient client = getAsyncHttpClient(confbuilder.build())) {
             RequestBuilder requestBuilder = new RequestBuilder("POST").setUrl(getTargetUrl()).setHeader("Content-Type", "message/rfc822");
 
             requestBuilder.setBody(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())));
@@ -53,8 +52,6 @@ public void negativeContentTypeTest() throws Exception {
             Response response = future.get();
             assertEquals(response.getStatusCode(), 200);
             assertEquals(response.getResponseBody(), MY_MESSAGE);
-        } finally {
-            client.close();
         }
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/request/body/ChunkingTest.java b/api/src/test/java/org/asynchttpclient/request/body/ChunkingTest.java
new file mode 100755
index 000000000..227963574
--- /dev/null
+++ b/api/src/test/java/org/asynchttpclient/request/body/ChunkingTest.java
@@ -0,0 +1,141 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.request.body;
+
+import static org.asynchttpclient.test.TestUtils.LARGE_IMAGE_BYTES;
+import static org.asynchttpclient.test.TestUtils.LARGE_IMAGE_FILE;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
+import static org.testng.FileAssert.fail;
+
+import java.io.BufferedInputStream;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+
+import org.asynchttpclient.AbstractBasicTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.ListenableFuture;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.request.body.generator.FeedableBodyGenerator;
+import org.asynchttpclient.request.body.generator.InputStreamBodyGenerator;
+import org.asynchttpclient.request.body.generator.SimpleFeedableBodyGenerator;
+import org.testng.annotations.Test;
+
+/**
+ * Test that the url fetcher is able to communicate via a proxy
+ * 
+ * @author dominict
+ */
+abstract public class ChunkingTest extends AbstractBasicTest {
+    // So we can just test the returned data is the image,
+    // and doesn't contain the chunked delimeters.
+    @Test()
+    public void testBufferLargerThanFileWithStreamBodyGenerator() throws Throwable {
+        doTestWithInputStreamBodyGenerator(new BufferedInputStream(new FileInputStream(LARGE_IMAGE_FILE), 400000));
+    }
+
+    @Test()
+    public void testBufferSmallThanFileWithStreamBodyGenerator() throws Throwable {
+        doTestWithInputStreamBodyGenerator(new BufferedInputStream(new FileInputStream(LARGE_IMAGE_FILE)));
+    }
+
+    @Test()
+    public void testDirectFileWithStreamBodyGenerator() throws Throwable {
+        doTestWithInputStreamBodyGenerator(new FileInputStream(LARGE_IMAGE_FILE));
+    }
+
+    @Test()
+    public void testDirectFileWithFeedableBodyGenerator() throws Throwable {
+        doTestWithFeedableBodyGenerator(new FileInputStream(LARGE_IMAGE_FILE));
+    }
+
+    public void doTestWithInputStreamBodyGenerator(InputStream is) throws Throwable {
+        AsyncHttpClientConfig.Builder bc = httpClientBuilder();
+
+        try (AsyncHttpClient c = getAsyncHttpClient(bc.build())) {
+
+            RequestBuilder builder = new RequestBuilder("POST");
+            builder.setUrl(getTargetUrl());
+            builder.setBody(new InputStreamBodyGenerator(is));
+
+            Request r = builder.build();
+
+            final ListenableFuture<Response> responseFuture = c.executeRequest(r);
+            waitForAndAssertResponse(responseFuture);
+        }
+    }
+
+    public void doTestWithFeedableBodyGenerator(InputStream is) throws Throwable {
+        AsyncHttpClientConfig.Builder bc = httpClientBuilder();
+
+        try (AsyncHttpClient c = getAsyncHttpClient(bc.build())) {
+
+            RequestBuilder builder = new RequestBuilder("POST");
+            builder.setUrl(getTargetUrl());
+            final FeedableBodyGenerator feedableBodyGenerator = new SimpleFeedableBodyGenerator();
+            builder.setBody(feedableBodyGenerator);
+
+            Request r = builder.build();
+
+            final ListenableFuture<Response> responseFuture = c.executeRequest(r);
+
+            feed(feedableBodyGenerator, is);
+
+            waitForAndAssertResponse(responseFuture);
+        }
+    }
+
+    private void feed(FeedableBodyGenerator feedableBodyGenerator, InputStream is) throws IOException {
+        try (InputStream inputStream = is) {
+            byte[] buffer = new byte[512];
+            for (int i = 0; (i = inputStream.read(buffer)) > -1;) {
+                byte[] chunk = new byte[i];
+                System.arraycopy(buffer, 0, chunk, 0, i);
+                feedableBodyGenerator.feed(ByteBuffer.wrap(chunk), false);
+            }
+        }
+        feedableBodyGenerator.feed(ByteBuffer.allocate(0), true);
+
+    }
+
+    private AsyncHttpClientConfig.Builder httpClientBuilder() {
+        return new AsyncHttpClientConfig.Builder()//
+                .setAllowPoolingConnections(true)//
+                .setMaxConnectionsPerHost(1)//
+                .setMaxConnections(1)//
+                .setConnectTimeout(1000)//
+                .setRequestTimeout(1000).setFollowRedirect(true);
+    }
+
+    private void waitForAndAssertResponse(ListenableFuture<Response> responseFuture) throws InterruptedException, java.util.concurrent.ExecutionException, IOException {
+        Response response = responseFuture.get();
+        if (500 == response.getStatusCode()) {
+            StringBuilder sb = new StringBuilder();
+            sb.append("==============\n");
+            sb.append("500 response from call\n");
+            sb.append("Headers:" + response.getHeaders() + "\n");
+            sb.append("==============\n");
+            logger.debug(sb.toString());
+            assertEquals(response.getStatusCode(), 500, "Should have 500 status code");
+            assertTrue(response.getHeader("X-Exception").contains("invalid.chunk.length"), "Should have failed due to chunking");
+            fail("HARD Failing the test due to provided InputStreamBodyGenerator, chunking incorrectly:" + response.getHeader("X-Exception"));
+        } else {
+            assertEquals(response.getResponseBodyAsBytes(), LARGE_IMAGE_BYTES);
+        }
+    }
+}
diff --git a/api/src/test/java/org/asynchttpclient/async/EmptyBodyTest.java b/api/src/test/java/org/asynchttpclient/request/body/EmptyBodyTest.java
similarity index 88%
rename from api/src/test/java/org/asynchttpclient/async/EmptyBodyTest.java
rename to api/src/test/java/org/asynchttpclient/request/body/EmptyBodyTest.java
index fc0693cba..468060392 100644
--- a/api/src/test/java/org/asynchttpclient/async/EmptyBodyTest.java
+++ b/api/src/test/java/org/asynchttpclient/request/body/EmptyBodyTest.java
@@ -13,7 +13,7 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient.request.body;
 
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertFalse;
@@ -21,6 +21,7 @@
 import static org.testng.Assert.assertTrue;
 import static org.testng.Assert.fail;
 
+import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.HttpResponseBodyPart;
@@ -68,10 +69,9 @@ public AbstractHandler configureHandler() throws Exception {
 
     @Test(groups = { "standalone", "default_provider" })
     public void testEmptyBody() throws IOException {
-        AsyncHttpClient ahc = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient ahc = getAsyncHttpClient(null)) {
             final AtomicBoolean err = new AtomicBoolean(false);
-            final LinkedBlockingQueue<String> queue = new LinkedBlockingQueue<String>();
+            final LinkedBlockingQueue<String> queue = new LinkedBlockingQueue<>();
             final AtomicBoolean status = new AtomicBoolean(false);
             final AtomicInteger headers = new AtomicInteger(0);
             final CountDownLatch latch = new CountDownLatch(1);
@@ -81,7 +81,7 @@ public void onThrowable(Throwable t) {
                     err.set(true);
                 }
 
-                public STATE onBodyPartReceived(HttpResponseBodyPart e) throws Exception {
+                public State onBodyPartReceived(HttpResponseBodyPart e) throws Exception {
                     byte[] bytes = e.getBodyPartBytes();
 
                     if (bytes.length != 0) {
@@ -90,19 +90,19 @@ public STATE onBodyPartReceived(HttpResponseBodyPart e) throws Exception {
                         logger.warn("Sampling stacktrace.", new Throwable("trace that, we should not get called for empty body."));
                         queue.put(s);
                     }
-                    return STATE.CONTINUE;
+                    return State.CONTINUE;
                 }
 
-                public STATE onStatusReceived(HttpResponseStatus e) throws Exception {
+                public State onStatusReceived(HttpResponseStatus e) throws Exception {
                     status.set(true);
-                    return AsyncHandler.STATE.CONTINUE;
+                    return AsyncHandler.State.CONTINUE;
                 }
 
-                public STATE onHeadersReceived(HttpResponseHeaders e) throws Exception {
+                public State onHeadersReceived(HttpResponseHeaders e) throws Exception {
                     if (headers.incrementAndGet() == 2) {
                         throw new Exception("Analyze this.");
                     }
-                    return STATE.CONTINUE;
+                    return State.CONTINUE;
                 }
 
                 public Object onCompleted() throws Exception {
@@ -119,15 +119,12 @@ public Object onCompleted() throws Exception {
             assertEquals(queue.size(), 0);
             assertTrue(status.get());
             assertEquals(headers.get(), 1);
-        } finally {
-            ahc.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void testPutEmptyBody() throws Exception {
-        AsyncHttpClient ahc = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient ahc = getAsyncHttpClient(null)) {
             Response response = ahc.preparePut(getTargetUrl()).setBody("String").execute().get();
 
             assertNotNull(response);
@@ -135,8 +132,6 @@ public void testPutEmptyBody() throws Exception {
             assertEquals(response.getResponseBody(), "");
             assertTrue(response.getResponseBodyAsStream() instanceof InputStream);
             assertEquals(response.getResponseBodyAsStream().read(), -1);
-        } finally {
-            ahc.close();
         }
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/FastUnauthorizedUploadTest.java b/api/src/test/java/org/asynchttpclient/request/body/FastUnauthorizedUploadTest.java
similarity index 85%
rename from api/src/test/java/org/asynchttpclient/async/FastUnauthorizedUploadTest.java
rename to api/src/test/java/org/asynchttpclient/request/body/FastUnauthorizedUploadTest.java
index 59ab42924..d3771038f 100644
--- a/api/src/test/java/org/asynchttpclient/async/FastUnauthorizedUploadTest.java
+++ b/api/src/test/java/org/asynchttpclient/request/body/FastUnauthorizedUploadTest.java
@@ -10,15 +10,16 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient.request.body;
 
-import static org.asynchttpclient.async.util.TestUtils.createTempFile;
+import static java.nio.charset.StandardCharsets.*;
+import static org.asynchttpclient.test.TestUtils.createTempFile;
 import static org.testng.Assert.assertEquals;
 
+import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.Response;
-import org.asynchttpclient.multipart.FilePart;
-import org.asynchttpclient.util.StandardCharsets;
+import org.asynchttpclient.request.body.multipart.FilePart;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.Test;
@@ -51,13 +52,10 @@ public void handle(String target, Request baseRequest, HttpServletRequest req, H
     public void testUnauthorizedWhileUploading() throws Exception {
         File file = createTempFile(1024 * 1024);
 
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
-            Response response = client.preparePut(getTargetUrl()).addBodyPart(new FilePart("test", file, "application/octet-stream", StandardCharsets.UTF_8)).execute()
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
+            Response response = client.preparePut(getTargetUrl()).addBodyPart(new FilePart("test", file, "application/octet-stream", UTF_8)).execute()
                     .get();
             assertEquals(response.getStatusCode(), 401);
-        } finally {
-            client.close();
         }
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/FilePartLargeFileTest.java b/api/src/test/java/org/asynchttpclient/request/body/FilePartLargeFileTest.java
similarity index 80%
rename from api/src/test/java/org/asynchttpclient/async/FilePartLargeFileTest.java
rename to api/src/test/java/org/asynchttpclient/request/body/FilePartLargeFileTest.java
index b2f378f9c..b27164b2f 100644
--- a/api/src/test/java/org/asynchttpclient/async/FilePartLargeFileTest.java
+++ b/api/src/test/java/org/asynchttpclient/request/body/FilePartLargeFileTest.java
@@ -10,17 +10,18 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient.request.body;
 
-import static org.asynchttpclient.async.util.TestUtils.LARGE_IMAGE_FILE;
-import static org.asynchttpclient.async.util.TestUtils.createTempFile;
+import static java.nio.charset.StandardCharsets.*;
+import static org.asynchttpclient.test.TestUtils.LARGE_IMAGE_FILE;
+import static org.asynchttpclient.test.TestUtils.createTempFile;
 import static org.testng.Assert.assertEquals;
 
+import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.Response;
-import org.asynchttpclient.multipart.FilePart;
-import org.asynchttpclient.util.StandardCharsets;
+import org.asynchttpclient.request.body.multipart.FilePart;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.Test;
@@ -62,12 +63,9 @@ public void handle(String target, Request baseRequest, HttpServletRequest req, H
 
     @Test(groups = { "standalone", "default_provider" }, enabled = true)
     public void testPutImageFile() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeout(100 * 6000).build());
-        try {
-            Response response = client.preparePut(getTargetUrl()).addBodyPart(new FilePart("test", LARGE_IMAGE_FILE, "application/octet-stream", StandardCharsets.UTF_8)).execute().get();
+        try (AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeout(100 * 6000).build())) {
+            Response response = client.preparePut(getTargetUrl()).addBodyPart(new FilePart("test", LARGE_IMAGE_FILE, "application/octet-stream", UTF_8)).execute().get();
             assertEquals(response.getStatusCode(), 200);
-        } finally {
-            client.close();
         }
     }
 
@@ -75,12 +73,9 @@ public void testPutImageFile() throws Exception {
     public void testPutLargeTextFile() throws Exception {
         File file = createTempFile(1024 * 1024);
 
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
-            Response response = client.preparePut(getTargetUrl()).addBodyPart(new FilePart("test", file, "application/octet-stream", StandardCharsets.UTF_8)).execute().get();
+        try (AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeout(100 * 6000).build())) {
+            Response response = client.preparePut(getTargetUrl()).addBodyPart(new FilePart("test", file, "application/octet-stream", UTF_8)).execute().get();
             assertEquals(response.getStatusCode(), 200);
-        } finally {
-            client.close();
         }
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/InputStreamTest.java b/api/src/test/java/org/asynchttpclient/request/body/InputStreamTest.java
similarity index 96%
rename from api/src/test/java/org/asynchttpclient/async/InputStreamTest.java
rename to api/src/test/java/org/asynchttpclient/request/body/InputStreamTest.java
index bd5b47284..7e2c9ea15 100644
--- a/api/src/test/java/org/asynchttpclient/async/InputStreamTest.java
+++ b/api/src/test/java/org/asynchttpclient/request/body/InputStreamTest.java
@@ -13,11 +13,12 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient.request.body;
 
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertNotNull;
 
+import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
 import org.asynchttpclient.Response;
@@ -68,8 +69,7 @@ public AbstractHandler configureHandler() throws Exception {
     @Test(groups = { "standalone", "default_provider" })
     public void testInvalidInputStream() throws IOException, ExecutionException, TimeoutException, InterruptedException {
 
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
             FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
             h.add("Content-Type", "application/x-www-form-urlencoded");
 
@@ -101,8 +101,6 @@ public int read() throws IOException {
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
             assertEquals(resp.getHeader("X-Param"), "abc");
-        } finally {
-            c.close();
         }
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/PutLargeFileTest.java b/api/src/test/java/org/asynchttpclient/request/body/PutLargeFileTest.java
similarity index 85%
rename from api/src/test/java/org/asynchttpclient/async/PutLargeFileTest.java
rename to api/src/test/java/org/asynchttpclient/request/body/PutLargeFileTest.java
index 51400e304..3602a8481 100644
--- a/api/src/test/java/org/asynchttpclient/async/PutLargeFileTest.java
+++ b/api/src/test/java/org/asynchttpclient/request/body/PutLargeFileTest.java
@@ -10,11 +10,12 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient.request.body;
 
-import static org.asynchttpclient.async.util.TestUtils.createTempFile;
+import static org.asynchttpclient.test.TestUtils.createTempFile;
 import static org.testng.Assert.assertEquals;
 
+import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.Response;
@@ -41,12 +42,9 @@ public void testPutLargeFile() throws Exception {
 
         int timeout = (int) file.length() / 1000;
 
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setConnectionTimeout(timeout).build());
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setConnectTimeout(timeout).build())) {
             Response response = client.preparePut(getTargetUrl()).setBody(file).execute().get();
             assertEquals(response.getStatusCode(), 200);
-        } finally {
-            client.close();
         }
     }
 
@@ -55,12 +53,9 @@ public void testPutSmallFile() throws Exception {
 
         File file = createTempFile(1024);
 
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             Response response = client.preparePut(getTargetUrl()).setBody(file).execute().get();
             assertEquals(response.getStatusCode(), 200);
-        } finally {
-            client.close();
         }
     }
 
diff --git a/api/src/test/java/org/asynchttpclient/request/body/ReactiveStreamsTest.java b/api/src/test/java/org/asynchttpclient/request/body/ReactiveStreamsTest.java
new file mode 100644
index 000000000..1cc67556b
--- /dev/null
+++ b/api/src/test/java/org/asynchttpclient/request/body/ReactiveStreamsTest.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.request.body;
+
+import static org.asynchttpclient.test.TestUtils.LARGE_IMAGE_BYTES;
+import static org.asynchttpclient.test.TestUtils.LARGE_IMAGE_PUBLISHER;
+import static org.testng.Assert.assertEquals;
+
+import java.nio.ByteBuffer;
+import java.util.concurrent.ExecutionException;
+
+import org.asynchttpclient.AbstractBasicTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.BoundRequestBuilder;
+import org.asynchttpclient.Response;
+import org.reactivestreams.Publisher;
+import org.testng.annotations.Test;
+
+import rx.Observable;
+import rx.RxReactiveStreams;
+
+public abstract class ReactiveStreamsTest extends AbstractBasicTest {
+
+    @Test(groups = { "standalone", "default_provider" }, enabled = true)
+    public void testStreamingPutImage() throws Exception {
+        try (AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeout(100 * 6000).build())) {
+            Response response = client.preparePut(getTargetUrl()).setBody(LARGE_IMAGE_PUBLISHER).execute().get();
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(response.getResponseBodyAsBytes(), LARGE_IMAGE_BYTES);
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider" }, enabled = true)
+    public void testConnectionDoesNotGetClosed() throws Exception { // test that we can stream the same request multiple times
+        try (AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeout(100 * 6000).build())) {
+            BoundRequestBuilder requestBuilder = client.preparePut(getTargetUrl()).setBody(LARGE_IMAGE_PUBLISHER);
+            Response response = requestBuilder.execute().get();
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(response.getResponseBodyAsBytes(), LARGE_IMAGE_BYTES);
+            
+            response = requestBuilder.execute().get();
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(response.getResponseBodyAsBytes(), LARGE_IMAGE_BYTES);
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider" }, enabled = true, expectedExceptions = ExecutionException.class)
+    public void testFailingStream() throws Exception {
+        try (AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeout(100 * 6000).build())) {
+            Observable<ByteBuffer> failingObservable = Observable.error(new FailedStream());
+            Publisher<ByteBuffer> failingPublisher = RxReactiveStreams.toPublisher(failingObservable);
+
+            client.preparePut(getTargetUrl()).setBody(failingPublisher).execute().get();
+        }
+    }
+
+    @SuppressWarnings("serial")
+    private class FailedStream extends RuntimeException {}
+}
diff --git a/api/src/test/java/org/asynchttpclient/async/TransferListenerTest.java b/api/src/test/java/org/asynchttpclient/request/body/TransferListenerTest.java
similarity index 71%
rename from api/src/test/java/org/asynchttpclient/async/TransferListenerTest.java
rename to api/src/test/java/org/asynchttpclient/request/body/TransferListenerTest.java
index 90ffb1993..25074ae7e 100644
--- a/api/src/test/java/org/asynchttpclient/async/TransferListenerTest.java
+++ b/api/src/test/java/org/asynchttpclient/request/body/TransferListenerTest.java
@@ -10,21 +10,21 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient.request.body;
 
-import static org.asynchttpclient.async.util.TestUtils.createTempFile;
+import static org.asynchttpclient.test.TestUtils.createTempFile;
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertNotNull;
 import static org.testng.Assert.assertNull;
-import static org.testng.Assert.fail;
 
+import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
 import org.asynchttpclient.Response;
-import org.asynchttpclient.generators.FileBodyGenerator;
-import org.asynchttpclient.listener.TransferCompletionHandler;
-import org.asynchttpclient.listener.TransferListener;
+import org.asynchttpclient.handler.TransferCompletionHandler;
+import org.asynchttpclient.handler.TransferListener;
+import org.asynchttpclient.request.body.generator.FileBodyGenerator;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.Test;
 
@@ -81,12 +81,11 @@ public AbstractHandler configureHandler() throws Exception {
 
     @Test(groups = { "standalone", "default_provider" })
     public void basicGetTest() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
-            final AtomicReference<Throwable> throwable = new AtomicReference<Throwable>();
-            final AtomicReference<FluentCaseInsensitiveStringsMap> hSent = new AtomicReference<FluentCaseInsensitiveStringsMap>();
-            final AtomicReference<FluentCaseInsensitiveStringsMap> hRead = new AtomicReference<FluentCaseInsensitiveStringsMap>();
-            final AtomicReference<byte[]> bb = new AtomicReference<byte[]>();
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
+            final AtomicReference<Throwable> throwable = new AtomicReference<>();
+            final AtomicReference<FluentCaseInsensitiveStringsMap> hSent = new AtomicReference<>();
+            final AtomicReference<FluentCaseInsensitiveStringsMap> hRead = new AtomicReference<>();
+            final AtomicReference<byte[]> bb = new AtomicReference<>();
             final AtomicBoolean completed = new AtomicBoolean(false);
 
             TransferCompletionHandler tl = new TransferCompletionHandler();
@@ -117,28 +116,22 @@ public void onThrowable(Throwable t) {
                 }
             });
 
-            try {
-                Response response = c.prepareGet(getTargetUrl()).execute(tl).get();
-
-                assertNotNull(response);
-                assertEquals(response.getStatusCode(), 200);
-                assertNotNull(hRead.get());
-                assertNotNull(hSent.get());
-                assertNull(bb.get());
-                assertNull(throwable.get());
-            } catch (IOException ex) {
-                fail("Should have timed out");
-            }
-        } finally {
-            c.close();
+            Response response = c.prepareGet(getTargetUrl()).execute(tl).get();
+
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+            assertNotNull(hRead.get());
+            assertNotNull(hSent.get());
+            assertNull(bb.get());
+            assertNull(throwable.get());
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void basicPutFileTest() throws Exception {
-        final AtomicReference<Throwable> throwable = new AtomicReference<Throwable>();
-        final AtomicReference<FluentCaseInsensitiveStringsMap> hSent = new AtomicReference<FluentCaseInsensitiveStringsMap>();
-        final AtomicReference<FluentCaseInsensitiveStringsMap> hRead = new AtomicReference<FluentCaseInsensitiveStringsMap>();
+        final AtomicReference<Throwable> throwable = new AtomicReference<>();
+        final AtomicReference<FluentCaseInsensitiveStringsMap> hSent = new AtomicReference<>();
+        final AtomicReference<FluentCaseInsensitiveStringsMap> hRead = new AtomicReference<>();
         final AtomicInteger bbReceivedLenght = new AtomicInteger(0);
         final AtomicLong bbSentLenght = new AtomicLong(0L);
 
@@ -147,9 +140,8 @@ public void basicPutFileTest() throws Exception {
         File file = createTempFile(1024 * 100 * 10);
 
         int timeout = (int) (file.length() / 1000);
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setConnectionTimeout(timeout).build());
 
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setConnectTimeout(timeout).build())) {
             TransferCompletionHandler tl = new TransferCompletionHandler();
             tl.addTransferListener(new TransferListener() {
 
@@ -178,30 +170,23 @@ public void onThrowable(Throwable t) {
                 }
             });
 
-            try {
-                Response response = client.preparePut(getTargetUrl()).setBody(file).execute(tl).get();
-
-                assertNotNull(response);
-                assertEquals(response.getStatusCode(), 200);
-                assertNotNull(hRead.get());
-                assertNotNull(hSent.get());
-                assertEquals(bbReceivedLenght.get(), file.length(), "Number of received bytes incorrect");
-                assertEquals(bbSentLenght.get(), file.length(), "Number of sent bytes incorrect");
-            } catch (IOException ex) {
-                fail("Should have timed out");
-            }
-        } finally {
-            client.close();
+            Response response = client.preparePut(getTargetUrl()).setBody(file).execute(tl).get();
+
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+            assertNotNull(hRead.get());
+            assertNotNull(hSent.get());
+            assertEquals(bbReceivedLenght.get(), file.length(), "Number of received bytes incorrect");
+            assertEquals(bbSentLenght.get(), file.length(), "Number of sent bytes incorrect");
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void basicPutFileBodyGeneratorTest() throws Exception {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
-            final AtomicReference<Throwable> throwable = new AtomicReference<Throwable>();
-            final AtomicReference<FluentCaseInsensitiveStringsMap> hSent = new AtomicReference<FluentCaseInsensitiveStringsMap>();
-            final AtomicReference<FluentCaseInsensitiveStringsMap> hRead = new AtomicReference<FluentCaseInsensitiveStringsMap>();
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
+            final AtomicReference<Throwable> throwable = new AtomicReference<>();
+            final AtomicReference<FluentCaseInsensitiveStringsMap> hSent = new AtomicReference<>();
+            final AtomicReference<FluentCaseInsensitiveStringsMap> hRead = new AtomicReference<>();
             final AtomicInteger bbReceivedLenght = new AtomicInteger(0);
             final AtomicLong bbSentLenght = new AtomicLong(0L);
 
@@ -237,20 +222,14 @@ public void onThrowable(Throwable t) {
                 }
             });
 
-            try {
-                Response response = client.preparePut(getTargetUrl()).setBody(new FileBodyGenerator(file)).execute(tl).get();
-
-                assertNotNull(response);
-                assertEquals(response.getStatusCode(), 200);
-                assertNotNull(hRead.get());
-                assertNotNull(hSent.get());
-                assertEquals(bbReceivedLenght.get(), file.length(), "Number of received bytes incorrect");
-                assertEquals(bbSentLenght.get(), file.length(), "Number of sent bytes incorrect");
-            } catch (IOException ex) {
-                fail("Should have timed out");
-            }
-        } finally {
-            client.close();
+            Response response = client.preparePut(getTargetUrl()).setBody(new FileBodyGenerator(file)).execute(tl).get();
+
+            assertNotNull(response);
+            assertEquals(response.getStatusCode(), 200);
+            assertNotNull(hRead.get());
+            assertNotNull(hSent.get());
+            assertEquals(bbReceivedLenght.get(), file.length(), "Number of received bytes incorrect");
+            assertEquals(bbSentLenght.get(), file.length(), "Number of sent bytes incorrect");
         }
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/ZeroCopyFileTest.java b/api/src/test/java/org/asynchttpclient/request/body/ZeroCopyFileTest.java
similarity index 62%
rename from api/src/test/java/org/asynchttpclient/async/ZeroCopyFileTest.java
rename to api/src/test/java/org/asynchttpclient/request/body/ZeroCopyFileTest.java
index 0ef54128f..202466f92 100644
--- a/api/src/test/java/org/asynchttpclient/async/ZeroCopyFileTest.java
+++ b/api/src/test/java/org/asynchttpclient/request/body/ZeroCopyFileTest.java
@@ -10,18 +10,20 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient.request.body;
 
-import static org.asynchttpclient.async.util.TestUtils.SIMPLE_TEXT_FILE;
-import static org.asynchttpclient.async.util.TestUtils.SIMPLE_TEXT_FILE_STRING;
+import static org.asynchttpclient.test.TestUtils.SIMPLE_TEXT_FILE;
+import static org.asynchttpclient.test.TestUtils.SIMPLE_TEXT_FILE_STRING;
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertNotNull;
 import static org.testng.Assert.assertNull;
 import static org.testng.Assert.assertTrue;
 
+import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.AsyncCompletionHandler;
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.BasicHttpsTest;
 import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.HttpResponseHeaders;
 import org.asynchttpclient.HttpResponseStatus;
@@ -68,21 +70,20 @@ public void handle(String s, Request r, HttpServletRequest httpRequest, HttpServ
 
     @Test(groups = { "standalone", "default_provider" })
     public void zeroCopyPostTest() throws IOException, ExecutionException, TimeoutException, InterruptedException, URISyntaxException {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             final AtomicBoolean headerSent = new AtomicBoolean(false);
             final AtomicBoolean operationCompleted = new AtomicBoolean(false);
 
             Response resp = client.preparePost("http://127.0.0.1:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute(new AsyncCompletionHandler<Response>() {
 
-                public STATE onHeaderWriteCompleted() {
+                public State onHeadersWritten() {
                     headerSent.set(true);
-                    return STATE.CONTINUE;
+                    return State.CONTINUE;
                 }
 
-                public STATE onContentWriteCompleted() {
+                public State onContentWritten() {
                     operationCompleted.set(true);
-                    return STATE.CONTINUE;
+                    return State.CONTINUE;
                 }
 
                 @Override
@@ -95,22 +96,17 @@ public Response onCompleted(Response response) throws Exception {
             assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
             assertTrue(operationCompleted.get());
             assertTrue(headerSent.get());
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void zeroCopyPutTest() throws IOException, ExecutionException, TimeoutException, InterruptedException, URISyntaxException {
-        AsyncHttpClient client = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             Future<Response> f = client.preparePut("http://127.0.0.1:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute();
             Response resp = f.get();
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
             assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
-        } finally {
-            client.close();
         }
     }
 
@@ -121,79 +117,72 @@ public AbstractHandler configureHandler() throws Exception {
 
     @Test(groups = { "standalone", "default_provider" })
     public void zeroCopyFileTest() throws IOException, ExecutionException, TimeoutException, InterruptedException, URISyntaxException {
-        AsyncHttpClient client = getAsyncHttpClient(null);
         File tmp = new File(System.getProperty("java.io.tmpdir") + File.separator + "zeroCopy.txt");
         tmp.deleteOnExit();
-        final FileOutputStream stream = new FileOutputStream(tmp);
-        try {
-            Response resp = client.preparePost("http://127.0.0.1:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute(new AsyncHandler<Response>() {
-                public void onThrowable(Throwable t) {
-                }
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
+            try (FileOutputStream stream = new FileOutputStream(tmp)) {
+                Response resp = client.preparePost("http://127.0.0.1:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute(new AsyncHandler<Response>() {
+                    public void onThrowable(Throwable t) {
+                    }
 
-                public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-                    bodyPart.writeTo(stream);
-                    return STATE.CONTINUE;
-                }
+                    public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+                        bodyPart.writeTo(stream);
+                        return State.CONTINUE;
+                    }
 
-                public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
-                    return STATE.CONTINUE;
-                }
+                    public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+                        return State.CONTINUE;
+                    }
 
-                public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
-                    return STATE.CONTINUE;
-                }
+                    public State onHeadersReceived(HttpResponseHeaders headers) throws Exception {
+                        return State.CONTINUE;
+                    }
 
-                public Response onCompleted() throws Exception {
-                    return null;
-                }
-            }).get();
-            assertNull(resp);
-            assertEquals(SIMPLE_TEXT_FILE.length(), tmp.length());
-        } finally {
-            stream.close();
-            client.close();
+                    public Response onCompleted() throws Exception {
+                        return null;
+                    }
+                }).get();
+                assertNull(resp);
+                assertEquals(SIMPLE_TEXT_FILE.length(), tmp.length());
+            }
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void zeroCopyFileWithBodyManipulationTest() throws IOException, ExecutionException, TimeoutException, InterruptedException, URISyntaxException {
-        AsyncHttpClient client = getAsyncHttpClient(null);
         File tmp = new File(System.getProperty("java.io.tmpdir") + File.separator + "zeroCopy.txt");
         tmp.deleteOnExit();
-        final FileOutputStream stream = new FileOutputStream(tmp);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
+            try (FileOutputStream stream = new FileOutputStream(tmp)) {
+                Response resp = client.preparePost("http://127.0.0.1:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute(new AsyncHandler<Response>() {
+                    public void onThrowable(Throwable t) {
+                    }
 
-            Response resp = client.preparePost("http://127.0.0.1:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute(new AsyncHandler<Response>() {
-                public void onThrowable(Throwable t) {
-                }
+                    public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+                        bodyPart.writeTo(stream);
 
-                public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-                    bodyPart.writeTo(stream);
+                        if (bodyPart.getBodyPartBytes().length == 0) {
+                            return State.ABORT;
+                        }
 
-                    if (bodyPart.getBodyPartBytes().length == 0) {
-                        return STATE.ABORT;
+                        return State.CONTINUE;
                     }
 
-                    return STATE.CONTINUE;
-                }
-
-                public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
-                    return STATE.CONTINUE;
-                }
+                    public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+                        return State.CONTINUE;
+                    }
 
-                public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
-                    return STATE.CONTINUE;
-                }
+                    public State onHeadersReceived(HttpResponseHeaders headers) throws Exception {
+                        return State.CONTINUE;
+                    }
 
-                public Response onCompleted() throws Exception {
-                    return null;
-                }
-            }).get();
-            assertNull(resp);
-            assertEquals(SIMPLE_TEXT_FILE.length(), tmp.length());
-        } finally {
-            stream.close();
-            client.close();
+                    public Response onCompleted() throws Exception {
+                        return null;
+                    }
+                }).get();
+                assertNull(resp);
+                assertEquals(SIMPLE_TEXT_FILE.length(), tmp.length());
+            }
         }
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/request/body/generator/FeedableBodyGeneratorTest.java b/api/src/test/java/org/asynchttpclient/request/body/generator/FeedableBodyGeneratorTest.java
new file mode 100755
index 000000000..200bed7a6
--- /dev/null
+++ b/api/src/test/java/org/asynchttpclient/request/body/generator/FeedableBodyGeneratorTest.java
@@ -0,0 +1,126 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.request.body.generator;
+
+import org.asynchttpclient.request.body.Body;
+import org.asynchttpclient.request.body.Body.State;
+import org.testng.annotations.BeforeMethod;
+import org.testng.annotations.Test;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.charset.StandardCharsets;
+
+import static org.testng.Assert.*;
+
+public class FeedableBodyGeneratorTest {
+
+    private SimpleFeedableBodyGenerator feedableBodyGenerator;
+    private TestFeedListener listener;
+
+    @BeforeMethod
+    public void setUp() throws Exception {
+        feedableBodyGenerator = new SimpleFeedableBodyGenerator();
+        listener = new TestFeedListener();
+        feedableBodyGenerator.setListener(listener);
+    }
+
+    @Test(groups = "standalone")
+    public void feedNotifiesListener() throws Exception {
+        feedableBodyGenerator.feed(ByteBuffer.allocate(0), false);
+        feedableBodyGenerator.feed(ByteBuffer.allocate(0), true);
+        assertEquals(listener.getCalls(), 2);
+    }
+
+    @Test(groups = "standalone")
+    public void readingBytesReturnsFedContentWithEmptyLastBufferWhenChunkBoundariesEnabled() throws Exception {
+        feedableBodyGenerator.writeChunkBoundaries();
+        byte[] content = "Test123".getBytes(StandardCharsets.US_ASCII);
+        feedableBodyGenerator.feed(ByteBuffer.wrap(content), false);
+        Body body = feedableBodyGenerator.createBody();
+        assertEquals(readFromBody(body), "7\r\nTest123\r\n".getBytes(StandardCharsets.US_ASCII));
+        feedableBodyGenerator.feed(ByteBuffer.allocate(0), true);
+        assertEquals(readFromBody(body), "0\r\n\r\n".getBytes(StandardCharsets.US_ASCII));
+        assertEquals(body.read(ByteBuffer.allocate(1)), State.Stop);
+    }
+
+    @Test(groups = "standalone")
+    public void readingBytesReturnsFedContentWithEmptyLastBufferWhenChunkBoundariesEnabledAllContentAvailable() throws Exception {
+        feedableBodyGenerator.writeChunkBoundaries();
+        byte[] content = "Test123".getBytes(StandardCharsets.US_ASCII);
+        feedableBodyGenerator.feed(ByteBuffer.wrap(content), false);
+        feedableBodyGenerator.feed(ByteBuffer.allocate(0), true);
+        Body body = feedableBodyGenerator.createBody();
+        assertEquals(readFromBody(body), "7\r\nTest123\r\n0\r\n\r\n".getBytes(StandardCharsets.US_ASCII));
+        assertEquals(body.read(ByteBuffer.allocate(1)), State.Stop);
+    }
+
+    @Test(groups = "standalone")
+    public void readingBytesReturnsFedContentWithFilledLastBufferWhenChunkBoundariesEnabled() throws Exception {
+        feedableBodyGenerator.writeChunkBoundaries();
+        byte[] content = "Test123".getBytes(StandardCharsets.US_ASCII);
+        feedableBodyGenerator.feed(ByteBuffer.wrap(content), true);
+        Body body = feedableBodyGenerator.createBody();
+        assertEquals(readFromBody(body), "7\r\nTest123\r\n0\r\n\r\n".getBytes(StandardCharsets.US_ASCII));
+        assertEquals(body.read(ByteBuffer.allocate(1)), State.Stop);
+
+    }
+
+    @Test(groups = "standalone")
+    public void readingBytesReturnsFedContentWithoutChunkBoundariesWhenNotEnabled() throws Exception {
+        byte[] content = "Test123".getBytes(StandardCharsets.US_ASCII);
+        feedableBodyGenerator.feed(ByteBuffer.wrap(content), true);
+        Body body = feedableBodyGenerator.createBody();
+        assertEquals(readFromBody(body), "Test123".getBytes(StandardCharsets.US_ASCII));
+        assertEquals(body.read(ByteBuffer.allocate(1)), State.Stop);
+    }
+
+
+    @Test(groups = "standalone")
+    public void returnZeroToSuspendStreamWhenNothingIsInQueue() throws Exception {
+        feedableBodyGenerator.writeChunkBoundaries();
+        byte[] content = "Test123".getBytes(StandardCharsets.US_ASCII);
+        feedableBodyGenerator.feed(ByteBuffer.wrap(content), false);
+
+        Body body = feedableBodyGenerator.createBody();
+        assertEquals(readFromBody(body), "7\r\nTest123\r\n".getBytes(StandardCharsets.US_ASCII));
+        assertEquals(body.read(ByteBuffer.allocate(1)), State.Suspend);
+    }
+
+    private byte[] readFromBody(Body body) throws IOException {
+        ByteBuffer byteBuffer = ByteBuffer.allocate(512);
+        body.read(byteBuffer);
+        byteBuffer.flip();
+        byte[] readBytes = new byte[byteBuffer.remaining()];
+        byteBuffer.get(readBytes);
+        return readBytes;
+    }
+
+    private static class TestFeedListener implements SimpleFeedableBodyGenerator.FeedListener {
+
+        private int calls;
+
+        @Override
+        public void onContentAdded() {
+            calls++;
+        }
+
+        @Override
+        public void onError(Throwable t) {}
+
+        public int getCalls() {
+            return calls;
+        }
+    }
+}
diff --git a/api/src/test/java/org/asynchttpclient/generators/ByteArrayBodyGeneratorTest.java b/api/src/test/java/org/asynchttpclient/request/body/generators/ByteArrayBodyGeneratorTest.java
similarity index 86%
rename from api/src/test/java/org/asynchttpclient/generators/ByteArrayBodyGeneratorTest.java
rename to api/src/test/java/org/asynchttpclient/request/body/generators/ByteArrayBodyGeneratorTest.java
index 80645ba1e..7cc1dc95d 100644
--- a/api/src/test/java/org/asynchttpclient/generators/ByteArrayBodyGeneratorTest.java
+++ b/api/src/test/java/org/asynchttpclient/request/body/generators/ByteArrayBodyGeneratorTest.java
@@ -11,11 +11,13 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package org.asynchttpclient.generators;
+package org.asynchttpclient.request.body.generators;
 
 import static org.testng.Assert.assertEquals;
 
-import org.asynchttpclient.Body;
+import org.asynchttpclient.request.body.Body;
+import org.asynchttpclient.request.body.Body.State;
+import org.asynchttpclient.request.body.generator.ByteArrayBodyGenerator;
 import org.testng.annotations.Test;
 
 import java.io.IOException;
@@ -43,11 +45,11 @@ public void testSingleRead() throws IOException {
         final ByteBuffer chunkBuffer = ByteBuffer.allocate(chunkSize);
 
         // should take 1 read to get through the srcArray
-        assertEquals(body.read(chunkBuffer), srcArraySize);
+        body.read(chunkBuffer);
         assertEquals(chunkBuffer.position(), srcArraySize, "bytes read");
         chunkBuffer.clear();
 
-        assertEquals(body.read(chunkBuffer), -1, "body at EOF");
+        assertEquals(body.read(chunkBuffer), State.Stop, "body at EOF");
     }
 
     @Test(groups = "standalone")
@@ -64,7 +66,7 @@ public void testMultipleReads() throws IOException {
 
         int reads = 0;
         int bytesRead = 0;
-        while (body.read(chunkBuffer) != -1) {
+        while (body.read(chunkBuffer) != State.Stop) {
           reads += 1;
           bytesRead += chunkBuffer.position();
           chunkBuffer.clear();
diff --git a/api/src/test/java/org/asynchttpclient/multipart/MultipartBodyTest.java b/api/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBodyTest.java
similarity index 74%
rename from api/src/test/java/org/asynchttpclient/multipart/MultipartBodyTest.java
rename to api/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBodyTest.java
index 3eeb05bbe..602837b64 100644
--- a/api/src/test/java/org/asynchttpclient/multipart/MultipartBodyTest.java
+++ b/api/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBodyTest.java
@@ -10,12 +10,18 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.multipart;
+package org.asynchttpclient.request.body.multipart;
 
-import static org.asynchttpclient.util.StandardCharsets.UTF_8;
+import static java.nio.charset.StandardCharsets.*;
 
-import org.asynchttpclient.Body;
 import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
+import org.asynchttpclient.request.body.Body;
+import org.asynchttpclient.request.body.Body.State;
+import org.asynchttpclient.request.body.multipart.ByteArrayPart;
+import org.asynchttpclient.request.body.multipart.FilePart;
+import org.asynchttpclient.request.body.multipart.MultipartUtils;
+import org.asynchttpclient.request.body.multipart.Part;
+import org.asynchttpclient.request.body.multipart.StringPart;
 import org.testng.Assert;
 import org.testng.annotations.Test;
 
@@ -30,8 +36,8 @@
 public class MultipartBodyTest {
 
     @Test(groups = "fast")
-    public void testBasics() {
-        final List<Part> parts = new ArrayList<Part>();
+    public void testBasics() throws IOException {
+        final List<Part> parts = new ArrayList<>();
 
         // add a file
         final File testFile = getTestfile();
@@ -41,7 +47,7 @@ public void testBasics() {
         parts.add(new ByteArrayPart("baPart", "testMultiPart".getBytes(UTF_8), "application/test", UTF_8, "fileName"));
 
         // add a string
-        parts.add(new StringPart("stringPart", "testString", UTF_8));
+        parts.add(new StringPart("stringPart", "testString"));
 
         compareContentLength(parts);
     }
@@ -59,7 +65,7 @@ private static File getTestfile() {
         return file;
     }
 
-    private static void compareContentLength(final List<Part> parts) {
+    private static void compareContentLength(final List<Part> parts) throws IOException {
         Assert.assertNotNull(parts);
         // get expected values
         final Body multipartBody = MultipartUtils.newMultipartBody(parts, new FluentCaseInsensitiveStringsMap());
@@ -67,22 +73,12 @@ private static void compareContentLength(final List<Part> parts) {
         try {
             final ByteBuffer buffer = ByteBuffer.allocate(8192);
             boolean last = false;
-            long totalBytes = 0;
             while (!last) {
-                long readBytes = 0;
-                try {
-                    readBytes = multipartBody.read(buffer);
-                } catch (IOException ie) {
-                    Assert.fail("read failure");
-                }
-                if (readBytes > 0) {
-                    totalBytes += readBytes;
-                } else {
+                if (multipartBody.read(buffer) == State.Stop) {
                     last = true;
                 }
-                buffer.clear();
             }
-            Assert.assertEquals(totalBytes, expectedContentLength);
+            Assert.assertEquals(buffer.position(), expectedContentLength);
         } finally {
             try {
                 multipartBody.close();
diff --git a/api/src/test/java/org/asynchttpclient/async/MultipartUploadTest.java b/api/src/test/java/org/asynchttpclient/request/body/multipart/MultipartUploadTest.java
similarity index 75%
rename from api/src/test/java/org/asynchttpclient/async/MultipartUploadTest.java
rename to api/src/test/java/org/asynchttpclient/request/body/multipart/MultipartUploadTest.java
index ad063a978..b57a71193 100644
--- a/api/src/test/java/org/asynchttpclient/async/MultipartUploadTest.java
+++ b/api/src/test/java/org/asynchttpclient/request/body/multipart/MultipartUploadTest.java
@@ -10,11 +10,12 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient.request.body.multipart;
 
-import static org.asynchttpclient.async.util.TestUtils.findFreePort;
-import static org.asynchttpclient.async.util.TestUtils.getClasspathFile;
-import static org.asynchttpclient.async.util.TestUtils.newJettyHttpServer;
+import static java.nio.charset.StandardCharsets.*;
+import static org.asynchttpclient.test.TestUtils.findFreePort;
+import static org.asynchttpclient.test.TestUtils.getClasspathFile;
+import static org.asynchttpclient.test.TestUtils.newJettyHttpServer;
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertNotNull;
 import static org.testng.Assert.assertTrue;
@@ -27,16 +28,15 @@
 import org.apache.commons.fileupload.util.Streams;
 import org.apache.commons.io.FileUtils;
 import org.apache.commons.io.IOUtils;
+import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.Request;
 import org.asynchttpclient.RequestBuilder;
 import org.asynchttpclient.Response;
-import org.asynchttpclient.multipart.ByteArrayPart;
-import org.asynchttpclient.multipart.FilePart;
-import org.asynchttpclient.multipart.StringPart;
-import org.asynchttpclient.util.AsyncHttpProviderUtils;
-import org.asynchttpclient.util.StandardCharsets;
+import org.asynchttpclient.request.body.multipart.ByteArrayPart;
+import org.asynchttpclient.request.body.multipart.FilePart;
+import org.asynchttpclient.request.body.multipart.StringPart;
 import org.eclipse.jetty.servlet.ServletContextHandler;
 import org.eclipse.jetty.servlet.ServletHolder;
 import org.slf4j.Logger;
@@ -86,9 +86,10 @@ public void setUp() throws Exception {
 
     /**
      * Tests that the streaming of a file works.
+     * @throws IOException 
      */
     @Test
-    public void testSendingSmallFilesAndByteArray() {
+    public void testSendingSmallFilesAndByteArray() throws IOException {
         String expectedContents = "filecontent: hello";
         String expectedContents2 = "gzipcontent: hello";
         String expectedContents3 = "filecontent: hello2";
@@ -120,28 +121,25 @@ public void testSendingSmallFilesAndByteArray() {
             fail("unable to find " + testResource3);
         }
 
-        List<File> testFiles = new ArrayList<File>();
+        List<File> testFiles = new ArrayList<>();
         testFiles.add(testResource1File);
         testFiles.add(testResource2File);
         testFiles.add(testResource3File);
 
-        List<String> expected = new ArrayList<String>();
+        List<String> expected = new ArrayList<>();
         expected.add(expectedContents);
         expected.add(expectedContents2);
         expected.add(expectedContents3);
 
-        List<Boolean> gzipped = new ArrayList<Boolean>();
+        List<Boolean> gzipped = new ArrayList<>();
         gzipped.add(false);
         gzipped.add(true);
         gzipped.add(false);
 
         boolean tmpFileCreated = false;
-        File tmpFile = null;
-        FileOutputStream os = null;
-        try {
-            tmpFile = File.createTempFile("textbytearray", ".txt");
-            os = new FileOutputStream(tmpFile);
-            IOUtils.write(expectedContents.getBytes(StandardCharsets.UTF_8), os);
+        File tmpFile = File.createTempFile("textbytearray", ".txt");
+        try (FileOutputStream os = new FileOutputStream(tmpFile)) {
+            IOUtils.write(expectedContents.getBytes(UTF_8), os);
             tmpFileCreated = true;
 
             testFiles.add(tmpFile);
@@ -154,10 +152,6 @@ public void testSendingSmallFilesAndByteArray() {
         } catch (IOException e1) {
             // TODO Auto-generated catch block
             e1.printStackTrace();
-        } finally {
-            if (os != null) {
-                IOUtils.closeQuietly(os);
-            }
         }
 
         if (!tmpFileCreated) {
@@ -168,22 +162,20 @@ public void testSendingSmallFilesAndByteArray() {
 
         bc.setFollowRedirect(true);
 
-        AsyncHttpClient c = getAsyncHttpClient(bc.build());
-
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(bc.build())) {
 
             RequestBuilder builder = new RequestBuilder("POST");
             builder.setUrl("http://localhost" + ":" + port1 + "/upload/bob");
-            builder.addBodyPart(new FilePart("file1", testResource1File, "text/plain", StandardCharsets.UTF_8));
+            builder.addBodyPart(new FilePart("file1", testResource1File, "text/plain", UTF_8));
             builder.addBodyPart(new FilePart("file2", testResource2File, "application/x-gzip", null));
-            builder.addBodyPart(new StringPart("Name", "Dominic", StandardCharsets.UTF_8));
-            builder.addBodyPart(new FilePart("file3", testResource3File, "text/plain", StandardCharsets.UTF_8));
+            builder.addBodyPart(new StringPart("Name", "Dominic"));
+            builder.addBodyPart(new FilePart("file3", testResource3File, "text/plain", UTF_8));
 
-            builder.addBodyPart(new StringPart("Age", "3", AsyncHttpProviderUtils.DEFAULT_CHARSET));
-            builder.addBodyPart(new StringPart("Height", "shrimplike", AsyncHttpProviderUtils.DEFAULT_CHARSET));
-            builder.addBodyPart(new StringPart("Hair", "ridiculous", AsyncHttpProviderUtils.DEFAULT_CHARSET));
+            builder.addBodyPart(new StringPart("Age", "3"));
+            builder.addBodyPart(new StringPart("Height", "shrimplike"));
+            builder.addBodyPart(new StringPart("Hair", "ridiculous"));
 
-            builder.addBodyPart(new ByteArrayPart("file4", expectedContents.getBytes(StandardCharsets.UTF_8), "text/plain", StandardCharsets.UTF_8, "bytearray.txt"));
+            builder.addBodyPart(new ByteArrayPart("file4", expectedContents.getBytes(UTF_8), "text/plain", UTF_8, "bytearray.txt"));
 
             Request r = builder.build();
 
@@ -193,12 +185,10 @@ public void testSendingSmallFilesAndByteArray() {
 
             testSentFile(expected, testFiles, res, gzipped);
 
-            c.close();
         } catch (Exception e) {
             e.printStackTrace();
             fail("Download Exception");
         } finally {
-            c.close();
             FileUtils.deleteQuietly(tmpFile);
         }
     }
@@ -239,14 +229,12 @@ private void testSentFile(List<String> expectedContents, List<File> sourceFiles,
         int i = 0;
         for (File sourceFile : sourceFiles) {
 
-            FileInputStream instream = null;
             File tmp = null;
             try {
 
                 ByteArrayOutputStream baos = new ByteArrayOutputStream();
                 byte[] sourceBytes = null;
-                try {
-                    instream = new FileInputStream(sourceFile);
+                try (FileInputStream instream = new FileInputStream(sourceFile)) {
                     byte[] buf = new byte[8092];
                     int len = 0;
                     while ((len = instream.read(buf)) > 0) {
@@ -258,8 +246,6 @@ private void testSentFile(List<String> expectedContents, List<File> sourceFiles,
                     logger.debug("================");
                     System.out.flush();
                     sourceBytes = baos.toByteArray();
-                } finally {
-                    IOUtils.closeQuietly(instream);
                 }
 
                 tmp = new File(responseFiles[i].trim());
@@ -269,40 +255,40 @@ private void testSentFile(List<String> expectedContents, List<File> sourceFiles,
                 System.out.flush();
                 assertTrue(tmp.exists());
 
-                instream = new FileInputStream(tmp);
-                ByteArrayOutputStream baos2 = new ByteArrayOutputStream();
-                byte[] buf = new byte[8092];
-                int len = 0;
-                while ((len = instream.read(buf)) > 0) {
-                    baos2.write(buf, 0, len);
+                byte[] bytes;
+                try (FileInputStream instream = new FileInputStream(tmp)) {
+                    ByteArrayOutputStream baos2 = new ByteArrayOutputStream();
+                    byte[] buf = new byte[8092];
+                    int len = 0;
+                    while ((len = instream.read(buf)) > 0) {
+                        baos2.write(buf, 0, len);
+                    }
+                    bytes = baos2.toByteArray();
+                    assertEquals(bytes, sourceBytes);
                 }
-                IOUtils.closeQuietly(instream);
 
-                assertEquals(baos2.toByteArray(), sourceBytes);
 
                 if (!deflate.get(i)) {
-
-                    String helloString = new String(baos2.toByteArray());
+                    String helloString = new String(bytes);
                     assertEquals(helloString, expectedContents.get(i));
                 } else {
-                    instream = new FileInputStream(tmp);
-
-                    ByteArrayOutputStream baos3 = new ByteArrayOutputStream();
-                    GZIPInputStream deflater = new GZIPInputStream(instream);
-                    try {
-                        byte[] buf3 = new byte[8092];
-                        int len3 = 0;
-                        while ((len3 = deflater.read(buf3)) > 0) {
-                            baos3.write(buf3, 0, len3);
+                    try (FileInputStream instream = new FileInputStream(tmp)) {
+                        ByteArrayOutputStream baos3 = new ByteArrayOutputStream();
+                        GZIPInputStream deflater = new GZIPInputStream(instream);
+                        try {
+                            byte[] buf3 = new byte[8092];
+                            int len3 = 0;
+                            while ((len3 = deflater.read(buf3)) > 0) {
+                                baos3.write(buf3, 0, len3);
+                            }
+                        } finally {
+                            deflater.close();
                         }
-                    } finally {
-                        deflater.close();
+    
+                        String helloString = new String(baos3.toByteArray());
+    
+                        assertEquals(expectedContents.get(i), helloString);
                     }
-
-                    String helloString = new String(baos3.toByteArray());
-
-                    assertEquals(expectedContents.get(i), helloString);
-
                 }
             } catch (Exception e) {
                 e.printStackTrace();
@@ -310,7 +296,6 @@ private void testSentFile(List<String> expectedContents, List<File> sourceFiles,
             } finally {
                 if (tmp != null)
                     FileUtils.deleteQuietly(tmp);
-                IOUtils.closeQuietly(instream);
                 i++;
             }
         }
@@ -364,7 +349,7 @@ public void service(HttpServletRequest request, HttpServletResponse response) th
             // Check that we have a file upload request
             boolean isMultipart = ServletFileUpload.isMultipartContent(request);
             if (isMultipart) {
-                List<String> files = new ArrayList<String>();
+                List<String> files = new ArrayList<>();
                 ServletFileUpload upload = new ServletFileUpload();
                 // Parse the request
                 FileItemIterator iter = null;
@@ -373,9 +358,7 @@ public void service(HttpServletRequest request, HttpServletResponse response) th
                     while (iter.hasNext()) {
                         FileItemStream item = iter.next();
                         String name = item.getFieldName();
-                        InputStream stream = null;
-                        try {
-                            stream = item.openStream();
+                        try (InputStream stream = item.openStream()) {
 
                             if (item.isFormField()) {
                                 LOGGER.debug("Form field " + name + " with value " + Streams.asString(stream) + " detected.");
@@ -383,11 +366,9 @@ public void service(HttpServletRequest request, HttpServletResponse response) th
                             } else {
                                 LOGGER.debug("File field " + name + " with file name " + item.getName() + " detected.");
                                 // Process the input stream
-                                OutputStream os = null;
-                                try {
-                                    File tmpFile = File.createTempFile(UUID.randomUUID().toString() + "_MockUploadServlet", ".tmp");
-                                    tmpFile.deleteOnExit();
-                                    os = new FileOutputStream(tmpFile);
+                                File tmpFile = File.createTempFile(UUID.randomUUID().toString() + "_MockUploadServlet", ".tmp");
+                                tmpFile.deleteOnExit();
+                                try (OutputStream os = new FileOutputStream(tmpFile)) {
                                     byte[] buffer = new byte[4096];
                                     int bytesRead;
                                     while ((bytesRead = stream.read(buffer)) != -1) {
@@ -395,37 +376,26 @@ public void service(HttpServletRequest request, HttpServletResponse response) th
                                     }
                                     incrementFilesProcessed();
                                     files.add(tmpFile.getAbsolutePath());
-                                } finally {
-                                    IOUtils.closeQuietly(os);
                                 }
                             }
-                        } finally {
-                            IOUtils.closeQuietly(stream);
                         }
                     }
                 } catch (FileUploadException e) {
 
                 }
-                Writer w = response.getWriter();
-                try {
+                try (Writer w = response.getWriter()) {
                     w.write(Integer.toString(getFilesProcessed()));
                     resetFilesProcessed();
                     resetStringsProcessed();
                     w.write("||");
                     w.write(files.toString());
-                } finally {
-                    // FIXME
-                    w.close();
                 }
             } else {
-                Writer w = response.getWriter();
-                try {
+                try (Writer w = response.getWriter()) {
                     w.write(Integer.toString(getFilesProcessed()));
                     resetFilesProcessed();
                     resetStringsProcessed();
                     w.write("||");
-                } finally {
-                    w.close();
                 }
             }
         }
diff --git a/api/src/test/java/org/asynchttpclient/async/SimpleAsyncClientErrorBehaviourTest.java b/api/src/test/java/org/asynchttpclient/simple/SimpleAsyncClientErrorBehaviourTest.java
similarity index 77%
rename from api/src/test/java/org/asynchttpclient/async/SimpleAsyncClientErrorBehaviourTest.java
rename to api/src/test/java/org/asynchttpclient/simple/SimpleAsyncClientErrorBehaviourTest.java
index 5912a7079..05c2656a2 100644
--- a/api/src/test/java/org/asynchttpclient/async/SimpleAsyncClientErrorBehaviourTest.java
+++ b/api/src/test/java/org/asynchttpclient/simple/SimpleAsyncClientErrorBehaviourTest.java
@@ -10,15 +10,16 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient.simple;
 
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertTrue;
 
+import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.Response;
-import org.asynchttpclient.SimpleAsyncHttpClient;
-import org.asynchttpclient.SimpleAsyncHttpClient.ErrorDocumentBehaviour;
-import org.asynchttpclient.consumers.OutputStreamBodyConsumer;
+import org.asynchttpclient.simple.SimpleAsyncHttpClient;
+import org.asynchttpclient.simple.SimpleAsyncHttpClient.ErrorDocumentBehaviour;
+import org.asynchttpclient.simple.consumer.OutputStreamBodyConsumer;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.Test;
 
@@ -36,12 +37,11 @@
  */
 public abstract class SimpleAsyncClientErrorBehaviourTest extends AbstractBasicTest {
     
-    public abstract String getProviderClass();
-
     @Test(groups = { "standalone", "default_provider" })
     public void testAccumulateErrorBody() throws Exception {
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setProviderClass(getProviderClass()).setUrl(getTargetUrl() + "/nonexistent").setErrorDocumentBehaviour(ErrorDocumentBehaviour.ACCUMULATE).build();
-        try {
+        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
+                .setUrl(getTargetUrl() + "/nonexistent")//
+                .setErrorDocumentBehaviour(ErrorDocumentBehaviour.ACCUMULATE).build()) {
             ByteArrayOutputStream o = new ByteArrayOutputStream(10);
             Future<Response> future = client.get(new OutputStreamBodyConsumer(o));
 
@@ -50,15 +50,14 @@ public void testAccumulateErrorBody() throws Exception {
             assertEquals(response.getStatusCode(), 404);
             assertEquals(o.toString(), "");
             assertTrue(response.getResponseBody().startsWith("<html>"));
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void testOmitErrorBody() throws Exception {
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setProviderClass(getProviderClass()).setUrl(getTargetUrl() + "/nonexistent").setErrorDocumentBehaviour(ErrorDocumentBehaviour.OMIT).build();
-        try {
+        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
+                .setUrl(getTargetUrl() + "/nonexistent")//
+                .setErrorDocumentBehaviour(ErrorDocumentBehaviour.OMIT).build()) {
             ByteArrayOutputStream o = new ByteArrayOutputStream(10);
             Future<Response> future = client.get(new OutputStreamBodyConsumer(o));
 
@@ -67,8 +66,6 @@ public void testOmitErrorBody() throws Exception {
             assertEquals(response.getStatusCode(), 404);
             assertEquals(o.toString(), "");
             assertEquals(response.getResponseBody(), "");
-        } finally {
-            client.close();
         }
     }
 
diff --git a/api/src/test/java/org/asynchttpclient/async/SimpleAsyncHttpClientTest.java b/api/src/test/java/org/asynchttpclient/simple/SimpleAsyncHttpClientTest.java
similarity index 65%
rename from api/src/test/java/org/asynchttpclient/async/SimpleAsyncHttpClientTest.java
rename to api/src/test/java/org/asynchttpclient/simple/SimpleAsyncHttpClientTest.java
index 04595946f..8ca355259 100644
--- a/api/src/test/java/org/asynchttpclient/async/SimpleAsyncHttpClientTest.java
+++ b/api/src/test/java/org/asynchttpclient/simple/SimpleAsyncHttpClientTest.java
@@ -10,105 +10,116 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient.simple;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertNotNull;
 import static org.testng.Assert.assertNotSame;
 import static org.testng.Assert.assertTrue;
 import static org.testng.Assert.fail;
 
-import org.asynchttpclient.Response;
-import org.asynchttpclient.SimpleAsyncHttpClient;
-import org.asynchttpclient.consumers.AppendableBodyConsumer;
-import org.asynchttpclient.consumers.OutputStreamBodyConsumer;
-import org.asynchttpclient.generators.FileBodyGenerator;
-import org.asynchttpclient.generators.InputStreamBodyGenerator;
-import org.asynchttpclient.multipart.ByteArrayPart;
-import org.asynchttpclient.simple.HeaderMap;
-import org.asynchttpclient.simple.SimpleAHCTransferListener;
-import org.asynchttpclient.uri.Uri;
-import org.asynchttpclient.util.StandardCharsets;
-import org.testng.annotations.Test;
-
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
-import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
+import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
 
+import org.asynchttpclient.AbstractBasicTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.request.body.generator.FileBodyGenerator;
+import org.asynchttpclient.request.body.generator.InputStreamBodyGenerator;
+import org.asynchttpclient.request.body.multipart.ByteArrayPart;
+import org.asynchttpclient.simple.HeaderMap;
+import org.asynchttpclient.simple.SimpleAHCTransferListener;
+import org.asynchttpclient.simple.SimpleAsyncHttpClient;
+import org.asynchttpclient.simple.consumer.AppendableBodyConsumer;
+import org.asynchttpclient.simple.consumer.OutputStreamBodyConsumer;
+import org.asynchttpclient.uri.Uri;
+import org.testng.annotations.Test;
+
 public abstract class SimpleAsyncHttpClientTest extends AbstractBasicTest {
 
     private final static String MY_MESSAGE = "my message";
 
-    public abstract String getProviderClass();
-
+    /**
+     * Not Used
+     * 
+     * @param config
+     * @return
+     */
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        throw new UnsupportedOperationException();
+    }
+    
     @Test(groups = { "standalone", "default_provider" })
-    public void inpuStreamBodyConsumerTest() throws Exception {
-
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setProviderClass(getProviderClass()).setPooledConnectionIdleTimeout(100)
-                .setMaxConnections(50).setRequestTimeout(5 * 60 * 1000).setUrl(getTargetUrl()).setHeader("Content-Type", "text/html").build();
-        try {
+    public void inputStreamBodyConsumerTest() throws Exception {
+
+        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
+                .setPooledConnectionIdleTimeout(100)//
+                .setMaxConnections(50)//
+                .setRequestTimeout(5 * 60 * 1000)//
+                .setUrl(getTargetUrl())//
+                .setHeader("Content-Type", "text/html").build()) {
             Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())));
 
             Response response = future.get();
             assertEquals(response.getStatusCode(), 200);
             assertEquals(response.getResponseBody(), MY_MESSAGE);
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void stringBuilderBodyConsumerTest() throws Exception {
 
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setProviderClass(getProviderClass()).setPooledConnectionIdleTimeout(100)
-                .setMaxConnections(50).setRequestTimeout(5 * 60 * 1000).setUrl(getTargetUrl()).setHeader("Content-Type", "text/html").build();
-        try {
+        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
+                .setPooledConnectionIdleTimeout(100)//
+                .setMaxConnections(50)//
+                .setRequestTimeout(5 * 60 * 1000)//
+                .setUrl(getTargetUrl())//
+                .setHeader("Content-Type", "text/html").build()) {
             StringBuilder s = new StringBuilder();
             Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())), new AppendableBodyConsumer(s));
 
             Response response = future.get();
             assertEquals(response.getStatusCode(), 200);
             assertEquals(s.toString(), MY_MESSAGE);
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void byteArrayOutputStreamBodyConsumerTest() throws Exception {
 
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setProviderClass(getProviderClass()).setPooledConnectionIdleTimeout(100)
-                .setMaxConnections(50).setRequestTimeout(5 * 60 * 1000).setUrl(getTargetUrl()).setHeader("Content-Type", "text/html").build();
-        try {
+        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
+                .setPooledConnectionIdleTimeout(100).setMaxConnections(50)//
+                .setRequestTimeout(5 * 60 * 1000)//
+                .setUrl(getTargetUrl())//
+                .setHeader("Content-Type", "text/html").build()) {
             ByteArrayOutputStream o = new ByteArrayOutputStream(10);
             Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())), new OutputStreamBodyConsumer(o));
 
             Response response = future.get();
             assertEquals(response.getStatusCode(), 200);
             assertEquals(o.toString(), MY_MESSAGE);
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void requestByteArrayOutputStreamBodyConsumerTest() throws Exception {
 
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setProviderClass(getProviderClass()).setUrl(getTargetUrl()).build();
-        try {
+        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl()).build()) {
             ByteArrayOutputStream o = new ByteArrayOutputStream(10);
             Future<Response> future = client.post(new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes())), new OutputStreamBodyConsumer(o));
 
             Response response = future.get();
             assertEquals(response.getStatusCode(), 200);
             assertEquals(o.toString(), MY_MESSAGE);
-        } finally {
-            client.close();
         }
     }
 
@@ -117,10 +128,12 @@ public void requestByteArrayOutputStreamBodyConsumerTest() throws Exception {
      */
     @Test(groups = { "standalone", "default_provider" }, enabled = true)
     public void testPutZeroBytesFileTest() throws Exception {
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setProviderClass(getProviderClass()).setPooledConnectionIdleTimeout(100)
-                .setMaxConnections(50).setRequestTimeout(5 * 1000).setUrl(getTargetUrl() + "/testPutZeroBytesFileTest.txt").setHeader("Content-Type", "text/plain")
-                .build();
-        try {
+        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
+                .setPooledConnectionIdleTimeout(100)//
+                .setMaxConnections(50)//
+                .setRequestTimeout(5 * 1000)//
+                .setUrl(getTargetUrl() + "/testPutZeroBytesFileTest.txt")//
+                .setHeader("Content-Type", "text/plain").build()) {
             File tmpfile = File.createTempFile("testPutZeroBytesFile", ".tmp");
             tmpfile.deleteOnExit();
 
@@ -132,14 +145,12 @@ public void testPutZeroBytesFileTest() throws Exception {
             tmpfile.delete();
 
             assertEquals(response.getStatusCode(), 200);
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void testDerive() throws Exception {
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setProviderClass(getProviderClass()).build();
+        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().build();
         SimpleAsyncHttpClient derived = client.derive().build();
         try {
             assertNotSame(derived, client);
@@ -151,22 +162,19 @@ public void testDerive() throws Exception {
 
     @Test(groups = { "standalone", "default_provider" })
     public void testDeriveOverrideURL() throws Exception {
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setProviderClass(getProviderClass()).setUrl("http://invalid.url").build();
-        ByteArrayOutputStream o = new ByteArrayOutputStream(10);
+        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl("http://invalid.url").build()) {
+            ByteArrayOutputStream o = new ByteArrayOutputStream(10);
 
-        InputStreamBodyGenerator generator = new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes()));
-        OutputStreamBodyConsumer consumer = new OutputStreamBodyConsumer(o);
+            InputStreamBodyGenerator generator = new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes()));
+            OutputStreamBodyConsumer consumer = new OutputStreamBodyConsumer(o);
 
-        SimpleAsyncHttpClient derived = client.derive().setUrl(getTargetUrl()).build();
-        try {
-            Future<Response> future = derived.post(generator, consumer);
+            try (SimpleAsyncHttpClient derived = client.derive().setUrl(getTargetUrl()).build()) {
+                Future<Response> future = derived.post(generator, consumer);
 
-            Response response = future.get();
-            assertEquals(response.getStatusCode(), 200);
-            assertEquals(o.toString(), MY_MESSAGE);
-        } finally {
-            client.close();
-            derived.close();
+                Response response = future.get();
+                assertEquals(response.getStatusCode(), 200);
+                assertEquals(o.toString(), MY_MESSAGE);
+            }
         }
     }
 
@@ -212,8 +220,9 @@ public void onCompleted(Uri uri, int statusCode, String statusText) {
             public void onBytesSent(Uri uri, long amount, long current, long total) {
                 try {
                     assertEquals(uri.toUrl(), getTargetUrl());
-                    // FIXME Netty bug, see https://github.com/netty/netty/issues/1855
-//                    assertEquals(total, MY_MESSAGE.getBytes().length);
+                    // FIXME Netty bug, see
+                    // https://github.com/netty/netty/issues/1855
+                    // assertEquals(total, MY_MESSAGE.getBytes().length);
                 } catch (Error e) {
                     errors.add(e);
                     throw e;
@@ -231,9 +240,11 @@ public void onBytesReceived(Uri uri, long amount, long current, long total) {
             }
         };
 
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setProviderClass(getProviderClass()).setUrl(getTargetUrl()).setHeader("Custom", "custom")
-                .setListener(listener).build();
-        try {
+        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
+                //
+                .setUrl(getTargetUrl())//
+                .setHeader("Custom", "custom")//
+                .setListener(listener).build()) {
             ByteArrayOutputStream o = new ByteArrayOutputStream(10);
 
             InputStreamBodyGenerator generator = new InputStreamBodyGenerator(new ByteArrayInputStream(MY_MESSAGE.getBytes()));
@@ -252,45 +263,32 @@ public void onBytesReceived(Uri uri, long amount, long current, long total) {
 
             assertEquals(response.getStatusCode(), 200);
             assertEquals(o.toString(), MY_MESSAGE);
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void testNullUrl() throws Exception {
-        SimpleAsyncHttpClient client = null;
-        try {
-            client = new SimpleAsyncHttpClient.Builder().setProviderClass(getProviderClass()).build();
+
+        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().build()) {
             assertTrue(true);
-        } catch (NullPointerException ex) {
-            fail();
-        } finally {
-            if (client != null)
-                client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void testCloseDerivedValidMaster() throws Exception {
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setProviderClass(getProviderClass()).setUrl(getTargetUrl()).build();
-        SimpleAsyncHttpClient derived = client.derive().build();
-        try {
-            derived.get().get();
-
-            derived.close();
+        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl()).build()) {
+            try (SimpleAsyncHttpClient derived = client.derive().build()) {
+                derived.get().get();
+            }
 
             Response response = client.get().get();
-
             assertEquals(response.getStatusCode(), 200);
-        } finally {
-            client.close();
         }
     }
 
-    @Test(groups = { "standalone", "default_provider" })
-    public void testCloseMasterInvalidDerived() throws Exception {
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setProviderClass(getProviderClass()).setUrl(getTargetUrl()).build();
+    @Test(groups = { "standalone", "default_provider" }, expectedExceptions = { IllegalStateException.class })
+    public void testCloseMasterInvalidDerived() throws Throwable {
+        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl()).build();
         SimpleAsyncHttpClient derived = client.derive().build();
 
         client.close();
@@ -298,16 +296,15 @@ public void testCloseMasterInvalidDerived() throws Exception {
         try {
             derived.get().get();
             fail("Expected closed AHC");
-        } catch (IOException e) {
-            // expected
+        } catch (ExecutionException e) {
+            throw e.getCause();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void testMultiPartPut() throws Exception {
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setProviderClass(getProviderClass()).setUrl(getTargetUrl() + "/multipart").build();
-        try {
-            Response response = client.put(new ByteArrayPart("baPart", "testMultiPart".getBytes(StandardCharsets.UTF_8), "application/test", StandardCharsets.UTF_8, "fileName")).get();
+        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl() + "/multipart").build()) {
+            Response response = client.put(new ByteArrayPart("baPart", "testMultiPart".getBytes(UTF_8), "application/test", UTF_8, "fileName")).get();
 
             String body = response.getResponseBody();
             String contentType = response.getHeader("X-Content-Type");
@@ -322,16 +319,13 @@ public void testMultiPartPut() throws Exception {
             assertTrue(body.contains("Content-Type: application/test"));
             assertTrue(body.contains("name=\"baPart"));
             assertTrue(body.contains("filename=\"fileName"));
-        } finally {
-            client.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void testMultiPartPost() throws Exception {
-        SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setProviderClass(getProviderClass()).setUrl(getTargetUrl() + "/multipart").build();
-        try {
-            Response response = client.post(new ByteArrayPart("baPart", "testMultiPart".getBytes(StandardCharsets.UTF_8), "application/test", StandardCharsets.UTF_8, "fileName")).get();
+        try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder().setUrl(getTargetUrl() + "/multipart").build()) {
+            Response response = client.post(new ByteArrayPart("baPart", "testMultiPart".getBytes(UTF_8), "application/test", UTF_8, "fileName")).get();
 
             String body = response.getResponseBody();
             String contentType = response.getHeader("X-Content-Type");
@@ -346,8 +340,6 @@ public void testMultiPartPost() throws Exception {
             assertTrue(body.contains("Content-Type: application/test"));
             assertTrue(body.contains("name=\"baPart"));
             assertTrue(body.contains("filename=\"fileName"));
-        } finally {
-            client.close();
         }
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/util/EchoHandler.java b/api/src/test/java/org/asynchttpclient/test/EchoHandler.java
similarity index 98%
rename from api/src/test/java/org/asynchttpclient/async/util/EchoHandler.java
rename to api/src/test/java/org/asynchttpclient/test/EchoHandler.java
index 00e132c84..bbb97b342 100644
--- a/api/src/test/java/org/asynchttpclient/async/util/EchoHandler.java
+++ b/api/src/test/java/org/asynchttpclient/test/EchoHandler.java
@@ -1,4 +1,4 @@
-package org.asynchttpclient.async.util;
+package org.asynchttpclient.test;
 
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
diff --git a/api/src/test/java/org/asynchttpclient/test/EventCollectingHandler.java b/api/src/test/java/org/asynchttpclient/test/EventCollectingHandler.java
new file mode 100644
index 000000000..325add4f3
--- /dev/null
+++ b/api/src/test/java/org/asynchttpclient/test/EventCollectingHandler.java
@@ -0,0 +1,116 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.test;
+
+import java.net.InetAddress;
+import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import org.asynchttpclient.AsyncCompletionHandlerBase;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.handler.AsyncHandlerExtensions;
+import org.testng.Assert;
+
+public class EventCollectingHandler extends AsyncCompletionHandlerBase implements AsyncHandlerExtensions {
+    public Queue<String> firedEvents = new ConcurrentLinkedQueue<>();
+    private CountDownLatch completionLatch = new CountDownLatch(1);
+
+    public void waitForCompletion(int timeout, TimeUnit unit) throws InterruptedException {
+        if (!completionLatch.await(timeout, unit)) {
+            Assert.fail("Timeout out");
+        }
+    }
+
+    @Override
+    public Response onCompleted(Response response) throws Exception {
+        firedEvents.add("Completed");
+        try {
+            return super.onCompleted(response);
+        } finally {
+            completionLatch.countDown();
+        }
+    }
+
+    @Override
+    public State onStatusReceived(HttpResponseStatus status) throws Exception {
+        firedEvents.add("StatusReceived");
+        return super.onStatusReceived(status);
+    }
+
+    @Override
+    public State onHeadersReceived(HttpResponseHeaders headers) throws Exception {
+        firedEvents.add("HeadersReceived");
+        return super.onHeadersReceived(headers);
+    }
+
+    @Override
+    public State onHeadersWritten() {
+        firedEvents.add("HeadersWritten");
+        return super.onHeadersWritten();
+    }
+
+    @Override
+    public State onContentWritten() {
+        firedEvents.add("ContentWritten");
+        return super.onContentWritten();
+    }
+
+    @Override
+    public void onConnectionOpen() {
+        firedEvents.add("ConnectionOpen");
+    }
+
+    @Override
+    public void onConnectionOpened(Object connection) {
+        firedEvents.add("ConnectionOpened");
+    }
+
+    @Override
+    public void onConnectionPool() {
+        firedEvents.add("ConnectionPool");
+    }
+
+    @Override
+    public void onConnectionPooled(Object connection) {
+        firedEvents.add("ConnectionPooled");
+    }
+
+    @Override
+    public void onConnectionOffer(Object connection) {
+        firedEvents.add("ConnectionOffer");
+    }
+    
+    @Override
+    public void onRequestSend(Object request) {
+        firedEvents.add("RequestSend");
+    }
+
+    @Override
+    public void onRetry() {
+        firedEvents.add("Retry");
+    }
+
+    @Override
+    public void onDnsResolved(InetAddress remoteAddress) {
+        firedEvents.add("DnsResolved");
+    }
+
+    @Override
+    public void onSslHandshakeCompleted() {
+        firedEvents.add("SslHandshakeCompleted");
+    }
+}
diff --git a/api/src/test/java/org/asynchttpclient/async/util/TestUtils.java b/api/src/test/java/org/asynchttpclient/test/TestUtils.java
similarity index 80%
rename from api/src/test/java/org/asynchttpclient/async/util/TestUtils.java
rename to api/src/test/java/org/asynchttpclient/test/TestUtils.java
index ad87080b8..548f062bc 100644
--- a/api/src/test/java/org/asynchttpclient/async/util/TestUtils.java
+++ b/api/src/test/java/org/asynchttpclient/test/TestUtils.java
@@ -1,9 +1,9 @@
-package org.asynchttpclient.async.util;
+package org.asynchttpclient.test;
 
+import static java.nio.charset.StandardCharsets.*;
 import static org.testng.Assert.assertEquals;
 
 import org.apache.commons.io.FileUtils;
-import org.asynchttpclient.util.StandardCharsets;
 import org.eclipse.jetty.security.ConstraintMapping;
 import org.eclipse.jetty.security.ConstraintSecurityHandler;
 import org.eclipse.jetty.security.HashLoginService;
@@ -20,6 +20,10 @@
 import org.eclipse.jetty.server.SslConnectionFactory;
 import org.eclipse.jetty.util.security.Constraint;
 import org.eclipse.jetty.util.ssl.SslContextFactory;
+import org.reactivestreams.Publisher;
+
+import rx.Observable;
+import rx.RxReactiveStreams;
 
 import javax.net.ssl.*;
 
@@ -32,12 +36,15 @@
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.net.URL;
+import java.nio.ByteBuffer;
 import java.nio.charset.Charset;
 import java.security.*;
 import java.security.cert.CertificateException;
 import java.security.cert.X509Certificate;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.HashSet;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
 import java.util.UUID;
@@ -52,7 +59,8 @@
     private static final File TMP_DIR = new File(System.getProperty("java.io.tmpdir"), "ahc-tests-" + UUID.randomUUID().toString().substring(0, 8));
     public static final byte[] PATTERN_BYTES = "FooBarBazQixFooBarBazQixFooBarBazQixFooBarBazQixFooBarBazQixFooBarBazQix".getBytes(Charset.forName("UTF-16"));
     public static final File LARGE_IMAGE_FILE;
-    public static byte[] LARGE_IMAGE_BYTES;
+    public static final byte[] LARGE_IMAGE_BYTES;
+    public static final Publisher<ByteBuffer> LARGE_IMAGE_PUBLISHER;
     public static final File SIMPLE_TEXT_FILE;
     public static final String SIMPLE_TEXT_FILE_STRING;
     private static final LoginService LOGIN_SERVICE = new HashLoginService("MyRealm", "src/test/resources/realm.properties");
@@ -63,23 +71,17 @@
             TMP_DIR.deleteOnExit();
             LARGE_IMAGE_FILE = new File(TestUtils.class.getClassLoader().getResource("300k.png").toURI());
             LARGE_IMAGE_BYTES = FileUtils.readFileToByteArray(LARGE_IMAGE_FILE);
+            LARGE_IMAGE_PUBLISHER = createPublisher(LARGE_IMAGE_BYTES, /*chunkSize*/ 1000);
             SIMPLE_TEXT_FILE = new File(TestUtils.class.getClassLoader().getResource("SimpleTextFile.txt").toURI());
-            SIMPLE_TEXT_FILE_STRING = FileUtils.readFileToString(SIMPLE_TEXT_FILE, StandardCharsets.UTF_8);
+            SIMPLE_TEXT_FILE_STRING = FileUtils.readFileToString(SIMPLE_TEXT_FILE, UTF_8);
         } catch (Exception e) {
             throw new ExceptionInInitializerError(e);
         }
     }
 
     public static synchronized int findFreePort() throws IOException {
-        ServerSocket socket = null;
-
-        try {
-            socket = new ServerSocket(0);
-
+        try (ServerSocket socket = new ServerSocket(0)) {
             return socket.getLocalPort();
-        } finally {
-            if (socket != null)
-                socket.close();
         }
     }
 
@@ -87,9 +89,7 @@ public static File createTempFile(int approxSize) throws IOException {
         long repeats = approxSize / TestUtils.PATTERN_BYTES.length + 1;
         File tmpFile = File.createTempFile("tmpfile-", ".data", TMP_DIR);
         tmpFile.deleteOnExit();
-        FileOutputStream out = null;
-        try {
-            out = new FileOutputStream(tmpFile);
+        try (FileOutputStream out = new FileOutputStream(tmpFile)) {
             for (int i = 0; i < repeats; i++) {
                 out.write(PATTERN_BYTES);
             }
@@ -98,10 +98,46 @@ public static File createTempFile(int approxSize) throws IOException {
             assertEquals(tmpFile.length(), expectedFileSize, "Invalid file length");
 
             return tmpFile;
-        } finally {
-            if (out != null) {
-                out.close();
-            }
+        }
+    }
+
+    public static Publisher<ByteBuffer> createPublisher(final byte[] bytes, final int chunkSize) {
+        Observable<ByteBuffer> observable = Observable.from(new ByteBufferIterable(bytes, chunkSize));
+        return RxReactiveStreams.toPublisher(observable);
+    }
+
+    public static class ByteBufferIterable implements Iterable<ByteBuffer> {
+        private final byte[] payload;
+        private final int chunkSize;
+
+        public ByteBufferIterable(byte[] payload, int chunkSize) {
+            this.payload = payload;
+            this.chunkSize = chunkSize;
+        }
+
+
+        @Override
+        public Iterator<ByteBuffer> iterator() {
+            return new Iterator<ByteBuffer>() {
+                private int currentIndex = 0;
+                @Override
+                public boolean hasNext() {
+                    return currentIndex != payload.length;
+                }
+
+                @Override
+                public ByteBuffer next() {
+                    int newIndex = Math.min(currentIndex + chunkSize, payload.length);
+                    byte[] bytesInElement = Arrays.copyOfRange(payload, currentIndex, newIndex);
+                    currentIndex = newIndex;
+                    return ByteBuffer.wrap(bytesInElement);
+                }
+
+                @Override
+                public void remove() {
+                    throw new UnsupportedOperationException("ByteBufferIterable's iterator does not support remove.");
+                }
+            };
         }
     }
 
@@ -147,15 +183,15 @@ public static void addHttpsConnector(Server server, int port) throws URISyntaxEx
         server.addConnector(connector);
     }
 
-    public static void addBasicAuthHandler(Server server, boolean strict, Handler handler) {
-        addAuthHandler(server, Constraint.__BASIC_AUTH, new BasicAuthenticator(), strict, handler);
+    public static void addBasicAuthHandler(Server server, Handler handler) {
+        addAuthHandler(server, Constraint.__BASIC_AUTH, new BasicAuthenticator(), handler);
     }
 
-    public static void addDigestAuthHandler(Server server, boolean strict, Handler handler) {
-        addAuthHandler(server, Constraint.__DIGEST_AUTH, new DigestAuthenticator(), strict, handler);
+    public static void addDigestAuthHandler(Server server, Handler handler) {
+        addAuthHandler(server, Constraint.__DIGEST_AUTH, new DigestAuthenticator(), handler);
     }
 
-    private static void addAuthHandler(Server server, String auth, LoginAuthenticator authenticator, boolean strict, Handler handler) {
+    private static void addAuthHandler(Server server, String auth, LoginAuthenticator authenticator, Handler handler) {
 
         server.addBean(LOGIN_SERVICE);
 
@@ -168,18 +204,17 @@ private static void addAuthHandler(Server server, String auth, LoginAuthenticato
         mapping.setConstraint(constraint);
         mapping.setPathSpec("/*");
 
-        Set<String> knownRoles = new HashSet<String>();
+        Set<String> knownRoles = new HashSet<>();
         knownRoles.add(USER);
         knownRoles.add(ADMIN);
 
-        List<ConstraintMapping> cm = new ArrayList<ConstraintMapping>();
+        List<ConstraintMapping> cm = new ArrayList<>();
         cm.add(mapping);
 
         ConstraintSecurityHandler security = new ConstraintSecurityHandler();
         security.setConstraintMappings(cm, knownRoles);
         security.setAuthenticator(authenticator);
         security.setLoginService(LOGIN_SERVICE);
-        security.setStrict(strict);
         security.setHandler(handler);
         server.setHandler(security);
     }
diff --git a/api/src/test/java/org/asynchttpclient/uri/UriTest.java b/api/src/test/java/org/asynchttpclient/uri/UriTest.java
index c54c1f895..3f798ed7f 100644
--- a/api/src/test/java/org/asynchttpclient/uri/UriTest.java
+++ b/api/src/test/java/org/asynchttpclient/uri/UriTest.java
@@ -15,6 +15,7 @@
 import org.testng.annotations.Test;
 
 import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNull;
 
 public class UriTest {
 
@@ -83,5 +84,134 @@ public void testAbsoluteURIWithContext() {
         assertEquals(url.getPath(), "/750198471659552/accounts/test-users");
         assertEquals(url.getQuery(), "method=get&access_token=750198471659552lleveCvbUu_zqBa9tkT3tcgaPh4");
     }
-}
 
+    @Test
+    public void testRelativeUriWithDots() {
+        Uri context = Uri.create("https://hello.com/level1/level2/");
+
+        Uri url = Uri.create(context, "../other/content/img.png");
+
+        assertEquals(url.getScheme(), "https");
+        assertEquals(url.getHost(), "hello.com");
+        assertEquals(url.getPort(), -1);
+        assertEquals(url.getPath(), "/level1/other/content/img.png");
+        assertNull(url.getQuery());
+    }
+
+    @Test
+    public void testRelativeUriWithDotsAboveRoot() {
+        Uri context = Uri.create("https://hello.com/level1");
+
+        Uri url = Uri.create(context, "../other/content/img.png");
+
+        assertEquals(url.getScheme(), "https");
+        assertEquals(url.getHost(), "hello.com");
+        assertEquals(url.getPort(), -1);
+        assertEquals(url.getPath(), "/../other/content/img.png");
+        assertNull(url.getQuery());
+    }
+
+    @Test
+    public void testRelativeUriWithAbsoluteDots() {
+        Uri context = Uri.create("https://hello.com/level1/");
+
+        Uri url = Uri.create(context, "/../other/content/img.png");
+
+        assertEquals(url.getScheme(), "https");
+        assertEquals(url.getHost(), "hello.com");
+        assertEquals(url.getPort(), -1);
+        assertEquals(url.getPath(), "/../other/content/img.png");
+        assertNull(url.getQuery());
+    }
+
+    @Test
+    public void testRelativeUriWithConsecutiveDots() {
+        Uri context = Uri.create("https://hello.com/level1/level2/");
+
+        Uri url = Uri.create(context, "../../other/content/img.png");
+
+        assertEquals(url.getScheme(), "https");
+        assertEquals(url.getHost(), "hello.com");
+        assertEquals(url.getPort(), -1);
+        assertEquals(url.getPath(), "/other/content/img.png");
+        assertNull(url.getQuery());
+    }
+
+    @Test
+    public void testRelativeUriWithConsecutiveDotsAboveRoot() {
+        Uri context = Uri.create("https://hello.com/level1/level2");
+
+        Uri url = Uri.create(context, "../../other/content/img.png");
+
+        assertEquals(url.getScheme(), "https");
+        assertEquals(url.getHost(), "hello.com");
+        assertEquals(url.getPort(), -1);
+        assertEquals(url.getPath(), "/../other/content/img.png");
+        assertNull(url.getQuery());
+    }
+
+    @Test
+    public void testRelativeUriWithAbsoluteConsecutiveDots() {
+        Uri context = Uri.create("https://hello.com/level1/level2/");
+
+        Uri url = Uri.create(context, "/../../other/content/img.png");
+
+        assertEquals(url.getScheme(), "https");
+        assertEquals(url.getHost(), "hello.com");
+        assertEquals(url.getPort(), -1);
+        assertEquals(url.getPath(), "/../../other/content/img.png");
+        assertNull(url.getQuery());
+    }
+
+    @Test
+    public void testRelativeUriWithConsecutiveDotsFromRoot() {
+        Uri context = Uri.create("https://hello.com/");
+
+        Uri url = Uri.create(context, "../../../other/content/img.png");
+
+        assertEquals(url.getScheme(), "https");
+        assertEquals(url.getHost(), "hello.com");
+        assertEquals(url.getPort(), -1);
+        assertEquals(url.getPath(), "/../../../other/content/img.png");
+        assertNull(url.getQuery());
+    }
+
+    @Test
+    public void testRelativeUriWithConsecutiveDotsFromRootResource() {
+        Uri context = Uri.create("https://hello.com/level1");
+
+        Uri url = Uri.create(context, "../../../other/content/img.png");
+
+        assertEquals(url.getScheme(), "https");
+        assertEquals(url.getHost(), "hello.com");
+        assertEquals(url.getPort(), -1);
+        assertEquals(url.getPath(), "/../../../other/content/img.png");
+        assertNull(url.getQuery());
+    }
+
+    @Test
+    public void testRelativeUriWithConsecutiveDotsFromSubrootResource() {
+        Uri context = Uri.create("https://hello.com/level1/level2");
+
+        Uri url = Uri.create(context, "../../../other/content/img.png");
+
+        assertEquals(url.getScheme(), "https");
+        assertEquals(url.getHost(), "hello.com");
+        assertEquals(url.getPort(), -1);
+        assertEquals(url.getPath(), "/../../other/content/img.png");
+        assertNull(url.getQuery());
+    }
+
+    @Test
+    public void testRelativeUriWithConsecutiveDotsFromLevel3Resource() {
+        Uri context = Uri.create("https://hello.com/level1/level2/level3");
+
+        Uri url = Uri.create(context, "../../../other/content/img.png");
+
+        assertEquals(url.getScheme(), "https");
+        assertEquals(url.getHost(), "hello.com");
+        assertEquals(url.getPort(), -1);
+        assertEquals(url.getPath(), "/../other/content/img.png");
+        assertNull(url.getQuery());
+    }
+}
diff --git a/api/src/test/java/org/asynchttpclient/util/TestUTF8UrlCodec.java b/api/src/test/java/org/asynchttpclient/util/TestUTF8UrlCodec.java
index 3b1dcdfba..7c74caa9c 100644
--- a/api/src/test/java/org/asynchttpclient/util/TestUTF8UrlCodec.java
+++ b/api/src/test/java/org/asynchttpclient/util/TestUTF8UrlCodec.java
@@ -22,8 +22,8 @@
 public class TestUTF8UrlCodec {
     @Test(groups = "fast")
     public void testBasics() {
-        assertEquals(UTF8UrlEncoder.encode("foobar"), "foobar");
-        assertEquals(UTF8UrlEncoder.encode("a&b"), "a%26b");
-        assertEquals(UTF8UrlEncoder.encode("a+b"), "a%2Bb");
+        assertEquals(Utf8UrlEncoder.encodeQueryElement("foobar"), "foobar");
+        assertEquals(Utf8UrlEncoder.encodeQueryElement("a&b"), "a%26b");
+        assertEquals(Utf8UrlEncoder.encodeQueryElement("a+b"), "a%2Bb");
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/async/WebDavBasicTest.java b/api/src/test/java/org/asynchttpclient/webdav/WebDavBasicTest.java
similarity index 89%
rename from api/src/test/java/org/asynchttpclient/async/WebDavBasicTest.java
rename to api/src/test/java/org/asynchttpclient/webdav/WebDavBasicTest.java
index 7045925d5..e8aaa5215 100644
--- a/api/src/test/java/org/asynchttpclient/async/WebDavBasicTest.java
+++ b/api/src/test/java/org/asynchttpclient/webdav/WebDavBasicTest.java
@@ -10,9 +10,9 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.async;
+package org.asynchttpclient.webdav;
 
-import static org.asynchttpclient.async.util.TestUtils.findFreePort;
+import static org.asynchttpclient.test.TestUtils.findFreePort;
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertNotNull;
 import static org.testng.Assert.assertTrue;
@@ -24,6 +24,7 @@
 import org.apache.catalina.connector.Connector;
 import org.apache.catalina.startup.Embedded;
 import org.apache.coyote.http11.Http11NioProtocol;
+import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.Request;
 import org.asynchttpclient.RequestBuilder;
@@ -89,61 +90,43 @@ protected String getTargetUrl() {
     @AfterMethod(alwaysRun = true)
     // FIXME not sure that's threadsafe
     public void clean() throws InterruptedException, Exception {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
             Request deleteRequest = new RequestBuilder("DELETE").setUrl(getTargetUrl()).build();
             c.executeRequest(deleteRequest).get();
-        } finally {
-            c.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void mkcolWebDavTest1() throws InterruptedException, IOException, ExecutionException {
-
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
             Request mkcolRequest = new RequestBuilder("MKCOL").setUrl(getTargetUrl()).build();
             Response response = c.executeRequest(mkcolRequest).get();
-
             assertEquals(response.getStatusCode(), 201);
-        } finally {
-            c.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void mkcolWebDavTest2() throws InterruptedException, IOException, ExecutionException {
-
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
             Request mkcolRequest = new RequestBuilder("MKCOL").setUrl(getTargetUrl() + "/folder2").build();
             Response response = c.executeRequest(mkcolRequest).get();
             assertEquals(response.getStatusCode(), 409);
-        } finally {
-            c.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void basicPropFindWebDavTest() throws InterruptedException, IOException, ExecutionException {
-
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
             Request propFindRequest = new RequestBuilder("PROPFIND").setUrl(getTargetUrl()).build();
             Response response = c.executeRequest(propFindRequest).get();
 
             assertEquals(response.getStatusCode(), 404);
-        } finally {
-            c.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void propFindWebDavTest() throws InterruptedException, IOException, ExecutionException {
-
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
             Request mkcolRequest = new RequestBuilder("MKCOL").setUrl(getTargetUrl()).build();
             Response response = c.executeRequest(mkcolRequest).get();
             assertEquals(response.getStatusCode(), 201);
@@ -157,16 +140,12 @@ public void propFindWebDavTest() throws InterruptedException, IOException, Execu
 
             assertEquals(response.getStatusCode(), 207);
             assertTrue(response.getResponseBody().contains("<status>HTTP/1.1 200 OK</status>"));
-        } finally {
-            c.close();
         }
     }
 
     @Test(groups = { "standalone", "default_provider" })
     public void propFindCompletionHandlerWebDavTest() throws InterruptedException, IOException, ExecutionException {
-
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
             Request mkcolRequest = new RequestBuilder("MKCOL").setUrl(getTargetUrl()).build();
             Response response = c.executeRequest(mkcolRequest).get();
             assertEquals(response.getStatusCode(), 201);
@@ -190,8 +169,6 @@ public WebDavResponse onCompleted(WebDavResponse response) throws Exception {
 
             assertNotNull(webDavResponse);
             assertEquals(webDavResponse.getStatusCode(), 200);
-        } finally {
-            c.close();
         }
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/websocket/AbstractBasicTest.java b/api/src/test/java/org/asynchttpclient/ws/AbstractBasicTest.java
similarity index 87%
rename from api/src/test/java/org/asynchttpclient/websocket/AbstractBasicTest.java
rename to api/src/test/java/org/asynchttpclient/ws/AbstractBasicTest.java
index f5f944d0c..2c74a0dfa 100644
--- a/api/src/test/java/org/asynchttpclient/websocket/AbstractBasicTest.java
+++ b/api/src/test/java/org/asynchttpclient/ws/AbstractBasicTest.java
@@ -10,16 +10,16 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.websocket;
+package org.asynchttpclient.ws;
 
-import static org.asynchttpclient.async.util.TestUtils.findFreePort;
-import static org.asynchttpclient.async.util.TestUtils.newJettyHttpServer;
+import static org.asynchttpclient.test.TestUtils.findFreePort;
+import static org.asynchttpclient.test.TestUtils.newJettyHttpServer;
 
 import org.eclipse.jetty.websocket.server.WebSocketHandler;
 import org.testng.annotations.AfterClass;
 import org.testng.annotations.BeforeClass;
 
-public abstract class AbstractBasicTest extends org.asynchttpclient.async.AbstractBasicTest {
+public abstract class AbstractBasicTest extends org.asynchttpclient.AbstractBasicTest {
 
     @BeforeClass(alwaysRun = true)
     public void setUpGlobal() throws Exception {
diff --git a/api/src/test/java/org/asynchttpclient/websocket/ByteMessageTest.java b/api/src/test/java/org/asynchttpclient/ws/ByteMessageTest.java
similarity index 92%
rename from api/src/test/java/org/asynchttpclient/websocket/ByteMessageTest.java
rename to api/src/test/java/org/asynchttpclient/ws/ByteMessageTest.java
index d1078047e..b1371a70b 100644
--- a/api/src/test/java/org/asynchttpclient/websocket/ByteMessageTest.java
+++ b/api/src/test/java/org/asynchttpclient/ws/ByteMessageTest.java
@@ -10,11 +10,14 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.websocket;
+package org.asynchttpclient.ws;
 
 import static org.testng.Assert.assertEquals;
 
 import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.ws.WebSocket;
+import org.asynchttpclient.ws.WebSocketByteListener;
+import org.asynchttpclient.ws.WebSocketUpgradeHandler;
 import org.eclipse.jetty.websocket.server.WebSocketHandler;
 import org.eclipse.jetty.websocket.servlet.WebSocketServletFactory;
 import org.testng.annotations.Test;
@@ -36,10 +39,9 @@ public void configure(WebSocketServletFactory factory) {
 
     @Test
     public void echoByte() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
             final CountDownLatch latch = new CountDownLatch(1);
-            final AtomicReference<byte[]> text = new AtomicReference<byte[]>(new byte[0]);
+            final AtomicReference<byte[]> text = new AtomicReference<>(new byte[0]);
 
             WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketByteListener() {
 
@@ -70,17 +72,14 @@ public void onMessage(byte[] message) {
 
             latch.await();
             assertEquals(text.get(), "ECHO".getBytes());
-        } finally {
-            c.close();
         }
     }
 
     @Test
     public void echoTwoMessagesTest() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
             final CountDownLatch latch = new CountDownLatch(2);
-            final AtomicReference<byte[]> text = new AtomicReference<byte[]>(null);
+            final AtomicReference<byte[]> text = new AtomicReference<>(null);
 
             WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketByteListener() {
 
@@ -118,17 +117,14 @@ public void onMessage(byte[] message) {
 
             latch.await();
             assertEquals(text.get(), "ECHOECHO".getBytes());
-        } finally {
-            c.close();
         }
     }
 
     @Test
     public void echoOnOpenMessagesTest() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
             final CountDownLatch latch = new CountDownLatch(2);
-            final AtomicReference<byte[]> text = new AtomicReference<byte[]>(null);
+            final AtomicReference<byte[]> text = new AtomicReference<>(null);
 
             /* WebSocket websocket = */c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketByteListener() {
 
@@ -165,16 +161,13 @@ public void onMessage(byte[] message) {
 
             latch.await();
             assertEquals(text.get(), "ECHOECHO".getBytes());
-        } finally {
-            c.close();
         }
     }
 
     public void echoFragments() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
             final CountDownLatch latch = new CountDownLatch(1);
-            final AtomicReference<byte[]> text = new AtomicReference<byte[]>(null);
+            final AtomicReference<byte[]> text = new AtomicReference<>(null);
 
             WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketByteListener() {
 
@@ -211,8 +204,6 @@ public void onMessage(byte[] message) {
             websocket.stream("ECHO".getBytes(), true);
             latch.await();
             assertEquals(text.get(), "ECHOECHO".getBytes());
-        } finally {
-            c.close();
         }
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/websocket/CloseCodeReasonMessageTest.java b/api/src/test/java/org/asynchttpclient/ws/CloseCodeReasonMessageTest.java
similarity index 70%
rename from api/src/test/java/org/asynchttpclient/websocket/CloseCodeReasonMessageTest.java
rename to api/src/test/java/org/asynchttpclient/ws/CloseCodeReasonMessageTest.java
index 5ab3ca228..182c77845 100644
--- a/api/src/test/java/org/asynchttpclient/websocket/CloseCodeReasonMessageTest.java
+++ b/api/src/test/java/org/asynchttpclient/ws/CloseCodeReasonMessageTest.java
@@ -10,18 +10,24 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.websocket;
+package org.asynchttpclient.ws;
 
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertNotNull;
 import static org.testng.Assert.assertTrue;
 
 import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.ws.WebSocket;
+import org.asynchttpclient.ws.WebSocketCloseCodeReasonListener;
+import org.asynchttpclient.ws.WebSocketListener;
+import org.asynchttpclient.ws.WebSocketTextListener;
+import org.asynchttpclient.ws.WebSocketUpgradeHandler;
 import org.eclipse.jetty.websocket.server.WebSocketHandler;
 import org.eclipse.jetty.websocket.servlet.WebSocketServletFactory;
 import org.testng.annotations.Test;
 
 import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
 import java.util.concurrent.atomic.AtomicReference;
 
 public abstract class CloseCodeReasonMessageTest extends AbstractBasicTest {
@@ -38,10 +44,9 @@ public void configure(WebSocketServletFactory factory) {
     
     @Test(timeOut = 60000)
     public void onCloseWithCode() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
             final CountDownLatch latch = new CountDownLatch(1);
-            final AtomicReference<String> text = new AtomicReference<String>("");
+            final AtomicReference<String> text = new AtomicReference<>("");
 
             WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new Listener(latch, text)).build()).get();
 
@@ -49,29 +54,23 @@ public void onCloseWithCode() throws Exception {
 
             latch.await();
             assertTrue(text.get().startsWith("1000"));
-        } finally {
-            c.close();
         }
     }
 
     @Test(timeOut = 60000)
     public void onCloseWithCodeServerClose() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
             final CountDownLatch latch = new CountDownLatch(1);
-            final AtomicReference<String> text = new AtomicReference<String>("");
+            final AtomicReference<String> text = new AtomicReference<>("");
 
             c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new Listener(latch, text)).build()).get();
 
             latch.await();
             assertEquals(text.get(), "1001-Idle Timeout");
-        } finally {
-            c.close();
         }
     }
 
-    public final static class Listener implements WebSocketListener,
-            WebSocketCloseCodeReasonListener {
+    public final static class Listener implements WebSocketListener, WebSocketCloseCodeReasonListener {
 
         final CountDownLatch latch;
         final AtomicReference<String> text;
@@ -102,25 +101,52 @@ public void onError(Throwable t) {
         }
     }
 
-    @Test(timeOut = 60000)
+    @Test(timeOut = 60000, expectedExceptions = { ExecutionException.class })
+    public void getWebSocketThrowsException() throws Throwable {
+        final CountDownLatch latch = new CountDownLatch(1);
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
+            client.prepareGet("http://apache.org").execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketTextListener() {
+
+                @Override
+                public void onMessage(String message) {
+                }
+
+                @Override
+                public void onOpen(WebSocket websocket) {
+                }
+
+                @Override
+                public void onClose(WebSocket websocket) {
+                }
+
+                @Override
+                public void onError(Throwable t) {
+                    latch.countDown();
+                }
+            }).build()).get();
+        }
+        
+        latch.await();
+    }
+
+    @Test(timeOut = 60000, expectedExceptions = { IllegalArgumentException.class } )
     public void wrongStatusCode() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
             final CountDownLatch latch = new CountDownLatch(1);
-            final AtomicReference<Throwable> throwable = new AtomicReference<Throwable>();
+            final AtomicReference<Throwable> throwable = new AtomicReference<>();
 
-            c.prepareGet("http://apache.org").execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketTextListener() {
+            client.prepareGet("http://apache.org").execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketTextListener() {
 
                 @Override
                 public void onMessage(String message) {
                 }
 
                 @Override
-                public void onOpen(WebSocket websocket) {
+                public void onOpen(org.asynchttpclient.ws.WebSocket websocket) {
                 }
 
                 @Override
-                public void onClose(WebSocket websocket) {
+                public void onClose(org.asynchttpclient.ws.WebSocket websocket) {
                 }
 
                 @Override
@@ -128,22 +154,19 @@ public void onError(Throwable t) {
                     throwable.set(t);
                     latch.countDown();
                 }
-            }).build()).get();
+            }).build());
 
             latch.await();
             assertNotNull(throwable.get());
-            assertEquals(throwable.get().getClass(), IllegalStateException.class);
-        } finally {
-            c.close();
+            throw throwable.get();
         }
     }
 
-    @Test(timeOut = 60000)
+    @Test(timeOut = 60000, expectedExceptions = { IllegalStateException.class } )
     public void wrongProtocolCode() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
             final CountDownLatch latch = new CountDownLatch(1);
-            final AtomicReference<Throwable> throwable = new AtomicReference<Throwable>();
+            final AtomicReference<Throwable> throwable = new AtomicReference<>();
 
             c.prepareGet("ws://www.google.com").execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketTextListener() {
 
@@ -164,13 +187,11 @@ public void onError(Throwable t) {
                     throwable.set(t);
                     latch.countDown();
                 }
-            }).build()).get();
+            }).build());
 
             latch.await();
             assertNotNull(throwable.get());
-            assertEquals(throwable.get().getClass(), IllegalStateException.class);
-        } finally {
-            c.close();
+            throw throwable.get();
         }
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/websocket/EchoSocket.java b/api/src/test/java/org/asynchttpclient/ws/EchoSocket.java
similarity index 82%
rename from api/src/test/java/org/asynchttpclient/websocket/EchoSocket.java
rename to api/src/test/java/org/asynchttpclient/ws/EchoSocket.java
index 9bc51fc79..dcb7d75ea 100644
--- a/api/src/test/java/org/asynchttpclient/websocket/EchoSocket.java
+++ b/api/src/test/java/org/asynchttpclient/ws/EchoSocket.java
@@ -1,4 +1,4 @@
-package org.asynchttpclient.websocket;
+package org.asynchttpclient.ws;
 
 import org.eclipse.jetty.websocket.api.Session;
 import org.eclipse.jetty.websocket.api.WebSocketAdapter;
@@ -12,17 +12,11 @@
     public void onWebSocketConnect(Session sess) {
         super.onWebSocketConnect(sess);
         sess.setIdleTimeout(10000);
-        sess.setMaximumMessageSize(1000);
     }
 
     @Override
     public void onWebSocketClose(int statusCode, String reason) {
-        try {
-            getSession().close();
-        } catch (IOException e) {
-            // TODO Auto-generated catch block
-            e.printStackTrace();
-        }
+        getSession().close();
         super.onWebSocketClose(statusCode, reason);
     }
 
diff --git a/api/src/test/java/org/asynchttpclient/websocket/ProxyTunnellingTest.java b/api/src/test/java/org/asynchttpclient/ws/ProxyTunnellingTest.java
similarity index 88%
rename from api/src/test/java/org/asynchttpclient/websocket/ProxyTunnellingTest.java
rename to api/src/test/java/org/asynchttpclient/ws/ProxyTunnellingTest.java
index 3e9ce1009..04eb41170 100644
--- a/api/src/test/java/org/asynchttpclient/websocket/ProxyTunnellingTest.java
+++ b/api/src/test/java/org/asynchttpclient/ws/ProxyTunnellingTest.java
@@ -10,11 +10,11 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.websocket;
+package org.asynchttpclient.ws;
 
-import static org.asynchttpclient.async.util.TestUtils.findFreePort;
-import static org.asynchttpclient.async.util.TestUtils.newJettyHttpServer;
-import static org.asynchttpclient.async.util.TestUtils.newJettyHttpsServer;
+import static org.asynchttpclient.test.TestUtils.findFreePort;
+import static org.asynchttpclient.test.TestUtils.newJettyHttpServer;
+import static org.asynchttpclient.test.TestUtils.newJettyHttpsServer;
 import static org.testng.Assert.assertEquals;
 
 import java.util.concurrent.CountDownLatch;
@@ -22,7 +22,10 @@
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.ProxyServer;
+import org.asynchttpclient.proxy.ProxyServer;
+import org.asynchttpclient.ws.WebSocket;
+import org.asynchttpclient.ws.WebSocketTextListener;
+import org.asynchttpclient.ws.WebSocketUpgradeHandler;
 import org.eclipse.jetty.proxy.ConnectHandler;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.websocket.server.WebSocketHandler;
@@ -87,10 +90,9 @@ private void runTest(boolean secure) throws Exception {
         // CONNECT happens over HTTP, not HTTPS
         ProxyServer ps = new ProxyServer(ProxyServer.Protocol.HTTP, "127.0.0.1", port1);
         AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder().setProxyServer(ps).setAcceptAnyCertificate(true).build();
-        AsyncHttpClient asyncHttpClient = getAsyncHttpClient(config);
-        try {
+        try (AsyncHttpClient asyncHttpClient = getAsyncHttpClient(config)) {
             final CountDownLatch latch = new CountDownLatch(1);
-            final AtomicReference<String> text = new AtomicReference<String>("");
+            final AtomicReference<String> text = new AtomicReference<>("");
 
             WebSocket websocket = asyncHttpClient.prepareGet(targetUrl).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketTextListener() {
 
@@ -120,8 +122,6 @@ public void onError(Throwable t) {
 
             latch.await();
             assertEquals(text.get(), "ECHO");
-        } finally {
-            asyncHttpClient.close();
         }
     }
 }
diff --git a/api/src/test/java/org/asynchttpclient/websocket/RedirectTest.java b/api/src/test/java/org/asynchttpclient/ws/RedirectTest.java
similarity index 88%
rename from api/src/test/java/org/asynchttpclient/websocket/RedirectTest.java
rename to api/src/test/java/org/asynchttpclient/ws/RedirectTest.java
index b0b825fa8..c082ea78b 100644
--- a/api/src/test/java/org/asynchttpclient/websocket/RedirectTest.java
+++ b/api/src/test/java/org/asynchttpclient/ws/RedirectTest.java
@@ -11,15 +11,18 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package org.asynchttpclient.websocket;
+package org.asynchttpclient.ws;
 
-import static org.asynchttpclient.async.util.TestUtils.addHttpConnector;
-import static org.asynchttpclient.async.util.TestUtils.findFreePort;
-import static org.asynchttpclient.async.util.TestUtils.newJettyHttpServer;
+import static org.asynchttpclient.test.TestUtils.addHttpConnector;
+import static org.asynchttpclient.test.TestUtils.findFreePort;
+import static org.asynchttpclient.test.TestUtils.newJettyHttpServer;
 import static org.testng.Assert.assertEquals;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.ws.WebSocket;
+import org.asynchttpclient.ws.WebSocketListener;
+import org.asynchttpclient.ws.WebSocketUpgradeHandler;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.eclipse.jetty.server.handler.HandlerList;
@@ -76,10 +79,9 @@ public void configure(WebSocketServletFactory factory) {
 
     @Test(timeOut = 60000)
     public void testRedirectToWSResource() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirect(true).build());
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setFollowRedirect(true).build())) {
             final CountDownLatch latch = new CountDownLatch(1);
-            final AtomicReference<String> text = new AtomicReference<String>("");
+            final AtomicReference<String> text = new AtomicReference<>("");
 
             WebSocket websocket = c.prepareGet(getRedirectURL()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
 
@@ -103,8 +105,6 @@ public void onError(Throwable t) {
             latch.await();
             assertEquals(text.get(), "OnOpen");
             websocket.close();
-        } finally {
-            c.close();
         }
     }
 
diff --git a/api/src/test/java/org/asynchttpclient/websocket/TextMessageTest.java b/api/src/test/java/org/asynchttpclient/ws/TextMessageTest.java
similarity index 87%
rename from api/src/test/java/org/asynchttpclient/websocket/TextMessageTest.java
rename to api/src/test/java/org/asynchttpclient/ws/TextMessageTest.java
index d367b4d7c..0a1b307b0 100644
--- a/api/src/test/java/org/asynchttpclient/websocket/TextMessageTest.java
+++ b/api/src/test/java/org/asynchttpclient/ws/TextMessageTest.java
@@ -10,20 +10,24 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.websocket;
+package org.asynchttpclient.ws;
 
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertTrue;
 import static org.testng.Assert.fail;
 
+import java.net.ConnectException;
+import java.net.UnknownHostException;
+import java.nio.channels.UnresolvedAddressException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.atomic.AtomicReference;
+
 import org.asynchttpclient.AsyncHttpClient;
 import org.eclipse.jetty.websocket.server.WebSocketHandler;
 import org.eclipse.jetty.websocket.servlet.WebSocketServletFactory;
 import org.testng.annotations.Test;
 
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.atomic.AtomicReference;
-
 public abstract class TextMessageTest extends AbstractBasicTest {
 
     @Override
@@ -38,10 +42,9 @@ public void configure(WebSocketServletFactory factory) {
 
     @Test(timeOut = 60000)
     public void onOpen() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
             final CountDownLatch latch = new CountDownLatch(1);
-            final AtomicReference<String> text = new AtomicReference<String>("");
+            final AtomicReference<String> text = new AtomicReference<>("");
 
             c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
 
@@ -64,15 +67,12 @@ public void onError(Throwable t) {
 
             latch.await();
             assertEquals(text.get(), "OnOpen");
-        } finally {
-            c.close();
         }
     }
 
     @Test(timeOut = 60000)
     public void onEmptyListenerTest() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
             WebSocket websocket = null;
             try {
                 websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().build()).get();
@@ -80,33 +80,26 @@ public void onEmptyListenerTest() throws Exception {
                 fail();
             }
             assertTrue(websocket != null);
-        } finally {
-            c.close();
         }
     }
 
-    @Test(timeOut = 60000)
-    public void onFailureTest() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
-            Throwable t = null;
-            try {
-                /* WebSocket websocket = */c.prepareGet("ws://abcdefg").execute(new WebSocketUpgradeHandler.Builder().build()).get();
-            } catch (Throwable t2) {
-                t = t2;
-            }
-            assertTrue(t != null);
-        } finally {
-            c.close();
+    @Test(timeOut = 60000, expectedExceptions = { ConnectException.class, UnresolvedAddressException.class, UnknownHostException.class })
+    public void onFailureTest() throws Throwable {
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
+            c.prepareGet("ws://abcdefg").execute(new WebSocketUpgradeHandler.Builder().build()).get();
+        } catch (ExecutionException e) {
+            if (e.getCause() != null)
+                throw e.getCause();
+            else
+                throw e;
         }
     }
 
     @Test(timeOut = 60000)
     public void onTimeoutCloseTest() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
             final CountDownLatch latch = new CountDownLatch(1);
-            final AtomicReference<String> text = new AtomicReference<String>("");
+            final AtomicReference<String> text = new AtomicReference<>("");
 
             c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
 
@@ -129,17 +122,14 @@ public void onError(Throwable t) {
 
             latch.await();
             assertEquals(text.get(), "OnClose");
-        } finally {
-            c.close();
         }
     }
 
     @Test(timeOut = 60000)
     public void onClose() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
             final CountDownLatch latch = new CountDownLatch(1);
-            final AtomicReference<String> text = new AtomicReference<String>("");
+            final AtomicReference<String> text = new AtomicReference<>("");
 
             WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketListener() {
 
@@ -164,17 +154,14 @@ public void onError(Throwable t) {
 
             latch.await();
             assertEquals(text.get(), "OnClose");
-        } finally {
-            c.close();
         }
     }
 
     @Test(timeOut = 60000)
     public void echoText() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
             final CountDownLatch latch = new CountDownLatch(1);
-            final AtomicReference<String> text = new AtomicReference<String>("");
+            final AtomicReference<String> text = new AtomicReference<>("");
 
             WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketTextListener() {
 
@@ -204,17 +191,14 @@ public void onError(Throwable t) {
 
             latch.await();
             assertEquals(text.get(), "ECHO");
-        } finally {
-            c.close();
         }
     }
 
     @Test(timeOut = 60000)
     public void echoDoubleListenerText() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
             final CountDownLatch latch = new CountDownLatch(2);
-            final AtomicReference<String> text = new AtomicReference<String>("");
+            final AtomicReference<String> text = new AtomicReference<>("");
 
             WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketTextListener() {
 
@@ -266,17 +250,14 @@ public void onError(Throwable t) {
 
             latch.await();
             assertEquals(text.get(), "ECHOECHO");
-        } finally {
-            c.close();
         }
     }
 
     @Test
     public void echoTwoMessagesTest() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
             final CountDownLatch latch = new CountDownLatch(2);
-            final AtomicReference<String> text = new AtomicReference<String>("");
+            final AtomicReference<String> text = new AtomicReference<>("");
 
             /* WebSocket websocket = */c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketTextListener() {
 
@@ -305,16 +286,13 @@ public void onError(Throwable t) {
 
             latch.await();
             assertEquals(text.get(), "ECHOECHO");
-        } finally {
-            c.close();
         }
     }
 
     public void echoFragments() throws Exception {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
             final CountDownLatch latch = new CountDownLatch(1);
-            final AtomicReference<String> text = new AtomicReference<String>("");
+            final AtomicReference<String> text = new AtomicReference<>("");
 
             WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketTextListener() {
 
@@ -345,18 +323,15 @@ public void onError(Throwable t) {
 
             latch.await();
             assertEquals(text.get(), "ECHOECHO");
-        } finally {
-            c.close();
         }
     }
 
     @Test(timeOut = 60000)
     public void echoTextAndThenClose() throws Throwable {
-        AsyncHttpClient c = getAsyncHttpClient(null);
-        try {
+        try (AsyncHttpClient c = getAsyncHttpClient(null)) {
             final CountDownLatch textLatch = new CountDownLatch(1);
             final CountDownLatch closeLatch = new CountDownLatch(1);
-            final AtomicReference<String> text = new AtomicReference<String>("");
+            final AtomicReference<String> text = new AtomicReference<>("");
 
             final WebSocket websocket = c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new WebSocketTextListener() {
 
@@ -389,8 +364,6 @@ public void onError(Throwable t) {
             closeLatch.await();
 
             assertEquals(text.get(), "ECHO");
-        } finally {
-            c.close();
         }
     }
 }
diff --git a/extras/guava/pom.xml b/extras/guava/pom.xml
index c759c8ebe..da1c721a8 100644
--- a/extras/guava/pom.xml
+++ b/extras/guava/pom.xml
@@ -1,6 +1,4 @@
-<project xmlns="http://maven.apache.org/POM/4.0.0"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
     <parent>
         <groupId>org.asynchttpclient</groupId>
         <artifactId>async-http-client-extras-parent</artifactId>
diff --git a/extras/guava/src/main/java/org/asynchttpclient/extras/guava/RateLimitedThrottleRequestFilter.java b/extras/guava/src/main/java/org/asynchttpclient/extras/guava/RateLimitedThrottleRequestFilter.java
index dc07928d4..125112a6a 100644
--- a/extras/guava/src/main/java/org/asynchttpclient/extras/guava/RateLimitedThrottleRequestFilter.java
+++ b/extras/guava/src/main/java/org/asynchttpclient/extras/guava/RateLimitedThrottleRequestFilter.java
@@ -56,7 +56,7 @@ public RateLimitedThrottleRequestFilter(int maxConnections, double rateLimitPerS
             throw new FilterException(String.format("Interrupted Request %s with AsyncHandler %s", ctx.getRequest(), ctx.getAsyncHandler()));
         }
 
-        return new FilterContext.FilterContextBuilder<T>(ctx).asyncHandler(new AsyncHandlerWrapper<T>(ctx.getAsyncHandler(), available))
+        return new FilterContext.FilterContextBuilder<>(ctx).asyncHandler(new AsyncHandlerWrapper<T>(ctx.getAsyncHandler(), available))
                 .build();
     }
 
diff --git a/extras/jdeferred/pom.xml b/extras/jdeferred/pom.xml
index 9945c60ad..9e913af7f 100644
--- a/extras/jdeferred/pom.xml
+++ b/extras/jdeferred/pom.xml
@@ -19,10 +19,9 @@
     <artifactId>async-http-client-extras-parent</artifactId>
     <groupId>org.asynchttpclient</groupId>
     <version>2.0.0-SNAPSHOT</version>
-    <relativePath>..</relativePath>
   </parent>
   <artifactId>async-http-client-extras-jdeferred</artifactId>
-  <name>Async Http Client JDeferred Extras</name>
+  <name>Asynchronous Http Client JDeferred Extras</name>
   <description>The Async Http Client jDeffered Extras.</description>
   <dependencies>
         <dependency>
diff --git a/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/AsyncHttpDeferredObject.java b/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/AsyncHttpDeferredObject.java
index 9f50dc71c..ce4500799 100644
--- a/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/AsyncHttpDeferredObject.java
+++ b/extras/jdeferred/src/main/java/org/asynchttpclient/extras/jdeferred/AsyncHttpDeferredObject.java
@@ -40,13 +40,13 @@ public void onThrowable(Throwable t) {
             }
 
             @Override
-            public AsyncHandler.STATE onContentWriteProgress(long amount, long current, long total) {
+            public AsyncHandler.State onContentWriteProgress(long amount, long current, long total) {
                 AsyncHttpDeferredObject.this.notify(new ContentWriteProgress(amount, current, total));
                 return super.onContentWriteProgress(amount, current, total);
             }
 
             @Override
-            public AsyncHandler.STATE onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+            public AsyncHandler.State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
                 AsyncHttpDeferredObject.this.notify(new HttpResponseBodyPartProgress(content));
                 return super.onBodyPartReceived(content);
             }
diff --git a/extras/jdeferred/src/test/java/org/asynchttpclient/extra/AsyncHttpTest.java b/extras/jdeferred/src/test/java/org/asynchttpclient/extra/AsyncHttpTest.java
index cb5847017..317f3d167 100644
--- a/extras/jdeferred/src/test/java/org/asynchttpclient/extra/AsyncHttpTest.java
+++ b/extras/jdeferred/src/test/java/org/asynchttpclient/extra/AsyncHttpTest.java
@@ -41,9 +41,7 @@ public void testPromiseAdapter() throws IOException {
         final AtomicInteger successCount = new AtomicInteger();
         final AtomicInteger progressCount = new AtomicInteger();
 
-        AsyncHttpClient client = new DefaultAsyncHttpClient();
-
-        try {
+        try (AsyncHttpClient client = new DefaultAsyncHttpClient()) {
             Promise<Response, Throwable, HttpProgress> p1 = AsyncHttpDeferredObject.promise(client.prepareGet("http://www.ning.com"));
             p1.done(new DoneCallback<Response>() {
                 @Override
@@ -67,8 +65,6 @@ public void onProgress(HttpProgress progress) {
             assertTrue(progressCount.get() > 0);
         } catch (InterruptedException e) {
             Thread.currentThread().interrupt();
-        } finally {
-            client.close();
         }
     }
 
@@ -76,9 +72,7 @@ public void testMultiplePromiseAdapter() throws IOException {
         final CountDownLatch latch = new CountDownLatch(1);
         final AtomicInteger successCount = new AtomicInteger();
 
-        AsyncHttpClient client = new DefaultAsyncHttpClient();
-
-        try {
+        try (AsyncHttpClient client = new DefaultAsyncHttpClient()) {
             Promise<Response, Throwable, HttpProgress> p1 = AsyncHttpDeferredObject.promise(client.prepareGet("http://www.ning.com"));
             Promise<Response, Throwable, HttpProgress> p2 = AsyncHttpDeferredObject.promise(client.prepareGet("http://www.google.com"));
             AsyncHttpDeferredObject deferredRequest = new AsyncHttpDeferredObject(client.prepareGet("http://jdeferred.org"));
@@ -101,8 +95,6 @@ public void onDone(MultipleResults result) {
 
         } catch (InterruptedException e) {
             Thread.currentThread().interrupt();
-        } finally {
-            client.close();
         }
     }
 }
diff --git a/extras/pom.xml b/extras/pom.xml
index ab0b2dc70..307204dcd 100644
--- a/extras/pom.xml
+++ b/extras/pom.xml
@@ -1,6 +1,4 @@
-<project xmlns="http://maven.apache.org/POM/4.0.0"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
     <parent>
         <groupId>org.asynchttpclient</groupId>
         <artifactId>async-http-client-project</artifactId>
@@ -47,6 +45,7 @@
         <module>guava</module>
         <module>jdeferred</module>
         <module>registry</module>
+        <module>rxjava</module>
     </modules>
 
     <dependencies>
@@ -63,4 +62,4 @@
             <classifier>tests</classifier>
         </dependency>
     </dependencies>
-</project>
\ No newline at end of file
+</project>
diff --git a/extras/registry/pom.xml b/extras/registry/pom.xml
index 66119acdb..bfac0345e 100644
--- a/extras/registry/pom.xml
+++ b/extras/registry/pom.xml
@@ -1,30 +1,29 @@
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-    <parent>
-        <groupId>org.asynchttpclient</groupId>
-        <artifactId>async-http-client-extras-parent</artifactId>
-        <version>2.0.0-SNAPSHOT</version>
-    </parent>
-    <modelVersion>4.0.0</modelVersion>
-    <artifactId>async-http-client-extras-registry</artifactId>
-    <name>Asynchronous Http Client Registry Extras</name>
-    <description>
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+	<parent>
+		<groupId>org.asynchttpclient</groupId>
+		<artifactId>async-http-client-extras-parent</artifactId>
+		<version>2.0.0-SNAPSHOT</version>
+	</parent>
+	<modelVersion>4.0.0</modelVersion>
+	<artifactId>async-http-client-extras-registry</artifactId>
+	<name>Asynchronous Http Client Registry Extras</name>
+	<description>
         The Async Http Client Registry Extras.
     </description>
 
-
-    <dependencies>
-        <dependency>
-            <groupId>org.asynchttpclient</groupId>
-            <artifactId>async-http-client-netty-provider</artifactId>
-            <version>${project.version}</version>
-            <scope>test</scope>
-        </dependency>
-        <dependency>
-            <groupId>org.asynchttpclient</groupId>
-            <artifactId>async-http-client-grizzly-provider</artifactId>
-            <version>${project.version}</version>
-            <scope>test</scope>
-        </dependency>
-    </dependencies>
+	<!-- broken, packages and classes are the same -->
+	<dependencies>
+		<dependency>
+			<groupId>org.asynchttpclient</groupId>
+			<artifactId>async-http-client-netty3</artifactId>
+			<version>${project.version}</version>
+			<scope>test</scope>
+		</dependency>
+		<dependency>
+			<groupId>org.asynchttpclient</groupId>
+			<artifactId>async-http-client-netty4</artifactId>
+			<version>${project.version}</version>
+			<scope>test</scope>
+		</dependency>
+	</dependencies>
 </project>
\ No newline at end of file
diff --git a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientFactory.java b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientFactory.java
index 90457a924..cb8076aec 100644
--- a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientFactory.java
+++ b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientFactory.java
@@ -35,9 +35,6 @@
  * throws an exception it thows a AsyncHttpClientImplException. By default if
  * neither the system property or the property file exists then it will return
  * the default instance of {@link DefaultAsyncHttpClient}
- * 
- * @author sasurendran
- * 
  */
 public class AsyncHttpClientFactory {
 
@@ -101,20 +98,6 @@ public static AsyncHttpClient getAsyncHttpClient(AsyncHttpProvider provider, Asy
         return new DefaultAsyncHttpClient(provider, config);
     }
 
-    public static AsyncHttpClient getAsyncHttpClient(String providerClass, AsyncHttpClientConfig config) {
-        if (attemptInstantiation()) {
-            try {
-                Constructor<AsyncHttpClient> constructor = asyncHttpClientImplClass.getConstructor(String.class,
-                        AsyncHttpClientConfig.class);
-                return constructor.newInstance(providerClass, config);
-            } catch (Exception e) {
-                throw new AsyncHttpClientImplException("Unable to find the instantiate the class specified by system property : "
-                        + AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY + "(AsyncHttpProvider) due to : " + e.getMessage(), e);
-            }
-        }
-        return new DefaultAsyncHttpClient(providerClass, config);
-    }
-
     private static boolean attemptInstantiation() {
         if (!instantiated) {
             lock.lock();
diff --git a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryImpl.java b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryImpl.java
index 0c13c2e58..b0f4c2e0b 100644
--- a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryImpl.java
+++ b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryImpl.java
@@ -22,7 +22,7 @@
 
 public class AsyncHttpClientRegistryImpl implements AsyncHttpClientRegistry {
 
-    private static ConcurrentMap<String, AsyncHttpClient> asyncHttpClientMap = new ConcurrentHashMap<String, AsyncHttpClient>();
+    private static ConcurrentMap<String, AsyncHttpClient> asyncHttpClientMap = new ConcurrentHashMap<>();
     private static volatile AsyncHttpClientRegistry _instance;
     private static Lock lock = new ReentrantLock();
 
diff --git a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncImplHelper.java b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncImplHelper.java
index 6d3803c64..a918bffdc 100644
--- a/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncImplHelper.java
+++ b/extras/registry/src/main/java/org/asynchttpclient/extras/registry/AsyncImplHelper.java
@@ -12,11 +12,8 @@
  */
 package org.asynchttpclient.extras.registry;
 
-
 import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.util.AsyncPropertiesHelper;
-
-import com.typesafe.config.ConfigException;
+import org.asynchttpclient.config.AsyncHttpClientConfigHelper;
 
 import java.security.AccessController;
 import java.security.PrivilegedActionException;
@@ -26,7 +23,7 @@
 
     public static final String ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY = "org.async.http.client.impl";
     public static final String ASYNC_HTTP_CLIENT_REGISTRY_SYSTEM_PROPERTY = "org.async.http.client.registry.impl";
-    
+
     /*
      * Returns the class specified by either a system property or a properties
      * file as the class to instantiated for the AsyncHttpClient. Returns null
@@ -34,13 +31,12 @@
      * the specified class couldn't be created.
      */
     public static Class<AsyncHttpClient> getAsyncImplClass(String propertyName) {
-        try {
-            String asyncHttpClientImplClassName = AsyncPropertiesHelper.getAsyncHttpClientConfig().getString(propertyName);
+        String asyncHttpClientImplClassName = AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getString(propertyName);
+        if (asyncHttpClientImplClassName != null) {
             Class<AsyncHttpClient> asyncHttpClientImplClass = AsyncImplHelper.getClass(asyncHttpClientImplClassName);
             return asyncHttpClientImplClass;
-        }catch(ConfigException configException) {
-            return null;
         }
+        return null;
     }
 
     private static Class<AsyncHttpClient> getClass(final String asyncImplClassName) {
@@ -53,8 +49,8 @@
                         try {
                             return (Class<AsyncHttpClient>) cl.loadClass(asyncImplClassName);
                         } catch (ClassNotFoundException e) {
-                            AsyncHttpClientFactory.logger.info("Couldn't find class : " + asyncImplClassName
-                                    + " in thread context classpath " + "checking system class path next", e);
+                            AsyncHttpClientFactory.logger.info("Couldn't find class : " + asyncImplClassName + " in thread context classpath " + "checking system class path next",
+                                    e);
                         }
 
                     cl = ClassLoader.getSystemClassLoader();
@@ -62,8 +58,7 @@
                 }
             });
         } catch (PrivilegedActionException e) {
-            throw new AsyncHttpClientImplException("Class : " + asyncImplClassName + " couldn't be found in " + " the classpath due to : "
-                    + e.getMessage(), e);
+            throw new AsyncHttpClientImplException("Class : " + asyncImplClassName + " couldn't be found in " + " the classpath due to : " + e.getMessage(), e);
         }
     }
 }
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AbstractAsyncHttpClientFactoryTest.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AbstractAsyncHttpClientFactoryTest.java
index b39946085..c05e77099 100644
--- a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AbstractAsyncHttpClientFactoryTest.java
+++ b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AbstractAsyncHttpClientFactoryTest.java
@@ -17,12 +17,12 @@
 import org.asynchttpclient.AsyncHttpProvider;
 import org.asynchttpclient.DefaultAsyncHttpClient;
 import org.asynchttpclient.Response;
-import org.asynchttpclient.async.util.EchoHandler;
-import org.asynchttpclient.async.util.TestUtils;
+import org.asynchttpclient.config.AsyncHttpClientConfigHelper;
 import org.asynchttpclient.extras.registry.AsyncHttpClientFactory;
 import org.asynchttpclient.extras.registry.AsyncHttpClientImplException;
 import org.asynchttpclient.extras.registry.AsyncImplHelper;
-import org.asynchttpclient.util.AsyncPropertiesHelper;
+import org.asynchttpclient.test.EchoHandler;
+import org.asynchttpclient.test.TestUtils;
 import org.eclipse.jetty.server.Server;
 import org.testng.Assert;
 import org.testng.annotations.AfterClass;
@@ -48,7 +48,7 @@ public void setUp() {
         PA.setValue(AsyncHttpClientFactory.class, "instantiated", false);
         PA.setValue(AsyncHttpClientFactory.class, "asyncHttpClientImplClass", null);
         System.clearProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY);
-        AsyncPropertiesHelper.reloadProperties();
+        AsyncHttpClientConfigHelper.reloadProperties();
     }
 
     @BeforeClass(alwaysRun = true)
@@ -71,43 +71,39 @@ public void tearDown() throws Exception {
     /**
      * If the property is not found via the system property or properties file
      * the default instance of AsyncHttpClient should be returned.
+     * @throws Exception 
      */
     // ================================================================================================================
     @Test(groups = "fast")
-    public void testGetAsyncHttpClient() {
-        AsyncHttpClient asyncHttpClient = AsyncHttpClientFactory.getAsyncHttpClient();
-        Assert.assertTrue(asyncHttpClient.getClass().equals(DefaultAsyncHttpClient.class));
-        assertClientWorks(asyncHttpClient);
-    }
-
-    @Test(groups = "fast")
-    public void testGetAsyncHttpClientConfig() {
-        AsyncHttpClient asyncHttpClient = AsyncHttpClientFactory.getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
-        Assert.assertTrue(asyncHttpClient.getClass().equals(DefaultAsyncHttpClient.class));
-        assertClientWorks(asyncHttpClient);
+    public void testGetAsyncHttpClient() throws Exception {
+        try (AsyncHttpClient asyncHttpClient = AsyncHttpClientFactory.getAsyncHttpClient()) {
+            Assert.assertTrue(asyncHttpClient.getClass().equals(DefaultAsyncHttpClient.class));
+            assertClientWorks(asyncHttpClient);
+        }
     }
 
     @Test(groups = "fast")
-    public void testGetAsyncHttpClientProvider() {
-        AsyncHttpClient asyncHttpClient = AsyncHttpClientFactory.getAsyncHttpClient(getAsyncHttpProvider(null));
-        Assert.assertTrue(asyncHttpClient.getClass().equals(DefaultAsyncHttpClient.class));
-        assertClientWorks(asyncHttpClient);
+    public void testGetAsyncHttpClientConfig() throws Exception {
+        try (AsyncHttpClient asyncHttpClient = AsyncHttpClientFactory.getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build())) {
+            Assert.assertTrue(asyncHttpClient.getClass().equals(DefaultAsyncHttpClient.class));
+            assertClientWorks(asyncHttpClient);
+        }
     }
 
     @Test(groups = "fast")
-    public void testGetAsyncHttpClientConfigAndProvider() {
-        AsyncHttpClient asyncHttpClient = AsyncHttpClientFactory.getAsyncHttpClient(getAsyncHttpProvider(null),
-                new AsyncHttpClientConfig.Builder().build());
-        Assert.assertTrue(asyncHttpClient.getClass().equals(DefaultAsyncHttpClient.class));
-        assertClientWorks(asyncHttpClient);
+    public void testGetAsyncHttpClientProvider() throws Exception {
+        try (AsyncHttpClient asyncHttpClient = AsyncHttpClientFactory.getAsyncHttpClient(getAsyncHttpProvider(null))) {
+            Assert.assertTrue(asyncHttpClient.getClass().equals(DefaultAsyncHttpClient.class));
+            assertClientWorks(asyncHttpClient);
+        }
     }
 
     @Test(groups = "fast")
-    public void testGetAsyncHttpClientStringConfig() {
-        AsyncHttpClient asyncHttpClient = AsyncHttpClientFactory.getAsyncHttpClient(getAsyncHttpProvider(null).getClass().getName(),
-                new AsyncHttpClientConfig.Builder().build());
-        Assert.assertTrue(asyncHttpClient.getClass().equals(DefaultAsyncHttpClient.class));
-        assertClientWorks(asyncHttpClient);
+    public void testGetAsyncHttpClientConfigAndProvider() throws Exception {
+        try (AsyncHttpClient asyncHttpClient = AsyncHttpClientFactory.getAsyncHttpClient(getAsyncHttpProvider(null), new AsyncHttpClientConfig.Builder().build())) {
+            Assert.assertTrue(asyncHttpClient.getClass().equals(DefaultAsyncHttpClient.class));
+            assertClientWorks(asyncHttpClient);
+        }
     }
 
     // ==================================================================================================================================
@@ -120,14 +116,14 @@ public void testGetAsyncHttpClientStringConfig() {
     @Test(groups = "fast")
     public void testFactoryWithSystemProperty() {
         System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, TEST_CLIENT_CLASS_NAME);
-        AsyncPropertiesHelper.reloadProperties();
+        AsyncHttpClientConfigHelper.reloadProperties();
         Assert.assertTrue(AsyncHttpClientFactory.getAsyncHttpClient().getClass().equals(TestAsyncHttpClient.class));
     }
 
     @Test(groups = "fast")
     public void testGetAsyncHttpClientConfigWithSystemProperty() {
         System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, TEST_CLIENT_CLASS_NAME);
-        AsyncPropertiesHelper.reloadProperties();
+        AsyncHttpClientConfigHelper.reloadProperties();
         AsyncHttpClient asyncHttpClient = AsyncHttpClientFactory.getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
         Assert.assertTrue(asyncHttpClient.getClass().equals(TestAsyncHttpClient.class));
     }
@@ -135,7 +131,7 @@ public void testGetAsyncHttpClientConfigWithSystemProperty() {
     @Test(groups = "fast")
     public void testGetAsyncHttpClientProviderWithSystemProperty() {
         System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, TEST_CLIENT_CLASS_NAME);
-        AsyncPropertiesHelper.reloadProperties();
+        AsyncHttpClientConfigHelper.reloadProperties();
         AsyncHttpClient asyncHttpClient = AsyncHttpClientFactory.getAsyncHttpClient(getAsyncHttpProvider(null));
         Assert.assertTrue(asyncHttpClient.getClass().equals(TestAsyncHttpClient.class));
     }
@@ -143,21 +139,12 @@ public void testGetAsyncHttpClientProviderWithSystemProperty() {
     @Test(groups = "fast")
     public void testGetAsyncHttpClientConfigAndProviderWithSystemProperty() {
         System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, TEST_CLIENT_CLASS_NAME);
-        AsyncPropertiesHelper.reloadProperties();
+        AsyncHttpClientConfigHelper.reloadProperties();
         AsyncHttpClient asyncHttpClient = AsyncHttpClientFactory.getAsyncHttpClient(getAsyncHttpProvider(null),
                 new AsyncHttpClientConfig.Builder().build());
         Assert.assertTrue(asyncHttpClient.getClass().equals(TestAsyncHttpClient.class));
     }
 
-    @Test(groups = "fast")
-    public void testGetAsyncHttpClientStringConfigWithSystemProperty() {
-        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, TEST_CLIENT_CLASS_NAME);
-        AsyncPropertiesHelper.reloadProperties();
-        AsyncHttpClient asyncHttpClient = AsyncHttpClientFactory.getAsyncHttpClient(getAsyncHttpProvider(null).getClass().getName(),
-                new AsyncHttpClientConfig.Builder().build());
-        Assert.assertTrue(asyncHttpClient.getClass().equals(TestAsyncHttpClient.class));
-    }
-
     // ===================================================================================================================================
 
     /**
@@ -168,7 +155,7 @@ public void testGetAsyncHttpClientStringConfigWithSystemProperty() {
     @Test(groups = "fast", expectedExceptions = BadAsyncHttpClientException.class)
     public void testFactoryWithBadAsyncHttpClient() {
         System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, BAD_CLIENT_CLASS_NAME);
-        AsyncPropertiesHelper.reloadProperties();
+        AsyncHttpClientConfigHelper.reloadProperties();
         AsyncHttpClientFactory.getAsyncHttpClient();
         Assert.fail("BadAsyncHttpClientException should have been thrown before this point");
     }
@@ -176,7 +163,7 @@ public void testFactoryWithBadAsyncHttpClient() {
     @Test(groups = "fast")
     public void testGetAsyncHttpClientConfigWithBadAsyncHttpClient() {
         System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, BAD_CLIENT_CLASS_NAME);
-        AsyncPropertiesHelper.reloadProperties();
+        AsyncHttpClientConfigHelper.reloadProperties();
         try {
             AsyncHttpClientFactory.getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
         } catch (AsyncHttpClientImplException e) {
@@ -188,7 +175,7 @@ public void testGetAsyncHttpClientConfigWithBadAsyncHttpClient() {
     @Test(groups = "fast")
     public void testGetAsyncHttpClientProviderWithBadAsyncHttpClient() {
         System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, BAD_CLIENT_CLASS_NAME);
-        AsyncPropertiesHelper.reloadProperties();
+        AsyncHttpClientConfigHelper.reloadProperties();
         try {
             AsyncHttpClientFactory.getAsyncHttpClient(getAsyncHttpProvider(null));
         } catch (AsyncHttpClientImplException e) {
@@ -200,7 +187,7 @@ public void testGetAsyncHttpClientProviderWithBadAsyncHttpClient() {
     @Test(groups = "fast")
     public void testGetAsyncHttpClientConfigAndProviderWithBadAsyncHttpClient() {
         System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, BAD_CLIENT_CLASS_NAME);
-        AsyncPropertiesHelper.reloadProperties();
+        AsyncHttpClientConfigHelper.reloadProperties();
         try {
             AsyncHttpClientFactory.getAsyncHttpClient(getAsyncHttpProvider(null), new AsyncHttpClientConfig.Builder().build());
         } catch (AsyncHttpClientImplException e) {
@@ -209,19 +196,6 @@ public void testGetAsyncHttpClientConfigAndProviderWithBadAsyncHttpClient() {
         //Assert.fail("AsyncHttpClientImplException should have been thrown before this point");
     }
 
-    @Test(groups = "fast")
-    public void testGetAsyncHttpClientStringConfigWithBadAsyncHttpClient() {
-        System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, BAD_CLIENT_CLASS_NAME);
-        AsyncPropertiesHelper.reloadProperties();
-        try {
-            AsyncHttpClientFactory.getAsyncHttpClient(getAsyncHttpProvider(null).getClass().getName(),
-                    new AsyncHttpClientConfig.Builder().build());
-        } catch (AsyncHttpClientImplException e) {
-            assertException(e);
-        }
-        //Assert.fail("AsyncHttpClientImplException should have been thrown before this point");
-    }
-
     // ===================================================================================================================================
 
     /*
@@ -231,7 +205,7 @@ public void testGetAsyncHttpClientStringConfigWithBadAsyncHttpClient() {
     @Test(groups = "fast", expectedExceptions = AsyncHttpClientImplException.class)
     public void testFactoryWithNonExistentAsyncHttpClient() {
         System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, NON_EXISTENT_CLIENT_CLASS_NAME);
-        AsyncPropertiesHelper.reloadProperties();
+        AsyncHttpClientConfigHelper.reloadProperties();
         AsyncHttpClientFactory.getAsyncHttpClient();
         Assert.fail("AsyncHttpClientImplException should have been thrown before this point");
     }
@@ -244,7 +218,7 @@ public void testFactoryWithNonExistentAsyncHttpClient() {
     public void testRepeatedCallsToBadAsyncHttpClient() {
         boolean exceptionCaught = false;
         System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_IMPL_SYSTEM_PROPERTY, NON_EXISTENT_CLIENT_CLASS_NAME);
-        AsyncPropertiesHelper.reloadProperties();
+        AsyncHttpClientConfigHelper.reloadProperties();
         try {
             AsyncHttpClientFactory.getAsyncHttpClient();
         } catch (AsyncHttpClientImplException e) {
@@ -258,21 +232,14 @@ public void testRepeatedCallsToBadAsyncHttpClient() {
             exceptionCaught = true;
         }
         Assert.assertTrue(exceptionCaught, "Didn't catch exception the second time");
-        AsyncHttpClientFactory.getAsyncHttpClient(getAsyncHttpProvider(null).getClass().getName(),
+        AsyncHttpClientFactory.getAsyncHttpClient(getAsyncHttpProvider(null),
                 new AsyncHttpClientConfig.Builder().build());
 
     }
 
-    private void assertClientWorks(AsyncHttpClient asyncHttpClient) {
-        Response response;
-        try {
-            response = asyncHttpClient.prepareGet("http://localhost:" + port + "/foo/test").execute().get();
-            Assert.assertEquals(200, response.getStatusCode());
-        } catch (Exception e) {
-            Assert.fail("Failed while making call with AsyncHttpClient", e);
-        } finally {
-            asyncHttpClient.close();
-        }
+    private void assertClientWorks(AsyncHttpClient asyncHttpClient) throws Exception {
+        Response response = asyncHttpClient.prepareGet("http://localhost:" + port + "/foo/test").execute().get();
+        Assert.assertEquals(200, response.getStatusCode());
     }
 
     private void assertException(AsyncHttpClientImplException e) {
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryTest.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryTest.java
index b250a9d65..47e659103 100644
--- a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryTest.java
+++ b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/AsyncHttpClientRegistryTest.java
@@ -13,11 +13,11 @@
 package org.asynchttpclient.extras.registry;
 
 import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.config.AsyncHttpClientConfigHelper;
 import org.asynchttpclient.extras.registry.AsyncHttpClientFactory;
 import org.asynchttpclient.extras.registry.AsyncHttpClientImplException;
 import org.asynchttpclient.extras.registry.AsyncHttpClientRegistryImpl;
 import org.asynchttpclient.extras.registry.AsyncImplHelper;
-import org.asynchttpclient.util.AsyncPropertiesHelper;
 import org.testng.Assert;
 import org.testng.annotations.AfterClass;
 import org.testng.annotations.BeforeClass;
@@ -33,7 +33,7 @@
     @BeforeMethod
     public void setUp() {
         System.clearProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_REGISTRY_SYSTEM_PROPERTY);
-        AsyncPropertiesHelper.reloadProperties();
+        AsyncHttpClientConfigHelper.reloadProperties();
         AsyncHttpClientRegistryImpl.getInstance().clearAllInstances();
         PA.setValue(AsyncHttpClientRegistryImpl.class, "_instance", null);
     }
@@ -97,14 +97,14 @@ public void testClearAllInstances() {
     @Test(groups = "fast")
     public void testCustomAsyncHttpClientRegistry() {
         System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_REGISTRY_SYSTEM_PROPERTY, TestAsyncHttpClientRegistry.class.getName());
-        AsyncPropertiesHelper.reloadProperties();
+        AsyncHttpClientConfigHelper.reloadProperties();
         Assert.assertTrue(AsyncHttpClientRegistryImpl.getInstance() instanceof TestAsyncHttpClientRegistry);
     }
 
     @Test(groups = "fast", expectedExceptions = AsyncHttpClientImplException.class)
     public void testNonExistentAsyncHttpClientRegistry() {
         System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_REGISTRY_SYSTEM_PROPERTY, AbstractAsyncHttpClientFactoryTest.NON_EXISTENT_CLIENT_CLASS_NAME);
-        AsyncPropertiesHelper.reloadProperties();
+        AsyncHttpClientConfigHelper.reloadProperties();
         AsyncHttpClientRegistryImpl.getInstance();
         Assert.fail("Should never have reached here");
     }
@@ -112,7 +112,7 @@ public void testNonExistentAsyncHttpClientRegistry() {
     @Test(groups = "fast", expectedExceptions = AsyncHttpClientImplException.class)
     public void testBadAsyncHttpClientRegistry() {
         System.setProperty(AsyncImplHelper.ASYNC_HTTP_CLIENT_REGISTRY_SYSTEM_PROPERTY, AbstractAsyncHttpClientFactoryTest.BAD_CLIENT_CLASS_NAME);
-        AsyncPropertiesHelper.reloadProperties();
+        AsyncHttpClientConfigHelper.reloadProperties();
         AsyncHttpClientRegistryImpl.getInstance();
         Assert.fail("Should never have reached here");
     }
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClient.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClient.java
index 84343ec0d..0bf71df19 100644
--- a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClient.java
+++ b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/BadAsyncHttpClient.java
@@ -22,8 +22,6 @@
 import org.asynchttpclient.Response;
 import org.asynchttpclient.SignatureCalculator;
 
-import java.io.IOException;
-
 public class BadAsyncHttpClient implements AsyncHttpClient {
 
     public BadAsyncHttpClient() {
@@ -127,12 +125,12 @@ public BoundRequestBuilder prepareRequest(Request request) {
     }
 
     @Override
-    public <T> ListenableFuture<T> executeRequest(Request request, AsyncHandler<T> handler) throws IOException {
+    public <T> ListenableFuture<T> executeRequest(Request request, AsyncHandler<T> handler) {
         return null;
     }
 
     @Override
-    public ListenableFuture<Response> executeRequest(Request request) throws IOException {
+    public ListenableFuture<Response> executeRequest(Request request) {
         return null;
     }
 
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/GrizzlyAsyncHttpClientFactoryTest.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/GrizzlyAsyncHttpClientFactoryTest.java
deleted file mode 100644
index cfa9c9d4b..000000000
--- a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/GrizzlyAsyncHttpClientFactoryTest.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.extras.registry;
-
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.AsyncHttpProvider;
-import org.asynchttpclient.extras.registry.AbstractAsyncHttpClientFactoryTest;
-import org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider;
-import org.testng.annotations.Test;
-
-@Test
-public class GrizzlyAsyncHttpClientFactoryTest extends AbstractAsyncHttpClientFactoryTest {
-
-    @Override
-    public AsyncHttpProvider getAsyncHttpProvider(AsyncHttpClientConfig config) {
-        if (config == null) {
-            config = new AsyncHttpClientConfig.Builder().build();
-        }
-        return new GrizzlyAsyncHttpProvider(config);
-    }
-}
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/NettyAsyncHttpClientFactoryTest.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/NettyAsyncHttpClientFactoryTest.java
index a5cc1fa02..0d57bc82c 100644
--- a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/NettyAsyncHttpClientFactoryTest.java
+++ b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/NettyAsyncHttpClientFactoryTest.java
@@ -15,7 +15,7 @@
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.AsyncHttpProvider;
 import org.asynchttpclient.extras.registry.AbstractAsyncHttpClientFactoryTest;
-import org.asynchttpclient.providers.netty.NettyAsyncHttpProvider;
+import org.asynchttpclient.netty.NettyAsyncHttpProvider;
 import org.testng.annotations.Test;
 
 @Test
diff --git a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClient.java b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClient.java
index 9d927287f..46d0095f8 100644
--- a/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClient.java
+++ b/extras/registry/src/test/java/org/asynchttpclient/extras/registry/TestAsyncHttpClient.java
@@ -22,8 +22,6 @@
 import org.asynchttpclient.Response;
 import org.asynchttpclient.SignatureCalculator;
 
-import java.io.IOException;
-
 public class TestAsyncHttpClient implements AsyncHttpClient {
 
     public TestAsyncHttpClient() {
@@ -120,12 +118,12 @@ public BoundRequestBuilder prepareRequest(Request request) {
     }
 
     @Override
-    public <T> ListenableFuture<T> executeRequest(Request request, AsyncHandler<T> handler) throws IOException {
+    public <T> ListenableFuture<T> executeRequest(Request request, AsyncHandler<T> handler) {
         return null;
     }
 
     @Override
-    public ListenableFuture<Response> executeRequest(Request request) throws IOException {
+    public ListenableFuture<Response> executeRequest(Request request) {
         return null;
     }
 
diff --git a/extras/rxjava/pom.xml b/extras/rxjava/pom.xml
new file mode 100644
index 000000000..17901fdc3
--- /dev/null
+++ b/extras/rxjava/pom.xml
@@ -0,0 +1,30 @@
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <modelVersion>4.0.0</modelVersion>
+    <parent>
+        <artifactId>async-http-client-extras-parent</artifactId>
+        <groupId>org.asynchttpclient</groupId>
+        <version>2.0.0-SNAPSHOT</version>
+    </parent>
+    <artifactId>async-http-client-extras-rxjava</artifactId>
+    <name>Asynchronous Http Client RxJava Extras</name>
+    <description>The Async Http Client RxJava Extras.</description>
+    <dependencies>
+        <dependency>
+            <groupId>io.reactivex</groupId>
+            <artifactId>rxjava</artifactId>
+            <version>1.0.14</version>
+        </dependency>
+        <dependency>
+            <groupId>org.asynchttpclient</groupId>
+            <artifactId>async-http-client-netty3</artifactId>
+            <version>${project.version}</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.asynchttpclient</groupId>
+            <artifactId>async-http-client-netty4</artifactId>
+            <version>${project.version}</version>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
+</project>
diff --git a/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/AsyncHttpObservable.java b/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/AsyncHttpObservable.java
new file mode 100644
index 000000000..dbea8f51c
--- /dev/null
+++ b/extras/rxjava/src/main/java/org/asynchttpclient/extras/rxjava/AsyncHttpObservable.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.extras.rxjava;
+
+import org.asynchttpclient.AsyncCompletionHandler;
+import org.asynchttpclient.BoundRequestBuilder;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.Response;
+import rx.Observable;
+import rx.Subscriber;
+import rx.functions.Func0;
+import rx.subjects.ReplaySubject;
+
+/**
+ * Provide RxJava support for executing requests. Request can be subscribed to and manipulated as needed.
+ * @See <a href="https://github.com/ReactiveX/RxJava" />
+ */
+public class AsyncHttpObservable {
+
+    /**
+     * Observe a request execution and emit the response to the observer.
+     *
+     * @param supplier
+     * @return The cold observable (must be subscribed to in order to execute).
+     */
+    public static Observable<Response> toObservable(final Func0<BoundRequestBuilder> supplier) {
+
+        //Get the builder from the function
+        final BoundRequestBuilder builder = supplier.call();
+
+        //create the observable from scratch
+        return Observable.create(new Observable.OnSubscribe<Response>() {
+
+            @Override
+            public void call(final Subscriber<? super Response> subscriber) {
+                try {
+                    AsyncCompletionHandler<Void> handler = new AsyncCompletionHandler<Void>() {
+
+                        @Override
+                        public Void onCompleted(Response response) throws Exception {
+                            subscriber.onNext(response);
+                            subscriber.onCompleted();
+                            return null;
+                        }
+
+                        @Override
+                        public void onThrowable(Throwable t) {
+                            subscriber.onError(t);
+                        }
+
+                    };
+                    //execute the request
+                    builder.execute(handler);
+                } catch (Throwable t) {
+                    subscriber.onError(t);
+                }
+            }
+
+        });
+
+    }
+
+    /**
+     * Observe a request execution and emit the response to the observer.
+     *
+     * @param supplier
+     * @return The hot observable (eagerly executes).
+     */
+    public static Observable<Response> observe(final Func0<BoundRequestBuilder> supplier) {
+        //use a ReplaySubject to buffer the eagerly subscribed-to Observable
+        ReplaySubject<Response> subject = ReplaySubject.create();
+        //eagerly kick off subscription
+        toObservable(supplier).subscribe(subject);
+        //return the subject that can be subscribed to later while the execution has already started
+        return subject;
+    }
+
+}
diff --git a/extras/rxjava/src/test/java/org/asynchttpclient/extras/rxjava/AsyncHttpObservableTest.java b/extras/rxjava/src/test/java/org/asynchttpclient/extras/rxjava/AsyncHttpObservableTest.java
new file mode 100644
index 000000000..aec253159
--- /dev/null
+++ b/extras/rxjava/src/test/java/org/asynchttpclient/extras/rxjava/AsyncHttpObservableTest.java
@@ -0,0 +1,174 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.extras.rxjava;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.BoundRequestBuilder;
+import org.asynchttpclient.DefaultAsyncHttpClient;
+import org.asynchttpclient.Response;
+import org.testng.annotations.Test;
+import rx.Observable;
+import rx.functions.Func0;
+import rx.observers.TestSubscriber;
+
+import java.util.List;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+
+/**
+ *
+ */
+public class AsyncHttpObservableTest {
+
+    @Test(groups = "fast")
+    public void testToObservableNoError() {
+        final TestSubscriber<Response> tester = new TestSubscriber<>();
+
+        try (AsyncHttpClient client = new DefaultAsyncHttpClient()) {
+            Observable<Response> o1 = AsyncHttpObservable.toObservable(new Func0<BoundRequestBuilder>() {
+                @Override
+                public BoundRequestBuilder call() {
+                    return client.prepareGet("http://www.ning.com");
+                }
+            });
+            o1.subscribe(tester);
+            tester.awaitTerminalEvent();
+            tester.assertTerminalEvent();
+            tester.assertCompleted();
+            tester.assertNoErrors();
+            List<Response> responses = tester.getOnNextEvents();
+            assertNotNull(responses);
+            assertEquals(responses.size(), 1);
+            assertEquals(responses.get(0).getStatusCode(), 200);
+        } catch (Exception e) {
+            Thread.currentThread().interrupt();
+        }
+    }
+
+    @Test(groups = "fast")
+    public void testToObservableError() {
+        final TestSubscriber<Response> tester = new TestSubscriber<>();
+
+        try (AsyncHttpClient client = new DefaultAsyncHttpClient()) {
+            Observable<Response> o1 = AsyncHttpObservable.toObservable(new Func0<BoundRequestBuilder>() {
+                @Override
+                public BoundRequestBuilder call() {
+                    return client.prepareGet("http://www.ning.com/ttfn");
+                }
+            });
+            o1.subscribe(tester);
+            tester.awaitTerminalEvent();
+            tester.assertTerminalEvent();
+            tester.assertCompleted();
+            tester.assertNoErrors();
+            List<Response> responses = tester.getOnNextEvents();
+            assertNotNull(responses);
+            assertEquals(responses.size(), 1);
+            assertEquals(responses.get(0).getStatusCode(), 404);
+        } catch (Exception e) {
+            Thread.currentThread().interrupt();
+        }
+    }
+
+    @Test(groups = "fast")
+    public void testObserveNoError() {
+        final TestSubscriber<Response> tester = new TestSubscriber<>();
+
+        try (AsyncHttpClient client = new DefaultAsyncHttpClient()) {
+            Observable<Response> o1 = AsyncHttpObservable.observe(new Func0<BoundRequestBuilder>() {
+                @Override
+                public BoundRequestBuilder call() {
+                    return client.prepareGet("http://www.ning.com");
+                }
+            });
+            o1.subscribe(tester);
+            tester.awaitTerminalEvent();
+            tester.assertTerminalEvent();
+            tester.assertCompleted();
+            tester.assertNoErrors();
+            List<Response> responses = tester.getOnNextEvents();
+            assertNotNull(responses);
+            assertEquals(responses.size(), 1);
+            assertEquals(responses.get(0).getStatusCode(), 200);
+        } catch (Exception e) {
+            Thread.currentThread().interrupt();
+        }
+    }
+
+    @Test(groups = "fast")
+    public void testObserveError() {
+        final TestSubscriber<Response> tester = new TestSubscriber<>();
+
+        try (AsyncHttpClient client = new DefaultAsyncHttpClient()) {
+            Observable<Response> o1 = AsyncHttpObservable.observe(new Func0<BoundRequestBuilder>() {
+                @Override
+                public BoundRequestBuilder call() {
+                    return client.prepareGet("http://www.ning.com/ttfn");
+                }
+            });
+            o1.subscribe(tester);
+            tester.awaitTerminalEvent();
+            tester.assertTerminalEvent();
+            tester.assertCompleted();
+            tester.assertNoErrors();
+            List<Response> responses = tester.getOnNextEvents();
+            assertNotNull(responses);
+            assertEquals(responses.size(), 1);
+            assertEquals(responses.get(0).getStatusCode(), 404);
+        } catch (Exception e) {
+            Thread.currentThread().interrupt();
+        }
+    }
+
+    @Test(groups = "fast")
+    public void testObserveMultiple() {
+        final TestSubscriber<Response> tester = new TestSubscriber<>();
+
+        try (AsyncHttpClient client = new DefaultAsyncHttpClient()) {
+            Observable<Response> o1 = AsyncHttpObservable.observe(new Func0<BoundRequestBuilder>() {
+                @Override
+                public BoundRequestBuilder call() {
+                    return client.prepareGet("http://www.ning.com");
+                }
+            });
+            Observable<Response> o2 = AsyncHttpObservable.observe(new Func0<BoundRequestBuilder>() {
+                @Override
+                public BoundRequestBuilder call() {
+                    return client.prepareGet("http://www.wisc.edu").setFollowRedirect(true);
+                }
+            });
+            Observable<Response> o3 = AsyncHttpObservable.observe(new Func0<BoundRequestBuilder>() {
+                @Override
+                public BoundRequestBuilder call() {
+                    return client.prepareGet("http://www.umn.edu").setFollowRedirect(true);
+                }
+            });
+            Observable<Response> all = Observable.merge(o1, o2, o3);
+            all.subscribe(tester);
+            tester.awaitTerminalEvent();
+            tester.assertTerminalEvent();
+            tester.assertCompleted();
+            tester.assertNoErrors();
+            List<Response> responses = tester.getOnNextEvents();
+            assertNotNull(responses);
+            assertEquals(responses.size(), 3);
+            for (Response response : responses) {
+                assertEquals(response.getStatusCode(), 200);
+            }
+        } catch (Exception e) {
+            Thread.currentThread().interrupt();
+        }
+    }
+
+}
diff --git a/pom.xml b/pom.xml
index a4e54d8de..b89b9408e 100644
--- a/pom.xml
+++ b/pom.xml
@@ -1,539 +1,456 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-    <parent>
-        <groupId>org.sonatype.oss</groupId>
-        <artifactId>oss-parent</artifactId>
-        <version>5</version>
-    </parent>
-    <modelVersion>4.0.0</modelVersion>
-    <groupId>org.asynchttpclient</groupId>
-    <artifactId>async-http-client-project</artifactId>
-    <name>Asynchronous Http Client Project</name>
-    <version>2.0.0-SNAPSHOT</version>
-    <packaging>pom</packaging>
-    <description>
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+	<parent>
+		<groupId>org.sonatype.oss</groupId>
+		<artifactId>oss-parent</artifactId>
+		<version>9</version>
+	</parent>
+	<modelVersion>4.0.0</modelVersion>
+	<groupId>org.asynchttpclient</groupId>
+	<artifactId>async-http-client-project</artifactId>
+	<name>Asynchronous Http Client Project</name>
+	<version>2.0.0-SNAPSHOT</version>
+	<packaging>pom</packaging>
+	<description>
         The Async Http Client (AHC) library's purpose is to allow Java
         applications to easily execute HTTP requests and
         asynchronously process the response.
     </description>
-    <url>http://github.com/AsyncHttpClient/async-http-client</url>
-    <scm>
-        <connection>scm:git:git@github.com:AsyncHttpClient/async-http-client.git
+	<url>http://github.com/AsyncHttpClient/async-http-client</url>
+	<scm>
+		<connection>scm:git:git@github.com:AsyncHttpClient/async-http-client.git
         </connection>
-        <url>https://github.com/AsyncHttpClient/async-http-client</url>
-        <developerConnection>
+		<url>https://github.com/AsyncHttpClient/async-http-client</url>
+		<developerConnection>
             scm:git:git@github.com:AsyncHttpClient/async-http-client.git
         </developerConnection>
-    </scm>
-    <issueManagement>
-        <system>jira</system>
-        <url>https://issues.sonatype.org/browse/AHC</url>
-    </issueManagement>
-    <mailingLists>
-        <mailingList>
-            <name>asynchttpclient</name>
-            <archive>http://groups.google.com/group/asynchttpclient/topics
+	</scm>
+	<issueManagement>
+		<system>jira</system>
+		<url>https://issues.sonatype.org/browse/AHC</url>
+	</issueManagement>
+	<mailingLists>
+		<mailingList>
+			<name>asynchttpclient</name>
+			<archive>http://groups.google.com/group/asynchttpclient/topics
             </archive>
-            <subscribe>
+			<subscribe>
                 http://groups.google.com/group/asynchttpclient/subscribe
             </subscribe>
-            <unsubscribe>
+			<unsubscribe>
                 http://groups.google.com/group/asynchttpclient/subscribe
             </unsubscribe>
-            <post>asynchttpclient@googlegroups.com</post>
-        </mailingList>
-    </mailingLists>
+			<post>asynchttpclient@googlegroups.com</post>
+		</mailingList>
+	</mailingLists>
 
-    <prerequisites>
-        <maven>2.0.9</maven>
-    </prerequisites>
-    <developers>
-        <developer>
-            <id>brianm</id>
-            <name>Brian McCallister</name>
-            <email>brianm@skife.org</email>
-        </developer>
-        <developer>
-            <id>jfarcand</id>
-            <name>Jeanfrancois Arcand</name>
-            <email>jfarcand@apache.org</email>
-        </developer>
-        <developer>
-            <id>thomd</id>
-            <name>Thomas Dudziak</name>
-            <email>tomdz@apache.org</email>
-        </developer>
-        <developer>
-            <id>neotyk</id>
-            <name>Hubert Iwaniuk</name>
-        </developer>
-        <developer>
-            <id>rlubke</id>
-            <name>Ryan Lubke</name>
-            <email>ryan.lubke@gmail.com</email>
-        </developer>
-        <developer>
-            <id>slandelle</id>
-            <name>Stephane Landelle</name>
-            <email>slandelle@excilys.com</email>
-        </developer>
-    </developers>
-    <contributors>
-        <contributor>
-            <name>Simone Tripodi</name>
-            <email>simonetripodi@apache.org</email>
-        </contributor>
-    </contributors>
-    <licenses>
-        <license>
-            <name>Apache License 2.0</name>
-            <url>http://www.apache.org/licenses/LICENSE-2.0.html</url>
-            <distribution>repo</distribution>
-        </license>
-    </licenses>
-    <build>
-        <resources>
-            <resource>
-                <filtering>true</filtering>
-                <directory>src/main/resources/</directory>
-            </resource>
-        </resources>
-        <extensions>
-            <!-- Enabling the use of SSH -->
-            <extension>
-                <groupId>org.apache.maven.wagon</groupId>
-                <artifactId>wagon-ssh-external</artifactId>
-                <version>1.0-beta-6</version>
-            </extension>
-            <extension>
-                <groupId>org.apache.maven.scm</groupId>
-                <artifactId>maven-scm-provider-gitexe</artifactId>
-                <version>1.6</version>
-            </extension>
-            <extension>
-                <groupId>org.apache.maven.scm</groupId>
-                <artifactId>maven-scm-manager-plexus</artifactId>
-                <version>1.6</version>
-            </extension>
-            <extension>
-                <groupId>org.kathrynhuxtable.maven.wagon</groupId>
-                <artifactId>wagon-gitsite</artifactId>
-                <version>0.3.1</version>
-            </extension>
-        </extensions>
-        <defaultGoal>install</defaultGoal>
-        <plugins>
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-compiler-plugin</artifactId>
-                <version>2.3.2</version>
-                <configuration>
-                    <source>${source.property}</source>
-                    <target>${target.property}</target>
-                    <maxmem>1024m</maxmem>
+	<prerequisites>
+		<maven>2.0.9</maven>
+	</prerequisites>
+	<developers>
+		<developer>
+			<id>brianm</id>
+			<name>Brian McCallister</name>
+			<email>brianm@skife.org</email>
+		</developer>
+		<developer>
+			<id>jfarcand</id>
+			<name>Jeanfrancois Arcand</name>
+			<email>jfarcand@apache.org</email>
+		</developer>
+		<developer>
+			<id>thomd</id>
+			<name>Thomas Dudziak</name>
+			<email>tomdz@apache.org</email>
+		</developer>
+		<developer>
+			<id>neotyk</id>
+			<name>Hubert Iwaniuk</name>
+		</developer>
+		<developer>
+			<id>rlubke</id>
+			<name>Ryan Lubke</name>
+			<email>ryan.lubke@gmail.com</email>
+		</developer>
+		<developer>
+			<id>slandelle</id>
+			<name>Stephane Landelle</name>
+			<email>slandelle@excilys.com</email>
+		</developer>
+	</developers>
+	<contributors>
+		<contributor>
+			<name>Simone Tripodi</name>
+			<email>simonetripodi@apache.org</email>
+		</contributor>
+	</contributors>
+	<licenses>
+		<license>
+			<name>Apache License 2.0</name>
+			<url>http://www.apache.org/licenses/LICENSE-2.0.html</url>
+			<distribution>repo</distribution>
+		</license>
+	</licenses>
+	<build>
+		<resources>
+			<resource>
+				<filtering>true</filtering>
+				<directory>src/main/resources/</directory>
+			</resource>
+		</resources>
+		<extensions>
+			<!-- Enabling the use of SSH -->
+			<extension>
+				<groupId>org.apache.maven.wagon</groupId>
+				<artifactId>wagon-ssh-external</artifactId>
+				<version>1.0-beta-6</version>
+			</extension>
+			<extension>
+				<groupId>org.apache.maven.scm</groupId>
+				<artifactId>maven-scm-provider-gitexe</artifactId>
+				<version>1.6</version>
+			</extension>
+			<extension>
+				<groupId>org.apache.maven.scm</groupId>
+				<artifactId>maven-scm-manager-plexus</artifactId>
+				<version>1.6</version>
+			</extension>
+		</extensions>
+		<defaultGoal>install</defaultGoal>
+		<plugins>
+			<plugin>
+				<artifactId>maven-compiler-plugin</artifactId>
+				<version>3.3</version>
+				<configuration>
+					<source>${source.property}</source>
+					<target>${target.property}</target>
+					<maxmem>1024m</maxmem>
 
-                </configuration>
-            </plugin>
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-surefire-plugin</artifactId>
-                <version>${surefire.version}</version>
-                <configuration>
-                    <redirectTestOutputToFile>
-                        ${surefire.redirectTestOutputToFile}
-                    </redirectTestOutputToFile>
-                </configuration>
-            </plugin>
-            <plugin>
-                <groupId>org.codehaus.mojo</groupId>
-                <artifactId>animal-sniffer-maven-plugin</artifactId>
-                <version>1.6</version>
-                <configuration>
-                    <signature>
-                        <groupId>org.codehaus.mojo.signature</groupId>
-                        <artifactId>java16</artifactId>
-                        <version>1.0</version>
-                    </signature>
-                </configuration>
-                <executions>
-                    <execution>
-                        <id>check-java-1.6-compat</id>
-                        <phase>process-classes</phase>
-                        <goals>
-                            <goal>check</goal>
-                        </goals>
-                    </execution>
-                </executions>
-            </plugin>
-            <plugin>
-                <groupId>org.apache.felix</groupId>
-                <artifactId>maven-bundle-plugin</artifactId>
-                <version>2.3.4</version>
-                <extensions>true</extensions>
-                <configuration>
-                    <manifestLocation>META-INF</manifestLocation>
-                    <instructions>
-                        <Bundle-Version>
-                            $(replace;$(project.version);-SNAPSHOT;.$(tstamp;yyyyMMdd-HHmm))
-                        </Bundle-Version>
-                        <Bundle-Vendor>Sonatype</Bundle-Vendor>
-                    </instructions>
-                </configuration>
-                <executions>
-                    <execution>
-                        <id>osgi-bundle</id>
-                        <phase>package</phase>
-                        <goals>
-                            <goal>bundle</goal>
-                        </goals>
-                    </execution>
-                </executions>
-            </plugin>
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-enforcer-plugin</artifactId>
-                <version>1.0-beta-1</version>
-                <executions>
-                    <execution>
-                        <id>enforce-versions</id>
-                        <goals>
-                            <goal>enforce</goal>
-                        </goals>
-                        <configuration>
-                            <rules>
-                                <requireMavenVersion>
-                                    <version>2.0.9</version>
-                                </requireMavenVersion>
-                                <requireJavaVersion>
-                                    <version>1.5</version>
-                                </requireJavaVersion>
-                            </rules>
-                        </configuration>
-                    </execution>
-                </executions>
-            </plugin>
-            <plugin>
-                <artifactId>maven-resources-plugin</artifactId>
-                <version>2.4.3</version>
-                <configuration>
-                    <encoding>UTF-8</encoding>
-                </configuration>
-            </plugin>
-            <plugin>
-                <artifactId>maven-release-plugin</artifactId>
-            </plugin>
-            <plugin>
-                <artifactId>maven-jar-plugin</artifactId>
-                <version>2.3.1</version>
-                <executions>
-                    <execution>
-                        <goals>
-                            <goal>test-jar</goal>
-                        </goals>
-                    </execution>
-                </executions>
-            </plugin>
-            <plugin>
-                <artifactId>maven-source-plugin</artifactId>
-                <version>2.1.2</version>
-                <executions>
-                    <execution>
-                        <id>attach-sources</id>
-                        <phase>verify</phase>
-                        <goals>
-                            <goal>jar-no-fork</goal>
-                        </goals>
-                    </execution>
-                </executions>
-            </plugin>
-            <plugin>
-                <artifactId>maven-site-plugin</artifactId>
-                <version>3.0</version>
-            </plugin>
-            <plugin>
-                <artifactId>maven-javadoc-plugin</artifactId>
-                <version>2.8.1</version>
-                <configuration>
-                    <aggregate>true</aggregate>
-                    <source>1.6</source>
-                    <encoding>UTF-8</encoding>
-                    <maxmemory>1g</maxmemory>
-                    <links>
-                        <link>http://java.sun.com/javase/6/docs/api/</link>
-                    </links>
-                </configuration>
-                <executions>
-                    <execution>
-                        <id>attach-javadocs</id>
-                        <phase>verify</phase>
-                        <goals>
-                            <goal>jar</goal>
-                        </goals>
-                    </execution>
-                </executions>
-            </plugin>
-        </plugins>
-    </build>
-    <reporting>
-        <plugins>
-            <plugin>
-                <artifactId>maven-javadoc-plugin</artifactId>
-                <version>2.8.1</version>
-                <configuration>
-                    <aggregate>true</aggregate>
-                    <source>1.6</source>
-                    <encoding>UTF-8</encoding>
-                    <maxmemory>1g</maxmemory>
-                    <links>
-                        <link>http://java.sun.com/javase/6/docs/api/</link>
-                    </links>
-                    <bootclasspath>${sun.boot.class.path}</bootclasspath>
-                    <doclet>com.google.doclava.Doclava</doclet>
-                    <useStandardDocletOptions>false</useStandardDocletOptions>
-                    <additionalJOption>-J-Xmx1024m</additionalJOption>
-                    <docletArtifact>
-                        <groupId>com.google.doclava</groupId>
-                        <artifactId>doclava</artifactId>
-                        <version>1.0.3</version>
-                    </docletArtifact>
-                    <additionalparam>
-                        -hdf project.name "${project.name}
-                        ${project.version}"
-                        -d
-                        ${project.reporting.outputDirectory}/apidocs
-                    </additionalparam>
-                </configuration>
-                <reportSets>
-                    <reportSet>
-                        <id>default</id>
-                        <reports>
-                            <report>javadoc</report>
-                        </reports>
-                    </reportSet>
-                </reportSets>
-            </plugin>
-            <plugin>
-                <artifactId>maven-surefire-report-plugin</artifactId>
-                <version>${surefire.version}</version>
-            </plugin>
-        </plugins>
-    </reporting>
-    <profiles>
-        <profile>
-            <id>release-sign-artifacts</id>
-            <activation>
-                <property>
-                    <name>performRelease</name>
-                    <value>true</value>
-                </property>
-            </activation>
-            <build>
-                <plugins>
-                    <plugin>
-                        <artifactId>maven-gpg-plugin</artifactId>
-                        <executions>
-                            <execution>
-                                <id>sign-artifacts</id>
-                                <phase>verify</phase>
-                                <goals>
-                                    <goal>sign</goal>
-                                </goals>
-                            </execution>
-                        </executions>
-                    </plugin>
-                </plugins>
-            </build>
-        </profile>
-        <profile>
-            <id>offline-testing</id>
-            <build>
-                <plugins>
-                    <plugin>
-                        <artifactId>maven-surefire-plugin</artifactId>
-                        <configuration>
-                            <groups>standalone</groups>
-                            <redirectTestOutputToFile>
-                                ${surefire.redirectTestOutputToFile}
-                            </redirectTestOutputToFile>
-                        </configuration>
-                    </plugin>
-                </plugins>
-            </build>
-        </profile>
-        <profile>
-            <id>online-testing</id>
-            <build>
-                <plugins>
-                    <plugin>
-                        <artifactId>maven-surefire-plugin</artifactId>
-                        <configuration>
-                            <groups>standalone, online</groups>
-                            <redirectTestOutputToFile>
-                                ${surefire.redirectTestOutputToFile}
-                            </redirectTestOutputToFile>
-                        </configuration>
-                    </plugin>
-                </plugins>
-            </build>
-        </profile>
-        <profile>
-            <id>test-output</id>
-            <properties>
-                <surefire.redirectTestOutputToFile>false</surefire.redirectTestOutputToFile>
-            </properties>
-        </profile>
-    </profiles>
-    <distributionManagement>
-        <repository>
-            <id>sonatype-nexus-staging</id>
-            <name>Sonatype Release</name>
-            <url>http://oss.sonatype.org/service/local/staging/deploy/maven2
+				</configuration>
+			</plugin>
+			<plugin>
+				<artifactId>maven-surefire-plugin</artifactId>
+				<version>2.18.1</version>
+				<configuration>
+					<redirectTestOutputToFile>
+						${surefire.redirectTestOutputToFile}
+					</redirectTestOutputToFile>
+				</configuration>
+			</plugin>
+			<plugin>
+				<groupId>org.codehaus.mojo</groupId>
+				<artifactId>animal-sniffer-maven-plugin</artifactId>
+				<version>1.14</version>
+				<configuration>
+					<signature>
+						<groupId>org.codehaus.mojo.signature</groupId>
+						<artifactId>java17</artifactId>
+						<version>1.0</version>
+					</signature>
+					<ignores>
+						<ignore>sun.misc.Unsafe</ignore>
+					</ignores>
+				</configuration>
+				<executions>
+					<execution>
+						<id>check-java-1.7-compat</id>
+						<phase>process-classes</phase>
+						<goals>
+							<goal>check</goal>
+						</goals>
+					</execution>
+				</executions>
+			</plugin>
+			<plugin>
+				<groupId>org.apache.felix</groupId>
+				<artifactId>maven-bundle-plugin</artifactId>
+				<version>2.5.4</version>
+				<extensions>true</extensions>
+				<configuration>
+					<manifestLocation>META-INF</manifestLocation>
+					<instructions>
+						<Bundle-Version>
+							$(replace;$(project.version);-SNAPSHOT;.$(tstamp;yyyyMMdd-HHmm))
+						</Bundle-Version>
+						<Bundle-Vendor>Sonatype</Bundle-Vendor>
+					</instructions>
+				</configuration>
+				<executions>
+					<execution>
+						<id>osgi-bundle</id>
+						<phase>package</phase>
+						<goals>
+							<goal>bundle</goal>
+						</goals>
+					</execution>
+				</executions>
+			</plugin>
+			<plugin>
+				<artifactId>maven-enforcer-plugin</artifactId>
+				<version>1.4</version>
+				<executions>
+					<execution>
+						<id>enforce-versions</id>
+						<goals>
+							<goal>enforce</goal>
+						</goals>
+						<configuration>
+							<rules>
+								<requireMavenVersion>
+									<version>2.0.9</version>
+								</requireMavenVersion>
+								<requireJavaVersion>
+									<version>1.5</version>
+								</requireJavaVersion>
+							</rules>
+						</configuration>
+					</execution>
+				</executions>
+			</plugin>
+			<plugin>
+				<artifactId>maven-resources-plugin</artifactId>
+				<version>2.7</version>
+				<configuration>
+					<encoding>UTF-8</encoding>
+				</configuration>
+			</plugin>
+			<plugin>
+				<artifactId>maven-release-plugin</artifactId>
+			</plugin>
+			<plugin>
+				<artifactId>maven-jar-plugin</artifactId>
+				<version>2.6</version>
+			</plugin>
+			<plugin>
+				<artifactId>maven-source-plugin</artifactId>
+				<version>2.4</version>
+				<executions>
+					<execution>
+						<id>attach-sources</id>
+						<phase>verify</phase>
+						<goals>
+							<goal>jar-no-fork</goal>
+						</goals>
+					</execution>
+				</executions>
+			</plugin>
+		</plugins>
+	</build>
+	<profiles>
+		<profile>
+			<id>release-sign-artifacts</id>
+			<activation>
+				<property>
+					<name>performRelease</name>
+					<value>true</value>
+				</property>
+			</activation>
+			<build>
+				<plugins>
+					<plugin>
+						<artifactId>maven-gpg-plugin</artifactId>
+						<executions>
+							<execution>
+								<id>sign-artifacts</id>
+								<phase>verify</phase>
+								<goals>
+									<goal>sign</goal>
+								</goals>
+							</execution>
+						</executions>
+					</plugin>
+				</plugins>
+			</build>
+		</profile>
+		<profile>
+			<id>offline-testing</id>
+			<build>
+				<plugins>
+					<plugin>
+						<artifactId>maven-surefire-plugin</artifactId>
+						<configuration>
+							<groups>standalone</groups>
+							<redirectTestOutputToFile>
+								${surefire.redirectTestOutputToFile}
+							</redirectTestOutputToFile>
+						</configuration>
+					</plugin>
+				</plugins>
+			</build>
+		</profile>
+		<profile>
+			<id>online-testing</id>
+			<build>
+				<plugins>
+					<plugin>
+						<artifactId>maven-surefire-plugin</artifactId>
+						<configuration>
+							<groups>standalone, online</groups>
+							<redirectTestOutputToFile>
+								${surefire.redirectTestOutputToFile}
+							</redirectTestOutputToFile>
+						</configuration>
+					</plugin>
+				</plugins>
+			</build>
+		</profile>
+		<profile>
+			<id>test-output</id>
+			<properties>
+				<surefire.redirectTestOutputToFile>false</surefire.redirectTestOutputToFile>
+			</properties>
+		</profile>
+	</profiles>
+	<distributionManagement>
+		<repository>
+			<id>sonatype-nexus-staging</id>
+			<name>Sonatype Release</name>
+			<url>http://oss.sonatype.org/service/local/staging/deploy/maven2
             </url>
-        </repository>
-        <snapshotRepository>
-            <id>sonatype-nexus-snapshots</id>
-            <name>sonatype-nexus-snapshots</name>
-            <url>${distMgmtSnapshotsUrl}</url>
-        </snapshotRepository>
-        <site>
-            <id>github</id>
-            <url>gitsite:git@github.com/sonatype/async-http-client.git</url>
-        </site>
-    </distributionManagement>
-    <repositories>
-        <repository>
-            <id>maven.java.net</id>
-            <url>https://maven.java.net/content/repositories/releases</url>
-        </repository>
-    </repositories>
-    <modules>
-        <module>api</module>
-        <module>providers</module>
-        <module>extras</module>
-        <module>site</module>
-    </modules>
-    <dependencies>
-        <!-- Test dependencies -->
-        <dependency>
-            <groupId>ch.qos.logback</groupId>
-            <artifactId>logback-classic</artifactId>
-            <version>${logback.version}</version>
-            <scope>test</scope>
-        </dependency>
-        <dependency>
-            <groupId>log4j</groupId>
-            <artifactId>log4j</artifactId>
-            <version>${log4j.version}</version>
-            <scope>test</scope>
-        </dependency>
-        <dependency>
-            <groupId>org.testng</groupId>
-            <artifactId>testng</artifactId>
-            <version>${testng.version}</version>
-            <scope>test</scope>
-            <exclusions>
-                <exclusion>
-                    <groupId>junit</groupId>
-                    <artifactId>junit</artifactId>
-                </exclusion>
-                <exclusion>
-                    <groupId>org.beanshell</groupId>
-                    <artifactId>bsh</artifactId>
-                </exclusion>
-                <exclusion>
-                    <groupId>org.yaml</groupId>
-                    <artifactId>snakeyaml</artifactId>
-                </exclusion>
-            </exclusions>
-        </dependency>
-        <dependency>
-            <groupId>org.eclipse.jetty</groupId>
-            <artifactId>jetty-servlet</artifactId>
-            <version>${jetty.version}</version>
-            <scope>test</scope>
-        </dependency>
-        <dependency>
-            <groupId>org.eclipse.jetty</groupId>
-            <artifactId>jetty-servlets</artifactId>
-            <version>${jetty.version}</version>
-            <scope>test</scope>
-        </dependency>
-        <dependency>
-            <groupId>org.eclipse.jetty</groupId>
-            <artifactId>jetty-security</artifactId>
-            <version>${jetty.version}</version>
-            <scope>test</scope>
-        </dependency>
-        <dependency>
-            <groupId>org.eclipse.jetty</groupId>
-            <artifactId>jetty-proxy</artifactId>
-            <version>${jetty.version}</version>
-            <scope>test</scope>
-        </dependency>
-        <dependency>
-            <groupId>org.eclipse.jetty.websocket</groupId>
-            <artifactId>websocket-server</artifactId>
-            <version>${jetty.version}</version>
-            <scope>test</scope>
-        </dependency>
-        <dependency>
-            <groupId>org.eclipse.jetty.websocket</groupId>
-            <artifactId>websocket-servlet</artifactId>
-            <version>${jetty.version}</version>
-            <scope>test</scope>
-        </dependency>
-        <dependency>
-            <groupId>org.apache.tomcat</groupId>
-            <artifactId>coyote</artifactId>
-            <version>${tomcat.version}</version>
-            <scope>test</scope>
-        </dependency>
-        <dependency>
-            <groupId>org.apache.tomcat</groupId>
-            <artifactId>catalina</artifactId>
-            <version>${tomcat.version}</version>
-            <scope>test</scope>
-            <exclusions>
-                <exclusion>
-                    <groupId>org.apache.tomcat</groupId>
-                    <artifactId>servlet-api</artifactId>
-                </exclusion>
-            </exclusions>
-        </dependency>
-        <dependency>
-            <groupId>commons-io</groupId>
-            <artifactId>commons-io</artifactId>
-            <version>${commons-io.version}</version>
-            <scope>test</scope>
-        </dependency>
-        <dependency>
-            <groupId>commons-fileupload</groupId>
-            <artifactId>commons-fileupload</artifactId>
-            <version>${commons-fileupload.version}</version>
-            <scope>test</scope>
-        </dependency>
-        <dependency>
-		  <groupId>com.e-movimento.tinytools</groupId>
-		  <artifactId>privilegedaccessor</artifactId>
-		  <version>${privilegedaccessor.version}</version>
-		  <scope>test</scope>
+		</repository>
+		<snapshotRepository>
+			<id>sonatype-nexus-snapshots</id>
+			<name>sonatype-nexus-snapshots</name>
+			<url>${distMgmtSnapshotsUrl}</url>
+		</snapshotRepository>
+	</distributionManagement>
+	<repositories>
+		<repository>
+			<id>maven.java.net</id>
+			<url>https://maven.java.net/content/repositories/releases</url>
+		</repository>
+	</repositories>
+	<modules>
+		<module>api</module>
+		<module>providers</module>
+		<module>extras</module>
+	</modules>
+	<dependencies>
+		<dependency>
+			<groupId>org.slf4j</groupId>
+			<artifactId>slf4j-api</artifactId>
+			<version>${slf4j.version}</version>
 		</dependency>
-    </dependencies>
-    <properties>
-        <distMgmtSnapshotsUrl>http://oss.sonatype.org/content/repositories/snapshots</distMgmtSnapshotsUrl>
-        <surefire.redirectTestOutputToFile>true</surefire.redirectTestOutputToFile>
-        <source.property>1.6</source.property>
-        <target.property>1.6</target.property>
-        <surefire.version>2.16</surefire.version>
-        <logback.version>1.0.13</logback.version>
-        <log4j.version>1.2.17</log4j.version>
-        <testng.version>6.8.7</testng.version>
-        <jetty.version>9.0.5.v20130815</jetty.version>
-        <tomcat.version>6.0.29</tomcat.version>
-        <commons-io.version>2.4</commons-io.version>
-        <commons-fileupload.version>1.3</commons-fileupload.version>
-        <privilegedaccessor.version>1.2.2</privilegedaccessor.version>
-    </properties>
+		<!-- Test dependencies -->
+		<dependency>
+			<groupId>ch.qos.logback</groupId>
+			<artifactId>logback-classic</artifactId>
+			<version>${logback.version}</version>
+			<scope>test</scope>
+		</dependency>
+		<dependency>
+			<groupId>log4j</groupId>
+			<artifactId>log4j</artifactId>
+			<version>${log4j.version}</version>
+			<scope>test</scope>
+		</dependency>
+		<dependency>
+			<groupId>org.testng</groupId>
+			<artifactId>testng</artifactId>
+			<version>${testng.version}</version>
+			<scope>test</scope>
+			<exclusions>
+				<exclusion>
+					<groupId>org.beanshell</groupId>
+					<artifactId>bsh</artifactId>
+				</exclusion>
+			</exclusions>
+		</dependency>
+		<dependency>
+			<groupId>org.eclipse.jetty</groupId>
+			<artifactId>jetty-servlet</artifactId>
+			<version>${jetty.version}</version>
+			<scope>test</scope>
+		</dependency>
+		<dependency>
+			<groupId>org.eclipse.jetty</groupId>
+			<artifactId>jetty-servlets</artifactId>
+			<version>${jetty.version}</version>
+			<scope>test</scope>
+		</dependency>
+		<dependency>
+			<groupId>org.eclipse.jetty</groupId>
+			<artifactId>jetty-security</artifactId>
+			<version>${jetty.version}</version>
+			<scope>test</scope>
+		</dependency>
+		<dependency>
+			<groupId>org.eclipse.jetty</groupId>
+			<artifactId>jetty-proxy</artifactId>
+			<version>${jetty.version}</version>
+			<scope>test</scope>
+		</dependency>
+		<dependency>
+			<groupId>org.eclipse.jetty.websocket</groupId>
+			<artifactId>websocket-server</artifactId>
+			<version>${jetty.version}</version>
+			<scope>test</scope>
+		</dependency>
+		<dependency>
+			<groupId>org.eclipse.jetty.websocket</groupId>
+			<artifactId>websocket-servlet</artifactId>
+			<version>${jetty.version}</version>
+			<scope>test</scope>
+		</dependency>
+		<dependency>
+			<groupId>org.apache.tomcat</groupId>
+			<artifactId>coyote</artifactId>
+			<version>${tomcat.version}</version>
+			<scope>test</scope>
+		</dependency>
+		<dependency>
+			<groupId>org.apache.tomcat</groupId>
+			<artifactId>catalina</artifactId>
+			<version>${tomcat.version}</version>
+			<scope>test</scope>
+			<exclusions>
+				<exclusion>
+					<groupId>org.apache.tomcat</groupId>
+					<artifactId>servlet-api</artifactId>
+				</exclusion>
+			</exclusions>
+		</dependency>
+		<dependency>
+			<groupId>commons-io</groupId>
+			<artifactId>commons-io</artifactId>
+			<version>${commons-io.version}</version>
+			<scope>test</scope>
+		</dependency>
+		<dependency>
+			<groupId>commons-fileupload</groupId>
+			<artifactId>commons-fileupload</artifactId>
+			<version>${commons-fileupload.version}</version>
+			<scope>test</scope>
+		</dependency>
+		<dependency>
+			<groupId>com.e-movimento.tinytools</groupId>
+			<artifactId>privilegedaccessor</artifactId>
+			<version>${privilegedaccessor.version}</version>
+			<scope>test</scope>
+		</dependency>
+		<dependency>
+			<groupId>io.reactivex</groupId>
+			<artifactId>rxjava-reactive-streams</artifactId>
+			<version>${rxjava-reactive-streams.version}</version>
+			<scope>test</scope>
+		</dependency>
+	</dependencies>
+	<properties>
+		<additionalparam>-Xdoclint:none</additionalparam>
+		<distMgmtSnapshotsUrl>http://oss.sonatype.org/content/repositories/snapshots</distMgmtSnapshotsUrl>
+		<surefire.redirectTestOutputToFile>true</surefire.redirectTestOutputToFile>
+		<source.property>1.7</source.property>
+		<target.property>1.7</target.property>
+		<slf4j.version>1.7.12</slf4j.version>
+		<logback.version>1.1.3</logback.version>
+		<log4j.version>1.2.17</log4j.version>
+		<testng.version>6.8.8</testng.version>
+		<jetty.version>9.2.11.v20150529</jetty.version>
+		<tomcat.version>6.0.29</tomcat.version>
+		<commons-io.version>2.4</commons-io.version>
+		<commons-fileupload.version>1.3</commons-fileupload.version>
+		<privilegedaccessor.version>1.2.2</privilegedaccessor.version>
+		<rxjava-reactive-streams.version>1.0.1</rxjava-reactive-streams.version>
+	</properties>
 </project>
 
diff --git a/providers/grizzly/pom.xml b/providers/grizzly/pom.xml
deleted file mode 100644
index 269aea00b..000000000
--- a/providers/grizzly/pom.xml
+++ /dev/null
@@ -1,63 +0,0 @@
-<project xmlns="http://maven.apache.org/POM/4.0.0"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-    <parent>
-        <groupId>org.asynchttpclient</groupId>
-        <artifactId>async-http-client-providers-parent</artifactId>
-        <version>2.0.0-SNAPSHOT</version>
-    </parent>
-    <modelVersion>4.0.0</modelVersion>
-    <artifactId>async-http-client-grizzly-provider</artifactId>
-    <name>Asynchronous Http Client Grizzly Provider</name>
-    <description>
-        The Async Http Client Grizzly Provider.
-    </description>
-
-    <properties>
-        <grizzly.version>2.3.16</grizzly.version>
-        <grizzly.npn.version>1.1</grizzly.npn.version>
-    </properties>
-
-    <dependencies>
-        <dependency>
-            <groupId>org.glassfish.grizzly</groupId>
-            <artifactId>grizzly-websockets</artifactId>
-            <version>${grizzly.version}</version>
-        </dependency>
-        <dependency>
-            <groupId>org.glassfish.grizzly</groupId>
-            <artifactId>grizzly-spdy</artifactId>
-            <version>${grizzly.version}</version>
-        </dependency>
-        <dependency>
-            <groupId>org.glassfish.grizzly</groupId>
-            <artifactId>connection-pool</artifactId>
-            <version>${grizzly.version}</version>
-        </dependency>
-        <dependency>
-            <groupId>org.glassfish.grizzly</groupId>
-            <artifactId>grizzly-npn-api</artifactId>
-            <version>${grizzly.npn.version}</version>
-        </dependency>
-        <dependency>
-            <groupId>org.glassfish.grizzly</groupId>
-            <artifactId>grizzly-http-server</artifactId>
-            <version>${grizzly.version}</version>
-            <scope>test</scope>
-        </dependency>
-    </dependencies>
-
-    <repositories>
-        <repository>
-            <id>jvnet-nexus-snapshots</id>
-            <url>https://maven.java.net/content/repositories/snapshots</url>
-            <releases>
-                <enabled>false</enabled>
-            </releases>
-            <snapshots>
-                <enabled>true</enabled>
-            </snapshots>
-        </repository>
-    </repositories>
-
-</project>
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/ConnectionManager.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/ConnectionManager.java
deleted file mode 100644
index 161a7accd..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/ConnectionManager.java
+++ /dev/null
@@ -1,294 +0,0 @@
-/*
- * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import static java.util.concurrent.TimeUnit.MILLISECONDS;
-
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.AsyncHttpProviderConfig;
-import org.asynchttpclient.ProxyServer;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.uri.Uri;
-import org.glassfish.grizzly.CompletionHandler;
-import org.glassfish.grizzly.Connection;
-import org.glassfish.grizzly.Grizzly;
-import org.glassfish.grizzly.GrizzlyFuture;
-import org.glassfish.grizzly.attributes.Attribute;
-import org.glassfish.grizzly.connectionpool.EndpointKey;
-import org.glassfish.grizzly.filterchain.FilterChainBuilder;
-import org.glassfish.grizzly.impl.FutureImpl;
-import org.glassfish.grizzly.utils.Futures;
-import org.glassfish.grizzly.utils.IdleTimeoutFilter;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import javax.net.ssl.HostnameVerifier;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.SocketAddress;
-import java.util.HashMap;
-import java.util.Locale;
-import java.util.Map;
-import java.util.concurrent.CancellationException;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.TimeoutException;
-import org.asynchttpclient.providers.grizzly.filters.SwitchingSSLFilter;
-
-public class ConnectionManager {
-
-    private final static Logger LOGGER = LoggerFactory.getLogger(ConnectionManager.class);
-
-    private static final Attribute<Boolean> DO_NOT_CACHE = Grizzly.DEFAULT_ATTRIBUTE_BUILDER.createAttribute(ConnectionManager.class
-            .getName());
-    private final ConnectionPool connectionPool;
-    private final GrizzlyAsyncHttpProvider provider;
-    private final boolean canDestroyPool;
-    private final Map<String, EndpointKey<SocketAddress>> endpointKeyMap = new HashMap<String, EndpointKey<SocketAddress>>();
-    private final FilterChainBuilder secureBuilder;
-    private final FilterChainBuilder nonSecureBuilder;
-    private final boolean asyncConnect;
-
-    // ------------------------------------------------------------ Constructors
-
-    ConnectionManager(final GrizzlyAsyncHttpProvider provider,//
-            final ConnectionPool connectionPool,//
-            final FilterChainBuilder secureBuilder,//
-            final FilterChainBuilder nonSecureBuilder) {
-
-        this.provider = provider;
-        final AsyncHttpClientConfig config = provider.getClientConfig();
-        if (connectionPool != null) {
-            this.connectionPool = connectionPool;
-            canDestroyPool = false;
-        } else {
-            this.connectionPool = new ConnectionPool(config.getMaxConnectionsPerHost(),//
-                    config.getMaxConnections(),//
-                    null,//
-                    config.getConnectionTimeout(),//
-                    config.getPooledConnectionIdleTimeout(),//
-                    2000);
-            canDestroyPool = true;
-        }
-        this.secureBuilder = secureBuilder;
-        this.nonSecureBuilder = nonSecureBuilder;
-        AsyncHttpProviderConfig<?, ?> providerConfig = config.getAsyncHttpProviderConfig();
-        asyncConnect = providerConfig instanceof GrizzlyAsyncHttpProviderConfig ? GrizzlyAsyncHttpProviderConfig.class.cast(providerConfig)
-                .isAsyncConnectMode() : false;
-    }
-
-    // ---------------------------------------------------------- Public Methods
-
-    public void doTrackedConnection(final Request request,//
-            final GrizzlyResponseFuture requestFuture,//
-            CompletionHandler<Connection> completionHandler) throws IOException {
-        final EndpointKey<SocketAddress> key = getEndPointKey(request, requestFuture.getProxyServer());
-        
-        final HostnameVerifier verifier = getVerifier();
-        final Uri uri = request.getUri();
-        
-        if (Utils.isSecure(uri) && verifier != null) {
-            completionHandler =
-                    SwitchingSSLFilter.wrapWithHostnameVerifierHandler(
-                            completionHandler, verifier, uri.getHost());
-        }
-        
-        if (asyncConnect) {
-            connectionPool.take(key, completionHandler);
-        } else {
-            IOException ioe = null;
-            GrizzlyFuture<Connection> future = connectionPool.take(key);
-            try {
-                // No explicit timeout when calling get() here as the Grizzly
-                // endpoint pool will time it out based on the connect timeout
-                // setting.
-                completionHandler.completed(future.get());
-            } catch (CancellationException e) {
-                completionHandler.cancelled();
-            } catch (ExecutionException ee) {
-                final Throwable cause = ee.getCause();
-                if (cause instanceof ConnectionPool.MaxCapacityException) {
-                    ioe = (IOException) cause;
-                } else {
-                    completionHandler.failed(ee.getCause());
-                }
-            } catch (Exception ie) {
-                completionHandler.failed(ie);
-            }
-            if (ioe != null) {
-                throw ioe;
-            }
-        }
-    }
-
-    public Connection obtainConnection(final Request request, final GrizzlyResponseFuture requestFuture) throws ExecutionException,
-            InterruptedException, TimeoutException, IOException {
-
-        final Connection c = obtainConnection0(request, requestFuture);
-        markConnectionAsDoNotCache(c);
-        return c;
-
-    }
-
-    // --------------------------------------------------Package Private Methods
-
-    static void markConnectionAsDoNotCache(final Connection c) {
-        DO_NOT_CACHE.set(c, Boolean.TRUE);
-    }
-
-    static boolean isConnectionCacheable(final Connection c) {
-        final Boolean canCache = DO_NOT_CACHE.get(c);
-        return ((canCache != null) ? canCache : false);
-    }
-
-    // --------------------------------------------------------- Private Methods
-
-    private HostnameVerifier getVerifier() {
-        return provider.getClientConfig().getHostnameVerifier();
-    }
-
-    private EndpointKey<SocketAddress> getEndPointKey(final Request request, final ProxyServer proxyServer) throws IOException {
-        final String stringKey = getPartitionId(request, proxyServer);
-        EndpointKey<SocketAddress> key = endpointKeyMap.get(stringKey);
-        if (key == null) {
-            synchronized (endpointKeyMap) {
-                key = endpointKeyMap.get(stringKey);
-                if (key == null) {
-                    SocketAddress address = getRemoteAddress(request, proxyServer);
-                    InetAddress localAddress = request.getLocalAddress();
-                    InetSocketAddress localSocketAddress = null;
-                    if (localAddress != null) {
-                        localSocketAddress = new InetSocketAddress(localAddress.getHostName(), 0);
-                    }
-                    
-                    ProxyAwareConnectorHandler handler = ProxyAwareConnectorHandler.builder(provider.clientTransport)
-                            .nonSecureFilterChainTemplate(nonSecureBuilder).secureFilterChainTemplate(secureBuilder)
-                            .asyncHttpClientConfig(provider.getClientConfig()).uri(request.getUri()).proxyServer(proxyServer).build();
-                    EndpointKey<SocketAddress> localKey = new EndpointKey<SocketAddress>(stringKey, address, localSocketAddress, handler);
-                    endpointKeyMap.put(stringKey, localKey);
-                    key = localKey;
-                }
-            }
-        }
-        return key;
-    }
-
-    private SocketAddress getRemoteAddress(final Request request, final ProxyServer proxyServer) {
-        final Uri requestUri = request.getUri();
-        final String host = ((proxyServer != null) ? proxyServer.getHost() : requestUri.getHost());
-        final int port = ((proxyServer != null) ? proxyServer.getPort() : requestUri.getPort());
-        return new InetSocketAddress(host, getPort(request.getUri(), port));
-    }
-
-    private static int getPort(final Uri uri, final int p) {
-        int port = p;
-        if (port == -1) {
-            final String protocol = uri.getScheme().toLowerCase(Locale.ENGLISH);
-            if ("http".equals(protocol) || "ws".equals(protocol)) {
-                port = 80;
-            } else if ("https".equals(protocol) || "wss".equals(protocol)) {
-                port = 443;
-            } else {
-                throw new IllegalArgumentException("Unknown protocol: " + protocol);
-            }
-        }
-        return port;
-    }
-
-    private Connection obtainConnection0(final Request request, final GrizzlyResponseFuture requestFuture) throws ExecutionException,
-            InterruptedException, TimeoutException, IOException {
-
-        final int cTimeout = provider.getClientConfig().getConnectionTimeout();
-        final FutureImpl<Connection> future = Futures.createSafeFuture();
-        final CompletionHandler<Connection> ch = Futures.toCompletionHandler(future,
-                createConnectionCompletionHandler(request, requestFuture, null));
-        final ProxyServer proxyServer = requestFuture.getProxyServer();
-        final SocketAddress address = getRemoteAddress(request, proxyServer);
-
-        ProxyAwareConnectorHandler handler = ProxyAwareConnectorHandler.builder(provider.clientTransport)
-                .nonSecureFilterChainTemplate(nonSecureBuilder)//
-                .secureFilterChainTemplate(secureBuilder)//
-                .asyncHttpClientConfig(provider.getClientConfig())//
-                .uri(request.getUri())//
-                .proxyServer(proxyServer)//
-                .build();
-        if (cTimeout > 0) {
-            handler.connect(address, ch);
-            return future.get(cTimeout, MILLISECONDS);
-        } else {
-            handler.connect(address, ch);
-            return future.get();
-        }
-    }
-
-    boolean returnConnection(final Connection c) {
-        final boolean result = (DO_NOT_CACHE.get(c) == null && connectionPool.release(c));
-        if (result) {
-            if (provider.getResolver() != null) {
-                provider.getResolver().setTimeoutMillis(c, IdleTimeoutFilter.FOREVER);
-            }
-        }
-        return result;
-    }
-
-    void destroy() {
-        if (canDestroyPool) {
-            connectionPool.close();
-        }
-    }
-
-    CompletionHandler<Connection> createConnectionCompletionHandler(//
-            final Request request,//
-            final GrizzlyResponseFuture future,//
-            final CompletionHandler<Connection> wrappedHandler) {
-
-        return new CompletionHandler<Connection>() {
-            public void cancelled() {
-                if (wrappedHandler != null) {
-                    wrappedHandler.cancelled();
-                } else {
-                    future.cancel(true);
-                }
-            }
-
-            public void failed(Throwable throwable) {
-                if (wrappedHandler != null) {
-                    wrappedHandler.failed(throwable);
-                } else {
-                    future.abort(throwable);
-                }
-            }
-
-            public void completed(Connection connection) {
-                future.setConnection(connection);
-                provider.touchConnection(connection, request);
-                if (wrappedHandler != null) {
-                    //connection.addCloseListener(connectionMonitor);
-                    wrappedHandler.completed(connection);
-                }
-            }
-
-            public void updated(Connection result) {
-                if (wrappedHandler != null) {
-                    wrappedHandler.updated(result);
-                }
-            }
-        };
-    }
-
-    private static String getPartitionId(final Request request, ProxyServer proxyServer) {
-        return request.getConnectionPoolPartitioning().getPartitionId(request.getUri(), proxyServer);
-    }
-}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/ConnectionPool.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/ConnectionPool.java
deleted file mode 100644
index 11197930d..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/ConnectionPool.java
+++ /dev/null
@@ -1,142 +0,0 @@
-/*
- * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.glassfish.grizzly.CompletionHandler;
-import org.glassfish.grizzly.Connection;
-import org.glassfish.grizzly.EmptyCompletionHandler;
-import org.glassfish.grizzly.GrizzlyFuture;
-import org.glassfish.grizzly.connectionpool.EndpointKey;
-import org.glassfish.grizzly.connectionpool.MultiEndpointPool;
-import org.glassfish.grizzly.connectionpool.SingleEndpointPool;
-import org.glassfish.grizzly.utils.DelayedExecutor;
-
-import java.io.IOException;
-import java.net.SocketAddress;
-
-/**
- * Extension of standard Grizzly {@link MultiEndpointPool}.
- *
- * @since 2.0
- * @author The Grizzly Team
- */
-public class ConnectionPool extends MultiEndpointPool<SocketAddress> {
-
-    private final Object lock = new Object();
-
-    // ------------------------------------------------------------ Constructors
-
-    public ConnectionPool(final int maxConnectionsPerEndpoint,//
-            final int maxConnectionsTotal,//
-            final DelayedExecutor delayedExecutor,//
-            final long connectTimeoutMillis,//
-            final long keepAliveTimeoutMillis,//
-            final long keepAliveCheckIntervalMillis) {
-        super(null,//
-                maxConnectionsPerEndpoint,//
-                maxConnectionsTotal,//
-                delayedExecutor,//
-                connectTimeoutMillis,//
-                keepAliveTimeoutMillis,//
-                keepAliveCheckIntervalMillis,//
-                -1,//
-                -1);
-    }
-
-    // ------------------------------------------ Methods from MultiEndpointPool
-
-    protected SingleEndpointPool<SocketAddress> obtainSingleEndpointPool(final EndpointKey<SocketAddress> endpointKey) throws IOException {
-        SingleEndpointPool<SocketAddress> sePool = endpointToPoolMap.get(endpointKey);
-        if (sePool == null) {
-            synchronized (poolSync) {
-                checkNotClosed();
-                if (isMaxCapacityReached()) {
-                    throw new MaxCapacityException();
-                }
-                sePool = endpointToPoolMap.get(endpointKey);
-                if (sePool == null) {
-                    sePool = createSingleEndpointPool(endpointKey);
-                    endpointToPoolMap.put(endpointKey, sePool);
-                }
-            }
-        }
-
-        return sePool;
-    }
-
-    @Override
-    public GrizzlyFuture<Connection> take(final EndpointKey<SocketAddress> endpointKey) {
-        synchronized (lock) {
-            final GrizzlyFuture<Connection> f = super.take(endpointKey);
-            f.addCompletionHandler(new EmptyCompletionHandler<Connection>() {
-                @Override
-                public void completed(Connection result) {
-                    if (Utils.isSpdyConnection(result)) {
-                        release(result);
-                    }
-                    super.completed(result);
-                }
-            });
-            return f;
-        }
-    }
-
-    @Override
-    public void take(final EndpointKey<SocketAddress> endpointKey, final CompletionHandler<Connection> completionHandler) {
-        synchronized (lock) {
-            if (completionHandler == null) {
-                throw new IllegalStateException("CompletionHandler argument cannot be null.");
-            }
-
-            super.take(endpointKey, new CompletionHandler<Connection>() {
-                @Override
-                public void cancelled() {
-                    completionHandler.cancelled();
-                }
-
-                @Override
-                public void failed(Throwable throwable) {
-                    completionHandler.failed(throwable);
-                }
-
-                @Override
-                public void completed(Connection result) {
-                    release(result);
-                    completionHandler.completed(result);
-                }
-
-                @Override
-                public void updated(Connection result) {
-                    completionHandler.updated(result);
-                }
-            });
-        }
-    }
-
-    @Override
-    public boolean release(Connection connection) {
-        synchronized (lock) {
-            return super.release(connection);
-        }
-    }
-
-    // ---------------------------------------------------------- Nested Classes
-
-    public static final class MaxCapacityException extends IOException {
-
-        public MaxCapacityException() {
-            super("Maximum pool capacity has been reached");
-        }
-    }
-}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/EventHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/EventHandler.java
deleted file mode 100644
index 7ca759938..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/EventHandler.java
+++ /dev/null
@@ -1,446 +0,0 @@
-/*
- * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import static org.asynchttpclient.AsyncHandler.STATE.ABORT;
-import static org.asynchttpclient.AsyncHandler.STATE.UPGRADE;
-import static org.asynchttpclient.providers.grizzly.statushandler.StatusHandler.InvocationStatus.CONTINUE;
-
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.AsyncHttpProviderConfig;
-import org.asynchttpclient.MaxRedirectException;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.RequestBuilder;
-import org.asynchttpclient.cookie.Cookie;
-import org.asynchttpclient.cookie.CookieDecoder;
-import org.asynchttpclient.filter.FilterContext;
-import org.asynchttpclient.filter.ResponseFilter;
-import org.asynchttpclient.listener.TransferCompletionHandler;
-import org.asynchttpclient.providers.grizzly.filters.events.ContinueEvent;
-import org.asynchttpclient.providers.grizzly.statushandler.AuthorizationHandler;
-import org.asynchttpclient.providers.grizzly.statushandler.ProxyAuthorizationHandler;
-import org.asynchttpclient.providers.grizzly.statushandler.RedirectHandler;
-import org.asynchttpclient.providers.grizzly.statushandler.StatusHandler;
-import org.asynchttpclient.providers.grizzly.websocket.GrizzlyWebSocketAdapter;
-import org.asynchttpclient.uri.Uri;
-import org.asynchttpclient.websocket.WebSocketUpgradeHandler;
-import org.glassfish.grizzly.Connection;
-import org.glassfish.grizzly.filterchain.FilterChainContext;
-import org.glassfish.grizzly.http.HttpContent;
-import org.glassfish.grizzly.http.HttpHeader;
-import org.glassfish.grizzly.http.HttpResponsePacket;
-import org.glassfish.grizzly.http.Method;
-import org.glassfish.grizzly.http.ProcessingState;
-import org.glassfish.grizzly.http.Protocol;
-import org.glassfish.grizzly.http.util.Header;
-import org.glassfish.grizzly.http.util.HttpStatus;
-import org.glassfish.grizzly.utils.IdleTimeoutFilter;
-import org.glassfish.grizzly.websockets.SimpleWebSocket;
-import org.glassfish.grizzly.websockets.WebSocketHolder;
-
-import java.util.HashMap;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.concurrent.TimeUnit;
-import org.glassfish.grizzly.Buffer;
-import org.glassfish.grizzly.http.HttpRequestPacket;
-
-public final class EventHandler {
-
-    private static final Map<Integer, StatusHandler> HANDLER_MAP = new HashMap<Integer, StatusHandler>();
-
-    static {
-        HANDLER_MAP.put(HttpStatus.UNAUTHORIZED_401.getStatusCode(), AuthorizationHandler.INSTANCE);
-        HANDLER_MAP.put(HttpStatus.PROXY_AUTHENTICATION_REQUIRED_407.getStatusCode(), ProxyAuthorizationHandler.INSTANCE);
-        HANDLER_MAP.put(HttpStatus.MOVED_PERMANENTLY_301.getStatusCode(), RedirectHandler.INSTANCE);
-        HANDLER_MAP.put(HttpStatus.FOUND_302.getStatusCode(), RedirectHandler.INSTANCE);
-        HANDLER_MAP.put(HttpStatus.SEE_OTHER_303.getStatusCode(), RedirectHandler.INSTANCE);
-        HANDLER_MAP.put(HttpStatus.TEMPORARY_REDIRECT_307.getStatusCode(), RedirectHandler.INSTANCE);
-        HANDLER_MAP.put(HttpStatus.PERMANENT_REDIRECT_308.getStatusCode(), RedirectHandler.INSTANCE);
-    }
-
-    private final AsyncHttpClientConfig config;
-    GrizzlyAsyncHttpProvider.Cleanup cleanup;
-
-    // -------------------------------------------------------- Constructors
-
-    EventHandler(final AsyncHttpClientConfig config) {
-        this.config = config;
-    }
-
-    // ----------------------------------------------------- Event Callbacks
-
-    public void exceptionOccurred(FilterChainContext ctx, Throwable error) {
-
-        HttpTxContext.get(ctx).abort(error);
-    }
-
-    public void onHttpContentParsed(HttpContent content, FilterChainContext ctx) {
-
-        final HttpTxContext context = HttpTxContext.get(ctx);
-        final AsyncHandler handler = context.getHandler();
-        if (handler != null && context.getCurrentState() != ABORT) {
-            try {
-                context.setCurrentState(handler.onBodyPartReceived(new GrizzlyResponseBodyPart(content, ctx.getConnection())));
-            } catch (Exception e) {
-                handler.onThrowable(e);
-            }
-        }
-
-    }
-
-    @SuppressWarnings("UnusedParameters")
-    public void onHttpHeadersEncoded(HttpHeader httpHeader, FilterChainContext ctx) {
-        final HttpTxContext context = HttpTxContext.get(ctx);
-        final AsyncHandler handler = context.getHandler();
-        if (handler instanceof TransferCompletionHandler) {
-            ((TransferCompletionHandler) handler).onHeaderWriteCompleted();
-        }
-    }
-
-    public void onHttpContentEncoded(HttpContent content, FilterChainContext ctx) {
-        final HttpTxContext context = HttpTxContext.get(ctx);
-        final AsyncHandler handler = context.getHandler();
-        if (handler instanceof TransferCompletionHandler) {
-            final int written = content.getContent().remaining();
-            final long total = context.getTotalBodyWritten().addAndGet(written);
-            ((TransferCompletionHandler) handler).onContentWriteProgress(written, total, content.getHttpHeader().getContentLength());
-        }
-    }
-
-    public void onInitialLineParsed(HttpHeader httpHeader, FilterChainContext ctx) {
-
-        //super.onInitialLineParsed(httpHeader, ctx);
-        if (httpHeader.isSkipRemainder()) {
-            return;
-        }
-        final HttpTxContext context = HttpTxContext.get(ctx);
-        final int status = ((HttpResponsePacket) httpHeader).getStatus();
-        if (HttpStatus.CONINTUE_100.statusMatches(status)) {
-            ctx.notifyUpstream(new ContinueEvent(context));
-            return;
-        }
-
-        StatusHandler statusHandler = context.getStatusHandler();
-        context.setStatusHandler(null);
-        if (statusHandler != null && !statusHandler.handlesStatus(status)) {
-            context.setStatusHandler(null);
-            context.setInvocationStatus(CONTINUE);
-        }
-
-        if (context.getInvocationStatus() == CONTINUE) {
-            if (HANDLER_MAP.containsKey(status)) {
-                context.setStatusHandler(HANDLER_MAP.get(status));
-            }
-            if (context.getStatusHandler() instanceof RedirectHandler) {
-                if (!isRedirectAllowed(context)) {
-                    context.setStatusHandler(null);
-                }
-            }
-        }
-        if (isRedirectAllowed(context)) {
-            if (isRedirect(status)) {
-                if (context.getStatusHandler() == null) {
-                    context.setStatusHandler(RedirectHandler.INSTANCE);
-                }
-                context.getRedirectCount().incrementAndGet();
-                if (redirectCountExceeded(context)) {
-                    httpHeader.setSkipRemainder(true);
-                    context.abort(new MaxRedirectException());
-                }
-            } else {
-                if (context.getRedirectCount().get() > 0) {
-                    context.getRedirectCount().set(0);
-                }
-            }
-        }
-        final GrizzlyResponseStatus responseStatus =
-                new GrizzlyResponseStatus((HttpResponsePacket) httpHeader,
-                        context.getRequest().getUri(), config);
-        context.setResponseStatus(responseStatus);
-        if (context.getStatusHandler() != null) {
-            return;
-        }
-
-        if (context.getCurrentState() != ABORT) {
-            try {
-                final AsyncHandler handler = context.getHandler();
-                if (handler != null) {
-                    context.setCurrentState(handler.onStatusReceived(responseStatus));
-                    if (context.isWSRequest() && context.getCurrentState() == ABORT) {
-                        httpHeader.setSkipRemainder(true);
-                        try {
-                            context.result(handler.onCompleted());
-                            context.done();
-                        } catch (Throwable e) {
-                            context.abort(e);
-                        }
-                    }
-                }
-            } catch (Exception e) {
-                httpHeader.setSkipRemainder(true);
-                context.abort(e);
-            }
-        }
-
-    }
-
-    public void onHttpHeaderError(final HttpHeader httpHeader, final FilterChainContext ctx, final Throwable t) {
-
-        httpHeader.setSkipRemainder(true);
-        HttpTxContext.get(ctx).abort(t);
-    }
-
-    public void onHttpContentError(final HttpHeader httpHeader, final FilterChainContext ctx, final Throwable t) {
-
-        httpHeader.setSkipRemainder(true);
-        HttpTxContext.get(ctx).abort(t);
-    }
-
-    @SuppressWarnings({ "unchecked" })
-    public void onHttpHeadersParsed(HttpHeader httpHeader, FilterChainContext ctx) {
-
-        //super.onHttpHeadersParsed(httpHeader, ctx);
-        GrizzlyAsyncHttpProvider.LOGGER.debug("RESPONSE: {}", httpHeader);
-        processKeepAlive(ctx.getConnection(), httpHeader);
-        final HttpTxContext context = HttpTxContext.get(ctx);
-
-        if (httpHeader.isSkipRemainder()) {
-            return;
-        }
-
-        final AsyncHandler handler = context.getHandler();
-        final GrizzlyResponseHeaders responseHeaders = new GrizzlyResponseHeaders((HttpResponsePacket) httpHeader);
-        if (context.getProvider().getClientConfig().hasResponseFilters()) {
-            final List<ResponseFilter> filters = context.getProvider().getClientConfig().getResponseFilters();
-            FilterContext fc = new FilterContext.FilterContextBuilder().asyncHandler(handler).request(context.getRequest())
-                    .responseHeaders(responseHeaders).responseStatus(context.getResponseStatus()).build();
-            try {
-                for (int i = 0, len = filters.size(); i < len; i++) {
-                    final ResponseFilter f = filters.get(i);
-                    fc = f.filter(fc);
-                }
-            } catch (Exception e) {
-                context.abort(e);
-            }
-            if (fc.replayRequest()) {
-                httpHeader.setSkipRemainder(true);
-                final Request newRequest = fc.getRequest();
-                final AsyncHandler newHandler = fc.getAsyncHandler();
-                try {
-                    final ConnectionManager m = context.getProvider().getConnectionManager();
-                    final Connection c = m.obtainConnection(newRequest, context.getFuture());
-                    final HttpTxContext newContext = context.copy();
-                    newContext.setRequest(newRequest);
-                    context.setFuture(null);
-                    context.getProvider().execute(c, newRequest, newHandler, context.getFuture(), newContext);
-                } catch (Exception e) {
-                    context.abort(e);
-                }
-                return;
-            }
-        }
-        if (context.getStatusHandler() != null && context.getInvocationStatus() == CONTINUE) {
-            final boolean result = context.getStatusHandler().handleStatus(((HttpResponsePacket) httpHeader), context, ctx);
-            if (!result) {
-                httpHeader.setSkipRemainder(true);
-                return;
-            }
-        }
-        if (context.isWSRequest()) {
-            try {
-                //in case of DIGEST auth protocol handler is null and just returning here is working
-                if (context.getProtocolHandler() == null) {
-                    return;
-                    //context.protocolHandler = Version.DRAFT17.createHandler(true);
-                    //context.currentState = AsyncHandler.STATE.UPGRADE;
-                }
-
-                context.getProtocolHandler().setConnection(ctx.getConnection());
-
-                final GrizzlyWebSocketAdapter webSocketAdapter = createWebSocketAdapter(context);
-                context.setWebSocket(webSocketAdapter);
-                SimpleWebSocket ws = webSocketAdapter.getGrizzlyWebSocket();
-                if (context.getCurrentState() == UPGRADE) {
-                    httpHeader.setChunked(false);
-                    ws.onConnect();
-                    WebSocketHolder.set(ctx.getConnection(), context.getProtocolHandler(), ws);
-                    ((WebSocketUpgradeHandler) context.getHandler()).onSuccess(context.getWebSocket());
-                    final int wsTimeout = context.getProvider().getClientConfig().getWebSocketTimeout();
-                    IdleTimeoutFilter.setCustomTimeout(ctx.getConnection(), ((wsTimeout <= 0) ? IdleTimeoutFilter.FOREVER : wsTimeout),
-                            TimeUnit.MILLISECONDS);
-                    context.result(handler.onCompleted());
-                } else {
-                    httpHeader.setSkipRemainder(true);
-                    ((WebSocketUpgradeHandler) context.getHandler()).onClose(context.getWebSocket(), 1002,
-                            "WebSocket protocol error: unexpected HTTP response status during handshake.");
-                    context.result(null);
-                }
-            } catch (Throwable e) {
-                httpHeader.setSkipRemainder(true);
-                context.abort(e);
-            }
-        } else {
-            if (context.getCurrentState() != ABORT) {
-                try {
-                    context.setCurrentState(handler.onHeadersReceived(responseHeaders));
-                } catch (Exception e) {
-                    httpHeader.setSkipRemainder(true);
-                    context.abort(e);
-                }
-            }
-        }
-
-    }
-
-    public boolean onHttpHeaderParsed(final HttpHeader httpHeader,
-            final Buffer buffer, final FilterChainContext ctx) {
-        final HttpRequestPacket request = ((HttpResponsePacket) httpHeader).getRequest();
-        if (Method.CONNECT.equals(request.getMethod())) {
-            // finish request/response processing, because Grizzly itself
-            // treats CONNECT traffic as part of request-response processing
-            // and we don't want it be treated like that
-            httpHeader.setExpectContent(false);
-        }
-
-        return false;
-    }
-
-    @SuppressWarnings("rawtypes")
-    public boolean onHttpPacketParsed(HttpHeader httpHeader, FilterChainContext ctx) {
-
-        Utils.removeRequestInFlight(ctx.getConnection());
-
-        if (cleanup != null) {
-            cleanup.cleanup(ctx);
-        }
-
-        if (httpHeader.isSkipRemainder()) {
-            if (Utils.getRequestInFlightCount(ctx.getConnection()) == 0) {
-                cleanup(ctx);
-            }
-            return false;
-        }
-
-        final HttpTxContext context = HttpTxContext.get(ctx);
-        cleanup(ctx);
-        final AsyncHandler handler = context.getHandler();
-        if (handler != null) {
-            try {
-                context.result(handler.onCompleted());
-            } catch (Throwable e) {
-                context.abort(e);
-            }
-        } else {
-            context.done();
-        }
-        return false;
-    }
-
-    // ----------------------------------------------------- Private Methods
-
-    @SuppressWarnings("rawtypes")
-    private static void processKeepAlive(final Connection c, final HttpHeader header) {
-        final ProcessingState state = header.getProcessingState();
-        final String connectionHeader = header.getHeader(Header.Connection);
-        if (connectionHeader == null) {
-            state.setKeepAlive(header.getProtocol() == Protocol.HTTP_1_1);
-        } else {
-            if ("close".equals(connectionHeader.toLowerCase(Locale.ENGLISH))) {
-                ConnectionManager.markConnectionAsDoNotCache(c);
-                state.setKeepAlive(false);
-            } else {
-                state.setKeepAlive(true);
-            }
-        }
-    }
-
-    @SuppressWarnings("rawtypes")
-    private static GrizzlyWebSocketAdapter createWebSocketAdapter(final HttpTxContext context) {
-        SimpleWebSocket ws = new SimpleWebSocket(context.getProtocolHandler());
-        AsyncHttpProviderConfig config = context.getProvider().getClientConfig().getAsyncHttpProviderConfig();
-        boolean bufferFragments = true;
-        if (config instanceof GrizzlyAsyncHttpProviderConfig) {
-            bufferFragments = (Boolean) ((GrizzlyAsyncHttpProviderConfig) config)
-                    .getProperty(GrizzlyAsyncHttpProviderConfig.Property.BUFFER_WEBSOCKET_FRAGMENTS);
-        }
-
-        return new GrizzlyWebSocketAdapter(ws, bufferFragments);
-    }
-
-    private static boolean isRedirectAllowed(final HttpTxContext ctx) {
-        return ctx.getRequest().getFollowRedirect() != null? ctx.getRequest().getFollowRedirect().booleanValue() : ctx.isRedirectsAllowed();
-    }
-
-    @SuppressWarnings("rawtypes")
-    private static HttpTxContext cleanup(final FilterChainContext ctx) {
-
-        final Connection c = ctx.getConnection();
-        final HttpTxContext context = HttpTxContext.remove(ctx);
-        if (!Utils.isSpdyConnection(c) && !Utils.isIgnored(c)) {
-            final ConnectionManager manager = context.getProvider().getConnectionManager();
-            //if (!manager.canReturnConnection(c)) {
-            //    context.abort(
-            //            new IOException("Maximum pooled connections exceeded"));
-            //} else {
-            if (!manager.returnConnection(c)) {
-                ctx.getConnection().close();
-            }
-            //}
-        }
-
-        return context;
-
-    }
-
-    private static boolean redirectCountExceeded(final HttpTxContext context) {
-        return (context.getRedirectCount().get() > context.getMaxRedirectCount());
-    }
-
-    public static boolean isRedirect(final int status) {
-
-        return HttpStatus.MOVED_PERMANENTLY_301.statusMatches(status)//
-                || HttpStatus.FOUND_302.statusMatches(status)//
-                || HttpStatus.SEE_OTHER_303.statusMatches(status)//
-                || HttpStatus.TEMPORARY_REDIRECT_307.statusMatches(status)
-                || HttpStatus.PERMANENT_REDIRECT_308.statusMatches(status);
-    }
-
-    // ----------------------------------------------------- Private Methods
-
-    public static Request newRequest(final Uri uri, final HttpResponsePacket response, final HttpTxContext ctx, boolean asGet) {
-
-        final RequestBuilder builder = new RequestBuilder(ctx.getRequest());
-        if (asGet) {
-            builder.setMethod(Method.GET.getMethodString());
-        }
-        builder.setUrl(uri.toString());
-
-        if (!ctx.getProvider().getClientConfig().isRemoveQueryParamOnRedirect())
-            builder.addQueryParams(ctx.getRequest().getQueryParams());
-        
-        if (response.getHeader(Header.Cookie) != null) {
-            for (String cookieStr : response.getHeaders().values(Header.Cookie)) {
-                Cookie c = CookieDecoder.decode(cookieStr);
-                if (c != null) {
-                    builder.addOrReplaceCookie(c);
-                }
-            }
-        }
-        return builder.build();
-    }
-
-} // END AsyncHttpClientEventFilter
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/FeedableBodyGenerator.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/FeedableBodyGenerator.java
deleted file mode 100644
index 6514edb61..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/FeedableBodyGenerator.java
+++ /dev/null
@@ -1,600 +0,0 @@
-/*
- * Copyright (c) 2012-2014 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.grizzly;
-
-import static java.lang.Boolean.TRUE;
-import static java.util.concurrent.TimeUnit.MILLISECONDS;
-import static org.glassfish.grizzly.utils.Exceptions.makeIOException;
-
-import org.asynchttpclient.Body;
-import org.asynchttpclient.BodyGenerator;
-import org.glassfish.grizzly.Buffer;
-import org.glassfish.grizzly.CompletionHandler;
-import org.glassfish.grizzly.Connection;
-import org.glassfish.grizzly.OutputSink;
-import org.glassfish.grizzly.WriteHandler;
-import org.glassfish.grizzly.WriteResult;
-import org.glassfish.grizzly.filterchain.FilterChain;
-import org.glassfish.grizzly.filterchain.FilterChainContext;
-import org.glassfish.grizzly.http.HttpContent;
-import org.glassfish.grizzly.http.HttpContext;
-import org.glassfish.grizzly.http.HttpRequestPacket;
-import org.glassfish.grizzly.impl.FutureImpl;
-import org.glassfish.grizzly.ssl.SSLBaseFilter;
-import org.glassfish.grizzly.ssl.SSLFilter;
-import org.glassfish.grizzly.threadpool.Threads;
-import org.glassfish.grizzly.utils.Futures;
-
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.util.concurrent.ExecutionException;
-
-import static org.glassfish.grizzly.ssl.SSLUtils.getSSLEngine;
-
-/**
- * {@link BodyGenerator} which may return just part of the payload at the time
- * handler is requesting it. If it happens - PartialBodyGenerator becomes responsible
- * for finishing payload transferring asynchronously.
- *
- * @author The Grizzly Team
- * @since 1.7.0
- */
-public class FeedableBodyGenerator implements BodyGenerator {
-    /**
-     * There is no limit on bytes waiting to be written.  This configuration
-     * value should be used with caution as it could lead to out-of-memory
-     * conditions.
-     */
-    @SuppressWarnings("UnusedDeclaration")
-    public static final int UNBOUND = -1;
-
-    /**
-     * Defer to whatever the connection has been configured for max pending bytes.
-     */
-    public static final int DEFAULT = -2;
-
-    private volatile HttpRequestPacket requestPacket;
-    private volatile FilterChainContext context;
-    private volatile HttpContent.Builder contentBuilder;
-
-    private final EmptyBody EMPTY_BODY = new EmptyBody();
-
-    private Feeder feeder;
-    private int origMaxPendingBytes;
-    private int configuredMaxPendingBytes = DEFAULT;
-    private boolean asyncTransferInitiated;
-
-    // ---------------------------------------------- Methods from BodyGenerator
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public Body createBody() throws IOException {
-        return EMPTY_BODY;
-    }
-
-    // ---------------------------------------------------------- Public Methods
-
-    /**
-     * Configured the maximum number of bytes that may be pending to be written
-     * to the wire.  If not explicitly configured, the connection's current
-     * configuration will be used instead.
-     * <p/>
-     * Once all data has been fed, the connection's max pending bytes configuration
-     * will be restored to its original value.
-     *
-     * @param maxPendingBytes maximum number of bytes that may be queued to
-     *                        be written to the wire.
-     * @throws IllegalStateException    if called after {@link #initializeAsynchronousTransfer(FilterChainContext, HttpRequestPacket)}
-     *                                  has been called by the {@link GrizzlyAsyncHttpProvider}.
-     * @throws IllegalArgumentException if maxPendingBytes is less than zero and is
-     *                                  not {@link #UNBOUND} or {@link #DEFAULT}.
-     */
-    @SuppressWarnings("UnusedDeclaration")
-    public synchronized void setMaxPendingBytes(final int maxPendingBytes) {
-        if (maxPendingBytes < DEFAULT) {
-            throw new IllegalArgumentException("Invalid maxPendingBytes value: " + maxPendingBytes);
-        }
-        if (asyncTransferInitiated) {
-            throw new IllegalStateException("Unable to set max pending bytes after async data transfer has been initiated.");
-        }
-        configuredMaxPendingBytes = maxPendingBytes;
-    }
-
-    /**
-     * Add a {@link Feeder} implementation that will be invoked when writing
-     * without blocking is possible.  This method must be set before dispatching
-     * the request this feeder is associated with.
-     *
-     * @param feeder the {@link Feeder} responsible for providing data.
-     * @throws IllegalStateException    if called after {@link #initializeAsynchronousTransfer(FilterChainContext, HttpRequestPacket)}
-     *                                  has been called by the {@link GrizzlyAsyncHttpProvider}.
-     * @throws IllegalArgumentException if <code>feeder</code> is <code>null</code>
-     */
-    @SuppressWarnings("UnusedDeclaration")
-    public synchronized void setFeeder(final Feeder feeder) {
-        if (asyncTransferInitiated) {
-            throw new IllegalStateException("Unable to set Feeder after async data transfer has been initiated.");
-        }
-        if (feeder == null) {
-            throw new IllegalArgumentException("Feeder argument cannot be null.");
-        }
-        this.feeder = feeder;
-    }
-
-    // ------------------------------------------------- Package Private Methods
-
-    /**
-     * Even though this method is public, it's not intended to be called by
-     * Developers directly.  Please avoid doing so.
-     */
-    public synchronized void initializeAsynchronousTransfer(final FilterChainContext context, final HttpRequestPacket requestPacket)
-            throws IOException {
-
-        if (asyncTransferInitiated) {
-            throw new IllegalStateException("Async transfer has already been initiated.");
-        }
-        if (feeder == null) {
-            throw new IllegalStateException("No feeder available to perform the transfer.");
-        }
-        assert (context != null);
-        assert (requestPacket != null);
-
-        this.requestPacket = requestPacket;
-        this.contentBuilder = HttpContent.builder(requestPacket);
-        final Connection c = context.getConnection();
-        origMaxPendingBytes = c.getMaxAsyncWriteQueueSize();
-        if (configuredMaxPendingBytes != DEFAULT) {
-            c.setMaxAsyncWriteQueueSize(configuredMaxPendingBytes);
-        }
-        this.context = context;
-        asyncTransferInitiated = true;
-        final Runnable r = new Runnable() {
-            @Override
-            public void run() {
-                try {
-                    if (requestPacket.isSecure() &&
-                            (getSSLEngine(context.getConnection()) == null)) {
-                        flushOnSSLHandshakeComplete();
-                    } else {
-                        feeder.flush();
-                    }
-                } catch (IOException ioe) {
-                    throwError(ioe);
-                }
-            }
-        };
-
-        // If the current thread is a selector thread, we need to execute
-        // the remainder of the task on the worker thread to prevent
-        // it from being blocked.
-        if (isServiceThread()) {
-            c.getTransport().getWorkerThreadPool().execute(r);
-        } else {
-            r.run();
-        }
-    }
-
-    // --------------------------------------------------------- Private Methods
-
-    private boolean isServiceThread() {
-        return Threads.isService();
-    }
-
-
-    private void flushOnSSLHandshakeComplete() throws IOException {
-        final FilterChain filterChain = context.getFilterChain();
-        final int idx = filterChain.indexOfType(SSLFilter.class);
-        assert (idx != -1);
-        final SSLFilter filter = (SSLFilter) filterChain.get(idx);
-        final Connection c = context.getConnection();
-        filter.addHandshakeListener(new SSLBaseFilter.HandshakeListener() {
-            public void onStart(Connection connection) {
-            }
-
-            public void onComplete(Connection connection) {
-                if (c.equals(connection)) {
-                    filter.removeHandshakeListener(this);
-                    try {
-                        feeder.flush();
-                    } catch (IOException ioe) {
-                        throwError(ioe);
-                    }
-                }
-            }
-        });
-        filter.handshake(context.getConnection(),  null);
-    }
-
-    private void throwError(final Throwable t) {
-        HttpTxContext httpTxContext = HttpTxContext.get(context);
-        httpTxContext.abort(t);
-    }
-
-    // ----------------------------------------------------------- Inner Classes
-
-    private final class EmptyBody implements Body {
-
-        @Override
-        public long getContentLength() {
-            return -1;
-        }
-
-        @Override
-        public long read(final ByteBuffer buffer) throws IOException {
-            return 0;
-        }
-
-        @Override
-        public void close() throws IOException {
-            context.completeAndRecycle();
-            context = null;
-            requestPacket = null;
-            contentBuilder = null;
-        }
-
-    } // END EmptyBody
-
-    // ---------------------------------------------------------- Nested Classes
-
-    /**
-     * Specifies the functionality all Feeders must implement.  Typically,
-     * developers need not worry about implementing this interface directly.
-     * It should be sufficient, for most use-cases, to simply use the {@link NonBlockingFeeder}
-     * or {@link SimpleFeeder} implementations.
-     */
-    public interface Feeder {
-
-        /**
-         * This method will be invoked when it's possible to begin feeding
-         * data downstream.  Implementations of this method must use {@link #feed(Buffer, boolean)}
-         * to perform the actual write.
-         *
-         * @throws IOException if an I/O error occurs.
-         */
-        void flush() throws IOException;
-
-        /**
-         * This method will write the specified {@link Buffer} to the connection.
-         * Be aware that this method may block depending if data is being fed
-         * faster than it can write.  How much data may be queued is dictated
-         * by {@link #setMaxPendingBytes(int)}.  Once this threshold is exceeded,
-         * the method will block until the write queue length drops below the
-         * aforementioned threshold.
-         *
-         * @param buffer the {@link Buffer} to write.
-         * @param last   flag indicating if this is the last buffer to send.
-         * @throws IOException                        if an I/O error occurs.
-         * @throws java.lang.IllegalArgumentException if <code>buffer</code>
-         *                                            is <code>null</code>.
-         * @throws java.lang.IllegalStateException    if this method is invoked
-         *                                            before asynchronous transferring has been initiated.
-         * @see #setMaxPendingBytes(int)
-         */
-        @SuppressWarnings("UnusedDeclaration")
-        void feed(final Buffer buffer, final boolean last) throws IOException;
-
-    } // END Feeder
-
-    /**
-     * Base class for {@link Feeder} implementations.  This class provides
-     * an implementation for the contract defined by the {@link #feed} method.
-     */
-    public static abstract class BaseFeeder implements Feeder {
-
-        protected final FeedableBodyGenerator feedableBodyGenerator;
-
-        // -------------------------------------------------------- Constructors
-
-        protected BaseFeeder(FeedableBodyGenerator feedableBodyGenerator) {
-            this.feedableBodyGenerator = feedableBodyGenerator;
-        }
-
-        // --------------------------------------------- Package Private Methods
-
-        /**
-         * {@inheritDoc}
-         */
-        @SuppressWarnings("UnusedDeclaration")
-        public final synchronized void feed(final Buffer buffer, final boolean last) throws IOException {
-            if (buffer == null) {
-                throw new NullPointerException("buffer");
-            }
-            if (!feedableBodyGenerator.asyncTransferInitiated) {
-                throw new IllegalStateException("Asynchronous transfer has not been initiated.");
-            }
-            blockUntilQueueFree(feedableBodyGenerator.context);
-            final HttpContent content = feedableBodyGenerator.contentBuilder.content(buffer).last(last).build();
-            final CompletionHandler<WriteResult> handler = ((last) ? new LastPacketCompletionHandler() : null);
-            feedableBodyGenerator.context.write(content, handler);
-        }
-
-        /**
-         * This method will block if the async write queue is currently larger
-         * than the configured maximum.  The amount of time that this method
-         * will block is dependent on the write timeout of the transport
-         * associated with the specified connection.
-         */
-        private static void blockUntilQueueFree(final FilterChainContext ctx) {
-            HttpContext httpContext = HttpContext.get(ctx);
-            final OutputSink outputSink = httpContext.getOutputSink();
-            if (!outputSink.canWrite()) {
-                final FutureImpl<Boolean> future = Futures.createSafeFuture();
-                outputSink.notifyCanWrite(new WriteHandler() {
-
-                    @Override
-                    public void onWritePossible() throws Exception {
-                        future.result(TRUE);
-                    }
-
-                    @Override
-                    public void onError(Throwable t) {
-                        future.failure(makeIOException(t));
-                    }
-                });
-
-                block(ctx, future);
-            }
-        }
-
-        private static void block(final FilterChainContext ctx, final FutureImpl<Boolean> future) {
-            try {
-                final long writeTimeout = ctx.getConnection().getTransport().getWriteTimeout(MILLISECONDS);
-                if (writeTimeout != -1) {
-                    future.get(writeTimeout, MILLISECONDS);
-                } else {
-                    future.get();
-                }
-            } catch (ExecutionException e) {
-                HttpTxContext httpTxContext = HttpTxContext.get(ctx);
-                httpTxContext.abort(e.getCause());
-            } catch (Exception e) {
-                HttpTxContext httpTxContext = HttpTxContext.get(ctx);
-                httpTxContext.abort(e);
-            }
-        }
-
-        // ------------------------------------------------------- Inner Classes
-
-        private final class LastPacketCompletionHandler implements CompletionHandler<WriteResult> {
-
-            private final CompletionHandler<WriteResult> delegate;
-            private final Connection c;
-            private final int origMaxPendingBytes;
-
-            // -------------------------------------------------------- Constructors
-
-            @SuppressWarnings("unchecked")
-            private LastPacketCompletionHandler() {
-                delegate = ((!feedableBodyGenerator.requestPacket.isCommitted()) ? feedableBodyGenerator.context.getTransportContext()
-                        .getCompletionHandler() : null);
-                c = feedableBodyGenerator.context.getConnection();
-                origMaxPendingBytes = feedableBodyGenerator.origMaxPendingBytes;
-            }
-
-            // -------------------------------------- Methods from CompletionHandler
-
-            @Override
-            public void cancelled() {
-                c.setMaxAsyncWriteQueueSize(origMaxPendingBytes);
-                if (delegate != null) {
-                    delegate.cancelled();
-                }
-            }
-
-            @Override
-            public void failed(Throwable throwable) {
-                c.setMaxAsyncWriteQueueSize(origMaxPendingBytes);
-                if (delegate != null) {
-                    delegate.failed(throwable);
-                }
-
-            }
-
-            @Override
-            public void completed(WriteResult result) {
-                c.setMaxAsyncWriteQueueSize(origMaxPendingBytes);
-                if (delegate != null) {
-                    delegate.completed(result);
-                }
-
-            }
-
-            @Override
-            public void updated(WriteResult result) {
-                if (delegate != null) {
-                    delegate.updated(result);
-                }
-            }
-
-        } // END LastPacketCompletionHandler
-
-    } // END Feeder
-
-    /**
-     * Implementations of this class provide the framework to read data from
-     * some source and feed data to the {@link FeedableBodyGenerator}
-     * without blocking.
-     */
-    @SuppressWarnings("UnusedDeclaration")
-    public static abstract class NonBlockingFeeder extends BaseFeeder {
-
-        // -------------------------------------------------------- Constructors
-
-        /**
-         * Constructs the <code>NonBlockingFeeder</code> with the associated
-         * {@link FeedableBodyGenerator}.
-         */
-        public NonBlockingFeeder(final FeedableBodyGenerator feedableBodyGenerator) {
-            super(feedableBodyGenerator);
-        }
-
-        // ------------------------------------------------------ Public Methods
-
-        /**
-         * Notification that it's possible to send another block of data via
-         * {@link #feed(org.glassfish.grizzly.Buffer, boolean)}.
-         * <p/>
-         * It's important to only invoke {@link #feed(Buffer, boolean)}
-         * once per invocation of {@link #canFeed()}.
-         */
-        public abstract void canFeed() throws IOException;
-
-        /**
-         * @return <code>true</code> if all data has been fed by this feeder,
-         * otherwise returns <code>false</code>.
-         */
-        public abstract boolean isDone();
-
-        /**
-         * @return <code>true</code> if data is available to be fed, otherwise
-         * returns <code>false</code>.  When this method returns <code>false</code>,
-         * the {@link FeedableBodyGenerator} will call {@link #notifyReadyToFeed(ReadyToFeedListener)}
-         * by which this {@link NonBlockingFeeder} implementation may signal data is once
-         * again available to be fed.
-         */
-        public abstract boolean isReady();
-
-        /**
-         * Callback registration to signal the {@link FeedableBodyGenerator} that
-         * data is available once again to continue feeding.  Once this listener
-         * has been invoked, the NonBlockingFeeder implementation should no longer maintain
-         * a reference to the listener.
-         */
-        public abstract void notifyReadyToFeed(final ReadyToFeedListener listener);
-
-        // ------------------------------------------------- Methods from Feeder
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public synchronized void flush() throws IOException {
-            final HttpContext httpContext = HttpContext.get(feedableBodyGenerator.context);
-            final OutputSink outputSink = httpContext.getOutputSink();
-            if (isReady()) {
-                final boolean notReady = writeUntilFullOrDone(outputSink);
-                if (!isDone()) {
-                    if (notReady) {
-                        notifyReadyToFeed(new ReadyToFeedListenerImpl());
-                    } else {
-                        // write queue is full, leverage WriteListener to let us know
-                        // when it is safe to write again.
-                        outputSink.notifyCanWrite(new WriteHandlerImpl());
-                    }
-                }
-            } else {
-                notifyReadyToFeed(new ReadyToFeedListenerImpl());
-            }
-        }
-
-        // ----------------------------------------------------- Private Methods
-
-        private boolean writeUntilFullOrDone(final OutputSink outputSink)
-                throws IOException {
-            while (outputSink.canWrite()) {
-                if (isReady()) {
-                    canFeed();
-                } else {
-                    return true;
-                }
-            }
-            
-            return false;
-        }
-
-        // ------------------------------------------------------- Inner Classes
-
-        /**
-         * Listener to signal that data is available to be fed.
-         */
-        public interface ReadyToFeedListener {
-
-            /**
-             * Data is once again ready to be fed.
-             */
-            @SuppressWarnings("UnusedDeclaration")
-            void ready();
-
-        } // END ReadyToFeedListener
-
-        private final class WriteHandlerImpl implements WriteHandler {
-
-            private final Connection c;
-            private final FilterChainContext ctx;
-
-            // -------------------------------------------------------- Constructors
-
-            private WriteHandlerImpl() {
-                this.c = feedableBodyGenerator.context.getConnection();
-                this.ctx = feedableBodyGenerator.context;
-            }
-
-            // ------------------------------------------ Methods from WriteListener
-
-            @Override
-            public void onWritePossible() throws Exception {
-                flush();
-            }
-
-            @Override
-            public void onError(Throwable t) {
-                if (!Utils.isSpdyConnection(c)) {
-                    c.setMaxAsyncWriteQueueSize(feedableBodyGenerator.origMaxPendingBytes);
-                }
-                feedableBodyGenerator.throwError(t);
-            }
-
-        } // END WriteHandlerImpl
-
-        private final class ReadyToFeedListenerImpl implements NonBlockingFeeder.ReadyToFeedListener {
-
-            // ------------------------------------ Methods from ReadyToFeedListener
-
-            @Override
-            public void ready() {
-                try {
-                    flush();
-                } catch (IOException e) {
-                    final Connection c = feedableBodyGenerator.context.getConnection();
-                    if (!Utils.isSpdyConnection(c)) {
-                        c.setMaxAsyncWriteQueueSize(feedableBodyGenerator.origMaxPendingBytes);
-                    }
-                    feedableBodyGenerator.throwError(e);
-                }
-            }
-
-        } // END ReadToFeedListenerImpl
-
-    } // END NonBlockingFeeder
-
-    /**
-     * This simple {@link Feeder} implementation allows the implementation to
-     * feed data in whatever fashion is deemed appropriate.
-     */
-    @SuppressWarnings("UnusedDeclaration")
-    public abstract static class SimpleFeeder extends BaseFeeder {
-
-        // -------------------------------------------------------- Constructors
-
-        /**
-         * Constructs the <code>SimpleFeeder</code> with the associated
-         * {@link FeedableBodyGenerator}.
-         */
-        public SimpleFeeder(FeedableBodyGenerator feedableBodyGenerator) {
-            super(feedableBodyGenerator);
-        }
-
-    } // END SimpleFeeder
-}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncHttpProvider.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncHttpProvider.java
deleted file mode 100644
index 31f485055..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncHttpProvider.java
+++ /dev/null
@@ -1,539 +0,0 @@
-/*
- * Copyright (c) 2012-2014 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import static org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProviderConfig.Property.CONNECTION_POOL;
-import static org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProviderConfig.Property.MAX_HTTP_PACKET_HEADER_SIZE;
-import static org.glassfish.grizzly.asyncqueue.AsyncQueueWriter.AUTO_SIZE;
-
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.AsyncHttpProvider;
-import org.asynchttpclient.ListenableFuture;
-import org.asynchttpclient.ProxyServer;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.ntlm.NTLMEngine;
-import org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProviderConfig.Property;
-import org.asynchttpclient.providers.grizzly.filters.AsyncHttpClientEventFilter;
-import org.asynchttpclient.providers.grizzly.filters.AsyncHttpClientFilter;
-import org.asynchttpclient.providers.grizzly.filters.AsyncSpdyClientEventFilter;
-import org.asynchttpclient.providers.grizzly.filters.ClientEncodingFilter;
-import org.asynchttpclient.providers.grizzly.filters.SwitchingSSLFilter;
-import org.asynchttpclient.util.AsyncHttpProviderUtils;
-import org.asynchttpclient.util.ProxyUtils;
-import org.asynchttpclient.util.SslUtils;
-import org.glassfish.grizzly.CompletionHandler;
-import org.glassfish.grizzly.Connection;
-import org.glassfish.grizzly.WriteResult;
-import org.glassfish.grizzly.filterchain.Filter;
-import org.glassfish.grizzly.filterchain.FilterChain;
-import org.glassfish.grizzly.filterchain.FilterChainBuilder;
-import org.glassfish.grizzly.filterchain.FilterChainContext;
-import org.glassfish.grizzly.filterchain.TransportFilter;
-import org.glassfish.grizzly.http.ContentEncoding;
-import org.glassfish.grizzly.http.GZipContentEncoding;
-import org.glassfish.grizzly.http.HttpClientFilter;
-import org.glassfish.grizzly.impl.SafeFutureImpl;
-import org.glassfish.grizzly.nio.transport.TCPNIOTransport;
-import org.glassfish.grizzly.nio.transport.TCPNIOTransportBuilder;
-import org.glassfish.grizzly.npn.ClientSideNegotiator;
-import org.glassfish.grizzly.spdy.NextProtoNegSupport;
-import org.glassfish.grizzly.spdy.SpdyFramingFilter;
-import org.glassfish.grizzly.spdy.SpdyHandlerFilter;
-import org.glassfish.grizzly.spdy.SpdyMode;
-import org.glassfish.grizzly.spdy.SpdySession;
-import org.glassfish.grizzly.ssl.SSLBaseFilter;
-import org.glassfish.grizzly.ssl.SSLConnectionContext;
-import org.glassfish.grizzly.ssl.SSLEngineConfigurator;
-import org.glassfish.grizzly.ssl.SSLFilter;
-import org.glassfish.grizzly.ssl.SSLUtils;
-import org.glassfish.grizzly.strategies.WorkerThreadIOStrategy;
-import org.glassfish.grizzly.utils.DelayedExecutor;
-import org.glassfish.grizzly.utils.IdleTimeoutFilter;
-import org.glassfish.grizzly.websockets.WebSocketClientFilter;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLEngine;
-
-import java.io.IOException;
-import java.util.LinkedHashSet;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-import org.glassfish.grizzly.nio.RoundRobinConnectionDistributor;
-import org.glassfish.grizzly.spdy.SpdyVersion;
-import org.glassfish.grizzly.threadpool.ThreadPoolConfig;
-
-/**
- * A Grizzly 2.0-based implementation of {@link AsyncHttpProvider}.
- *
- * @author The Grizzly Team
- * @since 1.7.0
- */
-@SuppressWarnings("rawtypes")
-public class GrizzlyAsyncHttpProvider implements AsyncHttpProvider {
-
-    public static final Logger LOGGER = LoggerFactory.getLogger(GrizzlyAsyncHttpProvider.class);
-    public final static NTLMEngine NTLM_ENGINE = new NTLMEngine();
-
-    private final AsyncHttpClientConfig clientConfig;
-
-    private ConnectionManager connectionManager;
-    private DelayedExecutor.Resolver<Connection> resolver;
-    private DelayedExecutor timeoutExecutor;
-
-    final TCPNIOTransport clientTransport;
-
-    // ------------------------------------------------------------ Constructors
-
-    public GrizzlyAsyncHttpProvider(final AsyncHttpClientConfig clientConfig) {
-
-        this.clientConfig = clientConfig;
-        final TCPNIOTransportBuilder builder = TCPNIOTransportBuilder.newInstance();
-        clientTransport = builder.build();
-        initializeTransport(clientConfig);
-        try {
-            clientTransport.start();
-        } catch (IOException ioe) {
-            throw new RuntimeException(ioe);
-        }
-    }
-
-    // ------------------------------------------ Methods from AsyncHttpProvider
-
-    /**
-     * {@inheritDoc}
-     */
-    public <T> ListenableFuture<T> execute(final Request request, final AsyncHandler<T> handler) throws IOException {
-
-        if (clientTransport.isStopped()) {
-            throw new IOException("AsyncHttpClient has been closed.");
-        }
-        final ProxyServer proxy = ProxyUtils.getProxyServer(clientConfig, request);
-        final GrizzlyResponseFuture<T> future = new GrizzlyResponseFuture<T>(this, request, handler, proxy);
-        future.setDelegate(SafeFutureImpl.<T> create());
-        final CompletionHandler<Connection> connectHandler = new CompletionHandler<Connection>() {
-            @Override
-            public void cancelled() {
-                future.cancel(true);
-            }
-
-            @Override
-            public void failed(final Throwable throwable) {
-                future.abort(throwable);
-            }
-
-            @Override
-            public void completed(final Connection c) {
-                try {
-                    touchConnection(c, request);
-                    execute(c, request, handler, future, null);
-                } catch (Exception e) {
-                    failed(e);
-                }
-            }
-
-            @Override
-            public void updated(final Connection c) {
-                // no-op
-            }
-        };
-
-        connectionManager.doTrackedConnection(request, future, connectHandler);
-
-        return future;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public void close() {
-
-        try {
-            connectionManager.destroy();
-            clientTransport.shutdownNow();
-            final ExecutorService service = clientConfig.executorService();
-            // service may be null due to a custom configuration that
-            // leverages Grizzly's SameThreadIOStrategy.
-            if (service != null) {
-                service.shutdown();
-            }
-            if (timeoutExecutor != null) {
-                timeoutExecutor.stop();
-                final ExecutorService threadPool = timeoutExecutor.getThreadPool();
-                if (threadPool != null) {
-                    threadPool.shutdownNow();
-                }
-            }
-        } catch (IOException ignored) {
-        }
-
-    }
-
-    // ---------------------------------------------------------- Public Methods
-
-    public AsyncHttpClientConfig getClientConfig() {
-        return clientConfig;
-    }
-
-    public ConnectionManager getConnectionManager() {
-        return connectionManager;
-    }
-
-    public DelayedExecutor.Resolver<Connection> getResolver() {
-        return resolver;
-    }
-
-    // ------------------------------------------------------- Protected Methods
-
-    @SuppressWarnings({ "unchecked" })
-    public <T> ListenableFuture<T> execute(final Connection c, final Request request, final AsyncHandler<T> handler,
-            final GrizzlyResponseFuture<T> future, final HttpTxContext httpTxContext) {
-        Utils.addRequestInFlight(c);
-        final RequestInfoHolder requestInfoHolder = new RequestInfoHolder(this, request, handler, future, httpTxContext);
-        c.write(requestInfoHolder, createWriteCompletionHandler(future));
-
-        return future;
-    }
-
-    void initializeTransport(final AsyncHttpClientConfig clientConfig) {
-
-        final FilterChainBuilder secure = FilterChainBuilder.stateless();
-        secure.add(new TransportFilter());
-
-        final int timeout = clientConfig.getRequestTimeout();
-        if (timeout > 0) {
-            int delay = 500;
-            //noinspection ConstantConditions
-            if (timeout < delay) {
-                delay = timeout - 10;
-                if (delay <= 0) {
-                    delay = timeout;
-                }
-            }
-            timeoutExecutor = IdleTimeoutFilter.createDefaultIdleDelayedExecutor(delay, TimeUnit.MILLISECONDS);
-            timeoutExecutor.start();
-            final IdleTimeoutFilter.TimeoutResolver timeoutResolver = new IdleTimeoutFilter.TimeoutResolver() {
-                @Override
-                public long getTimeout(FilterChainContext ctx) {
-                    final HttpTxContext context = HttpTxContext.get(ctx);
-                    if (context != null) {
-                        if (context.isWSRequest()) {
-                            return clientConfig.getWebSocketTimeout();
-                        }
-                        int requestTimeout = AsyncHttpProviderUtils.requestTimeout(clientConfig, context.getRequest());
-                        if (requestTimeout > 0) {
-                            return requestTimeout;
-                        }
-                    }
-                    return IdleTimeoutFilter.FOREVER;
-                }
-            };
-            final IdleTimeoutFilter timeoutFilter = new IdleTimeoutFilter(timeoutExecutor, timeoutResolver,
-                    new IdleTimeoutFilter.TimeoutHandler() {
-                        public void onTimeout(Connection connection) {
-                            timeout(connection);
-                        }
-                    });
-            secure.add(timeoutFilter);
-            resolver = timeoutFilter.getResolver();
-        }
-
-        SSLContext context = clientConfig.getSSLContext();
-        if (context == null) {
-            try {
-                context = SslUtils.getInstance().getSSLContext(clientConfig.isAcceptAnyCertificate());
-            } catch (Exception e) {
-                throw new IllegalStateException(e);
-            }
-        }
-        final SSLEngineConfigurator configurator = new SSLEngineConfigurator(context, true, false, false);
-        final SwitchingSSLFilter sslFilter = new SwitchingSSLFilter(configurator);
-        secure.add(sslFilter);
-        
-        GrizzlyAsyncHttpProviderConfig providerConfig = (GrizzlyAsyncHttpProviderConfig) clientConfig.getAsyncHttpProviderConfig();
-
-        boolean npnEnabled = NextProtoNegSupport.isEnabled();
-        boolean spdyEnabled = clientConfig.isSpdyEnabled();
-
-        if (spdyEnabled) {
-            // if NPN isn't available, check to see if it has been explicitly
-            // disabled.  If it has, we assume the user knows what they are doing
-            // and we enable SPDY without NPN - this effectively disables standard
-            // HTTP/1.1 support.
-            if (!npnEnabled && providerConfig != null) {
-                if ((Boolean) providerConfig.getProperty(Property.NPN_ENABLED)) {
-                    // NPN hasn't been disabled, so it's most likely a configuration problem.
-                    // Log a warning and disable spdy support.
-                    LOGGER.warn("Next Protocol Negotiation support is not available.  SPDY support has been disabled.");
-                    spdyEnabled = false;
-                }
-            }
-        }
-
-        final AsyncHttpClientEventFilter eventFilter;
-        final EventHandler handler = new EventHandler(clientConfig);
-        if (providerConfig != null) {
-            eventFilter = new AsyncHttpClientEventFilter(handler, (Integer) providerConfig.getProperty(MAX_HTTP_PACKET_HEADER_SIZE));
-        } else {
-            eventFilter = new AsyncHttpClientEventFilter(handler);
-        }
-        handler.cleanup = eventFilter;
-        ContentEncoding[] encodings = eventFilter.getContentEncodings();
-        if (encodings.length > 0) {
-            for (ContentEncoding encoding : encodings) {
-                eventFilter.removeContentEncoding(encoding);
-            }
-        }
-        if (clientConfig.isCompressionEnforced()) {
-            eventFilter.addContentEncoding(new GZipContentEncoding(512, 512, new ClientEncodingFilter()));
-        }
-        secure.add(eventFilter);
-        final AsyncHttpClientFilter clientFilter = new AsyncHttpClientFilter(this, clientConfig);
-        secure.add(clientFilter);
-        secure.add(new WebSocketClientFilter());
-
-        clientTransport.getAsyncQueueIO().getWriter().setMaxPendingBytesPerConnection(AUTO_SIZE);
-        
-        clientTransport.setNIOChannelDistributor(
-                new RoundRobinConnectionDistributor(clientTransport, false, false));
-        
-        final int kernelThreadsCount =
-                clientConfig.getIoThreadMultiplier() *
-                Runtime.getRuntime().availableProcessors();
-        
-        clientTransport.setSelectorRunnersCount(kernelThreadsCount);
-        clientTransport.setKernelThreadPoolConfig(
-                ThreadPoolConfig.defaultConfig()
-                .setCorePoolSize(kernelThreadsCount)
-                .setMaxPoolSize(kernelThreadsCount)
-                .setPoolName("grizzly-ahc-kernel")
-//                .setPoolName(Utils.discoverTestName("grizzly-ahc-kernel")) // uncomment for tests to track down the leaked threads
-        );
-        
-        if (providerConfig != null) {
-            final TransportCustomizer customizer = (TransportCustomizer) providerConfig.getProperty(Property.TRANSPORT_CUSTOMIZER);
-            if (customizer != null) {
-                customizer.customize(clientTransport, secure);
-            } else {
-                doDefaultTransportConfig();
-            }
-        } else {
-            doDefaultTransportConfig();
-        }
-
-        // FilterChain for the standard HTTP case has been configured, we now
-        // copy it and modify for SPDY purposes.
-        if (spdyEnabled) {
-            FilterChainBuilder spdyFilterChain = createSpdyFilterChain(secure, npnEnabled);
-            ProtocolNegotiator pn = new ProtocolNegotiator(spdyFilterChain.build());
-            NextProtoNegSupport.getInstance().setClientSideNegotiator(clientTransport, pn);
-        }
-
-        // Install the HTTP filter chain.
-        //clientTransport.setProcessor(fcb.build());
-        FilterChainBuilder nonSecure = FilterChainBuilder.stateless();
-        nonSecure.addAll(secure);
-        int idx = nonSecure.indexOfType(SSLFilter.class);
-        nonSecure.remove(idx);
-        final ConnectionPool pool;
-        if (providerConfig != null) {
-            pool = (ConnectionPool) providerConfig.getProperty(CONNECTION_POOL);
-        } else {
-            pool = null;
-        }
-        connectionManager = new ConnectionManager(this, pool, secure, nonSecure);
-
-    }
-
-    // ------------------------------------------------- Package Private Methods
-
-    void touchConnection(final Connection c, final Request request) {
-
-        int requestTimeout = AsyncHttpProviderUtils.requestTimeout(clientConfig, request);
-        if (requestTimeout > 0) {
-            if (resolver != null) {
-                resolver.setTimeoutMillis(c, System.currentTimeMillis() + requestTimeout);
-            }
-        }
-
-    }
-
-    // --------------------------------------------------------- Private Methods
-
-    private FilterChainBuilder createSpdyFilterChain(final FilterChainBuilder fcb, final boolean npnEnabled) {
-
-        FilterChainBuilder spdyFcb = FilterChainBuilder.stateless();
-        spdyFcb.addAll(fcb);
-        int idx = spdyFcb.indexOfType(SSLFilter.class);
-        Filter f = spdyFcb.get(idx);
-
-        // Adjust the SSLFilter to support NPN
-        if (npnEnabled) {
-            SSLBaseFilter sslBaseFilter = (SSLBaseFilter) f;
-            NextProtoNegSupport.getInstance().configure(sslBaseFilter);
-        }
-
-        // Remove the HTTP Client filter - this will be replaced by the
-        // SPDY framing and handler filters.
-        idx = spdyFcb.indexOfType(HttpClientFilter.class);
-        spdyFcb.set(idx, new SpdyFramingFilter());
-        final SpdyMode spdyMode = ((npnEnabled) ? SpdyMode.NPN : SpdyMode.PLAIN);
-        AsyncSpdyClientEventFilter spdyFilter = new AsyncSpdyClientEventFilter(new EventHandler(clientConfig), spdyMode,
-                clientConfig.executorService());
-        spdyFilter.setInitialWindowSize(clientConfig.getSpdyInitialWindowSize());
-        spdyFilter.setMaxConcurrentStreams(clientConfig.getSpdyMaxConcurrentStreams());
-        spdyFcb.add(idx + 1, spdyFilter);
-
-        // Remove the WebSocket filter - not currently supported.
-        idx = spdyFcb.indexOfType(WebSocketClientFilter.class);
-        spdyFcb.remove(idx);
-
-        return spdyFcb;
-    }
-
-    private void doDefaultTransportConfig() {
-        final ExecutorService service = clientConfig.executorService();
-        clientTransport.setIOStrategy(WorkerThreadIOStrategy.getInstance());
-        if (service != null) {
-            clientTransport.setWorkerThreadPool(service);
-        } else {
-            final int multiplier = clientConfig.getIoThreadMultiplier();
-            final int threadCount = multiplier * Runtime.getRuntime().availableProcessors();
-            clientTransport.getWorkerThreadPoolConfig().setCorePoolSize(threadCount).setMaxPoolSize(threadCount);
-        }
-    }
-
-    private <T> CompletionHandler<WriteResult> createWriteCompletionHandler(final GrizzlyResponseFuture<T> future) {
-        return new CompletionHandler<WriteResult>() {
-
-            public void cancelled() {
-                future.cancel(true);
-            }
-
-            public void failed(Throwable throwable) {
-                future.abort(throwable);
-            }
-
-            public void completed(WriteResult result) {
-            }
-
-            public void updated(WriteResult result) {
-                // no-op
-            }
-
-        };
-    }
-
-    void timeout(final Connection c) {
-
-        final String key = HttpTxContext.class.getName();
-        HttpTxContext ctx;
-        if (!Utils.isSpdyConnection(c)) {
-            ctx = (HttpTxContext) c.getAttributes().getAttribute(key);
-            if (ctx != null) {
-                c.getAttributes().removeAttribute(key);
-                ctx.abort(new TimeoutException("Timeout exceeded"));
-            }
-        } else {
-            throw new IllegalStateException();
-        }
-
-        //        if (context != null) {
-        //            HttpTxContext.set(c, null);
-        //            context.abort(new TimeoutException("Timeout exceeded"));
-        //        }
-
-    }
-
-    // ---------------------------------------------------------- Nested Classes
-
-    private static final class ProtocolNegotiator implements ClientSideNegotiator {
-        private static final SpdyVersion[] SUPPORTED_SPDY_VERSIONS =
-                {SpdyVersion.SPDY_3_1, SpdyVersion.SPDY_3};
-
-        private static final String HTTP = "HTTP/1.1";
-
-        private final FilterChain spdyFilterChain;
-        private final SpdyHandlerFilter spdyHandlerFilter;
-
-        // -------------------------------------------------------- Constructors
-
-        private ProtocolNegotiator(final FilterChain spdyFilterChain) {
-            this.spdyFilterChain = spdyFilterChain;
-            int idx = spdyFilterChain.indexOfType(SpdyHandlerFilter.class);
-            spdyHandlerFilter = (SpdyHandlerFilter) spdyFilterChain.get(idx);
-        }
-
-        // ----------------------------------- Methods from ClientSideNegotiator
-
-        @Override
-        public boolean wantNegotiate(SSLEngine engine) {
-            GrizzlyAsyncHttpProvider.LOGGER.info("ProtocolSelector::wantNegotiate");
-            return true;
-        }
-
-        @Override
-        public String selectProtocol(SSLEngine engine, LinkedHashSet<String> protocols) {
-            GrizzlyAsyncHttpProvider.LOGGER.info("ProtocolSelector::selectProtocol: " + protocols);
-            final Connection connection = NextProtoNegSupport.getConnection(engine);
-
-            // Give preference to SPDY/3.1 or SPDY/3.  If not available, check for HTTP as a
-            // fallback            
-            for (SpdyVersion version : SUPPORTED_SPDY_VERSIONS) {
-                final String versionDef = version.toString();
-                if (protocols.contains(versionDef)) {
-                    GrizzlyAsyncHttpProvider.LOGGER.info("ProtocolSelector::selecting: " + versionDef);
-                    SSLConnectionContext sslCtx = SSLUtils.getSslConnectionContext(connection);
-                    sslCtx.setNewConnectionFilterChain(spdyFilterChain);
-                    final SpdySession spdySession =
-                            version.newSession(connection, false, spdyHandlerFilter);
-
-                    spdySession.setLocalStreamWindowSize(spdyHandlerFilter.getInitialWindowSize());
-                    spdySession.setLocalMaxConcurrentStreams(spdyHandlerFilter.getMaxConcurrentStreams());
-                    Utils.setSpdyConnection(connection);
-                    SpdySession.bind(connection, spdySession);
-
-                    return versionDef;
-                }
-            }
-            
-            if (protocols.contains(HTTP)) {
-                GrizzlyAsyncHttpProvider.LOGGER.info("ProtocolSelector::selecting: " + HTTP);
-                // Use the default HTTP FilterChain.
-                return HTTP;
-            } else {
-                GrizzlyAsyncHttpProvider.LOGGER.info("ProtocolSelector::selecting NONE");
-                // no protocol support.  Will close the connection when
-                // onNoDeal is invoked
-                return "";
-            }
-        }
-
-        @Override
-        public void onNoDeal(SSLEngine engine) {
-            GrizzlyAsyncHttpProvider.LOGGER.info("ProtocolSelector::onNoDeal");
-            final Connection connection = NextProtoNegSupport.getConnection(engine);
-            connection.closeSilently();
-        }
-    }
-
-    public static interface Cleanup {
-
-        void cleanup(final FilterChainContext ctx);
-
-    }
-}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncHttpProviderConfig.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncHttpProviderConfig.java
deleted file mode 100644
index 662eb6a5d..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncHttpProviderConfig.java
+++ /dev/null
@@ -1,181 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpProviderConfig;
-import org.glassfish.grizzly.http.HttpCodecFilter;
-import org.glassfish.grizzly.nio.transport.TCPNIOTransport;
-
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Set;
-
-/**
- * {@link AsyncHttpProviderConfig} implementation that allows customization
- * of the Grizzly runtime outside of the scope of what the
- * {@link org.asynchttpclient.AsyncHttpClientConfig} offers.
- *
- * @see Property
- * 
- * @author The Grizzly Team
- * @since 1.7.0
- */
-public class GrizzlyAsyncHttpProviderConfig implements AsyncHttpProviderConfig<GrizzlyAsyncHttpProviderConfig.Property, Object> {
-
-    /**
-     * Grizzly-specific customization properties.  Each property describes
-     * what it's used for, what the default value is (if any), and what
-     * the expected type the value of the property should be.
-     */
-    public static enum Property {
-
-        /**
-         * If this property is specified with a custom {@link TransportCustomizer}
-         * instance, the {@link TCPNIOTransport} instance that is created by
-         * {@link GrizzlyAsyncHttpProvider} will be passed to the customizer
-         * bypassing all default configuration of the transport typically performed
-         * by the provider. The type of the value associated with this property
-         * must be <code>TransportCustomizer.class</code>.
-         *
-         * @see TransportCustomizer
-         */
-        TRANSPORT_CUSTOMIZER(TransportCustomizer.class),
-
-        /**
-         * Defines the maximum HTTP packet header size.
-         *
-         * @since 1.8
-         */
-        MAX_HTTP_PACKET_HEADER_SIZE(Integer.class, HttpCodecFilter.DEFAULT_MAX_HTTP_PACKET_HEADER_SIZE),
-
-        /**
-         * By default, Websocket messages that are fragmented will be buffered.  Once all
-         * fragments have been accumulated, the appropriate onMessage() call back will be
-         * invoked with the complete message.  If this functionality is not desired, set
-         * this property to false.
-         */
-        BUFFER_WEBSOCKET_FRAGMENTS(Boolean.class, true),
-
-        /**
-         * By disabling NPN support, SPDY will be used over secure or non-secure channels,
-         * but no negotiation of the protocol via NPN will occur.  In short, this means
-         * that this instance of AHC will only 'speak' SPDY - HTTP is effectively disabled.
-         */
-        NPN_ENABLED(Boolean.class, true),
-
-        /**
-         * Grizzly specific connection pool.
-         */
-        CONNECTION_POOL(ConnectionPool.class, null);
-
-        final Object defaultValue;
-        final Class<?> type;
-
-        private Property(final Class<?> type, final Object defaultValue) {
-            this.type = type;
-            this.defaultValue = defaultValue;
-        }
-
-        private Property(final Class<?> type) {
-            this(type, null);
-        }
-
-        boolean hasDefaultValue() {
-            return (defaultValue != null);
-        }
-
-    } // END PROPERTY
-
-    private final Map<Property, Object> attributes = new HashMap<Property, Object>();
-
-    /**
-     * @return <code>true</code> if the underlying provider should make new connections asynchronously or not.  By default
-     *  new connections are made synchronously.
-     *
-     * @since 2.0.0
-     */
-    private boolean asyncConnectMode;
-
-    public boolean isAsyncConnectMode() {
-        return asyncConnectMode;
-    }
-
-    public void setAsyncConnectMode(boolean asyncConnectMode) {
-        this.asyncConnectMode = asyncConnectMode;
-    }
-
-    // ------------------------------------ Methods from AsyncHttpProviderConfig
-
-    /**
-     * {@inheritDoc}
-     * 
-     * @throws IllegalArgumentException if the type of the specified value
-     *  does not match the expected type of the specified {@link Property}.
-     */
-    @SuppressWarnings("unchecked")
-    @Override
-    public AsyncHttpProviderConfig addProperty(Property name, Object value) {
-        if (name == null) {
-            return this;
-        }
-        if (value == null) {
-            if (name.hasDefaultValue()) {
-                value = name.defaultValue;
-            } else {
-                return this;
-            }
-        } else {
-            if (!name.type.isAssignableFrom(value.getClass())) {
-                throw new IllegalArgumentException(String.format(
-                        "The value of property [%s] must be of type [%s].  Type of value provided: [%s].", name.name(),
-                        name.type.getName(), value.getClass().getName()));
-            }
-        }
-        attributes.put(name, value);
-        return this;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public Object getProperty(Property name) {
-        Object ret = attributes.get(name);
-        if (ret == null) {
-            if (name.hasDefaultValue()) {
-                ret = name.defaultValue;
-            }
-        }
-        return ret;
-    }
-
-    /**
-      * {@inheritDoc}
-      */
-    @Override
-    public Object removeProperty(Property name) {
-        if (name == null) {
-            return null;
-        }
-        return attributes.remove(name);
-    }
-
-    /**
-      * {@inheritDoc}
-      */
-    @Override
-    public Set<Map.Entry<Property, Object>> propertiesSet() {
-        return attributes.entrySet();
-    }
-}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponse.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponse.java
deleted file mode 100644
index a1825f1b5..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponse.java
+++ /dev/null
@@ -1,198 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
-
-import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.HttpResponseHeaders;
-import org.asynchttpclient.HttpResponseStatus;
-import org.asynchttpclient.cookie.Cookie;
-import org.asynchttpclient.providers.ResponseBase;
-import org.asynchttpclient.util.AsyncHttpProviderUtils;
-import org.glassfish.grizzly.Buffer;
-import org.glassfish.grizzly.http.Cookies;
-import org.glassfish.grizzly.http.CookiesBuilder.ServerCookiesBuilder;
-import org.glassfish.grizzly.http.util.Header;
-import org.glassfish.grizzly.memory.Buffers;
-import org.glassfish.grizzly.memory.MemoryManager;
-import org.glassfish.grizzly.utils.BufferInputStream;
-import org.glassfish.grizzly.utils.Charsets;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.nio.ByteBuffer;
-import java.nio.charset.Charset;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
-/**
- * {@link org.asynchttpclient.HttpResponseBodyPart} implementation using the Grizzly 2.0 HTTP client
- * codec.
- *
- * @author The Grizzly Team
- * @since 1.7.0
- */
-public class GrizzlyResponse extends ResponseBase {
-
-    private Buffer responseBody;
-    private boolean initialized;
-
-    // ------------------------------------------------------------ Constructors
-
-    public GrizzlyResponse(final HttpResponseStatus status, final HttpResponseHeaders headers, final List<HttpResponseBodyPart> bodyParts) {
-        super(status, headers, bodyParts);
-    }
-
-    // --------------------------------------------------- Methods from Response
-
-    /**
-     * {@inheritDoc}
-     */
-    public InputStream getResponseBodyAsStream() throws IOException {
-        return new BufferInputStream(getResponseBody0());
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public String getResponseBodyExcerpt(int maxLength, String charset) throws IOException {
-        charset = calculateCharset(charset);
-        final Buffer responseBody = getResponseBody0();
-        final int len = Math.min(responseBody.remaining(), maxLength);
-        final int pos = responseBody.position();
-        return responseBody.toStringContent(getCharset(charset), pos, len + pos);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public String getResponseBody(String charset) throws IOException {
-        return getResponseBody0().toStringContent(getCharset(charset));
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public byte[] getResponseBodyAsBytes() throws IOException {
-        final Buffer responseBody = getResponseBody0();
-        final byte[] responseBodyBytes = new byte[responseBody.remaining()];
-        final int origPos = responseBody.position();
-        responseBody.get(responseBodyBytes);
-        responseBody.position(origPos);
-        return responseBodyBytes;
-    }
-
-    @Override
-    public ByteBuffer getResponseBodyAsByteBuffer() throws IOException {
-        return ByteBuffer.wrap(getResponseBodyAsBytes());
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public String getResponseBodyExcerpt(int maxLength) throws IOException {
-        return getResponseBodyExcerpt(maxLength, null);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public String getResponseBody() throws IOException {
-        return getResponseBody(null);
-    }
-
-    /**
-     * @return the response body as a Grizzly {@link Buffer}.
-     */
-    @SuppressWarnings("UnusedDeclaration")
-    public Buffer getResponseBodyAsBuffer() {
-        return getResponseBody0();
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public List<Cookie> buildCookies() {
-
-        List<String> values = headers.getHeaders().get(Header.SetCookie.toString());
-        if (isNonEmpty(values)) {
-            ServerCookiesBuilder builder = new ServerCookiesBuilder(false, true);
-            for (int i = 0, len = values.size(); i < len; i++) {
-                builder.parse(values.get(i));
-            }
-            return convertCookies(builder.build());
-
-        } else {
-            return Collections.unmodifiableList(Collections.<Cookie> emptyList());
-        }
-    }
-
-    // --------------------------------------------------------- Private Methods
-
-    private List<Cookie> convertCookies(Cookies cookies) {
-
-        final org.glassfish.grizzly.http.Cookie[] grizzlyCookies = cookies.get();
-        List<Cookie> convertedCookies = new ArrayList<Cookie>(grizzlyCookies.length);
-        for (int i = 0, len = grizzlyCookies.length; i < len; i++) {
-            org.glassfish.grizzly.http.Cookie gCookie = grizzlyCookies[i];
-            convertedCookies.add(new Cookie(gCookie.getName(), gCookie.getValue(), gCookie.getValue(), gCookie.getDomain(), gCookie
-                    .getPath(), -1L, gCookie.getMaxAge(), gCookie.isSecure(), gCookie.isHttpOnly()));
-        }
-        return Collections.unmodifiableList(convertedCookies);
-    }
-
-    private Charset getCharset(final String charset) {
-
-        String charsetLocal = charset;
-
-        if (charsetLocal == null) {
-            String contentType = getContentType();
-            if (contentType != null) {
-                charsetLocal = AsyncHttpProviderUtils.parseCharset(contentType);
-            }
-        }
-
-        if (charsetLocal == null) {
-            charsetLocal = Charsets.DEFAULT_CHARACTER_ENCODING;
-        }
-
-        return Charsets.lookupCharset(charsetLocal);
-    }
-
-    private synchronized Buffer getResponseBody0() {
-        if (!initialized) {
-            if (isNonEmpty(bodyParts)) {
-                if (bodyParts.size() == 1) {
-                    responseBody = ((GrizzlyResponseBodyPart) bodyParts.get(0)).getBodyBuffer();
-                } else {
-                    final Buffer firstBuffer = ((GrizzlyResponseBodyPart) bodyParts.get(0)).getBodyBuffer();
-                    final MemoryManager<?> mm = MemoryManager.DEFAULT_MEMORY_MANAGER;
-                    Buffer constructedBodyBuffer = firstBuffer;
-                    for (int i = 1, len = bodyParts.size(); i < len; i++) {
-                        constructedBodyBuffer = Buffers.appendBuffers(mm, constructedBodyBuffer,
-                                ((GrizzlyResponseBodyPart) bodyParts.get(i)).getBodyBuffer());
-                    }
-                    responseBody = constructedBodyBuffer;
-                }
-            } else {
-                responseBody = Buffers.EMPTY_BUFFER;
-            }
-            initialized = true;
-        }
-        return responseBody;
-    }
-}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponseBodyPart.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponseBodyPart.java
deleted file mode 100644
index 451ddae21..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponseBodyPart.java
+++ /dev/null
@@ -1,126 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.HttpResponseBodyPart;
-import org.glassfish.grizzly.Buffer;
-import org.glassfish.grizzly.Connection;
-import org.glassfish.grizzly.http.HttpContent;
-import org.glassfish.grizzly.utils.BufferInputStream;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.nio.ByteBuffer;
-import java.util.concurrent.atomic.AtomicReference;
-
-/**
- * {@link HttpResponseBodyPart} implementation using the Grizzly 2.0 HTTP client
- * codec.
- *
- * @author The Grizzly Team
- * @since 1.7.0
- */
-class GrizzlyResponseBodyPart extends HttpResponseBodyPart {
-
-    private final HttpContent content;
-    private final Connection<?> connection;
-    private final AtomicReference<byte[]> contentBytes = new AtomicReference<byte[]>();
-
-    // ------------------------------------------------------------ Constructors
-
-    public GrizzlyResponseBodyPart(final HttpContent content, final Connection<?> connection) {
-        this.content = content;
-        this.connection = connection;
-    }
-
-    // --------------------------------------- Methods from HttpResponseBodyPart
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public byte[] getBodyPartBytes() {
-        byte[] bytes = contentBytes.get();
-        if (bytes != null) {
-            return bytes;
-        }
-        final Buffer b = content.getContent();
-        final int origPos = b.position();
-        bytes = new byte[b.remaining()];
-        b.get(bytes);
-        b.position(origPos);
-        contentBytes.compareAndSet(null, bytes);
-        return bytes;
-    }
-
-    @Override
-    public InputStream readBodyPartBytes() {
-        return new BufferInputStream(content.getContent());
-    }
-
-    @Override
-    public int length() {
-        return content.getContent().remaining();
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public int writeTo(OutputStream outputStream) throws IOException {
-
-        final byte[] bytes = getBodyPartBytes();
-        outputStream.write(bytes);
-        return bytes.length;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public ByteBuffer getBodyByteBuffer() {
-        return content.getContent().toByteBuffer();
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public boolean isLast() {
-        return content.isLast();
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void markUnderlyingConnectionAsToBeClosed() {
-        ConnectionManager.markConnectionAsDoNotCache(connection);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public boolean isUnderlyingConnectionToBeClosed() {
-        return !ConnectionManager.isConnectionCacheable(connection);
-    }
-
-    // ----------------------------------------------- Package Protected Methods
-
-    Buffer getBodyBuffer() {
-        return content.getContent();
-    }
-}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponseFuture.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponseFuture.java
deleted file mode 100644
index 3a13110f7..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponseFuture.java
+++ /dev/null
@@ -1,163 +0,0 @@
-/*
- * Copyright (c) 2012-2013 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.ProxyServer;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.listenable.AbstractListenableFuture;
-import org.glassfish.grizzly.Connection;
-import org.glassfish.grizzly.impl.FutureImpl;
-
-import java.util.concurrent.CancellationException;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-import java.util.concurrent.atomic.AtomicBoolean;
-
-/**
- * {@link AbstractListenableFuture} implementation adaptation of Grizzly's
- * {@link FutureImpl}.
- *
- * @author The Grizzly Team
- * @since 1.7.0
- */
-public class GrizzlyResponseFuture<V> extends AbstractListenableFuture<V> {
-
-    private final AtomicBoolean done = new AtomicBoolean(false);
-    private final AtomicBoolean cancelled = new AtomicBoolean(false);
-    private final AsyncHandler handler;
-    private final GrizzlyAsyncHttpProvider provider;
-    private final Request request;
-    private final ProxyServer proxyServer;
-    private Connection connection;
-
-    FutureImpl<V> delegate;
-
-    // ------------------------------------------------------------ Constructors
-
-    public GrizzlyResponseFuture(final GrizzlyAsyncHttpProvider provider, final Request request, final AsyncHandler handler,
-            final ProxyServer proxyServer) {
-
-        this.provider = provider;
-        this.request = request;
-        this.handler = handler;
-        this.proxyServer = proxyServer;
-    }
-
-    // ----------------------------------- Methods from AbstractListenableFuture
-
-    public void done() {
-
-        if (!done.compareAndSet(false, true) || cancelled.get()) {
-            return;
-        }
-        runListeners();
-    }
-
-    public void abort(Throwable t) {
-
-        if (done.get() || !cancelled.compareAndSet(false, true)) {
-            return;
-        }
-        delegate.failure(t);
-        if (handler != null) {
-            try {
-                handler.onThrowable(t);
-            } catch (Throwable ignore) {
-            }
-        }
-        closeConnection();
-        runListeners();
-    }
-
-    public void touch() {
-        provider.touchConnection(connection, request);
-    }
-
-    public boolean getAndSetWriteHeaders(boolean writeHeaders) {
-
-        // TODO This doesn't currently do anything - and may not make sense
-        // with our implementation.  Needs further analysis.
-        return writeHeaders;
-    }
-
-    public boolean getAndSetWriteBody(boolean writeBody) {
-
-        // TODO This doesn't currently do anything - and may not make sense
-        // with our implementation.  Needs further analysis.
-        return writeBody;
-    }
-
-    // ----------------------------------------------------- Methods from Future
-
-    public boolean cancel(boolean mayInterruptIfRunning) {
-
-        if (done.get() || !cancelled.compareAndSet(false, true)) {
-            return false;
-        }
-        if (handler != null) {
-            try {
-                handler.onThrowable(new CancellationException());
-            } catch (Throwable ignore) {
-            }
-        }
-        runListeners();
-        return delegate.cancel(mayInterruptIfRunning);
-    }
-
-    public boolean isCancelled() {
-        return delegate.isCancelled();
-    }
-
-    public boolean isDone() {
-        return delegate.isDone();
-    }
-
-    public V get() throws InterruptedException, ExecutionException {
-        return delegate.get();
-    }
-
-    public V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
-
-        if (!delegate.isCancelled() || !delegate.isDone()) {
-            return delegate.get(timeout, unit);
-        } else {
-            return null;
-        }
-    }
-
-    // ------------------------------------------------- Package Private Methods
-
-    void setConnection(final Connection connection) {
-        this.connection = connection;
-    }
-
-    public void setDelegate(final FutureImpl<V> delegate) {
-        this.delegate = delegate;
-    }
-
-    // --------------------------------------------------------- Private Methods
-
-    private void closeConnection() {
-
-        if (connection != null && connection.isOpen()) {
-            connection.close().recycle(true);
-        }
-    }
-
-    public ProxyServer getProxyServer() {
-        return proxyServer;
-    }
-}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponseHeaders.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponseHeaders.java
deleted file mode 100644
index 6e0893b16..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponseHeaders.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
-import org.asynchttpclient.HttpResponseHeaders;
-import org.glassfish.grizzly.http.HttpResponsePacket;
-import org.glassfish.grizzly.http.util.MimeHeaders;
-
-/**
- * {@link HttpResponseHeaders} implementation using the Grizzly 2.0 HTTP client
- * codec.
- *
- * @author The Grizzly Team
- * @since 1.7.0
- */
-class GrizzlyResponseHeaders extends HttpResponseHeaders {
-
-    private FluentCaseInsensitiveStringsMap headers;
-    private MimeHeaders grizzlyHeaders;
-
-    // ------------------------------------------------------------ Constructors
-
-    public GrizzlyResponseHeaders(final HttpResponsePacket response) {
-
-        grizzlyHeaders = new MimeHeaders();
-        grizzlyHeaders.copyFrom(response.getHeaders());
-    }
-
-    // ---------------------------------------- Methods from HttpResponseHeaders
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public synchronized FluentCaseInsensitiveStringsMap getHeaders() {
-        if (headers == null) {
-            headers = new FluentCaseInsensitiveStringsMap();
-            for (String name : grizzlyHeaders.names()) {
-                for (String header : grizzlyHeaders.values(name)) {
-                    headers.add(name, header);
-                }
-            }
-        }
-        return headers;
-    }
-
-    @Override
-    public String toString() {
-        return getHeaders().toString();
-    }
-}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponseStatus.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponseStatus.java
deleted file mode 100644
index 882f0eed0..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/GrizzlyResponseStatus.java
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * Copyright (c) 2012-2014 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.HttpResponseHeaders;
-import org.asynchttpclient.HttpResponseStatus;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.uri.Uri;
-import org.glassfish.grizzly.http.HttpResponsePacket;
-
-import java.util.List;
-
-/**
- * {@link HttpResponseStatus} implementation using the Grizzly 2.0 HTTP client
- * codec.
- *
- * @author The Grizzly Team
- * @since 1.7.0
- */
-public class GrizzlyResponseStatus extends HttpResponseStatus {
-
-    private static final String PROTOCOL_NAME = "HTTP";
-    private final int statusCode;
-    private final String statusText;
-    private final int majorVersion;
-    private final int minorVersion;
-    private final String protocolText;
-    private final HttpResponsePacket response;
-    
-    // ------------------------------------------------------------ Constructors
-
-    public GrizzlyResponseStatus(final HttpResponsePacket response, final Uri uri, AsyncHttpClientConfig config) {
-
-        super(uri, config);
-        statusCode = response.getStatus();
-        statusText = response.getReasonPhrase();
-        majorVersion = response.getProtocol().getMajorVersion();
-        minorVersion = response.getProtocol().getMinorVersion();
-        protocolText = response.getProtocolString();
-        
-        this.response = response;
-    }
-
-    // ----------------------------------------- Methods from HttpResponseStatus
-
-    @Override
-    public Response prepareResponse(HttpResponseHeaders headers, List<HttpResponseBodyPart> bodyParts) {
-        return new GrizzlyResponse(this, headers, bodyParts);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public int getStatusCode() {
-        return statusCode;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public String getStatusText() {
-        return statusText;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public String getProtocolName() {
-        return PROTOCOL_NAME;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public int getProtocolMajorVersion() {
-        return majorVersion;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public int getProtocolMinorVersion() {
-        return minorVersion;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public String getProtocolText() {
-        return protocolText;
-    }
-
-    /**
-     * @return internal Grizzly {@link HttpResponsePacket}
-     */
-    public HttpResponsePacket getResponse() {
-        return response;
-    }
-}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/HttpTxContext.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/HttpTxContext.java
deleted file mode 100644
index 15aae3159..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/HttpTxContext.java
+++ /dev/null
@@ -1,309 +0,0 @@
-/*
- * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.providers.grizzly.bodyhandler.BodyHandler;
-import org.asynchttpclient.providers.grizzly.statushandler.StatusHandler;
-import org.asynchttpclient.providers.grizzly.statushandler.StatusHandler.InvocationStatus;
-import org.asynchttpclient.uri.Uri;
-import org.asynchttpclient.util.AsyncHttpProviderUtils;
-import org.asynchttpclient.websocket.WebSocket;
-import org.glassfish.grizzly.CloseListener;
-import org.glassfish.grizzly.CloseType;
-import org.glassfish.grizzly.Closeable;
-import org.glassfish.grizzly.Grizzly;
-import org.glassfish.grizzly.attributes.Attribute;
-import org.glassfish.grizzly.filterchain.FilterChainContext;
-import org.glassfish.grizzly.http.HttpContext;
-import org.glassfish.grizzly.websockets.HandShake;
-import org.glassfish.grizzly.websockets.ProtocolHandler;
-
-import java.io.IOException;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicLong;
-
-import org.asynchttpclient.providers.grizzly.filters.events.GracefulCloseEvent;
-import org.glassfish.grizzly.Connection;
-import org.glassfish.grizzly.filterchain.FilterChain;
-import org.glassfish.grizzly.http.HttpResponsePacket;
-
-public final class HttpTxContext {
-
-    private static final Attribute<HttpTxContext> REQUEST_STATE_ATTR = Grizzly.DEFAULT_ATTRIBUTE_BUILDER
-            .createAttribute(HttpTxContext.class.getName());
-
-    private final AtomicInteger redirectCount = new AtomicInteger(0);
-
-    private final int maxRedirectCount;
-    private final boolean redirectsAllowed;
-    private final GrizzlyAsyncHttpProvider provider;
-
-    private Request request;
-    private Uri requestUri;
-    private final AsyncHandler handler;
-    private BodyHandler bodyHandler;
-    private StatusHandler statusHandler;
-    private InvocationStatus invocationStatus = InvocationStatus.CONTINUE;
-    private GrizzlyResponseStatus responseStatus;
-    private GrizzlyResponseFuture future;
-    private String lastRedirectURI;
-    private final AtomicLong totalBodyWritten = new AtomicLong();
-    private AsyncHandler.STATE currentState;
-
-    private Uri wsRequestURI;
-    private boolean isWSRequest;
-    private HandShake handshake;
-    private ProtocolHandler protocolHandler;
-    private WebSocket webSocket;
-    private final CloseListener listener = new CloseListener<Closeable, CloseType>() {
-        @Override
-        public void onClosed(Closeable closeable, CloseType type) throws IOException {
-            if (responseStatus != null && // responseStatus==null if request wasn't even sent
-                    isGracefullyFinishResponseOnClose()) {
-                // Connection was closed.
-                // This event is fired only for responses, which don't have
-                // associated transfer-encoding or content-length.
-                // We have to complete such a request-response processing gracefully.
-                final Connection c = responseStatus.getResponse()
-                        .getRequest().getConnection();
-                final FilterChain fc = (FilterChain) c.getProcessor();
-                
-                fc.fireEventUpstream(c,
-                        new GracefulCloseEvent(HttpTxContext.this), null);
-            } else if (CloseType.REMOTELY.equals(type)) {
-                abort(AsyncHttpProviderUtils.REMOTELY_CLOSED_EXCEPTION);
-            }
-        }
-    };
-
-    // -------------------------------------------------------- Constructors
-
-    private HttpTxContext(final GrizzlyAsyncHttpProvider provider, final GrizzlyResponseFuture future, final Request request,
-            final AsyncHandler handler) {
-        this.provider = provider;
-        this.future = future;
-        this.request = request;
-        this.handler = handler;
-        redirectsAllowed = this.provider.getClientConfig().isFollowRedirect();
-        maxRedirectCount = this.provider.getClientConfig().getMaxRedirects();
-        this.requestUri = request.getUri();
-    }
-
-    // ---------------------------------------------------------- Public Methods
-
-    public static void set(final FilterChainContext ctx, final HttpTxContext httpTxContext) {
-        HttpContext httpContext = HttpContext.get(ctx);
-        httpContext.getCloseable().addCloseListener(httpTxContext.listener);
-        REQUEST_STATE_ATTR.set(httpContext, httpTxContext);
-    }
-
-    public static HttpTxContext remove(final FilterChainContext ctx) {
-        final HttpContext httpContext = HttpContext.get(ctx);
-        final HttpTxContext httpTxContext = REQUEST_STATE_ATTR.remove(httpContext);
-        if (httpTxContext != null) {
-            httpContext.getCloseable().removeCloseListener(httpTxContext.listener);
-        }
-        
-        return httpTxContext;
-    }
-
-    public static HttpTxContext get(FilterChainContext ctx) {
-        HttpContext httpContext = HttpContext.get(ctx);
-        return ((httpContext != null) ? REQUEST_STATE_ATTR.get(httpContext) : null);
-    }
-
-    public static HttpTxContext create(final RequestInfoHolder requestInfoHolder) {
-        return new HttpTxContext(requestInfoHolder.getProvider(),//
-                requestInfoHolder.getFuture(),//
-                requestInfoHolder.getRequest(),//
-                requestInfoHolder.getHandler());
-    }
-
-    public void abort(final Throwable t) {
-        if (future != null) {
-            future.abort(t);
-        }
-    }
-
-    public AtomicInteger getRedirectCount() {
-        return redirectCount;
-    }
-
-    public int getMaxRedirectCount() {
-        return maxRedirectCount;
-    }
-
-    public boolean isRedirectsAllowed() {
-        return redirectsAllowed;
-    }
-
-    public GrizzlyAsyncHttpProvider getProvider() {
-        return provider;
-    }
-
-    public Request getRequest() {
-        return request;
-    }
-
-    public void setRequest(Request request) {
-        this.request = request;
-    }
-
-    public Uri getRequestUri() {
-        return requestUri;
-    }
-
-    public void setRequestUri(Uri requestUri) {
-        this.requestUri = requestUri;
-    }
-
-    public AsyncHandler getHandler() {
-        return handler;
-    }
-
-    public BodyHandler getBodyHandler() {
-        return bodyHandler;
-    }
-
-    public void setBodyHandler(BodyHandler bodyHandler) {
-        this.bodyHandler = bodyHandler;
-    }
-
-    public StatusHandler getStatusHandler() {
-        return statusHandler;
-    }
-
-    public void setStatusHandler(StatusHandler statusHandler) {
-        this.statusHandler = statusHandler;
-    }
-
-    public InvocationStatus getInvocationStatus() {
-        return invocationStatus;
-    }
-
-    public void setInvocationStatus(InvocationStatus invocationStatus) {
-        this.invocationStatus = invocationStatus;
-    }
-
-    public GrizzlyResponseStatus getResponseStatus() {
-        return responseStatus;
-    }
-
-    public void setResponseStatus(GrizzlyResponseStatus responseStatus) {
-        this.responseStatus = responseStatus;
-    }
-
-    public GrizzlyResponseFuture getFuture() {
-        return future;
-    }
-
-    public void setFuture(GrizzlyResponseFuture future) {
-        this.future = future;
-    }
-
-    public String getLastRedirectURI() {
-        return lastRedirectURI;
-    }
-
-    public void setLastRedirectURI(String lastRedirectURI) {
-        this.lastRedirectURI = lastRedirectURI;
-    }
-
-    public AtomicLong getTotalBodyWritten() {
-        return totalBodyWritten;
-    }
-
-    public AsyncHandler.STATE getCurrentState() {
-        return currentState;
-    }
-
-    public void setCurrentState(AsyncHandler.STATE currentState) {
-        this.currentState = currentState;
-    }
-
-    public Uri getWsRequestURI() {
-        return wsRequestURI;
-    }
-
-    public void setWsRequestURI(Uri wsRequestURI) {
-        this.wsRequestURI = wsRequestURI;
-    }
-
-    public boolean isWSRequest() {
-        return isWSRequest;
-    }
-
-    public void setWSRequest(boolean WSRequest) {
-        isWSRequest = WSRequest;
-    }
-
-    public HandShake getHandshake() {
-        return handshake;
-    }
-
-    public void setHandshake(HandShake handshake) {
-        this.handshake = handshake;
-    }
-
-    public ProtocolHandler getProtocolHandler() {
-        return protocolHandler;
-    }
-
-    public void setProtocolHandler(ProtocolHandler protocolHandler) {
-        this.protocolHandler = protocolHandler;
-    }
-
-    public WebSocket getWebSocket() {
-        return webSocket;
-    }
-
-    public void setWebSocket(WebSocket webSocket) {
-        this.webSocket = webSocket;
-    }
-
-    private boolean isGracefullyFinishResponseOnClose() {
-        final HttpResponsePacket response = responseStatus.getResponse();
-        return !response.getProcessingState().isKeepAlive() &&
-                !response.isChunked() && response.getContentLength() == -1;
-    }
-    
-    // ------------------------------------------------- Package Private Methods
-
-    public HttpTxContext copy() {
-        final HttpTxContext newContext = new HttpTxContext(provider, future, request, handler);
-        newContext.invocationStatus = invocationStatus;
-        newContext.bodyHandler = bodyHandler;
-        newContext.currentState = currentState;
-        newContext.statusHandler = statusHandler;
-        newContext.lastRedirectURI = lastRedirectURI;
-        newContext.redirectCount.set(redirectCount.get());
-        return newContext;
-    }
-
-    void done() {
-        if (future != null) {
-            future.done();
-        }
-    }
-
-    @SuppressWarnings({ "unchecked" })
-    void result(Object result) {
-        if (future != null) {
-            future.delegate.result(result);
-            future.done();
-        }
-    }
-}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/ProxyAwareConnectorHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/ProxyAwareConnectorHandler.java
deleted file mode 100644
index 6276280be..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/ProxyAwareConnectorHandler.java
+++ /dev/null
@@ -1,134 +0,0 @@
-/*
- * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.ProxyServer;
-import org.asynchttpclient.providers.grizzly.filters.ProxyFilter;
-import org.asynchttpclient.providers.grizzly.filters.TunnelFilter;
-import org.asynchttpclient.uri.Uri;
-import org.glassfish.grizzly.Processor;
-import org.glassfish.grizzly.filterchain.FilterChain;
-import org.glassfish.grizzly.filterchain.FilterChainBuilder;
-import org.glassfish.grizzly.http.HttpClientFilter;
-import org.glassfish.grizzly.nio.transport.TCPNIOConnectorHandler;
-import org.glassfish.grizzly.nio.transport.TCPNIOTransport;
-
-final class ProxyAwareConnectorHandler extends TCPNIOConnectorHandler {
-
-    private FilterChainBuilder nonSecureTemplate;
-    private FilterChainBuilder secureTemplate;
-    private AsyncHttpClientConfig clientConfig;
-    private Uri uri;
-    private ProxyServer proxyServer;
-
-    // ------------------------------------------------------------ Constructors
-
-    private ProxyAwareConnectorHandler(final TCPNIOTransport transport) {
-        super(transport);
-    }
-
-    // ---------------------------------------------------------- Public Methods
-
-    public static Builder builder(final TCPNIOTransport transport) {
-        return new ProxyAwareConnectorHandler.Builder(transport);
-    }
-
-    // ------------------------------------------- Methods from ConnectorHandler
-
-    @Override
-    public Processor getProcessor() {
-        return ((proxyServer != null) ? createProxyFilterChain() : createFilterChain());
-    }
-
-    // --------------------------------------------------------- Private Methods
-
-    private FilterChain createFilterChain() {
-        return Utils.isSecure(uri) ? secureTemplate.build() : nonSecureTemplate.build();
-    }
-
-    private FilterChain createProxyFilterChain() {
-        final FilterChainBuilder builder = FilterChainBuilder.stateless();
-        if (Utils.isSecure(uri)) {
-            builder.addAll(secureTemplate);
-            updateSecureFilterChain(builder);
-        } else {
-            builder.addAll(nonSecureTemplate);
-            updateNonSecureFilterChain(builder);
-        }
-        return builder.build();
-    }
-
-    private void updateSecureFilterChain(final FilterChainBuilder builder) {
-        builder.add(1, new TunnelFilter(proxyServer, uri));
-        final int idx = builder.indexOfType(HttpClientFilter.class);
-        assert (idx != -1);
-        builder.add(idx + 1, new ProxyFilter(proxyServer, clientConfig, true));
-    }
-
-    private void updateNonSecureFilterChain(final FilterChainBuilder builder) {
-        final int idx = builder.indexOfType(HttpClientFilter.class);
-        assert (idx != -1);
-        builder.add(idx + 1, new ProxyFilter(proxyServer, clientConfig, false));
-    }
-
-    // ---------------------------------------------------------- Nested Classes
-
-    public static final class Builder extends TCPNIOConnectorHandler.Builder {
-
-        final ProxyAwareConnectorHandler connectorHandler;
-
-        // -------------------------------------------------------- Constructors
-
-        private Builder(final TCPNIOTransport transport) {
-            connectorHandler = new ProxyAwareConnectorHandler(transport);
-        }
-
-        // ----------------------------------------------------- Builder Methods
-
-        public Builder secureFilterChainTemplate(final FilterChainBuilder secureTemplate) {
-            connectorHandler.secureTemplate = secureTemplate;
-            return this;
-        }
-
-        public Builder nonSecureFilterChainTemplate(final FilterChainBuilder nonSecureTemplate) {
-            connectorHandler.nonSecureTemplate = nonSecureTemplate;
-            return this;
-        }
-
-        public Builder asyncHttpClientConfig(final AsyncHttpClientConfig clientConfig) {
-            connectorHandler.clientConfig = clientConfig;
-            return this;
-        }
-
-        public Builder uri(final Uri uri) {
-            connectorHandler.uri = uri;
-            return this;
-        }
-
-        public Builder proxyServer(final ProxyServer proxyServer) {
-            connectorHandler.proxyServer = proxyServer;
-            return this;
-        }
-
-        @Override
-        public ProxyAwareConnectorHandler build() {
-            assert (connectorHandler.secureTemplate != null);
-            assert (connectorHandler.nonSecureTemplate != null);
-            assert (connectorHandler.clientConfig != null);
-            assert (connectorHandler.uri != null);
-            return connectorHandler;
-        }
-    } // END Builder
-}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/RequestInfoHolder.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/RequestInfoHolder.java
deleted file mode 100644
index 94dfbdbd4..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/RequestInfoHolder.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.Request;
-
-public class RequestInfoHolder {
-
-    private final GrizzlyAsyncHttpProvider provider;
-    private final Request request;
-    private final AsyncHandler handler;
-    private final GrizzlyResponseFuture future;
-    private final HttpTxContext httpTxContext;
-
-    // ------------------------------------------------------------ Constructors
-
-    public RequestInfoHolder(final GrizzlyAsyncHttpProvider provider, final Request request, final AsyncHandler handler,
-            final GrizzlyResponseFuture future, final HttpTxContext httpTxContext) {
-        this.provider = provider;
-        this.request = request;
-        this.handler = handler;
-        this.future = future;
-        this.httpTxContext = httpTxContext;
-    }
-
-    // ---------------------------------------------------------- Public Methods
-
-    public GrizzlyAsyncHttpProvider getProvider() {
-        return provider;
-    }
-
-    public Request getRequest() {
-        return request;
-    }
-
-    public AsyncHandler getHandler() {
-        return handler;
-    }
-
-    public GrizzlyResponseFuture getFuture() {
-        return future;
-    }
-
-    public HttpTxContext getHttpTxContext() {
-        return httpTxContext;
-    }
-}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/TransportCustomizer.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/TransportCustomizer.java
deleted file mode 100644
index 34d5fe43f..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/TransportCustomizer.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.glassfish.grizzly.filterchain.FilterChainBuilder;
-import org.glassfish.grizzly.nio.transport.TCPNIOTransport;
-
-/**
- * This class may be provided as an option to the {@link GrizzlyAsyncHttpProviderConfig}
- * and allows low-level customization of the {@link TCPNIOTransport} beyond the
- * defaults typically used.
- * 
- * @author The Grizzly Team
- * @since 1.7.0
- */
-public interface TransportCustomizer {
-
-    /**
-     * Customizes the configuration of the provided {@link TCPNIOTransport} 
-     * and {@link FilterChainBuilder} instances.
-     * 
-     * @param transport the {@link TCPNIOTransport} instance for this client.
-     * @param filterChainBuilder the {@link FilterChainBuilder} that will
-     *   produce the {@link org.glassfish.grizzly.filterchain.FilterChain} that
-     *   will be used to send/receive data.  The FilterChain will be populated
-     *   with the Filters typically used for processing HTTP client requests.
-     *   These filters should generally be left alone.  But this does allow
-     *   adding additional filters to the chain to add additional features.
-     */
-    void customize(final TCPNIOTransport transport, final FilterChainBuilder filterChainBuilder);
-}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/Utils.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/Utils.java
deleted file mode 100644
index 44e1143a4..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/Utils.java
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.uri.Uri;
-import org.glassfish.grizzly.Connection;
-import org.glassfish.grizzly.Grizzly;
-import org.glassfish.grizzly.attributes.Attribute;
-import org.glassfish.grizzly.attributes.AttributeStorage;
-
-import java.util.concurrent.atomic.AtomicInteger;
-
-public final class Utils {
-
-    private static final Attribute<Boolean> IGNORE = Grizzly.DEFAULT_ATTRIBUTE_BUILDER.createAttribute(Utils.class.getName() + "-IGNORE");
-    private static final Attribute<AtomicInteger> REQUEST_IN_FLIGHT = Grizzly.DEFAULT_ATTRIBUTE_BUILDER.createAttribute(Utils.class
-            .getName() + "-IN-FLIGHT");
-    private static final Attribute<Boolean> SPDY = Grizzly.DEFAULT_ATTRIBUTE_BUILDER.createAttribute(Utils.class.getName()
-            + "-SPDY-CONNECTION");
-
-    // ------------------------------------------------------------ Constructors
-
-    private Utils() {
-    }
-
-    // ---------------------------------------------------------- Public Methods
-
-    public static boolean isSecure(final Uri uri) {
-        final String scheme = uri.getScheme();
-        return ("https".equals(scheme) || "wss".equals(scheme));
-    }
-
-    public static void connectionIgnored(final Connection c, boolean ignored) {
-        if (ignored) {
-            IGNORE.set(c, true);
-        } else {
-            IGNORE.remove(c);
-        }
-    }
-
-    public static boolean isIgnored(final Connection c) {
-        Boolean result = IGNORE.get(c);
-        return (result != null && result);
-    }
-
-    public static void addRequestInFlight(final AttributeStorage storage) {
-        AtomicInteger counter = REQUEST_IN_FLIGHT.get(storage);
-        if (counter == null) {
-            counter = new AtomicInteger(1);
-            REQUEST_IN_FLIGHT.set(storage, counter);
-        } else {
-            counter.incrementAndGet();
-        }
-    }
-
-    public static void removeRequestInFlight(final AttributeStorage storage) {
-        AtomicInteger counter = REQUEST_IN_FLIGHT.get(storage);
-        if (counter != null) {
-            counter.decrementAndGet();
-        }
-    }
-
-    public static int getRequestInFlightCount(final AttributeStorage storage) {
-        AtomicInteger counter = REQUEST_IN_FLIGHT.get(storage);
-        return counter != null ? counter.get() : 0;
-    }
-
-    public static void setSpdyConnection(final Connection c) {
-        SPDY.set(c, Boolean.TRUE);
-    }
-
-    public static boolean isSpdyConnection(final Connection c) {
-        Boolean result = SPDY.get(c);
-        return result != null ? result : false;
-    }
-    
-    static String discoverTestName(final String defaultName) {
-        final StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();
-        final int strackTraceLen = stackTrace.length;
-        
-        if (stackTrace[strackTraceLen - 1].getClassName().contains("surefire")) {
-            for (int i = strackTraceLen - 2; i >= 0; i--) {
-                if (stackTrace[i].getClassName().contains("org.asynchttpclient.async")) {
-                    return "grizzly-kernel-" +
-                            stackTrace[i].getClassName() + "." + stackTrace[i].getMethodName();
-                }
-            }
-        }
-        
-        return defaultName;
-    }    
-}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/BodyGeneratorBodyHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/BodyGeneratorBodyHandler.java
deleted file mode 100644
index 53770d3b4..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/BodyGeneratorBodyHandler.java
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly.bodyhandler;
-
-import org.asynchttpclient.Body;
-import org.asynchttpclient.BodyGenerator;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.providers.grizzly.FeedableBodyGenerator;
-import org.glassfish.grizzly.Buffer;
-import org.glassfish.grizzly.filterchain.FilterChainContext;
-import org.glassfish.grizzly.http.HttpContent;
-import org.glassfish.grizzly.http.HttpRequestPacket;
-import org.glassfish.grizzly.memory.Buffers;
-import org.glassfish.grizzly.memory.MemoryManager;
-
-import java.io.IOException;
-
-public final class BodyGeneratorBodyHandler extends BodyHandler {
-
-    // -------------------------------------------- Methods from BodyHandler
-
-    public boolean handlesBodyType(final Request request) {
-        return (request.getBodyGenerator() != null);
-    }
-
-    @SuppressWarnings({ "unchecked" })
-    public boolean doHandle(final FilterChainContext ctx, final Request request, final HttpRequestPacket requestPacket) throws IOException {
-
-        final BodyGenerator generator = request.getBodyGenerator();
-        final Body bodyLocal = generator.createBody();
-        final long len = bodyLocal.getContentLength();
-        if (len >= 0) {
-            requestPacket.setContentLengthLong(len);
-        } else {
-            requestPacket.setChunked(true);
-        }
-
-        final MemoryManager mm = ctx.getMemoryManager();
-        boolean last = false;
-
-        while (!last) {
-            Buffer buffer = mm.allocate(MAX_CHUNK_SIZE);
-            buffer.allowBufferDispose(true);
-
-            final long readBytes = bodyLocal.read(buffer.toByteBuffer());
-            if (readBytes > 0) {
-                buffer.position((int) readBytes);
-                buffer.trim();
-            } else {
-                buffer.dispose();
-
-                if (readBytes < 0) {
-                    last = true;
-                    buffer = Buffers.EMPTY_BUFFER;
-                } else {
-                    // pass the context to bodyLocal to be able to
-                    // continue body transferring once more data is available
-                    if (generator instanceof FeedableBodyGenerator) {
-                        ((FeedableBodyGenerator) generator).initializeAsynchronousTransfer(ctx, requestPacket);
-                        return false;
-                    } else {
-                        throw new IllegalStateException("BodyGenerator unexpectedly returned 0 bytes available");
-                    }
-                }
-            }
-
-            final HttpContent content = requestPacket.httpContentBuilder().content(buffer).last(last).build();
-            ctx.write(content, ((!requestPacket.isCommitted()) ? ctx.getTransportContext().getCompletionHandler() : null));
-        }
-
-        return true;
-    }
-
-} // END BodyGeneratorBodyHandler
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/BodyHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/BodyHandler.java
deleted file mode 100644
index 2b6e17a32..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/BodyHandler.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly.bodyhandler;
-
-import org.asynchttpclient.Request;
-import org.glassfish.grizzly.filterchain.FilterChainContext;
-import org.glassfish.grizzly.http.HttpRequestPacket;
-
-import java.io.IOException;
-
-public abstract class BodyHandler {
-
-    public static int MAX_CHUNK_SIZE = 8192;
-
-    public abstract boolean handlesBodyType(final Request request);
-
-    public abstract boolean doHandle(final FilterChainContext ctx,
-            final Request request, final HttpRequestPacket requestPacket)
-            throws IOException;
-    
-    /**
-     * Tries to predict request content-length based on the {@link Request}.
-     * Not all the <tt>BodyHandler</tt>s can predict the content-length in advance.
-     * 
-     * @param request
-     * @return the content-length, or <tt>-1</tt> if the content-length can't be
-     * predicted
-     */
-    protected long getContentLength(final Request request) {
-        return request.getContentLength();
-    }
-}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/BodyHandlerFactory.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/BodyHandlerFactory.java
deleted file mode 100644
index 8b5cf4ff6..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/BodyHandlerFactory.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly.bodyhandler;
-
-import org.asynchttpclient.Request;
-import org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider;
-
-public final class BodyHandlerFactory {
-
-    private final BodyHandler[] handlers;
-
-    public BodyHandlerFactory(GrizzlyAsyncHttpProvider grizzlyAsyncHttpProvider) {
-        handlers = new BodyHandler[] {//
-        new StringBodyHandler(grizzlyAsyncHttpProvider),//
-                new ByteArrayBodyHandler(grizzlyAsyncHttpProvider),//
-                new ParamsBodyHandler(grizzlyAsyncHttpProvider),//
-                new StreamDataBodyHandler(),//
-                new PartsBodyHandler(),//
-                new FileBodyHandler(grizzlyAsyncHttpProvider),//
-                new BodyGeneratorBodyHandler() //
-        };
-    }
-
-    public BodyHandler getBodyHandler(final Request request) {
-        for (int i = 0, len = handlers.length; i < len; i++) {
-            final BodyHandler h = handlers[i];
-            if (h.handlesBodyType(request)) {
-                return h;
-            }
-        }
-        
-        return null;
-    }
-
-} // END BodyHandlerFactory
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/ByteArrayBodyHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/ByteArrayBodyHandler.java
deleted file mode 100644
index bd9ddc23a..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/ByteArrayBodyHandler.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly.bodyhandler;
-
-import org.asynchttpclient.Request;
-import org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider;
-import org.glassfish.grizzly.Buffer;
-import org.glassfish.grizzly.filterchain.FilterChainContext;
-import org.glassfish.grizzly.http.HttpContent;
-import org.glassfish.grizzly.http.HttpRequestPacket;
-import org.glassfish.grizzly.memory.Buffers;
-import org.glassfish.grizzly.memory.MemoryManager;
-
-import java.io.IOException;
-
-public final class ByteArrayBodyHandler extends BodyHandler {
-
-    private final boolean compressionEnabled;
-
-    public ByteArrayBodyHandler(
-            final GrizzlyAsyncHttpProvider grizzlyAsyncHttpProvider) {
-        compressionEnabled = grizzlyAsyncHttpProvider.getClientConfig().isCompressionEnforced();
-    }
-
-    // -------------------------------------------- Methods from BodyHandler
-
-    public boolean handlesBodyType(final Request request) {
-        return (request.getByteData() != null);
-    }
-
-    @SuppressWarnings({ "unchecked" })
-    public boolean doHandle(final FilterChainContext ctx, final Request request,
-            final HttpRequestPacket requestPacket) throws IOException {
-
-        final byte[] data = request.getByteData();
-        final MemoryManager mm = ctx.getMemoryManager();
-        final Buffer gBuffer = Buffers.wrap(mm, data);
-        if (requestPacket.getContentLength() == -1) {
-            if (!compressionEnabled) {
-                requestPacket.setContentLengthLong(data.length);
-            }
-        }
-        final HttpContent content = requestPacket.httpContentBuilder().content(gBuffer).build();
-        content.setLast(true);
-        ctx.write(content, ((!requestPacket.isCommitted()) ? ctx.getTransportContext().getCompletionHandler() : null));
-        return true;
-    }
-
-    @Override
-    protected long getContentLength(final Request request) {
-        if (request.getContentLength() >= 0) {
-            return request.getContentLength();
-        }
-        
-        return compressionEnabled ? -1 : request.getByteData().length;
-    }
-}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/ExpectHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/ExpectHandler.java
deleted file mode 100644
index f322aa80d..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/ExpectHandler.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly.bodyhandler;
-
-import org.asynchttpclient.Request;
-import org.glassfish.grizzly.filterchain.FilterChainContext;
-import org.glassfish.grizzly.http.HttpRequestPacket;
-
-import java.io.IOException;
-
-public final class ExpectHandler extends BodyHandler {
-
-    private final BodyHandler delegate;
-    private Request request;
-    private HttpRequestPacket requestPacket;
-
-    // -------------------------------------------------------- Constructors
-
-    public ExpectHandler(final BodyHandler delegate) {
-        this.delegate = delegate;
-    }
-
-    // -------------------------------------------- Methods from BodyHandler
-
-    public boolean handlesBodyType(Request request) {
-        return delegate.handlesBodyType(request);
-    }
-
-    @SuppressWarnings({ "unchecked" })
-    public boolean doHandle(FilterChainContext ctx, Request request, HttpRequestPacket requestPacket) throws IOException {
-        this.request = request;
-        this.requestPacket = requestPacket;
-        
-        // Set content-length if possible
-        final long contentLength = delegate.getContentLength(request);
-        if (contentLength != -1) {
-            requestPacket.setContentLengthLong(contentLength);
-        }
-        
-        ctx.write(requestPacket, ((!requestPacket.isCommitted()) ? ctx.getTransportContext().getCompletionHandler() : null));
-        return true;
-    }
-
-    public void finish(final FilterChainContext ctx) throws IOException {
-        delegate.doHandle(ctx, request, requestPacket);
-    }
-
-} // END ContinueHandler
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/FileBodyHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/FileBodyHandler.java
deleted file mode 100644
index 0bdc2d062..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/FileBodyHandler.java
+++ /dev/null
@@ -1,154 +0,0 @@
-/*
- * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly.bodyhandler;
-
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.listener.TransferCompletionHandler;
-import org.asynchttpclient.providers.grizzly.HttpTxContext;
-import org.glassfish.grizzly.Buffer;
-import org.glassfish.grizzly.EmptyCompletionHandler;
-import org.glassfish.grizzly.FileTransfer;
-import org.glassfish.grizzly.WriteResult;
-import org.glassfish.grizzly.filterchain.FilterChainContext;
-import org.glassfish.grizzly.http.HttpContent;
-import org.glassfish.grizzly.http.HttpRequestPacket;
-import org.glassfish.grizzly.memory.Buffers;
-import org.glassfish.grizzly.memory.MemoryManager;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.util.concurrent.atomic.AtomicInteger;
-import org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider;
-
-public final class FileBodyHandler extends BodyHandler {
-
-    private static final boolean SEND_FILE_SUPPORT;
-    static {
-        SEND_FILE_SUPPORT = configSendFileSupport();
-    }
-
-    private final boolean compressionEnabled;
-
-    public FileBodyHandler(
-            final GrizzlyAsyncHttpProvider grizzlyAsyncHttpProvider) {
-        compressionEnabled = grizzlyAsyncHttpProvider.getClientConfig().isCompressionEnforced();
-    }
-    
-    // ------------------------------------------------ Methods from BodyHandler
-
-    public boolean handlesBodyType(final Request request) {
-        return request.getFile() != null;
-    }
-
-    @SuppressWarnings({ "unchecked" })
-    public boolean doHandle(final FilterChainContext ctx, final Request request, final HttpRequestPacket requestPacket) throws IOException {
-
-        final File f = request.getFile();
-        requestPacket.setContentLengthLong(f.length());
-        final HttpTxContext context = HttpTxContext.get(ctx);
-        if (compressionEnabled || !SEND_FILE_SUPPORT || requestPacket.isSecure()) {
-            final FileInputStream fis = new FileInputStream(request.getFile());
-            final MemoryManager mm = ctx.getMemoryManager();
-            AtomicInteger written = new AtomicInteger();
-            boolean last = false;
-            try {
-                for (byte[] buf = new byte[MAX_CHUNK_SIZE]; !last;) {
-                    Buffer b = null;
-                    int read;
-                    if ((read = fis.read(buf)) < 0) {
-                        last = true;
-                        b = Buffers.EMPTY_BUFFER;
-                    }
-                    if (b != Buffers.EMPTY_BUFFER) {
-                        written.addAndGet(read);
-                        b = Buffers.wrap(mm, buf, 0, read);
-                    }
-
-                    final HttpContent content = requestPacket.httpContentBuilder().content(b).last(last).build();
-                    ctx.write(content, ((!requestPacket.isCommitted()) ? ctx.getTransportContext().getCompletionHandler() : null));
-                }
-            } finally {
-                try {
-                    fis.close();
-                } catch (IOException ignored) {
-                }
-            }
-        } else {
-            // write the headers
-            ctx.write(requestPacket, ((!requestPacket.isCommitted()) ? ctx.getTransportContext().getCompletionHandler() : null));
-            ctx.write(new FileTransfer(f), new EmptyCompletionHandler<WriteResult>() {
-
-                @Override
-                public void updated(WriteResult result) {
-                    notifyHandlerIfNeeded(context, requestPacket, result);
-                }
-
-                @Override
-                public void completed(WriteResult result) {
-                    notifyHandlerIfNeeded(context, requestPacket, result);
-                }
-            });
-        }
-
-        return true;
-    }
-
-    @Override
-    protected long getContentLength(final Request request) {
-        if (request.getContentLength() >= 0) {
-            return request.getContentLength();
-        }
-        
-        return compressionEnabled ? -1 : request.getFile().length();
-    }
-    
-    // --------------------------------------------------------- Private Methods
-
-    private static void notifyHandlerIfNeeded(final HttpTxContext context, final HttpRequestPacket requestPacket,
-            final WriteResult writeResult) {
-        final AsyncHandler handler = context.getHandler();
-        if (handler != null) {
-            if (handler instanceof TransferCompletionHandler) {
-                // WriteResult keeps a track of the total amount written,
-                // so we need to calculate the delta ourselves.
-                final long resultTotal = writeResult.getWrittenSize();
-                final long written = (resultTotal - context.getTotalBodyWritten().get());
-                final long total = context.getTotalBodyWritten().addAndGet(written);
-                ((TransferCompletionHandler) handler).onContentWriteProgress(written, total, requestPacket.getContentLength());
-            }
-        }
-    }
-
-    private static boolean configSendFileSupport() {
-        return !((System.getProperty("os.name").equalsIgnoreCase("linux") && !linuxSendFileSupported()) || System.getProperty("os.name")
-                .equalsIgnoreCase("HP-UX"));
-    }
-
-    private static boolean linuxSendFileSupported() {
-        final String version = System.getProperty("java.version");
-        if (version.startsWith("1.6")) {
-            int idx = version.indexOf('_');
-            if (idx == -1) {
-                return false;
-            }
-            final int patchRev = Integer.parseInt(version.substring(idx + 1));
-            return (patchRev >= 18);
-        } else {
-            return version.startsWith("1.7") || version.startsWith("1.8");
-        }
-    }
-
-} // END FileBodyHandler
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/NoBodyHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/NoBodyHandler.java
deleted file mode 100644
index c3865952b..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/NoBodyHandler.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly.bodyhandler;
-
-import org.asynchttpclient.Request;
-import org.glassfish.grizzly.filterchain.FilterChainContext;
-import org.glassfish.grizzly.http.HttpContent;
-import org.glassfish.grizzly.http.HttpRequestPacket;
-import org.glassfish.grizzly.memory.Buffers;
-
-import java.io.IOException;
-
-public final class NoBodyHandler extends BodyHandler {
-
-    // -------------------------------------------- Methods from BodyHandler
-
-    public boolean handlesBodyType(final Request request) {
-        return false;
-    }
-
-    @SuppressWarnings({ "unchecked" })
-    public boolean doHandle(final FilterChainContext ctx, final Request request, final HttpRequestPacket requestPacket) throws IOException {
-
-        final HttpContent content = requestPacket.httpContentBuilder().content(Buffers.EMPTY_BUFFER).build();
-        content.setLast(true);
-        ctx.write(content, ((!requestPacket.isCommitted()) ? ctx.getTransportContext().getCompletionHandler() : null));
-        return true;
-    }
-
-} // END NoBodyHandler
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/ParamsBodyHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/ParamsBodyHandler.java
deleted file mode 100644
index 32ec96bfa..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/ParamsBodyHandler.java
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly.bodyhandler;
-
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
-
-import org.asynchttpclient.Param;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider;
-import org.glassfish.grizzly.Buffer;
-import org.glassfish.grizzly.filterchain.FilterChainContext;
-import org.glassfish.grizzly.http.HttpContent;
-import org.glassfish.grizzly.http.HttpRequestPacket;
-import org.glassfish.grizzly.memory.Buffers;
-import org.glassfish.grizzly.memory.MemoryManager;
-import org.glassfish.grizzly.utils.Charsets;
-
-import java.io.IOException;
-import java.net.URLEncoder;
-import java.util.List;
-
-public final class ParamsBodyHandler extends BodyHandler {
-
-    private final boolean compressionEnabled;
-
-    public ParamsBodyHandler(GrizzlyAsyncHttpProvider grizzlyAsyncHttpProvider) {
-        compressionEnabled = grizzlyAsyncHttpProvider.getClientConfig().isCompressionEnforced();
-    }
-
-    // -------------------------------------------- Methods from BodyHandler
-
-    public boolean handlesBodyType(final Request request) {
-        final List<Param> params = request.getFormParams();
-        return isNonEmpty(params);
-    }
-
-    @SuppressWarnings({ "unchecked" })
-    public boolean doHandle(final FilterChainContext ctx, final Request request, final HttpRequestPacket requestPacket) throws IOException {
-
-        if (requestPacket.getContentType() == null) {
-            requestPacket.setContentType("application/x-www-form-urlencoded");
-        }
-        StringBuilder sb = null;
-        String charset = request.getBodyEncoding();
-        if (charset == null) {
-            charset = Charsets.ASCII_CHARSET.name();
-        }
-        final List<Param> params = request.getFormParams();
-        if (!params.isEmpty()) {
-            if (sb == null) {
-                sb = new StringBuilder(128);
-            }
-            for (Param param : params) {
-                sb.append(URLEncoder.encode(param.getName(), charset)).append('=').append(URLEncoder.encode(param.getValue(), charset));
-                sb.append('&');
-            }
-            sb.setLength(sb.length() - 1);
-        }
-        if (sb != null) {
-            final byte[] data = sb.toString().getBytes(charset);
-            final MemoryManager mm = ctx.getMemoryManager();
-            final Buffer gBuffer = Buffers.wrap(mm, data);
-            final HttpContent content = requestPacket.httpContentBuilder().content(gBuffer).build();
-            if (requestPacket.getContentLength() == -1) {
-                if (!compressionEnabled) {
-                    requestPacket.setContentLengthLong(data.length);
-                }
-            }
-            content.setLast(true);
-            ctx.write(content, ((!requestPacket.isCommitted()) ? ctx.getTransportContext().getCompletionHandler() : null));
-        }
-        return true;
-    }
-} // END ParamsBodyHandler
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/PartsBodyHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/PartsBodyHandler.java
deleted file mode 100644
index 2c6e50616..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/PartsBodyHandler.java
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
- * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly.bodyhandler;
-
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
-
-import org.asynchttpclient.Body;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.multipart.MultipartBody;
-import org.asynchttpclient.multipart.MultipartUtils;
-import org.asynchttpclient.multipart.Part;
-import org.asynchttpclient.providers.grizzly.FeedableBodyGenerator;
-import org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider;
-import org.glassfish.grizzly.Buffer;
-import org.glassfish.grizzly.filterchain.FilterChainContext;
-import org.glassfish.grizzly.http.HttpRequestPacket;
-import org.glassfish.grizzly.memory.Buffers;
-import org.glassfish.grizzly.memory.MemoryManager;
-
-import java.io.IOException;
-import java.util.List;
-
-public final class PartsBodyHandler extends BodyHandler {
-
-    // -------------------------------------------- Methods from BodyHandler
-
-    public boolean handlesBodyType(final Request request) {
-        return isNonEmpty(request.getParts());
-    }
-
-    public boolean doHandle(final FilterChainContext ctx, final Request request, final HttpRequestPacket requestPacket) throws IOException {
-
-        final List<Part> parts = request.getParts();
-        final MultipartBody multipartBody = MultipartUtils.newMultipartBody(parts, request.getHeaders());
-        requestPacket.setContentLengthLong(multipartBody.getContentLength());
-        requestPacket.setContentType(multipartBody.getContentType());
-        if (GrizzlyAsyncHttpProvider.LOGGER.isDebugEnabled()) {
-            GrizzlyAsyncHttpProvider.LOGGER.debug("REQUEST(modified): contentLength={}, contentType={}",
-                    new Object[] { requestPacket.getContentLength(), requestPacket.getContentType() });
-        }
-
-        final FeedableBodyGenerator generator = new FeedableBodyGenerator() {
-            @Override
-            public Body createBody() throws IOException {
-                return multipartBody;
-            }
-        };
-        generator.setFeeder(new FeedableBodyGenerator.BaseFeeder(generator) {
-            @Override
-            public void flush() throws IOException {
-                final Body bodyLocal = feedableBodyGenerator.createBody();
-                try {
-                    final MemoryManager mm = ctx.getMemoryManager();
-                    boolean last = false;
-                    while (!last) {
-                        Buffer buffer = mm.allocate(BodyHandler.MAX_CHUNK_SIZE);
-                        buffer.allowBufferDispose(true);
-                        final long readBytes = bodyLocal.read(buffer.toByteBuffer());
-                        if (readBytes > 0) {
-                            buffer.position((int) readBytes);
-                            buffer.trim();
-                        } else {
-                            buffer.dispose();
-                            if (readBytes < 0) {
-                                last = true;
-                                buffer = Buffers.EMPTY_BUFFER;
-                            } else {
-                                throw new IllegalStateException("MultipartBody unexpectedly returned 0 bytes available");
-                            }
-                        }
-                        feed(buffer, last);
-                    }
-                } finally {
-                    if (bodyLocal != null) {
-                        try {
-                            bodyLocal.close();
-                        } catch (IOException ignore) {
-                        }
-                    }
-                }
-            }
-        });
-        generator.initializeAsynchronousTransfer(ctx, requestPacket);
-        return false;
-    }
-} // END PartsBodyHandler
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/StreamDataBodyHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/StreamDataBodyHandler.java
deleted file mode 100644
index 79eb60324..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/StreamDataBodyHandler.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly.bodyhandler;
-
-import static org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider.LOGGER;
-
-import org.asynchttpclient.Request;
-import org.glassfish.grizzly.Buffer;
-import org.glassfish.grizzly.filterchain.FilterChainContext;
-import org.glassfish.grizzly.http.HttpContent;
-import org.glassfish.grizzly.http.HttpRequestPacket;
-import org.glassfish.grizzly.memory.MemoryManager;
-
-import java.io.IOException;
-import java.io.InputStream;
-
-public final class StreamDataBodyHandler extends BodyHandler {
-
-    // -------------------------------------------- Methods from BodyHandler
-
-    public boolean handlesBodyType(final Request request) {
-        return (request.getStreamData() != null);
-    }
-
-    @SuppressWarnings({ "unchecked" })
-    public boolean doHandle(final FilterChainContext ctx, final Request request, final HttpRequestPacket requestPacket) throws IOException {
-
-        final MemoryManager mm = ctx.getMemoryManager();
-        Buffer buffer = mm.allocate(512);
-        final byte[] b = new byte[512];
-        int read;
-        final InputStream in = request.getStreamData();
-        try {
-            in.reset();
-        } catch (IOException ioe) {
-            if (LOGGER.isDebugEnabled()) {
-                LOGGER.debug(ioe.toString(), ioe);
-            }
-        }
-        if (in.markSupported()) {
-            in.mark(0);
-        }
-
-        while ((read = in.read(b)) != -1) {
-            if (read > buffer.remaining()) {
-                buffer = mm.reallocate(buffer, buffer.capacity() + 512);
-            }
-            buffer.put(b, 0, read);
-        }
-        buffer.trim();
-        if (buffer.hasRemaining()) {
-            final HttpContent content = requestPacket.httpContentBuilder().content(buffer).build();
-            buffer.allowBufferDispose(false);
-            content.setLast(true);
-            ctx.write(content, ((!requestPacket.isCommitted()) ? ctx.getTransportContext().getCompletionHandler() : null));
-        }
-        return true;
-    }
-} // END StreamDataBodyHandler
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/StringBodyHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/StringBodyHandler.java
deleted file mode 100644
index 30ad9f39a..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/bodyhandler/StringBodyHandler.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly.bodyhandler;
-
-import org.asynchttpclient.Request;
-import org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider;
-import org.glassfish.grizzly.Buffer;
-import org.glassfish.grizzly.filterchain.FilterChainContext;
-import org.glassfish.grizzly.http.HttpContent;
-import org.glassfish.grizzly.http.HttpRequestPacket;
-import org.glassfish.grizzly.memory.Buffers;
-import org.glassfish.grizzly.memory.MemoryManager;
-import org.glassfish.grizzly.utils.Charsets;
-
-import java.io.IOException;
-
-public final class StringBodyHandler extends BodyHandler {
-    private final GrizzlyAsyncHttpProvider grizzlyAsyncHttpProvider;
-
-    public StringBodyHandler(GrizzlyAsyncHttpProvider grizzlyAsyncHttpProvider) {
-        this.grizzlyAsyncHttpProvider = grizzlyAsyncHttpProvider;
-    }
-
-    // -------------------------------------------- Methods from BodyHandler
-
-    public boolean handlesBodyType(final Request request) {
-        return (request.getStringData() != null);
-    }
-
-    @SuppressWarnings({ "unchecked" })
-    public boolean doHandle(final FilterChainContext ctx, final Request request, final HttpRequestPacket requestPacket) throws IOException {
-
-        String charset = request.getBodyEncoding();
-        if (charset == null) {
-            charset = Charsets.ASCII_CHARSET.name();
-        }
-        final byte[] data = request.getStringData().getBytes(charset);
-        final MemoryManager mm = ctx.getMemoryManager();
-        final Buffer gBuffer = Buffers.wrap(mm, data);
-        if (requestPacket.getContentLength() == -1) {
-            if (!grizzlyAsyncHttpProvider.getClientConfig().isCompressionEnforced()) {
-                requestPacket.setContentLengthLong(data.length);
-            }
-        }
-        final HttpContent content = requestPacket.httpContentBuilder().content(gBuffer).build();
-        content.setLast(true);
-        ctx.write(content, ((!requestPacket.isCommitted()) ? ctx.getTransportContext().getCompletionHandler() : null));
-        return true;
-    }
-} // END StringBodyHandler
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/AsyncHttpClientEventFilter.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/AsyncHttpClientEventFilter.java
deleted file mode 100644
index 687984e6a..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/AsyncHttpClientEventFilter.java
+++ /dev/null
@@ -1,131 +0,0 @@
-/*
- * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly.filters;
-
-import org.asynchttpclient.providers.grizzly.EventHandler;
-import org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider;
-import org.glassfish.grizzly.filterchain.FilterChainContext;
-import org.glassfish.grizzly.http.HttpClientFilter;
-import org.glassfish.grizzly.http.HttpContent;
-import org.glassfish.grizzly.http.HttpHeader;
-
-import java.io.IOException;
-import org.asynchttpclient.providers.grizzly.filters.events.GracefulCloseEvent;
-import org.glassfish.grizzly.Buffer;
-import org.glassfish.grizzly.filterchain.FilterChainEvent;
-import org.glassfish.grizzly.filterchain.NextAction;
-import org.glassfish.grizzly.http.HttpResponsePacket;
-
-/**
- * Extension of the {@link HttpClientFilter} that is responsible for handling
- * events triggered by the parsing and serialization of HTTP packets.
- *
- * @since 2.0
- * @author The Grizzly Team
- */
-public final class AsyncHttpClientEventFilter extends HttpClientFilter implements GrizzlyAsyncHttpProvider.Cleanup {
-
-    private final EventHandler eventHandler;
-
-    // -------------------------------------------------------- Constructors
-
-    public AsyncHttpClientEventFilter(final EventHandler eventHandler) {
-        this(eventHandler, DEFAULT_MAX_HTTP_PACKET_HEADER_SIZE);
-    }
-
-    public AsyncHttpClientEventFilter(final EventHandler eventHandler, final int maxHeaderSize) {
-
-        super(maxHeaderSize);
-        this.eventHandler = eventHandler;
-    }
-
-    @Override
-    public NextAction handleEvent(final FilterChainContext ctx,
-            final FilterChainEvent event) throws IOException {
-        if (event.type() == GracefulCloseEvent.class) {
-            // Connection was closed.
-            // This event is fired only for responses, which don't have
-            // associated transfer-encoding or content-length.
-            // We have to complete such a request-response processing gracefully.
-            final GracefulCloseEvent closeEvent = (GracefulCloseEvent) event;
-            final HttpResponsePacket response = closeEvent.getHttpTxContext()
-                    .getResponseStatus().getResponse();
-            response.getProcessingState().getHttpContext().attach(ctx);
-            
-            onHttpPacketParsed(response, ctx);
-            
-            return ctx.getStopAction();
-        }
-        
-        return ctx.getInvokeAction();
-    }
-
-    
-    @Override
-    public void exceptionOccurred(FilterChainContext ctx, Throwable error) {
-        eventHandler.exceptionOccurred(ctx, error);
-    }
-
-    @Override
-    protected void onHttpContentParsed(HttpContent content, FilterChainContext ctx) {
-        eventHandler.onHttpContentParsed(content, ctx);
-    }
-
-    @Override
-    protected void onHttpHeadersEncoded(HttpHeader httpHeader, FilterChainContext ctx) {
-        eventHandler.onHttpHeadersEncoded(httpHeader, ctx);
-    }
-
-    @Override
-    protected void onHttpContentEncoded(HttpContent content, FilterChainContext ctx) {
-        eventHandler.onHttpContentEncoded(content, ctx);
-    }
-
-    @Override
-    protected void onInitialLineParsed(HttpHeader httpHeader, FilterChainContext ctx) {
-        eventHandler.onInitialLineParsed(httpHeader, ctx);
-    }
-
-    @Override
-    protected void onHttpHeaderError(HttpHeader httpHeader, FilterChainContext ctx, Throwable t) throws IOException {
-        eventHandler.onHttpHeaderError(httpHeader, ctx, t);
-    }
-
-    @Override
-    protected void onHttpContentError(HttpHeader httpHeader, FilterChainContext ctx, Throwable t) throws IOException {
-        eventHandler.onHttpContentError(httpHeader, ctx, t);
-    }
-
-    @Override
-    protected void onHttpHeadersParsed(HttpHeader httpHeader, FilterChainContext ctx) {
-        eventHandler.onHttpHeadersParsed(httpHeader, ctx);
-    }
-
-    @Override
-    protected boolean onHttpHeaderParsed(final HttpHeader httpHeader,
-            final Buffer buffer, final FilterChainContext ctx) {
-        super.onHttpHeaderParsed(httpHeader, buffer, ctx);
-        return eventHandler.onHttpHeaderParsed(httpHeader, buffer, ctx);
-    }
-    
-    @Override
-    protected boolean onHttpPacketParsed(HttpHeader httpHeader, FilterChainContext ctx) {
-        return eventHandler.onHttpPacketParsed(httpHeader, ctx);
-    }
-
-    @Override
-    public void cleanup(final FilterChainContext ctx) {
-        clearResponse(ctx.getConnection());
-    }
-}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/AsyncHttpClientFilter.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/AsyncHttpClientFilter.java
deleted file mode 100644
index 5159ed6c8..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/AsyncHttpClientFilter.java
+++ /dev/null
@@ -1,567 +0,0 @@
-/*
- * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly.filters;
-
-import static org.asynchttpclient.providers.grizzly.filters.SwitchingSSLFilter.getHandshakeError;
-import static org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider.NTLM_ENGINE;
-import static org.asynchttpclient.util.AsyncHttpProviderUtils.getAuthority;
-import static org.asynchttpclient.util.AsyncHttpProviderUtils.getNonEmptyPath;
-import static org.asynchttpclient.util.AuthenticatorUtils.computeBasicAuthentication;
-import static org.asynchttpclient.util.AuthenticatorUtils.computeDigestAuthentication;
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
-
-import org.asynchttpclient.AsyncCompletionHandler;
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
-import org.asynchttpclient.ProxyServer;
-import org.asynchttpclient.Realm;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.RequestBuilder;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.UpgradeHandler;
-import org.asynchttpclient.cookie.Cookie;
-import org.asynchttpclient.listener.TransferCompletionHandler;
-import org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider;
-import org.asynchttpclient.providers.grizzly.GrizzlyResponseFuture;
-import org.asynchttpclient.providers.grizzly.HttpTxContext;
-import org.asynchttpclient.providers.grizzly.RequestInfoHolder;
-import org.asynchttpclient.providers.grizzly.Utils;
-import org.asynchttpclient.providers.grizzly.bodyhandler.BodyHandler;
-import org.asynchttpclient.providers.grizzly.bodyhandler.BodyHandlerFactory;
-import org.asynchttpclient.providers.grizzly.bodyhandler.ExpectHandler;
-import org.asynchttpclient.providers.grizzly.filters.events.ContinueEvent;
-import org.asynchttpclient.providers.grizzly.filters.events.SSLSwitchingEvent;
-import org.asynchttpclient.providers.grizzly.filters.events.TunnelRequestEvent;
-import org.asynchttpclient.uri.Uri;
-import org.glassfish.grizzly.Buffer;
-import org.glassfish.grizzly.Connection;
-import org.glassfish.grizzly.Grizzly;
-import org.glassfish.grizzly.attributes.Attribute;
-import org.glassfish.grizzly.filterchain.BaseFilter;
-import org.glassfish.grizzly.filterchain.FilterChain;
-import org.glassfish.grizzly.filterchain.FilterChainContext;
-import org.glassfish.grizzly.filterchain.FilterChainEvent;
-import org.glassfish.grizzly.filterchain.NextAction;
-import org.glassfish.grizzly.http.HttpContent;
-import org.glassfish.grizzly.http.HttpContext;
-import org.glassfish.grizzly.http.HttpRequestPacket;
-import org.glassfish.grizzly.http.HttpResponsePacket;
-import org.glassfish.grizzly.http.Method;
-import org.glassfish.grizzly.http.ProcessingState;
-import org.glassfish.grizzly.http.Protocol;
-import org.glassfish.grizzly.http.util.CookieSerializerUtils;
-import org.glassfish.grizzly.http.util.Header;
-import org.glassfish.grizzly.http.util.MimeHeaders;
-import org.glassfish.grizzly.impl.SafeFutureImpl;
-import org.glassfish.grizzly.spdy.SpdySession;
-import org.glassfish.grizzly.spdy.SpdyStream;
-import org.glassfish.grizzly.ssl.SSLConnectionContext;
-import org.glassfish.grizzly.ssl.SSLUtils;
-import org.glassfish.grizzly.websockets.Version;
-import org.slf4j.Logger;
-
-import java.io.IOException;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.util.Collection;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.ConcurrentLinkedQueue;
-import java.util.concurrent.locks.Lock;
-
-/**
- * This {@link org.glassfish.grizzly.filterchain.Filter} is typically the last in the {@FilterChain}. Its primary responsibility is converting the async-http-client
- * {@link Request} into a Grizzly {@link HttpRequestPacket}.
- * 
- * @since 1.7
- * @author The Grizzly Team
- */
-public final class AsyncHttpClientFilter extends BaseFilter {
-
-    private ConcurrentLinkedQueue<HttpRequestPacketImpl> requestCache = new ConcurrentLinkedQueue<HttpRequestPacketImpl>();
-    private final Logger logger;
-
-    private final AsyncHttpClientConfig config;
-    private final GrizzlyAsyncHttpProvider grizzlyAsyncHttpProvider;
-    private final BodyHandlerFactory bodyHandlerFactory;
-
-    private static final Attribute<Boolean> PROXY_AUTH_FAILURE = Grizzly.DEFAULT_ATTRIBUTE_BUILDER
-            .createAttribute(AsyncHttpClientFilter.class.getName() + "-PROXY-AUTH_FAILURE");
-
-    // -------------------------------------------------------- Constructors
-
-    public AsyncHttpClientFilter(GrizzlyAsyncHttpProvider grizzlyAsyncHttpProvider, final AsyncHttpClientConfig config) {
-        this.grizzlyAsyncHttpProvider = grizzlyAsyncHttpProvider;
-        this.config = config;
-        bodyHandlerFactory = new BodyHandlerFactory(grizzlyAsyncHttpProvider);
-        logger = GrizzlyAsyncHttpProvider.LOGGER;
-    }
-
-    // --------------------------------------------- Methods from BaseFilter
-
-    @Override
-    public NextAction handleRead(final FilterChainContext ctx) throws IOException {
-        final HttpContent httpContent = ctx.getMessage();
-        if (httpContent.isLast()) {
-            // Perform the cleanup logic if it's the last chunk of the payload
-            final HttpResponsePacket response = (HttpResponsePacket) httpContent.getHttpHeader();
-
-            recycleRequestResponsePackets(ctx.getConnection(), response);
-            return ctx.getStopAction();
-        }
-
-        return ctx.getInvokeAction();
-    }
-
-    @Override
-    public NextAction handleWrite(final FilterChainContext ctx) throws IOException {
-
-        Object message = ctx.getMessage();
-        if (message instanceof RequestInfoHolder) {
-            ctx.setMessage(null);
-            if (!sendAsGrizzlyRequest((RequestInfoHolder) message, ctx)) {
-                return ctx.getSuspendAction();
-            }
-        } else if (message instanceof Buffer) {
-            return ctx.getInvokeAction();
-        }
-
-        return ctx.getStopAction();
-    }
-
-    @SuppressWarnings("unchecked")
-    @Override
-    public NextAction handleEvent(final FilterChainContext ctx, final FilterChainEvent event) throws IOException {
-
-        final Object type = event.type();
-        if (type == ContinueEvent.class) {
-            final ContinueEvent continueEvent = (ContinueEvent) event;
-            ((ExpectHandler) continueEvent.getContext().getBodyHandler()).finish(ctx);
-        } else if (type == TunnelRequestEvent.class) {
-            // Disable SSL for the time being...
-            ctx.notifyDownstream(new SSLSwitchingEvent(false, ctx.getConnection()));
-            ctx.suspend();
-            TunnelRequestEvent tunnelRequestEvent = (TunnelRequestEvent) event;
-            final ProxyServer proxyServer = tunnelRequestEvent.getProxyServer();
-            final Uri requestUri = tunnelRequestEvent.getUri();
-
-            RequestBuilder builder = new RequestBuilder();
-            builder.setMethod(Method.CONNECT.getMethodString());
-            builder.setUrl("http://" + getAuthority(requestUri));
-            Request request = builder.build();
-
-            AsyncHandler handler = new AsyncCompletionHandler() {
-                @Override
-                public Object onCompleted(Response response) throws Exception {
-                    if (response.getStatusCode() != 200) {
-                        PROXY_AUTH_FAILURE.set(ctx.getConnection(), Boolean.TRUE);
-                    }
-                    ctx.notifyDownstream(new SSLSwitchingEvent(true, ctx.getConnection()));
-                    ctx.notifyDownstream(event);
-                    return response;
-                }
-            };
-            final GrizzlyResponseFuture future = new GrizzlyResponseFuture(grizzlyAsyncHttpProvider, request, handler, proxyServer);
-            future.setDelegate(SafeFutureImpl.create());
-
-            grizzlyAsyncHttpProvider.execute(ctx.getConnection(), request, handler, future, HttpTxContext.get(ctx));
-            return ctx.getSuspendAction();
-        }
-
-        return ctx.getStopAction();
-    }
-
-    // ----------------------------------------------------- Private Methods
-
-    private static void recycleRequestResponsePackets(final Connection c, final HttpResponsePacket response) {
-        if (!Utils.isSpdyConnection(c)) {
-            HttpRequestPacket request = response.getRequest();
-            request.setExpectContent(false);
-            response.recycle();
-            request.recycle();
-        }
-    }
-
-    private boolean sendAsGrizzlyRequest(
-            final RequestInfoHolder requestInfoHolder,
-            final FilterChainContext ctx) throws IOException {
-
-        HttpTxContext httpTxContext = requestInfoHolder.getHttpTxContext();
-        if (httpTxContext == null) {
-            httpTxContext = HttpTxContext.create(requestInfoHolder);
-        }
-
-        if (checkProxyAuthFailure(ctx, httpTxContext)) {
-            return true;
-        }
-
-        final Request request = httpTxContext.getRequest();
-        final Uri uri = request.getUri();
-        boolean secure = Utils.isSecure(uri);
-        boolean isWebSocket = isWSRequest(httpTxContext.getRequestUri());
-
-        // If the request is secure, check to see if an error occurred during
-        // the handshake. We have to do this here, as the error would occur
-        // out of the scope of a HttpTxContext so there would be
-        // no good way to communicate the problem to the caller.
-        if (secure && checkHandshakeError(ctx, httpTxContext)) {
-            return true;
-        }
-
-        
-        if (isUpgradeRequest(httpTxContext.getHandler()) && isWebSocket) {
-            httpTxContext.setWSRequest(true);
-            convertToUpgradeRequest(httpTxContext);
-        }
-
-        HttpRequestPacket requestPacket = requestCache.poll();
-        if (requestPacket == null) {
-            requestPacket = new HttpRequestPacketImpl();
-        }
-        
-        final Method method = Method.valueOf(request.getMethod());
-        
-        requestPacket.setMethod(method);
-        requestPacket.setProtocol(Protocol.HTTP_1_1);
-
-        // Special handling for CONNECT.
-        if (method == Method.CONNECT) {
-            final int port = uri.getPort();
-            requestPacket.setRequestURI(uri.getHost() + ':' + (port == -1 ? 443 : port));
-        } else if ((secure || isWebSocket) && config.isUseRelativeURIsWithConnectProxies()) {
-            requestPacket.setRequestURI(getNonEmptyPath(uri));
-        } else {
-            requestPacket.setRequestURI(uri.toUrl());
-        }
-
-        final BodyHandler bodyHandler = isPayloadAllowed(method) ?
-                bodyHandlerFactory.getBodyHandler(request) :
-                null;
-        
-        if (bodyHandler != null) {
-            final long contentLength = request.getContentLength();
-            if (contentLength >= 0) {
-                requestPacket.setContentLengthLong(contentLength);
-                requestPacket.setChunked(false);
-            } else {
-                requestPacket.setChunked(true);
-            }
-        }
-
-        if (httpTxContext.isWSRequest()) {
-            try {
-                final URI wsURI = httpTxContext.getWsRequestURI().toJavaNetURI();
-                httpTxContext.setProtocolHandler(Version.RFC6455.createHandler(true));
-                httpTxContext.setHandshake(httpTxContext.getProtocolHandler().createHandShake(wsURI));
-                requestPacket = (HttpRequestPacket) httpTxContext.getHandshake().composeHeaders().getHttpHeader();
-            } catch (URISyntaxException e) {
-                throw new IllegalArgumentException("Invalid WS URI: " + httpTxContext.getWsRequestURI());
-            }
-        }
-
-        requestPacket.setSecure(secure);
-        addQueryString(request, requestPacket);
-        addHostHeader(request, uri, requestPacket);
-        addGeneralHeaders(request, requestPacket);
-        addCookies(request, requestPacket);
-        addAuthorizationHeader(request, requestPacket);
-
-        initTransferCompletionHandler(request, httpTxContext.getHandler());
-
-        final HttpRequestPacket requestPacketLocal = requestPacket;
-        FilterChainContext sendingCtx = ctx;
-
-        if (secure) {
-            // Check to see if the ProtocolNegotiator has given
-            // us a different FilterChain to use. If so, we need
-            // use a different FilterChainContext when invoking sendRequest().
-            sendingCtx = checkAndHandleFilterChainUpdate(ctx, sendingCtx);
-        }
-        final Connection c = ctx.getConnection();
-        final HttpContext httpCtx;
-        if (!Utils.isSpdyConnection(c)) {
-            httpCtx = HttpContext.newInstance(c, c, c, requestPacketLocal);
-        } else {
-            SpdySession session = SpdySession.get(c);
-            final Lock lock = session.getNewClientStreamLock();
-            try {
-                lock.lock();
-                SpdyStream stream = session.openStream(requestPacketLocal, session.getNextLocalStreamId(), 0, 0, 0, false,
-                        !requestPacketLocal.isExpectContent());
-                httpCtx = HttpContext.newInstance(stream, stream, stream, requestPacketLocal);
-            } finally {
-                lock.unlock();
-            }
-        }
-        httpCtx.attach(ctx);
-        HttpTxContext.set(ctx, httpTxContext);
-        requestPacketLocal.getProcessingState().setHttpContext(httpCtx);
-        requestPacketLocal.setConnection(c);
-        
-        return sendRequest(sendingCtx, request, requestPacketLocal,
-                wrapWithExpectHandlerIfNeeded(bodyHandler, requestPacket));
-    }
-
-    @SuppressWarnings("unchecked")
-    public boolean sendRequest(final FilterChainContext ctx,
-            final Request request, final HttpRequestPacket requestPacket,
-            final BodyHandler bodyHandler)
-            throws IOException {
-
-        boolean isWriteComplete = true;
-
-        if (bodyHandler != null) {
-            final HttpTxContext context = HttpTxContext.get(ctx);
-            context.setBodyHandler(bodyHandler);
-            if (logger.isDebugEnabled()) {
-                logger.debug("REQUEST: {}", requestPacket);
-            }
-            isWriteComplete = bodyHandler.doHandle(ctx, request, requestPacket);
-        } else {
-            HttpContent content = HttpContent.builder(requestPacket).last(true).build();
-            if (logger.isDebugEnabled()) {
-                logger.debug("REQUEST: {}", requestPacket);
-            }
-            ctx.write(content, ctx.getTransportContext().getCompletionHandler());
-        }
-
-        return isWriteComplete;
-    }
-
-    private static FilterChainContext checkAndHandleFilterChainUpdate(final FilterChainContext ctx, final FilterChainContext sendingCtx) {
-        FilterChainContext ctxLocal = sendingCtx;
-        SSLConnectionContext sslCtx = SSLUtils.getSslConnectionContext(ctx.getConnection());
-        if (sslCtx != null) {
-            FilterChain fc = sslCtx.getNewConnectionFilterChain();
-
-            if (fc != null) {
-                // Create a new FilterChain context using the new
-                // FilterChain.
-                // TODO: We need to mark this connection somehow
-                // as being only suitable for this type of
-                // request.
-                ctxLocal = obtainProtocolChainContext(ctx, fc);
-            }
-        }
-        return ctxLocal;
-    }
-
-    /**
-     * check if we need to wrap the BodyHandler with ExpectHandler
-     */
-    private static BodyHandler wrapWithExpectHandlerIfNeeded(
-            final BodyHandler bodyHandler,
-            final HttpRequestPacket requestPacket) {
-
-        if (bodyHandler == null) {
-            return null;
-        }
-
-        // check if we need to wrap the BodyHandler with ExpectHandler
-        final MimeHeaders headers = requestPacket.getHeaders();
-        final int expectHeaderIdx = headers.indexOf(Header.Expect, 0);
-
-        return expectHeaderIdx != -1
-                && headers.getValue(expectHeaderIdx).equalsIgnoreCase("100-Continue")
-                ? new ExpectHandler(bodyHandler)
-                : bodyHandler;
-    }
-        
-    private static boolean isPayloadAllowed(final Method method) {
-        return method.getPayloadExpectation() != Method.PayloadExpectation.NOT_ALLOWED;
-    }
-    
-    private static void initTransferCompletionHandler(final Request request, final AsyncHandler h) throws IOException {
-        if (h instanceof TransferCompletionHandler) {
-            final FluentCaseInsensitiveStringsMap map = new FluentCaseInsensitiveStringsMap(request.getHeaders());
-            TransferCompletionHandler.class.cast(h).headers(map);
-        }
-    }
-
-    private static boolean checkHandshakeError(final FilterChainContext ctx, final HttpTxContext httpCtx) {
-        Throwable t = getHandshakeError(ctx.getConnection());
-        if (t != null) {
-            httpCtx.abort(t);
-            return true;
-        }
-        return false;
-    }
-
-    private static boolean checkProxyAuthFailure(final FilterChainContext ctx, final HttpTxContext httpCtx) {
-        final Boolean failed = PROXY_AUTH_FAILURE.get(ctx.getConnection());
-        if (failed != null && failed) {
-            httpCtx.abort(new IllegalStateException("Unable to authenticate with proxy"));
-            return true;
-        }
-        return false;
-    }
-
-    private static FilterChainContext obtainProtocolChainContext(final FilterChainContext ctx, final FilterChain completeProtocolFilterChain) {
-
-        final FilterChainContext newFilterChainContext = completeProtocolFilterChain.obtainFilterChainContext(ctx.getConnection(),
-                ctx.getStartIdx() + 1, completeProtocolFilterChain.size(), ctx.getFilterIdx() + 1);
-
-        newFilterChainContext.setAddressHolder(ctx.getAddressHolder());
-        newFilterChainContext.setMessage(ctx.getMessage());
-        newFilterChainContext.getInternalContext().setIoEvent(ctx.getInternalContext().getIoEvent());
-        ctx.getConnection().setProcessor(completeProtocolFilterChain);
-        return newFilterChainContext;
-    }
-
-    private static void addHostHeader(final Request request,
-            final Uri uri, final HttpRequestPacket requestPacket) {
-        if (!request.getHeaders().containsKey(Header.Host.toString())) {
-            String host = request.getVirtualHost();
-            if (host != null) {
-                requestPacket.addHeader(Header.Host, host);
-            } else {
-                if (uri.getPort() == -1) {
-                    requestPacket.addHeader(Header.Host, uri.getHost());
-                } else {
-                    requestPacket.addHeader(Header.Host, uri.getHost() + ':' + uri.getPort());
-                }
-            }
-        }
-    }
-
-    private void addAuthorizationHeader(final Request request, final HttpRequestPacket requestPacket) {
-        Realm realm = request.getRealm();
-        if (realm == null) {
-            realm = config.getRealm();
-        }
-        if (realm != null && realm.getUsePreemptiveAuth()) {
-            final String authHeaderValue = generateAuthHeader(realm);
-            if (authHeaderValue != null) {
-                requestPacket.addHeader(Header.Authorization, authHeaderValue);
-            }
-        }
-    }
-
-    private String generateAuthHeader(final Realm realm) {
-        try {
-            switch (realm.getAuthScheme()) {
-            case BASIC:
-                return computeBasicAuthentication(realm);
-            case DIGEST:
-                return computeDigestAuthentication(realm);
-            case NTLM:
-                return NTLM_ENGINE.generateType1Msg("NTLM " + realm.getNtlmDomain(), realm.getNtlmHost());
-            default:
-                return null;
-            }
-        } catch (Exception e) {
-            throw new RuntimeException(e);
-        }
-    }
-
-    private static boolean isUpgradeRequest(final AsyncHandler handler) {
-        return (handler instanceof UpgradeHandler);
-    }
-
-    private static boolean isWSRequest(final Uri requestUri) {
-        return requestUri.getScheme().startsWith("ws");
-    }
-
-    private static void convertToUpgradeRequest(final HttpTxContext ctx) {
-        
-        final Uri requestUri = ctx.getRequestUri();
-
-        ctx.setWsRequestURI(requestUri);
-        ctx.setRequestUri(requestUri.withNewScheme(
-                "ws".equals(requestUri.getScheme())
-                        ? "http"
-                        : "https"));
-    }
-
-    private void addGeneralHeaders(final Request request, final HttpRequestPacket requestPacket) {
-
-        if (isNonEmpty(request.getHeaders())) {
-            final FluentCaseInsensitiveStringsMap map = request.getHeaders();
-            for (final Map.Entry<String, List<String>> entry : map.entrySet()) {
-                final String headerName = entry.getKey();
-                final List<String> headerValues = entry.getValue();
-                if (isNonEmpty(headerValues)) {
-                    for (int i = 0, len = headerValues.size(); i < len; i++) {
-                        requestPacket.addHeader(headerName, headerValues.get(i));
-                    }
-                }
-            }
-        }
-
-        final MimeHeaders headers = requestPacket.getHeaders();
-        if (!headers.contains(Header.Connection)) {
-            // final boolean canCache = context.provider.clientConfig.getAllowPoolingConnection();
-            requestPacket.addHeader(Header.Connection, /* (canCache ? */"keep-alive" /* : "close") */);
-        }
-
-        if (!headers.contains(Header.Accept)) {
-            requestPacket.addHeader(Header.Accept, "*/*");
-        }
-
-        if (!headers.contains(Header.UserAgent)) {
-            requestPacket.addHeader(Header.UserAgent, config.getUserAgent());
-        }
-    }
-
-    private void addCookies(final Request request, final HttpRequestPacket requestPacket) {
-
-        final Collection<Cookie> cookies = request.getCookies();
-        if (isNonEmpty(cookies)) {
-            StringBuilder sb = new StringBuilder(128);
-            org.glassfish.grizzly.http.Cookie[] gCookies = new org.glassfish.grizzly.http.Cookie[cookies.size()];
-            convertCookies(cookies, gCookies);
-            CookieSerializerUtils.serializeClientCookies(sb, false, true, gCookies);
-            requestPacket.addHeader(Header.Cookie, sb.toString());
-        }
-    }
-
-    private static void convertCookies(final Collection<Cookie> cookies,
-            final org.glassfish.grizzly.http.Cookie[] gCookies) {
-        int idx = 0;
-        if (!cookies.isEmpty()) {
-            for (final Cookie cookie : cookies) {
-                gCookies[idx++] = new org.glassfish.grizzly.http.Cookie(
-                        cookie.getName(), cookie.getValue());
-            }
-        }
-    }
-
-    private static void addQueryString(final Request request, final HttpRequestPacket requestPacket) {
-
-        String query = request.getUri().getQuery();
-        if (isNonEmpty(query)) {
-            requestPacket.setQueryString(query);
-        }
-    }
-
-    class HttpRequestPacketImpl extends HttpRequestPacket {
-
-        private ProcessingState processingState = new ProcessingState();
-
-        // -------------------------------------- Methods from HttpRequestPacketImpl
-
-        @Override
-        public ProcessingState getProcessingState() {
-            return processingState;
-        }
-
-        @Override
-        public void recycle() {
-            super.recycle();
-            processingState.recycle();
-            requestCache.add(this);
-        }
-    }
-}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/AsyncSpdyClientEventFilter.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/AsyncSpdyClientEventFilter.java
deleted file mode 100644
index 758c6e778..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/AsyncSpdyClientEventFilter.java
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly.filters;
-
-import org.asynchttpclient.providers.grizzly.EventHandler;
-import org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider;
-import org.glassfish.grizzly.filterchain.FilterChainContext;
-import org.glassfish.grizzly.http.HttpContent;
-import org.glassfish.grizzly.http.HttpHeader;
-import org.glassfish.grizzly.spdy.SpdyHandlerFilter;
-import org.glassfish.grizzly.spdy.SpdyMode;
-
-import java.io.IOException;
-import java.util.concurrent.ExecutorService;
-
-/**
- * Extension of the {@link SpdyHandlerFilter} that is responsible for handling
- * events triggered by the parsing and serialization of HTTP packets.
- *
- * @since 2.0
- * @author The Grizzly Team
- */
-public final class AsyncSpdyClientEventFilter extends SpdyHandlerFilter implements GrizzlyAsyncHttpProvider.Cleanup {
-
-    private final EventHandler eventHandler;
-
-    // -------------------------------------------------------- Constructors
-
-    public AsyncSpdyClientEventFilter(final EventHandler eventHandler, SpdyMode mode, ExecutorService threadPool) {
-        super(mode, threadPool);
-        this.eventHandler = eventHandler;
-    }
-
-    @Override
-    public void exceptionOccurred(FilterChainContext ctx, Throwable error) {
-        eventHandler.exceptionOccurred(ctx, error);
-    }
-
-    @Override
-    protected void onHttpContentParsed(HttpContent content, FilterChainContext ctx) {
-        eventHandler.onHttpContentParsed(content, ctx);
-    }
-
-    @Override
-    protected void onHttpHeadersEncoded(HttpHeader httpHeader, FilterChainContext ctx) {
-        eventHandler.onHttpHeadersEncoded(httpHeader, ctx);
-    }
-
-    @Override
-    protected void onHttpContentEncoded(HttpContent content, FilterChainContext ctx) {
-        eventHandler.onHttpContentEncoded(content, ctx);
-    }
-
-    @Override
-    protected void onInitialLineParsed(HttpHeader httpHeader, FilterChainContext ctx) {
-        eventHandler.onInitialLineParsed(httpHeader, ctx);
-    }
-
-    @Override
-    protected void onHttpHeaderError(HttpHeader httpHeader, FilterChainContext ctx, Throwable t) throws IOException {
-        eventHandler.onHttpHeaderError(httpHeader, ctx, t);
-    }
-
-    @Override
-    protected void onHttpContentError(HttpHeader httpHeader, FilterChainContext ctx, Throwable t) throws IOException {
-        eventHandler.onHttpContentError(httpHeader, ctx, t);
-    }
-
-
-    @Override
-    protected void onHttpHeadersParsed(HttpHeader httpHeader, FilterChainContext ctx) {
-        eventHandler.onHttpHeadersParsed(httpHeader, ctx);
-    }
-
-    @Override
-    protected boolean onHttpPacketParsed(HttpHeader httpHeader, FilterChainContext ctx) {
-        return eventHandler.onHttpPacketParsed(httpHeader, ctx);
-    }
-
-    @Override
-    public void cleanup(FilterChainContext ctx) {
-
-    }
-}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/ClientEncodingFilter.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/ClientEncodingFilter.java
deleted file mode 100644
index b3d7fa643..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/ClientEncodingFilter.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly.filters;
-
-import org.glassfish.grizzly.http.EncodingFilter;
-import org.glassfish.grizzly.http.HttpHeader;
-import org.glassfish.grizzly.http.HttpResponsePacket;
-import org.glassfish.grizzly.http.util.DataChunk;
-import org.glassfish.grizzly.http.util.Header;
-
-/**
- * {@link EncodingFilter} to enable gzip encoding.
- *
- * @since 1.7
- * @author The Grizzly Team
- */
-public final class ClientEncodingFilter implements EncodingFilter {
-
-    // --------------------------------------------- Methods from EncodingFilter
-
-    public boolean applyEncoding(HttpHeader httpPacket) {
-        httpPacket.addHeader(Header.AcceptEncoding, "gzip");
-        return false;
-    }
-
-    public boolean applyDecoding(HttpHeader httpPacket) {
-
-        final HttpResponsePacket httpResponse = (HttpResponsePacket) httpPacket;
-        final DataChunk bc = httpResponse.getHeaders().getValue(Header.ContentEncoding);
-        return bc != null && bc.indexOf("gzip", 0) != -1;
-    }
-}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/ProxyFilter.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/ProxyFilter.java
deleted file mode 100644
index ac54fb8b4..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/ProxyFilter.java
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly.filters;
-
-import static org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider.NTLM_ENGINE;
-import static org.asynchttpclient.util.AuthenticatorUtils.computeBasicAuthentication;
-import static org.asynchttpclient.util.AuthenticatorUtils.computeDigestAuthentication;
-
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.ProxyServer;
-import org.asynchttpclient.Realm;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.providers.grizzly.HttpTxContext;
-import org.glassfish.grizzly.filterchain.BaseFilter;
-import org.glassfish.grizzly.filterchain.FilterChainContext;
-import org.glassfish.grizzly.filterchain.NextAction;
-import org.glassfish.grizzly.http.HttpRequestPacket;
-import org.glassfish.grizzly.http.util.Header;
-
-import java.io.IOException;
-import org.glassfish.grizzly.http.HttpPacket;
-
-/**
- * This Filter will be placed in the FilterChain when a request is being
- * proxied.  It's main responsibility is to adjust the incoming request
- * as appropriate for a proxy to properly handle it.
- *
- * @since 2.0.0
- * @author The Grizzly Team
- */
-public final class ProxyFilter extends BaseFilter {
-
-    private final ProxyServer proxyServer;
-    private final AsyncHttpClientConfig config;
-    private final Boolean secure;
-
-    // ------------------------------------------------------------ Constructors
-
-    public ProxyFilter(final ProxyServer proxyServer, final AsyncHttpClientConfig config, boolean secure) {
-        this.proxyServer = proxyServer;
-        this.config = config;
-        this.secure = secure;
-    }
-
-    // ----------------------------------------------------- Methods from Filter
-
-    @Override
-    public NextAction handleWrite(FilterChainContext ctx) throws IOException {
-        final Object msg = ctx.getMessage();
-        if (HttpPacket.isHttp(msg)) {
-            HttpPacket httpPacket = (HttpPacket) msg;
-            final HttpRequestPacket request = (HttpRequestPacket) httpPacket.getHttpHeader();
-            if (!request.isCommitted()) {
-                HttpTxContext context = HttpTxContext.get(ctx);
-                assert (context != null);
-                Request req = context.getRequest();
-                if (!secure) {
-                    request.setRequestURI(req.getUrl());
-                }
-                addProxyHeaders(getRealm(req), request);
-            }
-        }
-        
-        return ctx.getInvokeAction();
-    }
-
-    // --------------------------------------------------------- Private Methods
-
-    private void addProxyHeaders(final Realm realm, final HttpRequestPacket request) {
-        if (realm != null && realm.getUsePreemptiveAuth()) {
-            final String authHeaderValue = generateAuthHeader(realm);
-            if (authHeaderValue != null) {
-                request.setHeader(Header.ProxyAuthorization, authHeaderValue);
-            }
-        }
-    }
-
-    private Realm getRealm(final Request request) {
-        Realm realm = request.getRealm();
-        if (realm == null) {
-            realm = config.getRealm();
-        }
-        return realm;
-    }
-
-    private String generateAuthHeader(final Realm realm) {
-        try {
-            switch (realm.getAuthScheme()) {
-            case BASIC:
-                return computeBasicAuthentication(realm);
-            case DIGEST:
-                return computeDigestAuthentication(realm);
-            case NTLM:
-                return NTLM_ENGINE.generateType1Msg("NTLM " + realm.getNtlmDomain(), realm.getNtlmHost());
-            default:
-                return null;
-            }
-        } catch (Exception e) {
-            throw new RuntimeException(e);
-        }
-    }
-}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/SwitchingSSLFilter.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/SwitchingSSLFilter.java
deleted file mode 100644
index b0449e82d..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/SwitchingSSLFilter.java
+++ /dev/null
@@ -1,225 +0,0 @@
-/*
- * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly.filters;
-
-import java.io.IOException;
-import java.net.ConnectException;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLEngine;
-import javax.net.ssl.SSLHandshakeException;
-import javax.net.ssl.SSLSession;
-import org.asynchttpclient.providers.grizzly.filters.events.SSLSwitchingEvent;
-import org.asynchttpclient.util.Base64;
-import org.glassfish.grizzly.CompletionHandler;
-import org.glassfish.grizzly.Connection;
-import org.glassfish.grizzly.EmptyCompletionHandler;
-import org.glassfish.grizzly.Grizzly;
-import org.glassfish.grizzly.IOEvent;
-import org.glassfish.grizzly.attributes.Attribute;
-import org.glassfish.grizzly.filterchain.FilterChain;
-import org.glassfish.grizzly.filterchain.FilterChainContext;
-import org.glassfish.grizzly.filterchain.FilterChainEvent;
-import org.glassfish.grizzly.filterchain.NextAction;
-import org.glassfish.grizzly.ssl.SSLEngineConfigurator;
-import org.glassfish.grizzly.ssl.SSLFilter;
-import org.glassfish.grizzly.ssl.SSLUtils;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-/**
- * SSL Filter that may be present within the FilterChain and may be
- * enabled/disabled by sending the appropriate {@link SSLSwitchingEvent}.
- *
- * @since 2.0
- * @author The Grizzly Team
- */
-public final class SwitchingSSLFilter extends SSLFilter {
-
-    private static final Attribute<Boolean> CONNECTION_IS_SECURE = Grizzly.DEFAULT_ATTRIBUTE_BUILDER
-            .createAttribute(SwitchingSSLFilter.class.getName());
-    private static final Attribute<Throwable> HANDSHAKE_ERROR = Grizzly.DEFAULT_ATTRIBUTE_BUILDER.createAttribute(SwitchingSSLFilter.class
-            .getName() + "-HANDSHAKE-ERROR");
-
-    private final static Logger LOGGER = LoggerFactory.getLogger(SwitchingSSLFilter.class);
-    
-    // ------------------------------------------------------------ Constructors
-
-    public SwitchingSSLFilter(final SSLEngineConfigurator clientConfig) {
-        super(null, clientConfig);
-    }
-
-    // -------------------------------------------------- Methods from SSLFilter
-
-    @Override
-    protected void notifyHandshakeFailed(Connection connection, Throwable t) {
-        setError(connection, t);
-    }
-
-    @Override
-    public NextAction handleConnect(final FilterChainContext ctx) throws IOException {
-        // Suspend further handleConnect processing.  We do this to ensure that
-        // the SSL handshake has been completed before returning the connection
-        // for use in processing user requests.  Additionally, this allows us
-        // to determine if a connection is SPDY or HTTP as early as possible.
-        ctx.suspend();
-        final Connection c = ctx.getConnection();
-        handshake(ctx.getConnection(), new EmptyCompletionHandler<SSLEngine>() {
-            @Override
-            public void completed(SSLEngine result) {
-                // Handshake was successful.  Resume the handleConnect
-                // processing.  We pass in Invoke Action so the filter
-                // chain will call handleConnect on the next filter.
-                ctx.resume(ctx.getInvokeAction());
-            }
-
-            @Override
-            public void cancelled() {
-                // Handshake was cancelled.  Stop the handleConnect
-                // processing.  The exception will be checked and
-                // passed to the user later.
-                setError(c, new SSLHandshakeException("Handshake canceled."));
-                ctx.resume(ctx.getStopAction());
-            }
-
-            @Override
-            public void failed(Throwable throwable) {
-                // Handshake failed.  Stop the handleConnect
-                // processing.  The exception will be checked and
-                // passed to the user later.
-                setError(c, throwable);
-                ctx.resume(ctx.getStopAction());
-            }
-        });
-
-        // This typically isn't advised, however, we need to be able to
-        // read the response from the proxy and OP_READ isn't typically
-        // enabled on the connection until all of the handleConnect()
-        // processing is complete.
-        enableRead(c);
-
-        // Tell the FilterChain that we're suspending further handleConnect
-        // processing.
-        return ctx.getSuspendAction();
-    }
-
-    @Override
-    public NextAction handleEvent(final FilterChainContext ctx, final FilterChainEvent event) throws IOException {
-
-        if (event.type() == SSLSwitchingEvent.class) {
-            final SSLSwitchingEvent se = (SSLSwitchingEvent) event;
-            setSecureStatus(se.getConnection(), se.isSecure());
-            return ctx.getStopAction();
-        }
-        return ctx.getInvokeAction();
-    }
-
-    @Override
-    public NextAction handleRead(final FilterChainContext ctx) throws IOException {
-
-        if (isSecure(ctx.getConnection())) {
-            return super.handleRead(ctx);
-        }
-        return ctx.getInvokeAction();
-    }
-
-    @Override
-    public NextAction handleWrite(final FilterChainContext ctx) throws IOException {
-
-        if (isSecure(ctx.getConnection())) {
-            return super.handleWrite(ctx);
-        }
-        return ctx.getInvokeAction();
-    }
-
-    @Override
-    public void onFilterChainChanged(final FilterChain filterChain) {
-        // no-op
-    }
-
-    public static Throwable getHandshakeError(final Connection c) {
-        return HANDSHAKE_ERROR.remove(c);
-    }
-
-    // --------------------------------------------------------- Private Methods
-
-    private static boolean isSecure(final Connection c) {
-        Boolean secStatus = CONNECTION_IS_SECURE.get(c);
-        return (secStatus == null ? true : secStatus);
-    }
-
-    private static void setSecureStatus(final Connection c, final boolean secure) {
-        CONNECTION_IS_SECURE.set(c, secure);
-    }
-
-    private static void setError(final Connection c, Throwable t) {
-        HANDSHAKE_ERROR.set(c, t);
-    }
-
-    private static void enableRead(final Connection c) throws IOException {
-        c.enableIOEvent(IOEvent.READ);
-    }
-    
-    // ================= HostnameVerifier section ========================
-    
-    public static CompletionHandler<Connection> wrapWithHostnameVerifierHandler(
-            final CompletionHandler<Connection> delegateCompletionHandler,
-            final HostnameVerifier verifier, final String host) {
-
-        return new CompletionHandler<Connection>() {
-
-            public void cancelled() {
-                if (delegateCompletionHandler != null) {
-                    delegateCompletionHandler.cancelled();
-                }
-            }
-
-            public void failed(final Throwable throwable) {
-                if (delegateCompletionHandler != null) {
-                    delegateCompletionHandler.failed(throwable);
-                }
-            }
-
-            public void completed(final Connection connection) {
-                if (getHandshakeError(connection) == null) {
-                    final SSLSession session = SSLUtils.getSSLEngine(connection).getSession();
-                    if (LOGGER.isDebugEnabled()) {
-                        LOGGER.debug("SSL Handshake onComplete: session = {}, id = {}, isValid = {}, host = {}",
-                                session.toString(), Base64.encode(session.getId()), session.isValid(), host);
-                    }
-
-                    if (!verifier.verify(host, session)) {
-                        connection.terminateSilently();
-
-                        if (delegateCompletionHandler != null) {
-                            IOException e = new ConnectException("Host name verification failed for host " + host);
-                            delegateCompletionHandler.failed(e);
-                        }
-
-                        return;
-                    }
-                }
-                
-                if (delegateCompletionHandler != null) {
-                    delegateCompletionHandler.completed(connection);
-                }
-            }
-
-            public void updated(final Connection connection) {
-                if (delegateCompletionHandler != null) {
-                    delegateCompletionHandler.updated(connection);
-                }
-            }
-        };
-    }
-}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/TunnelFilter.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/TunnelFilter.java
deleted file mode 100644
index 876e31109..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/TunnelFilter.java
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly.filters;
-
-import java.io.IOException;
-
-import org.asynchttpclient.ProxyServer;
-import org.asynchttpclient.providers.grizzly.Utils;
-import org.asynchttpclient.providers.grizzly.filters.events.TunnelRequestEvent;
-import org.asynchttpclient.uri.Uri;
-import org.glassfish.grizzly.IOEvent;
-import org.glassfish.grizzly.filterchain.BaseFilter;
-import org.glassfish.grizzly.filterchain.FilterChainContext;
-import org.glassfish.grizzly.filterchain.FilterChainEvent;
-import org.glassfish.grizzly.filterchain.NextAction;
-
-/**
- * This <code>Filter</code> is responsible for HTTP CONNECT
- * tunnelling when a connection should be secure and required to
- * go through a proxy.
- *
- * @since 2.0
- * @author The Grizzly Team
- */
-public final class TunnelFilter extends BaseFilter {
-
-    private final ProxyServer proxyServer;
-    private final Uri uri;
-
-    // ------------------------------------------------------------ Constructors
-
-    public TunnelFilter(final ProxyServer proxyServer, final Uri uri) {
-        this.proxyServer = proxyServer;
-        this.uri = uri;
-    }
-
-    // ----------------------------------------------------- Methods from Filter
-
-    @Override
-    public NextAction handleConnect(FilterChainContext ctx) throws IOException {
-        // We suspend the FilterChainContext here to prevent
-        // notification of other filters of the connection event.
-        // This allows us to control when the connection is returned
-        // to the user - we ensure that the tunnel is properly established
-        // before the user request is sent.
-        ctx.suspend();
-
-        // This connection is special and shouldn't be tracked.
-        Utils.connectionIgnored(ctx.getConnection(), true);
-
-        // This event will be handled by the AsyncHttpClientFilter.
-        // It will send the CONNECT request and process the response.
-        // When tunnel is complete, the AsyncHttpClientFilter will
-        // send this event back to this filter in order to notify
-        // it that the request processing is complete.
-        final TunnelRequestEvent tunnelRequestEvent = new TunnelRequestEvent(ctx, proxyServer, uri);
-        ctx.notifyUpstream(tunnelRequestEvent);
-
-        // This typically isn't advised, however, we need to be able to
-        // read the response from the proxy and OP_READ isn't typically
-        // enabled on the connection until all of the handleConnect()
-        // processing is complete.
-        ctx.getConnection().enableIOEvent(IOEvent.READ);
-
-        // Tell the FilterChain that we're suspending further handleConnect
-        // processing.
-        return ctx.getSuspendAction();
-    }
-
-    @Override
-    public NextAction handleEvent(FilterChainContext ctx, FilterChainEvent event) throws IOException {
-        if (event.type() == TunnelRequestEvent.class) {
-            TunnelRequestEvent tunnelRequestEvent = (TunnelRequestEvent) event;
-
-            // Clear ignore status.  Any further use of the connection will
-            // be bound by normal AHC connection processing.
-            Utils.connectionIgnored(ctx.getConnection(), false);
-
-            // Obtain the context that was previously suspended and resume.
-            // We pass in Invoke Action so the filter chain will call
-            // handleConnect on the next filter.
-            FilterChainContext suspendedContext = tunnelRequestEvent.getSuspendedContext();
-            suspendedContext.resume(ctx.getInvokeAction());
-
-            // Stop further event processing.
-            return ctx.getStopAction();
-        }
-        return ctx.getInvokeAction();
-    }
-}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/events/ContinueEvent.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/events/ContinueEvent.java
deleted file mode 100644
index c514d6677..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/events/ContinueEvent.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly.filters.events;
-
-import org.asynchttpclient.providers.grizzly.HttpTxContext;
-import org.glassfish.grizzly.filterchain.FilterChainEvent;
-
-/**
- * {@link FilterChainEvent} to trigger HTTP 100-Continue processing.
- *
- * @since 2.0
- * @author The Grizzly Team
- */
-public final class ContinueEvent implements FilterChainEvent {
-
-    private final HttpTxContext context;
-
-    // -------------------------------------------------------- Constructors
-
-    public ContinueEvent(final HttpTxContext context) {
-        this.context = context;
-    }
-
-    // --------------------------------------- Methods from FilterChainEvent
-
-    @Override
-    public Object type() {
-        return ContinueEvent.class;
-    }
-
-    // ---------------------------------------------------------- Public Methods
-
-    public HttpTxContext getContext() {
-        return context;
-    }
-}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/events/GracefulCloseEvent.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/events/GracefulCloseEvent.java
deleted file mode 100644
index 35252b610..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/events/GracefulCloseEvent.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Copyright (c) 2014 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly.filters.events;
-
-import org.asynchttpclient.providers.grizzly.HttpTxContext;
-import org.glassfish.grizzly.filterchain.FilterChainEvent;
-
-/**
- * {@link FilterChainEvent} to gracefully complete the request-response processing
- * when {@link Connection} is getting closed by the remote host.
- *
- * @since 1.8.7
- * @author The Grizzly Team
- */
-public class GracefulCloseEvent implements FilterChainEvent {
-    private final HttpTxContext httpTxContext;
-
-    public GracefulCloseEvent(HttpTxContext httpTxContext) {
-        this.httpTxContext = httpTxContext;
-    }
-
-    public HttpTxContext getHttpTxContext() {
-        return httpTxContext;
-    }
-
-    @Override
-    public Object type() {
-        return GracefulCloseEvent.class;
-    }
-}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/events/SSLSwitchingEvent.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/events/SSLSwitchingEvent.java
deleted file mode 100644
index 5fad70d10..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/events/SSLSwitchingEvent.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly.filters.events;
-
-import org.glassfish.grizzly.Connection;
-import org.glassfish.grizzly.filterchain.FilterChainEvent;
-
-/**
- * {@link FilterChainEvent} to dynamically enable/disable the SSLFilter on
- * a per-connection basis.
- *
- * @since 2.0
- * @author The Grizzly Team
- */
-public final class SSLSwitchingEvent implements FilterChainEvent {
-
-    private final boolean secure;
-    private final Connection connection;
-
-    // ------------------------------------------------------------ Constructors
-
-    public SSLSwitchingEvent(final boolean secure, final Connection c) {
-        this.secure = secure;
-        connection = c;
-    }
-
-    // ------------------------------------------- Methods from FilterChainEvent
-
-    @Override
-    public Object type() {
-        return SSLSwitchingEvent.class;
-    }
-
-    // ---------------------------------------------------------- Public Methods
-
-    public boolean isSecure() {
-        return secure;
-    }
-
-    public Connection getConnection() {
-        return connection;
-    }
-}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/events/TunnelRequestEvent.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/events/TunnelRequestEvent.java
deleted file mode 100644
index ec18ac68e..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/filters/events/TunnelRequestEvent.java
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.grizzly.filters.events;
-
-import org.asynchttpclient.ProxyServer;
-import org.asynchttpclient.uri.Uri;
-import org.glassfish.grizzly.filterchain.FilterChainContext;
-import org.glassfish.grizzly.filterchain.FilterChainEvent;
-
-/**
- * {@link FilterChainEvent} to initiate CONNECT tunnelling with a proxy server.
- *
- * @since 2.0
- * @author The Grizzly Team.
- */
-public final class TunnelRequestEvent implements FilterChainEvent {
-
-    private final FilterChainContext suspendedContext;
-    private final ProxyServer proxyServer;
-    private final Uri uri;
-
-    // ------------------------------------------------------------ Constructors
-
-    public TunnelRequestEvent(final FilterChainContext suspendedContext, final ProxyServer proxyServer, final Uri uri) {
-        this.suspendedContext = suspendedContext;
-        this.proxyServer = proxyServer;
-        this.uri = uri;
-    }
-
-    // ------------------------------------------- Methods from FilterChainEvent
-
-    @Override
-    public Object type() {
-        return TunnelRequestEvent.class;
-    }
-
-    // ---------------------------------------------------------- Public Methods
-
-    public FilterChainContext getSuspendedContext() {
-        return suspendedContext;
-    }
-
-    public ProxyServer getProxyServer() {
-        return proxyServer;
-    }
-
-    public Uri getUri() {
-        return uri;
-    }
-}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/statushandler/AuthorizationHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/statushandler/AuthorizationHandler.java
deleted file mode 100644
index d41dc9ef4..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/statushandler/AuthorizationHandler.java
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly.statushandler;
-
-import static org.asynchttpclient.providers.grizzly.statushandler.StatusHandler.InvocationStatus.STOP;
-
-import org.asynchttpclient.Realm;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.providers.grizzly.ConnectionManager;
-import org.asynchttpclient.providers.grizzly.HttpTxContext;
-import org.asynchttpclient.util.AuthenticatorUtils;
-import org.glassfish.grizzly.Connection;
-import org.glassfish.grizzly.filterchain.FilterChainContext;
-import org.glassfish.grizzly.http.HttpResponsePacket;
-import org.glassfish.grizzly.http.util.Header;
-import org.glassfish.grizzly.http.util.HttpStatus;
-
-import java.security.NoSuchAlgorithmException;
-import java.util.Locale;
-
-public final class AuthorizationHandler implements StatusHandler {
-
-    public static final AuthorizationHandler INSTANCE = new AuthorizationHandler();
-
-    // ---------------------------------------------- Methods from StatusHandler
-
-    public boolean handlesStatus(int statusCode) {
-        return (HttpStatus.UNAUTHORIZED_401.statusMatches(statusCode));
-    }
-
-    @SuppressWarnings({ "unchecked" })
-    public boolean handleStatus(final HttpResponsePacket responsePacket, final HttpTxContext httpTransactionContext,
-            final FilterChainContext ctx) {
-
-        final String auth = responsePacket.getHeader(Header.WWWAuthenticate);
-        if (auth == null) {
-            throw new IllegalStateException("401 response received, but no WWW-Authenticate header was present");
-        }
-
-        Realm realm = httpTransactionContext.getRequest().getRealm();
-        if (realm == null) {
-            realm = httpTransactionContext.getProvider().getClientConfig().getRealm();
-        }
-        if (realm == null) {
-            httpTransactionContext.setInvocationStatus(STOP);
-            if (httpTransactionContext.getHandler() != null) {
-                try {
-                    httpTransactionContext.getHandler().onStatusReceived(httpTransactionContext.getResponseStatus());
-                } catch (Exception e) {
-                    httpTransactionContext.abort(e);
-                }
-            }
-            return true;
-        }
-
-        responsePacket.setSkipRemainder(true); // ignore the remainder of the response
-
-        final Request req = httpTransactionContext.getRequest();
-        realm = new Realm.RealmBuilder().clone(realm).setScheme(realm.getAuthScheme()).setUri(req.getUri())
-                .setMethodName(req.getMethod()).setUsePreemptiveAuth(true).parseWWWAuthenticateHeader(auth).build();
-        String lowerCaseAuth = auth.toLowerCase(Locale.ENGLISH);
-        if (lowerCaseAuth.startsWith("basic")) {
-            req.getHeaders().remove(Header.Authorization.toString());
-            req.getHeaders().add(Header.Authorization.toString(), AuthenticatorUtils.computeBasicAuthentication(realm));
-        } else if (lowerCaseAuth.startsWith("digest")) {
-            req.getHeaders().remove(Header.Authorization.toString());
-            try {
-                req.getHeaders().add(Header.Authorization.toString(), AuthenticatorUtils.computeDigestAuthentication(realm));
-            } catch (NoSuchAlgorithmException e) {
-                throw new IllegalStateException("Digest authentication not supported", e);
-            }
-        } else {
-            throw new IllegalStateException("Unsupported authorization method: " + auth);
-        }
-
-        try {
-            final Connection c = getConnectionForNextRequest(ctx, req, responsePacket, httpTransactionContext);
-            final HttpTxContext newContext = httpTransactionContext.copy();
-            httpTransactionContext.setFuture(null);
-            HttpTxContext.set(ctx, newContext);
-            newContext.setInvocationStatus(STOP);
-            httpTransactionContext.getProvider().execute(c, req, httpTransactionContext.getHandler(), httpTransactionContext.getFuture(),
-                    newContext);
-            return false;
-        } catch (Exception e) {
-            httpTransactionContext.abort(e);
-        }
-        httpTransactionContext.setInvocationStatus(STOP);
-        return false;
-    }
-
-    // --------------------------------------------------------- Private Methods
-
-    private Connection getConnectionForNextRequest(final FilterChainContext ctx, final Request request, final HttpResponsePacket response,
-            final HttpTxContext httpCtx) throws Exception {
-        /*
-        if (response.getProcessingState().isKeepAlive()) {
-            return ctx.getConnection();
-        } else { */
-        final ConnectionManager m = httpCtx.getProvider().getConnectionManager();
-        return m.obtainConnection(request, httpCtx.getFuture());
-        /* } */
-    }
-
-} // END AuthorizationHandler
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/statushandler/ProxyAuthorizationHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/statushandler/ProxyAuthorizationHandler.java
deleted file mode 100644
index 4eb357dcb..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/statushandler/ProxyAuthorizationHandler.java
+++ /dev/null
@@ -1,217 +0,0 @@
-/*
- * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly.statushandler;
-
-import org.asynchttpclient.ProxyServer;
-import org.asynchttpclient.Realm;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.providers.grizzly.ConnectionManager;
-import org.asynchttpclient.providers.grizzly.GrizzlyAsyncHttpProvider;
-import org.asynchttpclient.providers.grizzly.HttpTxContext;
-import org.asynchttpclient.util.AuthenticatorUtils;
-import org.asynchttpclient.util.Base64;
-import org.glassfish.grizzly.Connection;
-import org.glassfish.grizzly.filterchain.FilterChainContext;
-import org.glassfish.grizzly.http.HttpResponsePacket;
-import org.glassfish.grizzly.http.Method;
-import org.glassfish.grizzly.http.util.Header;
-import org.glassfish.grizzly.http.util.HttpStatus;
-import org.ietf.jgss.GSSContext;
-import org.ietf.jgss.GSSException;
-import org.ietf.jgss.GSSManager;
-import org.ietf.jgss.GSSName;
-import org.ietf.jgss.Oid;
-import org.slf4j.LoggerFactory;
-
-import java.security.NoSuchAlgorithmException;
-import java.util.Locale;
-
-public final class ProxyAuthorizationHandler implements StatusHandler {
-
-    public static final ProxyAuthorizationHandler INSTANCE = new ProxyAuthorizationHandler();
-
-    // ---------------------------------------------- Methods from StatusHandler
-
-    public boolean handlesStatus(int statusCode) {
-        return (HttpStatus.PROXY_AUTHENTICATION_REQUIRED_407.statusMatches(statusCode));
-    }
-
-    public boolean handleStatus(final HttpResponsePacket responsePacket, final HttpTxContext httpTransactionContext,
-            final FilterChainContext ctx) {
-
-        final String proxyAuth = responsePacket.getHeader(Header.ProxyAuthenticate);
-        if (proxyAuth == null) {
-            throw new IllegalStateException("407 response received, but no Proxy Authenticate header was present");
-        }
-
-        final Request req = httpTransactionContext.getRequest();
-        ProxyServer proxyServer = httpTransactionContext.getProvider().getClientConfig().getProxyServerSelector()
-                .select(req.getUri());
-        String principal = proxyServer.getPrincipal();
-        String password = proxyServer.getPassword();
-        Realm realm = new Realm.RealmBuilder().setPrincipal(principal).setPassword(password).setUri(req.getUri()).setOmitQuery(true)
-                .setMethodName(Method.CONNECT.getMethodString()).setUsePreemptiveAuth(true).parseProxyAuthenticateHeader(proxyAuth).build();
-        String proxyAuthLowerCase = proxyAuth.toLowerCase(Locale.ENGLISH);
-        if (proxyAuthLowerCase.startsWith("basic")) {
-            req.getHeaders().remove(Header.ProxyAuthenticate.toString());
-            req.getHeaders().remove(Header.ProxyAuthorization.toString());
-            req.getHeaders().add(Header.ProxyAuthorization.toString(), AuthenticatorUtils.computeBasicAuthentication(realm));
-        } else if (proxyAuthLowerCase.startsWith("digest")) {
-            req.getHeaders().remove(Header.ProxyAuthenticate.toString());
-            req.getHeaders().remove(Header.ProxyAuthorization.toString());
-            try {
-                req.getHeaders().add(Header.ProxyAuthorization.toString(), AuthenticatorUtils.computeDigestAuthentication(realm));
-            } catch (NoSuchAlgorithmException e) {
-                throw new IllegalStateException("Digest authentication not supported", e);
-            }
-        } else if (proxyAuthLowerCase.startsWith("ntlm")) {
-
-            req.getHeaders().remove(Header.ProxyAuthenticate.toString());
-            req.getHeaders().remove(Header.ProxyAuthorization.toString());
-
-            String msg;
-            try {
-                if (isNTLMFirstHandShake(proxyAuth)) {
-                    msg = GrizzlyAsyncHttpProvider.NTLM_ENGINE.generateType1Msg(proxyServer.getNtlmDomain(), "");
-                } else {
-                    String serverChallenge = proxyAuth.trim().substring("NTLM ".length());
-                    msg = GrizzlyAsyncHttpProvider.NTLM_ENGINE.generateType3Msg(principal, password, proxyServer.getNtlmDomain(),
-                            proxyServer.getHost(), serverChallenge);
-                }
-
-                req.getHeaders().add(Header.ProxyAuthorization.toString(), "NTLM " + msg);
-            } catch (Exception e1) {
-                e1.printStackTrace();
-            }
-        } else if (proxyAuthLowerCase.startsWith("negotiate")) {
-            //this is for kerberos
-            req.getHeaders().remove(Header.ProxyAuthenticate.toString());
-            req.getHeaders().remove(Header.ProxyAuthorization.toString());
-        } else {
-            throw new IllegalStateException("Unsupported authorization method: " + proxyAuth);
-        }
-
-        InvocationStatus tempInvocationStatus = InvocationStatus.STOP;
-
-        try {
-            if (isNTLMFirstHandShake(proxyAuth)) {
-                tempInvocationStatus = InvocationStatus.CONTINUE;
-            }
-            if (proxyAuth.toLowerCase().startsWith("negotiate")) {
-                final Connection c = getConnectionForNextRequest(ctx, req, responsePacket, httpTransactionContext);
-                final HttpTxContext newContext = httpTransactionContext.copy();
-                httpTransactionContext.setFuture(null);
-                HttpTxContext.set(ctx, newContext);
-
-                newContext.setInvocationStatus(tempInvocationStatus);
-
-                String challengeHeader;
-                String server = proxyServer.getHost();
-
-                challengeHeader = GSSSPNEGOWrapper.generateToken(server);
-
-                req.getHeaders().add(Header.ProxyAuthorization.toString(), "Negotiate " + challengeHeader);
-
-                return executeRequest(httpTransactionContext, req, c, newContext);
-            } else if (isNTLMSecondHandShake(proxyAuth)) {
-                final Connection c = ctx.getConnection();
-                final HttpTxContext newContext = httpTransactionContext.copy();
-
-                httpTransactionContext.setFuture(null);
-                HttpTxContext.set(ctx, newContext);
-
-                newContext.setInvocationStatus(tempInvocationStatus);
-
-                return executeRequest(httpTransactionContext, req, c, newContext);
-
-            } else {
-                final Connection c = getConnectionForNextRequest(ctx, req, responsePacket, httpTransactionContext);
-                final HttpTxContext newContext = httpTransactionContext.copy();
-                httpTransactionContext.setFuture(null);
-                HttpTxContext.set(ctx, newContext);
-
-                newContext.setInvocationStatus(tempInvocationStatus);
-
-                //NTLM needs the same connection to be used for exchange of tokens
-                return executeRequest(httpTransactionContext, req, c, newContext);
-            }
-        } catch (Exception e) {
-            httpTransactionContext.abort(e);
-        }
-        httpTransactionContext.setInvocationStatus(tempInvocationStatus);
-        return false;
-    }
-
-    private boolean executeRequest(final HttpTxContext httpTransactionContext, final Request req, final Connection c,
-            final HttpTxContext httpTxContext) {
-        httpTransactionContext.getProvider().execute(c, req, httpTransactionContext.getHandler(), httpTransactionContext.getFuture(),
-                httpTxContext);
-        return false;
-    }
-
-    public static boolean isNTLMSecondHandShake(final String proxyAuth) {
-        return (proxyAuth != null && proxyAuth.toLowerCase(Locale.ENGLISH).startsWith("ntlm") && !proxyAuth.equalsIgnoreCase("ntlm"));
-    }
-
-    private static boolean isNTLMFirstHandShake(final String proxy_auth) {
-        return (proxy_auth.equalsIgnoreCase("ntlm"));
-    }
-
-    private Connection getConnectionForNextRequest(final FilterChainContext ctx, final Request request, final HttpResponsePacket response,
-            final HttpTxContext httpCtx) throws Exception {
-        /*
-                if (response.getProcessingState().isKeepAlive()) {
-                    return ctx.getConnection();
-                } else { */
-        final ConnectionManager m = httpCtx.getProvider().getConnectionManager();
-        return m.obtainConnection(request, httpCtx.getFuture());
-        /* } */
-    }
-
-    private static final class GSSSPNEGOWrapper {
-        private final static org.slf4j.Logger LOGGER = LoggerFactory.getLogger(GSSSPNEGOWrapper.class);
-        private static final String KERBEROS_OID = "1.2.840.113554.1.2.2";
-
-        static GSSManager getManager() {
-            return GSSManager.getInstance();
-        }
-
-        static byte[] generateGSSToken(final byte[] input, final Oid oid, final String authServer) throws GSSException {
-            byte[] token = input;
-            if (token == null) {
-                token = new byte[0];
-            }
-            GSSManager manager = getManager();
-            GSSName serverName = manager.createName("HTTP@" + authServer, GSSName.NT_HOSTBASED_SERVICE);
-            GSSContext gssContext = manager.createContext(serverName.canonicalize(oid), oid, null, GSSContext.DEFAULT_LIFETIME);
-            gssContext.requestMutualAuth(true);
-            gssContext.requestCredDeleg(true);
-            return gssContext.initSecContext(token, 0, token.length);
-        }
-
-        public static String generateToken(String authServer) {
-            String returnVal = "";
-            Oid oid;
-            try {
-                oid = new Oid(KERBEROS_OID);
-                byte[] token = GSSSPNEGOWrapper.generateGSSToken(null, oid, authServer);
-                returnVal = Base64.encode(token);
-            } catch (GSSException e) {
-                LOGGER.warn(e.toString(), e);
-            }
-
-            return returnVal;
-        }
-    }
-} // END AuthorizationHandler
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/statushandler/RedirectHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/statushandler/RedirectHandler.java
deleted file mode 100644
index f2db96a9f..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/statushandler/RedirectHandler.java
+++ /dev/null
@@ -1,99 +0,0 @@
-/*
- * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly.statushandler;
-
-import static org.asynchttpclient.providers.grizzly.statushandler.StatusHandler.InvocationStatus.CONTINUE;
-
-import org.asynchttpclient.Request;
-import org.asynchttpclient.providers.grizzly.ConnectionManager;
-import org.asynchttpclient.providers.grizzly.EventHandler;
-import org.asynchttpclient.providers.grizzly.HttpTxContext;
-import org.asynchttpclient.uri.Uri;
-import org.glassfish.grizzly.Connection;
-import org.glassfish.grizzly.filterchain.FilterChainContext;
-import org.glassfish.grizzly.http.HttpResponsePacket;
-import org.glassfish.grizzly.http.util.Header;
-
-public final class RedirectHandler implements StatusHandler {
-
-    public static final RedirectHandler INSTANCE = new RedirectHandler();
-
-    // ------------------------------------------ Methods from StatusHandler
-
-    public boolean handlesStatus(int statusCode) {
-        return (EventHandler.isRedirect(statusCode));
-    }
-
-    @SuppressWarnings({ "unchecked" })
-    public boolean handleStatus(final HttpResponsePacket responsePacket, final HttpTxContext httpTransactionContext,
-            final FilterChainContext ctx) {
-
-        final String redirectURL = responsePacket.getHeader(Header.Location);
-        if (redirectURL == null) {
-            throw new IllegalStateException("redirect received, but no location header was present");
-        }
-
-        Uri orig;
-        if (httpTransactionContext.getLastRedirectURI() == null) {
-            orig = httpTransactionContext.getRequest().getUri();
-        } else {
-            orig = Uri.create(httpTransactionContext.getRequest().getUri(),
-                    httpTransactionContext.getLastRedirectURI());
-        }
-        httpTransactionContext.setLastRedirectURI(redirectURL);
-        Request requestToSend;
-        Uri uri = Uri.create(orig, redirectURL);
-        if (!uri.toUrl().equalsIgnoreCase(orig.toUrl())) {
-            requestToSend = EventHandler.newRequest(uri, responsePacket, httpTransactionContext,
-                    sendAsGet(responsePacket, httpTransactionContext));
-        } else {
-            httpTransactionContext.setStatusHandler(null);
-            httpTransactionContext.setInvocationStatus(CONTINUE);
-            try {
-                httpTransactionContext.getHandler().onStatusReceived(httpTransactionContext.getResponseStatus());
-            } catch (Exception e) {
-                httpTransactionContext.abort(e);
-            }
-            return true;
-        }
-
-        final ConnectionManager m = httpTransactionContext.getProvider().getConnectionManager();
-        try {
-            final Connection c = m.obtainConnection(requestToSend, httpTransactionContext.getFuture());
-            final HttpTxContext newContext = httpTransactionContext.copy();
-            httpTransactionContext.setFuture(null);
-            newContext.setInvocationStatus(CONTINUE);
-            newContext.setRequest(requestToSend);
-            newContext.setRequestUri(requestToSend.getUri());
-            HttpTxContext.set(ctx, newContext);
-            httpTransactionContext.getProvider().execute(c, requestToSend, newContext.getHandler(), newContext.getFuture(), newContext);
-            return false;
-        } catch (Exception e) {
-            httpTransactionContext.abort(e);
-        }
-
-        httpTransactionContext.setInvocationStatus(CONTINUE);
-        return true;
-
-    }
-
-    // ------------------------------------------------- Private Methods
-
-    private boolean sendAsGet(final HttpResponsePacket response, final HttpTxContext ctx) {
-        final int statusCode = response.getStatus();
-        return !(statusCode < 302 || statusCode > 303) &&
-                !(statusCode == 302 && ctx.getProvider().getClientConfig().isStrict302Handling());
-    }
-
-} // END RedirectHandler
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/statushandler/StatusHandler.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/statushandler/StatusHandler.java
deleted file mode 100644
index bca0d2a26..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/statushandler/StatusHandler.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly.statushandler;
-
-import org.asynchttpclient.providers.grizzly.HttpTxContext;
-import org.glassfish.grizzly.filterchain.FilterChainContext;
-import org.glassfish.grizzly.http.HttpResponsePacket;
-
-public interface StatusHandler {
-
-    public enum InvocationStatus {
-        CONTINUE, STOP
-    }
-
-    boolean handleStatus(final HttpResponsePacket httpResponse, final HttpTxContext httpTransactionContext, final FilterChainContext ctx);
-
-    boolean handlesStatus(final int statusCode);
-}
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/websocket/AHCWebSocketListenerAdapter.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/websocket/AHCWebSocketListenerAdapter.java
deleted file mode 100644
index 1d2dd1291..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/websocket/AHCWebSocketListenerAdapter.java
+++ /dev/null
@@ -1,181 +0,0 @@
-/*
- * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly.websocket;
-
-import org.asynchttpclient.websocket.WebSocketByteListener;
-import org.asynchttpclient.websocket.WebSocketCloseCodeReasonListener;
-import org.asynchttpclient.websocket.WebSocketListener;
-import org.asynchttpclient.websocket.WebSocketPingListener;
-import org.asynchttpclient.websocket.WebSocketPongListener;
-import org.asynchttpclient.websocket.WebSocketTextListener;
-import org.glassfish.grizzly.websockets.ClosingFrame;
-import org.glassfish.grizzly.websockets.DataFrame;
-
-import java.io.ByteArrayOutputStream;
-
-final class AHCWebSocketListenerAdapter implements org.glassfish.grizzly.websockets.WebSocketListener {
-
-    private final WebSocketListener ahcListener;
-    private final GrizzlyWebSocketAdapter webSocket;
-    private final StringBuilder stringBuffer;
-    private final ByteArrayOutputStream byteArrayOutputStream;
-
-    // -------------------------------------------------------- Constructors
-
-    public AHCWebSocketListenerAdapter(final WebSocketListener ahcListener, final GrizzlyWebSocketAdapter webSocket) {
-        this.ahcListener = ahcListener;
-        this.webSocket = webSocket;
-        if (webSocket.bufferFragments) {
-            stringBuffer = new StringBuilder();
-            byteArrayOutputStream = new ByteArrayOutputStream();
-        } else {
-            stringBuffer = null;
-            byteArrayOutputStream = null;
-        }
-    }
-
-    // ------------------------------ Methods from Grizzly WebSocketListener
-
-    @Override
-    public void onClose(org.glassfish.grizzly.websockets.WebSocket gWebSocket, DataFrame dataFrame) {
-        try {
-            if (ahcListener instanceof WebSocketCloseCodeReasonListener) {
-                ClosingFrame cf = ClosingFrame.class.cast(dataFrame);
-                WebSocketCloseCodeReasonListener.class.cast(ahcListener).onClose(webSocket, cf.getCode(), cf.getReason());
-            } else {
-                ahcListener.onClose(webSocket);
-            }
-        } catch (Throwable e) {
-            ahcListener.onError(e);
-        }
-    }
-
-    @Override
-    public void onConnect(org.glassfish.grizzly.websockets.WebSocket gWebSocket) {
-        try {
-            ahcListener.onOpen(webSocket);
-        } catch (Throwable e) {
-            ahcListener.onError(e);
-        }
-    }
-
-    @Override
-    public void onMessage(org.glassfish.grizzly.websockets.WebSocket webSocket, String s) {
-        try {
-            if (ahcListener instanceof WebSocketTextListener) {
-                WebSocketTextListener.class.cast(ahcListener).onMessage(s);
-            }
-        } catch (Throwable e) {
-            ahcListener.onError(e);
-        }
-    }
-
-    @Override
-    public void onMessage(org.glassfish.grizzly.websockets.WebSocket webSocket, byte[] bytes) {
-        try {
-            if (ahcListener instanceof WebSocketByteListener) {
-                WebSocketByteListener.class.cast(ahcListener).onMessage(bytes);
-            }
-        } catch (Throwable e) {
-            ahcListener.onError(e);
-        }
-    }
-
-    @Override
-    public void onPing(org.glassfish.grizzly.websockets.WebSocket webSocket, byte[] bytes) {
-        try {
-            if (ahcListener instanceof WebSocketPingListener) {
-                WebSocketPingListener.class.cast(ahcListener).onPing(bytes);
-            }
-        } catch (Throwable e) {
-            ahcListener.onError(e);
-        }
-    }
-
-    @Override
-    public void onPong(org.glassfish.grizzly.websockets.WebSocket webSocket, byte[] bytes) {
-        try {
-            if (ahcListener instanceof WebSocketPongListener) {
-                WebSocketPongListener.class.cast(ahcListener).onPong(bytes);
-            }
-        } catch (Throwable e) {
-            ahcListener.onError(e);
-        }
-    }
-
-    @Override
-    public void onFragment(org.glassfish.grizzly.websockets.WebSocket webSocket, String s, boolean last) {
-        try {
-            if (this.webSocket.bufferFragments) {
-                synchronized (this.webSocket) {
-                    stringBuffer.append(s);
-                    if (last) {
-                        if (ahcListener instanceof WebSocketTextListener) {
-                            final String message = stringBuffer.toString();
-                            stringBuffer.setLength(0);
-                            WebSocketTextListener.class.cast(ahcListener).onMessage(message);
-                        }
-                    }
-                }
-            }
-        } catch (Throwable e) {
-            ahcListener.onError(e);
-        }
-    }
-
-    @Override
-    public void onFragment(org.glassfish.grizzly.websockets.WebSocket webSocket, byte[] bytes, boolean last) {
-        try {
-            if (this.webSocket.bufferFragments) {
-                synchronized (this.webSocket) {
-                    byteArrayOutputStream.write(bytes);
-                    if (last) {
-                        if (ahcListener instanceof WebSocketByteListener) {
-                            final byte[] bytesLocal = byteArrayOutputStream.toByteArray();
-                            byteArrayOutputStream.reset();
-                            WebSocketByteListener.class.cast(ahcListener).onMessage(bytesLocal);
-                        }
-                    }
-                }
-            }
-        } catch (Throwable e) {
-            ahcListener.onError(e);
-        }
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (this == o)
-            return true;
-        if (o == null || getClass() != o.getClass())
-            return false;
-
-        AHCWebSocketListenerAdapter that = (AHCWebSocketListenerAdapter) o;
-
-        if (ahcListener != null ? !ahcListener.equals(that.ahcListener) : that.ahcListener != null)
-            return false;
-        //noinspection RedundantIfStatement
-        if (webSocket != null ? !webSocket.equals(that.webSocket) : that.webSocket != null)
-            return false;
-
-        return true;
-    }
-
-    @Override
-    public int hashCode() {
-        int result = ahcListener != null ? ahcListener.hashCode() : 0;
-        result = 31 * result + (webSocket != null ? webSocket.hashCode() : 0);
-        return result;
-    }
-} // END AHCWebSocketListenerAdapter
diff --git a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyWebSocketAdapter.java b/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyWebSocketAdapter.java
deleted file mode 100644
index e06538fdc..000000000
--- a/providers/grizzly/src/main/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyWebSocketAdapter.java
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
- * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly.websocket;
-
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
-
-import org.asynchttpclient.websocket.WebSocket;
-import org.asynchttpclient.websocket.WebSocketListener;
-import org.glassfish.grizzly.websockets.SimpleWebSocket;
-
-public final class GrizzlyWebSocketAdapter implements WebSocket {
-
-    private final SimpleWebSocket gWebSocket;
-    final boolean bufferFragments;
-
-    // -------------------------------------------------------- Constructors
-
-    public GrizzlyWebSocketAdapter(final SimpleWebSocket gWebSocket, final boolean bufferFragments) {
-        this.gWebSocket = gWebSocket;
-        this.bufferFragments = bufferFragments;
-    }
-
-    // ---------------------------------------------- Methods from AHC WebSocket
-
-    @Override
-    public WebSocket sendMessage(byte[] message) {
-        gWebSocket.send(message);
-        return this;
-    }
-
-    @Override
-    public WebSocket stream(byte[] fragment, boolean last) {
-        if (isNonEmpty(fragment)) {
-            gWebSocket.stream(last, fragment, 0, fragment.length);
-        }
-        return this;
-    }
-
-    @Override
-    public WebSocket stream(byte[] fragment, int offset, int len, boolean last) {
-        if (isNonEmpty(fragment)) {
-            gWebSocket.stream(last, fragment, offset, len);
-        }
-        return this;
-    }
-
-    @Override
-    public WebSocket sendMessage(String message) {
-        gWebSocket.send(message);
-        return this;
-    }
-
-    @Override
-    public WebSocket stream(String fragment, boolean last) {
-        gWebSocket.stream(last, fragment);
-        return this;
-    }
-
-    @Override
-    public WebSocket sendPing(byte[] payload) {
-        gWebSocket.sendPing(payload);
-        return this;
-    }
-
-    @Override
-    public WebSocket sendPong(byte[] payload) {
-        gWebSocket.sendPong(payload);
-        return this;
-    }
-
-    @Override
-    public WebSocket addWebSocketListener(WebSocketListener l) {
-        gWebSocket.add(new AHCWebSocketListenerAdapter(l, this));
-        return this;
-    }
-
-    @Override
-    public WebSocket removeWebSocketListener(WebSocketListener l) {
-        gWebSocket.remove(new AHCWebSocketListenerAdapter(l, this));
-        return this;
-    }
-
-    @Override
-    public boolean isOpen() {
-        return gWebSocket.isConnected();
-    }
-
-    @Override
-    public void close() {
-        gWebSocket.close();
-    }
-
-    // ---------------------------------------------------------- Public Methods
-
-    public SimpleWebSocket getGrizzlyWebSocket() {
-        return gWebSocket;
-    }
-
-} // END GrizzlyWebSocketAdapter
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncProviderBasicTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncProviderBasicTest.java
deleted file mode 100644
index 3c9403e20..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncProviderBasicTest.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.AsyncHttpProviderConfig;
-import org.asynchttpclient.async.AsyncProvidersBasicTest;
-import org.testng.annotations.Test;
-
-@Test
-public class GrizzlyAsyncProviderBasicTest extends AsyncProvidersBasicTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-
-    @Override
-    protected AsyncHttpProviderConfig<?, ?> getProviderConfig() {
-        final GrizzlyAsyncHttpProviderConfig config = new GrizzlyAsyncHttpProviderConfig();
-        return config;
-    }
-
-    @Override
-    protected String acceptEncodingHeader() {
-        return "gzip";
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncStreamHandlerTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncStreamHandlerTest.java
deleted file mode 100644
index 5f4dfd49b..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncStreamHandlerTest.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.AsyncStreamHandlerTest;
-
-public class GrizzlyAsyncStreamHandlerTest extends AsyncStreamHandlerTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyBasicAuthTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyBasicAuthTest.java
deleted file mode 100644
index 08387273a..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyBasicAuthTest.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.BasicAuthTest;
-
-public class GrizzlyBasicAuthTest extends BasicAuthTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-
-    @Override
-    public String getProviderClass() {
-        return GrizzlyAsyncHttpProvider.class.getName();
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyBasicHttpsTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyBasicHttpsTest.java
deleted file mode 100644
index c2cedc0ee..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyBasicHttpsTest.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.BasicHttpsTest;
-
-public class GrizzlyBasicHttpsTest extends BasicHttpsTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyBodyChunkTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyBodyChunkTest.java
deleted file mode 100644
index 782d97308..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyBodyChunkTest.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.BodyChunkTest;
-
-public class GrizzlyBodyChunkTest extends BodyChunkTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyBodyDeferringAsyncHandlerTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyBodyDeferringAsyncHandlerTest.java
deleted file mode 100644
index 92a236599..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyBodyDeferringAsyncHandlerTest.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.BodyDeferringAsyncHandlerTest;
-
-public class GrizzlyBodyDeferringAsyncHandlerTest extends BodyDeferringAsyncHandlerTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyByteBufferCapacityTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyByteBufferCapacityTest.java
deleted file mode 100644
index 3151f436e..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyByteBufferCapacityTest.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.ByteBufferCapacityTest;
-import org.testng.annotations.Test;
-
-public class GrizzlyByteBufferCapacityTest extends ByteBufferCapacityTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-
-    @Test(groups = { "standalone", "default_provider" }, enabled = false)
-    public void basicByteBufferTest() throws Exception {
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyChunkingTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyChunkingTest.java
deleted file mode 100644
index eb20e31ab..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyChunkingTest.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.ChunkingTest;
-
-public class GrizzlyChunkingTest extends ChunkingTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyComplexClientTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyComplexClientTest.java
deleted file mode 100644
index 4385eeb3a..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyComplexClientTest.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.ComplexClientTest;
-
-public class GrizzlyComplexClientTest extends ComplexClientTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyConnectionPoolTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyConnectionPoolTest.java
deleted file mode 100644
index be0aed7b7..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyConnectionPoolTest.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNotNull;
-import static org.testng.Assert.fail;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.async.ConnectionPoolTest;
-import org.testng.annotations.Test;
-
-import java.util.concurrent.TimeUnit;
-
-public class GrizzlyConnectionPoolTest extends ConnectionPoolTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-
-    @Override
-    @Test(enabled = false)
-    public void testMaxTotalConnectionsException() {
-    }
-
-    @Override
-    @Test
-    public void multipleMaxConnectionOpenTest() throws Exception {
-        AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setAllowPoolingConnections(true).setConnectionTimeout(5000)
-                .setMaxConnections(1).build();
-        AsyncHttpClient c = getAsyncHttpClient(cg);
-        try {
-            String body = "hello there";
-
-            // once
-            Response response = c.preparePost(getTargetUrl()).setBody(body).execute().get(TIMEOUT, TimeUnit.SECONDS);
-
-            assertEquals(response.getResponseBody(), body);
-
-            // twice
-            Exception exception = null;
-            try {
-                c.preparePost(String.format("http://127.0.0.1:%d/foo/test", port2)).setBody(body).execute().get(TIMEOUT, TimeUnit.SECONDS);
-                fail("Should throw exception. Too many connections issued.");
-            } catch (Exception ex) {
-                ex.printStackTrace();
-                exception = ex;
-            }
-            assertNotNull(exception);
-        } finally {
-            c.close();
-        }
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyDigestAuthTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyDigestAuthTest.java
deleted file mode 100644
index ab5c9b901..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyDigestAuthTest.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.DigestAuthTest;
-
-public class GrizzlyDigestAuthTest extends DigestAuthTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyEmptyBodyTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyEmptyBodyTest.java
deleted file mode 100644
index 58cd22bd2..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyEmptyBodyTest.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.EmptyBodyTest;
-
-public class GrizzlyEmptyBodyTest extends EmptyBodyTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyErrorResponseTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyErrorResponseTest.java
deleted file mode 100644
index a3f52b827..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyErrorResponseTest.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.ErrorResponseTest;
-
-public class GrizzlyErrorResponseTest extends ErrorResponseTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyExpectContinue100Test.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyExpectContinue100Test.java
deleted file mode 100644
index fe1f7cff1..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyExpectContinue100Test.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.Expect100ContinueTest;
-
-public class GrizzlyExpectContinue100Test extends Expect100ContinueTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyFeedableBodyGeneratorTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyFeedableBodyGeneratorTest.java
deleted file mode 100644
index 2beca1a78..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyFeedableBodyGeneratorTest.java
+++ /dev/null
@@ -1,437 +0,0 @@
-/*
- * Copyright (c) 2013-2014 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.URL;
-import java.util.Random;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.TimeUnit;
-import org.asynchttpclient.AsyncCompletionHandler;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.DefaultAsyncHttpClient;
-import org.asynchttpclient.RequestBuilder;
-import org.asynchttpclient.providers.grizzly.FeedableBodyGenerator.NonBlockingFeeder;
-import org.glassfish.grizzly.Buffer;
-import org.glassfish.grizzly.http.server.HttpHandler;
-import org.glassfish.grizzly.http.server.HttpServer;
-import org.glassfish.grizzly.http.server.NetworkListener;
-import static org.glassfish.grizzly.http.server.NetworkListener.DEFAULT_NETWORK_HOST;
-import org.glassfish.grizzly.http.server.Request;
-import org.glassfish.grizzly.http.server.Response;
-import org.glassfish.grizzly.memory.Buffers;
-import static org.glassfish.grizzly.memory.MemoryManager.DEFAULT_MEMORY_MANAGER;
-import org.glassfish.grizzly.ssl.SSLContextConfigurator;
-import org.glassfish.grizzly.ssl.SSLEngineConfigurator;
-import org.glassfish.grizzly.utils.Charsets;
-import static org.testng.Assert.assertNull;
-import static org.testng.Assert.fail;
-import static org.testng.AssertJUnit.assertEquals;
-import org.testng.annotations.AfterMethod;
-import org.testng.annotations.BeforeMethod;
-import org.testng.annotations.Test;
-
-public class GrizzlyFeedableBodyGeneratorTest {
-
-    private static final byte[] DATA =
-            "aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ".getBytes(Charsets.ASCII_CHARSET);
-    private static final int TEMP_FILE_SIZE = 2 * 1024 * 1024;
-    private static final int NON_SECURE_PORT = 9991;
-    private static final int SECURE_PORT = 9992;
-
-
-    private HttpServer server;
-    private File tempFile;
-
-
-    // ------------------------------------------------------------------- Setup
-
-
-    @BeforeMethod
-    public void setup() throws Exception {
-        generateTempFile();
-        server = new HttpServer();
-        NetworkListener nonSecure =
-                new NetworkListener("nonsecure",
-                                    DEFAULT_NETWORK_HOST,
-                                    NON_SECURE_PORT);
-        NetworkListener secure =
-                new NetworkListener("secure",
-                                    DEFAULT_NETWORK_HOST,
-                                    SECURE_PORT);
-        secure.setSecure(true);
-        secure.setSSLEngineConfig(createSSLConfig());
-        server.addListener(nonSecure);
-        server.addListener(secure);
-        server.getServerConfiguration().addHttpHandler(new ConsumingHandler(), "/test");
-        server.start();
-    }
-
-
-    // --------------------------------------------------------------- Tear Down
-
-
-    @AfterMethod
-    public void tearDown() {
-        if (!tempFile.delete()) {
-            tempFile.deleteOnExit();
-        }
-        tempFile = null;
-        server.shutdownNow();
-        server = null;
-    }
-
-
-    // ------------------------------------------------------------ Test Methods
-
-
-    @Test
-    public void testSimpleFeederMultipleThreads() throws Exception {
-        doSimpleFeeder(false);
-    }
-
-    @Test
-    public void testSimpleFeederOverSSLMultipleThreads() throws Exception {
-        doSimpleFeeder(true);
-    }
-
-    @Test
-    public void testNonBlockingFeederMultipleThreads() throws Exception {
-        doNonBlockingFeeder(false);
-    }
-
-    @Test
-    public void testNonBlockingFeederOverSSLMultipleThreads() throws Exception {
-        doNonBlockingFeeder(true);
-    }
-
-    // --------------------------------------------------------- Private Methods
-
-
-    private void doSimpleFeeder(final boolean secure) {
-        final int threadCount = 10;
-        final CountDownLatch latch = new CountDownLatch(threadCount);
-        final int port = (secure ? SECURE_PORT : NON_SECURE_PORT);
-        final String scheme = (secure ? "https" : "http");
-        ExecutorService service = Executors.newFixedThreadPool(threadCount);
-
-        AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder()
-                .setMaxConnectionsPerHost(60)
-                .setMaxConnections(60)
-                .setAcceptAnyCertificate(true)
-                .build();
-        final AsyncHttpClient client =
-                new DefaultAsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
-        final int[] statusCodes = new int[threadCount];
-        final int[] totalsReceived = new int[threadCount];
-        final Throwable[] errors = new Throwable[threadCount];
-        for (int i = 0; i < threadCount; i++) {
-            final int idx = i;
-            service.execute(new Runnable() {
-                @Override
-                public void run() {
-                    FeedableBodyGenerator generator =
-                            new FeedableBodyGenerator();
-                    FeedableBodyGenerator.SimpleFeeder simpleFeeder =
-                            new FeedableBodyGenerator.SimpleFeeder(generator) {
-                                @Override
-                                public void flush() throws IOException {
-                                    FileInputStream in = null;
-                                    try {
-                                        final byte[] bytesIn = new byte[2048];
-                                        in = new FileInputStream(tempFile);
-                                        int read;
-                                        while ((read = in.read(bytesIn)) != -1) {
-                                            final Buffer b =
-                                                    Buffers.wrap(
-                                                            DEFAULT_MEMORY_MANAGER,
-                                                            bytesIn,
-                                                            0,
-                                                            read);
-                                            feed(b, false);
-                                        }
-                                        feed(Buffers.EMPTY_BUFFER, true);
-                                    } finally {
-                                        if (in != null) {
-                                            try {
-                                                in.close();
-                                            } catch (IOException ignored) {
-                                            }
-                                        }
-                                    }
-                                }
-                            };
-                    generator.setFeeder(simpleFeeder);
-                    generator.setMaxPendingBytes(10000);
-
-                    RequestBuilder builder = new RequestBuilder("POST");
-                    builder.setUrl(scheme + "://localhost:" + port + "/test");
-                    builder.setBody(generator);
-                    try {
-                        client.executeRequest(builder.build(),
-                                new AsyncCompletionHandler<org.asynchttpclient.Response>() {
-                                    @Override
-                                    public org.asynchttpclient.Response onCompleted(org.asynchttpclient.Response response)
-                                    throws Exception {
-                                        try {
-                                            totalsReceived[idx] = Integer.parseInt(response.getHeader("x-total"));
-                                        } catch (Exception e) {
-                                            errors[idx] = e;
-                                        }
-                                        statusCodes[idx] = response.getStatusCode();
-                                        latch.countDown();
-                                        return response;
-                                    }
-
-                                    @Override
-                                    public void onThrowable(Throwable t) {
-                                        errors[idx] = t;
-                                        t.printStackTrace();
-                                        latch.countDown();
-                                    }
-                               });
-                    } catch (IOException e) {
-                        errors[idx] = e;
-                        latch.countDown();
-                    }
-                }
-            });
-        }
-
-        try {
-            latch.await(1, TimeUnit.MINUTES);
-        } catch (InterruptedException e) {
-            fail("Latch interrupted");
-        }
-
-        for (int i = 0; i < threadCount; i++) {
-            assertEquals(200, statusCodes[i]);
-            assertNull(errors[i]);
-            assertEquals(tempFile.length(), totalsReceived[i]);
-        }
-    }
-
-    private void doNonBlockingFeeder(final boolean secure) {
-        final int threadCount = 10;
-        final CountDownLatch latch = new CountDownLatch(threadCount);
-        final int port = (secure ? SECURE_PORT : NON_SECURE_PORT);
-        final String scheme = (secure ? "https" : "http");
-        final ExecutorService service = Executors.newCachedThreadPool();
-
-        AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder()
-                .setMaxConnectionsPerHost(60)
-                .setMaxConnections(60)
-                .setAcceptAnyCertificate(true)
-                .build();
-        final AsyncHttpClient client =
-                new DefaultAsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
-        final int[] statusCodes = new int[threadCount];
-        final int[] totalsReceived = new int[threadCount];
-        final Throwable[] errors = new Throwable[threadCount];
-        for (int i = 0; i < threadCount; i++) {
-            final int idx = i;
-            service.execute(new Runnable() {
-                @Override
-                public void run() {
-                    FeedableBodyGenerator generator =
-                            new FeedableBodyGenerator();
-                    FeedableBodyGenerator.NonBlockingFeeder nonBlockingFeeder =
-                            new FeedableBodyGenerator.NonBlockingFeeder(generator) {
-                                private final Random r = new Random();
-                                private final InputStream in;
-                                private final byte[] bytesIn = new byte[2048];
-                                private boolean isDone;
-                                
-                                {
-                                    try {
-                                        in = new FileInputStream(tempFile);
-                                    } catch (IOException e) {
-                                        throw new IllegalStateException(e);
-                                    }
-                                }
-
-                                @Override
-                                public void canFeed() throws IOException {
-                                    final int read = in.read(bytesIn);
-                                    if (read == -1) {
-                                        isDone = true;
-                                        feed(Buffers.EMPTY_BUFFER, true);
-                                        return;
-                                    }
-
-                                    final Buffer b =
-                                            Buffers.wrap(
-                                                    DEFAULT_MEMORY_MANAGER,
-                                                    bytesIn,
-                                                    0,
-                                                    read);
-                                    feed(b, false);
-                                }
-
-                                @Override
-                                public boolean isDone() {
-                                    return isDone;
-                                }
-
-                                @Override
-                                public boolean isReady() {
-                                    // simulate real-life usecase, where data could not be ready
-                                    return r.nextInt(100) < 80;
-                                }
-
-                                @Override
-                                public void notifyReadyToFeed(
-                                        final NonBlockingFeeder.ReadyToFeedListener listener) {
-                                    service.execute(new Runnable() {
-
-                                        public void run() {
-                                            try {
-                                                Thread.sleep(2);
-                                            } catch (InterruptedException e) {
-                                            }
-                                            
-                                            listener.ready();
-                                        }
-                                        
-                                    });
-                                }
-                            };
-                    generator.setFeeder(nonBlockingFeeder);
-                    generator.setMaxPendingBytes(10000);
-
-                    RequestBuilder builder = new RequestBuilder("POST");
-                    builder.setUrl(scheme + "://localhost:" + port + "/test");
-                    builder.setBody(generator);
-                    try {
-                        client.executeRequest(builder.build(),
-                                new AsyncCompletionHandler<org.asynchttpclient.Response>() {
-                                    @Override
-                                    public org.asynchttpclient.Response onCompleted(org.asynchttpclient.Response response)
-                                    throws Exception {
-                                        try {
-                                            totalsReceived[idx] = Integer.parseInt(response.getHeader("x-total"));
-                                        } catch (Exception e) {
-                                            errors[idx] = e;
-                                        }
-                                        statusCodes[idx] = response.getStatusCode();
-                                        latch.countDown();
-                                        return response;
-                                    }
-
-                                    @Override
-                                    public void onThrowable(Throwable t) {
-                                        errors[idx] = t;
-                                        t.printStackTrace();
-                                        latch.countDown();
-                                    }
-                               });
-                    } catch (IOException e) {
-                        errors[idx] = e;
-                        latch.countDown();
-                    }
-                }
-            });
-        }
-
-        try {
-            latch.await(1, TimeUnit.MINUTES);
-        } catch (InterruptedException e) {
-            fail("Latch interrupted");
-        } finally {
-            service.shutdownNow();
-        }
-
-        for (int i = 0; i < threadCount; i++) {
-            assertEquals(200, statusCodes[i]);
-            assertNull(errors[i]);
-            assertEquals(tempFile.length(), totalsReceived[i]);
-        }
-    }
-    
-    private static SSLEngineConfigurator createSSLConfig()
-    throws Exception {
-        final SSLContextConfigurator sslContextConfigurator =
-                new SSLContextConfigurator();
-        final ClassLoader cl = GrizzlyFeedableBodyGeneratorTest.class.getClassLoader();
-        // override system properties
-        final URL cacertsUrl = cl.getResource("ssltest-cacerts.jks");
-        if (cacertsUrl != null) {
-            sslContextConfigurator.setTrustStoreFile(cacertsUrl.getFile());
-            sslContextConfigurator.setTrustStorePass("changeit");
-        }
-
-        // override system properties
-        final URL keystoreUrl = cl.getResource("ssltest-keystore.jks");
-        if (keystoreUrl != null) {
-            sslContextConfigurator.setKeyStoreFile(keystoreUrl.getFile());
-            sslContextConfigurator.setKeyStorePass("changeit");
-        }
-
-        return new SSLEngineConfigurator(
-                sslContextConfigurator.createSSLContext(),
-                false, false, false);
-    }
-
-
-    private void generateTempFile() throws IOException {
-        tempFile = File.createTempFile("feedable", null);
-        int total = 0;
-        byte[] chunk = new byte[1024];
-        Random r = new Random(System.currentTimeMillis());
-        FileOutputStream out = new FileOutputStream(tempFile);
-        while (total < TEMP_FILE_SIZE) {
-            for (int i = 0; i < chunk.length; i++) {
-                chunk[i] = DATA[r.nextInt(DATA.length)];
-            }
-            out.write(chunk);
-            total += chunk.length;
-        }
-        out.flush();
-        out.close();
-    }
-
-
-    // ---------------------------------------------------------- Nested Classes
-
-
-    private static final class ConsumingHandler extends HttpHandler {
-
-
-        // -------------------------------------------- Methods from HttpHandler
-
-
-        @Override
-        public void service(Request request, Response response)
-        throws Exception {
-            int total = 0;
-            byte[] bytesIn = new byte[2048];
-            InputStream in = request.getInputStream();
-            int read;
-            while ((read = in.read(bytesIn)) != -1) {
-                total += read;
-                Thread.sleep(5);
-            }
-            response.addHeader("X-Total", Integer.toString(total));
-        }
-
-    } // END ConsumingHandler
-
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyFilterTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyFilterTest.java
deleted file mode 100644
index b45f00a31..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyFilterTest.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.FilterTest;
-
-public class GrizzlyFilterTest extends FilterTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyFollowingThreadTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyFollowingThreadTest.java
deleted file mode 100644
index 4f3c80361..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyFollowingThreadTest.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.FollowingThreadTest;
-
-public class GrizzlyFollowingThreadTest extends FollowingThreadTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyHead302Test.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyHead302Test.java
deleted file mode 100644
index af3f92b7d..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyHead302Test.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.Head302Test;
-
-public class GrizzlyHead302Test extends Head302Test {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyHostnameVerifierTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyHostnameVerifierTest.java
deleted file mode 100644
index 7453f6a24..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyHostnameVerifierTest.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (c) 2013 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.HostnameVerifierTest;
-
-public class GrizzlyHostnameVerifierTest extends HostnameVerifierTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyHttpToHttpsRedirectTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyHttpToHttpsRedirectTest.java
deleted file mode 100644
index bd14ab34b..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyHttpToHttpsRedirectTest.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.HttpToHttpsRedirectTest;
-
-public class GrizzlyHttpToHttpsRedirectTest extends HttpToHttpsRedirectTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyIdleStateHandlerTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyIdleStateHandlerTest.java
deleted file mode 100644
index adc6a1641..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyIdleStateHandlerTest.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.IdleStateHandlerTest;
-
-public class GrizzlyIdleStateHandlerTest extends IdleStateHandlerTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyInputStreamTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyInputStreamTest.java
deleted file mode 100644
index 60503e83c..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyInputStreamTest.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.InputStreamTest;
-
-public class GrizzlyInputStreamTest extends InputStreamTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyListenableFutureTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyListenableFutureTest.java
deleted file mode 100644
index 866a09729..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyListenableFutureTest.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.ListenableFutureTest;
-
-public class GrizzlyListenableFutureTest extends ListenableFutureTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyMaxConnectionsInThreadsTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyMaxConnectionsInThreadsTest.java
deleted file mode 100644
index f07f7abfe..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyMaxConnectionsInThreadsTest.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.MaxConnectionsInThreads;
-import org.testng.annotations.Test;
-
-public class GrizzlyMaxConnectionsInThreadsTest extends MaxConnectionsInThreads {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-
-    @Override
-    @Test(enabled = false)
-    public void testMaxConnectionsWithinThreads() {
-        super.testMaxConnectionsWithinThreads();
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyMaxTotalConnectionTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyMaxTotalConnectionTest.java
deleted file mode 100644
index f5593bd81..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyMaxTotalConnectionTest.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.MaxTotalConnectionTest;
-
-public class GrizzlyMaxTotalConnectionTest extends MaxTotalConnectionTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyMultipleHeaderTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyMultipleHeaderTest.java
deleted file mode 100644
index 3cf596576..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyMultipleHeaderTest.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.MultipleHeaderTest;
-
-public class GrizzlyMultipleHeaderTest extends MultipleHeaderTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyNoNullResponseTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyNoNullResponseTest.java
deleted file mode 100644
index 3dfe5a935..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyNoNullResponseTest.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.NoNullResponseTest;
-
-public class GrizzlyNoNullResponseTest extends NoNullResponseTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyNoTransferEncodingTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyNoTransferEncodingTest.java
deleted file mode 100644
index 17ddbb69c..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyNoTransferEncodingTest.java
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * Copyright (c) 2014 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.DefaultAsyncHttpClient;
-import org.glassfish.grizzly.http.server.HttpHandler;
-import org.glassfish.grizzly.http.server.HttpServer;
-import org.glassfish.grizzly.http.server.NetworkListener;
-import static org.glassfish.grizzly.http.server.NetworkListener.DEFAULT_NETWORK_HOST;
-import org.glassfish.grizzly.http.server.Request;
-import org.glassfish.grizzly.http.server.Response;
-import org.testng.Assert;
-import org.testng.annotations.AfterMethod;
-import org.testng.annotations.BeforeMethod;
-import org.testng.annotations.Test;
-
-public class GrizzlyNoTransferEncodingTest {
-    private static final String TEST_MESSAGE = "Hello World!";
-    
-    private HttpServer server;
-    private int port;
-    // ------------------------------------------------------------------- Setup
-
-
-    @BeforeMethod
-    public void setup() throws Exception {
-        server = new HttpServer();
-        final NetworkListener listener =
-                new NetworkListener("server",
-                                    DEFAULT_NETWORK_HOST,
-                                    0);
-        // disable chunking
-        listener.setChunkingEnabled(false);
-        server.addListener(listener);
-        server.getServerConfiguration().addHttpHandler(
-                new HttpHandler() {
-
-                    @Override
-                    public void service(final Request request,
-                            final Response response) throws Exception {
-                        response.setContentType("plain/text;charset=\"utf-8\"");
-                        // flush to make sure content-length will be missed
-                        response.flush();
-                        
-                        response.getWriter().write(TEST_MESSAGE);
-                    }
-                }, "/test");
-        
-        server.start();
-        
-        port = listener.getPort();
-    }
-
-
-    // --------------------------------------------------------------- Tear Down
-
-
-    @AfterMethod
-    public void tearDown() {
-        server.shutdownNow();
-        server = null;
-    }
-
-
-    // ------------------------------------------------------------ Test Methods
-
-
-    @Test
-    public void testNoTransferEncoding() throws Exception {
-        String url = "http://localhost:" + port + "/test";
-
-        AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder()
-            .setFollowRedirect(false)
-            .setConnectionTimeout(15000)
-            .setRequestTimeout(15000)
-            .setAllowPoolingConnections(false)
-            .setDisableUrlEncodingForBoundRequests(true)
-            .setIOThreadMultiplier(2) // 2 is default
-            .build();
-
-        AsyncHttpClient client = new DefaultAsyncHttpClient(
-                new GrizzlyAsyncHttpProvider(config), config);
-
-        try {
-            Future<org.asynchttpclient.Response> f = client.prepareGet(url).execute();
-            org.asynchttpclient.Response r = f.get(10, TimeUnit.SECONDS);
-            Assert.assertEquals(TEST_MESSAGE, r.getResponseBody());
-        } finally {
-            client.close();
-        }
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyNonAsciiContentLengthTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyNonAsciiContentLengthTest.java
deleted file mode 100644
index 7534360a3..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyNonAsciiContentLengthTest.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.NonAsciiContentLengthTest;
-
-public class GrizzlyNonAsciiContentLengthTest extends NonAsciiContentLengthTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyParamEncodingTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyParamEncodingTest.java
deleted file mode 100644
index c49beec01..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyParamEncodingTest.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.ParamEncodingTest;
-
-public class GrizzlyParamEncodingTest extends ParamEncodingTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPerRequestRelative302Test.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPerRequestRelative302Test.java
deleted file mode 100644
index 9f7aa9797..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPerRequestRelative302Test.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.PerRequestRelative302Test;
-
-public class GrizzlyPerRequestRelative302Test extends PerRequestRelative302Test {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPerRequestTimeoutTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPerRequestTimeoutTest.java
deleted file mode 100644
index 14bccfc9d..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPerRequestTimeoutTest.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import static org.testng.Assert.assertEquals;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.PerRequestTimeoutTest;
-
-public class GrizzlyPerRequestTimeoutTest extends PerRequestTimeoutTest {
-
-    @Override
-    protected void checkTimeoutMessage(String message) {
-        assertEquals(message, "Timeout exceeded");
-    }
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPostRedirectGetTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPostRedirectGetTest.java
deleted file mode 100644
index aeab91c4c..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPostRedirectGetTest.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.PostRedirectGetTest;
-
-public class GrizzlyPostRedirectGetTest extends PostRedirectGetTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPostWithQSTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPostWithQSTest.java
deleted file mode 100644
index 70f67cfc7..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPostWithQSTest.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.PostWithQSTest;
-
-public class GrizzlyPostWithQSTest extends PostWithQSTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyProxyTunnelingTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyProxyTunnelingTest.java
deleted file mode 100644
index 1828989c4..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyProxyTunnelingTest.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright (c) 2012-2013 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.ProxyTunnellingTest;
-
-public class GrizzlyProxyTunnelingTest extends ProxyTunnellingTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-
-    @Override
-    public String getProviderClass() {
-        return GrizzlyAsyncHttpProvider.class.getName();
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPutLargeFileTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPutLargeFileTest.java
deleted file mode 100644
index a3c3bfd6b..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyPutLargeFileTest.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.PutLargeFileTest;
-
-public class GrizzlyPutLargeFileTest extends PutLargeFileTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyQueryParametersTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyQueryParametersTest.java
deleted file mode 100644
index 36ad0a8d5..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyQueryParametersTest.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.QueryParametersTest;
-
-public class GrizzlyQueryParametersTest extends QueryParametersTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRC10KTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRC10KTest.java
deleted file mode 100644
index ef43002b5..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRC10KTest.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.RC10KTest;
-
-public class GrizzlyRC10KTest extends RC10KTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRedirectConnectionUsageTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRedirectConnectionUsageTest.java
deleted file mode 100644
index b9fbc218a..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRedirectConnectionUsageTest.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.RedirectConnectionUsageTest;
-
-public class GrizzlyRedirectConnectionUsageTest extends RedirectConnectionUsageTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRelative302Test.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRelative302Test.java
deleted file mode 100644
index 6b0dffe2c..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRelative302Test.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.Relative302Test;
-
-public class GrizzlyRelative302Test extends Relative302Test {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRemoteSiteTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRemoteSiteTest.java
deleted file mode 100644
index cdfa5455f..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRemoteSiteTest.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.RemoteSiteTest;
-
-public class GrizzlyRemoteSiteTest extends RemoteSiteTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRetryRequestTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRetryRequestTest.java
deleted file mode 100644
index 8f27e132b..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyRetryRequestTest.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.RetryRequestTest;
-
-public class GrizzlyRetryRequestTest extends RetryRequestTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlySimpleAsyncClientErrorBehaviourTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlySimpleAsyncClientErrorBehaviourTest.java
deleted file mode 100644
index db9a6a157..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlySimpleAsyncClientErrorBehaviourTest.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.SimpleAsyncClientErrorBehaviourTest;
-
-public class GrizzlySimpleAsyncClientErrorBehaviourTest extends SimpleAsyncClientErrorBehaviourTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-
-    public String getProviderClass() {
-        return GrizzlyAsyncHttpProvider.class.getName();
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlySimpleAsyncHttpClientTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlySimpleAsyncHttpClientTest.java
deleted file mode 100644
index dbd541b93..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlySimpleAsyncHttpClientTest.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.SimpleAsyncHttpClientTest;
-
-public class GrizzlySimpleAsyncHttpClientTest extends SimpleAsyncHttpClientTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-
-    public String getProviderClass() {
-        return GrizzlyAsyncHttpProvider.class.getName();
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyTransferListenerTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyTransferListenerTest.java
deleted file mode 100644
index 6173dbab4..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyTransferListenerTest.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.TransferListenerTest;
-
-public class GrizzlyTransferListenerTest extends TransferListenerTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyUnexpectingTimeoutTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyUnexpectingTimeoutTest.java
deleted file mode 100644
index 3829983aa..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyUnexpectingTimeoutTest.java
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
- * Copyright (c) 2012-2013 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly;
-
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertFalse;
-import static org.testng.Assert.assertNull;
-import static org.testng.Assert.fail;
-
-import org.asynchttpclient.AsyncCompletionHandler;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.async.AbstractBasicTest;
-import org.eclipse.jetty.continuation.Continuation;
-import org.eclipse.jetty.continuation.ContinuationSupport;
-import org.eclipse.jetty.server.Request;
-import org.eclipse.jetty.server.handler.AbstractHandler;
-import org.testng.annotations.Test;
-
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import java.io.IOException;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeoutException;
-import java.util.concurrent.atomic.AtomicInteger;
-
-public class GrizzlyUnexpectingTimeoutTest extends AbstractBasicTest {
-
-    private static final String MSG = "Unauthorized without WWW-Authenticate header";
-
-    protected String getExpectedTimeoutMessage() {
-        return "401 response received, but no WWW-Authenticate header was present";
-    }
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-
-    @Override
-    public AbstractHandler configureHandler() throws Exception {
-        return new ExpectExceptionHandler();
-    }
-
-    private class ExpectExceptionHandler extends AbstractHandler {
-        public void handle(String target, Request baseRequest, HttpServletRequest request, final HttpServletResponse response)
-                throws IOException, ServletException {
-            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
-            final Continuation continuation = ContinuationSupport.getContinuation(request);
-            continuation.suspend();
-            new Thread(new Runnable() {
-                public void run() {
-                    try {
-                        response.getOutputStream().print(MSG);
-                        response.getOutputStream().flush();
-                    } catch (IOException e) {
-                        logger.error(e.getMessage(), e);
-                    }
-                }
-            }).start();
-            baseRequest.setHandled(true);
-        }
-    }
-
-    @Test(groups = { "standalone", "default_provider" })
-    public void unexpectingTimeoutTest() throws IOException {
-        final AtomicInteger counts = new AtomicInteger();
-        final int timeout = 100;
-
-        final AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeout(timeout).build());
-        try {
-            Future<Response> responseFuture = client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandler<Response>() {
-                @Override
-                public Response onCompleted(Response response) throws Exception {
-                    counts.incrementAndGet();
-                    return response;
-                }
-
-                @Override
-                public void onThrowable(Throwable t) {
-                    counts.incrementAndGet();
-                    super.onThrowable(t);
-                }
-            });
-            // currently, an exception is expected
-            // because the grizzly provider would throw IllegalStateException if WWW-Authenticate header doesn't exist with 401 response status.
-            try {
-                Response response = responseFuture.get();
-                assertNull(response);
-            } catch (InterruptedException e) {
-                fail("Interrupted.", e);
-            } catch (ExecutionException e) {
-                assertFalse(e.getCause() instanceof TimeoutException);
-                assertEquals(e.getCause().getMessage(), getExpectedTimeoutMessage());
-            }
-            // wait for timeout again.
-            try {
-                Thread.sleep(timeout * 2);
-            } catch (InterruptedException e) {
-                fail("Interrupted.", e);
-            }
-            // the result should be either onCompleted or onThrowable.
-            assertEquals(counts.get(), 1, "result should be one");
-        } finally {
-            client.close();
-        }
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyByteMessageTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyByteMessageTest.java
deleted file mode 100644
index 7a809b1d7..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyByteMessageTest.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.grizzly.websocket;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.providers.grizzly.GrizzlyProviderUtil;
-import org.asynchttpclient.websocket.ByteMessageTest;
-import org.testng.annotations.Test;
-
-public class GrizzlyByteMessageTest extends ByteMessageTest {
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-
-    @Test(timeOut = 60000)
-    @Override
-    public void echoFragments() throws Exception {
-        super.echoFragments();
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyCloseCodeReasonMsgTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyCloseCodeReasonMsgTest.java
deleted file mode 100644
index 7ff2884f7..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyCloseCodeReasonMsgTest.java
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly.websocket;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.providers.grizzly.GrizzlyProviderUtil;
-import org.asynchttpclient.websocket.CloseCodeReasonMessageTest;
-
-public class GrizzlyCloseCodeReasonMsgTest extends CloseCodeReasonMessageTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyRedirectTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyRedirectTest.java
deleted file mode 100644
index d01f2424d..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyRedirectTest.java
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-
-package org.asynchttpclient.providers.grizzly.websocket;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.providers.grizzly.GrizzlyProviderUtil;
-import org.asynchttpclient.websocket.RedirectTest;
-
-public class GrizzlyRedirectTest extends RedirectTest {
-
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyTextMessageTest.java b/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyTextMessageTest.java
deleted file mode 100644
index c89bb0b0f..000000000
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyTextMessageTest.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.grizzly.websocket;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.providers.grizzly.GrizzlyProviderUtil;
-import org.asynchttpclient.websocket.ByteMessageTest;
-
-public class GrizzlyTextMessageTest extends ByteMessageTest {
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
-    }
-}
diff --git a/providers/netty/pom.xml b/providers/netty/pom.xml
deleted file mode 100644
index 57510c4cf..000000000
--- a/providers/netty/pom.xml
+++ /dev/null
@@ -1,51 +0,0 @@
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-    <parent>
-        <groupId>org.asynchttpclient</groupId>
-        <artifactId>async-http-client-providers-parent</artifactId>
-        <version>2.0.0-SNAPSHOT</version>
-    </parent>
-    <modelVersion>4.0.0</modelVersion>
-    <artifactId>async-http-client-netty-provider</artifactId>
-    <name>Asynchronous Http Client Netty 4 Provider</name>
-    <description>
-        The Async Http Client Netty 4 Provider.
-    </description>
-
-    <repositories>
-        <repository>
-            <id>sonatype-releases</id>
-            <url>https://oss.sonatype.org/content/repositories/releases</url>
-            <releases>
-                <enabled>true</enabled>
-            </releases>
-            <snapshots>
-                <enabled>false</enabled>
-            </snapshots>
-        </repository>
-        <repository>
-            <id>sonatype-snapshots</id>
-            <url>https://oss.sonatype.org/content/repositories/snapshots</url>
-            <releases>
-                <enabled>false</enabled>
-            </releases>
-            <snapshots>
-                <enabled>true</enabled>
-            </snapshots>
-        </repository>
-    </repositories>
-
-    <dependencies>
-        <dependency>
-            <groupId>io.netty</groupId>
-            <artifactId>netty-all</artifactId>
-            <version>4.0.23.Final</version>
-        </dependency>
-        <dependency>
-            <groupId>org.javassist</groupId>
-            <artifactId>javassist</artifactId>
-            <version>3.18.2-GA</version>
-        </dependency>
-    </dependencies>
-
-</project>
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyAsyncHttpProviderConfig.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyAsyncHttpProviderConfig.java
deleted file mode 100755
index ce81243a5..000000000
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyAsyncHttpProviderConfig.java
+++ /dev/null
@@ -1,313 +0,0 @@
-/*
- * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at
- *     http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import io.netty.buffer.ByteBuf;
-import io.netty.channel.Channel;
-import io.netty.channel.ChannelOption;
-import io.netty.channel.EventLoopGroup;
-import io.netty.util.Timer;
-
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Set;
-
-import org.asynchttpclient.AsyncHttpProviderConfig;
-import org.asynchttpclient.SSLEngineFactory;
-import org.asynchttpclient.providers.netty.channel.pool.ChannelPool;
-import org.asynchttpclient.providers.netty.response.EagerNettyResponseBodyPart;
-import org.asynchttpclient.providers.netty.response.LazyNettyResponseBodyPart;
-import org.asynchttpclient.providers.netty.response.NettyResponseBodyPart;
-import org.asynchttpclient.providers.netty.ws.NettyWebSocket;
-
-/**
- * This class can be used to pass Netty's internal configuration options. See
- * Netty documentation for more information.
- */
-public class NettyAsyncHttpProviderConfig implements AsyncHttpProviderConfig<ChannelOption<Object>, Object> {
-
-    private final Map<ChannelOption<Object>, Object> properties = new HashMap<ChannelOption<Object>, Object>();
-
-    /**
-     * Add a property that will be used when the AsyncHttpClient initialize its
-     * {@link org.asynchttpclient.AsyncHttpProvider}
-     * 
-     * @param name the name of the property
-     * @param value the value of the property
-     * @return this instance of AsyncHttpProviderConfig
-     */
-    public NettyAsyncHttpProviderConfig addProperty(ChannelOption<Object> name, Object value) {
-        properties.put(name, value);
-        return this;
-    }
-
-    @SuppressWarnings("unchecked")
-    public <T> NettyAsyncHttpProviderConfig addChannelOption(ChannelOption<T> name, T value) {
-        properties.put((ChannelOption<Object>) name, value);
-        return this;
-    }
-
-    /**
-     * Return the value associated with the property's name
-     * 
-     * @param name
-     * @return this instance of AsyncHttpProviderConfig
-     */
-    public Object getProperty(ChannelOption<Object> name) {
-        return properties.get(name);
-    }
-
-    /**
-     * Remove the value associated with the property's name
-     * 
-     * @param name
-     * @return true if removed
-     */
-    public Object removeProperty(ChannelOption<Object> name) {
-        return properties.remove(name);
-    }
-
-    /**
-     * Return the curent entry set.
-     * 
-     * @return a the curent entry set.
-     */
-    public Set<Map.Entry<ChannelOption<Object>, Object>> propertiesSet() {
-        return properties.entrySet();
-    }
-
-    public static interface AdditionalChannelInitializer {
-
-        void initChannel(Channel ch) throws Exception;
-    }
-
-    public static interface ResponseBodyPartFactory {
-
-        NettyResponseBodyPart newResponseBodyPart(ByteBuf buf, boolean last);
-    }
-
-    public static class EagerResponseBodyPartFactory implements ResponseBodyPartFactory {
-
-        @Override
-        public NettyResponseBodyPart newResponseBodyPart(ByteBuf buf, boolean last) {
-            return new EagerNettyResponseBodyPart(buf, last);
-        }
-    }
-
-    public static class LazyResponseBodyPartFactory implements ResponseBodyPartFactory {
-
-        @Override
-        public NettyResponseBodyPart newResponseBodyPart(ByteBuf buf, boolean last) {
-            return new LazyNettyResponseBodyPart(buf, last);
-        }
-    }
-
-    public static interface NettyWebSocketFactory {
-        NettyWebSocket newNettyWebSocket(Channel channel, NettyAsyncHttpProviderConfig nettyConfig);
-    }
-
-    public class DefaultNettyWebSocketFactory implements NettyWebSocketFactory {
-
-        @Override
-        public NettyWebSocket newNettyWebSocket(Channel channel, NettyAsyncHttpProviderConfig nettyConfig) {
-            return new NettyWebSocket(channel, nettyConfig);
-        }
-    }
-
-    /**
-     * Allow configuring the Netty's event loop.
-     */
-    private EventLoopGroup eventLoopGroup;
-
-    private AdditionalChannelInitializer httpAdditionalChannelInitializer;
-    private AdditionalChannelInitializer wsAdditionalChannelInitializer;
-    private AdditionalChannelInitializer httpsAdditionalChannelInitializer;
-    private AdditionalChannelInitializer wssAdditionalChannelInitializer;
-
-    /**
-     * Allow configuring Netty's HttpClientCodecs.
-     */
-    private int httpClientCodecMaxInitialLineLength = 4096;
-    private int httpClientCodecMaxHeaderSize = 8192;
-    private int httpClientCodecMaxChunkSize = 8192;
-
-    private ResponseBodyPartFactory bodyPartFactory = new EagerResponseBodyPartFactory();
-
-    private ChannelPool channelPool;
-
-    /**
-     * Allow one to disable zero copy for bodies and use chunking instead
-     */
-    private boolean disableZeroCopy;
-
-    private Timer nettyTimer;
-
-    private long handshakeTimeout;
-
-    private SSLEngineFactory sslEngineFactory;
-
-    /**
-     * chunkedFileChunkSize
-     */
-    private int chunkedFileChunkSize = 8192;
-
-    private NettyWebSocketFactory nettyWebSocketFactory = new DefaultNettyWebSocketFactory();
-
-    private int webSocketMaxBufferSize = 128000000;
-
-    private int webSocketMaxFrameSize = 10 * 1024;
-
-    public EventLoopGroup getEventLoopGroup() {
-        return eventLoopGroup;
-    }
-
-    public void setEventLoopGroup(EventLoopGroup eventLoopGroup) {
-        this.eventLoopGroup = eventLoopGroup;
-    }
-
-    public AdditionalChannelInitializer getHttpAdditionalChannelInitializer() {
-        return httpAdditionalChannelInitializer;
-    }
-
-    public void setHttpAdditionalChannelInitializer(AdditionalChannelInitializer httpAdditionalChannelInitializer) {
-        this.httpAdditionalChannelInitializer = httpAdditionalChannelInitializer;
-    }
-
-    public AdditionalChannelInitializer getWsAdditionalChannelInitializer() {
-        return wsAdditionalChannelInitializer;
-    }
-
-    public void setWsAdditionalChannelInitializer(AdditionalChannelInitializer wsAdditionalChannelInitializer) {
-        this.wsAdditionalChannelInitializer = wsAdditionalChannelInitializer;
-    }
-
-    public AdditionalChannelInitializer getHttpsAdditionalChannelInitializer() {
-        return httpsAdditionalChannelInitializer;
-    }
-
-    public void setHttpsAdditionalChannelInitializer(AdditionalChannelInitializer httpsAdditionalChannelInitializer) {
-        this.httpsAdditionalChannelInitializer = httpsAdditionalChannelInitializer;
-    }
-
-    public AdditionalChannelInitializer getWssAdditionalChannelInitializer() {
-        return wssAdditionalChannelInitializer;
-    }
-
-    public void setWssAdditionalChannelInitializer(AdditionalChannelInitializer wssAdditionalChannelInitializer) {
-        this.wssAdditionalChannelInitializer = wssAdditionalChannelInitializer;
-    }
-
-    public int getHttpClientCodecMaxInitialLineLength() {
-        return httpClientCodecMaxInitialLineLength;
-    }
-
-    public void setHttpClientCodecMaxInitialLineLength(int httpClientCodecMaxInitialLineLength) {
-        this.httpClientCodecMaxInitialLineLength = httpClientCodecMaxInitialLineLength;
-    }
-
-    public int getHttpClientCodecMaxHeaderSize() {
-        return httpClientCodecMaxHeaderSize;
-    }
-
-    public void setHttpClientCodecMaxHeaderSize(int httpClientCodecMaxHeaderSize) {
-        this.httpClientCodecMaxHeaderSize = httpClientCodecMaxHeaderSize;
-    }
-
-    public int getHttpClientCodecMaxChunkSize() {
-        return httpClientCodecMaxChunkSize;
-    }
-
-    public void setHttpClientCodecMaxChunkSize(int httpClientCodecMaxChunkSize) {
-        this.httpClientCodecMaxChunkSize = httpClientCodecMaxChunkSize;
-    }
-
-    public ResponseBodyPartFactory getBodyPartFactory() {
-        return bodyPartFactory;
-    }
-
-    public void setBodyPartFactory(ResponseBodyPartFactory bodyPartFactory) {
-        this.bodyPartFactory = bodyPartFactory;
-    }
-
-    public ChannelPool getChannelPool() {
-        return channelPool;
-    }
-
-    public void setChannelPool(ChannelPool channelPool) {
-        this.channelPool = channelPool;
-    }
-
-    public boolean isDisableZeroCopy() {
-        return disableZeroCopy;
-    }
-
-    public void setDisableZeroCopy(boolean disableZeroCopy) {
-        this.disableZeroCopy = disableZeroCopy;
-    }
-
-    public Timer getNettyTimer() {
-        return nettyTimer;
-    }
-
-    public void setNettyTimer(Timer nettyTimer) {
-        this.nettyTimer = nettyTimer;
-    }
-
-    public long getHandshakeTimeout() {
-        return handshakeTimeout;
-    }
-
-    public void setHandshakeTimeout(long handshakeTimeout) {
-        this.handshakeTimeout = handshakeTimeout;
-    }
-
-    public SSLEngineFactory getSslEngineFactory() {
-        return sslEngineFactory;
-    }
-
-    public void setSslEngineFactory(SSLEngineFactory sslEngineFactory) {
-        this.sslEngineFactory = sslEngineFactory;
-    }
-
-    public int getChunkedFileChunkSize() {
-        return chunkedFileChunkSize;
-    }
-
-    public void setChunkedFileChunkSize(int chunkedFileChunkSize) {
-        this.chunkedFileChunkSize = chunkedFileChunkSize;
-    }
-
-    public NettyWebSocketFactory getNettyWebSocketFactory() {
-        return nettyWebSocketFactory;
-    }
-
-    public void setNettyWebSocketFactory(NettyWebSocketFactory nettyWebSocketFactory) {
-        this.nettyWebSocketFactory = nettyWebSocketFactory;
-    }
-
-    public int getWebSocketMaxBufferSize() {
-        return webSocketMaxBufferSize;
-    }
-
-    public void setWebSocketMaxBufferSize(int webSocketMaxBufferSize) {
-        this.webSocketMaxBufferSize = webSocketMaxBufferSize;
-    }
-
-    public int getWebSocketMaxFrameSize() {
-        return webSocketMaxFrameSize;
-    }
-    public void setWebSocketMaxFrameSize(int webSocketMaxFrameSize) {
-        this.webSocketMaxFrameSize = webSocketMaxFrameSize;
-    }
-}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/ChannelManager.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/ChannelManager.java
deleted file mode 100755
index 233407e0b..000000000
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/ChannelManager.java
+++ /dev/null
@@ -1,438 +0,0 @@
-/*
- * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at
- *     http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty.channel;
-
-import static org.asynchttpclient.providers.netty.util.HttpUtils.WEBSOCKET;
-import static org.asynchttpclient.providers.netty.util.HttpUtils.isSecure;
-import static org.asynchttpclient.providers.netty.util.HttpUtils.isWebSocket;
-import io.netty.bootstrap.Bootstrap;
-import io.netty.channel.Channel;
-import io.netty.channel.ChannelInitializer;
-import io.netty.channel.ChannelOption;
-import io.netty.channel.ChannelPipeline;
-import io.netty.channel.EventLoopGroup;
-import io.netty.channel.group.ChannelGroup;
-import io.netty.channel.nio.NioEventLoopGroup;
-import io.netty.channel.socket.nio.NioSocketChannel;
-import io.netty.handler.codec.http.HttpClientCodec;
-import io.netty.handler.codec.http.HttpContentDecompressor;
-import io.netty.handler.codec.http.websocketx.WebSocket08FrameDecoder;
-import io.netty.handler.codec.http.websocketx.WebSocket08FrameEncoder;
-import io.netty.handler.codec.http.websocketx.WebSocketFrameAggregator;
-import io.netty.handler.ssl.SslHandler;
-import io.netty.handler.stream.ChunkedWriteHandler;
-import io.netty.util.Timer;
-
-import java.io.IOException;
-import java.security.GeneralSecurityException;
-import java.util.Map.Entry;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.Semaphore;
-import java.util.concurrent.atomic.AtomicBoolean;
-
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLEngine;
-
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.ConnectionPoolPartitioning;
-import org.asynchttpclient.ProxyServer;
-import org.asynchttpclient.providers.netty.Callback;
-import org.asynchttpclient.providers.netty.NettyAsyncHttpProviderConfig;
-import org.asynchttpclient.providers.netty.channel.pool.ChannelPool;
-import org.asynchttpclient.providers.netty.channel.pool.ChannelPoolPartitionSelector;
-import org.asynchttpclient.providers.netty.channel.pool.DefaultChannelPool;
-import org.asynchttpclient.providers.netty.channel.pool.NoopChannelPool;
-import org.asynchttpclient.providers.netty.future.NettyResponseFuture;
-import org.asynchttpclient.providers.netty.handler.HttpProtocol;
-import org.asynchttpclient.providers.netty.handler.Processor;
-import org.asynchttpclient.providers.netty.handler.WebSocketProtocol;
-import org.asynchttpclient.providers.netty.request.NettyRequestSender;
-import org.asynchttpclient.uri.Uri;
-import org.asynchttpclient.util.SslUtils;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-public class ChannelManager {
-
-    private static final Logger LOGGER = LoggerFactory.getLogger(ChannelManager.class);
-    public static final String HTTP_HANDLER = "httpHandler";
-    public static final String SSL_HANDLER = "sslHandler";
-    public static final String HTTP_PROCESSOR = "httpProcessor";
-    public static final String WS_PROCESSOR = "wsProcessor";
-    public static final String DEFLATER_HANDLER = "deflater";
-    public static final String INFLATER_HANDLER = "inflater";
-    public static final String CHUNKED_WRITER_HANDLER = "chunkedWriter";
-    public static final String WS_DECODER_HANDLER = "ws-decoder";
-    public static final String WS_FRAME_AGGREGATOR = "ws-aggregator";
-    public static final String WS_ENCODER_HANDLER = "ws-encoder";
-
-    private final AsyncHttpClientConfig config;
-    private final NettyAsyncHttpProviderConfig nettyConfig;
-
-    private final EventLoopGroup eventLoopGroup;
-    private final boolean allowReleaseEventLoopGroup;
-
-    private final Bootstrap plainBootstrap;
-    private final Bootstrap secureBootstrap;
-    private final Bootstrap webSocketBootstrap;
-    private final Bootstrap secureWebSocketBootstrap;
-
-    private final long handshakeTimeout;
-
-    private final ChannelPool channelPool;
-    private final boolean maxConnectionsEnabled;
-    private final Semaphore freeChannels;
-    private final ChannelGroup openChannels;
-    private final boolean maxConnectionsPerHostEnabled;
-    private final ConcurrentHashMap<String, Semaphore> freeChannelsPerHost;
-    private final ConcurrentHashMap<Channel, String> channel2KeyPool;
-
-    private Processor wsProcessor;
-
-    public ChannelManager(AsyncHttpClientConfig config, NettyAsyncHttpProviderConfig nettyConfig, Timer nettyTimer) {
-
-        this.config = config;
-        this.nettyConfig = nettyConfig;
-
-        ChannelPool channelPool = nettyConfig.getChannelPool();
-        if (channelPool == null && config.isAllowPoolingConnections()) {
-            channelPool = new DefaultChannelPool(config, nettyTimer);
-        } else if (channelPool == null) {
-            channelPool = new NoopChannelPool();
-        }
-        this.channelPool = channelPool;
-
-        maxConnectionsEnabled = config.getMaxConnections() > 0;
-        maxConnectionsPerHostEnabled = config.getMaxConnectionsPerHost() > 0;
-
-        if (maxConnectionsEnabled) {
-            openChannels = new CleanupChannelGroup("asyncHttpClient") {
-                @Override
-                public boolean remove(Object o) {
-                    boolean removed = super.remove(o);
-                    if (removed) {
-                        freeChannels.release();
-                        if (maxConnectionsPerHostEnabled) {
-                            String poolKey = channel2KeyPool.remove(Channel.class.cast(o));
-                            if (poolKey != null) {
-                                Semaphore freeChannelsForHost = freeChannelsPerHost.get(poolKey);
-                                if (freeChannelsForHost != null)
-                                    freeChannelsForHost.release();
-                            }
-                        }
-                    }
-                    return removed;
-                }
-            };
-            freeChannels = new Semaphore(config.getMaxConnections());
-        } else {
-            openChannels = new CleanupChannelGroup("asyncHttpClient");
-            freeChannels = null;
-        }
-
-        if (maxConnectionsPerHostEnabled) {
-            freeChannelsPerHost = new ConcurrentHashMap<String, Semaphore>();
-            channel2KeyPool = new ConcurrentHashMap<Channel, String>();
-        } else {
-            freeChannelsPerHost = null;
-            channel2KeyPool = null;
-        }
-
-        handshakeTimeout = nettyConfig.getHandshakeTimeout();
-
-        // check if external EventLoopGroup is defined
-        allowReleaseEventLoopGroup = nettyConfig.getEventLoopGroup() == null;
-        eventLoopGroup = allowReleaseEventLoopGroup ? new NioEventLoopGroup() : nettyConfig.getEventLoopGroup();
-        if (!(eventLoopGroup instanceof NioEventLoopGroup))
-            throw new IllegalArgumentException("Only Nio is supported");
-
-        plainBootstrap = new Bootstrap().channel(NioSocketChannel.class).group(eventLoopGroup);
-        secureBootstrap = new Bootstrap().channel(NioSocketChannel.class).group(eventLoopGroup);
-        webSocketBootstrap = new Bootstrap().channel(NioSocketChannel.class).group(eventLoopGroup);
-        secureWebSocketBootstrap = new Bootstrap().channel(NioSocketChannel.class).group(eventLoopGroup);
-
-        if (config.getConnectionTimeout() > 0)
-            nettyConfig.addChannelOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, config.getConnectionTimeout());
-        for (Entry<ChannelOption<Object>, Object> entry : nettyConfig.propertiesSet()) {
-            ChannelOption<Object> key = entry.getKey();
-            Object value = entry.getValue();
-            plainBootstrap.option(key, value);
-            webSocketBootstrap.option(key, value);
-            secureBootstrap.option(key, value);
-            secureWebSocketBootstrap.option(key, value);
-        }
-    }
-
-    public void configureBootstraps(NettyRequestSender requestSender, AtomicBoolean closed) {
-
-        HttpProtocol httpProtocol = new HttpProtocol(this, config, nettyConfig, requestSender);
-        final Processor httpProcessor = new Processor(config, this, requestSender, httpProtocol);
-
-        WebSocketProtocol wsProtocol = new WebSocketProtocol(this, config, nettyConfig, requestSender);
-        wsProcessor = new Processor(config, this, requestSender, wsProtocol);
-
-        plainBootstrap.handler(new ChannelInitializer<Channel>() {
-            @Override
-            protected void initChannel(Channel ch) throws Exception {
-                ch.pipeline()//
-                        .addLast(HTTP_HANDLER, newHttpClientCodec())//
-                        .addLast(INFLATER_HANDLER, new HttpContentDecompressor())//
-                        .addLast(CHUNKED_WRITER_HANDLER, new ChunkedWriteHandler())//
-                        .addLast(HTTP_PROCESSOR, httpProcessor);
-
-                if (nettyConfig.getHttpAdditionalChannelInitializer() != null)
-                    nettyConfig.getHttpAdditionalChannelInitializer().initChannel(ch);
-            }
-        });
-
-        webSocketBootstrap.handler(new ChannelInitializer<Channel>() {
-            @Override
-            protected void initChannel(Channel ch) throws Exception {
-                ch.pipeline()//
-                        .addLast(HTTP_HANDLER, newHttpClientCodec())//
-                        .addLast(WS_PROCESSOR, wsProcessor);
-
-                if (nettyConfig.getWsAdditionalChannelInitializer() != null) {
-                    nettyConfig.getWsAdditionalChannelInitializer().initChannel(ch);
-                }
-            }
-        });
-
-        secureBootstrap.handler(new ChannelInitializer<Channel>() {
-
-            @Override
-            protected void initChannel(Channel ch) throws Exception {
-                ch.pipeline()//
-                        .addLast(SSL_HANDLER, new SslInitializer(ChannelManager.this))//
-                        .addLast(HTTP_HANDLER, newHttpClientCodec())//
-                        .addLast(INFLATER_HANDLER, new HttpContentDecompressor())//
-                        .addLast(CHUNKED_WRITER_HANDLER, new ChunkedWriteHandler())//
-                        .addLast(HTTP_PROCESSOR, httpProcessor);
-
-                if (nettyConfig.getHttpsAdditionalChannelInitializer() != null)
-                    nettyConfig.getHttpsAdditionalChannelInitializer().initChannel(ch);
-            }
-        });
-
-        secureWebSocketBootstrap.handler(new ChannelInitializer<Channel>() {
-
-            @Override
-            protected void initChannel(Channel ch) throws Exception {
-                ch.pipeline()//
-                        .addLast(SSL_HANDLER, new SslInitializer(ChannelManager.this))//
-                        .addLast(HTTP_HANDLER, newHttpClientCodec())//
-                        .addLast(WS_PROCESSOR, wsProcessor);
-
-                if (nettyConfig.getWssAdditionalChannelInitializer() != null) {
-                    nettyConfig.getWssAdditionalChannelInitializer().initChannel(ch);
-                }
-            }
-        });
-    }
-
-    public final void tryToOfferChannelToPool(Channel channel, boolean keepAlive, String partitionId) {
-        if (keepAlive && channel.isActive()) {
-            LOGGER.debug("Adding key: {} for channel {}", partitionId, channel);
-            channelPool.offer(channel, partitionId);
-            if (maxConnectionsPerHostEnabled)
-                channel2KeyPool.putIfAbsent(channel, partitionId);
-            Channels.setDiscard(channel);
-        } else {
-            // not offered
-            closeChannel(channel);
-        }
-    }
-
-    public Channel poll(Uri uri, ProxyServer proxy, ConnectionPoolPartitioning connectionPoolPartitioning) {
-        String partitionId = connectionPoolPartitioning.getPartitionId(uri, proxy);
-        return channelPool.poll(partitionId);
-    }
-
-    public boolean removeAll(Channel connection) {
-        return channelPool.removeAll(connection);
-    }
-
-    private boolean tryAcquireGlobal() {
-        return !maxConnectionsEnabled || freeChannels.tryAcquire();
-    }
-
-    private Semaphore getFreeConnectionsForHost(String poolKey) {
-        Semaphore freeConnections = freeChannelsPerHost.get(poolKey);
-        if (freeConnections == null) {
-            // lazy create the semaphore
-            Semaphore newFreeConnections = new Semaphore(config.getMaxConnectionsPerHost());
-            freeConnections = freeChannelsPerHost.putIfAbsent(poolKey, newFreeConnections);
-            if (freeConnections == null)
-                freeConnections = newFreeConnections;
-        }
-        return freeConnections;
-    }
-
-    private boolean tryAcquirePerHost(String poolKey) {
-        return !maxConnectionsPerHostEnabled || getFreeConnectionsForHost(poolKey).tryAcquire();
-    }
-
-    public boolean preemptChannel(String poolKey) {
-        return channelPool.isOpen() && tryAcquireGlobal() && tryAcquirePerHost(poolKey);
-    }
-
-    public void close() {
-        channelPool.destroy();
-        openChannels.close();
-
-        for (Channel channel : openChannels) {
-            Object attribute = Channels.getAttribute(channel);
-            if (attribute instanceof NettyResponseFuture<?>) {
-                NettyResponseFuture<?> future = (NettyResponseFuture<?>) attribute;
-                future.cancelTimeouts();
-            }
-        }
-
-        if (allowReleaseEventLoopGroup)
-            eventLoopGroup.shutdownGracefully();
-    }
-
-    public void closeChannel(Channel channel) {
-
-        LOGGER.debug("Closing Channel {} ", channel);
-        removeAll(channel);
-        Channels.setDiscard(channel);
-        Channels.silentlyCloseChannel(channel);
-        openChannels.remove(channel);
-    }
-
-    public void abortChannelPreemption(String poolKey) {
-        if (maxConnectionsEnabled)
-            freeChannels.release();
-        if (maxConnectionsPerHostEnabled)
-            getFreeConnectionsForHost(poolKey).release();
-    }
-
-    public void registerOpenChannel(Channel channel) {
-        openChannels.add(channel);
-    }
-
-    private HttpClientCodec newHttpClientCodec() {
-        return new HttpClientCodec(//
-                nettyConfig.getHttpClientCodecMaxInitialLineLength(),//
-                nettyConfig.getHttpClientCodecMaxHeaderSize(),//
-                nettyConfig.getHttpClientCodecMaxChunkSize(),//
-                false);
-    }
-
-    public SslHandler createSslHandler(String peerHost, int peerPort) throws IOException, GeneralSecurityException {
-
-        SSLEngine sslEngine = null;
-        if (nettyConfig.getSslEngineFactory() != null) {
-            sslEngine = nettyConfig.getSslEngineFactory().newSSLEngine();
-
-        } else {
-            SSLContext sslContext = config.getSSLContext();
-            if (sslContext == null)
-                sslContext = SslUtils.getInstance().getSSLContext(config.isAcceptAnyCertificate());
-
-            sslEngine = sslContext.createSSLEngine(peerHost, peerPort);
-            sslEngine.setUseClientMode(true);
-        }
-
-        SslHandler sslHandler = new SslHandler(sslEngine);
-        if (handshakeTimeout > 0)
-            sslHandler.setHandshakeTimeoutMillis(handshakeTimeout);
-
-        return sslHandler;
-    }
-
-    public static SslHandler getSslHandler(ChannelPipeline pipeline) {
-        return (SslHandler) pipeline.get(SSL_HANDLER);
-    }
-
-    public static boolean isSslHandlerConfigured(ChannelPipeline pipeline) {
-        return pipeline.get(SSL_HANDLER) != null;
-    }
-
-    public void upgradeProtocol(ChannelPipeline pipeline, String scheme, String host, int port) throws IOException, GeneralSecurityException {
-        if (pipeline.get(HTTP_HANDLER) != null)
-            pipeline.remove(HTTP_HANDLER);
-
-        if (isSecure(scheme))
-            if (isSslHandlerConfigured(pipeline)) {
-                pipeline.addAfter(SSL_HANDLER, HTTP_HANDLER, newHttpClientCodec());
-            } else {
-                pipeline.addFirst(HTTP_HANDLER, newHttpClientCodec());
-                pipeline.addFirst(SSL_HANDLER, createSslHandler(host, port));
-            }
-
-        else
-            pipeline.addFirst(HTTP_HANDLER, newHttpClientCodec());
-
-        if (isWebSocket(scheme)) {
-            pipeline.addAfter(HTTP_PROCESSOR, WS_PROCESSOR, wsProcessor);
-            pipeline.remove(HTTP_PROCESSOR);
-        }
-    }
-
-    public String getPartitionId(NettyResponseFuture<?> future) {
-        return future.getConnectionPoolPartitioning().getPartitionId(future.getUri(), future.getProxyServer());
-    }
-
-    /**
-     * Always make sure the channel who got cached support the proper protocol.
-     * It could only occurs when a HttpMethod. CONNECT is used against a proxy
-     * that requires upgrading from http to https.
-     */
-    public void verifyChannelPipeline(ChannelPipeline pipeline, String scheme) throws IOException, GeneralSecurityException {
-
-        boolean sslHandlerConfigured = isSslHandlerConfigured(pipeline);
-
-        if (isSecure(scheme)) {
-            if (!sslHandlerConfigured)
-                pipeline.addFirst(SSL_HANDLER, new SslInitializer(this));
-
-        } else if (sslHandlerConfigured)
-            pipeline.remove(SSL_HANDLER);
-    }
-
-    public Bootstrap getBootstrap(Uri uri, boolean useProxy, boolean useSSl) {
-        return uri.getScheme().startsWith(WEBSOCKET) && !useProxy ? (useSSl ? secureWebSocketBootstrap : webSocketBootstrap) : //
-                (useSSl ? secureBootstrap : plainBootstrap);
-    }
-
-    public void upgradePipelineForWebSockets(ChannelPipeline pipeline) {
-        pipeline.addAfter(HTTP_HANDLER, WS_ENCODER_HANDLER, new WebSocket08FrameEncoder(true));
-        pipeline.remove(HTTP_HANDLER);
-        pipeline.addBefore(WS_PROCESSOR, WS_DECODER_HANDLER, new WebSocket08FrameDecoder(false, false, nettyConfig.getWebSocketMaxFrameSize()));
-        pipeline.addAfter(WS_DECODER_HANDLER, WS_FRAME_AGGREGATOR, new WebSocketFrameAggregator(nettyConfig.getWebSocketMaxBufferSize()));
-    }
-
-    public final Callback newDrainCallback(final NettyResponseFuture<?> future, final Channel channel, final boolean keepAlive, final String poolKey) {
-
-        return new Callback(future) {
-            public void call() throws Exception {
-                tryToOfferChannelToPool(channel, keepAlive, poolKey);
-            }
-        };
-    }
-
-    public void drainChannel(final Channel channel, final NettyResponseFuture<?> future) {
-        Channels.setAttribute(channel, newDrainCallback(future, channel, future.isKeepAlive(), getPartitionId(future)));
-    }
-
-    public void flushPartition(String partitionId) {
-        channelPool.flushPartition(partitionId);
-    } 
-
-    public void flushPartitions(ChannelPoolPartitionSelector selector) {
-        channelPool.flushPartitions(selector);
-    }
-}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/SslInitializer.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/SslInitializer.java
deleted file mode 100755
index 0a938b1f5..000000000
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/SslInitializer.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Copyright 2014 AsyncHttpClient Project.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package org.asynchttpclient.providers.netty.channel;
-
-import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelOutboundHandlerAdapter;
-import io.netty.channel.ChannelPromise;
-import io.netty.handler.ssl.SslHandler;
-
-import java.net.InetSocketAddress;
-import java.net.SocketAddress;
-
-/**
- * On connect, replaces itself with a SslHandler that has a SSLEngine configured with the remote host and port.
- * 
- * @author slandelle
- */
-public class SslInitializer extends ChannelOutboundHandlerAdapter {
-
-    private final ChannelManager channelManager;
-
-    public SslInitializer(ChannelManager channelManager) {
-        this.channelManager = channelManager;
-    }
-
-    @Override
-    public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)
-            throws Exception {
-
-        InetSocketAddress remoteInetSocketAddress = (InetSocketAddress) remoteAddress;
-        String peerHost = remoteInetSocketAddress.getHostString();
-        int peerPort = remoteInetSocketAddress.getPort();
-
-        SslHandler sslHandler = channelManager.createSslHandler(peerHost, peerPort);
-
-        ctx.pipeline().replace(ChannelManager.SSL_HANDLER, ChannelManager.SSL_HANDLER, sslHandler);
-
-        ctx.connect(remoteAddress, localAddress, promise);
-    }
-}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/handler/Protocol.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/handler/Protocol.java
deleted file mode 100755
index a97c388e2..000000000
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/handler/Protocol.java
+++ /dev/null
@@ -1,199 +0,0 @@
-/*
- * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at
- *     http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty.handler;
-
-import static io.netty.handler.codec.http.HttpResponseStatus.FOUND;
-import static io.netty.handler.codec.http.HttpResponseStatus.MOVED_PERMANENTLY;
-import static io.netty.handler.codec.http.HttpResponseStatus.SEE_OTHER;
-import static io.netty.handler.codec.http.HttpResponseStatus.TEMPORARY_REDIRECT;
-import static org.asynchttpclient.providers.netty.util.HttpUtils.HTTP;
-import static org.asynchttpclient.providers.netty.util.HttpUtils.WEBSOCKET;
-import static org.asynchttpclient.util.AsyncHttpProviderUtils.followRedirect;
-import io.netty.channel.Channel;
-import io.netty.handler.codec.http.HttpHeaders;
-import io.netty.handler.codec.http.HttpResponse;
-
-import java.io.IOException;
-import java.util.HashSet;
-import java.util.Set;
-
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.HttpResponseHeaders;
-import org.asynchttpclient.HttpResponseStatus;
-import org.asynchttpclient.MaxRedirectException;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.RequestBuilder;
-import org.asynchttpclient.cookie.Cookie;
-import org.asynchttpclient.cookie.CookieDecoder;
-import org.asynchttpclient.date.TimeConverter;
-import org.asynchttpclient.filter.FilterContext;
-import org.asynchttpclient.filter.FilterException;
-import org.asynchttpclient.filter.ResponseFilter;
-import org.asynchttpclient.providers.netty.Callback;
-import org.asynchttpclient.providers.netty.NettyAsyncHttpProviderConfig;
-import org.asynchttpclient.providers.netty.channel.ChannelManager;
-import org.asynchttpclient.providers.netty.channel.Channels;
-import org.asynchttpclient.providers.netty.future.NettyResponseFuture;
-import org.asynchttpclient.providers.netty.request.NettyRequestSender;
-import org.asynchttpclient.uri.Uri;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-public abstract class Protocol {
-
-    protected final Logger logger = LoggerFactory.getLogger(getClass());
-
-    protected final ChannelManager channelManager;
-    protected final AsyncHttpClientConfig config;
-    protected final NettyAsyncHttpProviderConfig nettyConfig;
-    protected final NettyRequestSender requestSender;
-
-    private final boolean hasResponseFilters;
-    protected final boolean hasIOExceptionFilters;
-    private final TimeConverter timeConverter;
-
-    public static final Set<Integer> REDIRECT_STATUSES = new HashSet<Integer>();
-    static {
-        REDIRECT_STATUSES.add(MOVED_PERMANENTLY.code());
-        REDIRECT_STATUSES.add(FOUND.code());
-        REDIRECT_STATUSES.add(SEE_OTHER.code());
-        REDIRECT_STATUSES.add(TEMPORARY_REDIRECT.code());
-    }
-
-    public Protocol(ChannelManager channelManager, AsyncHttpClientConfig config, NettyAsyncHttpProviderConfig nettyConfig,
-            NettyRequestSender requestSender) {
-        this.channelManager = channelManager;
-        this.config = config;
-        this.requestSender = requestSender;
-        this.nettyConfig = nettyConfig;
-
-        hasResponseFilters = !config.getResponseFilters().isEmpty();
-        hasIOExceptionFilters = !config.getIOExceptionFilters().isEmpty();
-        timeConverter = config.getTimeConverter();
-    }
-
-    public abstract void handle(Channel channel, NettyResponseFuture<?> future, Object message) throws Exception;
-
-    public abstract void onError(NettyResponseFuture<?> future, Throwable error);
-
-    public abstract void onClose(NettyResponseFuture<?> future);
-
-    protected boolean exitAfterHandlingRedirect(//
-            Channel channel,//
-            NettyResponseFuture<?> future,//
-            HttpResponse response,//
-            Request request,//
-            int statusCode) throws Exception {
-
-        if (followRedirect(config, request) && REDIRECT_STATUSES.contains(statusCode)) {
-            if (future.incrementAndGetCurrentRedirectCount() >= config.getMaxRedirects()) {
-                throw new MaxRedirectException("Maximum redirect reached: " + config.getMaxRedirects());
-
-            } else {
-                // We must allow 401 handling again.
-                future.getAndSetAuth(false);
-
-                HttpHeaders responseHeaders = response.headers();
-                String location = responseHeaders.get(HttpHeaders.Names.LOCATION);
-                Uri uri = Uri.create(future.getUri(), location);
-
-                if (!uri.equals(future.getUri())) {
-                    final RequestBuilder requestBuilder = new RequestBuilder(future.getRequest());
-
-                    if (!config.isRemoveQueryParamOnRedirect())
-                        requestBuilder.addQueryParams(future.getRequest().getQueryParams());
-
-                    // if we are to strictly handle 302, we should keep the original method (which browsers don't)
-                    // 303 must force GET
-                    if ((statusCode == FOUND.code() && !config.isStrict302Handling()) || statusCode == SEE_OTHER.code())
-                        requestBuilder.setMethod("GET");
-
-                    // in case of a redirect from HTTP to HTTPS, future attributes might change
-                    final boolean initialConnectionKeepAlive = future.isKeepAlive();
-                    final String initialPoolKey = channelManager.getPartitionId(future);
-
-                    future.setUri(uri);
-                    String newUrl = uri.toUrl();
-                    if (request.getUri().getScheme().startsWith(WEBSOCKET)) {
-                        newUrl = newUrl.replaceFirst(HTTP, WEBSOCKET);
-                    }
-
-                    logger.debug("Redirecting to {}", newUrl);
-
-                    for (String cookieStr : responseHeaders.getAll(HttpHeaders.Names.SET_COOKIE)) {
-                        Cookie c = CookieDecoder.decode(cookieStr, timeConverter);
-                        if (c != null)
-                            requestBuilder.addOrReplaceCookie(c);
-                    }
-
-                    Callback callback = channelManager.newDrainCallback(future, channel, initialConnectionKeepAlive, initialPoolKey);
-
-                    if (HttpHeaders.isTransferEncodingChunked(response)) {
-                        // We must make sure there is no bytes left before
-                        // executing the next request.
-                        // FIXME investigate this
-                        Channels.setAttribute(channel, callback);
-                    } else {
-                        // FIXME don't understand: this offers the connection to the pool, or even closes it, while the
-                        // request has not been sent, right?
-                        callback.call();
-                    }
-
-                    Request redirectRequest = requestBuilder.setUrl(newUrl).build();
-                    // FIXME why not reuse the channel is same host?
-                    requestSender.sendNextRequest(redirectRequest, future);
-                    return true;
-                }
-            }
-        }
-        return false;
-    }
-
-    @SuppressWarnings({ "rawtypes", "unchecked" })
-    protected boolean exitAfterProcessingFilters(//
-            Channel channel,//
-            NettyResponseFuture<?> future,//
-            AsyncHandler<?> handler, //
-            HttpResponseStatus status,//
-            HttpResponseHeaders responseHeaders) throws IOException {
-
-        if (hasResponseFilters) {
-            FilterContext fc = new FilterContext.FilterContextBuilder().asyncHandler(handler).request(future.getRequest())
-                    .responseStatus(status).responseHeaders(responseHeaders).build();
-
-            for (ResponseFilter asyncFilter : config.getResponseFilters()) {
-                try {
-                    fc = asyncFilter.filter(fc);
-                    // FIXME Is it worth protecting against this?
-                    if (fc == null) {
-                        throw new NullPointerException("FilterContext is null");
-                    }
-                } catch (FilterException efe) {
-                    requestSender.abort(channel, future, efe);
-                }
-            }
-
-            // The handler may have been wrapped.
-            future.setAsyncHandler(fc.getAsyncHandler());
-
-            // The request has changed
-            if (fc.replayRequest()) {
-                requestSender.replayRequest(future, fc, channel);
-                return true;
-            }
-        }
-        return false;
-    }
-}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/NettyConnectListener.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/NettyConnectListener.java
deleted file mode 100755
index 933115a99..000000000
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/NettyConnectListener.java
+++ /dev/null
@@ -1,154 +0,0 @@
-/*
- * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at
- *     http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty.request;
-
-import io.netty.channel.Channel;
-import io.netty.channel.ChannelFuture;
-import io.netty.channel.ChannelFutureListener;
-import io.netty.handler.ssl.SslHandler;
-import io.netty.util.concurrent.Future;
-import io.netty.util.concurrent.GenericFutureListener;
-
-import java.net.ConnectException;
-import java.nio.channels.ClosedChannelException;
-
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLEngine;
-import javax.net.ssl.SSLSession;
-
-import org.asynchttpclient.AsyncHandlerExtensions;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.providers.netty.channel.ChannelManager;
-import org.asynchttpclient.providers.netty.channel.Channels;
-import org.asynchttpclient.providers.netty.future.NettyResponseFuture;
-import org.asynchttpclient.providers.netty.future.StackTraceInspector;
-import org.asynchttpclient.util.Base64;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-/**
- * Non Blocking connect.
- */
-final class NettyConnectListener<T> implements ChannelFutureListener {
-
-    private final static Logger LOGGER = LoggerFactory.getLogger(NettyConnectListener.class);
-
-    private final AsyncHttpClientConfig config;
-    private final NettyRequestSender requestSender;
-    private final NettyResponseFuture<T> future;
-    private final ChannelManager channelManager;
-    private final boolean channelPreempted;
-    private final String poolKey;
-
-    public NettyConnectListener(AsyncHttpClientConfig config,//
-            NettyResponseFuture<T> future,//
-            NettyRequestSender requestSender,//
-            ChannelManager channelManager,//
-            boolean channelPreempted,//
-            String poolKey) {
-        this.config = config;
-        this.future = future;
-        this.requestSender = requestSender;
-        this.channelManager = channelManager;
-        this.channelPreempted = channelPreempted;
-        this.poolKey = poolKey;
-    }
-
-    private void abortChannelPreemption(String poolKey) {
-        if (channelPreempted)
-            channelManager.abortChannelPreemption(poolKey);
-    }
-
-    private void writeRequest(Channel channel) {
-
-        LOGGER.debug("Request using non cached Channel '{}':\n{}\n", channel, future.getNettyRequest().getHttpRequest());
-
-        if (future.isDone()) {
-            abortChannelPreemption(poolKey);
-            return;
-        }
-
-        if (future.getAsyncHandler() instanceof AsyncHandlerExtensions)
-            AsyncHandlerExtensions.class.cast(future.getAsyncHandler()).onConnectionOpen();
-
-        channelManager.registerOpenChannel(channel);
-        future.attachChannel(channel, false);
-        requestSender.writeRequest(future, channel);
-    }
-
-    public void onFutureSuccess(final Channel channel) throws ConnectException {
-        Channels.setAttribute(channel, future);
-        final HostnameVerifier hostnameVerifier = config.getHostnameVerifier();
-        final SslHandler sslHandler = ChannelManager.getSslHandler(channel.pipeline());
-        if (hostnameVerifier != null && sslHandler != null) {
-            final String host = future.getUri().getHost();
-            sslHandler.handshakeFuture().addListener(new GenericFutureListener<Future<? super Channel>>() {
-                @Override
-                public void operationComplete(Future<? super Channel> handshakeFuture) throws Exception {
-                    if (handshakeFuture.isSuccess()) {
-                        Channel channel = (Channel) handshakeFuture.getNow();
-                        SSLEngine engine = sslHandler.engine();
-                        SSLSession session = engine.getSession();
-
-                        LOGGER.debug("onFutureSuccess: session = {}, id = {}, isValid = {}, host = {}", session.toString(),
-                                Base64.encode(session.getId()), session.isValid(), host);
-                        if (hostnameVerifier.verify(host, session)) {
-                            writeRequest(channel);
-                        } else {
-                            abortChannelPreemption(poolKey);
-                            ConnectException exception = new ConnectException("HostnameVerifier exception");
-                            future.abort(exception);
-                            throw exception;
-                        }
-                    }
-                }
-            });
-        } else {
-            writeRequest(channel);
-        }
-    }
-
-    public void onFutureFailure(Channel channel, Throwable cause) {
-
-        abortChannelPreemption(poolKey);
-
-        boolean canRetry = future.canRetry();
-        LOGGER.debug("Trying to recover a dead cached channel {} with a retry value of {} ", channel, canRetry);
-        if (canRetry//
-                && cause != null//
-                && (cause instanceof ClosedChannelException || future.getState() != NettyResponseFuture.STATE.NEW || StackTraceInspector.abortOnDisconnectException(cause))) {
-
-            if (requestSender.retry(future)) {
-                return;
-            }
-        }
-
-        LOGGER.debug("Failed to recover from exception: {} with channel {}", cause, channel);
-
-        boolean printCause = cause != null && cause.getMessage() != null;
-        String url = future.getUri().toUrl();
-        String printedCause = printCause ? cause.getMessage() + " to " + url : url;
-        ConnectException e = new ConnectException(printedCause);
-        if (cause != null)
-            e.initCause(cause);
-        future.abort(e);
-    }
-
-    public final void operationComplete(ChannelFuture f) throws Exception {
-        if (f.isSuccess())
-            onFutureSuccess(f.channel());
-        else
-            onFutureFailure(f.channel(), f.cause());
-    }
-}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/NettyRequestFactory.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/NettyRequestFactory.java
deleted file mode 100755
index f679a3b45..000000000
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/NettyRequestFactory.java
+++ /dev/null
@@ -1,331 +0,0 @@
-/*
- * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at
- *     http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty.request;
-
-import static org.asynchttpclient.providers.netty.util.HttpUtils.isNTLM;
-import static org.asynchttpclient.providers.netty.util.HttpUtils.isSecure;
-import static org.asynchttpclient.providers.netty.util.HttpUtils.isWebSocket;
-import static org.asynchttpclient.providers.netty.util.HttpUtils.useProxyConnect;
-import static org.asynchttpclient.providers.netty.ws.WebSocketUtils.getKey;
-import static org.asynchttpclient.util.AsyncHttpProviderUtils.DEFAULT_CHARSET;
-import static org.asynchttpclient.util.AsyncHttpProviderUtils.getAuthority;
-import static org.asynchttpclient.util.AsyncHttpProviderUtils.getNonEmptyPath;
-import static org.asynchttpclient.util.AsyncHttpProviderUtils.keepAliveHeaderValue;
-import static org.asynchttpclient.util.AuthenticatorUtils.computeBasicAuthentication;
-import static org.asynchttpclient.util.AuthenticatorUtils.computeDigestAuthentication;
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
-import io.netty.buffer.Unpooled;
-import io.netty.handler.codec.http.DefaultFullHttpRequest;
-import io.netty.handler.codec.http.DefaultHttpRequest;
-import io.netty.handler.codec.http.HttpHeaders;
-import io.netty.handler.codec.http.HttpMethod;
-import io.netty.handler.codec.http.HttpRequest;
-import io.netty.handler.codec.http.HttpVersion;
-
-import java.io.IOException;
-import java.nio.charset.Charset;
-import java.security.NoSuchAlgorithmException;
-import java.util.List;
-import java.util.Map.Entry;
-
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.Param;
-import org.asynchttpclient.ProxyServer;
-import org.asynchttpclient.Realm;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.cookie.CookieEncoder;
-import org.asynchttpclient.generators.FileBodyGenerator;
-import org.asynchttpclient.generators.InputStreamBodyGenerator;
-import org.asynchttpclient.ntlm.NTLMEngine;
-import org.asynchttpclient.ntlm.NTLMEngineException;
-import org.asynchttpclient.providers.netty.NettyAsyncHttpProviderConfig;
-import org.asynchttpclient.providers.netty.request.body.NettyBody;
-import org.asynchttpclient.providers.netty.request.body.NettyBodyBody;
-import org.asynchttpclient.providers.netty.request.body.NettyByteArrayBody;
-import org.asynchttpclient.providers.netty.request.body.NettyFileBody;
-import org.asynchttpclient.providers.netty.request.body.NettyInputStreamBody;
-import org.asynchttpclient.providers.netty.request.body.NettyMultipartBody;
-import org.asynchttpclient.spnego.SpnegoEngine;
-import org.asynchttpclient.uri.Uri;
-import org.asynchttpclient.util.UTF8UrlEncoder;
-
-public final class NettyRequestFactory {
-
-    public static final String GZIP_DEFLATE = HttpHeaders.Values.GZIP + "," + HttpHeaders.Values.DEFLATE;
-
-    private final AsyncHttpClientConfig config;
-    private final NettyAsyncHttpProviderConfig nettyConfig;
-
-    public NettyRequestFactory(AsyncHttpClientConfig config, NettyAsyncHttpProviderConfig nettyConfig) {
-        this.config = config;
-        this.nettyConfig = nettyConfig;
-    }
-
-    private String requestUri(Uri uri, ProxyServer proxyServer, HttpMethod method) {
-        if (method == HttpMethod.CONNECT)
-            return getAuthority(uri);
-
-        else if (proxyServer != null && !(useProxyConnect(uri) && config.isUseRelativeURIsWithConnectProxies()))
-            return uri.toUrl();
-
-        else {
-            String path = getNonEmptyPath(uri);
-            if (isNonEmpty(uri.getQuery()))
-                return path + "?" + uri.getQuery();
-            else
-                return path;
-        }
-    }
-
-    private String hostHeader(Request request, Uri uri) {
-        String host = request.getVirtualHost() != null ? request.getVirtualHost() : uri.getHost();
-        return request.getVirtualHost() != null || uri.getPort() == -1 ? host : host + ":" + uri.getPort();
-    }
-
-    private String authorizationHeader(Request request, Uri uri, ProxyServer proxyServer, Realm realm) throws IOException {
-
-        String authorizationHeader = null;
-
-        if (realm != null && realm.getUsePreemptiveAuth()) {
-
-            switch (realm.getAuthScheme()) {
-            case BASIC:
-                authorizationHeader = computeBasicAuthentication(realm);
-                break;
-            case DIGEST:
-                if (isNonEmpty(realm.getNonce())) {
-                    try {
-                        authorizationHeader = computeDigestAuthentication(realm);
-                    } catch (NoSuchAlgorithmException e) {
-                        throw new SecurityException(e);
-                    }
-                }
-                break;
-            case NTLM:
-                String domain;
-                if (proxyServer != null && proxyServer.getNtlmDomain() != null) {
-                    domain = proxyServer.getNtlmDomain();
-                } else {
-                    domain = realm.getNtlmDomain();
-                }
-                try {
-                    String msg = NTLMEngine.INSTANCE.generateType1Msg("NTLM " + domain, realm.getNtlmHost());
-                    authorizationHeader = "NTLM " + msg;
-                } catch (NTLMEngineException e) {
-                    throw new IOException(e);
-                }
-                break;
-            case KERBEROS:
-            case SPNEGO:
-
-                String host;
-                if (proxyServer != null)
-                    host = proxyServer.getHost();
-                else if (request.getVirtualHost() != null)
-                    host = request.getVirtualHost();
-                else
-                    host = uri.getHost();
-
-                try {
-                    authorizationHeader = "Negotiate " + SpnegoEngine.instance().generateToken(host);
-                } catch (Throwable e) {
-                    throw new IOException(e);
-                }
-                break;
-            case NONE:
-                break;
-            default:
-                throw new IllegalStateException("Invalid Authentication " + realm);
-            }
-        }
-
-        return authorizationHeader;
-    }
-
-    private String proxyAuthorizationHeader(Request request, ProxyServer proxyServer, HttpMethod method) throws IOException {
-
-        String proxyAuthorization = null;
-
-        if (method == HttpMethod.CONNECT) {
-            List<String> auth = request.getHeaders().get(HttpHeaders.Names.PROXY_AUTHORIZATION);
-            if (isNTLM(auth)) {
-                proxyAuthorization = auth.get(0);
-            }
-
-        } else if (proxyServer != null && proxyServer.getPrincipal() != null) {
-            if (isNonEmpty(proxyServer.getNtlmDomain())) {
-                List<String> auth = request.getHeaders().get(HttpHeaders.Names.PROXY_AUTHORIZATION);
-                if (!isNTLM(auth)) {
-                    try {
-                        String msg = NTLMEngine.INSTANCE.generateType1Msg(proxyServer.getNtlmDomain(), proxyServer.getHost());
-                        proxyAuthorization = "NTLM " + msg;
-                    } catch (NTLMEngineException e) {
-                        IOException ie = new IOException();
-                        ie.initCause(e);
-                        throw ie;
-                    }
-                }
-            } else {
-                proxyAuthorization = computeBasicAuthentication(proxyServer);
-            }
-        }
-
-        return proxyAuthorization;
-    }
-
-    private byte[] computeBodyFromParams(List<Param> params, Charset bodyCharset) {
-
-        StringBuilder sb = new StringBuilder();
-        for (Param param : params) {
-            UTF8UrlEncoder.appendEncoded(sb, param.getName());
-            sb.append('=');
-            UTF8UrlEncoder.appendEncoded(sb, param.getValue());
-            sb.append('&');
-        }
-        sb.setLength(sb.length() - 1);
-        return sb.toString().getBytes(bodyCharset);
-    }
-
-    private NettyBody body(Request request, HttpMethod method) throws IOException {
-        NettyBody nettyBody = null;
-        if (method != HttpMethod.CONNECT) {
-
-            Charset bodyCharset = request.getBodyEncoding() == null ? DEFAULT_CHARSET : Charset.forName(request.getBodyEncoding());
-
-            if (request.getByteData() != null) {
-                nettyBody = new NettyByteArrayBody(request.getByteData());
-
-            } else if (request.getStringData() != null) {
-                nettyBody = new NettyByteArrayBody(request.getStringData().getBytes(bodyCharset));
-
-            } else if (request.getStreamData() != null) {
-                nettyBody = new NettyInputStreamBody(request.getStreamData());
-
-            } else if (isNonEmpty(request.getFormParams())) {
-
-                String contentType = null;
-                if (!request.getHeaders().containsKey(HttpHeaders.Names.CONTENT_TYPE))
-                    contentType = HttpHeaders.Values.APPLICATION_X_WWW_FORM_URLENCODED;
-
-                nettyBody = new NettyByteArrayBody(computeBodyFromParams(request.getFormParams(), bodyCharset), contentType);
-
-            } else if (isNonEmpty(request.getParts())) {
-                nettyBody = new NettyMultipartBody(request.getParts(), request.getHeaders(), nettyConfig);
-
-            } else if (request.getFile() != null) {
-                nettyBody = new NettyFileBody(request.getFile(), nettyConfig);
-
-            } else if (request.getBodyGenerator() instanceof FileBodyGenerator) {
-                FileBodyGenerator fileBodyGenerator = (FileBodyGenerator) request.getBodyGenerator();
-                nettyBody = new NettyFileBody(fileBodyGenerator.getFile(), fileBodyGenerator.getRegionSeek(), fileBodyGenerator.getRegionLength(), nettyConfig);
-
-            } else if (request.getBodyGenerator() instanceof InputStreamBodyGenerator) {
-                nettyBody = new NettyInputStreamBody(InputStreamBodyGenerator.class.cast(request.getBodyGenerator()).getInputStream());
-
-            } else if (request.getBodyGenerator() != null) {
-                nettyBody = new NettyBodyBody(request.getBodyGenerator().createBody(), nettyConfig);
-            }
-        }
-
-        return nettyBody;
-    }
-
-    public NettyRequest newNettyRequest(Request request, Uri uri, boolean forceConnect, ProxyServer proxyServer) throws IOException {
-
-        HttpMethod method = forceConnect ? HttpMethod.CONNECT : HttpMethod.valueOf(request.getMethod());
-        HttpVersion httpVersion = method == HttpMethod.CONNECT ? HttpVersion.HTTP_1_0 : HttpVersion.HTTP_1_1;
-        String requestUri = requestUri(uri, proxyServer, method);
-
-        NettyBody body = body(request, method);
-
-        HttpRequest httpRequest;
-        NettyRequest nettyRequest;
-        if (body instanceof NettyByteArrayBody) {
-            byte[] bytes = NettyByteArrayBody.class.cast(body).getBytes();
-            httpRequest = new DefaultFullHttpRequest(httpVersion, method, requestUri, Unpooled.wrappedBuffer(bytes));
-            // body is passed as null as it's written directly with the request
-            nettyRequest = new NettyRequest(httpRequest, null);
-
-        } else if (body == null) {
-            httpRequest = new DefaultFullHttpRequest(httpVersion, method, requestUri);
-            nettyRequest = new NettyRequest(httpRequest, null);
-
-        } else {
-            httpRequest = new DefaultHttpRequest(httpVersion, method, requestUri);
-            nettyRequest = new NettyRequest(httpRequest, body);
-        }
-
-        HttpHeaders headers = httpRequest.headers();
-
-        if (method != HttpMethod.CONNECT) {
-            // assign headers as configured on request
-            for (Entry<String, List<String>> header : request.getHeaders()) {
-                headers.set(header.getKey(), header.getValue());
-            }
-
-            if (isNonEmpty(request.getCookies()))
-                headers.set(HttpHeaders.Names.COOKIE, CookieEncoder.encode(request.getCookies()));
-
-            if (config.isCompressionEnforced() && !headers.contains(HttpHeaders.Names.ACCEPT_ENCODING))
-                headers.set(HttpHeaders.Names.ACCEPT_ENCODING, GZIP_DEFLATE);
-        }
-
-        if (body != null) {
-            if (body.getContentLength() < 0)
-                headers.set(HttpHeaders.Names.TRANSFER_ENCODING, HttpHeaders.Values.CHUNKED);
-            else
-                headers.set(HttpHeaders.Names.CONTENT_LENGTH, body.getContentLength());
-
-            if (body.getContentType() != null)
-                headers.set(HttpHeaders.Names.CONTENT_TYPE, body.getContentType());
-        }
-
-        // connection header and friends
-        boolean webSocket = isWebSocket(uri.getScheme());
-        if (method != HttpMethod.CONNECT && webSocket) {
-            headers.set(HttpHeaders.Names.UPGRADE, HttpHeaders.Values.WEBSOCKET)//
-            .set(HttpHeaders.Names.CONNECTION, HttpHeaders.Values.UPGRADE)//
-            .set(HttpHeaders.Names.ORIGIN, "http://" + uri.getHost() + ":" + (uri.getPort() == -1 ? isSecure(uri.getScheme()) ? 443 : 80 : uri.getPort()))//
-            .set(HttpHeaders.Names.SEC_WEBSOCKET_KEY, getKey())//
-            .set(HttpHeaders.Names.SEC_WEBSOCKET_VERSION, "13");
-
-        } else if (!headers.contains(HttpHeaders.Names.CONNECTION)) {
-            headers.set(HttpHeaders.Names.CONNECTION, keepAliveHeaderValue(config));
-        }
-
-        String hostHeader = hostHeader(request, uri);
-        if (hostHeader != null)
-            headers.set(HttpHeaders.Names.HOST, hostHeader);
-
-        Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
-        String authorizationHeader = authorizationHeader(request, uri, proxyServer, realm);
-        if (authorizationHeader != null)
-            // don't override authorization but append
-            headers.add(HttpHeaders.Names.AUTHORIZATION, authorizationHeader);
-
-        String proxyAuthorizationHeader = proxyAuthorizationHeader(request, proxyServer, method);
-        if (proxyAuthorizationHeader != null)
-            headers.set(HttpHeaders.Names.PROXY_AUTHORIZATION, proxyAuthorizationHeader);
-
-        // Add default accept headers
-        if (!headers.contains(HttpHeaders.Names.ACCEPT))
-            headers.set(HttpHeaders.Names.ACCEPT, "*/*");
-
-        // Add default user agent
-        if (!headers.contains(HttpHeaders.Names.USER_AGENT) && config.getUserAgent() != null)
-            headers.set(HttpHeaders.Names.USER_AGENT, config.getUserAgent());
-
-        return nettyRequest;
-    }
-}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/FeedableBodyGenerator.java b/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/FeedableBodyGenerator.java
deleted file mode 100755
index dbff02252..000000000
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/FeedableBodyGenerator.java
+++ /dev/null
@@ -1,120 +0,0 @@
-/*
- * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at
- *     http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty.request.body;
-
-import org.asynchttpclient.Body;
-import org.asynchttpclient.BodyGenerator;
-import org.asynchttpclient.util.StandardCharsets;
-
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.util.Queue;
-import java.util.concurrent.ConcurrentLinkedQueue;
-import java.util.concurrent.atomic.AtomicInteger;
-
-/**
- * {@link BodyGenerator} which may return just part of the payload at the time handler is requesting it.
- * If it happens, PartialBodyGenerator becomes responsible for finishing payload transferring asynchronously.
- */
-public class FeedableBodyGenerator implements BodyGenerator {
-    private final static byte[] END_PADDING = "\r\n".getBytes(StandardCharsets.US_ASCII);
-    private final static byte[] ZERO = "0".getBytes(StandardCharsets.US_ASCII);
-    private final Queue<BodyPart> queue = new ConcurrentLinkedQueue<BodyPart>();
-    private final AtomicInteger queueSize = new AtomicInteger();
-    private FeedListener listener;
-
-    @Override
-    public Body createBody() throws IOException {
-        return new PushBody();
-    }
-
-    public void feed(final ByteBuffer buffer, final boolean isLast) throws IOException {
-        queue.offer(new BodyPart(buffer, isLast));
-        queueSize.incrementAndGet();
-        if (listener != null) {
-            listener.onContentAdded();
-        }
-    }
-
-    public static interface FeedListener {
-        void onContentAdded();
-    }
-
-    public void setListener(FeedListener listener) {
-        this.listener = listener;
-    }
-
-    private final class PushBody implements Body {
-        private final int ONGOING = 0;
-        private final int CLOSING = 1;
-        private final int FINISHED = 2;
-
-        private int finishState = 0;
-
-        @Override
-        public long getContentLength() {
-            return -1;
-        }
-
-        @Override
-        public long read(final ByteBuffer buffer) throws IOException {
-            BodyPart nextPart = queue.peek();
-            if (nextPart == null) {
-                // Nothing in the queue
-                switch (finishState) {
-                case ONGOING:
-                    return 0;
-                case CLOSING:
-                    buffer.put(ZERO);
-                    buffer.put(END_PADDING);
-                    finishState = FINISHED;
-                    return buffer.position();
-                case FINISHED:
-                    buffer.put(END_PADDING);
-                    return -1;
-                }
-            }
-            int capacity = buffer.remaining() - 10; // be safe (we'll have to add size, ending, etc.)
-            int size = Math.min(nextPart.buffer.remaining(), capacity);
-            buffer.put(Integer.toHexString(size).getBytes(StandardCharsets.US_ASCII));
-            buffer.put(END_PADDING);
-            for (int i = 0; i < size; i++) {
-                buffer.put(nextPart.buffer.get());
-            }
-            buffer.put(END_PADDING);
-            if (!nextPart.buffer.hasRemaining()) {
-                if (nextPart.isLast) {
-                    finishState = CLOSING;
-                }
-                queue.remove();
-            }
-            return size;
-        }
-
-        @Override
-        public void close() throws IOException {
-        }
-
-    }
-
-    private final static class BodyPart {
-        private final boolean isLast;
-        private final ByteBuffer buffer;
-
-        public BodyPart(final ByteBuffer buffer, final boolean isLast) {
-            this.buffer = buffer;
-            this.isLast = isLast;
-        }
-    }
-}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettySimpleAsyncHttpClientTest.java b/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettySimpleAsyncHttpClientTest.java
deleted file mode 100644
index 0b117c9ee..000000000
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettySimpleAsyncHttpClientTest.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.providers.netty;
-
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.SimpleAsyncHttpClientTest;
-
-public class NettySimpleAsyncHttpClientTest extends SimpleAsyncHttpClientTest {
-
-    /**
-     * Not Used with {@link org.asynchttpclient.SimpleAsyncHttpClient}
-     * 
-     * @param config
-     * @return
-     */
-    @Override
-    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return null;
-    }
-
-    public String getProviderClass() {
-        return NettyAsyncHttpProvider.class.getName();
-    }
-}
diff --git a/providers/netty3/pom.xml b/providers/netty3/pom.xml
new file mode 100644
index 000000000..f59eeeb7c
--- /dev/null
+++ b/providers/netty3/pom.xml
@@ -0,0 +1,21 @@
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+	<parent>
+		<groupId>org.asynchttpclient</groupId>
+		<artifactId>async-http-client-providers-parent</artifactId>
+		<version>2.0.0-SNAPSHOT</version>
+	</parent>
+	<modelVersion>4.0.0</modelVersion>
+	<artifactId>async-http-client-netty3</artifactId>
+	<name>Asynchronous Http Client Netty 3 Provider</name>
+	<description>
+        The Async Http Client Netty 3 Provider.
+    </description>
+
+	<dependencies>
+		<dependency>
+			<groupId>io.netty</groupId>
+			<artifactId>netty</artifactId>
+			<version>3.10.4.Final</version>
+		</dependency>
+	</dependencies>
+</project>
diff --git a/providers/netty3/src/main/java/org/asynchttpclient/netty/Callback.java b/providers/netty3/src/main/java/org/asynchttpclient/netty/Callback.java
new file mode 100644
index 000000000..a282ce273
--- /dev/null
+++ b/providers/netty3/src/main/java/org/asynchttpclient/netty/Callback.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+
+public abstract class Callback {
+
+    private final NettyResponseFuture<?> future;
+
+    public Callback(NettyResponseFuture<?> future) {
+        this.future = future;
+    }
+
+    abstract public void call() throws Exception;
+
+    public NettyResponseFuture<?> future() {
+        return future;
+    }
+}
diff --git a/providers/netty3/src/main/java/org/asynchttpclient/netty/NettyAsyncHttpProvider.java b/providers/netty3/src/main/java/org/asynchttpclient/netty/NettyAsyncHttpProvider.java
new file mode 100644
index 000000000..e759d3b28
--- /dev/null
+++ b/providers/netty3/src/main/java/org/asynchttpclient/netty/NettyAsyncHttpProvider.java
@@ -0,0 +1,101 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.AsyncHttpProvider;
+import org.asynchttpclient.ListenableFuture;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.netty.channel.ChannelManager;
+import org.asynchttpclient.netty.channel.pool.ChannelPoolPartitionSelector;
+import org.asynchttpclient.netty.request.NettyRequestSender;
+import org.asynchttpclient.netty.NettyAsyncHttpProvider;
+import org.asynchttpclient.netty.NettyAsyncHttpProviderConfig;
+import org.jboss.netty.channel.SimpleChannelUpstreamHandler;
+import org.jboss.netty.util.HashedWheelTimer;
+import org.jboss.netty.util.Timer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class NettyAsyncHttpProvider extends SimpleChannelUpstreamHandler implements AsyncHttpProvider {
+
+    static final Logger LOGGER = LoggerFactory.getLogger(NettyAsyncHttpProvider.class);
+
+    private final AsyncHttpClientConfig config;
+    private final AtomicBoolean closed = new AtomicBoolean(false);
+    private final ChannelManager channelManager;
+    private final boolean allowStopNettyTimer;
+    private final Timer nettyTimer;
+
+    private final NettyRequestSender requestSender;
+
+    public NettyAsyncHttpProvider(AsyncHttpClientConfig config) {
+
+        this.config = config;
+        NettyAsyncHttpProviderConfig nettyConfig = config.getAsyncHttpProviderConfig() instanceof NettyAsyncHttpProviderConfig ? //
+        (NettyAsyncHttpProviderConfig) config.getAsyncHttpProviderConfig()
+                : new NettyAsyncHttpProviderConfig();
+
+        allowStopNettyTimer = nettyConfig.getNettyTimer() == null;
+        nettyTimer = allowStopNettyTimer ? newNettyTimer() : nettyConfig.getNettyTimer();
+
+        channelManager = new ChannelManager(config, nettyConfig, nettyTimer);
+        requestSender = new NettyRequestSender(config, channelManager, nettyTimer, closed);
+        channelManager.configureBootstraps(requestSender, closed);
+    }
+
+    private Timer newNettyTimer() {
+        HashedWheelTimer timer = new HashedWheelTimer();
+        timer.start();
+        return timer;
+    }
+
+    public void close() {
+        if (closed.compareAndSet(false, true)) {
+            try {
+                channelManager.close();
+
+                // FIXME shouldn't close if not allowed
+                config.getExecutorService().shutdown();
+
+                if (allowStopNettyTimer)
+                    nettyTimer.stop();
+
+            } catch (Throwable t) {
+                LOGGER.warn("Unexpected error on close", t);
+            }
+        }
+    }
+
+    @Override
+    public <T> ListenableFuture<T> execute(Request request, final AsyncHandler<T> asyncHandler) {
+        try {
+            return requestSender.sendRequest(request, asyncHandler, null, false);
+        } catch (Exception e) {
+            asyncHandler.onThrowable(e);
+            return new ListenableFuture.CompletedFailure<>(e);
+        }
+    }
+
+    public void flushChannelPoolPartition(String partitionId) {
+        channelManager.flushPartition(partitionId);
+    }
+
+    public void flushChannelPoolPartitions(ChannelPoolPartitionSelector selector) {
+        channelManager.flushPartitions(selector);
+    }
+}
diff --git a/providers/netty3/src/main/java/org/asynchttpclient/netty/NettyAsyncHttpProviderConfig.java b/providers/netty3/src/main/java/org/asynchttpclient/netty/NettyAsyncHttpProviderConfig.java
new file mode 100644
index 000000000..b4cae8efc
--- /dev/null
+++ b/providers/netty3/src/main/java/org/asynchttpclient/netty/NettyAsyncHttpProviderConfig.java
@@ -0,0 +1,212 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ExecutorService;
+
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.AsyncHttpProviderConfig;
+import org.asynchttpclient.channel.pool.ConnectionStrategy;
+import org.asynchttpclient.netty.channel.pool.ChannelPool;
+import org.asynchttpclient.netty.handler.DefaultConnectionStrategy;
+import org.asynchttpclient.netty.ws.NettyWebSocket;
+import org.jboss.netty.channel.Channel;
+import org.jboss.netty.channel.ChannelPipeline;
+import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;
+import org.jboss.netty.handler.codec.http.HttpRequest;
+import org.jboss.netty.handler.codec.http.HttpResponse;
+import org.jboss.netty.util.Timer;
+
+/**
+ * This class can be used to pass Netty's internal configuration options. See
+ * Netty documentation for more information.
+ */
+public class NettyAsyncHttpProviderConfig implements AsyncHttpProviderConfig<String, Object> {
+
+    private final ConcurrentHashMap<String, Object> properties = new ConcurrentHashMap<>();
+
+    /**
+     * Add a property that will be used when the AsyncHttpClient initialize its
+     * {@link com.ning.http.client.AsyncHttpProvider}
+     * 
+     * @param name the name of the property
+     * @param value the value of the property
+     * @return this instance of AsyncHttpProviderConfig
+     */
+    public NettyAsyncHttpProviderConfig addProperty(String name, Object value) {
+        properties.put(name, value);
+        return this;
+    }
+
+    /**
+     * Return the value associated with the property's name
+     * 
+     * @param name
+     * @return this instance of AsyncHttpProviderConfig
+     */
+    public Object getProperty(String name) {
+        return properties.get(name);
+    }
+
+    /**
+     * Return the value associated with the property's name
+     * 
+     * @param name
+     * @return this instance of AsyncHttpProviderConfig
+     */
+    public <T> T getProperty(String name, Class<T> type, T defaultValue) {
+        Object value = properties.get(name);
+        if (value != null && type.isAssignableFrom(value.getClass())) {
+            return type.cast(value);
+        }
+        return defaultValue;
+    }
+
+    /**
+     * Remove the value associated with the property's name
+     * 
+     * @param name
+     * @return true if removed
+     */
+    public Object removeProperty(String name) {
+        return properties.remove(name);
+    }
+
+    /**
+     * Return the curent entry set.
+     * 
+     * @return a the curent entry set.
+     */
+    public Set<Map.Entry<String, Object>> propertiesSet() {
+        return properties.entrySet();
+    }
+
+    /**
+     * Enable Netty DeadLockChecker
+     */
+    private boolean useDeadLockChecker;
+
+    /**
+     * Allow configuring the Netty's boss executor service.
+     */
+    private ExecutorService bossExecutorService;
+
+    private AdditionalPipelineInitializer httpAdditionalPipelineInitializer;
+    private AdditionalPipelineInitializer wsAdditionalPipelineInitializer;
+
+    /**
+     * Allow configuring the Netty's socket channel factory.
+     */
+    private NioClientSocketChannelFactory socketChannelFactory;
+
+    private ChannelPool channelPool;
+
+    private Timer nettyTimer;
+
+    private NettyWebSocketFactory nettyWebSocketFactory = new DefaultNettyWebSocketFactory();
+
+    private ConnectionStrategy<HttpRequest, HttpResponse> connectionStrategy = new DefaultConnectionStrategy();
+
+    public boolean isUseDeadLockChecker() {
+        return useDeadLockChecker;
+    }
+
+    public void setUseDeadLockChecker(boolean useDeadLockChecker) {
+        this.useDeadLockChecker = useDeadLockChecker;
+    }
+
+    public ExecutorService getBossExecutorService() {
+        return bossExecutorService;
+    }
+
+    public void setBossExecutorService(ExecutorService bossExecutorService) {
+        this.bossExecutorService = bossExecutorService;
+    }
+
+    public AdditionalPipelineInitializer getHttpAdditionalPipelineInitializer() {
+        return httpAdditionalPipelineInitializer;
+    }
+
+    public void setHttpAdditionalPipelineInitializer(AdditionalPipelineInitializer httpAdditionalPipelineInitializer) {
+        this.httpAdditionalPipelineInitializer = httpAdditionalPipelineInitializer;
+    }
+
+    public AdditionalPipelineInitializer getWsAdditionalPipelineInitializer() {
+        return wsAdditionalPipelineInitializer;
+    }
+
+    public void setWsAdditionalPipelineInitializer(AdditionalPipelineInitializer wsAdditionalPipelineInitializer) {
+        this.wsAdditionalPipelineInitializer = wsAdditionalPipelineInitializer;
+    }
+
+    public NioClientSocketChannelFactory getSocketChannelFactory() {
+        return socketChannelFactory;
+    }
+
+    public void setSocketChannelFactory(NioClientSocketChannelFactory socketChannelFactory) {
+        this.socketChannelFactory = socketChannelFactory;
+    }
+
+    public Timer getNettyTimer() {
+        return nettyTimer;
+    }
+
+    public void setNettyTimer(Timer nettyTimer) {
+        this.nettyTimer = nettyTimer;
+    }
+
+    public ChannelPool getChannelPool() {
+        return channelPool;
+    }
+
+    public void setChannelPool(ChannelPool channelPool) {
+        this.channelPool = channelPool;
+    }
+
+    public NettyWebSocketFactory getNettyWebSocketFactory() {
+        return nettyWebSocketFactory;
+    }
+
+    public void setNettyWebSocketFactory(NettyWebSocketFactory nettyWebSocketFactory) {
+        this.nettyWebSocketFactory = nettyWebSocketFactory;
+    }
+
+    public ConnectionStrategy<HttpRequest, HttpResponse> getConnectionStrategy() {
+        return connectionStrategy;
+    }
+
+    public void setConnectionStrategy(ConnectionStrategy<HttpRequest, HttpResponse> connectionStrategy) {
+        this.connectionStrategy = connectionStrategy;
+    }
+
+    public static interface NettyWebSocketFactory {
+        NettyWebSocket newNettyWebSocket(Channel channel, AsyncHttpClientConfig config);
+    }
+
+    public static interface AdditionalPipelineInitializer {
+
+        void initPipeline(ChannelPipeline pipeline) throws Exception;
+    }
+
+    public class DefaultNettyWebSocketFactory implements NettyWebSocketFactory {
+
+        @Override
+        public NettyWebSocket newNettyWebSocket(Channel channel, AsyncHttpClientConfig config) {
+            return new NettyWebSocket(channel, config);
+        }
+    }
+}
diff --git a/providers/netty3/src/main/java/org/asynchttpclient/netty/NettyResponse.java b/providers/netty3/src/main/java/org/asynchttpclient/netty/NettyResponse.java
new file mode 100644
index 000000000..d7da0155a
--- /dev/null
+++ b/providers/netty3/src/main/java/org/asynchttpclient/netty/NettyResponse.java
@@ -0,0 +1,104 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+import static org.asynchttpclient.netty.util.ChannelBufferUtils.channelBuffer2bytes;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import java.nio.charset.Charset;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.ResponseBase;
+import org.asynchttpclient.cookie.Cookie;
+import org.asynchttpclient.cookie.CookieDecoder;
+import org.jboss.netty.buffer.ChannelBuffer;
+import org.jboss.netty.buffer.ChannelBufferInputStream;
+import org.jboss.netty.buffer.ChannelBuffers;
+import org.jboss.netty.handler.codec.http.HttpHeaders;
+
+/**
+ * Wrapper around the {@link org.asynchttpclient.ning.http.client.Response} API.
+ */
+public class NettyResponse extends ResponseBase {
+
+    public NettyResponse(HttpResponseStatus status, HttpResponseHeaders headers, List<HttpResponseBodyPart> bodyParts) {
+        super(status, headers, bodyParts);
+    }
+
+    @Override
+    public byte[] getResponseBodyAsBytes() throws IOException {
+        return channelBuffer2bytes(getResponseBodyAsChannelBuffer());
+    }
+
+    @Override
+    public ByteBuffer getResponseBodyAsByteBuffer() throws IOException {
+        return getResponseBodyAsChannelBuffer().toByteBuffer();
+    }
+
+    @Override
+    public String getResponseBody() throws IOException {
+        return getResponseBody(null);
+    }
+
+    public String getResponseBody(Charset charset) throws IOException {
+        return getResponseBodyAsChannelBuffer().toString(calculateCharset(charset));
+    }
+
+    @Override
+    public InputStream getResponseBodyAsStream() throws IOException {
+        return new ChannelBufferInputStream(getResponseBodyAsChannelBuffer());
+    }
+
+    public ChannelBuffer getResponseBodyAsChannelBuffer() throws IOException {
+        ChannelBuffer b = null;
+        switch (bodyParts.size()) {
+        case 0:
+            b = ChannelBuffers.EMPTY_BUFFER;
+            break;
+        case 1:
+            b = NettyResponseBodyPart.class.cast(bodyParts.get(0)).getChannelBuffer();
+            break;
+        default:
+            ChannelBuffer[] channelBuffers = new ChannelBuffer[bodyParts.size()];
+            for (int i = 0; i < bodyParts.size(); i++) {
+                channelBuffers[i] = NettyResponseBodyPart.class.cast(bodyParts.get(i)).getChannelBuffer();
+            }
+            b = ChannelBuffers.wrappedBuffer(channelBuffers);
+        }
+
+        return b;
+    }
+
+    @Override
+    protected List<Cookie> buildCookies() {
+        List<Cookie> cookies = new ArrayList<>();
+        for (Map.Entry<String, List<String>> header : headers.getHeaders().entrySet()) {
+            if (header.getKey().equalsIgnoreCase(HttpHeaders.Names.SET_COOKIE)) {
+                // TODO: ask for parsed header
+                List<String> v = header.getValue();
+                for (String value : v) {
+                    cookies.add(CookieDecoder.decode(value));
+                }
+            }
+        }
+        return cookies;
+    }
+}
diff --git a/providers/netty3/src/main/java/org/asynchttpclient/netty/NettyResponseBodyPart.java b/providers/netty3/src/main/java/org/asynchttpclient/netty/NettyResponseBodyPart.java
new file mode 100644
index 000000000..dc9111d06
--- /dev/null
+++ b/providers/netty3/src/main/java/org/asynchttpclient/netty/NettyResponseBodyPart.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+import static org.asynchttpclient.netty.util.ChannelBufferUtils.channelBuffer2bytes;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.nio.ByteBuffer;
+
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.jboss.netty.buffer.ChannelBuffer;
+import org.jboss.netty.handler.codec.http.HttpChunk;
+import org.jboss.netty.handler.codec.http.HttpResponse;
+
+/**
+ * A callback class used when an HTTP response body is received.
+ */
+public class NettyResponseBodyPart extends HttpResponseBodyPart {
+
+    private final boolean last;
+    private final ChannelBuffer content;
+    private volatile byte[] bytes;
+    private final int length;
+    private boolean closeConnection;
+
+    public NettyResponseBodyPart(HttpResponse response, boolean last) {
+        this(response, null, last);
+    }
+
+    public NettyResponseBodyPart(HttpResponse response, HttpChunk chunk, boolean last) {
+        this.last = last;
+        content = chunk != null ? chunk.getContent() : response.getContent();
+        length = content.readableBytes();
+    }
+
+    /**
+     * Return the response body's part bytes received.
+     *
+     * @return the response body's part bytes received.
+     */
+    public byte[] getBodyPartBytes() {
+        if (bytes == null)
+            bytes = channelBuffer2bytes(content);
+        return bytes;
+    }
+
+    public int writeTo(OutputStream outputStream) throws IOException {
+        ChannelBuffer b = getChannelBuffer();
+        int read = b.readableBytes();
+        int index = b.readerIndex();
+        if (read > 0) {
+            b.readBytes(outputStream, read);
+        }
+        b.readerIndex(index);
+        return read;
+    }
+
+    public ChannelBuffer getChannelBuffer() {
+        return content;
+    }
+
+    @Override
+    public ByteBuffer getBodyByteBuffer() {
+        return content.toByteBuffer();
+    }
+
+    @Override
+    public int length() {
+        return length;
+    }
+
+    @Override
+    public InputStream readBodyPartBytes() {
+        return new ByteArrayInputStream(bytes);
+    }
+
+    @Override
+    public boolean isLast() {
+        return last;
+    }
+
+    @Override
+    public void markUnderlyingConnectionAsToBeClosed() {
+        closeConnection = true;
+    }
+
+    @Override
+    public boolean isUnderlyingConnectionToBeClosed() {
+        return closeConnection;
+    }
+}
diff --git a/providers/netty3/src/main/java/org/asynchttpclient/netty/NettyResponseFuture.java b/providers/netty3/src/main/java/org/asynchttpclient/netty/NettyResponseFuture.java
new file mode 100644
index 000000000..eeac423b6
--- /dev/null
+++ b/providers/netty3/src/main/java/org/asynchttpclient/netty/NettyResponseFuture.java
@@ -0,0 +1,445 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+import static org.asynchttpclient.util.DateUtils.millisTime;
+
+import java.net.SocketAddress;
+import java.util.concurrent.CancellationException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicReference;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.channel.pool.ConnectionPoolPartitioning;
+import org.asynchttpclient.future.AbstractListenableFuture;
+import org.asynchttpclient.netty.channel.Channels;
+import org.asynchttpclient.netty.request.NettyRequest;
+import org.asynchttpclient.netty.timeout.TimeoutsHolder;
+import org.asynchttpclient.proxy.ProxyServer;
+import org.asynchttpclient.uri.Uri;
+import org.jboss.netty.channel.Channel;
+import org.jboss.netty.handler.codec.http.HttpHeaders;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * A {@link Future} that can be used to track when an asynchronous HTTP request has been fully processed.
+ * 
+ * @param <V>
+ */
+public final class NettyResponseFuture<V> extends AbstractListenableFuture<V> {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(NettyResponseFuture.class);
+
+    public enum STATE {
+        NEW, POOLED, RECONNECTED, CLOSED,
+    }
+    
+    private final long start = millisTime();
+    private final ConnectionPoolPartitioning connectionPoolPartitioning;
+    private final ProxyServer proxyServer;
+    private final int maxRetry;
+    private final CountDownLatch latch = new CountDownLatch(1);
+
+    // state mutated from outside the event loop
+    // TODO check if they are indeed mutated outside the event loop
+    private final AtomicBoolean isDone = new AtomicBoolean(false);
+    private final AtomicBoolean isCancelled = new AtomicBoolean(false);
+    private final AtomicInteger redirectCount = new AtomicInteger();
+    private final AtomicBoolean inAuth = new AtomicBoolean(false);
+    private final AtomicBoolean statusReceived = new AtomicBoolean(false);
+    private final AtomicLong touch = new AtomicLong(millisTime());
+    private final AtomicReference<STATE> state = new AtomicReference<>(STATE.NEW);
+    private final AtomicBoolean contentProcessed = new AtomicBoolean(false);
+    private final AtomicInteger currentRetry = new AtomicInteger(0);
+    private final AtomicBoolean onThrowableCalled = new AtomicBoolean(false);
+    private final AtomicReference<V> content = new AtomicReference<>();
+    private final AtomicReference<ExecutionException> exEx = new AtomicReference<>();
+    private volatile TimeoutsHolder timeoutsHolder;
+
+    // state mutated only inside the event loop
+    private Channel channel;
+    private boolean keepAlive = true;
+    private Request request;
+    private NettyRequest nettyRequest;
+    private HttpHeaders httpHeaders;
+    private AsyncHandler<V> asyncHandler;
+    private boolean streamWasAlreadyConsumed;
+    private boolean reuseChannel;
+    private boolean headersAlreadyWrittenOnContinue;
+    private boolean dontWriteBodyBecauseExpectContinue;
+    private boolean allowConnect;
+
+    public NettyResponseFuture(Request request,//
+            AsyncHandler<V> asyncHandler,//
+            NettyRequest nettyRequest,//
+            int maxRetry,//
+            ConnectionPoolPartitioning connectionPoolPartitioning,//
+            ProxyServer proxyServer) {
+
+        this.asyncHandler = asyncHandler;
+        this.request = request;
+        this.nettyRequest = nettyRequest;
+        this.connectionPoolPartitioning = connectionPoolPartitioning;
+        this.proxyServer = proxyServer;
+        this.maxRetry = maxRetry;
+    }
+
+    /*********************************************/
+    /**       java.util.concurrent.Future       **/
+    /*********************************************/
+
+    @Override
+    public boolean isDone() {
+        return isDone.get() || isCancelled();
+    }
+
+    @Override
+    public boolean isCancelled() {
+        return isCancelled.get();
+    }
+
+    @Override
+    public boolean cancel(boolean force) {
+        cancelTimeouts();
+
+        if (isCancelled.getAndSet(true))
+            return false;
+
+        // cancel could happen before channel was attached
+        if (channel != null) {
+            Channels.setDiscard(channel);
+            Channels.silentlyCloseChannel(channel);
+        }
+
+        if (!onThrowableCalled.getAndSet(true)) {
+            try {
+                asyncHandler.onThrowable(new CancellationException());
+            } catch (Throwable t) {
+                LOGGER.warn("cancel", t);
+            }
+        }
+        latch.countDown();
+        runListeners();
+        return true;
+    }
+
+    @Override
+    public V get() throws InterruptedException, ExecutionException {
+        latch.await();
+        return getContent();
+    }
+
+    @Override
+    public V get(long l, TimeUnit tu) throws InterruptedException, TimeoutException, ExecutionException {
+        if (!latch.await(l, tu))
+            throw new TimeoutException();
+        return getContent();
+    }
+
+    private V getContent() throws ExecutionException {
+
+        if (isCancelled())
+            throw new CancellationException();
+
+        ExecutionException e = exEx.get();
+        if (e != null)
+            throw e;
+
+        V update = content.get();
+        // No more retry
+        currentRetry.set(maxRetry);
+        if (!contentProcessed.getAndSet(true)) {
+            try {
+                update = asyncHandler.onCompleted();
+            } catch (Throwable ex) {
+                if (!onThrowableCalled.getAndSet(true)) {
+                    try {
+                        try {
+                            asyncHandler.onThrowable(ex);
+                        } catch (Throwable t) {
+                            LOGGER.debug("asyncHandler.onThrowable", t);
+                        }
+                        throw new RuntimeException(ex);
+                    } finally {
+                        cancelTimeouts();
+                    }
+                }
+            }
+            content.compareAndSet(null, update);
+        }
+        return update;
+    }
+
+    /*********************************************/
+    /**   org.asynchttpclient.ListenableFuture  **/
+    /*********************************************/
+
+    private boolean terminateAndExit() {
+        cancelTimeouts();
+        this.channel = null;
+        this.reuseChannel = false;
+        return isDone.getAndSet(true) || isCancelled.get();
+    }
+
+    public final void done() {
+
+        if (terminateAndExit())
+            return;
+
+        try {
+            getContent();
+
+        } catch (ExecutionException t) {
+            return;
+        } catch (RuntimeException t) {
+            Throwable exception = t.getCause() != null ? t.getCause() : t;
+            exEx.compareAndSet(null, new ExecutionException(exception));
+
+        } finally {
+            latch.countDown();
+        }
+
+        runListeners();
+    }
+
+    public final void abort(final Throwable t) {
+
+        exEx.compareAndSet(null, new ExecutionException(t));
+
+        if (terminateAndExit())
+            return;
+
+        if (onThrowableCalled.compareAndSet(false, true)) {
+            try {
+                asyncHandler.onThrowable(t);
+            } catch (Throwable te) {
+                LOGGER.debug("asyncHandler.onThrowable", te);
+            }
+        }
+        latch.countDown();
+        runListeners();
+    }
+
+    @Override
+    public void touch() {
+        touch.set(millisTime());
+    }
+
+    /*********************************************/
+    /**                 INTERNAL                **/
+    /*********************************************/
+
+    public Uri getUri() {
+        return request.getUri();
+    }
+
+    public ConnectionPoolPartitioning getConnectionPoolPartitioning() {
+        return connectionPoolPartitioning;
+    }
+
+    public ProxyServer getProxyServer() {
+        return proxyServer;
+    }
+
+    public void setAsyncHandler(AsyncHandler<V> asyncHandler) {
+        this.asyncHandler = asyncHandler;
+    }
+
+    public void cancelTimeouts() {
+        if (timeoutsHolder != null) {
+            timeoutsHolder.cancel();
+            timeoutsHolder = null;
+        }
+    }
+
+    public final Request getRequest() {
+        return request;
+    }
+
+    public final NettyRequest getNettyRequest() {
+        return nettyRequest;
+    }
+
+    public final void setNettyRequest(NettyRequest nettyRequest) {
+        this.nettyRequest = nettyRequest;
+    }
+
+    public final AsyncHandler<V> getAsyncHandler() {
+        return asyncHandler;
+    }
+
+    public final boolean isKeepAlive() {
+        return keepAlive;
+    }
+
+    public final void setKeepAlive(final boolean keepAlive) {
+        this.keepAlive = keepAlive;
+    }
+
+    public final HttpHeaders getHttpHeaders() {
+        return httpHeaders;
+    }
+
+    public final void setHttpHeaders(HttpHeaders httpHeaders) {
+        this.httpHeaders = httpHeaders;
+    }
+
+    public int incrementAndGetCurrentRedirectCount() {
+        return redirectCount.incrementAndGet();
+    }
+
+    public void setTimeoutsHolder(TimeoutsHolder timeoutsHolder) {
+        this.timeoutsHolder = timeoutsHolder;
+    }
+
+    public boolean isInAuth() {
+        return inAuth.get();
+    }
+
+    public boolean getAndSetAuth(boolean inDigestAuth) {
+        return inAuth.getAndSet(inDigestAuth);
+    }
+
+    public STATE getState() {
+        return state.get();
+    }
+
+    public void setState(STATE state) {
+        this.state.set(state);
+    }
+
+    public boolean getAndSetStatusReceived(boolean sr) {
+        return statusReceived.getAndSet(sr);
+    }
+
+    public boolean isStreamWasAlreadyConsumed() {
+        return streamWasAlreadyConsumed;
+    }
+
+    public void setStreamWasAlreadyConsumed(boolean streamWasAlreadyConsumed) {
+        this.streamWasAlreadyConsumed = streamWasAlreadyConsumed;
+    }
+
+    public long getLastTouch() {
+        return touch.get();
+    }
+
+    public void setHeadersAlreadyWrittenOnContinue(boolean headersAlreadyWrittenOnContinue) {
+        this.headersAlreadyWrittenOnContinue = headersAlreadyWrittenOnContinue;
+    }
+
+    public boolean isHeadersAlreadyWrittenOnContinue() {
+        return headersAlreadyWrittenOnContinue;
+    }
+
+    public void setDontWriteBodyBecauseExpectContinue(boolean dontWriteBodyBecauseExpectContinue) {
+        this.dontWriteBodyBecauseExpectContinue = dontWriteBodyBecauseExpectContinue;
+    }
+
+    public boolean isDontWriteBodyBecauseExpectContinue() {
+        return dontWriteBodyBecauseExpectContinue;
+    }
+
+    public void setReuseChannel(boolean reuseChannel) {
+        this.reuseChannel = reuseChannel;
+    }
+
+    public boolean isConnectAllowed() {
+        return allowConnect;
+    }
+
+    public void setConnectAllowed(boolean allowConnect) {
+        this.allowConnect = allowConnect;
+    }
+
+    public void attachChannel(Channel channel, boolean reuseChannel) {
+
+        // future could have been cancelled first
+        if (isDone()) {
+            Channels.silentlyCloseChannel(channel);
+        }
+
+        this.channel = channel;
+        this.reuseChannel = reuseChannel;
+    }
+
+    public Channel channel() {
+        return channel;
+    }
+
+    public boolean reuseChannel() {
+        return reuseChannel;
+    }
+
+    public boolean canRetry() {
+        return maxRetry > 0 && currentRetry.incrementAndGet() <= maxRetry;
+    }
+
+    public SocketAddress getChannelRemoteAddress() {
+        return channel != null ? channel.getRemoteAddress() : null;
+    }
+
+    public void setRequest(Request request) {
+        this.request = request;
+    }
+
+    /**
+     * Return true if the {@link Future} can be recovered. There is some scenario where a connection can be closed by an
+     * unexpected IOException, and in some situation we can recover from that exception.
+     * 
+     * @return true if that {@link Future} cannot be recovered.
+     */
+    public boolean canBeReplayed() {
+        return !isDone() && canRetry()
+                && !(Channels.isChannelValid(channel) && !getUri().getScheme().equalsIgnoreCase("https")) && !isInAuth();
+    }
+
+    public long getStart() {
+        return start;
+    }
+
+    public Object getPartitionKey() {
+        return connectionPoolPartitioning.getPartitionKey(request.getUri(), request.getVirtualHost(), proxyServer);
+    }
+
+    @Override
+    public String toString() {
+        return "NettyResponseFuture{" + //
+                "currentRetry=" + currentRetry + //
+                ",\n\tisDone=" + isDone + //
+                ",\n\tisCancelled=" + isCancelled + //
+                ",\n\tasyncHandler=" + asyncHandler + //
+                ",\n\tnettyRequest=" + nettyRequest + //
+                ",\n\tcontent=" + content + //
+                ",\n\turi=" + getUri() + //
+                ",\n\tkeepAlive=" + keepAlive + //
+                ",\n\thttpHeaders=" + httpHeaders + //
+                ",\n\texEx=" + exEx + //
+                ",\n\tredirectCount=" + redirectCount + //
+                ",\n\ttimeoutsHolder=" + timeoutsHolder + //
+                ",\n\tinAuth=" + inAuth + //
+                ",\n\tstatusReceived=" + statusReceived + //
+                ",\n\ttouch=" + touch + //
+                '}';
+    }
+}
diff --git a/providers/netty3/src/main/java/org/asynchttpclient/netty/NettyResponseHeaders.java b/providers/netty3/src/main/java/org/asynchttpclient/netty/NettyResponseHeaders.java
new file mode 100644
index 000000000..a70ca6374
--- /dev/null
+++ b/providers/netty3/src/main/java/org/asynchttpclient/netty/NettyResponseHeaders.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+import java.util.Map;
+
+import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.jboss.netty.handler.codec.http.HttpHeaders;
+
+/**
+ * A class that represent the HTTP headers.
+ */
+public class NettyResponseHeaders extends HttpResponseHeaders {
+
+    private final HttpHeaders responseHeaders;
+    private final HttpHeaders trailingHeaders;
+    private final FluentCaseInsensitiveStringsMap headers;
+
+    // FIXME unused AsyncHttpProvider provider
+    public NettyResponseHeaders(HttpHeaders responseHeaders) {
+        this(responseHeaders, null);
+    }
+
+    public NettyResponseHeaders(HttpHeaders responseHeaders, HttpHeaders traillingHeaders) {
+        super(traillingHeaders != null);
+        this.responseHeaders = responseHeaders;
+        this.trailingHeaders = traillingHeaders;
+        headers = computerHeaders();
+    }
+
+    private FluentCaseInsensitiveStringsMap computerHeaders() {
+        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+        for (Map.Entry<String, String> header : responseHeaders) {
+            h.add(header.getKey(), header.getValue());
+        }
+
+        if (trailingHeaders != null) {
+            for (Map.Entry<String, String> header : trailingHeaders) {
+                h.add(header.getKey(), header.getValue());
+            }
+        }
+
+        return h;
+    }
+
+    /**
+     * Return the HTTP header
+     * 
+     * @return an {@link org.asynchttpclient.FluentCaseInsensitiveStringsMap}
+     */
+    @Override
+    public FluentCaseInsensitiveStringsMap getHeaders() {
+        return headers;
+    }
+}
diff --git a/providers/netty3/src/main/java/org/asynchttpclient/netty/NettyResponseStatus.java b/providers/netty3/src/main/java/org/asynchttpclient/netty/NettyResponseStatus.java
new file mode 100644
index 000000000..b29817263
--- /dev/null
+++ b/providers/netty3/src/main/java/org/asynchttpclient/netty/NettyResponseStatus.java
@@ -0,0 +1,101 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+import java.net.SocketAddress;
+import java.util.List;
+
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.uri.Uri;
+import org.jboss.netty.channel.Channel;
+import org.jboss.netty.handler.codec.http.HttpResponse;
+
+/**
+ * A class that represent the HTTP response' status line (code + text)
+ */
+public class NettyResponseStatus extends HttpResponseStatus {
+
+    private final HttpResponse response;
+    private final SocketAddress remoteAddress;
+    private final SocketAddress localAddress;
+
+    public NettyResponseStatus(Uri uri, AsyncHttpClientConfig config, HttpResponse response, Channel channel) {
+        super(uri, config);
+        this.response = response;
+        if (channel != null) {
+            remoteAddress = channel.getRemoteAddress();
+            localAddress = channel.getLocalAddress();
+        } else {
+            remoteAddress = null;
+            localAddress = null;
+        }
+    }
+
+    /**
+     * Return the response status code
+     *
+     * @return the response status code
+     */
+    public int getStatusCode() {
+        return response.getStatus().getCode();
+    }
+
+    /**
+     * Return the response status text
+     *
+     * @return the response status text
+     */
+    public String getStatusText() {
+        return response.getStatus().getReasonPhrase();
+    }
+
+    @Override
+    public String getProtocolName() {
+        return response.getProtocolVersion().getProtocolName();
+    }
+
+    @Override
+    public int getProtocolMajorVersion() {
+        return response.getProtocolVersion().getMajorVersion();
+    }
+
+    @Override
+    public int getProtocolMinorVersion() {
+        return response.getProtocolVersion().getMinorVersion();
+    }
+
+    @Override
+    public String getProtocolText() {
+        return response.getProtocolVersion().getText();
+    }
+
+    @Override
+    public Response prepareResponse(HttpResponseHeaders headers, List<HttpResponseBodyPart> bodyParts) {
+        return new NettyResponse(this, headers, bodyParts);
+    }
+
+    @Override
+    public SocketAddress getRemoteAddress() {
+        return remoteAddress;
+    }
+
+    @Override
+    public SocketAddress getLocalAddress() {
+        return localAddress;
+    }
+}
diff --git a/providers/netty3/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java b/providers/netty3/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java
new file mode 100644
index 000000000..68b8d7af1
--- /dev/null
+++ b/providers/netty3/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java
@@ -0,0 +1,481 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.channel;
+
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.getExplicitPort;
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.getSchemeDefaultPort;
+import static org.asynchttpclient.util.HttpUtils.WS;
+import static org.asynchttpclient.util.HttpUtils.isSecure;
+import static org.asynchttpclient.util.HttpUtils.isWebSocket;
+import static org.asynchttpclient.util.MiscUtils.buildStaticIOException;
+import static org.jboss.netty.channel.Channels.pipeline;
+import static org.jboss.netty.handler.ssl.SslHandler.getDefaultBufferPool;
+
+import java.io.IOException;
+import java.security.GeneralSecurityException;
+import java.util.Map.Entry;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Semaphore;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import javax.net.ssl.SSLEngine;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.channel.SSLEngineFactory;
+import org.asynchttpclient.channel.pool.ConnectionPoolPartitioning;
+import org.asynchttpclient.handler.AsyncHandlerExtensions;
+import org.asynchttpclient.internal.chmv8.ConcurrentHashMapV8;
+import org.asynchttpclient.netty.Callback;
+import org.asynchttpclient.netty.NettyAsyncHttpProviderConfig;
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.channel.pool.ChannelPool;
+import org.asynchttpclient.netty.channel.pool.ChannelPoolPartitionSelector;
+import org.asynchttpclient.netty.channel.pool.DefaultChannelPool;
+import org.asynchttpclient.netty.channel.pool.NoopChannelPool;
+import org.asynchttpclient.netty.handler.HttpProtocol;
+import org.asynchttpclient.netty.handler.Processor;
+import org.asynchttpclient.netty.handler.Protocol;
+import org.asynchttpclient.netty.handler.WebSocketProtocol;
+import org.asynchttpclient.netty.request.NettyRequestSender;
+import org.asynchttpclient.proxy.ProxyServer;
+import org.asynchttpclient.uri.Uri;
+import org.asynchttpclient.util.PrefixIncrementThreadFactory;
+import org.jboss.netty.bootstrap.ClientBootstrap;
+import org.jboss.netty.channel.Channel;
+import org.jboss.netty.channel.ChannelPipeline;
+import org.jboss.netty.channel.ChannelPipelineFactory;
+import org.jboss.netty.channel.DefaultChannelFuture;
+import org.jboss.netty.channel.group.ChannelGroup;
+import org.jboss.netty.channel.socket.ClientSocketChannelFactory;
+import org.jboss.netty.channel.socket.nio.NioClientBossPool;
+import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;
+import org.jboss.netty.channel.socket.nio.NioWorkerPool;
+import org.jboss.netty.handler.codec.http.HttpClientCodec;
+import org.jboss.netty.handler.codec.http.HttpContentDecompressor;
+import org.jboss.netty.handler.codec.http.websocketx.WebSocket08FrameDecoder;
+import org.jboss.netty.handler.codec.http.websocketx.WebSocket08FrameEncoder;
+import org.jboss.netty.handler.codec.http.websocketx.WebSocketFrameAggregator;
+import org.jboss.netty.handler.ssl.SslHandler;
+import org.jboss.netty.handler.stream.ChunkedWriteHandler;
+import org.jboss.netty.util.HashedWheelTimer;
+import org.jboss.netty.util.ThreadNameDeterminer;
+import org.jboss.netty.util.Timer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class ChannelManager {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(ChannelManager.class);
+
+    public static final String HTTP_HANDLER = "httpHandler";
+    public static final String SSL_HANDLER = "sslHandler";
+    public static final String HTTP_PROCESSOR = "httpProcessor";
+    public static final String WS_PROCESSOR = "wsProcessor";
+    public static final String DEFLATER_HANDLER = "deflater";
+    public static final String INFLATER_HANDLER = "inflater";
+    public static final String CHUNKED_WRITER_HANDLER = "chunkedWriter";
+    public static final String WS_DECODER_HANDLER = "ws-decoder";
+    public static final String WS_FRAME_AGGREGATOR = "ws-aggregator";
+    public static final String WS_ENCODER_HANDLER = "ws-encoder";
+
+    private final AsyncHttpClientConfig config;
+    private final NettyAsyncHttpProviderConfig nettyConfig;
+    private final SSLEngineFactory sslEngineFactory;
+    private final ChannelPool channelPool;
+    private final boolean maxTotalConnectionsEnabled;
+    private final Semaphore freeChannels;
+    private final ChannelGroup openChannels;
+    private final boolean maxConnectionsPerHostEnabled;
+    private final ConcurrentHashMapV8<Object, Semaphore> freeChannelsPerHost;
+    private final ConcurrentHashMapV8<Integer, Object> channelId2PartitionKey;
+    private final long handshakeTimeout;
+    private final Timer nettyTimer;
+    private final IOException tooManyConnections;
+    private final IOException tooManyConnectionsPerHost;
+    private final IOException poolAlreadyClosed;
+
+    private final ClientSocketChannelFactory socketChannelFactory;
+    private final boolean allowReleaseSocketChannelFactory;
+    private final ClientBootstrap httpBootstrap;
+    private final ClientBootstrap wsBootstrap;
+    private final ConcurrentHashMapV8.Fun<Object, Semaphore> semaphoreComputer;
+
+    private Processor wsProcessor;
+
+    public ChannelManager(final AsyncHttpClientConfig config, NettyAsyncHttpProviderConfig nettyConfig, Timer nettyTimer) {
+
+        this.config = config;
+        this.nettyConfig = nettyConfig;
+        this.nettyTimer = nettyTimer;
+        this.sslEngineFactory = config.getSslEngineFactory() != null ? config.getSslEngineFactory() : new SSLEngineFactory.DefaultSSLEngineFactory(config);
+
+        ChannelPool channelPool = nettyConfig.getChannelPool();
+        if (channelPool == null && config.isAllowPoolingConnections()) {
+            channelPool = new DefaultChannelPool(config, nettyTimer);
+        } else if (channelPool == null) {
+            channelPool = new NoopChannelPool();
+        }
+        this.channelPool = channelPool;
+
+        tooManyConnections = buildStaticIOException(String.format("Too many connections %s", config.getMaxConnections()));
+        tooManyConnectionsPerHost = buildStaticIOException(String.format("Too many connections per host %s", config.getMaxConnectionsPerHost()));
+        poolAlreadyClosed = buildStaticIOException("Pool is already closed");
+        maxTotalConnectionsEnabled = config.getMaxConnections() > 0;
+        maxConnectionsPerHostEnabled = config.getMaxConnectionsPerHost() > 0;
+
+        if (maxTotalConnectionsEnabled || maxConnectionsPerHostEnabled) {
+            openChannels = new CleanupChannelGroup("asyncHttpClient") {
+                @Override
+                public boolean remove(Object o) {
+                    boolean removed = super.remove(o);
+                    if (removed) {
+                        if (maxTotalConnectionsEnabled)
+                            freeChannels.release();
+                        if (maxConnectionsPerHostEnabled) {
+                            Object partitionKey = channelId2PartitionKey.remove(Channel.class.cast(o).getId());
+                            if (partitionKey != null) {
+                                Semaphore freeChannelsForHost = freeChannelsPerHost.get(partitionKey);
+                                if (freeChannelsForHost != null)
+                                    freeChannelsForHost.release();
+                            }
+                        }
+                    }
+                    return removed;
+                }
+            };
+            freeChannels = new Semaphore(config.getMaxConnections());
+        } else {
+            openChannels = new CleanupChannelGroup("asyncHttpClient");
+            freeChannels = null;
+        }
+
+        if (maxConnectionsPerHostEnabled) {
+            freeChannelsPerHost = new ConcurrentHashMapV8<>();
+            channelId2PartitionKey = new ConcurrentHashMapV8<>();
+            semaphoreComputer = new ConcurrentHashMapV8.Fun<Object, Semaphore>() {
+                @Override
+                public Semaphore apply(Object partitionKey) {
+                    return new Semaphore(config.getMaxConnectionsPerHost());
+                }
+            };
+        } else {
+            freeChannelsPerHost = null;
+            channelId2PartitionKey = null;
+            semaphoreComputer = null;
+        }
+
+        handshakeTimeout = config.getHandshakeTimeout();
+
+        if (nettyConfig.getSocketChannelFactory() != null) {
+            socketChannelFactory = nettyConfig.getSocketChannelFactory();
+            // cannot allow releasing shared channel factory
+            allowReleaseSocketChannelFactory = false;
+
+        } else {
+            ExecutorService e = nettyConfig.getBossExecutorService();
+            if (e == null) {
+                ThreadFactory threadFactory = new PrefixIncrementThreadFactory(
+                        config.getNameOrDefault() + "-boss-");
+                e = Executors.newCachedThreadPool(threadFactory);
+            }
+            int numWorkers = config.getIoThreadMultiplier() * Runtime.getRuntime().availableProcessors();
+            LOGGER.trace("Number of application's worker threads is {}", numWorkers);
+            NioClientBossPool nioClientBossPool = new NioClientBossPool(e, 1, new HashedWheelTimer(), ThreadNameDeterminer.CURRENT);
+            NioWorkerPool nioWorkerPool = new NioWorkerPool(config.getExecutorService(), numWorkers, ThreadNameDeterminer.CURRENT);
+            socketChannelFactory = new NioClientSocketChannelFactory(nioClientBossPool, nioWorkerPool);
+            allowReleaseSocketChannelFactory = true;
+        }
+
+        httpBootstrap = new ClientBootstrap(socketChannelFactory);
+        wsBootstrap = new ClientBootstrap(socketChannelFactory);
+
+        DefaultChannelFuture.setUseDeadLockChecker(nettyConfig.isUseDeadLockChecker());
+
+        // FIXME isn't there a constant for this name???
+        if (config.getConnectTimeout() > 0)
+            nettyConfig.addProperty("connectTimeoutMillis", config.getConnectTimeout());
+        for (Entry<String, Object> entry : nettyConfig.propertiesSet()) {
+            String key = entry.getKey();
+            Object value = entry.getValue();
+            httpBootstrap.setOption(key, value);
+            wsBootstrap.setOption(key, value);
+        }
+    }
+
+    public void configureBootstraps(NettyRequestSender requestSender, AtomicBoolean closed) {
+
+        Protocol httpProtocol = new HttpProtocol(this, config, nettyConfig, requestSender);
+        final Processor httpProcessor = new Processor(config, this, requestSender, httpProtocol);
+
+        Protocol wsProtocol = new WebSocketProtocol(this, config, nettyConfig, requestSender);
+        wsProcessor = new Processor(config, this, requestSender, wsProtocol);
+
+        httpBootstrap.setPipelineFactory(new ChannelPipelineFactory() {
+
+            public ChannelPipeline getPipeline() throws Exception {
+                ChannelPipeline pipeline = pipeline();
+                pipeline.addLast(HTTP_HANDLER, newHttpClientCodec());
+                pipeline.addLast(INFLATER_HANDLER, newHttpContentDecompressor());
+                pipeline.addLast(CHUNKED_WRITER_HANDLER, new ChunkedWriteHandler());
+                pipeline.addLast(HTTP_PROCESSOR, httpProcessor);
+
+                if (nettyConfig.getHttpAdditionalPipelineInitializer() != null)
+                    nettyConfig.getHttpAdditionalPipelineInitializer().initPipeline(pipeline);
+
+                return pipeline;
+            }
+        });
+
+        wsBootstrap.setPipelineFactory(new ChannelPipelineFactory() {
+
+            public ChannelPipeline getPipeline() throws Exception {
+                ChannelPipeline pipeline = pipeline();
+                pipeline.addLast(HTTP_HANDLER, newHttpClientCodec());
+                pipeline.addLast(WS_PROCESSOR, wsProcessor);
+
+                if (nettyConfig.getWsAdditionalPipelineInitializer() != null)
+                    nettyConfig.getWsAdditionalPipelineInitializer().initPipeline(pipeline);
+
+                return pipeline;
+            }
+        });
+    }
+
+    private HttpContentDecompressor newHttpContentDecompressor() {
+        if (config.isKeepEncodingHeader())
+            return new HttpContentDecompressor() {
+                @Override
+                protected String getTargetContentEncoding(String contentEncoding) throws Exception {
+                    return contentEncoding;
+                }
+            };
+        else
+            return new HttpContentDecompressor();
+    }
+
+    public final void tryToOfferChannelToPool(Channel channel, AsyncHandler<?> handler, boolean keepAlive, Object partitionKey) {
+        if (channel.isConnected() && keepAlive && channel.isReadable()) {
+            LOGGER.debug("Adding key: {} for channel {}", partitionKey, channel);
+            Channels.setDiscard(channel);
+            if (handler instanceof AsyncHandlerExtensions) {
+                AsyncHandlerExtensions.class.cast(handler).onConnectionOffer(channel);
+            }
+            channelPool.offer(channel, partitionKey);
+            if (maxConnectionsPerHostEnabled)
+                channelId2PartitionKey.putIfAbsent(channel.getId(), partitionKey);
+        } else {
+            // not offered
+            closeChannel(channel);
+        }
+    }
+
+    public Channel poll(Uri uri, String virtualHost, ProxyServer proxy, ConnectionPoolPartitioning connectionPoolPartitioning) {
+        Object partitionKey = connectionPoolPartitioning.getPartitionKey(uri, virtualHost, proxy);
+        return channelPool.poll(partitionKey);
+    }
+
+    public boolean removeAll(Channel connection) {
+        return channelPool.removeAll(connection);
+    }
+
+    private boolean tryAcquireGlobal() {
+        return !maxTotalConnectionsEnabled || freeChannels.tryAcquire();
+    }
+
+    private Semaphore getFreeConnectionsForHost(Object partitionKey) {
+        return freeChannelsPerHost.computeIfAbsent(partitionKey, semaphoreComputer);
+    }
+
+    private boolean tryAcquirePerHost(Object partitionKey) {
+        return !maxConnectionsPerHostEnabled || getFreeConnectionsForHost(partitionKey).tryAcquire();
+    }
+
+    public void preemptChannel(Object partitionKey) throws IOException {
+        if (!channelPool.isOpen())
+            throw poolAlreadyClosed;
+        if (!tryAcquireGlobal())
+            throw tooManyConnections;
+        if (!tryAcquirePerHost(partitionKey)) {
+            if (maxTotalConnectionsEnabled)
+                freeChannels.release();
+
+            throw tooManyConnectionsPerHost;
+        }
+    }
+
+    public void close() {
+        channelPool.destroy();
+        openChannels.close();
+
+        for (Channel channel : openChannels) {
+            Object attribute = Channels.getAttribute(channel);
+            if (attribute instanceof NettyResponseFuture<?>) {
+                NettyResponseFuture<?> future = (NettyResponseFuture<?>) attribute;
+                future.cancelTimeouts();
+            }
+        }
+
+        // FIXME also shutdown in provider
+        config.getExecutorService().shutdown();
+        if (allowReleaseSocketChannelFactory) {
+            socketChannelFactory.releaseExternalResources();
+            httpBootstrap.releaseExternalResources();
+            wsBootstrap.releaseExternalResources();
+        }
+    }
+
+    public void closeChannel(Channel channel) {
+
+        // The channel may have already been removed from the future if a
+        // timeout occurred, and this method may be called just after.
+        LOGGER.debug("Closing Channel {} ", channel);
+        try {
+            removeAll(channel);
+            Channels.setDiscard(channel);
+            Channels.silentlyCloseChannel(channel);
+        } catch (Throwable t) {
+            LOGGER.debug("Error closing a connection", t);
+        }
+        openChannels.remove(channel);
+    }
+
+    public void abortChannelPreemption(Object partitionKey) {
+        if (maxTotalConnectionsEnabled)
+            freeChannels.release();
+        if (maxConnectionsPerHostEnabled)
+            getFreeConnectionsForHost(partitionKey).release();
+    }
+
+    public void registerOpenChannel(Channel channel, Object partitionKey) {
+        openChannels.add(channel);
+        if (maxConnectionsPerHostEnabled) {
+            channelId2PartitionKey.put(channel.getId(), partitionKey);
+        }
+    }
+
+    private HttpClientCodec newHttpClientCodec() {
+        return new HttpClientCodec(//
+                config.getHttpClientCodecMaxInitialLineLength(),//
+                config.getHttpClientCodecMaxHeaderSize(),//
+                config.getHttpClientCodecMaxChunkSize());
+    }
+
+    private SslHandler createSslHandler(String peerHost, int peerPort) throws GeneralSecurityException {
+        SSLEngine sslEngine = sslEngineFactory.newSSLEngine(peerHost, peerPort);
+        SslHandler sslHandler = handshakeTimeout > 0 ? new SslHandler(sslEngine, getDefaultBufferPool(), false, nettyTimer, handshakeTimeout) : new SslHandler(sslEngine);
+        sslHandler.setCloseOnSSLException(true);
+        return sslHandler;
+    }
+
+    public static boolean isSslHandlerConfigured(ChannelPipeline pipeline) {
+        return pipeline.get(SSL_HANDLER) != null;
+    }
+
+    public void upgradeProtocol(ChannelPipeline pipeline, String scheme, String host, int port) throws GeneralSecurityException {
+        if (pipeline.get(HTTP_HANDLER) != null)
+            pipeline.remove(HTTP_HANDLER);
+
+        if (isSecure(scheme))
+            if (isSslHandlerConfigured(pipeline)) {
+                pipeline.addAfter(SSL_HANDLER, HTTP_HANDLER, newHttpClientCodec());
+            } else {
+                pipeline.addFirst(HTTP_HANDLER, newHttpClientCodec());
+                pipeline.addFirst(SSL_HANDLER, createSslHandler(host, port));
+            }
+        else
+            pipeline.addFirst(HTTP_HANDLER, newHttpClientCodec());
+
+        if (isWebSocket(scheme)) {
+            pipeline.addAfter(HTTP_PROCESSOR, WS_PROCESSOR, wsProcessor);
+            pipeline.remove(HTTP_PROCESSOR);
+        }
+    }
+
+    public SslHandler addSslHandler(ChannelPipeline pipeline, Uri uri, String virtualHost) throws GeneralSecurityException {
+        String peerHost;
+        int peerPort;
+        
+        if (virtualHost != null) {
+            int i = virtualHost.indexOf(':');
+            if (i == -1) {
+                peerHost = virtualHost;
+                peerPort = getSchemeDefaultPort(uri.getScheme());
+            } else {
+                peerHost = virtualHost.substring(0, i);
+                peerPort = Integer.valueOf(virtualHost.substring(i + 1));
+            }
+            
+        } else {
+            peerHost = uri.getHost();
+            peerPort = getExplicitPort(uri);
+        }
+
+        SslHandler sslHandler = createSslHandler(peerHost, peerPort);
+        pipeline.addFirst(SSL_HANDLER, sslHandler);
+        return sslHandler;
+    }
+
+    public void verifyChannelPipeline(ChannelPipeline pipeline, Uri uri, String virtualHost) throws GeneralSecurityException {
+
+        boolean sslHandlerConfigured = isSslHandlerConfigured(pipeline);
+
+        if (isSecure(uri.getScheme())) {
+            if (!sslHandlerConfigured) {
+                addSslHandler(pipeline, uri, virtualHost);
+            }
+
+        } else if (sslHandlerConfigured)
+            pipeline.remove(SSL_HANDLER);
+    }
+
+    public ClientBootstrap getBootstrap(String scheme, boolean useProxy) {
+        return scheme.startsWith(WS) && !useProxy ? wsBootstrap : httpBootstrap;
+    }
+
+    public void upgradePipelineForWebSockets(ChannelPipeline pipeline) {
+        pipeline.addAfter(HTTP_HANDLER, WS_ENCODER_HANDLER, new WebSocket08FrameEncoder(true));
+        pipeline.remove(HTTP_HANDLER);
+        pipeline.addBefore(WS_PROCESSOR, WS_DECODER_HANDLER, new WebSocket08FrameDecoder(false, false, config.getWebSocketMaxFrameSize()));
+        pipeline.addAfter(WS_DECODER_HANDLER, WS_FRAME_AGGREGATOR, new WebSocketFrameAggregator(config.getWebSocketMaxBufferSize()));
+    }
+
+    public final Callback newDrainCallback(final NettyResponseFuture<?> future, final Channel channel, final boolean keepAlive, final Object partitionKey) {
+
+        return new Callback(future) {
+            @Override
+            public void call() {
+                tryToOfferChannelToPool(channel, future.getAsyncHandler(), keepAlive, partitionKey);
+            }
+        };
+    }
+
+    public void drainChannelAndOffer(final Channel channel, final NettyResponseFuture<?> future) {
+        drainChannelAndOffer(channel, future, future.isKeepAlive(), future.getPartitionKey());
+    }
+
+    public void drainChannelAndOffer(final Channel channel, final NettyResponseFuture<?> future, boolean keepAlive, Object partitionKey) {
+        Channels.setAttribute(channel, newDrainCallback(future, channel, keepAlive, partitionKey));
+    }
+
+    public void flushPartition(Object partitionKey) {
+        channelPool.flushPartition(partitionKey);
+    }
+
+    public void flushPartitions(ChannelPoolPartitionSelector selector) {
+        channelPool.flushPartitions(selector);
+    }
+}
diff --git a/providers/netty3/src/main/java/org/asynchttpclient/netty/channel/Channels.java b/providers/netty3/src/main/java/org/asynchttpclient/netty/channel/Channels.java
new file mode 100644
index 000000000..28cb05b6d
--- /dev/null
+++ b/providers/netty3/src/main/java/org/asynchttpclient/netty/channel/Channels.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.channel;
+
+import org.asynchttpclient.netty.DiscardEvent;
+import org.jboss.netty.channel.Channel;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public final class Channels {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(Channels.class);
+
+    private Channels() {
+    }
+
+    public static void setAttribute(Channel channel, Object attribute) {
+        channel.setAttachment(attribute);
+    }
+
+    public static Object getAttribute(Channel channel) {
+        return channel.getAttachment();
+    }
+
+    public static void setDiscard(Channel channel) {
+        setAttribute(channel, DiscardEvent.INSTANCE);
+    }
+
+    public static boolean isChannelValid(Channel channel) {
+        return channel != null && channel.isConnected();
+    }
+
+    public static void silentlyCloseChannel(Channel channel) {
+        try {
+            if (channel != null && channel.isOpen())
+                channel.close();
+        } catch (Throwable t) {
+            LOGGER.debug("Failed to close channel", t);
+        }
+    }
+}
diff --git a/providers/netty3/src/main/java/org/asynchttpclient/netty/channel/CleanupChannelGroup.java b/providers/netty3/src/main/java/org/asynchttpclient/netty/channel/CleanupChannelGroup.java
new file mode 100644
index 000000000..66a83e9dd
--- /dev/null
+++ b/providers/netty3/src/main/java/org/asynchttpclient/netty/channel/CleanupChannelGroup.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.channel;
+
+import org.jboss.netty.channel.Channel;
+import org.jboss.netty.channel.ChannelFuture;
+import org.jboss.netty.channel.group.ChannelGroup;
+import org.jboss.netty.channel.group.ChannelGroupFuture;
+import org.jboss.netty.channel.group.DefaultChannelGroup;
+import org.jboss.netty.channel.group.DefaultChannelGroupFuture;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+/**
+ * Extension of {@link DefaultChannelGroup} that's used mainly as a cleanup container, where {@link #close()} is only
+ * supposed to be called once.
+ *
+ * @author <a href="http://bruno.biasedbit.com/">Bruno de Carvalho</a>
+ */
+public class CleanupChannelGroup extends DefaultChannelGroup {
+
+    private final static Logger logger = LoggerFactory.getLogger(CleanupChannelGroup.class);
+
+    // internal vars --------------------------------------------------------------------------------------------------
+
+    private final AtomicBoolean closed;
+    private final ReentrantReadWriteLock lock;
+
+    // constructors ---------------------------------------------------------------------------------------------------
+
+    public CleanupChannelGroup() {
+        this.closed = new AtomicBoolean(false);
+        this.lock = new ReentrantReadWriteLock();
+    }
+
+    public CleanupChannelGroup(String name) {
+        super(name);
+        this.closed = new AtomicBoolean(false);
+        this.lock = new ReentrantReadWriteLock();
+    }
+
+    // DefaultChannelGroup --------------------------------------------------------------------------------------------
+
+    @Override
+    public ChannelGroupFuture close() {
+        this.lock.writeLock().lock();
+        try {
+            if (!this.closed.getAndSet(true)) {
+                // First time close() is called.
+                return super.close();
+            } else {
+                Collection<ChannelFuture> futures = new ArrayList<>();
+                logger.debug("CleanupChannelGroup Already closed");
+                return new DefaultChannelGroupFuture(ChannelGroup.class.cast(this), futures);
+            }
+        } finally {
+            this.lock.writeLock().unlock();
+        }
+    }
+
+    @Override
+    public boolean add(Channel channel) {
+        // Synchronization must occur to avoid add() and close() overlap (thus potentially leaving one channel open).
+        // This could also be done by synchronizing the method itself but using a read lock here (rather than a
+        // synchronized() block) allows multiple concurrent calls to add().
+        this.lock.readLock().lock();
+        try {
+            if (this.closed.get()) {
+                // Immediately close channel, as close() was already called.
+                Channels.silentlyCloseChannel(channel);
+                return false;
+            }
+
+            return super.add(channel);
+        } finally {
+            this.lock.readLock().unlock();
+        }
+    }
+}
diff --git a/providers/netty3/src/main/java/org/asynchttpclient/netty/channel/NettyConnectListener.java b/providers/netty3/src/main/java/org/asynchttpclient/netty/channel/NettyConnectListener.java
new file mode 100644
index 000000000..cf313fe9c
--- /dev/null
+++ b/providers/netty3/src/main/java/org/asynchttpclient/netty/channel/NettyConnectListener.java
@@ -0,0 +1,150 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.channel;
+
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.getBaseUrl;
+import static org.asynchttpclient.util.HttpUtils.isSecure;
+
+import java.net.ConnectException;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.handler.AsyncHandlerExtensions;
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.future.StackTraceInspector;
+import org.asynchttpclient.netty.request.NettyRequestSender;
+import org.asynchttpclient.uri.Uri;
+import org.jboss.netty.channel.Channel;
+import org.jboss.netty.channel.ChannelFuture;
+import org.jboss.netty.channel.ChannelFutureListener;
+import org.jboss.netty.handler.ssl.SslHandler;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Non Blocking connect.
+ */
+public final class NettyConnectListener<T> implements ChannelFutureListener {
+    private static final Logger LOGGER = LoggerFactory.getLogger(NettyConnectListener.class);
+    private final NettyResponseFuture<T> future;
+    private final NettyRequestSender requestSender;
+    private final ChannelManager channelManager;
+    private final boolean channelPreempted;
+    private final Object partitionKey;
+
+    public NettyConnectListener(NettyResponseFuture<T> future,//
+            NettyRequestSender requestSender,//
+            ChannelManager channelManager,//
+            boolean channelPreempted,//
+            Object partitionKey) {
+        this.future = future;
+        this.requestSender = requestSender;
+        this.channelManager = channelManager;
+        this.channelPreempted = channelPreempted;
+        this.partitionKey = partitionKey;
+    }
+
+    public NettyResponseFuture<T> future() {
+        return future;
+    }
+
+    private void abortChannelPreemption() {
+        if (channelPreempted)
+            channelManager.abortChannelPreemption(partitionKey);
+    }
+
+    private void writeRequest(Channel channel) {
+
+        LOGGER.debug("Using non-cached Channel {} for {} '{}'",
+                channel,
+                future.getNettyRequest().getHttpRequest().getMethod(),
+                future.getNettyRequest().getHttpRequest().getUri());
+
+        Channels.setAttribute(channel, future);
+        
+        if (future.isDone()) {
+            abortChannelPreemption();
+            return;
+        }
+
+        future.attachChannel(channel, false);
+
+        if (future.getAsyncHandler() instanceof AsyncHandlerExtensions)
+            AsyncHandlerExtensions.class.cast(future.getAsyncHandler()).onConnectionOpened(channel);
+
+        channelManager.registerOpenChannel(channel, partitionKey);
+        requestSender.writeRequest(future, channel);
+    }
+
+    private void onFutureSuccess(final Channel channel) throws Exception {
+
+        Request request = future.getRequest();
+        Uri uri = request.getUri();
+
+        // in case of proxy tunneling, we'll add the SslHandler later, after the CONNECT request
+        if (future.getProxyServer() == null && isSecure(uri)) {
+            SslHandler sslHandler = channelManager.addSslHandler(channel.getPipeline(), uri, request.getVirtualHost());
+            sslHandler.handshake().addListener(new ChannelFutureListener() {
+                
+                @Override
+                public void operationComplete(ChannelFuture handshakeFuture) throws Exception {
+                    if (handshakeFuture.isSuccess()) {
+                        final AsyncHandler<T> asyncHandler = future.getAsyncHandler();
+                        if (asyncHandler instanceof AsyncHandlerExtensions)
+                            AsyncHandlerExtensions.class.cast(asyncHandler).onSslHandshakeCompleted();
+
+                        writeRequest(channel);
+                    } else {
+                        onFutureFailure(channel, handshakeFuture.getCause());
+                    }
+                }
+            });
+        
+        } else {
+            writeRequest(channel);
+        }
+    }
+
+    private void onFutureFailure(Channel channel, Throwable cause) {
+        abortChannelPreemption();
+
+        boolean canRetry = future.canRetry();
+        LOGGER.debug("Trying to recover from failing to connect channel {} with a retry value of {} ", channel, canRetry);
+        if (canRetry
+                && cause != null
+                && (future.getState() != NettyResponseFuture.STATE.NEW || StackTraceInspector.recoverOnNettyDisconnectException(cause))) {
+
+            if (requestSender.retry(future))
+                return;
+        }
+
+        LOGGER.debug("Failed to recover from connect exception: {} with channel {}", cause, channel);
+
+        boolean printCause = cause != null && cause.getMessage() != null;
+        String printedCause = printCause ? cause.getMessage() : getBaseUrl(future.getUri());
+        ConnectException e = new ConnectException(printedCause);
+        if (cause != null) {
+            e.initCause(cause);
+        }
+        future.abort(e);
+    }
+
+    public final void operationComplete(ChannelFuture f) throws Exception {
+        Channel channel = f.getChannel();
+        if (f.isSuccess())
+            onFutureSuccess(channel);
+        else
+            onFutureFailure(channel, f.getCause());
+    }
+}
diff --git a/providers/netty3/src/main/java/org/asynchttpclient/netty/channel/pool/ChannelPool.java b/providers/netty3/src/main/java/org/asynchttpclient/netty/channel/pool/ChannelPool.java
new file mode 100644
index 000000000..ef423102a
--- /dev/null
+++ b/providers/netty3/src/main/java/org/asynchttpclient/netty/channel/pool/ChannelPool.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.channel.pool;
+
+import org.asynchttpclient.AsyncHttpProvider;
+import org.asynchttpclient.netty.channel.pool.ChannelPoolPartitionSelector;
+import org.jboss.netty.channel.Channel;
+
+/**
+ * An interface used by an {@link AsyncHttpProvider} for caching http connections.
+ */
+public interface ChannelPool {
+
+    /**
+     * Add a connection to the pool
+     *
+     * @param partitionKey        a key used to retrieve the cached connection
+     * @param connection an I/O connection
+     * @return true if added.
+     */
+    boolean offer(Channel connection, Object partitionKey);
+
+    /**
+     * Get a connection from a partition
+     *
+     * @param partitionKey the id of the partition used when invoking offer
+     * @return the connection associated with the partitionId
+     */
+    Channel poll(Object partitionKey);
+
+    /**
+     * Remove all connections from the cache. A connection might have been associated with several uri.
+     *
+     * @param connection a connection
+     * @return the true if the connection has been removed
+     */
+    boolean removeAll(Channel connection);
+
+    /**
+     * Return true if a connection can be cached. A implementation can decide based on some rules to allow caching
+     * Calling this method is equivalent of checking the returned value of {@link ChannelPool#offer(Object, Object)}
+     *
+     * @return true if a connection can be cached.
+     */
+    boolean isOpen();
+
+    /**
+     * Destroy all connections that has been cached by this instance.
+     */
+    void destroy();
+
+    /**
+     * Flush a partition
+     * 
+     * @param partitionKey
+     */
+    void flushPartition(Object partitionKey);
+
+    /**
+     * Flush partitions based on a selector
+     * 
+     * @param selector
+     */
+    void flushPartitions(ChannelPoolPartitionSelector selector);
+}
diff --git a/providers/netty3/src/main/java/org/asynchttpclient/netty/channel/pool/DefaultChannelPool.java b/providers/netty3/src/main/java/org/asynchttpclient/netty/channel/pool/DefaultChannelPool.java
new file mode 100644
index 000000000..699535c71
--- /dev/null
+++ b/providers/netty3/src/main/java/org/asynchttpclient/netty/channel/pool/DefaultChannelPool.java
@@ -0,0 +1,329 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.channel.pool;
+
+import static org.asynchttpclient.util.DateUtils.millisTime;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.internal.chmv8.ConcurrentHashMapV8;
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.channel.Channels;
+import org.asynchttpclient.netty.channel.pool.ChannelPoolPartitionSelector;
+import org.jboss.netty.channel.Channel;
+import org.jboss.netty.handler.ssl.SslHandler;
+import org.jboss.netty.util.Timeout;
+import org.jboss.netty.util.Timer;
+import org.jboss.netty.util.TimerTask;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * A simple implementation of {@link com.ning.http.client.providers.netty.channel.pool.ChannelPool} based on a {@link java.util.concurrent.ConcurrentHashMap}
+ */
+public final class DefaultChannelPool implements ChannelPool {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(DefaultChannelPool.class);
+
+    private static final ConcurrentHashMapV8.Fun<Object, ConcurrentLinkedQueue<IdleChannel>> PARTITION_COMPUTER = new ConcurrentHashMapV8.Fun<Object, ConcurrentLinkedQueue<IdleChannel>>() {
+        @Override
+        public ConcurrentLinkedQueue<IdleChannel> apply(Object partitionKey) {
+            return new ConcurrentLinkedQueue<>();
+        }
+    };
+
+    private final ConcurrentHashMapV8<Object, ConcurrentLinkedQueue<IdleChannel>> partitions = new ConcurrentHashMapV8<>();
+    private final ConcurrentHashMapV8<Integer, ChannelCreation> channelId2Creation = new ConcurrentHashMapV8<>();
+    private final AtomicBoolean isClosed = new AtomicBoolean(false);
+    private final Timer nettyTimer;
+    private final boolean sslConnectionPoolEnabled;
+    private final int maxConnectionTTL;
+    private final boolean maxConnectionTTLDisabled;
+    private final long maxIdleTime;
+    private final boolean maxIdleTimeDisabled;
+    private final long cleanerPeriod;
+
+    public DefaultChannelPool(AsyncHttpClientConfig config, Timer hashedWheelTimer) {
+        this(config.getPooledConnectionIdleTimeout(),//
+                config.getConnectionTTL(),//
+                config.isAllowPoolingSslConnections(),//
+                hashedWheelTimer);
+    }
+
+    public DefaultChannelPool(//
+            long maxIdleTime,//
+            int maxConnectionTTL,//
+            boolean sslConnectionPoolEnabled,//
+            Timer nettyTimer) {
+        this.sslConnectionPoolEnabled = sslConnectionPoolEnabled;
+        this.maxIdleTime = maxIdleTime;
+        this.maxConnectionTTL = maxConnectionTTL;
+        maxConnectionTTLDisabled = maxConnectionTTL <= 0;
+        this.nettyTimer = nettyTimer;
+        maxIdleTimeDisabled = maxIdleTime <= 0;
+
+        cleanerPeriod = Math.min(maxConnectionTTLDisabled ? Long.MAX_VALUE : maxConnectionTTL, maxIdleTimeDisabled ? Long.MAX_VALUE
+                : maxIdleTime);
+
+        if (!maxConnectionTTLDisabled || !maxIdleTimeDisabled)
+            scheduleNewIdleChannelDetector(new IdleChannelDetector());
+    }
+
+    private void scheduleNewIdleChannelDetector(TimerTask task) {
+        nettyTimer.newTimeout(task, cleanerPeriod, TimeUnit.MILLISECONDS);
+    }
+
+    private static final class ChannelCreation {
+        final long creationTime;
+        final Object partitionKey;
+
+        ChannelCreation(long creationTime, Object partitionKey) {
+            this.creationTime = creationTime;
+            this.partitionKey = partitionKey;
+        }
+    }
+
+    private static final class IdleChannel {
+        final Channel channel;
+        final long start;
+
+        IdleChannel(Channel channel, long start) {
+            if (channel == null)
+                throw new NullPointerException("channel");
+            this.channel = channel;
+            this.start = start;
+        }
+
+        @Override
+        // only depends on channel
+        public boolean equals(Object o) {
+            return this == o || (o instanceof IdleChannel && channel.equals(IdleChannel.class.cast(o).channel));
+        }
+
+        @Override
+        public int hashCode() {
+            return channel.hashCode();
+        }
+    }
+
+    private boolean isTTLExpired(Channel channel, long now) {
+        if (maxConnectionTTLDisabled)
+            return false;
+
+        ChannelCreation creation = channelId2Creation.get(channel.getId());
+        return creation != null && now - creation.creationTime >= maxConnectionTTL;
+    }
+
+    private final class IdleChannelDetector implements TimerTask {
+
+        private boolean isIdleTimeoutExpired(IdleChannel idleChannel, long now) {
+            return !maxIdleTimeDisabled && now - idleChannel.start >= maxIdleTime;
+        }
+
+        private List<IdleChannel> expiredChannels(ConcurrentLinkedQueue<IdleChannel> partition, long now) {
+            // lazy create
+            List<IdleChannel> idleTimeoutChannels = null;
+            for (IdleChannel idleChannel : partition) {
+                if (isTTLExpired(idleChannel.channel, now) || isIdleTimeoutExpired(idleChannel, now)
+                        || !Channels.isChannelValid(idleChannel.channel)) {
+                    LOGGER.debug("Adding Candidate expired Channel {}", idleChannel.channel);
+                    if (idleTimeoutChannels == null)
+                        idleTimeoutChannels = new ArrayList<>();
+                    idleTimeoutChannels.add(idleChannel);
+                }
+            }
+
+            return idleTimeoutChannels != null ? idleTimeoutChannels : Collections.<IdleChannel> emptyList();
+        }
+
+        private boolean isChannelCloseable(Channel channel) {
+            Object attribute = Channels.getAttribute(channel);
+            if (attribute instanceof NettyResponseFuture) {
+                NettyResponseFuture<?> future = (NettyResponseFuture<?>) attribute;
+                if (!future.isDone()) {
+                    LOGGER.error("Future not in appropriate state %s, not closing", future);
+                    return false;
+                }
+            }
+            return true;
+        }
+
+        private final List<IdleChannel> closeChannels(List<IdleChannel> candidates) {
+
+            // lazy create, only if we have a non-closeable channel
+            List<IdleChannel> closedChannels = null;
+            for (int i = 0; i < candidates.size(); i++) {
+                IdleChannel idleChannel = candidates.get(i);
+                if (isChannelCloseable(idleChannel.channel)) {
+                    LOGGER.debug("Closing Idle Channel {}", idleChannel.channel);
+                    close(idleChannel.channel);
+                    if (closedChannels != null) {
+                        closedChannels.add(idleChannel);
+                    }
+
+                } else if (closedChannels == null) {
+                    // first non closeable to be skipped, copy all previously skipped closeable channels
+                    closedChannels = new ArrayList<>(candidates.size());
+                    for (int j = 0; j < i; j++)
+                        closedChannels.add(candidates.get(j));
+                }
+            }
+
+            return closedChannels != null ? closedChannels : candidates;
+        }
+
+        public void run(Timeout timeout) throws Exception {
+
+            if (isClosed.get())
+                return;
+
+            try {
+                if (LOGGER.isDebugEnabled()) {
+                    for (Object key : partitions.keySet()) {
+                        LOGGER.debug("Entry count for : {} : {}", key, partitions.get(key).size());
+                    }
+                }
+
+
+                long start = millisTime();
+                int closedCount = 0;
+                int totalCount = 0;
+
+                for (ConcurrentLinkedQueue<IdleChannel> partition : partitions.values()) {
+
+                    // store in intermediate unsynchronized lists to minimize the impact on the ConcurrentLinkedQueue
+                    if (LOGGER.isDebugEnabled())
+                        totalCount += partition.size();
+
+                    List<IdleChannel> closedChannels = closeChannels(expiredChannels(partition, start));
+
+                    if (!closedChannels.isEmpty()) {
+                        for (IdleChannel closedChannel : closedChannels)
+                            channelId2Creation.remove(closedChannel.channel.getId());
+
+                        partition.removeAll(closedChannels);
+                        closedCount += closedChannels.size();
+                    }
+                }
+
+                long duration = millisTime() - start;
+
+                LOGGER.debug("Closed {} connections out of {} in {}ms", closedCount, totalCount, duration);
+
+            } catch (Throwable t) {
+                LOGGER.error("uncaught exception!", t);
+            }
+
+            scheduleNewIdleChannelDetector(timeout.getTask());
+        }
+    }
+
+    public boolean offer(Channel channel, Object partitionKey) {
+        if (isClosed.get() || (!sslConnectionPoolEnabled && channel.getPipeline().get(SslHandler.class) != null))
+            return false;
+
+        long now = millisTime();
+
+        if (isTTLExpired(channel, now))
+            return false;
+
+        boolean added = partitions.computeIfAbsent(partitionKey, PARTITION_COMPUTER).add(new IdleChannel(channel, now));
+        if (added)
+            channelId2Creation.putIfAbsent(channel.getId(), new ChannelCreation(now, partitionKey));
+
+        return added;
+    }
+
+    public Channel poll(Object partitionKey) {
+
+        IdleChannel idleChannel = null;
+        ConcurrentLinkedQueue<IdleChannel> partition = partitions.get(partitionKey);
+        if (partition != null) {
+            while (idleChannel == null) {
+                idleChannel = partition.poll();
+
+                if (idleChannel == null)
+                    // pool is empty
+                    break;
+                else if (!Channels.isChannelValid(idleChannel.channel)) {
+                    idleChannel = null;
+                    LOGGER.trace("Channel not connected or not opened, probably remotely closed!");
+                }
+            }
+        }
+        return idleChannel != null ? idleChannel.channel : null;
+    }
+
+    @Override
+    public boolean removeAll(Channel channel) {
+        ChannelCreation creation = channelId2Creation.remove(channel.getId());
+        return !isClosed.get() && creation != null && partitions.get(creation.partitionKey).remove(channel);
+    }
+
+    @Override
+    public boolean isOpen() {
+        return !isClosed.get();
+    }
+
+    @Override
+    public void destroy() {
+        if (isClosed.getAndSet(true))
+            return;
+
+        for (ConcurrentLinkedQueue<IdleChannel> partition : partitions.values()) {
+            for (IdleChannel idleChannel : partition)
+                close(idleChannel.channel);
+        }
+
+        partitions.clear();
+        channelId2Creation.clear();
+    }
+
+    private void close(Channel channel) {
+        // FIXME pity to have to do this here
+        Channels.setDiscard(channel);
+        channelId2Creation.remove(channel.getId());
+        Channels.silentlyCloseChannel(channel);
+    }
+
+    private void flushPartition(Object partitionKey, ConcurrentLinkedQueue<IdleChannel> partition) {
+        if (partition != null) {
+            partitions.remove(partitionKey);
+            for (IdleChannel idleChannel : partition)
+                close(idleChannel.channel);
+        }
+    }
+    
+    @Override
+    public void flushPartition(Object partitionKey) {
+        flushPartition(partitionKey, partitions.get(partitionKey));
+    }
+    
+    @Override
+    public void flushPartitions(ChannelPoolPartitionSelector selector) {
+
+        for (Map.Entry<Object, ConcurrentLinkedQueue<IdleChannel>> partitionsEntry : partitions.entrySet()) {
+            Object partitionKey = partitionsEntry.getKey();
+            if (selector.select(partitionKey))
+                flushPartition(partitionKey, partitionsEntry.getValue());
+        }
+    }
+}
diff --git a/providers/netty3/src/main/java/org/asynchttpclient/netty/channel/pool/NoopChannelPool.java b/providers/netty3/src/main/java/org/asynchttpclient/netty/channel/pool/NoopChannelPool.java
new file mode 100644
index 000000000..30a2d823e
--- /dev/null
+++ b/providers/netty3/src/main/java/org/asynchttpclient/netty/channel/pool/NoopChannelPool.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.channel.pool;
+
+import org.asynchttpclient.netty.channel.pool.ChannelPoolPartitionSelector;
+import org.jboss.netty.channel.Channel;
+
+public class NoopChannelPool implements ChannelPool {
+
+    @Override
+    public boolean offer(Channel connection, Object partitionKey) {
+        return false;
+    }
+
+    @Override
+    public Channel poll(Object partitionKey) {
+        return null;
+    }
+
+    @Override
+    public boolean removeAll(Channel connection) {
+        return false;
+    }
+
+    @Override
+    public boolean isOpen() {
+        return true;
+    }
+
+    @Override
+    public void destroy() {
+    }
+
+    @Override
+    public void flushPartition(Object partitionKey) {
+    }
+
+    @Override
+    public void flushPartitions(ChannelPoolPartitionSelector selector) {
+    }
+}
diff --git a/providers/netty3/src/main/java/org/asynchttpclient/netty/handler/DefaultConnectionStrategy.java b/providers/netty3/src/main/java/org/asynchttpclient/netty/handler/DefaultConnectionStrategy.java
new file mode 100644
index 000000000..c9d8a6ca1
--- /dev/null
+++ b/providers/netty3/src/main/java/org/asynchttpclient/netty/handler/DefaultConnectionStrategy.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.handler;
+
+import static org.jboss.netty.handler.codec.http.HttpHeaders.Names.CONNECTION;
+import static org.jboss.netty.handler.codec.http.HttpHeaders.Values.CLOSE;
+import static org.jboss.netty.handler.codec.http.HttpHeaders.Values.KEEP_ALIVE;
+
+import org.asynchttpclient.channel.pool.ConnectionStrategy;
+import org.jboss.netty.handler.codec.http.HttpMessage;
+import org.jboss.netty.handler.codec.http.HttpRequest;
+import org.jboss.netty.handler.codec.http.HttpResponse;
+import org.jboss.netty.handler.codec.http.HttpVersion;
+
+/**
+ * Connection strategy implementing standard HTTP 1.0/1.1 behaviour.
+ */
+public class DefaultConnectionStrategy implements ConnectionStrategy<HttpRequest, HttpResponse> {
+
+    /**
+     * Implemented in accordance with RFC 7230 section 6.1
+     * https://tools.ietf.org/html/rfc7230#section-6.1
+     */
+    @Override
+    public boolean keepAlive(HttpRequest request, HttpResponse response) {
+        
+        String responseConnectionHeader = connectionHeader(response);
+        
+        
+        if (CLOSE.equalsIgnoreCase(responseConnectionHeader)) {
+            return false;
+        } else {
+            String requestConnectionHeader = connectionHeader(request);
+            
+            if (request.getProtocolVersion() == HttpVersion.HTTP_1_0) {
+                // only use keep-alive if both parties agreed upon it
+                return KEEP_ALIVE.equalsIgnoreCase(requestConnectionHeader) && KEEP_ALIVE.equalsIgnoreCase(responseConnectionHeader);
+                
+            } else {
+                // 1.1+, keep-alive is default behavior
+                return !CLOSE.equalsIgnoreCase(requestConnectionHeader);
+            }
+        }
+    }
+
+    private String connectionHeader(HttpMessage message) {
+        return message.headers().get(CONNECTION);
+    }
+}
diff --git a/providers/netty3/src/main/java/org/asynchttpclient/netty/handler/HttpProtocol.java b/providers/netty3/src/main/java/org/asynchttpclient/netty/handler/HttpProtocol.java
new file mode 100644
index 000000000..0a561c875
--- /dev/null
+++ b/providers/netty3/src/main/java/org/asynchttpclient/netty/handler/HttpProtocol.java
@@ -0,0 +1,507 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.handler;
+
+import static org.asynchttpclient.ntlm.NtlmUtils.getNTLM;
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.getExplicitPort;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+import static org.jboss.netty.handler.codec.http.HttpResponseStatus.CONTINUE;
+import static org.jboss.netty.handler.codec.http.HttpResponseStatus.OK;
+import static org.jboss.netty.handler.codec.http.HttpResponseStatus.PROXY_AUTHENTICATION_REQUIRED;
+import static org.jboss.netty.handler.codec.http.HttpResponseStatus.UNAUTHORIZED;
+
+import java.io.IOException;
+import java.security.GeneralSecurityException;
+import java.util.List;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHandler.State;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
+import org.asynchttpclient.Realm;
+import org.asynchttpclient.Realm.AuthScheme;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.channel.pool.ConnectionStrategy;
+import org.asynchttpclient.netty.NettyAsyncHttpProviderConfig;
+import org.asynchttpclient.netty.NettyResponseBodyPart;
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.NettyResponseHeaders;
+import org.asynchttpclient.netty.NettyResponseStatus;
+import org.asynchttpclient.netty.channel.ChannelManager;
+import org.asynchttpclient.netty.request.NettyRequestSender;
+import org.asynchttpclient.ntlm.NtlmEngine;
+import org.asynchttpclient.proxy.ProxyServer;
+import org.asynchttpclient.spnego.SpnegoEngine;
+import org.asynchttpclient.spnego.SpnegoEngineException;
+import org.asynchttpclient.uri.Uri;
+import org.jboss.netty.channel.Channel;
+import org.jboss.netty.handler.codec.http.HttpChunk;
+import org.jboss.netty.handler.codec.http.HttpChunkTrailer;
+import org.jboss.netty.handler.codec.http.HttpHeaders;
+import org.jboss.netty.handler.codec.http.HttpMethod;
+import org.jboss.netty.handler.codec.http.HttpRequest;
+import org.jboss.netty.handler.codec.http.HttpResponse;
+
+public final class HttpProtocol extends Protocol {
+
+    private final ConnectionStrategy<HttpRequest, HttpResponse> connectionStrategy;
+
+    public HttpProtocol(ChannelManager channelManager, AsyncHttpClientConfig config, NettyAsyncHttpProviderConfig nettyConfig,
+            NettyRequestSender requestSender) {
+        super(channelManager, config, nettyConfig, requestSender);
+
+        connectionStrategy = nettyConfig.getConnectionStrategy();
+    }
+
+    private Realm kerberosChallenge(Channel channel,//
+            List<String> authHeaders,//
+            Request request,//
+            FluentCaseInsensitiveStringsMap headers,//
+            Realm realm,//
+            NettyResponseFuture<?> future) {
+
+        Uri uri = request.getUri();
+        String host = request.getVirtualHost() == null ? uri.getHost() : request.getVirtualHost();
+        try {
+            String challengeHeader = SpnegoEngine.instance().generateToken(host);
+            headers.remove(HttpHeaders.Names.AUTHORIZATION);
+            headers.add(HttpHeaders.Names.AUTHORIZATION, "Negotiate " + challengeHeader);
+
+            return new Realm.RealmBuilder().clone(realm)//
+                    .setUri(uri)//
+                    .setMethodName(request.getMethod())//
+                    .setScheme(Realm.AuthScheme.KERBEROS)//
+                    .build();
+
+
+        } catch (SpnegoEngineException throwable) {
+            String ntlmAuthenticate = getNTLM(authHeaders);
+            if (ntlmAuthenticate != null) {
+                return ntlmChallenge(ntlmAuthenticate, request, headers, realm, future);
+            }
+            requestSender.abort(channel, future, throwable);
+            return null;
+        }
+    }
+
+    private Realm kerberosProxyChallenge(Channel channel,//
+            List<String> proxyAuth,//
+            Request request,//
+            ProxyServer proxyServer,//
+            FluentCaseInsensitiveStringsMap headers,//
+            NettyResponseFuture<?> future) {
+
+        try {
+            String challengeHeader = SpnegoEngine.instance().generateToken(proxyServer.getHost());
+            headers.remove(HttpHeaders.Names.AUTHORIZATION);
+            headers.add(HttpHeaders.Names.AUTHORIZATION, "Negotiate " + challengeHeader);
+
+            return proxyServer.realmBuilder()//
+                    .setUri(request.getUri())//
+                    .setMethodName(request.getMethod())//
+                    .setScheme(Realm.AuthScheme.KERBEROS)//
+                    .build();
+
+        } catch (SpnegoEngineException throwable) {
+            String ntlmAuthenticate = getNTLM(proxyAuth);
+            if (ntlmAuthenticate != null) {
+                return ntlmProxyChallenge(ntlmAuthenticate, request, proxyServer, headers, future);
+            }
+            requestSender.abort(channel, future, throwable);
+            return null;
+        }
+    }
+    
+    private String authorizationHeaderName(boolean proxyInd) {
+        return proxyInd ? HttpHeaders.Names.PROXY_AUTHORIZATION : HttpHeaders.Names.AUTHORIZATION;
+    }
+
+    private void addNTLMAuthorizationHeader(FluentCaseInsensitiveStringsMap headers, String challengeHeader, boolean proxyInd) {
+        headers.add(authorizationHeaderName(proxyInd), "NTLM " + challengeHeader);
+    }
+
+    private Realm ntlmChallenge(String authenticateHeader,//
+            Request request,//
+            FluentCaseInsensitiveStringsMap headers,//
+            Realm realm,//
+            NettyResponseFuture<?> future) {
+
+        if (authenticateHeader.equals("NTLM")) {
+            // server replied bare NTLM => we didn't preemptively sent Type1Msg
+            String challengeHeader = NtlmEngine.INSTANCE.generateType1Msg();
+
+            addNTLMAuthorizationHeader(headers, challengeHeader, false);
+            future.getAndSetAuth(false);
+
+        } else {
+            // probably receiving Type2Msg, so we issue Type3Msg
+            addType3NTLMAuthorizationHeader(authenticateHeader, headers, realm, false);
+        }
+
+        return new Realm.RealmBuilder().clone(realm)//
+                .setUri(request.getUri())//
+                .setMethodName(request.getMethod())//
+                .build();
+    }
+
+    private Realm ntlmProxyChallenge(String authenticateHeader,//
+            Request request,//
+            ProxyServer proxyServer,//
+            FluentCaseInsensitiveStringsMap headers,//
+            NettyResponseFuture<?> future) {
+
+        future.getAndSetAuth(false);
+        headers.remove(HttpHeaders.Names.PROXY_AUTHORIZATION);
+
+        Realm realm = proxyServer.realmBuilder()//
+                .setScheme(AuthScheme.NTLM)//
+                .setUri(request.getUri())//
+                .setMethodName(request.getMethod()).build();
+
+        addType3NTLMAuthorizationHeader(authenticateHeader, headers, realm, true);
+
+        return realm;
+    }
+
+    private void addType3NTLMAuthorizationHeader(String auth, FluentCaseInsensitiveStringsMap headers, Realm realm, boolean proxyInd) {
+        headers.remove(authorizationHeaderName(proxyInd));
+
+        if (isNonEmpty(auth) && auth.startsWith("NTLM ")) {
+            String serverChallenge = auth.substring("NTLM ".length()).trim();
+            String challengeHeader = NtlmEngine.INSTANCE.generateType3Msg(realm.getPrincipal(), realm.getPassword(), realm.getNtlmDomain(), realm.getNtlmHost(), serverChallenge);
+            addNTLMAuthorizationHeader(headers, challengeHeader, proxyInd);
+        }
+    }
+
+    private void finishUpdate(final NettyResponseFuture<?> future, Channel channel, boolean expectOtherChunks) {
+
+        future.cancelTimeouts();
+
+        boolean keepAlive = future.isKeepAlive();
+        if (expectOtherChunks && keepAlive)
+            channelManager.drainChannelAndOffer(channel, future);
+        else
+            channelManager.tryToOfferChannelToPool(channel, future.getAsyncHandler(), keepAlive, future.getPartitionKey());
+
+        try {
+            future.done();
+        } catch (Exception t) {
+            // Never propagate exception once we know we are done.
+            logger.debug(t.getMessage(), t);
+        }
+    }
+
+    private boolean updateBodyAndInterrupt(NettyResponseFuture<?> future, AsyncHandler<?> handler, NettyResponseBodyPart bodyPart)
+            throws Exception {
+        boolean interrupt = handler.onBodyPartReceived(bodyPart) != State.CONTINUE;
+        if (bodyPart.isUnderlyingConnectionToBeClosed())
+            future.setKeepAlive(false);
+        return interrupt;
+    }
+
+    private boolean exitAfterHandling401(//
+            final Channel channel,//
+            final NettyResponseFuture<?> future,//
+            HttpResponse response,//
+            final Request request,//
+            int statusCode,//
+            Realm realm,//
+            ProxyServer proxyServer) {
+
+        if (statusCode == UNAUTHORIZED.getCode() && realm != null && !future.getAndSetAuth(true)) {
+
+            List<String> wwwAuthHeaders = response.headers().getAll(HttpHeaders.Names.WWW_AUTHENTICATE);
+
+            if (!wwwAuthHeaders.isEmpty()) {
+                future.setState(NettyResponseFuture.STATE.NEW);
+                Realm newRealm = null;
+
+                boolean negociate = wwwAuthHeaders.contains("Negotiate");
+                String ntlmAuthenticate = getNTLM(wwwAuthHeaders);
+                if (!wwwAuthHeaders.contains("Kerberos") && ntlmAuthenticate != null) {
+                    // NTLM
+                    newRealm = ntlmChallenge(ntlmAuthenticate, request, request.getHeaders(), realm, future);
+
+                } else if (negociate) {
+                    // SPNEGO KERBEROS
+                    newRealm = kerberosChallenge(channel, wwwAuthHeaders, request, request.getHeaders(), realm, future);
+                    if (newRealm == null)
+                        return true;
+
+                } else {
+                    newRealm = new Realm.RealmBuilder()//
+                            .clone(realm)//
+                            .setUri(request.getUri())//
+                            .setMethodName(request.getMethod())//
+                            .setUsePreemptiveAuth(true)//
+                            .parseWWWAuthenticateHeader(wwwAuthHeaders.get(0))//
+                            .build();
+                }
+
+                final Request nextRequest = new RequestBuilder(future.getRequest()).setHeaders(request.getHeaders()).setRealm(newRealm).build();
+
+                logger.debug("Sending authentication to {}", request.getUri());
+                if (future.isKeepAlive() && !HttpHeaders.isTransferEncodingChunked(response) && !response.isChunked()) {
+                    future.setReuseChannel(true);
+                } else {
+                    channelManager.closeChannel(channel);
+                }
+
+                requestSender.sendNextRequest(nextRequest, future);
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    private boolean exitAfterHandling100(final Channel channel, final NettyResponseFuture<?> future, int statusCode) {
+        if (statusCode == CONTINUE.getCode()) {
+            future.setHeadersAlreadyWrittenOnContinue(true);
+            future.setDontWriteBodyBecauseExpectContinue(false);
+            requestSender.writeRequest(future, channel);
+            return true;
+
+        }
+        return false;
+    }
+
+    private boolean exitAfterHandling407(//
+            final Channel channel,//
+            final NettyResponseFuture<?> future,//
+            HttpResponse response,//
+            Request request,//
+            int statusCode,//
+            Realm realm,//
+            ProxyServer proxyServer) {
+
+        if (statusCode == PROXY_AUTHENTICATION_REQUIRED.getCode() && realm != null && !future.getAndSetAuth(true)) {
+
+            List<String> proxyAuthHeaders = response.headers().getAll(HttpHeaders.Names.PROXY_AUTHENTICATE);
+
+            if (!proxyAuthHeaders.isEmpty()) {
+                logger.debug("Sending proxy authentication to {}", request.getUri());
+
+                future.setState(NettyResponseFuture.STATE.NEW);
+                Realm newRealm = null;
+                FluentCaseInsensitiveStringsMap requestHeaders = request.getHeaders();
+
+                boolean negociate = proxyAuthHeaders.contains("Negotiate");
+                String ntlmAuthenticate = getNTLM(proxyAuthHeaders);
+                if (!proxyAuthHeaders.contains("Kerberos") && ntlmAuthenticate != null) {
+                    newRealm = ntlmProxyChallenge(ntlmAuthenticate, request, proxyServer, requestHeaders, future);
+                    // SPNEGO KERBEROS
+
+                } else if (negociate) {
+                    newRealm = kerberosProxyChallenge(channel, proxyAuthHeaders, request, proxyServer, requestHeaders, future);
+                    if (newRealm == null)
+                        return true;
+
+                } else {
+                    newRealm = new Realm.RealmBuilder().clone(realm)//
+                            .setUri(request.getUri())//
+                            .setOmitQuery(true)//
+                            .setMethodName(request.getMethod())//
+                            .setUsePreemptiveAuth(true)//
+                            .parseProxyAuthenticateHeader(proxyAuthHeaders.get(0))//
+                            .build();
+                }
+
+                final Request nextRequest = new RequestBuilder(future.getRequest()).setHeaders(request.getHeaders()).setRealm(newRealm).build();
+
+                logger.debug("Sending proxy authentication to {}", request.getUri());
+                if (future.isKeepAlive() && !HttpHeaders.isTransferEncodingChunked(response) && !response.isChunked()) {
+                    future.setConnectAllowed(true);
+                    future.setReuseChannel(true);
+                } else {
+                    channelManager.closeChannel(channel);
+                }
+
+                requestSender.sendNextRequest(nextRequest, future);
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private boolean exitAfterHandlingConnect(//
+            final Channel channel,//
+            final NettyResponseFuture<?> future,//
+            final Request request,//
+            ProxyServer proxyServer,//
+            int statusCode,//
+            HttpRequest httpRequest) {
+
+        if (statusCode == OK.getCode() && httpRequest.getMethod() == HttpMethod.CONNECT) {
+
+            if (future.isKeepAlive())
+                future.attachChannel(channel, true);
+
+            Uri requestUri = request.getUri();
+            String scheme = requestUri.getScheme();
+            String host = requestUri.getHost();
+            int port = getExplicitPort(requestUri);
+
+            logger.debug("Connecting to proxy {} for scheme {}", proxyServer, scheme);
+
+            try {
+                channelManager.upgradeProtocol(channel.getPipeline(), scheme, host, port);
+                future.setReuseChannel(true);
+                future.setConnectAllowed(false);
+                requestSender.sendNextRequest(new RequestBuilder(future.getRequest()).build(), future);
+
+            } catch (GeneralSecurityException ex) {
+                requestSender.abort(channel, future, ex);
+            }
+
+            return true;
+        }
+
+        return false;
+    }
+
+    private boolean exitAfterHandlingStatus(Channel channel, NettyResponseFuture<?> future, HttpResponse response,
+            AsyncHandler<?> handler, NettyResponseStatus status) throws Exception {
+        if (!future.getAndSetStatusReceived(true) && handler.onStatusReceived(status) != State.CONTINUE) {
+            finishUpdate(future, channel, HttpHeaders.isTransferEncodingChunked(response));
+            return true;
+        }
+        return false;
+    }
+
+    private boolean exitAfterHandlingHeaders(Channel channel, NettyResponseFuture<?> future, HttpResponse response,
+            AsyncHandler<?> handler, NettyResponseHeaders responseHeaders) throws Exception {
+        if (!response.headers().isEmpty() && handler.onHeadersReceived(responseHeaders) != State.CONTINUE) {
+            finishUpdate(future, channel, HttpHeaders.isTransferEncodingChunked(response));
+            return true;
+        }
+        return false;
+    }
+
+    // Netty 3: if the response is not chunked, the full body comes with the response
+    private boolean exitAfterHandlingBody(Channel channel, NettyResponseFuture<?> future, HttpResponse response,
+            AsyncHandler<?> handler) throws Exception {
+        if (!response.isChunked()) {
+            // no chunks expected, exiting
+            if (response.getContent().readableBytes() > 0) {
+                // no need to notify an empty bodypart
+                updateBodyAndInterrupt(future, handler, new NettyResponseBodyPart(response, null, true));
+            }
+            finishUpdate(future, channel, false);
+            return true;
+        }
+        return false;
+    }
+
+    private boolean handleHttpResponse(final HttpResponse response,//
+            final Channel channel,//
+            final NettyResponseFuture<?> future,//
+            AsyncHandler<?> handler) throws Exception {
+
+        HttpRequest httpRequest = future.getNettyRequest().getHttpRequest();
+        ProxyServer proxyServer = future.getProxyServer();
+        logger.debug("\n\nRequest {}\n\nResponse {}\n", httpRequest, response);
+
+        // store the original headers so we can re-send all them to
+        // the handler in case of trailing headers
+        future.setHttpHeaders(response.headers());
+
+        future.setKeepAlive(connectionStrategy.keepAlive(httpRequest, response));
+
+        NettyResponseStatus status = new NettyResponseStatus(future.getUri(), config, response, channel);
+        int statusCode = response.getStatus().getCode();
+        Request request = future.getRequest();
+        Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
+        NettyResponseHeaders responseHeaders = new NettyResponseHeaders(response.headers());
+
+        return exitAfterProcessingFilters(channel, future, handler, status, responseHeaders)
+                || exitAfterHandling401(channel, future, response, request, statusCode, realm, proxyServer) || //
+                exitAfterHandling407(channel, future, response, request, statusCode, realm, proxyServer) || //
+                exitAfterHandling100(channel, future, statusCode) || //
+                exitAfterHandlingRedirect(channel, future, response, request, statusCode, realm) || //
+                exitAfterHandlingConnect(channel, future, request, proxyServer, statusCode, httpRequest) || //
+                exitAfterHandlingStatus(channel, future, response, handler, status) || //
+                exitAfterHandlingHeaders(channel, future, response, handler, responseHeaders) || //
+                exitAfterHandlingBody(channel, future, response, handler);
+    }
+
+    private void handleChunk(HttpChunk chunk,//
+            final Channel channel,//
+            final NettyResponseFuture<?> future,//
+            AsyncHandler<?> handler) throws Exception {
+
+        boolean last = chunk.isLast();
+        // we don't notify updateBodyAndInterrupt with the last chunk as it's empty
+        if (last || updateBodyAndInterrupt(future, handler, new NettyResponseBodyPart(null, chunk, last))) {
+
+            // only possible if last is true
+            if (chunk instanceof HttpChunkTrailer) {
+                HttpChunkTrailer chunkTrailer = (HttpChunkTrailer) chunk;
+                if (!chunkTrailer.trailingHeaders().isEmpty()) {
+                    NettyResponseHeaders responseHeaders = new NettyResponseHeaders(future.getHttpHeaders(), chunkTrailer.trailingHeaders());
+                    handler.onHeadersReceived(responseHeaders);
+                }
+            }
+            finishUpdate(future, channel, !chunk.isLast());
+        }
+    }
+
+    @Override
+    public void handle(final Channel channel, final NettyResponseFuture<?> future, final Object e) throws Exception {
+
+        future.touch();
+
+        // future is already done because of an exception or a timeout
+        if (future.isDone()) {
+            // FIXME isn't the channel already properly closed?
+            channelManager.closeChannel(channel);
+            return;
+        }
+
+        AsyncHandler<?> handler = future.getAsyncHandler();
+        try {
+            if (e instanceof HttpResponse) {
+                if (handleHttpResponse((HttpResponse) e, channel, future, handler))
+                    return;
+
+            } else if (e instanceof HttpChunk)
+                handleChunk((HttpChunk) e, channel, future, handler);
+
+        } catch (Exception t) {
+            // e.g. an IOException when trying to open a connection and send the next request
+            if (hasIOExceptionFilters//
+                    && t instanceof IOException//
+                    && requestSender.applyIoExceptionFiltersAndReplayRequest(future, IOException.class.cast(t), channel)) {
+                return;
+            }
+
+            // FIXME Weird: close channel in abort, then close again
+            try {
+                requestSender.abort(channel, future, t);
+            } catch (Exception abortException) {
+                logger.debug("Abort failed", abortException);
+            } finally {
+                finishUpdate(future, channel, false);
+            }
+            throw t;
+        }
+    }
+
+    public void onError(NettyResponseFuture<?> future, Throwable e) {
+    }
+
+    public void onClose(NettyResponseFuture<?> future) {
+    }
+}
diff --git a/providers/netty3/src/main/java/org/asynchttpclient/netty/handler/Processor.java b/providers/netty3/src/main/java/org/asynchttpclient/netty/handler/Processor.java
new file mode 100644
index 000000000..e9330a4c4
--- /dev/null
+++ b/providers/netty3/src/main/java/org/asynchttpclient/netty/handler/Processor.java
@@ -0,0 +1,184 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.handler;
+
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.CHANNEL_CLOSED_EXCEPTION;
+
+import java.io.IOException;
+import java.nio.channels.ClosedChannelException;
+
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.netty.Callback;
+import org.asynchttpclient.netty.DiscardEvent;
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.channel.ChannelManager;
+import org.asynchttpclient.netty.channel.Channels;
+import org.asynchttpclient.netty.future.StackTraceInspector;
+import org.asynchttpclient.netty.request.NettyRequestSender;
+import org.jboss.netty.channel.Channel;
+import org.jboss.netty.channel.ChannelHandlerContext;
+import org.jboss.netty.channel.ChannelStateEvent;
+import org.jboss.netty.channel.ExceptionEvent;
+import org.jboss.netty.channel.MessageEvent;
+import org.jboss.netty.channel.SimpleChannelUpstreamHandler;
+import org.jboss.netty.handler.codec.PrematureChannelClosureException;
+import org.jboss.netty.handler.codec.http.HttpChunk;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class Processor extends SimpleChannelUpstreamHandler {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(Processor.class);
+
+    private final AsyncHttpClientConfig config;
+    private final ChannelManager channelManager;
+    private final NettyRequestSender requestSender;
+    private final Protocol protocol;
+
+    public Processor(AsyncHttpClientConfig config,//
+            ChannelManager channelManager,//
+            NettyRequestSender requestSender,//
+            Protocol protocol) {
+        this.config = config;
+        this.channelManager = channelManager;
+        this.requestSender = requestSender;
+        this.protocol = protocol;
+    }
+
+    @Override
+    public void messageReceived(final ChannelHandlerContext ctx, MessageEvent e) throws Exception {
+
+        // call super to reset the read timeout
+        super.messageReceived(ctx, e);
+
+        Channel channel = ctx.getChannel();
+        Object attribute = Channels.getAttribute(channel);
+
+        if (attribute instanceof Callback) {
+            Object message = e.getMessage();
+            Callback ac = (Callback) attribute;
+            if (message instanceof HttpChunk) {
+                // the AsyncCallable is to be processed on the last chunk
+                if (HttpChunk.class.cast(message).isLast())
+                    // process the AsyncCallable before passing the message to the protocol
+                    ac.call();
+                    // FIXME remove attribute?
+            } else {
+                LOGGER.info("Received unexpected message while expecting a chunk: " + message);
+                ac.call();
+                Channels.setDiscard(channel);
+            }
+
+        } else if (attribute instanceof NettyResponseFuture<?>) {
+            NettyResponseFuture<?> future = (NettyResponseFuture<?>) attribute;
+            protocol.handle(channel, future, e.getMessage());
+
+        } else if (attribute != DiscardEvent.INSTANCE) {
+            // unhandled message
+            LOGGER.debug("Orphan channel {} with attribute {} received message {}, closing", channel, attribute, e.getMessage());
+            Channels.silentlyCloseChannel(channel);
+        }
+    }
+
+    @Override
+    public void channelClosed(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {
+
+        if (requestSender.isClosed())
+            return;
+
+        Channel channel = ctx.getChannel();
+        channelManager.removeAll(channel);
+
+        try {
+            super.channelClosed(ctx, e);
+        } catch (Exception ex) {
+            LOGGER.trace("super.channelClosed", ex);
+        }
+
+        Object attribute = Channels.getAttribute(channel);
+        LOGGER.debug("Channel Closed: {} with attribute {}", channel, attribute);
+
+        if (attribute instanceof Callback) {
+            Callback callback = (Callback) attribute;
+            Channels.setAttribute(channel, callback.future());
+            callback.call();
+
+        } else if (attribute instanceof NettyResponseFuture<?>) {
+            NettyResponseFuture<?> future = (NettyResponseFuture<?>) attribute;
+            future.touch();
+
+            if (!config.getIOExceptionFilters().isEmpty()
+                    && requestSender.applyIoExceptionFiltersAndReplayRequest(future, CHANNEL_CLOSED_EXCEPTION, channel))
+                return;
+
+            protocol.onClose(future);
+            requestSender.handleUnexpectedClosedChannel(channel, future);
+        }
+    }
+
+    @Override
+    public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception {
+        Channel channel = ctx.getChannel();
+        Throwable cause = e.getCause();
+        NettyResponseFuture<?> future = null;
+
+        // FIXME we can't get a PrematureChannelClosureException as we create the HttpClientCodec without setting failOnMissingResponse to true
+        if (cause instanceof PrematureChannelClosureException || cause instanceof ClosedChannelException)
+            return;
+
+        LOGGER.debug("Unexpected I/O exception on channel {}", channel, cause);
+
+        try {
+            Object attribute = Channels.getAttribute(channel);
+            if (attribute instanceof NettyResponseFuture<?>) {
+                future = (NettyResponseFuture<?>) attribute;
+                future.attachChannel(null, false);
+                future.touch();
+
+                if (cause instanceof IOException) {
+
+                    // FIXME why drop the original exception and throw a new one?
+                    if (!config.getIOExceptionFilters().isEmpty()) {
+                        if (!requestSender.applyIoExceptionFiltersAndReplayRequest(future, CHANNEL_CLOSED_EXCEPTION, channel))
+                            // Close the channel so the recovering can occurs.
+                            Channels.silentlyCloseChannel(channel);
+                        return;
+                    }
+                }
+
+                // FIXME how does recovery occur?!
+                if (StackTraceInspector.recoverOnReadOrWriteException(cause)) {
+                    LOGGER.debug("Trying to recover from dead Channel: {}", channel);
+                    return;
+                }
+            } else if (attribute instanceof Callback) {
+                future = ((Callback) attribute).future();
+            }
+        } catch (Throwable t) {
+            cause = t;
+        }
+
+        if (future != null)
+            try {
+                LOGGER.debug("Was unable to recover Future: {}", future);
+                requestSender.abort(channel, future, cause);
+                protocol.onError(future, e.getCause());
+            } catch (Throwable t) {
+                LOGGER.error(t.getMessage(), t);
+            }
+
+        channelManager.closeChannel(channel);
+        ctx.sendUpstream(e);
+    }
+}
diff --git a/providers/netty3/src/main/java/org/asynchttpclient/netty/handler/Protocol.java b/providers/netty3/src/main/java/org/asynchttpclient/netty/handler/Protocol.java
new file mode 100644
index 000000000..6066fbf2d
--- /dev/null
+++ b/providers/netty3/src/main/java/org/asynchttpclient/netty/handler/Protocol.java
@@ -0,0 +1,241 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.handler;
+
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.followRedirect;
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.isSameBase;
+import static org.jboss.netty.handler.codec.http.HttpHeaders.Names.AUTHORIZATION;
+import static org.jboss.netty.handler.codec.http.HttpHeaders.Names.PROXY_AUTHORIZATION;
+import static org.jboss.netty.handler.codec.http.HttpResponseStatus.FOUND;
+import static org.jboss.netty.handler.codec.http.HttpResponseStatus.MOVED_PERMANENTLY;
+import static org.jboss.netty.handler.codec.http.HttpResponseStatus.SEE_OTHER;
+import static org.jboss.netty.handler.codec.http.HttpResponseStatus.TEMPORARY_REDIRECT;
+
+import java.util.HashSet;
+import java.util.Set;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.Realm;
+import org.asynchttpclient.Realm.AuthScheme;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.cookie.Cookie;
+import org.asynchttpclient.cookie.CookieDecoder;
+import org.asynchttpclient.filter.FilterContext;
+import org.asynchttpclient.filter.FilterException;
+import org.asynchttpclient.filter.ResponseFilter;
+import org.asynchttpclient.handler.MaxRedirectException;
+import org.asynchttpclient.netty.NettyAsyncHttpProviderConfig;
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.channel.ChannelManager;
+import org.asynchttpclient.netty.request.NettyRequestSender;
+import org.asynchttpclient.uri.Uri;
+import org.asynchttpclient.util.MiscUtils;
+import org.jboss.netty.channel.Channel;
+import org.jboss.netty.handler.codec.http.HttpHeaders;
+import org.jboss.netty.handler.codec.http.HttpResponse;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public abstract class Protocol {
+
+    protected final Logger logger = LoggerFactory.getLogger(getClass());
+
+    protected final ChannelManager channelManager;
+    protected final AsyncHttpClientConfig config;
+    protected final NettyAsyncHttpProviderConfig nettyConfig;
+    protected final NettyRequestSender requestSender;
+
+    private final boolean hasResponseFilters;
+    protected final boolean hasIOExceptionFilters;
+    private final MaxRedirectException maxRedirectException;
+
+    public static final Set<Integer> REDIRECT_STATUSES = new HashSet<>();
+    static {
+        REDIRECT_STATUSES.add(MOVED_PERMANENTLY.getCode());
+        REDIRECT_STATUSES.add(FOUND.getCode());
+        REDIRECT_STATUSES.add(SEE_OTHER.getCode());
+        REDIRECT_STATUSES.add(TEMPORARY_REDIRECT.getCode());
+    }
+
+    public Protocol(ChannelManager channelManager, AsyncHttpClientConfig config, NettyAsyncHttpProviderConfig nettyConfig, NettyRequestSender requestSender) {
+        this.channelManager = channelManager;
+        this.config = config;
+        this.nettyConfig = nettyConfig;
+        this.requestSender = requestSender;
+
+        hasResponseFilters = !config.getResponseFilters().isEmpty();
+        hasIOExceptionFilters = !config.getIOExceptionFilters().isEmpty();
+        maxRedirectException = new MaxRedirectException("Maximum redirect reached: " + config.getMaxRedirects());
+    }
+
+    public abstract void handle(Channel channel, NettyResponseFuture<?> future, Object message) throws Exception;
+
+    public abstract void onError(NettyResponseFuture<?> future, Throwable e);
+
+    public abstract void onClose(NettyResponseFuture<?> future);
+
+    private FluentCaseInsensitiveStringsMap propagatedHeaders(Request request, Realm realm, boolean switchToGet) {
+
+        FluentCaseInsensitiveStringsMap headers = request.getHeaders()//
+                .delete(HttpHeaders.Names.HOST)//
+                .delete(HttpHeaders.Names.CONTENT_LENGTH)//
+                .delete(HttpHeaders.Names.CONTENT_TYPE);
+
+        if (realm != null && realm.getScheme() == AuthScheme.NTLM) {
+            headers.delete(AUTHORIZATION)//
+                    .delete(PROXY_AUTHORIZATION);
+        }
+        return headers;
+    }
+
+    protected boolean exitAfterHandlingRedirect(//
+            Channel channel,//
+            NettyResponseFuture<?> future,//
+            HttpResponse response,//
+            Request request,//
+            int statusCode,//
+            Realm realm) throws Exception {
+
+        if (followRedirect(config, request) && REDIRECT_STATUSES.contains(statusCode)) {
+            if (future.incrementAndGetCurrentRedirectCount() >= config.getMaxRedirects()) {
+                throw maxRedirectException;
+
+            } else {
+                // We must allow 401 handling again.
+                future.getAndSetAuth(false);
+
+                // if we are to strictly handle 302, we should keep the
+                // original method (which browsers don't)
+                // 303 must force GET
+                String originalMethod = request.getMethod();
+                boolean switchToGet = !originalMethod.equals("GET") && (statusCode == 303 || (statusCode == 302 && !config.isStrict302Handling()));
+                boolean keepBody = statusCode == 307 || (statusCode == 302 && config.isStrict302Handling());
+
+                final RequestBuilder requestBuilder = new RequestBuilder(switchToGet ? "GET" : originalMethod)//
+                        .setCookies(request.getCookies())//
+                        .setConnectionPoolPartitioning(request.getConnectionPoolPartitioning())//
+                        .setFollowRedirect(true)//
+                        .setLocalInetAddress(request.getLocalAddress())//
+                        .setNameResolver(request.getNameResolver())//
+                        .setProxyServer(request.getProxyServer())//
+                        .setRealm(request.getRealm())//
+                        .setRequestTimeout(request.getRequestTimeout());
+
+                if (keepBody) {
+                    requestBuilder.setBodyCharset(request.getBodyCharset());
+                    if (MiscUtils.isNonEmpty(request.getFormParams()))
+                        requestBuilder.setFormParams(request.getFormParams());
+                    else if (request.getStringData() != null)
+                        requestBuilder.setBody(request.getStringData());
+                    else if (request.getByteData() != null)
+                        requestBuilder.setBody(request.getByteData());
+                    else if (request.getByteBufferData() != null)
+                        requestBuilder.setBody(request.getByteBufferData());
+                    else if (request.getBodyGenerator() != null)
+                        requestBuilder.setBody(request.getBodyGenerator());
+                }
+
+                requestBuilder.setHeaders(propagatedHeaders(request, realm, switchToGet));
+
+                // in case of a redirect from HTTP to HTTPS, future
+                // attributes might change
+                final boolean initialConnectionKeepAlive = future.isKeepAlive();
+                final Object initialPartitionKey = future.getPartitionKey();
+
+                HttpHeaders responseHeaders = response.headers();
+                String location = responseHeaders.get(HttpHeaders.Names.LOCATION);
+                Uri newUri = Uri.create(future.getUri(), location);
+
+                logger.debug("Redirecting to {}", newUri);
+
+                for (String cookieStr : responseHeaders.getAll(HttpHeaders.Names.SET_COOKIE)) {
+                    Cookie c = CookieDecoder.decode(cookieStr);
+                    if (c != null)
+                        requestBuilder.addOrReplaceCookie(c);
+                }
+
+                requestBuilder.setHeaders(propagatedHeaders(future.getRequest(), realm, switchToGet));
+
+                boolean sameBase = isSameBase(request.getUri(), newUri);
+
+                if (sameBase) {
+                    // we can only assume the virtual host is still valid if the baseUrl is the same
+                    requestBuilder.setVirtualHost(request.getVirtualHost());
+                }
+
+                final Request nextRequest = requestBuilder.setUri(newUri).build();
+
+                logger.debug("Sending redirect to {}", newUri);
+
+                if (future.isKeepAlive() && !HttpHeaders.isTransferEncodingChunked(response) && !response.isChunked()) {
+
+                    if (sameBase) {
+                        future.setReuseChannel(true);
+                    } else {
+                        channelManager.drainChannelAndOffer(channel, future, initialConnectionKeepAlive, initialPartitionKey);
+                    }
+
+                } else {
+                    // redirect + chunking = WAT
+                    channelManager.closeChannel(channel);
+                }
+
+                requestSender.sendNextRequest(nextRequest, future);
+                return true;
+            }
+        }
+        return false;
+    }
+
+    @SuppressWarnings({ "rawtypes", "unchecked" })
+    protected boolean exitAfterProcessingFilters(//
+            Channel channel,//
+            NettyResponseFuture<?> future,//
+            AsyncHandler<?> handler, //
+            HttpResponseStatus status,//
+            HttpResponseHeaders responseHeaders) {
+
+        if (hasResponseFilters) {
+            FilterContext fc = new FilterContext.FilterContextBuilder().asyncHandler(handler).request(future.getRequest()).responseStatus(status).responseHeaders(responseHeaders)
+                    .build();
+
+            for (ResponseFilter asyncFilter : config.getResponseFilters()) {
+                try {
+                    fc = asyncFilter.filter(fc);
+                    // FIXME Is it worth protecting against this?
+                    if (fc == null) {
+                        throw new NullPointerException("FilterContext is null");
+                    }
+                } catch (FilterException efe) {
+                    requestSender.abort(channel, future, efe);
+                }
+            }
+
+            // The handler may have been wrapped.
+            future.setAsyncHandler(fc.getAsyncHandler());
+
+            // The request has changed
+            if (fc.replayRequest()) {
+                requestSender.replayRequest(future, fc, channel);
+                return true;
+            }
+        }
+        return false;
+    }
+}
diff --git a/providers/netty3/src/main/java/org/asynchttpclient/netty/handler/WebSocketProtocol.java b/providers/netty3/src/main/java/org/asynchttpclient/netty/handler/WebSocketProtocol.java
new file mode 100644
index 000000000..2ace8962d
--- /dev/null
+++ b/providers/netty3/src/main/java/org/asynchttpclient/netty/handler/WebSocketProtocol.java
@@ -0,0 +1,209 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.handler;
+
+import static org.asynchttpclient.ws.WebSocketUtils.getAcceptKey;
+import static org.jboss.netty.handler.codec.http.HttpResponseStatus.SWITCHING_PROTOCOLS;
+
+import java.io.IOException;
+import java.util.Locale;
+
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.Realm;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.AsyncHandler.State;
+import org.asynchttpclient.netty.NettyAsyncHttpProviderConfig;
+import org.asynchttpclient.netty.NettyResponseBodyPart;
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.NettyResponseHeaders;
+import org.asynchttpclient.netty.NettyResponseStatus;
+import org.asynchttpclient.netty.channel.ChannelManager;
+import org.asynchttpclient.netty.channel.Channels;
+import org.asynchttpclient.netty.request.NettyRequestSender;
+import org.asynchttpclient.netty.ws.NettyWebSocket;
+import org.asynchttpclient.ws.WebSocketUpgradeHandler;
+import org.jboss.netty.buffer.ChannelBuffer;
+import org.jboss.netty.channel.Channel;
+import org.jboss.netty.handler.codec.http.HttpChunk;
+import org.jboss.netty.handler.codec.http.HttpHeaders;
+import org.jboss.netty.handler.codec.http.HttpResponse;
+import org.jboss.netty.handler.codec.http.websocketx.BinaryWebSocketFrame;
+import org.jboss.netty.handler.codec.http.websocketx.CloseWebSocketFrame;
+import org.jboss.netty.handler.codec.http.websocketx.PingWebSocketFrame;
+import org.jboss.netty.handler.codec.http.websocketx.PongWebSocketFrame;
+import org.jboss.netty.handler.codec.http.websocketx.TextWebSocketFrame;
+import org.jboss.netty.handler.codec.http.websocketx.WebSocketFrame;
+
+public final class WebSocketProtocol extends Protocol {
+
+    public WebSocketProtocol(ChannelManager channelManager,//
+            AsyncHttpClientConfig config,//
+            NettyAsyncHttpProviderConfig nettyConfig,//
+            NettyRequestSender requestSender) {
+        super(channelManager, config, nettyConfig, requestSender);
+    }
+
+    // We don't need to synchronize as replacing the "ws-decoder" will
+    // process using the same thread.
+    private void invokeOnSucces(Channel channel, WebSocketUpgradeHandler h) {
+        if (!h.touchSuccess()) {
+            try {
+                h.onSuccess(nettyConfig.getNettyWebSocketFactory().newNettyWebSocket(channel, config));
+            } catch (Exception ex) {
+                logger.warn("onSuccess unexpected exception", ex);
+            }
+        }
+    }
+
+    @Override
+    public void handle(Channel channel, NettyResponseFuture<?> future, Object e) throws Exception {
+        WebSocketUpgradeHandler handler = WebSocketUpgradeHandler.class.cast(future.getAsyncHandler());
+        Request request = future.getRequest();
+
+        if (e instanceof HttpResponse) {
+            HttpResponse response = (HttpResponse) e;
+            HttpResponseStatus status = new NettyResponseStatus(future.getUri(), config, response, channel);
+            HttpResponseHeaders responseHeaders = new NettyResponseHeaders(response.headers());
+            Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
+
+            if (exitAfterProcessingFilters(channel, future, handler, status, responseHeaders)) {
+                return;
+            }
+
+            future.setHttpHeaders(response.headers());
+            if (exitAfterHandlingRedirect(channel, future, response, request, response.getStatus().getCode(), realm))
+                return;
+
+            boolean validStatus = response.getStatus().equals(SWITCHING_PROTOCOLS);
+            boolean validUpgrade = response.headers().get(HttpHeaders.Names.UPGRADE) != null;
+            String connection = response.headers().get(HttpHeaders.Names.CONNECTION);
+            if (connection == null)
+                connection = response.headers().get(HttpHeaders.Names.CONNECTION.toLowerCase(Locale.ENGLISH));
+            boolean validConnection = HttpHeaders.Values.UPGRADE.equalsIgnoreCase(connection);
+            boolean statusReceived = handler.onStatusReceived(status) == State.UPGRADE;
+
+            if (!statusReceived) {
+                try {
+                    handler.onCompleted();
+                } finally {
+                    future.done();
+                }
+                return;
+            }
+
+            final boolean headerOK = handler.onHeadersReceived(responseHeaders) == State.CONTINUE;
+            if (!headerOK || !validStatus || !validUpgrade || !validConnection) {
+                requestSender.abort(channel, future, new IOException("Invalid handshake response"));
+                return;
+            }
+
+            String accept = response.headers().get(HttpHeaders.Names.SEC_WEBSOCKET_ACCEPT);
+            String key = getAcceptKey(future.getNettyRequest().getHttpRequest().headers().get(HttpHeaders.Names.SEC_WEBSOCKET_KEY));
+            if (accept == null || !accept.equals(key)) {
+                requestSender.abort(channel, future, new IOException(String.format("Invalid challenge. Actual: %s. Expected: %s", accept, key)));
+            }
+
+            channelManager.upgradePipelineForWebSockets(channel.getPipeline());
+
+            invokeOnSucces(channel, handler);
+            future.done();
+
+        } else if (e instanceof WebSocketFrame) {
+
+            final WebSocketFrame frame = (WebSocketFrame) e;
+            NettyWebSocket webSocket = NettyWebSocket.class.cast(handler.onCompleted());
+            invokeOnSucces(channel, handler);
+
+            if (webSocket != null) {
+                if (frame instanceof CloseWebSocketFrame) {
+                    Channels.setDiscard(channel);
+                    CloseWebSocketFrame closeFrame = CloseWebSocketFrame.class.cast(frame);
+                    webSocket.onClose(closeFrame.getStatusCode(), closeFrame.getReasonText());
+                    
+                } else if (frame.getBinaryData() != null) {
+                    HttpChunk webSocketChunk = new HttpChunk() {
+                        private ChannelBuffer content = frame.getBinaryData();
+
+                        @Override
+                        public boolean isLast() {
+                            return frame.isFinalFragment();
+                        }
+
+                        @Override
+                        public ChannelBuffer getContent() {
+                            return content;
+                        }
+
+                        @Override
+                        public void setContent(ChannelBuffer content) {
+                            throw new UnsupportedOperationException();
+                        }
+                    };
+
+                    NettyResponseBodyPart part = new NettyResponseBodyPart(null, webSocketChunk, frame.isFinalFragment());
+                    handler.onBodyPartReceived(part);
+
+                    if (frame instanceof BinaryWebSocketFrame) {
+                        webSocket.onBinaryFragment(part);
+                    } else if (frame instanceof TextWebSocketFrame) {
+                        webSocket.onTextFragment(part);
+                    } else if (frame instanceof PingWebSocketFrame) {
+                        webSocket.onPing(part);
+                    } else if (frame instanceof PongWebSocketFrame) {
+                        webSocket.onPong(part);
+                    }
+                }
+            } else {
+                logger.debug("UpgradeHandler returned a null NettyWebSocket ");
+            }
+        } else {
+            logger.error("Invalid message {}", e);
+        }
+    }
+
+    @Override
+    public void onError(NettyResponseFuture<?> future, Throwable e) {
+        logger.warn("onError {}", e);
+
+        try {
+            WebSocketUpgradeHandler h = (WebSocketUpgradeHandler) future.getAsyncHandler();
+
+            NettyWebSocket webSocket = NettyWebSocket.class.cast(h.onCompleted());
+            if (webSocket != null) {
+                webSocket.onError(e.getCause());
+                webSocket.close();
+            }
+        } catch (Throwable t) {
+            logger.error("onError", t);
+        }
+    }
+
+    @Override
+    public void onClose(NettyResponseFuture<?> future) {
+        logger.trace("onClose");
+
+        try {
+            WebSocketUpgradeHandler h = (WebSocketUpgradeHandler) future.getAsyncHandler();
+            NettyWebSocket webSocket = NettyWebSocket.class.cast(h.onCompleted());
+
+            logger.trace("Connection was closed abnormally (that is, with no close frame being sent).");
+            if (webSocket != null)
+                webSocket.close(1006, "Connection was closed abnormally (that is, with no close frame being sent).");
+        } catch (Throwable t) {
+            logger.error("onError", t);
+        }
+    }
+}
diff --git a/providers/netty3/src/main/java/org/asynchttpclient/netty/request/NettyRequest.java b/providers/netty3/src/main/java/org/asynchttpclient/netty/request/NettyRequest.java
new file mode 100644
index 000000000..ddb0ffcb2
--- /dev/null
+++ b/providers/netty3/src/main/java/org/asynchttpclient/netty/request/NettyRequest.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.request;
+
+import org.asynchttpclient.netty.request.body.NettyBody;
+import org.jboss.netty.handler.codec.http.HttpRequest;
+
+public final class NettyRequest {
+
+    private final HttpRequest httpRequest;
+    private final NettyBody body;
+
+    public NettyRequest(HttpRequest httpRequest, NettyBody body) {
+        this.httpRequest = httpRequest;
+        this.body = body;
+    }
+
+    public HttpRequest getHttpRequest() {
+        return httpRequest;
+    }
+
+    public NettyBody getBody() {
+        return body;
+    }
+}
diff --git a/providers/netty3/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactory.java b/providers/netty3/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactory.java
new file mode 100644
index 000000000..5e0bddd71
--- /dev/null
+++ b/providers/netty3/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactory.java
@@ -0,0 +1,227 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.request;
+
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.DEFAULT_CHARSET;
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.hostHeader;
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.urlEncodeFormParams;
+import static org.asynchttpclient.util.AuthenticatorUtils.perRequestAuthorizationHeader;
+import static org.asynchttpclient.util.AuthenticatorUtils.perRequestProxyAuthorizationHeader;
+import static org.asynchttpclient.util.HttpUtils.isSecure;
+import static org.asynchttpclient.util.HttpUtils.isWebSocket;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+import static org.asynchttpclient.ws.WebSocketUtils.getKey;
+import static org.jboss.netty.handler.codec.http.HttpHeaders.Names.ACCEPT;
+import static org.jboss.netty.handler.codec.http.HttpHeaders.Names.ACCEPT_ENCODING;
+import static org.jboss.netty.handler.codec.http.HttpHeaders.Names.AUTHORIZATION;
+import static org.jboss.netty.handler.codec.http.HttpHeaders.Names.CONNECTION;
+import static org.jboss.netty.handler.codec.http.HttpHeaders.Names.CONTENT_LENGTH;
+import static org.jboss.netty.handler.codec.http.HttpHeaders.Names.CONTENT_TYPE;
+import static org.jboss.netty.handler.codec.http.HttpHeaders.Names.COOKIE;
+import static org.jboss.netty.handler.codec.http.HttpHeaders.Names.HOST;
+import static org.jboss.netty.handler.codec.http.HttpHeaders.Names.ORIGIN;
+import static org.jboss.netty.handler.codec.http.HttpHeaders.Names.PROXY_AUTHORIZATION;
+import static org.jboss.netty.handler.codec.http.HttpHeaders.Names.SEC_WEBSOCKET_KEY;
+import static org.jboss.netty.handler.codec.http.HttpHeaders.Names.SEC_WEBSOCKET_VERSION;
+import static org.jboss.netty.handler.codec.http.HttpHeaders.Names.TRANSFER_ENCODING;
+import static org.jboss.netty.handler.codec.http.HttpHeaders.Names.UPGRADE;
+import static org.jboss.netty.handler.codec.http.HttpHeaders.Names.USER_AGENT;
+
+import java.nio.charset.Charset;
+import java.util.List;
+import java.util.Map.Entry;
+
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Realm;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.cookie.CookieEncoder;
+import org.asynchttpclient.netty.request.body.NettyBody;
+import org.asynchttpclient.netty.request.body.NettyBodyBody;
+import org.asynchttpclient.netty.request.body.NettyByteArrayBody;
+import org.asynchttpclient.netty.request.body.NettyByteBufferBody;
+import org.asynchttpclient.netty.request.body.NettyCompositeByteArrayBody;
+import org.asynchttpclient.netty.request.body.NettyDirectBody;
+import org.asynchttpclient.netty.request.body.NettyFileBody;
+import org.asynchttpclient.netty.request.body.NettyInputStreamBody;
+import org.asynchttpclient.netty.request.body.NettyMultipartBody;
+import org.asynchttpclient.proxy.ProxyServer;
+import org.asynchttpclient.request.body.generator.FileBodyGenerator;
+import org.asynchttpclient.request.body.generator.InputStreamBodyGenerator;
+import org.asynchttpclient.uri.Uri;
+import org.asynchttpclient.util.HttpUtils;
+import org.asynchttpclient.util.StringUtils;
+import org.jboss.netty.buffer.ChannelBuffer;
+import org.jboss.netty.handler.codec.http.DefaultHttpRequest;
+import org.jboss.netty.handler.codec.http.HttpHeaders;
+import org.jboss.netty.handler.codec.http.HttpMethod;
+import org.jboss.netty.handler.codec.http.HttpRequest;
+import org.jboss.netty.handler.codec.http.HttpVersion;
+
+public final class NettyRequestFactory extends NettyRequestFactoryBase {
+
+    public static final String GZIP_DEFLATE = HttpHeaders.Values.GZIP + "," + HttpHeaders.Values.DEFLATE;
+
+    public NettyRequestFactory(AsyncHttpClientConfig config) {
+        super(config);
+    }
+
+    private NettyBody body(Request request, boolean connect) {
+        NettyBody nettyBody = null;
+        if (!connect) {
+
+            Charset bodyCharset = request.getBodyCharset() == null ? DEFAULT_CHARSET : request.getBodyCharset();
+
+            if (request.getByteData() != null)
+                nettyBody = new NettyByteArrayBody(request.getByteData());
+
+            else if (request.getCompositeByteData() != null)
+                nettyBody = new NettyCompositeByteArrayBody(request.getCompositeByteData());
+
+            else if (request.getStringData() != null)
+                nettyBody = new NettyByteBufferBody(StringUtils.charSequence2ByteBuffer(request.getStringData(), bodyCharset));
+
+            else if (request.getByteBufferData() != null)
+                nettyBody = new NettyByteBufferBody(request.getByteBufferData());
+
+            else if (request.getStreamData() != null)
+                nettyBody = new NettyInputStreamBody(request.getStreamData(), config);
+
+            else if (isNonEmpty(request.getFormParams())) {
+
+                String contentType = null;
+                if (!request.getHeaders().containsKey(CONTENT_TYPE))
+                    contentType = HttpHeaders.Values.APPLICATION_X_WWW_FORM_URLENCODED;
+
+                nettyBody = new NettyByteBufferBody(urlEncodeFormParams(request.getFormParams(), bodyCharset), contentType);
+
+            } else if (isNonEmpty(request.getParts()))
+                nettyBody = new NettyMultipartBody(request.getParts(), request.getHeaders(), config);
+
+            else if (request.getFile() != null)
+                nettyBody = new NettyFileBody(request.getFile(), config);
+
+            else if (request.getBodyGenerator() instanceof FileBodyGenerator) {
+                FileBodyGenerator fileBodyGenerator = (FileBodyGenerator) request.getBodyGenerator();
+                nettyBody = new NettyFileBody(fileBodyGenerator.getFile(), fileBodyGenerator.getRegionSeek(), fileBodyGenerator.getRegionLength(), config);
+
+            } else if (request.getBodyGenerator() instanceof InputStreamBodyGenerator)
+                nettyBody = new NettyInputStreamBody(InputStreamBodyGenerator.class.cast(request.getBodyGenerator()).getInputStream(), config);
+
+            else if (request.getBodyGenerator() != null)
+                nettyBody = new NettyBodyBody(request.getBodyGenerator().createBody(), config);
+        }
+
+        return nettyBody;
+    }
+
+    public void addAuthorizationHeader(HttpHeaders headers, String authorizationHeader) {
+        if (authorizationHeader != null)
+            // don't override authorization but append
+            headers.add(AUTHORIZATION, authorizationHeader);
+    }
+
+    public void setProxyAuthorizationHeader(HttpHeaders headers, String proxyAuthorizationHeader) {
+        if (proxyAuthorizationHeader != null)
+            headers.set(PROXY_AUTHORIZATION, proxyAuthorizationHeader);
+    }
+
+    public NettyRequest newNettyRequest(Request request, boolean forceConnect, ProxyServer proxyServer) {
+
+        Uri uri = request.getUri();
+        HttpMethod method = forceConnect ? HttpMethod.CONNECT : HttpMethod.valueOf(request.getMethod());
+        boolean connect = method == HttpMethod.CONNECT;
+
+        boolean allowConnectionPooling = config.isAllowPoolingConnections() && (!HttpUtils.isSecure(uri) || config.isAllowPoolingSslConnections());
+
+        HttpVersion httpVersion = !allowConnectionPooling || (connect && proxyServer.isForceHttp10()) ? HttpVersion.HTTP_1_0 : HttpVersion.HTTP_1_1;
+        String requestUri = requestUri(uri, proxyServer, connect);
+
+        NettyBody body = body(request, connect);
+
+        HttpRequest httpRequest;
+        NettyRequest nettyRequest;
+        if (body instanceof NettyDirectBody) {
+            ChannelBuffer buffer = NettyDirectBody.class.cast(body).channelBuffer();
+            httpRequest = new DefaultHttpRequest(httpVersion, method, requestUri);
+            // body is passed as null as it's written directly with the request
+            httpRequest.setContent(buffer);
+            nettyRequest = new NettyRequest(httpRequest, null);
+
+        } else {
+            httpRequest = new DefaultHttpRequest(httpVersion, method, requestUri);
+            nettyRequest = new NettyRequest(httpRequest, body);
+        }
+
+        HttpHeaders headers = httpRequest.headers();
+
+        if (!connect) {
+            // assign headers as configured on request
+            for (Entry<String, List<String>> header : request.getHeaders()) {
+                headers.set(header.getKey(), header.getValue());
+            }
+
+            if (isNonEmpty(request.getCookies()))
+                headers.set(COOKIE, CookieEncoder.encode(request.getCookies()));
+
+            if (config.isCompressionEnforced() && !headers.contains(ACCEPT_ENCODING))
+                headers.set(ACCEPT_ENCODING, GZIP_DEFLATE);
+        }
+
+        if (body != null) {
+            if (body.getContentLength() < 0)
+                headers.set(TRANSFER_ENCODING, HttpHeaders.Values.CHUNKED);
+            else
+                headers.set(CONTENT_LENGTH, body.getContentLength());
+
+            if (body.getContentType() != null)
+                headers.set(CONTENT_TYPE, body.getContentType());
+        }
+
+        // connection header and friends
+        boolean webSocket = isWebSocket(uri.getScheme());
+        if (!connect && webSocket) {
+            String origin = "http://" + uri.getHost() + ":" + (uri.getPort() == -1 ? isSecure(uri.getScheme()) ? 443 : 80 : uri.getPort());
+            headers.set(UPGRADE, HttpHeaders.Values.WEBSOCKET)//
+                    .set(CONNECTION, HttpHeaders.Values.UPGRADE)//
+                    .set(ORIGIN, origin)//
+                    .set(SEC_WEBSOCKET_KEY, getKey())//
+                    .set(SEC_WEBSOCKET_VERSION, "13");
+
+        } else if (!headers.contains(CONNECTION)) {
+            String connectionHeaderValue = connectionHeader(allowConnectionPooling, httpVersion == HttpVersion.HTTP_1_1);
+            if (connectionHeaderValue != null)
+                headers.set(CONNECTION, connectionHeaderValue);
+        }
+
+        if (!headers.contains(HOST))
+            headers.set(HOST, hostHeader(request, uri));
+
+        Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
+
+        // don't override authorization but append
+        addAuthorizationHeader(headers, perRequestAuthorizationHeader(request, realm));
+
+        setProxyAuthorizationHeader(headers, perRequestProxyAuthorizationHeader(request, proxyServer, realm, connect));
+
+        // Add default accept headers
+        if (!headers.contains(ACCEPT))
+            headers.set(ACCEPT, "*/*");
+
+        // Add default user agent
+        if (!headers.contains(USER_AGENT) && config.getUserAgent() != null)
+            headers.set(USER_AGENT, config.getUserAgent());
+
+        return nettyRequest;
+    }
+}
diff --git a/providers/netty3/src/main/java/org/asynchttpclient/netty/request/NettyRequestSender.java b/providers/netty3/src/main/java/org/asynchttpclient/netty/request/NettyRequestSender.java
new file mode 100644
index 000000000..1d3b334db
--- /dev/null
+++ b/providers/netty3/src/main/java/org/asynchttpclient/netty/request/NettyRequestSender.java
@@ -0,0 +1,514 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.request;
+
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.REMOTELY_CLOSED_EXCEPTION;
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.getExplicitPort;
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.requestTimeout;
+import static org.asynchttpclient.util.AuthenticatorUtils.perConnectionAuthorizationHeader;
+import static org.asynchttpclient.util.AuthenticatorUtils.perConnectionProxyAuthorizationHeader;
+import static org.asynchttpclient.util.HttpUtils.WS;
+import static org.asynchttpclient.util.HttpUtils.useProxyConnect;
+import static org.asynchttpclient.util.ProxyUtils.avoidProxy;
+import static org.asynchttpclient.util.ProxyUtils.getProxyServer;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.UnknownHostException;
+import java.util.Map;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
+import org.asynchttpclient.ListenableFuture;
+import org.asynchttpclient.Realm;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.filter.FilterContext;
+import org.asynchttpclient.filter.FilterException;
+import org.asynchttpclient.filter.IOExceptionFilter;
+import org.asynchttpclient.handler.AsyncHandlerExtensions;
+import org.asynchttpclient.handler.TransferCompletionHandler;
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.channel.ChannelManager;
+import org.asynchttpclient.netty.channel.Channels;
+import org.asynchttpclient.netty.channel.NettyConnectListener;
+import org.asynchttpclient.netty.timeout.ReadTimeoutTimerTask;
+import org.asynchttpclient.netty.timeout.RequestTimeoutTimerTask;
+import org.asynchttpclient.netty.timeout.TimeoutsHolder;
+import org.asynchttpclient.proxy.ProxyServer;
+import org.asynchttpclient.uri.Uri;
+import org.asynchttpclient.ws.WebSocketUpgradeHandler;
+import org.jboss.netty.bootstrap.ClientBootstrap;
+import org.jboss.netty.channel.Channel;
+import org.jboss.netty.channel.ChannelFuture;
+import org.jboss.netty.handler.codec.http.HttpHeaders;
+import org.jboss.netty.handler.codec.http.HttpMethod;
+import org.jboss.netty.handler.codec.http.HttpRequest;
+import org.jboss.netty.util.Timeout;
+import org.jboss.netty.util.Timer;
+import org.jboss.netty.util.TimerTask;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public final class NettyRequestSender {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(NettyRequestSender.class);
+
+    private final AsyncHttpClientConfig config;
+    private final ChannelManager channelManager;
+    private final Timer nettyTimer;
+    private final AtomicBoolean closed;
+    private final NettyRequestFactory requestFactory;
+
+    public NettyRequestSender(AsyncHttpClientConfig config,//
+            ChannelManager channelManager,//
+            Timer nettyTimer,//
+            AtomicBoolean closed) {
+        this.config = config;
+        this.channelManager = channelManager;
+        this.nettyTimer = nettyTimer;
+        this.closed = closed;
+        requestFactory = new NettyRequestFactory(config);
+    }
+
+    public <T> ListenableFuture<T> sendRequest(final Request request,//
+            final AsyncHandler<T> asyncHandler,//
+            NettyResponseFuture<T> future,//
+            boolean reclaimCache) {
+
+        if (closed.get())
+            throw new IllegalStateException("Closed");
+
+        validateWebSocketRequest(request, asyncHandler);
+
+        ProxyServer proxyServer = getProxyServer(config, request);
+        boolean resultOfAConnect = future != null && future.getNettyRequest() != null && future.getNettyRequest().getHttpRequest().getMethod() == HttpMethod.CONNECT;
+        boolean useProxy = proxyServer != null && !resultOfAConnect;
+
+        if (useProxy && useProxyConnect(request.getUri()))
+            // SSL proxy, have to handle CONNECT
+            if (future != null && future.isConnectAllowed())
+                // CONNECT forced
+                return sendRequestWithCertainForceConnect(request, asyncHandler, future, reclaimCache, proxyServer, true, true);
+            else
+                return sendRequestThroughSslProxy(request, asyncHandler, future, reclaimCache, proxyServer);
+        else
+            return sendRequestWithCertainForceConnect(request, asyncHandler, future, reclaimCache, proxyServer, useProxy, false);
+    }
+
+    /**
+     * We know for sure if we have to force to connect or not, so we can build
+     * the HttpRequest right away This reduces the probability of having a
+     * pooled channel closed by the server by the time we build the request
+     */
+    private <T> ListenableFuture<T> sendRequestWithCertainForceConnect(//
+            Request request,//
+            AsyncHandler<T> asyncHandler,//
+            NettyResponseFuture<T> future,//
+            boolean reclaimCache,//
+            ProxyServer proxyServer,//
+            boolean useProxy,//
+            boolean forceConnect) {
+        NettyResponseFuture<T> newFuture = newNettyRequestAndResponseFuture(request, asyncHandler, future, proxyServer, forceConnect);
+
+        Channel channel = getCachedChannel(future, request, proxyServer, asyncHandler);
+
+        if (Channels.isChannelValid(channel))
+            return sendRequestWithCachedChannel(request, proxyServer, newFuture, asyncHandler, channel);
+        else
+            return sendRequestWithNewChannel(request, proxyServer, useProxy, newFuture, asyncHandler, reclaimCache);
+    }
+
+    /**
+     * Using CONNECT depends on wither we can fetch a valid channel or not Loop
+     * until we get a valid channel from the pool and it's still valid once the
+     * request is built
+     */
+    @SuppressWarnings("unused")
+    private <T> ListenableFuture<T> sendRequestThroughSslProxy(//
+            Request request,//
+            AsyncHandler<T> asyncHandler,//
+            NettyResponseFuture<T> future,//
+            boolean reclaimCache,//
+            ProxyServer proxyServer) {
+
+        NettyResponseFuture<T> newFuture = null;
+        for (int i = 0; i < 3; i++) {
+            Channel channel = getCachedChannel(future, request, proxyServer, asyncHandler);
+            if (Channels.isChannelValid(channel))
+                if (newFuture == null)
+                    newFuture = newNettyRequestAndResponseFuture(request, asyncHandler, future, proxyServer, false);
+
+            if (Channels.isChannelValid(channel))
+                // if the channel is still active, we can use it, otherwise try
+                // gain
+                return sendRequestWithCachedChannel(request, proxyServer, newFuture, asyncHandler, channel);
+            else
+                // pool is empty
+                break;
+        }
+
+        newFuture = newNettyRequestAndResponseFuture(request, asyncHandler, future, proxyServer, true);
+        return sendRequestWithNewChannel(request, proxyServer, true, newFuture, asyncHandler, reclaimCache);
+    }
+
+    private <T> NettyResponseFuture<T> newNettyRequestAndResponseFuture(final Request request, final AsyncHandler<T> asyncHandler, NettyResponseFuture<T> originalFuture,
+            ProxyServer proxy, boolean forceConnect) {
+
+        NettyRequest nettyRequest = requestFactory.newNettyRequest(request, forceConnect, proxy);
+
+        if (originalFuture == null) {
+            return newNettyResponseFuture(request, asyncHandler, nettyRequest, proxy);
+        } else {
+            originalFuture.setNettyRequest(nettyRequest);
+            originalFuture.setRequest(request);
+            return originalFuture;
+        }
+    }
+
+    private Channel getCachedChannel(NettyResponseFuture<?> future, Request request, ProxyServer proxyServer, AsyncHandler<?> asyncHandler) {
+
+        if (future != null && future.reuseChannel() && Channels.isChannelValid(future.channel()))
+            return future.channel();
+        else
+            return pollAndVerifyCachedChannel(request, proxyServer, asyncHandler);
+    }
+
+    private <T> ListenableFuture<T> sendRequestWithCachedChannel(Request request, ProxyServer proxy, NettyResponseFuture<T> future, AsyncHandler<T> asyncHandler, Channel channel) {
+
+        if (asyncHandler instanceof AsyncHandlerExtensions)
+            AsyncHandlerExtensions.class.cast(asyncHandler).onConnectionPooled(channel);
+
+        future.setState(NettyResponseFuture.STATE.POOLED);
+        future.attachChannel(channel, false);
+
+        LOGGER.debug("Using cached Channel {} for {} '{}'", channel, future.getNettyRequest().getHttpRequest().getMethod(), future.getNettyRequest().getHttpRequest().getUri());
+
+        if (Channels.isChannelValid(channel)) {
+            Channels.setAttribute(channel, future);
+
+            writeRequest(future, channel);
+        } else {
+            // bad luck, the channel was closed in-between
+            // there's a very good chance onClose was already notified but the
+            // future wasn't already registered
+            handleUnexpectedClosedChannel(channel, future);
+        }
+
+        return future;
+    }
+
+    private <T> ListenableFuture<T> sendRequestWithNewChannel(//
+            Request request,//
+            ProxyServer proxy,//
+            boolean useProxy,//
+            NettyResponseFuture<T> future,//
+            AsyncHandler<T> asyncHandler,//
+            boolean reclaimCache) {
+
+        // some headers are only set when performing the first request
+        HttpHeaders headers = future.getNettyRequest().getHttpRequest().headers();
+        Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
+        boolean connect = future.getNettyRequest().getHttpRequest().getMethod() == HttpMethod.CONNECT;
+        requestFactory.addAuthorizationHeader(headers, perConnectionAuthorizationHeader(request, proxy, realm));
+        requestFactory.setProxyAuthorizationHeader(headers, perConnectionProxyAuthorizationHeader(request, proxy, connect));
+
+        // Do not throw an exception when we need an extra connection for a
+        // redirect
+        // FIXME why? This violate the max connection per host handling, right?
+        ClientBootstrap bootstrap = channelManager.getBootstrap(request.getUri().getScheme(), useProxy);
+
+        boolean channelPreempted = false;
+        Object partitionKey = future.getPartitionKey();
+
+        try {
+            // Do not throw an exception when we need an extra connection for a
+            // redirect.
+            if (!reclaimCache) {
+                channelManager.preemptChannel(partitionKey);
+                channelPreempted = true;
+            }
+
+            if (asyncHandler instanceof AsyncHandlerExtensions)
+                AsyncHandlerExtensions.class.cast(asyncHandler).onConnectionOpen();
+
+            ChannelFuture channelFuture = connect(request, proxy, useProxy, bootstrap, asyncHandler);
+            channelFuture.addListener(new NettyConnectListener<T>(future, this, channelManager, channelPreempted, partitionKey));
+
+        } catch (Throwable t) {
+            if (channelPreempted)
+                channelManager.abortChannelPreemption(partitionKey);
+
+            abort(null, future, t.getCause() == null ? t : t.getCause());
+        }
+
+        return future;
+    }
+
+    private <T> NettyResponseFuture<T> newNettyResponseFuture(Request request, AsyncHandler<T> asyncHandler, NettyRequest nettyRequest, ProxyServer proxyServer) {
+
+        NettyResponseFuture<T> future = new NettyResponseFuture<>(//
+                request,//
+                asyncHandler,//
+                nettyRequest,//
+                config.getMaxRequestRetry(),//
+                request.getConnectionPoolPartitioning(),//
+                proxyServer);
+
+        String expectHeader = request.getHeaders().getFirstValue(HttpHeaders.Names.EXPECT);
+        if (expectHeader != null && expectHeader.equalsIgnoreCase(HttpHeaders.Values.CONTINUE))
+            future.setDontWriteBodyBecauseExpectContinue(true);
+        return future;
+    }
+
+    public <T> void writeRequest(NettyResponseFuture<T> future, Channel channel) {
+
+        NettyRequest nettyRequest = future.getNettyRequest();
+        HttpRequest httpRequest = nettyRequest.getHttpRequest();
+        AsyncHandler<T> handler = future.getAsyncHandler();
+
+        // if the channel is dead because it was pooled and the remote
+        // server decided to close it,
+        // we just let it go and the channelInactive do its work
+        if (!Channels.isChannelValid(channel))
+            return;
+
+        try {
+            if (handler instanceof TransferCompletionHandler)
+                configureTransferAdapter(handler, httpRequest);
+
+            if (!future.isHeadersAlreadyWrittenOnContinue()) {
+                if (future.getAsyncHandler() instanceof AsyncHandlerExtensions)
+                    AsyncHandlerExtensions.class.cast(future.getAsyncHandler()).onRequestSend(nettyRequest);
+                channel.write(httpRequest).addListener(new ProgressListener(config, future.getAsyncHandler(), future, true));
+            }
+
+            if (!future.isDontWriteBodyBecauseExpectContinue() && httpRequest.getMethod() != HttpMethod.CONNECT && nettyRequest.getBody() != null)
+                nettyRequest.getBody().write(channel, future);
+
+            // don't bother scheduling timeouts if channel became invalid
+            if (Channels.isChannelValid(channel))
+                scheduleTimeouts(future);
+
+        } catch (Exception e) {
+            LOGGER.error("Can't write request", e);
+            abort(channel, future, e);
+        }
+    }
+
+    private InetSocketAddress remoteAddress(Request request, ProxyServer proxy, boolean useProxy) throws UnknownHostException {
+
+        InetAddress address;
+        Uri uri = request.getUri();
+        int port = getExplicitPort(uri);
+
+        if (request.getInetAddress() != null) {
+            address = request.getInetAddress();
+
+        } else if (!useProxy || avoidProxy(proxy, uri.getHost())) {
+            address = request.getNameResolver().resolve(uri.getHost());
+
+        } else {
+            address = request.getNameResolver().resolve(proxy.getHost());
+            port = proxy.getPort();
+        }
+
+        return new InetSocketAddress(address, port);
+    }
+
+    private ChannelFuture connect(Request request, ProxyServer proxy, boolean useProxy, ClientBootstrap bootstrap, AsyncHandler<?> asyncHandler) throws UnknownHostException {
+        InetSocketAddress remoteAddress = remoteAddress(request, proxy, useProxy);
+
+        if (asyncHandler instanceof AsyncHandlerExtensions)
+            AsyncHandlerExtensions.class.cast(asyncHandler).onDnsResolved(remoteAddress.getAddress());
+
+        if (request.getLocalAddress() != null)
+            return bootstrap.connect(remoteAddress, new InetSocketAddress(request.getLocalAddress(), 0));
+        else
+            return bootstrap.connect(remoteAddress);
+    }
+
+    private void configureTransferAdapter(AsyncHandler<?> handler, HttpRequest httpRequest) {
+        FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
+        for (Map.Entry<String, String> entries : httpRequest.headers()) {
+            h.add(entries.getKey(), entries.getValue());
+        }
+
+        TransferCompletionHandler transferCompletionHandler = (TransferCompletionHandler) handler;
+        transferCompletionHandler.patchForNetty3();
+        transferCompletionHandler.headers(h);
+    }
+
+    private void scheduleTimeouts(NettyResponseFuture<?> nettyResponseFuture) {
+
+        nettyResponseFuture.touch();
+        int requestTimeoutInMs = requestTimeout(config, nettyResponseFuture.getRequest());
+        TimeoutsHolder timeoutsHolder = new TimeoutsHolder();
+        if (requestTimeoutInMs != -1) {
+            Timeout requestTimeout = newTimeout(new RequestTimeoutTimerTask(nettyResponseFuture, this, timeoutsHolder, requestTimeoutInMs), requestTimeoutInMs);
+            timeoutsHolder.requestTimeout = requestTimeout;
+        }
+
+        int readTimeoutValue = config.getReadTimeout();
+        if (readTimeoutValue != -1 && readTimeoutValue < requestTimeoutInMs) {
+            // no need for a readTimeout that's less than the requestTimeout
+            Timeout readTimeout = newTimeout(new ReadTimeoutTimerTask(nettyResponseFuture, this, timeoutsHolder, requestTimeoutInMs, readTimeoutValue), readTimeoutValue);
+            timeoutsHolder.readTimeout = readTimeout;
+        }
+        nettyResponseFuture.setTimeoutsHolder(timeoutsHolder);
+    }
+
+    public Timeout newTimeout(TimerTask task, long delay) {
+        return nettyTimer.newTimeout(task, delay, TimeUnit.MILLISECONDS);
+    }
+
+    public void abort(Channel channel, NettyResponseFuture<?> future, Throwable t) {
+
+        if (channel != null)
+            channelManager.closeChannel(channel);
+
+        if (!future.isDone()) {
+            future.setState(NettyResponseFuture.STATE.CLOSED);
+            LOGGER.debug("Aborting Future {}\n", future);
+            LOGGER.debug(t.getMessage(), t);
+            future.abort(t);
+        }
+    }
+
+    public void handleUnexpectedClosedChannel(Channel channel, NettyResponseFuture<?> future) {
+        if (future.isDone())
+            channelManager.closeChannel(channel);
+
+        else if (!retry(future))
+            abort(channel, future, REMOTELY_CLOSED_EXCEPTION);
+    }
+
+    public boolean retry(NettyResponseFuture<?> future) {
+
+        if (isClosed())
+            return false;
+
+        if (future.canBeReplayed()) {
+            future.setState(NettyResponseFuture.STATE.RECONNECTED);
+            future.getAndSetStatusReceived(false);
+
+            LOGGER.debug("Trying to recover request {}\n", future.getNettyRequest().getHttpRequest());
+            if (future.getAsyncHandler() instanceof AsyncHandlerExtensions) {
+                AsyncHandlerExtensions.class.cast(future.getAsyncHandler()).onRetry();
+            }
+
+            try {
+                sendNextRequest(future.getRequest(), future);
+                return true;
+
+            } catch (Exception e) {
+                abort(future.channel(), future, e);
+                return false;
+            }
+        } else {
+            LOGGER.debug("Unable to recover future {}\n", future);
+            return false;
+        }
+    }
+
+    public boolean applyIoExceptionFiltersAndReplayRequest(NettyResponseFuture<?> future, IOException e, Channel channel) {
+
+        boolean replayed = false;
+
+        @SuppressWarnings({ "unchecked", "rawtypes" })
+        FilterContext<?> fc = new FilterContext.FilterContextBuilder().asyncHandler(future.getAsyncHandler()).request(future.getRequest()).ioException(e).build();
+        for (IOExceptionFilter asyncFilter : config.getIOExceptionFilters()) {
+            try {
+                fc = asyncFilter.filter(fc);
+                if (fc == null) {
+                    throw new NullPointerException("FilterContext is null");
+                }
+            } catch (FilterException efe) {
+                abort(channel, future, efe);
+            }
+        }
+
+        if (fc.replayRequest() && future.canBeReplayed()) {
+            replayRequest(future, fc, channel);
+            replayed = true;
+        }
+        return replayed;
+    }
+
+    public <T> void sendNextRequest(Request request, NettyResponseFuture<T> future) {
+        sendRequest(request, future.getAsyncHandler(), future, true);
+    }
+
+    private void validateWebSocketRequest(Request request, AsyncHandler<?> asyncHandler) {
+        Uri uri = request.getUri();
+        boolean isWs = uri.getScheme().startsWith(WS);
+        if (asyncHandler instanceof WebSocketUpgradeHandler) {
+            if (!isWs)
+                throw new IllegalArgumentException("WebSocketUpgradeHandler but scheme isn't ws or wss: " + uri.getScheme());
+            else if (!request.getMethod().equals(HttpMethod.GET.getName()))
+                throw new IllegalArgumentException("WebSocketUpgradeHandler but method isn't GET: " + request.getMethod());
+        } else if (isWs) {
+            throw new IllegalArgumentException("No WebSocketUpgradeHandler but scheme is " + uri.getScheme());
+        }
+    }
+
+    public Channel pollAndVerifyCachedChannel(Request request, ProxyServer proxy, AsyncHandler<?> asyncHandler) {
+
+        if (asyncHandler instanceof AsyncHandlerExtensions)
+            AsyncHandlerExtensions.class.cast(asyncHandler).onConnectionPool();
+
+        Uri uri = request.getUri();
+        String virtualHost = request.getVirtualHost();
+        final Channel channel = channelManager.poll(uri, virtualHost, proxy, request.getConnectionPoolPartitioning());
+
+        if (channel != null) {
+            LOGGER.debug("Using cached Channel {}\n for uri {}\n", channel, uri);
+
+            try {
+                // Always make sure the channel who got cached support the
+                // proper protocol. It could
+                // only occurs when a HttpMethod.CONNECT is used against a proxy
+                // that requires upgrading from http to
+                // https.
+                channelManager.verifyChannelPipeline(channel.getPipeline(), uri, virtualHost);
+            } catch (Exception ex) {
+                LOGGER.debug(ex.getMessage(), ex);
+            }
+        }
+        return channel;
+    }
+
+    @SuppressWarnings({ "rawtypes", "unchecked" })
+    public void replayRequest(final NettyResponseFuture<?> future, FilterContext fc, Channel channel) {
+
+        final Request newRequest = fc.getRequest();
+        future.setAsyncHandler(fc.getAsyncHandler());
+        future.setState(NettyResponseFuture.STATE.NEW);
+        future.touch();
+
+        LOGGER.debug("\n\nReplaying Request {}\n for Future {}\n", newRequest, future);
+        if (future.getAsyncHandler() instanceof AsyncHandlerExtensions)
+            AsyncHandlerExtensions.class.cast(future.getAsyncHandler()).onRetry();
+
+        channelManager.drainChannelAndOffer(channel, future);
+        sendNextRequest(newRequest, future);
+        return;
+    }
+
+    public boolean isClosed() {
+        return closed.get();
+    }
+}
diff --git a/providers/netty3/src/main/java/org/asynchttpclient/netty/request/ProgressListener.java b/providers/netty3/src/main/java/org/asynchttpclient/netty/request/ProgressListener.java
new file mode 100644
index 000000000..21fc6f05a
--- /dev/null
+++ b/providers/netty3/src/main/java/org/asynchttpclient/netty/request/ProgressListener.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.request;
+
+import java.nio.channels.ClosedChannelException;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Realm;
+import org.asynchttpclient.handler.ProgressAsyncHandler;
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.channel.Channels;
+import org.asynchttpclient.netty.future.StackTraceInspector;
+import org.jboss.netty.channel.Channel;
+import org.jboss.netty.channel.ChannelFuture;
+import org.jboss.netty.channel.ChannelFutureProgressListener;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class ProgressListener implements ChannelFutureProgressListener {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(ProgressListener.class);
+
+    private final AsyncHttpClientConfig config;
+    private final boolean notifyHeaders;
+    private final AsyncHandler<?> asyncHandler;
+    private final NettyResponseFuture<?> future;
+
+    public ProgressListener(AsyncHttpClientConfig config,//
+            AsyncHandler<?> asyncHandler,//
+            NettyResponseFuture<?> future,//
+            boolean notifyHeaders) {
+        this.config = config;
+        this.asyncHandler = asyncHandler;
+        this.future = future;
+        this.notifyHeaders = notifyHeaders;
+    }
+
+    private boolean abortOnThrowable(Throwable cause, Channel channel) {
+        if (cause != null && future.getState() != NettyResponseFuture.STATE.NEW) {
+            // The write operation failed. If the channel was cached, it means it got asynchronously closed.
+            // Let's retry a second time.
+            if (cause instanceof IllegalStateException || cause instanceof ClosedChannelException || StackTraceInspector.recoverOnReadOrWriteException(cause)) {
+                LOGGER.debug(cause == null ? "" : cause.getMessage(), cause);
+                Channels.silentlyCloseChannel(channel);
+
+            } else {
+                future.abort(cause);
+            }
+            return true;
+        }
+        return false;
+    }
+    
+    public void operationComplete(ChannelFuture cf) {
+
+        if (!abortOnThrowable(cf.getCause(), cf.getChannel())) {
+            future.touch();
+
+            /**
+             * We need to make sure we aren't in the middle of an authorization process before publishing events as we will re-publish again the same event after the authorization,
+             * causing unpredictable behavior.
+             */
+            Realm realm = future.getRequest().getRealm() != null ? future.getRequest().getRealm() : config.getRealm();
+            boolean startPublishing = future.isInAuth() || realm == null || realm.getUsePreemptiveAuth();
+
+            if (startPublishing && asyncHandler instanceof ProgressAsyncHandler) {
+                if (notifyHeaders) {
+                    ProgressAsyncHandler.class.cast(asyncHandler).onHeadersWritten();
+                } else {
+                    ProgressAsyncHandler.class.cast(asyncHandler).onContentWritten();
+                }
+            }
+        }
+    }
+
+    public void operationProgressed(ChannelFuture cf, long amount, long current, long total) {
+        future.touch();
+        if (asyncHandler instanceof ProgressAsyncHandler) {
+            ProgressAsyncHandler.class.cast(asyncHandler).onContentWriteProgress(amount, current, total);
+        }
+    }
+}
\ No newline at end of file
diff --git a/providers/netty3/src/main/java/org/asynchttpclient/netty/request/body/BodyChunkedInput.java b/providers/netty3/src/main/java/org/asynchttpclient/netty/request/body/BodyChunkedInput.java
new file mode 100644
index 000000000..49bef830e
--- /dev/null
+++ b/providers/netty3/src/main/java/org/asynchttpclient/netty/request/body/BodyChunkedInput.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.request.body;
+
+import java.nio.ByteBuffer;
+
+import org.asynchttpclient.request.body.Body;
+import org.jboss.netty.buffer.ChannelBuffers;
+import org.jboss.netty.handler.stream.ChunkedInput;
+
+/**
+ * Adapts a {@link Body} to Netty's {@link ChunkedInput}.
+ */
+public class BodyChunkedInput implements ChunkedInput {
+
+    private static final int DEFAULT_CHUNK_SIZE = 8 * 1024;
+
+    private final Body body;
+    private final int contentLength;
+    private final int chunkSize;
+
+    private boolean endOfInput;
+
+    public BodyChunkedInput(Body body) {
+        if (body == null)
+            throw new NullPointerException("body");
+        this.body = body;
+        contentLength = (int) body.getContentLength();
+        if (contentLength <= 0)
+            chunkSize = DEFAULT_CHUNK_SIZE;
+        else
+            chunkSize = Math.min(contentLength, DEFAULT_CHUNK_SIZE);
+    }
+
+    public boolean hasNextChunk() throws Exception {
+        // unused
+        throw new UnsupportedOperationException();
+    }
+
+    public Object nextChunk() throws Exception {
+        if (endOfInput) {
+            return null;
+        } else {
+            ByteBuffer buffer = ByteBuffer.allocate(chunkSize);
+            Body.State state = body.read(buffer);
+            switch (state) {
+                case Stop:
+                    endOfInput = true;
+                    return null;
+                case Suspend:
+                    //this will suspend the stream in ChunkedWriteHandler
+                    return null;
+                case Continue:
+                    buffer.flip();
+                    return ChannelBuffers.wrappedBuffer(buffer);
+                default:
+                    throw new IllegalStateException("Unknown state: " + state);
+            }
+        }
+    }
+
+    public boolean isEndOfInput() throws Exception {
+        // called by ChunkedWriteHandler AFTER nextChunk
+        return endOfInput;
+    }
+
+    public void close() throws Exception {
+        body.close();
+    }
+}
diff --git a/providers/netty3/src/main/java/org/asynchttpclient/netty/request/body/BodyFileRegion.java b/providers/netty3/src/main/java/org/asynchttpclient/netty/request/body/BodyFileRegion.java
new file mode 100644
index 000000000..b62b546bb
--- /dev/null
+++ b/providers/netty3/src/main/java/org/asynchttpclient/netty/request/body/BodyFileRegion.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.request.body;
+
+import static org.asynchttpclient.util.MiscUtils.closeSilently;
+
+import java.io.IOException;
+import java.nio.channels.WritableByteChannel;
+
+import org.asynchttpclient.request.body.RandomAccessBody;
+import org.jboss.netty.channel.FileRegion;
+
+/**
+ * Adapts a {@link RandomAccessBody} to Netty's {@link FileRegion}.
+ */
+public class BodyFileRegion implements FileRegion {
+
+    private final RandomAccessBody body;
+
+    public BodyFileRegion(RandomAccessBody body) {
+        if (body == null)
+            throw new NullPointerException("body");
+        this.body = body;
+    }
+
+    public long getPosition() {
+        return 0;
+    }
+
+    public long getCount() {
+        return body.getContentLength();
+    }
+
+    public long transferTo(WritableByteChannel target, long position)
+            throws IOException {
+        return body.transferTo(position, target);
+    }
+
+    public void releaseExternalResources() {
+        closeSilently(body);
+    }
+}
diff --git a/providers/netty3/src/main/java/org/asynchttpclient/netty/request/body/NettyBody.java b/providers/netty3/src/main/java/org/asynchttpclient/netty/request/body/NettyBody.java
new file mode 100644
index 000000000..53d33cc79
--- /dev/null
+++ b/providers/netty3/src/main/java/org/asynchttpclient/netty/request/body/NettyBody.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.request.body;
+
+import java.io.IOException;
+
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.jboss.netty.channel.Channel;
+
+public interface NettyBody {
+
+    long getContentLength();
+
+    String getContentType();
+
+    void write(Channel channel, NettyResponseFuture<?> future) throws IOException;
+}
diff --git a/providers/netty3/src/main/java/org/asynchttpclient/netty/request/body/NettyBodyBody.java b/providers/netty3/src/main/java/org/asynchttpclient/netty/request/body/NettyBodyBody.java
new file mode 100644
index 000000000..7219a4eeb
--- /dev/null
+++ b/providers/netty3/src/main/java/org/asynchttpclient/netty/request/body/NettyBodyBody.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.request.body;
+
+import static org.asynchttpclient.util.MiscUtils.closeSilently;
+
+import java.io.IOException;
+
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.channel.ChannelManager;
+import org.asynchttpclient.netty.request.ProgressListener;
+import org.asynchttpclient.request.body.Body;
+import org.asynchttpclient.request.body.RandomAccessBody;
+import org.asynchttpclient.request.body.generator.BodyGenerator;
+import org.asynchttpclient.request.body.generator.FeedableBodyGenerator.FeedListener;
+import org.asynchttpclient.request.body.generator.FeedableBodyGenerator;
+import org.jboss.netty.channel.Channel;
+import org.jboss.netty.channel.ChannelFuture;
+import org.jboss.netty.handler.stream.ChunkedWriteHandler;
+
+public class NettyBodyBody implements NettyBody {
+
+    private final Body body;
+    private final AsyncHttpClientConfig config;
+
+    public NettyBodyBody(Body body, AsyncHttpClientConfig config) {
+        this.body = body;
+        this.config = config;
+    }
+
+    public Body getBody() {
+        return body;
+    }
+
+    @Override
+    public long getContentLength() {
+        return body.getContentLength();
+    }
+
+    @Override
+    public String getContentType() {
+        return null;
+    }
+
+    @Override
+    public void write(final Channel channel, final NettyResponseFuture<?> future) throws IOException {
+
+        Object msg;
+        if (body instanceof RandomAccessBody && !ChannelManager.isSslHandlerConfigured(channel.getPipeline()) && !config.isDisableZeroCopy()) {
+            msg = new BodyFileRegion((RandomAccessBody) body);
+
+        } else {
+            msg = new BodyChunkedInput(body);
+            
+            BodyGenerator bg = future.getRequest().getBodyGenerator();
+            if (bg instanceof FeedableBodyGenerator) {
+                final FeedableBodyGenerator feedableBodyGenerator = (FeedableBodyGenerator) bg;
+                feedableBodyGenerator.writeChunkBoundaries();
+                feedableBodyGenerator.setListener(new FeedListener() {
+                    @Override
+                    public void onContentAdded() {
+                        channel.getPipeline().get(ChunkedWriteHandler.class).resumeTransfer();
+                    }
+                    @Override
+                    public void onError(Throwable t) {
+                        future.abort(t);
+                    }
+                });
+            }
+        }
+        
+        channel.write(msg).addListener(new ProgressListener(config, future.getAsyncHandler(), future, false) {
+            public void operationComplete(ChannelFuture cf) {
+                closeSilently(body);
+                super.operationComplete(cf);
+            }
+        });
+    }
+}
diff --git a/providers/netty3/src/main/java/org/asynchttpclient/netty/request/body/NettyByteArrayBody.java b/providers/netty3/src/main/java/org/asynchttpclient/netty/request/body/NettyByteArrayBody.java
new file mode 100755
index 000000000..8e9be0ce2
--- /dev/null
+++ b/providers/netty3/src/main/java/org/asynchttpclient/netty/request/body/NettyByteArrayBody.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.request.body;
+
+import org.jboss.netty.buffer.ChannelBuffer;
+import org.jboss.netty.buffer.ChannelBuffers;
+
+public class NettyByteArrayBody extends NettyDirectBody {
+
+    private final byte[] bytes;
+    private final String contentType;
+
+    public NettyByteArrayBody(byte[] bytes) {
+        this(bytes, null);
+    }
+
+    public NettyByteArrayBody(byte[] bytes, String contentType) {
+        this.bytes = bytes;
+        this.contentType = contentType;
+    }
+
+    @Override
+    public long getContentLength() {
+        return bytes.length;
+    }
+
+    @Override
+    public String getContentType() {
+        return contentType;
+    }
+
+    @Override
+    public ChannelBuffer channelBuffer() {
+        return ChannelBuffers.wrappedBuffer(bytes);
+    }
+}
diff --git a/providers/netty3/src/main/java/org/asynchttpclient/netty/request/body/NettyByteBufferBody.java b/providers/netty3/src/main/java/org/asynchttpclient/netty/request/body/NettyByteBufferBody.java
new file mode 100644
index 000000000..80621c685
--- /dev/null
+++ b/providers/netty3/src/main/java/org/asynchttpclient/netty/request/body/NettyByteBufferBody.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.request.body;
+
+import org.jboss.netty.buffer.ChannelBuffer;
+import org.jboss.netty.buffer.ChannelBuffers;
+
+import java.nio.ByteBuffer;
+
+public class NettyByteBufferBody extends NettyDirectBody {
+
+    private final ByteBuffer bb;
+    private final String contentType;
+    private final long length;
+
+    public NettyByteBufferBody(ByteBuffer bb) {
+        this(bb, null);
+    }
+
+    public NettyByteBufferBody(ByteBuffer bb, String contentType) {
+        this.bb = bb;
+        length = bb.remaining();
+        bb.mark();
+        this.contentType = contentType;
+    }
+
+    @Override
+    public long getContentLength() {
+        return length;
+    }
+
+    @Override
+    public String getContentType() {
+        return contentType;
+    }
+
+    @Override
+    public ChannelBuffer channelBuffer() {
+        // for retry
+        bb.reset();
+        return ChannelBuffers.wrappedBuffer(bb);
+    }
+}
diff --git a/providers/netty3/src/main/java/org/asynchttpclient/netty/request/body/NettyCompositeByteArrayBody.java b/providers/netty3/src/main/java/org/asynchttpclient/netty/request/body/NettyCompositeByteArrayBody.java
new file mode 100644
index 000000000..21b2dc3f3
--- /dev/null
+++ b/providers/netty3/src/main/java/org/asynchttpclient/netty/request/body/NettyCompositeByteArrayBody.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.request.body;
+
+import java.util.List;
+
+import org.jboss.netty.buffer.ChannelBuffer;
+import org.jboss.netty.buffer.ChannelBuffers;
+
+public class NettyCompositeByteArrayBody extends NettyDirectBody {
+
+    private final byte[][] bytes;
+    private final String contentType;
+    private final long contentLength;
+
+    public NettyCompositeByteArrayBody(List<byte[]> bytes) {
+        this(bytes, null);
+    }
+
+    public NettyCompositeByteArrayBody(List<byte[]> bytes, String contentType) {
+        this.bytes = new byte[bytes.size()][];
+        bytes.toArray(this.bytes);
+        this.contentType = contentType;
+        long l = 0;
+        for (byte[] b : bytes)
+            l += b.length;
+        contentLength = l;
+    }
+
+    @Override
+    public long getContentLength() {
+        return contentLength;
+    }
+
+    @Override
+    public String getContentType() {
+        return contentType;
+    }
+
+    @Override
+    public ChannelBuffer channelBuffer() {
+        return ChannelBuffers.wrappedBuffer(bytes);
+    }
+}
diff --git a/providers/netty3/src/main/java/org/asynchttpclient/netty/request/body/NettyDirectBody.java b/providers/netty3/src/main/java/org/asynchttpclient/netty/request/body/NettyDirectBody.java
new file mode 100644
index 000000000..8dcb8917e
--- /dev/null
+++ b/providers/netty3/src/main/java/org/asynchttpclient/netty/request/body/NettyDirectBody.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.request.body;
+
+import java.io.IOException;
+
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.jboss.netty.buffer.ChannelBuffer;
+import org.jboss.netty.channel.Channel;
+
+public abstract class NettyDirectBody implements NettyBody {
+
+    public abstract ChannelBuffer channelBuffer();
+
+    @Override
+    public void write(Channel channel, NettyResponseFuture<?> future) throws IOException {
+        throw new UnsupportedOperationException("This kind of body is supposed to be writen directly");
+    }
+}
diff --git a/providers/netty3/src/main/java/org/asynchttpclient/netty/request/body/NettyFileBody.java b/providers/netty3/src/main/java/org/asynchttpclient/netty/request/body/NettyFileBody.java
new file mode 100644
index 000000000..7954ac1b9
--- /dev/null
+++ b/providers/netty3/src/main/java/org/asynchttpclient/netty/request/body/NettyFileBody.java
@@ -0,0 +1,93 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.request.body;
+
+import static org.asynchttpclient.util.MiscUtils.closeSilently;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.RandomAccessFile;
+
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.channel.ChannelManager;
+import org.asynchttpclient.netty.request.ProgressListener;
+import org.jboss.netty.channel.Channel;
+import org.jboss.netty.channel.ChannelFuture;
+import org.jboss.netty.channel.FileRegion;
+import org.jboss.netty.handler.stream.ChunkedFile;
+
+public class NettyFileBody implements NettyBody {
+
+    private final File file;
+    private final long offset;
+    private final long length;
+    private final AsyncHttpClientConfig config;
+
+    public NettyFileBody(File file, AsyncHttpClientConfig config) {
+        this(file, 0, file.length(), config);
+    }
+
+    public NettyFileBody(File file, long offset, long length, AsyncHttpClientConfig config) {
+        if (!file.isFile()) {
+            throw new IllegalArgumentException(String.format("File %s is not a file or doesn't exist", file.getAbsolutePath()));
+        }
+        this.file = file;
+        this.offset = offset;
+        this.length = length;
+        this.config = config;
+    }
+
+    public File getFile() {
+        return file;
+    }
+
+    public long getOffset() {
+        return offset;
+    }
+
+    @Override
+    public long getContentLength() {
+        return length;
+    }
+
+    @Override
+    public String getContentType() {
+        return null;
+    }
+
+    @Override
+    public void write(Channel channel, NettyResponseFuture<?> future) throws IOException {
+        final RandomAccessFile raf = new RandomAccessFile(file, "r");
+
+        try {
+            ChannelFuture writeFuture;
+            if (ChannelManager.isSslHandlerConfigured(channel.getPipeline()) || config.isDisableZeroCopy()) {
+                writeFuture = channel.write(new ChunkedFile(raf, offset, raf.length(), config.getChunkedFileChunkSize()));
+            } else {
+                final FileRegion region = new OptimizedFileRegion(raf, offset, raf.length());
+                writeFuture = channel.write(region);
+            }
+            writeFuture.addListener(new ProgressListener(config, future.getAsyncHandler(), future, false) {
+                public void operationComplete(ChannelFuture cf) {
+                    closeSilently(raf);
+                    super.operationComplete(cf);
+                }
+            });
+        } catch (IOException ex) {
+            closeSilently(raf);
+            throw ex;
+        }
+    }
+}
diff --git a/providers/netty3/src/main/java/org/asynchttpclient/netty/request/body/NettyInputStreamBody.java b/providers/netty3/src/main/java/org/asynchttpclient/netty/request/body/NettyInputStreamBody.java
new file mode 100644
index 000000000..570e37bbc
--- /dev/null
+++ b/providers/netty3/src/main/java/org/asynchttpclient/netty/request/body/NettyInputStreamBody.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.request.body;
+
+import static org.asynchttpclient.util.MiscUtils.closeSilently;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.request.ProgressListener;
+import org.asynchttpclient.request.body.Body;
+import org.asynchttpclient.request.body.generator.InputStreamBodyGenerator;
+import org.jboss.netty.channel.Channel;
+import org.jboss.netty.channel.ChannelFuture;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class NettyInputStreamBody implements NettyBody {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(NettyInputStreamBody.class);
+
+    private final InputStream inputStream;
+    private final AsyncHttpClientConfig config;
+
+    public NettyInputStreamBody(InputStream inputStream, AsyncHttpClientConfig config) {
+        this.inputStream = inputStream;
+        this.config = config;
+    }
+
+    public InputStream getInputStream() {
+        return inputStream;
+    }
+
+    @Override
+    public long getContentLength() {
+        return -1L;
+    }
+
+    @Override
+    public String getContentType() {
+        return null;
+    }
+
+    @Override
+    public void write(Channel channel, NettyResponseFuture<?> future) throws IOException {
+        final InputStream is = inputStream;
+
+        if (future.isStreamWasAlreadyConsumed()) {
+            if (is.markSupported())
+                is.reset();
+            else {
+                LOGGER.warn("Stream has already been consumed and cannot be reset");
+                return;
+            }
+        } else {
+            future.setStreamWasAlreadyConsumed(true);
+        }
+
+        InputStreamBodyGenerator generator = new InputStreamBodyGenerator(is);
+        // FIXME is this still usefull?
+        generator.patchNetty3ChunkingIssue(true);
+        final Body body = generator.createBody();
+        channel.write(new BodyChunkedInput(body)).addListener(new ProgressListener(config, future.getAsyncHandler(), future, false) {
+            public void operationComplete(ChannelFuture cf) {
+                closeSilently(body);
+                super.operationComplete(cf);
+            }
+        });
+        
+        // FIXME ChunkedStream is broken in Netty 3 but fixed in Netty 4
+//        channel.write(new ChunkedStream(is)).addListener(
+//                new ProgressListener(config, future.getAsyncHandler(), future, false) {
+//                    public void operationComplete(ChannelFuture cf) {
+//                        try {
+//                            is.close();
+//                        } catch (IOException e) {
+//                            LOGGER.warn("Failed to close request body: {}", e.getMessage(), e);
+//                        }
+//                        super.operationComplete(cf);
+//                    }
+//                });
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/NettyMultipartBody.java b/providers/netty3/src/main/java/org/asynchttpclient/netty/request/body/NettyMultipartBody.java
old mode 100755
new mode 100644
similarity index 66%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/NettyMultipartBody.java
rename to providers/netty3/src/main/java/org/asynchttpclient/netty/request/body/NettyMultipartBody.java
index 0c6944053..3990d1c85
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/NettyMultipartBody.java
+++ b/providers/netty3/src/main/java/org/asynchttpclient/netty/request/body/NettyMultipartBody.java
@@ -11,27 +11,26 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty.request.body;
-
-import static org.asynchttpclient.multipart.MultipartUtils.newMultipartBody;
+package org.asynchttpclient.netty.request.body;
 
 import java.util.List;
 
+import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
-import org.asynchttpclient.multipart.MultipartBody;
-import org.asynchttpclient.multipart.Part;
-import org.asynchttpclient.providers.netty.NettyAsyncHttpProviderConfig;
+import org.asynchttpclient.request.body.multipart.MultipartBody;
+import org.asynchttpclient.request.body.multipart.MultipartUtils;
+import org.asynchttpclient.request.body.multipart.Part;
 
 public class NettyMultipartBody extends NettyBodyBody {
 
     private final String contentType;
 
-    public NettyMultipartBody(List<Part> parts, FluentCaseInsensitiveStringsMap headers, NettyAsyncHttpProviderConfig nettyConfig) {
-        this(newMultipartBody(parts, headers), nettyConfig);
+    public NettyMultipartBody(List<Part> parts, FluentCaseInsensitiveStringsMap headers, AsyncHttpClientConfig config) {
+        this(MultipartUtils.newMultipartBody(parts, headers), config);
     }
 
-    private NettyMultipartBody(MultipartBody body, NettyAsyncHttpProviderConfig nettyConfig) {
-        super(body, nettyConfig);
+    private NettyMultipartBody(MultipartBody body, AsyncHttpClientConfig config) {
+        super(body, config);
         contentType = body.getContentType();
     }
 
diff --git a/providers/netty3/src/main/java/org/asynchttpclient/netty/request/body/OptimizedFileRegion.java b/providers/netty3/src/main/java/org/asynchttpclient/netty/request/body/OptimizedFileRegion.java
new file mode 100644
index 000000000..66aa34aff
--- /dev/null
+++ b/providers/netty3/src/main/java/org/asynchttpclient/netty/request/body/OptimizedFileRegion.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.request.body;
+
+import static org.asynchttpclient.util.MiscUtils.closeSilently;
+
+import java.io.IOException;
+import java.io.RandomAccessFile;
+import java.nio.channels.FileChannel;
+import java.nio.channels.WritableByteChannel;
+
+import org.jboss.netty.channel.FileRegion;
+
+public class OptimizedFileRegion implements FileRegion {
+
+    private final FileChannel file;
+    private final RandomAccessFile raf;
+    private final long position;
+    private final long count;
+    private long byteWritten;
+
+    public OptimizedFileRegion(RandomAccessFile raf, long position, long count) {
+        this.raf = raf;
+        this.file = raf.getChannel();
+        this.position = position;
+        this.count = count;
+    }
+
+    public long getPosition() {
+        return position;
+    }
+
+    public long getCount() {
+        return count;
+    }
+
+    public long transferTo(WritableByteChannel target, long position) throws IOException {
+        long count = this.count - position;
+        if (count < 0 || position < 0) {
+            throw new IllegalArgumentException("position out of range: " + position + " (expected: 0 - " + (this.count - 1) + ")");
+        }
+        if (count == 0) {
+            return 0L;
+        }
+
+        long bw = file.transferTo(this.position + position, count, target);
+        byteWritten += bw;
+        if (byteWritten == raf.length()) {
+            releaseExternalResources();
+        }
+        return bw;
+    }
+
+    public void releaseExternalResources() {
+        closeSilently(file);
+        closeSilently(raf);
+    }
+}
diff --git a/providers/netty3/src/main/java/org/asynchttpclient/netty/timeout/ReadTimeoutTimerTask.java b/providers/netty3/src/main/java/org/asynchttpclient/netty/timeout/ReadTimeoutTimerTask.java
new file mode 100644
index 000000000..ac5d610b1
--- /dev/null
+++ b/providers/netty3/src/main/java/org/asynchttpclient/netty/timeout/ReadTimeoutTimerTask.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.timeout;
+
+import static org.asynchttpclient.util.DateUtils.millisTime;
+
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.request.NettyRequestSender;
+import org.jboss.netty.util.Timeout;
+
+public class ReadTimeoutTimerTask extends TimeoutTimerTask {
+
+    private final long readTimeout;
+    private final long requestTimeoutInstant;
+
+    public ReadTimeoutTimerTask(//
+            NettyResponseFuture<?> nettyResponseFuture,//
+            NettyRequestSender requestSender,//
+            TimeoutsHolder timeoutsHolder,//
+            long requestTimeout,//
+            long readTimeout) {
+        super(nettyResponseFuture, requestSender, timeoutsHolder);
+        this.readTimeout = readTimeout;
+        requestTimeoutInstant = requestTimeout >= 0 ? nettyResponseFuture.getStart() + requestTimeout : Long.MAX_VALUE;
+    }
+
+    public void run(Timeout timeout) throws Exception {
+
+        if (done.getAndSet(true) || requestSender.isClosed())
+            return;
+        
+        if (nettyResponseFuture.isDone()) {
+            timeoutsHolder.cancel();
+            return;
+        }
+
+        long now = millisTime();
+
+        long currentReadTimeoutInstant = readTimeout + nettyResponseFuture.getLastTouch();
+        long durationBeforeCurrentReadTimeout = currentReadTimeoutInstant - now;
+
+        if (durationBeforeCurrentReadTimeout <= 0L) {
+            // readTimeout reached
+            String message = "Read timeout to " + remoteAddress + " of " + readTimeout + " ms";
+            long durationSinceLastTouch = now - nettyResponseFuture.getLastTouch();
+            expire(message, durationSinceLastTouch);
+            // cancel request timeout sibling
+            timeoutsHolder.cancel();
+
+        } else if (currentReadTimeoutInstant < requestTimeoutInstant) {
+            // reschedule
+            done.set(false);
+            timeoutsHolder.readTimeout = requestSender.newTimeout(this, durationBeforeCurrentReadTimeout);
+
+        } else {
+            // otherwise, no need to reschedule: requestTimeout will happen sooner
+            timeoutsHolder.readTimeout = null;
+        }
+    }
+}
diff --git a/providers/netty3/src/main/java/org/asynchttpclient/netty/timeout/RequestTimeoutTimerTask.java b/providers/netty3/src/main/java/org/asynchttpclient/netty/timeout/RequestTimeoutTimerTask.java
new file mode 100644
index 000000000..4495abc7a
--- /dev/null
+++ b/providers/netty3/src/main/java/org/asynchttpclient/netty/timeout/RequestTimeoutTimerTask.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.timeout;
+
+import static org.asynchttpclient.util.DateUtils.millisTime;
+
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.request.NettyRequestSender;
+import org.jboss.netty.util.Timeout;
+
+public class RequestTimeoutTimerTask extends TimeoutTimerTask {
+
+    private final long requestTimeout;
+
+    public RequestTimeoutTimerTask(//
+            NettyResponseFuture<?> nettyResponseFuture,//
+            NettyRequestSender requestSender,//
+            TimeoutsHolder timeoutsHolder,//
+            long requestTimeout) {
+        super(nettyResponseFuture, requestSender, timeoutsHolder);
+        this.requestTimeout = requestTimeout;
+    }
+
+    public void run(Timeout timeout) throws Exception {
+
+        if (done.getAndSet(true) || requestSender.isClosed())
+            return;
+
+        // in any case, cancel possible readTimeout sibling
+        timeoutsHolder.cancel();
+
+        if (nettyResponseFuture.isDone())
+            return;
+
+        String message = "Request timed out to " + remoteAddress + " of " + requestTimeout + " ms";
+        long age = millisTime() - nettyResponseFuture.getStart();
+        expire(message, age);
+    }
+}
diff --git a/providers/netty3/src/main/java/org/asynchttpclient/netty/timeout/TimeoutTimerTask.java b/providers/netty3/src/main/java/org/asynchttpclient/netty/timeout/TimeoutTimerTask.java
new file mode 100644
index 000000000..363a2ca0a
--- /dev/null
+++ b/providers/netty3/src/main/java/org/asynchttpclient/netty/timeout/TimeoutTimerTask.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.timeout;
+
+import java.net.SocketAddress;
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.request.NettyRequestSender;
+import org.jboss.netty.util.TimerTask;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public abstract class TimeoutTimerTask implements TimerTask {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(TimeoutTimerTask.class);
+
+    protected final AtomicBoolean done = new AtomicBoolean();
+    protected volatile NettyResponseFuture<?> nettyResponseFuture;
+    protected final NettyRequestSender requestSender;
+    protected final TimeoutsHolder timeoutsHolder;
+    protected final String remoteAddress;
+
+    public TimeoutTimerTask(NettyResponseFuture<?> nettyResponseFuture, NettyRequestSender requestSender, TimeoutsHolder timeoutsHolder) {
+        this.nettyResponseFuture = nettyResponseFuture;
+        this.requestSender = requestSender;
+        this.timeoutsHolder = timeoutsHolder;
+        // saving remote address as the channel might be removed from the future when an exception occurs
+        SocketAddress sa = nettyResponseFuture.getChannelRemoteAddress();
+        remoteAddress = sa != null ? sa.toString() : "not-connected";
+    }
+
+    protected void expire(String message, long time) {
+        LOGGER.debug("{} for {} after {} ms", message, nettyResponseFuture, time);
+        requestSender.abort(nettyResponseFuture.channel(), nettyResponseFuture, new TimeoutException(message));
+    }
+
+    /**
+     * When the timeout is cancelled, it could still be referenced for quite some time in the Timer.
+     * Holding a reference to the future might mean holding a reference to the channel, and heavy objects such as SslEngines
+     */
+    public void clean() {
+        if (done.compareAndSet(false, true))
+            nettyResponseFuture = null;
+    }
+}
diff --git a/providers/netty3/src/main/java/org/asynchttpclient/netty/timeout/TimeoutsHolder.java b/providers/netty3/src/main/java/org/asynchttpclient/netty/timeout/TimeoutsHolder.java
new file mode 100644
index 000000000..fbb60f6b2
--- /dev/null
+++ b/providers/netty3/src/main/java/org/asynchttpclient/netty/timeout/TimeoutsHolder.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.timeout;
+
+import org.jboss.netty.util.Timeout;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+
+public class TimeoutsHolder {
+
+    private final AtomicBoolean cancelled = new AtomicBoolean();
+    public volatile Timeout requestTimeout;
+    public volatile Timeout readTimeout;
+
+    public void cancel() {
+        if (cancelled.compareAndSet(false, true)) {
+            if (requestTimeout != null) {
+                requestTimeout.cancel();
+                RequestTimeoutTimerTask.class.cast(requestTimeout.getTask()).clean();
+                requestTimeout = null;
+            }
+            if (readTimeout != null) {
+                readTimeout.cancel();
+                ReadTimeoutTimerTask.class.cast(readTimeout.getTask()).clean();
+                readTimeout = null;
+            }
+        }
+    }
+}
diff --git a/providers/netty3/src/main/java/org/asynchttpclient/netty/util/ChannelBufferUtils.java b/providers/netty3/src/main/java/org/asynchttpclient/netty/util/ChannelBufferUtils.java
new file mode 100644
index 000000000..e3791f017
--- /dev/null
+++ b/providers/netty3/src/main/java/org/asynchttpclient/netty/util/ChannelBufferUtils.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.util;
+
+import org.jboss.netty.buffer.ChannelBuffer;
+
+public class ChannelBufferUtils {
+
+    public static byte[] channelBuffer2bytes(ChannelBuffer b) {
+        int readable = b.readableBytes();
+        int readerIndex = b.readerIndex();
+        if (b.hasArray()) {
+            byte[] array = b.array();
+            if (b.arrayOffset() == 0 && readerIndex == 0 && array.length == readable) {
+                return array;
+            }
+        }
+        byte[] array = new byte[readable];
+        b.getBytes(readerIndex, array);
+        return array;
+    }
+}
diff --git a/providers/netty3/src/main/java/org/asynchttpclient/netty/ws/NettyWebSocket.java b/providers/netty3/src/main/java/org/asynchttpclient/netty/ws/NettyWebSocket.java
new file mode 100644
index 000000000..18d915b38
--- /dev/null
+++ b/providers/netty3/src/main/java/org/asynchttpclient/netty/ws/NettyWebSocket.java
@@ -0,0 +1,320 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.ws;
+
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.asynchttpclient.netty.util.ChannelBufferUtils.channelBuffer2bytes;
+import static org.jboss.netty.buffer.ChannelBuffers.wrappedBuffer;
+
+import java.net.SocketAddress;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.ConcurrentLinkedQueue;
+
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.netty.NettyResponseBodyPart;
+import org.asynchttpclient.ws.WebSocket;
+import org.asynchttpclient.ws.WebSocketByteFragmentListener;
+import org.asynchttpclient.ws.WebSocketByteListener;
+import org.asynchttpclient.ws.WebSocketCloseCodeReasonListener;
+import org.asynchttpclient.ws.WebSocketListener;
+import org.asynchttpclient.ws.WebSocketPingListener;
+import org.asynchttpclient.ws.WebSocketPongListener;
+import org.asynchttpclient.ws.WebSocketTextFragmentListener;
+import org.asynchttpclient.ws.WebSocketTextListener;
+import org.jboss.netty.buffer.ChannelBuffer;
+import org.jboss.netty.channel.Channel;
+import org.jboss.netty.channel.ChannelFutureListener;
+import org.jboss.netty.handler.codec.http.websocketx.BinaryWebSocketFrame;
+import org.jboss.netty.handler.codec.http.websocketx.CloseWebSocketFrame;
+import org.jboss.netty.handler.codec.http.websocketx.PingWebSocketFrame;
+import org.jboss.netty.handler.codec.http.websocketx.PongWebSocketFrame;
+import org.jboss.netty.handler.codec.http.websocketx.TextWebSocketFrame;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class NettyWebSocket implements WebSocket {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(NettyWebSocket.class);
+
+    protected final Channel channel;
+    protected final Collection<WebSocketListener> listeners;
+    protected final int maxBufferSize;
+    private int bufferSize;
+    private List<ChannelBuffer> _fragments;
+    private volatile boolean interestedInByteMessages;
+    private volatile boolean interestedInTextMessages;
+
+    public NettyWebSocket(Channel channel, AsyncHttpClientConfig config) {
+        this(channel, config, new ConcurrentLinkedQueue<WebSocketListener>());
+    }
+
+    public NettyWebSocket(Channel channel, AsyncHttpClientConfig config, Collection<WebSocketListener> listeners) {
+        this.channel = channel;
+        this.listeners = listeners;
+        maxBufferSize = config.getWebSocketMaxBufferSize();
+    }
+
+    @Override
+    public SocketAddress getRemoteAddress() {
+        return channel.getRemoteAddress();
+    }
+    
+    @Override
+    public SocketAddress getLocalAddress() {
+        return channel.getLocalAddress();
+    }
+    
+    @Override
+    public WebSocket sendMessage(byte[] message) {
+        channel.write(new BinaryWebSocketFrame(wrappedBuffer(message)));
+        return this;
+    }
+
+    @Override
+    public WebSocket stream(byte[] fragment, boolean last) {
+        BinaryWebSocketFrame frame = new BinaryWebSocketFrame(wrappedBuffer(fragment));
+        frame.setFinalFragment(last);
+        channel.write(frame);
+        return this;
+    }
+
+    @Override
+    public WebSocket stream(byte[] fragment, int offset, int len, boolean last) {
+        BinaryWebSocketFrame frame = new BinaryWebSocketFrame(wrappedBuffer(fragment, offset, len));
+        frame.setFinalFragment(last);
+        channel.write(frame);
+        return this;
+    }
+
+    @Override
+    public WebSocket sendMessage(String message) {
+        channel.write(new TextWebSocketFrame(message));
+        return this;
+    }
+
+    @Override
+    public WebSocket stream(String fragment, boolean last) {
+        TextWebSocketFrame frame = new TextWebSocketFrame(fragment);
+        frame.setFinalFragment(last);
+        channel.write(frame);
+        return this;
+    }
+
+    @Override
+    public WebSocket sendPing(byte[] payload) {
+        channel.write(new PingWebSocketFrame(wrappedBuffer(payload)));
+        return this;
+    }
+
+    @Override
+    public WebSocket sendPong(byte[] payload) {
+        channel.write(new PongWebSocketFrame(wrappedBuffer(payload)));
+        return this;
+    }
+
+    @Override
+    public boolean isOpen() {
+        return channel.isOpen();
+    }
+
+    @Override
+    public void close() {
+        if (channel.isOpen()) {
+            onClose();
+            listeners.clear();
+            channel.write(new CloseWebSocketFrame()).addListener(ChannelFutureListener.CLOSE);
+        }
+    }
+
+    public void close(int statusCode, String reason) {
+        onClose(statusCode, reason);
+        listeners.clear();
+    }
+
+    public void onError(Throwable t) {
+        for (WebSocketListener listener : listeners) {
+            try {
+                listener.onError(t);
+            } catch (Throwable t2) {
+                LOGGER.error("", t2);
+            }
+        }
+    }
+
+    protected void onClose() {
+        onClose(1000, "Normal closure; the connection successfully completed whatever purpose for which it was created.");
+    }
+
+    public void onClose(int code, String reason) {
+        for (WebSocketListener l : listeners) {
+            try {
+                if (l instanceof WebSocketCloseCodeReasonListener) {
+                    WebSocketCloseCodeReasonListener.class.cast(l).onClose(this, code, reason);
+                }
+                l.onClose(this);
+            } catch (Throwable t) {
+                l.onError(t);
+            }
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "NettyWebSocket{channel=" + channel + '}';
+    }
+
+    private boolean hasWebSocketByteListener() {
+        for (WebSocketListener listener : listeners) {
+            if (listener instanceof WebSocketByteListener)
+                return true;
+        }
+        return false;
+    }
+
+    private boolean hasWebSocketTextListener() {
+        for (WebSocketListener listener : listeners) {
+            if (listener instanceof WebSocketTextListener)
+                return true;
+        }
+        return false;
+    }
+
+    @Override
+    public WebSocket addWebSocketListener(WebSocketListener l) {
+        listeners.add(l);
+        interestedInByteMessages = interestedInByteMessages || l instanceof WebSocketByteListener;
+        interestedInTextMessages = interestedInTextMessages || l instanceof WebSocketTextListener;
+        return this;
+    }
+
+    @Override
+    public WebSocket removeWebSocketListener(WebSocketListener l) {
+        listeners.remove(l);
+
+        if (l instanceof WebSocketByteListener)
+            interestedInByteMessages = hasWebSocketByteListener();
+        if (l instanceof WebSocketTextListener)
+            interestedInTextMessages = hasWebSocketTextListener();
+
+        return this;
+    }
+
+    private List<ChannelBuffer> fragments() {
+        if (_fragments == null)
+            _fragments = new ArrayList<>(2);
+        return _fragments;
+    }
+
+    private void bufferFragment(ChannelBuffer buffer) {
+        bufferSize += buffer.readableBytes();
+        if (bufferSize > maxBufferSize) {
+            onError(new Exception("Exceeded Netty Web Socket maximum buffer size of " + maxBufferSize));
+            reset();
+            close();
+        } else {
+            fragments().add(buffer);
+        }
+    }
+
+    private void reset() {
+        fragments().clear();
+        bufferSize = 0;
+    }
+
+    private void notifyByteListeners(ChannelBuffer channelBuffer) {
+        byte[] message = channelBuffer2bytes(channelBuffer);
+        for (WebSocketListener listener : listeners) {
+            if (listener instanceof WebSocketByteListener)
+                WebSocketByteListener.class.cast(listener).onMessage(message);
+        }
+    }
+
+    private void notifyTextListeners(ChannelBuffer channelBuffer) {
+        String message = channelBuffer.toString(UTF_8);
+        for (WebSocketListener listener : listeners) {
+            if (listener instanceof WebSocketTextListener)
+                WebSocketTextListener.class.cast(listener).onMessage(message);
+        }
+    }
+
+    public void onBinaryFragment(HttpResponseBodyPart part) {
+
+        for (WebSocketListener listener : listeners) {
+            if (listener instanceof WebSocketByteFragmentListener)
+                WebSocketByteFragmentListener.class.cast(listener).onFragment(part);
+        }
+
+        if (interestedInByteMessages) {
+            ChannelBuffer fragment = NettyResponseBodyPart.class.cast(part).getChannelBuffer();
+
+            if (part.isLast()) {
+                if (bufferSize == 0) {
+                    notifyByteListeners(fragment);
+
+                } else {
+                    bufferFragment(fragment);
+                    notifyByteListeners(wrappedBuffer(fragments().toArray(new ChannelBuffer[fragments().size()])));
+                }
+
+                reset();
+
+            } else
+                bufferFragment(fragment);
+        }
+    }
+
+    public void onTextFragment(HttpResponseBodyPart part) {
+        for (WebSocketListener listener : listeners) {
+            if (listener instanceof WebSocketTextFragmentListener)
+                WebSocketTextFragmentListener.class.cast(listener).onFragment(part);
+        }
+
+        if (interestedInTextMessages) {
+            ChannelBuffer fragment = NettyResponseBodyPart.class.cast(part).getChannelBuffer();
+
+            if (part.isLast()) {
+                if (bufferSize == 0) {
+                    notifyTextListeners(fragment);
+
+                } else {
+                    bufferFragment(fragment);
+                    notifyTextListeners(wrappedBuffer(fragments().toArray(new ChannelBuffer[fragments().size()])));
+                }
+
+                reset();
+
+            } else
+                bufferFragment(fragment);
+        }
+    }
+
+    public void onPing(HttpResponseBodyPart part) {
+        for (WebSocketListener listener : listeners) {
+            if (listener instanceof WebSocketPingListener)
+                // bytes are cached in the part
+                WebSocketPingListener.class.cast(listener).onPing(part.getBodyPartBytes());
+        }
+    }
+
+    public void onPong(HttpResponseBodyPart part) {
+        for (WebSocketListener listener : listeners) {
+            if (listener instanceof WebSocketPongListener)
+                // bytes are cached in the part
+                WebSocketPongListener.class.cast(listener).onPong(part.getBodyPartBytes());
+        }
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncHttpProviderTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyAsyncHttpProviderTest.java
similarity index 91%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncHttpProviderTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/NettyAsyncHttpProviderTest.java
index 4ceea1570..3e30b1df1 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncHttpProviderTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyAsyncHttpProviderTest.java
@@ -10,11 +10,11 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty;
 
+import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.AbstractBasicTest;
 
 public class NettyAsyncHttpProviderTest extends AbstractBasicTest {
 
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyBasicAuthTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyAsyncProviderBasicTest.java
similarity index 70%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyBasicAuthTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/NettyAsyncProviderBasicTest.java
index 589cfd1e6..75ed942fb 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyBasicAuthTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyAsyncProviderBasicTest.java
@@ -10,13 +10,16 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.BasicAuthTest;
+import org.asynchttpclient.AsyncHttpProviderConfig;
+import org.asynchttpclient.AsyncProvidersBasicTest;
+import org.testng.annotations.Test;
 
-public class NettyBasicAuthTest extends BasicAuthTest {
+@Test
+public class NettyAsyncProviderBasicTest extends AsyncProvidersBasicTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
@@ -24,7 +27,7 @@ public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
     }
 
     @Override
-    public String getProviderClass() {
-        return NettyAsyncHttpProvider.class.getName();
+    protected AsyncHttpProviderConfig<?, ?> getProviderConfig() {
+        return new NettyAsyncHttpProviderConfig().addProperty("tcpNoDelay", true);
     }
-}
+}
\ No newline at end of file
diff --git a/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyAsyncProviderPipelineTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyAsyncProviderPipelineTest.java
new file mode 100644
index 000000000..da04cf7fe
--- /dev/null
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyAsyncProviderPipelineTest.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.netty;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.fail;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import org.asynchttpclient.AbstractBasicTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.netty.NettyAsyncHttpProviderConfig;
+import org.asynchttpclient.netty.NettyAsyncHttpProviderConfig.AdditionalPipelineInitializer;
+import org.jboss.netty.channel.ChannelHandlerContext;
+import org.jboss.netty.channel.ChannelPipeline;
+import org.jboss.netty.channel.MessageEvent;
+import org.jboss.netty.channel.SimpleChannelUpstreamHandler;
+import org.jboss.netty.handler.codec.http.HttpMessage;
+import org.testng.annotations.Test;
+
+public class NettyAsyncProviderPipelineTest extends AbstractBasicTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+
+    @Test(groups = { "standalone", "netty_provider" })
+    public void asyncPipelineTest() throws Exception {
+
+        NettyAsyncHttpProviderConfig nettyConfig = new NettyAsyncHttpProviderConfig();
+        nettyConfig.setHttpAdditionalPipelineInitializer(new AdditionalPipelineInitializer() {
+            public void initPipeline(ChannelPipeline pipeline) throws Exception {
+                pipeline.addBefore("inflater", "copyEncodingHeader", new CopyEncodingHandler());
+            }
+        });
+
+        try (AsyncHttpClient p = getAsyncHttpClient(new AsyncHttpClientConfig.Builder()
+                .setAsyncHttpClientProviderConfig(nettyConfig).build())) {
+            final CountDownLatch l = new CountDownLatch(1);
+            Request request = new RequestBuilder("GET").setUrl(getTargetUrl()).build();
+            p.executeRequest(request, new AsyncCompletionHandlerAdapter() {
+                @Override
+                public Response onCompleted(Response response) throws Exception {
+                    try {
+                        assertEquals(response.getStatusCode(), 200);
+                        assertEquals(response.getHeader("X-Original-Content-Encoding"), "<original encoding>");
+                    } finally {
+                        l.countDown();
+                    }
+                    return response;
+                }
+            }).get();
+            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
+                fail("Timeout out");
+            }
+        }
+    }
+
+    private static class CopyEncodingHandler extends SimpleChannelUpstreamHandler {
+        @Override
+        public void messageReceived(final ChannelHandlerContext ctx, MessageEvent e) throws Exception {
+            
+            Object message = e.getMessage();
+            
+            if (message instanceof HttpMessage) {
+                HttpMessage m = (HttpMessage) message;
+                // for test there is no Content-Encoding header so just hard
+                // coding value
+                // for verification
+                m.headers().set("X-Original-Content-Encoding", "<original encoding>");
+            }
+            ctx.sendUpstream(e);
+        }
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncResponseTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyAsyncResponseTest.java
similarity index 83%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncResponseTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/NettyAsyncResponseTest.java
index 915857185..37ec10926 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncResponseTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyAsyncResponseTest.java
@@ -11,15 +11,14 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty;
 
 import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
 
 import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
 import org.asynchttpclient.HttpResponseHeaders;
 import org.asynchttpclient.cookie.Cookie;
-import org.asynchttpclient.providers.netty.response.NettyResponse;
-import org.asynchttpclient.providers.netty.response.NettyResponseStatus;
 import org.testng.annotations.Test;
 
 import java.text.SimpleDateFormat;
@@ -42,30 +41,29 @@ public void testCookieParseExpires() {
         Date date = new Date(System.currentTimeMillis() + 60000);
         final String cookieDef = String.format("efmembercheck=true; expires=%s; path=/; domain=.eclipse.org", sdf.format(date));
 
-        NettyResponse response = new NettyResponse(new NettyResponseStatus(null, null, null), new HttpResponseHeaders() {
+        NettyResponse response = new NettyResponse(new NettyResponseStatus(null, null, null, null), new HttpResponseHeaders() {
             @Override
             public FluentCaseInsensitiveStringsMap getHeaders() {
                 return new FluentCaseInsensitiveStringsMap().add("Set-Cookie", cookieDef);
             }
-        }, null, null);
+        }, null);
 
         List<Cookie> cookies = response.getCookies();
         assertEquals(cookies.size(), 1);
 
         Cookie cookie = cookies.get(0);
-        long originalDateWith1SecPrecision = date.getTime() / 1000 * 1000;
-        assertEquals(cookie.getExpires(), originalDateWith1SecPrecision);
+        assertTrue(cookie.getMaxAge() >= 58 && cookie.getMaxAge() <= 60);
     }
 
     @Test(groups = "standalone")
     public void testCookieParseMaxAge() {
         final String cookieDef = "efmembercheck=true; max-age=60; path=/; domain=.eclipse.org";
-        NettyResponse response = new NettyResponse(new NettyResponseStatus(null, null, null), new HttpResponseHeaders() {
+        NettyResponse response = new NettyResponse(new NettyResponseStatus(null, null, null, null), new HttpResponseHeaders() {
             @Override
             public FluentCaseInsensitiveStringsMap getHeaders() {
                 return new FluentCaseInsensitiveStringsMap().add("Set-Cookie", cookieDef);
             }
-        }, null, null);
+        }, null);
         List<Cookie> cookies = response.getCookies();
         assertEquals(cookies.size(), 1);
 
@@ -76,18 +74,18 @@ public FluentCaseInsensitiveStringsMap getHeaders() {
     @Test(groups = "standalone")
     public void testCookieParseWeirdExpiresValue() {
         final String cookieDef = "efmembercheck=true; expires=60; path=/; domain=.eclipse.org";
-        NettyResponse response = new NettyResponse(new NettyResponseStatus(null, null, null), new HttpResponseHeaders() {
+        NettyResponse response = new NettyResponse(new NettyResponseStatus(null, null, null, null), new HttpResponseHeaders() {
             @Override
             public FluentCaseInsensitiveStringsMap getHeaders() {
                 return new FluentCaseInsensitiveStringsMap().add("Set-Cookie", cookieDef);
             }
-        }, null, null);
+        }, null);
 
         List<Cookie> cookies = response.getCookies();
         assertEquals(cookies.size(), 1);
 
         Cookie cookie = cookies.get(0);
-        assertEquals(cookie.getMaxAge(), -1);
+        assertEquals(cookie.getMaxAge(), Long.MIN_VALUE);
     }
 
 }
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncStreamHandlerTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyAsyncStreamHandlerTest.java
similarity index 90%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncStreamHandlerTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/NettyAsyncStreamHandlerTest.java
index 1c1bea893..e03efb1f4 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncStreamHandlerTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyAsyncStreamHandlerTest.java
@@ -10,11 +10,11 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.AsyncStreamHandlerTest;
+import org.asynchttpclient.AsyncStreamHandlerTest;
 
 public class NettyAsyncStreamHandlerTest extends AsyncStreamHandlerTest {
 
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncStreamLifecycleTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyAsyncStreamLifecycleTest.java
similarity index 90%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncStreamLifecycleTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/NettyAsyncStreamLifecycleTest.java
index 9760aa429..c66e9d250 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncStreamLifecycleTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyAsyncStreamLifecycleTest.java
@@ -10,11 +10,11 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.AsyncStreamLifecycleTest;
+import org.asynchttpclient.AsyncStreamLifecycleTest;
 
 public class NettyAsyncStreamLifecycleTest extends AsyncStreamLifecycleTest {
     @Override
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAuthTimeoutTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyAuthTimeoutTest.java
similarity index 91%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAuthTimeoutTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/NettyAuthTimeoutTest.java
index 1056d502f..89e25b215 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAuthTimeoutTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyAuthTimeoutTest.java
@@ -10,11 +10,11 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.AuthTimeoutTest;
+import org.asynchttpclient.AuthTimeoutTest;
 
 public class NettyAuthTimeoutTest extends AuthTimeoutTest {
 
diff --git a/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyBasicAuthTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyBasicAuthTest.java
new file mode 100644
index 000000000..0b9db54af
--- /dev/null
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyBasicAuthTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.BasicAuthTest;
+
+public class NettyBasicAuthTest extends BasicAuthTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyBasicHttpsTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyBasicHttpsTest.java
similarity index 91%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyBasicHttpsTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/NettyBasicHttpsTest.java
index 5790fd96b..9fe45ee2b 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyBasicHttpsTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyBasicHttpsTest.java
@@ -10,11 +10,11 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.BasicHttpsTest;
+import org.asynchttpclient.BasicHttpsTest;
 
 public class NettyBasicHttpsTest extends BasicHttpsTest {
 
@@ -22,4 +22,4 @@
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return NettyProviderUtil.nettyProvider(config);
     }
-}
+}
\ No newline at end of file
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyByteBufferCapacityTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyByteBufferCapacityTest.java
similarity index 90%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyByteBufferCapacityTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/NettyByteBufferCapacityTest.java
index 8cabb0c63..e38a63e1e 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyByteBufferCapacityTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyByteBufferCapacityTest.java
@@ -10,11 +10,11 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.ByteBufferCapacityTest;
+import org.asynchttpclient.ByteBufferCapacityTest;
 
 public class NettyByteBufferCapacityTest extends ByteBufferCapacityTest {
 
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyComplexClientTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyComplexClientTest.java
similarity index 91%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyComplexClientTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/NettyComplexClientTest.java
index 7cb83020d..d055f9131 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyComplexClientTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyComplexClientTest.java
@@ -10,11 +10,11 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.ComplexClientTest;
+import org.asynchttpclient.ComplexClientTest;
 
 public class NettyComplexClientTest extends ComplexClientTest {
 
diff --git a/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyConnectionPoolTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyConnectionPoolTest.java
new file mode 100644
index 000000000..cae39841f
--- /dev/null
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyConnectionPoolTest.java
@@ -0,0 +1,120 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved. This program is licensed to you under the Apache License
+ * Version 2.0, and you may not use this file except in compliance with the Apache License Version 2.0. You may obtain a
+ * copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0. Unless required by applicable
+ * law or agreed to in writing, software distributed under the Apache License Version 2.0 is distributed on an "AS IS"
+ * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the Apache License Version 2.0
+ * for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+import static org.asynchttpclient.test.TestUtils.findFreePort;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertNull;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
+
+import java.net.ConnectException;
+import java.util.concurrent.TimeUnit;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.channel.pool.ConnectionPoolTest;
+import org.asynchttpclient.netty.NettyAsyncHttpProviderConfig;
+import org.asynchttpclient.netty.channel.pool.ChannelPool;
+import org.asynchttpclient.netty.channel.pool.NoopChannelPool;
+import org.jboss.netty.channel.Channel;
+import org.testng.annotations.Test;
+
+public class NettyConnectionPoolTest extends ConnectionPoolTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void testInvalidConnectionsPool() {
+        ChannelPool cp = new NoopChannelPool() {
+
+            @Override
+            public boolean offer(Channel connection, Object partitionKey) {
+                return false;
+            }
+
+            @Override
+            public boolean isOpen() {
+                return false;
+            }
+        };
+
+        NettyAsyncHttpProviderConfig providerConfig = new NettyAsyncHttpProviderConfig();
+        providerConfig.setChannelPool(cp);
+        try (AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setAsyncHttpClientProviderConfig(providerConfig)
+                .build())) {
+            Exception exception = null;
+            try {
+                client.prepareGet(getTargetUrl()).execute().get(TIMEOUT, TimeUnit.SECONDS);
+            } catch (Exception ex) {
+                ex.printStackTrace();
+                exception = ex;
+            }
+            assertNotNull(exception);
+            assertNotNull(exception.getCause());
+            assertEquals(exception.getCause().getMessage(), "Pool is already closed");
+        }
+    }
+
+    @Test(groups = { "standalone", "default_provider" })
+    public void testValidConnectionsPool() {
+        ChannelPool cp = new NoopChannelPool() {
+
+            @Override
+            public boolean offer(Channel connection, Object partitionKey) {
+                return true;
+            }
+        };
+
+        NettyAsyncHttpProviderConfig providerConfig = new NettyAsyncHttpProviderConfig();
+        providerConfig.setChannelPool(cp);
+        try (AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setAsyncHttpClientProviderConfig(providerConfig)
+                .build())) {
+            Exception exception = null;
+            try {
+                client.prepareGet(getTargetUrl()).execute().get(TIMEOUT, TimeUnit.SECONDS);
+            } catch (Exception ex) {
+                ex.printStackTrace();
+                exception = ex;
+            }
+            assertNull(exception);
+        }
+    }
+
+    @Test
+    public void testHostNotContactable() {
+
+        try (AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build())) {
+            String url = null;
+            try {
+                url = "http://127.0.0.1:" + findFreePort();
+            } catch (Exception e) {
+                fail("unable to find free port to simulate downed host");
+            }
+            int i;
+            for (i = 0; i < 2; i++) {
+                try {
+                    log.info("{} requesting url [{}]...", i, url);
+                    Response response = client.prepareGet(url).execute().get();
+                    log.info("{} response [{}].", i, response);
+                    fail("Shouldn't be here: should get an exception instead");
+                } catch (Exception ex) {
+                    assertNotNull(ex.getCause());
+                    Throwable cause = ex.getCause();
+                    assertTrue(cause instanceof ConnectException);
+                }
+            }
+        }
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyDigestAuthTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyDigestAuthTest.java
similarity index 91%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyDigestAuthTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/NettyDigestAuthTest.java
index 205fb73a1..cc48a025c 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyDigestAuthTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyDigestAuthTest.java
@@ -10,11 +10,11 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.DigestAuthTest;
+import org.asynchttpclient.DigestAuthTest;
 
 public class NettyDigestAuthTest extends DigestAuthTest {
     @Override
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyErrorResponseTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyErrorResponseTest.java
similarity index 91%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyErrorResponseTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/NettyErrorResponseTest.java
index ee34de01f..b8a899ce4 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyErrorResponseTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyErrorResponseTest.java
@@ -10,11 +10,11 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.ErrorResponseTest;
+import org.asynchttpclient.ErrorResponseTest;
 
 public class NettyErrorResponseTest extends ErrorResponseTest {
 
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyExpect100ContinueTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyExpect100ContinueTest.java
similarity index 90%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyExpect100ContinueTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/NettyExpect100ContinueTest.java
index ce9759922..6a5a6ce8f 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyExpect100ContinueTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyExpect100ContinueTest.java
@@ -10,11 +10,11 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.Expect100ContinueTest;
+import org.asynchttpclient.Expect100ContinueTest;
 
 public class NettyExpect100ContinueTest extends Expect100ContinueTest {
 
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyFollowingThreadTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyFollowingThreadTest.java
similarity index 91%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyFollowingThreadTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/NettyFollowingThreadTest.java
index c3e2c8b75..43d6707fc 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyFollowingThreadTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyFollowingThreadTest.java
@@ -10,11 +10,11 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.FollowingThreadTest;
+import org.asynchttpclient.FollowingThreadTest;
 
 public class NettyFollowingThreadTest extends FollowingThreadTest {
     @Override
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyHead302Test.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyHead302Test.java
similarity index 91%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyHead302Test.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/NettyHead302Test.java
index 8fc323e3b..43f5a0f6d 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyHead302Test.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyHead302Test.java
@@ -10,11 +10,11 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.Head302Test;
+import org.asynchttpclient.Head302Test;
 
 public class NettyHead302Test extends Head302Test {
 
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyHttpToHttpsRedirectTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyHttpToHttpsRedirectTest.java
similarity index 90%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyHttpToHttpsRedirectTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/NettyHttpToHttpsRedirectTest.java
index ec739b406..8f3d54d8c 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyHttpToHttpsRedirectTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyHttpToHttpsRedirectTest.java
@@ -10,11 +10,11 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.HttpToHttpsRedirectTest;
+import org.asynchttpclient.HttpToHttpsRedirectTest;
 
 public class NettyHttpToHttpsRedirectTest extends HttpToHttpsRedirectTest {
     @Override
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyIdleStateHandlerTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyIdleStateHandlerTest.java
similarity index 91%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyIdleStateHandlerTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/NettyIdleStateHandlerTest.java
index 26dc2a2db..590eadb39 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyIdleStateHandlerTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyIdleStateHandlerTest.java
@@ -10,11 +10,11 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.IdleStateHandlerTest;
+import org.asynchttpclient.IdleStateHandlerTest;
 
 public class NettyIdleStateHandlerTest extends IdleStateHandlerTest {
     @Override
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyMultipleHeaderTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyMultipleHeaderTest.java
similarity index 91%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyMultipleHeaderTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/NettyMultipleHeaderTest.java
index 2198b1b1f..cad2dcbde 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyMultipleHeaderTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyMultipleHeaderTest.java
@@ -10,11 +10,11 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.MultipleHeaderTest;
+import org.asynchttpclient.MultipleHeaderTest;
 
 public class NettyMultipleHeaderTest extends MultipleHeaderTest {
     @Override
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyNoNullResponseTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyNoNullResponseTest.java
similarity index 91%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyNoNullResponseTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/NettyNoNullResponseTest.java
index d6b012226..4e133dd51 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyNoNullResponseTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyNoNullResponseTest.java
@@ -10,11 +10,11 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.NoNullResponseTest;
+import org.asynchttpclient.NoNullResponseTest;
 
 public class NettyNoNullResponseTest extends NoNullResponseTest {
     @Override
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyNonAsciiContentLengthTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyNonAsciiContentLengthTest.java
similarity index 90%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyNonAsciiContentLengthTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/NettyNonAsciiContentLengthTest.java
index 50fca62df..193ccec42 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyNonAsciiContentLengthTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyNonAsciiContentLengthTest.java
@@ -10,11 +10,11 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.NonAsciiContentLengthTest;
+import org.asynchttpclient.NonAsciiContentLengthTest;
 
 public class NettyNonAsciiContentLengthTest extends NonAsciiContentLengthTest {
 
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyParamEncodingTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyParamEncodingTest.java
similarity index 91%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyParamEncodingTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/NettyParamEncodingTest.java
index d633d3797..0315db8cd 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyParamEncodingTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyParamEncodingTest.java
@@ -10,11 +10,11 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.ParamEncodingTest;
+import org.asynchttpclient.ParamEncodingTest;
 
 public class NettyParamEncodingTest extends ParamEncodingTest {
     @Override
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyPerRequestRelative302Test.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyPerRequestRelative302Test.java
similarity index 90%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyPerRequestRelative302Test.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/NettyPerRequestRelative302Test.java
index b0fabf1ef..23ef73899 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyPerRequestRelative302Test.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyPerRequestRelative302Test.java
@@ -10,11 +10,11 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.PerRequestRelative302Test;
+import org.asynchttpclient.PerRequestRelative302Test;
 
 public class NettyPerRequestRelative302Test extends PerRequestRelative302Test {
     @Override
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyPerRequestTimeoutTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyPerRequestTimeoutTest.java
similarity index 93%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyPerRequestTimeoutTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/NettyPerRequestTimeoutTest.java
index 960a039d9..41b8f1bbf 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyPerRequestTimeoutTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyPerRequestTimeoutTest.java
@@ -10,13 +10,13 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty;
 
 import static org.testng.Assert.assertTrue;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.PerRequestTimeoutTest;
+import org.asynchttpclient.PerRequestTimeoutTest;
 
 public class NettyPerRequestTimeoutTest extends PerRequestTimeoutTest {
 
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyPostRedirectGetTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyPostRedirectGetTest.java
similarity index 91%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyPostRedirectGetTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/NettyPostRedirectGetTest.java
index 979c761bd..18fd29e3c 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyPostRedirectGetTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyPostRedirectGetTest.java
@@ -11,11 +11,11 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.PostRedirectGetTest;
+import org.asynchttpclient.PostRedirectGetTest;
 
 public class NettyPostRedirectGetTest extends PostRedirectGetTest {
 
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyPostWithQSTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyPostWithQSTest.java
similarity index 91%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyPostWithQSTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/NettyPostWithQSTest.java
index c244b89c0..d7bc0eaf7 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyPostWithQSTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyPostWithQSTest.java
@@ -10,11 +10,11 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.PostWithQSTest;
+import org.asynchttpclient.PostWithQSTest;
 
 public class NettyPostWithQSTest extends PostWithQSTest {
     @Override
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyProviderUtil.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyProviderUtil.java
similarity index 92%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyProviderUtil.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/NettyProviderUtil.java
index b6120976b..d889242c5 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyProviderUtil.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyProviderUtil.java
@@ -13,11 +13,12 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.DefaultAsyncHttpClient;
+import org.asynchttpclient.netty.NettyAsyncHttpProvider;
 
 public class NettyProviderUtil {
 
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyQueryParametersTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyQueryParametersTest.java
similarity index 91%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyQueryParametersTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/NettyQueryParametersTest.java
index 7a38145ef..77a63d4d0 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyQueryParametersTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyQueryParametersTest.java
@@ -10,11 +10,11 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.QueryParametersTest;
+import org.asynchttpclient.QueryParametersTest;
 
 public class NettyQueryParametersTest extends QueryParametersTest {
     @Override
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRC10KTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyRC10KTest.java
similarity index 91%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRC10KTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/NettyRC10KTest.java
index 17f26efbb..276d21f7f 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRC10KTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyRC10KTest.java
@@ -10,11 +10,11 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.RC10KTest;
+import org.asynchttpclient.RC10KTest;
 
 public class NettyRC10KTest extends RC10KTest {
     @Override
diff --git a/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyRedirectBodyTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyRedirectBodyTest.java
new file mode 100644
index 000000000..ed2299b02
--- /dev/null
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyRedirectBodyTest.java
@@ -0,0 +1,15 @@
+package org.asynchttpclient.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.RedirectBodyTest;
+import org.testng.annotations.Test;
+
+@Test
+public class NettyRedirectBodyTest extends RedirectBodyTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRedirectConnectionUsageTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyRedirectConnectionUsageTest.java
similarity index 90%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRedirectConnectionUsageTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/NettyRedirectConnectionUsageTest.java
index cd62bb347..f7f384671 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRedirectConnectionUsageTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyRedirectConnectionUsageTest.java
@@ -10,11 +10,11 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.RedirectConnectionUsageTest;
+import org.asynchttpclient.RedirectConnectionUsageTest;
 
 public class NettyRedirectConnectionUsageTest extends RedirectConnectionUsageTest {
     @Override
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRelative302Test.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyRelative302Test.java
similarity index 91%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRelative302Test.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/NettyRelative302Test.java
index 22fca88ad..5bc48614f 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRelative302Test.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyRelative302Test.java
@@ -10,11 +10,11 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.Relative302Test;
+import org.asynchttpclient.Relative302Test;
 
 public class NettyRelative302Test extends Relative302Test {
 
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRemoteSiteTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyRemoteSiteTest.java
similarity index 90%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRemoteSiteTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/NettyRemoteSiteTest.java
index 94c6f0d7a..f15c32256 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRemoteSiteTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyRemoteSiteTest.java
@@ -13,11 +13,11 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.RemoteSiteTest;
+import org.asynchttpclient.RemoteSiteTest;
 
 public class NettyRemoteSiteTest extends RemoteSiteTest {
     @Override
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRequestThrottleTimeoutTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyRequestThrottleTimeoutTest.java
similarity index 94%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRequestThrottleTimeoutTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/NettyRequestThrottleTimeoutTest.java
index 3836c1c3e..e73980600 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRequestThrottleTimeoutTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyRequestThrottleTimeoutTest.java
@@ -10,16 +10,16 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty;
 
 import static org.testng.Assert.assertTrue;
 import static org.testng.Assert.fail;
 
+import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.AsyncCompletionHandler;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.Response;
-import org.asynchttpclient.async.AbstractBasicTest;
 import org.eclipse.jetty.continuation.Continuation;
 import org.eclipse.jetty.continuation.ContinuationSupport;
 import org.eclipse.jetty.server.Request;
@@ -81,11 +81,9 @@ public void run() {
     public void testRequestTimeout() throws IOException {
         final Semaphore requestThrottle = new Semaphore(1);
 
-        final AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setMaxConnections(1).build());
-
         int samples = 10;
 
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setMaxConnections(1).build())) {
             final CountDownLatch latch = new CountDownLatch(samples);
             final List<Exception> tooManyConnections = Collections.synchronizedList(new ArrayList<Exception>(2));
 
@@ -97,7 +95,7 @@ public void run() {
                             requestThrottle.acquire();
                             Future<Response> responseFuture = null;
                             try {
-                                responseFuture = client.prepareGet(getTargetUrl()).setRequestTimeoutInMs(SLEEPTIME_MS / 2)
+                                responseFuture = client.prepareGet(getTargetUrl()).setRequestTimeout(SLEEPTIME_MS / 2)
                                         .execute(new AsyncCompletionHandler<Response>() {
 
                                             @Override
@@ -140,8 +138,6 @@ public void onThrowable(Throwable t) {
                 logger.error("Exception while calling execute", e);
 
             assertTrue(tooManyConnections.isEmpty(), "Should not have any connection errors where too many connections have been attempted");
-        } finally {
-            client.close();
         }
     }
 }
diff --git a/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyRetryRequestTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyRetryRequestTest.java
new file mode 100644
index 000000000..1fdeaa838
--- /dev/null
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyRetryRequestTest.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package org.asynchttpclient.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.RetryRequestTest;
+
+public class NettyRetryRequestTest extends RetryRequestTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyThreadNameTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyThreadNameTest.java
new file mode 100644
index 000000000..dfa8d0aa9
--- /dev/null
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/NettyThreadNameTest.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.RetryRequestTest;
+import org.asynchttpclient.ThreadNameTest;
+
+/**
+ * @author Stepan Koltsov
+ */
+public class NettyThreadNameTest extends ThreadNameTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/RetryNonBlockingIssue.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/RetryNonBlockingIssue.java
similarity index 92%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/RetryNonBlockingIssue.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/RetryNonBlockingIssue.java
index c5d179859..bc1e2a1fd 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/RetryNonBlockingIssue.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/RetryNonBlockingIssue.java
@@ -10,20 +10,20 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty;
 
-import static org.asynchttpclient.async.util.TestUtils.findFreePort;
-import static org.asynchttpclient.async.util.TestUtils.newJettyHttpServer;
+import static org.asynchttpclient.test.TestUtils.findFreePort;
+import static org.asynchttpclient.test.TestUtils.newJettyHttpServer;
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertTrue;
 
+import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.ListenableFuture;
 import org.asynchttpclient.Request;
 import org.asynchttpclient.RequestBuilder;
 import org.asynchttpclient.Response;
-import org.asynchttpclient.async.AbstractBasicTest;
 import org.eclipse.jetty.servlet.ServletContextHandler;
 import org.eclipse.jetty.servlet.ServletHolder;
 import org.testng.annotations.BeforeClass;
@@ -90,13 +90,12 @@ public void testRetryNonBlocking() throws IOException, InterruptedException, Exe
         AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder()//
                 .setAllowPoolingConnections(true)//
                 .setMaxConnections(100)//
-                .setConnectionTimeout(60000)//
+                .setConnectTimeout(60000)//
                 .setRequestTimeout(30000)//
                 .build();
 
-        AsyncHttpClient client = getAsyncHttpClient(config);
-        try {
-            List<ListenableFuture<Response>> res = new ArrayList<ListenableFuture<Response>>();
+        try (AsyncHttpClient client = getAsyncHttpClient(config)) {
+            List<ListenableFuture<Response>> res = new ArrayList<>();
             for (int i = 0; i < 32; i++) {
                 res.add(testMethodRequest(client, 3, "servlet", UUID.randomUUID().toString()));
             }
@@ -114,9 +113,6 @@ public void testRetryNonBlocking() throws IOException, InterruptedException, Exe
             }
             System.out.println(b.toString());
             System.out.flush();
-
-        } finally {
-            client.close();
         }
     }
 
@@ -126,14 +122,12 @@ public void testRetryNonBlockingAsyncConnect() throws IOException, InterruptedEx
         AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder()//
                 .setAllowPoolingConnections(true)//
                 .setMaxConnections(100)//
-                .setConnectionTimeout(60000)//
+                .setConnectTimeout(60000)//
                 .setRequestTimeout(30000)//
                 .build();
 
-        AsyncHttpClient client = getAsyncHttpClient(config);
-
-        try {
-            List<ListenableFuture<Response>> res = new ArrayList<ListenableFuture<Response>>();
+        try (AsyncHttpClient client = getAsyncHttpClient(config)) {
+            List<ListenableFuture<Response>> res = new ArrayList<>();
             for (int i = 0; i < 32; i++) {
                 res.add(testMethodRequest(client, 3, "servlet", UUID.randomUUID().toString()));
             }
@@ -151,16 +145,13 @@ public void testRetryNonBlockingAsyncConnect() throws IOException, InterruptedEx
             }
             System.out.println(b.toString());
             System.out.flush();
-
-        } finally {
-            client.close();
         }
     }
 
     @SuppressWarnings("serial")
     public class MockExceptionServlet extends HttpServlet {
 
-        private Map<String, Integer> requests = new ConcurrentHashMap<String, Integer>();
+        private Map<String, Integer> requests = new ConcurrentHashMap<>();
 
         private synchronized int increment(String id) {
             int val = 0;
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyMaxConnectionsInThreads.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/channel/NettyMaxConnectionsInThreads.java
similarity index 86%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyMaxConnectionsInThreads.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/channel/NettyMaxConnectionsInThreads.java
index 0e24c3d55..55a1da687 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyMaxConnectionsInThreads.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/channel/NettyMaxConnectionsInThreads.java
@@ -9,11 +9,12 @@
  *   http://www.apache.org/licenses/LICENSE-2.0.html
  * You may elect to redistribute this code under either of these licenses.
  *******************************************************************************/
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty.channel;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.MaxConnectionsInThreads;
+import org.asynchttpclient.channel.MaxConnectionsInThreads;
+import org.asynchttpclient.netty.NettyProviderUtil;
 
 public class NettyMaxConnectionsInThreads extends MaxConnectionsInThreads {
     @Override
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyMaxTotalConnectionTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/channel/NettyMaxTotalConnectionTest.java
similarity index 86%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyMaxTotalConnectionTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/channel/NettyMaxTotalConnectionTest.java
index 15e0892a6..e8faf3990 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyMaxTotalConnectionTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/channel/NettyMaxTotalConnectionTest.java
@@ -10,11 +10,12 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty.channel;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.MaxTotalConnectionTest;
+import org.asynchttpclient.channel.MaxTotalConnectionTest;
+import org.asynchttpclient.netty.NettyProviderUtil;
 
 public class NettyMaxTotalConnectionTest extends MaxTotalConnectionTest {
     @Override
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyFilterTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/filter/NettyFilterTest.java
similarity index 88%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyFilterTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/filter/NettyFilterTest.java
index f725ea228..a1854eea1 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyFilterTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/filter/NettyFilterTest.java
@@ -10,11 +10,12 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty.filter;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.FilterTest;
+import org.asynchttpclient.filter.FilterTest;
+import org.asynchttpclient.netty.NettyProviderUtil;
 import org.testng.annotations.Test;
 
 @Test
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyListenableFutureTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/future/NettyListenableFutureTest.java
similarity index 87%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyListenableFutureTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/future/NettyListenableFutureTest.java
index 723fc12d5..d71c19122 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyListenableFutureTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/future/NettyListenableFutureTest.java
@@ -10,11 +10,12 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty.future;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.ListenableFutureTest;
+import org.asynchttpclient.ListenableFutureTest;
+import org.asynchttpclient.netty.NettyProviderUtil;
 
 public class NettyListenableFutureTest extends ListenableFutureTest {
 
diff --git a/providers/netty3/src/test/java/org/asynchttpclient/netty/handler/NettyBodyDeferringAsyncHandlerTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/handler/NettyBodyDeferringAsyncHandlerTest.java
new file mode 100644
index 000000000..d3875b70a
--- /dev/null
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/handler/NettyBodyDeferringAsyncHandlerTest.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.handler;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.handler.BodyDeferringAsyncHandlerTest;
+import org.asynchttpclient.netty.NettyProviderUtil;
+
+public class NettyBodyDeferringAsyncHandlerTest extends BodyDeferringAsyncHandlerTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+
+}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyProxyTunnellingTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/ntlm/NettyNtlmTest.java
similarity index 66%
rename from providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyProxyTunnellingTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/ntlm/NettyNtlmTest.java
index 0d864e1fc..48a97d0e3 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/websocket/GrizzlyProxyTunnellingTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/ntlm/NettyNtlmTest.java
@@ -3,26 +3,27 @@
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the Apache License Version 2.0 is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.grizzly.websocket;
+package org.asynchttpclient.netty.ntlm;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.providers.grizzly.GrizzlyProviderUtil;
-import org.asynchttpclient.websocket.ProxyTunnellingTest;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.ntlm.NtlmTest;
 import org.testng.annotations.Test;
 
 @Test
-public class GrizzlyProxyTunnellingTest extends ProxyTunnellingTest {
+public class NettyNtlmTest extends NtlmTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 }
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyProxyTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/proxy/NettyProxyTest.java
similarity index 87%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyProxyTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/proxy/NettyProxyTest.java
index 7c381c111..43c37e567 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyProxyTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/proxy/NettyProxyTest.java
@@ -10,11 +10,12 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty.proxy;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.ProxyTest;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.proxy.ProxyTest;
 
 public class NettyProxyTest extends ProxyTest {
     @Override
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyProxyTunnellingTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/proxy/NettyProxyTunnellingTest.java
similarity index 83%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyProxyTunnellingTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/proxy/NettyProxyTunnellingTest.java
index 2d4705854..1086a91b6 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyProxyTunnellingTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/proxy/NettyProxyTunnellingTest.java
@@ -10,19 +10,16 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty.proxy;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.ProxyTunnellingTest;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.proxy.ProxyTunnellingTest;
 
 public class NettyProxyTunnellingTest extends ProxyTunnellingTest {
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return NettyProviderUtil.nettyProvider(config);
     }
-
-    public String getProviderClass() {
-        return NettyAsyncHttpProvider.class.getName();
-    }
 }
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyBodyChunkTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/request/body/NettyBodyChunkTest.java
similarity index 86%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyBodyChunkTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/request/body/NettyBodyChunkTest.java
index e8dacd968..9a0f316d5 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyBodyChunkTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/request/body/NettyBodyChunkTest.java
@@ -10,11 +10,12 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty.request.body;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.BodyChunkTest;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.request.body.BodyChunkTest;
 
 public class NettyBodyChunkTest extends BodyChunkTest {
 
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyChunkingTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/request/body/NettyChunkingTest.java
similarity index 66%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyChunkingTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/request/body/NettyChunkingTest.java
index 7783e21d5..02a756c96 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyChunkingTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/request/body/NettyChunkingTest.java
@@ -1,8 +1,9 @@
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty.request.body;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.ChunkingTest;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.request.body.ChunkingTest;
 
 public class NettyChunkingTest extends ChunkingTest {
     @Override
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyEmptyBodyTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/request/body/NettyEmptyBodyTest.java
similarity index 86%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyEmptyBodyTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/request/body/NettyEmptyBodyTest.java
index 8cdbe19e6..52c846454 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyEmptyBodyTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/request/body/NettyEmptyBodyTest.java
@@ -10,11 +10,12 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty.request.body;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.EmptyBodyTest;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.request.body.EmptyBodyTest;
 
 public class NettyEmptyBodyTest extends EmptyBodyTest {
 
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyFastUnauthorizedUploadTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/request/body/NettyFastUnauthorizedUploadTest.java
similarity index 86%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyFastUnauthorizedUploadTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/request/body/NettyFastUnauthorizedUploadTest.java
index 51128081d..9b6eae7ad 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyFastUnauthorizedUploadTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/request/body/NettyFastUnauthorizedUploadTest.java
@@ -10,11 +10,12 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty.request.body;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.FastUnauthorizedUploadTest;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.request.body.FastUnauthorizedUploadTest;
 import org.testng.annotations.Test;
 
 @Test
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyFilePartLargeFileTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/request/body/NettyFilePartLargeFileTest.java
similarity index 86%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyFilePartLargeFileTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/request/body/NettyFilePartLargeFileTest.java
index 8b9adcbd6..6265c04e4 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyFilePartLargeFileTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/request/body/NettyFilePartLargeFileTest.java
@@ -10,11 +10,12 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty.request.body;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.FilePartLargeFileTest;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.request.body.FilePartLargeFileTest;
 
 public class NettyFilePartLargeFileTest extends FilePartLargeFileTest {
     @Override
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyInputStreamTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/request/body/NettyInputStreamTest.java
similarity index 86%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyInputStreamTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/request/body/NettyInputStreamTest.java
index 5854ddc98..075a935fe 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyInputStreamTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/request/body/NettyInputStreamTest.java
@@ -10,11 +10,12 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty.request.body;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.InputStreamTest;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.request.body.InputStreamTest;
 
 public class NettyInputStreamTest extends InputStreamTest {
     @Override
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyPutLargeFileTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/request/body/NettyPutLargeFileTest.java
similarity index 86%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyPutLargeFileTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/request/body/NettyPutLargeFileTest.java
index 550847c06..e1e3394da 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyPutLargeFileTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/request/body/NettyPutLargeFileTest.java
@@ -10,11 +10,12 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty.request.body;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.PutLargeFileTest;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.request.body.PutLargeFileTest;
 
 public class NettyPutLargeFileTest extends PutLargeFileTest {
     @Override
diff --git a/providers/netty3/src/test/java/org/asynchttpclient/netty/request/body/NettyReactiveStreamsTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/request/body/NettyReactiveStreamsTest.java
new file mode 100644
index 000000000..9d953bf93
--- /dev/null
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/request/body/NettyReactiveStreamsTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.request.body;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.request.body.ReactiveStreamsTest;
+
+public class NettyReactiveStreamsTest extends ReactiveStreamsTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty3/src/test/java/org/asynchttpclient/netty/request/body/NettyTransferListenerTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/request/body/NettyTransferListenerTest.java
new file mode 100644
index 000000000..32c093167
--- /dev/null
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/request/body/NettyTransferListenerTest.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.request.body;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.request.body.TransferListenerTest;
+import org.testng.annotations.Test;
+
+@Test
+public class NettyTransferListenerTest extends TransferListenerTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyZeroCopyFileTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/request/body/NettyZeroCopyFileTest.java
similarity index 86%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyZeroCopyFileTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/request/body/NettyZeroCopyFileTest.java
index 3e98117d0..6db5e3573 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyZeroCopyFileTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/request/body/NettyZeroCopyFileTest.java
@@ -10,11 +10,12 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty.request.body;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.ZeroCopyFileTest;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.request.body.ZeroCopyFileTest;
 
 public class NettyZeroCopyFileTest extends ZeroCopyFileTest {
     @Override
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyMultipartUploadTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/request/body/multipart/NettyMultipartUploadTest.java
similarity index 85%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyMultipartUploadTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/request/body/multipart/NettyMultipartUploadTest.java
index fdbfb52d1..2b2454b59 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyMultipartUploadTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/request/body/multipart/NettyMultipartUploadTest.java
@@ -10,11 +10,12 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty.request.body.multipart;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.MultipartUploadTest;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.request.body.multipart.MultipartUploadTest;
 
 /**
  * @author dominict
diff --git a/providers/netty3/src/test/java/org/asynchttpclient/netty/simple/NettySimpleAsyncClientErrorBehaviourTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/simple/NettySimpleAsyncClientErrorBehaviourTest.java
new file mode 100644
index 000000000..1a4e965d4
--- /dev/null
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/simple/NettySimpleAsyncClientErrorBehaviourTest.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.simple;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.simple.SimpleAsyncClientErrorBehaviourTest;
+
+public class NettySimpleAsyncClientErrorBehaviourTest extends SimpleAsyncClientErrorBehaviourTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty3/src/test/java/org/asynchttpclient/netty/simple/NettySimpleAsyncHttpClientTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/simple/NettySimpleAsyncHttpClientTest.java
new file mode 100644
index 000000000..bf36ef848
--- /dev/null
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/simple/NettySimpleAsyncHttpClientTest.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.simple;
+
+import org.asynchttpclient.simple.SimpleAsyncHttpClientTest;
+import org.testng.annotations.Test;
+
+@Test
+public class NettySimpleAsyncHttpClientTest extends SimpleAsyncHttpClientTest {
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyWebDavBasicTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/webdav/NettyWebDavBasicTest.java
similarity index 87%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyWebDavBasicTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/webdav/NettyWebDavBasicTest.java
index e3f938171..d7512671f 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyWebDavBasicTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/webdav/NettyWebDavBasicTest.java
@@ -10,11 +10,12 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty.webdav;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.WebDavBasicTest;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.webdav.WebDavBasicTest;
 
 public class NettyWebDavBasicTest extends WebDavBasicTest {
     @Override
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyByteMessageTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/ws/NettyByteMessageTest.java
similarity index 85%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyByteMessageTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/ws/NettyByteMessageTest.java
index 695db23d5..e93fcdf4a 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyByteMessageTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/ws/NettyByteMessageTest.java
@@ -10,12 +10,12 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty.websocket;
+package org.asynchttpclient.netty.ws;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.providers.netty.NettyProviderUtil;
-import org.asynchttpclient.websocket.ByteMessageTest;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.ws.ByteMessageTest;
 
 public class NettyByteMessageTest extends ByteMessageTest {
     @Override
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncStreamLifecycleTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/ws/NettyCloseCodeReasonMsgTest.java
similarity index 75%
rename from providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncStreamLifecycleTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/ws/NettyCloseCodeReasonMsgTest.java
index cee8d596d..51feb2451 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyAsyncStreamLifecycleTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/ws/NettyCloseCodeReasonMsgTest.java
@@ -10,17 +10,17 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-
-package org.asynchttpclient.providers.grizzly;
+package org.asynchttpclient.netty.ws;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.AsyncStreamLifecycleTest;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.ws.CloseCodeReasonMessageTest;
 
-public class GrizzlyAsyncStreamLifecycleTest extends AsyncStreamLifecycleTest {
+public class NettyCloseCodeReasonMsgTest extends CloseCodeReasonMessageTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 }
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyProxyTunnellingTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/ws/NettyProxyTunnellingTest.java
similarity index 85%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyProxyTunnellingTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/ws/NettyProxyTunnellingTest.java
index 2ce2156d9..b5749300a 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyProxyTunnellingTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/ws/NettyProxyTunnellingTest.java
@@ -10,12 +10,12 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty.websocket;
+package org.asynchttpclient.netty.ws;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.providers.netty.NettyProviderUtil;
-import org.asynchttpclient.websocket.ProxyTunnellingTest;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.ws.ProxyTunnellingTest;
 import org.testng.annotations.Test;
 
 @Test
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyRedirectTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/ws/NettyRedirectTest.java
similarity index 85%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyRedirectTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/ws/NettyRedirectTest.java
index 185ffb180..8afa59393 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyRedirectTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/ws/NettyRedirectTest.java
@@ -10,12 +10,12 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty.websocket;
+package org.asynchttpclient.netty.ws;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.providers.netty.NettyProviderUtil;
-import org.asynchttpclient.websocket.RedirectTest;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.ws.RedirectTest;
 
 public class NettyRedirectTest extends RedirectTest {
 
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyTextMessageTest.java b/providers/netty3/src/test/java/org/asynchttpclient/netty/ws/NettyTextMessageTest.java
similarity index 85%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyTextMessageTest.java
rename to providers/netty3/src/test/java/org/asynchttpclient/netty/ws/NettyTextMessageTest.java
index c1286255a..6c351283c 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyTextMessageTest.java
+++ b/providers/netty3/src/test/java/org/asynchttpclient/netty/ws/NettyTextMessageTest.java
@@ -10,12 +10,12 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty.websocket;
+package org.asynchttpclient.netty.ws;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.providers.netty.NettyProviderUtil;
-import org.asynchttpclient.websocket.TextMessageTest;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.ws.TextMessageTest;
 
 public class NettyTextMessageTest extends TextMessageTest {
     @Override
diff --git a/providers/grizzly/src/test/resources/300k.png b/providers/netty3/src/test/resources/300k.png
similarity index 100%
rename from providers/grizzly/src/test/resources/300k.png
rename to providers/netty3/src/test/resources/300k.png
diff --git a/providers/grizzly/src/test/resources/SimpleTextFile.txt b/providers/netty3/src/test/resources/SimpleTextFile.txt
similarity index 100%
rename from providers/grizzly/src/test/resources/SimpleTextFile.txt
rename to providers/netty3/src/test/resources/SimpleTextFile.txt
diff --git a/providers/grizzly/src/test/resources/client.keystore b/providers/netty3/src/test/resources/client.keystore
similarity index 100%
rename from providers/grizzly/src/test/resources/client.keystore
rename to providers/netty3/src/test/resources/client.keystore
diff --git a/providers/grizzly/src/test/resources/gzip.txt.gz b/providers/netty3/src/test/resources/gzip.txt.gz
similarity index 100%
rename from providers/grizzly/src/test/resources/gzip.txt.gz
rename to providers/netty3/src/test/resources/gzip.txt.gz
diff --git a/providers/grizzly/src/test/resources/logback-test.xml b/providers/netty3/src/test/resources/logback-test.xml
similarity index 100%
rename from providers/grizzly/src/test/resources/logback-test.xml
rename to providers/netty3/src/test/resources/logback-test.xml
diff --git a/providers/grizzly/src/test/resources/realm.properties b/providers/netty3/src/test/resources/realm.properties
similarity index 100%
rename from providers/grizzly/src/test/resources/realm.properties
rename to providers/netty3/src/test/resources/realm.properties
diff --git a/providers/grizzly/src/test/resources/ssltest-cacerts.jks b/providers/netty3/src/test/resources/ssltest-cacerts.jks
similarity index 100%
rename from providers/grizzly/src/test/resources/ssltest-cacerts.jks
rename to providers/netty3/src/test/resources/ssltest-cacerts.jks
diff --git a/providers/grizzly/src/test/resources/ssltest-keystore.jks b/providers/netty3/src/test/resources/ssltest-keystore.jks
similarity index 100%
rename from providers/grizzly/src/test/resources/ssltest-keystore.jks
rename to providers/netty3/src/test/resources/ssltest-keystore.jks
diff --git a/providers/grizzly/src/test/resources/textfile.txt b/providers/netty3/src/test/resources/textfile.txt
similarity index 100%
rename from providers/grizzly/src/test/resources/textfile.txt
rename to providers/netty3/src/test/resources/textfile.txt
diff --git a/providers/grizzly/src/test/resources/textfile2.txt b/providers/netty3/src/test/resources/textfile2.txt
similarity index 100%
rename from providers/grizzly/src/test/resources/textfile2.txt
rename to providers/netty3/src/test/resources/textfile2.txt
diff --git a/providers/netty4/pom.xml b/providers/netty4/pom.xml
new file mode 100644
index 000000000..19f8bc8d6
--- /dev/null
+++ b/providers/netty4/pom.xml
@@ -0,0 +1,36 @@
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+	<parent>
+		<groupId>org.asynchttpclient</groupId>
+		<artifactId>async-http-client-providers-parent</artifactId>
+		<version>2.0.0-SNAPSHOT</version>
+	</parent>
+	<modelVersion>4.0.0</modelVersion>
+	<artifactId>async-http-client-netty4</artifactId>
+	<name>Asynchronous Http Client Netty 4 Provider</name>
+	<description>
+        The Async Http Client Netty 4 Provider.
+    </description>
+
+	<dependencies>
+		<dependency>
+			<groupId>io.netty</groupId>
+			<artifactId>netty-codec-http</artifactId>
+			<version>4.0.30.Final</version>
+		</dependency>
+		<dependency>
+			<groupId>com.typesafe.netty</groupId>
+			<artifactId>netty-reactive-streams</artifactId>
+			<version>1.0.0-M2</version>
+		</dependency>
+		<dependency>
+			<groupId>org.javassist</groupId>
+			<artifactId>javassist</artifactId>
+			<version>3.20.0-GA</version>
+		</dependency>
+		<dependency>
+			<groupId>com.jcraft</groupId>
+			<artifactId>jzlib</artifactId>
+			<version>1.1.3</version>
+		</dependency>
+	</dependencies>
+</project>
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/Callback.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/Callback.java
similarity index 85%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/Callback.java
rename to providers/netty4/src/main/java/org/asynchttpclient/netty/Callback.java
index 14328ca42..2e4393f85 100644
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/Callback.java
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/Callback.java
@@ -10,13 +10,12 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty;
 
-import org.asynchttpclient.providers.netty.future.NettyResponseFuture;
 
 public abstract class Callback {
 
-    private final NettyResponseFuture<?> future;
+    protected final NettyResponseFuture<?> future;
 
     public Callback(NettyResponseFuture<?> future) {
         this.future = future;
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/response/EagerNettyResponseBodyPart.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/EagerNettyResponseBodyPart.java
similarity index 93%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/response/EagerNettyResponseBodyPart.java
rename to providers/netty4/src/main/java/org/asynchttpclient/netty/EagerNettyResponseBodyPart.java
index e993bd497..3261473af 100755
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/response/EagerNettyResponseBodyPart.java
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/EagerNettyResponseBodyPart.java
@@ -10,10 +10,9 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty.response;
-
-import static org.asynchttpclient.providers.netty.util.ByteBufUtils.*;
+package org.asynchttpclient.netty;
 
+import static org.asynchttpclient.netty.util.ByteBufUtils.*;
 import io.netty.buffer.ByteBuf;
 
 import java.io.ByteArrayInputStream;
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/response/LazyNettyResponseBodyPart.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/LazyNettyResponseBodyPart.java
similarity index 97%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/response/LazyNettyResponseBodyPart.java
rename to providers/netty4/src/main/java/org/asynchttpclient/netty/LazyNettyResponseBodyPart.java
index d3f136b9f..d07b08770 100755
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/response/LazyNettyResponseBodyPart.java
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/LazyNettyResponseBodyPart.java
@@ -10,7 +10,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty.response;
+package org.asynchttpclient.netty;
 
 import io.netty.buffer.ByteBuf;
 
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyAsyncHttpProvider.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/NettyAsyncHttpProvider.java
similarity index 79%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyAsyncHttpProvider.java
rename to providers/netty4/src/main/java/org/asynchttpclient/netty/NettyAsyncHttpProvider.java
index 48cf1c06c..65c588844 100755
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/NettyAsyncHttpProvider.java
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/NettyAsyncHttpProvider.java
@@ -11,12 +11,11 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty;
 
 import io.netty.util.HashedWheelTimer;
 import io.netty.util.Timer;
 
-import java.io.IOException;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import org.asynchttpclient.AsyncHandler;
@@ -24,9 +23,9 @@
 import org.asynchttpclient.AsyncHttpProvider;
 import org.asynchttpclient.ListenableFuture;
 import org.asynchttpclient.Request;
-import org.asynchttpclient.providers.netty.channel.ChannelManager;
-import org.asynchttpclient.providers.netty.channel.pool.ChannelPoolPartitionSelector;
-import org.asynchttpclient.providers.netty.request.NettyRequestSender;
+import org.asynchttpclient.netty.channel.ChannelManager;
+import org.asynchttpclient.netty.channel.pool.ChannelPoolPartitionSelector;
+import org.asynchttpclient.netty.request.NettyRequestSender;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -34,7 +33,6 @@
 
     private static final Logger LOGGER = LoggerFactory.getLogger(NettyAsyncHttpProvider.class);
 
-    private final NettyAsyncHttpProviderConfig nettyConfig;
     private final AtomicBoolean closed = new AtomicBoolean(false);
     private final ChannelManager channelManager;
     private final NettyRequestSender requestSender;
@@ -43,7 +41,7 @@
 
     public NettyAsyncHttpProvider(AsyncHttpClientConfig config) {
 
-        nettyConfig = config.getAsyncHttpProviderConfig() instanceof NettyAsyncHttpProviderConfig ? //
+        NettyAsyncHttpProviderConfig nettyConfig = config.getAsyncHttpProviderConfig() instanceof NettyAsyncHttpProviderConfig ? //
         (NettyAsyncHttpProviderConfig) config.getAsyncHttpProviderConfig()
                 : new NettyAsyncHttpProviderConfig();
 
@@ -51,7 +49,7 @@ public NettyAsyncHttpProvider(AsyncHttpClientConfig config) {
         nettyTimer = allowStopNettyTimer ? newNettyTimer() : nettyConfig.getNettyTimer();
 
         channelManager = new ChannelManager(config, nettyConfig, nettyTimer);
-        requestSender = new NettyRequestSender(config, nettyConfig, channelManager, nettyTimer, closed);
+        requestSender = new NettyRequestSender(config, channelManager, nettyTimer, closed);
         channelManager.configureBootstraps(requestSender, closed);
     }
 
@@ -77,8 +75,13 @@ public void close() {
     }
 
     @Override
-    public <T> ListenableFuture<T> execute(Request request, final AsyncHandler<T> asyncHandler) throws IOException {
-        return requestSender.sendRequest(request, asyncHandler, null, false);
+    public <T> ListenableFuture<T> execute(Request request, final AsyncHandler<T> asyncHandler) {
+        try {
+            return requestSender.sendRequest(request, asyncHandler, null, false);
+        } catch (Exception e) {
+            asyncHandler.onThrowable(e);
+            return new ListenableFuture.CompletedFailure<>(e);
+        }
     }
 
     public void flushChannelPoolPartition(String partitionId) {
diff --git a/providers/netty4/src/main/java/org/asynchttpclient/netty/NettyAsyncHttpProviderConfig.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/NettyAsyncHttpProviderConfig.java
new file mode 100755
index 000000000..dfa4f2f84
--- /dev/null
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/NettyAsyncHttpProviderConfig.java
@@ -0,0 +1,221 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelOption;
+import io.netty.channel.ChannelPipeline;
+import io.netty.channel.EventLoopGroup;
+import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.codec.http.HttpResponse;
+import io.netty.util.Timer;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.AsyncHttpProviderConfig;
+import org.asynchttpclient.channel.pool.ConnectionStrategy;
+import org.asynchttpclient.netty.channel.pool.ChannelPool;
+import org.asynchttpclient.netty.handler.DefaultConnectionStrategy;
+import org.asynchttpclient.netty.ws.NettyWebSocket;
+
+/**
+ * This class can be used to pass Netty's internal configuration options. See
+ * Netty documentation for more information.
+ */
+public class NettyAsyncHttpProviderConfig implements AsyncHttpProviderConfig<ChannelOption<Object>, Object> {
+
+    private final Map<ChannelOption<Object>, Object> properties = new HashMap<>();
+
+    /**
+     * Add a property that will be used when the AsyncHttpClient initialize its
+     * {@link org.asynchttpclient.AsyncHttpProvider}
+     * 
+     * @param name the name of the property
+     * @param value the value of the property
+     * @return this instance of AsyncHttpProviderConfig
+     */
+    public NettyAsyncHttpProviderConfig addProperty(ChannelOption<Object> name, Object value) {
+        properties.put(name, value);
+        return this;
+    }
+
+    @SuppressWarnings("unchecked")
+    public <T> NettyAsyncHttpProviderConfig addChannelOption(ChannelOption<T> name, T value) {
+        properties.put((ChannelOption<Object>) name, value);
+        return this;
+    }
+
+    /**
+     * Return the value associated with the property's name
+     * 
+     * @param name
+     * @return this instance of AsyncHttpProviderConfig
+     */
+    public Object getProperty(ChannelOption<Object> name) {
+        return properties.get(name);
+    }
+
+    /**
+     * Remove the value associated with the property's name
+     * 
+     * @param name
+     * @return true if removed
+     */
+    public Object removeProperty(ChannelOption<Object> name) {
+        return properties.remove(name);
+    }
+
+    /**
+     * Return the curent entry set.
+     * 
+     * @return a the curent entry set.
+     */
+    public Set<Map.Entry<ChannelOption<Object>, Object>> propertiesSet() {
+        return properties.entrySet();
+    }
+
+    public static interface AdditionalPipelineInitializer {
+
+        void initPipeline(ChannelPipeline pipeline) throws Exception;
+    }
+
+    public static interface ResponseBodyPartFactory {
+
+        NettyResponseBodyPart newResponseBodyPart(ByteBuf buf, boolean last);
+    }
+
+    public static class EagerResponseBodyPartFactory implements ResponseBodyPartFactory {
+
+        @Override
+        public NettyResponseBodyPart newResponseBodyPart(ByteBuf buf, boolean last) {
+            return new EagerNettyResponseBodyPart(buf, last);
+        }
+    }
+
+    public static class LazyResponseBodyPartFactory implements ResponseBodyPartFactory {
+
+        @Override
+        public NettyResponseBodyPart newResponseBodyPart(ByteBuf buf, boolean last) {
+            return new LazyNettyResponseBodyPart(buf, last);
+        }
+    }
+
+    public static interface NettyWebSocketFactory {
+        NettyWebSocket newNettyWebSocket(Channel channel, AsyncHttpClientConfig config);
+    }
+
+    public class DefaultNettyWebSocketFactory implements NettyWebSocketFactory {
+
+        @Override
+        public NettyWebSocket newNettyWebSocket(Channel channel, AsyncHttpClientConfig config) {
+            return new NettyWebSocket(channel, config);
+        }
+    }
+
+    /**
+     * Allow configuring the Netty's event loop.
+     */
+    private EventLoopGroup eventLoopGroup;
+
+    private Class<? extends Channel> socketChannelClass;
+
+    private AdditionalPipelineInitializer httpAdditionalPipelineInitializer;
+    private AdditionalPipelineInitializer wsAdditionalPipelineInitializer;
+
+    private ResponseBodyPartFactory bodyPartFactory = new EagerResponseBodyPartFactory();
+
+    private ChannelPool channelPool;
+
+    private Timer nettyTimer;
+
+    private NettyWebSocketFactory nettyWebSocketFactory = new DefaultNettyWebSocketFactory();
+
+    private ConnectionStrategy<HttpRequest, HttpResponse> connectionStrategy = new DefaultConnectionStrategy();
+
+    public EventLoopGroup getEventLoopGroup() {
+        return eventLoopGroup;
+    }
+
+    public void setEventLoopGroup(EventLoopGroup eventLoopGroup) {
+        this.eventLoopGroup = eventLoopGroup;
+    }
+
+    public Class<? extends Channel> getSocketChannelClass() {
+        return socketChannelClass;
+    }
+
+    public void setSocketChannelClass(Class<? extends Channel> socketChannelClass) {
+        this.socketChannelClass = socketChannelClass;
+    }
+
+    public AdditionalPipelineInitializer getHttpAdditionalPipelineInitializer() {
+        return httpAdditionalPipelineInitializer;
+    }
+
+    public void setHttpAdditionalPipelineInitializer(AdditionalPipelineInitializer httpAdditionalPipelineInitializer) {
+        this.httpAdditionalPipelineInitializer = httpAdditionalPipelineInitializer;
+    }
+
+    public AdditionalPipelineInitializer getWsAdditionalPipelineInitializer() {
+        return wsAdditionalPipelineInitializer;
+    }
+
+    public void setWsAdditionalPipelineInitializer(AdditionalPipelineInitializer wsAdditionalPipelineInitializer) {
+        this.wsAdditionalPipelineInitializer = wsAdditionalPipelineInitializer;
+    }
+
+    public ResponseBodyPartFactory getBodyPartFactory() {
+        return bodyPartFactory;
+    }
+
+    public void setBodyPartFactory(ResponseBodyPartFactory bodyPartFactory) {
+        this.bodyPartFactory = bodyPartFactory;
+    }
+
+    public ChannelPool getChannelPool() {
+        return channelPool;
+    }
+
+    public void setChannelPool(ChannelPool channelPool) {
+        this.channelPool = channelPool;
+    }
+
+    public Timer getNettyTimer() {
+        return nettyTimer;
+    }
+
+    public void setNettyTimer(Timer nettyTimer) {
+        this.nettyTimer = nettyTimer;
+    }
+
+    public NettyWebSocketFactory getNettyWebSocketFactory() {
+        return nettyWebSocketFactory;
+    }
+
+    public void setNettyWebSocketFactory(NettyWebSocketFactory nettyWebSocketFactory) {
+        this.nettyWebSocketFactory = nettyWebSocketFactory;
+    }
+
+    public ConnectionStrategy<HttpRequest, HttpResponse> getConnectionStrategy() {
+        return connectionStrategy;
+    }
+
+    public void setConnectionStrategy(ConnectionStrategy<HttpRequest, HttpResponse> connectionStrategy) {
+        this.connectionStrategy = connectionStrategy;
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/response/NettyResponse.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/NettyResponse.java
similarity index 73%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/response/NettyResponse.java
rename to providers/netty4/src/main/java/org/asynchttpclient/netty/NettyResponse.java
index 17d593541..5d6bb29e3 100755
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/response/NettyResponse.java
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/NettyResponse.java
@@ -11,9 +11,8 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty.response;
+package org.asynchttpclient.netty;
 
-import static org.asynchttpclient.util.AsyncHttpProviderUtils.contentToBytes;
 import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 import io.netty.handler.codec.http.HttpHeaders;
 
@@ -21,6 +20,7 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.ByteBuffer;
+import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -28,36 +28,19 @@
 import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.HttpResponseHeaders;
 import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.ResponseBase;
 import org.asynchttpclient.cookie.Cookie;
 import org.asynchttpclient.cookie.CookieDecoder;
-import org.asynchttpclient.date.TimeConverter;
-import org.asynchttpclient.providers.ResponseBase;
 
 /**
  * Wrapper around the {@link org.asynchttpclient.Response} API.
  */
 public class NettyResponse extends ResponseBase {
 
-    private final TimeConverter timeConverter;
-
     public NettyResponse(HttpResponseStatus status,//
             HttpResponseHeaders headers,//
-            List<HttpResponseBodyPart> bodyParts,//
-            TimeConverter timeConverter) {
+            List<HttpResponseBodyPart> bodyParts) {
         super(status, headers, bodyParts);
-        this.timeConverter = timeConverter;
-    }
-
-    @Override
-    public String getResponseBodyExcerpt(int maxLength) throws IOException {
-        return getResponseBodyExcerpt(maxLength, null);
-    }
-
-    public String getResponseBodyExcerpt(int maxLength, String charset) throws IOException {
-        // should be fine; except that it may split multi-byte chars (last char may become '?')
-        charset = calculateCharset(charset);
-        byte[] b = contentToBytes(bodyParts, maxLength);
-        return new String(b, charset);
     }
 
     protected List<Cookie> buildCookies() {
@@ -69,9 +52,9 @@ public String getResponseBodyExcerpt(int maxLength, String charset) throws IOExc
         }
 
         if (isNonEmpty(setCookieHeaders)) {
-            List<Cookie> cookies = new ArrayList<Cookie>();
+            List<Cookie> cookies = new ArrayList<>();
             for (String value : setCookieHeaders) {
-                Cookie c = CookieDecoder.decode(value, timeConverter);
+                Cookie c = CookieDecoder.decode(value);
                 if (c != null)
                     cookies.add(c);
             }
@@ -106,7 +89,7 @@ public String getResponseBody() throws IOException {
     }
 
     @Override
-    public String getResponseBody(String charset) throws IOException {
+    public String getResponseBody(Charset charset) throws IOException {
         return new String(getResponseBodyAsBytes(), calculateCharset(charset));
     }
 
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/response/NettyResponseBodyPart.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/NettyResponseBodyPart.java
similarity index 96%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/response/NettyResponseBodyPart.java
rename to providers/netty4/src/main/java/org/asynchttpclient/netty/NettyResponseBodyPart.java
index 76399a14e..a17eb1e62 100755
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/response/NettyResponseBodyPart.java
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/NettyResponseBodyPart.java
@@ -11,7 +11,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty.response;
+package org.asynchttpclient.netty;
 
 import org.asynchttpclient.HttpResponseBodyPart;
 
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/future/NettyResponseFuture.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/NettyResponseFuture.java
similarity index 84%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/future/NettyResponseFuture.java
rename to providers/netty4/src/main/java/org/asynchttpclient/netty/NettyResponseFuture.java
index c9fbef429..5c0573c37 100755
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/future/NettyResponseFuture.java
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/NettyResponseFuture.java
@@ -11,12 +11,11 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty.future;
+package org.asynchttpclient.netty;
 
 import static org.asynchttpclient.util.DateUtils.millisTime;
 import io.netty.channel.Channel;
 import io.netty.handler.codec.http.HttpHeaders;
-import io.netty.handler.codec.http.HttpResponse;
 
 import java.net.SocketAddress;
 import java.util.concurrent.CancellationException;
@@ -31,13 +30,13 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.ConnectionPoolPartitioning;
-import org.asynchttpclient.ProxyServer;
 import org.asynchttpclient.Request;
-import org.asynchttpclient.listenable.AbstractListenableFuture;
-import org.asynchttpclient.providers.netty.channel.Channels;
-import org.asynchttpclient.providers.netty.request.NettyRequest;
-import org.asynchttpclient.providers.netty.request.timeout.TimeoutsHolder;
+import org.asynchttpclient.channel.pool.ConnectionPoolPartitioning;
+import org.asynchttpclient.future.AbstractListenableFuture;
+import org.asynchttpclient.netty.channel.Channels;
+import org.asynchttpclient.netty.request.NettyRequest;
+import org.asynchttpclient.netty.timeout.TimeoutsHolder;
+import org.asynchttpclient.proxy.ProxyServer;
 import org.asynchttpclient.uri.Uri;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -55,8 +54,6 @@
         NEW, POOLED, RECONNECTED, CLOSED,
     }
 
-    private volatile boolean requestTimeoutReached;
-    private volatile boolean idleConnectionTimeoutReached;
     private final long start = millisTime();
     private final ConnectionPoolPartitioning connectionPoolPartitioning;
     private final ProxyServer proxyServer;
@@ -71,31 +68,28 @@
     private final AtomicBoolean inAuth = new AtomicBoolean(false);
     private final AtomicBoolean statusReceived = new AtomicBoolean(false);
     private final AtomicLong touch = new AtomicLong(millisTime());
-    private final AtomicReference<STATE> state = new AtomicReference<STATE>(STATE.NEW);
+    private final AtomicReference<STATE> state = new AtomicReference<>(STATE.NEW);
     private final AtomicBoolean contentProcessed = new AtomicBoolean(false);
     private final AtomicInteger currentRetry = new AtomicInteger(0);
     private final AtomicBoolean onThrowableCalled = new AtomicBoolean(false);
-    private final AtomicReference<V> content = new AtomicReference<V>();
-    private final AtomicReference<ExecutionException> exEx = new AtomicReference<ExecutionException>();
+    private final AtomicReference<V> content = new AtomicReference<>();
+    private final AtomicReference<ExecutionException> exEx = new AtomicReference<>();
     private volatile TimeoutsHolder timeoutsHolder;
 
     // state mutated only inside the event loop
     private Channel channel;
-    private Uri uri;
     private boolean keepAlive = true;
     private Request request;
     private NettyRequest nettyRequest;
     private HttpHeaders httpHeaders;
     private AsyncHandler<V> asyncHandler;
-    private HttpResponse pendingResponse;
     private boolean streamWasAlreadyConsumed;
     private boolean reuseChannel;
     private boolean headersAlreadyWrittenOnContinue;
     private boolean dontWriteBodyBecauseExpectContinue;
     private boolean allowConnect;
 
-    public NettyResponseFuture(Uri uri,//
-            Request request,//
+    public NettyResponseFuture(Request request,//
             AsyncHandler<V> asyncHandler,//
             NettyRequest nettyRequest,//
             int maxRetry,//
@@ -105,7 +99,6 @@ public NettyResponseFuture(Uri uri,//
         this.asyncHandler = asyncHandler;
         this.request = request;
         this.nettyRequest = nettyRequest;
-        this.uri = uri;
         this.connectionPoolPartitioning = connectionPoolPartitioning;
         this.proxyServer = proxyServer;
         this.maxRetry = maxRetry;
@@ -117,7 +110,7 @@ public NettyResponseFuture(Uri uri,//
 
     @Override
     public boolean isDone() {
-        return isDone.get() || isCancelled.get();
+        return isDone.get() || isCancelled();
     }
 
     @Override
@@ -132,8 +125,11 @@ public boolean cancel(boolean force) {
         if (isCancelled.getAndSet(true))
             return false;
 
-        Channels.setDiscard(channel);
-        Channels.silentlyCloseChannel(channel);
+        // cancel could happen before channel was attached
+        if (channel != null) {
+            Channels.setDiscard(channel);
+            Channels.silentlyCloseChannel(channel);
+        }
 
         if (!onThrowableCalled.getAndSet(true)) {
             try {
@@ -162,6 +158,9 @@ public V get(long l, TimeUnit tu) throws InterruptedException, TimeoutException,
 
     private V getContent() throws ExecutionException {
 
+        if (isCancelled())
+            throw new CancellationException();
+
         ExecutionException e = exEx.get();
         if (e != null)
             throw e;
@@ -195,11 +194,16 @@ private V getContent() throws ExecutionException {
     /**   org.asynchttpclient.ListenableFuture  **/
     /*********************************************/
 
-    public final void done() {
-
+    private boolean terminateAndExit() {
         cancelTimeouts();
+        this.channel = null;
+        this.reuseChannel = false;
+        return isDone.getAndSet(true) || isCancelled.get();
+    }
 
-        if (isDone.getAndSet(true) || isCancelled.get())
+    public final void done() {
+
+        if (terminateAndExit())
             return;
 
         try {
@@ -220,12 +224,11 @@ public final void done() {
 
     public final void abort(final Throwable t) {
 
-        cancelTimeouts();
+        exEx.compareAndSet(null, new ExecutionException(t));
 
-        if (isDone.get() || isCancelled.getAndSet(true))
+        if (terminateAndExit())
             return;
 
-        exEx.compareAndSet(null, new ExecutionException(t));
         if (onThrowableCalled.compareAndSet(false, true)) {
             try {
                 asyncHandler.onThrowable(t);
@@ -247,11 +250,7 @@ public void touch() {
     /*********************************************/
 
     public Uri getUri() {
-        return uri;
-    }
-
-    public void setUri(Uri uri) {
-        this.uri = uri;
+        return request.getUri();
     }
 
     public ConnectionPoolPartitioning getConnectionPoolPartitioning() {
@@ -266,31 +265,6 @@ public void setAsyncHandler(AsyncHandler<V> asyncHandler) {
         this.asyncHandler = asyncHandler;
     }
 
-    /**
-     * Is the Future still valid
-     * 
-     * @return <code>true</code> if response has expired and should be terminated.
-     */
-    public boolean hasExpired() {
-        return requestTimeoutReached || idleConnectionTimeoutReached;
-    }
-
-    public void setRequestTimeoutReached() {
-        this.requestTimeoutReached = true;
-    }
-
-    public boolean isRequestTimeoutReached() {
-        return requestTimeoutReached;
-    }
-
-    public void setIdleConnectionTimeoutReached() {
-        this.idleConnectionTimeoutReached = true;
-    }
-
-    public boolean isIdleConnectionTimeoutReached() {
-        return idleConnectionTimeoutReached;
-    }
-
     public void cancelTimeouts() {
         if (timeoutsHolder != null) {
             timeoutsHolder.cancel();
@@ -358,14 +332,6 @@ public boolean getAndSetStatusReceived(boolean sr) {
         return statusReceived.getAndSet(sr);
     }
 
-    public HttpResponse getPendingResponse() {
-        return pendingResponse;
-    }
-
-    public void setPendingResponse(HttpResponse pendingResponse) {
-        this.pendingResponse = pendingResponse;
-    }
-
     public boolean isStreamWasAlreadyConsumed() {
         return streamWasAlreadyConsumed;
     }
@@ -407,6 +373,12 @@ public void setConnectAllowed(boolean allowConnect) {
     }
 
     public void attachChannel(Channel channel, boolean reuseChannel) {
+
+        // future could have been cancelled first
+        if (isDone()) {
+            Channels.silentlyCloseChannel(channel);
+        }
+
         this.channel = channel;
         this.reuseChannel = reuseChannel;
     }
@@ -420,10 +392,7 @@ public boolean reuseChannel() {
     }
 
     public boolean canRetry() {
-        if (currentRetry.incrementAndGet() > maxRetry) {
-            return false;
-        }
-        return true;
+        return maxRetry > 0 && currentRetry.incrementAndGet() <= maxRetry;
     }
 
     public SocketAddress getChannelRemoteAddress() {
@@ -442,13 +411,17 @@ public void setRequest(Request request) {
      */
     public boolean canBeReplayed() {
         return !isDone() && canRetry()
-                && !(Channels.isChannelValid(channel) && !uri.getScheme().equalsIgnoreCase("https")) && !isInAuth();
+                && !(Channels.isChannelValid(channel) && !getUri().getScheme().equalsIgnoreCase("https")) && !isInAuth();
     }
 
     public long getStart() {
         return start;
     }
 
+    public Object getPartitionKey() {
+        return connectionPoolPartitioning.getPartitionKey(request.getUri(), request.getVirtualHost(), proxyServer);
+    }
+
     @Override
     public String toString() {
         return "NettyResponseFuture{" + //
@@ -458,7 +431,7 @@ public String toString() {
                 ",\n\tasyncHandler=" + asyncHandler + //
                 ",\n\tnettyRequest=" + nettyRequest + //
                 ",\n\tcontent=" + content + //
-                ",\n\turi=" + uri + //
+                ",\n\turi=" + getUri() + //
                 ",\n\tkeepAlive=" + keepAlive + //
                 ",\n\thttpHeaders=" + httpHeaders + //
                 ",\n\texEx=" + exEx + //
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/response/NettyResponseHeaders.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/NettyResponseHeaders.java
similarity index 97%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/response/NettyResponseHeaders.java
rename to providers/netty4/src/main/java/org/asynchttpclient/netty/NettyResponseHeaders.java
index 375f0cd3b..d87272d39 100755
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/response/NettyResponseHeaders.java
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/NettyResponseHeaders.java
@@ -11,7 +11,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty.response;
+package org.asynchttpclient.netty;
 
 import io.netty.handler.codec.http.HttpHeaders;
 
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/response/NettyResponseStatus.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/NettyResponseStatus.java
similarity index 76%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/response/NettyResponseStatus.java
rename to providers/netty4/src/main/java/org/asynchttpclient/netty/NettyResponseStatus.java
index b94260f56..3de33a95f 100755
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/response/NettyResponseStatus.java
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/NettyResponseStatus.java
@@ -11,7 +11,13 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty.response;
+package org.asynchttpclient.netty;
+
+import io.netty.channel.Channel;
+import io.netty.handler.codec.http.HttpResponse;
+
+import java.net.SocketAddress;
+import java.util.List;
 
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.HttpResponseBodyPart;
@@ -20,25 +26,30 @@
 import org.asynchttpclient.Response;
 import org.asynchttpclient.uri.Uri;
 
-import io.netty.handler.codec.http.HttpResponse;
-
-import java.util.List;
-
 /**
  * A class that represent the HTTP response' status line (code + text)
  */
 public class NettyResponseStatus extends HttpResponseStatus {
 
     private final HttpResponse response;
+    private final SocketAddress remoteAddress;
+    private final SocketAddress localAddress;
 
-    public NettyResponseStatus(Uri uri, AsyncHttpClientConfig config, HttpResponse response) {
+    public NettyResponseStatus(Uri uri, AsyncHttpClientConfig config, HttpResponse response, Channel channel) {
         super(uri, config);
         this.response = response;
+        if (channel != null) {
+            remoteAddress = channel.remoteAddress();
+            localAddress = channel.localAddress();
+        } else {
+            remoteAddress = null;
+            localAddress = null;
+        }
     }
 
     @Override
     public Response prepareResponse(HttpResponseHeaders headers, List<HttpResponseBodyPart> bodyParts) {
-        return new NettyResponse(this, headers, bodyParts, config.getTimeConverter());
+        return new NettyResponse(this, headers, bodyParts);
     }
 
     /**
@@ -78,4 +89,14 @@ public int getProtocolMinorVersion() {
     public String getProtocolText() {
         return response.getProtocolVersion().text();
     }
+
+    @Override
+    public SocketAddress getRemoteAddress() {
+        return remoteAddress;
+    }
+
+    @Override
+    public SocketAddress getLocalAddress() {
+        return localAddress;
+    }
 }
diff --git a/providers/netty4/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java
new file mode 100755
index 000000000..57bb88c67
--- /dev/null
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java
@@ -0,0 +1,460 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.channel;
+
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.getExplicitPort;
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.getSchemeDefaultPort;
+import static org.asynchttpclient.util.HttpUtils.WS;
+import static org.asynchttpclient.util.HttpUtils.isSecure;
+import static org.asynchttpclient.util.HttpUtils.isWebSocket;
+import static org.asynchttpclient.util.MiscUtils.buildStaticIOException;
+import io.netty.bootstrap.Bootstrap;
+import io.netty.buffer.PooledByteBufAllocator;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelInitializer;
+import io.netty.channel.ChannelOption;
+import io.netty.channel.ChannelPipeline;
+import io.netty.channel.EventLoopGroup;
+import io.netty.channel.group.ChannelGroup;
+import io.netty.channel.nio.NioEventLoopGroup;
+import io.netty.channel.oio.OioEventLoopGroup;
+import io.netty.channel.socket.nio.NioSocketChannel;
+import io.netty.handler.codec.http.HttpClientCodec;
+import io.netty.handler.codec.http.HttpContentDecompressor;
+import io.netty.handler.codec.http.websocketx.WebSocket08FrameDecoder;
+import io.netty.handler.codec.http.websocketx.WebSocket08FrameEncoder;
+import io.netty.handler.codec.http.websocketx.WebSocketFrameAggregator;
+import io.netty.handler.ssl.SslHandler;
+import io.netty.handler.stream.ChunkedWriteHandler;
+import io.netty.util.Timer;
+import io.netty.util.concurrent.DefaultThreadFactory;
+import io.netty.util.internal.chmv8.ConcurrentHashMapV8;
+
+import java.io.IOException;
+import java.security.GeneralSecurityException;
+import java.util.Map.Entry;
+import java.util.concurrent.Semaphore;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import javax.net.ssl.SSLEngine;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.channel.SSLEngineFactory;
+import org.asynchttpclient.channel.pool.ConnectionPoolPartitioning;
+import org.asynchttpclient.handler.AsyncHandlerExtensions;
+import org.asynchttpclient.netty.Callback;
+import org.asynchttpclient.netty.NettyAsyncHttpProviderConfig;
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.channel.pool.ChannelPool;
+import org.asynchttpclient.netty.channel.pool.ChannelPoolPartitionSelector;
+import org.asynchttpclient.netty.channel.pool.DefaultChannelPool;
+import org.asynchttpclient.netty.channel.pool.NoopChannelPool;
+import org.asynchttpclient.netty.handler.HttpProtocol;
+import org.asynchttpclient.netty.handler.Processor;
+import org.asynchttpclient.netty.handler.WebSocketProtocol;
+import org.asynchttpclient.netty.request.NettyRequestSender;
+import org.asynchttpclient.proxy.ProxyServer;
+import org.asynchttpclient.uri.Uri;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class ChannelManager {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(ChannelManager.class);
+    public static final String HTTP_HANDLER = "httpHandler";
+    public static final String SSL_HANDLER = "sslHandler";
+    public static final String HTTP_PROCESSOR = "httpProcessor";
+    public static final String WS_PROCESSOR = "wsProcessor";
+    public static final String DEFLATER_HANDLER = "deflater";
+    public static final String INFLATER_HANDLER = "inflater";
+    public static final String CHUNKED_WRITER_HANDLER = "chunkedWriter";
+    public static final String WS_DECODER_HANDLER = "ws-decoder";
+    public static final String WS_FRAME_AGGREGATOR = "ws-aggregator";
+    public static final String WS_ENCODER_HANDLER = "ws-encoder";
+
+    private final AsyncHttpClientConfig config;
+    private final NettyAsyncHttpProviderConfig nettyConfig;
+    private final SSLEngineFactory sslEngineFactory;
+    private final EventLoopGroup eventLoopGroup;
+    private final boolean allowReleaseEventLoopGroup;
+    private final Class<? extends Channel> socketChannelClass;
+    private final Bootstrap httpBootstrap;
+    private final Bootstrap wsBootstrap;
+    private final long handshakeTimeout;
+    private final IOException tooManyConnections;
+    private final IOException tooManyConnectionsPerHost;
+    private final IOException poolAlreadyClosed;
+
+    private final ChannelPool channelPool;
+    private final boolean maxTotalConnectionsEnabled;
+    private final Semaphore freeChannels;
+    private final ChannelGroup openChannels;
+    private final boolean maxConnectionsPerHostEnabled;
+    private final ConcurrentHashMapV8<Object, Semaphore> freeChannelsPerHost;
+    private final ConcurrentHashMapV8<Channel, Object> channelId2PartitionKey;
+    private final ConcurrentHashMapV8.Fun<Object, Semaphore> semaphoreComputer;
+
+    private Processor wsProcessor;
+
+    public ChannelManager(final AsyncHttpClientConfig config, NettyAsyncHttpProviderConfig nettyConfig, Timer nettyTimer) {
+
+        this.config = config;
+        this.nettyConfig = nettyConfig;
+        this.sslEngineFactory = config.getSslEngineFactory() != null? config.getSslEngineFactory() : new SSLEngineFactory.DefaultSSLEngineFactory(config);
+
+        ChannelPool channelPool = nettyConfig.getChannelPool();
+        if (channelPool == null && config.isAllowPoolingConnections()) {
+            channelPool = new DefaultChannelPool(config, nettyTimer);
+        } else if (channelPool == null) {
+            channelPool = new NoopChannelPool();
+        }
+        this.channelPool = channelPool;
+
+        tooManyConnections = buildStaticIOException(String.format("Too many connections %s", config.getMaxConnections()));
+        tooManyConnectionsPerHost = buildStaticIOException(String.format("Too many connections per host %s", config.getMaxConnectionsPerHost()));
+        poolAlreadyClosed = buildStaticIOException("Pool is already closed");
+        maxTotalConnectionsEnabled = config.getMaxConnections() > 0;
+        maxConnectionsPerHostEnabled = config.getMaxConnectionsPerHost() > 0;
+
+        if (maxTotalConnectionsEnabled || maxConnectionsPerHostEnabled) {
+            openChannels = new CleanupChannelGroup("asyncHttpClient") {
+                @Override
+                public boolean remove(Object o) {
+                    boolean removed = super.remove(o);
+                    if (removed) {
+                        if (maxTotalConnectionsEnabled)
+                            freeChannels.release();
+                        if (maxConnectionsPerHostEnabled) {
+                            Object partitionKey = channelId2PartitionKey.remove(Channel.class.cast(o));
+                            if (partitionKey != null) {
+                                Semaphore freeChannelsForHost = freeChannelsPerHost.get(partitionKey);
+                                if (freeChannelsForHost != null)
+                                    freeChannelsForHost.release();
+                            }
+                        }
+                    }
+                    return removed;
+                }
+            };
+            freeChannels = new Semaphore(config.getMaxConnections());
+        } else {
+            openChannels = new CleanupChannelGroup("asyncHttpClient");
+            freeChannels = null;
+        }
+
+        if (maxConnectionsPerHostEnabled) {
+            freeChannelsPerHost = new ConcurrentHashMapV8<>();
+            channelId2PartitionKey = new ConcurrentHashMapV8<>();
+            semaphoreComputer = new ConcurrentHashMapV8.Fun<Object, Semaphore>() {
+                @Override
+                public Semaphore apply(Object partitionKey) {
+                    return new Semaphore(config.getMaxConnectionsPerHost());
+                }
+            };
+        } else {
+            freeChannelsPerHost = null;
+            channelId2PartitionKey = null;
+            semaphoreComputer = null;
+        }
+
+        handshakeTimeout = config.getHandshakeTimeout();
+
+        // check if external EventLoopGroup is defined
+        allowReleaseEventLoopGroup = nettyConfig.getEventLoopGroup() == null;
+        if (allowReleaseEventLoopGroup) {
+            DefaultThreadFactory threadFactory = new DefaultThreadFactory(config.getNameOrDefault());
+            eventLoopGroup = new NioEventLoopGroup(0, threadFactory);
+        } else {
+            eventLoopGroup = nettyConfig.getEventLoopGroup();
+        }
+        if (eventLoopGroup instanceof OioEventLoopGroup)
+            throw new IllegalArgumentException("Oio is not supported");
+
+        // allow users to specify SocketChannel class and default to NioSocketChannel
+        socketChannelClass = nettyConfig.getSocketChannelClass() == null ? NioSocketChannel.class : nettyConfig.getSocketChannelClass();
+
+        httpBootstrap = new Bootstrap().channel(socketChannelClass).group(eventLoopGroup);
+        wsBootstrap = new Bootstrap().channel(socketChannelClass).group(eventLoopGroup);
+
+        // default to PooledByteBufAllocator
+        httpBootstrap.option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);
+        wsBootstrap.option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);
+
+        if (config.getConnectTimeout() > 0)
+            nettyConfig.addChannelOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, config.getConnectTimeout());
+        for (Entry<ChannelOption<Object>, Object> entry : nettyConfig.propertiesSet()) {
+            ChannelOption<Object> key = entry.getKey();
+            Object value = entry.getValue();
+            httpBootstrap.option(key, value);
+            wsBootstrap.option(key, value);
+        }
+    }
+
+    public void configureBootstraps(NettyRequestSender requestSender, AtomicBoolean closed) {
+
+        HttpProtocol httpProtocol = new HttpProtocol(this, config, nettyConfig, requestSender);
+        final Processor httpProcessor = new Processor(config, nettyConfig, this, requestSender, httpProtocol);
+
+        WebSocketProtocol wsProtocol = new WebSocketProtocol(this, config, nettyConfig, requestSender);
+        wsProcessor = new Processor(config, nettyConfig, this, requestSender, wsProtocol);
+
+        httpBootstrap.handler(new ChannelInitializer<Channel>() {
+            @Override
+            protected void initChannel(Channel ch) throws Exception {
+                ch.pipeline()//
+                        .addLast(HTTP_HANDLER, newHttpClientCodec())//
+                        .addLast(INFLATER_HANDLER, newHttpContentDecompressor())//
+                        .addLast(CHUNKED_WRITER_HANDLER, new ChunkedWriteHandler())//
+                        .addLast(HTTP_PROCESSOR, httpProcessor);
+
+                ch.config().setOption(ChannelOption.AUTO_READ, false);
+
+                if (nettyConfig.getHttpAdditionalPipelineInitializer() != null)
+                    nettyConfig.getHttpAdditionalPipelineInitializer().initPipeline(ch.pipeline());
+            }
+        });
+
+        wsBootstrap.handler(new ChannelInitializer<Channel>() {
+            @Override
+            protected void initChannel(Channel ch) throws Exception {
+                ch.pipeline()//
+                        .addLast(HTTP_HANDLER, newHttpClientCodec())//
+                        .addLast(WS_PROCESSOR, wsProcessor);
+
+                if (nettyConfig.getWsAdditionalPipelineInitializer() != null)
+                    nettyConfig.getWsAdditionalPipelineInitializer().initPipeline(ch.pipeline());
+            }
+        });
+    }
+
+    private HttpContentDecompressor newHttpContentDecompressor() {
+        if (config.isKeepEncodingHeader())
+            return new HttpContentDecompressor() {
+                @Override
+                protected String getTargetContentEncoding(String contentEncoding) throws Exception {
+                    return contentEncoding;
+                }
+            };
+        else
+            return new HttpContentDecompressor();
+    }
+
+    public final void tryToOfferChannelToPool(Channel channel, AsyncHandler<?> handler, boolean keepAlive, Object partitionKey) {
+        if (channel.isActive() && keepAlive && channel.isActive()) {
+            LOGGER.debug("Adding key: {} for channel {}", partitionKey, channel);
+            Channels.setDiscard(channel);
+            if (handler instanceof AsyncHandlerExtensions) {
+                AsyncHandlerExtensions.class.cast(handler).onConnectionOffer(channel);
+            }
+            channelPool.offer(channel, partitionKey);
+            if (maxConnectionsPerHostEnabled)
+                channelId2PartitionKey.putIfAbsent(channel, partitionKey);
+        } else {
+            // not offered
+            closeChannel(channel);
+        }
+    }
+
+    public Channel poll(Uri uri, String virtualHost, ProxyServer proxy, ConnectionPoolPartitioning connectionPoolPartitioning) {
+        Object partitionKey = connectionPoolPartitioning.getPartitionKey(uri, virtualHost, proxy);
+        return channelPool.poll(partitionKey);
+    }
+
+    public boolean removeAll(Channel connection) {
+        return channelPool.removeAll(connection);
+    }
+
+    private boolean tryAcquireGlobal() {
+        return !maxTotalConnectionsEnabled || freeChannels.tryAcquire();
+    }
+
+    private Semaphore getFreeConnectionsForHost(Object partitionKey) {
+        return freeChannelsPerHost.computeIfAbsent(partitionKey, semaphoreComputer);
+    }
+
+    private boolean tryAcquirePerHost(Object partitionKey) {
+        return !maxConnectionsPerHostEnabled || getFreeConnectionsForHost(partitionKey).tryAcquire();
+    }
+
+    public void preemptChannel(Object partitionKey) throws IOException {
+        if (!channelPool.isOpen())
+            throw poolAlreadyClosed;
+        if (!tryAcquireGlobal())
+            throw tooManyConnections;
+        if (!tryAcquirePerHost(partitionKey)) {
+            if (maxTotalConnectionsEnabled)
+                freeChannels.release();
+
+            throw tooManyConnectionsPerHost;
+        }
+    }
+
+    public void close() {
+        channelPool.destroy();
+        openChannels.close();
+
+        for (Channel channel : openChannels) {
+            Object attribute = Channels.getAttribute(channel);
+            if (attribute instanceof NettyResponseFuture<?>) {
+                NettyResponseFuture<?> future = (NettyResponseFuture<?>) attribute;
+                future.cancelTimeouts();
+            }
+        }
+
+        if (allowReleaseEventLoopGroup)
+            eventLoopGroup.shutdownGracefully();
+    }
+
+    public void closeChannel(Channel channel) {
+
+        LOGGER.debug("Closing Channel {} ", channel);
+        removeAll(channel);
+        Channels.setDiscard(channel);
+        Channels.silentlyCloseChannel(channel);
+        openChannels.remove(channel);
+    }
+
+    public void abortChannelPreemption(Object partitionKey) {
+        if (maxTotalConnectionsEnabled)
+            freeChannels.release();
+        if (maxConnectionsPerHostEnabled)
+            getFreeConnectionsForHost(partitionKey).release();
+    }
+
+    public void registerOpenChannel(Channel channel, Object partitionKey) {
+        openChannels.add(channel);
+        if (maxConnectionsPerHostEnabled) {
+            channelId2PartitionKey.put(channel, partitionKey);
+        }
+    }
+
+    private HttpClientCodec newHttpClientCodec() {
+        return new HttpClientCodec(//
+                config.getHttpClientCodecMaxInitialLineLength(),//
+                config.getHttpClientCodecMaxHeaderSize(),//
+                config.getHttpClientCodecMaxChunkSize(),//
+                false);
+    }
+
+    private SslHandler createSslHandler(String peerHost, int peerPort) throws GeneralSecurityException {
+        SSLEngine sslEngine = sslEngineFactory.newSSLEngine(peerHost, peerPort);
+        SslHandler sslHandler = new SslHandler(sslEngine);
+        if (handshakeTimeout > 0)
+            sslHandler.setHandshakeTimeoutMillis(handshakeTimeout);
+        return sslHandler;
+    }
+
+    public static boolean isSslHandlerConfigured(ChannelPipeline pipeline) {
+        return pipeline.get(SSL_HANDLER) != null;
+    }
+
+    public void upgradeProtocol(ChannelPipeline pipeline, String scheme, String host, int port) throws GeneralSecurityException {
+        if (pipeline.get(HTTP_HANDLER) != null)
+            pipeline.remove(HTTP_HANDLER);
+
+        if (isSecure(scheme))
+            if (isSslHandlerConfigured(pipeline)) {
+                pipeline.addAfter(SSL_HANDLER, HTTP_HANDLER, newHttpClientCodec());
+            } else {
+                pipeline.addFirst(HTTP_HANDLER, newHttpClientCodec());
+                pipeline.addFirst(SSL_HANDLER, createSslHandler(host, port));
+            }
+
+        else
+            pipeline.addFirst(HTTP_HANDLER, newHttpClientCodec());
+
+        if (isWebSocket(scheme)) {
+            pipeline.addAfter(HTTP_PROCESSOR, WS_PROCESSOR, wsProcessor);
+            pipeline.remove(HTTP_PROCESSOR);
+        }
+    }
+
+    public SslHandler addSslHandler(ChannelPipeline pipeline, Uri uri, String virtualHost) throws GeneralSecurityException {
+        String peerHost;
+        int peerPort;
+        
+        if (virtualHost != null) {
+            int i = virtualHost.indexOf(':');
+            if (i == -1) {
+                peerHost = virtualHost;
+                peerPort = getSchemeDefaultPort(uri.getScheme());
+            } else {
+                peerHost = virtualHost.substring(0, i);
+                peerPort = Integer.valueOf(virtualHost.substring(i + 1));
+            }
+            
+        } else {
+            peerHost = uri.getHost();
+            peerPort = getExplicitPort(uri);
+        }
+
+        SslHandler sslHandler = createSslHandler(peerHost, peerPort);
+        pipeline.addFirst(ChannelManager.SSL_HANDLER, sslHandler);
+        return sslHandler;
+    }
+
+    /**
+     * Always make sure the channel who got cached support the proper protocol.
+     * It could only occurs when a HttpMethod. CONNECT is used against a proxy
+     * that requires upgrading from http to https.
+     */
+    public void verifyChannelPipeline(ChannelPipeline pipeline, Uri uri, String virtualHost) throws GeneralSecurityException {
+
+        boolean sslHandlerConfigured = isSslHandlerConfigured(pipeline);
+
+        if (isSecure(uri)) {
+            if (!sslHandlerConfigured)
+                addSslHandler(pipeline, uri, virtualHost);
+
+        } else if (sslHandlerConfigured)
+            pipeline.remove(SSL_HANDLER);
+    }
+
+    public Bootstrap getBootstrap(Uri uri, boolean useProxy) {
+        return uri.getScheme().startsWith(WS) && !useProxy ? wsBootstrap : httpBootstrap;
+    }
+
+    public void upgradePipelineForWebSockets(ChannelPipeline pipeline) {
+        pipeline.addAfter(HTTP_HANDLER, WS_ENCODER_HANDLER, new WebSocket08FrameEncoder(true));
+        pipeline.remove(HTTP_HANDLER);
+        pipeline.addBefore(WS_PROCESSOR, WS_DECODER_HANDLER, new WebSocket08FrameDecoder(false, false, config.getWebSocketMaxFrameSize()));
+        pipeline.addAfter(WS_DECODER_HANDLER, WS_FRAME_AGGREGATOR, new WebSocketFrameAggregator(config.getWebSocketMaxBufferSize()));
+    }
+
+    public final Callback newDrainCallback(final NettyResponseFuture<?> future, final Channel channel, final boolean keepAlive, final Object partitionKey) {
+
+        return new Callback(future) {
+            public void call() {
+                tryToOfferChannelToPool(channel, future.getAsyncHandler(), keepAlive, partitionKey);
+            }
+        };
+    }
+
+    public void drainChannelAndOffer(final Channel channel, final NettyResponseFuture<?> future) {
+        drainChannelAndOffer(channel, future, future.isKeepAlive(), future.getPartitionKey());
+    }
+
+    public void drainChannelAndOffer(final Channel channel, final NettyResponseFuture<?> future, boolean keepAlive, Object partitionKey) {
+        Channels.setAttribute(channel, newDrainCallback(future, channel, keepAlive, partitionKey));
+    }
+
+    public void flushPartition(String partitionId) {
+        channelPool.flushPartition(partitionId);
+    } 
+
+    public void flushPartitions(ChannelPoolPartitionSelector selector) {
+        channelPool.flushPartitions(selector);
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/Channels.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/channel/Channels.java
similarity index 94%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/Channels.java
rename to providers/netty4/src/main/java/org/asynchttpclient/netty/channel/Channels.java
index 02a0a6959..67adaa08f 100755
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/Channels.java
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/channel/Channels.java
@@ -11,13 +11,13 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty.channel;
+package org.asynchttpclient.netty.channel;
 
 import io.netty.channel.Channel;
 import io.netty.util.Attribute;
 import io.netty.util.AttributeKey;
 
-import org.asynchttpclient.providers.netty.DiscardEvent;
+import org.asynchttpclient.netty.DiscardEvent;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/CleanupChannelGroup.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/channel/CleanupChannelGroup.java
similarity index 98%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/CleanupChannelGroup.java
rename to providers/netty4/src/main/java/org/asynchttpclient/netty/channel/CleanupChannelGroup.java
index db52cb1de..b8f009bcd 100755
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/CleanupChannelGroup.java
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/channel/CleanupChannelGroup.java
@@ -25,7 +25,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.asynchttpclient.providers.netty.channel;
+package org.asynchttpclient.netty.channel;
 
 import io.netty.channel.Channel;
 import io.netty.channel.group.ChannelGroupFuture;
@@ -69,7 +69,7 @@ public ChannelGroupFuture close() {
                 return super.close();
             } else {
                 // FIXME DefaultChannelGroupFuture is package protected
-                // Collection<ChannelFuture> futures = new ArrayList<ChannelFuture>();
+                // Collection<ChannelFuture> futures = new ArrayList<>();
                 // logger.debug("CleanupChannelGroup already closed");
                 // return new DefaultChannelGroupFuture(ChannelGroup.class.cast(this), futures,
                 // GlobalEventExecutor.INSTANCE);
diff --git a/providers/netty4/src/main/java/org/asynchttpclient/netty/channel/NettyConnectListener.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/channel/NettyConnectListener.java
new file mode 100755
index 000000000..f7e23ee26
--- /dev/null
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/channel/NettyConnectListener.java
@@ -0,0 +1,149 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.channel;
+
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.getBaseUrl;
+import static org.asynchttpclient.util.HttpUtils.isSecure;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelFutureListener;
+import io.netty.handler.ssl.SslHandler;
+import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.GenericFutureListener;
+
+import java.net.ConnectException;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.handler.AsyncHandlerExtensions;
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.future.StackTraceInspector;
+import org.asynchttpclient.netty.request.NettyRequestSender;
+import org.asynchttpclient.uri.Uri;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Non Blocking connect.
+ */
+public final class NettyConnectListener<T> implements ChannelFutureListener {
+
+    private final static Logger LOGGER = LoggerFactory.getLogger(NettyConnectListener.class);
+
+    private final NettyRequestSender requestSender;
+    private final NettyResponseFuture<T> future;
+    private final ChannelManager channelManager;
+    private final boolean channelPreempted;
+    private final Object partitionKey;
+
+    public NettyConnectListener(NettyResponseFuture<T> future,//
+            NettyRequestSender requestSender,//
+            ChannelManager channelManager,//
+            boolean channelPreempted,//
+            Object partitionKey) {
+        this.future = future;
+        this.requestSender = requestSender;
+        this.channelManager = channelManager;
+        this.channelPreempted = channelPreempted;
+        this.partitionKey = partitionKey;
+    }
+
+    private void abortChannelPreemption() {
+        if (channelPreempted)
+            channelManager.abortChannelPreemption(partitionKey);
+    }
+
+    private void writeRequest(Channel channel) {
+
+        LOGGER.debug("Using non-cached Channel {} for {} '{}'",
+                channel,
+                future.getNettyRequest().getHttpRequest().getMethod(),
+                future.getNettyRequest().getHttpRequest().getUri());
+
+        Channels.setAttribute(channel, future);
+        
+        if (future.isDone()) {
+            abortChannelPreemption();
+            return;
+        }
+
+        if (future.getAsyncHandler() instanceof AsyncHandlerExtensions)
+            AsyncHandlerExtensions.class.cast(future.getAsyncHandler()).onConnectionOpened(channel);
+
+        channelManager.registerOpenChannel(channel, partitionKey);
+        future.attachChannel(channel, false);
+        requestSender.writeRequest(future, channel);
+    }
+
+    private void onFutureSuccess(final Channel channel) throws Exception {
+        
+        Request request = future.getRequest();
+        Uri uri = request.getUri();
+
+        // in case of proxy tunneling, we'll add the SslHandler later, after the CONNECT request
+        if (future.getProxyServer() == null && isSecure(uri)) {
+            SslHandler sslHandler = channelManager.addSslHandler(channel.pipeline(), uri, request.getVirtualHost());
+            sslHandler.handshakeFuture().addListener(new GenericFutureListener<Future<Channel>>() {
+                @Override
+                public void operationComplete(Future<Channel> handshakeFuture) throws Exception {
+                 
+                    if (handshakeFuture.isSuccess()) {
+                        final AsyncHandler<T> asyncHandler = future.getAsyncHandler();
+                        if (asyncHandler instanceof AsyncHandlerExtensions)
+                            AsyncHandlerExtensions.class.cast(asyncHandler).onSslHandshakeCompleted();
+
+                        writeRequest(channel);
+                    } else {
+                        onFutureFailure(channel, handshakeFuture.cause());
+                    }
+                }
+            });
+        
+        } else {
+            writeRequest(channel);
+        }
+    }
+
+    private void onFutureFailure(Channel channel, Throwable cause) {
+
+        abortChannelPreemption();
+
+        boolean canRetry = future.canRetry();
+        LOGGER.debug("Trying to recover from failing to connect channel {} with a retry value of {} ", channel, canRetry);
+        if (canRetry//
+                && cause != null//
+                && (future.getState() != NettyResponseFuture.STATE.NEW || StackTraceInspector.recoverOnNettyDisconnectException(cause))) {
+
+            if (requestSender.retry(future)) {
+                return;
+            }
+        }
+
+        LOGGER.debug("Failed to recover from connect exception: {} with channel {}", cause, channel);
+
+        boolean printCause = cause != null && cause.getMessage() != null;
+        String printedCause = printCause ? cause.getMessage() : getBaseUrl(future.getUri());
+        ConnectException e = new ConnectException(printedCause);
+        if (cause != null)
+            e.initCause(cause);
+        future.abort(e);
+    }
+
+    public final void operationComplete(ChannelFuture f) throws Exception {
+        if (f.isSuccess())
+            onFutureSuccess(f.channel());
+        else
+            onFutureFailure(f.channel(), f.cause());
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/pool/ChannelPool.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/channel/pool/ChannelPool.java
similarity index 81%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/pool/ChannelPool.java
rename to providers/netty4/src/main/java/org/asynchttpclient/netty/channel/pool/ChannelPool.java
index ce0480b77..5e29ef24b 100755
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/pool/ChannelPool.java
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/channel/pool/ChannelPool.java
@@ -11,7 +11,9 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty.channel.pool;
+package org.asynchttpclient.netty.channel.pool;
+
+import org.asynchttpclient.netty.channel.pool.ChannelPoolPartitionSelector;
 
 import io.netty.channel.Channel;
 
@@ -20,19 +22,19 @@
     /**
      * Add a channel to the pool
      * 
-     * @param partitionId a key used to retrieve the cached channel
+     * @param partitionKey a key used to retrieve the cached channel
      * @param channel an I/O channel
      * @return true if added.
      */
-    boolean offer(Channel channel, String partitionId);
+    boolean offer(Channel channel, Object partitionKey);
 
     /**
      * Remove the channel associated with the uri.
      * 
-     * @param partitionId the partition used when invoking offer
+     * @param partitionKey the partition used when invoking offer
      * @return the channel associated with the uri
      */
-    Channel poll(String partitionId);
+    Channel poll(Object partitionKey);
 
     /**
      * Remove all channels from the cache. A channel might have been associated with several uri.
@@ -58,9 +60,9 @@
     /**
      * Flush a partition
      * 
-     * @param partitionId
+     * @param partitionKey
      */
-    void flushPartition(String partitionId);
+    void flushPartition(Object partitionKey);
 
     /**
      * Flush partitions based on a selector
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/pool/DefaultChannelPool.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/channel/pool/DefaultChannelPool.java
similarity index 74%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/pool/DefaultChannelPool.java
rename to providers/netty4/src/main/java/org/asynchttpclient/netty/channel/pool/DefaultChannelPool.java
index 3e465a09a..024f2e52f 100755
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/pool/DefaultChannelPool.java
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/channel/pool/DefaultChannelPool.java
@@ -11,7 +11,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty.channel.pool;
+package org.asynchttpclient.netty.channel.pool;
 
 import static org.asynchttpclient.util.DateUtils.millisTime;
 import io.netty.channel.Channel;
@@ -19,31 +19,41 @@
 import io.netty.util.Timeout;
 import io.netty.util.Timer;
 import io.netty.util.TimerTask;
+import io.netty.util.internal.chmv8.ConcurrentHashMapV8;
 
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.providers.netty.channel.Channels;
-import org.asynchttpclient.providers.netty.future.NettyResponseFuture;
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.channel.Channels;
+import org.asynchttpclient.netty.channel.pool.ChannelPoolPartitionSelector;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 /**
- * A simple implementation of {@link com.ning.http.client.providers.netty.pool.ChannelPool} based on a {@link java.util.concurrent.ConcurrentHashMap}
+ * A simple implementation of
+ * {@link com.ning.http.client.providers.netty.pool.ChannelPool} based on a
+ * {@link java.util.concurrent.ConcurrentHashMap}
  */
 public final class DefaultChannelPool implements ChannelPool {
 
     private static final Logger LOGGER = LoggerFactory.getLogger(DefaultChannelPool.class);
 
-    private final ConcurrentHashMap<String, ConcurrentLinkedQueue<IdleChannel>> partitions = new ConcurrentHashMap<String, ConcurrentLinkedQueue<IdleChannel>>();
-    private final ConcurrentHashMap<Channel, ChannelCreation> channel2Creation = new ConcurrentHashMap<Channel, ChannelCreation>();
+    private static final ConcurrentHashMapV8.Fun<Object, ConcurrentLinkedQueue<IdleChannel>> PARTITION_COMPUTER = new ConcurrentHashMapV8.Fun<Object, ConcurrentLinkedQueue<IdleChannel>>() {
+        @Override
+        public ConcurrentLinkedQueue<IdleChannel> apply(Object partitionKey) {
+            return new ConcurrentLinkedQueue<>();
+        }
+    };
+
+    private final ConcurrentHashMapV8<Object, ConcurrentLinkedQueue<IdleChannel>> partitions = new ConcurrentHashMapV8<>();
+    private final ConcurrentHashMapV8<Integer, ChannelCreation> channelId2Creation = new ConcurrentHashMapV8<>();
     private final AtomicBoolean isClosed = new AtomicBoolean(false);
     private final Timer nettyTimer;
     private final boolean sslConnectionPoolEnabled;
@@ -60,8 +70,11 @@ public DefaultChannelPool(AsyncHttpClientConfig config, Timer hashedWheelTimer)
                 hashedWheelTimer);
     }
 
-    public DefaultChannelPool(
-            long maxIdleTime,//
+    private int channelId(Channel channel) {
+        return channel.hashCode();
+    }
+
+    public DefaultChannelPool(long maxIdleTime,//
             int maxConnectionTTL,//
             boolean sslConnectionPoolEnabled,//
             Timer nettyTimer) {
@@ -72,8 +85,7 @@ public DefaultChannelPool(
         this.nettyTimer = nettyTimer;
         maxIdleTimeDisabled = maxIdleTime <= 0;
 
-        cleanerPeriod = Math.min(maxConnectionTTLDisabled ? Long.MAX_VALUE : maxConnectionTTL, maxIdleTimeDisabled ? Long.MAX_VALUE
-                : maxIdleTime);
+        cleanerPeriod = Math.min(maxConnectionTTLDisabled ? Long.MAX_VALUE : maxConnectionTTL, maxIdleTimeDisabled ? Long.MAX_VALUE : maxIdleTime);
 
         if (!maxConnectionTTLDisabled || !maxIdleTimeDisabled)
             scheduleNewIdleChannelDetector(new IdleChannelDetector());
@@ -85,11 +97,11 @@ private void scheduleNewIdleChannelDetector(TimerTask task) {
 
     private static final class ChannelCreation {
         final long creationTime;
-        final String poolKey;
+        final Object partitionKey;
 
-        ChannelCreation(long creationTime, String poolKey) {
+        ChannelCreation(long creationTime, Object partitionKey) {
             this.creationTime = creationTime;
-            this.poolKey = poolKey;
+            this.partitionKey = partitionKey;
         }
     }
 
@@ -120,8 +132,8 @@ private boolean isTTLExpired(Channel channel, long now) {
         if (maxConnectionTTLDisabled)
             return false;
 
-        ChannelCreation creation = channel2Creation.get(channel);
-        return creation == null || now - creation.creationTime >= maxConnectionTTL;
+        ChannelCreation creation = channelId2Creation.get(channelId(channel));
+        return creation != null && now - creation.creationTime >= maxConnectionTTL;
     }
 
     private boolean isRemotelyClosed(Channel channel) {
@@ -138,11 +150,10 @@ private boolean isIdleTimeoutExpired(IdleChannel idleChannel, long now) {
             // lazy create
             List<IdleChannel> idleTimeoutChannels = null;
             for (IdleChannel idleChannel : partition) {
-                if (isTTLExpired(idleChannel.channel, now) || isIdleTimeoutExpired(idleChannel, now)
-                        || isRemotelyClosed(idleChannel.channel)) {
+                if (isTTLExpired(idleChannel.channel, now) || isIdleTimeoutExpired(idleChannel, now) || isRemotelyClosed(idleChannel.channel)) {
                     LOGGER.debug("Adding Candidate expired Channel {}", idleChannel.channel);
                     if (idleTimeoutChannels == null)
-                        idleTimeoutChannels = new ArrayList<IdleChannel>();
+                        idleTimeoutChannels = new ArrayList<>();
                     idleTimeoutChannels.add(idleChannel);
                 }
             }
@@ -154,8 +165,10 @@ private boolean isChannelCloseable(Channel channel) {
             Object attribute = Channels.getAttribute(channel);
             if (attribute instanceof NettyResponseFuture) {
                 NettyResponseFuture<?> future = (NettyResponseFuture<?>) attribute;
-                if (!future.isDone())
+                if (!future.isDone()) {
                     LOGGER.error("Future not in appropriate state %s, not closing", future);
+                    return false;
+                }
             }
             return true;
         }
@@ -167,17 +180,19 @@ private boolean isChannelCloseable(Channel channel) {
             for (int i = 0; i < candidates.size(); i++) {
                 IdleChannel idleChannel = candidates.get(i);
                 if (!isChannelCloseable(idleChannel.channel))
-                    if (closedChannels == null) {
-                        // first non closeable to be skipped, copy all previously skipped closeable channels
-                        closedChannels = new ArrayList<IdleChannel>(candidates.size());
-                        for (int j = 0; j < i; j++)
-                            closedChannels.add(candidates.get(j));
-                    } else {
+                    if (isChannelCloseable(idleChannel.channel)) {
                         LOGGER.debug("Closing Idle Channel {}", idleChannel.channel);
                         close(idleChannel.channel);
                         if (closedChannels != null) {
                             closedChannels.add(idleChannel);
                         }
+
+                    } else if (closedChannels == null) {
+                        // first non closeable to be skipped, copy all
+                        // previously skipped closeable channels
+                        closedChannels = new ArrayList<>(candidates.size());
+                        for (int j = 0; j < i; j++)
+                            closedChannels.add(candidates.get(j));
                     }
             }
 
@@ -191,7 +206,7 @@ public void run(Timeout timeout) throws Exception {
 
             try {
                 if (LOGGER.isDebugEnabled())
-                    for (String key : partitions.keySet()) {
+                    for (Object key: partitions.keySet()) {
                         LOGGER.debug("Entry count for : {} : {}", key, partitions.get(key).size());
                     }
 
@@ -201,7 +216,8 @@ public void run(Timeout timeout) throws Exception {
 
                 for (ConcurrentLinkedQueue<IdleChannel> partition : partitions.values()) {
 
-                    // store in intermediate unsynchronized lists to minimize the impact on the ConcurrentLinkedQueue
+                    // store in intermediate unsynchronized lists to minimize
+                    // the impact on the ConcurrentLinkedQueue
                     if (LOGGER.isDebugEnabled())
                         totalCount += partition.size();
 
@@ -209,7 +225,7 @@ public void run(Timeout timeout) throws Exception {
 
                     if (!closedChannels.isEmpty()) {
                         for (IdleChannel closedChannel : closedChannels)
-                            channel2Creation.remove(closedChannel.channel);
+                            channelId2Creation.remove(channelId(closedChannel.channel));
 
                         partition.removeAll(closedChannels);
                         closedCount += closedChannels.size();
@@ -228,22 +244,10 @@ public void run(Timeout timeout) throws Exception {
         }
     }
 
-    private ConcurrentLinkedQueue<IdleChannel> getPartition(String partitionId) {
-        ConcurrentLinkedQueue<IdleChannel> partition = partitions.get(partitionId);
-        if (partition == null) {
-            // lazy init pool
-            ConcurrentLinkedQueue<IdleChannel> newPartition = new ConcurrentLinkedQueue<IdleChannel>();
-            partition = partitions.putIfAbsent(partitionId, newPartition);
-            if (partition == null)
-                partition = newPartition;
-        }
-        return partition;
-    }
-    
     /**
      * {@inheritDoc}
      */
-    public boolean offer(Channel channel, String partitionId) {
+    public boolean offer(Channel channel, Object partitionKey) {
         if (isClosed.get() || (!sslConnectionPoolEnabled && channel.pipeline().get(SslHandler.class) != null))
             return false;
 
@@ -252,9 +256,9 @@ public boolean offer(Channel channel, String partitionId) {
         if (isTTLExpired(channel, now))
             return false;
 
-        boolean added = getPartition(partitionId).add(new IdleChannel(channel, now));
+        boolean added = partitions.computeIfAbsent(partitionKey, PARTITION_COMPUTER).add(new IdleChannel(channel, now));
         if (added)
-            channel2Creation.putIfAbsent(channel, new ChannelCreation(now, partitionId));
+            channelId2Creation.putIfAbsent(channelId(channel), new ChannelCreation(now, partitionKey));
 
         return added;
     }
@@ -262,12 +266,10 @@ public boolean offer(Channel channel, String partitionId) {
     /**
      * {@inheritDoc}
      */
-    public Channel poll(String partitionId) {
-        if (!sslConnectionPoolEnabled && partitionId.startsWith("https"))
-            return null;
+    public Channel poll(Object partitionKey) {
 
         IdleChannel idleChannel = null;
-        ConcurrentLinkedQueue<IdleChannel> partition = partitions.get(partitionId);
+        ConcurrentLinkedQueue<IdleChannel> partition = partitions.get(partitionKey);
         if (partition != null) {
             while (idleChannel == null) {
                 idleChannel = partition.poll();
@@ -288,8 +290,8 @@ else if (isRemotelyClosed(idleChannel.channel)) {
      * {@inheritDoc}
      */
     public boolean removeAll(Channel channel) {
-        ChannelCreation creation = channel2Creation.remove(channel);
-        return !isClosed.get() && creation != null && partitions.get(creation.poolKey).remove(channel);
+        ChannelCreation creation = channelId2Creation.remove(channelId(channel));
+        return !isClosed.get() && creation != null && partitions.get(creation.partitionKey).remove(channel);
     }
 
     /**
@@ -312,36 +314,36 @@ public void destroy() {
         }
 
         partitions.clear();
-        channel2Creation.clear();
+        channelId2Creation.clear();
     }
 
     private void close(Channel channel) {
         // FIXME pity to have to do this here
         Channels.setDiscard(channel);
-        channel2Creation.remove(channel);
+        channelId2Creation.remove(channelId(channel));
         Channels.silentlyCloseChannel(channel);
     }
 
-    private void flushPartition(String partitionId, ConcurrentLinkedQueue<IdleChannel> partition) {
+    private void flushPartition(Object partitionKey, ConcurrentLinkedQueue<IdleChannel> partition) {
         if (partition != null) {
-            partitions.remove(partitionId);
+            partitions.remove(partitionKey);
             for (IdleChannel idleChannel : partition)
                 close(idleChannel.channel);
         }
     }
-    
+
     @Override
-    public void flushPartition(String partitionId) {
-        flushPartition(partitionId, partitions.get(partitionId));
+    public void flushPartition(Object partitionKey) {
+        flushPartition(partitionKey, partitions.get(partitionKey));
     }
-    
+
     @Override
     public void flushPartitions(ChannelPoolPartitionSelector selector) {
 
-        for (Map.Entry<String, ConcurrentLinkedQueue<IdleChannel>> partitionsEntry : partitions.entrySet()) {
-            String partitionId = partitionsEntry.getKey();
-            if (selector.select(partitionId))
-                flushPartition(partitionId, partitionsEntry.getValue());
+        for (Map.Entry<Object, ConcurrentLinkedQueue<IdleChannel>> partitionsEntry : partitions.entrySet()) {
+            Object partitionKey = partitionsEntry.getKey();
+            if (selector.select(partitionKey))
+                flushPartition(partitionKey, partitionsEntry.getValue());
         }
     }
 }
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/pool/NoopChannelPool.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/channel/pool/NoopChannelPool.java
similarity index 80%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/pool/NoopChannelPool.java
rename to providers/netty4/src/main/java/org/asynchttpclient/netty/channel/pool/NoopChannelPool.java
index 342a044dd..44c37804d 100755
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/channel/pool/NoopChannelPool.java
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/channel/pool/NoopChannelPool.java
@@ -11,19 +11,21 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty.channel.pool;
+package org.asynchttpclient.netty.channel.pool;
+
+import org.asynchttpclient.netty.channel.pool.ChannelPoolPartitionSelector;
 
 import io.netty.channel.Channel;
 
 public class NoopChannelPool implements ChannelPool {
 
     @Override
-    public boolean offer(Channel channel, String poolKey) {
+    public boolean offer(Channel channel, Object partitionKey) {
         return false;
     }
 
     @Override
-    public Channel poll(String poolKey) {
+    public Channel poll(Object partitionKey) {
         return null;
     }
 
@@ -42,7 +44,7 @@ public void destroy() {
     }
 
     @Override
-    public void flushPartition(String partitionId) {
+    public void flushPartition(Object partitionKey) {
     }
 
     @Override
diff --git a/providers/netty4/src/main/java/org/asynchttpclient/netty/handler/DefaultConnectionStrategy.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/handler/DefaultConnectionStrategy.java
new file mode 100644
index 000000000..639fcd0a2
--- /dev/null
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/handler/DefaultConnectionStrategy.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.handler;
+
+import static io.netty.handler.codec.http.HttpHeaders.Names.CONNECTION;
+import static io.netty.handler.codec.http.HttpHeaders.Values.CLOSE;
+import static io.netty.handler.codec.http.HttpHeaders.Values.KEEP_ALIVE;
+import io.netty.handler.codec.http.HttpMessage;
+import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.codec.http.HttpResponse;
+import io.netty.handler.codec.http.HttpVersion;
+
+import org.asynchttpclient.channel.pool.ConnectionStrategy;
+
+/**
+ * Connection strategy implementing standard HTTP 1.0/1.1 behaviour.
+ */
+public class DefaultConnectionStrategy implements ConnectionStrategy<HttpRequest, HttpResponse> {
+
+    /**
+     * Implemented in accordance with RFC 7230 section 6.1
+     * https://tools.ietf.org/html/rfc7230#section-6.1
+     */
+    @Override
+    public boolean keepAlive(HttpRequest request, HttpResponse response) {
+
+        String responseConnectionHeader = connectionHeader(response);
+
+        if (CLOSE.equalsIgnoreCase(responseConnectionHeader)) {
+            return false;
+        } else {
+            String requestConnectionHeader = connectionHeader(request);
+
+            if (request.getProtocolVersion() == HttpVersion.HTTP_1_0) {
+                // only use keep-alive if both parties agreed upon it
+                return KEEP_ALIVE.equalsIgnoreCase(requestConnectionHeader) && KEEP_ALIVE.equalsIgnoreCase(responseConnectionHeader);
+
+            } else {
+                // 1.1+, keep-alive is default behavior
+                return !CLOSE.equalsIgnoreCase(requestConnectionHeader);
+            }
+        }
+    }
+
+    private String connectionHeader(HttpMessage message) {
+        return message.headers().get(CONNECTION);
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/handler/HttpProtocol.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/handler/HttpProtocol.java
similarity index 55%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/handler/HttpProtocol.java
rename to providers/netty4/src/main/java/org/asynchttpclient/netty/handler/HttpProtocol.java
index a7e9e1873..2b3642812 100755
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/handler/HttpProtocol.java
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/handler/HttpProtocol.java
@@ -11,15 +11,14 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty.handler;
+package org.asynchttpclient.netty.handler;
 
 import static io.netty.handler.codec.http.HttpResponseStatus.CONTINUE;
 import static io.netty.handler.codec.http.HttpResponseStatus.OK;
 import static io.netty.handler.codec.http.HttpResponseStatus.PROXY_AUTHENTICATION_REQUIRED;
 import static io.netty.handler.codec.http.HttpResponseStatus.UNAUTHORIZED;
-import static org.asynchttpclient.providers.netty.util.HttpUtils.isNTLM;
-import static org.asynchttpclient.util.AsyncHttpProviderUtils.getDefaultPort;
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+import static org.asynchttpclient.ntlm.NtlmUtils.getNTLM;
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.getExplicitPort;
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.Channel;
 import io.netty.handler.codec.http.HttpContent;
@@ -30,60 +29,97 @@
 import io.netty.handler.codec.http.LastHttpContent;
 
 import java.io.IOException;
+import java.security.GeneralSecurityException;
 import java.util.List;
 
 import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.AsyncHandler.STATE;
+import org.asynchttpclient.AsyncHandler.State;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
-import org.asynchttpclient.ProxyServer;
 import org.asynchttpclient.Realm;
+import org.asynchttpclient.Realm.AuthScheme;
 import org.asynchttpclient.Request;
 import org.asynchttpclient.RequestBuilder;
-import org.asynchttpclient.ntlm.NTLMEngine;
-import org.asynchttpclient.ntlm.NTLMEngineException;
-import org.asynchttpclient.providers.netty.Callback;
-import org.asynchttpclient.providers.netty.NettyAsyncHttpProviderConfig;
-import org.asynchttpclient.providers.netty.channel.ChannelManager;
-import org.asynchttpclient.providers.netty.channel.Channels;
-import org.asynchttpclient.providers.netty.future.NettyResponseFuture;
-import org.asynchttpclient.providers.netty.request.NettyRequestSender;
-import org.asynchttpclient.providers.netty.response.NettyResponseBodyPart;
-import org.asynchttpclient.providers.netty.response.NettyResponseHeaders;
-import org.asynchttpclient.providers.netty.response.NettyResponseStatus;
+import org.asynchttpclient.channel.pool.ConnectionStrategy;
+import org.asynchttpclient.handler.StreamedAsyncHandler;
+import org.asynchttpclient.netty.Callback;
+import org.asynchttpclient.netty.NettyAsyncHttpProviderConfig;
+import org.asynchttpclient.netty.NettyResponseBodyPart;
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.NettyResponseHeaders;
+import org.asynchttpclient.netty.NettyResponseStatus;
+import org.asynchttpclient.netty.channel.ChannelManager;
+import org.asynchttpclient.netty.channel.Channels;
+import org.asynchttpclient.netty.request.NettyRequestSender;
+import org.asynchttpclient.ntlm.NtlmEngine;
+import org.asynchttpclient.proxy.ProxyServer;
 import org.asynchttpclient.spnego.SpnegoEngine;
+import org.asynchttpclient.spnego.SpnegoEngineException;
 import org.asynchttpclient.uri.Uri;
 
 public final class HttpProtocol extends Protocol {
 
+    private final ConnectionStrategy<HttpRequest, HttpResponse> connectionStrategy;
+
     public HttpProtocol(ChannelManager channelManager, AsyncHttpClientConfig config, NettyAsyncHttpProviderConfig nettyConfig, NettyRequestSender requestSender) {
         super(channelManager, config, nettyConfig, requestSender);
-    }
 
-    private Realm.RealmBuilder newRealmBuilder(Realm realm) {
-        return realm != null ? new Realm.RealmBuilder().clone(realm) : new Realm.RealmBuilder();
+        connectionStrategy = nettyConfig.getConnectionStrategy();
     }
 
-    private Realm kerberosChallenge(Channel channel, List<String> proxyAuth, Request request, ProxyServer proxyServer, FluentCaseInsensitiveStringsMap headers, Realm realm,
-            NettyResponseFuture<?> future, boolean proxyInd) throws NTLMEngineException {
+    private Realm kerberosChallenge(Channel channel,//
+            List<String> authHeaders,//
+            Request request,//
+            FluentCaseInsensitiveStringsMap headers,//
+            Realm realm,//
+            NettyResponseFuture<?> future) {
 
         Uri uri = request.getUri();
         String host = request.getVirtualHost() == null ? uri.getHost() : request.getVirtualHost();
-        String server = proxyServer == null ? host : proxyServer.getHost();
         try {
-            String challengeHeader = SpnegoEngine.instance().generateToken(server);
+            String challengeHeader = SpnegoEngine.instance().generateToken(host);
             headers.remove(HttpHeaders.Names.AUTHORIZATION);
             headers.add(HttpHeaders.Names.AUTHORIZATION, "Negotiate " + challengeHeader);
 
-            return newRealmBuilder(realm)//
+            return new Realm.RealmBuilder().clone(realm)//
                     .setUri(uri)//
                     .setMethodName(request.getMethod())//
                     .setScheme(Realm.AuthScheme.KERBEROS)//
                     .build();
 
-        } catch (Throwable throwable) {
-            if (isNTLM(proxyAuth)) {
-                return ntlmChallenge(proxyAuth, request, proxyServer, headers, realm, future, proxyInd);
+
+        } catch (SpnegoEngineException throwable) {
+            String ntlmAuthenticate = getNTLM(authHeaders);
+            if (ntlmAuthenticate != null) {
+                return ntlmChallenge(ntlmAuthenticate, request, headers, realm, future);
+            }
+            requestSender.abort(channel, future, throwable);
+            return null;
+        }
+    }
+
+    private Realm kerberosProxyChallenge(Channel channel,//
+            List<String> proxyAuth,//
+            Request request,//
+            ProxyServer proxyServer,//
+            FluentCaseInsensitiveStringsMap headers,//
+            NettyResponseFuture<?> future) {
+
+        try {
+            String challengeHeader = SpnegoEngine.instance().generateToken(proxyServer.getHost());
+            headers.remove(HttpHeaders.Names.AUTHORIZATION);
+            headers.add(HttpHeaders.Names.AUTHORIZATION, "Negotiate " + challengeHeader);
+
+            return proxyServer.realmBuilder()//
+                    .setUri(request.getUri())//
+                    .setMethodName(request.getMethod())//
+                    .setScheme(Realm.AuthScheme.KERBEROS)//
+                    .build();
+
+        } catch (SpnegoEngineException throwable) {
+            String ntlmAuthenticate = getNTLM(proxyAuth);
+            if (ntlmAuthenticate != null) {
+                return ntlmProxyChallenge(ntlmAuthenticate, request, proxyServer, headers, future);
             }
             requestSender.abort(channel, future, throwable);
             return null;
@@ -98,94 +134,82 @@ private void addNTLMAuthorizationHeader(FluentCaseInsensitiveStringsMap headers,
         headers.add(authorizationHeaderName(proxyInd), "NTLM " + challengeHeader);
     }
 
-    private Realm ntlmChallenge(List<String> wwwAuth, Request request, ProxyServer proxyServer, FluentCaseInsensitiveStringsMap headers, Realm realm,
-            NettyResponseFuture<?> future, boolean proxyInd) throws NTLMEngineException {
-
-        boolean useRealm = proxyServer == null && realm != null;
-
-        String ntlmDomain = useRealm ? realm.getNtlmDomain() : proxyServer.getNtlmDomain();
-        String ntlmHost = useRealm ? realm.getNtlmHost() : proxyServer.getHost();
-        String principal = useRealm ? realm.getPrincipal() : proxyServer.getPrincipal();
-        String password = useRealm ? realm.getPassword() : proxyServer.getPassword();
-        Uri uri = request.getUri();
+    private Realm ntlmChallenge(String authenticateHeader,//
+            Request request,//
+            FluentCaseInsensitiveStringsMap headers,//
+            Realm realm,//
+            NettyResponseFuture<?> future) {
 
-        if (realm != null && !realm.isNtlmMessageType2Received()) {
-            String challengeHeader = NTLMEngine.INSTANCE.generateType1Msg(ntlmDomain, ntlmHost);
+        if (authenticateHeader.equals("NTLM")) {
+            // server replied bare NTLM => we didn't preemptively sent Type1Msg
+            String challengeHeader = NtlmEngine.INSTANCE.generateType1Msg();
 
-            addNTLMAuthorizationHeader(headers, challengeHeader, proxyInd);
+            addNTLMAuthorizationHeader(headers, challengeHeader, false);
             future.getAndSetAuth(false);
-            return newRealmBuilder(realm)//
-                    .setScheme(realm.getAuthScheme())//
-                    .setUri(uri)//
-                    .setMethodName(request.getMethod())//
-                    .setNtlmMessageType2Received(true)//
-                    .build();
 
         } else {
-            addType3NTLMAuthorizationHeader(wwwAuth, headers, principal, password, ntlmDomain, ntlmHost, proxyInd);
-            Realm.AuthScheme authScheme = realm != null ? realm.getAuthScheme() : Realm.AuthScheme.NTLM;
-            return newRealmBuilder(realm)//
-                    .setScheme(authScheme)//
-                    .setUri(uri)//
-                    .setMethodName(request.getMethod())//
-                    .build();
+            addType3NTLMAuthorizationHeader(authenticateHeader, headers, realm, false);
         }
+ 
+        return new Realm.RealmBuilder().clone(realm)//
+                .setUri(request.getUri())//
+                .setMethodName(request.getMethod())//
+                .build();
     }
 
-    private Realm ntlmProxyChallenge(List<String> wwwAuth, Request request, ProxyServer proxyServer, FluentCaseInsensitiveStringsMap headers, Realm realm,
-            NettyResponseFuture<?> future, boolean proxyInd) throws NTLMEngineException {
+    private Realm ntlmProxyChallenge(String authenticateHeader,//
+            Request request,//
+            ProxyServer proxyServer,//
+            FluentCaseInsensitiveStringsMap headers,//
+            NettyResponseFuture<?> future) {
+
         future.getAndSetAuth(false);
         headers.remove(HttpHeaders.Names.PROXY_AUTHORIZATION);
 
-        addType3NTLMAuthorizationHeader(wwwAuth, headers, proxyServer.getPrincipal(), proxyServer.getPassword(), proxyServer.getNtlmDomain(), proxyServer.getHost(), proxyInd);
-
-        return newRealmBuilder(realm)//
-                // .setScheme(realm.getAuthScheme())
+        Realm realm = proxyServer.realmBuilder()//
+                .setScheme(AuthScheme.NTLM)//
                 .setUri(request.getUri())//
                 .setMethodName(request.getMethod()).build();
+        
+        addType3NTLMAuthorizationHeader(authenticateHeader, headers, realm, true);
+
+        return realm;
     }
 
-    private void addType3NTLMAuthorizationHeader(List<String> auth, FluentCaseInsensitiveStringsMap headers, String username, String password, String domain, String workstation,
-            boolean proxyInd) throws NTLMEngineException {
+    private void addType3NTLMAuthorizationHeader(String authenticateHeader, FluentCaseInsensitiveStringsMap headers, Realm realm,
+            boolean proxyInd) {
         headers.remove(authorizationHeaderName(proxyInd));
 
-        if (isNonEmpty(auth) && auth.get(0).startsWith("NTLM ")) {
-            String serverChallenge = auth.get(0).trim().substring("NTLM ".length());
-            String challengeHeader = NTLMEngine.INSTANCE.generateType3Msg(username, password, domain, workstation, serverChallenge);
+        if (authenticateHeader.startsWith("NTLM ")) {
+            String serverChallenge = authenticateHeader.substring("NTLM ".length()).trim();
+            String challengeHeader = NtlmEngine.INSTANCE.generateType3Msg(realm.getPrincipal(), realm.getPassword(), realm.getNtlmDomain(), realm.getNtlmHost(), serverChallenge);
             addNTLMAuthorizationHeader(headers, challengeHeader, proxyInd);
         }
     }
 
     private void finishUpdate(final NettyResponseFuture<?> future, Channel channel, boolean expectOtherChunks) throws IOException {
 
+        future.cancelTimeouts();
+
         boolean keepAlive = future.isKeepAlive();
         if (expectOtherChunks && keepAlive)
-            channelManager.drainChannel(channel, future);
+            channelManager.drainChannelAndOffer(channel, future);
         else
-            channelManager.tryToOfferChannelToPool(channel, keepAlive, channelManager.getPartitionId(future));
-        markAsDone(future, channel);
-    }
+            channelManager.tryToOfferChannelToPool(channel, future.getAsyncHandler(), keepAlive, future.getPartitionKey());
 
-    private boolean updateBodyAndInterrupt(NettyResponseFuture<?> future, AsyncHandler<?> handler, NettyResponseBodyPart bodyPart) throws Exception {
-        boolean interrupt = handler.onBodyPartReceived(bodyPart) != STATE.CONTINUE;
-        if (bodyPart.isUnderlyingConnectionToBeClosed())
-            future.setKeepAlive(false);
-        return interrupt;
-    }
-
-    private void markAsDone(NettyResponseFuture<?> future, final Channel channel) {
-        // We need to make sure everything is OK before adding the
-        // connection back to the pool.
         try {
             future.done();
-        } catch (Throwable t) {
+        } catch (Exception t) {
             // Never propagate exception once we know we are done.
             logger.debug(t.getMessage(), t);
         }
+    }
 
-        if (!future.isKeepAlive() || !channel.isActive()) {
-            channelManager.closeChannel(channel);
-        }
+    private boolean updateBodyAndInterrupt(NettyResponseFuture<?> future, AsyncHandler<?> handler, NettyResponseBodyPart bodyPart) throws Exception {
+        boolean interrupt = handler.onBodyPartReceived(bodyPart) != State.CONTINUE;
+        if (bodyPart.isUnderlyingConnectionToBeClosed())
+            future.setKeepAlive(false);
+        return interrupt;
     }
 
     private boolean exitAfterHandling401(//
@@ -205,18 +229,21 @@ private boolean exitAfterHandling401(//
                 future.setState(NettyResponseFuture.STATE.NEW);
                 Realm newRealm = null;
                 boolean negociate = wwwAuthHeaders.contains("Negotiate");
-                if (!wwwAuthHeaders.contains("Kerberos") && (isNTLM(wwwAuthHeaders) || negociate)) {
+                String ntlmAuthenticate = getNTLM(wwwAuthHeaders);
+                if (!wwwAuthHeaders.contains("Kerberos") && ntlmAuthenticate != null) {
                     // NTLM
-                    newRealm = ntlmChallenge(wwwAuthHeaders, request, proxyServer, request.getHeaders(), realm, future, false);
+                    newRealm = ntlmChallenge(ntlmAuthenticate, request, request.getHeaders(), realm, future);
+
                 } else if (negociate) {
-                    newRealm = kerberosChallenge(channel, wwwAuthHeaders, request, proxyServer, request.getHeaders(), realm, future, false);
+                    newRealm = kerberosChallenge(channel, wwwAuthHeaders, request, request.getHeaders(), realm, future);
                     // SPNEGO KERBEROS
                     if (newRealm == null)
                         return true;
+
                 } else {
+                    // BASIC or DIGEST
                     newRealm = new Realm.RealmBuilder()//
                             .clone(realm)//
-                            .setScheme(realm.getAuthScheme())//
                             .setUri(request.getUri())//
                             .setMethodName(request.getMethod())//
                             .setUsePreemptiveAuth(true)//
@@ -224,23 +251,16 @@ private boolean exitAfterHandling401(//
                             .build();
                 }
 
-                Realm nr = newRealm;
-                final Request nextRequest = new RequestBuilder(future.getRequest()).setHeaders(request.getHeaders()).setRealm(nr).build();
+                final Request nextRequest = new RequestBuilder(future.getRequest()).setHeaders(request.getHeaders()).setRealm(newRealm).build();
 
                 logger.debug("Sending authentication to {}", request.getUri());
-                Callback callback = new Callback(future) {
-                    public void call() throws Exception {
-                        channelManager.drainChannel(channel, future);
-                        requestSender.sendNextRequest(nextRequest, future);
-                    }
-                };
-
-                if (future.isKeepAlive() && HttpHeaders.isTransferEncodingChunked(response))
-                    // We must make sure there is no bytes left
-                    // before executing the next request.
-                    Channels.setAttribute(channel, callback);
-                else
-                    callback.call();
+                if (future.isKeepAlive() && !HttpHeaders.isTransferEncodingChunked(response)) {
+                    future.setReuseChannel(true);
+                    requestSender.drainChannelAndExecuteNextRequest(channel, future, nextRequest);
+                } else {
+                    channelManager.closeChannel(channel);
+                    requestSender.sendNextRequest(nextRequest, future);
+                }
 
                 return true;
             }
@@ -253,10 +273,15 @@ private boolean exitAfterHandling100(final Channel channel, final NettyResponseF
         if (statusCode == CONTINUE.code()) {
             future.setHeadersAlreadyWrittenOnContinue(true);
             future.setDontWriteBodyBecauseExpectContinue(false);
-            // FIXME why not reuse the channel?
-            requestSender.writeRequest(future, channel);
+            // directly send the body
+            Channels.setAttribute(channel, new Callback(future) {
+                @Override
+                public void call() throws IOException {
+                    Channels.setAttribute(channel, future);
+                    requestSender.writeRequest(future, channel);
+                }
+            });
             return true;
-
         }
         return false;
     }
@@ -282,28 +307,40 @@ private boolean exitAfterHandling407(//
                 FluentCaseInsensitiveStringsMap requestHeaders = request.getHeaders();
 
                 boolean negociate = proxyAuthHeaders.contains("Negotiate");
-                if (!proxyAuthHeaders.contains("Kerberos") && (isNTLM(proxyAuthHeaders) || negociate)) {
-                    newRealm = ntlmProxyChallenge(proxyAuthHeaders, request, proxyServer, requestHeaders, realm, future, true);
-                    // SPNEGO KERBEROS
+                String ntlmAuthenticate = getNTLM(proxyAuthHeaders);
+                if (!proxyAuthHeaders.contains("Kerberos") && ntlmAuthenticate != null) {
+                    // NTLM
+                    newRealm = ntlmProxyChallenge(ntlmAuthenticate, request, proxyServer, requestHeaders, future);
+
                 } else if (negociate) {
-                    newRealm = kerberosChallenge(channel, proxyAuthHeaders, request, proxyServer, requestHeaders, realm, future, true);
+                    // SPNEGO KERBEROS
+                    newRealm = kerberosProxyChallenge(channel, proxyAuthHeaders, request, proxyServer, requestHeaders, future);
                     if (newRealm == null)
                         return true;
+
                 } else {
+                    // BASIC or DIGEST
                     newRealm = new Realm.RealmBuilder().clone(realm)//
-                            .setScheme(realm.getAuthScheme())//
                             .setUri(request.getUri())//
                             .setOmitQuery(true)//
-                            .setMethodName(HttpMethod.CONNECT.name())//
+                            .setMethodName(request.getMethod())//
                             .setUsePreemptiveAuth(true)//
                             .parseProxyAuthenticateHeader(proxyAuthHeaders.get(0))//
                             .build();
                 }
 
-                future.setReuseChannel(true);
-                future.setConnectAllowed(true);
-                Request nextRequest = new RequestBuilder(future.getRequest()).setHeaders(requestHeaders).setRealm(newRealm).build();
-                requestSender.sendNextRequest(nextRequest, future);
+                final Request nextRequest = new RequestBuilder(future.getRequest()).setHeaders(request.getHeaders()).setRealm(newRealm).build();
+
+                logger.debug("Sending proxy authentication to {}", request.getUri());
+                if (future.isKeepAlive() && !HttpHeaders.isTransferEncodingChunked(response)) {
+                    future.setConnectAllowed(true);
+                    future.setReuseChannel(true);
+                    requestSender.drainChannelAndExecuteNextRequest(channel, future, nextRequest);
+                } else {
+                    channelManager.closeChannel(channel);
+                    requestSender.sendNextRequest(nextRequest, future);
+                }
+
                 return true;
             }
         }
@@ -322,23 +359,24 @@ private boolean exitAfterHandlingConnect(//
 
             if (future.isKeepAlive())
                 future.attachChannel(channel, true);
-
+            
+            Uri requestUri = request.getUri();
+            String scheme = requestUri.getScheme();
+            String host = requestUri.getHost();
+            int port = getExplicitPort(requestUri);
+
+            logger.debug("Connecting to proxy {} for scheme {}", proxyServer, scheme);
+                
             try {
-                Uri requestUri = request.getUri();
-                String scheme = requestUri.getScheme();
-                String host = requestUri.getHost();
-                int port = getDefaultPort(requestUri);
-
-                logger.debug("Connecting to proxy {} for scheme {}", proxyServer, scheme);
                 channelManager.upgradeProtocol(channel.pipeline(), scheme, host, port);
+                future.setReuseChannel(true);
+                future.setConnectAllowed(false);
+                requestSender.drainChannelAndExecuteNextRequest(channel, future, new RequestBuilder(future.getRequest()).build());
 
-            } catch (Throwable ex) {
+            } catch (GeneralSecurityException ex) {
                 requestSender.abort(channel, future, ex);
             }
 
-            future.setReuseChannel(true);
-            future.setConnectAllowed(false);
-            requestSender.sendNextRequest(new RequestBuilder(future.getRequest()).build(), future);
             return true;
         }
 
@@ -347,7 +385,7 @@ private boolean exitAfterHandlingConnect(//
 
     private boolean exitAfterHandlingStatus(Channel channel, NettyResponseFuture<?> future, HttpResponse response, AsyncHandler<?> handler, NettyResponseStatus status)
             throws IOException, Exception {
-        if (!future.getAndSetStatusReceived(true) && handler.onStatusReceived(status) != STATE.CONTINUE) {
+        if (!future.getAndSetStatusReceived(true) && handler.onStatusReceived(status) != State.CONTINUE) {
             finishUpdate(future, channel, HttpHeaders.isTransferEncodingChunked(response));
             return true;
         }
@@ -356,13 +394,27 @@ private boolean exitAfterHandlingStatus(Channel channel, NettyResponseFuture<?>
 
     private boolean exitAfterHandlingHeaders(Channel channel, NettyResponseFuture<?> future, HttpResponse response, AsyncHandler<?> handler, NettyResponseHeaders responseHeaders)
             throws IOException, Exception {
-        if (!response.headers().isEmpty() && handler.onHeadersReceived(responseHeaders) != STATE.CONTINUE) {
+        if (!response.headers().isEmpty() && handler.onHeadersReceived(responseHeaders) != State.CONTINUE) {
             finishUpdate(future, channel, HttpHeaders.isTransferEncodingChunked(response));
             return true;
         }
         return false;
     }
 
+    private boolean exitAfterHandlingReactiveStreams(Channel channel, NettyResponseFuture<?> future, HttpResponse response, AsyncHandler<?> handler) throws IOException {
+        if (handler instanceof StreamedAsyncHandler) {
+            StreamedAsyncHandler<?> streamedAsyncHandler = (StreamedAsyncHandler<?>) handler;
+            StreamedResponsePublisher publisher = new StreamedResponsePublisher(channel.eventLoop(), channelManager, future, channel);
+            channel.pipeline().addLast(channel.eventLoop(), "streamedAsyncHandler", publisher);
+            Channels.setAttribute(channel, publisher);
+            if (streamedAsyncHandler.onStream(publisher) != State.CONTINUE) {
+                finishUpdate(future, channel, HttpHeaders.isTransferEncodingChunked(response));
+                return true;
+            }
+        }
+        return false;
+    }
+
     private boolean handleHttpResponse(final HttpResponse response, final Channel channel, final NettyResponseFuture<?> future, AsyncHandler<?> handler) throws Exception {
 
         HttpRequest httpRequest = future.getNettyRequest().getHttpRequest();
@@ -373,9 +425,9 @@ private boolean handleHttpResponse(final HttpResponse response, final Channel ch
         // the handler in case of trailing headers
         future.setHttpHeaders(response.headers());
 
-        future.setKeepAlive(!HttpHeaders.Values.CLOSE.equalsIgnoreCase(response.headers().get(HttpHeaders.Names.CONNECTION)));
+        future.setKeepAlive(connectionStrategy.keepAlive(httpRequest, response));
 
-        NettyResponseStatus status = new NettyResponseStatus(future.getUri(), config, response);
+        NettyResponseStatus status = new NettyResponseStatus(future.getUri(), config, response, channel);
         int statusCode = response.getStatus().code();
         Request request = future.getRequest();
         Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
@@ -385,12 +437,45 @@ private boolean handleHttpResponse(final HttpResponse response, final Channel ch
                 || exitAfterHandling401(channel, future, response, request, statusCode, realm, proxyServer) || //
                 exitAfterHandling407(channel, future, response, request, statusCode, realm, proxyServer) || //
                 exitAfterHandling100(channel, future, statusCode) || //
-                exitAfterHandlingRedirect(channel, future, response, request, statusCode) || //
+                exitAfterHandlingRedirect(channel, future, response, request, statusCode, realm) || //
                 exitAfterHandlingConnect(channel, future, request, proxyServer, statusCode, httpRequest) || //
                 exitAfterHandlingStatus(channel, future, response, handler, status) || //
-                exitAfterHandlingHeaders(channel, future, response, handler, responseHeaders);
+                exitAfterHandlingHeaders(channel, future, response, handler, responseHeaders) ||
+                exitAfterHandlingReactiveStreams(channel, future, response, handler);
     }
 
+    private void handleChunk(HttpContent chunk,//
+            final Channel channel,//
+            final NettyResponseFuture<?> future,//
+            AsyncHandler<?> handler) throws IOException, Exception {
+
+        boolean interrupt = false;
+        boolean last = chunk instanceof LastHttpContent;
+        
+        // Netty 4: the last chunk is not empty
+        if (last) {
+            LastHttpContent lastChunk = (LastHttpContent) chunk;
+            HttpHeaders trailingHeaders = lastChunk.trailingHeaders();
+            if (!trailingHeaders.isEmpty()) {
+                NettyResponseHeaders responseHeaders = new NettyResponseHeaders(future.getHttpHeaders(), trailingHeaders);
+                interrupt = handler.onHeadersReceived(responseHeaders) != State.CONTINUE;
+            }
+        }
+
+        ByteBuf buf = chunk.content();
+        try {
+            if (!interrupt && !(handler instanceof StreamedAsyncHandler) && (buf.readableBytes() > 0 || last)) {
+                NettyResponseBodyPart part = nettyConfig.getBodyPartFactory().newResponseBodyPart(buf, last);
+                interrupt = updateBodyAndInterrupt(future, handler, part);
+            }
+        } finally {
+            buf.release();
+        }
+
+        if (interrupt || last)
+            finishUpdate(future, channel, !last);
+    }
+    
     @Override
     public void handle(final Channel channel, final NettyResponseFuture<?> future, final Object e) throws Exception {
 
@@ -406,47 +491,14 @@ public void handle(final Channel channel, final NettyResponseFuture<?> future, f
         AsyncHandler<?> handler = future.getAsyncHandler();
         try {
             if (e instanceof HttpResponse) {
-                HttpResponse response = (HttpResponse) e;
-                // we buffer the response until we get the LastHttpContent
-                future.setPendingResponse(response);
-                return;
-
-            } else if (e instanceof HttpContent) {
-                HttpResponse response = future.getPendingResponse();
-                future.setPendingResponse(null);
-                if (response != null && handleHttpResponse(response, channel, future, handler))
+                if (handleHttpResponse((HttpResponse) e, channel, future, handler))
                     return;
 
-                HttpContent chunk = (HttpContent) e;
-
-                boolean interrupt = false;
-                boolean last = chunk instanceof LastHttpContent;
-
-                // Netty 4: the last chunk is not empty
-                if (last) {
-                    LastHttpContent lastChunk = (LastHttpContent) chunk;
-                    HttpHeaders trailingHeaders = lastChunk.trailingHeaders();
-                    if (!trailingHeaders.isEmpty()) {
-                        NettyResponseHeaders responseHeaders = new NettyResponseHeaders(future.getHttpHeaders(), trailingHeaders);
-                        interrupt = handler.onHeadersReceived(responseHeaders) != STATE.CONTINUE;
-                    }
-                }
-
-                ByteBuf buf = chunk.content();
-                try {
-                    if (!interrupt && (buf.readableBytes() > 0 || last)) {
-                        NettyResponseBodyPart part = nettyConfig.getBodyPartFactory().newResponseBodyPart(buf, last);
-                        interrupt = updateBodyAndInterrupt(future, handler, part);
-                    }
-                } finally {
-                    // FIXME we shouldn't need this, should we? But a leak was reported there without it?!
-                    buf.release();
-                }
-
-                if (interrupt || last)
-                    finishUpdate(future, channel, !last);
+            } else if (e instanceof HttpContent) {
+                handleChunk((HttpContent) e, channel, future, handler);
             }
         } catch (Exception t) {
+            // e.g. an IOException when trying to open a connection and send the next request
             if (hasIOExceptionFilters//
                     && t instanceof IOException//
                     && requestSender.applyIoExceptionFiltersAndReplayRequest(future, IOException.class.cast(t), channel)) {
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/handler/Processor.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/handler/Processor.java
similarity index 58%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/handler/Processor.java
rename to providers/netty4/src/main/java/org/asynchttpclient/netty/handler/Processor.java
index 2c281133e..a79800181 100755
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/handler/Processor.java
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/handler/Processor.java
@@ -11,27 +11,29 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty.handler;
+package org.asynchttpclient.netty.handler;
 
-import static org.asynchttpclient.util.AsyncHttpProviderUtils.REMOTELY_CLOSED_EXCEPTION;
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.CHANNEL_CLOSED_EXCEPTION;
+
+import io.netty.buffer.ByteBuf;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.handler.codec.PrematureChannelClosureException;
+import io.netty.handler.codec.http.HttpContent;
 import io.netty.handler.codec.http.LastHttpContent;
 
 import java.io.IOException;
 import java.nio.channels.ClosedChannelException;
 
+import io.netty.util.ReferenceCountUtil;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.providers.netty.Callback;
-import org.asynchttpclient.providers.netty.DiscardEvent;
-import org.asynchttpclient.providers.netty.channel.ChannelManager;
-import org.asynchttpclient.providers.netty.channel.Channels;
-import org.asynchttpclient.providers.netty.future.NettyResponseFuture;
-import org.asynchttpclient.providers.netty.future.StackTraceInspector;
-import org.asynchttpclient.providers.netty.request.NettyRequestSender;
+import org.asynchttpclient.netty.*;
+import org.asynchttpclient.netty.channel.ChannelManager;
+import org.asynchttpclient.netty.channel.Channels;
+import org.asynchttpclient.netty.future.StackTraceInspector;
+import org.asynchttpclient.netty.request.NettyRequestSender;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -40,21 +42,19 @@
 
     private static final Logger LOGGER = LoggerFactory.getLogger(Processor.class);
 
-    public static final IOException CHANNEL_CLOSED_EXCEPTION = new IOException("Channel Closed");
-    static {
-        CHANNEL_CLOSED_EXCEPTION.setStackTrace(new StackTraceElement[0]);
-    }
-
     private final AsyncHttpClientConfig config;
+    private final NettyAsyncHttpProviderConfig nettyConfig;
     private final ChannelManager channelManager;
     private final NettyRequestSender requestSender;
     private final Protocol protocol;
 
-    public Processor(AsyncHttpClientConfig config,//
-            ChannelManager channelManager,//
-            NettyRequestSender requestSender,//
+    public Processor(AsyncHttpClientConfig config,
+            NettyAsyncHttpProviderConfig nettyConfig,
+            ChannelManager channelManager,
+            NettyRequestSender requestSender,
             Protocol protocol) {
         this.config = config;
+        this.nettyConfig = nettyConfig;
         this.channelManager = channelManager;
         this.requestSender = requestSender;
         this.protocol = protocol;
@@ -66,17 +66,53 @@ public void channelRead(final ChannelHandlerContext ctx, Object msg) throws Exce
         Channel channel = ctx.channel();
         Object attribute = Channels.getAttribute(channel);
 
-        if (attribute instanceof Callback && msg instanceof LastHttpContent) {
+        if (attribute instanceof Callback) {
             Callback ac = (Callback) attribute;
-            ac.call();
-            Channels.setAttribute(channel, DiscardEvent.INSTANCE);
+            if (msg instanceof LastHttpContent) {
+                ac.call();
+            } else if (!(msg instanceof HttpContent)) {
+                LOGGER.info("Received unexpected message while expecting a chunk: " + msg);
+                ac.call();
+                Channels.setDiscard(channel);
+            }
+            ReferenceCountUtil.release(msg);
+
 
         } else if (attribute instanceof NettyResponseFuture) {
             NettyResponseFuture<?> future = (NettyResponseFuture<?>) attribute;
             protocol.handle(channel, future, msg);
 
+        } else if (attribute instanceof StreamedResponsePublisher) {
+
+            StreamedResponsePublisher publisher = (StreamedResponsePublisher) attribute;
+
+            if (msg instanceof LastHttpContent) {
+                // Remove the handler from the pipeline, this will trigger it to finish
+                ctx.pipeline().remove(publisher);
+                // Trigger a read, just in case the last read complete triggered no new read
+                ctx.read();
+                // Send the last content on to the protocol, so that it can conclude the cleanup
+                protocol.handle(channel, publisher.future(), msg);
+            } else if (msg instanceof HttpContent) {
+
+                ByteBuf content = ((HttpContent) msg).content();
+
+                // Republish as a HttpResponseBodyPart
+                if (content.readableBytes() > 0) {
+                    NettyResponseBodyPart part = nettyConfig.getBodyPartFactory().newResponseBodyPart(content, false);
+                    ctx.fireChannelRead(part);
+                }
+
+                ReferenceCountUtil.release(msg);
+            } else {
+                LOGGER.info("Received unexpected message while expecting a chunk: " + msg);
+                ctx.pipeline().remove((StreamedResponsePublisher) attribute);
+                Channels.setDiscard(channel);
+            }
+
         } else if (attribute != DiscardEvent.INSTANCE) {
-            LOGGER.trace("Closing an orphan channel {}", channel);
+            // unhandled message
+            LOGGER.debug("Orphan channel {} with attribute {} received message {}, closing", channel, attribute, msg);
             Channels.silentlyCloseChannel(channel);
         }
     }
@@ -97,7 +133,10 @@ public void channelInactive(ChannelHandlerContext ctx) throws Exception {
 
         Object attribute = Channels.getAttribute(channel);
         LOGGER.debug("Channel Closed: {} with attribute {}", channel, attribute);
-
+        if (attribute instanceof StreamedResponsePublisher) {
+            // setting `attribute` to be the underlying future so that the retry logic can kick-in 
+            attribute = ((StreamedResponsePublisher) attribute).future();
+        }
         if (attribute instanceof Callback) {
             Callback callback = (Callback) attribute;
             Channels.setAttribute(channel, callback.future());
@@ -111,12 +150,7 @@ public void channelInactive(ChannelHandlerContext ctx) throws Exception {
                 return;
 
             protocol.onClose(future);
-
-            if (future.isDone())
-                channelManager.closeChannel(channel);
-
-            else if (!requestSender.retry(future))
-                requestSender.abort(channel, future, REMOTELY_CLOSED_EXCEPTION);
+            requestSender.handleUnexpectedClosedChannel(channel, future);
         }
     }
 
@@ -134,6 +168,11 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable e) throws Excep
 
         try {
             Object attribute = Channels.getAttribute(channel);
+            if (attribute instanceof StreamedResponsePublisher) {
+                ctx.fireExceptionCaught(e);
+                // setting `attribute` to be the underlying future so that the retry logic can kick-in
+                attribute = ((StreamedResponsePublisher) attribute).future();
+            }
             if (attribute instanceof NettyResponseFuture<?>) {
                 future = (NettyResponseFuture<?>) attribute;
                 future.attachChannel(null, false);
@@ -150,7 +189,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable e) throws Excep
                     }
                 }
 
-                if (StackTraceInspector.abortOnReadOrWriteException(cause)) {
+                if (StackTraceInspector.recoverOnReadOrWriteException(cause)) {
                     LOGGER.debug("Trying to recover from dead Channel: {}", channel);
                     return;
                 }
@@ -175,4 +214,22 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable e) throws Excep
         // ctx.fireChannelRead(e);
         Channels.silentlyCloseChannel(channel);
     }
+
+    @Override
+    public void channelActive(ChannelHandlerContext ctx) throws Exception {
+        ctx.read();
+    }
+
+    @Override
+    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
+        if (!isHandledByReactiveStreams(ctx)) {
+            ctx.read();
+        } else {
+            ctx.fireChannelReadComplete();
+        }
+    }
+
+    private boolean isHandledByReactiveStreams(ChannelHandlerContext ctx) {
+        return Channels.getAttribute(ctx.channel()) instanceof StreamedResponsePublisher;
+    }
 }
diff --git a/providers/netty4/src/main/java/org/asynchttpclient/netty/handler/Protocol.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/handler/Protocol.java
new file mode 100755
index 000000000..1b5e30de9
--- /dev/null
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/handler/Protocol.java
@@ -0,0 +1,241 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.handler;
+
+import static io.netty.handler.codec.http.HttpHeaders.Names.AUTHORIZATION;
+import static io.netty.handler.codec.http.HttpHeaders.Names.PROXY_AUTHORIZATION;
+import static io.netty.handler.codec.http.HttpResponseStatus.FOUND;
+import static io.netty.handler.codec.http.HttpResponseStatus.MOVED_PERMANENTLY;
+import static io.netty.handler.codec.http.HttpResponseStatus.SEE_OTHER;
+import static io.netty.handler.codec.http.HttpResponseStatus.TEMPORARY_REDIRECT;
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.followRedirect;
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.isSameBase;
+import io.netty.channel.Channel;
+import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.HttpResponse;
+
+import java.util.HashSet;
+import java.util.Set;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.Realm;
+import org.asynchttpclient.Realm.AuthScheme;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.cookie.Cookie;
+import org.asynchttpclient.cookie.CookieDecoder;
+import org.asynchttpclient.filter.FilterContext;
+import org.asynchttpclient.filter.FilterException;
+import org.asynchttpclient.filter.ResponseFilter;
+import org.asynchttpclient.handler.MaxRedirectException;
+import org.asynchttpclient.netty.NettyAsyncHttpProviderConfig;
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.channel.ChannelManager;
+import org.asynchttpclient.netty.request.NettyRequestSender;
+import org.asynchttpclient.uri.Uri;
+import org.asynchttpclient.util.MiscUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public abstract class Protocol {
+
+    protected final Logger logger = LoggerFactory.getLogger(getClass());
+
+    protected final ChannelManager channelManager;
+    protected final AsyncHttpClientConfig config;
+    protected final NettyAsyncHttpProviderConfig nettyConfig;
+    protected final NettyRequestSender requestSender;
+
+    private final boolean hasResponseFilters;
+    protected final boolean hasIOExceptionFilters;
+    private final MaxRedirectException maxRedirectException;
+
+    public static final Set<Integer> REDIRECT_STATUSES = new HashSet<>();
+    static {
+        REDIRECT_STATUSES.add(MOVED_PERMANENTLY.code());
+        REDIRECT_STATUSES.add(FOUND.code());
+        REDIRECT_STATUSES.add(SEE_OTHER.code());
+        REDIRECT_STATUSES.add(TEMPORARY_REDIRECT.code());
+    }
+
+    public Protocol(ChannelManager channelManager, AsyncHttpClientConfig config, NettyAsyncHttpProviderConfig nettyConfig, NettyRequestSender requestSender) {
+        this.channelManager = channelManager;
+        this.config = config;
+        this.requestSender = requestSender;
+        this.nettyConfig = nettyConfig;
+
+        hasResponseFilters = !config.getResponseFilters().isEmpty();
+        hasIOExceptionFilters = !config.getIOExceptionFilters().isEmpty();
+        maxRedirectException = new MaxRedirectException("Maximum redirect reached: " + config.getMaxRedirects());
+    }
+
+    public abstract void handle(Channel channel, NettyResponseFuture<?> future, Object message) throws Exception;
+
+    public abstract void onError(NettyResponseFuture<?> future, Throwable error);
+
+    public abstract void onClose(NettyResponseFuture<?> future);
+
+    private FluentCaseInsensitiveStringsMap propagatedHeaders(Request request, Realm realm, boolean switchToGet) {
+
+        FluentCaseInsensitiveStringsMap headers = request.getHeaders()//
+                .delete(HttpHeaders.Names.HOST)//
+                .delete(HttpHeaders.Names.CONTENT_LENGTH)//
+                .delete(HttpHeaders.Names.CONTENT_TYPE);
+
+        if (realm != null && realm.getScheme() == AuthScheme.NTLM) {
+            headers.delete(AUTHORIZATION)//
+                    .delete(PROXY_AUTHORIZATION);
+        }
+        return headers;
+    }
+
+    protected boolean exitAfterHandlingRedirect(//
+            Channel channel,//
+            NettyResponseFuture<?> future,//
+            HttpResponse response,//
+            Request request,//
+            int statusCode,//
+            Realm realm) throws Exception {
+
+        if (followRedirect(config, request) && REDIRECT_STATUSES.contains(statusCode)) {
+            if (future.incrementAndGetCurrentRedirectCount() >= config.getMaxRedirects()) {
+                throw maxRedirectException;
+
+            } else {
+                // We must allow 401 handling again.
+                future.getAndSetAuth(false);
+
+                String originalMethod = request.getMethod();
+                boolean switchToGet = !originalMethod.equals("GET") && (statusCode == 303 || (statusCode == 302 && !config.isStrict302Handling()));
+                boolean keepBody = statusCode == 307 || (statusCode == 302 && config.isStrict302Handling());
+
+                final RequestBuilder requestBuilder = new RequestBuilder(switchToGet ? "GET" : originalMethod)//
+                        .setCookies(request.getCookies())//
+                        .setConnectionPoolPartitioning(request.getConnectionPoolPartitioning())//
+                        .setFollowRedirect(true)//
+                        .setLocalInetAddress(request.getLocalAddress())//
+                        .setNameResolver(request.getNameResolver())//
+                        .setProxyServer(request.getProxyServer())//
+                        .setRealm(request.getRealm())//
+                        .setRequestTimeout(request.getRequestTimeout());
+
+                if (keepBody) {
+                    requestBuilder.setBodyCharset(request.getBodyCharset());
+                    if (MiscUtils.isNonEmpty(request.getFormParams()))
+                        requestBuilder.setFormParams(request.getFormParams());
+                    else if (request.getStringData() != null)
+                        requestBuilder.setBody(request.getStringData());
+                    else if (request.getByteData() != null)
+                        requestBuilder.setBody(request.getByteData());
+                    else if (request.getByteBufferData() != null)
+                        requestBuilder.setBody(request.getByteBufferData());
+                    else if (request.getBodyGenerator() != null)
+                        requestBuilder.setBody(request.getBodyGenerator());
+                }
+
+                requestBuilder.setHeaders(propagatedHeaders(request, realm, switchToGet));
+
+                // in case of a redirect from HTTP to HTTPS, future
+                // attributes might change
+                final boolean initialConnectionKeepAlive = future.isKeepAlive();
+                final Object initialPartitionKey = future.getPartitionKey();
+
+                HttpHeaders responseHeaders = response.headers();
+                String location = responseHeaders.get(HttpHeaders.Names.LOCATION);
+                Uri newUri = Uri.create(future.getUri(), location);
+
+                logger.debug("Redirecting to {}", newUri);
+
+                for (String cookieStr : responseHeaders.getAll(HttpHeaders.Names.SET_COOKIE)) {
+                    Cookie c = CookieDecoder.decode(cookieStr);
+                    if (c != null)
+                        requestBuilder.addOrReplaceCookie(c);
+                }
+
+                requestBuilder.setHeaders(propagatedHeaders(future.getRequest(), realm, switchToGet));
+
+                boolean sameBase = isSameBase(request.getUri(), newUri);
+
+                if (sameBase) {
+                    // we can only assume the virtual host is still valid if the baseUrl is the same
+                    requestBuilder.setVirtualHost(request.getVirtualHost());
+                }
+
+                final Request nextRequest = requestBuilder.setUri(newUri).build();
+
+                logger.debug("Sending redirect to {}", newUri);
+
+                if (future.isKeepAlive() && !HttpHeaders.isTransferEncodingChunked(response)) {
+
+                    if (sameBase) {
+                        future.setReuseChannel(true);
+                        // we can't directly send the next request because we still have to received LastContent
+                        requestSender.drainChannelAndExecuteNextRequest(channel, future, nextRequest);
+                    } else {
+                        channelManager.drainChannelAndOffer(channel, future, initialConnectionKeepAlive, initialPartitionKey);
+                        requestSender.sendNextRequest(nextRequest, future);
+                    }
+
+                } else {
+                    // redirect + chunking = WAT
+                    channelManager.closeChannel(channel);
+                    requestSender.sendNextRequest(nextRequest, future);
+                }
+
+                return true;
+            }
+        }
+        return false;
+    }
+
+    @SuppressWarnings({ "rawtypes", "unchecked" })
+    protected boolean exitAfterProcessingFilters(//
+            Channel channel,//
+            NettyResponseFuture<?> future,//
+            AsyncHandler<?> handler, //
+            HttpResponseStatus status,//
+            HttpResponseHeaders responseHeaders) {
+
+        if (hasResponseFilters) {
+            FilterContext fc = new FilterContext.FilterContextBuilder().asyncHandler(handler).request(future.getRequest()).responseStatus(status).responseHeaders(responseHeaders)
+                    .build();
+
+            for (ResponseFilter asyncFilter : config.getResponseFilters()) {
+                try {
+                    fc = asyncFilter.filter(fc);
+                    // FIXME Is it worth protecting against this?
+                    if (fc == null) {
+                        throw new NullPointerException("FilterContext is null");
+                    }
+                } catch (FilterException efe) {
+                    requestSender.abort(channel, future, efe);
+                }
+            }
+
+            // The handler may have been wrapped.
+            future.setAsyncHandler(fc.getAsyncHandler());
+
+            // The request has changed
+            if (fc.replayRequest()) {
+                requestSender.replayRequest(future, fc, channel);
+                return true;
+            }
+        }
+        return false;
+    }
+}
diff --git a/providers/netty4/src/main/java/org/asynchttpclient/netty/handler/StreamedResponsePublisher.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/handler/StreamedResponsePublisher.java
new file mode 100644
index 000000000..903c61706
--- /dev/null
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/handler/StreamedResponsePublisher.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.handler;
+
+import com.typesafe.netty.HandlerPublisher;
+import io.netty.channel.Channel;
+import io.netty.util.concurrent.EventExecutor;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.channel.ChannelManager;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class StreamedResponsePublisher extends HandlerPublisher<HttpResponseBodyPart> {
+
+    protected final Logger logger = LoggerFactory.getLogger(getClass());
+
+    private final ChannelManager channelManager;
+    private final NettyResponseFuture<?> future;
+    private final Channel channel;
+
+    public StreamedResponsePublisher(EventExecutor executor, ChannelManager channelManager, NettyResponseFuture<?> future, Channel channel) {
+        super(executor, HttpResponseBodyPart.class);
+        this.channelManager = channelManager;
+        this.future = future;
+        this.channel = channel;
+    }
+
+    @Override
+    protected void cancelled() {
+        logger.debug("Subscriber cancelled, ignoring the rest of the body");
+
+        // The subscriber cancelled early, we need to drain the remaining elements from the stream
+        channelManager.drainChannelAndOffer(channel, future);
+        channel.pipeline().remove(StreamedResponsePublisher.class);
+
+        try {
+            future.done();
+        } catch (Exception t) {
+            // Never propagate exception once we know we are done.
+            logger.debug(t.getMessage(), t);
+        }
+    }
+
+    NettyResponseFuture<?> future() {
+        return future;
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/handler/WebSocketProtocol.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/handler/WebSocketProtocol.java
similarity index 76%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/handler/WebSocketProtocol.java
rename to providers/netty4/src/main/java/org/asynchttpclient/netty/handler/WebSocketProtocol.java
index 2b51c80fe..1c9859b27 100755
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/handler/WebSocketProtocol.java
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/handler/WebSocketProtocol.java
@@ -11,15 +11,14 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty.handler;
+package org.asynchttpclient.netty.handler;
 
 import static io.netty.handler.codec.http.HttpResponseStatus.SWITCHING_PROTOCOLS;
-import static org.asynchttpclient.providers.netty.ws.WebSocketUtils.getAcceptKey;
+import static org.asynchttpclient.ws.WebSocketUtils.getAcceptKey;
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.Channel;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpResponse;
-import io.netty.handler.codec.http.LastHttpContent;
 import io.netty.handler.codec.http.websocketx.BinaryWebSocketFrame;
 import io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;
 import io.netty.handler.codec.http.websocketx.PingWebSocketFrame;
@@ -30,21 +29,23 @@
 import java.io.IOException;
 import java.util.Locale;
 
-import org.asynchttpclient.AsyncHandler.STATE;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.HttpResponseHeaders;
 import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.Realm;
 import org.asynchttpclient.Request;
-import org.asynchttpclient.providers.netty.NettyAsyncHttpProviderConfig;
-import org.asynchttpclient.providers.netty.channel.ChannelManager;
-import org.asynchttpclient.providers.netty.channel.Channels;
-import org.asynchttpclient.providers.netty.future.NettyResponseFuture;
-import org.asynchttpclient.providers.netty.request.NettyRequestSender;
-import org.asynchttpclient.providers.netty.response.NettyResponseBodyPart;
-import org.asynchttpclient.providers.netty.response.NettyResponseHeaders;
-import org.asynchttpclient.providers.netty.response.NettyResponseStatus;
-import org.asynchttpclient.providers.netty.ws.NettyWebSocket;
-import org.asynchttpclient.websocket.WebSocketUpgradeHandler;
+import org.asynchttpclient.AsyncHandler.State;
+import org.asynchttpclient.netty.Callback;
+import org.asynchttpclient.netty.NettyAsyncHttpProviderConfig;
+import org.asynchttpclient.netty.NettyResponseBodyPart;
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.NettyResponseHeaders;
+import org.asynchttpclient.netty.NettyResponseStatus;
+import org.asynchttpclient.netty.channel.ChannelManager;
+import org.asynchttpclient.netty.channel.Channels;
+import org.asynchttpclient.netty.request.NettyRequestSender;
+import org.asynchttpclient.netty.ws.NettyWebSocket;
+import org.asynchttpclient.ws.WebSocketUpgradeHandler;
 
 public final class WebSocketProtocol extends Protocol {
 
@@ -60,35 +61,40 @@ public WebSocketProtocol(ChannelManager channelManager,//
     private void invokeOnSucces(Channel channel, WebSocketUpgradeHandler h) {
         if (!h.touchSuccess()) {
             try {
-                h.onSuccess(nettyConfig.getNettyWebSocketFactory().newNettyWebSocket(channel, nettyConfig));
+                h.onSuccess(nettyConfig.getNettyWebSocketFactory().newNettyWebSocket(channel, config));
             } catch (Exception ex) {
                 logger.warn("onSuccess unexpected exception", ex);
             }
         }
     }
 
-    @Override
-    public void handle(Channel channel, NettyResponseFuture<?> future, Object e) throws Exception {
-        WebSocketUpgradeHandler handler = WebSocketUpgradeHandler.class.cast(future.getAsyncHandler());
-        Request request = future.getRequest();
+    private class UpgradeCallback extends Callback {
 
-        if (e instanceof HttpResponse) {
-            HttpResponse response = (HttpResponse) e;
-            // we buffer the response until we get the LastHttpContent
-            future.setPendingResponse(response);
-
-        } else if (e instanceof LastHttpContent) {
-            HttpResponse response = future.getPendingResponse();
-            future.setPendingResponse(null);
-            HttpResponseStatus status = new NettyResponseStatus(future.getUri(), config, response);
+        private final Channel channel;
+        private final HttpResponse response;
+        
+        public UpgradeCallback(NettyResponseFuture<?> future, Channel channel, HttpResponse response) {
+            super(future);
+            this.channel = channel;
+            this.response = response;
+        }
+        
+        @Override
+        public void call() throws Exception {
+            
+            WebSocketUpgradeHandler handler = WebSocketUpgradeHandler.class.cast(future.getAsyncHandler());
+            Request request = future.getRequest();
+            
+            HttpResponseStatus status = new NettyResponseStatus(future.getUri(), config, response, channel);
             HttpResponseHeaders responseHeaders = new NettyResponseHeaders(response.headers());
+            Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
 
             if (exitAfterProcessingFilters(channel, future, handler, status, responseHeaders)) {
                 return;
             }
 
             future.setHttpHeaders(response.headers());
-            if (exitAfterHandlingRedirect(channel, future, response, request, response.getStatus().code()))
+            if (exitAfterHandlingRedirect(channel, future, response, request, response.getStatus().code(), realm))
                 return;
 
             boolean validStatus = response.getStatus().equals(SWITCHING_PROTOCOLS);
@@ -97,9 +103,7 @@ public void handle(Channel channel, NettyResponseFuture<?> future, Object e) thr
             if (connection == null)
                 connection = response.headers().get(HttpHeaders.Names.CONNECTION.toLowerCase(Locale.ENGLISH));
             boolean validConnection = HttpHeaders.Values.UPGRADE.equalsIgnoreCase(connection);
-
-            status = new NettyResponseStatus(future.getUri(), config, response);
-            final boolean statusReceived = handler.onStatusReceived(status) == STATE.UPGRADE;
+            boolean statusReceived = handler.onStatusReceived(status) == State.UPGRADE;
 
             if (!statusReceived) {
                 try {
@@ -110,7 +114,7 @@ public void handle(Channel channel, NettyResponseFuture<?> future, Object e) thr
                 return;
             }
 
-            final boolean headerOK = handler.onHeadersReceived(responseHeaders) == STATE.CONTINUE;
+            final boolean headerOK = handler.onHeadersReceived(responseHeaders) == State.CONTINUE;
             if (!headerOK || !validStatus || !validUpgrade || !validConnection) {
                 requestSender.abort(channel, future, new IOException("Invalid handshake response"));
                 return;
@@ -126,10 +130,23 @@ public void handle(Channel channel, NettyResponseFuture<?> future, Object e) thr
 
             invokeOnSucces(channel, handler);
             future.done();
+            // set back the future so the protocol gets notified of frames
+            Channels.setAttribute(channel, future);
+        }
+        
+    }
+    
+    @Override
+    public void handle(Channel channel, NettyResponseFuture<?> future, Object e) throws Exception {
+
+        if (e instanceof HttpResponse) {
+            HttpResponse response = (HttpResponse) e;
+            Channels.setAttribute(channel, new UpgradeCallback(future, channel, response));
 
         } else if (e instanceof WebSocketFrame) {
 
             final WebSocketFrame frame = (WebSocketFrame) e;
+            WebSocketUpgradeHandler handler = WebSocketUpgradeHandler.class.cast(future.getAsyncHandler());
             NettyWebSocket webSocket = NettyWebSocket.class.cast(handler.onCompleted());
             invokeOnSucces(channel, handler);
 
@@ -172,7 +189,7 @@ public void onError(NettyResponseFuture<?> future, Throwable e) {
         logger.warn("onError {}", e);
 
         try {
-            WebSocketUpgradeHandler h = WebSocketUpgradeHandler.class.cast(future);
+            WebSocketUpgradeHandler h = (WebSocketUpgradeHandler) future.getAsyncHandler();
 
             NettyWebSocket webSocket = NettyWebSocket.class.cast(h.onCompleted());
             if (webSocket != null) {
@@ -186,10 +203,10 @@ public void onError(NettyResponseFuture<?> future, Throwable e) {
 
     @Override
     public void onClose(NettyResponseFuture<?> future) {
-        logger.trace("onClose {}");
+        logger.trace("onClose");
 
         try {
-            WebSocketUpgradeHandler h = WebSocketUpgradeHandler.class.cast(future);
+            WebSocketUpgradeHandler h = (WebSocketUpgradeHandler) future.getAsyncHandler();
             NettyWebSocket webSocket = NettyWebSocket.class.cast(h.onCompleted());
 
             logger.trace("Connection was closed abnormally (that is, with no close frame being sent).");
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/NettyRequest.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/request/NettyRequest.java
similarity index 90%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/NettyRequest.java
rename to providers/netty4/src/main/java/org/asynchttpclient/netty/request/NettyRequest.java
index aec5d2fd0..65c067b4c 100755
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/NettyRequest.java
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/request/NettyRequest.java
@@ -11,9 +11,9 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty.request;
+package org.asynchttpclient.netty.request;
 
-import org.asynchttpclient.providers.netty.request.body.NettyBody;
+import org.asynchttpclient.netty.request.body.NettyBody;
 
 import io.netty.handler.codec.http.HttpRequest;
 
diff --git a/providers/netty4/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactory.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactory.java
new file mode 100755
index 000000000..24d8f2249
--- /dev/null
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactory.java
@@ -0,0 +1,233 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.request;
+
+import static io.netty.handler.codec.http.HttpHeaders.Names.ACCEPT;
+import static io.netty.handler.codec.http.HttpHeaders.Names.ACCEPT_ENCODING;
+import static io.netty.handler.codec.http.HttpHeaders.Names.AUTHORIZATION;
+import static io.netty.handler.codec.http.HttpHeaders.Names.CONNECTION;
+import static io.netty.handler.codec.http.HttpHeaders.Names.CONTENT_LENGTH;
+import static io.netty.handler.codec.http.HttpHeaders.Names.CONTENT_TYPE;
+import static io.netty.handler.codec.http.HttpHeaders.Names.COOKIE;
+import static io.netty.handler.codec.http.HttpHeaders.Names.HOST;
+import static io.netty.handler.codec.http.HttpHeaders.Names.ORIGIN;
+import static io.netty.handler.codec.http.HttpHeaders.Names.PROXY_AUTHORIZATION;
+import static io.netty.handler.codec.http.HttpHeaders.Names.SEC_WEBSOCKET_KEY;
+import static io.netty.handler.codec.http.HttpHeaders.Names.SEC_WEBSOCKET_VERSION;
+import static io.netty.handler.codec.http.HttpHeaders.Names.TRANSFER_ENCODING;
+import static io.netty.handler.codec.http.HttpHeaders.Names.UPGRADE;
+import static io.netty.handler.codec.http.HttpHeaders.Names.USER_AGENT;
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.DEFAULT_CHARSET;
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.hostHeader;
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.urlEncodeFormParams;
+import static org.asynchttpclient.util.AuthenticatorUtils.perRequestAuthorizationHeader;
+import static org.asynchttpclient.util.AuthenticatorUtils.perRequestProxyAuthorizationHeader;
+import static org.asynchttpclient.util.HttpUtils.isSecure;
+import static org.asynchttpclient.util.HttpUtils.isWebSocket;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+import static org.asynchttpclient.ws.WebSocketUtils.getKey;
+import io.netty.buffer.ByteBuf;
+import io.netty.handler.codec.http.DefaultFullHttpRequest;
+import io.netty.handler.codec.http.DefaultHttpRequest;
+import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.HttpMethod;
+import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.codec.http.HttpVersion;
+
+import java.nio.charset.Charset;
+import java.util.List;
+import java.util.Map.Entry;
+
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Realm;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.cookie.CookieEncoder;
+import org.asynchttpclient.netty.request.body.NettyBody;
+import org.asynchttpclient.netty.request.body.NettyBodyBody;
+import org.asynchttpclient.netty.request.body.NettyByteArrayBody;
+import org.asynchttpclient.netty.request.body.NettyByteBufferBody;
+import org.asynchttpclient.netty.request.body.NettyCompositeByteArrayBody;
+import org.asynchttpclient.netty.request.body.NettyDirectBody;
+import org.asynchttpclient.netty.request.body.NettyFileBody;
+import org.asynchttpclient.netty.request.body.NettyInputStreamBody;
+import org.asynchttpclient.netty.request.body.NettyMultipartBody;
+import org.asynchttpclient.netty.request.body.NettyReactiveStreamsBody;
+import org.asynchttpclient.proxy.ProxyServer;
+import org.asynchttpclient.request.body.generator.FileBodyGenerator;
+import org.asynchttpclient.request.body.generator.InputStreamBodyGenerator;
+import org.asynchttpclient.request.body.generator.ReactiveStreamsBodyGenerator;
+import org.asynchttpclient.uri.Uri;
+import org.asynchttpclient.util.HttpUtils;
+import org.asynchttpclient.util.StringUtils;
+
+public final class NettyRequestFactory extends NettyRequestFactoryBase {
+
+    public static final String GZIP_DEFLATE = HttpHeaders.Values.GZIP + "," + HttpHeaders.Values.DEFLATE;
+
+    public NettyRequestFactory(AsyncHttpClientConfig config) {
+        super(config);
+    }
+
+    private NettyBody body(Request request, boolean connect) {
+        NettyBody nettyBody = null;
+        if (!connect) {
+
+            Charset bodyCharset = request.getBodyCharset() == null ? DEFAULT_CHARSET : request.getBodyCharset();
+
+            if (request.getByteData() != null)
+                nettyBody = new NettyByteArrayBody(request.getByteData());
+
+            else if (request.getCompositeByteData() != null)
+                nettyBody = new NettyCompositeByteArrayBody(request.getCompositeByteData());
+
+            else if (request.getStringData() != null)
+                nettyBody = new NettyByteBufferBody(StringUtils.charSequence2ByteBuffer(request.getStringData(), bodyCharset));
+
+            else if (request.getByteBufferData() != null)
+                nettyBody = new NettyByteBufferBody(request.getByteBufferData());
+
+            else if (request.getStreamData() != null)
+                nettyBody = new NettyInputStreamBody(request.getStreamData(), config);
+
+            else if (isNonEmpty(request.getFormParams())) {
+
+                String contentType = null;
+                if (!request.getHeaders().containsKey(CONTENT_TYPE))
+                    contentType = HttpHeaders.Values.APPLICATION_X_WWW_FORM_URLENCODED;
+
+                nettyBody = new NettyByteBufferBody(urlEncodeFormParams(request.getFormParams(), bodyCharset), contentType);
+
+            } else if (isNonEmpty(request.getParts()))
+                nettyBody = new NettyMultipartBody(request.getParts(), request.getHeaders(), config);
+
+            else if (request.getFile() != null)
+                nettyBody = new NettyFileBody(request.getFile(), config);
+
+            else if (request.getBodyGenerator() instanceof FileBodyGenerator) {
+                FileBodyGenerator fileBodyGenerator = (FileBodyGenerator) request.getBodyGenerator();
+                nettyBody = new NettyFileBody(fileBodyGenerator.getFile(), fileBodyGenerator.getRegionSeek(), fileBodyGenerator.getRegionLength(), config);
+
+            } else if (request.getBodyGenerator() instanceof InputStreamBodyGenerator)
+                nettyBody = new NettyInputStreamBody(InputStreamBodyGenerator.class.cast(request.getBodyGenerator()).getInputStream(), config);
+            else if (request.getBodyGenerator() instanceof ReactiveStreamsBodyGenerator)
+                nettyBody = new NettyReactiveStreamsBody(ReactiveStreamsBodyGenerator.class.cast(request.getBodyGenerator()).getPublisher());
+            else if (request.getBodyGenerator() != null)
+                nettyBody = new NettyBodyBody(request.getBodyGenerator().createBody(), config);
+        }
+
+        return nettyBody;
+    }
+
+    public void addAuthorizationHeader(HttpHeaders headers, String authorizationHeader) {
+        if (authorizationHeader != null)
+            // don't override authorization but append
+            headers.add(AUTHORIZATION, authorizationHeader);
+    }
+
+    public void setProxyAuthorizationHeader(HttpHeaders headers, String proxyAuthorizationHeader) {
+        if (proxyAuthorizationHeader != null)
+            headers.set(PROXY_AUTHORIZATION, proxyAuthorizationHeader);
+    }
+
+    public NettyRequest newNettyRequest(Request request, boolean forceConnect, ProxyServer proxyServer) {
+
+        Uri uri = request.getUri();
+        HttpMethod method = forceConnect ? HttpMethod.CONNECT : HttpMethod.valueOf(request.getMethod());
+        boolean connect = method == HttpMethod.CONNECT;
+
+        boolean allowConnectionPooling = config.isAllowPoolingConnections() && (!HttpUtils.isSecure(uri) || config.isAllowPoolingSslConnections());
+
+        HttpVersion httpVersion = !allowConnectionPooling || (connect && proxyServer.isForceHttp10()) ? HttpVersion.HTTP_1_0 : HttpVersion.HTTP_1_1;
+        String requestUri = requestUri(uri, proxyServer, connect);
+
+        NettyBody body = body(request, connect);
+
+        HttpRequest httpRequest;
+        NettyRequest nettyRequest;
+        if (body instanceof NettyDirectBody) {
+            ByteBuf buf = NettyDirectBody.class.cast(body).byteBuf();
+            httpRequest = new DefaultFullHttpRequest(httpVersion, method, requestUri, buf);
+            // body is passed as null as it's written directly with the request
+            nettyRequest = new NettyRequest(httpRequest, null);
+
+        } else if (body == null) {
+            httpRequest = new DefaultFullHttpRequest(httpVersion, method, requestUri);
+            nettyRequest = new NettyRequest(httpRequest, null);
+
+        } else {
+            httpRequest = new DefaultHttpRequest(httpVersion, method, requestUri);
+            nettyRequest = new NettyRequest(httpRequest, body);
+        }
+
+        HttpHeaders headers = httpRequest.headers();
+
+        if (!connect) {
+            // assign headers as configured on request
+            for (Entry<String, List<String>> header : request.getHeaders()) {
+                headers.set(header.getKey(), header.getValue());
+            }
+
+            if (isNonEmpty(request.getCookies()))
+                headers.set(COOKIE, CookieEncoder.encode(request.getCookies()));
+
+            if (config.isCompressionEnforced() && !headers.contains(ACCEPT_ENCODING))
+                headers.set(ACCEPT_ENCODING, GZIP_DEFLATE);
+        }
+
+        if (body != null) {
+            if (body.getContentLength() < 0)
+                headers.set(TRANSFER_ENCODING, HttpHeaders.Values.CHUNKED);
+            else
+                headers.set(CONTENT_LENGTH, body.getContentLength());
+
+            if (body.getContentType() != null)
+                headers.set(CONTENT_TYPE, body.getContentType());
+        }
+
+        // connection header and friends
+        boolean webSocket = isWebSocket(uri.getScheme());
+        if (!connect && webSocket) {
+            headers.set(UPGRADE, HttpHeaders.Values.WEBSOCKET)//
+                    .set(CONNECTION, HttpHeaders.Values.UPGRADE)//
+                    .set(ORIGIN, "http://" + uri.getHost() + ":" + (uri.getPort() == -1 ? isSecure(uri.getScheme()) ? 443 : 80 : uri.getPort()))//
+                    .set(SEC_WEBSOCKET_KEY, getKey())//
+                    .set(SEC_WEBSOCKET_VERSION, "13");
+
+        } else if (!headers.contains(CONNECTION)) {
+            String connectionHeaderValue = connectionHeader(allowConnectionPooling, httpVersion == HttpVersion.HTTP_1_1);
+            if (connectionHeaderValue != null)
+                headers.set(CONNECTION, connectionHeaderValue);
+        }
+
+        if (!headers.contains(HOST))
+            headers.set(HOST, hostHeader(request, uri));
+
+        Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
+
+        // don't override authorization but append
+        addAuthorizationHeader(headers, perRequestAuthorizationHeader(request, realm));
+
+        setProxyAuthorizationHeader(headers, perRequestProxyAuthorizationHeader(request, proxyServer, realm, connect));
+
+        // Add default accept headers
+        if (!headers.contains(ACCEPT))
+            headers.set(ACCEPT, "*/*");
+
+        // Add default user agent
+        if (!headers.contains(USER_AGENT) && config.getUserAgent() != null)
+            headers.set(USER_AGENT, config.getUserAgent());
+
+        return nettyRequest;
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/NettyRequestSender.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/request/NettyRequestSender.java
similarity index 58%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/NettyRequestSender.java
rename to providers/netty4/src/main/java/org/asynchttpclient/netty/request/NettyRequestSender.java
index 0637204cc..2dca64b1e 100755
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/NettyRequestSender.java
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/request/NettyRequestSender.java
@@ -11,13 +11,15 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty.request;
+package org.asynchttpclient.netty.request;
 
-import static org.asynchttpclient.providers.netty.util.HttpUtils.WEBSOCKET;
-import static org.asynchttpclient.providers.netty.util.HttpUtils.isSecure;
-import static org.asynchttpclient.providers.netty.util.HttpUtils.useProxyConnect;
-import static org.asynchttpclient.util.AsyncHttpProviderUtils.getDefaultPort;
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.REMOTELY_CLOSED_EXCEPTION;
+import static org.asynchttpclient.util.AsyncHttpProviderUtils.getExplicitPort;
 import static org.asynchttpclient.util.AsyncHttpProviderUtils.requestTimeout;
+import static org.asynchttpclient.util.AuthenticatorUtils.perConnectionAuthorizationHeader;
+import static org.asynchttpclient.util.AuthenticatorUtils.perConnectionProxyAuthorizationHeader;
+import static org.asynchttpclient.util.HttpUtils.WS;
+import static org.asynchttpclient.util.HttpUtils.useProxyConnect;
 import static org.asynchttpclient.util.ProxyUtils.avoidProxy;
 import static org.asynchttpclient.util.ProxyUtils.getProxyServer;
 import io.netty.bootstrap.Bootstrap;
@@ -31,32 +33,35 @@
 import io.netty.util.TimerTask;
 
 import java.io.IOException;
+import java.net.InetAddress;
 import java.net.InetSocketAddress;
+import java.net.UnknownHostException;
 import java.util.Map;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.AsyncHandlerExtensions;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.ConnectionPoolPartitioning;
 import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
 import org.asynchttpclient.ListenableFuture;
-import org.asynchttpclient.ProxyServer;
+import org.asynchttpclient.Realm;
 import org.asynchttpclient.Request;
 import org.asynchttpclient.filter.FilterContext;
 import org.asynchttpclient.filter.FilterException;
 import org.asynchttpclient.filter.IOExceptionFilter;
-import org.asynchttpclient.listener.TransferCompletionHandler;
-import org.asynchttpclient.providers.netty.NettyAsyncHttpProviderConfig;
-import org.asynchttpclient.providers.netty.channel.ChannelManager;
-import org.asynchttpclient.providers.netty.channel.Channels;
-import org.asynchttpclient.providers.netty.future.NettyResponseFuture;
-import org.asynchttpclient.providers.netty.request.timeout.ReadTimeoutTimerTask;
-import org.asynchttpclient.providers.netty.request.timeout.RequestTimeoutTimerTask;
-import org.asynchttpclient.providers.netty.request.timeout.TimeoutsHolder;
+import org.asynchttpclient.handler.AsyncHandlerExtensions;
+import org.asynchttpclient.handler.TransferCompletionHandler;
+import org.asynchttpclient.netty.Callback;
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.channel.ChannelManager;
+import org.asynchttpclient.netty.channel.Channels;
+import org.asynchttpclient.netty.channel.NettyConnectListener;
+import org.asynchttpclient.netty.timeout.ReadTimeoutTimerTask;
+import org.asynchttpclient.netty.timeout.RequestTimeoutTimerTask;
+import org.asynchttpclient.netty.timeout.TimeoutsHolder;
+import org.asynchttpclient.proxy.ProxyServer;
 import org.asynchttpclient.uri.Uri;
-import org.asynchttpclient.websocket.WebSocketUpgradeHandler;
+import org.asynchttpclient.ws.WebSocketUpgradeHandler;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -71,7 +76,6 @@
     private final NettyRequestFactory requestFactory;
 
     public NettyRequestSender(AsyncHttpClientConfig config,//
-            NettyAsyncHttpProviderConfig nettyConfig,//
             ChannelManager channelManager,//
             Timer nettyTimer,//
             AtomicBoolean closed) {
@@ -79,36 +83,32 @@ public NettyRequestSender(AsyncHttpClientConfig config,//
         this.channelManager = channelManager;
         this.nettyTimer = nettyTimer;
         this.closed = closed;
-        requestFactory = new NettyRequestFactory(config, nettyConfig);
+        requestFactory = new NettyRequestFactory(config);
     }
 
     public <T> ListenableFuture<T> sendRequest(final Request request,//
             final AsyncHandler<T> asyncHandler,//
             NettyResponseFuture<T> future,//
-            boolean reclaimCache) throws IOException {
+            boolean reclaimCache) {
 
         if (closed.get())
-            throw new IOException("Closed");
+            throw new IllegalStateException("Closed");
 
-        Uri uri = request.getUri();
-
-        // FIXME really useful? Why not do this check when building the request?
-        if (uri.getScheme().startsWith(WEBSOCKET) && !validateWebSocketRequest(request, asyncHandler))
-            throw new IOException("WebSocket method must be a GET");
+        validateWebSocketRequest(request, asyncHandler);
 
         ProxyServer proxyServer = getProxyServer(config, request);
         boolean resultOfAConnect = future != null && future.getNettyRequest() != null && future.getNettyRequest().getHttpRequest().getMethod() == HttpMethod.CONNECT;
         boolean useProxy = proxyServer != null && !resultOfAConnect;
 
-        if (useProxy && useProxyConnect(uri))
+        if (useProxy && useProxyConnect(request.getUri()))
             // SSL proxy, have to handle CONNECT
             if (future != null && future.isConnectAllowed())
                 // CONNECT forced
-                return sendRequestWithCertainForceConnect(request, asyncHandler, future, reclaimCache, uri, proxyServer, true, true);
+                return sendRequestWithCertainForceConnect(request, asyncHandler, future, reclaimCache, proxyServer, true, true);
             else
-                return sendRequestThroughSslProxy(request, asyncHandler, future, reclaimCache, uri, proxyServer);
+                return sendRequestThroughSslProxy(request, asyncHandler, future, reclaimCache, proxyServer);
         else
-            return sendRequestWithCertainForceConnect(request, asyncHandler, future, reclaimCache, uri, proxyServer, useProxy, false);
+            return sendRequestWithCertainForceConnect(request, asyncHandler, future, reclaimCache, proxyServer, useProxy, false);
     }
 
     /**
@@ -121,25 +121,24 @@ public NettyRequestSender(AsyncHttpClientConfig config,//
             AsyncHandler<T> asyncHandler,//
             NettyResponseFuture<T> future,//
             boolean reclaimCache,//
-            Uri uri,//
             ProxyServer proxyServer,//
             boolean useProxy,//
-            boolean forceConnect) throws IOException {
+            boolean forceConnect) {
 
-        NettyResponseFuture<T> newFuture = newNettyRequestAndResponseFuture(request, asyncHandler, future, uri, proxyServer, forceConnect);
+        NettyResponseFuture<T> newFuture = newNettyRequestAndResponseFuture(request, asyncHandler, future, proxyServer, forceConnect);
 
-        Channel channel = getCachedChannel(future, uri, request.getConnectionPoolPartitioning(), proxyServer, asyncHandler);
+        Channel channel = getCachedChannel(future, request, proxyServer, asyncHandler);
 
         if (Channels.isChannelValid(channel))
-            return sendRequestWithCachedChannel(request, uri, proxyServer, newFuture, asyncHandler, channel);
+            return sendRequestWithCachedChannel(request, proxyServer, newFuture, asyncHandler, channel);
         else
-            return sendRequestWithNewChannel(request, uri, proxyServer, useProxy, newFuture, asyncHandler, reclaimCache);
+            return sendRequestWithNewChannel(request, proxyServer, useProxy, newFuture, asyncHandler, reclaimCache);
     }
 
     /**
      * Using CONNECT depends on wither we can fetch a valid channel or not Loop
      * until we get a valid channel from the pool and it's still valid once the
-     * request is built
+     * request is built @
      */
     @SuppressWarnings("unused")
     private <T> ListenableFuture<T> sendRequestThroughSslProxy(//
@@ -147,35 +146,35 @@ public NettyRequestSender(AsyncHttpClientConfig config,//
             AsyncHandler<T> asyncHandler,//
             NettyResponseFuture<T> future,//
             boolean reclaimCache,//
-            Uri uri,//
-            ProxyServer proxyServer) throws IOException {
+            ProxyServer proxyServer) {
 
         NettyResponseFuture<T> newFuture = null;
         for (int i = 0; i < 3; i++) {
-            Channel channel = getCachedChannel(future, uri, request.getConnectionPoolPartitioning(), proxyServer, asyncHandler);
+            Channel channel = getCachedChannel(future, request, proxyServer, asyncHandler);
             if (Channels.isChannelValid(channel))
                 if (newFuture == null)
-                    newFuture = newNettyRequestAndResponseFuture(request, asyncHandler, future, uri, proxyServer, false);
+                    newFuture = newNettyRequestAndResponseFuture(request, asyncHandler, future, proxyServer, false);
 
             if (Channels.isChannelValid(channel))
-                // if the channel is still active, we can use it, otherwise try gain
-                return sendRequestWithCachedChannel(request, uri, proxyServer, newFuture, asyncHandler, channel);
+                // if the channel is still active, we can use it, otherwise try
+                // gain
+                return sendRequestWithCachedChannel(request, proxyServer, newFuture, asyncHandler, channel);
             else
                 // pool is empty
                 break;
         }
 
-        newFuture = newNettyRequestAndResponseFuture(request, asyncHandler, future, uri, proxyServer, true);
-        return sendRequestWithNewChannel(request, uri, proxyServer, true, newFuture, asyncHandler, reclaimCache);
+        newFuture = newNettyRequestAndResponseFuture(request, asyncHandler, future, proxyServer, true);
+        return sendRequestWithNewChannel(request, proxyServer, true, newFuture, asyncHandler, reclaimCache);
     }
 
     private <T> NettyResponseFuture<T> newNettyRequestAndResponseFuture(final Request request, final AsyncHandler<T> asyncHandler, NettyResponseFuture<T> originalFuture,
-            Uri uri, ProxyServer proxy, boolean forceConnect) throws IOException {
+            ProxyServer proxy, boolean forceConnect) {
 
-        NettyRequest nettyRequest = requestFactory.newNettyRequest(request, uri, forceConnect, proxy);
+        NettyRequest nettyRequest = requestFactory.newNettyRequest(request, forceConnect, proxy);
 
         if (originalFuture == null) {
-            return newNettyResponseFuture(uri, request, asyncHandler, nettyRequest, proxy);
+            return newNettyResponseFuture(request, asyncHandler, nettyRequest, proxy);
         } else {
             originalFuture.setNettyRequest(nettyRequest);
             originalFuture.setRequest(request);
@@ -183,88 +182,77 @@ public NettyRequestSender(AsyncHttpClientConfig config,//
         }
     }
 
-    private Channel getCachedChannel(NettyResponseFuture<?> future, Uri uri, ConnectionPoolPartitioning poolKeyGen, ProxyServer proxyServer, AsyncHandler<?> asyncHandler) {
+    private Channel getCachedChannel(NettyResponseFuture<?> future, Request request, ProxyServer proxyServer, AsyncHandler<?> asyncHandler) {
 
         if (future != null && future.reuseChannel() && Channels.isChannelValid(future.channel()))
             return future.channel();
         else
-            return pollAndVerifyCachedChannel(uri, proxyServer, poolKeyGen, asyncHandler);
+            return pollAndVerifyCachedChannel(request, proxyServer, asyncHandler);
     }
 
-    private <T> ListenableFuture<T> sendRequestWithCachedChannel(Request request, Uri uri, ProxyServer proxy, NettyResponseFuture<T> future,
-            AsyncHandler<T> asyncHandler, Channel channel) throws IOException {
+    private <T> ListenableFuture<T> sendRequestWithCachedChannel(Request request, ProxyServer proxy, NettyResponseFuture<T> future, AsyncHandler<T> asyncHandler, Channel channel) {
 
         if (asyncHandler instanceof AsyncHandlerExtensions)
-            AsyncHandlerExtensions.class.cast(asyncHandler).onConnectionPooled();
+            AsyncHandlerExtensions.class.cast(asyncHandler).onConnectionPooled(channel);
 
         future.setState(NettyResponseFuture.STATE.POOLED);
         future.attachChannel(channel, false);
 
-        LOGGER.debug("\nUsing cached Channel {}\n for request \n{}\n", channel, future.getNettyRequest().getHttpRequest());
-        Channels.setAttribute(channel, future);
+        LOGGER.debug("Using cached Channel {} for {} '{}'", channel, future.getNettyRequest().getHttpRequest().getMethod(), future.getNettyRequest().getHttpRequest().getUri());
 
-        try {
+        if (Channels.isChannelValid(channel)) {
+            Channels.setAttribute(channel, future);
             writeRequest(future, channel);
-        } catch (Exception ex) {
-            LOGGER.debug("writeRequest failure", ex);
-            if (ex.getMessage() != null && ex.getMessage().contains("SSLEngine")) {
-                LOGGER.debug("SSLEngine failure", ex);
-                future = null;
-            } else {
-                try {
-                    asyncHandler.onThrowable(ex);
-                } catch (Throwable t) {
-                    LOGGER.warn("doConnect.writeRequest()", t);
-                }
-                IOException ioe = new IOException(ex.getMessage());
-                ioe.initCause(ex);
-                throw ioe;
-            }
+        } else {
+            // bad luck, the channel was closed in-between
+            // there's a very good chance onClose was already notified but the
+            // future wasn't already registered
+            handleUnexpectedClosedChannel(channel, future);
         }
+
         return future;
     }
 
     private <T> ListenableFuture<T> sendRequestWithNewChannel(//
             Request request,//
-            Uri uri,//
             ProxyServer proxy,//
             boolean useProxy,//
             NettyResponseFuture<T> future,//
             AsyncHandler<T> asyncHandler,//
-            boolean reclaimCache) throws IOException {
+            boolean reclaimCache) {
 
-        boolean useSSl = isSecure(uri) && !useProxy;
+        // some headers are only set when performing the first request
+        HttpHeaders headers = future.getNettyRequest().getHttpRequest().headers();
+        Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
+        boolean connect = future.getNettyRequest().getHttpRequest().getMethod() == HttpMethod.CONNECT;
+        requestFactory.addAuthorizationHeader(headers, perConnectionAuthorizationHeader(request, proxy, realm));
+        requestFactory.setProxyAuthorizationHeader(headers, perConnectionProxyAuthorizationHeader(request, proxy, connect));
 
         // Do not throw an exception when we need an extra connection for a
         // redirect
         // FIXME why? This violate the max connection per host handling, right?
-        Bootstrap bootstrap = channelManager.getBootstrap(request.getUri(), useProxy, useSSl);
+        Bootstrap bootstrap = channelManager.getBootstrap(request.getUri(), useProxy);
 
         boolean channelPreempted = false;
-        String poolKey = null;
+        Object partitionKey = future.getPartitionKey();
 
-        // Do not throw an exception when we need an extra connection for a
-        // redirect.
-        if (!reclaimCache) {
-
-            // only compute when maxConnectionPerHost is enabled
-            // FIXME clean up
-            if (config.getMaxConnectionsPerHost() > 0)
-                poolKey = channelManager.getPartitionId(future);
+        try {
+            // Do not throw an exception when we need an extra connection for a
+            // redirect.
+            if (!reclaimCache) {
+                channelManager.preemptChannel(partitionKey);
+                channelPreempted = true;
+            }
 
-            channelPreempted = preemptChannel(asyncHandler, poolKey);
-        }
+            if (asyncHandler instanceof AsyncHandlerExtensions)
+                AsyncHandlerExtensions.class.cast(asyncHandler).onConnectionOpen();
 
-        if (asyncHandler instanceof AsyncHandlerExtensions)
-            AsyncHandlerExtensions.class.cast(asyncHandler).onOpenConnection();
-
-        try {
-            ChannelFuture channelFuture = connect(request, uri, proxy, useProxy, bootstrap);
-            channelFuture.addListener(new NettyConnectListener<T>(config, future, this, channelManager, channelPreempted, poolKey));
+            ChannelFuture channelFuture = connect(request, proxy, useProxy, bootstrap, asyncHandler);
+            channelFuture.addListener(new NettyConnectListener<T>(future, this, channelManager, channelPreempted, partitionKey));
 
         } catch (Throwable t) {
             if (channelPreempted)
-                channelManager.abortChannelPreemption(poolKey);
+                channelManager.abortChannelPreemption(partitionKey);
 
             abort(null, future, t.getCause() == null ? t : t.getCause());
         }
@@ -272,10 +260,9 @@ private Channel getCachedChannel(NettyResponseFuture<?> future, Uri uri, Connect
         return future;
     }
 
-    private <T> NettyResponseFuture<T> newNettyResponseFuture(Uri uri, Request request, AsyncHandler<T> asyncHandler, NettyRequest nettyRequest, ProxyServer proxyServer) {
+    private <T> NettyResponseFuture<T> newNettyResponseFuture(Request request, AsyncHandler<T> asyncHandler, NettyRequest nettyRequest, ProxyServer proxyServer) {
 
-        NettyResponseFuture<T> future = new NettyResponseFuture<T>(//
-                uri,//
+        NettyResponseFuture<T> future = new NettyResponseFuture<>(//
                 request,//
                 asyncHandler,//
                 nettyRequest,//
@@ -306,44 +293,50 @@ private Channel getCachedChannel(NettyResponseFuture<?> future, Uri uri, Connect
                 configureTransferAdapter(handler, httpRequest);
 
             if (!future.isHeadersAlreadyWrittenOnContinue()) {
-                try {
-                    if (future.getAsyncHandler() instanceof AsyncHandlerExtensions)
-                        AsyncHandlerExtensions.class.cast(future.getAsyncHandler()).onSendRequest();
-
-                    channel.writeAndFlush(httpRequest, channel.newProgressivePromise()).addListener(new ProgressListener(config, future.getAsyncHandler(), future, true, 0L));
-                } catch (Throwable cause) {
-                    // FIXME why not notify?
-                    LOGGER.debug(cause.getMessage(), cause);
-                    Channels.silentlyCloseChannel(channel);
-                    return;
-                }
+                if (future.getAsyncHandler() instanceof AsyncHandlerExtensions)
+                    AsyncHandlerExtensions.class.cast(future.getAsyncHandler()).onRequestSend(nettyRequest);
+
+                channel.writeAndFlush(httpRequest, channel.newProgressivePromise()).addListener(new ProgressListener(config, future.getAsyncHandler(), future, true, 0L));
             }
 
-            if (!future.isDontWriteBodyBecauseExpectContinue() && !httpRequest.getMethod().equals(HttpMethod.CONNECT) && nettyRequest.getBody() != null)
-                nettyRequest.getBody().write(channel, future, config);
+            if (!future.isDontWriteBodyBecauseExpectContinue() && httpRequest.getMethod() != HttpMethod.CONNECT && nettyRequest.getBody() != null)
+                nettyRequest.getBody().write(channel, future);
 
             // don't bother scheduling timeouts if channel became invalid
             if (Channels.isChannelValid(channel))
                 scheduleTimeouts(future);
 
-        } catch (Throwable ioe) {
-            Channels.silentlyCloseChannel(channel);
+        } catch (Exception e) {
+            LOGGER.error("Can't write request", e);
+            abort(channel, future, e);
         }
     }
 
-    private InetSocketAddress remoteAddress(Request request, Uri uri, ProxyServer proxy, boolean useProxy) {
-        if (request.getInetAddress() != null)
-            return new InetSocketAddress(request.getInetAddress(), getDefaultPort(uri));
+    private InetSocketAddress remoteAddress(Request request, ProxyServer proxy, boolean useProxy) throws UnknownHostException {
 
-        else if (!useProxy || avoidProxy(proxy, uri.getHost()))
-            return new InetSocketAddress(uri.getHost(), getDefaultPort(uri));
+        InetAddress address;
+        Uri uri = request.getUri();
+        int port = getExplicitPort(uri);
 
-        else
-            return new InetSocketAddress(proxy.getHost(), proxy.getPort());
+        if (request.getInetAddress() != null) {
+            address = request.getInetAddress();
+
+        } else if (!useProxy || avoidProxy(proxy, uri.getHost())) {
+            address = request.getNameResolver().resolve(uri.getHost());
+
+        } else {
+            address = request.getNameResolver().resolve(proxy.getHost());
+            port = proxy.getPort();
+        }
+
+        return new InetSocketAddress(address, port);
     }
 
-    private ChannelFuture connect(Request request, Uri uri, ProxyServer proxy, boolean useProxy, Bootstrap bootstrap) {
-        InetSocketAddress remoteAddress = remoteAddress(request, uri, proxy, useProxy);
+    private ChannelFuture connect(Request request, ProxyServer proxy, boolean useProxy, Bootstrap bootstrap, AsyncHandler<?> asyncHandler) throws UnknownHostException {
+        InetSocketAddress remoteAddress = remoteAddress(request, proxy, useProxy);
+
+        if (asyncHandler instanceof AsyncHandlerExtensions)
+            AsyncHandlerExtensions.class.cast(asyncHandler).onDnsResolved(remoteAddress.getAddress());
 
         if (request.getLocalAddress() != null)
             return bootstrap.connect(remoteAddress, new InetSocketAddress(request.getLocalAddress(), 0));
@@ -370,12 +363,11 @@ private void scheduleTimeouts(NettyResponseFuture<?> nettyResponseFuture) {
             timeoutsHolder.requestTimeout = requestTimeout;
         }
 
-        int readTimeout = config.getReadTimeout();
-        if (readTimeout != -1 && readTimeout < requestTimeoutInMs) {
-            // no need for a idleConnectionTimeout that's less than the
-            // requestTimeoutInMs
-            Timeout idleConnectionTimeout = newTimeout(new ReadTimeoutTimerTask(nettyResponseFuture, this, timeoutsHolder, requestTimeoutInMs, readTimeout), readTimeout);
-            timeoutsHolder.readTimeout = idleConnectionTimeout;
+        int readTimeoutValue = config.getReadTimeout();
+        if (readTimeoutValue != -1 && readTimeoutValue < requestTimeoutInMs) {
+            // no need for a readTimeout that's less than the requestTimeoutInMs
+            Timeout readTimeout = newTimeout(new ReadTimeoutTimerTask(nettyResponseFuture, this, timeoutsHolder, requestTimeoutInMs, readTimeoutValue), readTimeoutValue);
+            timeoutsHolder.readTimeout = readTimeout;
         }
         nettyResponseFuture.setTimeoutsHolder(timeoutsHolder);
     }
@@ -390,20 +382,26 @@ public void abort(Channel channel, NettyResponseFuture<?> future, Throwable t) {
             channelManager.closeChannel(channel);
 
         if (!future.isDone()) {
+            future.setState(NettyResponseFuture.STATE.CLOSED);
             LOGGER.debug("Aborting Future {}\n", future);
             LOGGER.debug(t.getMessage(), t);
             future.abort(t);
         }
     }
 
+    public void handleUnexpectedClosedChannel(Channel channel, NettyResponseFuture<?> future) {
+        if (future.isDone())
+            channelManager.closeChannel(channel);
+
+        else if (!retry(future))
+            abort(channel, future, REMOTELY_CLOSED_EXCEPTION);
+    }
+
     public boolean retry(NettyResponseFuture<?> future) {
 
         if (isClosed())
             return false;
 
-        // FIXME what is this for???
-        //channelManager.removeAll(channel);
-
         if (future.canBeReplayed()) {
             future.setState(NettyResponseFuture.STATE.RECONNECTED);
             future.getAndSetStatusReceived(false);
@@ -417,10 +415,8 @@ public boolean retry(NettyResponseFuture<?> future) {
                 sendNextRequest(future.getRequest(), future);
                 return true;
 
-            } catch (IOException iox) {
-                future.setState(NettyResponseFuture.STATE.CLOSED);
-                future.abort(iox);
-                LOGGER.error("Remotely Closed, unable to recover", iox);
+            } catch (Exception e) {
+                abort(future.channel(), future, e);
                 return false;
             }
         } else {
@@ -429,7 +425,7 @@ public boolean retry(NettyResponseFuture<?> future) {
         }
     }
 
-    public boolean applyIoExceptionFiltersAndReplayRequest(NettyResponseFuture<?> future, IOException e, Channel channel) throws IOException {
+    public boolean applyIoExceptionFiltersAndReplayRequest(NettyResponseFuture<?> future, IOException e, Channel channel) {
 
         boolean replayed = false;
 
@@ -446,34 +442,44 @@ public boolean applyIoExceptionFiltersAndReplayRequest(NettyResponseFuture<?> fu
             }
         }
 
-        if (fc.replayRequest()  && future.canBeReplayed()) {
+        if (fc.replayRequest() && future.canBeReplayed()) {
             replayRequest(future, fc, channel);
             replayed = true;
         }
         return replayed;
     }
 
-    public <T> void sendNextRequest(final Request request, final NettyResponseFuture<T> future) throws IOException {
+    public <T> void sendNextRequest(final Request request, final NettyResponseFuture<T> future) {
         sendRequest(request, future.getAsyncHandler(), future, true);
     }
 
-    // FIXME is this useful? Can't we do that when building the request?
-    private boolean validateWebSocketRequest(Request request, AsyncHandler<?> asyncHandler) {
-        return request.getMethod().equals(HttpMethod.GET.name()) && asyncHandler instanceof WebSocketUpgradeHandler;
+    private void validateWebSocketRequest(Request request, AsyncHandler<?> asyncHandler) {
+        Uri uri = request.getUri();
+        boolean isWs = uri.getScheme().startsWith(WS);
+        if (asyncHandler instanceof WebSocketUpgradeHandler) {
+            if (!isWs)
+                throw new IllegalArgumentException("WebSocketUpgradeHandler but scheme isn't ws or wss: " + uri.getScheme());
+            else if (!request.getMethod().equals(HttpMethod.GET.name()))
+                throw new IllegalArgumentException("WebSocketUpgradeHandler but method isn't GET: " + request.getMethod());
+        } else if (isWs) {
+            throw new IllegalArgumentException("No WebSocketUpgradeHandler but scheme is " + uri.getScheme());
+        }
     }
 
-    private Channel pollAndVerifyCachedChannel(Uri uri, ProxyServer proxy, ConnectionPoolPartitioning connectionPoolPartitioning, AsyncHandler<?> asyncHandler) {
+    private Channel pollAndVerifyCachedChannel(Request request, ProxyServer proxy, AsyncHandler<?> asyncHandler) {
 
         if (asyncHandler instanceof AsyncHandlerExtensions)
-            AsyncHandlerExtensions.class.cast(asyncHandler).onPoolConnection();
+            AsyncHandlerExtensions.class.cast(asyncHandler).onConnectionPool();
 
-        final Channel channel = channelManager.poll(uri, proxy, connectionPoolPartitioning);
+        Uri uri = request.getUri();
+        String virtualHost = request.getVirtualHost();
+        final Channel channel = channelManager.poll(uri, virtualHost, proxy, request.getConnectionPoolPartitioning());
 
         if (channel != null) {
             LOGGER.debug("Using cached Channel {}\n for uri {}\n", channel, uri);
 
             try {
-                channelManager.verifyChannelPipeline(channel.pipeline(), uri.getScheme());
+                channelManager.verifyChannelPipeline(channel.pipeline(), uri, virtualHost);
             } catch (Exception ex) {
                 LOGGER.debug(ex.getMessage(), ex);
             }
@@ -481,25 +487,8 @@ private Channel pollAndVerifyCachedChannel(Uri uri, ProxyServer proxy, Connectio
         return channel;
     }
 
-    private boolean preemptChannel(AsyncHandler<?> asyncHandler, String poolKey) throws IOException {
-
-        boolean channelPreempted = false;
-        if (channelManager.preemptChannel(poolKey)) {
-            channelPreempted = true;
-        } else {
-            IOException ex = new IOException(String.format("Too many connections %s", config.getMaxConnections()));
-            try {
-                asyncHandler.onThrowable(ex);
-            } catch (Exception e) {
-                LOGGER.warn("asyncHandler.onThrowable crashed", e);
-            }
-            throw ex;
-        }
-        return channelPreempted;
-    }
-
     @SuppressWarnings({ "rawtypes", "unchecked" })
-    public void replayRequest(final NettyResponseFuture<?> future, FilterContext fc, Channel channel) throws IOException {
+    public void replayRequest(final NettyResponseFuture<?> future, FilterContext fc, Channel channel) {
 
         Request newRequest = fc.getRequest();
         future.setAsyncHandler(fc.getAsyncHandler());
@@ -510,11 +499,25 @@ public void replayRequest(final NettyResponseFuture<?> future, FilterContext fc,
         if (future.getAsyncHandler() instanceof AsyncHandlerExtensions)
             AsyncHandlerExtensions.class.cast(future.getAsyncHandler()).onRetry();
 
-        channelManager.drainChannel(channel, future);
+        channelManager.drainChannelAndOffer(channel, future);
         sendNextRequest(newRequest, future);
     }
 
     public boolean isClosed() {
         return closed.get();
     }
+
+    public final Callback newExecuteNextRequestCallback(final NettyResponseFuture<?> future, final Request nextRequest) {
+
+        return new Callback(future) {
+            @Override
+            public void call() {
+                sendNextRequest(nextRequest, future);
+            }
+        };
+    }
+
+    public void drainChannelAndExecuteNextRequest(final Channel channel, final NettyResponseFuture<?> future, Request nextRequest) {
+        Channels.setAttribute(channel, newExecuteNextRequestCallback(future, nextRequest));
+    }
 }
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/ProgressListener.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/request/ProgressListener.java
similarity index 84%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/ProgressListener.java
rename to providers/netty4/src/main/java/org/asynchttpclient/netty/request/ProgressListener.java
index 11aa82725..2c025ceac 100755
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/ProgressListener.java
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/request/ProgressListener.java
@@ -11,7 +11,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty.request;
+package org.asynchttpclient.netty.request;
 
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelProgressiveFuture;
@@ -21,11 +21,11 @@
 
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.ProgressAsyncHandler;
 import org.asynchttpclient.Realm;
-import org.asynchttpclient.providers.netty.channel.Channels;
-import org.asynchttpclient.providers.netty.future.NettyResponseFuture;
-import org.asynchttpclient.providers.netty.future.StackTraceInspector;
+import org.asynchttpclient.handler.ProgressAsyncHandler;
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.channel.Channels;
+import org.asynchttpclient.netty.future.StackTraceInspector;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -55,11 +55,7 @@ public ProgressListener(AsyncHttpClientConfig config,//
     private boolean abortOnThrowable(Throwable cause, Channel channel) {
 
         if (cause != null && future.getState() != NettyResponseFuture.STATE.NEW) {
-            if (cause instanceof IllegalStateException) {
-                LOGGER.debug(cause.getMessage(), cause);
-                Channels.silentlyCloseChannel(channel);
-
-            } else if (cause instanceof ClosedChannelException || StackTraceInspector.abortOnReadOrWriteException(cause)) {
+            if (cause instanceof IllegalStateException || cause instanceof ClosedChannelException || StackTraceInspector.recoverOnReadOrWriteException(cause)) {
                 LOGGER.debug(cause.getMessage(), cause);
                 Channels.silentlyCloseChannel(channel);
                 
@@ -92,9 +88,9 @@ public void operationComplete(ChannelProgressiveFuture cf) {
             if (startPublishing && asyncHandler instanceof ProgressAsyncHandler) {
                 ProgressAsyncHandler<?> progressAsyncHandler = (ProgressAsyncHandler<?>) asyncHandler;
                 if (notifyHeaders) {
-                    progressAsyncHandler.onHeaderWriteCompleted();
+                    progressAsyncHandler.onHeadersWritten();
                 } else {
-                    progressAsyncHandler.onContentWriteCompleted();
+                    progressAsyncHandler.onContentWritten();
                 }
             }
         }
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/BodyChunkedInput.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/request/body/BodyChunkedInput.java
similarity index 76%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/BodyChunkedInput.java
rename to providers/netty4/src/main/java/org/asynchttpclient/netty/request/body/BodyChunkedInput.java
index a9b50bd40..d26079661 100755
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/BodyChunkedInput.java
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/request/body/BodyChunkedInput.java
@@ -11,9 +11,9 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty.request.body;
+package org.asynchttpclient.netty.request.body;
 
-import org.asynchttpclient.Body;
+import org.asynchttpclient.request.body.Body;
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
@@ -53,14 +53,19 @@ public ByteBuf readChunk(ChannelHandlerContext ctx) throws Exception {
         } else {
             // FIXME pass a visitor so we can directly pass a pooled ByteBuf
             ByteBuffer buffer = ByteBuffer.allocate(chunkSize);
-            long r = body.read(buffer);
-            if (r < 0L) {
-                endOfInput = true;
-                return null;
-            } else {
-                endOfInput = r == contentLength || r < chunkSize && contentLength > 0;
-                buffer.flip();
-                return Unpooled.wrappedBuffer(buffer);
+            Body.State state = body.read(buffer);
+            switch (state) {
+                case Stop:
+                    endOfInput = true;
+                    return null;
+                case Suspend:
+                    //this will suspend the stream in ChunkedWriteHandler
+                    return null;
+                case Continue:
+                    buffer.flip();
+                    return Unpooled.wrappedBuffer(buffer);
+                default:
+                    throw new IllegalStateException("Unknown state: " + state);
             }
         }
     }
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/BodyFileRegion.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/request/body/BodyFileRegion.java
similarity index 94%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/BodyFileRegion.java
rename to providers/netty4/src/main/java/org/asynchttpclient/netty/request/body/BodyFileRegion.java
index b1d02275e..b6934449e 100755
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/BodyFileRegion.java
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/request/body/BodyFileRegion.java
@@ -11,12 +11,11 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty.request.body;
+package org.asynchttpclient.netty.request.body;
 
 import static org.asynchttpclient.util.MiscUtils.closeSilently;
 
-
-import org.asynchttpclient.RandomAccessBody;
+import org.asynchttpclient.request.body.RandomAccessBody;
 
 import io.netty.channel.FileRegion;
 import io.netty.util.AbstractReferenceCounted;
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/NettyBody.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/request/body/NettyBody.java
similarity index 74%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/NettyBody.java
rename to providers/netty4/src/main/java/org/asynchttpclient/netty/request/body/NettyBody.java
index cea79857c..39cbde82f 100755
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/NettyBody.java
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/request/body/NettyBody.java
@@ -11,20 +11,19 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty.request.body;
-
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.providers.netty.future.NettyResponseFuture;
+package org.asynchttpclient.netty.request.body;
 
 import io.netty.channel.Channel;
 
 import java.io.IOException;
 
+import org.asynchttpclient.netty.NettyResponseFuture;
+
 public interface NettyBody {
 
     long getContentLength();
 
     String getContentType();
 
-    void write(Channel channel, NettyResponseFuture<?> future, AsyncHttpClientConfig config) throws IOException;
+    void write(Channel channel, NettyResponseFuture<?> future) throws IOException;
 }
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/NettyBodyBody.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/request/body/NettyBodyBody.java
similarity index 70%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/NettyBodyBody.java
rename to providers/netty4/src/main/java/org/asynchttpclient/netty/request/body/NettyBodyBody.java
index 96957591a..0173e6c2b 100755
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/NettyBodyBody.java
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/request/body/NettyBodyBody.java
@@ -11,7 +11,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty.request.body;
+package org.asynchttpclient.netty.request.body;
 
 import static org.asynchttpclient.util.MiscUtils.closeSilently;
 import io.netty.channel.Channel;
@@ -23,23 +23,23 @@
 import java.io.IOException;
 
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.Body;
-import org.asynchttpclient.BodyGenerator;
-import org.asynchttpclient.RandomAccessBody;
-import org.asynchttpclient.providers.netty.NettyAsyncHttpProviderConfig;
-import org.asynchttpclient.providers.netty.channel.ChannelManager;
-import org.asynchttpclient.providers.netty.future.NettyResponseFuture;
-import org.asynchttpclient.providers.netty.request.ProgressListener;
-import org.asynchttpclient.providers.netty.request.body.FeedableBodyGenerator.FeedListener;
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.channel.ChannelManager;
+import org.asynchttpclient.netty.request.ProgressListener;
+import org.asynchttpclient.request.body.Body;
+import org.asynchttpclient.request.body.RandomAccessBody;
+import org.asynchttpclient.request.body.generator.BodyGenerator;
+import org.asynchttpclient.request.body.generator.SimpleFeedableBodyGenerator;
+import org.asynchttpclient.request.body.generator.FeedableBodyGenerator.FeedListener;
 
 public class NettyBodyBody implements NettyBody {
 
     private final Body body;
-    private final NettyAsyncHttpProviderConfig nettyConfig;
+    private final AsyncHttpClientConfig config;
 
-    public NettyBodyBody(Body body, NettyAsyncHttpProviderConfig nettyConfig) {
+    public NettyBodyBody(Body body, AsyncHttpClientConfig config) {
         this.body = body;
-        this.nettyConfig = nettyConfig;
+        this.config = config;
     }
 
     public Body getBody() {
@@ -57,22 +57,24 @@ public String getContentType() {
     };
 
     @Override
-    public void write(final Channel channel, NettyResponseFuture<?> future, AsyncHttpClientConfig config) throws IOException {
+    public void write(final Channel channel, NettyResponseFuture<?> future) throws IOException {
 
         Object msg;
-        if (body instanceof RandomAccessBody && !ChannelManager.isSslHandlerConfigured(channel.pipeline()) && !nettyConfig.isDisableZeroCopy()) {
+        if (body instanceof RandomAccessBody && !ChannelManager.isSslHandlerConfigured(channel.pipeline()) && !config.isDisableZeroCopy()) {
             msg = new BodyFileRegion((RandomAccessBody) body);
 
         } else {
             msg = new BodyChunkedInput(body);
 
             BodyGenerator bg = future.getRequest().getBodyGenerator();
-            if (bg instanceof FeedableBodyGenerator) {
-                FeedableBodyGenerator.class.cast(bg).setListener(new FeedListener() {
+            if (bg instanceof SimpleFeedableBodyGenerator) {
+                SimpleFeedableBodyGenerator.class.cast(bg).setListener(new FeedListener() {
                     @Override
                     public void onContentAdded() {
                         channel.pipeline().get(ChunkedWriteHandler.class).resumeTransfer();
                     }
+                    @Override
+                    public void onError(Throwable t) {}
                 });
             }
         }
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/NettyByteArrayBody.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/request/body/NettyByteArrayBody.java
similarity index 67%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/NettyByteArrayBody.java
rename to providers/netty4/src/main/java/org/asynchttpclient/netty/request/body/NettyByteArrayBody.java
index 953461fb8..a5ab11569 100755
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/NettyByteArrayBody.java
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/request/body/NettyByteArrayBody.java
@@ -11,16 +11,13 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty.request.body;
+package org.asynchttpclient.netty.request.body;
 
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.providers.netty.future.NettyResponseFuture;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
 
-import io.netty.channel.Channel;
 
-import java.io.IOException;
-
-public class NettyByteArrayBody implements NettyBody {
+public class NettyByteArrayBody extends NettyDirectBody {
 
     private final byte[] bytes;
     private final String contentType;
@@ -34,10 +31,6 @@ public NettyByteArrayBody(byte[] bytes, String contentType) {
         this.contentType = contentType;
     }
 
-    public byte[] getBytes() {
-        return bytes;
-    }
-
     @Override
     public long getContentLength() {
         return bytes.length;
@@ -49,7 +42,7 @@ public String getContentType() {
     }
 
     @Override
-    public void write(Channel channel, NettyResponseFuture<?> future, AsyncHttpClientConfig config) throws IOException {
-        throw new UnsupportedOperationException("This kind of body is supposed to be writen directly");
+    public ByteBuf byteBuf() {
+        return Unpooled.wrappedBuffer(bytes);
     }
 }
diff --git a/providers/netty4/src/main/java/org/asynchttpclient/netty/request/body/NettyByteBufferBody.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/request/body/NettyByteBufferBody.java
new file mode 100644
index 000000000..4b06d6589
--- /dev/null
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/request/body/NettyByteBufferBody.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.request.body;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+
+import java.nio.ByteBuffer;
+
+public class NettyByteBufferBody extends NettyDirectBody {
+
+    private final ByteBuffer bb;
+    private final String contentType;
+    private final long length;
+
+    public NettyByteBufferBody(ByteBuffer bb) {
+        this(bb, null);
+    }
+
+    public NettyByteBufferBody(ByteBuffer bb, String contentType) {
+        this.bb = bb;
+        length = bb.remaining();
+        bb.mark();
+        this.contentType = contentType;
+    }
+
+    @Override
+    public long getContentLength() {
+        return length;
+    }
+
+    @Override
+    public String getContentType() {
+        return contentType;
+    }
+
+    @Override
+    public ByteBuf byteBuf() {
+        // for retry
+        bb.reset();
+        return Unpooled.wrappedBuffer(bb);
+    }
+}
diff --git a/providers/netty4/src/main/java/org/asynchttpclient/netty/request/body/NettyCompositeByteArrayBody.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/request/body/NettyCompositeByteArrayBody.java
new file mode 100644
index 000000000..4a1f60183
--- /dev/null
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/request/body/NettyCompositeByteArrayBody.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.request.body;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+
+import java.util.List;
+
+public class NettyCompositeByteArrayBody extends NettyDirectBody {
+
+    private final byte[][] bytes;
+    private final String contentType;
+    private final long contentLength;
+
+    public NettyCompositeByteArrayBody(List<byte[]> bytes) {
+        this(bytes, null);
+    }
+
+    public NettyCompositeByteArrayBody(List<byte[]> bytes, String contentType) {
+        this.bytes = new byte[bytes.size()][];
+        bytes.toArray(this.bytes);
+        this.contentType = contentType;
+        long l = 0;
+        for (byte[] b : bytes)
+            l += b.length;
+        contentLength = l;
+    }
+
+    @Override
+    public long getContentLength() {
+        return contentLength;
+    }
+
+    @Override
+    public String getContentType() {
+        return contentType;
+    }
+
+    @Override
+    public ByteBuf byteBuf() {
+        return Unpooled.wrappedBuffer(bytes);
+    }
+}
diff --git a/providers/netty4/src/main/java/org/asynchttpclient/netty/request/body/NettyDirectBody.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/request/body/NettyDirectBody.java
new file mode 100644
index 000000000..caa8fbefb
--- /dev/null
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/request/body/NettyDirectBody.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.request.body;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.Channel;
+
+import java.io.IOException;
+
+import org.asynchttpclient.netty.NettyResponseFuture;
+
+public abstract class NettyDirectBody implements NettyBody {
+
+    public abstract ByteBuf byteBuf();
+
+    @Override
+    public void write(Channel channel, NettyResponseFuture<?> future) throws IOException {
+        throw new UnsupportedOperationException("This kind of body is supposed to be writen directly");
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/NettyFileBody.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/request/body/NettyFileBody.java
similarity index 73%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/NettyFileBody.java
rename to providers/netty4/src/main/java/org/asynchttpclient/netty/request/body/NettyFileBody.java
index 44a5349a7..e3270d2ea 100755
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/NettyFileBody.java
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/request/body/NettyFileBody.java
@@ -11,7 +11,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty.request.body;
+package org.asynchttpclient.netty.request.body;
 
 import static org.asynchttpclient.util.MiscUtils.closeSilently;
 import io.netty.channel.Channel;
@@ -27,30 +27,29 @@
 import java.io.RandomAccessFile;
 
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.providers.netty.NettyAsyncHttpProviderConfig;
-import org.asynchttpclient.providers.netty.channel.ChannelManager;
-import org.asynchttpclient.providers.netty.future.NettyResponseFuture;
-import org.asynchttpclient.providers.netty.request.ProgressListener;
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.channel.ChannelManager;
+import org.asynchttpclient.netty.request.ProgressListener;
 
 public class NettyFileBody implements NettyBody {
 
     private final File file;
     private final long offset;
     private final long length;
-    private final NettyAsyncHttpProviderConfig nettyConfig;
+    private final AsyncHttpClientConfig config;
 
-    public NettyFileBody(File file, NettyAsyncHttpProviderConfig nettyConfig) throws IOException {
-        this(file, 0, file.length(), nettyConfig);
+    public NettyFileBody(File file, AsyncHttpClientConfig config) {
+        this(file, 0, file.length(), config);
     }
 
-    public NettyFileBody(File file, long offset, long length, NettyAsyncHttpProviderConfig nettyConfig) throws IOException {
+    public NettyFileBody(File file, long offset, long length, AsyncHttpClientConfig config) {
         if (!file.isFile()) {
-            throw new IOException(String.format("File %s is not a file or doesn't exist", file.getAbsolutePath()));
+            throw new IllegalArgumentException(String.format("File %s is not a file or doesn't exist", file.getAbsolutePath()));
         }
         this.file = file;
         this.offset = offset;
         this.length = length;
-        this.nettyConfig = nettyConfig;
+        this.config = config;
     }
 
     public File getFile() {
@@ -72,13 +71,13 @@ public String getContentType() {
     }
 
     @Override
-    public void write(Channel channel, NettyResponseFuture<?> future, AsyncHttpClientConfig config) throws IOException {
+    public void write(Channel channel, NettyResponseFuture<?> future) throws IOException {
         final RandomAccessFile raf = new RandomAccessFile(file, "r");
 
         try {
             ChannelFuture writeFuture;
-            if (ChannelManager.isSslHandlerConfigured(channel.pipeline()) || nettyConfig.isDisableZeroCopy()) {
-                writeFuture = channel.write(new ChunkedFile(raf, offset, length, nettyConfig.getChunkedFileChunkSize()), channel.newProgressivePromise());
+            if (ChannelManager.isSslHandlerConfigured(channel.pipeline()) || config.isDisableZeroCopy()) {
+                writeFuture = channel.write(new ChunkedFile(raf, offset, length, config.getChunkedFileChunkSize()), channel.newProgressivePromise());
             } else {
                 FileRegion region = new DefaultFileRegion(raf.getChannel(), offset, length);
                 writeFuture = channel.write(region, channel.newProgressivePromise());
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/NettyInputStreamBody.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/request/body/NettyInputStreamBody.java
similarity index 87%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/NettyInputStreamBody.java
rename to providers/netty4/src/main/java/org/asynchttpclient/netty/request/body/NettyInputStreamBody.java
index 9f7d84199..edccb9ca7 100755
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/body/NettyInputStreamBody.java
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/request/body/NettyInputStreamBody.java
@@ -11,13 +11,13 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty.request.body;
+package org.asynchttpclient.netty.request.body;
 
 import static org.asynchttpclient.util.MiscUtils.closeSilently;
 
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.providers.netty.future.NettyResponseFuture;
-import org.asynchttpclient.providers.netty.request.ProgressListener;
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.request.ProgressListener;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -34,9 +34,11 @@
     private static final Logger LOGGER = LoggerFactory.getLogger(NettyInputStreamBody.class);
 
     private final InputStream inputStream;
+    private final AsyncHttpClientConfig config;
 
-    public NettyInputStreamBody(InputStream inputStream) {
+    public NettyInputStreamBody(InputStream inputStream, AsyncHttpClientConfig config) {
         this.inputStream = inputStream;
+        this.config = config;
     }
 
     public InputStream getInputStream() {
@@ -54,7 +56,7 @@ public String getContentType() {
     }
 
     @Override
-    public void write(Channel channel, NettyResponseFuture<?> future, AsyncHttpClientConfig config) throws IOException {
+    public void write(Channel channel, NettyResponseFuture<?> future) throws IOException {
         final InputStream is = inputStream;
 
         if (future.isStreamWasAlreadyConsumed()) {
diff --git a/providers/netty4/src/main/java/org/asynchttpclient/netty/request/body/NettyMultipartBody.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/request/body/NettyMultipartBody.java
new file mode 100755
index 000000000..4786e8469
--- /dev/null
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/request/body/NettyMultipartBody.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.request.body;
+
+import static org.asynchttpclient.request.body.multipart.MultipartUtils.newMultipartBody;
+
+import java.util.List;
+
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
+import org.asynchttpclient.request.body.multipart.MultipartBody;
+import org.asynchttpclient.request.body.multipart.Part;
+
+public class NettyMultipartBody extends NettyBodyBody {
+
+    private final String contentType;
+
+    public NettyMultipartBody(List<Part> parts, FluentCaseInsensitiveStringsMap headers, AsyncHttpClientConfig config) {
+        this(newMultipartBody(parts, headers), config);
+    }
+
+    private NettyMultipartBody(MultipartBody body, AsyncHttpClientConfig config) {
+        super(body, config);
+        contentType = body.getContentType();
+    }
+
+    @Override
+    public String getContentType() {
+        return contentType;
+    }
+}
diff --git a/providers/netty4/src/main/java/org/asynchttpclient/netty/request/body/NettyReactiveStreamsBody.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/request/body/NettyReactiveStreamsBody.java
new file mode 100644
index 000000000..7504ad64e
--- /dev/null
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/request/body/NettyReactiveStreamsBody.java
@@ -0,0 +1,141 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.request.body;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.NoSuchElementException;
+
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.reactivestreams.Publisher;
+import org.reactivestreams.Subscriber;
+import org.reactivestreams.Subscription;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.typesafe.netty.HandlerSubscriber;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelFutureListener;
+import io.netty.handler.codec.http.DefaultHttpContent;
+import io.netty.handler.codec.http.HttpContent;
+import io.netty.handler.codec.http.LastHttpContent;
+import io.netty.util.concurrent.EventExecutor;
+
+public class NettyReactiveStreamsBody implements NettyBody {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(NettyReactiveStreamsBody.class);
+    private static final String NAME_IN_CHANNEL_PIPELINE = "request-body-streamer";
+
+    private final Publisher<ByteBuffer> publisher;
+
+    public NettyReactiveStreamsBody(Publisher<ByteBuffer> publisher) {
+        this.publisher = publisher;
+    }
+
+    @Override
+    public long getContentLength() {
+        return -1L;
+    }
+
+    @Override
+    public String getContentType() {
+        return null;
+    }
+
+    @Override
+    public void write(Channel channel, NettyResponseFuture<?> future) throws IOException {
+        if (future.isStreamWasAlreadyConsumed()) {
+            LOGGER.warn("Stream has already been consumed and cannot be reset");
+        } else {
+            future.setStreamWasAlreadyConsumed(true);
+            NettySubscriber subscriber = new NettySubscriber(channel, future);
+            channel.pipeline().addLast(NAME_IN_CHANNEL_PIPELINE, subscriber);
+            publisher.subscribe(new SubscriberAdapter(subscriber));
+        }
+    }
+
+    private static class SubscriberAdapter implements Subscriber<ByteBuffer> {
+        private volatile Subscriber<HttpContent> subscriber;
+        
+        public SubscriberAdapter(Subscriber<HttpContent> subscriber) {
+            this.subscriber = subscriber;
+        }
+        @Override
+        public void onSubscribe(Subscription s) {
+           subscriber.onSubscribe(s);
+        }
+        @Override
+        public void onNext(ByteBuffer t) {
+            ByteBuf buffer = Unpooled.wrappedBuffer(t.array());
+            HttpContent content = new DefaultHttpContent(buffer);
+            subscriber.onNext(content);
+        }
+        @Override
+        public void onError(Throwable t) {
+            subscriber.onError(t);
+        }
+        @Override
+        public void onComplete() {
+            subscriber.onComplete();
+        }        
+    }
+    
+    private static class NettySubscriber extends HandlerSubscriber<HttpContent> {
+        private static final Logger LOGGER = LoggerFactory.getLogger(NettySubscriber.class);
+
+        private final Channel channel;
+        private final NettyResponseFuture<?> future;
+
+        public NettySubscriber(Channel channel, NettyResponseFuture<?> future) {
+            super(channel.eventLoop());
+            this.channel = channel;
+            this.future = future;
+        }
+
+        @Override
+        protected void complete() {
+            EventExecutor executor = channel.eventLoop();
+            executor.execute(new Runnable() {
+                @Override
+                public void run() {
+                    channel.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT).addListener(new ChannelFutureListener() {
+                        @Override
+                        public void operationComplete(ChannelFuture future) throws Exception {
+                            removeFromPipeline();
+                        }
+                    });
+                }
+            });
+        }
+
+        @Override
+        protected void error(Throwable error) {
+            if(error == null) throw null;
+            removeFromPipeline();
+            future.abort(error);
+        }
+
+        private void removeFromPipeline() {
+            try {
+                channel.pipeline().remove(this);
+                LOGGER.debug(String.format("Removed handler %s from pipeline.", NAME_IN_CHANNEL_PIPELINE));
+            } catch (NoSuchElementException e) {
+                LOGGER.debug(String.format("Failed to remove handler %s from pipeline.", NAME_IN_CHANNEL_PIPELINE), e);
+            }
+        }
+    }
+}
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/timeout/ReadTimeoutTimerTask.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/timeout/ReadTimeoutTimerTask.java
similarity index 88%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/timeout/ReadTimeoutTimerTask.java
rename to providers/netty4/src/main/java/org/asynchttpclient/netty/timeout/ReadTimeoutTimerTask.java
index 2c56a0404..715afadf6 100755
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/timeout/ReadTimeoutTimerTask.java
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/timeout/ReadTimeoutTimerTask.java
@@ -11,13 +11,13 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty.request.timeout;
+package org.asynchttpclient.netty.timeout;
 
 import static org.asynchttpclient.util.DateUtils.millisTime;
 import io.netty.util.Timeout;
 
-import org.asynchttpclient.providers.netty.future.NettyResponseFuture;
-import org.asynchttpclient.providers.netty.request.NettyRequestSender;
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.request.NettyRequestSender;
 
 public class ReadTimeoutTimerTask extends TimeoutTimerTask {
 
@@ -51,7 +51,7 @@ public void run(Timeout timeout) throws Exception {
         long durationBeforeCurrentReadTimeout = currentReadTimeoutInstant - now;
 
         if (durationBeforeCurrentReadTimeout <= 0L) {
-            // idleConnectionTimeout reached
+            // idleConnectTimeout reached
             String message = "Read timeout to " + remoteAddress + " of " + readTimeout + " ms";
             long durationSinceLastTouch = now - nettyResponseFuture.getLastTouch();
             expire(message, durationSinceLastTouch);
@@ -67,8 +67,5 @@ public void run(Timeout timeout) throws Exception {
             // otherwise, no need to reschedule: requestTimeout will happen sooner
             timeoutsHolder.readTimeout = null;
         }
-
-        // this task should be evacuated from the timer but who knows
-        nettyResponseFuture = null;
     }
 }
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/timeout/RequestTimeoutTimerTask.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/timeout/RequestTimeoutTimerTask.java
similarity index 81%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/timeout/RequestTimeoutTimerTask.java
rename to providers/netty4/src/main/java/org/asynchttpclient/netty/timeout/RequestTimeoutTimerTask.java
index 2c448a4b8..42ba4f16b 100755
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/timeout/RequestTimeoutTimerTask.java
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/timeout/RequestTimeoutTimerTask.java
@@ -11,13 +11,13 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty.request.timeout;
+package org.asynchttpclient.netty.timeout;
 
 import static org.asynchttpclient.util.DateUtils.millisTime;
 import io.netty.util.Timeout;
 
-import org.asynchttpclient.providers.netty.future.NettyResponseFuture;
-import org.asynchttpclient.providers.netty.request.NettyRequestSender;
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.request.NettyRequestSender;
 
 public class RequestTimeoutTimerTask extends TimeoutTimerTask {
 
@@ -37,7 +37,7 @@ public void run(Timeout timeout) throws Exception {
         if (done.getAndSet(true) || requestSender.isClosed())
             return;
 
-        // in any case, cancel possible idleConnectionTimeout sibling
+        // in any case, cancel possible readTimeout sibling
         timeoutsHolder.cancel();
 
         if (nettyResponseFuture.isDone())
@@ -46,8 +46,5 @@ public void run(Timeout timeout) throws Exception {
         String message = "Request timed out to " + remoteAddress + " of " + requestTimeout + " ms";
         long age = millisTime() - nettyResponseFuture.getStart();
         expire(message, age);
-        
-        // this task should be evacuated from the timer but who knows
-        nettyResponseFuture = null;
     }
 }
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/timeout/TimeoutTimerTask.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/timeout/TimeoutTimerTask.java
similarity index 92%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/timeout/TimeoutTimerTask.java
rename to providers/netty4/src/main/java/org/asynchttpclient/netty/timeout/TimeoutTimerTask.java
index d0bc0328b..1c411a7fa 100755
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/timeout/TimeoutTimerTask.java
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/timeout/TimeoutTimerTask.java
@@ -11,7 +11,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty.request.timeout;
+package org.asynchttpclient.netty.timeout;
 
 import io.netty.util.TimerTask;
 
@@ -19,8 +19,8 @@
 import java.util.concurrent.TimeoutException;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import org.asynchttpclient.providers.netty.future.NettyResponseFuture;
-import org.asynchttpclient.providers.netty.request.NettyRequestSender;
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.request.NettyRequestSender;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/timeout/TimeoutsHolder.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/timeout/TimeoutsHolder.java
similarity index 96%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/timeout/TimeoutsHolder.java
rename to providers/netty4/src/main/java/org/asynchttpclient/netty/timeout/TimeoutsHolder.java
index 6fb7fa328..6d424c23b 100755
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/request/timeout/TimeoutsHolder.java
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/timeout/TimeoutsHolder.java
@@ -11,7 +11,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty.request.timeout;
+package org.asynchttpclient.netty.timeout;
 
 import io.netty.util.Timeout;
 
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/util/ByteBufUtils.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/util/ByteBufUtils.java
similarity index 97%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/util/ByteBufUtils.java
rename to providers/netty4/src/main/java/org/asynchttpclient/netty/util/ByteBufUtils.java
index f370ac153..dc803e728 100755
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/util/ByteBufUtils.java
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/util/ByteBufUtils.java
@@ -13,7 +13,7 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package org.asynchttpclient.providers.netty.util;
+package org.asynchttpclient.netty.util;
 
 import io.netty.buffer.ByteBuf;
 
diff --git a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/ws/NettyWebSocket.java b/providers/netty4/src/main/java/org/asynchttpclient/netty/ws/NettyWebSocket.java
similarity index 87%
rename from providers/netty/src/main/java/org/asynchttpclient/providers/netty/ws/NettyWebSocket.java
rename to providers/netty4/src/main/java/org/asynchttpclient/netty/ws/NettyWebSocket.java
index a6a9a2a74..57bc31890 100755
--- a/providers/netty/src/main/java/org/asynchttpclient/providers/netty/ws/NettyWebSocket.java
+++ b/providers/netty4/src/main/java/org/asynchttpclient/netty/ws/NettyWebSocket.java
@@ -11,10 +11,10 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty.ws;
+package org.asynchttpclient.netty.ws;
 
 import static io.netty.buffer.Unpooled.wrappedBuffer;
-import static org.asynchttpclient.util.StandardCharsets.UTF_8;
+import static java.nio.charset.StandardCharsets.UTF_8;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.handler.codec.http.websocketx.BinaryWebSocketFrame;
@@ -25,23 +25,24 @@
 
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
+import java.net.SocketAddress;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
 import java.util.concurrent.ConcurrentLinkedQueue;
 
+import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.providers.netty.NettyAsyncHttpProviderConfig;
-import org.asynchttpclient.providers.netty.response.NettyResponseBodyPart;
-import org.asynchttpclient.websocket.WebSocket;
-import org.asynchttpclient.websocket.WebSocketByteFragmentListener;
-import org.asynchttpclient.websocket.WebSocketByteListener;
-import org.asynchttpclient.websocket.WebSocketCloseCodeReasonListener;
-import org.asynchttpclient.websocket.WebSocketListener;
-import org.asynchttpclient.websocket.WebSocketPingListener;
-import org.asynchttpclient.websocket.WebSocketPongListener;
-import org.asynchttpclient.websocket.WebSocketTextFragmentListener;
-import org.asynchttpclient.websocket.WebSocketTextListener;
+import org.asynchttpclient.netty.NettyResponseBodyPart;
+import org.asynchttpclient.ws.WebSocket;
+import org.asynchttpclient.ws.WebSocketByteFragmentListener;
+import org.asynchttpclient.ws.WebSocketByteListener;
+import org.asynchttpclient.ws.WebSocketCloseCodeReasonListener;
+import org.asynchttpclient.ws.WebSocketListener;
+import org.asynchttpclient.ws.WebSocketPingListener;
+import org.asynchttpclient.ws.WebSocketPongListener;
+import org.asynchttpclient.ws.WebSocketTextFragmentListener;
+import org.asynchttpclient.ws.WebSocketTextListener;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -57,14 +58,24 @@
     private volatile boolean interestedInByteMessages;
     private volatile boolean interestedInTextMessages;
 
-    public NettyWebSocket(Channel channel, NettyAsyncHttpProviderConfig nettyConfig) {
-        this(channel, nettyConfig, new ConcurrentLinkedQueue<WebSocketListener>());
+    public NettyWebSocket(Channel channel, AsyncHttpClientConfig config) {
+        this(channel, config, new ConcurrentLinkedQueue<WebSocketListener>());
     }
 
-    public NettyWebSocket(Channel channel, NettyAsyncHttpProviderConfig nettyConfig, Collection<WebSocketListener> listeners) {
+    public NettyWebSocket(Channel channel, AsyncHttpClientConfig config, Collection<WebSocketListener> listeners) {
         this.channel = channel;
         this.listeners = listeners;
-        maxBufferSize = nettyConfig.getWebSocketMaxBufferSize();
+        maxBufferSize = config.getWebSocketMaxBufferSize();
+    }
+
+    @Override
+    public SocketAddress getRemoteAddress() {
+        return channel.remoteAddress();
+    }
+
+    @Override
+    public SocketAddress getLocalAddress() {
+        return channel.localAddress();
     }
 
     @Override
@@ -198,7 +209,7 @@ public WebSocket removeWebSocketListener(WebSocketListener l) {
 
     private List<byte[]> fragments() {
         if (_fragments == null)
-            _fragments = new ArrayList<byte[]>(2);
+            _fragments = new ArrayList<>(2);
         return _fragments;
     }
 
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyAsyncHttpProviderTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyAsyncHttpProviderTest.java
new file mode 100644
index 000000000..3e30b1df1
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyAsyncHttpProviderTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+import org.asynchttpclient.AbstractBasicTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+
+public class NettyAsyncHttpProviderTest extends AbstractBasicTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncProviderBasicTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyAsyncProviderBasicTest.java
similarity index 86%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncProviderBasicTest.java
rename to providers/netty4/src/test/java/org/asynchttpclient/netty/NettyAsyncProviderBasicTest.java
index 79c511286..0aaaa6ce8 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncProviderBasicTest.java
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyAsyncProviderBasicTest.java
@@ -10,15 +10,17 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty;
+
+import io.netty.channel.ChannelOption;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.AsyncHttpProviderConfig;
-import org.asynchttpclient.async.AsyncProvidersBasicTest;
-
-import io.netty.channel.ChannelOption;
+import org.asynchttpclient.AsyncProvidersBasicTest;
+import org.testng.annotations.Test;
 
+@Test
 public class NettyAsyncProviderBasicTest extends AsyncProvidersBasicTest {
 
     @Override
@@ -30,9 +32,4 @@ public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
     protected AsyncHttpProviderConfig<?, ?> getProviderConfig() {
         return new NettyAsyncHttpProviderConfig().addChannelOption(ChannelOption.TCP_NODELAY, Boolean.TRUE);
     }
-
-    @Override
-    protected String acceptEncodingHeader() {
-        return "gzip,deflate";
-    }
-}
+}
\ No newline at end of file
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncProviderPipelineTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyAsyncProviderPipelineTest.java
similarity index 82%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncProviderPipelineTest.java
rename to providers/netty4/src/test/java/org/asynchttpclient/netty/NettyAsyncProviderPipelineTest.java
index 259d93db8..f6b28b1e6 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyAsyncProviderPipelineTest.java
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyAsyncProviderPipelineTest.java
@@ -11,23 +11,24 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty;
 
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.fail;
 
+import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.Request;
 import org.asynchttpclient.RequestBuilder;
 import org.asynchttpclient.Response;
-import org.asynchttpclient.async.AbstractBasicTest;
-import org.asynchttpclient.providers.netty.NettyAsyncHttpProviderConfig.AdditionalChannelInitializer;
+import org.asynchttpclient.netty.NettyAsyncHttpProviderConfig;
+import org.asynchttpclient.netty.NettyAsyncHttpProviderConfig.AdditionalPipelineInitializer;
 import org.testng.annotations.Test;
 
-import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.ChannelPipeline;
 import io.netty.handler.codec.http.HttpMessage;
 
 import java.util.concurrent.CountDownLatch;
@@ -44,16 +45,14 @@ public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
     public void asyncPipelineTest() throws Exception {
 
         NettyAsyncHttpProviderConfig nettyConfig = new NettyAsyncHttpProviderConfig();
-        nettyConfig.setHttpAdditionalChannelInitializer(new AdditionalChannelInitializer() {
-            public void initChannel(Channel ch) throws Exception {
-                // super.initPlainChannel(ch);
-                ch.pipeline().addBefore("inflater", "copyEncodingHeader", new CopyEncodingHandler());
+        nettyConfig.setHttpAdditionalPipelineInitializer(new AdditionalPipelineInitializer() {
+            public void initPipeline(ChannelPipeline pipeline) throws Exception {
+                pipeline.addBefore("inflater", "copyEncodingHeader", new CopyEncodingHandler());
             }
         });
-        AsyncHttpClient p = getAsyncHttpClient(new AsyncHttpClientConfig.Builder()
-                .setAsyncHttpClientProviderConfig(nettyConfig).build());
 
-        try {
+        try (AsyncHttpClient p = getAsyncHttpClient(new AsyncHttpClientConfig.Builder()
+                .setAsyncHttpClientProviderConfig(nettyConfig).build())) {
             final CountDownLatch l = new CountDownLatch(1);
             Request request = new RequestBuilder("GET").setUrl(getTargetUrl()).build();
             p.executeRequest(request, new AsyncCompletionHandlerAdapter() {
@@ -71,8 +70,6 @@ public Response onCompleted(Response response) throws Exception {
             if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
                 fail("Timeout out");
             }
-        } finally {
-            p.close();
         }
     }
 
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyAsyncResponseTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyAsyncResponseTest.java
new file mode 100644
index 000000000..dbc49ca17
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyAsyncResponseTest.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+
+package org.asynchttpclient.netty;
+
+import static org.testng.Assert.*;
+
+import org.asynchttpclient.FluentCaseInsensitiveStringsMap;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.cookie.Cookie;
+import org.testng.annotations.Test;
+
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.List;
+import java.util.Locale;
+import java.util.TimeZone;
+
+/**
+ * @author Benjamin Hanzelmann
+ */
+public class NettyAsyncResponseTest {
+
+    @Test(groups = "standalone")
+    public void testCookieParseExpires() {
+        // e.g. "Sun, 06-Feb-2012 03:45:24 GMT";
+        SimpleDateFormat sdf = new SimpleDateFormat("EEE, dd-MMM-yyyy HH:mm:ss z", Locale.US);
+        sdf.setTimeZone(TimeZone.getTimeZone("GMT"));
+
+        Date date = new Date(System.currentTimeMillis() + 60000);
+        final String cookieDef = String.format("efmembercheck=true; expires=%s; path=/; domain=.eclipse.org", sdf.format(date));
+
+        NettyResponse response = new NettyResponse(new NettyResponseStatus(null, null, null, null), new HttpResponseHeaders() {
+            @Override
+            public FluentCaseInsensitiveStringsMap getHeaders() {
+                return new FluentCaseInsensitiveStringsMap().add("Set-Cookie", cookieDef);
+            }
+        }, null);
+
+        List<Cookie> cookies = response.getCookies();
+        assertEquals(cookies.size(), 1);
+
+        Cookie cookie = cookies.get(0);
+        assertTrue(cookie.getMaxAge() >= 58 && cookie.getMaxAge() <= 60);
+    }
+
+    @Test(groups = "standalone")
+    public void testCookieParseMaxAge() {
+        final String cookieDef = "efmembercheck=true; max-age=60; path=/; domain=.eclipse.org";
+        NettyResponse response = new NettyResponse(new NettyResponseStatus(null, null, null, null), new HttpResponseHeaders() {
+            @Override
+            public FluentCaseInsensitiveStringsMap getHeaders() {
+                return new FluentCaseInsensitiveStringsMap().add("Set-Cookie", cookieDef);
+            }
+        }, null);
+        List<Cookie> cookies = response.getCookies();
+        assertEquals(cookies.size(), 1);
+
+        Cookie cookie = cookies.get(0);
+        assertEquals(cookie.getMaxAge(), 60);
+    }
+
+    @Test(groups = "standalone")
+    public void testCookieParseWeirdExpiresValue() {
+        final String cookieDef = "efmembercheck=true; expires=60; path=/; domain=.eclipse.org";
+        NettyResponse response = new NettyResponse(new NettyResponseStatus(null, null, null, null), new HttpResponseHeaders() {
+            @Override
+            public FluentCaseInsensitiveStringsMap getHeaders() {
+                return new FluentCaseInsensitiveStringsMap().add("Set-Cookie", cookieDef);
+            }
+        }, null);
+
+        List<Cookie> cookies = response.getCookies();
+        assertEquals(cookies.size(), 1);
+
+        Cookie cookie = cookies.get(0);
+        assertEquals(cookie.getMaxAge(), Long.MIN_VALUE);
+    }
+
+}
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyAsyncStreamHandlerTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyAsyncStreamHandlerTest.java
new file mode 100644
index 000000000..e03efb1f4
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyAsyncStreamHandlerTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.AsyncStreamHandlerTest;
+
+public class NettyAsyncStreamHandlerTest extends AsyncStreamHandlerTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyAsyncStreamLifecycleTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyAsyncStreamLifecycleTest.java
new file mode 100644
index 000000000..c66e9d250
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyAsyncStreamLifecycleTest.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.AsyncStreamLifecycleTest;
+
+public class NettyAsyncStreamLifecycleTest extends AsyncStreamLifecycleTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyAuthTimeoutTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyAuthTimeoutTest.java
new file mode 100644
index 000000000..89e25b215
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyAuthTimeoutTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.AuthTimeoutTest;
+
+public class NettyAuthTimeoutTest extends AuthTimeoutTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyBasicAuthTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyBasicAuthTest.java
new file mode 100644
index 000000000..0b9db54af
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyBasicAuthTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.BasicAuthTest;
+
+public class NettyBasicAuthTest extends BasicAuthTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyBasicHttpsTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyBasicHttpsTest.java
new file mode 100644
index 000000000..9fe45ee2b
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyBasicHttpsTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.BasicHttpsTest;
+
+public class NettyBasicHttpsTest extends BasicHttpsTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
\ No newline at end of file
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyBodyDeferringAsyncHandlerTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyBodyDeferringAsyncHandlerTest.java
similarity index 90%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyBodyDeferringAsyncHandlerTest.java
rename to providers/netty4/src/test/java/org/asynchttpclient/netty/NettyBodyDeferringAsyncHandlerTest.java
index 01e8daba4..b9ab2b6d0 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyBodyDeferringAsyncHandlerTest.java
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyBodyDeferringAsyncHandlerTest.java
@@ -10,11 +10,11 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.BodyDeferringAsyncHandlerTest;
+import org.asynchttpclient.handler.BodyDeferringAsyncHandlerTest;
 
 public class NettyBodyDeferringAsyncHandlerTest extends BodyDeferringAsyncHandlerTest {
 
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyByteBufferCapacityTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyByteBufferCapacityTest.java
new file mode 100644
index 000000000..e38a63e1e
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyByteBufferCapacityTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.ByteBufferCapacityTest;
+
+public class NettyByteBufferCapacityTest extends ByteBufferCapacityTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyComplexClientTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyComplexClientTest.java
new file mode 100644
index 000000000..d055f9131
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyComplexClientTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.ComplexClientTest;
+
+public class NettyComplexClientTest extends ComplexClientTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyConnectionPoolTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyConnectionPoolTest.java
similarity index 76%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyConnectionPoolTest.java
rename to providers/netty4/src/test/java/org/asynchttpclient/netty/NettyConnectionPoolTest.java
index aad2b47ca..d53f39def 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyConnectionPoolTest.java
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyConnectionPoolTest.java
@@ -6,27 +6,29 @@
  * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the Apache License Version 2.0
  * for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty;
 
-import static org.asynchttpclient.async.util.TestUtils.findFreePort;
+import static org.asynchttpclient.test.TestUtils.findFreePort;
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertNotNull;
 import static org.testng.Assert.assertNull;
 import static org.testng.Assert.assertTrue;
 import static org.testng.Assert.fail;
-import io.netty.channel.Channel;
-
-import java.net.ConnectException;
-import java.util.concurrent.TimeUnit;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.Response;
-import org.asynchttpclient.async.ConnectionPoolTest;
-import org.asynchttpclient.providers.netty.channel.pool.ChannelPool;
-import org.asynchttpclient.providers.netty.channel.pool.NoopChannelPool;
+import org.asynchttpclient.channel.pool.ConnectionPoolTest;
+import org.asynchttpclient.netty.NettyAsyncHttpProviderConfig;
+import org.asynchttpclient.netty.channel.pool.ChannelPool;
+import org.asynchttpclient.netty.channel.pool.NoopChannelPool;
 import org.testng.annotations.Test;
 
+import java.net.ConnectException;
+import java.util.concurrent.TimeUnit;
+
+import io.netty.channel.Channel;
+
 public class NettyConnectionPoolTest extends ConnectionPoolTest {
 
     @Override
@@ -39,7 +41,7 @@ public void testInvalidConnectionsPool() {
         ChannelPool cp = new NoopChannelPool() {
 
             @Override
-            public boolean offer(Channel connection, String poolKey) {
+            public boolean offer(Channel connection, Object partitionKey) {
                 return false;
             }
 
@@ -51,9 +53,8 @@ public boolean isOpen() {
 
         NettyAsyncHttpProviderConfig providerConfig = new NettyAsyncHttpProviderConfig();
         providerConfig.setChannelPool(cp);
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setAsyncHttpClientProviderConfig(providerConfig)
-                .build());
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setAsyncHttpClientProviderConfig(providerConfig)
+                .build())) {
             Exception exception = null;
             try {
                 client.prepareGet(getTargetUrl()).execute().get(TIMEOUT, TimeUnit.SECONDS);
@@ -62,9 +63,8 @@ public boolean isOpen() {
                 exception = ex;
             }
             assertNotNull(exception);
-            assertEquals(exception.getMessage(), "Too many connections -1");
-        } finally {
-            client.close();
+            assertNotNull(exception.getCause());
+            assertEquals(exception.getCause().getMessage(), "Pool is already closed");
         }
     }
 
@@ -73,16 +73,15 @@ public void testValidConnectionsPool() {
         ChannelPool cp = new NoopChannelPool() {
 
             @Override
-            public boolean offer(Channel connection, String poolKey) {
+            public boolean offer(Channel connection, Object partitionKey) {
                 return true;
             }
         };
 
         NettyAsyncHttpProviderConfig providerConfig = new NettyAsyncHttpProviderConfig();
         providerConfig.setChannelPool(cp);
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setAsyncHttpClientProviderConfig(providerConfig)
-                .build());
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setAsyncHttpClientProviderConfig(providerConfig)
+                .build())) {
             Exception exception = null;
             try {
                 client.prepareGet(getTargetUrl()).execute().get(TIMEOUT, TimeUnit.SECONDS);
@@ -91,16 +90,13 @@ public boolean offer(Channel connection, String poolKey) {
                 exception = ex;
             }
             assertNull(exception);
-        } finally {
-            client.close();
         }
     }
 
     @Test
     public void testHostNotContactable() {
-        AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build());
 
-        try {
+        try (AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().build())) {
             String url = null;
             try {
                 url = "http://127.0.0.1:" + findFreePort();
@@ -120,8 +116,6 @@ public void testHostNotContactable() {
                     assertTrue(cause instanceof ConnectException);
                 }
             }
-        } finally {
-            client.close();
         }
     }
 }
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyDigestAuthTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyDigestAuthTest.java
new file mode 100644
index 000000000..cc48a025c
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyDigestAuthTest.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.DigestAuthTest;
+
+public class NettyDigestAuthTest extends DigestAuthTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyErrorResponseTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyErrorResponseTest.java
new file mode 100644
index 000000000..b8a899ce4
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyErrorResponseTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.ErrorResponseTest;
+
+public class NettyErrorResponseTest extends ErrorResponseTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyExpect100ContinueTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyExpect100ContinueTest.java
new file mode 100644
index 000000000..6a5a6ce8f
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyExpect100ContinueTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Expect100ContinueTest;
+
+public class NettyExpect100ContinueTest extends Expect100ContinueTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyFollowingThreadTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyFollowingThreadTest.java
new file mode 100644
index 000000000..43d6707fc
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyFollowingThreadTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.FollowingThreadTest;
+
+public class NettyFollowingThreadTest extends FollowingThreadTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+
+}
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyHead302Test.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyHead302Test.java
new file mode 100644
index 000000000..43f5a0f6d
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyHead302Test.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Head302Test;
+
+public class NettyHead302Test extends Head302Test {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyHttpToHttpsRedirectTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyHttpToHttpsRedirectTest.java
new file mode 100644
index 000000000..8f3d54d8c
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyHttpToHttpsRedirectTest.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.HttpToHttpsRedirectTest;
+
+public class NettyHttpToHttpsRedirectTest extends HttpToHttpsRedirectTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyIdleStateHandlerTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyIdleStateHandlerTest.java
new file mode 100644
index 000000000..590eadb39
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyIdleStateHandlerTest.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.IdleStateHandlerTest;
+
+public class NettyIdleStateHandlerTest extends IdleStateHandlerTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyMultipleHeaderTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyMultipleHeaderTest.java
new file mode 100644
index 000000000..cad2dcbde
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyMultipleHeaderTest.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.MultipleHeaderTest;
+
+public class NettyMultipleHeaderTest extends MultipleHeaderTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyNoNullResponseTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyNoNullResponseTest.java
new file mode 100644
index 000000000..4e133dd51
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyNoNullResponseTest.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.NoNullResponseTest;
+
+public class NettyNoNullResponseTest extends NoNullResponseTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyNonAsciiContentLengthTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyNonAsciiContentLengthTest.java
new file mode 100644
index 000000000..193ccec42
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyNonAsciiContentLengthTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.NonAsciiContentLengthTest;
+
+public class NettyNonAsciiContentLengthTest extends NonAsciiContentLengthTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyParamEncodingTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyParamEncodingTest.java
new file mode 100644
index 000000000..0315db8cd
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyParamEncodingTest.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.ParamEncodingTest;
+
+public class NettyParamEncodingTest extends ParamEncodingTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyPerRequestRelative302Test.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyPerRequestRelative302Test.java
new file mode 100644
index 000000000..23ef73899
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyPerRequestRelative302Test.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.PerRequestRelative302Test;
+
+public class NettyPerRequestRelative302Test extends PerRequestRelative302Test {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyPerRequestTimeoutTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyPerRequestTimeoutTest.java
new file mode 100644
index 000000000..41b8f1bbf
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyPerRequestTimeoutTest.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+import static org.testng.Assert.assertTrue;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.PerRequestTimeoutTest;
+
+public class NettyPerRequestTimeoutTest extends PerRequestTimeoutTest {
+
+    @Override
+    protected void checkTimeoutMessage(String message) {
+        assertTrue(message.startsWith("Request timed out"), "error message indicates reason of error");
+        assertTrue(message.contains("127.0.0.1"), "error message contains remote ip address");
+        assertTrue(message.contains("of 100 ms"), "error message contains timeout configuration value");
+    }
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyProxyTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyPostRedirectGetTest.java
similarity index 81%
rename from providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyProxyTest.java
rename to providers/netty4/src/test/java/org/asynchttpclient/netty/NettyPostRedirectGetTest.java
index f3e1deab4..18fd29e3c 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyProxyTest.java
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyPostRedirectGetTest.java
@@ -11,16 +11,17 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package org.asynchttpclient.providers.grizzly;
+package org.asynchttpclient.netty;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.ProxyTest;
+import org.asynchttpclient.PostRedirectGetTest;
 
-public class GrizzlyProxyTest extends ProxyTest {
+public class NettyPostRedirectGetTest extends PostRedirectGetTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
+
 }
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyPostWithQSTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyPostWithQSTest.java
new file mode 100644
index 000000000..d7bc0eaf7
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyPostWithQSTest.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.PostWithQSTest;
+
+public class NettyPostWithQSTest extends PostWithQSTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyProviderUtil.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyProviderUtil.java
similarity index 75%
rename from providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyProviderUtil.java
rename to providers/netty4/src/test/java/org/asynchttpclient/netty/NettyProviderUtil.java
index 501eb0ff7..d889242c5 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyProviderUtil.java
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyProviderUtil.java
@@ -13,18 +13,19 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package org.asynchttpclient.providers.grizzly;
+package org.asynchttpclient.netty;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.DefaultAsyncHttpClient;
+import org.asynchttpclient.netty.NettyAsyncHttpProvider;
 
-public class GrizzlyProviderUtil {
+public class NettyProviderUtil {
 
-    public static AsyncHttpClient grizzlyProvider(AsyncHttpClientConfig config) {
+    public static AsyncHttpClient nettyProvider(AsyncHttpClientConfig config) {
         if (config == null) {
             config = new AsyncHttpClientConfig.Builder().build();
         }
-        return new DefaultAsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);
+        return new DefaultAsyncHttpClient(new NettyAsyncHttpProvider(config), config);
     }
 }
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyQueryParametersTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyQueryParametersTest.java
new file mode 100644
index 000000000..77a63d4d0
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyQueryParametersTest.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.QueryParametersTest;
+
+public class NettyQueryParametersTest extends QueryParametersTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyRC10KTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyRC10KTest.java
new file mode 100644
index 000000000..276d21f7f
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyRC10KTest.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.RC10KTest;
+
+public class NettyRC10KTest extends RC10KTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyRedirectBodyTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyRedirectBodyTest.java
new file mode 100644
index 000000000..ed2299b02
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyRedirectBodyTest.java
@@ -0,0 +1,15 @@
+package org.asynchttpclient.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.RedirectBodyTest;
+import org.testng.annotations.Test;
+
+@Test
+public class NettyRedirectBodyTest extends RedirectBodyTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyRedirectConnectionUsageTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyRedirectConnectionUsageTest.java
new file mode 100644
index 000000000..f7f384671
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyRedirectConnectionUsageTest.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.RedirectConnectionUsageTest;
+
+public class NettyRedirectConnectionUsageTest extends RedirectConnectionUsageTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyRelative302Test.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyRelative302Test.java
new file mode 100644
index 000000000..5bc48614f
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyRelative302Test.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Relative302Test;
+
+public class NettyRelative302Test extends Relative302Test {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyRemoteSiteTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyRemoteSiteTest.java
new file mode 100644
index 000000000..f15c32256
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyRemoteSiteTest.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package org.asynchttpclient.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.RemoteSiteTest;
+
+public class NettyRemoteSiteTest extends RemoteSiteTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+
+}
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyRequestThrottleTimeoutTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyRequestThrottleTimeoutTest.java
new file mode 100644
index 000000000..e73980600
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyRequestThrottleTimeoutTest.java
@@ -0,0 +1,143 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
+
+import org.asynchttpclient.AbstractBasicTest;
+import org.asynchttpclient.AsyncCompletionHandler;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Response;
+import org.eclipse.jetty.continuation.Continuation;
+import org.eclipse.jetty.continuation.ContinuationSupport;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.Test;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Future;
+import java.util.concurrent.Semaphore;
+import java.util.concurrent.TimeUnit;
+
+public class NettyRequestThrottleTimeoutTest extends AbstractBasicTest {
+    private static final String MSG = "Enough is enough.";
+    private static final int SLEEPTIME_MS = 1000;
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+
+    @Override
+    public AbstractHandler configureHandler() throws Exception {
+        return new SlowHandler();
+    }
+
+    private class SlowHandler extends AbstractHandler {
+        public void handle(String target, Request baseRequest, HttpServletRequest request, final HttpServletResponse response)
+                throws IOException, ServletException {
+            response.setStatus(HttpServletResponse.SC_OK);
+            final Continuation continuation = ContinuationSupport.getContinuation(request);
+            continuation.suspend();
+            new Thread(new Runnable() {
+                public void run() {
+                    try {
+                        Thread.sleep(SLEEPTIME_MS);
+                        response.getOutputStream().print(MSG);
+                        response.getOutputStream().flush();
+                        continuation.complete();
+                    } catch (InterruptedException e) {
+                        logger.error(e.getMessage(), e);
+                    } catch (IOException e) {
+                        logger.error(e.getMessage(), e);
+                    }
+                }
+            }).start();
+            baseRequest.setHandled(true);
+        }
+    }
+
+    @Test(groups = { "standalone", "netty_provider" })
+    public void testRequestTimeout() throws IOException {
+        final Semaphore requestThrottle = new Semaphore(1);
+
+        int samples = 10;
+
+        try (AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setMaxConnections(1).build())) {
+            final CountDownLatch latch = new CountDownLatch(samples);
+            final List<Exception> tooManyConnections = Collections.synchronizedList(new ArrayList<Exception>(2));
+
+            for (int i = 0; i < samples; i++) {
+                new Thread(new Runnable() {
+
+                    public void run() {
+                        try {
+                            requestThrottle.acquire();
+                            Future<Response> responseFuture = null;
+                            try {
+                                responseFuture = client.prepareGet(getTargetUrl()).setRequestTimeout(SLEEPTIME_MS / 2)
+                                        .execute(new AsyncCompletionHandler<Response>() {
+
+                                            @Override
+                                            public Response onCompleted(Response response) throws Exception {
+                                                return response;
+                                            }
+
+                                            @Override
+                                            public void onThrowable(Throwable t) {
+                                                logger.error("onThrowable got an error", t);
+                                                try {
+                                                    Thread.sleep(100);
+                                                } catch (InterruptedException e) {
+                                                }
+                                                requestThrottle.release();
+                                            }
+                                        });
+                            } catch (Exception e) {
+                                tooManyConnections.add(e);
+                            }
+
+                            if (responseFuture != null)
+                                responseFuture.get();
+                        } catch (Exception e) {
+                        } finally {
+                            latch.countDown();
+                        }
+
+                    }
+                }).start();
+            }
+
+            try {
+                latch.await(30, TimeUnit.SECONDS);
+            } catch (Exception e) {
+                fail("failed to wait for requests to complete");
+            }
+
+            for (Exception e : tooManyConnections)
+                logger.error("Exception while calling execute", e);
+
+            assertTrue(tooManyConnections.isEmpty(), "Should not have any connection errors where too many connections have been attempted");
+        }
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRetryRequestTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyRetryRequestTest.java
similarity index 90%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRetryRequestTest.java
rename to providers/netty4/src/test/java/org/asynchttpclient/netty/NettyRetryRequestTest.java
index 8ea77a62f..e734a19df 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyRetryRequestTest.java
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyRetryRequestTest.java
@@ -14,11 +14,11 @@
  * under the License.
  */
 
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.RetryRequestTest;
+import org.asynchttpclient.RetryRequestTest;
 
 public class NettyRetryRequestTest extends RetryRequestTest {
     @Override
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyThreadNameTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyThreadNameTest.java
new file mode 100644
index 000000000..13cf240c7
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/NettyThreadNameTest.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.ThreadNameTest;
+
+/**
+ * @author Stepan Koltsov
+ */
+public class NettyThreadNameTest extends ThreadNameTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/RetryNonBlockingIssue.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/RetryNonBlockingIssue.java
new file mode 100644
index 000000000..bc1e2a1fd
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/RetryNonBlockingIssue.java
@@ -0,0 +1,216 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+import static org.asynchttpclient.test.TestUtils.findFreePort;
+import static org.asynchttpclient.test.TestUtils.newJettyHttpServer;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
+
+import org.asynchttpclient.AbstractBasicTest;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.ListenableFuture;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.Response;
+import org.eclipse.jetty.servlet.ServletContextHandler;
+import org.eclipse.jetty.servlet.ServletHolder;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.UUID;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ExecutionException;
+
+//FIXME there's no retry actually
+public class RetryNonBlockingIssue extends AbstractBasicTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+
+    @BeforeClass(alwaysRun = true)
+    public void setUpGlobal() throws Exception {
+        port1 = findFreePort();
+        server = newJettyHttpServer(port1);
+
+        ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);
+        context.setContextPath("/");
+        context.addServlet(new ServletHolder(new MockExceptionServlet()), "/*");
+
+        server.setHandler(context);
+        server.start();
+    }
+
+    protected String getTargetUrl() {
+        return String.format("http://127.0.0.1:%d/", port1);
+    }
+
+    private ListenableFuture<Response> testMethodRequest(AsyncHttpClient client, int requests, String action, String id) throws IOException {
+        Request r = new RequestBuilder("GET")//
+                .setUrl(getTargetUrl())//
+                .addQueryParam(action, "1")//
+                .addQueryParam("maxRequests", "" + requests)//
+                .addQueryParam("id", id)//
+                .build();
+        return client.executeRequest(r);
+    }
+
+    /**
+     * Tests that a head request can be made
+     * 
+     * @throws IOException
+     * @throws ExecutionException
+     * @throws InterruptedException
+     */
+    @Test
+    public void testRetryNonBlocking() throws IOException, InterruptedException, ExecutionException {
+
+        AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder()//
+                .setAllowPoolingConnections(true)//
+                .setMaxConnections(100)//
+                .setConnectTimeout(60000)//
+                .setRequestTimeout(30000)//
+                .build();
+
+        try (AsyncHttpClient client = getAsyncHttpClient(config)) {
+            List<ListenableFuture<Response>> res = new ArrayList<>();
+            for (int i = 0; i < 32; i++) {
+                res.add(testMethodRequest(client, 3, "servlet", UUID.randomUUID().toString()));
+            }
+
+            StringBuilder b = new StringBuilder();
+            for (ListenableFuture<Response> r : res) {
+                Response theres = r.get();
+                assertEquals(200, theres.getStatusCode());
+                b.append("==============\r\n");
+                b.append("Response Headers\r\n");
+                Map<String, List<String>> heads = theres.getHeaders();
+                b.append(heads + "\r\n");
+                b.append("==============\r\n");
+                assertTrue(heads.size() > 0);
+            }
+            System.out.println(b.toString());
+            System.out.flush();
+        }
+    }
+
+    @Test
+    public void testRetryNonBlockingAsyncConnect() throws IOException, InterruptedException, ExecutionException {
+
+        AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder()//
+                .setAllowPoolingConnections(true)//
+                .setMaxConnections(100)//
+                .setConnectTimeout(60000)//
+                .setRequestTimeout(30000)//
+                .build();
+
+        try (AsyncHttpClient client = getAsyncHttpClient(config)) {
+            List<ListenableFuture<Response>> res = new ArrayList<>();
+            for (int i = 0; i < 32; i++) {
+                res.add(testMethodRequest(client, 3, "servlet", UUID.randomUUID().toString()));
+            }
+
+            StringBuilder b = new StringBuilder();
+            for (ListenableFuture<Response> r : res) {
+                Response theres = r.get();
+                assertEquals(theres.getStatusCode(), 200);
+                b.append("==============\r\n");
+                b.append("Response Headers\r\n");
+                Map<String, List<String>> heads = theres.getHeaders();
+                b.append(heads + "\r\n");
+                b.append("==============\r\n");
+                assertTrue(heads.size() > 0);
+            }
+            System.out.println(b.toString());
+            System.out.flush();
+        }
+    }
+
+    @SuppressWarnings("serial")
+    public class MockExceptionServlet extends HttpServlet {
+
+        private Map<String, Integer> requests = new ConcurrentHashMap<>();
+
+        private synchronized int increment(String id) {
+            int val = 0;
+            if (requests.containsKey(id)) {
+                Integer i = requests.get(id);
+                val = i + 1;
+                requests.put(id, val);
+            } else {
+                requests.put(id, 1);
+                val = 1;
+            }
+            System.out.println("REQUESTS: " + requests);
+            return val;
+        }
+
+        public void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
+            String maxRequests = req.getParameter("maxRequests");
+            int max = 0;
+            try {
+                max = Integer.parseInt(maxRequests);
+            } catch (NumberFormatException e) {
+                max = 3;
+            }
+            String id = req.getParameter("id");
+            int requestNo = increment(id);
+            String servlet = req.getParameter("servlet");
+            String io = req.getParameter("io");
+            String error = req.getParameter("500");
+
+            if (requestNo >= max) {
+                res.setHeader("Success-On-Attempt", "" + requestNo);
+                res.setHeader("id", id);
+                if (servlet != null && servlet.trim().length() > 0)
+                    res.setHeader("type", "servlet");
+                if (error != null && error.trim().length() > 0)
+                    res.setHeader("type", "500");
+                if (io != null && io.trim().length() > 0)
+                    res.setHeader("type", "io");
+                res.setStatus(200);
+                res.setContentLength(0);
+                res.flushBuffer();
+                return;
+            }
+
+            res.setStatus(200);
+            res.setContentLength(100);
+            res.setContentType("application/octet-stream");
+            res.flushBuffer();
+
+            // error after flushing the status
+            if (servlet != null && servlet.trim().length() > 0)
+                throw new ServletException("Servlet Exception");
+
+            if (io != null && io.trim().length() > 0)
+                throw new IOException("IO Exception");
+
+            if (error != null && error.trim().length() > 0) {
+                res.sendError(500, "servlet process was 500");
+            }
+        }
+    }
+}
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/channel/NettyMaxConnectionsInThreads.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/channel/NettyMaxConnectionsInThreads.java
new file mode 100644
index 000000000..55a1da687
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/channel/NettyMaxConnectionsInThreads.java
@@ -0,0 +1,24 @@
+/*******************************************************************************
+ * Copyright (c) 2010-2012 Sonatype, Inc.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * and Apache License v2.0 which accompanies this distribution.
+ * The Eclipse Public License is available at
+ *   http://www.eclipse.org/legal/epl-v10.html
+ * The Apache License v2.0 is available at
+ *   http://www.apache.org/licenses/LICENSE-2.0.html
+ * You may elect to redistribute this code under either of these licenses.
+ *******************************************************************************/
+package org.asynchttpclient.netty.channel;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.channel.MaxConnectionsInThreads;
+import org.asynchttpclient.netty.NettyProviderUtil;
+
+public class NettyMaxConnectionsInThreads extends MaxConnectionsInThreads {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/channel/NettyMaxTotalConnectionTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/channel/NettyMaxTotalConnectionTest.java
new file mode 100644
index 000000000..e8faf3990
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/channel/NettyMaxTotalConnectionTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.channel;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.channel.MaxTotalConnectionTest;
+import org.asynchttpclient.netty.NettyProviderUtil;
+
+public class NettyMaxTotalConnectionTest extends MaxTotalConnectionTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/filter/NettyFilterTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/filter/NettyFilterTest.java
new file mode 100644
index 000000000..a1854eea1
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/filter/NettyFilterTest.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.filter;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.filter.FilterTest;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.testng.annotations.Test;
+
+@Test
+public class NettyFilterTest extends FilterTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyHostnameVerifierTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/handler/NettyListenableFutureTest.java
similarity index 82%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyHostnameVerifierTest.java
rename to providers/netty4/src/test/java/org/asynchttpclient/netty/handler/NettyListenableFutureTest.java
index 004a2eb43..94ebd845e 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyHostnameVerifierTest.java
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/handler/NettyListenableFutureTest.java
@@ -10,16 +10,18 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty.handler;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.HostnameVerifierTest;
+import org.asynchttpclient.ListenableFutureTest;
+import org.asynchttpclient.netty.NettyProviderUtil;
 
-public class NettyHostnameVerifierTest extends HostnameVerifierTest {
+public class NettyListenableFutureTest extends ListenableFutureTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return NettyProviderUtil.nettyProvider(config);
     }
+
 }
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/ntlm/NettyNtlmTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/ntlm/NettyNtlmTest.java
new file mode 100644
index 000000000..48a97d0e3
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/ntlm/NettyNtlmTest.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.ntlm;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.ntlm.NtlmTest;
+import org.testng.annotations.Test;
+
+@Test
+public class NettyNtlmTest extends NtlmTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/proxy/NettyProxyTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/proxy/NettyProxyTest.java
new file mode 100644
index 000000000..43c37e567
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/proxy/NettyProxyTest.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.proxy;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.proxy.ProxyTest;
+
+public class NettyProxyTest extends ProxyTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+
+}
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/proxy/NettyProxyTunnellingTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/proxy/NettyProxyTunnellingTest.java
new file mode 100644
index 000000000..1086a91b6
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/proxy/NettyProxyTunnellingTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.proxy;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.proxy.ProxyTunnellingTest;
+
+public class NettyProxyTunnellingTest extends ProxyTunnellingTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/reactivestreams/NettyReactiveStreamsTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/reactivestreams/NettyReactiveStreamsTest.java
new file mode 100644
index 000000000..3a53ce328
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/reactivestreams/NettyReactiveStreamsTest.java
@@ -0,0 +1,157 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.reactivestreams;
+
+import static org.asynchttpclient.test.TestUtils.LARGE_IMAGE_BYTES;
+import static org.testng.Assert.assertTrue;
+
+import java.net.InetAddress;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.handler.AsyncHandlerExtensions;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.netty.handler.StreamedResponsePublisher;
+import org.asynchttpclient.reactivestreams.ReactiveStreamsTest;
+import org.reactivestreams.Publisher;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.testng.annotations.Test;
+
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelFutureListener;
+
+import java.lang.reflect.*;
+
+public class NettyReactiveStreamsTest extends ReactiveStreamsTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+
+
+    @Test(groups = { "standalone", "default_provider" }, enabled = true)
+    public void testRetryingOnFailingStream() throws Exception {
+        try (AsyncHttpClient client = getAsyncHttpClient(null)) {
+            final CountDownLatch streamStarted = new CountDownLatch(1); // allows us to wait until subscriber has received the first body chunk
+            final CountDownLatch streamOnHold = new CountDownLatch(1); // allows us to hold the subscriber from processing further body chunks
+            final CountDownLatch replayingRequest = new CountDownLatch(1); // allows us to block until the request is being replayed ( this is what we want to test here!)
+
+            // a ref to the publisher is needed to get a hold on the channel (if there is a better way, this should be changed) 
+            final AtomicReference<StreamedResponsePublisher> publisherRef = new AtomicReference<>(null);
+
+            // executing the request
+            client.preparePost(getTargetUrl())
+                    .setBody(LARGE_IMAGE_BYTES)
+                    .execute(new ReplayedSimpleAsyncHandler(replayingRequest,
+                            new BlockedStreamSubscriber(streamStarted, streamOnHold)) {
+                        @Override
+                        public State onStream(Publisher<HttpResponseBodyPart> publisher) {
+                            if(!(publisher instanceof StreamedResponsePublisher)) {
+                                throw new IllegalStateException(String.format("publisher %s is expected to be an instance of %s", publisher, StreamedResponsePublisher.class));
+                            }
+                            else if(!publisherRef.compareAndSet(null, (StreamedResponsePublisher) publisher)) {
+                                // abort on retry
+                                return State.ABORT;
+                            }
+                            return super.onStream(publisher);
+                        }
+                    });
+
+            // before proceeding, wait for the subscriber to receive at least one body chunk
+            streamStarted.await();
+            // The stream has started, hence `StreamedAsyncHandler.onStream(publisher)` was called, and `publisherRef` was initialized with the `publisher` passed to `onStream`
+            assertTrue(publisherRef.get() != null, "Expected a not null publisher.");
+
+            // close the channel to emulate a connection crash while the response body chunks were being received.
+            StreamedResponsePublisher publisher = publisherRef.get();
+            final CountDownLatch channelClosed = new CountDownLatch(1);
+
+            getChannel(publisher).close().addListener(new ChannelFutureListener() {
+                @Override
+                public void operationComplete(ChannelFuture future) throws Exception {
+                    channelClosed.countDown();
+                }
+            });
+            streamOnHold.countDown(); // the subscriber is set free to process new incoming body chunks.
+            channelClosed.await(); // the channel is confirmed to be closed
+
+            // now we expect a new connection to be created and AHC retry logic to kick-in automatically
+            replayingRequest.await(); // wait until we are notified the request is being replayed
+
+            // Change this if there is a better way of stating the test succeeded 
+            assertTrue(true);
+        }
+    }
+
+    private Channel getChannel(StreamedResponsePublisher publisher) throws Exception {
+        Field field = publisher.getClass().getDeclaredField("channel");
+        field.setAccessible(true);
+        return (Channel) field.get(publisher);
+    }
+
+    private static class BlockedStreamSubscriber extends SimpleSubscriber<HttpResponseBodyPart> {
+        private static final Logger LOGGER = LoggerFactory.getLogger(BlockedStreamSubscriber.class);
+        private final CountDownLatch streamStarted;
+        private final CountDownLatch streamOnHold;
+
+        public BlockedStreamSubscriber(CountDownLatch streamStarted, CountDownLatch streamOnHold) {
+            this.streamStarted = streamStarted;
+            this.streamOnHold = streamOnHold;
+        }
+
+        @Override
+        public void onNext(HttpResponseBodyPart t) {
+            streamStarted.countDown();
+            try {
+                streamOnHold.await();
+            } catch (InterruptedException e) {
+                LOGGER.error("`streamOnHold` latch was interrupted", e);
+            }
+            super.onNext(t);
+        }
+    }
+    
+    private static class ReplayedSimpleAsyncHandler extends SimpleStreamedAsyncHandler implements AsyncHandlerExtensions {
+        private final CountDownLatch replaying;
+        public ReplayedSimpleAsyncHandler(CountDownLatch replaying, SimpleSubscriber<HttpResponseBodyPart> subscriber) {
+            super(subscriber);
+            this.replaying = replaying;
+        }
+        @Override
+        public void onConnectionOpen() {}
+        @Override
+        public void onConnectionOpened(Object connection) {}
+        @Override
+        public void onConnectionPool() {}
+        @Override
+        public void onConnectionPooled(Object connection) {}
+        @Override
+        public void onConnectionOffer(Object connection) {}
+        @Override
+        public void onRequestSend(Object request) {}
+        @Override
+        public void onRetry() {
+            replaying.countDown();
+        }
+        @Override
+        public void onDnsResolved(InetAddress address) {}
+        @Override
+        public void onSslHandshakeCompleted() {}
+    }
+}
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/request/body/NettyBodyChunkTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/request/body/NettyBodyChunkTest.java
new file mode 100644
index 000000000..9a0f316d5
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/request/body/NettyBodyChunkTest.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.request.body;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.request.body.BodyChunkTest;
+
+public class NettyBodyChunkTest extends BodyChunkTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/request/body/NettyChunkingTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/request/body/NettyChunkingTest.java
new file mode 100644
index 000000000..02a756c96
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/request/body/NettyChunkingTest.java
@@ -0,0 +1,13 @@
+package org.asynchttpclient.netty.request.body;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.request.body.ChunkingTest;
+
+public class NettyChunkingTest extends ChunkingTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/request/body/NettyEmptyBodyTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/request/body/NettyEmptyBodyTest.java
new file mode 100644
index 000000000..52c846454
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/request/body/NettyEmptyBodyTest.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.request.body;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.request.body.EmptyBodyTest;
+
+public class NettyEmptyBodyTest extends EmptyBodyTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/request/body/NettyFastUnauthorizedUploadTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/request/body/NettyFastUnauthorizedUploadTest.java
new file mode 100644
index 000000000..9b6eae7ad
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/request/body/NettyFastUnauthorizedUploadTest.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.request.body;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.request.body.FastUnauthorizedUploadTest;
+import org.testng.annotations.Test;
+
+@Test
+public class NettyFastUnauthorizedUploadTest extends FastUnauthorizedUploadTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/request/body/NettyFilePartLargeFileTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/request/body/NettyFilePartLargeFileTest.java
new file mode 100644
index 000000000..6265c04e4
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/request/body/NettyFilePartLargeFileTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.request.body;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.request.body.FilePartLargeFileTest;
+
+public class NettyFilePartLargeFileTest extends FilePartLargeFileTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/request/body/NettyInputStreamTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/request/body/NettyInputStreamTest.java
new file mode 100644
index 000000000..075a935fe
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/request/body/NettyInputStreamTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.request.body;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.request.body.InputStreamTest;
+
+public class NettyInputStreamTest extends InputStreamTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/request/body/NettyPutLargeFileTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/request/body/NettyPutLargeFileTest.java
new file mode 100644
index 000000000..e1e3394da
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/request/body/NettyPutLargeFileTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.request.body;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.request.body.PutLargeFileTest;
+
+public class NettyPutLargeFileTest extends PutLargeFileTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/request/body/NettyReactiveStreamsTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/request/body/NettyReactiveStreamsTest.java
new file mode 100644
index 000000000..b79c56601
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/request/body/NettyReactiveStreamsTest.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.request.body;
+
+import static org.asynchttpclient.test.TestUtils.LARGE_IMAGE_BYTES;
+import static org.asynchttpclient.test.TestUtils.LARGE_IMAGE_PUBLISHER;
+import static org.testng.Assert.assertEquals;
+
+import java.nio.ByteBuffer;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.request.body.Body;
+import org.asynchttpclient.request.body.ReactiveStreamsTest;
+import org.asynchttpclient.request.body.generator.BodyGenerator;
+import org.asynchttpclient.request.body.generator.ReactiveStreamsBodyGenerator;
+import org.reactivestreams.Publisher;
+import org.testng.annotations.Test;
+
+public class NettyReactiveStreamsTest extends ReactiveStreamsTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+
+    @Test(groups = { "standalone" }, enabled = true)
+    public void testEagerPutImage() throws Exception { // this tests the `ReactiveStreamBodyGenerator.createBody` implementation
+        try (AsyncHttpClient client = getAsyncHttpClient(new AsyncHttpClientConfig.Builder().setRequestTimeout(100 * 6000).build())) {
+            BodyGenerator bodyGenerator = new GenericBodyGenerator(createBody(LARGE_IMAGE_PUBLISHER));
+            Response response = client.preparePut(getTargetUrl()).setBody(bodyGenerator).execute().get();
+            assertEquals(response.getStatusCode(), 200);
+            assertEquals(response.getResponseBodyAsBytes(), LARGE_IMAGE_BYTES);
+        }
+    }
+
+    public BodyGenerator createBody(Publisher<ByteBuffer> publisher) {
+        return new ReactiveStreamsBodyGenerator(publisher);
+    }
+
+    // Because NettyRequestFactory#body uses the type information to decide the type of body to create, this class allows to hide
+    // the type so that the generic `NettyBodyBody` is used.
+    // This is useful to test that the implementation of ReactiveStreamBodyGenerator#createBody works as expected.
+    private class GenericBodyGenerator implements BodyGenerator {
+
+        private final BodyGenerator bodyGenerator;
+
+        public GenericBodyGenerator(BodyGenerator bodyGenerator) {
+            this.bodyGenerator = bodyGenerator;
+        }
+
+        @Override
+        public Body createBody() {
+            return this.bodyGenerator.createBody();
+        }
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyTransferListenerTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/request/body/NettyTransferListenerTest.java
similarity index 86%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyTransferListenerTest.java
rename to providers/netty4/src/test/java/org/asynchttpclient/netty/request/body/NettyTransferListenerTest.java
index 504607b65..3c22546f8 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettyTransferListenerTest.java
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/request/body/NettyTransferListenerTest.java
@@ -10,11 +10,12 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty.request.body;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.TransferListenerTest;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.request.body.TransferListenerTest;
 
 public class NettyTransferListenerTest extends TransferListenerTest {
     @Override
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/request/body/NettyZeroCopyFileTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/request/body/NettyZeroCopyFileTest.java
new file mode 100644
index 000000000..6db5e3573
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/request/body/NettyZeroCopyFileTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.request.body;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.request.body.ZeroCopyFileTest;
+
+public class NettyZeroCopyFileTest extends ZeroCopyFileTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/request/body/multipart/NettyMultipartUploadTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/request/body/multipart/NettyMultipartUploadTest.java
new file mode 100644
index 000000000..2b2454b59
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/request/body/multipart/NettyMultipartUploadTest.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.request.body.multipart;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.request.body.multipart.MultipartUploadTest;
+
+/**
+ * @author dominict
+ */
+public class NettyMultipartUploadTest extends MultipartUploadTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettySimpleAsyncClientErrorBehaviourTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/simple/NettySimpleAsyncClientErrorBehaviourTest.java
similarity index 82%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettySimpleAsyncClientErrorBehaviourTest.java
rename to providers/netty4/src/test/java/org/asynchttpclient/netty/simple/NettySimpleAsyncClientErrorBehaviourTest.java
index c57b8b89d..0cb6b0bab 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/NettySimpleAsyncClientErrorBehaviourTest.java
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/simple/NettySimpleAsyncClientErrorBehaviourTest.java
@@ -11,11 +11,12 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package org.asynchttpclient.providers.netty;
+package org.asynchttpclient.netty.simple;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.SimpleAsyncClientErrorBehaviourTest;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.simple.SimpleAsyncClientErrorBehaviourTest;
 
 public class NettySimpleAsyncClientErrorBehaviourTest extends SimpleAsyncClientErrorBehaviourTest {
 
@@ -23,8 +24,4 @@
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return NettyProviderUtil.nettyProvider(config);
     }
-
-    public String getProviderClass() {
-        return NettyAsyncHttpProvider.class.getName();
-    }
 }
diff --git a/api/src/main/java/org/asynchttpclient/date/TimeConverter.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/simple/NettySimpleAsyncHttpClientTest.java
similarity index 71%
rename from api/src/main/java/org/asynchttpclient/date/TimeConverter.java
rename to providers/netty4/src/test/java/org/asynchttpclient/netty/simple/NettySimpleAsyncHttpClientTest.java
index 5b7cda67c..d6a2ee317 100644
--- a/api/src/main/java/org/asynchttpclient/date/TimeConverter.java
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/simple/NettySimpleAsyncHttpClientTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010-2014 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -10,14 +10,9 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.date;
+package org.asynchttpclient.netty.simple;
 
-/**
- * Converts a RFC2616Date to time in millis
- * 
- * @author slandelle
- */
-public interface TimeConverter {
+import org.asynchttpclient.simple.SimpleAsyncHttpClientTest;
 
-    long toTime(RFC2616Date dateElements);
+public class NettySimpleAsyncHttpClientTest extends SimpleAsyncHttpClientTest {
 }
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/webdav/NettyWebDavBasicTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/webdav/NettyWebDavBasicTest.java
new file mode 100644
index 000000000..d7512671f
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/webdav/NettyWebDavBasicTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.webdav;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.webdav.WebDavBasicTest;
+
+public class NettyWebDavBasicTest extends WebDavBasicTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/ws/NettyByteMessageTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/ws/NettyByteMessageTest.java
new file mode 100644
index 000000000..e93fcdf4a
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/ws/NettyByteMessageTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.ws;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.ws.ByteMessageTest;
+
+public class NettyByteMessageTest extends ByteMessageTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyCloseCodeReasonMsgTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/ws/NettyCloseCodeReasonMsgTest.java
similarity index 84%
rename from providers/netty/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyCloseCodeReasonMsgTest.java
rename to providers/netty4/src/test/java/org/asynchttpclient/netty/ws/NettyCloseCodeReasonMsgTest.java
index deec16902..3428a6a71 100644
--- a/providers/netty/src/test/java/org/asynchttpclient/providers/netty/websocket/NettyCloseCodeReasonMsgTest.java
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/ws/NettyCloseCodeReasonMsgTest.java
@@ -11,12 +11,12 @@
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 
-package org.asynchttpclient.providers.netty.websocket;
+package org.asynchttpclient.netty.ws;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.providers.netty.NettyProviderUtil;
-import org.asynchttpclient.websocket.CloseCodeReasonMessageTest;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.ws.CloseCodeReasonMessageTest;
 
 public class NettyCloseCodeReasonMsgTest extends CloseCodeReasonMessageTest {
 
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/ws/NettyProxyTunnellingTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/ws/NettyProxyTunnellingTest.java
new file mode 100644
index 000000000..b5749300a
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/ws/NettyProxyTunnellingTest.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.ws;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.ws.ProxyTunnellingTest;
+import org.testng.annotations.Test;
+
+@Test
+public class NettyProxyTunnellingTest extends ProxyTunnellingTest {
+
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyAuthTimeoutTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/ws/NettyRedirectTest.java
similarity index 78%
rename from providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyAuthTimeoutTest.java
rename to providers/netty4/src/test/java/org/asynchttpclient/netty/ws/NettyRedirectTest.java
index 32dd91806..8afa59393 100644
--- a/providers/grizzly/src/test/java/org/asynchttpclient/providers/grizzly/GrizzlyAuthTimeoutTest.java
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/ws/NettyRedirectTest.java
@@ -10,17 +10,17 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-
-package org.asynchttpclient.providers.grizzly;
+package org.asynchttpclient.netty.ws;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.async.AuthTimeoutTest;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.ws.RedirectTest;
 
-public class GrizzlyAuthTimeoutTest extends AuthTimeoutTest {
+public class NettyRedirectTest extends RedirectTest {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return GrizzlyProviderUtil.grizzlyProvider(config);
+        return NettyProviderUtil.nettyProvider(config);
     }
 }
diff --git a/providers/netty4/src/test/java/org/asynchttpclient/netty/ws/NettyTextMessageTest.java b/providers/netty4/src/test/java/org/asynchttpclient/netty/ws/NettyTextMessageTest.java
new file mode 100644
index 000000000..6c351283c
--- /dev/null
+++ b/providers/netty4/src/test/java/org/asynchttpclient/netty/ws/NettyTextMessageTest.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.ws;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.netty.NettyProviderUtil;
+import org.asynchttpclient.ws.TextMessageTest;
+
+public class NettyTextMessageTest extends TextMessageTest {
+    @Override
+    public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
+        return NettyProviderUtil.nettyProvider(config);
+    }
+}
diff --git a/providers/netty/src/test/resources/300k.png b/providers/netty4/src/test/resources/300k.png
similarity index 100%
rename from providers/netty/src/test/resources/300k.png
rename to providers/netty4/src/test/resources/300k.png
diff --git a/providers/netty/src/test/resources/SimpleTextFile.txt b/providers/netty4/src/test/resources/SimpleTextFile.txt
similarity index 100%
rename from providers/netty/src/test/resources/SimpleTextFile.txt
rename to providers/netty4/src/test/resources/SimpleTextFile.txt
diff --git a/providers/netty/src/test/resources/client.keystore b/providers/netty4/src/test/resources/client.keystore
similarity index 100%
rename from providers/netty/src/test/resources/client.keystore
rename to providers/netty4/src/test/resources/client.keystore
diff --git a/providers/netty/src/test/resources/gzip.txt.gz b/providers/netty4/src/test/resources/gzip.txt.gz
similarity index 100%
rename from providers/netty/src/test/resources/gzip.txt.gz
rename to providers/netty4/src/test/resources/gzip.txt.gz
diff --git a/providers/netty/src/test/resources/logback-test.xml b/providers/netty4/src/test/resources/logback-test.xml
similarity index 100%
rename from providers/netty/src/test/resources/logback-test.xml
rename to providers/netty4/src/test/resources/logback-test.xml
diff --git a/providers/netty/src/test/resources/realm.properties b/providers/netty4/src/test/resources/realm.properties
similarity index 100%
rename from providers/netty/src/test/resources/realm.properties
rename to providers/netty4/src/test/resources/realm.properties
diff --git a/providers/netty/src/test/resources/ssltest-cacerts.jks b/providers/netty4/src/test/resources/ssltest-cacerts.jks
similarity index 100%
rename from providers/netty/src/test/resources/ssltest-cacerts.jks
rename to providers/netty4/src/test/resources/ssltest-cacerts.jks
diff --git a/providers/netty/src/test/resources/ssltest-keystore.jks b/providers/netty4/src/test/resources/ssltest-keystore.jks
similarity index 100%
rename from providers/netty/src/test/resources/ssltest-keystore.jks
rename to providers/netty4/src/test/resources/ssltest-keystore.jks
diff --git a/providers/netty/src/test/resources/textfile.txt b/providers/netty4/src/test/resources/textfile.txt
similarity index 100%
rename from providers/netty/src/test/resources/textfile.txt
rename to providers/netty4/src/test/resources/textfile.txt
diff --git a/providers/netty/src/test/resources/textfile2.txt b/providers/netty4/src/test/resources/textfile2.txt
similarity index 100%
rename from providers/netty/src/test/resources/textfile2.txt
rename to providers/netty4/src/test/resources/textfile2.txt
diff --git a/providers/pom.xml b/providers/pom.xml
index 72af625a7..822983c23 100644
--- a/providers/pom.xml
+++ b/providers/pom.xml
@@ -1,6 +1,4 @@
-<project xmlns="http://maven.apache.org/POM/4.0.0"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
     <parent>
         <groupId>org.asynchttpclient</groupId>
         <artifactId>async-http-client-project</artifactId>
@@ -44,8 +42,8 @@
     </build>
 
     <modules>
-        <module>grizzly</module>
-        <module>netty</module>
+        <module>netty3</module>
+        <module>netty4</module>
     </modules>
 
     <dependencies>
diff --git a/site/pom.xml b/site/pom.xml
deleted file mode 100644
index b6e29bd13..000000000
--- a/site/pom.xml
+++ /dev/null
@@ -1,16 +0,0 @@
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-    <parent>
-        <groupId>org.asynchttpclient</groupId>
-        <artifactId>async-http-client-project</artifactId>
-        <version>2.0.0-SNAPSHOT</version>
-    </parent>
-    <modelVersion>4.0.0</modelVersion>
-    <groupId>org.asynchttpclient</groupId>
-    <artifactId>async-http-client-site</artifactId>
-    <name>Asynchronous Http Client Project Site</name>
-    <version>2.0.0-SNAPSHOT</version>
-    <packaging>pom</packaging>
-    <description>
-        The Async Http Client site.
-    </description>
-</project>
\ No newline at end of file
diff --git a/site/src/site/apt/auth.apt b/site/src/site/apt/auth.apt
deleted file mode 100644
index 567830b3a..000000000
--- a/site/src/site/apt/auth.apt
+++ /dev/null
@@ -1,39 +0,0 @@
-                                    ------
-                           Async Http Client - Configuring Authentication: BASIC, DIGEST or NTLM
-                                    ------
-                              Jeanfrancois Arcand
-                                    ------
-                                       2012
-
-Configuring Authentication: BASIC, DIGEST or NTLM
-
-  Configuring authentication with AsyncHttpClient is simple. You can configure it at the <<<Request>>> level using the
-  <<<RealmBuilder>>>:
-
-+-----+
-AsyncHttpClient client = new AsyncHttpClient();
-Realm realm = new Realm.RealmBuilder()
-                       .setPrincipal(user)
-                       .setPassword(admin)
-                       .setUsePreemptiveAuth(true)
-                       .setScheme(AuthScheme.BASIC)
-                       .build();
-client.prepareGet("http://...").setRealm(realm).execute();
-+-----+
-
-  You can also set the realm at the AsyncHttpClientConfig level:
-
-+-----+
-Builder builder = new AsyncHttpClientConfig.Builder();
-Realm realm = new Realm.RealmBuilder()
-                       .setPrincipal(user)
-                       .setPassword(admin)
-                       .setUsePreemptiveAuth(true)
-                       .setScheme(AuthScheme.BASIC)
-                       .build();
-builder.setRealm(realm).build();
-AsyncHttpClient client = new AsyncHttpClient(builder.build());
-+-----+
-
-  The authentication type supported are <<<BASIC>>>, <<<DIGEST>>> and <<<NTLM>>>. You can also customize your own
-  authentication mechanism by using the Response Filter.
diff --git a/site/src/site/apt/configuring.apt b/site/src/site/apt/configuring.apt
deleted file mode 100644
index 6eecccc88..000000000
--- a/site/src/site/apt/configuring.apt
+++ /dev/null
@@ -1,50 +0,0 @@
-                                    ------
-                           Async Http Client - Configuring the AsyncHttpClient
-                                    ------
-                              Jeanfrancois Arcand
-                                    ------
-                                       2012
-
-Configuring the AsyncHttpClient.
-
-  You can configure the <<<AsyncHttpClient>>> class using the <<<AsyncHttpClientConfig>>>'s Builder:
-
-+-----+
-Builder builder = new AsyncHttpClientConfig.Builder();
-builder.setCompressionEnabled(true)
-    .setAllowPoolingConnection(true)
-    .setRequestTimesout(30000)
-    .build();
-
-AsyncHttpClient client = new AsyncHttpClient(builder.build());
-+-----+
-
-  You can set the ExecutorServices as well if you don't want to use the default, which is a cached threads pool:
-
-+-----+
-Builder builder = new AsyncHttpClientConfig.Builder();
-builder.setExecutorService(myOwnThreadPool);
-AsyncHttpClient client = new AsyncHttpClient(builder.build());
-+-----+
-
-  You can also configure the connection pool the library is using and implement your own polling strategy:
-
-+-----+
-Builder builder = new AsyncHttpClientConfig.Builder();
-builder.setConnectionsPool(new ConnectionsPoo<U,V>() {
-    public boolean offer(U uri, V connection) {...}
-
-    public V poll(U uri) {...}
-
-    public boolean removeAll(V connection) {...}
-
-    public boolean canCacheConnection() {...}
-
-    public void destroy() {...}
-});
-AsyncHttpClient client = new AsyncHttpClient(builder.build());
-+-----+
-
-  It is recommended to use the default connections pool for performance reason, but you are always free to design a better one.
-
-  You can also set the SSL information, Filters, etc. Those topics will be covered inside their own section.
diff --git a/site/src/site/apt/filters.apt b/site/src/site/apt/filters.apt
deleted file mode 100644
index 797b071e1..000000000
--- a/site/src/site/apt/filters.apt
+++ /dev/null
@@ -1,151 +0,0 @@
-                                    ------
-                           Async Http Client - Using Filters
-                                    ------
-                              Jeanfrancois Arcand
-                                    ------
-                                       2012
-
-Using Filters
-
-  The library supports three types of <<<Filter>>> who can intercept, transform, decorate and replay transactions:
-  <<<Request>>>, <<<Response>>> and <<<IOException>>>.
-
-* Request Filter
-
-  Request Filters are useful if you need to manipulate the Request or AsyncHandler object before the request is made. As an example, you can throttle requests using the following RequestFilter implementation:
-
-+-----+
-public class ThrottleRequestFilter implements RequestFilter {
-    private final int maxConnections;
-    private final Semaphore available;
-    private final int maxWait;
-
-    public ThrottleRequestFilter(int maxConnections) {
-        this.maxConnections = maxConnections;
-        this.maxWait = Integer.MAX_VALUE;
-        available = new Semaphore(maxConnections, true);
-    }
-
-    public ThrottleRequestFilter(int maxConnections, int maxWait) {
-        this.maxConnections = maxConnections;
-        this.maxWait = maxWait;
-        available = new Semaphore(maxConnections, true);
-    }
-
-    public FilterContext filter(FilterContext ctx) throws FilterException {
-        try {
-            if (!available.tryAcquire(maxWait, TimeUnit.MILLISECONDS))
-                throw new FilterException(String.format("No slot available for Request %s with AsyncHandler %s",
-                                                        ctx.getRequest(),
-                                                        ctx.getAsyncHandler()));
-            }
-        } catch (InterruptedException e) {
-            throw new FilterException( String.format("Interrupted Request %s with AsyncHandler %s",
-                                                     ctx.getRequest(),
-                                                     ctx.getAsyncHandler()));
-        }
-
-        return new FilterContext(new AsyncHandlerWrapper(ctx.getAsyncHandler()), ctx.getRequest());
-    }
-
-}
-
-private class AsyncHandlerWrapper implements AsyncHandler<T> {
-    private final AsyncHandler asyncHandler;
-
-    public AsyncHandlerWrapper(AsyncHandler asyncHandler) {
-        this.asyncHandler = asyncHandler;
-    }
-
-    public void onThrowable(Throwable t) {
-        asyncHandler.onThrowable(t);
-    }
-
-    public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-        return asyncHandler.onBodyPartReceived(bodyPart);
-    }
-
-    public STATE onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
-        return asyncHandler.onStatusReceived(responseStatus);
-    }
-
-    public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
-        return asyncHandler.onHeadersReceived(headers); }
-
-    public T onCompleted() throws Exception {
-        available.release();
-        return asyncHandler.onCompleted();
-    }
-}
-+-----+
-
-  In the above, we decorate the original <<<AsyncHandler>>> and use semaphore to throttle requests.
-  To add <<<RequestFilter>>>, all you need to do is to configure it on the <<<AsyncHttpClientConfig>>>:
-
-+-----+
-AsyncHttpClientConfig.Builder b = new AsyncHttpClientConfig.Builder();
-b.addRequestFilter(new ThrottleRequestFilter(100));
-AsyncHttpClient c = new AsyncHttpClient(b.build());
-+-----+
-
- * Response Filter
-
-  Like with <<<Request>>>, you can also filter the <<<Response>>>'s bytes before an <<<AsyncHandler>>> gets called.
-  <<<Response Filters>>> are always invoked before the library executes the logic for authentication, proxy challenging,
-  redirection etc. That means an application can takes control of those operations at any moment using a <<<Response Filter>>>.
-
-  As an example, the following <<<Response Filter>>> redirect request from <<<google.ca>>> to <<<google.com>>> in case
-  <<<.ca>>> is not responding:
-
-+-----+
-AsyncHttpClientConfig.Builder b = new AsyncHttpClientConfig.Builder();
-b.addResponseFilter(new ResponseFilter() {
-    public FilterContext filter(FilterContext ctx) throws FilterException {
-        if (ctx.getResponseStatus().getStatusCode() == 503) {
-            return new FilterContext.FilterContextBuilder(ctx)
-                .request(new RequestBuilder("GET")
-                .setUrl("http://google.com").build())
-                .build();
-        }
-    }
-});
-AsyncHttpClient c = new AsyncHttpClient(b.build());
-+-----+
-
-* IOException Filter
-
-  The AsyncHttpClient library support <<<IOExceptionFilter>>> that can be used to replay a request in case server a
-  server goes down or unresponsive, a network outage occurs, or nay kind of I/O abnormal situation.
-
-  In those cases, the library will catch the <<<IOException>>> and delegate the <<<IOException>>> handling to the <<<Filter>>>.
-
-  As an example, the following filter will resume an interrupted download instead of restarting downloading the file
-  from the beginning:
-
-+-----+
-AsyncHttpClient c = new AsyncHttpClient(
-    new AsyncHttpClientConfig.Builder()
-        .addIOExceptionFilter(new ResumableIOExceptionFilter()).build());
-
-Response r = c.prepareGet("http://host:port/LargeFile.avi").execute(new AsyncHandler(){...}).get();
-+-----+
-
-  The <<<IOExceptionFilter>>> is defined as
-  
-+-----+
-public class ResumableIOExceptionFilter implements IOExceptionFilter {
-    public FilterContext filter(FilterContext ctx) throws FilterException {
-        if (ctx.getIOException() != null ) {
-            Request request = new RequestBuilder(ctx.getRequest()).setRangeOffset(file.length());
-            return new FilterContext.FilterContextBuilder(ctx)
-                .request(request)
-                .replayRequest(true)
-                .build();
-        }
-        return ctx;
-    }
-}
-+-----+
-
-In the above we just catch any <<<IOException>>> and replay the request using the <<<Range>>> header to tell the remote
-server to restart sending bytes at that position. This way we don't need to re download the entire file.
diff --git a/site/src/site/apt/oauth.apt b/site/src/site/apt/oauth.apt
deleted file mode 100644
index fb8e9bab2..000000000
--- a/site/src/site/apt/oauth.apt
+++ /dev/null
@@ -1,26 +0,0 @@
-                                    ------
-                           Async Http Client - Using OAuth
-                                    ------
-                              Jeanfrancois Arcand
-                                    ------
-                                       2012
-
-Using OAuth
-
-  You can use the library to pull data from any OAuth site (like Twitter). This is as simple as:
-
-+-----+
-private static final String CONSUMER_KEY = "dpf43f3p2l4k3l03";
-private static final String CONSUMER_SECRET = "kd94hf93k423k f44";
-public static final String TOKEN_KEY = "nnch734d00sl2jdk";
-public static final String TOKEN_SECRET = "pfkkdhi9sl3r4s00";
-public static final String NONCE = "kllo9940pd9333jh";
-final static long TIMESTAMP = 1191242096;
-
-public void oAuth() {
-ConsumerKey consumer = new ConsumerKey(CONSUMER_KEY, CONSUMER_SECRET);
-RequestToken user = new RequestToken(TOKEN_KEY, TOKEN_SECRET);
-OAuthSignatureCalculator calc = new OAuthSignatureCalculator(consumer, user);
-AsyncHttpClient client = new AsyncHttpClient();
-Response response = client.prepareGet("http://...").setSignatureCalculator(calc).execute().get();
-+-----+
diff --git a/site/src/site/apt/performances.apt b/site/src/site/apt/performances.apt
deleted file mode 100644
index 6d26b77af..000000000
--- a/site/src/site/apt/performances.apt
+++ /dev/null
@@ -1,22 +0,0 @@
-                                    ------
-                           Async Http Client - Limiting the number of connections to improve raw performance
-                                    ------
-                              Jeanfrancois Arcand
-                                    ------
-                                       2012
-
-Limiting the number of connections to improve raw performance
-
-  By default the library uses a connection pool and re-use connections as needed. It is important to not let the
-  connection pool grow too large as it takes resources in memory. One way consist of setting the maximum number of
-  connection per host or in total:
-
-+-----+
-AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder()
-                                        .setMaximumConnectionsPerHost(10)
-                                        .setMaximumConnectionsTotal(100)
-                                        .build();
-AsyncHttpClient c = new AsyncHttpClient(config);
-+-----+
-
-  There is no magic number, so you will need to try it and decide which one gives the best result.
diff --git a/site/src/site/apt/providers.apt b/site/src/site/apt/providers.apt
deleted file mode 100644
index 1ececa103..000000000
--- a/site/src/site/apt/providers.apt
+++ /dev/null
@@ -1,38 +0,0 @@
-                                    ------
-                           Async Http Client - Switching Provider
-                                    ------
-                              Jeanfrancois Arcand
-                                    ------
-                                       2012
-
-Switching Provider
-
-  By default, the <<<AsyncHttpClient>>> is using the powerful {{{http://netty.io/}Netty}}'s framework as the
-  HTTP processor. There might be environment where you can't use Netty. Fortunately, the <<<AsyncHttpClient>>> library
-  supports two other http runtime: the <<<JDKAsyncHttpProvider>>>, which build around the <<<URLConnection>>>, and
-  <<<ApacheAsyncHttpProvider>>> which build on top of the
-  {{{http://hc.apache.org/httpcomponents-client-ga/index.html}Apache HttpClient}}.
-
-  To change provider, all you need to do is:
-
-+-----+
-AsyncHttpClient client = new AsyncHttpClient(new ApacheAsyncHttpProvider(new AsyncHttpClientConfig.Builder().build()));
-+-----+
-
-  Same for the JDK:
-
-+-----+
-AsyncHttpclient client = new AsyncHttpClient(new JDKAsyncHttpProvider(new AsyncHttpClientConfig.Builder().build()));
-+-----+
-
-  Also every <<<AsyncHttpClientProvider>>> can be configured with their native functionality.
-
-  As an example, you can switch the <<<NettyAsyncHttpProvider>>> to use blocking I/O instead of NIO:
-
-+-----+
-NettyAsyncHttpProviderConfig config = new NettyAsyncHttpProviderConfig();
-config.setProperty(NettyAsyncHttpProviderConfig.USE_BLOCKING_IO, "true");
-
-AsyncHttpClientConfig c = new AsyncHttpClientConfig().setAsyncHttpClientProviderConfig(config).build();
-AsyncHttpClient client = new AsyncHttpClient(new NettyAsyncHttpProvider(config));
-+-----+
diff --git a/site/src/site/apt/proxy.apt b/site/src/site/apt/proxy.apt
deleted file mode 100644
index a09932fc0..000000000
--- a/site/src/site/apt/proxy.apt
+++ /dev/null
@@ -1,86 +0,0 @@
-                                    ------
-                           Async Http Client - Configuring a Proxy
-                                    ------
-                              Jeanfrancois Arcand
-                                    ------
-                                       2012
-
-Configuring a Proxy
-
-  The AsyncHttpClient library supports proxy, proxy authentication and proxy tunneling.
-  Just need to create a <<<ProxyServer>>> instance:
-
-+-----+
-AsyncHttpClient client = new AsyncHttpClient();
-Future<Response> f = client.prepareGet("http://....)
-                           .setProxyServer(new ProxyServer("127.0.0.1", 8080))
-                           .execute();
-+-----+
-
-  If you need to use an SSL tunnel, all you need to do is:
-
-+-----+
-ProxyServer ps = new ProxyServer(ProxyServer.Protocol.HTTPS, "127.0.0.1", 8080);
-AsyncHttpClient asyncHttpClient = new AsyncHttpClient();
-RequestBuilder rb = new RequestBuilder("GET")
-                                .setProxyServer(ps)
-                                .setUrl("https://twitpic.com:443");
-Future responseFuture = asyncHttpClient.executeRequest(rb.build(), new AsyncCompletionHandlerBase() {
-    @Override
-    public void onThrowable(Throwable t) {}
-
-    @Override
-    public Response onCompleted(Response response) throws Exception {
-        return response;
-    }
-
-});
-Response r = responseFuture.get();
-+-----+
-
-  You can also set the authentication token on the <<<ProxyServer>>> instance:
-
-+-----+
-ProxyServer ps = new ProxyServer(ProxyServer.Protocol.HTTPS, "127.0.0.1", 8080, "admin", "password");
-AsyncHttpClient asyncHttpClient = new AsyncHttpClient();
-RequestBuilder rb = new RequestBuilder("GET")
-                            .setProxyServer(ps)
-                            .setUrl("https://twitpic.com:443");
-Future responseFuture = asyncHttpClient.executeRequest(rb.build(), new AsyncCompletionHandlerBase() {
-    @Override
-    public void onThrowable(Throwable t) {}
-
-    @Override
-    public Response onCompleted(Response response) throws Exception {
-        return response;
-    }
-
-});
-Response r = responseFuture.get();
-+-----+
-
-  You can also set the <<<ProxyServer>>> at the <<<AsyncHttpClientConfig>>> level. In that case, all request will share
-  the same proxy information.
-
-Using Java System Properties
-
-  The AsyncHttpClient library supports the standard
-  {{{http://docs.oracle.com/javase/7/docs/api/java/net/doc-files/net-properties.html#Proxies}Java Proxy System Properties}}.
-  You can configure this at a global level using the <<<setUseProxyProperties(true)>>> method on the
-  <<<AsyncHttpClientConfig.Builder>>>, or by setting the <<<org.asynchttpclient.AsyncHttpClientConfig.useProxyProperties>>>
-  system property to true.
-
-Using JDK ProxySelectors
-
-  The AsyncHttpClient library also supports using the default
-  {{{http://docs.oracle.com/javase/7/docs/api/java/net/ProxySelector.html}JDK ProxySelector}}.  This allows for more
-  fine grained control over which proxies to use, for example, it can be used in combination with
-  {{{https://code.google.com/p/proxy-vole/}Proxy Vole}} to use OS configured proxies or to use a proxy.pac file.
-
-  You configure this at a global level using the <<<setUseProxySelector(true)>>> method on the
-  <<<AsyncHttpClientConfig.Builder>>>, or by setting the
-   <<<org.asynchttpclient.AsyncHttpClientConfig.useProxySelector>>> system property to true.
-
-  If you don't change the default JDK <<<ProxySelector>>>, this setting is very similar to the <<<useProxyProperties>>>
-  setting, though the <<<useProxyProperties>>> setting does allow more flexibility, such as the ability to use an
-  HTTPS proxy.
\ No newline at end of file
diff --git a/site/src/site/apt/request.apt b/site/src/site/apt/request.apt
deleted file mode 100644
index 09e6e358d..000000000
--- a/site/src/site/apt/request.apt
+++ /dev/null
@@ -1,180 +0,0 @@
-                                    ------
-                           Async Http Client - Executing request
-                                    ------
-                              Jeanfrancois Arcand
-                                    ------
-                                       2012
-
-Executing request synchronously or asynchronously.
-
-  The first thing to decide when using the library is if your application can handle asynchronous response or not.
-  If not, the library has been designed using the Future API, hence you can always execute synchronous call by blocking
-  on the <<<Future.get()>>> method:
-
-+-----+
-AsyncHttpClient client = new AsyncHttpClient();
-Response response = client.prepareGet(("http://sonatype.com").execute().get();
-+-----+
-
-  The above means the request will block until the full Response has been received. It also made your application's
-  blocking, waiting for the response to comes back. This could be potentially an issue to block for every request,
-  specially when doing <<<POST>>> or <<<PUT>>> operations where you don't necessarily need to wait for the response.
-  A simple way consist of not calling the <<<Future.get()>>>
-
-+-----+
-AsyncHttpClient client = new AsyncHttpClient();
-Response response = client.preparePut(("http://sonatype.com/myFile.avi").execute();
-+-----+
-
-  A better way than above would consist of using an AsyncHandler. The AynchHandler API is fairly simple and just
-  consists of 5 methods to implements:
-
-+-----+
-public interface AsyncHandler<T> {
-    void onThrowable(Throwable t);
-
-    STATE onBodyPartReceived(HttpResponseBodyPart bodyPart)
-        throws Exception;
-
-    STATE onStatusReceived(HttpResponseStatus responseStatus)
-        throws Exception;
-
-    STATE onHeadersReceived(HttpResponseHeaders headers)
-        throws Exception;
-
-    T onCompleted() throws Exception;
-}
-+-----+
-
-* Creating a Request object
-
-  The AsynHttpClient uses the builder pattern when it is time to create Request object. The simplest way consist of:
-
-+-----+
-RequestBuilder builder = new RequestBuilder("PUT");
-Request request = builder..setUrl("http://")
-    .addHeader("name", "value")
-    .setBody(new File("myUpload.avi"))
-    .build();
-AsyncHttpClient client = new AsyncHttpClient();
-client.execute(request, new AsyncHandler<...>() {
-.....
-} );
-+-----+
-
-  If you need to work with File, the library supports the {{{./zero-bytes-copy.html}zero copy in memory concept}},
-  e.g the File can be uploaded or downloaded without loading its associated bytes in memory, preventing out of memory
-  errors in case you need to upload or download many large files. Although the library support the following:
-
-+-----+
-Request request = builder.setUrl("http://")
-    .addHeader("name", "value")
-    .setBody(myInputStream))
-    .build();
-+-----+
-
-  it is discouraged to use <<<InputStream>>> as the library will need to buffer bytes in memory in order to determine
-  the length of the stream, and instead highly recommended to either use a File or the <<<BodyGenerator>>> API to avoid
-  loading unnecessary bytes in memory:
-
-+-----+
-public interface BodyGenerator {
-    Body createBody() throws IOException;
-}
-+-----+
-
-  where a Body is defined as:
-
-+-----+
-public interface Body {
-    long getContentLength();
-
-    long read(ByteBuffer buffer)
-        throws IOException;
-
-    void close() throws IOException;
-}
-+-----+
-
-  This way the library will never read unnecessary bytes in memory, which could significantly improve the performance
-  your application.
-
-  The <<<RequestBuilder>>> can also be used to create per <<<Request>>> configuration,
-  like setting a Proxy or request timeout:
-
-+-----+
-PerRequestConfig requestConfig = new PerRequestConfig();
-requestConfig.setRequestTimeoutInMs(5 * 1000);
-requestConfig.setProxy(new ProxyServer(...));
-Future responseFuture = client.prepareGet("http://").setPerRequestConfig(requestConfig).execute();
-+-----+
-
-* Creating a Response object
-
-  The AsyncHandler is typed, e.g you can return any object from the <<<AsyncHandler.onCompleted()>>>. One useful object
-  of the library is the <<<Response>>> object and it's associate builder. You can incrementally create a <<<Response>>>
-  object using the <<<ResponseBuilder.accumulate()>>> method:
-
-+-----+
-MyAsyncHandler<Response> asyncHandler = new MyAsyncHanfler<Response>() {
-    private final Response.ResponseBuilder builder = new Response.ResponseBuilder();
-
-    public STATE onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
-        builder.accumulate(content);
-        return STATE.CONTINUE;
-    }
-
-    public STATE onStatusReceived(final HttpResponseStatus status) throws Exception {
-        builder.accumulate(status);
-        return STATE.CONTINUE;
-    }
-
-    public STATE onHeadersReceived(final HttpResponseHeaders headers) throws Exception {
-        builder.accumulate(headers);
-        return STATE.CONTINUE;
-    }
-
-    public Response onCompleted() throws Exception {
-        return builder.build();
-    }
-
-}
-
-Response response = client.prepareGet("http://sonatype.com").execute(asyncHandler).get();
-+-----+
-
-  One thing to consider when creating a <<<Response>>> object is the size of the response body. By default,
-  a <<<Response>>> object will accumulate all response's bytes in memory, and that could potentially create an out of
-  memory error. If you are planning to use the API for downloading large files, it is not recommended to accumulate
-  bytes in memory and instead flush the bytes on disk as soon as they are available. Note that you can still use the
-  <<<Response>>> object, except you don't accumulate the response's bytes as demonstrated below:
-
-+-----+
-MyAsyncHandler<Response> asyncHandler = new MyAsyncHanfler<Response>() {
-    private final Response.ResponseBuilder builder = new Response.ResponseBuilder();
-
-    public STATE onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
-        content.write(myOutputStream);
-        return STATE.CONTINUE;
-    }
-
-    public STATE onStatusReceived(final HttpResponseStatus status) throws Exception {
-        builder.accumulate(status); return STATE.CONTINUE;
-    }
-
-    public STATE onHeadersReceived(final HttpResponseHeaders headers) throws Exception {
-        builder.accumulate(headers);
-        return STATE.CONTINUE;
-    }
-
-    public Response onCompleted() throws Exception {
-        return builder.build();
-    }
-
-}
-
-Response response = client.prepareGet("http://sonatype.com").execute(asyncHandler).get();
-+-----+
-
-  Note that in the above scenario invoking <<<Response.getResponseBodyAsStream()>>> or <<<getResponseBody()>>> will
-  return an <<<IllegalStateException>>> because the body wasn't accumulated by the <<<Response>>> object.
diff --git a/site/src/site/apt/resumable-download.apt b/site/src/site/apt/resumable-download.apt
deleted file mode 100644
index 22ba329a9..000000000
--- a/site/src/site/apt/resumable-download.apt
+++ /dev/null
@@ -1,75 +0,0 @@
-                                    ------
-                           Async Http Client - Resumable Dowload
-                                    ------
-                              Jeanfrancois Arcand
-                                    ------
-                                       2012
-
-Uploading file: Progress Listener
-
-  The AsyncHttpClient supports resumable download in two different scenarios:
-
-  * <<<IOException>>>: If an <<<IOException>>> occurs (for whatever reason), you can configure the library to restart
-    the download automatically without having to restart the download from the beginning.
-
-  * <<<JVM crashes>>>: If your application or the JVM goes down during a file download, the library can also restart the
-    download automatically when the same download is requested.
-
-
-  You can configure the <<<AsyncHttpClient>>> Library to survive <<<IOException>> using the <<<IOException Filter>>>:
-
-+-----+
-AsyncHttpClient c = new AsyncHttpClient(new AsyncHttpClientConfig.Builder()
-                                            .addIOExceptionFilter(new ResumableIOExceptionFilter()).build());
-ResumableAsyncHandler a = new ResumableAsyncHandler(new ResumableRandomAccessFileListener());
-a.setResumableListener(new ResumableRandomAccessFileListener(new RandomAccessFile("file.avi", "rw")));
-Response r = c.prepareGet("http://host:port/file.avi").execute(a).get();
-+-----+
-
-  If you need something more high level and configurable, you can use a <<<ResumableAsyncHandler>>>, and or implement
-  a <<<ResumableProcessor>>>:
-
-+-----+
-AsyncHttpClient c = new AsyncHttpClient();
-ResumableAsyncHandler a = new ResumableAsyncHandler(new PropertiesBasedResumableProcessor());
-a.setResumableListener(new ResumableRandomAccessFileListener(new RandomAccessFile("file.avi", "rw")));
-Response r = c.prepareGet( "http://localhost:8081/file.AVI" ).execute( a ).get();
-+-----+
-
-  You can also simply use a <<<ResumableListener>>> (or use the <<<ResumableRandomAccessFileListener>>>,
-  which does what's described below):
-
-+-----+
-public interface ResumableListener {
-    public void onBytesReceived(ByteBuffer byteBuffer) throws IOException;
-
-    public void onAllBytesReceived();
-
-    public long length();
-}
-+-----+
-
-  As simple as:
-
-+-----+
-AsyncHttpClient c = new AsyncHttpClient();
-final RandomAccessFile file = new RandomAccessFile("file.avi", "rw");
-ResumableAsyncHandler a = new ResumableAsyncHandler();
-a.setResumableListener(new ResumableListener() {
-
-    public void onBytesReceived(ByteBuffer byteBuffer) throws IOException {
-        file.seek(file.length());
-        file.write(byteBuffer.array());
-    }
-
-    public void onAllBytesReceived() {
-        file.close();
-    }
-
-    public long length() {
-        return file.length();
-    }
-
-});
-Response r = c.prepareGet( "http://localhost:8081/file.AVI" ).execute( a ).get();
-+-----+
diff --git a/site/src/site/apt/ssl.apt b/site/src/site/apt/ssl.apt
deleted file mode 100644
index aeb3e958a..000000000
--- a/site/src/site/apt/ssl.apt
+++ /dev/null
@@ -1,40 +0,0 @@
-                                    ------
-                           Async Http Client - Configuring SSL
-                                    ------
-                              Jeanfrancois Arcand
-                                    ------
-                                       2012
-
-Configuring SSL
-
-  Configuring the library to support SSL is simple. By default you don't have to configure anything if you don't need to use your own certificates etc.
-
-+-----+
-AsyncHttpClient client = new AsyncHttpClient();
-Response response = client.prepareGet(("https://sonatype.com").execute().get();
-+-----+
-
-  The library will detect it's an SSL request and appropriately locate the key store, trust store etc.
-  If you need to configure those objects, all you need to do is to create an <<<SSLContext>>> and set it using the
-  <<<AsyncHttpClient>>>'s Builder as showed below:
-
-+-----+
-InputStream keyStoreStream = ....
-char[] keyStorePassword = "changeit".toCharArray();
-KeyStore ks = KeyStore.getInstance("JKS");
-ks.load(keyStoreStream, keyStorePassword);
-
-char[] certificatePassword = "changeit".toCharArray();
-KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509");
-kmf.init(ks, certificatePassword);
-
-KeyManager[] keyManagers = kmf.getKeyManagers();
-TrustManager[] trustManagers = new TrustManager[]{DUMMY_TRUST_MANAGER};
-SecureRandom secureRandom = new SecureRandom();
-
-SSLContext sslContext = SSLContext.getInstance("TLS");
-sslContext.init(keyManagers, trustManagers, secureRandom);
-Builder builder = new AsyncHttpClientConfig.Builder();
-builder.setSSLContext(sslContext);
-AsyncHttpClient client = new AsyncHttpClient(builder.build());
-+-----+
diff --git a/site/src/site/apt/transfer-listener.apt b/site/src/site/apt/transfer-listener.apt
deleted file mode 100644
index 399ea9649..000000000
--- a/site/src/site/apt/transfer-listener.apt
+++ /dev/null
@@ -1,34 +0,0 @@
-                                    ------
-                           Async Http Client - TransferListener
-                                    ------
-                              Jeanfrancois Arcand
-                                    ------
-                                       2012
-
-TransferListener
-
-  In some scenario an application may need to manipulate the received bytes in more than one place, e.g. saves the bytes
-  on disk but also accumulate it for checksum checking later. In that case, instead of using an <<<AsyncHandler>>> and
-  mixes logic inside an <<<AsyncHandler.onBodyPartReceived>>>, it is recommended to use the <<<TransferListener>>>
-  simple API:
-
-+-----+
-public interface TransferListener {
-    public void onRequestHeadersSent(FluentCaseInsensitiveStringsMap headers);
-    public void onResponseHeadersReceived (FluentCaseInsensitiveStringsMap headers);
-    public void onBytesReceived(ByteBuffer buffer) throws IOException;
-    public void onBytesSent(ByteBuffer buffer);
-    public void onRequestResponseCompleted();
-    public void onThrowable(Throwable t);
-}
-+-----+
-
-  All you need to do in that case is to create a <<<TransferCompletionHandler>>> and add as many <<<TransferListener>>>
-  as you need:
-
-+-----+
-AsyncHttpClient client = new AsyncHttpClient();
-TransferCompletionHandler tl = new TransferCompletionHandler();
-tl.addTransferListener(new TransferListener(){...});
-Response response = httpClient.prepareGet("http://...").execute(tl).get();
-+-----+
diff --git a/site/src/site/apt/upload.apt b/site/src/site/apt/upload.apt
deleted file mode 100644
index 65da26e44..000000000
--- a/site/src/site/apt/upload.apt
+++ /dev/null
@@ -1,32 +0,0 @@
-                                    ------
-                           Async Http Client - Uploading file: Progress Listener
-                                    ------
-                              Jeanfrancois Arcand
-                                    ------
-                                       2012
-
-Uploading file: Progress Listener
-
-  When uploading bytes, an application might need to take some action depending on where the upload status is.
-
-  The AsyncHttpClient library support a special <<<AsyncHandler>>> called <<<ProgressAsyncHandler>>> that can be used to
-  track the upload operation:
-
-+-----+
-public interface ProgressAsyncHandler<T> extends AsyncHandler<T> {
-    STATE onHeaderWriteCompleted();
-    STATE onContentWriteCompleted();
-    STATE onContentWriteProgress(long amount, long current, long total);
-}
-+-----+
-
-  The methods are called in the following order:
-
-  * <<<onHeaderWriteCompleted>>>: invoked when the headers has been flushed to the remote server
-
-  * <<<onContentWriteProgress>>>: as soon as some response's body bytes are written. Might be invoked many times.
-
-  * <<<onContentWriteCompleted>>>: invoked when the response has been sent or aborted.
-
-
-  Like with <<<AsyncHandler>>>, you can always always abort the processing at any moment in the upload process.
diff --git a/site/src/site/apt/webdav.apt b/site/src/site/apt/webdav.apt
deleted file mode 100644
index e20d3fa2b..000000000
--- a/site/src/site/apt/webdav.apt
+++ /dev/null
@@ -1,25 +0,0 @@
-                                    ------
-                           Async Http Client - Using the WebDav protocol
-                                    ------
-                              Jeanfrancois Arcand
-                                    ------
-                                       2012
-
-Using the WebDav protocol
-
-  The <<<AsyncHttpClient>>> has build in support for the WebDav protocol. The API can be used the same way normal HTTP
-  request are made, and everything discussed in this documentation works with WebDAV as well:
-
-+-----+
-AsyncHttpClient c = new AsyncHttpClient();
-Request mkcolRequest = new RequestBuilder("MKCOL").setUrl("http://host:port/folder1").build();
-Response response = c.executeRequest(mkcolRequest).get();
-+-----+
-
-  or
-
-+-----+
-AsyncHttpClient c = new AsyncHttpClient();
-Request propFindRequest = new RequestBuilder("PROPFIND").setUrl("http://host:port).build();
-Response response = c.executeRequest(propFindRequest, new AsyncHandler(){...}).get();
-+-----+
diff --git a/site/src/site/apt/zero-bytes-copy.apt b/site/src/site/apt/zero-bytes-copy.apt
deleted file mode 100644
index 0d16cd768..000000000
--- a/site/src/site/apt/zero-bytes-copy.apt
+++ /dev/null
@@ -1,45 +0,0 @@
-                                    ------
-                           Async Http Client - Zero Bytes Copy
-                                    ------
-                              Jeanfrancois Arcand
-                                    ------
-                                       2012
-
-Zero Bytes Copy
-
-  When uploading or downloading bytes, it is important to try to avoid buffering bytes in memory.
-
-* Upload
-
-  On the upload side, the mechanism is enabled by default when setting the <<<Request>>>'s body to a File:
-
-+-----+
-AsyncHttpClient client = new AsyncHttpClient();
-File file = new File("file.avi");
-Future f = client.preparePut("http://localhost").setBody(file).execute();
-+-----+
-
-  If you can't use a File, the recommended way is to use a <<<BodyGenerator>>>. It is strongly recommended to avoid
-  using <<<InputStream>>> as the library will unfortunately buffer the entire content in memory in order to set the
-  <<<content-length>>>, which can cause out of memory error.
-
-* Download
-
-  On the download side, you can use the <<<HttpResponseBodyPart.writeTo>>> to avoid loading bytes in memory and
-  unnecessary copy:
-
-+-----+
-AsyncHttpClient client = new AsyncHttpClient();
-File tmp = new File("zeroCopy.txt");
-final FileOutputStream stream = new FileOutputStream(tmp);
-Future f = client.prepareGet("http://localhost/largefile.avi").execute(new AsyncHandler() {
-    public void onThrowable(Throwable t) { }
-
-    public STATE onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-        bodyPart.writeTo(stream);
-        return STATE.CONTINUE;
-    }
-
-{ .... } });
-Response resp = f.get();
-+-----+
diff --git a/site/src/site/site.xml b/site/src/site/site.xml
deleted file mode 100644
index 1602c44f3..000000000
--- a/site/src/site/site.xml
+++ /dev/null
@@ -1,47 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project xmlns="http://maven.apache.org/DECORATION/1.1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-  xsi:schemaLocation="http://maven.apache.org/DECORATION/1.1.0 http://maven.apache.org/xsd/decoration-1.1.0.xsd"
-  name="${project.name}">
-
-  <skin>
-    <groupId>org.apache.maven.skins</groupId>
-    <artifactId>maven-fluido-skin</artifactId>
-    <version>1.1</version>
-  </skin>
-
-  <custom>
-    <fluidoSkin>
-      <topBarEnabled>true</topBarEnabled>
-      <sideBarEnabled>false</sideBarEnabled>
-      <twitter>
-        <user>jfarcand</user>
-        <showUser>true</showUser>
-        <showFollowers>true</showFollowers>
-      </twitter>
-    </fluidoSkin>
-  </custom>
-
-  <publishDate format="dd MMMM yyyy" position="left" />
-  <version position="left" />
-
-  <body>
-    <menu name="User guide">
-      <item name="Executing request" href="request.html" />
-      <item name="Configuring the AsyncHttpClient" href="configuring.html" />
-      <item name="SSL" href="ssl.html" />
-      <item name="Using Filters" href="filters.html" />
-      <item name="Uploading file" href="upload.html" />
-      <item name="Authentication" href="auth.html" />
-      <item name="Proxy" href="proxy.html" />
-      <item name="Switching Provider" href="providers.html" />
-      <item name="Using the WebDav protocol" href="webdav.html" />
-      <item name="Resumable Dowload" href="resumable-download.html" />
-      <item name="TransferListener" href="transfer-listener.html" />
-      <item name="Zero Bytes Copy" href="zero-bytes-copy.html" />
-      <item name="Improve raw performance" href="performances.html" />
-      <item name="OAuth" href="oauth.html" />
-    </menu>
-
-    <menu ref="reports" inherit="bottom" />
-  </body>
-</project>
diff --git a/site/src/site/xdoc/index.xml.vm b/site/src/site/xdoc/index.xml.vm
deleted file mode 100644
index 6860f4dd7..000000000
--- a/site/src/site/xdoc/index.xml.vm
+++ /dev/null
@@ -1,28 +0,0 @@
-<?xml version="1.0"?>
-<document xmlns="http://maven.apache.org/XDOC/2.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-          xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">
-
-  <properties>
-    <title>Async Http Client - Home</title>
-    <author>Jeanfrancois Arcand</author>
-  </properties>
-
-  <body>
-    <div class="hero-unit">
-      <h1>Welcome to the Async Http Client!</h1>
-      <p>The <span style="font-weight: bold">Async Http Client</span> library purpose is to allow Java applications to
-      easily execute HTTP requests and asynchronously process the HTTP responses.
-      The library also supports the WebSocket Protocol.</p>
-    </div>
-
-    <section name="Get started">
-      <p>The Async HTTP Client library is simple to use. First, in order to add it to your Maven project, simply add
-      this dependency:</p>
-      <source><![CDATA[<dependency>
-   <groupId>${project.groupId}</groupId>
-   <artifactId>${project.artifactId}</artifactId>
-   <version>${project.version}</version>
-</dependency>]]></source>
-    </section>
-  </body>
-</document>
