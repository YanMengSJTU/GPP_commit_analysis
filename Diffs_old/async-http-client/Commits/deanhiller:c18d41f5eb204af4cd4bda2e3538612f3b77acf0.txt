diff --git a/api/src/test/java/com/ning/http/client/async/AbstractBasicTest.java b/api/src/test/java/com/ning/http/client/async/AbstractBasicTest.java
index 9fc2c0509..6e7dd540e 100644
--- a/api/src/test/java/com/ning/http/client/async/AbstractBasicTest.java
+++ b/api/src/test/java/com/ning/http/client/async/AbstractBasicTest.java
@@ -41,6 +41,8 @@
 import java.net.ServerSocket;
 import java.util.Enumeration;
 
+import junit.framework.TestCase;
+
 public abstract class AbstractBasicTest {
     protected final Logger log = LoggerFactory.getLogger(AbstractBasicTest.class);
     protected Server server;
diff --git a/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/ChanMgrAsyncHttpProvider.java b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/ChanMgrAsyncHttpProvider.java
new file mode 100644
index 000000000..19ff2e2c2
--- /dev/null
+++ b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/ChanMgrAsyncHttpProvider.java
@@ -0,0 +1,783 @@
+/*
+ * Copyright 2010 Ning, Inc.
+ *
+ * Ning licenses this file to you under the Apache License, version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at:
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package com.ning.http.client.providers.chanmgr;
+
+import static com.ning.http.util.AsyncHttpProviderUtils.DEFAULT_CHARSET;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.RandomAccessFile;
+import java.net.ConnectException;
+import java.net.InetSocketAddress;
+import java.net.MalformedURLException;
+import java.net.URI;
+import java.nio.channels.ClosedChannelException;
+import java.nio.channels.FileChannel;
+import java.nio.channels.WritableByteChannel;
+import java.nio.charset.Charset;
+import java.security.GeneralSecurityException;
+import java.security.NoSuchAlgorithmException;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.Semaphore;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import javax.net.ssl.SSLEngine;
+
+import org.jboss.netty.bootstrap.ClientBootstrap;
+import org.jboss.netty.buffer.ChannelBuffer;
+import org.jboss.netty.buffer.ChannelBufferOutputStream;
+import org.jboss.netty.buffer.ChannelBuffers;
+import org.jboss.netty.channel.Channel;
+import org.jboss.netty.channel.ChannelFuture;
+import org.jboss.netty.channel.ChannelFutureProgressListener;
+import org.jboss.netty.channel.ChannelHandlerContext;
+import org.jboss.netty.channel.ChannelPipeline;
+import org.jboss.netty.channel.ChannelStateEvent;
+import org.jboss.netty.channel.DefaultChannelFuture;
+import org.jboss.netty.channel.ExceptionEvent;
+import org.jboss.netty.channel.FileRegion;
+import org.jboss.netty.channel.MessageEvent;
+import org.jboss.netty.channel.SimpleChannelUpstreamHandler;
+import org.jboss.netty.channel.group.ChannelGroup;
+import org.jboss.netty.handler.codec.http.CookieEncoder;
+import org.jboss.netty.handler.codec.http.DefaultCookie;
+import org.jboss.netty.handler.codec.http.DefaultHttpChunkTrailer;
+import org.jboss.netty.handler.codec.http.DefaultHttpRequest;
+import org.jboss.netty.handler.codec.http.HttpChunk;
+import org.jboss.netty.handler.codec.http.HttpChunkTrailer;
+import org.jboss.netty.handler.codec.http.HttpClientCodec;
+import org.jboss.netty.handler.codec.http.HttpHeaders;
+import org.jboss.netty.handler.codec.http.HttpMethod;
+import org.jboss.netty.handler.codec.http.HttpRequest;
+import org.jboss.netty.handler.codec.http.HttpResponse;
+import org.jboss.netty.handler.codec.http.HttpVersion;
+import org.jboss.netty.handler.codec.http.websocketx.CloseWebSocketFrame;
+import org.jboss.netty.handler.codec.http.websocketx.WebSocket08FrameDecoder;
+import org.jboss.netty.handler.codec.http.websocketx.WebSocket08FrameEncoder;
+import org.jboss.netty.handler.codec.http.websocketx.WebSocketFrame;
+import org.jboss.netty.handler.ssl.SslHandler;
+import org.jboss.netty.handler.stream.ChunkedFile;
+import org.jboss.netty.handler.stream.ChunkedWriteHandler;
+import org.playorm.nio.api.ChannelManager;
+import org.playorm.nio.api.ChannelManagerFactory;
+import org.playorm.nio.api.channels.TCPChannel;
+import org.playorm.nio.api.handlers.FutureOperation;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.ning.http.client.AsyncHandler;
+import com.ning.http.client.AsyncHandler.STATE;
+import com.ning.http.client.AsyncHttpClientConfig;
+import com.ning.http.client.AsyncHttpProvider;
+import com.ning.http.client.Body;
+import com.ning.http.client.BodyGenerator;
+import com.ning.http.client.ConnectionsPool;
+import com.ning.http.client.Cookie;
+import com.ning.http.client.FluentCaseInsensitiveStringsMap;
+import com.ning.http.client.HttpResponseBodyPart;
+import com.ning.http.client.HttpResponseHeaders;
+import com.ning.http.client.HttpResponseStatus;
+import com.ning.http.client.ListenableFuture;
+import com.ning.http.client.MaxRedirectException;
+import com.ning.http.client.PerRequestConfig;
+import com.ning.http.client.ProgressAsyncHandler;
+import com.ning.http.client.ProxyServer;
+import com.ning.http.client.RandomAccessBody;
+import com.ning.http.client.Realm;
+import com.ning.http.client.Request;
+import com.ning.http.client.RequestBuilder;
+import com.ning.http.client.Response;
+import com.ning.http.client.filter.FilterContext;
+import com.ning.http.client.filter.FilterException;
+import com.ning.http.client.filter.IOExceptionFilter;
+import com.ning.http.client.filter.ResponseFilter;
+import com.ning.http.client.generators.InputStreamBodyGenerator;
+import com.ning.http.client.listener.TransferCompletionHandler;
+import com.ning.http.client.ntlm.NTLMEngine;
+import com.ning.http.client.ntlm.NTLMEngineException;
+import com.ning.http.client.providers.chanmgr.FeedableBodyGenerator.FeedListener;
+import com.ning.http.client.providers.chanmgr.chain.AConnectListener;
+import com.ning.http.client.providers.chanmgr.spnego.SpnegoEngine;
+import com.ning.http.client.providers.chanmgr.util.CleanupChannelGroup;
+import com.ning.http.client.websocket.WebSocketUpgradeHandler;
+import com.ning.http.multipart.MultipartBody;
+import com.ning.http.multipart.MultipartRequestEntity;
+import com.ning.http.util.AsyncHttpProviderUtils;
+import com.ning.http.util.AuthenticatorUtils;
+import com.ning.http.util.ProxyUtils;
+import com.ning.http.util.SslUtils;
+import com.ning.http.util.UTF8UrlEncoder;
+
+public class ChanMgrAsyncHttpProvider extends SimpleChannelUpstreamHandler implements AsyncHttpProvider {
+    private final static String WEBSOCKET_KEY = "Sec-WebSocket-Key";
+    private final static String HTTP_HANDLER = "httpHandler";
+    protected final static String SSL_HANDLER = "sslHandler";
+    private final static String HTTPS = "https";
+    private final static String HTTP = "http";
+    private static final String WEBSOCKET = "ws";
+    private static final String WEBSOCKET_SSL = "wss";
+
+    private final static Logger log = LoggerFactory.getLogger(ChanMgrAsyncHttpProvider.class);
+    private final static Charset UTF8 = Charset.forName("UTF-8");
+
+    private final static int MAX_BUFFERED_BYTES = 8192;
+    private final AsyncHttpClientConfig config;
+    private final AtomicBoolean isClose = new AtomicBoolean(false);
+
+    private final ConnectionsPool<String, TCPChannel> connectionsPool;
+    private Semaphore freeConnections = null;
+    private final ChanMgrAsyncHttpProviderConfig asyncHttpProviderConfig;
+    private final boolean trackConnections;
+    private final boolean useRawUrl;
+    private final static NTLMEngine ntlmEngine = new NTLMEngine();
+    private final static SpnegoEngine spnegoEngine = new SpnegoEngine();
+    //private final Protocol httpProtocol = new HttpProtocol();
+    //private final Protocol webSocketProtocol = new WebSocketProtocol();
+	private ChannelManager chanMgr;
+	private int chanCount;
+
+    public ChanMgrAsyncHttpProvider(AsyncHttpClientConfig config) {
+
+        if (config.getAsyncHttpProviderConfig() != null
+                && ChanMgrAsyncHttpProviderConfig.class.isAssignableFrom(config.getAsyncHttpProviderConfig().getClass())) {
+            asyncHttpProviderConfig = ChanMgrAsyncHttpProviderConfig.class.cast(config.getAsyncHttpProviderConfig());
+        } else {
+            asyncHttpProviderConfig = new ChanMgrAsyncHttpProviderConfig();
+        }
+
+        Map<String, Object> props = null;
+		chanMgr = ChannelManagerFactory.createChannelManager("client", props);
+
+        this.config = config;
+
+        // This is dangerous as we can't catch a wrong typed ConnectionsPool
+        ConnectionsPool<String, TCPChannel> cp = (ConnectionsPool<String, TCPChannel>) config.getConnectionsPool();
+        if (cp == null && config.getAllowPoolingConnection()) {
+            cp = new ChanMgrConnectionsPool(this);
+        } else if (cp == null) {
+            cp = new NonConnectionsPool();
+        }
+        this.connectionsPool = cp;
+
+        if (config.getMaxTotalConnections() != -1) {
+            trackConnections = true;
+            freeConnections = new Semaphore(config.getMaxTotalConnections());
+        } else {
+            trackConnections = false;
+        }
+
+        useRawUrl = config.isUseRawUrl();
+    }
+
+    @Override
+    public String toString() {
+        return String.format("ChanMgrAsyncHttpProvider:\n\t- maxConnections: %d\n\t- connectionPools: %s",
+                config.getMaxTotalConnections() - freeConnections.availablePermits(),
+                connectionsPool.toString());
+    }
+
+    private TCPChannel lookupInCache(URI uri) {
+        final TCPChannel channel = connectionsPool.poll(AsyncHttpProviderUtils.getBaseUrl(uri));
+
+//        if (channel != null) {
+//            log.debug("Using cached Channel {}\n for uri {}\n", channel, uri);
+//
+//            try {
+//                // Always make sure the channel who got cached support the proper protocol. It could
+//                // only occurs when a HttpMethod.CONNECT is used agains a proxy that require upgrading from http to
+//                // https.
+//                return verifyChannelPipeline(channel, uri.getScheme());
+//            } catch (Exception ex) {
+//                log.debug(ex.getMessage(), ex);
+//            }
+//        }
+        return null;
+    }
+
+    private SSLEngine createSSLEngine() throws IOException, GeneralSecurityException {
+        SSLEngine sslEngine = config.getSSLEngineFactory().newSSLEngine();
+        if (sslEngine == null) {
+            sslEngine = SslUtils.getSSLEngine();
+        }
+        return sslEngine;
+    }
+
+    private TCPChannel verifyChannelPipeline(TCPChannel channel, String scheme) throws IOException, GeneralSecurityException {
+
+//        if (channel.getPipeline().get(SSL_HANDLER) != null && HTTP.equalsIgnoreCase(scheme)) {
+//            channel.getPipeline().remove(SSL_HANDLER);
+//        } else if (channel.getPipeline().get(HTTP_HANDLER) != null && HTTP.equalsIgnoreCase(scheme)) {
+//            return channel;
+//        } else if (channel.getPipeline().get(SSL_HANDLER) == null && isSecure(scheme)) {
+//            channel.getPipeline().addFirst(SSL_HANDLER, new SslHandler(createSSLEngine()));
+//        }
+        return channel;
+    }
+
+    private static boolean isProxyServer(AsyncHttpClientConfig config, Request request) {
+        return request.getProxyServer() != null || config.getProxyServer() != null;
+    }
+
+    protected final static HttpRequest buildRequest(AsyncHttpClientConfig config, Request request, URI uri,
+                                                    boolean allowConnect, ChannelBuffer buffer) throws IOException {
+
+        String method = request.getMethod();
+        if (allowConnect && (isProxyServer(config, request) && isSecure(uri))) {
+            method = HttpMethod.CONNECT.toString();
+        }
+        return construct(config, request, new HttpMethod(method), uri, buffer);
+    }
+
+    private static HttpRequest construct(AsyncHttpClientConfig config,
+                                         Request request,
+                                         HttpMethod m,
+                                         URI uri,
+                                         ChannelBuffer buffer) throws IOException {
+
+        String host = AsyncHttpProviderUtils.getHost(uri);
+        boolean webSocket = isWebSocket(uri);
+
+        if (request.getVirtualHost() != null) {
+            host = request.getVirtualHost();
+        }
+
+        HttpRequest nettyRequest;
+        if (m.equals(HttpMethod.CONNECT)) {
+            nettyRequest = new DefaultHttpRequest(HttpVersion.HTTP_1_0, m, AsyncHttpProviderUtils.getAuthority(uri));
+        } else {
+            StringBuilder path = null;
+            if (isProxyServer(config, request))
+                path = new StringBuilder(uri.toString());
+            else {
+                path = new StringBuilder(uri.getRawPath());
+                if (uri.getQuery() != null) {
+                    path.append("?").append(uri.getRawQuery());
+                }
+            }
+            nettyRequest = new DefaultHttpRequest(HttpVersion.HTTP_1_1, m, path.toString());
+        }
+
+        if (webSocket) {
+            nettyRequest.addHeader(HttpHeaders.Names.UPGRADE, HttpHeaders.Values.WEBSOCKET);
+            nettyRequest.addHeader(HttpHeaders.Names.CONNECTION, HttpHeaders.Values.UPGRADE);
+            nettyRequest.addHeader("Origin", "http://" + uri.getHost() + ":"
+                    + (uri.getPort() == -1 ? isSecure(uri) ? 443 : 80 : uri.getPort()));
+            nettyRequest.addHeader(WEBSOCKET_KEY, WebSocketUtil.getKey());
+            nettyRequest.addHeader("Sec-WebSocket-Version", "13");
+        }
+
+        if (host != null) {
+            if (uri.getPort() == -1) {
+                nettyRequest.setHeader(HttpHeaders.Names.HOST, host);
+            } else if (request.getVirtualHost() != null) {
+                nettyRequest.setHeader(HttpHeaders.Names.HOST, host);
+            } else {
+                nettyRequest.setHeader(HttpHeaders.Names.HOST, host + ":" + uri.getPort());
+            }
+        } else {
+            host = "127.0.0.1";
+        }
+
+        if (!m.equals(HttpMethod.CONNECT)) {
+            FluentCaseInsensitiveStringsMap h = request.getHeaders();
+            if (h != null) {
+                for (String name : h.keySet()) {
+                    if (!"host".equalsIgnoreCase(name)) {
+                        for (String value : h.get(name)) {
+                            nettyRequest.addHeader(name, value);
+                        }
+                    }
+                }
+            }
+
+            if (config.isCompressionEnabled()) {
+                nettyRequest.setHeader(HttpHeaders.Names.ACCEPT_ENCODING, HttpHeaders.Values.GZIP);
+            }
+        } else {
+            List<String> auth = request.getHeaders().get(HttpHeaders.Names.PROXY_AUTHORIZATION);
+            if (auth != null && auth.size() > 0 && auth.get(0).startsWith("NTLM")) {
+                nettyRequest.addHeader(HttpHeaders.Names.PROXY_AUTHORIZATION, auth.get(0));
+            }
+        }
+        ProxyServer proxyServer = request.getProxyServer() != null ? request.getProxyServer() : config.getProxyServer();
+        Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
+
+        if (realm != null && realm.getUsePreemptiveAuth()) {
+
+            String domain = realm.getNtlmDomain();
+            if (proxyServer != null && proxyServer.getNtlmDomain() != null) {
+                domain = proxyServer.getNtlmDomain();
+            }
+
+            String authHost = realm.getNtlmHost();
+            if (proxyServer != null && proxyServer.getHost() != null) {
+                host = proxyServer.getHost();
+            }
+
+            switch (realm.getAuthScheme()) {
+                case BASIC:
+                    nettyRequest.setHeader(HttpHeaders.Names.AUTHORIZATION,
+                            AuthenticatorUtils.computeBasicAuthentication(realm));
+                    break;
+                case DIGEST:
+                    if (realm.getNonce() != null && !realm.getNonce().equals("")) {
+                        try {
+                            nettyRequest.setHeader(HttpHeaders.Names.AUTHORIZATION,
+                                    AuthenticatorUtils.computeDigestAuthentication(realm));
+                        } catch (NoSuchAlgorithmException e) {
+                            throw new SecurityException(e);
+                        }
+                    }
+                    break;
+                case NTLM:
+                    try {
+                        String msg = ntlmEngine.generateType1Msg("NTLM " + domain, authHost);
+                        nettyRequest.setHeader(HttpHeaders.Names.AUTHORIZATION, "NTLM " + msg);
+                    } catch (NTLMEngineException e) {
+                        IOException ie = new IOException();
+                        ie.initCause(e);
+                        throw ie;
+                    }
+                    break;
+                case KERBEROS:
+                case SPNEGO:
+                    String challengeHeader = null;
+                    String server = proxyServer == null ? host : proxyServer.getHost();
+                    try {
+                        challengeHeader = spnegoEngine.generateToken(server);
+                    } catch (Throwable e) {
+                        IOException ie = new IOException();
+                        ie.initCause(e);
+                        throw ie;
+                    }
+                    nettyRequest.setHeader(HttpHeaders.Names.AUTHORIZATION, "Negotiate " + challengeHeader);
+                    break;
+                case NONE:
+                    break;
+                default:
+                    throw new IllegalStateException(String.format("Invalid Authentication %s", realm.toString()));
+            }
+        }
+
+        if (!webSocket && !request.getHeaders().containsKey(HttpHeaders.Names.CONNECTION)) {
+            nettyRequest.setHeader(HttpHeaders.Names.CONNECTION, "keep-alive");
+        }
+
+        boolean avoidProxy = ProxyUtils.avoidProxy(proxyServer, request);
+        if (!avoidProxy) {
+            if (!request.getHeaders().containsKey("Proxy-Connection")) {
+                nettyRequest.setHeader("Proxy-Connection", "keep-alive");
+            }
+
+            if (proxyServer.getPrincipal() != null) {
+                if (proxyServer.getNtlmDomain() != null && proxyServer.getNtlmDomain().length() > 0) {
+
+                    List<String> auth = request.getHeaders().get(HttpHeaders.Names.PROXY_AUTHORIZATION);
+                    if (!(auth != null && auth.size() > 0 && auth.get(0).startsWith("NTLM"))) {
+                        try {
+                            String msg = ntlmEngine.generateType1Msg(proxyServer.getNtlmDomain(),
+                                    proxyServer.getHost());
+                            nettyRequest.setHeader(HttpHeaders.Names.PROXY_AUTHORIZATION, "NTLM " + msg);
+                        } catch (NTLMEngineException e) {
+                            IOException ie = new IOException();
+                            ie.initCause(e);
+                            throw ie;
+                        }
+                    }
+                } else {
+                    nettyRequest.setHeader(HttpHeaders.Names.PROXY_AUTHORIZATION,
+                            AuthenticatorUtils.computeBasicAuthentication(proxyServer));
+                }
+            }
+        }
+
+        // Add default accept headers.
+        if (request.getHeaders().getFirstValue("Accept") == null) {
+            nettyRequest.setHeader(HttpHeaders.Names.ACCEPT, "*/*");
+        }
+
+        if (request.getHeaders().getFirstValue("User-Agent") != null) {
+            nettyRequest.setHeader("User-Agent", request.getHeaders().getFirstValue("User-Agent"));
+        } else if (config.getUserAgent() != null) {
+            nettyRequest.setHeader("User-Agent", config.getUserAgent());
+        } else {
+            nettyRequest.setHeader("User-Agent",
+                         AsyncHttpProviderUtils.constructUserAgent(ChanMgrAsyncHttpProvider.class,
+                                                                   config));
+        }
+
+        if (!m.equals(HttpMethod.CONNECT)) {
+            if (request.getCookies() != null && !request.getCookies().isEmpty()) {
+                CookieEncoder httpCookieEncoder = new CookieEncoder(false);
+                Iterator<Cookie> ic = request.getCookies().iterator();
+                Cookie c;
+                org.jboss.netty.handler.codec.http.Cookie cookie;
+                while (ic.hasNext()) {
+                    c = ic.next();
+                    cookie = new DefaultCookie(c.getName(), c.getValue());
+                    cookie.setPath(c.getPath());
+                    cookie.setMaxAge(c.getMaxAge());
+                    cookie.setDomain(c.getDomain());
+                    httpCookieEncoder.addCookie(cookie);
+                }
+                nettyRequest.setHeader(HttpHeaders.Names.COOKIE, httpCookieEncoder.encode());
+            }
+
+            String reqType = request.getMethod();
+            if (!"GET".equals(reqType) && !"HEAD".equals(reqType) && !"OPTION".equals(reqType) && !"TRACE".equals(reqType)) {
+
+                String bodyCharset = request.getBodyEncoding() == null ? DEFAULT_CHARSET : request.getBodyEncoding();
+
+                // We already have processed the body.
+                if (buffer != null && buffer.writerIndex() != 0) {
+                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, buffer.writerIndex());
+                    nettyRequest.setContent(buffer);
+                } else if (request.getByteData() != null) {
+                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(request.getByteData().length));
+                    nettyRequest.setContent(ChannelBuffers.wrappedBuffer(request.getByteData()));
+                } else if (request.getStringData() != null) {
+                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(request.getStringData().getBytes(bodyCharset).length));
+                    nettyRequest.setContent(ChannelBuffers.wrappedBuffer(request.getStringData().getBytes(bodyCharset)));
+                } else if (request.getStreamData() != null) {
+                    int[] lengthWrapper = new int[1];
+                    byte[] bytes = AsyncHttpProviderUtils.readFully(request.getStreamData(), lengthWrapper);
+                    int length = lengthWrapper[0];
+                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(length));
+                    nettyRequest.setContent(ChannelBuffers.wrappedBuffer(bytes, 0, length));
+                } else if (request.getParams() != null && !request.getParams().isEmpty()) {
+                    StringBuilder sb = new StringBuilder();
+                    for (final Entry<String, List<String>> paramEntry : request.getParams()) {
+                        final String key = paramEntry.getKey();
+                        for (final String value : paramEntry.getValue()) {
+                            if (sb.length() > 0) {
+                                sb.append("&");
+                            }
+                            UTF8UrlEncoder.appendEncoded(sb, key);
+                            sb.append("=");
+                            UTF8UrlEncoder.appendEncoded(sb, value);
+                        }
+                    }
+                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(sb.length()));
+                    nettyRequest.setContent(ChannelBuffers.wrappedBuffer(sb.toString().getBytes(bodyCharset)));
+
+                    if (!request.getHeaders().containsKey(HttpHeaders.Names.CONTENT_TYPE)) {
+                        nettyRequest.setHeader(HttpHeaders.Names.CONTENT_TYPE, "application/x-www-form-urlencoded");
+                    }
+
+                } else if (request.getParts() != null) {
+                    int lenght = computeAndSetContentLength(request, nettyRequest);
+
+                    if (lenght == -1) {
+                        lenght = MAX_BUFFERED_BYTES;
+                    }
+
+                    MultipartRequestEntity mre = AsyncHttpProviderUtils.createMultipartRequestEntity(request.getParts(), request.getParams());
+
+                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_TYPE, mre.getContentType());
+                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(mre.getContentLength()));
+
+                    /**
+                     * TODO: AHC-78: SSL + zero copy isn't supported by the MultiPart class and pretty complex to implements.
+                     */
+
+                    if (isSecure(uri)) {
+                        ChannelBuffer b = ChannelBuffers.dynamicBuffer(lenght);
+                        mre.writeRequest(new ChannelBufferOutputStream(b));
+                        nettyRequest.setContent(b);
+                    }
+                } else if (request.getEntityWriter() != null) {
+                    int lenght = computeAndSetContentLength(request, nettyRequest);
+
+                    if (lenght == -1) {
+                        lenght = MAX_BUFFERED_BYTES;
+                    }
+
+                    ChannelBuffer b = ChannelBuffers.dynamicBuffer(lenght);
+                    request.getEntityWriter().writeEntity(new ChannelBufferOutputStream(b));
+                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, b.writerIndex());
+                    nettyRequest.setContent(b);
+                } else if (request.getFile() != null) {
+                    File file = request.getFile();
+                    if (!file.isFile()) {
+                        throw new IOException(String.format("File %s is not a file or doesn't exist", file.getAbsolutePath()));
+                    }
+                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, file.length());
+                }
+            }
+        }
+        return nettyRequest;
+    }
+
+    private static boolean isWebSocket(URI uri) {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	private static boolean isSecure(URI uri) {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	public void close() {
+        isClose.set(true);
+        try {
+            connectionsPool.destroy();
+            config.executorService().shutdown();
+            config.reaper().shutdown();
+            chanMgr.stop();
+        } catch (Throwable t) {
+            log.warn("Unexpected error on close", t);
+        }
+    }
+
+    /* @Override */
+
+    public Response prepareResponse(final HttpResponseStatus status,
+                                    final HttpResponseHeaders headers,
+                                    final List<HttpResponseBodyPart> bodyParts) {
+        return new NettyResponse(status, headers, bodyParts);
+    }
+
+    /* @Override */
+
+    public <T> ListenableFuture<T> execute(Request request, final AsyncHandler<T> asyncHandler) throws IOException {
+    	TCPChannel channel = chanMgr.createTCPChannel("channel"+getNextNum());
+    	
+        String requestUrl = request.getUrl();
+        URI uri = AsyncHttpProviderUtils.createUri(requestUrl);
+
+        InetSocketAddress remoteAddress = null;
+        if (request.getInetAddress() != null) {
+            remoteAddress = new InetSocketAddress(request.getInetAddress(), AsyncHttpProviderUtils.getPort(uri));
+        }
+
+       // connectionsPool.
+        
+        HttpRequest nettyRequest = null;
+
+        ChanMgrResponseFuture<T> future = new ChanMgrResponseFuture<T>(uri, request, asyncHandler, nettyRequest, config.getRequestTimeoutInMs(), config.getIdleConnectionTimeoutInMs(), this);
+        
+        AConnectListener<T> listener = new AConnectListener<T>(future);
+        boolean fromPool = false;
+        
+        if(!fromPool) {
+        	FutureOperation futureOp = channel.connect(remoteAddress);
+        	futureOp.setListener(listener);
+        } else {
+        	//we are re-using the channel, so just perform the write only then...
+        	
+        	//no need to wait for connection so just write the request out
+        	listener.performWrite(channel);
+        }
+    	
+    	return future;
+    }
+
+    private synchronized int getNextNum() {
+    	return chanCount++;
+    }
+    protected static int requestTimeout(AsyncHttpClientConfig config, PerRequestConfig perRequestConfig) {
+        int result;
+        if (perRequestConfig != null) {
+            int prRequestTimeout = perRequestConfig.getRequestTimeoutInMs();
+            result = (prRequestTimeout != 0 ? prRequestTimeout : config.getRequestTimeoutInMs());
+        } else {
+            result = config.getRequestTimeoutInMs();
+        }
+        return result;
+    }
+
+    private Realm kerberosChallenge(List<String> proxyAuth,
+                                    Request request,
+                                    ProxyServer proxyServer,
+                                    FluentCaseInsensitiveStringsMap headers,
+                                    Realm realm,
+                                    ChanMgrResponseFuture<?> future) throws NTLMEngineException {
+
+        URI uri = URI.create(request.getUrl());
+        String host = request.getVirtualHost() == null ? AsyncHttpProviderUtils.getHost(uri) : request.getVirtualHost();
+        String server = proxyServer == null ? host : proxyServer.getHost();
+        try {
+            String challengeHeader = spnegoEngine.generateToken(server);
+            headers.remove(HttpHeaders.Names.AUTHORIZATION);
+            headers.add(HttpHeaders.Names.AUTHORIZATION, "Negotiate " + challengeHeader);
+
+            Realm.RealmBuilder realmBuilder;
+            if (realm != null) {
+                realmBuilder = new Realm.RealmBuilder().clone(realm);
+            } else {
+                realmBuilder = new Realm.RealmBuilder();
+            }
+            return realmBuilder.setUri(uri.getPath())
+                    .setMethodName(request.getMethod())
+                    .setScheme(Realm.AuthScheme.KERBEROS)
+                    .build();
+        } catch (Throwable throwable) {
+            if (proxyAuth.contains("NTLM")) {
+                return ntlmChallenge(proxyAuth, request, proxyServer, headers, realm, future);
+            }
+            abort(future, throwable);
+            return null;
+        }
+    }
+
+    private void abort(ChanMgrResponseFuture<?> future, Throwable throwable) {
+		// TODO Auto-generated method stub
+		
+	}
+
+	private Realm ntlmChallenge(List<String> wwwAuth,
+                                Request request,
+                                ProxyServer proxyServer,
+                                FluentCaseInsensitiveStringsMap headers,
+                                Realm realm,
+                                ChanMgrResponseFuture<?> future) throws NTLMEngineException {
+
+        boolean useRealm = (proxyServer == null && realm != null);
+
+        String ntlmDomain = useRealm ? realm.getNtlmDomain() : proxyServer.getNtlmDomain();
+        String ntlmHost = useRealm ? realm.getNtlmHost() : proxyServer.getHost();
+        String principal = useRealm ? realm.getPrincipal() : proxyServer.getPrincipal();
+        String password = useRealm ? realm.getPassword() : proxyServer.getPassword();
+
+        Realm newRealm;
+        if (realm != null && !realm.isNtlmMessageType2Received()) {
+            String challengeHeader = ntlmEngine.generateType1Msg(ntlmDomain, ntlmHost);
+
+            headers.add(HttpHeaders.Names.AUTHORIZATION, "NTLM " + challengeHeader);
+            newRealm = new Realm.RealmBuilder().clone(realm).setScheme(realm.getAuthScheme())
+                    .setUri(URI.create(request.getUrl()).getPath())
+                    .setMethodName(request.getMethod())
+                    .setNtlmMessageType2Received(true)
+                    .build();
+            future.getAndSetAuth(false);
+        } else {
+            headers.remove(HttpHeaders.Names.AUTHORIZATION);
+
+            if (wwwAuth.get(0).startsWith("NTLM ")) {
+                String serverChallenge = wwwAuth.get(0).trim().substring("NTLM ".length());
+                String challengeHeader = ntlmEngine.generateType3Msg(principal, password,
+                        ntlmDomain, ntlmHost, serverChallenge);
+
+                headers.add(HttpHeaders.Names.AUTHORIZATION, "NTLM " + challengeHeader);
+            }
+
+            Realm.RealmBuilder realmBuilder;
+            Realm.AuthScheme authScheme;
+            if (realm != null) {
+                realmBuilder = new Realm.RealmBuilder().clone(realm);
+                authScheme = realm.getAuthScheme();
+            } else {
+                realmBuilder = new Realm.RealmBuilder();
+                authScheme = Realm.AuthScheme.NTLM;
+            }
+            newRealm = realmBuilder.setScheme(authScheme)
+                    .setUri(URI.create(request.getUrl()).getPath())
+                    .setMethodName(request.getMethod())
+                    .build();
+        }
+
+        return newRealm;
+    }
+
+    private Realm ntlmProxyChallenge(List<String> wwwAuth,
+                                     Request request,
+                                     ProxyServer proxyServer,
+                                     FluentCaseInsensitiveStringsMap headers,
+                                     Realm realm,
+                                     ChanMgrResponseFuture<?> future) throws NTLMEngineException {
+        future.getAndSetAuth(false);
+        headers.remove(HttpHeaders.Names.PROXY_AUTHORIZATION);
+
+        if (wwwAuth.get(0).startsWith("NTLM ")) {
+            String serverChallenge = wwwAuth.get(0).trim().substring("NTLM ".length());
+            String challengeHeader = ntlmEngine.generateType3Msg(proxyServer.getPrincipal(),
+                    proxyServer.getPassword(),
+                    proxyServer.getNtlmDomain(),
+                    proxyServer.getHost(),
+                    serverChallenge);
+            headers.add(HttpHeaders.Names.PROXY_AUTHORIZATION, "NTLM " + challengeHeader);
+        }
+        Realm newRealm;
+        Realm.RealmBuilder realmBuilder;
+        if (realm != null) {
+            realmBuilder = new Realm.RealmBuilder().clone(realm);
+        } else {
+            realmBuilder = new Realm.RealmBuilder();
+        }
+        newRealm = realmBuilder//.setScheme(realm.getAuthScheme())
+                .setUri(URI.create(request.getUrl()).getPath())
+                .setMethodName(request.getMethod())
+                .build();
+
+        return newRealm;
+    }
+
+    //Simple marker for stopping publishing bytes.
+
+    final static class DiscardEvent {
+    }
+
+    private final static int computeAndSetContentLength(Request request, HttpRequest r) {
+        int length = (int) request.getContentLength();
+        if (length == -1 && r.getHeader(HttpHeaders.Names.CONTENT_LENGTH) != null) {
+            length = Integer.valueOf(r.getHeader(HttpHeaders.Names.CONTENT_LENGTH));
+        }
+
+        if (length >= 0) {
+            r.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(length));
+        }
+        return length;
+    }
+
+    public AsyncHttpClientConfig getConfig() {
+        return config;
+    }
+
+    private static class NonConnectionsPool implements ConnectionsPool<String, TCPChannel> {
+
+        public boolean offer(String uri, TCPChannel connection) {
+            return false;
+        }
+
+        public TCPChannel poll(String uri) {
+            return null;
+        }
+
+        public boolean removeAll(TCPChannel connection) {
+            return false;
+        }
+
+        public boolean canCacheConnection() {
+            return true;
+        }
+
+        public void destroy() {
+        }
+    }
+   
+}
diff --git a/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/NettyAsyncHttpProviderConfig.java b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/ChanMgrAsyncHttpProviderConfig.java
similarity index 64%
rename from providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/NettyAsyncHttpProviderConfig.java
rename to providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/ChanMgrAsyncHttpProviderConfig.java
index 25167b822..3098f734b 100644
--- a/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/NettyAsyncHttpProviderConfig.java
+++ b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/ChanMgrAsyncHttpProviderConfig.java
@@ -25,42 +25,12 @@
 /**
  * This class can be used to pass Netty's internal configuration options. See Netty documentation for more information.
  */
-public class NettyAsyncHttpProviderConfig implements AsyncHttpProviderConfig<String, Object> {
-
-    /**
-     * Use Netty's blocking IO stategy.
-     */
-    public final static String USE_BLOCKING_IO = "useBlockingIO";
-
-    /**
-     * Use direct {@link java.nio.ByteBuffer}
-     */
-    public final static String USE_DIRECT_BYTEBUFFER = "bufferFactory";
-
-    /**
-     * Execute the connect operation asynchronously.
-     */
-    public final static String EXECUTE_ASYNC_CONNECT = "asyncConnect";
-
-    /**
-     * Allow nested request from any {@link com.ning.http.client.AsyncHandler}
-     */
-    public final static String DISABLE_NESTED_REQUEST = "disableNestedRequest";
-
-    /**
-     * Allow configuring the Netty's boss executor service.
-     */
-    public final static String BOSS_EXECUTOR_SERVICE = "bossExecutorService";
-
-    /**
-     * See {@link java.net.Socket#setReuseAddress(boolean)}
-     */
-    public final static String REUSE_ADDRESS = "reuseAddress";
+public class ChanMgrAsyncHttpProviderConfig implements AsyncHttpProviderConfig<String, Object> {
 
     private final ConcurrentHashMap<String, Object> properties = new ConcurrentHashMap<String, Object>();
 
-    public NettyAsyncHttpProviderConfig() {
-        properties.put(REUSE_ADDRESS, "false");
+    public ChanMgrAsyncHttpProviderConfig() {
+        //properties.put(REUSE_ADDRESS, "false");
     }
 
     /**
@@ -70,7 +40,7 @@ public NettyAsyncHttpProviderConfig() {
      * @param value the value of the property
      * @return this instance of AsyncHttpProviderConfig
      */
-    public NettyAsyncHttpProviderConfig addProperty(String name, Object value) {
+    public ChanMgrAsyncHttpProviderConfig addProperty(String name, Object value) {
         properties.put(name, value);
         return this;
     }
diff --git a/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/NettyConnectionsPool.java b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/ChanMgrConnectionsPool.java
similarity index 57%
rename from providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/NettyConnectionsPool.java
rename to providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/ChanMgrConnectionsPool.java
index ee03b2495..b580f2acc 100644
--- a/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/NettyConnectionsPool.java
+++ b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/ChanMgrConnectionsPool.java
@@ -12,12 +12,8 @@
  */
 package com.ning.http.client.providers.chanmgr;
 
-import com.ning.http.client.ConnectionsPool;
-import org.jboss.netty.channel.Channel;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 import java.util.ArrayList;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 import java.util.Timer;
@@ -26,15 +22,21 @@
 import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.atomic.AtomicBoolean;
 
+import org.playorm.nio.api.channels.TCPChannel;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.ning.http.client.ConnectionsPool;
+
 /**
  * A simple implementation of {@link com.ning.http.client.ConnectionsPool} based on a {@link java.util.concurrent.ConcurrentHashMap}
  */
-public class NettyConnectionsPool implements ConnectionsPool<String, Channel> {
+public class ChanMgrConnectionsPool implements ConnectionsPool<String, TCPChannel> {
 
-    private final static Logger log = LoggerFactory.getLogger(NettyConnectionsPool.class);
-    private final ConcurrentHashMap<String, ConcurrentLinkedQueue<IdleChannel>> connectionsPool = new ConcurrentHashMap<String, ConcurrentLinkedQueue<IdleChannel>>();
-    private final ConcurrentHashMap<Channel, IdleChannel> channel2IdleChannel = new ConcurrentHashMap<Channel, IdleChannel>();
-    private final ConcurrentHashMap<Channel, Long> channel2CreationDate = new ConcurrentHashMap<Channel, Long>();
+    private final static Logger log = LoggerFactory.getLogger(ChanMgrConnectionsPool.class);
+    private final ConcurrentHashMap<String, ConcurrentLinkedQueue<TCPChannel>> connectionsPool = new ConcurrentHashMap<String, ConcurrentLinkedQueue<TCPChannel>>();
+    private final Set<TCPChannel> openChannels = new HashSet<TCPChannel>();
+    
     private final AtomicBoolean isClosed = new AtomicBoolean(false);
     private final Timer idleConnectionDetector = new Timer(true);
     private final boolean sslConnectionPoolEnabled;
@@ -43,7 +45,7 @@
     private final int maxConnectionLifeTimeInMs;
     private final long maxIdleTime;
 
-    public NettyConnectionsPool(NettyAsyncHttpProvider provider) {
+    public ChanMgrConnectionsPool(ChanMgrAsyncHttpProvider provider) {
         this.maxTotalConnections = provider.getConfig().getMaxTotalConnections();
         this.maxConnectionPerHost = provider.getConfig().getMaxConnectionPerHost();
         this.sslConnectionPoolEnabled = provider.getConfig().isSslConnectionPoolEnabled();
@@ -52,105 +54,19 @@ public NettyConnectionsPool(NettyAsyncHttpProvider provider) {
         this.idleConnectionDetector.schedule(new IdleChannelDetector(), maxIdleTime, maxIdleTime);
     }
 
-    private static class IdleChannel {
-        final String uri;
-        final Channel channel;
-        final long start;
-
-        IdleChannel(String uri, Channel channel) {
-            this.uri = uri;
-            this.channel = channel;
-            this.start = System.currentTimeMillis();
-        }
-
-        @Override
-        public boolean equals(Object o) {
-            if (this == o) return true;
-            if (!(o instanceof IdleChannel)) return false;
-
-            IdleChannel that = (IdleChannel) o;
-
-            if (channel != null ? !channel.equals(that.channel) : that.channel != null) return false;
-
-            return true;
-        }
-
-        @Override
-        public int hashCode() {
-            return channel != null ? channel.hashCode() : 0;
-        }
-    }
-
-    private class IdleChannelDetector extends TimerTask {
-        @Override
-        public void run() {
-            try {
-                if (isClosed.get()) return;
-
-                if (log.isDebugEnabled()) {
-                    Set<String> keys = connectionsPool.keySet();
-
-                    for (String s : keys) {
-                        log.debug("Entry count for : {} : {}", s, connectionsPool.get(s).size());
-                    }
-                }
-
-                List<IdleChannel> channelsInTimeout = new ArrayList<IdleChannel>();
-                long currentTime = System.currentTimeMillis();
-
-                for (IdleChannel idleChannel : channel2IdleChannel.values()) {
-                    long age = currentTime - idleChannel.start;
-                    if (age > maxIdleTime) {
-
-                        log.debug("Adding Candidate Idle Channel {}", idleChannel.channel);
-
-                        // store in an unsynchronized list to minimize the impact on the ConcurrentHashMap.
-                        channelsInTimeout.add(idleChannel);
-                    }
-                }
-                long endConcurrentLoop = System.currentTimeMillis();
-
-                for (IdleChannel idleChannel : channelsInTimeout) {
-                    Object attachment = idleChannel.channel.getPipeline().getContext(NettyAsyncHttpProvider.class).getAttachment();
-                    if (attachment != null) {
-                        if (NettyResponseFuture.class.isAssignableFrom(attachment.getClass())) {
-                            NettyResponseFuture<?> future = (NettyResponseFuture<?>) attachment;
-
-                            if (!future.isDone() && !future.isCancelled()) {
-                                log.debug("Future not in appropriate state %s\n", future);
-                                continue;
-                            }
-                        }
-                    }
-
-                    if (remove(idleChannel)) {
-                        log.debug("Closing Idle Channel {}", idleChannel.channel);
-                        close(idleChannel.channel);
-                    }
-                }
-
-                if (log.isTraceEnabled())
-                    log.trace(String.format("%d channel open, %d idle channels closed (times: 1st-loop=%d, 2nd-loop=%d).\n",
-                        connectionsPool.size(), channelsInTimeout.size(), endConcurrentLoop - currentTime, System.currentTimeMillis() - endConcurrentLoop));
-            } catch (Throwable t) {
-                log.error("uncaught exception!", t);
-            }
-        }
-    }
-
     /**
      * {@inheritDoc}
      */
-    public boolean offer(String uri, Channel channel) {
+    public boolean offer(String uri, TCPChannel channel) {
         if (isClosed.get()) return false;
 
         if (!sslConnectionPoolEnabled && uri.startsWith("https")) {
             return false;
         }
 
-        Long createTime = channel2CreationDate.get(channel);
+        Long createTime = (Long) channel.getSession().get("createTime");
         if (createTime == null){
-           channel2CreationDate.putIfAbsent(channel, System.currentTimeMillis());
+        	channel.getSession().put("createTime", System.currentTimeMillis());
         }
         else if (maxConnectionLifeTimeInMs != -1 && (createTime + maxConnectionLifeTimeInMs) < System.currentTimeMillis() ) {
            log.debug("Channel {} expired", channel);
@@ -158,25 +74,24 @@ else if (maxConnectionLifeTimeInMs != -1 && (createTime + maxConnectionLifeTimeI
         }
 
         log.debug("Adding uri: {} for channel {}", uri, channel);
-        channel.getPipeline().getContext(NettyAsyncHttpProvider.class).setAttachment(new NettyAsyncHttpProvider.DiscardEvent());
+        //channel.getPipeline().getContext(ChanMgrAsyncHttpProvider.class).setAttachment(new ChanMgrAsyncHttpProvider.DiscardEvent());
 
-        ConcurrentLinkedQueue<IdleChannel> idleConnectionForHost = connectionsPool.get(uri);
+        ConcurrentLinkedQueue<TCPChannel> idleConnectionForHost = connectionsPool.get(uri);
         if (idleConnectionForHost == null) {
-            ConcurrentLinkedQueue<IdleChannel> newPool = new ConcurrentLinkedQueue<IdleChannel>();
+            ConcurrentLinkedQueue<TCPChannel> newPool = new ConcurrentLinkedQueue<TCPChannel>();
             idleConnectionForHost = connectionsPool.putIfAbsent(uri, newPool);
-            if (idleConnectionForHost == null) idleConnectionForHost = newPool;
+            if (idleConnectionForHost == null) 
+            	idleConnectionForHost = newPool;
         }
 
         boolean added;
         int size = idleConnectionForHost.size();
         if (maxConnectionPerHost == -1 || size < maxConnectionPerHost) {
-            IdleChannel idleChannel = new IdleChannel(uri, channel);
+            TCPChannel idleChannel = channel;
+            channel.getSession().put("uri", uri);
             synchronized (idleConnectionForHost) {
                 added = idleConnectionForHost.add(idleChannel);
-
-                if (channel2IdleChannel.put(channel, idleChannel) != null) {
-                    log.error("Channel {} already exists in the connections pool!", channel);
-                }
+                openChannels.add(idleChannel);
             }
         } else {
             log.debug("Maximum number of requests per host reached {} for {}", maxConnectionPerHost, uri);
@@ -188,68 +103,66 @@ else if (maxConnectionLifeTimeInMs != -1 && (createTime + maxConnectionLifeTimeI
     /**
      * {@inheritDoc}
      */
-    public Channel poll(String uri) {
+    public TCPChannel poll(String uri) {
         if (!sslConnectionPoolEnabled && uri.startsWith("https")) {
             return null;
         }
 
-        IdleChannel idleChannel = null;
-        ConcurrentLinkedQueue<IdleChannel> idleConnectionForHost = connectionsPool.get(uri);
+        TCPChannel idleChannel = null;
+        ConcurrentLinkedQueue<TCPChannel> idleConnectionForHost = connectionsPool.get(uri);
         if (idleConnectionForHost != null) {
             boolean poolEmpty = false;
             while (!poolEmpty && idleChannel == null) {
                 if (idleConnectionForHost.size() > 0) {
                     synchronized (idleConnectionForHost) {
                         idleChannel = idleConnectionForHost.poll();
-                        if (idleChannel != null) {
-                            channel2IdleChannel.remove(idleChannel.channel);
-                        }
                     }
                 }
 
                 if (idleChannel == null) {
                     poolEmpty = true;
-                } else if (!idleChannel.channel.isConnected() || !idleChannel.channel.isOpen()) {
+                } else if (!idleChannel.isConnected() || idleChannel.isClosed()) {
                     idleChannel = null;
                     log.trace("Channel not connected or not opened!");
                 }
             }
         }
-        return idleChannel != null ? idleChannel.channel : null;
+        return idleChannel;
     }
 
-    private boolean remove(IdleChannel pooledChannel) {
+    private boolean remove(TCPChannel pooledChannel) {
         if (pooledChannel == null || isClosed.get()) return false;
 
+        String uri = (String) pooledChannel.getSession().get("uri");
+        
         boolean isRemoved = false;
-        ConcurrentLinkedQueue<IdleChannel> pooledConnectionForHost = connectionsPool.get(pooledChannel.uri);
+        ConcurrentLinkedQueue<TCPChannel> pooledConnectionForHost = connectionsPool.get(uri);
         if (pooledConnectionForHost != null) {
             isRemoved = pooledConnectionForHost.remove(pooledChannel);
         }
-        isRemoved |= channel2IdleChannel.remove(pooledChannel.channel) != null;
+        openChannels.remove(pooledChannel);
         return isRemoved;
     }
 
     /**
      * {@inheritDoc}
      */
-    public boolean removeAll(Channel channel) {
-        channel2CreationDate.remove(channel);
-        return !isClosed.get() && remove(channel2IdleChannel.get(channel));
+    public boolean removeAll(TCPChannel channel) {
+        return !isClosed.get() && remove(channel);
     }
 
     /**
      * {@inheritDoc}
      */
     public boolean canCacheConnection() {
-        if (!isClosed.get() && maxTotalConnections != -1 && channel2IdleChannel.size() >= maxTotalConnections) {
+        if (!isClosed.get() && maxTotalConnections != -1 && openChannels.size() >= maxTotalConnections) {
             return false;
         } else {
             return true;
         }
     }
 
-    /**
+	/**
      * {@inheritDoc}
      */
     public void destroy() {
@@ -259,25 +172,70 @@ public void destroy() {
         idleConnectionDetector.cancel();
         idleConnectionDetector.purge();
 
-        for (Channel channel : channel2IdleChannel.keySet()) {
+        for (TCPChannel channel : openChannels) {
             close(channel);
         }
         connectionsPool.clear();
-        channel2IdleChannel.clear();
-        channel2CreationDate.clear();
+        openChannels.clear();
     }
 
-    private void close(Channel channel) {
+    private void close(TCPChannel channel) {
         try {
-            channel.getPipeline().getContext(NettyAsyncHttpProvider.class).setAttachment(new NettyAsyncHttpProvider.DiscardEvent());
-            channel2CreationDate.remove(channel);
-            channel.close();
+        	openChannels.remove(channel);
+        	channel.close();
         } catch (Throwable t) {
             // noop
         }
     }
 
     public final String toString() {
-        return String.format("NettyConnectionPool: {pool-size: %d}", channel2IdleChannel.size());
+        return String.format("NettyConnectionPool: {pool-size: %d}", openChannels.size());
+    }
+    
+    private class IdleChannelDetector extends TimerTask {
+        @Override
+        public void run() {
+            try {
+                if (isClosed.get()) return;
+
+                if (log.isDebugEnabled()) {
+                    Set<String> keys = connectionsPool.keySet();
+
+                    for (String s : keys) {
+                        log.debug("Entry count for : {} : {}", s, connectionsPool.get(s).size());
+                    }
+                }
+
+                List<TCPChannel> channelsInTimeout = new ArrayList<TCPChannel>();
+                long currentTime = System.currentTimeMillis();
+
+                for (TCPChannel idleChannel : openChannels) {
+                	long start = (Long) idleChannel.getSession().get("createTime");
+                    long age = currentTime - start;
+                    if (age > maxIdleTime) {
+
+                        log.debug("Adding Candidate Idle Channel {}", idleChannel);
+
+                        // store in an unsynchronized list to minimize the impact on the ConcurrentHashMap.
+                        channelsInTimeout.add(idleChannel);
+                    }
+                }
+                long endConcurrentLoop = System.currentTimeMillis();
+
+                for (TCPChannel idleChannel : channelsInTimeout) {
+                    if (remove(idleChannel)) {
+                        log.debug("Closing Idle Channel {}", idleChannel);
+                        close(idleChannel);
+                    }
+                }
+
+                if (log.isTraceEnabled())
+                    log.trace(String.format("%d channel open, %d idle channels closed (times: 1st-loop=%d, 2nd-loop=%d).\n",
+                        connectionsPool.size(), channelsInTimeout.size(), endConcurrentLoop - currentTime, System.currentTimeMillis() - endConcurrentLoop));
+            } catch (Throwable t) {
+                log.error("uncaught exception!", t);
+            }
+        }
     }
+
 }
diff --git a/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/NettyResponseFuture.java b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/ChanMgrResponseFuture.java
similarity index 95%
rename from providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/NettyResponseFuture.java
rename to providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/ChanMgrResponseFuture.java
index 9daee180c..5cec14660 100755
--- a/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/NettyResponseFuture.java
+++ b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/ChanMgrResponseFuture.java
@@ -43,9 +43,9 @@
  *
  * @param <V>
  */
-public final class NettyResponseFuture<V> extends AbstractListenableFuture<V> {
+public final class ChanMgrResponseFuture<V> extends AbstractListenableFuture<V> {
 
-    private final static Logger logger = LoggerFactory.getLogger(NettyResponseFuture.class);
+    private final static Logger logger = LoggerFactory.getLogger(ChanMgrResponseFuture.class);
     public final static String MAX_RETRY = "com.ning.http.client.providers.netty.maxRetry";
 
     enum STATE {
@@ -74,7 +74,7 @@
     private final AtomicBoolean statusReceived = new AtomicBoolean(false);
     private final AtomicLong touch = new AtomicLong(System.currentTimeMillis());
     private final long start = System.currentTimeMillis();
-    private final NettyAsyncHttpProvider asyncHttpProvider;
+    private final ChanMgrAsyncHttpProvider asyncHttpProvider;
     private final AtomicReference<STATE> state = new AtomicReference<STATE>(STATE.NEW);
     private final AtomicBoolean contentProcessed = new AtomicBoolean(false);
     private Channel channel;
@@ -86,13 +86,13 @@
     private final AtomicBoolean throwableCalled = new AtomicBoolean(false);
     private boolean allowConnect = false;
 
-    public NettyResponseFuture(URI uri,
+    public ChanMgrResponseFuture(URI uri,
                                Request request,
                                AsyncHandler<V> asyncHandler,
                                HttpRequest nettyRequest,
                                int responseTimeoutInMs,
                                int idleConnectionTimeoutInMs,
-                               NettyAsyncHttpProvider asyncHttpProvider) {
+                               ChanMgrAsyncHttpProvider asyncHttpProvider) {
 
         this.asyncHandler = asyncHandler;
         this.responseTimeoutInMs = responseTimeoutInMs;
@@ -149,7 +149,7 @@ public boolean cancel(boolean force) {
         if (isCancelled.get()) return false;
 
         try {
-            channel.getPipeline().getContext(NettyAsyncHttpProvider.class).setAttachment(new NettyAsyncHttpProvider.DiscardEvent());
+            channel.getPipeline().getContext(ChanMgrAsyncHttpProvider.class).setAttachment(new ChanMgrAsyncHttpProvider.DiscardEvent());
             channel.close();
         } catch (Throwable t) {
             // Ignore
@@ -213,7 +213,7 @@ public V get(long l, TimeUnit tu) throws InterruptedException, TimeoutException,
             if (expired) {
                 isCancelled.set(true);
                 try {
-                    channel.getPipeline().getContext(NettyAsyncHttpProvider.class).setAttachment(new NettyAsyncHttpProvider.DiscardEvent());
+                    channel.getPipeline().getContext(ChanMgrAsyncHttpProvider.class).setAttachment(new ChanMgrAsyncHttpProvider.DiscardEvent());
                     channel.close();
                 } catch (Throwable t) {
                     // Ignore
@@ -407,7 +407,7 @@ public boolean getAndSetWriteBody(boolean writeBody) {
         return b;
     }
 
-    protected NettyAsyncHttpProvider provider() {
+    protected ChanMgrAsyncHttpProvider provider() {
         return asyncHttpProvider;
     }
 
diff --git a/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/NettyAsyncHttpProvider.java b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/NettyAsyncHttpProvider.java
deleted file mode 100644
index c61412ea8..000000000
--- a/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/NettyAsyncHttpProvider.java
+++ /dev/null
@@ -1,2474 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package com.ning.http.client.providers.chanmgr;
-
-import com.ning.http.client.AsyncHandler;
-import com.ning.http.client.AsyncHandler.STATE;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.AsyncHttpProvider;
-import com.ning.http.client.Body;
-import com.ning.http.client.BodyGenerator;
-import com.ning.http.client.ConnectionsPool;
-import com.ning.http.client.Cookie;
-import com.ning.http.client.FluentCaseInsensitiveStringsMap;
-import com.ning.http.client.HttpResponseBodyPart;
-import com.ning.http.client.HttpResponseHeaders;
-import com.ning.http.client.HttpResponseStatus;
-import com.ning.http.client.ListenableFuture;
-import com.ning.http.client.MaxRedirectException;
-import com.ning.http.client.PerRequestConfig;
-import com.ning.http.client.ProgressAsyncHandler;
-import com.ning.http.client.ProxyServer;
-import com.ning.http.client.RandomAccessBody;
-import com.ning.http.client.Realm;
-import com.ning.http.client.Request;
-import com.ning.http.client.RequestBuilder;
-import com.ning.http.client.Response;
-import com.ning.http.client.filter.FilterContext;
-import com.ning.http.client.filter.FilterException;
-import com.ning.http.client.filter.IOExceptionFilter;
-import com.ning.http.client.filter.ResponseFilter;
-import com.ning.http.client.generators.InputStreamBodyGenerator;
-import com.ning.http.client.listener.TransferCompletionHandler;
-import com.ning.http.client.ntlm.NTLMEngine;
-import com.ning.http.client.ntlm.NTLMEngineException;
-import com.ning.http.client.providers.chanmgr.FeedableBodyGenerator.FeedListener;
-import com.ning.http.client.providers.chanmgr.spnego.SpnegoEngine;
-import com.ning.http.client.providers.chanmgr.util.CleanupChannelGroup;
-import com.ning.http.client.websocket.WebSocketUpgradeHandler;
-import com.ning.http.multipart.MultipartBody;
-import com.ning.http.multipart.MultipartRequestEntity;
-import com.ning.http.util.AsyncHttpProviderUtils;
-import com.ning.http.util.AuthenticatorUtils;
-import com.ning.http.util.ProxyUtils;
-import com.ning.http.util.SslUtils;
-import com.ning.http.util.UTF8UrlEncoder;
-import org.jboss.netty.bootstrap.ClientBootstrap;
-import org.jboss.netty.buffer.ChannelBuffer;
-import org.jboss.netty.buffer.ChannelBufferOutputStream;
-import org.jboss.netty.buffer.ChannelBuffers;
-import org.jboss.netty.channel.Channel;
-import org.jboss.netty.channel.ChannelFuture;
-import org.jboss.netty.channel.ChannelFutureProgressListener;
-import org.jboss.netty.channel.ChannelHandlerContext;
-import org.jboss.netty.channel.ChannelPipeline;
-import org.jboss.netty.channel.ChannelPipelineFactory;
-import org.jboss.netty.channel.ChannelStateEvent;
-import org.jboss.netty.channel.DefaultChannelFuture;
-import org.jboss.netty.channel.ExceptionEvent;
-import org.jboss.netty.channel.FileRegion;
-import org.jboss.netty.channel.MessageEvent;
-import org.jboss.netty.channel.SimpleChannelUpstreamHandler;
-import org.jboss.netty.channel.group.ChannelGroup;
-import org.jboss.netty.channel.socket.ClientSocketChannelFactory;
-import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;
-import org.jboss.netty.channel.socket.oio.OioClientSocketChannelFactory;
-import org.jboss.netty.handler.codec.http.CookieEncoder;
-import org.jboss.netty.handler.codec.http.DefaultCookie;
-import org.jboss.netty.handler.codec.http.DefaultHttpChunkTrailer;
-import org.jboss.netty.handler.codec.http.DefaultHttpRequest;
-import org.jboss.netty.handler.codec.http.HttpChunk;
-import org.jboss.netty.handler.codec.http.HttpChunkTrailer;
-import org.jboss.netty.handler.codec.http.HttpClientCodec;
-import org.jboss.netty.handler.codec.http.HttpContentCompressor;
-import org.jboss.netty.handler.codec.http.HttpContentDecompressor;
-import org.jboss.netty.handler.codec.http.HttpHeaders;
-import org.jboss.netty.handler.codec.http.HttpMethod;
-import org.jboss.netty.handler.codec.http.HttpRequest;
-import org.jboss.netty.handler.codec.http.HttpRequestEncoder;
-import org.jboss.netty.handler.codec.http.HttpResponse;
-import org.jboss.netty.handler.codec.http.HttpResponseDecoder;
-import org.jboss.netty.handler.codec.http.HttpVersion;
-import org.jboss.netty.handler.codec.http.websocketx.CloseWebSocketFrame;
-import org.jboss.netty.handler.codec.http.websocketx.WebSocket08FrameDecoder;
-import org.jboss.netty.handler.codec.http.websocketx.WebSocket08FrameEncoder;
-import org.jboss.netty.handler.codec.http.websocketx.WebSocketFrame;
-import org.jboss.netty.handler.ssl.SslHandler;
-import org.jboss.netty.handler.stream.ChunkedFile;
-import org.jboss.netty.handler.stream.ChunkedWriteHandler;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import javax.net.ssl.SSLEngine;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.RandomAccessFile;
-import java.net.ConnectException;
-import java.net.InetSocketAddress;
-import java.net.MalformedURLException;
-import java.net.URI;
-import java.nio.channels.ClosedChannelException;
-import java.nio.channels.FileChannel;
-import java.nio.channels.WritableByteChannel;
-import java.nio.charset.Charset;
-import java.security.GeneralSecurityException;
-import java.security.NoSuchAlgorithmException;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map.Entry;
-import java.util.concurrent.Callable;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import java.util.concurrent.RejectedExecutionException;
-import java.util.concurrent.Semaphore;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-import java.util.concurrent.atomic.AtomicBoolean;
-
-import static com.ning.http.util.AsyncHttpProviderUtils.DEFAULT_CHARSET;
-import static org.jboss.netty.channel.Channels.pipeline;
-
-public class NettyAsyncHttpProvider extends SimpleChannelUpstreamHandler implements AsyncHttpProvider {
-    private final static String WEBSOCKET_KEY = "Sec-WebSocket-Key";
-    private final static String HTTP_HANDLER = "httpHandler";
-    protected final static String SSL_HANDLER = "sslHandler";
-    private final static String HTTPS = "https";
-    private final static String HTTP = "http";
-    private static final String WEBSOCKET = "ws";
-    private static final String WEBSOCKET_SSL = "wss";
-
-    private final static Logger log = LoggerFactory.getLogger(NettyAsyncHttpProvider.class);
-    private final static Charset UTF8 = Charset.forName("UTF-8");
-
-    private final ClientBootstrap plainBootstrap;
-    private final ClientBootstrap secureBootstrap;
-    private final ClientBootstrap webSocketBootstrap;
-    private final ClientBootstrap secureWebSocketBootstrap;
-    private final static int MAX_BUFFERED_BYTES = 8192;
-    private final AsyncHttpClientConfig config;
-    private final AtomicBoolean isClose = new AtomicBoolean(false);
-    private final ClientSocketChannelFactory socketChannelFactory;
-
-    private final ChannelGroup openChannels = new
-            CleanupChannelGroup("asyncHttpClient") {
-                @Override
-                public boolean remove(Object o) {
-                    boolean removed = super.remove(o);
-                    if (removed && trackConnections) {
-                        freeConnections.release();
-                    }
-                    return removed;
-                }
-            };
-    private final ConnectionsPool<String, Channel> connectionsPool;
-    private Semaphore freeConnections = null;
-    private final NettyAsyncHttpProviderConfig asyncHttpProviderConfig;
-    private boolean executeConnectAsync = true;
-    public static final ThreadLocal<Boolean> IN_IO_THREAD = new ThreadLocalBoolean();
-    private final boolean trackConnections;
-    private final boolean useRawUrl;
-    private final static NTLMEngine ntlmEngine = new NTLMEngine();
-    private final static SpnegoEngine spnegoEngine = new SpnegoEngine();
-    private final Protocol httpProtocol = new HttpProtocol();
-    private final Protocol webSocketProtocol = new WebSocketProtocol();
-
-    public NettyAsyncHttpProvider(AsyncHttpClientConfig config) {
-
-        if (config.getAsyncHttpProviderConfig() != null
-                && NettyAsyncHttpProviderConfig.class.isAssignableFrom(config.getAsyncHttpProviderConfig().getClass())) {
-            asyncHttpProviderConfig = NettyAsyncHttpProviderConfig.class.cast(config.getAsyncHttpProviderConfig());
-        } else {
-            asyncHttpProviderConfig = new NettyAsyncHttpProviderConfig();
-        }
-
-        if (asyncHttpProviderConfig.getProperty(NettyAsyncHttpProviderConfig.USE_BLOCKING_IO) != null) {
-            socketChannelFactory = new OioClientSocketChannelFactory(config.executorService());
-        } else {
-            ExecutorService e;
-            Object o = asyncHttpProviderConfig.getProperty(NettyAsyncHttpProviderConfig.BOSS_EXECUTOR_SERVICE);
-            if (o != null && ExecutorService.class.isAssignableFrom(o.getClass())) {
-                e = ExecutorService.class.cast(o);
-            } else {
-                e = Executors.newCachedThreadPool();
-            }
-            int numWorkers = config.getIoThreadMultiplier() * Runtime.getRuntime().availableProcessors();
-            log.debug("Number of application's worker threads is {}", numWorkers);
-            socketChannelFactory = new NioClientSocketChannelFactory(e, config.executorService(), numWorkers);
-        }
-        plainBootstrap = new ClientBootstrap(socketChannelFactory);
-        secureBootstrap = new ClientBootstrap(socketChannelFactory);
-        webSocketBootstrap = new ClientBootstrap(socketChannelFactory);
-        secureWebSocketBootstrap = new ClientBootstrap(socketChannelFactory);
-        configureNetty();
-
-        this.config = config;
-
-        // This is dangerous as we can't catch a wrong typed ConnectionsPool
-        ConnectionsPool<String, Channel> cp = (ConnectionsPool<String, Channel>) config.getConnectionsPool();
-        if (cp == null && config.getAllowPoolingConnection()) {
-            cp = new NettyConnectionsPool(this);
-        } else if (cp == null) {
-            cp = new NonConnectionsPool();
-        }
-        this.connectionsPool = cp;
-
-        if (config.getMaxTotalConnections() != -1) {
-            trackConnections = true;
-            freeConnections = new Semaphore(config.getMaxTotalConnections());
-        } else {
-            trackConnections = false;
-        }
-
-        useRawUrl = config.isUseRawUrl();
-    }
-
-    @Override
-    public String toString() {
-        return String.format("NettyAsyncHttpProvider:\n\t- maxConnections: %d\n\t- openChannels: %s\n\t- connectionPools: %s",
-                config.getMaxTotalConnections() - freeConnections.availablePermits(),
-                openChannels.toString(),
-                connectionsPool.toString());
-    }
-
-    void configureNetty() {
-        if (asyncHttpProviderConfig != null) {
-            for (Entry<String, Object> entry : asyncHttpProviderConfig.propertiesSet()) {
-                plainBootstrap.setOption(entry.getKey(), entry.getValue());
-            }
-        }
-
-        plainBootstrap.setPipelineFactory(new ChannelPipelineFactory() {
-
-            /* @Override */
-            public ChannelPipeline getPipeline() throws Exception {
-                ChannelPipeline pipeline = pipeline();
-
-                pipeline.addLast(HTTP_HANDLER, new HttpClientCodec());
-
-                if (config.getRequestCompressionLevel() > 0) {
-                    pipeline.addLast("deflater", new HttpContentCompressor(config.getRequestCompressionLevel()));
-                }
-
-                if (config.isCompressionEnabled()) {
-                    pipeline.addLast("inflater", new HttpContentDecompressor());
-                }
-                pipeline.addLast("chunkedWriter", new ChunkedWriteHandler());
-                pipeline.addLast("httpProcessor", NettyAsyncHttpProvider.this);
-                return pipeline;
-            }
-        });
-        DefaultChannelFuture.setUseDeadLockChecker(false);
-
-        if (asyncHttpProviderConfig != null) {
-            Object value = asyncHttpProviderConfig.getProperty(NettyAsyncHttpProviderConfig.EXECUTE_ASYNC_CONNECT);
-            if (value != null && Boolean.class.isAssignableFrom(value.getClass())) {
-                executeConnectAsync = Boolean.class.cast(value);
-            } else if (asyncHttpProviderConfig.getProperty(NettyAsyncHttpProviderConfig.DISABLE_NESTED_REQUEST) != null) {
-                DefaultChannelFuture.setUseDeadLockChecker(true);
-            }
-        }
-
-        webSocketBootstrap.setPipelineFactory(new ChannelPipelineFactory() {
-
-            /* @Override */
-            public ChannelPipeline getPipeline() throws Exception {
-                ChannelPipeline pipeline = pipeline();
-                pipeline.addLast("ws-decoder", new HttpResponseDecoder());
-                pipeline.addLast("ws-encoder", new HttpRequestEncoder());
-                pipeline.addLast("httpProcessor", NettyAsyncHttpProvider.this);
-                return pipeline;
-            }
-        });
-    }
-
-    void constructSSLPipeline(final NettyConnectListener<?> cl) {
-
-        secureBootstrap.setPipelineFactory(new ChannelPipelineFactory() {
-
-            /* @Override */
-            public ChannelPipeline getPipeline() throws Exception {
-                ChannelPipeline pipeline = pipeline();
-
-                try {
-                    pipeline.addLast(SSL_HANDLER, new SslHandler(createSSLEngine()));
-                } catch (Throwable ex) {
-                    abort(cl.future(), ex);
-                }
-
-                pipeline.addLast(HTTP_HANDLER, new HttpClientCodec());
-
-                if (config.isCompressionEnabled()) {
-                    pipeline.addLast("inflater", new HttpContentDecompressor());
-                }
-                pipeline.addLast("chunkedWriter", new ChunkedWriteHandler());
-                pipeline.addLast("httpProcessor", NettyAsyncHttpProvider.this);
-                return pipeline;
-            }
-        });
-
-        secureWebSocketBootstrap.setPipelineFactory(new ChannelPipelineFactory() {
-
-            /* @Override */
-            public ChannelPipeline getPipeline() throws Exception {
-                ChannelPipeline pipeline = pipeline();
-
-                try {
-                    pipeline.addLast(SSL_HANDLER, new SslHandler(createSSLEngine()));
-                } catch (Throwable ex) {
-                    abort(cl.future(), ex);
-                }
-
-                pipeline.addLast("ws-decoder", new HttpResponseDecoder());
-                pipeline.addLast("ws-encoder", new HttpRequestEncoder());
-                pipeline.addLast("httpProcessor", NettyAsyncHttpProvider.this);
-
-                return pipeline;
-            }
-        });
-
-        if (asyncHttpProviderConfig != null) {
-            for (Entry<String, Object> entry : asyncHttpProviderConfig.propertiesSet()) {
-                secureBootstrap.setOption(entry.getKey(), entry.getValue());
-                secureWebSocketBootstrap.setOption(entry.getKey(), entry.getValue());
-            }
-        }
-    }
-
-    private Channel lookupInCache(URI uri) {
-        final Channel channel = connectionsPool.poll(AsyncHttpProviderUtils.getBaseUrl(uri));
-
-        if (channel != null) {
-            log.debug("Using cached Channel {}\n for uri {}\n", channel, uri);
-
-            try {
-                // Always make sure the channel who got cached support the proper protocol. It could
-                // only occurs when a HttpMethod.CONNECT is used agains a proxy that require upgrading from http to
-                // https.
-                return verifyChannelPipeline(channel, uri.getScheme());
-            } catch (Exception ex) {
-                log.debug(ex.getMessage(), ex);
-            }
-        }
-        return null;
-    }
-
-    private SSLEngine createSSLEngine() throws IOException, GeneralSecurityException {
-        SSLEngine sslEngine = config.getSSLEngineFactory().newSSLEngine();
-        if (sslEngine == null) {
-            sslEngine = SslUtils.getSSLEngine();
-        }
-        return sslEngine;
-    }
-
-    private Channel verifyChannelPipeline(Channel channel, String scheme) throws IOException, GeneralSecurityException {
-
-        if (channel.getPipeline().get(SSL_HANDLER) != null && HTTP.equalsIgnoreCase(scheme)) {
-            channel.getPipeline().remove(SSL_HANDLER);
-        } else if (channel.getPipeline().get(HTTP_HANDLER) != null && HTTP.equalsIgnoreCase(scheme)) {
-            return channel;
-        } else if (channel.getPipeline().get(SSL_HANDLER) == null && isSecure(scheme)) {
-            channel.getPipeline().addFirst(SSL_HANDLER, new SslHandler(createSSLEngine()));
-        }
-        return channel;
-    }
-
-    protected final <T> void writeRequest(final Channel channel,
-                                          final AsyncHttpClientConfig config,
-                                          final NettyResponseFuture<T> future,
-                                          final HttpRequest nettyRequest) {
-        try {
-            /**
-             * If the channel is dead because it was pooled and the remote server decided to close it,
-             * we just let it go and the closeChannel do it's work.
-             */
-            if (!channel.isOpen() || !channel.isConnected()) {
-                return;
-            }
-
-            Body body = null;
-            if (!future.getNettyRequest().getMethod().equals(HttpMethod.CONNECT)) {
-                BodyGenerator bg = future.getRequest().getBodyGenerator();
-                if (bg != null) {
-                    // Netty issue with chunking.
-                    if (InputStreamBodyGenerator.class.isAssignableFrom(bg.getClass())) {
-                        InputStreamBodyGenerator.class.cast(bg).patchNettyChunkingIssue(true);
-                    }
-
-                    try {
-                        body = bg.createBody();
-                    } catch (IOException ex) {
-                        throw new IllegalStateException(ex);
-                    }
-                    long length = body.getContentLength();
-                    if (length >= 0) {
-                        nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, length);
-                    } else {
-                        nettyRequest.setHeader(HttpHeaders.Names.TRANSFER_ENCODING, HttpHeaders.Values.CHUNKED);
-                    }
-                } else {
-                    body = null;
-                }
-            }
-
-            if (TransferCompletionHandler.class.isAssignableFrom(future.getAsyncHandler().getClass())) {
-
-                FluentCaseInsensitiveStringsMap h = new FluentCaseInsensitiveStringsMap();
-                for (String s : future.getNettyRequest().getHeaderNames()) {
-                    for (String header : future.getNettyRequest().getHeaders(s)) {
-                        h.add(s, header);
-                    }
-                }
-
-                TransferCompletionHandler.class.cast(future.getAsyncHandler()).transferAdapter(
-                        new NettyTransferAdapter(h, nettyRequest.getContent(), future.getRequest().getFile()));
-            }
-
-            // Leave it to true.
-            if (future.getAndSetWriteHeaders(true)) {
-                try {
-                    channel.write(nettyRequest).addListener(new ProgressListener(true, future.getAsyncHandler(), future));
-                } catch (Throwable cause) {
-                    log.debug(cause.getMessage(), cause);
-                    try {
-                        channel.close();
-                    } catch (RuntimeException ex) {
-                        log.debug(ex.getMessage(), ex);
-                    }
-                    return;
-                }
-            }
-
-            if (future.getAndSetWriteBody(true)) {
-                if (!future.getNettyRequest().getMethod().equals(HttpMethod.CONNECT)) {
-
-                    if (future.getRequest().getFile() != null) {
-                        final File file = future.getRequest().getFile();
-                        long fileLength = 0;
-                        final RandomAccessFile raf = new RandomAccessFile(file, "r");
-
-                        try {
-                            fileLength = raf.length();
-
-                            ChannelFuture writeFuture;
-                            if (channel.getPipeline().get(SslHandler.class) != null) {
-                                writeFuture = channel.write(new ChunkedFile(raf, 0, fileLength, 8192));
-                            } else {
-                                final FileRegion region = new OptimizedFileRegion(raf, 0, fileLength);
-                                writeFuture = channel.write(region);
-                            }
-                            writeFuture.addListener(new ProgressListener(false, future.getAsyncHandler(), future));
-                        } catch (IOException ex) {
-                            if (raf != null) {
-                                try {
-                                    raf.close();
-                                } catch (IOException e) {
-                                }
-                            }
-                            throw ex;
-                        }
-                    } else if (body != null || future.getRequest().getParts() != null) {
-                        /**
-                         * TODO: AHC-78: SSL + zero copy isn't supported by the MultiPart class and pretty complex to implements.
-                         */
-                        if (future.getRequest().getParts() != null) {
-                            String boundary = future.getNettyRequest().getHeader("Content-Type");
-                            String length = future.getNettyRequest().getHeader("Content-Length");
-                            body = new MultipartBody(future.getRequest().getParts(), boundary, length);
-                        }
-
-                        ChannelFuture writeFuture;
-                        if (channel.getPipeline().get(SslHandler.class) == null && (body instanceof RandomAccessBody)) {
-                            BodyFileRegion bodyFileRegion = new BodyFileRegion((RandomAccessBody) body);
-                            writeFuture = channel.write(bodyFileRegion);
-                        } else {
-                            BodyChunkedInput bodyChunkedInput = new BodyChunkedInput(body);
-                            BodyGenerator bg = future.getRequest().getBodyGenerator();
-                                if (bg instanceof FeedableBodyGenerator) {
-                                    ((FeedableBodyGenerator)bg).setListener(new FeedListener() {
-                                        @Override public void onContentAdded() {
-                                            channel.getPipeline().get(ChunkedWriteHandler.class).resumeTransfer();
-                                        }
-                                    });
-                                }
-                            writeFuture = channel.write(bodyChunkedInput);
-                        }
-
-                        final Body b = body;
-                        writeFuture.addListener(new ProgressListener(false, future.getAsyncHandler(), future) {
-                            public void operationComplete(ChannelFuture cf) {
-                                try {
-                                    b.close();
-                                } catch (IOException e) {
-                                    log.warn("Failed to close request body: {}", e.getMessage(), e);
-                                }
-                                super.operationComplete(cf);
-                            }
-                        });
-                    }
-                }
-            }
-        } catch (Throwable ioe) {
-            try {
-                channel.close();
-            } catch (RuntimeException ex) {
-                log.debug(ex.getMessage(), ex);
-            }
-        }
-
-        try {
-            future.touch();
-            int delay = requestTimeout(config, future.getRequest().getPerRequestConfig());
-            if (delay != -1 && !future.isDone() && !future.isCancelled()) {
-                ReaperFuture reaperFuture = new ReaperFuture(future);
-                Future<?> scheduledFuture = config.reaper().scheduleAtFixedRate(reaperFuture, 0, delay, TimeUnit.MILLISECONDS);
-                reaperFuture.setScheduledFuture(scheduledFuture);
-                future.setReaperFuture(reaperFuture);
-            }
-        } catch (RejectedExecutionException ex) {
-            abort(future, ex);
-        }
-
-    }
-
-    private static boolean isProxyServer(AsyncHttpClientConfig config, Request request) {
-        return request.getProxyServer() != null || config.getProxyServer() != null;
-    }
-
-    protected final static HttpRequest buildRequest(AsyncHttpClientConfig config, Request request, URI uri,
-                                                    boolean allowConnect, ChannelBuffer buffer) throws IOException {
-
-        String method = request.getMethod();
-        if (allowConnect && (isProxyServer(config, request) && isSecure(uri))) {
-            method = HttpMethod.CONNECT.toString();
-        }
-        return construct(config, request, new HttpMethod(method), uri, buffer);
-    }
-
-    private static HttpRequest construct(AsyncHttpClientConfig config,
-                                         Request request,
-                                         HttpMethod m,
-                                         URI uri,
-                                         ChannelBuffer buffer) throws IOException {
-
-        String host = AsyncHttpProviderUtils.getHost(uri);
-        boolean webSocket = isWebSocket(uri);
-
-        if (request.getVirtualHost() != null) {
-            host = request.getVirtualHost();
-        }
-
-        HttpRequest nettyRequest;
-        if (m.equals(HttpMethod.CONNECT)) {
-            nettyRequest = new DefaultHttpRequest(HttpVersion.HTTP_1_0, m, AsyncHttpProviderUtils.getAuthority(uri));
-        } else {
-            StringBuilder path = null;
-            if (isProxyServer(config, request))
-                path = new StringBuilder(uri.toString());
-            else {
-                path = new StringBuilder(uri.getRawPath());
-                if (uri.getQuery() != null) {
-                    path.append("?").append(uri.getRawQuery());
-                }
-            }
-            nettyRequest = new DefaultHttpRequest(HttpVersion.HTTP_1_1, m, path.toString());
-        }
-
-        if (webSocket) {
-            nettyRequest.addHeader(HttpHeaders.Names.UPGRADE, HttpHeaders.Values.WEBSOCKET);
-            nettyRequest.addHeader(HttpHeaders.Names.CONNECTION, HttpHeaders.Values.UPGRADE);
-            nettyRequest.addHeader("Origin", "http://" + uri.getHost() + ":"
-                    + (uri.getPort() == -1 ? isSecure(uri.getScheme()) ? 443 : 80 : uri.getPort()));
-            nettyRequest.addHeader(WEBSOCKET_KEY, WebSocketUtil.getKey());
-            nettyRequest.addHeader("Sec-WebSocket-Version", "13");
-        }
-
-        if (host != null) {
-            if (uri.getPort() == -1) {
-                nettyRequest.setHeader(HttpHeaders.Names.HOST, host);
-            } else if (request.getVirtualHost() != null) {
-                nettyRequest.setHeader(HttpHeaders.Names.HOST, host);
-            } else {
-                nettyRequest.setHeader(HttpHeaders.Names.HOST, host + ":" + uri.getPort());
-            }
-        } else {
-            host = "127.0.0.1";
-        }
-
-        if (!m.equals(HttpMethod.CONNECT)) {
-            FluentCaseInsensitiveStringsMap h = request.getHeaders();
-            if (h != null) {
-                for (String name : h.keySet()) {
-                    if (!"host".equalsIgnoreCase(name)) {
-                        for (String value : h.get(name)) {
-                            nettyRequest.addHeader(name, value);
-                        }
-                    }
-                }
-            }
-
-            if (config.isCompressionEnabled()) {
-                nettyRequest.setHeader(HttpHeaders.Names.ACCEPT_ENCODING, HttpHeaders.Values.GZIP);
-            }
-        } else {
-            List<String> auth = request.getHeaders().get(HttpHeaders.Names.PROXY_AUTHORIZATION);
-            if (auth != null && auth.size() > 0 && auth.get(0).startsWith("NTLM")) {
-                nettyRequest.addHeader(HttpHeaders.Names.PROXY_AUTHORIZATION, auth.get(0));
-            }
-        }
-        ProxyServer proxyServer = request.getProxyServer() != null ? request.getProxyServer() : config.getProxyServer();
-        Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
-
-        if (realm != null && realm.getUsePreemptiveAuth()) {
-
-            String domain = realm.getNtlmDomain();
-            if (proxyServer != null && proxyServer.getNtlmDomain() != null) {
-                domain = proxyServer.getNtlmDomain();
-            }
-
-            String authHost = realm.getNtlmHost();
-            if (proxyServer != null && proxyServer.getHost() != null) {
-                host = proxyServer.getHost();
-            }
-
-            switch (realm.getAuthScheme()) {
-                case BASIC:
-                    nettyRequest.setHeader(HttpHeaders.Names.AUTHORIZATION,
-                            AuthenticatorUtils.computeBasicAuthentication(realm));
-                    break;
-                case DIGEST:
-                    if (realm.getNonce() != null && !realm.getNonce().equals("")) {
-                        try {
-                            nettyRequest.setHeader(HttpHeaders.Names.AUTHORIZATION,
-                                    AuthenticatorUtils.computeDigestAuthentication(realm));
-                        } catch (NoSuchAlgorithmException e) {
-                            throw new SecurityException(e);
-                        }
-                    }
-                    break;
-                case NTLM:
-                    try {
-                        String msg = ntlmEngine.generateType1Msg("NTLM " + domain, authHost);
-                        nettyRequest.setHeader(HttpHeaders.Names.AUTHORIZATION, "NTLM " + msg);
-                    } catch (NTLMEngineException e) {
-                        IOException ie = new IOException();
-                        ie.initCause(e);
-                        throw ie;
-                    }
-                    break;
-                case KERBEROS:
-                case SPNEGO:
-                    String challengeHeader = null;
-                    String server = proxyServer == null ? host : proxyServer.getHost();
-                    try {
-                        challengeHeader = spnegoEngine.generateToken(server);
-                    } catch (Throwable e) {
-                        IOException ie = new IOException();
-                        ie.initCause(e);
-                        throw ie;
-                    }
-                    nettyRequest.setHeader(HttpHeaders.Names.AUTHORIZATION, "Negotiate " + challengeHeader);
-                    break;
-                case NONE:
-                    break;
-                default:
-                    throw new IllegalStateException(String.format("Invalid Authentication %s", realm.toString()));
-            }
-        }
-
-        if (!webSocket && !request.getHeaders().containsKey(HttpHeaders.Names.CONNECTION)) {
-            nettyRequest.setHeader(HttpHeaders.Names.CONNECTION, "keep-alive");
-        }
-
-        boolean avoidProxy = ProxyUtils.avoidProxy(proxyServer, request);
-        if (!avoidProxy) {
-            if (!request.getHeaders().containsKey("Proxy-Connection")) {
-                nettyRequest.setHeader("Proxy-Connection", "keep-alive");
-            }
-
-            if (proxyServer.getPrincipal() != null) {
-                if (proxyServer.getNtlmDomain() != null && proxyServer.getNtlmDomain().length() > 0) {
-
-                    List<String> auth = request.getHeaders().get(HttpHeaders.Names.PROXY_AUTHORIZATION);
-                    if (!(auth != null && auth.size() > 0 && auth.get(0).startsWith("NTLM"))) {
-                        try {
-                            String msg = ntlmEngine.generateType1Msg(proxyServer.getNtlmDomain(),
-                                    proxyServer.getHost());
-                            nettyRequest.setHeader(HttpHeaders.Names.PROXY_AUTHORIZATION, "NTLM " + msg);
-                        } catch (NTLMEngineException e) {
-                            IOException ie = new IOException();
-                            ie.initCause(e);
-                            throw ie;
-                        }
-                    }
-                } else {
-                    nettyRequest.setHeader(HttpHeaders.Names.PROXY_AUTHORIZATION,
-                            AuthenticatorUtils.computeBasicAuthentication(proxyServer));
-                }
-            }
-        }
-
-        // Add default accept headers.
-        if (request.getHeaders().getFirstValue("Accept") == null) {
-            nettyRequest.setHeader(HttpHeaders.Names.ACCEPT, "*/*");
-        }
-
-        if (request.getHeaders().getFirstValue("User-Agent") != null) {
-            nettyRequest.setHeader("User-Agent", request.getHeaders().getFirstValue("User-Agent"));
-        } else if (config.getUserAgent() != null) {
-            nettyRequest.setHeader("User-Agent", config.getUserAgent());
-        } else {
-            nettyRequest.setHeader("User-Agent",
-                         AsyncHttpProviderUtils.constructUserAgent(NettyAsyncHttpProvider.class,
-                                                                   config));
-        }
-
-        if (!m.equals(HttpMethod.CONNECT)) {
-            if (request.getCookies() != null && !request.getCookies().isEmpty()) {
-                CookieEncoder httpCookieEncoder = new CookieEncoder(false);
-                Iterator<Cookie> ic = request.getCookies().iterator();
-                Cookie c;
-                org.jboss.netty.handler.codec.http.Cookie cookie;
-                while (ic.hasNext()) {
-                    c = ic.next();
-                    cookie = new DefaultCookie(c.getName(), c.getValue());
-                    cookie.setPath(c.getPath());
-                    cookie.setMaxAge(c.getMaxAge());
-                    cookie.setDomain(c.getDomain());
-                    httpCookieEncoder.addCookie(cookie);
-                }
-                nettyRequest.setHeader(HttpHeaders.Names.COOKIE, httpCookieEncoder.encode());
-            }
-
-            String reqType = request.getMethod();
-            if (!"GET".equals(reqType) && !"HEAD".equals(reqType) && !"OPTION".equals(reqType) && !"TRACE".equals(reqType)) {
-
-                String bodyCharset = request.getBodyEncoding() == null ? DEFAULT_CHARSET : request.getBodyEncoding();
-
-                // We already have processed the body.
-                if (buffer != null && buffer.writerIndex() != 0) {
-                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, buffer.writerIndex());
-                    nettyRequest.setContent(buffer);
-                } else if (request.getByteData() != null) {
-                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(request.getByteData().length));
-                    nettyRequest.setContent(ChannelBuffers.wrappedBuffer(request.getByteData()));
-                } else if (request.getStringData() != null) {
-                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(request.getStringData().getBytes(bodyCharset).length));
-                    nettyRequest.setContent(ChannelBuffers.wrappedBuffer(request.getStringData().getBytes(bodyCharset)));
-                } else if (request.getStreamData() != null) {
-                    int[] lengthWrapper = new int[1];
-                    byte[] bytes = AsyncHttpProviderUtils.readFully(request.getStreamData(), lengthWrapper);
-                    int length = lengthWrapper[0];
-                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(length));
-                    nettyRequest.setContent(ChannelBuffers.wrappedBuffer(bytes, 0, length));
-                } else if (request.getParams() != null && !request.getParams().isEmpty()) {
-                    StringBuilder sb = new StringBuilder();
-                    for (final Entry<String, List<String>> paramEntry : request.getParams()) {
-                        final String key = paramEntry.getKey();
-                        for (final String value : paramEntry.getValue()) {
-                            if (sb.length() > 0) {
-                                sb.append("&");
-                            }
-                            UTF8UrlEncoder.appendEncoded(sb, key);
-                            sb.append("=");
-                            UTF8UrlEncoder.appendEncoded(sb, value);
-                        }
-                    }
-                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(sb.length()));
-                    nettyRequest.setContent(ChannelBuffers.wrappedBuffer(sb.toString().getBytes(bodyCharset)));
-
-                    if (!request.getHeaders().containsKey(HttpHeaders.Names.CONTENT_TYPE)) {
-                        nettyRequest.setHeader(HttpHeaders.Names.CONTENT_TYPE, "application/x-www-form-urlencoded");
-                    }
-
-                } else if (request.getParts() != null) {
-                    int lenght = computeAndSetContentLength(request, nettyRequest);
-
-                    if (lenght == -1) {
-                        lenght = MAX_BUFFERED_BYTES;
-                    }
-
-                    MultipartRequestEntity mre = AsyncHttpProviderUtils.createMultipartRequestEntity(request.getParts(), request.getParams());
-
-                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_TYPE, mre.getContentType());
-                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(mre.getContentLength()));
-
-                    /**
-                     * TODO: AHC-78: SSL + zero copy isn't supported by the MultiPart class and pretty complex to implements.
-                     */
-
-                    if (isSecure(uri)) {
-                        ChannelBuffer b = ChannelBuffers.dynamicBuffer(lenght);
-                        mre.writeRequest(new ChannelBufferOutputStream(b));
-                        nettyRequest.setContent(b);
-                    }
-                } else if (request.getEntityWriter() != null) {
-                    int lenght = computeAndSetContentLength(request, nettyRequest);
-
-                    if (lenght == -1) {
-                        lenght = MAX_BUFFERED_BYTES;
-                    }
-
-                    ChannelBuffer b = ChannelBuffers.dynamicBuffer(lenght);
-                    request.getEntityWriter().writeEntity(new ChannelBufferOutputStream(b));
-                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, b.writerIndex());
-                    nettyRequest.setContent(b);
-                } else if (request.getFile() != null) {
-                    File file = request.getFile();
-                    if (!file.isFile()) {
-                        throw new IOException(String.format("File %s is not a file or doesn't exist", file.getAbsolutePath()));
-                    }
-                    nettyRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, file.length());
-                }
-            }
-        }
-        return nettyRequest;
-    }
-
-    public void close() {
-        isClose.set(true);
-        try {
-            connectionsPool.destroy();
-            openChannels.close();
-
-            for (Channel channel : openChannels) {
-                ChannelHandlerContext ctx = channel.getPipeline().getContext(NettyAsyncHttpProvider.class);
-                if (ctx.getAttachment() instanceof NettyResponseFuture<?>) {
-                    NettyResponseFuture<?> future = (NettyResponseFuture<?>) ctx.getAttachment();
-                    future.setReaperFuture(null);
-                }
-            }
-
-            config.executorService().shutdown();
-            config.reaper().shutdown();
-            socketChannelFactory.releaseExternalResources();
-            plainBootstrap.releaseExternalResources();
-            secureBootstrap.releaseExternalResources();
-            webSocketBootstrap.releaseExternalResources();
-            secureWebSocketBootstrap.releaseExternalResources();
-        } catch (Throwable t) {
-            log.warn("Unexpected error on close", t);
-        }
-    }
-
-    /* @Override */
-
-    public Response prepareResponse(final HttpResponseStatus status,
-                                    final HttpResponseHeaders headers,
-                                    final List<HttpResponseBodyPart> bodyParts) {
-        return new NettyResponse(status, headers, bodyParts);
-    }
-
-    /* @Override */
-
-    public <T> ListenableFuture<T> execute(Request request, final AsyncHandler<T> asyncHandler) throws IOException {
-        return doConnect(request, asyncHandler, null, true, executeConnectAsync, false);
-    }
-
-    private <T> void execute(final Request request, final NettyResponseFuture<T> f, boolean useCache, boolean asyncConnect, boolean reclaimCache) throws IOException {
-        doConnect(request, f.getAsyncHandler(), f, useCache, asyncConnect, reclaimCache);
-    }
-
-    private <T> ListenableFuture<T> doConnect(final Request request, final AsyncHandler<T> asyncHandler, NettyResponseFuture<T> f,
-                                              boolean useCache, boolean asyncConnect, boolean reclaimCache) throws IOException {
-
-        if (isClose.get()) {
-            throw new IOException("Closed");
-        }
-
-        if (request.getUrl().startsWith(WEBSOCKET) && !validateWebSocketRequest(request, asyncHandler)) {
-            throw new IOException("WebSocket method must be a GET");
-        }
-
-        ProxyServer proxyServer = request.getProxyServer() != null ? request.getProxyServer() : config.getProxyServer();
-        String requestUrl;
-        if (useRawUrl) {
-            requestUrl = request.getRawUrl();
-        } else {
-            requestUrl = request.getUrl();
-        }
-        URI uri = AsyncHttpProviderUtils.createUri(requestUrl);
-        Channel channel = null;
-
-        if (useCache) {
-            if (f != null && f.reuseChannel() && f.channel() != null) {
-                channel = f.channel();
-            } else {
-                channel = lookupInCache(uri);
-            }
-        }
-
-        ChannelBuffer bufferedBytes = null;
-        if (f != null && f.getRequest().getFile() == null &&
-                !f.getNettyRequest().getMethod().getName().equals(HttpMethod.CONNECT.getName())) {
-            bufferedBytes = f.getNettyRequest().getContent();
-        }
-
-        boolean useSSl = isSecure(uri) && proxyServer == null;
-        if (channel != null && channel.isOpen() && channel.isConnected()) {
-            HttpRequest nettyRequest = buildRequest(config, request, uri, f == null ? false : f.isConnectAllowed(), bufferedBytes);
-
-            if (f == null) {
-                f = newFuture(uri, request, asyncHandler, nettyRequest, config, this);
-            } else {
-                nettyRequest = buildRequest(config, request, uri, f.isConnectAllowed(), bufferedBytes);
-                f.setNettyRequest(nettyRequest);
-            }
-            f.setState(NettyResponseFuture.STATE.POOLED);
-            f.attachChannel(channel, false);
-
-            log.debug("\nUsing cached Channel {}\n for request \n{}\n", channel, nettyRequest);
-            channel.getPipeline().getContext(NettyAsyncHttpProvider.class).setAttachment(f);
-
-            try {
-                writeRequest(channel, config, f, nettyRequest);
-            } catch (Exception ex) {
-                log.debug("writeRequest failure", ex);
-                if (useSSl && ex.getMessage() != null && ex.getMessage().contains("SSLEngine")) {
-                    log.debug("SSLEngine failure", ex);
-                    f = null;
-                } else {
-                    try {
-                        asyncHandler.onThrowable(ex);
-                    } catch (Throwable t) {
-                        log.warn("doConnect.writeRequest()", t);
-                    }
-                    IOException ioe = new IOException(ex.getMessage());
-                    ioe.initCause(ex);
-                    throw ioe;
-                }
-            }
-            return f;
-        }
-
-        // Do not throw an exception when we need an extra connection for a redirect.
-        if (!reclaimCache && !connectionsPool.canCacheConnection()) {
-            IOException ex = new IOException(String.format("Too many connections %s", config.getMaxTotalConnections()));
-            try {
-                asyncHandler.onThrowable(ex);
-            } catch (Throwable t) {
-                log.warn("!connectionsPool.canCacheConnection()", t);
-            }
-            throw ex;
-        }
-
-        boolean acquiredConnection = false;
-
-        if (trackConnections) {
-            if (!reclaimCache) {
-                if (!freeConnections.tryAcquire()) {
-                    IOException ex = new IOException(String.format("Too many connections %s", config.getMaxTotalConnections()));
-                    try {
-                        asyncHandler.onThrowable(ex);
-                    } catch (Throwable t) {
-                        log.warn("!connectionsPool.canCacheConnection()", t);
-                    }
-                    throw ex;
-                } else {
-                    acquiredConnection = true;
-                }
-            }
-        }
-
-        NettyConnectListener<T> c = new NettyConnectListener.Builder<T>(config, request, asyncHandler, f, this, bufferedBytes).build(uri);
-        boolean avoidProxy = ProxyUtils.avoidProxy(proxyServer, uri.getHost());
-
-        if (useSSl) {
-            constructSSLPipeline(c);
-        }
-
-        ChannelFuture channelFuture;
-        ClientBootstrap bootstrap = request.getUrl().startsWith(WEBSOCKET) ? (useSSl ? secureWebSocketBootstrap : webSocketBootstrap) : (useSSl ? secureBootstrap : plainBootstrap);
-        bootstrap.setOption("connectTimeoutMillis", config.getConnectionTimeoutInMs());
-
-        // Do no enable this with win.
-        if (System.getProperty("os.name").toLowerCase().indexOf("win") == -1) {
-            bootstrap.setOption("reuseAddress", asyncHttpProviderConfig.getProperty(NettyAsyncHttpProviderConfig.REUSE_ADDRESS));
-        }
-
-        try {
-            InetSocketAddress remoteAddress;
-            if (request.getInetAddress() != null) {
-                remoteAddress = new InetSocketAddress(request.getInetAddress(), AsyncHttpProviderUtils.getPort(uri));
-            } else if (proxyServer == null || avoidProxy) {
-                remoteAddress = new InetSocketAddress(AsyncHttpProviderUtils.getHost(uri), AsyncHttpProviderUtils.getPort(uri));
-            } else {
-                remoteAddress = new InetSocketAddress(proxyServer.getHost(), proxyServer.getPort());
-            }
-
-            if(request.getLocalAddress() != null){
-                channelFuture = bootstrap.connect(remoteAddress, new InetSocketAddress(request.getLocalAddress(), 0));
-            }else{
-                channelFuture = bootstrap.connect(remoteAddress);
-            }
-
-        } catch (Throwable t) {
-            if (acquiredConnection) {
-                freeConnections.release();
-            }
-            abort(c.future(), t.getCause() == null ? t : t.getCause());
-            return c.future();
-        }
-
-        boolean directInvokation = true;
-        if (IN_IO_THREAD.get() && DefaultChannelFuture.isUseDeadLockChecker()) {
-            directInvokation = false;
-        }
-
-        if (directInvokation && !asyncConnect && request.getFile() == null) {
-            int timeOut = config.getConnectionTimeoutInMs() > 0 ? config.getConnectionTimeoutInMs() : Integer.MAX_VALUE;
-            if (!channelFuture.awaitUninterruptibly(timeOut, TimeUnit.MILLISECONDS)) {
-                if (acquiredConnection) {
-                    freeConnections.release();
-                }
-                channelFuture.cancel();
-                abort(c.future(), new ConnectException(String.format("Connect operation to %s timeout %s", uri, timeOut)));
-            }
-
-            try {
-                c.operationComplete(channelFuture);
-            } catch (Exception e) {
-                if (acquiredConnection) {
-                    freeConnections.release();
-                }
-                IOException ioe = new IOException(e.getMessage());
-                ioe.initCause(e);
-                try {
-                    asyncHandler.onThrowable(ioe);
-                } catch (Throwable t) {
-                    log.warn("c.operationComplete()", t);
-                }
-                throw ioe;
-            }
-        } else {
-            channelFuture.addListener(c);
-        }
-
-        log.debug("\nNon cached request \n{}\n\nusing Channel \n{}\n", c.future().getNettyRequest(), channelFuture.getChannel());
-
-        if (!c.future().isCancelled() || !c.future().isDone()) {
-            openChannels.add(channelFuture.getChannel());
-            c.future().attachChannel(channelFuture.getChannel(), false);
-        }
-        return c.future();
-    }
-
-    protected static int requestTimeout(AsyncHttpClientConfig config, PerRequestConfig perRequestConfig) {
-        int result;
-        if (perRequestConfig != null) {
-            int prRequestTimeout = perRequestConfig.getRequestTimeoutInMs();
-            result = (prRequestTimeout != 0 ? prRequestTimeout : config.getRequestTimeoutInMs());
-        } else {
-            result = config.getRequestTimeoutInMs();
-        }
-        return result;
-    }
-
-    private void closeChannel(final ChannelHandlerContext ctx) {
-        connectionsPool.removeAll(ctx.getChannel());
-        finishChannel(ctx);
-    }
-
-    private void finishChannel(final ChannelHandlerContext ctx) {
-        ctx.setAttachment(new DiscardEvent());
-
-        // The channel may have already been removed if a timeout occurred, and this method may be called just after.
-        if (ctx.getChannel() == null) {
-            return;
-        }
-
-        log.debug("Closing Channel {} ", ctx.getChannel());
-
-
-        try {
-            ctx.getChannel().close();
-        } catch (Throwable t) {
-            log.debug("Error closing a connection", t);
-        }
-
-        if (ctx.getChannel() != null) {
-            openChannels.remove(ctx.getChannel());
-        }
-
-    }
-
-    @Override
-    public void messageReceived(final ChannelHandlerContext ctx, MessageEvent e) throws Exception {
-        //call super to reset the read timeout
-        super.messageReceived(ctx, e);
-        IN_IO_THREAD.set(Boolean.TRUE);
-        if (ctx.getAttachment() == null) {
-            log.debug("ChannelHandlerContext wasn't having any attachment");
-        }
-
-        if (ctx.getAttachment() instanceof DiscardEvent) {
-            return;
-        } else if (ctx.getAttachment() instanceof AsyncCallable) {
-            if (e.getMessage() instanceof HttpChunk) {
-                HttpChunk chunk = (HttpChunk) e.getMessage();
-                if (chunk.isLast()) {
-                    AsyncCallable ac = (AsyncCallable) ctx.getAttachment();
-                    ac.call();
-                } else {
-                    return;
-                }
-            } else {
-                AsyncCallable ac = (AsyncCallable) ctx.getAttachment();
-                ac.call();
-            }
-            ctx.setAttachment(new DiscardEvent());
-            return;
-        } else if (!(ctx.getAttachment() instanceof NettyResponseFuture<?>)) {
-            try {
-                ctx.getChannel().close();
-            } catch (Throwable t) {
-                log.trace("Closing an orphan channel {}", ctx.getChannel());
-            }
-            return;
-        }
-
-        Protocol p = (ctx.getPipeline().get(HttpClientCodec.class) != null ? httpProtocol : webSocketProtocol);
-        p.handle(ctx, e);
-    }
-
-    private Realm kerberosChallenge(List<String> proxyAuth,
-                                    Request request,
-                                    ProxyServer proxyServer,
-                                    FluentCaseInsensitiveStringsMap headers,
-                                    Realm realm,
-                                    NettyResponseFuture<?> future) throws NTLMEngineException {
-
-        URI uri = URI.create(request.getUrl());
-        String host = request.getVirtualHost() == null ? AsyncHttpProviderUtils.getHost(uri) : request.getVirtualHost();
-        String server = proxyServer == null ? host : proxyServer.getHost();
-        try {
-            String challengeHeader = spnegoEngine.generateToken(server);
-            headers.remove(HttpHeaders.Names.AUTHORIZATION);
-            headers.add(HttpHeaders.Names.AUTHORIZATION, "Negotiate " + challengeHeader);
-
-            Realm.RealmBuilder realmBuilder;
-            if (realm != null) {
-                realmBuilder = new Realm.RealmBuilder().clone(realm);
-            } else {
-                realmBuilder = new Realm.RealmBuilder();
-            }
-            return realmBuilder.setUri(uri.getPath())
-                    .setMethodName(request.getMethod())
-                    .setScheme(Realm.AuthScheme.KERBEROS)
-                    .build();
-        } catch (Throwable throwable) {
-            if (proxyAuth.contains("NTLM")) {
-                return ntlmChallenge(proxyAuth, request, proxyServer, headers, realm, future);
-            }
-            abort(future, throwable);
-            return null;
-        }
-    }
-
-    private Realm ntlmChallenge(List<String> wwwAuth,
-                                Request request,
-                                ProxyServer proxyServer,
-                                FluentCaseInsensitiveStringsMap headers,
-                                Realm realm,
-                                NettyResponseFuture<?> future) throws NTLMEngineException {
-
-        boolean useRealm = (proxyServer == null && realm != null);
-
-        String ntlmDomain = useRealm ? realm.getNtlmDomain() : proxyServer.getNtlmDomain();
-        String ntlmHost = useRealm ? realm.getNtlmHost() : proxyServer.getHost();
-        String principal = useRealm ? realm.getPrincipal() : proxyServer.getPrincipal();
-        String password = useRealm ? realm.getPassword() : proxyServer.getPassword();
-
-        Realm newRealm;
-        if (realm != null && !realm.isNtlmMessageType2Received()) {
-            String challengeHeader = ntlmEngine.generateType1Msg(ntlmDomain, ntlmHost);
-
-            headers.add(HttpHeaders.Names.AUTHORIZATION, "NTLM " + challengeHeader);
-            newRealm = new Realm.RealmBuilder().clone(realm).setScheme(realm.getAuthScheme())
-                    .setUri(URI.create(request.getUrl()).getPath())
-                    .setMethodName(request.getMethod())
-                    .setNtlmMessageType2Received(true)
-                    .build();
-            future.getAndSetAuth(false);
-        } else {
-            headers.remove(HttpHeaders.Names.AUTHORIZATION);
-
-            if (wwwAuth.get(0).startsWith("NTLM ")) {
-                String serverChallenge = wwwAuth.get(0).trim().substring("NTLM ".length());
-                String challengeHeader = ntlmEngine.generateType3Msg(principal, password,
-                        ntlmDomain, ntlmHost, serverChallenge);
-
-                headers.add(HttpHeaders.Names.AUTHORIZATION, "NTLM " + challengeHeader);
-            }
-
-            Realm.RealmBuilder realmBuilder;
-            Realm.AuthScheme authScheme;
-            if (realm != null) {
-                realmBuilder = new Realm.RealmBuilder().clone(realm);
-                authScheme = realm.getAuthScheme();
-            } else {
-                realmBuilder = new Realm.RealmBuilder();
-                authScheme = Realm.AuthScheme.NTLM;
-            }
-            newRealm = realmBuilder.setScheme(authScheme)
-                    .setUri(URI.create(request.getUrl()).getPath())
-                    .setMethodName(request.getMethod())
-                    .build();
-        }
-
-        return newRealm;
-    }
-
-    private Realm ntlmProxyChallenge(List<String> wwwAuth,
-                                     Request request,
-                                     ProxyServer proxyServer,
-                                     FluentCaseInsensitiveStringsMap headers,
-                                     Realm realm,
-                                     NettyResponseFuture<?> future) throws NTLMEngineException {
-        future.getAndSetAuth(false);
-        headers.remove(HttpHeaders.Names.PROXY_AUTHORIZATION);
-
-        if (wwwAuth.get(0).startsWith("NTLM ")) {
-            String serverChallenge = wwwAuth.get(0).trim().substring("NTLM ".length());
-            String challengeHeader = ntlmEngine.generateType3Msg(proxyServer.getPrincipal(),
-                    proxyServer.getPassword(),
-                    proxyServer.getNtlmDomain(),
-                    proxyServer.getHost(),
-                    serverChallenge);
-            headers.add(HttpHeaders.Names.PROXY_AUTHORIZATION, "NTLM " + challengeHeader);
-        }
-        Realm newRealm;
-        Realm.RealmBuilder realmBuilder;
-        if (realm != null) {
-            realmBuilder = new Realm.RealmBuilder().clone(realm);
-        } else {
-            realmBuilder = new Realm.RealmBuilder();
-        }
-        newRealm = realmBuilder//.setScheme(realm.getAuthScheme())
-                .setUri(URI.create(request.getUrl()).getPath())
-                .setMethodName(request.getMethod())
-                .build();
-
-        return newRealm;
-    }
-
-    private void drainChannel(final ChannelHandlerContext ctx, final NettyResponseFuture<?> future, final boolean keepAlive, final URI uri) {
-        ctx.setAttachment(new AsyncCallable(future) {
-            public Object call() throws Exception {
-                if (keepAlive && ctx.getChannel().isReadable() && connectionsPool.offer(AsyncHttpProviderUtils.getBaseUrl(uri), ctx.getChannel())) {
-                    return null;
-                }
-
-                finishChannel(ctx);
-                return null;
-            }
-
-            @Override
-            public String toString() {
-                return String.format("Draining task for channel %s", ctx.getChannel());
-            }
-        });
-    }
-
-    private FilterContext handleIoException(FilterContext fc, NettyResponseFuture<?> future) {
-        for (IOExceptionFilter asyncFilter : config.getIOExceptionFilters()) {
-            try {
-                fc = asyncFilter.filter(fc);
-                if (fc == null) {
-                    throw new NullPointerException("FilterContext is null");
-                }
-            } catch (FilterException efe) {
-                abort(future, efe);
-            }
-        }
-        return fc;
-    }
-
-    private void replayRequest(final NettyResponseFuture<?> future, FilterContext fc, HttpResponse response, ChannelHandlerContext ctx) throws IOException {
-        final Request newRequest = fc.getRequest();
-        future.setAsyncHandler(fc.getAsyncHandler());
-        future.setState(NettyResponseFuture.STATE.NEW);
-        future.touch();
-
-        log.debug("\n\nReplaying Request {}\n for Future {}\n", newRequest, future);
-        drainChannel(ctx, future, future.getKeepAlive(), future.getURI());
-        nextRequest(newRequest, future);
-        return;
-    }
-
-    private List<String> getAuthorizationToken(List<Entry<String, String>> list, String headerAuth) {
-        ArrayList<String> l = new ArrayList<String>();
-        for (Entry<String, String> e : list) {
-            if (e.getKey().equalsIgnoreCase(headerAuth)) {
-                l.add(e.getValue().trim());
-            }
-        }
-        return l;
-    }
-
-    private void nextRequest(final Request request, final NettyResponseFuture<?> future) throws IOException {
-        nextRequest(request, future, true);
-    }
-
-    private void nextRequest(final Request request, final NettyResponseFuture<?> future, final boolean useCache) throws IOException {
-        execute(request, future, useCache, true, true);
-    }
-
-    private void abort(NettyResponseFuture<?> future, Throwable t) {
-        Channel channel = future.channel();
-        if (channel != null && openChannels.contains(channel)) {
-            closeChannel(channel.getPipeline().getContext(NettyAsyncHttpProvider.class));
-            openChannels.remove(channel);
-        }
-
-        if (!future.isCancelled() && !future.isDone()) {
-            log.debug("Aborting Future {}\n", future);
-            log.debug(t.getMessage(), t);
-        }
-
-        future.abort(t);
-    }
-
-    private void upgradeProtocol(ChannelPipeline p, String scheme) throws IOException, GeneralSecurityException {
-        if (p.get(HTTP_HANDLER) != null) {
-            p.remove(HTTP_HANDLER);
-        }
-
-        if (isSecure(scheme)) {
-            if (p.get(SSL_HANDLER) == null) {
-                p.addFirst(HTTP_HANDLER, new HttpClientCodec());
-                p.addFirst(SSL_HANDLER, new SslHandler(createSSLEngine()));
-            } else {
-                p.addAfter(SSL_HANDLER, HTTP_HANDLER, new HttpClientCodec());
-            }
-
-        } else {
-            p.addFirst(HTTP_HANDLER, new HttpClientCodec());
-        }
-    }
-
-    public void channelClosed(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {
-
-        if (isClose.get()) {
-            return;
-        }
-
-        connectionsPool.removeAll(ctx.getChannel());
-        try {
-            super.channelClosed(ctx, e);
-        } catch (Exception ex) {
-            log.trace("super.channelClosed", ex);
-        }
-
-        log.debug("Channel Closed: {} with attachment {}", e.getChannel(), ctx.getAttachment());
-
-        if (ctx.getAttachment() instanceof AsyncCallable) {
-            AsyncCallable ac = (AsyncCallable) ctx.getAttachment();
-            ctx.setAttachment(ac.future());
-            ac.call();
-            return;
-        }
-
-        if (ctx.getAttachment() instanceof NettyResponseFuture<?>) {
-            NettyResponseFuture<?> future = (NettyResponseFuture<?>) ctx.getAttachment();
-            future.touch();
-
-            if (config.getIOExceptionFilters().size() > 0) {
-                FilterContext<?> fc = new FilterContext.FilterContextBuilder().asyncHandler(future.getAsyncHandler())
-                        .request(future.getRequest()).ioException(new IOException("Channel Closed")).build();
-                fc = handleIoException(fc, future);
-
-                if (fc.replayRequest() && !future.cannotBeReplay()) {
-                    replayRequest(future, fc, null, ctx);
-                    return;
-                }
-            }
-
-            Protocol p = (ctx.getPipeline().get(HttpClientCodec.class) != null ? httpProtocol : webSocketProtocol);
-            p.onClose(ctx, e);
-
-            if (future != null && !future.isDone() && !future.isCancelled()) {
-                if (!remotelyClosed(ctx.getChannel(), future)) {
-                    abort(future, new IOException("Remotely Closed " + ctx.getChannel()));
-                }
-            } else {
-                closeChannel(ctx);
-            }
-        }
-    }
-
-    protected boolean remotelyClosed(Channel channel, NettyResponseFuture<?> future) {
-
-        if (isClose.get()) {
-            return false;
-        }
-
-        connectionsPool.removeAll(channel);
-
-        if (future == null && channel.getPipeline().getContext(NettyAsyncHttpProvider.class).getAttachment() != null
-                && NettyResponseFuture.class.isAssignableFrom(
-                channel.getPipeline().getContext(NettyAsyncHttpProvider.class).getAttachment().getClass())) {
-            future = (NettyResponseFuture<?>)
-                    channel.getPipeline().getContext(NettyAsyncHttpProvider.class).getAttachment();
-        }
-
-        if (future == null || future.cannotBeReplay()) {
-            log.debug("Unable to recover future {}\n", future);
-            return false;
-        }
-
-        future.setState(NettyResponseFuture.STATE.RECONNECTED);
-        future.getAndSetStatusReceived(false);
-
-        log.debug("Trying to recover request {}\n", future.getNettyRequest());
-
-        try {
-            nextRequest(future.getRequest(), future);
-            return true;
-        } catch (IOException iox) {
-            future.setState(NettyResponseFuture.STATE.CLOSED);
-            future.abort(iox);
-            log.error("Remotely Closed, unable to recover", iox);
-        }
-        return false;
-    }
-
-    private void markAsDone(final NettyResponseFuture<?> future, final ChannelHandlerContext ctx) throws MalformedURLException {
-        // We need to make sure everything is OK before adding the connection back to the pool.
-        try {
-            future.done(null);
-        } catch (Throwable t) {
-            // Never propagate exception once we know we are done.
-            log.debug(t.getMessage(), t);
-        }
-
-        if (!future.getKeepAlive() || !ctx.getChannel().isReadable()) {
-            closeChannel(ctx);
-        }
-    }
-
-    private void finishUpdate(final NettyResponseFuture<?> future, final ChannelHandlerContext ctx, boolean lastValidChunk) throws IOException {
-        if (lastValidChunk && future.getKeepAlive()) {
-            drainChannel(ctx, future, future.getKeepAlive(), future.getURI());
-        } else {
-            if (future.getKeepAlive() && ctx.getChannel().isReadable() &&
-                    connectionsPool.offer(AsyncHttpProviderUtils.getBaseUrl(future.getURI()), ctx.getChannel())) {
-                markAsDone(future, ctx);
-                return;
-            }
-            finishChannel(ctx);
-        }
-        markAsDone(future, ctx);
-    }
-
-    private final boolean updateStatusAndInterrupt(AsyncHandler<?> handler, HttpResponseStatus c) throws Exception {
-        return handler.onStatusReceived(c) != STATE.CONTINUE;
-    }
-
-    private final boolean updateHeadersAndInterrupt(AsyncHandler<?> handler, HttpResponseHeaders c) throws Exception {
-        return handler.onHeadersReceived(c) != STATE.CONTINUE;
-    }
-
-    private final boolean updateBodyAndInterrupt(final NettyResponseFuture<?> future, AsyncHandler<?> handler, HttpResponseBodyPart c) throws Exception {
-        boolean state = handler.onBodyPartReceived(c) != STATE.CONTINUE;
-        if (c.closeUnderlyingConnection()) {
-            future.setKeepAlive(false);
-        }
-        return state;
-    }
-
-    //Simple marker for stopping publishing bytes.
-
-    final static class DiscardEvent {
-    }
-
-    @Override
-    public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e)
-            throws Exception {
-        Channel channel = e.getChannel();
-        Throwable cause = e.getCause();
-        NettyResponseFuture<?> future = null;
-
-        /** Issue 81
-        if (e.getCause() != null && e.getCause().getClass().isAssignableFrom(PrematureChannelClosureException.class)) {
-            return;
-        }
-        */
-        if (e.getCause() != null && e.getCause().getClass().getSimpleName().equals("PrematureChannelClosureException")) {
-            return;
-        }
-
-        if (log.isDebugEnabled()) {
-            log.debug("Unexpected I/O exception on channel {}", channel, cause);
-        }
-
-        try {
-
-            if (cause != null && ClosedChannelException.class.isAssignableFrom(cause.getClass())) {
-                return;
-            }
-
-            if (ctx.getAttachment() instanceof NettyResponseFuture<?>) {
-                future = (NettyResponseFuture<?>) ctx.getAttachment();
-                future.attachChannel(null, false);
-                future.touch();
-
-                if (IOException.class.isAssignableFrom(cause.getClass())) {
-
-                    if (config.getIOExceptionFilters().size() > 0) {
-                        FilterContext<?> fc = new FilterContext.FilterContextBuilder().asyncHandler(future.getAsyncHandler())
-                                .request(future.getRequest()).ioException(new IOException("Channel Closed")).build();
-                        fc = handleIoException(fc, future);
-
-                        if (fc.replayRequest()) {
-                            replayRequest(future, fc, null, ctx);
-                            return;
-                        }
-                    } else {
-                        // Close the channel so the recovering can occurs.
-                        try {
-                            ctx.getChannel().close();
-                        } catch (Throwable t) {
-                            ; // Swallow.
-                        }
-                        return;
-                    }
-                }
-
-                if (abortOnReadCloseException(cause) || abortOnWriteCloseException(cause)) {
-                    log.debug("Trying to recover from dead Channel: {}", channel);
-                    return;
-                }
-            } else if (ctx.getAttachment() instanceof AsyncCallable) {
-                future = ((AsyncCallable) ctx.getAttachment()).future();
-            }
-        } catch (Throwable t) {
-            cause = t;
-        }
-
-        if (future != null) {
-            try {
-                log.debug("Was unable to recover Future: {}", future);
-                abort(future, cause);
-            } catch (Throwable t) {
-                log.error(t.getMessage(), t);
-            }
-        }
-
-        Protocol p = (ctx.getPipeline().get(HttpClientCodec.class) != null ? httpProtocol : webSocketProtocol);
-        p.onError(ctx, e);
-
-        closeChannel(ctx);
-        ctx.sendUpstream(e);
-    }
-
-    protected static boolean abortOnConnectCloseException(Throwable cause) {
-        try {
-            for (StackTraceElement element : cause.getStackTrace()) {
-                if (element.getClassName().equals("sun.nio.ch.SocketChannelImpl")
-                        && element.getMethodName().equals("checkConnect")) {
-                    return true;
-                }
-            }
-
-            if (cause.getCause() != null) {
-                return abortOnConnectCloseException(cause.getCause());
-            }
-
-        } catch (Throwable t) {
-        }
-        return false;
-    }
-
-    protected static boolean abortOnDisconnectException(Throwable cause) {
-        try {
-            for (StackTraceElement element : cause.getStackTrace()) {
-                if (element.getClassName().equals("org.jboss.netty.handler.ssl.SslHandler")
-                        && element.getMethodName().equals("channelDisconnected")) {
-                    return true;
-                }
-            }
-
-            if (cause.getCause() != null) {
-                return abortOnConnectCloseException(cause.getCause());
-            }
-
-        } catch (Throwable t) {
-        }
-        return false;
-    }
-
-    protected static boolean abortOnReadCloseException(Throwable cause) {
-
-        for (StackTraceElement element : cause.getStackTrace()) {
-            if (element.getClassName().equals("sun.nio.ch.SocketDispatcher")
-                    && element.getMethodName().equals("read")) {
-                return true;
-            }
-        }
-
-        if (cause.getCause() != null) {
-            return abortOnReadCloseException(cause.getCause());
-        }
-
-        return false;
-    }
-
-    protected static boolean abortOnWriteCloseException(Throwable cause) {
-
-        for (StackTraceElement element : cause.getStackTrace()) {
-            if (element.getClassName().equals("sun.nio.ch.SocketDispatcher")
-                    && element.getMethodName().equals("write")) {
-                return true;
-            }
-        }
-
-        if (cause.getCause() != null) {
-            return abortOnReadCloseException(cause.getCause());
-        }
-
-        return false;
-    }
-
-    private final static int computeAndSetContentLength(Request request, HttpRequest r) {
-        int length = (int) request.getContentLength();
-        if (length == -1 && r.getHeader(HttpHeaders.Names.CONTENT_LENGTH) != null) {
-            length = Integer.valueOf(r.getHeader(HttpHeaders.Names.CONTENT_LENGTH));
-        }
-
-        if (length >= 0) {
-            r.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(length));
-        }
-        return length;
-    }
-
-    public static <T> NettyResponseFuture<T> newFuture(URI uri,
-                                                       Request request,
-                                                       AsyncHandler<T> asyncHandler,
-                                                       HttpRequest nettyRequest,
-                                                       AsyncHttpClientConfig config,
-                                                       NettyAsyncHttpProvider provider) {
-
-        NettyResponseFuture<T> f = new NettyResponseFuture<T>(uri, request, asyncHandler, nettyRequest,
-                requestTimeout(config, request.getPerRequestConfig()), config.getIdleConnectionTimeoutInMs(), provider);
-
-        if (request.getHeaders().getFirstValue("Expect") != null
-                && request.getHeaders().getFirstValue("Expect").equalsIgnoreCase("100-Continue")) {
-            f.getAndSetWriteBody(false);
-        }
-        return f;
-    }
-
-    private class ProgressListener implements ChannelFutureProgressListener {
-
-        private final boolean notifyHeaders;
-        private final AsyncHandler asyncHandler;
-        private final NettyResponseFuture<?> future;
-
-        public ProgressListener(boolean notifyHeaders, AsyncHandler asyncHandler, NettyResponseFuture<?> future) {
-            this.notifyHeaders = notifyHeaders;
-            this.asyncHandler = asyncHandler;
-            this.future = future;
-        }
-
-        public void operationComplete(ChannelFuture cf) {
-            // The write operation failed. If the channel was cached, it means it got asynchronously closed.
-            // Let's retry a second time.
-            Throwable cause = cf.getCause();
-            if (cause != null && future.getState() != NettyResponseFuture.STATE.NEW) {
-
-                if (IllegalStateException.class.isAssignableFrom(cause.getClass())) {
-                    log.debug(cause.getMessage(), cause);
-                    try {
-                        cf.getChannel().close();
-                    } catch (RuntimeException ex) {
-                        log.debug(ex.getMessage(), ex);
-                    }
-                    return;
-                }
-
-                if (ClosedChannelException.class.isAssignableFrom(cause.getClass())
-                        || abortOnReadCloseException(cause)
-                        || abortOnWriteCloseException(cause)) {
-
-                    if (log.isDebugEnabled()) {
-                        log.debug(cf.getCause() == null ? "" : cf.getCause().getMessage(), cf.getCause());
-                    }
-
-                    try {
-                        cf.getChannel().close();
-                    } catch (RuntimeException ex) {
-                        log.debug(ex.getMessage(), ex);
-                    }
-                    return;
-                } else {
-                    future.abort(cause);
-                }
-                return;
-            }
-            future.touch();
-
-            /**
-             * We need to make sure we aren't in the middle of an authorization process before publishing events
-             * as we will re-publish again the same event after the authorization, causing unpredictable behavior.
-             */
-            Realm realm = future.getRequest().getRealm() != null ? future.getRequest().getRealm() : NettyAsyncHttpProvider.this.getConfig().getRealm();
-            boolean startPublishing = future.isInAuth()
-                    || realm == null
-                    || realm.getUsePreemptiveAuth() == true;
-
-            if (startPublishing && ProgressAsyncHandler.class.isAssignableFrom(asyncHandler.getClass())) {
-                if (notifyHeaders) {
-                    ProgressAsyncHandler.class.cast(asyncHandler).onHeaderWriteCompleted();
-                } else {
-                    ProgressAsyncHandler.class.cast(asyncHandler).onContentWriteCompleted();
-                }
-            }
-        }
-
-        public void operationProgressed(ChannelFuture cf, long amount, long current, long total) {
-            future.touch();
-            if (ProgressAsyncHandler.class.isAssignableFrom(asyncHandler.getClass())) {
-                ProgressAsyncHandler.class.cast(asyncHandler).onContentWriteProgress(amount, current, total);
-            }
-        }
-    }
-
-    /**
-     * Because some implementation of the ThreadSchedulingService do not clean up cancel task until they try to run
-     * them, we wrap the task with the future so the when the NettyResponseFuture cancel the reaper future
-     * this wrapper will release the references to the channel and the nettyResponseFuture immediately. Otherwise,
-     * the memory referenced this way will only be released after the request timeout period which can be arbitrary long.
-     */
-    private final class ReaperFuture implements Future, Runnable {
-        private Future scheduledFuture;
-        private NettyResponseFuture<?> nettyResponseFuture;
-
-        public ReaperFuture(NettyResponseFuture<?> nettyResponseFuture) {
-            this.nettyResponseFuture = nettyResponseFuture;
-        }
-
-        public void setScheduledFuture(Future scheduledFuture) {
-            this.scheduledFuture = scheduledFuture;
-        }
-
-        /**
-         * @Override
-         */
-        public boolean cancel(boolean mayInterruptIfRunning) {
-            nettyResponseFuture = null;
-            return scheduledFuture.cancel(mayInterruptIfRunning);
-        }
-
-        /**
-         * @Override
-         */
-        public Object get() throws InterruptedException, ExecutionException {
-            return scheduledFuture.get();
-        }
-
-        /**
-         * @Override
-         */
-        public Object get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
-            return scheduledFuture.get(timeout, unit);
-        }
-
-        /**
-         * @Override
-         */
-        public boolean isCancelled() {
-            return scheduledFuture.isCancelled();
-        }
-
-        /**
-         * @Override
-         */
-        public boolean isDone() {
-            return scheduledFuture.isDone();
-        }
-
-        /**
-         * @Override
-         */
-        public synchronized void run() {
-            if (isClose.get()) {
-                cancel(true);
-                return;
-            }
-
-            if (nettyResponseFuture != null && nettyResponseFuture.hasExpired()
-                    && !nettyResponseFuture.isDone() && !nettyResponseFuture.isCancelled()) {
-                log.debug("Request Timeout expired for {}\n", nettyResponseFuture);
-
-                int requestTimeout = config.getRequestTimeoutInMs();
-                PerRequestConfig p = nettyResponseFuture.getRequest().getPerRequestConfig();
-                if (p != null && p.getRequestTimeoutInMs() != -1) {
-                    requestTimeout = p.getRequestTimeoutInMs();
-                }
-
-                abort(nettyResponseFuture, new TimeoutException(String.format("No response received after %s", requestTimeout)));
-
-                nettyResponseFuture = null;
-            }
-
-            if (nettyResponseFuture == null || nettyResponseFuture.isDone() || nettyResponseFuture.isCancelled()) {
-                cancel(true);
-            }
-        }
-    }
-
-    private abstract class AsyncCallable implements Callable<Object> {
-
-        private final NettyResponseFuture<?> future;
-
-        public AsyncCallable(NettyResponseFuture<?> future) {
-            this.future = future;
-        }
-
-        abstract public Object call() throws Exception;
-
-        public NettyResponseFuture<?> future() {
-            return future;
-        }
-    }
-
-    public static class ThreadLocalBoolean extends ThreadLocal<Boolean> {
-
-        private final boolean defaultValue;
-
-        public ThreadLocalBoolean() {
-            this(false);
-        }
-
-        public ThreadLocalBoolean(boolean defaultValue) {
-            this.defaultValue = defaultValue;
-        }
-
-        @Override
-        protected Boolean initialValue() {
-            return defaultValue ? Boolean.TRUE : Boolean.FALSE;
-        }
-    }
-
-    public static class OptimizedFileRegion implements FileRegion {
-
-        private final FileChannel file;
-        private final RandomAccessFile raf;
-        private final long position;
-        private final long count;
-        private long byteWritten;
-
-        public OptimizedFileRegion(RandomAccessFile raf, long position, long count) {
-            this.raf = raf;
-            this.file = raf.getChannel();
-            this.position = position;
-            this.count = count;
-        }
-
-        public long getPosition() {
-            return position;
-        }
-
-        public long getCount() {
-            return count;
-        }
-
-        public long transferTo(WritableByteChannel target, long position) throws IOException {
-            long count = this.count - position;
-            if (count < 0 || position < 0) {
-                throw new IllegalArgumentException(
-                        "position out of range: " + position +
-                                " (expected: 0 - " + (this.count - 1) + ")");
-            }
-            if (count == 0) {
-                return 0L;
-            }
-
-            long bw = file.transferTo(this.position + position, count, target);
-            byteWritten += bw;
-            if (byteWritten == raf.length()) {
-                releaseExternalResources();
-            }
-            return bw;
-        }
-
-        public void releaseExternalResources() {
-            try {
-                file.close();
-            } catch (IOException e) {
-                log.warn("Failed to close a file.", e);
-            }
-
-            try {
-                raf.close();
-            } catch (IOException e) {
-                log.warn("Failed to close a file.", e);
-            }
-        }
-    }
-
-    private static class NettyTransferAdapter extends TransferCompletionHandler.TransferAdapter {
-
-        private final ChannelBuffer content;
-        private final FileInputStream file;
-        private int byteRead = 0;
-
-        public NettyTransferAdapter(FluentCaseInsensitiveStringsMap headers, ChannelBuffer content, File file) throws IOException {
-            super(headers);
-            this.content = content;
-            if (file != null) {
-                this.file = new FileInputStream(file);
-            } else {
-                this.file = null;
-            }
-        }
-
-        @Override
-        public void getBytes(byte[] bytes) {
-            if (content.writableBytes() != 0) {
-                content.getBytes(byteRead, bytes);
-                byteRead += bytes.length;
-            } else if (file != null) {
-                try {
-                    byteRead += file.read(bytes);
-                } catch (IOException e) {
-                    log.error(e.getMessage(), e);
-                }
-            }
-        }
-    }
-
-    protected AsyncHttpClientConfig getConfig() {
-        return config;
-    }
-
-    private static class NonConnectionsPool implements ConnectionsPool<String, Channel> {
-
-        public boolean offer(String uri, Channel connection) {
-            return false;
-        }
-
-        public Channel poll(String uri) {
-            return null;
-        }
-
-        public boolean removeAll(Channel connection) {
-            return false;
-        }
-
-        public boolean canCacheConnection() {
-            return true;
-        }
-
-        public void destroy() {
-        }
-    }
-
-    private static final boolean validateWebSocketRequest(Request request, AsyncHandler<?> asyncHandler) {
-        if (request.getMethod() != "GET" || !WebSocketUpgradeHandler.class.isAssignableFrom(asyncHandler.getClass())) {
-            return false;
-        }
-        return true;
-    }
-
-    private boolean redirect(Request request,
-                             NettyResponseFuture<?> future,
-                             HttpResponse response,
-                             final ChannelHandlerContext ctx) throws Exception {
-
-        int statusCode = response.getStatus().getCode();
-        boolean redirectEnabled = request.isRedirectOverrideSet() ? request.isRedirectEnabled() : config.isRedirectEnabled();
-        if (redirectEnabled && (statusCode == 302
-                || statusCode == 301
-                || statusCode == 303
-                || statusCode == 307)) {
-
-            if (future.incrementAndGetCurrentRedirectCount() < config.getMaxRedirects()) {
-                // We must allow 401 handling again.
-                future.getAndSetAuth(false);
-
-                String location = response.getHeader(HttpHeaders.Names.LOCATION);
-                URI uri = AsyncHttpProviderUtils.getRedirectUri(future.getURI(), location);
-                boolean stripQueryString = config.isRemoveQueryParamOnRedirect();
-                if (!uri.toString().equals(future.getURI().toString())) {
-                    final RequestBuilder nBuilder = stripQueryString ?
-                            new RequestBuilder(future.getRequest()).setQueryParameters(null)
-                            : new RequestBuilder(future.getRequest());
-
-                    if (!(statusCode < 302 || statusCode > 303)
-                            && !(statusCode == 302
-                            && config.isStrict302Handling())) {
-                        nBuilder.setMethod("GET");
-                    }
-                    final URI initialConnectionUri = future.getURI();
-                    final boolean initialConnectionKeepAlive = future.getKeepAlive();
-                    future.setURI(uri);
-                    String newUrl = uri.toString();
-                    if (request.getUrl().startsWith(WEBSOCKET)) {
-                        newUrl = newUrl.replace(HTTP, WEBSOCKET);
-                    }
-
-                    log.debug("Redirecting to {}", newUrl);
-                    for (String cookieStr : future.getHttpResponse().getHeaders(HttpHeaders.Names.SET_COOKIE)) {
-                        Cookie c = AsyncHttpProviderUtils.parseCookie(cookieStr);
-                        nBuilder.addOrReplaceCookie(c);
-                    }
-
-                    for (String cookieStr : future.getHttpResponse().getHeaders(HttpHeaders.Names.SET_COOKIE2)) {
-                        Cookie c = AsyncHttpProviderUtils.parseCookie(cookieStr);
-                        nBuilder.addOrReplaceCookie(c);
-                    }
-
-                    AsyncCallable ac = new AsyncCallable(future) {
-                        public Object call() throws Exception {
-                            if (initialConnectionKeepAlive && ctx.getChannel().isReadable() &&
-                                    connectionsPool.offer(AsyncHttpProviderUtils.getBaseUrl(initialConnectionUri), ctx.getChannel())) {
-                                return null;
-                            }
-                            finishChannel(ctx);
-                            return null;
-                        }
-                    };
-
-                    if (response.isChunked()) {
-                        // We must make sure there is no bytes left before executing the next request.
-                        ctx.setAttachment(ac);
-                    } else {
-                        ac.call();
-                    }
-                    nextRequest(nBuilder.setUrl(newUrl).build(), future);
-                    return true;
-                }
-            } else {
-                throw new MaxRedirectException("Maximum redirect reached: " + config.getMaxRedirects());
-            }
-        }
-        return false;
-    }
-
-    private final class HttpProtocol implements Protocol {
-        // @Override
-        public void handle(final ChannelHandlerContext ctx, final MessageEvent e) throws Exception {
-            final NettyResponseFuture<?> future = (NettyResponseFuture<?>) ctx.getAttachment();
-            future.touch();
-
-            // The connect timeout occured.
-            if (future.isCancelled() || future.isDone()) {
-                finishChannel(ctx);
-                return;
-            }
-
-            HttpRequest nettyRequest = future.getNettyRequest();
-            AsyncHandler handler = future.getAsyncHandler();
-            Request request = future.getRequest();
-            HttpResponse response = null;
-            try {
-                if (e.getMessage() instanceof HttpResponse) {
-                    response = (HttpResponse) e.getMessage();
-
-                    log.debug("\n\nRequest {}\n\nResponse {}\n", nettyRequest, response);
-
-                    // Required if there is some trailing headers.
-                    future.setHttpResponse(response);
-
-                    int statusCode = response.getStatus().getCode();
-
-                    String ka = response.getHeader(HttpHeaders.Names.CONNECTION);
-                    future.setKeepAlive(ka == null || ! ka.toLowerCase().equals("close"));
-
-                    List<String> wwwAuth = getAuthorizationToken(response.getHeaders(), HttpHeaders.Names.WWW_AUTHENTICATE);
-                    Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
-
-                    HttpResponseStatus status = new ResponseStatus(future.getURI(), response, NettyAsyncHttpProvider.this);
-                    HttpResponseHeaders responseHeaders = new ResponseHeaders(future.getURI(), response, NettyAsyncHttpProvider.this);
-                    FilterContext fc = new FilterContext.FilterContextBuilder()
-                            .asyncHandler(handler)
-                            .request(request)
-                            .responseStatus(status)
-                            .responseHeaders(responseHeaders)
-                            .build();
-
-                    for (ResponseFilter asyncFilter : config.getResponseFilters()) {
-                        try {
-                            fc = asyncFilter.filter(fc);
-                            if (fc == null) {
-                                throw new NullPointerException("FilterContext is null");
-                            }
-                        } catch (FilterException efe) {
-                            abort(future, efe);
-                        }
-                    }
-
-                    // The handler may have been wrapped.
-                    handler = fc.getAsyncHandler();
-                    future.setAsyncHandler(handler);
-
-                    // The request has changed
-                    if (fc.replayRequest()) {
-                        replayRequest(future, fc, response, ctx);
-                        return;
-                    }
-
-                    Realm newRealm = null;
-                    ProxyServer proxyServer = request.getProxyServer() != null ? request.getProxyServer() : config.getProxyServer();
-                    final FluentCaseInsensitiveStringsMap headers = request.getHeaders();
-                    final RequestBuilder builder = new RequestBuilder(future.getRequest());
-
-                    //if (realm != null && !future.getURI().getPath().equalsIgnoreCase(realm.getUri())) {
-                    //    builder.setUrl(future.getURI().toString());
-                    //}
-
-                    if (statusCode == 401
-                            && realm != null
-                            && wwwAuth.size() > 0
-                            && !future.getAndSetAuth(true)) {
-
-                        future.setState(NettyResponseFuture.STATE.NEW);
-                        // NTLM
-                        if (!wwwAuth.contains("Kerberos") && (wwwAuth.contains("NTLM") || (wwwAuth.contains("Negotiate")))) {
-                            newRealm = ntlmChallenge(wwwAuth, request, proxyServer, headers, realm, future);
-                            // SPNEGO KERBEROS
-                        } else if (wwwAuth.contains("Negotiate")) {
-                            newRealm = kerberosChallenge(wwwAuth, request, proxyServer, headers, realm, future);
-                            if (newRealm == null) return;
-                        } else {
-                            Realm.RealmBuilder realmBuilder;
-                            if (realm != null) {
-                                realmBuilder = new Realm.RealmBuilder().clone(realm).setScheme(realm.getAuthScheme())
-                                ;
-                            } else {
-                                realmBuilder = new Realm.RealmBuilder();
-                            }
-                            newRealm = realmBuilder
-                                    .setUri(URI.create(request.getUrl()).getPath())
-                                    .setMethodName(request.getMethod())
-                                    .setUsePreemptiveAuth(true)
-                                    .parseWWWAuthenticateHeader(wwwAuth.get(0))
-                                    .build();
-                        }
-
-                        final Realm nr = new Realm.RealmBuilder().clone(newRealm)
-                                .setUri(URI.create(request.getUrl()).getPath()).build();
-
-                        log.debug("Sending authentication to {}", request.getUrl());
-                        AsyncCallable ac = new AsyncCallable(future) {
-                            public Object call() throws Exception {
-                                drainChannel(ctx, future, future.getKeepAlive(), future.getURI());
-                                nextRequest(builder.setHeaders(headers).setRealm(nr).build(), future);
-                                return null;
-                            }
-                        };
-
-                        if (future.getKeepAlive() && response.isChunked()) {
-                            // We must make sure there is no bytes left before executing the next request.
-                            ctx.setAttachment(ac);
-                        } else {
-                            ac.call();
-                        }
-                        return;
-                    }
-
-                    if (statusCode == 100) {
-                        future.getAndSetWriteHeaders(false);
-                        future.getAndSetWriteBody(true);
-                        writeRequest(ctx.getChannel(), config, future, nettyRequest);
-                        return;
-                    }
-
-                    List<String> proxyAuth = getAuthorizationToken(response.getHeaders(), HttpHeaders.Names.PROXY_AUTHENTICATE);
-                    if (statusCode == 407
-                            && realm != null
-                            && proxyAuth.size() > 0
-                            && !future.getAndSetAuth(true)) {
-
-                        log.debug("Sending proxy authentication to {}", request.getUrl());
-
-                        future.setState(NettyResponseFuture.STATE.NEW);
-
-                        if (!proxyAuth.contains("Kerberos") && (proxyAuth.get(0).contains("NTLM") || (proxyAuth.contains("Negotiate")))) {
-                            newRealm = ntlmProxyChallenge(proxyAuth, request, proxyServer, headers, realm, future);
-                            // SPNEGO KERBEROS
-                        } else if (proxyAuth.contains("Negotiate")) {
-                            newRealm = kerberosChallenge(proxyAuth, request, proxyServer, headers, realm, future);
-                            if (newRealm == null) return;
-                        } else {
-                            newRealm = future.getRequest().getRealm();
-                        }
-
-                        Request req = builder.setHeaders(headers).setRealm(newRealm).build();
-                        future.setReuseChannel(true);
-                        future.setConnectAllowed(true);
-                        nextRequest(req, future);
-                        return;
-                    }
-
-                    if (future.getNettyRequest().getMethod().equals(HttpMethod.CONNECT)
-                            && statusCode == 200) {
-
-                        log.debug("Connected to {}:{}", proxyServer.getHost(), proxyServer.getPort());
-
-                        if (future.getKeepAlive()) {
-                            future.attachChannel(ctx.getChannel(), true);
-                        }
-
-                        try {
-                            log.debug("Connecting to proxy {} for scheme {}", proxyServer, request.getUrl());
-                            upgradeProtocol(ctx.getChannel().getPipeline(), URI.create(request.getUrl()).getScheme());
-                        } catch (Throwable ex) {
-                            abort(future, ex);
-                        }
-                        Request req = builder.build();
-                        future.setReuseChannel(true);
-                        future.setConnectAllowed(false);
-                        nextRequest(req, future);
-                        return;
-                    }
-
-                    if (redirect(request, future, response, ctx)) return;
-
-                    if (!future.getAndSetStatusReceived(true) && updateStatusAndInterrupt(handler, status)) {
-                        finishUpdate(future, ctx, response.isChunked());
-                        return;
-                    } else if (updateHeadersAndInterrupt(handler, responseHeaders)) {
-                        finishUpdate(future, ctx, response.isChunked());
-                        return;
-                    } else if (!response.isChunked()) {
-                        if (response.getContent().readableBytes() != 0) {
-                            updateBodyAndInterrupt(future, handler, new ResponseBodyPart(future.getURI(), response, NettyAsyncHttpProvider.this, true));
-                        }
-                        finishUpdate(future, ctx, false);
-                        return;
-                    }
-
-                    if (nettyRequest.getMethod().equals(HttpMethod.HEAD)) {
-                        updateBodyAndInterrupt(future, handler, new ResponseBodyPart(future.getURI(), response, NettyAsyncHttpProvider.this, true));
-                        markAsDone(future, ctx);
-                        drainChannel(ctx, future, future.getKeepAlive(), future.getURI());
-                    }
-
-                } else if (e.getMessage() instanceof HttpChunk) {
-                    HttpChunk chunk = (HttpChunk) e.getMessage();
-
-                    if (handler != null) {
-                        if (chunk.isLast() || updateBodyAndInterrupt(future, handler,
-                                new ResponseBodyPart(future.getURI(), null, NettyAsyncHttpProvider.this, chunk, chunk.isLast()))) {
-                            if (chunk instanceof DefaultHttpChunkTrailer) {
-                                updateHeadersAndInterrupt(handler, new ResponseHeaders(future.getURI(),
-                                        future.getHttpResponse(), NettyAsyncHttpProvider.this, (HttpChunkTrailer) chunk));
-                            }
-                            finishUpdate(future, ctx, !chunk.isLast());
-                        }
-                    }
-                }
-            } catch (Exception t) {
-                if (IOException.class.isAssignableFrom(t.getClass()) && config.getIOExceptionFilters().size() > 0) {
-                    FilterContext<?> fc = new FilterContext.FilterContextBuilder().asyncHandler(future.getAsyncHandler())
-                            .request(future.getRequest()).ioException(IOException.class.cast(t)).build();
-                    fc = handleIoException(fc, future);
-
-                    if (fc.replayRequest()) {
-                        replayRequest(future, fc, response, ctx);
-                        return;
-                    }
-                }
-
-                try {
-                    abort(future, t);
-                } finally {
-                    finishUpdate(future, ctx, false);
-                    throw t;
-                }
-            }
-        }
-
-        // @Override
-        public void onError(ChannelHandlerContext ctx, ExceptionEvent e) {
-        }
-
-        // @Override
-        public void onClose(ChannelHandlerContext ctx, ChannelStateEvent e) {
-        }
-    }
-
-    private final class WebSocketProtocol implements Protocol {
-
-        // @Override
-        public void handle(ChannelHandlerContext ctx, MessageEvent e) throws Exception {
-            NettyResponseFuture future = NettyResponseFuture.class.cast(ctx.getAttachment());
-            WebSocketUpgradeHandler h = WebSocketUpgradeHandler.class.cast(future.getAsyncHandler());
-            Request request = future.getRequest();
-
-            if (e.getMessage() instanceof HttpResponse) {
-                HttpResponse response = (HttpResponse) e.getMessage();
-
-                HttpResponseStatus s = new ResponseStatus(future.getURI(), response, NettyAsyncHttpProvider.this);
-                HttpResponseHeaders responseHeaders = new ResponseHeaders(future.getURI(), response, NettyAsyncHttpProvider.this);
-                FilterContext<?> fc = new FilterContext.FilterContextBuilder()
-                        .asyncHandler(h)
-                        .request(request)
-                        .responseStatus(s)
-                        .responseHeaders(responseHeaders)
-                        .build();
-                for (ResponseFilter asyncFilter : config.getResponseFilters()) {
-                    try {
-                        fc = asyncFilter.filter(fc);
-                        if (fc == null) {
-                            throw new NullPointerException("FilterContext is null");
-                        }
-                    } catch (FilterException efe) {
-                        abort(future, efe);
-                    }
-
-                }
-
-                // The handler may have been wrapped.
-                future.setAsyncHandler(fc.getAsyncHandler());
-
-                // The request has changed
-                if (fc.replayRequest()) {
-                    replayRequest(future, fc, response, ctx);
-                    return;
-                }
-
-                future.setHttpResponse(response);
-                if (redirect(request, future, response, ctx)) return;
-
-                final org.jboss.netty.handler.codec.http.HttpResponseStatus status =
-                        new org.jboss.netty.handler.codec.http.HttpResponseStatus(101, "Web Socket Protocol Handshake");
-
-                final boolean validStatus = response.getStatus().equals(status);
-                final boolean validUpgrade = response.getHeader(HttpHeaders.Names.UPGRADE) != null;
-                String c = response.getHeader(HttpHeaders.Names.CONNECTION);
-                if (c == null) {
-                    c = response.getHeader("connection");
-                }
-
-                final boolean validConnection = c == null ? false : c.equalsIgnoreCase(HttpHeaders.Values.UPGRADE);
-
-                s = new ResponseStatus(future.getURI(), response, NettyAsyncHttpProvider.this);
-                final boolean statusReceived = h.onStatusReceived(s) == STATE.UPGRADE;
-
-                if (!statusReceived) {
-                    h.onClose(new NettyWebSocket(ctx.getChannel()), 1002, "Bad response status " + response.getStatus().getCode());
-                    future.done(null);
-                    return;
-                }
-
-                if (!validStatus || !validUpgrade || !validConnection) {
-                    throw new IOException("Invalid handshake response");
-                }
-
-                String accept = response.getHeader("Sec-WebSocket-Accept");
-                String key = WebSocketUtil.getAcceptKey(future.getNettyRequest().getHeader(WEBSOCKET_KEY));
-                if (accept == null || !accept.equals(key)) {
-                    throw new IOException(String.format("Invalid challenge. Actual: %s. Expected: %s", accept, key));
-                }
-
-                ctx.getPipeline().replace("ws-decoder", "ws-decoder", new WebSocket08FrameDecoder(false, false));
-                ctx.getPipeline().replace("ws-encoder", "ws-encoder", new WebSocket08FrameEncoder(true));
-                if (h.onHeadersReceived(responseHeaders) == STATE.CONTINUE) {
-                    h.onSuccess(new NettyWebSocket(ctx.getChannel()));
-                }
-                future.done(null);
-            } else if (e.getMessage() instanceof WebSocketFrame) {
-                final WebSocketFrame frame = (WebSocketFrame) e.getMessage();
-
-                HttpChunk webSocketChunk = new HttpChunk() {
-                    private ChannelBuffer content;
-
-                    // @Override
-                    public boolean isLast() {
-                        return false;
-                    }
-
-                    // @Override
-                    public ChannelBuffer getContent() {
-                        return content;
-                    }
-
-                    // @Override
-                    public void setContent(ChannelBuffer content) {
-                        this.content = content;
-                    }
-                };
-
-                if (frame.getBinaryData() != null) {
-                    webSocketChunk.setContent(ChannelBuffers.wrappedBuffer(frame.getBinaryData()));
-                    ResponseBodyPart rp = new ResponseBodyPart(future.getURI(), null, NettyAsyncHttpProvider.this, webSocketChunk, true);
-                    h.onBodyPartReceived(rp);
-
-                    NettyWebSocket webSocket = NettyWebSocket.class.cast(h.onCompleted());
-                    webSocket.onMessage(rp.getBodyPartBytes());
-                    webSocket.onTextMessage(frame.getBinaryData().toString(UTF8));
-
-                    if (CloseWebSocketFrame.class.isAssignableFrom(frame.getClass())) {
-                        try {
-                            webSocket.onClose(CloseWebSocketFrame.class.cast(frame).getStatusCode(), CloseWebSocketFrame.class.cast(frame).getReasonText());
-                        } catch (Throwable t) {
-                            // Swallow any exception that may comes from a Netty version released before 3.4.0
-                            log.trace("", t);
-                        }
-                    }
-                }
-            } else {
-                log.error("Invalid attachment {}", ctx.getAttachment());
-            }
-        }
-
-        //@Override
-        public void onError(ChannelHandlerContext ctx, ExceptionEvent e) {
-            try {
-                log.warn("onError {}", e);
-                if (ctx.getAttachment() == null || !NettyResponseFuture.class.isAssignableFrom(ctx.getAttachment().getClass())) {
-                    return;
-                }
-
-                NettyResponseFuture<?> nettyResponse = NettyResponseFuture.class.cast(ctx.getAttachment());
-                WebSocketUpgradeHandler h = WebSocketUpgradeHandler.class.cast(nettyResponse.getAsyncHandler());
-
-                NettyWebSocket webSocket = NettyWebSocket.class.cast(h.onCompleted());
-                webSocket.onError(e.getCause());
-                webSocket.close();
-            } catch (Throwable t) {
-                log.error("onError", t);
-            }
-        }
-
-        //@Override
-        public void onClose(ChannelHandlerContext ctx, ChannelStateEvent e) {
-            log.trace("onClose {}", e);
-            if (ctx.getAttachment() == null || !NettyResponseFuture.class.isAssignableFrom(ctx.getAttachment().getClass())) {
-                return;
-            }
-
-            try {
-                NettyResponseFuture<?> nettyResponse = NettyResponseFuture.class.cast(ctx.getAttachment());
-                WebSocketUpgradeHandler h = WebSocketUpgradeHandler.class.cast(nettyResponse.getAsyncHandler());
-                NettyWebSocket webSocket = NettyWebSocket.class.cast(h.onCompleted());
-
-                webSocket.close();
-            } catch (Throwable t) {
-                log.error("onError", t);
-            }
-        }
-    }
-
-    private static boolean isWebSocket(URI uri) {
-        return WEBSOCKET.equalsIgnoreCase(uri.getScheme()) || WEBSOCKET_SSL.equalsIgnoreCase(uri.getScheme());
-    }
-
-    private static boolean isSecure(String scheme) {
-        return HTTPS.equalsIgnoreCase(scheme) || WEBSOCKET_SSL.equalsIgnoreCase(scheme);
-    }
-
-    private static boolean isSecure(URI uri) {
-        return isSecure(uri.getScheme());
-    }
-}
diff --git a/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/NettyConnectListener.java b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/NettyConnectListener.java
deleted file mode 100644
index 6a2bde0e4..000000000
--- a/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/NettyConnectListener.java
+++ /dev/null
@@ -1,148 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- *
- */
-package com.ning.http.client.providers.chanmgr;
-
-import com.ning.http.client.AsyncHandler;
-import com.ning.http.client.AsyncHttpClientConfig;
-import com.ning.http.client.Request;
-import org.jboss.netty.buffer.ChannelBuffer;
-import org.jboss.netty.channel.Channel;
-import org.jboss.netty.channel.ChannelFuture;
-import org.jboss.netty.channel.ChannelFutureListener;
-import org.jboss.netty.handler.codec.http.HttpRequest;
-import org.jboss.netty.handler.ssl.SslHandler;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import javax.net.ssl.HostnameVerifier;
-import java.io.IOException;
-import java.net.ConnectException;
-import java.net.URI;
-import java.nio.channels.ClosedChannelException;
-import java.util.concurrent.atomic.AtomicBoolean;
-
-
-/**
- * Non Blocking connect.
- */
-final class NettyConnectListener<T> implements ChannelFutureListener {
-    private final static Logger logger = LoggerFactory.getLogger(NettyConnectListener.class);
-    private final AsyncHttpClientConfig config;
-    private final NettyResponseFuture<T> future;
-    private final HttpRequest nettyRequest;
-    private final AtomicBoolean handshakeDone = new AtomicBoolean(false);
-
-    private NettyConnectListener(AsyncHttpClientConfig config,
-                                 NettyResponseFuture<T> future,
-                                 HttpRequest nettyRequest) {
-        this.config = config;
-        this.future = future;
-        this.nettyRequest = nettyRequest;
-    }
-
-    public NettyResponseFuture<T> future() {
-        return future;
-    }
-
-    public final void operationComplete(ChannelFuture f) throws Exception {
-        if (f.isSuccess()) {
-            Channel channel = f.getChannel();
-            channel.getPipeline().getContext(NettyAsyncHttpProvider.class).setAttachment(future);
-            SslHandler sslHandler = (SslHandler) channel.getPipeline().get(NettyAsyncHttpProvider.SSL_HANDLER);
-            if (!handshakeDone.getAndSet(true) && (sslHandler != null)) {
-                ((SslHandler) channel.getPipeline().get(NettyAsyncHttpProvider.SSL_HANDLER)).handshake().addListener(this);
-                return;
-            }
-
-            HostnameVerifier v = config.getHostnameVerifier();
-            if (sslHandler != null) {
-                if (!v.verify(future.getURI().getHost(), sslHandler.getEngine().getSession())) {
-                	ConnectException exception = new ConnectException("HostnameVerifier exception.");
-                	future.abort(exception);
-                	throw exception;
-                }
-            }
-
-            future.provider().writeRequest(f.getChannel(), config, future, nettyRequest);
-        } else {
-            Throwable cause = f.getCause();
-
-            logger.debug("Trying to recover a dead cached channel {} with a retry value of {} ", f.getChannel(), future.canRetry());
-            if (future.canRetry() && cause != null && (NettyAsyncHttpProvider.abortOnDisconnectException(cause)
-                    || ClosedChannelException.class.isAssignableFrom(cause.getClass())
-                    || future.getState() != NettyResponseFuture.STATE.NEW)) {
-
-                logger.debug("Retrying {} ", nettyRequest);
-                if (future.provider().remotelyClosed(f.getChannel(), future)) {
-                    return;
-                }
-            }
-
-            logger.debug("Failed to recover from exception: {} with channel {}", cause, f.getChannel());
-
-            boolean printCause = f.getCause() != null && cause.getMessage() != null;
-            ConnectException e = new ConnectException(printCause ? cause.getMessage() + " to " + future.getURI().toString() : future.getURI().toString());
-            if (cause != null) {
-                e.initCause(cause);
-            }
-            future.abort(e);
-        }
-    }
-
-    public static class Builder<T> {
-        private final AsyncHttpClientConfig config;
-
-        private final Request request;
-        private final AsyncHandler<T> asyncHandler;
-        private NettyResponseFuture<T> future;
-        private final NettyAsyncHttpProvider provider;
-        private final ChannelBuffer buffer;
-
-        public Builder(AsyncHttpClientConfig config, Request request, AsyncHandler<T> asyncHandler,
-                       NettyAsyncHttpProvider provider, ChannelBuffer buffer) {
-
-            this.config = config;
-            this.request = request;
-            this.asyncHandler = asyncHandler;
-            this.future = null;
-            this.provider = provider;
-            this.buffer = buffer;
-        }
-
-        public Builder(AsyncHttpClientConfig config, Request request, AsyncHandler<T> asyncHandler,
-                       NettyResponseFuture<T> future, NettyAsyncHttpProvider provider, ChannelBuffer buffer) {
-
-            this.config = config;
-            this.request = request;
-            this.asyncHandler = asyncHandler;
-            this.future = future;
-            this.provider = provider;
-            this.buffer = buffer;
-        }
-
-        public NettyConnectListener<T> build(final URI uri) throws IOException {
-            HttpRequest nettyRequest = NettyAsyncHttpProvider.buildRequest(config, request, uri, true, buffer);
-            if (future == null) {
-                future = NettyAsyncHttpProvider.newFuture(uri, request, asyncHandler, nettyRequest, config, provider);
-            } else {
-                future.setNettyRequest(nettyRequest);
-                future.setRequest(request);
-            }
-            return new NettyConnectListener<T>(config, future, nettyRequest);
-        }
-    }
-}
diff --git a/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/chain/AConnectListener.java b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/chain/AConnectListener.java
new file mode 100644
index 000000000..8f9a80527
--- /dev/null
+++ b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/chain/AConnectListener.java
@@ -0,0 +1,40 @@
+package com.ning.http.client.providers.chanmgr.chain;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+
+import org.playorm.nio.api.channels.Channel;
+import org.playorm.nio.api.channels.RegisterableChannel;
+import org.playorm.nio.api.handlers.FutureOperation;
+import org.playorm.nio.api.handlers.OperationCallback;
+
+import com.ning.http.client.providers.chanmgr.ChanMgrResponseFuture;
+
+public class AConnectListener<T> implements OperationCallback {
+
+	private ChanMgrResponseFuture<T> future;
+
+	public AConnectListener(ChanMgrResponseFuture<T> future) {
+		this.future = future;
+	}
+
+	@Override
+	public void finished(Channel c) throws IOException {
+		performWrite(c);
+	}
+
+	@Override
+	public void failed(RegisterableChannel c, Throwable e) {
+		// TODO Auto-generated method stub
+		
+	}
+
+	public void performWrite(Channel c) {
+		BWriteListener<T> writeListener = new BWriteListener<T>(future);
+		
+		ByteBuffer b = null;
+		FutureOperation futureOp = c.write(b);
+		futureOp.setListener(writeListener);
+	}
+
+}
diff --git a/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/chain/BWriteListener.java b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/chain/BWriteListener.java
new file mode 100644
index 000000000..9e7d2fe84
--- /dev/null
+++ b/providers/channelmgr/src/main/java/com/ning/http/client/providers/chanmgr/chain/BWriteListener.java
@@ -0,0 +1,28 @@
+package com.ning.http.client.providers.chanmgr.chain;
+
+import java.io.IOException;
+
+import org.playorm.nio.api.channels.Channel;
+import org.playorm.nio.api.channels.RegisterableChannel;
+import org.playorm.nio.api.handlers.OperationCallback;
+
+import com.ning.http.client.providers.chanmgr.ChanMgrResponseFuture;
+
+public class BWriteListener<T> implements OperationCallback {
+
+	private ChanMgrResponseFuture<T> future;
+
+	public BWriteListener(ChanMgrResponseFuture<T> future) {
+		this.future = future;
+	}
+
+	@Override
+	public void finished(Channel c) throws IOException {
+		//is there anyway to notify the client in async-http-client that the write request went through?
+	}
+
+	@Override
+	public void failed(RegisterableChannel c, Throwable e) {
+	}
+
+}
diff --git a/providers/channelmgr/src/main/java/com/ning/http/pool/AsyncConnectionPool.java b/providers/channelmgr/src/main/java/com/ning/http/pool/AsyncConnectionPool.java
new file mode 100644
index 000000000..2a57eaf39
--- /dev/null
+++ b/providers/channelmgr/src/main/java/com/ning/http/pool/AsyncConnectionPool.java
@@ -0,0 +1,18 @@
+package com.ning.http.pool;
+
+public interface AsyncConnectionPool<T> {
+
+	public void setCreator(ConnectionCreator<T> creator);
+
+	/**
+	 * Fires back the connection when available to the listener which may be immediately or if pool is used up
+	 * will be when another connection becomes available OR when request timeout period elapses, we fire back
+	 * a timeout event as request timeout has exceeded.
+	 * 
+	 * @param l
+	 */
+	void obtainConnection(String baseUrl, ConnectionAvailableListener<T> l);
+	
+	void releaseConnection(Connection<T> state);	
+	
+}
diff --git a/providers/channelmgr/src/main/java/com/ning/http/pool/AsyncConnectionPoolImpl.java b/providers/channelmgr/src/main/java/com/ning/http/pool/AsyncConnectionPoolImpl.java
new file mode 100644
index 000000000..24ea5e59c
--- /dev/null
+++ b/providers/channelmgr/src/main/java/com/ning/http/pool/AsyncConnectionPoolImpl.java
@@ -0,0 +1,181 @@
+package com.ning.http.pool;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.TimeUnit;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.ning.http.client.providers.chanmgr.ChanMgrAsyncHttpProvider;
+import com.ning.http.client.providers.chanmgr.ChanMgrConnectionsPool;
+
+public class AsyncConnectionPoolImpl<T> implements AsyncConnectionPool<T> {
+
+    private final static Logger log = LoggerFactory.getLogger(ChanMgrConnectionsPool.class);
+    private final ConcurrentHashMap<String, HostPool<T>> connectionsPool = new ConcurrentHashMap<String, HostPool<T>>();
+    private List<PendingRequest<T>> pendingRequests = new ArrayList<PendingRequest<T>>();
+    
+    //private final boolean sslConnectionPoolEnabled;
+    private final int maxTotalConnections;
+    private final int maxConnectionPerHost;
+    private final long maxIdleTime;
+	private ConnectionCreator<T> creator;
+	private int requestTimeout;
+	private ScheduledExecutorService timer;
+
+    public AsyncConnectionPoolImpl(PoolConfig config, ScheduledExecutorService svc) {
+        this.maxTotalConnections = config.getMaxTotalConnections();
+        this.maxConnectionPerHost = config.getMaxConnectionPerHost();
+        //this.sslConnectionPoolEnabled = config.isSslConnectionPoolEnabled();
+        this.maxIdleTime = config.getIdleConnectionInPoolTimeoutInMs();
+        this.requestTimeout = config.getRequestTimeoutInMs();
+        this.timer = svc;
+        timer.scheduleAtFixedRate(new IdleChannelDetector(), maxIdleTime, maxIdleTime, TimeUnit.MILLISECONDS);
+    }
+
+	@Override
+	public void setCreator(ConnectionCreator<T> creator) {
+		this.creator = creator;
+	}
+
+	@Override
+	public void obtainConnection(String baseUrl, ConnectionAvailableListener<T> l) {
+		HostPool<T> idleConnectionForHost = fetchQueue(baseUrl, connectionsPool);
+		
+		int maxPerHost = Integer.MAX_VALUE;
+		int max = Integer.MAX_VALUE;
+		
+		if(maxConnectionPerHost > 0)
+			maxPerHost = maxConnectionPerHost;
+		if(maxTotalConnections > 0)
+			max = maxTotalConnections;
+
+        synchronized(this) {
+            int size = idleConnectionForHost.numInUse();
+            if(getTotalSize() >= max) {
+            	log.debug("Maximum number of requests reached for total="+maxTotalConnections+" We are waiting for release of connection now ms="+requestTimeout);
+            	schedulePendingRequest(baseUrl, l);
+            } else if(size >= maxPerHost) {
+	        	log.debug("Maximum number of requests reached for host="+baseUrl+" total="+maxConnectionPerHost+" We are waiting for release of connection now ms="+requestTimeout);
+	        	schedulePendingRequest(baseUrl, l);
+	        } else {
+	        	Connection<T> connection = idleConnectionForHost.grabConnection(creator);
+	        	connection.setBaseUrl(baseUrl);
+	        	l.connectionAvailable(connection);
+	        }
+        }
+	}
+
+	private int getTotalSize() {
+		//because we are outside every other hosts sync blocks, this is approximate but good enough for keeping connections roughly within
+		//the total amoune of connections
+		int total = 0;
+		for(HostPool<T> host : connectionsPool.values()) {
+			total += host.numTotalConnections();
+		}
+		return total;
+	}
+
+	private void schedulePendingRequest(String baseUrl, ConnectionAvailableListener<T> l) {
+		//we need to queue the request
+		PendingRequest<T> r = new PendingRequest<T>(l, baseUrl);
+		ScheduledFuture<?> future = timer.schedule(r, requestTimeout, TimeUnit.MILLISECONDS);
+		r.setFuture(future);
+
+		pendingRequests.add(r);
+	}
+
+	private static <Z> HostPool<Z> fetchQueue(String baseUrl, ConcurrentHashMap<String, HostPool<Z>> map) {
+		HostPool<Z> queue = map.get(baseUrl);
+		if(queue == null) {
+			HostPool<Z> newOne = new HostPool<Z>();
+			queue = map.putIfAbsent(baseUrl, newOne);
+			if(queue == null)
+				queue = newOne;			
+		}
+
+		return queue;
+	}
+
+	@Override
+	public void releaseConnection(Connection<T> state) {
+		String baseUrl = state.getBaseUrl();
+		state.setLastTimeUsed(System.currentTimeMillis());
+		
+		int maxPerHost = Integer.MAX_VALUE;
+		int max = Integer.MAX_VALUE;
+		
+		if(maxConnectionPerHost > 0)
+			maxPerHost = maxConnectionPerHost;
+		if(maxTotalConnections > 0)
+			max = maxTotalConnections;
+		
+		HostPool<T> idleConnectionsForHost = fetchQueue(baseUrl, connectionsPool);
+		synchronized(this) {
+			//release the connection back to it's pool
+			idleConnectionsForHost.releaseConnection(state);
+			
+			//fetch the next pending request which could be for any pool
+			for(int i = 0; i < pendingRequests.size(); i++) {
+				PendingRequest<T> request = pendingRequests.get(i);
+				if(process(request, maxPerHost, max))
+					break; 
+			}
+		}
+	}
+
+	private boolean process(PendingRequest<T> request, int maxPerHost, int max) {
+		HostPool<T> pool = fetchQueue(request.getBaseUrl(), connectionsPool);
+		int numInUse = pool.numInUse();
+        if(numInUse >= maxPerHost) {
+        	log.debug("Pool still at max connections, skip this pending request=" +request.getBaseUrl());
+        	return false;
+        } else {
+        	Connection<T> connection = pool.grabConnection(creator);
+        	connection.setBaseUrl(request.getBaseUrl());
+        	request.connectionAvailable(connection);
+        	return true;
+        }
+	}
+
+	private class IdleChannelDetector implements Runnable {
+
+		@Override
+		public void run() {
+			//can't iterate over open 
+			for(HostPool<T> pool : connectionsPool.values()) {
+				//synchronize inside the for loop such that other threads still have a chance to obtain connections so if
+				//there was 1000 connections, we don't stay in the loop too long(unless they are all to one server :( ).
+				synchronized(AsyncConnectionPoolImpl.this) {
+					pool.releaseIdleConnections(maxIdleTime);
+				}
+			}
+		}
+
+	}
+
+	@Override
+	public String toString() {
+		String poolStr = "ConnectionPool...\n";
+		for(String key : connectionsPool.keySet()) {
+			HostPool<T> pool = connectionsPool.get(key);
+			poolStr += key+"="+pool+"\n";
+		}
+		return poolStr;
+	}
+
+	public int getNumIdleConnections() {
+		return 0;
+	}
+
+	public int getNumInUseConnections() {
+		return 0;
+	}
+	
+}
diff --git a/providers/channelmgr/src/main/java/com/ning/http/pool/Connection.java b/providers/channelmgr/src/main/java/com/ning/http/pool/Connection.java
new file mode 100644
index 000000000..23f531a8c
--- /dev/null
+++ b/providers/channelmgr/src/main/java/com/ning/http/pool/Connection.java
@@ -0,0 +1,40 @@
+package com.ning.http.pool;
+
+public abstract class Connection<T> {
+
+	private String baseUrl;
+	private T channel;
+	private long lastTimeUsed;
+	
+	public Connection(T channel2) {
+		this.channel = channel2;
+		this.lastTimeUsed = System.currentTimeMillis();
+	}
+
+	
+	/**
+	 * Implement how to close the channel so you can do getChannel().close() in the subclass.
+	 */
+	protected abstract void close();
+	
+	public String getBaseUrl() {
+		return baseUrl;
+	}
+
+	void setBaseUrl(String uri) {
+		this.baseUrl = uri;
+	}
+
+	void setLastTimeUsed(long currentTimeMillis) {
+		this.lastTimeUsed = currentTimeMillis;
+	}
+
+	long getLastTimeUsed() {
+		return lastTimeUsed;
+	}
+
+	public T getChannel() {
+		return channel;
+	}
+	
+}
diff --git a/providers/channelmgr/src/main/java/com/ning/http/pool/ConnectionAvailableListener.java b/providers/channelmgr/src/main/java/com/ning/http/pool/ConnectionAvailableListener.java
new file mode 100644
index 000000000..a89a9920b
--- /dev/null
+++ b/providers/channelmgr/src/main/java/com/ning/http/pool/ConnectionAvailableListener.java
@@ -0,0 +1,13 @@
+package com.ning.http.pool;
+
+public interface ConnectionAvailableListener<T> {
+
+	void connectionAvailable(Connection<T> connection);
+
+	/**
+	 * IF waiting for a connection to be released, we exceed the timeout period, we call this method on failure
+	 * @param uri
+	 */
+	void timeoutNotAvailble(String uri);
+
+}
diff --git a/providers/channelmgr/src/main/java/com/ning/http/pool/ConnectionCreator.java b/providers/channelmgr/src/main/java/com/ning/http/pool/ConnectionCreator.java
new file mode 100644
index 000000000..4bea36715
--- /dev/null
+++ b/providers/channelmgr/src/main/java/com/ning/http/pool/ConnectionCreator.java
@@ -0,0 +1,7 @@
+package com.ning.http.pool;
+
+public interface ConnectionCreator<T> {
+
+	Connection<T> createConnection();
+
+}
diff --git a/providers/channelmgr/src/main/java/com/ning/http/pool/HostPool.java b/providers/channelmgr/src/main/java/com/ning/http/pool/HostPool.java
new file mode 100644
index 000000000..3774b5c16
--- /dev/null
+++ b/providers/channelmgr/src/main/java/com/ning/http/pool/HostPool.java
@@ -0,0 +1,63 @@
+package com.ning.http.pool;
+
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Set;
+import java.util.concurrent.ConcurrentLinkedQueue;
+
+public class HostPool<T> {
+
+	private ConcurrentLinkedQueue<Connection<T>> idleConnections = new ConcurrentLinkedQueue<Connection<T>>();
+	private Set<Connection<T>> inUseConnections = new HashSet<Connection<T>>();
+
+	@Override
+	public String toString() {
+		return "[IDLE="+idleConnections+",   IN_USE="+inUseConnections+"]";
+	}
+
+	public Connection<T> grabConnection(ConnectionCreator<T> creator) {
+    	Connection<T> conn = idleConnections.poll();
+    	if(conn == null) {
+    		conn = creator.createConnection();
+    	}
+    	
+		if(conn != null)
+			inUseConnections.add(conn);
+		return conn;
+	}
+	
+	public void releaseConnection(Connection<T> conn) {
+		inUseConnections.remove(conn);
+		idleConnections.add(conn);
+	}
+
+//	public void addPendingRequest(PendingRequest<T> request) {
+//		pendingRequests.add(request);
+//	}
+//	
+	public int numIdle() {
+		return idleConnections.size();
+	}
+
+	public int numInUse() {
+		return inUseConnections.size();
+	}
+
+	public int numTotalConnections() {
+		return idleConnections.size() + inUseConnections.size();
+	}
+
+	public void releaseIdleConnections(long maxIdleTime) {
+		long now = System.currentTimeMillis();
+		Iterator<Connection<T>> iterator = idleConnections.iterator();
+		while(iterator.hasNext()) {
+			Connection<T> conn = iterator.next();
+			long time = conn.getLastTimeUsed();
+
+			if(now-time > maxIdleTime) {
+				idleConnections.remove(conn);
+				conn.close();
+			}
+		}
+	}
+}
diff --git a/providers/channelmgr/src/main/java/com/ning/http/pool/PendingRequest.java b/providers/channelmgr/src/main/java/com/ning/http/pool/PendingRequest.java
new file mode 100644
index 000000000..16f88f8ef
--- /dev/null
+++ b/providers/channelmgr/src/main/java/com/ning/http/pool/PendingRequest.java
@@ -0,0 +1,49 @@
+package com.ning.http.pool;
+
+import java.util.concurrent.ScheduledFuture;
+
+class PendingRequest<T> implements Runnable {
+	private ConnectionAvailableListener<T> listener;
+	private String baseUrl;
+	private ScheduledFuture<?> future;
+	private boolean wasRun = false;
+	private boolean cancelled = false;
+	public PendingRequest(ConnectionAvailableListener<T> listener, String baseUrl) {
+		super();
+		this.listener = listener;
+		this.baseUrl = baseUrl;
+	}
+
+	public void setFuture(ScheduledFuture<?> future) {
+		this.future = future;
+	}
+
+	@Override
+	public synchronized void run() {
+		if(wasRun)
+			return; //nothing to do, it barely beat us
+		cancelled = true;
+
+		listener.timeoutNotAvailble(baseUrl);
+	}
+
+	/**
+	 * Returns whether we actually ran it.  true if successful, false if it was cancelled
+	 * @param conn
+	 * @return
+	 */
+	public synchronized boolean connectionAvailable(Connection<T> conn) {
+		if(cancelled == true)
+			return false;
+		wasRun = true;
+		if(future != null)
+			future.cancel(true);
+		
+		listener.connectionAvailable(conn);
+		return true;
+	}
+
+	public String getBaseUrl() {
+		return baseUrl;
+	}
+}
\ No newline at end of file
diff --git a/providers/channelmgr/src/main/java/com/ning/http/pool/PoolConfig.java b/providers/channelmgr/src/main/java/com/ning/http/pool/PoolConfig.java
new file mode 100644
index 000000000..df6d290d4
--- /dev/null
+++ b/providers/channelmgr/src/main/java/com/ning/http/pool/PoolConfig.java
@@ -0,0 +1,44 @@
+package com.ning.http.pool;
+
+public class PoolConfig {
+
+	private int maxTotalConnections;
+	private int maxConnectionPerHost;
+	private long idleConnectionInPoolTimeoutInMs;
+	private int requestTimeoutInMs;
+
+	
+	public void setMaxTotalConnections(int maxTotalConnections) {
+		this.maxTotalConnections = maxTotalConnections;
+	}
+
+	public void setMaxConnectionPerHost(int maxConnectionPerHost) {
+		this.maxConnectionPerHost = maxConnectionPerHost;
+	}
+
+	public void setIdleConnectionInPoolTimeoutInMs(
+			long idleConnectionInPoolTimeoutInMs) {
+		this.idleConnectionInPoolTimeoutInMs = idleConnectionInPoolTimeoutInMs;
+	}
+
+	public void setRequestTimeoutInMs(int requestTimeoutInMs) {
+		this.requestTimeoutInMs = requestTimeoutInMs;
+	}
+
+	public int getMaxTotalConnections() {
+		return maxTotalConnections;
+	}
+
+	public int getMaxConnectionPerHost() {
+		return maxConnectionPerHost;
+	}
+
+	public long getIdleConnectionInPoolTimeoutInMs() {
+		return idleConnectionInPoolTimeoutInMs;
+	}
+
+	public int getRequestTimeoutInMs() {
+		return requestTimeoutInMs;
+	}
+
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/ChanMgrUtil.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/ChanMgrUtil.java
new file mode 100644
index 000000000..280a3ed13
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/ChanMgrUtil.java
@@ -0,0 +1,15 @@
+package com.ning.http.client.providers.chanmgr;
+
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.AsyncHttpClientConfig;
+
+public class ChanMgrUtil {
+
+	public static AsyncHttpClient provider(AsyncHttpClientConfig config) {
+        if (config == null) {
+            config = new AsyncHttpClientConfig.Builder().build();
+        }
+        return new AsyncHttpClient(new ChanMgrAsyncHttpProvider(config), config);
+	}
+
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyAsyncHttpProviderTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyAsyncHttpProviderTest.java
index a74883499..31daa3fcb 100644
--- a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyAsyncHttpProviderTest.java
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyAsyncHttpProviderTest.java
@@ -12,25 +12,21 @@
  */
 package com.ning.http.client.providers.chanmgr;
 
+import static org.testng.Assert.assertEquals;
+
+import org.testng.annotations.Test;
+
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.Response;
 import com.ning.http.client.async.AbstractBasicTest;
-import com.ning.http.client.async.ProviderUtil;
-import com.ning.http.client.providers.chanmgr.NettyAsyncHttpProviderConfig;
-
-import org.testng.annotations.Test;
-
-import java.util.concurrent.Executors;
-
-import static org.testng.Assert.assertEquals;
 
 public class NettyAsyncHttpProviderTest extends AbstractBasicTest {
 
     @Test
     public void bossThreadPoolExecutor() throws Throwable {
-        NettyAsyncHttpProviderConfig conf = new NettyAsyncHttpProviderConfig();
-        conf.addProperty(NettyAsyncHttpProviderConfig.BOSS_EXECUTOR_SERVICE, Executors.newSingleThreadExecutor());
+        ChanMgrAsyncHttpProviderConfig conf = new ChanMgrAsyncHttpProviderConfig();
+        //conf.addProperty(ChanMgrAsyncHttpProviderConfig.BOSS_EXECUTOR_SERVICE, Executors.newSingleThreadExecutor());
 
         AsyncHttpClientConfig cf = new AsyncHttpClientConfig.Builder().setAsyncHttpClientProviderConfig(conf).build();
         AsyncHttpClient c = getAsyncHttpClient(cf);
@@ -42,6 +38,6 @@ public void bossThreadPoolExecutor() throws Throwable {
 
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return ChanMgrUtil.provider(config);
     }
 }
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyAsyncProviderBasicTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyAsyncProviderBasicTest.java
index 54a306499..7e2f5c994 100644
--- a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyAsyncProviderBasicTest.java
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyAsyncProviderBasicTest.java
@@ -17,7 +17,7 @@
 import com.ning.http.client.AsyncHttpProviderConfig;
 import com.ning.http.client.async.AsyncProvidersBasicTest;
 import com.ning.http.client.async.ProviderUtil;
-import com.ning.http.client.providers.chanmgr.NettyAsyncHttpProviderConfig;
+import com.ning.http.client.providers.chanmgr.ChanMgrAsyncHttpProviderConfig;
 
 public class NettyAsyncProviderBasicTest extends AsyncProvidersBasicTest {
 
@@ -28,8 +28,8 @@ public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
 
     @Override
     protected AsyncHttpProviderConfig getProviderConfig() {
-        final NettyAsyncHttpProviderConfig config = 
-                new NettyAsyncHttpProviderConfig();
+        final ChanMgrAsyncHttpProviderConfig config = 
+                new ChanMgrAsyncHttpProviderConfig();
         config.addProperty("tcpNoDelay", true);
         return config;
     }
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyChunkingTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyChunkingTest.java
index 974f20e86..a86f7d391 100644
--- a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyChunkingTest.java
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyChunkingTest.java
@@ -1,13 +1,19 @@
 package com.ning.http.client.providers.chanmgr;
 
+import org.testng.annotations.Test;
+
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.async.ChunkingTest;
-import com.ning.http.client.async.ProviderUtil;
 
 public class NettyChunkingTest extends ChunkingTest {
     @Override
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
-        return ProviderUtil.nettyProvider(config);
+        return ChanMgrUtil.provider(config);
+    }
+    
+    @Test()
+    public void testCustomChunking() throws Throwable {
+    	super.testCustomChunking();
     }
 }
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyRedirectConnectionUsageTest.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyRedirectConnectionUsageTest.java
index cef8cfb75..5d062d5be 100644
--- a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyRedirectConnectionUsageTest.java
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/NettyRedirectConnectionUsageTest.java
@@ -17,7 +17,7 @@
 import com.ning.http.client.AsyncHttpProviderConfig;
 import com.ning.http.client.async.ProviderUtil;
 import com.ning.http.client.async.RedirectConnectionUsageTest;
-import com.ning.http.client.providers.chanmgr.NettyAsyncHttpProviderConfig;
+import com.ning.http.client.providers.chanmgr.ChanMgrAsyncHttpProviderConfig;
 
 public class NettyRedirectConnectionUsageTest extends RedirectConnectionUsageTest {
     @Override
@@ -27,11 +27,8 @@ public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
 
     @Override
     protected AsyncHttpProviderConfig getProviderConfig() {
-        final NettyAsyncHttpProviderConfig config = 
-                new NettyAsyncHttpProviderConfig();
-        if (System.getProperty("blockingio") != null) {
-            config.addProperty(NettyAsyncHttpProviderConfig.USE_BLOCKING_IO, "true");
-        }
+        final ChanMgrAsyncHttpProviderConfig config = 
+                new ChanMgrAsyncHttpProviderConfig();
         return config;
     }
 }
diff --git a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/RetryNonBlockingIssue.java b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/RetryNonBlockingIssue.java
index 9ab80ae22..1e8c800b3 100644
--- a/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/RetryNonBlockingIssue.java
+++ b/providers/channelmgr/src/test/java/com/ning/http/client/providers/chanmgr/RetryNonBlockingIssue.java
@@ -17,7 +17,7 @@
 import com.ning.http.client.ListenableFuture;
 import com.ning.http.client.RequestBuilder;
 import com.ning.http.client.Response;
-import com.ning.http.client.providers.chanmgr.NettyAsyncHttpProviderConfig;
+import com.ning.http.client.providers.chanmgr.ChanMgrAsyncHttpProviderConfig;
 
 import org.eclipse.jetty.server.Connector;
 import org.eclipse.jetty.server.Server;
@@ -140,8 +140,8 @@ public void testRetryNonBlocking() throws IOException, InterruptedException,
             bc.setConnectionTimeoutInMs(60000);
             bc.setRequestTimeoutInMs(30000);
 
-            NettyAsyncHttpProviderConfig config = new
-                    NettyAsyncHttpProviderConfig();
+            ChanMgrAsyncHttpProviderConfig config = new
+                    ChanMgrAsyncHttpProviderConfig();
 
             bc.setAsyncHttpClientProviderConfig(config);
             c = new AsyncHttpClient(bc.build());
@@ -184,9 +184,9 @@ public void testRetryNonBlockingAsyncConnect() throws IOException, InterruptedEx
             bc.setConnectionTimeoutInMs(60000);
             bc.setRequestTimeoutInMs(30000);
 
-            NettyAsyncHttpProviderConfig config = new
-                    NettyAsyncHttpProviderConfig();
-            config.addProperty(NettyAsyncHttpProviderConfig.EXECUTE_ASYNC_CONNECT, "true");
+            ChanMgrAsyncHttpProviderConfig config = new
+                    ChanMgrAsyncHttpProviderConfig();
+            //config.addProperty(ChanMgrAsyncHttpProviderConfig.EXECUTE_ASYNC_CONNECT, "true");
 
             bc.setAsyncHttpClientProviderConfig(config);
             c = new AsyncHttpClient(bc.build());
@@ -229,9 +229,9 @@ public void testRetryBlocking() throws IOException, InterruptedException,
             bc.setConnectionTimeoutInMs(30000);
             bc.setRequestTimeoutInMs(30000);
 
-            NettyAsyncHttpProviderConfig config = new
-                    NettyAsyncHttpProviderConfig();
-            config.addProperty(NettyAsyncHttpProviderConfig.USE_BLOCKING_IO, "true");
+            ChanMgrAsyncHttpProviderConfig config = new
+                    ChanMgrAsyncHttpProviderConfig();
+            //config.addProperty(ChanMgrAsyncHttpProviderConfig.USE_BLOCKING_IO, "true");
 
             bc.setAsyncHttpClientProviderConfig(config);
             c = new AsyncHttpClient(bc.build());
diff --git a/providers/channelmgr/src/test/java/com/ning/http/pool/MockCreator.java b/providers/channelmgr/src/test/java/com/ning/http/pool/MockCreator.java
new file mode 100644
index 000000000..ad60db8eb
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/pool/MockCreator.java
@@ -0,0 +1,25 @@
+package com.ning.http.pool;
+
+public class MockCreator implements ConnectionCreator<Integer> {
+
+	private int counter;
+	
+	@Override
+	public Connection<Integer> createConnection() {
+		return new MyConnection(counter++);
+	}
+	
+	private class MyConnection extends Connection<Integer> {
+
+		private boolean isClosed;
+
+		public MyConnection(int channel) {
+			super(channel);
+		}
+
+		@Override
+		protected void close() {
+			isClosed = true;
+		}
+	}
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/pool/MockListener.java b/providers/channelmgr/src/test/java/com/ning/http/pool/MockListener.java
new file mode 100644
index 000000000..1aed02feb
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/pool/MockListener.java
@@ -0,0 +1,31 @@
+package com.ning.http.pool;
+
+public class MockListener implements ConnectionAvailableListener<Integer> {
+
+	private Connection<Integer> connection;
+	private String uri;
+
+	@Override
+	public void connectionAvailable(Connection<Integer> connection) {
+		this.connection = connection;
+	}
+
+	@Override
+	public void timeoutNotAvailble(String uri) {
+		this.uri = uri;
+	}
+
+	public Connection<Integer> fetchAndReset() {
+		Connection<Integer> temp = connection;
+		connection = null;
+		return temp;
+	}
+
+	public String fetchFailure() {
+		String temp = uri;
+		uri = null;
+		return temp;
+	}
+	
+	
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/pool/MockTimer.java b/providers/channelmgr/src/test/java/com/ning/http/pool/MockTimer.java
new file mode 100644
index 000000000..dcdd15062
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/pool/MockTimer.java
@@ -0,0 +1,141 @@
+package com.ning.http.pool;
+
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+
+public class MockTimer implements ScheduledExecutorService {
+
+	private Runnable idleRunnable;
+	private Runnable lastRunnable;
+
+	@Override
+	public void shutdown() {
+		// TODO Auto-generated method stub
+		
+	}
+
+	@Override
+	public List<Runnable> shutdownNow() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public boolean isShutdown() {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	@Override
+	public boolean isTerminated() {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	@Override
+	public boolean awaitTermination(long timeout, TimeUnit unit)
+			throws InterruptedException {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	@Override
+	public <T> Future<T> submit(Callable<T> task) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public <T> Future<T> submit(Runnable task, T result) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public Future<?> submit(Runnable task) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
+			throws InterruptedException {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public <T> List<Future<T>> invokeAll(
+			Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)
+			throws InterruptedException {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public <T> T invokeAny(Collection<? extends Callable<T>> tasks)
+			throws InterruptedException, ExecutionException {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public <T> T invokeAny(Collection<? extends Callable<T>> tasks,
+			long timeout, TimeUnit unit) throws InterruptedException,
+			ExecutionException, TimeoutException {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public void execute(Runnable command) {
+		// TODO Auto-generated method stub
+		
+	}
+
+	@Override
+	public ScheduledFuture<?> schedule(Runnable command, long delay,
+			TimeUnit unit) {
+		this.lastRunnable = command;
+		return null;
+	}
+
+	@Override
+	public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay,
+			TimeUnit unit) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public ScheduledFuture<?> scheduleAtFixedRate(Runnable command,
+			long initialDelay, long period, TimeUnit unit) {
+		this.idleRunnable= command;
+		return null;
+	}
+
+	@Override
+	public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command,
+			long initialDelay, long delay, TimeUnit unit) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	public Runnable fetchRunnableAndReset() {
+		Runnable temp = lastRunnable;
+		lastRunnable = null;
+		return temp;
+	}
+
+	public Runnable fetchIdleRunnable() {
+		return idleRunnable;
+	}
+
+}
diff --git a/providers/channelmgr/src/test/java/com/ning/http/pool/PoolTests.java b/providers/channelmgr/src/test/java/com/ning/http/pool/PoolTests.java
new file mode 100644
index 000000000..fdd8dc29a
--- /dev/null
+++ b/providers/channelmgr/src/test/java/com/ning/http/pool/PoolTests.java
@@ -0,0 +1,134 @@
+package com.ning.http.pool;
+
+import org.testng.Assert;
+import org.testng.annotations.BeforeMethod;
+import org.testng.annotations.Test;
+
+public class PoolTests {
+
+	private AsyncConnectionPoolImpl<Integer> pool;
+	private MockTimer mockTimer;
+	private Runnable idleConnectionRunnable;
+
+	@BeforeMethod
+	public void setup() {
+		mockTimer = new MockTimer();
+    	
+		PoolConfig config = new PoolConfig();
+		config.setMaxConnectionPerHost(2);
+		config.setMaxTotalConnections(3);
+		config.setRequestTimeoutInMs(100000);
+		pool = new AsyncConnectionPoolImpl<Integer>(config , mockTimer);
+    	
+		idleConnectionRunnable = mockTimer.fetchIdleRunnable();
+		
+		MockCreator mockCreator = new MockCreator();
+		pool.setCreator(mockCreator);
+	}
+	
+    @Test
+    public void testReuse() throws Throwable {
+		MockListener l = new MockListener();
+		Connection<Integer> conn1 = useUpTwoConnections(l);
+		
+		pool.releaseConnection(conn1);
+		
+		pool.obtainConnection("abc", l);
+		
+		Assert.assertNull(mockTimer.fetchRunnableAndReset());
+		
+		Connection<Integer> conn3 = l.fetchAndReset();
+		Assert.assertEquals(conn1, conn3);
+		Assert.assertEquals(conn1.getChannel(), conn3.getChannel());
+    }
+
+	private Connection<Integer> useUpTwoConnections(MockListener l) {
+		pool.obtainConnection("abc", l);
+		
+		//expect listener to fire immediately
+		Connection<Integer> conn1 = l.fetchAndReset();
+		Assert.assertEquals(new Integer(0), conn1.getChannel());
+		
+		pool.obtainConnection("abc", l);
+		Connection<Integer> conn2 = l.fetchAndReset();
+		Assert.assertEquals(new Integer(1), conn2.getChannel());
+		return conn1;
+	}
+    
+    @Test
+    public void testMaxHost() {
+		MockListener l = new MockListener();
+		Connection<Integer> conn1 = useUpTwoConnections(l);
+
+		MockListener list2 = new MockListener();
+		pool.obtainConnection("abc", list2);
+		//since we are full here, listener will not fire so verify null(ie. no fire happened)..
+		Assert.assertNull(list2.fetchAndReset());
+		//This means a runnable is scheduled as well
+		Runnable timeoutRunnable = mockTimer.fetchRunnableAndReset();
+		Assert.assertNotNull(timeoutRunnable);
+
+		//now, let's release a connection and see if we fire
+		pool.releaseConnection(conn1);
+		
+		//now the release fires...
+		Connection<Integer> conn3 = list2.fetchAndReset();
+		Assert.assertEquals(conn1, conn3);
+    }
+    
+    @Test
+    public void testMaxHostTimeout() {
+		MockListener l = new MockListener();
+		useUpTwoConnections(l);
+
+		MockListener list2 = new MockListener();
+		pool.obtainConnection("abc", list2);
+		//since we are full here, listener will not fire so verify null(ie. no fire happened)..
+		Assert.assertNull(list2.fetchAndReset());
+		//This means a runnable is scheduled as well
+		Runnable timeoutRunnable = mockTimer.fetchRunnableAndReset();
+		Assert.assertNotNull(timeoutRunnable);
+
+		//now if the timer fires, we have timed out and client should hear that through listener
+		timeoutRunnable.run();
+		String uri = list2.fetchFailure();
+		Assert.assertEquals("abc", uri);
+		
+    }
+    
+    @Test
+    public void testMaxTotal() {
+    	MockListener l = new MockListener();
+    	Connection<Integer> conn = useUpTwoConnections(l);
+    	
+    	MockListener list2 = new MockListener();
+    	//now use up last connection for total connections
+    	pool.obtainConnection("def", list2);
+    	Connection<Integer> conn3 = list2.fetchAndReset();
+    	Assert.assertEquals(new Integer(2), conn3.getChannel());
+    	
+    	MockListener list3 = new MockListener();
+    	//now this connection ends up in pending
+    	pool.obtainConnection("abc", list3);
+    	Assert.assertNull(list3.fetchAndReset());
+    	
+    	MockListener list4 = new MockListener();
+    	pool.obtainConnection("zyx", list4);
+    	Assert.assertNull(list4.fetchAndReset());
+    	
+    	pool.releaseConnection(conn3);
+    	//listener3 still can't fire because his pool is still full
+    	Assert.assertNull(list3.fetchAndReset());
+    	
+    	//BUT listener4 should fire as we are below max connections and he has no one in his pool
+    	Connection<Integer> conn4 = list4.fetchAndReset();
+    	Assert.assertNotNull(conn4);
+    	
+    	int idle = pool.getNumIdleConnections();
+    	int inUse = pool.getNumInUseConnections();
+    	Assert.assertEquals(3, idle+inUse);
+    	
+    	String poolStr = pool+"";
+    	System.out.println("poolStr="+poolStr);
+    }
+}
diff --git a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyChunkingTest.java b/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyChunkingTest.java
index f52a7a45f..f27f52858 100644
--- a/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyChunkingTest.java
+++ b/providers/netty/src/test/java/com/ning/http/client/providers/netty/NettyChunkingTest.java
@@ -1,5 +1,7 @@
 package com.ning.http.client.providers.netty;
 
+import org.testng.annotations.Test;
+
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
 import com.ning.http.client.async.ChunkingTest;
@@ -10,4 +12,12 @@
     public AsyncHttpClient getAsyncHttpClient(AsyncHttpClientConfig config) {
         return ProviderUtil.nettyProvider(config);
     }
+
+    @Test
+	@Override
+	public void testCustomChunking() throws Throwable {
+		// TODO Auto-generated method stub
+		super.testCustomChunking();
+	}
+    
 }
