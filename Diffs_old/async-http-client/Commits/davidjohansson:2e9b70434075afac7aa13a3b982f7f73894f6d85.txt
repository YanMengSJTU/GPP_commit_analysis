diff --git a/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsTest.java b/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsTest.java
index eaefdfc30..dc43db8ab 100644
--- a/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsTest.java
+++ b/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsTest.java
@@ -18,12 +18,17 @@
 import static org.testng.Assert.assertEquals;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
+import io.netty.channel.*;
+import io.netty.handler.codec.http.HttpContent;
 import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.LastHttpContent;
 import io.reactivex.Flowable;
 
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.IOException;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Enumeration;
@@ -51,7 +56,10 @@
 import org.asynchttpclient.ListenableFuture;
 import org.asynchttpclient.Response;
 import org.asynchttpclient.handler.StreamedAsyncHandler;
+import org.asynchttpclient.netty.channel.ChannelManager;
+import org.asynchttpclient.netty.util.ByteBufUtils;
 import org.asynchttpclient.test.TestUtils;
+import org.asynchttpclient.util.Base64;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
@@ -225,7 +233,10 @@ public void testStreamingPutImage() throws Exception {
 	@Test(groups = "standalone")
 	public void testConnectionDoesNotGetClosed() throws Exception {
 		// test that we can stream the same request multiple times
-		try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(100 * 6000))) {
+		try (AsyncHttpClient client = asyncHttpClient(config().setHttpAdditionalChannelInitializer(channel -> {
+			channel.pipeline().addBefore(ChannelManager.AHC_HTTP_HANDLER, "RequestChunksChecker",
+					new RequestChunksChecker());
+		}).setRequestTimeout(100 * 6000))) {
 			BoundRequestBuilder requestBuilder = client.preparePut(getTargetUrl())//
 					.setBody(createPublisher(LARGE_IMAGE_BYTES, 1000))//
 					.setHeader("X-" + CONTENT_LENGTH, LARGE_IMAGE_BYTES.length)//
@@ -247,12 +258,15 @@ public void testConnectionDoesNotGetClosed() throws Exception {
 			assertEquals(response.getStatusCode(), 200);
 			responseBody = response.getResponseBodyAsBytes();
 			assertEquals(Integer.valueOf(response.getHeader("X-" + CONTENT_LENGTH)).intValue(),
-					LARGE_IMAGE_BYTES.length, "Server side payload length invalid");
-			assertEquals(responseBody.length, LARGE_IMAGE_BYTES.length, "Client side payload length invalid");
+					LARGE_IMAGE_BYTES.length, "Length of request payload received by the server invalid");
+			assertEquals(responseBody.length, LARGE_IMAGE_BYTES.length,
+					"Length of response payload received from the server invalid");
 
 			try {
-				assertEquals(response.getHeader(CONTENT_MD5), LARGE_IMAGE_BYTES_MD5, "Server side payload MD5 invalid");
-				assertEquals(TestUtils.md5(responseBody), LARGE_IMAGE_BYTES_MD5, "Client side payload MD5 invalid");
+				assertEquals(response.getHeader(CONTENT_MD5), LARGE_IMAGE_BYTES_MD5,
+						"MD5 of request payload received by the server invalid");
+				assertEquals(TestUtils.md5(responseBody), LARGE_IMAGE_BYTES_MD5,
+						"MD5 of response payload received from the server invalid");
 				assertEquals(responseBody, LARGE_IMAGE_BYTES, "Image bytes weren't equal on subsequent test");
 			} catch (AssertionError e) {
 				e.printStackTrace();
@@ -293,8 +307,8 @@ public void streamedResponseTest() throws Throwable {
 		try (AsyncHttpClient c = asyncHttpClient()) {
 
 			SimpleSubscriber<HttpResponseBodyPart> subscriber = new SimpleSubscriber<>();
-			ListenableFuture<Void> future = c.preparePost(getTargetUrl())
-					.setBody(LARGE_IMAGE_BYTES).execute(new SimpleStreamedAsyncHandler(subscriber));
+			ListenableFuture<Void> future = c.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_BYTES)
+					.execute(new SimpleStreamedAsyncHandler(subscriber));
 
 			// block
 			future.get();
@@ -302,7 +316,8 @@ public void streamedResponseTest() throws Throwable {
 
 			// Run it again to check that the pipeline is in a good state
 			subscriber = new SimpleSubscriber<>();
-			future = c.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_BYTES).execute(new SimpleStreamedAsyncHandler(subscriber));
+			future = c.preparePost(getTargetUrl()).setBody(LARGE_IMAGE_BYTES)
+					.execute(new SimpleStreamedAsyncHandler(subscriber));
 
 			future.get();
 			assertEquals(getBytes(subscriber.getElements()), LARGE_IMAGE_BYTES);
@@ -538,4 +553,40 @@ public void remove() {
 			};
 		}
 	}
+
+	private static class RequestChunksChecker extends ChannelOutboundHandlerAdapter {
+
+		private static MessageDigest newMd5() {
+			try {
+				return MessageDigest.getInstance("MD5");
+			} catch (NoSuchAlgorithmException e) {
+				throw new InternalError(e);
+			}
+		}
+
+		private final MessageDigest md = newMd5();
+
+		@Override
+		public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
+
+			if (msg instanceof HttpContent) {
+
+				HttpContent content = (HttpContent) msg;
+				if (content.content().isReadable()) {
+					byte[] bytes = ByteBufUtils.byteBuf2Bytes(content.content().duplicate());
+					md.update(bytes, 0, bytes.length);
+				}
+
+				if (content instanceof LastHttpContent) {
+					String md5 = Base64.encode(md.digest());
+					if (!md5.equals(LARGE_IMAGE_BYTES_MD5)) {
+						new Exception("Sent a request payload with invalid MD5 of " + md5).printStackTrace();
+					}
+					md.reset();
+				}
+			}
+
+			super.write(ctx, msg, promise);
+		}
+	}
 }
