diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java b/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java
index 522fc7462..771f7e55e 100755
--- a/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java
@@ -15,11 +15,6 @@
 
 import static org.asynchttpclient.util.Assertions.assertNotNull;
 import static org.asynchttpclient.util.DateUtils.unpreciseMillisTime;
-import io.netty.channel.Channel;
-import io.netty.channel.ChannelId;
-import io.netty.util.Timeout;
-import io.netty.util.Timer;
-import io.netty.util.TimerTask;
 
 import java.net.InetSocketAddress;
 import java.util.*;
@@ -27,6 +22,7 @@
 import java.util.concurrent.ConcurrentLinkedDeque;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.function.Function;
 import java.util.function.Predicate;
 import java.util.stream.Collectors;
@@ -36,6 +32,12 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelId;
+import io.netty.util.Timeout;
+import io.netty.util.Timer;
+import io.netty.util.TimerTask;
+
 /**
  * A simple implementation of {@link ChannelPool} based on a {@link java.util.concurrent.ConcurrentHashMap}
  */
@@ -106,9 +108,13 @@ private void scheduleNewIdleChannelDetector(TimerTask task) {
     }
 
     private static final class IdleChannel {
+        
+        private static final AtomicIntegerFieldUpdater<IdleChannel> ownedField = AtomicIntegerFieldUpdater.newUpdater(IdleChannel.class, "owned");
+        
         final Channel channel;
         final long start;
-        final AtomicBoolean owned = new AtomicBoolean(false);
+        @SuppressWarnings("unused")
+        private volatile int owned = 0;
 
         IdleChannel(Channel channel, long start) {
             this.channel = assertNotNull(channel, "channel");
@@ -116,7 +122,7 @@ private void scheduleNewIdleChannelDetector(TimerTask task) {
         }
 
         public boolean takeOwnership() {
-            return owned.compareAndSet(false, true);
+            return ownedField.getAndSet(this, 1) == 0;
         }
 
         public Channel getChannel() {
diff --git a/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBasicAuthTest.java b/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBasicAuthTest.java
index ea05f2030..ecb24ab4e 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBasicAuthTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBasicAuthTest.java
@@ -25,11 +25,7 @@
 import java.util.concurrent.ExecutionException;
 import java.util.function.Function;
 
-import org.asynchttpclient.AbstractBasicTest;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.BasicAuthTest;
-import org.asynchttpclient.BoundRequestBuilder;
-import org.asynchttpclient.Response;
+import org.asynchttpclient.*;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.ServerConnector;
 import org.eclipse.jetty.server.handler.AbstractHandler;
@@ -71,7 +67,6 @@ private void expectBrokenPipe(Function<BoundRequestBuilder, BoundRequestBuilder>
         }
 
         assertTrue(cause instanceof IOException, "Expected an IOException");
-        assertEquals(cause.getMessage(), "Broken pipe");
     }
 
     @Test(groups = "standalone")
