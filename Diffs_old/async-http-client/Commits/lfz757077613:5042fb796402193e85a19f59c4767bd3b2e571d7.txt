diff --git a/README.md b/README.md
index 6685707ca..218d72037 100644
--- a/README.md
+++ b/README.md
@@ -73,7 +73,7 @@ AsyncHttpClient c = asyncHttpClient(config().setProxyServer(proxyServer("127.0.0
 ### Basics
 
 AHC provides 2 APIs for defining requests: bound and unbound.
-`AsyncHttpClient` and Dls` provide methods for standard HTTP methods (POST, PUT, etc) but you can also pass a custom one.
+`AsyncHttpClient` and Dsl` provide methods for standard HTTP methods (POST, PUT, etc) but you can also pass a custom one.
 
 ```java
 import org.asynchttpclient.*;
diff --git a/client/pom.xml b/client/pom.xml
index 771f5df15..4c3294f15 100644
--- a/client/pom.xml
+++ b/client/pom.xml
@@ -2,7 +2,7 @@
   <parent>
     <groupId>org.asynchttpclient</groupId>
     <artifactId>async-http-client-project</artifactId>
-    <version>2.8.2-SNAPSHOT</version>
+    <version>2.10.2-SNAPSHOT</version>
   </parent>
   <modelVersion>4.0.0</modelVersion>
   <artifactId>async-http-client</artifactId>
diff --git a/client/src/main/java/org/asynchttpclient/channel/DefaultKeepAliveStrategy.java b/client/src/main/java/org/asynchttpclient/channel/DefaultKeepAliveStrategy.java
index b9fb306cf..f1c6a5f42 100644
--- a/client/src/main/java/org/asynchttpclient/channel/DefaultKeepAliveStrategy.java
+++ b/client/src/main/java/org/asynchttpclient/channel/DefaultKeepAliveStrategy.java
@@ -5,6 +5,8 @@
 import io.netty.handler.codec.http.HttpUtil;
 import org.asynchttpclient.Request;
 
+import java.net.InetSocketAddress;
+
 import static io.netty.handler.codec.http.HttpHeaderValues.CLOSE;
 
 /**
@@ -16,7 +18,7 @@
    * Implemented in accordance with RFC 7230 section 6.1 https://tools.ietf.org/html/rfc7230#section-6.1
    */
   @Override
-  public boolean keepAlive(Request ahcRequest, HttpRequest request, HttpResponse response) {
+  public boolean keepAlive(InetSocketAddress remoteAddress, Request ahcRequest, HttpRequest request, HttpResponse response) {
     return HttpUtil.isKeepAlive(response)
             && HttpUtil.isKeepAlive(request)
             // support non standard Proxy-Connection
diff --git a/client/src/main/java/org/asynchttpclient/channel/KeepAliveStrategy.java b/client/src/main/java/org/asynchttpclient/channel/KeepAliveStrategy.java
index 4d619f222..c748fe76a 100644
--- a/client/src/main/java/org/asynchttpclient/channel/KeepAliveStrategy.java
+++ b/client/src/main/java/org/asynchttpclient/channel/KeepAliveStrategy.java
@@ -17,15 +17,18 @@
 import io.netty.handler.codec.http.HttpResponse;
 import org.asynchttpclient.Request;
 
+import java.net.InetSocketAddress;
+
 public interface KeepAliveStrategy {
 
   /**
    * Determines whether the connection should be kept alive after this HTTP message exchange.
    *
-   * @param ahcRequest    the Request, as built by AHC
-   * @param nettyRequest  the HTTP request sent to Netty
-   * @param nettyResponse the HTTP response received from Netty
+   * @param remoteAddress  the remote InetSocketAddress associated with the request
+   * @param ahcRequest     the Request, as built by AHC
+   * @param nettyRequest   the HTTP request sent to Netty
+   * @param nettyResponse  the HTTP response received from Netty
    * @return true if the connection should be kept alive, false if it should be closed.
    */
-  boolean keepAlive(Request ahcRequest, HttpRequest nettyRequest, HttpResponse nettyResponse);
+  boolean keepAlive(InetSocketAddress remoteAddress, Request ahcRequest, HttpRequest nettyRequest, HttpResponse nettyResponse);
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java b/client/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java
index 6a5ed0597..ac18269c2 100755
--- a/client/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java
@@ -481,7 +481,7 @@ public EventLoopGroup getEventLoopGroup() {
 
   public ClientStats getClientStats() {
     Map<String, Long> totalConnectionsPerHost = openChannels.stream().map(Channel::remoteAddress).filter(a -> a.getClass() == InetSocketAddress.class)
-            .map(a -> (InetSocketAddress) a).map(InetSocketAddress::getHostName).collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
+            .map(a -> (InetSocketAddress) a).map(InetSocketAddress::getHostString).collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
     Map<String, Long> idleConnectionsPerHost = channelPool.getIdleChannelCountPerHost();
     Map<String, HostStats> statsPerHost = totalConnectionsPerHost.entrySet().stream().collect(Collectors.toMap(Entry::getKey, entry -> {
       final long totalConnectionCount = entry.getValue();
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java b/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java
index 998842159..f9c08b973 100755
--- a/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java
@@ -222,7 +222,7 @@ public void flushPartitions(Predicate<Object> predicate) {
             .map(idle -> idle.getChannel().remoteAddress())
             .filter(a -> a.getClass() == InetSocketAddress.class)
             .map(a -> (InetSocketAddress) a)
-            .map(InetSocketAddress::getHostName)
+            .map(InetSocketAddress::getHostString)
             .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
   }
 
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/HttpHandler.java b/client/src/main/java/org/asynchttpclient/netty/handler/HttpHandler.java
index ad29808d9..a52f75fc8 100755
--- a/client/src/main/java/org/asynchttpclient/netty/handler/HttpHandler.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/HttpHandler.java
@@ -30,6 +30,7 @@
 import org.asynchttpclient.netty.request.NettyRequestSender;
 
 import java.io.IOException;
+import java.net.InetSocketAddress;
 
 @Sharable
 public final class HttpHandler extends AsyncHttpClientHandler {
@@ -69,7 +70,7 @@ private void handleHttpResponse(final HttpResponse response, final Channel chann
     HttpRequest httpRequest = future.getNettyRequest().getHttpRequest();
     logger.debug("\n\nRequest {}\n\nResponse {}\n", httpRequest, response);
 
-    future.setKeepAlive(config.getKeepAliveStrategy().keepAlive(future.getTargetRequest(), httpRequest, response));
+    future.setKeepAlive(config.getKeepAliveStrategy().keepAlive((InetSocketAddress) channel.remoteAddress(), future.getTargetRequest(), httpRequest, response));
 
     NettyResponseStatus status = new NettyResponseStatus(future.getUri(), response, channel);
     HttpHeaders responseHeaders = response.headers();
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Redirect30xInterceptor.java b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Redirect30xInterceptor.java
index 121bb7165..d56b90fd2 100644
--- a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Redirect30xInterceptor.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Redirect30xInterceptor.java
@@ -111,6 +111,9 @@ else if (request.getByteBufferData() != null)
             requestBuilder.setBody(request.getByteBufferData());
           else if (request.getBodyGenerator() != null)
             requestBuilder.setBody(request.getBodyGenerator());
+          else if (isNonEmpty(request.getBodyParts())) {
+            requestBuilder.setBodyParts(request.getBodyParts());
+          }
         }
 
         requestBuilder.setHeaders(propagatedHeaders(request, realm, keepBody));
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/WriteListener.java b/client/src/main/java/org/asynchttpclient/netty/request/WriteListener.java
index ab38a66f9..0a51e63e9 100644
--- a/client/src/main/java/org/asynchttpclient/netty/request/WriteListener.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/WriteListener.java
@@ -16,11 +16,13 @@
 import io.netty.channel.Channel;
 import org.asynchttpclient.handler.ProgressAsyncHandler;
 import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.channel.ChannelState;
 import org.asynchttpclient.netty.channel.Channels;
 import org.asynchttpclient.netty.future.StackTraceInspector;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import javax.net.ssl.SSLException;
 import java.nio.channels.ClosedChannelException;
 
 public abstract class WriteListener {
@@ -36,27 +38,27 @@
     this.notifyHeaders = notifyHeaders;
   }
 
-  private boolean abortOnThrowable(Channel channel, Throwable cause) {
-    if (cause != null) {
-      if (cause instanceof IllegalStateException || cause instanceof ClosedChannelException || StackTraceInspector.recoverOnReadOrWriteException(cause)) {
-        LOGGER.debug(cause.getMessage(), cause);
-        Channels.silentlyCloseChannel(channel);
+  private void abortOnThrowable(Channel channel, Throwable cause) {
+    if (future.getChannelState() == ChannelState.POOLED
+      && (cause instanceof IllegalStateException
+      || cause instanceof ClosedChannelException
+      || cause instanceof SSLException
+      || StackTraceInspector.recoverOnReadOrWriteException(cause))) {
+      LOGGER.debug("Write exception on pooled channel, letting retry trigger", cause);
 
-      } else {
-        future.abort(cause);
-      }
-      return true;
+    } else {
+      future.abort(cause);
     }
-
-    return false;
+    Channels.silentlyCloseChannel(channel);
   }
 
   void operationComplete(Channel channel, Throwable cause) {
     future.touch();
 
-    // The write operation failed. If the channel was cached, it means it got asynchronously closed.
+    // The write operation failed. If the channel was pooled, it means it got asynchronously closed.
     // Let's retry a second time.
-    if (abortOnThrowable(channel, cause)) {
+    if (cause != null) {
+      abortOnThrowable(channel, cause);
       return;
     }
 
diff --git a/client/src/main/java/org/asynchttpclient/netty/timeout/TimeoutTimerTask.java b/client/src/main/java/org/asynchttpclient/netty/timeout/TimeoutTimerTask.java
index e746adfdb..034502785 100755
--- a/client/src/main/java/org/asynchttpclient/netty/timeout/TimeoutTimerTask.java
+++ b/client/src/main/java/org/asynchttpclient/netty/timeout/TimeoutTimerTask.java
@@ -55,7 +55,7 @@ public void clean() {
 
   void appendRemoteAddress(StringBuilder sb) {
     InetSocketAddress remoteAddress = timeoutsHolder.remoteAddress();
-    sb.append(remoteAddress.getHostName());
+    sb.append(remoteAddress.getHostString());
     if (!remoteAddress.isUnresolved()) {
       sb.append('/').append(remoteAddress.getAddress().getHostAddress());
     }
diff --git a/client/src/main/java/org/asynchttpclient/resolver/RequestHostnameResolver.java b/client/src/main/java/org/asynchttpclient/resolver/RequestHostnameResolver.java
index 3edf13ff1..da42fcf66 100644
--- a/client/src/main/java/org/asynchttpclient/resolver/RequestHostnameResolver.java
+++ b/client/src/main/java/org/asynchttpclient/resolver/RequestHostnameResolver.java
@@ -35,7 +35,7 @@
 
   public Future<List<InetSocketAddress>> resolve(NameResolver<InetAddress> nameResolver, InetSocketAddress unresolvedAddress, AsyncHandler<?> asyncHandler) {
 
-    final String hostname = unresolvedAddress.getHostName();
+    final String hostname = unresolvedAddress.getHostString();
     final int port = unresolvedAddress.getPort();
     final Promise<List<InetSocketAddress>> promise = ImmediateEventExecutor.INSTANCE.newPromise();
 
diff --git a/client/src/main/java/org/asynchttpclient/util/ProxyUtils.java b/client/src/main/java/org/asynchttpclient/util/ProxyUtils.java
index 5a22abc36..11d00c057 100644
--- a/client/src/main/java/org/asynchttpclient/util/ProxyUtils.java
+++ b/client/src/main/java/org/asynchttpclient/util/ProxyUtils.java
@@ -156,7 +156,7 @@ private static ProxyServerSelector createProxyServerSelector(final ProxySelector
                     return null;
                   } else {
                     InetSocketAddress address = (InetSocketAddress) proxy.address();
-                    return proxyServer(address.getHostName(), address.getPort()).build();
+                    return proxyServer(address.getHostString(), address.getPort()).build();
                   }
                 case DIRECT:
                   return null;
diff --git a/client/src/test/java/org/asynchttpclient/BasicHttpsTest.java b/client/src/test/java/org/asynchttpclient/BasicHttpsTest.java
index 216e26043..4395f0f49 100644
--- a/client/src/test/java/org/asynchttpclient/BasicHttpsTest.java
+++ b/client/src/test/java/org/asynchttpclient/BasicHttpsTest.java
@@ -107,7 +107,7 @@ public void multipleSequentialPostRequestsOverHttps() throws Throwable {
   public void multipleConcurrentPostRequestsOverHttpsWithDisabledKeepAliveStrategy() throws Throwable {
     logger.debug(">>> multipleConcurrentPostRequestsOverHttpsWithDisabledKeepAliveStrategy");
 
-    KeepAliveStrategy keepAliveStrategy = (ahcRequest, nettyRequest, nettyResponse) -> !ahcRequest.getUri().isSecured();
+    KeepAliveStrategy keepAliveStrategy = (remoteAddress, ahcRequest, nettyRequest, nettyResponse) -> !ahcRequest.getUri().isSecured();
 
     withClient(config().setSslEngineFactory(createSslEngineFactory()).setKeepAliveStrategy(keepAliveStrategy)).run(client ->
       withServer(server).run(server -> {
diff --git a/client/src/test/java/org/asynchttpclient/channel/MaxTotalConnectionTest.java b/client/src/test/java/org/asynchttpclient/channel/MaxTotalConnectionTest.java
index 5992bf3ed..61b4403b7 100644
--- a/client/src/test/java/org/asynchttpclient/channel/MaxTotalConnectionTest.java
+++ b/client/src/test/java/org/asynchttpclient/channel/MaxTotalConnectionTest.java
@@ -33,7 +33,7 @@
 
   @Test(groups = "online")
   public void testMaxTotalConnectionsExceedingException() throws IOException {
-    String[] urls = new String[]{"http://google.com", "http://github.com/"};
+    String[] urls = new String[]{"https://google.com", "https://github.com"};
 
     AsyncHttpClientConfig config = config()
             .setConnectTimeout(1000)
@@ -69,7 +69,7 @@ public void testMaxTotalConnectionsExceedingException() throws IOException {
 
   @Test(groups = "online")
   public void testMaxTotalConnections() throws Exception {
-    String[] urls = new String[]{"http://google.com", "http://gatling.io"};
+    String[] urls = new String[]{"https://google.com", "https://gatling.io"};
 
     final CountDownLatch latch = new CountDownLatch(2);
     final AtomicReference<Throwable> ex = new AtomicReference<>();
diff --git a/client/src/test/java/org/asynchttpclient/ws/CloseCodeReasonMessageTest.java b/client/src/test/java/org/asynchttpclient/ws/CloseCodeReasonMessageTest.java
index 52aaefc3a..ebbfb511f 100644
--- a/client/src/test/java/org/asynchttpclient/ws/CloseCodeReasonMessageTest.java
+++ b/client/src/test/java/org/asynchttpclient/ws/CloseCodeReasonMessageTest.java
@@ -51,7 +51,8 @@ public void onCloseWithCodeServerClose() throws Exception {
       c.prepareGet(getTargetUrl()).execute(new WebSocketUpgradeHandler.Builder().addWebSocketListener(new Listener(latch, text)).build()).get();
 
       latch.await();
-      assertEquals(text.get(), "1001-Idle Timeout");
+      // used to be correct 001-Idle Timeout prior to Jetty 9.4.15...
+      assertEquals(text.get(), "1000-");
     }
   }
 
diff --git a/example/pom.xml b/example/pom.xml
index 9b01614c7..f7b77eca6 100644
--- a/example/pom.xml
+++ b/example/pom.xml
@@ -2,7 +2,7 @@
   <parent>
     <groupId>org.asynchttpclient</groupId>
     <artifactId>async-http-client-project</artifactId>
-    <version>2.8.2-SNAPSHOT</version>
+    <version>2.10.2-SNAPSHOT</version>
   </parent>
   <modelVersion>4.0.0</modelVersion>
   <artifactId>async-http-client-example</artifactId>
diff --git a/extras/guava/pom.xml b/extras/guava/pom.xml
index 19868a8d0..0f1b6e1d8 100644
--- a/extras/guava/pom.xml
+++ b/extras/guava/pom.xml
@@ -2,7 +2,7 @@
   <parent>
     <groupId>org.asynchttpclient</groupId>
     <artifactId>async-http-client-extras-parent</artifactId>
-    <version>2.8.2-SNAPSHOT</version>
+    <version>2.10.2-SNAPSHOT</version>
   </parent>
   <modelVersion>4.0.0</modelVersion>
   <artifactId>async-http-client-extras-guava</artifactId>
diff --git a/extras/jdeferred/pom.xml b/extras/jdeferred/pom.xml
index f761ef198..851b5b9ea 100644
--- a/extras/jdeferred/pom.xml
+++ b/extras/jdeferred/pom.xml
@@ -18,7 +18,7 @@
   <parent>
     <artifactId>async-http-client-extras-parent</artifactId>
     <groupId>org.asynchttpclient</groupId>
-    <version>2.8.2-SNAPSHOT</version>
+    <version>2.10.2-SNAPSHOT</version>
   </parent>
   <artifactId>async-http-client-extras-jdeferred</artifactId>
   <name>Asynchronous Http Client JDeferred Extras</name>
diff --git a/extras/pom.xml b/extras/pom.xml
index dfc199fd1..0b7b0c30f 100644
--- a/extras/pom.xml
+++ b/extras/pom.xml
@@ -2,7 +2,7 @@
   <parent>
     <groupId>org.asynchttpclient</groupId>
     <artifactId>async-http-client-project</artifactId>
-    <version>2.8.2-SNAPSHOT</version>
+    <version>2.10.2-SNAPSHOT</version>
   </parent>
   <modelVersion>4.0.0</modelVersion>
   <artifactId>async-http-client-extras-parent</artifactId>
diff --git a/extras/registry/pom.xml b/extras/registry/pom.xml
index ef075a21c..d7546751e 100644
--- a/extras/registry/pom.xml
+++ b/extras/registry/pom.xml
@@ -2,7 +2,7 @@
   <parent>
     <groupId>org.asynchttpclient</groupId>
     <artifactId>async-http-client-extras-parent</artifactId>
-    <version>2.8.2-SNAPSHOT</version>
+    <version>2.10.2-SNAPSHOT</version>
   </parent>
   <modelVersion>4.0.0</modelVersion>
   <artifactId>async-http-client-extras-registry</artifactId>
diff --git a/extras/retrofit2/pom.xml b/extras/retrofit2/pom.xml
index dc7ca941b..c2baa5d5b 100644
--- a/extras/retrofit2/pom.xml
+++ b/extras/retrofit2/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <artifactId>async-http-client-extras-parent</artifactId>
     <groupId>org.asynchttpclient</groupId>
-    <version>2.8.2-SNAPSHOT</version>
+    <version>2.10.2-SNAPSHOT</version>
   </parent>
 
   <artifactId>async-http-client-extras-retrofit2</artifactId>
diff --git a/extras/retrofit2/src/main/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCall.java b/extras/retrofit2/src/main/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCall.java
index bbd760187..d5534a9ce 100644
--- a/extras/retrofit2/src/main/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCall.java
+++ b/extras/retrofit2/src/main/java/org/asynchttpclient/extras/retrofit/AsyncHttpClientCall.java
@@ -39,7 +39,7 @@
 @Value
 @Builder(toBuilder = true)
 @Slf4j
-class AsyncHttpClientCall implements Cloneable, okhttp3.Call {
+public class AsyncHttpClientCall implements Cloneable, okhttp3.Call {
   private static final ResponseBody EMPTY_BODY = ResponseBody.create(null, "");
 
   /**
diff --git a/extras/rxjava/pom.xml b/extras/rxjava/pom.xml
index 51e936f05..f22b04ffa 100644
--- a/extras/rxjava/pom.xml
+++ b/extras/rxjava/pom.xml
@@ -3,7 +3,7 @@
   <parent>
     <artifactId>async-http-client-extras-parent</artifactId>
     <groupId>org.asynchttpclient</groupId>
-    <version>2.8.2-SNAPSHOT</version>
+    <version>2.10.2-SNAPSHOT</version>
   </parent>
   <artifactId>async-http-client-extras-rxjava</artifactId>
   <name>Asynchronous Http Client RxJava Extras</name>
diff --git a/extras/rxjava2/pom.xml b/extras/rxjava2/pom.xml
index 59543cf26..65d3f0406 100644
--- a/extras/rxjava2/pom.xml
+++ b/extras/rxjava2/pom.xml
@@ -3,7 +3,7 @@
   <parent>
     <artifactId>async-http-client-extras-parent</artifactId>
     <groupId>org.asynchttpclient</groupId>
-    <version>2.8.2-SNAPSHOT</version>
+    <version>2.10.2-SNAPSHOT</version>
   </parent>
   <artifactId>async-http-client-extras-rxjava2</artifactId>
   <name>Asynchronous Http Client RxJava2 Extras</name>
diff --git a/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeAsyncHandlerBridge.java b/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeAsyncHandlerBridge.java
index bf366f820..6a5f8dca7 100644
--- a/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeAsyncHandlerBridge.java
+++ b/extras/rxjava2/src/main/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeAsyncHandlerBridge.java
@@ -13,6 +13,7 @@
  */
 package org.asynchttpclient.extras.rxjava2.maybe;
 
+import io.netty.channel.Channel;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.reactivex.MaybeEmitter;
 import io.reactivex.exceptions.CompositeException;
@@ -21,10 +22,14 @@
 import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.HttpResponseStatus;
 import org.asynchttpclient.extras.rxjava2.DisposedException;
+import org.asynchttpclient.netty.request.NettyRequest;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import javax.net.ssl.SSLSession;
+import java.net.InetSocketAddress;
 import java.util.Arrays;
+import java.util.List;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import static java.util.Objects.requireNonNull;
@@ -144,6 +149,76 @@ public final void onThrowable(Throwable t) {
     emitOnError(error);
   }
 
+  @Override
+  public void onHostnameResolutionAttempt(String name) {
+    executeUnlessEmitterDisposed(() -> delegate().onHostnameResolutionAttempt(name));
+  }
+
+  @Override
+  public void onHostnameResolutionSuccess(String name, List<InetSocketAddress> addresses) {
+    executeUnlessEmitterDisposed(() -> delegate().onHostnameResolutionSuccess(name, addresses));
+  }
+
+  @Override
+  public void onHostnameResolutionFailure(String name, Throwable cause) {
+    executeUnlessEmitterDisposed(() -> delegate().onHostnameResolutionFailure(name, cause));
+  }
+
+  @Override
+  public void onTcpConnectAttempt(InetSocketAddress remoteAddress) {
+    executeUnlessEmitterDisposed(() -> delegate().onTcpConnectAttempt(remoteAddress));
+  }
+
+  @Override
+  public void onTcpConnectSuccess(InetSocketAddress remoteAddress, Channel connection) {
+    executeUnlessEmitterDisposed(() -> delegate().onTcpConnectSuccess(remoteAddress, connection));
+  }
+
+  @Override
+  public void onTcpConnectFailure(InetSocketAddress remoteAddress, Throwable cause) {
+    executeUnlessEmitterDisposed(() -> delegate().onTcpConnectFailure(remoteAddress, cause));
+  }
+
+  @Override
+  public void onTlsHandshakeAttempt() {
+    executeUnlessEmitterDisposed(() -> delegate().onTlsHandshakeAttempt());
+  }
+
+  @Override
+  public void onTlsHandshakeSuccess(SSLSession sslSession) {
+    executeUnlessEmitterDisposed(() -> delegate().onTlsHandshakeSuccess(sslSession));
+  }
+
+  @Override
+  public void onTlsHandshakeFailure(Throwable cause) {
+    executeUnlessEmitterDisposed(() -> delegate().onTlsHandshakeFailure(cause));
+  }
+
+  @Override
+  public void onConnectionPoolAttempt() {
+    executeUnlessEmitterDisposed(() -> delegate().onConnectionPoolAttempt());
+  }
+
+  @Override
+  public void onConnectionPooled(Channel connection) {
+    executeUnlessEmitterDisposed(() -> delegate().onConnectionPooled(connection));
+  }
+
+  @Override
+  public void onConnectionOffer(Channel connection) {
+    executeUnlessEmitterDisposed(() -> delegate().onConnectionOffer(connection));
+  }
+
+  @Override
+  public void onRequestSend(NettyRequest request) {
+    executeUnlessEmitterDisposed(() -> delegate().onRequestSend(request));
+  }
+
+  @Override
+  public void onRetry() {
+    executeUnlessEmitterDisposed(() -> delegate().onRetry());
+  }
+
   /**
    * Called to indicate that request processing is to be aborted because the linked Rx stream has been disposed. If
    * the {@link #delegate() delegate} didn't already receive a terminal event,
@@ -184,4 +259,12 @@ private void emitOnError(Throwable error) {
       LOGGER.debug("Not propagating onError after disposal: {}", error.getMessage(), error);
     }
   }
+
+  private void executeUnlessEmitterDisposed(Runnable runnable) {
+    if (emitter.isDisposed()) {
+      disposed();
+    } else {
+      runnable.run();
+    }
+  }
 }
diff --git a/extras/rxjava2/src/test/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeAsyncHandlerBridgeTest.java b/extras/rxjava2/src/test/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeAsyncHandlerBridgeTest.java
index b8a9b3b4e..5c14778e1 100644
--- a/extras/rxjava2/src/test/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeAsyncHandlerBridgeTest.java
+++ b/extras/rxjava2/src/test/java/org/asynchttpclient/extras/rxjava2/maybe/AbstractMaybeAsyncHandlerBridgeTest.java
@@ -13,6 +13,7 @@
  */
 package org.asynchttpclient.extras.rxjava2.maybe;
 
+import io.netty.channel.Channel;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.reactivex.MaybeEmitter;
 import io.reactivex.exceptions.CompositeException;
@@ -26,7 +27,10 @@
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 
+import javax.net.ssl.SSLSession;
+import java.net.InetSocketAddress;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.Callable;
 
@@ -35,10 +39,6 @@
 import static org.mockito.BDDMockito.*;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.isA;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.only;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
 
 public class AbstractMaybeAsyncHandlerBridgeTest {
 
@@ -57,6 +57,20 @@
   @Mock
   private HttpResponseBodyPart bodyPart;
 
+  private final String hostname = "service:8080";
+
+  @Mock
+  private InetSocketAddress remoteAddress;
+
+  @Mock
+  private Channel channel;
+
+  @Mock
+  private SSLSession sslSession;
+
+  @Mock
+  private Throwable error;
+
   @Captor
   private ArgumentCaptor<Throwable> throwable;
 
@@ -76,6 +90,20 @@ public T call() throws Exception {
     };
   }
 
+  private static Runnable named(String name, Runnable runnable) {
+    return new Runnable() {
+      @Override
+      public String toString() {
+        return name;
+      }
+
+      @Override
+      public void run() {
+        runnable.run();
+      }
+    };
+  }
+
   @BeforeMethod
   public void initializeTest() {
     MockitoAnnotations.initMocks(this);
@@ -104,10 +132,68 @@ public void forwardsEvents() throws Exception {
     underTest.onTrailingHeadersReceived(headers);
     then(delegate).should().onTrailingHeadersReceived(headers);
 
+    /* when */
+    underTest.onHostnameResolutionAttempt(hostname);
+    then(delegate).should().onHostnameResolutionAttempt(hostname);
+
+    /* when */
+    List<InetSocketAddress> remoteAddresses = Collections.singletonList(remoteAddress);
+    underTest.onHostnameResolutionSuccess(hostname, remoteAddresses);
+    then(delegate).should().onHostnameResolutionSuccess(hostname, remoteAddresses);
+
+    /* when */
+    underTest.onHostnameResolutionFailure(hostname, error);
+    then(delegate).should().onHostnameResolutionFailure(hostname, error);
+
+    /* when */
+    underTest.onTcpConnectAttempt(remoteAddress);
+    then(delegate).should().onTcpConnectAttempt(remoteAddress);
+
+    /* when */
+    underTest.onTcpConnectSuccess(remoteAddress, channel);
+    then(delegate).should().onTcpConnectSuccess(remoteAddress, channel);
+
+    /* when */
+    underTest.onTcpConnectFailure(remoteAddress, error);
+    then(delegate).should().onTcpConnectFailure(remoteAddress, error);
+
+    /* when */
+    underTest.onTlsHandshakeAttempt();
+    then(delegate).should().onTlsHandshakeAttempt();
+
+    /* when */
+    underTest.onTlsHandshakeSuccess(sslSession);
+    then(delegate).should().onTlsHandshakeSuccess(sslSession);
+
+    /* when */
+    underTest.onTlsHandshakeFailure(error);
+    then(delegate).should().onTlsHandshakeFailure(error);
+
+    /* when */
+    underTest.onConnectionPoolAttempt();
+    then(delegate).should().onConnectionPoolAttempt();
+
+    /* when */
+    underTest.onConnectionPooled(channel);
+    then(delegate).should().onConnectionPooled(channel);
+
+    /* when */
+    underTest.onConnectionOffer(channel);
+    then(delegate).should().onConnectionOffer(channel);
+
+    /* when */
+    underTest.onRequestSend(null);
+    then(delegate).should().onRequestSend(null);
+
+    /* when */
+    underTest.onRetry();
+    then(delegate).should().onRetry();
+
     /* when */
     underTest.onCompleted();
     then(delegate).should().onCompleted();
     then(emitter).should().onSuccess(this);
+
     /* then */
     verifyNoMoreInteractions(delegate);
   }
@@ -254,6 +340,42 @@ public void httpEventCallbacksCheckDisposal(Callable<AsyncHandler.State> httpEve
     verifyNoMoreInteractions(delegate);
   }
 
+  @DataProvider
+  public Object[][] variousEvents() {
+    return new Object[][]{
+            {named("onHostnameResolutionAttempt", () -> underTest.onHostnameResolutionAttempt("service:8080"))},
+            {named("onHostnameResolutionSuccess", () -> underTest.onHostnameResolutionSuccess("service:8080",
+                    Collections.singletonList(remoteAddress)))},
+            {named("onHostnameResolutionFailure", () -> underTest.onHostnameResolutionFailure("service:8080", error))},
+            {named("onTcpConnectAttempt", () -> underTest.onTcpConnectAttempt(remoteAddress))},
+            {named("onTcpConnectSuccess", () -> underTest.onTcpConnectSuccess(remoteAddress, channel))},
+            {named("onTcpConnectFailure", () -> underTest.onTcpConnectFailure(remoteAddress, error))},
+            {named("onTlsHandshakeAttempt", () -> underTest.onTlsHandshakeAttempt())},
+            {named("onTlsHandshakeSuccess", () -> underTest.onTlsHandshakeSuccess(sslSession))},
+            {named("onTlsHandshakeFailure", () -> underTest.onTlsHandshakeFailure(error))},
+            {named("onConnectionPoolAttempt", () -> underTest.onConnectionPoolAttempt())},
+            {named("onConnectionPooled", () -> underTest.onConnectionPooled(channel))},
+            {named("onConnectionOffer", () -> underTest.onConnectionOffer(channel))},
+            {named("onRequestSend", () -> underTest.onRequestSend(null))},
+            {named("onRetry", () -> underTest.onRetry())},
+    };
+  }
+
+  @Test(dataProvider = "variousEvents")
+  public void variousEventCallbacksCheckDisposal(Runnable event) {
+    given(emitter.isDisposed()).willReturn(true);
+
+    /* when */
+    event.run();
+    /* then */
+    then(delegate).should(only()).onThrowable(isA(DisposedException.class));
+
+    /* when */
+    event.run();
+    /* then */
+    verifyNoMoreInteractions(delegate);
+  }
+
   private final class UnderTest extends AbstractMaybeAsyncHandlerBridge<Object> {
     UnderTest() {
       super(AbstractMaybeAsyncHandlerBridgeTest.this.emitter);
diff --git a/extras/simple/pom.xml b/extras/simple/pom.xml
index 0a782de77..7ecfd7405 100644
--- a/extras/simple/pom.xml
+++ b/extras/simple/pom.xml
@@ -3,7 +3,7 @@
   <parent>
     <artifactId>async-http-client-extras-parent</artifactId>
     <groupId>org.asynchttpclient</groupId>
-    <version>2.8.2-SNAPSHOT</version>
+    <version>2.10.2-SNAPSHOT</version>
   </parent>
   <artifactId>async-http-client-extras-simple</artifactId>
   <name>Asynchronous Http Simple Client</name>
diff --git a/extras/typesafeconfig/pom.xml b/extras/typesafeconfig/pom.xml
index af0986dd8..e920e8cd8 100644
--- a/extras/typesafeconfig/pom.xml
+++ b/extras/typesafeconfig/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <artifactId>async-http-client-extras-parent</artifactId>
     <groupId>org.asynchttpclient</groupId>
-    <version>2.8.2-SNAPSHOT</version>
+    <version>2.10.2-SNAPSHOT</version>
   </parent>
 
   <artifactId>async-http-client-extras-typesafe-config</artifactId>
diff --git a/netty-utils/pom.xml b/netty-utils/pom.xml
index 22f562c7f..bb32ae3b6 100644
--- a/netty-utils/pom.xml
+++ b/netty-utils/pom.xml
@@ -2,7 +2,7 @@
   <parent>
     <groupId>org.asynchttpclient</groupId>
     <artifactId>async-http-client-project</artifactId>
-    <version>2.8.2-SNAPSHOT</version>
+    <version>2.10.2-SNAPSHOT</version>
   </parent>
   <modelVersion>4.0.0</modelVersion>
   <artifactId>async-http-client-netty-utils</artifactId>
diff --git a/netty-utils/src/test/java/org/asynchttpclient/netty/util/ByteBufUtilsTests.java b/netty-utils/src/test/java/org/asynchttpclient/netty/util/ByteBufUtilsTests.java
new file mode 100644
index 000000000..4aaa61c8a
--- /dev/null
+++ b/netty-utils/src/test/java/org/asynchttpclient/netty/util/ByteBufUtilsTests.java
@@ -0,0 +1,126 @@
+/*
+ * Copyright (c) 2019 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.util;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import java.nio.charset.Charset;
+import org.testng.annotations.Test;
+import org.testng.Assert;
+import org.testng.internal.junit.ArrayAsserts;
+
+public class ByteBufUtilsTests {
+
+    @Test
+    public void testByteBuf2BytesEmptyByteBuf() {
+        ByteBuf buf = Unpooled.buffer();
+
+        try {
+            ArrayAsserts.assertArrayEquals(new byte[]{},
+                    ByteBufUtils.byteBuf2Bytes(buf));
+        } finally {
+            buf.release();
+        }
+    }
+
+    @Test
+    public void testByteBuf2BytesNotEmptyByteBuf() {
+        ByteBuf byteBuf = Unpooled.wrappedBuffer(new byte[]{'f', 'o', 'o'});
+
+        try {
+            ArrayAsserts.assertArrayEquals(new byte[]{'f', 'o', 'o'},
+                    ByteBufUtils.byteBuf2Bytes(byteBuf));
+        } finally {
+            byteBuf.release();
+        }
+    }
+
+    @Test
+    public void testByteBuf2String() {
+        ByteBuf byteBuf = Unpooled.wrappedBuffer(new byte[]{'f', 'o', 'o'});
+        Charset charset = Charset.forName("US-ASCII");
+
+        try {
+            Assert.assertEquals(
+                    ByteBufUtils.byteBuf2String(charset, byteBuf), "foo");
+        } finally {
+            byteBuf.release();
+        }
+    }
+
+    @Test
+    public void testByteBuf2StringWithByteBufArray() {
+        ByteBuf byteBuf1 = Unpooled.wrappedBuffer(new byte[]{'f'});
+        ByteBuf byteBuf2 = Unpooled.wrappedBuffer(new byte[]{'o', 'o'});
+
+        try {
+            Assert.assertEquals(ByteBufUtils.byteBuf2String(
+                    Charset.forName("ISO-8859-1"), byteBuf1, byteBuf2), "foo");
+        } finally {
+            byteBuf1.release();
+            byteBuf2.release();
+        }
+    }
+
+    @Test
+    public void testByteBuf2Chars() {
+        ByteBuf byteBuf1 = Unpooled.wrappedBuffer(new byte[]{});
+        ByteBuf byteBuf2 = Unpooled.wrappedBuffer(new byte[]{'o'});
+
+        try {
+            ArrayAsserts.assertArrayEquals(new char[]{}, ByteBufUtils
+                    .byteBuf2Chars(Charset.forName("US-ASCII"), byteBuf1));
+            ArrayAsserts.assertArrayEquals(new char[]{}, ByteBufUtils
+                    .byteBuf2Chars(Charset.forName("ISO-8859-1"), byteBuf1));
+            ArrayAsserts.assertArrayEquals(new char[]{'o'}, ByteBufUtils
+                    .byteBuf2Chars(Charset.forName("ISO-8859-1"), byteBuf2));
+        } finally {
+            byteBuf1.release();
+            byteBuf2.release();
+        }
+    }
+
+    @Test
+    public void testByteBuf2CharsWithByteBufArray() {
+        ByteBuf byteBuf1 = Unpooled.wrappedBuffer(new byte[]{'f', 'o'});
+        ByteBuf byteBuf2 = Unpooled.wrappedBuffer(new byte[]{'%', '*'});
+
+        try {
+            ArrayAsserts.assertArrayEquals(new char[]{'f', 'o', '%', '*'},
+                    ByteBufUtils.byteBuf2Chars(Charset.forName("US-ASCII"),
+                            byteBuf1, byteBuf2));
+            ArrayAsserts.assertArrayEquals(new char[]{'f', 'o', '%', '*'},
+                    ByteBufUtils.byteBuf2Chars(Charset.forName("ISO-8859-1"),
+                            byteBuf1, byteBuf2));
+        } finally {
+            byteBuf1.release();
+            byteBuf2.release();
+        }
+    }
+
+    @Test
+    public void testByteBuf2CharsWithEmptyByteBufArray() {
+        ByteBuf byteBuf1 = Unpooled.wrappedBuffer(new byte[]{});
+        ByteBuf byteBuf2 = Unpooled.wrappedBuffer(new byte[]{'o'});
+
+        try {
+            ArrayAsserts.assertArrayEquals(new char[]{'o'}, ByteBufUtils
+                    .byteBuf2Chars(Charset.forName("ISO-8859-1"),
+                            byteBuf1, byteBuf2));
+        } finally {
+            byteBuf1.release();
+            byteBuf2.release();
+        }
+    }
+}
diff --git a/pom.xml b/pom.xml
index fbd0450c7..e43e5d493 100644
--- a/pom.xml
+++ b/pom.xml
@@ -9,7 +9,7 @@
   <groupId>org.asynchttpclient</groupId>
   <artifactId>async-http-client-project</artifactId>
   <name>Asynchronous Http Client Project</name>
-  <version>2.8.2-SNAPSHOT</version>
+  <version>2.10.2-SNAPSHOT</version>
   <packaging>pom</packaging>
   <description>
     The Async Http Client (AHC) library's purpose is to allow Java
@@ -427,21 +427,21 @@
     <surefire.redirectTestOutputToFile>true</surefire.redirectTestOutputToFile>
     <source.property>1.8</source.property>
     <target.property>1.8</target.property>
-    <netty.version>4.1.33.Final</netty.version>
-    <slf4j.version>1.7.25</slf4j.version>
+    <netty.version>4.1.36.Final</netty.version>
+    <slf4j.version>1.7.26</slf4j.version>
     <reactive-streams.version>1.0.2</reactive-streams.version>
     <activation.version>1.2.0</activation.version>
-    <netty-reactive-streams.version>2.0.0</netty-reactive-streams.version>
+    <netty-reactive-streams.version>2.0.3</netty-reactive-streams.version>
     <rxjava.version>1.3.8</rxjava.version>
-    <rxjava2.version>2.2.5</rxjava2.version>
+    <rxjava2.version>2.2.9</rxjava2.version>
     <logback.version>1.2.3</logback.version>
     <testng.version>6.13.1</testng.version>
-    <jetty.version>9.4.14.v20181114</jetty.version>
-    <tomcat.version>9.0.14</tomcat.version>
+    <jetty.version>9.4.18.v20190429</jetty.version>
+    <tomcat.version>9.0.20</tomcat.version>
     <commons-io.version>2.6</commons-io.version>
     <commons-fileupload.version>1.3.3</commons-fileupload.version>
     <privilegedaccessor.version>1.2.2</privilegedaccessor.version>
-    <mockito.version>2.23.4</mockito.version>
+    <mockito.version>2.28.2</mockito.version>
     <hamcrest.version>2.1</hamcrest.version>
     <kerby.version>1.1.1</kerby.version>
   </properties>
