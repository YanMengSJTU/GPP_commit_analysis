diff --git a/.travis.yml b/.travis.yml
new file mode 100644
index 000000000..f1a834f4a
--- /dev/null
+++ b/.travis.yml
@@ -0,0 +1,22 @@
+language: java
+jdk:
+  - oraclejdk8
+before_script: "[[ $TRAVIS_PULL_REQUEST == \"false\" ]] && ./make_credentials.py"
+script: 
+  - find $HOME/.m2 -name "_remote.repositories" | xargs rm
+  - find $HOME/.m2 -name "resolver-status.properties" | xargs rm -f
+  
+# If building master, Publish to Sonatype
+after_success: "[[ $TRAVIS_PULL_REQUEST == \"false\" ]] && mvn deploy"
+
+sudo: false
+
+# Cache settings
+cache:
+  directories:
+    - $HOME/.m2/repository
+
+# whitelist
+branches:
+  only:
+    - master
\ No newline at end of file
diff --git a/MIGRATION.md b/MIGRATION.md
index 43781ca2c..05c976a07 100644
--- a/MIGRATION.md
+++ b/MIGRATION.md
@@ -19,7 +19,7 @@ AsyncHttpClient v1.9 is a preview of v2, so it comes with some breaking changes.
   * `allowPoolingConnection` becomes `allowPoolingConnections`
   * `allowSslConnectionPool` becomes `allowPoolingSslConnections`
   * `connectionTimeout` becomes `connectTimeout`
-  * `compressionEnabled` becomes `compressionEnforced` (default true) so it's always enabled and can honor user defined Accept-Encoding
+  * `compressionEnabled` becomes `compressionEnforced`. Default false, so AHC only honors user defined Accept-Encoding.
   * `requestCompressionLevel` was dropped, as it wasn't working
   * `SSLEngineFactory` was moved to Netty config as only Netty honors it
   * `useRawUrl` becomes `disableUrlEncodingForBoundedRequests`, as it's only honored by bound requests
diff --git a/README.md b/README.md
index 57cc2226a..b85a07746 100644
--- a/README.md
+++ b/README.md
@@ -1,4 +1,4 @@
-Async Http Client ([@AsyncHttpClient](https://twitter.com/AsyncHttpClient) on twitter)
+Async Http Client ([@AsyncHttpClient](https://twitter.com/AsyncHttpClient) on twitter) [![Build Status](https://travis-ci.org/AsyncHttpClient/async-http-client.svg?branch=master)](https://travis-ci.org/AsyncHttpClient/async-http-client)
 ---------------------------------------------------
 
 [Javadoc](http://www.javadoc.io/doc/com.ning/async-http-client/)
@@ -16,7 +16,7 @@ First, in order to add it to your Maven project, simply add this dependency:
 <dependency>
   <groupId>com.ning</groupId>
   <artifactId>async-http-client</artifactId>
-  <version>1.9.31</version>
+  <version>1.9.33</version>
 </dependency>
 ```
 
@@ -179,7 +179,7 @@ Finally, you can also configure the AsyncHttpClient via its AsyncHttpClientConfi
 
 ```java
 AsyncHttpClientConfig cf = new AsyncHttpClientConfig.Builder()
-    S.setProxyServer(new ProxyServer("127.0.0.1", 38080)).build();
+    .setProxyServer(new ProxyServer("127.0.0.1", 38080)).build();
 AsyncHttpClient c = new AsyncHttpClient(cf);
 ```
 
diff --git a/client/pom.xml b/client/pom.xml
index 4b815c625..70ff7e8e4 100644
--- a/client/pom.xml
+++ b/client/pom.xml
@@ -2,7 +2,7 @@
 	<parent>
 		<groupId>org.asynchttpclient</groupId>
 		<artifactId>async-http-client-project</artifactId>
-		<version>2.0.0-SNAPSHOT</version>
+		<version>2.0.0-RC9-SNAPSHOT</version>
 	</parent>
 	<modelVersion>4.0.0</modelVersion>
 	<artifactId>async-http-client</artifactId>
@@ -28,7 +28,11 @@
 		<dependency>
 			<groupId>io.netty</groupId>
 			<artifactId>netty-codec-http</artifactId>
-			<version>4.0.32.Final</version>
+		</dependency>
+		<dependency>
+			<groupId>org.asynchttpclient</groupId>
+			<artifactId>netty-resolver-dns</artifactId>
+			<version>${project.version}</version>
 		</dependency>
 		<dependency>
 			<groupId>org.reactivestreams</groupId>
@@ -38,17 +42,12 @@
 		<dependency>
 			<groupId>com.typesafe.netty</groupId>
 			<artifactId>netty-reactive-streams</artifactId>
-			<version>1.0.0</version>
+			<version>1.0.2</version>
 		</dependency>
 		<dependency>
 			<groupId>org.javassist</groupId>
 			<artifactId>javassist</artifactId>
 			<version>3.20.0-GA</version>
 		</dependency>
-		<dependency>
-			<groupId>com.jcraft</groupId>
-			<artifactId>jzlib</artifactId>
-			<version>1.1.3</version>
-		</dependency>
 	</dependencies>
 </project>
diff --git a/client/src/main/java/org/asynchttpclient/AsyncCompletionHandlerBase.java b/client/src/main/java/org/asynchttpclient/AsyncCompletionHandlerBase.java
index d14951605..20837c99f 100644
--- a/client/src/main/java/org/asynchttpclient/AsyncCompletionHandlerBase.java
+++ b/client/src/main/java/org/asynchttpclient/AsyncCompletionHandlerBase.java
@@ -16,15 +16,11 @@
  */
 package org.asynchttpclient;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 
 /**
  * Simple {@link AsyncHandler} of type {@link Response}
  */
 public class AsyncCompletionHandlerBase extends AsyncCompletionHandler<Response> {
-    private static final Logger LOGGER = LoggerFactory.getLogger(AsyncCompletionHandlerBase.class);
-
     /**
      * {@inheritDoc}
      */
@@ -32,12 +28,4 @@
     public Response onCompleted(Response response) throws Exception {
         return response;
     }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void onThrowable(Throwable t) {
-        LOGGER.debug(t.getMessage(), t);
-    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java b/client/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java
index ad85a6189..3349b1ce3 100644
--- a/client/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java
+++ b/client/src/main/java/org/asynchttpclient/AsyncHttpClientConfig.java
@@ -11,14 +11,13 @@
 import java.util.Map;
 import java.util.concurrent.ThreadFactory;
 
-import org.asynchttpclient.channel.pool.KeepAliveStrategy;
+import org.asynchttpclient.channel.ChannelPool;
+import org.asynchttpclient.channel.KeepAliveStrategy;
 import org.asynchttpclient.filter.IOExceptionFilter;
 import org.asynchttpclient.filter.RequestFilter;
 import org.asynchttpclient.filter.ResponseFilter;
-import org.asynchttpclient.netty.EagerNettyResponseBodyPart;
-import org.asynchttpclient.netty.LazyNettyResponseBodyPart;
-import org.asynchttpclient.netty.NettyResponseBodyPart;
-import org.asynchttpclient.netty.channel.pool.ChannelPool;
+import org.asynchttpclient.netty.EagerResponseBodyPart;
+import org.asynchttpclient.netty.LazyResponseBodyPart;
 import org.asynchttpclient.proxy.ProxyServer;
 import org.asynchttpclient.proxy.ProxyServerSelector;
 
@@ -30,64 +29,51 @@
     String getAhcVersion();
 
     /**
-     * Return the name of {@link AsyncHttpClient}, which is used for thread
-     * naming and debugging.
+     * Return the name of {@link AsyncHttpClient}, which is used for thread naming and debugging.
      *
      * @return the name.
      */
     String getThreadPoolName();
 
     /**
-     * Return the maximum number of connections an {@link AsyncHttpClient} can
-     * handle.
+     * Return the maximum number of connections an {@link AsyncHttpClient} can handle.
      *
-     * @return the maximum number of connections an {@link AsyncHttpClient} can
-     *         handle.
+     * @return the maximum number of connections an {@link AsyncHttpClient} can handle.
      */
     int getMaxConnections();
 
     /**
-     * Return the maximum number of connections per hosts an
-     * {@link AsyncHttpClient} can handle.
+     * Return the maximum number of connections per hosts an {@link AsyncHttpClient} can handle.
      *
-     * @return the maximum number of connections per host an
-     *         {@link AsyncHttpClient} can handle.
+     * @return the maximum number of connections per host an {@link AsyncHttpClient} can handle.
      */
     int getMaxConnectionsPerHost();
 
     /**
-     * Return the maximum time in millisecond an {@link AsyncHttpClient} can
-     * wait when connecting to a remote host
+     * Return the maximum time in millisecond an {@link AsyncHttpClient} can wait when connecting to a remote host
      *
-     * @return the maximum time in millisecond an {@link AsyncHttpClient} can
-     *         wait when connecting to a remote host
+     * @return the maximum time in millisecond an {@link AsyncHttpClient} can wait when connecting to a remote host
      */
     int getConnectTimeout();
 
     /**
-     * Return the maximum time in millisecond an {@link AsyncHttpClient} can
-     * stay idle.
+     * Return the maximum time in millisecond an {@link AsyncHttpClient} can stay idle.
      *
-     * @return the maximum time in millisecond an {@link AsyncHttpClient} can
-     *         stay idle.
+     * @return the maximum time in millisecond an {@link AsyncHttpClient} can stay idle.
      */
     int getReadTimeout();
 
     /**
-     * Return the maximum time in millisecond an {@link AsyncHttpClient} will
-     * keep connection in pool.
+     * Return the maximum time in millisecond an {@link AsyncHttpClient} will keep connection in pool.
      *
-     * @return the maximum time in millisecond an {@link AsyncHttpClient} will
-     *         keep connection in pool.
+     * @return the maximum time in millisecond an {@link AsyncHttpClient} will keep connection in pool.
      */
     int getPooledConnectionIdleTimeout();
 
     /**
-     * Return the maximum time in millisecond an {@link AsyncHttpClient} waits
-     * until the response is completed.
+     * Return the maximum time in millisecond an {@link AsyncHttpClient} waits until the response is completed.
      *
-     * @return the maximum time in millisecond an {@link AsyncHttpClient} waits
-     *         until the response is completed.
+     * @return the maximum time in millisecond an {@link AsyncHttpClient} waits until the response is completed.
      */
     int getRequestTimeout();
 
@@ -127,13 +113,10 @@
     boolean isCompressionEnforced();
 
     /**
-     * Return the {@link java.util.concurrent.ThreadFactory} an
-     * {@link AsyncHttpClient} use for handling asynchronous response.
+     * Return the {@link java.util.concurrent.ThreadFactory} an {@link AsyncHttpClient} use for handling asynchronous response.
      *
-     * @return the {@link java.util.concurrent.ThreadFactory} an
-     *         {@link AsyncHttpClient} use for handling asynchronous response.
-     *         If no {@link ThreadFactory} has been explicitly provided, this
-     *         method will return <code>null</code>
+     * @return the {@link java.util.concurrent.ThreadFactory} an {@link AsyncHttpClient} use for handling asynchronous response. If no {@link ThreadFactory} has been explicitly
+     *         provided, this method will return <code>null</code>
      */
     ThreadFactory getThreadFactory();
 
@@ -180,11 +163,9 @@
     List<IOExceptionFilter> getIoExceptionFilters();
 
     /**
-     * Return the number of time the library will retry when an
-     * {@link java.io.IOException} is throw by the remote server
+     * Return the number of time the library will retry when an {@link java.io.IOException} is throw by the remote server
      *
-     * @return the number of time the library will retry when an
-     *         {@link java.io.IOException} is throw by the remote server
+     * @return the number of time the library will retry when an {@link java.io.IOException} is throw by the remote server
      */
     int getMaxRequestRetry();
 
@@ -194,28 +175,22 @@
     boolean isDisableUrlEncodingForBoundRequests();
 
     /**
-     * In the case of a POST/Redirect/Get scenario where the server uses a 302
-     * for the redirect, should AHC respond to the redirect with a GET or
-     * whatever the original method was. Unless configured otherwise, for a 302,
-     * AHC, will use a GET for this case.
+     * In the case of a POST/Redirect/Get scenario where the server uses a 302 for the redirect, should AHC respond to the redirect with a GET or whatever the original method was.
+     * Unless configured otherwise, for a 302, AHC, will use a GET for this case.
      *
-     * @return <code>true</code> if string 302 handling is to be used, otherwise
-     *         <code>false</code>.
+     * @return <code>true</code> if string 302 handling is to be used, otherwise <code>false</code>.
      */
     boolean isStrict302Handling();
 
     /**
-     * Return the maximum time in millisecond an {@link AsyncHttpClient} will
-     * keep connection in the pool, or -1 to keep connection while possible.
+     * Return the maximum time in millisecond an {@link AsyncHttpClient} will keep connection in the pool, or -1 to keep connection while possible.
      *
-     * @return the maximum time in millisecond an {@link AsyncHttpClient} will
-     *         keep connection in the pool, or -1 to keep connection while
-     *         possible.
+     * @return the maximum time in millisecond an {@link AsyncHttpClient} will keep connection in the pool, or -1 to keep connection while possible.
      */
     int getConnectionTtl();
 
     boolean isUseOpenSsl();
-    
+
     boolean isAcceptAnyCertificate();
 
     /**
@@ -280,6 +255,20 @@
 
     KeepAliveStrategy getKeepAliveStrategy();
 
+    boolean isValidateResponseHeaders();
+
+    boolean isTcpNoDelay();
+
+    boolean isSoReuseAddress();
+
+    int getSoLinger();
+
+    int getSoSndBuf();
+
+    int getSoRcvBuf();
+
+    boolean isUsePooledMemory();
+
     interface AdditionalChannelInitializer {
 
         void initChannel(Channel channel) throws Exception;
@@ -289,19 +278,19 @@
 
         EAGER {
             @Override
-            public NettyResponseBodyPart newResponseBodyPart(ByteBuf buf, boolean last) {
-                return new EagerNettyResponseBodyPart(buf, last);
+            public HttpResponseBodyPart newResponseBodyPart(ByteBuf buf, boolean last) {
+                return new EagerResponseBodyPart(buf, last);
             }
         },
 
         LAZY {
 
             @Override
-            public NettyResponseBodyPart newResponseBodyPart(ByteBuf buf, boolean last) {
-                return new LazyNettyResponseBodyPart(buf, last);
+            public HttpResponseBodyPart newResponseBodyPart(ByteBuf buf, boolean last) {
+                return new LazyResponseBodyPart(buf, last);
             }
         };
 
-        public abstract NettyResponseBodyPart newResponseBodyPart(ByteBuf buf, boolean last);
+        public abstract HttpResponseBodyPart newResponseBodyPart(ByteBuf buf, boolean last);
     }
 }
diff --git a/client/src/main/java/org/asynchttpclient/BoundRequestBuilder.java b/client/src/main/java/org/asynchttpclient/BoundRequestBuilder.java
index c18f79758..e4ad98879 100644
--- a/client/src/main/java/org/asynchttpclient/BoundRequestBuilder.java
+++ b/client/src/main/java/org/asynchttpclient/BoundRequestBuilder.java
@@ -12,11 +12,15 @@
  */
 package org.asynchttpclient;
 
-
 public class BoundRequestBuilder extends RequestBuilderBase<BoundRequestBuilder> {
 
     private final AsyncHttpClient client;
 
+    public BoundRequestBuilder(AsyncHttpClient client, String method, boolean isDisableUrlEncoding, boolean validateHeaders) {
+        super(method, isDisableUrlEncoding, validateHeaders);
+        this.client = client;
+    }
+
     public BoundRequestBuilder(AsyncHttpClient client, String method, boolean isDisableUrlEncoding) {
         super(method, isDisableUrlEncoding);
         this.client = client;
diff --git a/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java b/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java
index 9e12bf695..ba72e0b30 100644
--- a/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java
+++ b/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClient.java
@@ -22,12 +22,12 @@
 
 import java.util.concurrent.atomic.AtomicBoolean;
 
+import org.asynchttpclient.channel.ChannelPool;
 import org.asynchttpclient.filter.FilterContext;
 import org.asynchttpclient.filter.FilterException;
 import org.asynchttpclient.filter.RequestFilter;
 import org.asynchttpclient.handler.resumable.ResumableAsyncHandler;
 import org.asynchttpclient.netty.channel.ChannelManager;
-import org.asynchttpclient.netty.channel.pool.ChannelPool;
 import org.asynchttpclient.netty.request.NettyRequestSender;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
diff --git a/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClientConfig.java b/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClientConfig.java
index 787d0b1e6..bffb34bf2 100644
--- a/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClientConfig.java
+++ b/client/src/main/java/org/asynchttpclient/DefaultAsyncHttpClientConfig.java
@@ -31,18 +31,18 @@
 import java.util.Properties;
 import java.util.concurrent.ThreadFactory;
 
-import org.asynchttpclient.channel.pool.KeepAliveStrategy;
+import org.asynchttpclient.channel.ChannelPool;
+import org.asynchttpclient.channel.DefaultKeepAliveStrategy;
+import org.asynchttpclient.channel.KeepAliveStrategy;
 import org.asynchttpclient.filter.IOExceptionFilter;
 import org.asynchttpclient.filter.RequestFilter;
 import org.asynchttpclient.filter.ResponseFilter;
-import org.asynchttpclient.netty.channel.pool.ChannelPool;
 import org.asynchttpclient.proxy.ProxyServer;
 import org.asynchttpclient.proxy.ProxyServerSelector;
 import org.asynchttpclient.util.ProxyUtils;
 
 /**
- * Configuration class to use with a {@link AsyncHttpClient}. System property
- * can be also used to configure this object default behavior by doing: <br>
+ * Configuration class to use with a {@link AsyncHttpClient}. System property can be also used to configure this object default behavior by doing: <br>
  * -Dorg.asynchttpclient.nameOfTheProperty
  * 
  * @see AsyncHttpClientConfig for documentation
@@ -73,6 +73,7 @@
     private final boolean disableZeroCopy;
     private final boolean keepEncodingHeader;
     private final ProxyServerSelector proxyServerSelector;
+    private final boolean validateResponseHeaders;
 
     // timeouts
     private final int connectTimeout;
@@ -117,6 +118,12 @@
     private final Map<ChannelOption<Object>, Object> channelOptions;
     private final EventLoopGroup eventLoopGroup;
     private final boolean useNativeTransport;
+    private final boolean usePooledMemory;
+    private final boolean tcpNoDelay;
+    private final boolean soReuseAddress;
+    private final int soLinger;
+    private final int soSndBuf;
+    private final int soRcvBuf;
     private final Timer nettyTimer;
     private final ThreadFactory threadFactory;
     private final AdditionalChannelInitializer httpAdditionalChannelInitializer;
@@ -136,6 +143,7 @@ private DefaultAsyncHttpClientConfig(//
             boolean disableZeroCopy,//
             boolean keepEncodingHeader,//
             ProxyServerSelector proxyServerSelector,//
+            boolean validateResponseHeaders,//
 
             // timeouts
             int connectTimeout,//
@@ -169,6 +177,13 @@ private DefaultAsyncHttpClientConfig(//
             List<ResponseFilter> responseFilters,//
             List<IOExceptionFilter> ioExceptionFilters,//
 
+            // tuning
+            boolean tcpNoDelay,//
+            boolean soReuseAddress,//
+            int soLinger, //
+            int soSndBuf, //
+            int soRcvBuf, //
+
             // internals
             String threadPoolName,//
             int httpClientCodecMaxInitialLineLength,//
@@ -180,6 +195,7 @@ private DefaultAsyncHttpClientConfig(//
             Map<ChannelOption<Object>, Object> channelOptions,//
             EventLoopGroup eventLoopGroup,//
             boolean useNativeTransport,//
+            boolean usePooledMemory,//
             Timer nettyTimer,//
             ThreadFactory threadFactory,//
             AdditionalChannelInitializer httpAdditionalChannelInitializer,//
@@ -198,6 +214,7 @@ private DefaultAsyncHttpClientConfig(//
         this.disableZeroCopy = disableZeroCopy;
         this.keepEncodingHeader = keepEncodingHeader;
         this.proxyServerSelector = proxyServerSelector;
+        this.validateResponseHeaders = validateResponseHeaders;
 
         // timeouts
         this.connectTimeout = connectTimeout;
@@ -231,6 +248,13 @@ private DefaultAsyncHttpClientConfig(//
         this.responseFilters = responseFilters;
         this.ioExceptionFilters = ioExceptionFilters;
 
+        // tuning
+        this.tcpNoDelay = tcpNoDelay;
+        this.soReuseAddress = soReuseAddress;
+        this.soLinger = soLinger;
+        this.soSndBuf = soSndBuf;
+        this.soRcvBuf = soRcvBuf;
+
         // internals
         this.threadPoolName = threadPoolName;
         this.httpClientCodecMaxInitialLineLength = httpClientCodecMaxInitialLineLength;
@@ -242,6 +266,7 @@ private DefaultAsyncHttpClientConfig(//
         this.channelOptions = channelOptions;
         this.eventLoopGroup = eventLoopGroup;
         this.useNativeTransport = useNativeTransport;
+        this.usePooledMemory = usePooledMemory;
         this.nettyTimer = nettyTimer;
         this.threadFactory = threadFactory;
         this.httpAdditionalChannelInitializer = httpAdditionalChannelInitializer;
@@ -373,12 +398,17 @@ public KeepAliveStrategy getKeepAliveStrategy() {
         return keepAliveStrategy;
     }
 
+    @Override
+    public boolean isValidateResponseHeaders() {
+        return validateResponseHeaders;
+    }
+
     // ssl
     @Override
     public boolean isUseOpenSsl() {
         return useOpenSsl;
     }
-    
+
     @Override
     public boolean isAcceptAnyCertificate() {
         return acceptAnyCertificate;
@@ -435,6 +465,32 @@ public SslEngineFactory getSslEngineFactory() {
         return ioExceptionFilters;
     }
 
+    // tuning
+    @Override
+    public boolean isTcpNoDelay() {
+        return tcpNoDelay;
+    }
+
+    @Override
+    public boolean isSoReuseAddress() {
+        return soReuseAddress;
+    }
+
+    @Override
+    public int getSoLinger() {
+        return soLinger;
+    }
+
+    @Override
+    public int getSoSndBuf() {
+        return soSndBuf;
+    }
+
+    @Override
+    public int getSoRcvBuf() {
+        return soRcvBuf;
+    }
+
     // internals
     @Override
     public String getThreadPoolName() {
@@ -486,6 +542,11 @@ public boolean isUseNativeTransport() {
         return useNativeTransport;
     }
 
+    @Override
+    public boolean isUsePooledMemory() {
+        return usePooledMemory;
+    }
+
     @Override
     public Timer getNettyTimer() {
         return nettyTimer;
@@ -530,6 +591,7 @@ public ResponseBodyPartFactory getResponseBodyPartFactory() {
         private ProxyServerSelector proxyServerSelector;
         private boolean useProxySelector = defaultUseProxySelector();
         private boolean useProxyProperties = defaultUseProxyProperties();
+        private boolean validateResponseHeaders = defaultValidateResponseHeaders();
 
         // timeouts
         private int connectTimeout = defaultConnectTimeout();
@@ -545,7 +607,7 @@ public ResponseBodyPartFactory getResponseBodyPartFactory() {
         private int maxConnections = defaultMaxConnections();
         private int maxConnectionsPerHost = defaultMaxConnectionsPerHost();
         private ChannelPool channelPool;
-        private KeepAliveStrategy keepAliveStrategy = KeepAliveStrategy.DefaultKeepAliveStrategy.INSTANCE;
+        private KeepAliveStrategy keepAliveStrategy = new DefaultKeepAliveStrategy();
 
         // ssl
         private boolean useOpenSsl = defaultUseOpenSsl();
@@ -563,6 +625,13 @@ public ResponseBodyPartFactory getResponseBodyPartFactory() {
         private final List<ResponseFilter> responseFilters = new LinkedList<>();
         private final List<IOExceptionFilter> ioExceptionFilters = new LinkedList<>();
 
+        // tuning
+        private boolean tcpNoDelay = defaultTcpNoDelay();
+        private boolean soReuseAddress = defaultSoReuseAddress();
+        private int soLinger = defaultSoLinger();
+        private int soSndBuf = defaultSoSndBuf();
+        private int soRcvBuf = defaultSoRcvBuf();
+
         // internals
         private String threadPoolName = defaultThreadPoolName();
         private int httpClientCodecMaxInitialLineLength = defaultHttpClientCodecMaxInitialLineLength();
@@ -572,6 +641,7 @@ public ResponseBodyPartFactory getResponseBodyPartFactory() {
         private int webSocketMaxBufferSize = defaultWebSocketMaxBufferSize();
         private int webSocketMaxFrameSize = defaultWebSocketMaxFrameSize();
         private boolean useNativeTransport = defaultUseNativeTransport();
+        private boolean usePooledMemory = defaultUsePooledMemory();
         private Map<ChannelOption<Object>, Object> channelOptions = new HashMap<>();
         private EventLoopGroup eventLoopGroup;
         private Timer nettyTimer;
@@ -628,6 +698,13 @@ public Builder(AsyncHttpClientConfig config) {
             responseFilters.addAll(config.getResponseFilters());
             ioExceptionFilters.addAll(config.getIoExceptionFilters());
 
+            // tuning
+            tcpNoDelay = config.isTcpNoDelay();
+            soReuseAddress = config.isSoReuseAddress();
+            soLinger = config.getSoLinger();
+            soSndBuf = config.getSoSndBuf();
+            soRcvBuf = config.getSoRcvBuf();
+
             // internals
             threadPoolName = config.getThreadPoolName();
             httpClientCodecMaxInitialLineLength = config.getHttpClientCodecMaxInitialLineLength();
@@ -639,6 +716,7 @@ public Builder(AsyncHttpClientConfig config) {
             channelOptions.putAll(config.getChannelOptions());
             eventLoopGroup = config.getEventLoopGroup();
             useNativeTransport = config.isUseNativeTransport();
+            usePooledMemory = config.isUsePooledMemory();
             nettyTimer = config.getNettyTimer();
             threadFactory = config.getThreadFactory();
             httpAdditionalChannelInitializer = config.getHttpAdditionalChannelInitializer();
@@ -676,7 +754,7 @@ public Builder setRealm(Realm realm) {
             this.realm = realm;
             return this;
         }
-        
+
         public Builder setRealm(Realm.Builder realmBuilder) {
             this.realm = realmBuilder.build();
             return this;
@@ -707,11 +785,16 @@ public Builder setProxyServerSelector(ProxyServerSelector proxyServerSelector) {
             return this;
         }
 
+        public Builder setValidateResponseHeaders(boolean validateResponseHeaders) {
+            this.validateResponseHeaders = validateResponseHeaders;
+            return this;
+        }
+
         public Builder setProxyServer(ProxyServer proxyServer) {
             this.proxyServerSelector = ProxyUtils.createProxyServerSelector(proxyServer);
             return this;
         }
-        
+
         public Builder setProxyServer(ProxyServer.Builder proxyServerBuilder) {
             this.proxyServerSelector = ProxyUtils.createProxyServerSelector(proxyServerBuilder.build());
             return this;
@@ -866,6 +949,32 @@ public Builder removeIOExceptionFilter(IOExceptionFilter ioExceptionFilter) {
             return this;
         }
 
+        // tuning
+        public Builder setTcpNoDelay(boolean tcpNoDelay) {
+            this.tcpNoDelay = tcpNoDelay;
+            return this;
+        }
+
+        public Builder setSoReuseAddress(boolean soReuseAddress) {
+            this.soReuseAddress = soReuseAddress;
+            return this;
+        }
+
+        public Builder setSoLinger(int soLinger) {
+            this.soLinger = soLinger;
+            return this;
+        }
+
+        public Builder setSoSndBuf(int soSndBuf) {
+            this.soSndBuf = soSndBuf;
+            return this;
+        }
+
+        public Builder setSoRcvBuf(int soRcvBuf) {
+            this.soRcvBuf = soRcvBuf;
+            return this;
+        }
+
         // internals
         public Builder setThreadPoolName(String threadPoolName) {
             this.threadPoolName = threadPoolName;
@@ -918,6 +1027,11 @@ public Builder setUseNativeTransport(boolean useNativeTransport) {
             return this;
         }
 
+        public Builder setUsePooledMemory(boolean usePooledMemory) {
+            this.usePooledMemory = usePooledMemory;
+            return this;
+        }
+
         public Builder setNettyTimer(Timer nettyTimer) {
             this.nettyTimer = nettyTimer;
             return this;
@@ -970,6 +1084,7 @@ public DefaultAsyncHttpClientConfig build() {
                     disableZeroCopy, //
                     keepEncodingHeader, //
                     resolveProxyServerSelector(), //
+                    validateResponseHeaders, //
                     connectTimeout, //
                     requestTimeout, //
                     readTimeout, //
@@ -994,6 +1109,11 @@ public DefaultAsyncHttpClientConfig build() {
                     requestFilters.isEmpty() ? Collections.emptyList() : Collections.unmodifiableList(requestFilters), //
                     responseFilters.isEmpty() ? Collections.emptyList() : Collections.unmodifiableList(responseFilters),//
                     ioExceptionFilters.isEmpty() ? Collections.emptyList() : Collections.unmodifiableList(ioExceptionFilters),//
+                    tcpNoDelay, //
+                    soReuseAddress, //
+                    soLinger, //
+                    soSndBuf, //
+                    soRcvBuf, //
                     threadPoolName, //
                     httpClientCodecMaxInitialLineLength, //
                     httpClientCodecMaxHeaderSize, //
@@ -1004,6 +1124,7 @@ public DefaultAsyncHttpClientConfig build() {
                     channelOptions.isEmpty() ? Collections.emptyMap() : Collections.unmodifiableMap(channelOptions),//
                     eventLoopGroup, //
                     useNativeTransport, //
+                    usePooledMemory, //
                     nettyTimer, //
                     threadFactory, //
                     httpAdditionalChannelInitializer, //
diff --git a/client/src/main/java/org/asynchttpclient/DefaultRequest.java b/client/src/main/java/org/asynchttpclient/DefaultRequest.java
index a893d37bb..2c10f5d3d 100644
--- a/client/src/main/java/org/asynchttpclient/DefaultRequest.java
+++ b/client/src/main/java/org/asynchttpclient/DefaultRequest.java
@@ -15,6 +15,7 @@
 
 import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.resolver.NameResolver;
 
 import java.io.File;
 import java.io.InputStream;
@@ -26,8 +27,7 @@
 import java.util.List;
 import java.util.Map;
 
-import org.asynchttpclient.channel.NameResolver;
-import org.asynchttpclient.channel.pool.ConnectionPoolPartitioning;
+import org.asynchttpclient.channel.ChannelPoolPartitioning;
 import org.asynchttpclient.cookie.Cookie;
 import org.asynchttpclient.proxy.ProxyServer;
 import org.asynchttpclient.request.body.generator.BodyGenerator;
@@ -59,8 +59,8 @@
     private final int requestTimeout;
     private final long rangeOffset;
     private final Charset charset;
-    private final ConnectionPoolPartitioning connectionPoolPartitioning;
-    private final NameResolver nameResolver;
+    private final ChannelPoolPartitioning channelPoolPartitioning;
+    private final NameResolver<InetAddress> nameResolver;
     // lazily loaded
     private List<Param> queryParams;
 
@@ -87,8 +87,8 @@ public DefaultRequest(String method,//
             int requestTimeout,//
             long rangeOffset,//
             Charset charset,//
-            ConnectionPoolPartitioning connectionPoolPartitioning,//
-            NameResolver nameResolver) {
+            ChannelPoolPartitioning channelPoolPartitioning,//
+            NameResolver<InetAddress> nameResolver) {
         this.method = method;
         this.uri = uri;
         this.address = address;
@@ -112,7 +112,7 @@ public DefaultRequest(String method,//
         this.requestTimeout = requestTimeout;
         this.rangeOffset = rangeOffset;
         this.charset = charset;
-        this.connectionPoolPartitioning = connectionPoolPartitioning;
+        this.channelPoolPartitioning = channelPoolPartitioning;
         this.nameResolver = nameResolver;
     }
 
@@ -237,12 +237,12 @@ public Charset getCharset() {
     }
 
     @Override
-    public ConnectionPoolPartitioning getConnectionPoolPartitioning() {
-        return connectionPoolPartitioning;
+    public ChannelPoolPartitioning getChannelPoolPartitioning() {
+        return channelPoolPartitioning;
     }
 
     @Override
-    public NameResolver getNameResolver() {
+    public NameResolver<InetAddress> getNameResolver() {
         return nameResolver;
     }
 
diff --git a/client/src/main/java/org/asynchttpclient/Dsl.java b/client/src/main/java/org/asynchttpclient/Dsl.java
index 257f67caa..ca678f3c1 100644
--- a/client/src/main/java/org/asynchttpclient/Dsl.java
+++ b/client/src/main/java/org/asynchttpclient/Dsl.java
@@ -13,7 +13,7 @@
  */
 package org.asynchttpclient;
 
-import io.netty.handler.codec.http.HttpMethod;
+import static org.asynchttpclient.util.HttpConstants.Methods.*;
 
 import org.asynchttpclient.Realm.AuthScheme;
 import org.asynchttpclient.proxy.ProxyServer;
@@ -35,35 +35,35 @@ public static AsyncHttpClient asyncHttpClient(AsyncHttpClientConfig config) {
 
     // /////////// Request ////////////////
     public static RequestBuilder get(String url) {
-        return request(HttpMethod.GET.name(), url);
+        return request(GET, url);
     }
 
     public static RequestBuilder put(String url) {
-        return request(HttpMethod.PUT.name(), url);
+        return request(PUT, url);
     }
 
     public static RequestBuilder post(String url) {
-        return request(HttpMethod.POST.name(), url);
+        return request(POST, url);
     }
 
     public static RequestBuilder delete(String url) {
-        return request(HttpMethod.DELETE.name(), url);
+        return request(DELETE, url);
     }
 
     public static RequestBuilder head(String url) {
-        return request(HttpMethod.HEAD.name(), url);
+        return request(HEAD, url);
     }
 
     public static RequestBuilder options(String url) {
-        return request(HttpMethod.OPTIONS.name(), url);
+        return request(OPTIONS, url);
     }
 
     public static RequestBuilder path(String url) {
-        return request(HttpMethod.PATCH.name(), url);
+        return request(PATCH, url);
     }
 
     public static RequestBuilder trace(String url) {
-        return request(HttpMethod.TRACE.name(), url);
+        return request(TRACE, url);
     }
 
     public static RequestBuilder request(String method, String url) {
diff --git a/client/src/main/java/org/asynchttpclient/HttpResponseBodyPart.java b/client/src/main/java/org/asynchttpclient/HttpResponseBodyPart.java
index 530e70537..4e4258251 100644
--- a/client/src/main/java/org/asynchttpclient/HttpResponseBodyPart.java
+++ b/client/src/main/java/org/asynchttpclient/HttpResponseBodyPart.java
@@ -20,26 +20,34 @@
 /**
  * A callback class used when an HTTP response body is received.
  */
-public interface HttpResponseBodyPart {
+public abstract class HttpResponseBodyPart {
+
+    private final boolean last;
+
+    public HttpResponseBodyPart(boolean last) {
+        this.last = last;
+    }
 
     /**
      * @return length of this part in bytes
      */
-    int length();
+    public abstract int length();
 
     /**
      * @return  the response body's part bytes received.
      */
-    byte[] getBodyPartBytes();
+    public abstract byte[] getBodyPartBytes();
 
     /**
      * @return a {@link ByteBuffer} that wraps the actual bytes read from the response's chunk.
      * The {@link ByteBuffer}'s capacity is equal to the number of bytes available.
      */
-    ByteBuffer getBodyByteBuffer();
+    public abstract ByteBuffer getBodyByteBuffer();
 
     /**
      * @return true if this is the last part.
      */
-    boolean isLast();
+    public boolean isLast() {
+        return last;
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/HttpResponseHeaders.java b/client/src/main/java/org/asynchttpclient/HttpResponseHeaders.java
index 743eaae9a..c1ed4bc11 100644
--- a/client/src/main/java/org/asynchttpclient/HttpResponseHeaders.java
+++ b/client/src/main/java/org/asynchttpclient/HttpResponseHeaders.java
@@ -17,35 +17,28 @@
 
 import io.netty.handler.codec.http.HttpHeaders;
 
-
 /**
  * A class that represent the HTTP headers.
  */
-public abstract class HttpResponseHeaders {
+public class HttpResponseHeaders {
 
-    private final boolean traillingHeaders;
+    private final HttpHeaders headers;
+    private final boolean trailling;
 
-    public HttpResponseHeaders() {
-        this.traillingHeaders = false;
+    public HttpResponseHeaders(HttpHeaders headers) {
+        this(headers, false);
     }
 
-    public HttpResponseHeaders(boolean traillingHeaders) {
-        this.traillingHeaders = traillingHeaders;
+    public HttpResponseHeaders(HttpHeaders headers, boolean trailling) {
+        this.headers = headers;
+        this.trailling = trailling;
     }
 
-    /**
-     * Return the HTTP header
-     *
-     * @return an {@link HttpHeaders}
-     */
-    abstract public HttpHeaders getHeaders();
+    public HttpHeaders getHeaders() {
+        return headers;
+    }
 
-    /**
-     * Return true is headers has been received after the response body.
-     *
-     * @return true is headers has been received after the response body.
-     */
-    public boolean isTraillingHeadersReceived() {
-        return traillingHeaders;
+    public boolean isTrailling() {
+        return trailling;
     }
 }
diff --git a/client/src/main/java/org/asynchttpclient/HttpResponseStatus.java b/client/src/main/java/org/asynchttpclient/HttpResponseStatus.java
index 04c244adb..722f5c0a2 100644
--- a/client/src/main/java/org/asynchttpclient/HttpResponseStatus.java
+++ b/client/src/main/java/org/asynchttpclient/HttpResponseStatus.java
@@ -17,7 +17,6 @@
 package org.asynchttpclient;
 
 import java.net.SocketAddress;
-import java.util.List;
 
 import org.asynchttpclient.uri.Uri;
 
@@ -43,15 +42,6 @@ public final Uri getUri() {
         return uri;
     }
 
-    /**
-     * Prepare a {@link Response}
-     * 
-     * @param headers {@link HttpResponseHeaders}
-     * @param bodyParts list of {@link HttpResponseBodyPart}
-     * @return a {@link Response}
-     */
-    public abstract Response prepareResponse(HttpResponseHeaders headers, List<HttpResponseBodyPart> bodyParts);
-
     /**
      * Return the response status code
      * 
diff --git a/client/src/main/java/org/asynchttpclient/Realm.java b/client/src/main/java/org/asynchttpclient/Realm.java
index db5db23e2..d7152ce33 100644
--- a/client/src/main/java/org/asynchttpclient/Realm.java
+++ b/client/src/main/java/org/asynchttpclient/Realm.java
@@ -31,8 +31,7 @@
 import org.asynchttpclient.util.StringUtils;
 
 /**
- * This class is required when authentication is needed. The class support
- * DIGEST and BASIC.
+ * This class is required when authentication is needed. The class support BASIC, DIGEST, NTLM, SPNEGO and KERBEROS.
  */
 public class Realm {
 
@@ -64,16 +63,33 @@
         BASIC, DIGEST, NTLM, SPNEGO, KERBEROS;
     }
 
-    private Realm(AuthScheme scheme, String principal, String password, String realmName, String nonce, String algorithm, String response, String qop, String nc, String cnonce,
-            Uri uri, String method, boolean usePreemptiveAuth, String ntlmDomain, Charset charset, String host, String opaque, boolean useAbsoluteURI, boolean omitQuery) {
+    private Realm(AuthScheme scheme,//
+            String principal,//
+            String password,//
+            String realmName,//
+            String nonce,//
+            String algorithm,//
+            String response,//
+            String opaque,//
+            String qop,//
+            String nc,//
+            String cnonce,//
+            Uri uri,//
+            String methodName,//
+            boolean usePreemptiveAuth,//
+            Charset charset,//
+            String ntlmDomain,//
+            String ntlmHost,//
+            boolean useAbsoluteURI,//
+            boolean omitQuery) {
 
         assertNotNull(scheme, "scheme");
         assertNotNull(principal, "principal");
         assertNotNull(password, "password");
 
+        this.scheme = scheme;
         this.principal = principal;
         this.password = password;
-        this.scheme = scheme;
         this.realmName = realmName;
         this.nonce = nonce;
         this.algorithm = algorithm;
@@ -83,11 +99,11 @@ private Realm(AuthScheme scheme, String principal, String password, String realm
         this.nc = nc;
         this.cnonce = cnonce;
         this.uri = uri;
-        this.methodName = method;
+        this.methodName = methodName;
         this.usePreemptiveAuth = usePreemptiveAuth;
-        this.ntlmDomain = ntlmDomain;
-        this.ntlmHost = host;
         this.charset = charset;
+        this.ntlmDomain = ntlmDomain;
+        this.ntlmHost = ntlmHost;
         this.useAbsoluteURI = useAbsoluteURI;
         this.omitQuery = omitQuery;
     }
@@ -101,7 +117,6 @@ public String getPassword() {
     }
 
     public AuthScheme getScheme() {
-
         return scheme;
     }
 
@@ -494,8 +509,25 @@ public Realm build() {
                 newResponse(md);
             }
 
-            return new Realm(scheme, principal, password, realmName, nonce, algorithm, response, qop, nc, cnonce, uri, methodName, usePreemptive, ntlmDomain, charset, ntlmHost,
-                    opaque, useAbsoluteURI, omitQuery);
+            return new Realm(scheme,//
+                    principal,//
+                    password,//
+                    realmName,//
+                    nonce, //
+                    algorithm, //
+                    response,//
+                    opaque, //
+                    qop, //
+                    nc, //
+                    cnonce, //
+                    uri, //
+                    methodName, //
+                    usePreemptive, //
+                    charset, //
+                    ntlmDomain,//
+                    ntlmHost, //
+                    useAbsoluteURI, //
+                    omitQuery);
         }
     }
 }
diff --git a/client/src/main/java/org/asynchttpclient/Request.java b/client/src/main/java/org/asynchttpclient/Request.java
index fee8a0857..66c8d1ea6 100644
--- a/client/src/main/java/org/asynchttpclient/Request.java
+++ b/client/src/main/java/org/asynchttpclient/Request.java
@@ -17,17 +17,16 @@
 package org.asynchttpclient;
 
 import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.resolver.NameResolver;
 
 import java.io.File;
 import java.io.InputStream;
 import java.net.InetAddress;
 import java.nio.ByteBuffer;
 import java.nio.charset.Charset;
-import java.util.Collection;
 import java.util.List;
 
-import org.asynchttpclient.channel.NameResolver;
-import org.asynchttpclient.channel.pool.ConnectionPoolPartitioning;
+import org.asynchttpclient.channel.ChannelPoolPartitioning;
 import org.asynchttpclient.cookie.Cookie;
 import org.asynchttpclient.proxy.ProxyServer;
 import org.asynchttpclient.request.body.generator.BodyGenerator;
@@ -74,11 +73,11 @@
     HttpHeaders getHeaders();
 
     /**
-     * Return Coookie.
+     * Return cookies.
      *
      * @return an unmodifiable Collection of Cookies
      */
-    Collection<Cookie> getCookies();
+    List<Cookie> getCookies();
 
     /**
      * Return the current request's body as a byte array
@@ -203,7 +202,7 @@
      */
     Charset getCharset();
 
-    ConnectionPoolPartitioning getConnectionPoolPartitioning();
+    ChannelPoolPartitioning getChannelPoolPartitioning();
 
-    NameResolver getNameResolver();
+    NameResolver<InetAddress> getNameResolver();
 }
diff --git a/client/src/main/java/org/asynchttpclient/RequestBuilder.java b/client/src/main/java/org/asynchttpclient/RequestBuilder.java
index 2c4599d80..bd9bbb61c 100644
--- a/client/src/main/java/org/asynchttpclient/RequestBuilder.java
+++ b/client/src/main/java/org/asynchttpclient/RequestBuilder.java
@@ -15,26 +15,35 @@
  */
 package org.asynchttpclient;
 
+import static org.asynchttpclient.util.HttpConstants.Methods.GET;
+
 /**
- * Builder for a {@link Request}. Warning: mutable and not thread-safe! Beware
- * that it holds a reference on the Request instance it builds, so modifying the
- * builder will modify the request even after it has been built.
+ * Builder for a {@link Request}. Warning: mutable and not thread-safe! Beware that it holds a reference on the Request instance it builds, so modifying the builder will modify the
+ * request even after it has been built.
  */
 public class RequestBuilder extends RequestBuilderBase<RequestBuilder> {
 
     public RequestBuilder() {
-        this("GET");
+        this(GET);
     }
 
     public RequestBuilder(String method) {
-        super(method, false);
+        this(method, false);
     }
 
     public RequestBuilder(String method, boolean disableUrlEncoding) {
         super(method, disableUrlEncoding);
     }
 
+    public RequestBuilder(String method, boolean disableUrlEncoding, boolean validateHeaders) {
+        super(method, disableUrlEncoding, validateHeaders);
+    }
+
     public RequestBuilder(Request prototype) {
         super(prototype);
     }
+
+    public RequestBuilder(Request prototype, boolean disableUrlEncoding, boolean validateHeaders) {
+        super(prototype, disableUrlEncoding, validateHeaders);
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/RequestBuilderBase.java b/client/src/main/java/org/asynchttpclient/RequestBuilderBase.java
index 157db5c17..3d6da35eb 100644
--- a/client/src/main/java/org/asynchttpclient/RequestBuilderBase.java
+++ b/client/src/main/java/org/asynchttpclient/RequestBuilderBase.java
@@ -19,6 +19,9 @@
 import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 import io.netty.handler.codec.http.DefaultHttpHeaders;
 import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.resolver.DefaultNameResolver;
+import io.netty.resolver.NameResolver;
+import io.netty.util.concurrent.ImmediateEventExecutor;
 
 import java.io.File;
 import java.io.InputStream;
@@ -31,8 +34,7 @@
 import java.util.List;
 import java.util.Map;
 
-import org.asynchttpclient.channel.NameResolver;
-import org.asynchttpclient.channel.pool.ConnectionPoolPartitioning;
+import org.asynchttpclient.channel.ChannelPoolPartitioning;
 import org.asynchttpclient.cookie.Cookie;
 import org.asynchttpclient.proxy.ProxyServer;
 import org.asynchttpclient.request.body.generator.BodyGenerator;
@@ -50,6 +52,8 @@
  * @param <T> the builder type
  */
 public abstract class RequestBuilderBase<T extends RequestBuilderBase<T>> {
+    
+    public static NameResolver<InetAddress> DEFAULT_NAME_RESOLVER = new DefaultNameResolver(ImmediateEventExecutor.INSTANCE);
 
     private final static Logger LOGGER = LoggerFactory.getLogger(RequestBuilderBase.class);
 
@@ -65,7 +69,7 @@
     protected Uri uri;
     protected InetAddress address;
     protected InetAddress localAddress;
-    protected HttpHeaders headers = new DefaultHttpHeaders();
+    protected HttpHeaders headers;
     protected ArrayList<Cookie> cookies;
     protected byte[] byteData;
     protected List<byte[]> compositeByteData;
@@ -84,24 +88,30 @@
     protected int requestTimeout;
     protected long rangeOffset;
     protected Charset charset;
-    protected ConnectionPoolPartitioning connectionPoolPartitioning = ConnectionPoolPartitioning.PerHostConnectionPoolPartitioning.INSTANCE;
-    protected NameResolver nameResolver = NameResolver.JdkNameResolver.INSTANCE;
+    protected ChannelPoolPartitioning channelPoolPartitioning = ChannelPoolPartitioning.PerHostChannelPoolPartitioning.INSTANCE;
+    protected NameResolver<InetAddress> nameResolver = DEFAULT_NAME_RESOLVER;
 
     protected RequestBuilderBase(String method, boolean disableUrlEncoding) {
+        this(method, disableUrlEncoding, true);
+    }
+
+    protected RequestBuilderBase(String method, boolean disableUrlEncoding, boolean validateHeaders) {
         this.method = method;
         this.uriEncoder = UriEncoder.uriEncoder(disableUrlEncoding);
+        this.headers = new DefaultHttpHeaders(validateHeaders);
     }
 
     protected RequestBuilderBase(Request prototype) {
-        this(prototype, false);
+        this(prototype, false, false);
     }
 
-    protected RequestBuilderBase(Request prototype, boolean disableUrlEncoding) {
+    protected RequestBuilderBase(Request prototype, boolean disableUrlEncoding, boolean validateHeaders) {
         this.method = prototype.getMethod();
         this.uriEncoder = UriEncoder.uriEncoder(disableUrlEncoding);
         this.uri = prototype.getUri();
         this.address = prototype.getAddress();
         this.localAddress = prototype.getLocalAddress();
+        this.headers = new DefaultHttpHeaders(validateHeaders);
         this.headers.add(prototype.getHeaders());
         if (isNonEmpty(prototype.getCookies())) {
             this.cookies = new ArrayList<>(prototype.getCookies());
@@ -127,7 +137,7 @@ protected RequestBuilderBase(Request prototype, boolean disableUrlEncoding) {
         this.requestTimeout = prototype.getRequestTimeout();
         this.rangeOffset = prototype.getRangeOffset();
         this.charset = prototype.getCharset();
-        this.connectionPoolPartitioning = prototype.getConnectionPoolPartitioning();
+        this.channelPoolPartitioning = prototype.getChannelPoolPartitioning();
         this.nameResolver = prototype.getNameResolver();
     }
 
@@ -176,12 +186,15 @@ public T addHeader(CharSequence name, String value) {
     }
 
     public T setHeaders(HttpHeaders headers) {
-        this.headers = headers == null ? new DefaultHttpHeaders() : headers;
+        if (headers == null)
+            this.headers.clear();
+        else
+            this.headers = headers;
         return asDerivedType();
     }
 
     public T setHeaders(Map<String, Collection<String>> headers) {
-        this.headers = new DefaultHttpHeaders();
+        this.headers.clear();
         if (headers != null) {
             for (Map.Entry<String, Collection<String>> entry : headers.entrySet()) {
                 String headerName = entry.getKey();
@@ -375,7 +388,7 @@ public T setProxyServer(ProxyServer proxyServer) {
         this.proxyServer = proxyServer;
         return asDerivedType();
     }
-    
+
     public T setProxyServer(ProxyServer.Builder proxyServerBuilder) {
         this.proxyServer = proxyServerBuilder.build();
         return asDerivedType();
@@ -411,12 +424,12 @@ public T setCharset(Charset charset) {
         return asDerivedType();
     }
 
-    public T setConnectionPoolPartitioning(ConnectionPoolPartitioning connectionPoolPartitioning) {
-        this.connectionPoolPartitioning = connectionPoolPartitioning;
+    public T setChannelPoolPartitioning(ChannelPoolPartitioning channelPoolPartitioning) {
+        this.channelPoolPartitioning = channelPoolPartitioning;
         return asDerivedType();
     }
 
-    public T setNameResolver(NameResolver nameResolver) {
+    public T setNameResolver(NameResolver<InetAddress> nameResolver) {
         this.nameResolver = nameResolver;
         return asDerivedType();
     }
@@ -466,7 +479,7 @@ public T setSignatureCalculator(SignatureCalculator signatureCalculator) {
         rb.requestTimeout = this.requestTimeout;
         rb.rangeOffset = this.rangeOffset;
         rb.charset = this.charset;
-        rb.connectionPoolPartitioning = this.connectionPoolPartitioning;
+        rb.channelPoolPartitioning = this.channelPoolPartitioning;
         rb.nameResolver = this.nameResolver;
         Request unsignedRequest = rb.build();
         signatureCalculator.calculateAndAddSignature(unsignedRequest, rb);
@@ -528,12 +541,12 @@ public Request build() {
         Uri finalUri = rb.computeUri();
         Charset finalCharset = rb.computeCharset();
         long finalContentLength = rb.computeRequestContentLength();
-        
+
         // make copies of mutable internal collections
         List<Cookie> cookiesCopy = rb.cookies == null ? Collections.emptyList() : new ArrayList<>(rb.cookies);
         List<Param> formParamsCopy = rb.formParams == null ? Collections.emptyList() : new ArrayList<>(rb.formParams);
         List<Part> bodyPartsCopy = rb.bodyParts == null ? Collections.emptyList() : new ArrayList<>(rb.bodyParts);
-        
+
         return new DefaultRequest(rb.method,//
                 finalUri,//
                 rb.address,//
@@ -557,7 +570,7 @@ public Request build() {
                 rb.requestTimeout,//
                 rb.rangeOffset,//
                 finalCharset,//
-                rb.connectionPoolPartitioning,//
+                rb.channelPoolPartitioning,//
                 rb.nameResolver);
     }
 }
diff --git a/client/src/main/java/org/asynchttpclient/Response.java b/client/src/main/java/org/asynchttpclient/Response.java
index 6422e1f08..d59c2a2c0 100644
--- a/client/src/main/java/org/asynchttpclient/Response.java
+++ b/client/src/main/java/org/asynchttpclient/Response.java
@@ -16,9 +16,6 @@
  */
 package org.asynchttpclient;
 
-import org.asynchttpclient.cookie.Cookie;
-import org.asynchttpclient.uri.Uri;
-
 import io.netty.handler.codec.http.HttpHeaders;
 
 import java.io.InputStream;
@@ -28,6 +25,10 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import org.asynchttpclient.cookie.Cookie;
+import org.asynchttpclient.netty.NettyResponse;
+import org.asynchttpclient.uri.Uri;
+
 /**
  * Represents the asynchronous HTTP response callback for an {@link AsyncCompletionHandler}
  */
@@ -70,8 +71,7 @@
     /**
      * Return the entire response body as a String.
      * 
-     * @param charset
-     *            the charset to use when decoding the stream
+     * @param charset the charset to use when decoding the stream
      * @return the entire response body as a String.
      */
     String getResponseBody(Charset charset);
@@ -158,19 +158,17 @@
     /**
      * Get remote address client initiated request to.
      * 
-     * @return remote address client initiated request to, may be {@code null}
-     *         if asynchronous provider is unable to provide the remote address
+     * @return remote address client initiated request to, may be {@code null} if asynchronous provider is unable to provide the remote address
      */
     SocketAddress getRemoteAddress();
 
     /**
      * Get local address client initiated request from.
      * 
-     * @return local address client initiated request from, may be {@code null}
-     *         if asynchronous provider is unable to provide the local address
+     * @return local address client initiated request from, may be {@code null} if asynchronous provider is unable to provide the local address
      */
     SocketAddress getLocalAddress();
-    
+
     class ResponseBuilder {
         private final List<HttpResponseBodyPart> bodyParts = new ArrayList<>();
         private HttpResponseStatus status;
@@ -182,13 +180,12 @@ public ResponseBuilder accumulate(HttpResponseStatus status) {
         }
 
         public ResponseBuilder accumulate(HttpResponseHeaders headers) {
-            this.headers = headers;
+            this.headers = this.headers == null ? headers : new HttpResponseHeaders(this.headers.getHeaders().add(headers.getHeaders()), true);
             return this;
         }
 
         /**
-         * @param bodyPart
-         *            a body part (possibly empty, but will be filtered out)
+         * @param bodyPart a body part (possibly empty, but will be filtered out)
          * @return this
          */
         public ResponseBuilder accumulate(HttpResponseBodyPart bodyPart) {
@@ -203,7 +200,7 @@ public ResponseBuilder accumulate(HttpResponseBodyPart bodyPart) {
          * @return a {@link Response} instance
          */
         public Response build() {
-            return status == null ? null : status.prepareResponse(headers, bodyParts);
+            return status == null ? null : new NettyResponse(status, headers, bodyParts);
         }
 
         /**
diff --git a/client/src/main/java/org/asynchttpclient/ResponseBase.java b/client/src/main/java/org/asynchttpclient/ResponseBase.java
deleted file mode 100644
index 2672e2f85..000000000
--- a/client/src/main/java/org/asynchttpclient/ResponseBase.java
+++ /dev/null
@@ -1,144 +0,0 @@
-package org.asynchttpclient;
-
-import static org.asynchttpclient.util.HttpUtils.*;
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
-import io.netty.handler.codec.http.HttpHeaders;
-
-import java.net.SocketAddress;
-import java.nio.charset.Charset;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
-
-import org.asynchttpclient.cookie.Cookie;
-import org.asynchttpclient.uri.Uri;
-
-public abstract class ResponseBase implements Response {
-
-    protected final List<HttpResponseBodyPart> bodyParts;
-    protected final HttpResponseHeaders headers;
-    protected final HttpResponseStatus status;
-    private List<Cookie> cookies;
-
-    protected ResponseBase(HttpResponseStatus status, HttpResponseHeaders headers, List<HttpResponseBodyPart> bodyParts) {
-        this.bodyParts = bodyParts;
-        this.headers = headers;
-        this.status = status;
-    }
-
-    protected abstract List<Cookie> buildCookies();
-
-    protected Charset calculateCharset(Charset charset) {
-
-        if (charset == null) {
-            String contentType = getContentType();
-            if (contentType != null)
-                charset = parseCharset(contentType); // parseCharset can return
-                                                     // null
-        }
-        return charset != null ? charset : DEFAULT_CHARSET;
-    }
-
-    @Override
-    public final int getStatusCode() {
-        return status.getStatusCode();
-    }
-
-    @Override
-    public final String getStatusText() {
-        return status.getStatusText();
-    }
-
-    @Override
-    public final Uri getUri() {
-        return status.getUri();
-    }
-
-    @Override
-    public SocketAddress getRemoteAddress() {
-        return status.getRemoteAddress();
-    }
-
-    @Override
-    public SocketAddress getLocalAddress() {
-        return status.getLocalAddress();
-    }
-
-    @Override
-    public final String getContentType() {
-        return headers != null ? getHeader("Content-Type") : null;
-    }
-
-    @Override
-    public final String getHeader(String name) {
-        return headers != null ? getHeaders().get(name) : null;
-    }
-
-    @Override
-    public final List<String> getHeaders(String name) {
-        return headers != null ? getHeaders().getAll(name) : Collections.<String> emptyList();
-    }
-
-    @Override
-    public final HttpHeaders getHeaders() {
-        return headers != null ? headers.getHeaders() : HttpHeaders.EMPTY_HEADERS;
-    }
-
-    @Override
-    public final boolean isRedirected() {
-        switch (status.getStatusCode()) {
-        case 301:
-        case 302:
-        case 303:
-        case 307:
-        case 308:
-            return true;
-        default:
-            return false;
-        }
-    }
-
-    @Override
-    public List<Cookie> getCookies() {
-
-        if (headers == null) {
-            return Collections.emptyList();
-        }
-
-        if (cookies == null) {
-            cookies = buildCookies();
-        }
-        return cookies;
-
-    }
-
-    @Override
-    public boolean hasResponseStatus() {
-        return status != null;
-    }
-
-    @Override
-    public boolean hasResponseHeaders() {
-        return headers != null && !headers.getHeaders().isEmpty();
-    }
-
-    @Override
-    public boolean hasResponseBody() {
-        return isNonEmpty(bodyParts);
-    }
-
-    @Override
-    public String toString() {
-        StringBuilder sb = new StringBuilder();
-        sb.append(getClass().getSimpleName()).append(" {\n")//
-        .append("\tstatusCode=").append(getStatusCode()).append("\n")//
-        .append("\theaders=\n");
-        
-        for (Map.Entry<String, String> header: getHeaders()) {
-            sb.append("\t\t").append(header.getKey()).append(": ").append(header.getValue()).append("\n");
-        }
-        sb.append("\tbody=\n").append(getResponseBody()).append("\n")//
-                .append("}").toString();
-        return sb.toString();
-    }
-}
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/pool/ChannelPool.java b/client/src/main/java/org/asynchttpclient/channel/ChannelPool.java
similarity index 97%
rename from client/src/main/java/org/asynchttpclient/netty/channel/pool/ChannelPool.java
rename to client/src/main/java/org/asynchttpclient/channel/ChannelPool.java
index 348dd2e4d..f8cea67fe 100755
--- a/client/src/main/java/org/asynchttpclient/netty/channel/pool/ChannelPool.java
+++ b/client/src/main/java/org/asynchttpclient/channel/ChannelPool.java
@@ -11,7 +11,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.netty.channel.pool;
+package org.asynchttpclient.channel;
 
 import io.netty.channel.Channel;
 
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/pool/ChannelPoolPartitionSelector.java b/client/src/main/java/org/asynchttpclient/channel/ChannelPoolPartitionSelector.java
similarity index 94%
rename from client/src/main/java/org/asynchttpclient/netty/channel/pool/ChannelPoolPartitionSelector.java
rename to client/src/main/java/org/asynchttpclient/channel/ChannelPoolPartitionSelector.java
index ea39a8ef9..4abc3c602 100644
--- a/client/src/main/java/org/asynchttpclient/netty/channel/pool/ChannelPoolPartitionSelector.java
+++ b/client/src/main/java/org/asynchttpclient/channel/ChannelPoolPartitionSelector.java
@@ -11,7 +11,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.netty.channel.pool;
+package org.asynchttpclient.channel;
 
 public interface ChannelPoolPartitionSelector {
 
diff --git a/client/src/main/java/org/asynchttpclient/channel/pool/ConnectionPoolPartitioning.java b/client/src/main/java/org/asynchttpclient/channel/ChannelPoolPartitioning.java
similarity index 61%
rename from client/src/main/java/org/asynchttpclient/channel/pool/ConnectionPoolPartitioning.java
rename to client/src/main/java/org/asynchttpclient/channel/ChannelPoolPartitioning.java
index 7687ae83d..4cce3c636 100644
--- a/client/src/main/java/org/asynchttpclient/channel/pool/ConnectionPoolPartitioning.java
+++ b/client/src/main/java/org/asynchttpclient/channel/ChannelPoolPartitioning.java
@@ -10,13 +10,13 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.channel.pool;
+package org.asynchttpclient.channel;
 
 import org.asynchttpclient.proxy.ProxyServer;
 import org.asynchttpclient.uri.Uri;
 import org.asynchttpclient.util.HttpUtils;
 
-public interface ConnectionPoolPartitioning {
+public interface ChannelPoolPartitioning {
 
     class ProxyPartitionKey {
         private final String proxyHost;
@@ -31,6 +31,43 @@ public ProxyPartitionKey(String proxyHost, int proxyPort, boolean secured, Strin
             this.targetHostBaseUrl = targetHostBaseUrl;
         }
 
+        @Override
+        public int hashCode() {
+            final int prime = 31;
+            int result = 1;
+            result = prime * result + ((proxyHost == null) ? 0 : proxyHost.hashCode());
+            result = prime * result + proxyPort;
+            result = prime * result + (secured ? 1231 : 1237);
+            result = prime * result + ((targetHostBaseUrl == null) ? 0 : targetHostBaseUrl.hashCode());
+            return result;
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            if (this == obj)
+                return true;
+            if (obj == null)
+                return false;
+            if (getClass() != obj.getClass())
+                return false;
+            ProxyPartitionKey other = (ProxyPartitionKey) obj;
+            if (proxyHost == null) {
+                if (other.proxyHost != null)
+                    return false;
+            } else if (!proxyHost.equals(other.proxyHost))
+                return false;
+            if (proxyPort != other.proxyPort)
+                return false;
+            if (secured != other.secured)
+                return false;
+            if (targetHostBaseUrl == null) {
+                if (other.targetHostBaseUrl != null)
+                    return false;
+            } else if (!targetHostBaseUrl.equals(other.targetHostBaseUrl))
+                return false;
+            return true;
+        }
+
         @Override
         public String toString() {
             return new StringBuilder()//
@@ -44,7 +81,7 @@ public String toString() {
 
     Object getPartitionKey(Uri uri, String virtualHost, ProxyServer proxyServer);
 
-    enum PerHostConnectionPoolPartitioning implements ConnectionPoolPartitioning {
+    enum PerHostChannelPoolPartitioning implements ChannelPoolPartitioning {
 
         INSTANCE;
 
diff --git a/client/src/main/java/org/asynchttpclient/channel/DefaultKeepAliveStrategy.java b/client/src/main/java/org/asynchttpclient/channel/DefaultKeepAliveStrategy.java
new file mode 100644
index 000000000..a426ed062
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/channel/DefaultKeepAliveStrategy.java
@@ -0,0 +1,24 @@
+package org.asynchttpclient.channel;
+
+import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.codec.http.HttpResponse;
+
+import org.asynchttpclient.Request;
+
+/**
+ * Connection strategy implementing standard HTTP 1.0/1.1 behavior.
+ */
+public class DefaultKeepAliveStrategy implements KeepAliveStrategy {
+
+    /**
+     * Implemented in accordance with RFC 7230 section 6.1 https://tools.ietf.org/html/rfc7230#section-6.1
+     */
+    @Override
+    public boolean keepAlive(Request ahcRequest, HttpRequest request, HttpResponse response) {
+        return HttpHeaders.isKeepAlive(response)//
+                && HttpHeaders.isKeepAlive(request)
+                // support non standard Proxy-Connection
+                && !response.headers().contains("Proxy-Connection", HttpHeaders.Values.CLOSE, true);
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/channel/KeepAliveStrategy.java b/client/src/main/java/org/asynchttpclient/channel/KeepAliveStrategy.java
new file mode 100644
index 000000000..db24724e4
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/channel/KeepAliveStrategy.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.channel;
+
+import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.codec.http.HttpResponse;
+
+import org.asynchttpclient.Request;
+
+public interface KeepAliveStrategy {
+
+    /**
+     * Determines whether the connection should be kept alive after this HTTP message exchange.
+     * 
+     * @param ahcRequest the Request, as built by AHC
+     * @param nettyRequest the HTTP request sent to Netty
+     * @param nettyResponse the HTTP response received from Netty
+     * @return true if the connection should be kept alive, false if it should be closed.
+     */
+    boolean keepAlive(Request ahcRequest, HttpRequest nettyRequest, HttpResponse nettyResponse);
+}
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/pool/NoopChannelPool.java b/client/src/main/java/org/asynchttpclient/channel/NoopChannelPool.java
similarity index 91%
rename from client/src/main/java/org/asynchttpclient/netty/channel/pool/NoopChannelPool.java
rename to client/src/main/java/org/asynchttpclient/channel/NoopChannelPool.java
index ea38e4637..f5b59fab6 100644
--- a/client/src/main/java/org/asynchttpclient/netty/channel/pool/NoopChannelPool.java
+++ b/client/src/main/java/org/asynchttpclient/channel/NoopChannelPool.java
@@ -11,9 +11,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.netty.channel.pool;
-
-import org.asynchttpclient.netty.channel.pool.ChannelPoolPartitionSelector;
+package org.asynchttpclient.channel;
 
 import io.netty.channel.Channel;
 
diff --git a/client/src/main/java/org/asynchttpclient/channel/pool/KeepAliveStrategy.java b/client/src/main/java/org/asynchttpclient/channel/pool/KeepAliveStrategy.java
deleted file mode 100644
index 1c498ddb8..000000000
--- a/client/src/main/java/org/asynchttpclient/channel/pool/KeepAliveStrategy.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at
- *     http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.channel.pool;
-
-import static io.netty.handler.codec.http.HttpHeaders.Names.CONNECTION;
-import static io.netty.handler.codec.http.HttpHeaders.Values.*;
-import io.netty.handler.codec.http.HttpMessage;
-import io.netty.handler.codec.http.HttpRequest;
-import io.netty.handler.codec.http.HttpResponse;
-import io.netty.handler.codec.http.HttpVersion;
-
-import org.asynchttpclient.Request;
-
-public interface KeepAliveStrategy {
-
-    /**
-     * Determines whether the connection should be kept alive after this HTTP message exchange.
-     * @param ahcRequest the Request, as built by AHC
-     * @param nettyRequest the HTTP request sent to Netty
-     * @param nettyResponse the HTTP response received from Netty
-     * @return true if the connection should be kept alive, false if it should be closed.
-     */
-    boolean keepAlive(Request ahcRequest, HttpRequest nettyRequest, HttpResponse nettyResponse);
-
-    /**
-     * Connection strategy implementing standard HTTP 1.0/1.1 behaviour.
-     */
-    enum DefaultKeepAliveStrategy implements KeepAliveStrategy {
-        
-        INSTANCE;
-
-        /**
-         * Implemented in accordance with RFC 7230 section 6.1
-         * https://tools.ietf.org/html/rfc7230#section-6.1
-         */
-        @Override
-        public boolean keepAlive(Request ahcRequest, HttpRequest request, HttpResponse response) {
-
-            String responseConnectionHeader = connectionHeader(response);
-
-            if (CLOSE.equalsIgnoreCase(responseConnectionHeader)) {
-                return false;
-            } else {
-                String requestConnectionHeader = connectionHeader(request);
-
-                if (request.getProtocolVersion() == HttpVersion.HTTP_1_0) {
-                    // only use keep-alive if both parties agreed upon it
-                    return KEEP_ALIVE.equalsIgnoreCase(requestConnectionHeader) && KEEP_ALIVE.equalsIgnoreCase(responseConnectionHeader);
-
-                } else {
-                    // 1.1+, keep-alive is default behavior
-                    return !CLOSE.equalsIgnoreCase(requestConnectionHeader);
-                }
-            }
-        }
-
-        private String connectionHeader(HttpMessage message) {
-            return message.headers().get(CONNECTION);
-        }
-    }
-}
diff --git a/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigDefaults.java b/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigDefaults.java
index 9830912d8..1d2c06fee 100644
--- a/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigDefaults.java
+++ b/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigDefaults.java
@@ -79,6 +79,10 @@ public static boolean defaultUseProxyProperties() {
         return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "useProxyProperties");
     }
 
+    public static boolean defaultValidateResponseHeaders() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "validateResponseHeaders");
+    }
+
     public static boolean defaultStrict302Handling() {
         return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "strict302Handling");
     }
@@ -111,6 +115,26 @@ public static int defaultSslSessionTimeout() {
         return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "sslSessionTimeout");
     }
 
+    public static boolean defaultTcpNoDelay() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "tcpNoDelay");
+    }
+
+    public static boolean defaultSoReuseAddress() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "soReuseAddress");
+    }
+
+    public static int defaultSoLinger() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "soLinger");
+    }
+
+    public static int defaultSoSndBuf() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "soSndBuf");
+    }
+
+    public static int defaultSoRcvBuf() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "soRcvBuf");
+    }
+
     public static int defaultHttpClientCodecMaxInitialLineLength() {
         return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getInt(ASYNC_CLIENT_CONFIG_ROOT + "httpClientCodecMaxInitialLineLength");
     }
@@ -158,4 +182,8 @@ public static int defaultShutdownTimeout() {
     public static boolean defaultUseNativeTransport() {
         return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "useNativeTransport");
     }
+
+    public static boolean defaultUsePooledMemory() {
+        return AsyncHttpClientConfigHelper.getAsyncHttpClientConfig().getBoolean(ASYNC_CLIENT_CONFIG_ROOT + "usePooledMemory");
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigHelper.java b/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigHelper.java
index 0a31e823a..b2f3c5ea1 100644
--- a/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigHelper.java
+++ b/client/src/main/java/org/asynchttpclient/config/AsyncHttpClientConfigHelper.java
@@ -47,6 +47,13 @@ private Properties parsePropertiesFile(String file) {
             try (InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream(file)) {
                 if (is != null) {
                     props.load(is);
+                } else {
+                   //Try loading from this class classloader instead, e.g. for OSGi environments.
+                    try(InputStream is2 = this.getClass().getClassLoader().getResourceAsStream(file)) {
+                        if (is2 != null) {
+                            props.load(is2);
+                        }
+                    }
                 }
             } catch (IOException e) {
                 throw new IllegalArgumentException("Can't parse file", e);
diff --git a/client/src/main/java/org/asynchttpclient/cookie/CookieEncoder.java b/client/src/main/java/org/asynchttpclient/cookie/CookieEncoder.java
index ab657edf1..74896bca5 100644
--- a/client/src/main/java/org/asynchttpclient/cookie/CookieEncoder.java
+++ b/client/src/main/java/org/asynchttpclient/cookie/CookieEncoder.java
@@ -12,20 +12,63 @@
  */
 package org.asynchttpclient.cookie;
 
-import org.asynchttpclient.util.StringUtils;
-
+import java.util.Arrays;
 import java.util.Collection;
+import java.util.Comparator;
+
+import org.asynchttpclient.util.StringUtils;
 
 public final class CookieEncoder {
 
+    /**
+     * Sort cookies into decreasing order of path length, breaking ties by sorting into increasing chronological order of creation time, as recommended by RFC 6265.
+     */
+    private static final Comparator<Cookie> COOKIE_COMPARATOR = new Comparator<Cookie>() {
+        @Override
+        public int compare(Cookie c1, Cookie c2) {
+            String path1 = c1.getPath();
+            String path2 = c2.getPath();
+            // Cookies with unspecified path default to the path of the request. We don't
+            // know the request path here, but we assume that the length of an unspecified
+            // path is longer than any specified path (i.e. pathless cookies come first),
+            // because setting cookies with a path longer than the request path is of
+            // limited use.
+            int len1 = path1 == null ? Integer.MAX_VALUE : path1.length();
+            int len2 = path2 == null ? Integer.MAX_VALUE : path2.length();
+            int diff = len2 - len1;
+            if (diff != 0) {
+                return diff;
+            }
+            // Rely on Java's sort stability to retain creation order in cases where
+            // cookies have same path length.
+            return -1;
+        }
+    };
+
     private CookieEncoder() {
     }
 
     public static String encode(Collection<Cookie> cookies) {
         StringBuilder sb = StringUtils.stringBuilder();
 
-        for (Cookie cookie : cookies) {
-            add(sb, cookie.getName(), cookie.getValue(), cookie.isWrap());
+        if (cookies.isEmpty()) {
+            return "";
+
+        } else if (cookies.size() == 1) {
+            Cookie cookie = cookies.iterator().next();
+            if (cookie != null) {
+                add(sb, cookie.getName(), cookie.getValue(), cookie.isWrap());
+            }
+
+        } else {
+            Cookie[] cookiesSorted = cookies.toArray(new Cookie[cookies.size()]);
+            Arrays.sort(cookiesSorted, COOKIE_COMPARATOR);
+            for (int i = 0; i < cookiesSorted.length; i++) {
+                Cookie cookie = cookiesSorted[i];
+                if (cookie != null) {
+                    add(sb, cookie.getName(), cookie.getValue(), cookie.isWrap());
+                }
+            }
         }
 
         if (sb.length() > 0) {
diff --git a/client/src/main/java/org/asynchttpclient/channel/NameResolver.java b/client/src/main/java/org/asynchttpclient/exception/ChannelClosedException.java
similarity index 50%
rename from client/src/main/java/org/asynchttpclient/channel/NameResolver.java
rename to client/src/main/java/org/asynchttpclient/exception/ChannelClosedException.java
index 3a595d851..93bbf7fad 100644
--- a/client/src/main/java/org/asynchttpclient/channel/NameResolver.java
+++ b/client/src/main/java/org/asynchttpclient/exception/ChannelClosedException.java
@@ -10,26 +10,18 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.channel;
+package org.asynchttpclient.exception;
 
-import java.net.InetAddress;
-import java.net.UnknownHostException;
+import java.io.IOException;
 
-public interface NameResolver {
+import static org.asynchttpclient.util.MiscUtils.trimStackTrace;
 
-    NameResolution[] resolve(String name) throws UnknownHostException;
+@SuppressWarnings("serial")
+public final class ChannelClosedException extends IOException {
 
-    enum JdkNameResolver implements NameResolver {
+    public static final ChannelClosedException INSTANCE = trimStackTrace(new ChannelClosedException());
 
-        INSTANCE;
-
-        @Override
-        public NameResolution[] resolve(String name) throws UnknownHostException {
-            InetAddress[] addresses = InetAddress.getAllByName(name);
-            NameResolution[] resolutions = new NameResolution[addresses.length];
-            for (int i = 0; i < addresses.length; i++)
-                resolutions[i] = new NameResolution(addresses[i]);
-            return resolutions;
-        }
+    private ChannelClosedException() {
+        super("Channel closed");
     }
 }
diff --git a/client/src/main/java/org/asynchttpclient/exception/PoolAlreadyClosedException.java b/client/src/main/java/org/asynchttpclient/exception/PoolAlreadyClosedException.java
new file mode 100644
index 000000000..2209fb2ef
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/exception/PoolAlreadyClosedException.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.exception;
+
+import java.io.IOException;
+
+import static org.asynchttpclient.util.MiscUtils.trimStackTrace;
+
+@SuppressWarnings("serial")
+public class PoolAlreadyClosedException extends IOException {
+
+    public static final PoolAlreadyClosedException INSTANCE = trimStackTrace(new PoolAlreadyClosedException());
+
+    private PoolAlreadyClosedException() {
+        super("Pool is already closed");
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/channel/NameResolution.java b/client/src/main/java/org/asynchttpclient/exception/RemotelyClosedException.java
similarity index 60%
rename from client/src/main/java/org/asynchttpclient/channel/NameResolution.java
rename to client/src/main/java/org/asynchttpclient/exception/RemotelyClosedException.java
index bc28dafce..a3df8ef19 100644
--- a/client/src/main/java/org/asynchttpclient/channel/NameResolution.java
+++ b/client/src/main/java/org/asynchttpclient/exception/RemotelyClosedException.java
@@ -10,23 +10,18 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.channel;
+package org.asynchttpclient.exception;
 
-import java.net.InetAddress;
+import java.io.IOException;
 
-public class NameResolution {
+import static org.asynchttpclient.util.MiscUtils.trimStackTrace;
 
-    public static final long UNKNOWN_EXPIRATION = 0;
-    
-    public final InetAddress address;
-    public final long expiration;
-    
-    public NameResolution(InetAddress address) {
-        this(address, UNKNOWN_EXPIRATION);
-       }
+@SuppressWarnings("serial")
+public final class RemotelyClosedException extends IOException {
+
+    public static final RemotelyClosedException INSTANCE = trimStackTrace(new RemotelyClosedException());
     
-    public NameResolution(InetAddress address, long expiration) {
-     this.address = address;
-     this.expiration = expiration;
+    public RemotelyClosedException() {
+        super("Remotely closed");
     }
 }
diff --git a/client/src/main/java/org/asynchttpclient/exception/TooManyConnectionsException.java b/client/src/main/java/org/asynchttpclient/exception/TooManyConnectionsException.java
new file mode 100644
index 000000000..2685e3a95
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/exception/TooManyConnectionsException.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.exception;
+
+import java.io.IOException;
+
+@SuppressWarnings("serial")
+public class TooManyConnectionsException extends IOException {
+
+    public TooManyConnectionsException(int max) {
+        super("Too many connections: " + max);
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/exception/TooManyConnectionsPerHostException.java b/client/src/main/java/org/asynchttpclient/exception/TooManyConnectionsPerHostException.java
new file mode 100644
index 000000000..a08a22ee3
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/exception/TooManyConnectionsPerHostException.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.exception;
+
+import java.io.IOException;
+
+@SuppressWarnings("serial")
+public class TooManyConnectionsPerHostException extends IOException {
+
+    public TooManyConnectionsPerHostException(int max) {
+        super("Too many connections: " + max);
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/handler/AsyncHandlerExtensions.java b/client/src/main/java/org/asynchttpclient/handler/AsyncHandlerExtensions.java
index 45151b8ec..167b4003d 100644
--- a/client/src/main/java/org/asynchttpclient/handler/AsyncHandlerExtensions.java
+++ b/client/src/main/java/org/asynchttpclient/handler/AsyncHandlerExtensions.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010-2012 Sonatype, Inc. All rights reserved.
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -14,57 +14,100 @@
 
 import io.netty.channel.Channel;
 
-import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.util.List;
 
 import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.channel.NameResolution;
 import org.asynchttpclient.netty.request.NettyRequest;
 
 /**
  * This interface hosts new low level callback methods on {@link AsyncHandler}.
- * For now, those methods are in a dedicated interface in order not to break the
- * existing API, but could be merged into one of the existing ones in AHC 2.
  * 
  */
 public interface AsyncHandlerExtensions {
 
+    // ////////// DNS /////////////////
+
     /**
-     * Notify the callback when trying to open a new connection.
+     * Notify the callback before hostname resolution
+     * 
+     * @param name the name to be resolved
      */
-    void onConnectionOpen();
+    void onHostnameResolutionAttempt(String name);
 
     /**
-     * Notify the callback after DNS resolution has completed.
+     * Notify the callback after hostname resolution was successful.
      * 
+     * @param name the name to be resolved
      * @param addresses the resolved addresses
      */
-    void onDnsResolved(NameResolution[] addresses);
+    void onHostnameResolutionSuccess(String name, List<InetSocketAddress> addresses);
+
+    /**
+     * Notify the callback after hostname resolution failed.
+     * 
+     * @param name the name to be resolved
+     * @param cause the failure cause
+     */
+    void onHostnameResolutionFailure(String name, Throwable cause);
+
+    // ////////////// TCP CONNECT ////////
+
+    /**
+     * Notify the callback when trying to open a new connection.
+     * 
+     * Might be called several times if the name was resolved to multiple addresses and we failed to connect to the first(s) one(s).
+     * 
+     * @param remoteAddress the address we try to connect to
+     */
+    void onTcpConnectAttempt(InetSocketAddress remoteAddress);
 
     /**
      * Notify the callback after a successful connect
      * 
+     * @param remoteAddress the address we try to connect to
      * @param connection the connection
-     * @param address the connected addresses
      */
-    void onConnectionSuccess(Channel connection, InetAddress address);
-    
+    void onTcpConnectSuccess(InetSocketAddress remoteAddress, Channel connection);
+
     /**
      * Notify the callback after a failed connect.
-     * Might be called several times, or be followed by onConnectionSuccess
-     * when the name was resolved to multiple addresses.
      * 
-     * @param address the tentative addresses
+     * Might be called several times, or be followed by onTcpConnectSuccess when the name was resolved to multiple addresses.
+     * 
+     * @param remoteAddress the address we try to connect to
+     * @param cause the cause of the failure
      */
-    void onConnectionFailure(InetAddress address);
+    void onTcpConnectFailure(InetSocketAddress remoteAddress, Throwable cause);
+
+    // ////////////// TLS ///////////////
+
+    /**
+     * Notify the callback before TLS handshake
+     */
+    void onTlsHandshakeAttempt();
+
+    /**
+     * Notify the callback after the TLS was successful
+     */
+    void onTlsHandshakeSuccess();
+
+    /**
+     * Notify the callback after the TLS failed
+     * 
+     * @param cause the cause of the failure
+     */
+    void onTlsHandshakeFailure(Throwable cause);
+
+    // /////////// POOLING /////////////
 
     /**
      * Notify the callback when trying to fetch a connection from the pool.
      */
-    void onConnectionPool();
+    void onConnectionPoolAttempt();
 
     /**
-     * Notify the callback when a new connection was successfully fetched from
-     * the pool.
+     * Notify the callback when a new connection was successfully fetched from the pool.
      * 
      * @param connection the connection
      */
@@ -77,10 +120,11 @@
      */
     void onConnectionOffer(Channel connection);
 
+    // //////////// SENDING //////////////
+
     /**
-     * Notify the callback when a request is being written on the wire. If the
-     * original request causes multiple requests to be sent, for example,
-     * because of authorization or retry, it will be notified multiple times.
+     * Notify the callback when a request is being written on the channel. If the original request causes multiple requests to be sent, for example, because of authorization or
+     * retry, it will be notified multiple times.
      * 
      * @param request the real request object as passed to the provider
      */
@@ -90,10 +134,4 @@
      * Notify the callback every time a request is being retried.
      */
     void onRetry();
-
-    /**
-     * Notify the callback when the SSL handshake performed to establish an
-     * HTTPS connection has been completed.
-     */
-    void onSslHandshakeCompleted();
 }
diff --git a/client/src/main/java/org/asynchttpclient/handler/AsyncHandlerExtensionsUtils.java b/client/src/main/java/org/asynchttpclient/handler/AsyncHandlerExtensionsUtils.java
new file mode 100644
index 000000000..3d6f7d37f
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/handler/AsyncHandlerExtensionsUtils.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.handler;
+
+import org.asynchttpclient.AsyncHandler;
+
+public final class AsyncHandlerExtensionsUtils {
+
+    public static AsyncHandlerExtensions toAsyncHandlerExtensions(AsyncHandler<?> asyncHandler) {
+        return asyncHandler instanceof AsyncHandlerExtensions ? (AsyncHandlerExtensions) asyncHandler : null;
+    }
+
+    private AsyncHandlerExtensionsUtils() {
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/handler/ExtendedAsyncHandler.java b/client/src/main/java/org/asynchttpclient/handler/ExtendedAsyncHandler.java
new file mode 100644
index 000000000..6c173d4a3
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/handler/ExtendedAsyncHandler.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.handler;
+
+import io.netty.channel.Channel;
+
+import java.net.InetSocketAddress;
+import java.util.List;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.netty.request.NettyRequest;
+
+public abstract class ExtendedAsyncHandler<T> implements AsyncHandler<T>, AsyncHandlerExtensions {
+
+    @Override
+    public void onHostnameResolutionAttempt(String name) {
+    }
+
+    @Override
+    public void onHostnameResolutionSuccess(String name, List<InetSocketAddress> addresses) {
+    }
+
+    @Override
+    public void onHostnameResolutionFailure(String name, Throwable cause) {
+    }
+
+    @Override
+    public void onTcpConnectAttempt(InetSocketAddress address) {
+    }
+
+    @Override
+    public void onTcpConnectSuccess(InetSocketAddress remoteAddress, Channel connection) {
+    }
+
+    @Override
+    public void onTcpConnectFailure(InetSocketAddress remoteAddress, Throwable cause) {
+    }
+
+    @Override
+    public void onTlsHandshakeAttempt() {
+    }
+
+    @Override
+    public void onTlsHandshakeSuccess() {
+    }
+
+    @Override
+    public void onTlsHandshakeFailure(Throwable cause) {
+    }
+
+    @Override
+    public void onConnectionPoolAttempt() {
+    }
+
+    @Override
+    public void onConnectionPooled(Channel connection) {
+    }
+
+    @Override
+    public void onConnectionOffer(Channel connection) {
+    }
+
+    @Override
+    public void onRequestSend(NettyRequest request) {
+    }
+
+    @Override
+    public void onRetry() {
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/handler/MaxRedirectException.java b/client/src/main/java/org/asynchttpclient/handler/MaxRedirectException.java
index fd91b4546..e88882e2b 100644
--- a/client/src/main/java/org/asynchttpclient/handler/MaxRedirectException.java
+++ b/client/src/main/java/org/asynchttpclient/handler/MaxRedirectException.java
@@ -1,18 +1,15 @@
 /*
- * Copyright 2010 Ning, Inc.
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
  *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
  *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 package org.asynchttpclient.handler;
 
diff --git a/client/src/main/java/org/asynchttpclient/handler/resumable/ResumableAsyncHandler.java b/client/src/main/java/org/asynchttpclient/handler/resumable/ResumableAsyncHandler.java
index 3359a8bef..1f1ec608d 100644
--- a/client/src/main/java/org/asynchttpclient/handler/resumable/ResumableAsyncHandler.java
+++ b/client/src/main/java/org/asynchttpclient/handler/resumable/ResumableAsyncHandler.java
@@ -40,6 +40,8 @@
  * to track how many bytes has been transferred and to properly adjust the file's write position.
  * <br>
  * In case of a JVM crash/shutdown, you can create an instance of this class and pass the last valid bytes position.
+ * 
+ * Beware that it registers a shutdown hook, that will cause a ClassLoader leak when used in an appserver and only redeploying the application.
  */
 public class ResumableAsyncHandler implements AsyncHandler<Response> {
     private final static Logger logger = LoggerFactory.getLogger(TransferCompletionHandler.class);
diff --git a/client/src/main/java/org/asynchttpclient/netty/EagerNettyResponseBodyPart.java b/client/src/main/java/org/asynchttpclient/netty/EagerResponseBodyPart.java
similarity index 85%
rename from client/src/main/java/org/asynchttpclient/netty/EagerNettyResponseBodyPart.java
rename to client/src/main/java/org/asynchttpclient/netty/EagerResponseBodyPart.java
index 384b99d26..f8020d260 100755
--- a/client/src/main/java/org/asynchttpclient/netty/EagerNettyResponseBodyPart.java
+++ b/client/src/main/java/org/asynchttpclient/netty/EagerResponseBodyPart.java
@@ -12,20 +12,22 @@
  */
 package org.asynchttpclient.netty;
 
-import static org.asynchttpclient.netty.util.ByteBufUtils.byteBuf2Bytes;
+import static org.asynchttpclient.util.ByteBufUtils.byteBuf2Bytes;
 import io.netty.buffer.ByteBuf;
 
 import java.nio.ByteBuffer;
 
+import org.asynchttpclient.HttpResponseBodyPart;
+
 /**
  * A callback class used when an HTTP response body is received.
  * Bytes are eagerly fetched from the ByteBuf
  */
-public class EagerNettyResponseBodyPart extends NettyResponseBodyPart {
+public class EagerResponseBodyPart extends HttpResponseBodyPart {
 
     private final byte[] bytes;
 
-    public EagerNettyResponseBodyPart(ByteBuf buf, boolean last) {
+    public EagerResponseBodyPart(ByteBuf buf, boolean last) {
         super(last);
         bytes = byteBuf2Bytes(buf);
     }
diff --git a/client/src/main/java/org/asynchttpclient/netty/LazyNettyResponseBodyPart.java b/client/src/main/java/org/asynchttpclient/netty/LazyResponseBodyPart.java
similarity index 86%
rename from client/src/main/java/org/asynchttpclient/netty/LazyNettyResponseBodyPart.java
rename to client/src/main/java/org/asynchttpclient/netty/LazyResponseBodyPart.java
index b9b30ed36..02159fb85 100755
--- a/client/src/main/java/org/asynchttpclient/netty/LazyNettyResponseBodyPart.java
+++ b/client/src/main/java/org/asynchttpclient/netty/LazyResponseBodyPart.java
@@ -16,16 +16,17 @@
 
 import java.nio.ByteBuffer;
 
-import org.asynchttpclient.netty.util.ByteBufUtils;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.util.ByteBufUtils;
 
 /**
  * A callback class used when an HTTP response body is received.
  */
-public class LazyNettyResponseBodyPart extends NettyResponseBodyPart {
+public class LazyResponseBodyPart extends HttpResponseBodyPart {
 
     private final ByteBuf buf;
 
-    public LazyNettyResponseBodyPart(ByteBuf buf, boolean last) {
+    public LazyResponseBodyPart(ByteBuf buf, boolean last) {
         super(last);
         this.buf = buf;
     }
diff --git a/client/src/main/java/org/asynchttpclient/netty/NettyResponse.java b/client/src/main/java/org/asynchttpclient/netty/NettyResponse.java
index 935839c24..2e7e788f2 100755
--- a/client/src/main/java/org/asynchttpclient/netty/NettyResponse.java
+++ b/client/src/main/java/org/asynchttpclient/netty/NettyResponse.java
@@ -13,41 +13,53 @@
  */
 package org.asynchttpclient.netty;
 
+import static io.netty.handler.codec.http.HttpHeaders.Names.*;
+import static org.asynchttpclient.util.HttpUtils.*;
 import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 import io.netty.handler.codec.http.HttpHeaders;
 
 import java.io.ByteArrayInputStream;
 import java.io.InputStream;
+import java.net.SocketAddress;
 import java.nio.ByteBuffer;
 import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
+import java.util.Map;
 
 import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.HttpResponseHeaders;
 import org.asynchttpclient.HttpResponseStatus;
-import org.asynchttpclient.ResponseBase;
+import org.asynchttpclient.Response;
 import org.asynchttpclient.cookie.Cookie;
 import org.asynchttpclient.cookie.CookieDecoder;
+import org.asynchttpclient.uri.Uri;
 
 /**
  * Wrapper around the {@link org.asynchttpclient.Response} API.
  */
-public class NettyResponse extends ResponseBase {
+public class NettyResponse implements Response {
+
+    private final List<HttpResponseBodyPart> bodyParts;
+    private final HttpResponseHeaders headers;
+    private final HttpResponseStatus status;
+    private List<Cookie> cookies;
 
     public NettyResponse(HttpResponseStatus status,//
             HttpResponseHeaders headers,//
             List<HttpResponseBodyPart> bodyParts) {
-        super(status, headers, bodyParts);
+        this.bodyParts = bodyParts;
+        this.headers = headers;
+        this.status = status;
     }
 
-    protected List<Cookie> buildCookies() {
+    private List<Cookie> buildCookies() {
 
-        List<String> setCookieHeaders = headers.getHeaders().getAll(HttpHeaders.Names.SET_COOKIE2);
+        List<String> setCookieHeaders = headers.getHeaders().getAll(SET_COOKIE2);
 
         if (!isNonEmpty(setCookieHeaders)) {
-            setCookieHeaders = headers.getHeaders().getAll(HttpHeaders.Names.SET_COOKIE);
+            setCookieHeaders = headers.getHeaders().getAll(SET_COOKIE);
         }
 
         if (isNonEmpty(setCookieHeaders)) {
@@ -63,6 +75,94 @@ public NettyResponse(HttpResponseStatus status,//
         return Collections.emptyList();
     }
 
+    @Override
+    public final int getStatusCode() {
+        return status.getStatusCode();
+    }
+
+    @Override
+    public final String getStatusText() {
+        return status.getStatusText();
+    }
+
+    @Override
+    public final Uri getUri() {
+        return status.getUri();
+    }
+
+    @Override
+    public SocketAddress getRemoteAddress() {
+        return status.getRemoteAddress();
+    }
+
+    @Override
+    public SocketAddress getLocalAddress() {
+        return status.getLocalAddress();
+    }
+
+    @Override
+    public final String getContentType() {
+        return headers != null ? getHeader(CONTENT_TYPE) : null;
+    }
+
+    @Override
+    public final String getHeader(String name) {
+        return headers != null ? getHeaders().get(name) : null;
+    }
+
+    @Override
+    public final List<String> getHeaders(String name) {
+        return headers != null ? getHeaders().getAll(name) : Collections.<String> emptyList();
+    }
+
+    @Override
+    public final HttpHeaders getHeaders() {
+        return headers != null ? headers.getHeaders() : HttpHeaders.EMPTY_HEADERS;
+    }
+
+    @Override
+    public final boolean isRedirected() {
+        switch (status.getStatusCode()) {
+        case 301:
+        case 302:
+        case 303:
+        case 307:
+        case 308:
+            return true;
+        default:
+            return false;
+        }
+    }
+
+    @Override
+    public List<Cookie> getCookies() {
+
+        if (headers == null) {
+            return Collections.emptyList();
+        }
+
+        if (cookies == null) {
+            cookies = buildCookies();
+        }
+        return cookies;
+
+    }
+
+    @Override
+    public boolean hasResponseStatus() {
+        return status != null;
+    }
+
+    @Override
+    public boolean hasResponseHeaders() {
+        return headers != null && !headers.getHeaders().isEmpty();
+    }
+
+    @Override
+    public boolean hasResponseBody() {
+        return isNonEmpty(bodyParts);
+    }
+
     @Override
     public byte[] getResponseBodyAsBytes() {
         return getResponseBodyAsByteBuffer().array();
@@ -87,13 +187,39 @@ public String getResponseBody() {
         return getResponseBody(null);
     }
 
+    private Charset computeCharset(Charset charset) {
+
+        if (charset == null) {
+            String contentType = getContentType();
+            if (contentType != null)
+                charset = parseCharset(contentType); // parseCharset can return
+                                                     // null
+        }
+        return charset != null ? charset : DEFAULT_CHARSET;
+    }
+
     @Override
     public String getResponseBody(Charset charset) {
-        return new String(getResponseBodyAsBytes(), calculateCharset(charset));
+        return new String(getResponseBodyAsBytes(), computeCharset(charset));
     }
 
     @Override
     public InputStream getResponseBodyAsStream() {
         return new ByteArrayInputStream(getResponseBodyAsBytes());
     }
+
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder();
+        sb.append(getClass().getSimpleName()).append(" {\n")//
+                .append("\tstatusCode=").append(getStatusCode()).append("\n")//
+                .append("\theaders=\n");
+
+        for (Map.Entry<String, String> header : getHeaders()) {
+            sb.append("\t\t").append(header.getKey()).append(": ").append(header.getValue()).append("\n");
+        }
+        sb.append("\tbody=\n").append(getResponseBody()).append("\n")//
+                .append("}").toString();
+        return sb.toString();
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/NettyResponseFuture.java b/client/src/main/java/org/asynchttpclient/netty/NettyResponseFuture.java
index 8e362c171..79920d6bb 100755
--- a/client/src/main/java/org/asynchttpclient/netty/NettyResponseFuture.java
+++ b/client/src/main/java/org/asynchttpclient/netty/NettyResponseFuture.java
@@ -14,10 +14,10 @@
 package org.asynchttpclient.netty;
 
 import static org.asynchttpclient.util.DateUtils.millisTime;
+import static org.asynchttpclient.util.MiscUtils.getCause;
+import static io.netty.util.internal.PlatformDependent.*;
 import io.netty.channel.Channel;
-import io.netty.handler.codec.http.HttpHeaders;
 
-import java.net.SocketAddress;
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CountDownLatch;
@@ -27,14 +27,13 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicLong;
-import java.util.concurrent.atomic.AtomicReference;
+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.Realm;
 import org.asynchttpclient.Request;
-import org.asynchttpclient.channel.pool.ConnectionPoolPartitioning;
+import org.asynchttpclient.channel.ChannelPoolPartitioning;
 import org.asynchttpclient.future.AbstractListenableFuture;
 import org.asynchttpclient.netty.channel.ChannelState;
 import org.asynchttpclient.netty.channel.Channels;
@@ -54,8 +53,17 @@
 
     private static final Logger LOGGER = LoggerFactory.getLogger(NettyResponseFuture.class);
 
+    private static final AtomicIntegerFieldUpdater<NettyResponseFuture<?>> REDIRECT_COUNT_UPDATER = newAtomicIntegerFieldUpdater(NettyResponseFuture.class, "redirectCount");
+    private static final AtomicIntegerFieldUpdater<NettyResponseFuture<?>> CURRENT_RETRY_UPDATER = newAtomicIntegerFieldUpdater(NettyResponseFuture.class, "currentRetry");
+    @SuppressWarnings("rawtypes")
+    // FIXME see https://github.com/netty/netty/pull/4669
+    private static final AtomicReferenceFieldUpdater<NettyResponseFuture, Object> CONTENT_UPDATER = newAtomicReferenceFieldUpdater(NettyResponseFuture.class, "content");
+    @SuppressWarnings("rawtypes")
+    // FIXME see https://github.com/netty/netty/pull/4669
+    private static final AtomicReferenceFieldUpdater<NettyResponseFuture, ExecutionException> EX_EX_UPDATER = newAtomicReferenceFieldUpdater(NettyResponseFuture.class, "exEx");
+
     private final long start = millisTime();
-    private final ConnectionPoolPartitioning connectionPoolPartitioning;
+    private final ChannelPoolPartitioning connectionPoolPartitioning;
     private final ProxyServer proxyServer;
     private final int maxRetry;
     private final CountDownLatch latch = new CountDownLatch(1);
@@ -64,18 +72,22 @@
     // TODO check if they are indeed mutated outside the event loop
     private final AtomicBoolean isDone = new AtomicBoolean(false);
     private final AtomicBoolean isCancelled = new AtomicBoolean(false);
-    private final AtomicInteger redirectCount = new AtomicInteger();
     private final AtomicBoolean inAuth = new AtomicBoolean(false);
     private final AtomicBoolean inProxyAuth = new AtomicBoolean(false);
     private final AtomicBoolean statusReceived = new AtomicBoolean(false);
-    private final AtomicLong touch = new AtomicLong(millisTime());
-    private final AtomicReference<ChannelState> channelState = new AtomicReference<>(ChannelState.NEW);
     private final AtomicBoolean contentProcessed = new AtomicBoolean(false);
-    private final AtomicInteger currentRetry = new AtomicInteger(0);
     private final AtomicBoolean onThrowableCalled = new AtomicBoolean(false);
-    private final AtomicReference<V> content = new AtomicReference<>();
-    private final AtomicReference<ExecutionException> exEx = new AtomicReference<>();
+
+    // volatile where we need CAS ops
+    private volatile int redirectCount = 0;
+    private volatile int currentRetry = 0;
+    private volatile V content;
+    private volatile ExecutionException exEx;
+
+    // volatile where we don't need CAS ops
+    private volatile long touch = millisTime();
     private volatile TimeoutsHolder timeoutsHolder;
+    private volatile ChannelState channelState = ChannelState.NEW;
 
     // state mutated only inside the event loop
     private Channel channel;
@@ -83,7 +95,6 @@
     private Request targetRequest;
     private Request currentRequest;
     private NettyRequest nettyRequest;
-    private HttpHeaders httpHeaders;
     private AsyncHandler<V> asyncHandler;
     private boolean streamWasAlreadyConsumed;
     private boolean reuseChannel;
@@ -92,12 +103,13 @@
     private boolean allowConnect;
     private Realm realm;
     private Realm proxyRealm;
+    public Throwable pendingException;
 
     public NettyResponseFuture(Request originalRequest,//
             AsyncHandler<V> asyncHandler,//
             NettyRequest nettyRequest,//
             int maxRetry,//
-            ConnectionPoolPartitioning connectionPoolPartitioning,//
+            ChannelPoolPartitioning connectionPoolPartitioning,//
             ProxyServer proxyServer) {
 
         this.asyncHandler = asyncHandler;
@@ -163,13 +175,14 @@ private V getContent() throws ExecutionException {
         if (isCancelled())
             throw new CancellationException();
 
-        ExecutionException e = exEx.get();
+        ExecutionException e = EX_EX_UPDATER.get(this);
         if (e != null)
             throw e;
 
-        V update = content.get();
+        @SuppressWarnings("unchecked")
+        V update = (V) CONTENT_UPDATER.get(this);
         // No more retry
-        currentRetry.set(maxRetry);
+        CURRENT_RETRY_UPDATER.set(this, maxRetry);
         if (!contentProcessed.getAndSet(true)) {
             try {
                 update = asyncHandler.onCompleted();
@@ -187,7 +200,7 @@ private V getContent() throws ExecutionException {
                     }
                 }
             }
-            content.compareAndSet(null, update);
+            CONTENT_UPDATER.compareAndSet(this, null, update);
         }
         return update;
     }
@@ -212,8 +225,7 @@ public final void done() {
         } catch (ExecutionException t) {
             return;
         } catch (RuntimeException t) {
-            Throwable exception = t.getCause() != null ? t.getCause() : t;
-            exEx.compareAndSet(null, new ExecutionException(exception));
+            EX_EX_UPDATER.compareAndSet(this, null, new ExecutionException(getCause(t)));
 
         } finally {
             latch.countDown();
@@ -224,7 +236,7 @@ public final void done() {
 
     public final void abort(final Throwable t) {
 
-        exEx.compareAndSet(null, new ExecutionException(t));
+        EX_EX_UPDATER.compareAndSet(this, null, new ExecutionException(t));
 
         if (terminateAndExit())
             return;
@@ -242,7 +254,7 @@ public final void abort(final Throwable t) {
 
     @Override
     public void touch() {
-        touch.set(millisTime());
+        touch = millisTime();
     }
 
     @Override
@@ -250,12 +262,13 @@ public void touch() {
         CompletableFuture<V> completable = new CompletableFuture<>();
         addListener(new Runnable() {
             @Override
+            @SuppressWarnings("unchecked")
             public void run() {
-                ExecutionException e = exEx.get();
+                ExecutionException e = EX_EX_UPDATER.get(NettyResponseFuture.this);
                 if (e != null)
                     completable.completeExceptionally(e);
                 else
-                    completable.complete(content.get());
+                    completable.complete((V) CONTENT_UPDATER.get(NettyResponseFuture.this));
             }
 
         }, new Executor() {
@@ -267,14 +280,14 @@ public void execute(Runnable command) {
 
         return completable;
     }
-    
+
     // INTERNAL
 
     public Uri getUri() {
         return targetRequest.getUri();
     }
 
-    public ConnectionPoolPartitioning getConnectionPoolPartitioning() {
+    public ChannelPoolPartitioning getConnectionPoolPartitioning() {
         return connectionPoolPartitioning;
     }
 
@@ -296,7 +309,7 @@ public void cancelTimeouts() {
     public final Request getTargetRequest() {
         return targetRequest;
     }
-    
+
     public final Request getCurrentRequest() {
         return currentRequest;
     }
@@ -321,22 +334,18 @@ public final void setKeepAlive(final boolean keepAlive) {
         this.keepAlive = keepAlive;
     }
 
-    public final HttpHeaders getHttpHeaders() {
-        return httpHeaders;
-    }
-
-    public final void setHttpHeaders(HttpHeaders httpHeaders) {
-        this.httpHeaders = httpHeaders;
-    }
-
     public int incrementAndGetCurrentRedirectCount() {
-        return redirectCount.incrementAndGet();
+        return REDIRECT_COUNT_UPDATER.incrementAndGet(this);
     }
 
     public void setTimeoutsHolder(TimeoutsHolder timeoutsHolder) {
         this.timeoutsHolder = timeoutsHolder;
     }
 
+    public TimeoutsHolder getTimeoutsHolder() {
+        return timeoutsHolder;
+    }
+
     public AtomicBoolean getInAuth() {
         return inAuth;
     }
@@ -346,11 +355,11 @@ public AtomicBoolean getInProxyAuth() {
     }
 
     public ChannelState getChannelState() {
-        return channelState.get();
+        return channelState;
     }
 
     public void setChannelState(ChannelState channelState) {
-        this.channelState.set(channelState);
+        this.channelState = channelState;
     }
 
     public boolean getAndSetStatusReceived(boolean sr) {
@@ -366,7 +375,7 @@ public void setStreamWasAlreadyConsumed(boolean streamWasAlreadyConsumed) {
     }
 
     public long getLastTouch() {
-        return touch.get();
+        return touch;
     }
 
     public void setHeadersAlreadyWrittenOnContinue(boolean headersAlreadyWrittenOnContinue) {
@@ -417,11 +426,7 @@ public boolean reuseChannel() {
     }
 
     public boolean canRetry() {
-        return maxRetry > 0 && currentRetry.incrementAndGet() <= maxRetry;
-    }
-
-    public SocketAddress getChannelRemoteAddress() {
-        return channel != null ? channel.remoteAddress() : null;
+        return maxRetry > 0 && CURRENT_RETRY_UPDATER.incrementAndGet(this) <= maxRetry;
     }
 
     public void setTargetRequest(Request targetRequest) {
@@ -433,14 +438,13 @@ public void setCurrentRequest(Request currentRequest) {
     }
 
     /**
-     * Return true if the {@link Future} can be recovered. There is some scenario where a connection can be closed by an
-     * unexpected IOException, and in some situation we can recover from that exception.
+     * Return true if the {@link Future} can be recovered. There is some scenario where a connection can be closed by an unexpected IOException, and in some situation we can
+     * recover from that exception.
      * 
      * @return true if that {@link Future} cannot be recovered.
      */
     public boolean canBeReplayed() {
-        return !isDone() && canRetry()
-                && !(Channels.isChannelValid(channel) && !getUri().getScheme().equalsIgnoreCase("https")) && !inAuth.get() && !inProxyAuth.get();
+        return !isDone() && canRetry() && !(Channels.isChannelValid(channel) && !getUri().getScheme().equalsIgnoreCase("https")) && !inAuth.get() && !inProxyAuth.get();
     }
 
     public long getStart() {
@@ -478,7 +482,6 @@ public String toString() {
                 ",\n\tcontent=" + content + //
                 ",\n\turi=" + getUri() + //
                 ",\n\tkeepAlive=" + keepAlive + //
-                ",\n\thttpHeaders=" + httpHeaders + //
                 ",\n\texEx=" + exEx + //
                 ",\n\tredirectCount=" + redirectCount + //
                 ",\n\ttimeoutsHolder=" + timeoutsHolder + //
diff --git a/client/src/main/java/org/asynchttpclient/netty/NettyResponseHeaders.java b/client/src/main/java/org/asynchttpclient/netty/NettyResponseHeaders.java
deleted file mode 100755
index 878580774..000000000
--- a/client/src/main/java/org/asynchttpclient/netty/NettyResponseHeaders.java
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at
- *     http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.netty;
-
-import io.netty.handler.codec.http.DefaultHttpHeaders;
-import io.netty.handler.codec.http.HttpHeaders;
-
-import java.util.Map;
-
-import org.asynchttpclient.HttpResponseHeaders;
-
-/**
- * A class that represent the HTTP headers.
- */
-public class NettyResponseHeaders extends HttpResponseHeaders {
-
-    private final HttpHeaders responseHeaders;
-    private final HttpHeaders trailingHeaders;
-    private final HttpHeaders headers;
-
-    public NettyResponseHeaders(HttpHeaders responseHeaders) {
-        this(responseHeaders, null);
-    }
-
-    public NettyResponseHeaders(HttpHeaders responseHeaders, HttpHeaders traillingHeaders) {
-        super(traillingHeaders != null);
-        this.responseHeaders = responseHeaders;
-        this.trailingHeaders = traillingHeaders;
-        headers = computerHeaders();
-    }
-
-    private HttpHeaders computerHeaders() {
-        HttpHeaders h = new DefaultHttpHeaders();
-        for (Map.Entry<String, String> header : responseHeaders) {
-            h.add(header.getKey(), header.getValue());
-        }
-
-        if (trailingHeaders != null) {
-            for (Map.Entry<String, String> header : trailingHeaders) {
-                h.add(header.getKey(), header.getValue());
-            }
-        }
-
-        return h;
-    }
-
-    @Override
-    public HttpHeaders getHeaders() {
-        return headers;
-    }
-}
diff --git a/client/src/main/java/org/asynchttpclient/netty/NettyResponseStatus.java b/client/src/main/java/org/asynchttpclient/netty/NettyResponseStatus.java
index b593868b3..1dde7159a 100755
--- a/client/src/main/java/org/asynchttpclient/netty/NettyResponseStatus.java
+++ b/client/src/main/java/org/asynchttpclient/netty/NettyResponseStatus.java
@@ -17,13 +17,9 @@
 import io.netty.handler.codec.http.HttpResponse;
 
 import java.net.SocketAddress;
-import java.util.List;
 
-import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.HttpResponseHeaders;
-import org.asynchttpclient.HttpResponseStatus;
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.Response;
+import org.asynchttpclient.HttpResponseStatus;
 import org.asynchttpclient.uri.Uri;
 
 /**
@@ -47,11 +43,6 @@ public NettyResponseStatus(Uri uri, AsyncHttpClientConfig config, HttpResponse r
         }
     }
 
-    @Override
-    public Response prepareResponse(HttpResponseHeaders headers, List<HttpResponseBodyPart> bodyParts) {
-        return new NettyResponse(this, headers, bodyParts);
-    }
-
     /**
      * Return the response status code
      * 
diff --git a/client/src/main/java/org/asynchttpclient/netty/SimpleChannelFutureListener.java b/client/src/main/java/org/asynchttpclient/netty/SimpleChannelFutureListener.java
new file mode 100644
index 000000000..f2c8c2c91
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/netty/SimpleChannelFutureListener.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelFutureListener;
+
+public abstract class SimpleChannelFutureListener implements ChannelFutureListener {
+
+    @Override
+    public final void operationComplete(ChannelFuture future) throws Exception {
+        Channel channel = future.channel();
+        if (future.isSuccess()) {
+            onSuccess(channel);
+        } else {
+            onFailure(channel, future.cause());
+        }
+    }
+
+    public abstract void onSuccess(Channel channel);
+
+    public abstract void onFailure(Channel channel, Throwable cause);
+}
diff --git a/client/src/main/java/org/asynchttpclient/netty/SimpleFutureListener.java b/client/src/main/java/org/asynchttpclient/netty/SimpleFutureListener.java
new file mode 100644
index 000000000..f10f9ff4c
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/netty/SimpleFutureListener.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty;
+
+import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.FutureListener;
+
+public abstract class SimpleFutureListener<V> implements FutureListener<V> {
+
+    @Override
+    public final void operationComplete(Future<V> future) throws Exception {
+        if (future.isSuccess()) {
+            onSuccess(future.getNow());
+        } else {
+            onFailure(future.cause());
+        }
+    }
+
+    protected abstract void onSuccess(V value) throws Exception;
+
+    protected abstract void onFailure(Throwable t) throws Exception;
+}
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java b/client/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java
index 615176831..e1f1659f9 100755
--- a/client/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/ChannelManager.java
@@ -13,9 +13,10 @@
  */
 package org.asynchttpclient.netty.channel;
 
-import static org.asynchttpclient.util.MiscUtils.buildStaticIOException;
+import static org.asynchttpclient.util.MiscUtils.trimStackTrace;
 import io.netty.bootstrap.Bootstrap;
 import io.netty.buffer.PooledByteBufAllocator;
+import io.netty.buffer.UnpooledByteBufAllocator;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelOption;
@@ -30,15 +31,17 @@
 import io.netty.handler.codec.http.websocketx.WebSocket08FrameDecoder;
 import io.netty.handler.codec.http.websocketx.WebSocket08FrameEncoder;
 import io.netty.handler.codec.http.websocketx.WebSocketFrameAggregator;
+import io.netty.handler.logging.LoggingHandler;
 import io.netty.handler.ssl.SslHandler;
 import io.netty.handler.stream.ChunkedWriteHandler;
 import io.netty.util.Timer;
 import io.netty.util.concurrent.DefaultThreadFactory;
-import io.netty.util.concurrent.GenericFutureListener;
-import io.netty.util.internal.chmv8.ConcurrentHashMapV8;
+import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.FutureListener;
 
 import java.io.IOException;
 import java.util.Map.Entry;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.Semaphore;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.TimeUnit;
@@ -49,16 +52,18 @@
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.SslEngineFactory;
-import org.asynchttpclient.channel.pool.ConnectionPoolPartitioning;
+import org.asynchttpclient.channel.ChannelPool;
+import org.asynchttpclient.channel.ChannelPoolPartitioning;
+import org.asynchttpclient.channel.NoopChannelPool;
+import org.asynchttpclient.exception.PoolAlreadyClosedException;
+import org.asynchttpclient.exception.TooManyConnectionsException;
+import org.asynchttpclient.exception.TooManyConnectionsPerHostException;
 import org.asynchttpclient.handler.AsyncHandlerExtensions;
 import org.asynchttpclient.netty.Callback;
 import org.asynchttpclient.netty.NettyResponseFuture;
-import org.asynchttpclient.netty.channel.pool.ChannelPool;
-import org.asynchttpclient.netty.channel.pool.DefaultChannelPool;
-import org.asynchttpclient.netty.channel.pool.NoopChannelPool;
 import org.asynchttpclient.netty.handler.AsyncHttpClientHandler;
-import org.asynchttpclient.netty.handler.HttpProtocol;
-import org.asynchttpclient.netty.handler.WebSocketProtocol;
+import org.asynchttpclient.netty.handler.HttpHandler;
+import org.asynchttpclient.netty.handler.WebSocketHandler;
 import org.asynchttpclient.netty.request.NettyRequestSender;
 import org.asynchttpclient.netty.ssl.DefaultSslEngineFactory;
 import org.asynchttpclient.proxy.ProxyServer;
@@ -80,27 +85,25 @@
     public static final String WS_ENCODER_HANDLER = "ws-encoder";
     public static final String AHC_HTTP_HANDLER = "ahc-http";
     public static final String AHC_WS_HANDLER = "ahc-ws";
+    public static final String LOGGING_HANDLER = "logging";
 
     private final AsyncHttpClientConfig config;
     private final SslEngineFactory sslEngineFactory;
     private final EventLoopGroup eventLoopGroup;
     private final boolean allowReleaseEventLoopGroup;
-    private final Class<? extends Channel> socketChannelClass;
     private final Bootstrap httpBootstrap;
     private final Bootstrap wsBootstrap;
     private final long handshakeTimeout;
     private final IOException tooManyConnections;
     private final IOException tooManyConnectionsPerHost;
-    private final IOException poolAlreadyClosed;
 
     private final ChannelPool channelPool;
     private final boolean maxTotalConnectionsEnabled;
     private final Semaphore freeChannels;
     private final ChannelGroup openChannels;
     private final boolean maxConnectionsPerHostEnabled;
-    private final ConcurrentHashMapV8<Object, Semaphore> freeChannelsPerHost;
-    private final ConcurrentHashMapV8<Channel, Object> channelId2PartitionKey;
-    private final ConcurrentHashMapV8.Fun<Object, Semaphore> semaphoreComputer;
+    private final ConcurrentHashMap<Object, Semaphore> freeChannelsPerHost = new ConcurrentHashMap<>();
+    private final ConcurrentHashMap<Channel, Object> channelId2PartitionKey = new ConcurrentHashMap<>();
 
     private AsyncHttpClientHandler wsHandler;
 
@@ -123,9 +126,8 @@ public ChannelManager(final AsyncHttpClientConfig config, Timer nettyTimer) {
         }
         this.channelPool = channelPool;
 
-        tooManyConnections = buildStaticIOException("Too many connections " + config.getMaxConnections());
-        tooManyConnectionsPerHost = buildStaticIOException("Too many connections per host " + config.getMaxConnectionsPerHost());
-        poolAlreadyClosed = buildStaticIOException("Pool is already closed");
+        tooManyConnections = trimStackTrace(new TooManyConnectionsException(config.getMaxConnections()));
+        tooManyConnectionsPerHost = trimStackTrace(new TooManyConnectionsPerHostException(config.getMaxConnectionsPerHost()));
         maxTotalConnectionsEnabled = config.getMaxConnections() > 0;
         maxConnectionsPerHostEnabled = config.getMaxConnectionsPerHost() > 0;
 
@@ -155,26 +157,12 @@ public boolean remove(Object o) {
             freeChannels = null;
         }
 
-        if (maxConnectionsPerHostEnabled) {
-            freeChannelsPerHost = new ConcurrentHashMapV8<>();
-            channelId2PartitionKey = new ConcurrentHashMapV8<>();
-            semaphoreComputer = new ConcurrentHashMapV8.Fun<Object, Semaphore>() {
-                @Override
-                public Semaphore apply(Object partitionKey) {
-                    return new Semaphore(config.getMaxConnectionsPerHost());
-                }
-            };
-        } else {
-            freeChannelsPerHost = null;
-            channelId2PartitionKey = null;
-            semaphoreComputer = null;
-        }
-
         handshakeTimeout = config.getHandshakeTimeout();
 
         // check if external EventLoopGroup is defined
         ThreadFactory threadFactory = config.getThreadFactory() != null ? config.getThreadFactory() : new DefaultThreadFactory(config.getThreadPoolName());
         allowReleaseEventLoopGroup = config.getEventLoopGroup() == null;
+        Class<? extends Channel> socketChannelClass;
         if (allowReleaseEventLoopGroup) {
             if (config.isUseNativeTransport()) {
                 eventLoopGroup = newEpollEventLoopGroup(threadFactory);
@@ -197,23 +185,43 @@ public Semaphore apply(Object partitionKey) {
             }
         }
 
-        httpBootstrap = new Bootstrap().channel(socketChannelClass).group(eventLoopGroup);
-        wsBootstrap = new Bootstrap().channel(socketChannelClass).group(eventLoopGroup);
+        httpBootstrap = newBootstrap(socketChannelClass, eventLoopGroup, config);
+        wsBootstrap = newBootstrap(socketChannelClass, eventLoopGroup, config);
 
-        // default to PooledByteBufAllocator
-        httpBootstrap.option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);
-        wsBootstrap.option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);
+        // for reactive streams
+        httpBootstrap.option(ChannelOption.AUTO_READ, false);
+    }
+
+    private Bootstrap newBootstrap(Class<? extends Channel> socketChannelClass, EventLoopGroup eventLoopGroup, AsyncHttpClientConfig config) {
+        @SuppressWarnings("deprecation")
+        Bootstrap bootstrap = new Bootstrap().channel(socketChannelClass).group(eventLoopGroup)//
+                // default to PooledByteBufAllocator
+                .option(ChannelOption.ALLOCATOR, config.isUsePooledMemory() ? PooledByteBufAllocator.DEFAULT : UnpooledByteBufAllocator.DEFAULT)//
+                .option(ChannelOption.TCP_NODELAY, config.isTcpNoDelay())//
+                .option(ChannelOption.SO_REUSEADDR, config.isSoReuseAddress())//
+                .option(ChannelOption.AUTO_CLOSE, false);
 
         if (config.getConnectTimeout() > 0) {
-            httpBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, config.getConnectTimeout());
-            wsBootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, config.getConnectTimeout());
+            bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, config.getConnectTimeout());
+        }
+
+        if (config.getSoLinger() >= 0) {
+            bootstrap.option(ChannelOption.SO_LINGER, config.getSoLinger());
+        }
+
+        if (config.getSoSndBuf() >= 0) {
+            bootstrap.option(ChannelOption.SO_SNDBUF, config.getSoSndBuf());
         }
+
+        if (config.getSoRcvBuf() >= 0) {
+            bootstrap.option(ChannelOption.SO_RCVBUF, config.getSoRcvBuf());
+        }
+
         for (Entry<ChannelOption<Object>, Object> entry : config.getChannelOptions().entrySet()) {
-            ChannelOption<Object> key = entry.getKey();
-            Object value = entry.getValue();
-            httpBootstrap.option(key, value);
-            wsBootstrap.option(key, value);
+            bootstrap.option(entry.getKey(), entry.getValue());
         }
+
+        return bootstrap;
     }
 
     private EventLoopGroup newEpollEventLoopGroup(ThreadFactory threadFactory) {
@@ -236,25 +244,26 @@ private EventLoopGroup newEpollEventLoopGroup(ThreadFactory threadFactory) {
 
     public void configureBootstraps(NettyRequestSender requestSender) {
 
-        HttpProtocol httpProtocol = new HttpProtocol(this, config, requestSender);
-        final AsyncHttpClientHandler httpHandler = new AsyncHttpClientHandler(config, this, requestSender, httpProtocol);
-
-        WebSocketProtocol wsProtocol = new WebSocketProtocol(this, config, requestSender);
-        wsHandler = new AsyncHttpClientHandler(config, this, requestSender, wsProtocol);
+        final AsyncHttpClientHandler httpHandler = new HttpHandler(config, this, requestSender);
+        wsHandler = new WebSocketHandler(config, this, requestSender);
 
         final NoopHandler pinnedEntry = new NoopHandler();
 
+        final LoggingHandler loggingHandler = new LoggingHandler();
+
         httpBootstrap.handler(new ChannelInitializer<Channel>() {
             @Override
             protected void initChannel(Channel ch) throws Exception {
-                ch.pipeline()//
+                ChannelPipeline pipeline = ch.pipeline()//
                         .addLast(PINNED_ENTRY, pinnedEntry)//
                         .addLast(HTTP_CLIENT_CODEC, newHttpClientCodec())//
                         .addLast(INFLATER_HANDLER, newHttpContentDecompressor())//
                         .addLast(CHUNKED_WRITER_HANDLER, new ChunkedWriteHandler())//
                         .addLast(AHC_HTTP_HANDLER, httpHandler);
 
-                ch.config().setOption(ChannelOption.AUTO_READ, false);
+                if (LOGGER.isDebugEnabled()) {
+                    pipeline.addAfter(PINNED_ENTRY, LOGGING_HANDLER, loggingHandler);
+                }
 
                 if (config.getHttpAdditionalChannelInitializer() != null)
                     config.getHttpAdditionalChannelInitializer().initChannel(ch);
@@ -264,11 +273,15 @@ protected void initChannel(Channel ch) throws Exception {
         wsBootstrap.handler(new ChannelInitializer<Channel>() {
             @Override
             protected void initChannel(Channel ch) throws Exception {
-                ch.pipeline()//
+                ChannelPipeline pipeline = ch.pipeline()//
                         .addLast(PINNED_ENTRY, pinnedEntry)//
                         .addLast(HTTP_CLIENT_CODEC, newHttpClientCodec())//
                         .addLast(AHC_WS_HANDLER, wsHandler);
 
+                if (LOGGER.isDebugEnabled()) {
+                    pipeline.addAfter(PINNED_ENTRY, LOGGING_HANDLER, loggingHandler);
+                }
+
                 if (config.getWsAdditionalChannelInitializer() != null)
                     config.getWsAdditionalChannelInitializer().initChannel(ch);
             }
@@ -287,13 +300,12 @@ protected String getTargetContentEncoding(String contentEncoding) throws Excepti
             return new HttpContentDecompressor();
     }
 
-    public final void tryToOfferChannelToPool(Channel channel, AsyncHandler<?> handler, boolean keepAlive, Object partitionKey) {
+    public final void tryToOfferChannelToPool(Channel channel, AsyncHandler<?> asyncHandler, boolean keepAlive, Object partitionKey) {
         if (channel.isActive() && keepAlive) {
             LOGGER.debug("Adding key: {} for channel {}", partitionKey, channel);
             Channels.setDiscard(channel);
-            if (handler instanceof AsyncHandlerExtensions) {
-                AsyncHandlerExtensions.class.cast(handler).onConnectionOffer(channel);
-            }
+            if (asyncHandler instanceof AsyncHandlerExtensions)
+                AsyncHandlerExtensions.class.cast(asyncHandler).onConnectionOffer(channel);
             channelPool.offer(channel, partitionKey);
             if (maxConnectionsPerHostEnabled)
                 channelId2PartitionKey.putIfAbsent(channel, partitionKey);
@@ -303,7 +315,7 @@ public final void tryToOfferChannelToPool(Channel channel, AsyncHandler<?> handl
         }
     }
 
-    public Channel poll(Uri uri, String virtualHost, ProxyServer proxy, ConnectionPoolPartitioning connectionPoolPartitioning) {
+    public Channel poll(Uri uri, String virtualHost, ProxyServer proxy, ChannelPoolPartitioning connectionPoolPartitioning) {
         Object partitionKey = connectionPoolPartitioning.getPartitionKey(uri, virtualHost, proxy);
         return channelPool.poll(partitionKey);
     }
@@ -317,7 +329,7 @@ private boolean tryAcquireGlobal() {
     }
 
     private Semaphore getFreeConnectionsForHost(Object partitionKey) {
-        return freeChannelsPerHost.computeIfAbsent(partitionKey, semaphoreComputer);
+        return freeChannelsPerHost.computeIfAbsent(partitionKey, pk -> new Semaphore(config.getMaxConnectionsPerHost()));
     }
 
     private boolean tryAcquirePerHost(Object partitionKey) {
@@ -326,7 +338,7 @@ private boolean tryAcquirePerHost(Object partitionKey) {
 
     public void preemptChannel(Object partitionKey) throws IOException {
         if (!channelPool.isOpen())
-            throw poolAlreadyClosed;
+            throw PoolAlreadyClosedException.INSTANCE;
         if (!tryAcquireGlobal())
             throw tooManyConnections;
         if (!tryAcquirePerHost(partitionKey)) {
@@ -353,14 +365,13 @@ private void doClose() {
     @SuppressWarnings({ "unchecked", "rawtypes" })
     public void close() {
         if (allowReleaseEventLoopGroup) {
-            io.netty.util.concurrent.Future whenEventLoopGroupClosed = eventLoopGroup.shutdownGracefully(config.getShutdownQuietPeriod(), config.getShutdownTimeout(),
-                    TimeUnit.MILLISECONDS);
-
-            whenEventLoopGroupClosed.addListener((GenericFutureListener<?>) new GenericFutureListener<io.netty.util.concurrent.Future<?>>() {
-                public void operationComplete(io.netty.util.concurrent.Future<?> future) throws Exception {
-                    doClose();
-                };
-            });
+            eventLoopGroup.shutdownGracefully(config.getShutdownQuietPeriod(), config.getShutdownTimeout(), TimeUnit.MILLISECONDS)//
+                    .addListener(new FutureListener() {
+                        @Override
+                        public void operationComplete(Future future) throws Exception {
+                            doClose();
+                        }
+                    });
         } else
             doClose();
     }
@@ -368,8 +379,8 @@ public void operationComplete(io.netty.util.concurrent.Future<?> future) throws
     public void closeChannel(Channel channel) {
 
         LOGGER.debug("Closing Channel {} ", channel);
-        removeAll(channel);
         Channels.setDiscard(channel);
+        removeAll(channel);
         Channels.silentlyCloseChannel(channel);
         openChannels.remove(channel);
     }
@@ -393,7 +404,8 @@ private HttpClientCodec newHttpClientCodec() {
                 config.getHttpClientCodecMaxInitialLineLength(),//
                 config.getHttpClientCodecMaxHeaderSize(),//
                 config.getHttpClientCodecMaxChunkSize(),//
-                false);
+                false,//
+                config.isValidateResponseHeaders());
     }
 
     private SslHandler createSslHandler(String peerHost, int peerPort) {
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/pool/DefaultChannelPool.java b/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java
similarity index 87%
rename from client/src/main/java/org/asynchttpclient/netty/channel/pool/DefaultChannelPool.java
rename to client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java
index d627cf079..677f10c01 100755
--- a/client/src/main/java/org/asynchttpclient/netty/channel/pool/DefaultChannelPool.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/DefaultChannelPool.java
@@ -11,7 +11,7 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.netty.channel.pool;
+package org.asynchttpclient.netty.channel;
 
 import static org.asynchttpclient.util.Assertions.*;
 import static org.asynchttpclient.util.DateUtils.millisTime;
@@ -30,8 +30,9 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.channel.ChannelPool;
+import org.asynchttpclient.channel.ChannelPoolPartitionSelector;
 import org.asynchttpclient.netty.NettyResponseFuture;
-import org.asynchttpclient.netty.channel.Channels;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -166,21 +167,20 @@ private boolean isChannelCloseable(Channel channel) {
             List<IdleChannel> closedChannels = null;
             for (int i = 0; i < candidates.size(); i++) {
                 IdleChannel idleChannel = candidates.get(i);
-                if (!isChannelCloseable(idleChannel.channel))
-                    if (isChannelCloseable(idleChannel.channel)) {
-                        LOGGER.debug("Closing Idle Channel {}", idleChannel.channel);
-                        close(idleChannel.channel);
-                        if (closedChannels != null) {
-                            closedChannels.add(idleChannel);
-                        }
-
-                    } else if (closedChannels == null) {
-                        // first non closeable to be skipped, copy all
-                        // previously skipped closeable channels
-                        closedChannels = new ArrayList<>(candidates.size());
-                        for (int j = 0; j < i; j++)
-                            closedChannels.add(candidates.get(j));
+                if (isChannelCloseable(idleChannel.channel)) {
+                    LOGGER.debug("Closing Idle Channel {}", idleChannel.channel);
+                    close(idleChannel.channel);
+                    if (closedChannels != null) {
+                        closedChannels.add(idleChannel);
                     }
+
+                } else if (closedChannels == null) {
+                    // first non closeable to be skipped, copy all
+                    // previously skipped closeable channels
+                    closedChannels = new ArrayList<>(candidates.size());
+                    for (int j = 0; j < i; j++)
+                        closedChannels.add(candidates.get(j));
+                }
             }
 
             return closedChannels != null ? closedChannels : candidates;
@@ -243,13 +243,28 @@ public boolean offer(Channel channel, Object partitionKey) {
         if (isTtlExpired(channel, now))
             return false;
 
-        boolean added = partitions.computeIfAbsent(partitionKey, pk -> new ConcurrentLinkedQueue<>()).add(new IdleChannel(channel, now));
-        if (added)
-            channelId2Creation.putIfAbsent(channelId(channel), new ChannelCreation(now, partitionKey));
+        boolean offered = offer0(channel, partitionKey,now);
+        if (offered) {
+            registerChannelCreation(channel, partitionKey, now);
+        }
 
-        return added;
+        return offered;
     }
-
+    
+    private boolean offer0(Channel channel, Object partitionKey, long now) {
+        ConcurrentLinkedQueue<IdleChannel> partition = partitions.get(partitionKey);
+        if (partition == null) {
+            partition = partitions.computeIfAbsent(partitionKey, pk -> new ConcurrentLinkedQueue<>());
+        }
+        return partition.add(new IdleChannel(channel, now));
+    }
+    
+    private void registerChannelCreation(Channel channel, Object partitionKey, long now) {
+        if (channelId2Creation.containsKey(partitionKey)) {
+            channelId2Creation.putIfAbsent(channelId(channel), new ChannelCreation(now, partitionKey));
+        }
+    }
+    
     /**
      * {@inheritDoc}
      */
diff --git a/client/src/main/java/org/asynchttpclient/netty/channel/NettyConnectListener.java b/client/src/main/java/org/asynchttpclient/netty/channel/NettyConnectListener.java
index 2274d10df..ab0e4c953 100755
--- a/client/src/main/java/org/asynchttpclient/netty/channel/NettyConnectListener.java
+++ b/client/src/main/java/org/asynchttpclient/netty/channel/NettyConnectListener.java
@@ -13,20 +13,18 @@
  */
 package org.asynchttpclient.netty.channel;
 
+import static org.asynchttpclient.handler.AsyncHandlerExtensionsUtils.toAsyncHandlerExtensions;
 import static org.asynchttpclient.util.HttpUtils.getBaseUrl;
 import io.netty.channel.Channel;
-import io.netty.channel.ChannelFuture;
-import io.netty.channel.ChannelFutureListener;
 import io.netty.handler.ssl.SslHandler;
-import io.netty.util.concurrent.Future;
-import io.netty.util.concurrent.GenericFutureListener;
 
 import java.net.ConnectException;
 
-import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.Request;
 import org.asynchttpclient.handler.AsyncHandlerExtensions;
 import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.SimpleChannelFutureListener;
+import org.asynchttpclient.netty.SimpleFutureListener;
 import org.asynchttpclient.netty.future.StackTraceInspector;
 import org.asynchttpclient.netty.request.NettyRequestSender;
 import org.asynchttpclient.uri.Uri;
@@ -36,7 +34,7 @@
 /**
  * Non Blocking connect.
  */
-public final class NettyConnectListener<T> implements ChannelFutureListener {
+public final class NettyConnectListener<T> extends SimpleChannelFutureListener {
 
     private final static Logger LOGGER = LoggerFactory.getLogger(NettyConnectListener.class);
 
@@ -65,13 +63,10 @@ private void abortChannelPreemption() {
 
     private void writeRequest(Channel channel) {
 
-        LOGGER.debug("Using non-cached Channel {} for {} '{}'",
-                channel,
-                future.getNettyRequest().getHttpRequest().getMethod(),
-                future.getNettyRequest().getHttpRequest().getUri());
+        LOGGER.debug("Using non-cached Channel {} for {} '{}'", channel, future.getNettyRequest().getHttpRequest().getMethod(), future.getNettyRequest().getHttpRequest().getUri());
 
         Channels.setAttribute(channel, future);
-        
+
         if (future.isDone()) {
             abortChannelPreemption();
             return;
@@ -82,37 +77,46 @@ private void writeRequest(Channel channel) {
         requestSender.writeRequest(future, channel);
     }
 
-    private void onFutureSuccess(final Channel channel) throws Exception {
-        
+    @Override
+    public void onSuccess(Channel channel) {
+
         Request request = future.getTargetRequest();
         Uri uri = request.getUri();
 
         // in case of proxy tunneling, we'll add the SslHandler later, after the CONNECT request
         if (future.getProxyServer() == null && uri.isSecured()) {
             SslHandler sslHandler = channelManager.addSslHandler(channel.pipeline(), uri, request.getVirtualHost());
-            sslHandler.handshakeFuture().addListener(new GenericFutureListener<Future<Channel>>() {
+
+            final AsyncHandlerExtensions asyncHandlerExtensions = toAsyncHandlerExtensions(future.getAsyncHandler());
+
+            if (asyncHandlerExtensions != null)
+                asyncHandlerExtensions.onTlsHandshakeAttempt();
+
+            sslHandler.handshakeFuture().addListener(new SimpleFutureListener<Channel>() {
+
                 @Override
-                public void operationComplete(Future<Channel> handshakeFuture) throws Exception {
-                 
-                    if (handshakeFuture.isSuccess()) {
-                        final AsyncHandler<T> asyncHandler = future.getAsyncHandler();
-                        if (asyncHandler instanceof AsyncHandlerExtensions)
-                            AsyncHandlerExtensions.class.cast(asyncHandler).onSslHandshakeCompleted();
-
-                        writeRequest(channel);
-                    } else {
-                        onFutureFailure(channel, handshakeFuture.cause());
-                    }
+                protected void onSuccess(Channel value) throws Exception {
+                    if (asyncHandlerExtensions != null)
+                        asyncHandlerExtensions.onTlsHandshakeSuccess();
+                    writeRequest(channel);
+                }
+
+                @Override
+                protected void onFailure(Throwable cause) throws Exception {
+                    if (asyncHandlerExtensions != null)
+                        asyncHandlerExtensions.onTlsHandshakeFailure(cause);
+                    NettyConnectListener.this.onFailure(channel, cause);
                 }
             });
-        
+
         } else {
             writeRequest(channel);
         }
     }
 
-    private void onFutureFailure(Channel channel, Throwable cause) {
-
+    @Override
+    public void onFailure(Channel channel, Throwable cause) {
+        //beware, channel can be null
         abortChannelPreemption();
 
         boolean canRetry = future.canRetry();
@@ -135,11 +139,4 @@ private void onFutureFailure(Channel channel, Throwable cause) {
             e.initCause(cause);
         future.abort(e);
     }
-
-    public final void operationComplete(ChannelFuture f) throws Exception {
-        if (f.isSuccess())
-            onFutureSuccess(f.channel());
-        else
-            onFutureFailure(f.channel(), f.cause());
-    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/AsyncHttpClientHandler.java b/client/src/main/java/org/asynchttpclient/netty/handler/AsyncHttpClientHandler.java
index 4381df565..ca00f7a4e 100755
--- a/client/src/main/java/org/asynchttpclient/netty/handler/AsyncHttpClientHandler.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/AsyncHttpClientHandler.java
@@ -13,10 +13,9 @@
  */
 package org.asynchttpclient.netty.handler;
 
-import static org.asynchttpclient.util.HttpUtils.CHANNEL_CLOSED_EXCEPTION;
+import static org.asynchttpclient.util.MiscUtils.getCause;
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.Channel;
-import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.handler.codec.PrematureChannelClosureException;
@@ -28,35 +27,37 @@
 import java.nio.channels.ClosedChannelException;
 
 import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.exception.ChannelClosedException;
 import org.asynchttpclient.netty.Callback;
 import org.asynchttpclient.netty.DiscardEvent;
-import org.asynchttpclient.netty.NettyResponseBodyPart;
 import org.asynchttpclient.netty.NettyResponseFuture;
 import org.asynchttpclient.netty.channel.ChannelManager;
 import org.asynchttpclient.netty.channel.Channels;
 import org.asynchttpclient.netty.future.StackTraceInspector;
+import org.asynchttpclient.netty.handler.intercept.Interceptors;
 import org.asynchttpclient.netty.request.NettyRequestSender;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-@Sharable
-public class AsyncHttpClientHandler extends ChannelInboundHandlerAdapter {
+public abstract class AsyncHttpClientHandler extends ChannelInboundHandlerAdapter {
 
-    private static final Logger LOGGER = LoggerFactory.getLogger(AsyncHttpClientHandler.class);
+    protected final Logger logger = LoggerFactory.getLogger(getClass());
 
-    private final AsyncHttpClientConfig config;
-    private final ChannelManager channelManager;
-    private final NettyRequestSender requestSender;
-    private final Protocol protocol;
+    protected final AsyncHttpClientConfig config;
+    protected final ChannelManager channelManager;
+    protected final NettyRequestSender requestSender;
+    protected final Interceptors interceptors;
+    protected final boolean hasIOExceptionFilters;
 
     public AsyncHttpClientHandler(AsyncHttpClientConfig config,//
             ChannelManager channelManager,//
-            NettyRequestSender requestSender,//
-            Protocol protocol) {
+            NettyRequestSender requestSender) {
         this.config = config;
         this.channelManager = channelManager;
         this.requestSender = requestSender;
-        this.protocol = protocol;
+        interceptors = new Interceptors(config, channelManager, requestSender);
+        hasIOExceptionFilters = !config.getIoExceptionFilters().isEmpty();
     }
 
     @Override
@@ -71,24 +72,24 @@ public void channelRead(final ChannelHandlerContext ctx, Object msg) throws Exce
                 if (msg instanceof LastHttpContent) {
                     ac.call();
                 } else if (!(msg instanceof HttpContent)) {
-                    LOGGER.info("Received unexpected message while expecting a chunk: " + msg);
+                    logger.info("Received unexpected message while expecting a chunk: " + msg);
                     ac.call();
                     Channels.setDiscard(channel);
                 }
 
             } else if (attribute instanceof NettyResponseFuture) {
                 NettyResponseFuture<?> future = (NettyResponseFuture<?>) attribute;
-                protocol.handle(channel, future, msg);
+                handleRead(channel, future, msg);
 
             } else if (attribute instanceof StreamedResponsePublisher) {
 
                 StreamedResponsePublisher publisher = (StreamedResponsePublisher) attribute;
 
-                if(msg instanceof HttpContent) {
+                if (msg instanceof HttpContent) {
                     ByteBuf content = ((HttpContent) msg).content();
                     // Republish as a HttpResponseBodyPart
                     if (content.readableBytes() > 0) {
-                        NettyResponseBodyPart part = config.getResponseBodyPartFactory().newResponseBodyPart(content, false);
+                        HttpResponseBodyPart part = config.getResponseBodyPartFactory().newResponseBodyPart(content, false);
                         ctx.fireChannelRead(part);
                     }
                     if (msg instanceof LastHttpContent) {
@@ -100,16 +101,16 @@ public void channelRead(final ChannelHandlerContext ctx, Object msg) throws Exce
                         ctx.read();
                         // Send the last content on to the protocol, so that it can
                         // conclude the cleanup
-                        protocol.handle(channel, publisher.future(), msg);
+                        handleRead(channel, publisher.future(), msg);
                     }
                 } else {
-                    LOGGER.info("Received unexpected message while expecting a chunk: " + msg);
-                    ctx.pipeline().remove((StreamedResponsePublisher) attribute);
+                    logger.info("Received unexpected message while expecting a chunk: " + msg);
+                    ctx.pipeline().remove(publisher);
                     Channels.setDiscard(channel);
                 }
             } else if (attribute != DiscardEvent.INSTANCE) {
                 // unhandled message
-                LOGGER.debug("Orphan channel {} with attribute {} received message {}, closing", channel, attribute, msg);
+                logger.debug("Orphan channel {} with attribute {} received message {}, closing", channel, attribute, msg);
                 Channels.silentlyCloseChannel(channel);
             }
         } finally {
@@ -128,11 +129,11 @@ public void channelInactive(ChannelHandlerContext ctx) throws Exception {
         try {
             super.channelInactive(ctx);
         } catch (Exception ex) {
-            LOGGER.trace("super.channelClosed", ex);
+            logger.trace("super.channelClosed", ex);
         }
 
         Object attribute = Channels.getAttribute(channel);
-        LOGGER.debug("Channel Closed: {} with attribute {}", channel, attribute);
+        logger.debug("Channel Closed: {} with attribute {}", channel, attribute);
         if (attribute instanceof StreamedResponsePublisher) {
             // setting `attribute` to be the underlying future so that the retry
             // logic can kick-in
@@ -147,17 +148,17 @@ public void channelInactive(ChannelHandlerContext ctx) throws Exception {
             NettyResponseFuture<?> future = NettyResponseFuture.class.cast(attribute);
             future.touch();
 
-            if (!config.getIoExceptionFilters().isEmpty() && requestSender.applyIoExceptionFiltersAndReplayRequest(future, CHANNEL_CLOSED_EXCEPTION, channel))
+            if (hasIOExceptionFilters && requestSender.applyIoExceptionFiltersAndReplayRequest(future, ChannelClosedException.INSTANCE, channel))
                 return;
 
-            protocol.onClose(future);
+            handleChannelInactive(future);
             requestSender.handleUnexpectedClosedChannel(channel, future);
         }
     }
 
     @Override
     public void exceptionCaught(ChannelHandlerContext ctx, Throwable e) throws Exception {
-        Throwable cause = e.getCause() != null ? e.getCause() : e;
+        Throwable cause = getCause(e);
 
         if (cause instanceof PrematureChannelClosureException || cause instanceof ClosedChannelException)
             return;
@@ -165,7 +166,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable e) throws Excep
         Channel channel = ctx.channel();
         NettyResponseFuture<?> future = null;
 
-        LOGGER.debug("Unexpected I/O exception on channel {}", channel, cause);
+        logger.debug("Unexpected I/O exception on channel {}", channel, cause);
 
         try {
             Object attribute = Channels.getAttribute(channel);
@@ -182,18 +183,19 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable e) throws Excep
 
                 if (cause instanceof IOException) {
 
-                    // FIXME why drop the original exception and throw a new
-                    // one?
-                    if (!config.getIoExceptionFilters().isEmpty()) {
-                        if (!requestSender.applyIoExceptionFiltersAndReplayRequest(future, CHANNEL_CLOSED_EXCEPTION, channel))
+                    // FIXME why drop the original exception and throw a new one?
+                    if (hasIOExceptionFilters) {
+                        if (!requestSender.applyIoExceptionFiltersAndReplayRequest(future, ChannelClosedException.INSTANCE, channel)) {
                             // Close the channel so the recovering can occurs.
                             Channels.silentlyCloseChannel(channel);
+                        }
                         return;
                     }
                 }
 
                 if (StackTraceInspector.recoverOnReadOrWriteException(cause)) {
-                    LOGGER.debug("Trying to recover from dead Channel: {}", channel);
+                    logger.debug("Trying to recover from dead Channel: {}", channel);
+                    future.pendingException = cause;
                     return;
                 }
             } else if (attribute instanceof Callback) {
@@ -205,11 +207,11 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable e) throws Excep
 
         if (future != null)
             try {
-                LOGGER.debug("Was unable to recover Future: {}", future);
+                logger.debug("Was unable to recover Future: {}", future);
                 requestSender.abort(channel, future, cause);
-                protocol.onError(future, e);
+                handleException(future, e);
             } catch (Throwable t) {
-                LOGGER.error(t.getMessage(), t);
+                logger.error(t.getMessage(), t);
             }
 
         channelManager.closeChannel(channel);
@@ -235,4 +237,10 @@ public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
     private boolean isHandledByReactiveStreams(ChannelHandlerContext ctx) {
         return Channels.getAttribute(ctx.channel()) instanceof StreamedResponsePublisher;
     }
+
+    public abstract void handleRead(Channel channel, NettyResponseFuture<?> future, Object message) throws Exception;
+
+    public abstract void handleException(NettyResponseFuture<?> future, Throwable error);
+
+    public abstract void handleChannelInactive(NettyResponseFuture<?> future);
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/HttpHandler.java b/client/src/main/java/org/asynchttpclient/netty/handler/HttpHandler.java
new file mode 100755
index 000000000..1cfe1ca79
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/HttpHandler.java
@@ -0,0 +1,222 @@
+/*
+ * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.handler;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelHandler.Sharable;
+import io.netty.handler.codec.http.HttpContent;
+import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.HttpObject;
+import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.codec.http.HttpResponse;
+import io.netty.handler.codec.http.LastHttpContent;
+
+import java.io.IOException;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHandler.State;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.handler.StreamedAsyncHandler;
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.NettyResponseStatus;
+import org.asynchttpclient.netty.channel.ChannelManager;
+import org.asynchttpclient.netty.channel.Channels;
+import org.asynchttpclient.netty.request.NettyRequestSender;
+
+@Sharable
+public final class HttpHandler extends AsyncHttpClientHandler {
+
+    public HttpHandler(AsyncHttpClientConfig config, ChannelManager channelManager, NettyRequestSender requestSender) {
+        super(config, channelManager, requestSender);
+    }
+
+    private void finishUpdate(final NettyResponseFuture<?> future, Channel channel, boolean expectOtherChunks) throws IOException {
+
+        future.cancelTimeouts();
+
+        boolean keepAlive = future.isKeepAlive();
+        if (expectOtherChunks && keepAlive)
+            channelManager.drainChannelAndOffer(channel, future);
+        else
+            channelManager.tryToOfferChannelToPool(channel, future.getAsyncHandler(), keepAlive, future.getPartitionKey());
+
+        try {
+            future.done();
+        } catch (Exception t) {
+            // Never propagate exception once we know we are done.
+            logger.debug(t.getMessage(), t);
+        }
+    }
+
+    private boolean updateBodyAndInterrupt(NettyResponseFuture<?> future, AsyncHandler<?> handler, HttpResponseBodyPart bodyPart) throws Exception {
+        boolean interrupt = handler.onBodyPartReceived(bodyPart) != State.CONTINUE;
+        if (interrupt)
+            future.setKeepAlive(false);
+        return interrupt;
+    }
+
+    private void notifyHandler(Channel channel, NettyResponseFuture<?> future, HttpResponse response, AsyncHandler<?> handler, NettyResponseStatus status,
+            HttpRequest httpRequest, HttpResponseHeaders responseHeaders) throws IOException, Exception {
+
+        boolean exit = exitAfterHandlingStatus(channel, future, response, handler, status, httpRequest) || //
+                exitAfterHandlingHeaders(channel, future, response, handler, responseHeaders, httpRequest) || //
+                exitAfterHandlingReactiveStreams(channel, future, response, handler, httpRequest);
+
+        if (exit)
+            finishUpdate(future, channel, HttpHeaders.isTransferEncodingChunked(httpRequest) || HttpHeaders.isTransferEncodingChunked(response));
+    }
+
+    private boolean exitAfterHandlingStatus(//
+            Channel channel,//
+            NettyResponseFuture<?> future,//
+            HttpResponse response, AsyncHandler<?> handler,//
+            NettyResponseStatus status,//
+            HttpRequest httpRequest) throws IOException, Exception {
+        return !future.getAndSetStatusReceived(true) && handler.onStatusReceived(status) != State.CONTINUE;
+    }
+
+    private boolean exitAfterHandlingHeaders(//
+            Channel channel,//
+            NettyResponseFuture<?> future,//
+            HttpResponse response,//
+            AsyncHandler<?> handler,//
+            HttpResponseHeaders responseHeaders,//
+            HttpRequest httpRequest) throws IOException, Exception {
+        return !response.headers().isEmpty() && handler.onHeadersReceived(responseHeaders) != State.CONTINUE;
+    }
+
+    private boolean exitAfterHandlingReactiveStreams(//
+            Channel channel,//
+            NettyResponseFuture<?> future,//
+            HttpResponse response,//
+            AsyncHandler<?> handler,//
+            HttpRequest httpRequest) throws IOException {
+        if (handler instanceof StreamedAsyncHandler) {
+            StreamedAsyncHandler<?> streamedAsyncHandler = (StreamedAsyncHandler<?>) handler;
+            StreamedResponsePublisher publisher = new StreamedResponsePublisher(channel.eventLoop(), channelManager, future, channel);
+            // FIXME do we really need to pass the event loop?
+            // FIXME move this to ChannelManager
+            channel.pipeline().addLast(channel.eventLoop(), "streamedAsyncHandler", publisher);
+            Channels.setAttribute(channel, publisher);
+            return streamedAsyncHandler.onStream(publisher) != State.CONTINUE;
+        }
+        return false;
+    }
+
+    private void handleHttpResponse(final HttpResponse response, final Channel channel, final NettyResponseFuture<?> future, AsyncHandler<?> handler) throws Exception {
+
+        HttpRequest httpRequest = future.getNettyRequest().getHttpRequest();
+        logger.debug("\n\nRequest {}\n\nResponse {}\n", httpRequest, response);
+
+        future.setKeepAlive(config.getKeepAliveStrategy().keepAlive(future.getTargetRequest(), httpRequest, response));
+
+        NettyResponseStatus status = new NettyResponseStatus(future.getUri(), config, response, channel);
+        HttpResponseHeaders responseHeaders = new HttpResponseHeaders(response.headers());
+
+        if (!interceptors.exitAfterIntercept(channel, future, handler, response, status, responseHeaders)) {
+            notifyHandler(channel, future, response, handler, status, httpRequest, responseHeaders);
+        }
+    }
+
+    private void handleChunk(HttpContent chunk,//
+            final Channel channel,//
+            final NettyResponseFuture<?> future,//
+            AsyncHandler<?> handler) throws IOException, Exception {
+
+        boolean interrupt = false;
+        boolean last = chunk instanceof LastHttpContent;
+
+        // Netty 4: the last chunk is not empty
+        if (last) {
+            LastHttpContent lastChunk = (LastHttpContent) chunk;
+            HttpHeaders trailingHeaders = lastChunk.trailingHeaders();
+            if (!trailingHeaders.isEmpty()) {
+                interrupt = handler.onHeadersReceived(new HttpResponseHeaders(trailingHeaders, true)) != State.CONTINUE;
+            }
+        }
+
+        ByteBuf buf = chunk.content();
+        if (!interrupt && !(handler instanceof StreamedAsyncHandler) && (buf.readableBytes() > 0 || last)) {
+            HttpResponseBodyPart part = config.getResponseBodyPartFactory().newResponseBodyPart(buf, last);
+            interrupt = updateBodyAndInterrupt(future, handler, part);
+        }
+
+        if (interrupt || last)
+            finishUpdate(future, channel, !last);
+    }
+
+    @Override
+    public void handleRead(final Channel channel, final NettyResponseFuture<?> future, final Object e) throws Exception {
+
+        future.touch();
+
+        // future is already done because of an exception or a timeout
+        if (future.isDone()) {
+            // FIXME isn't the channel already properly closed?
+            channelManager.closeChannel(channel);
+            return;
+        }
+
+        AsyncHandler<?> handler = future.getAsyncHandler();
+        try {
+            if (e instanceof HttpObject) {
+                HttpObject object = (HttpObject) e;
+                Throwable t = object.getDecoderResult().cause();
+                if (t != null) {
+                    readFailed(channel, future, t);
+                    return;
+                }
+            }
+            
+            if (e instanceof HttpResponse) {
+                handleHttpResponse((HttpResponse) e, channel, future, handler);
+
+            } else if (e instanceof HttpContent) {
+                handleChunk((HttpContent) e, channel, future, handler);
+            }
+        } catch (Exception t) {
+            // e.g. an IOException when trying to open a connection and send the
+            // next request
+            if (hasIOExceptionFilters//
+                    && t instanceof IOException//
+                    && requestSender.applyIoExceptionFiltersAndReplayRequest(future, IOException.class.cast(t), channel)) {
+                return;
+            }
+
+            readFailed(channel, future, t);
+            throw t;
+        }
+    }
+    
+    private void readFailed(Channel channel, NettyResponseFuture<?> future, Throwable t) throws Exception {
+        try {
+            requestSender.abort(channel, future, t);
+        } catch (Exception abortException) {
+            logger.debug("Abort failed", abortException);
+        } finally {
+            finishUpdate(future, channel, false);
+        }
+    }
+
+    @Override
+    public void handleException(NettyResponseFuture<?> future, Throwable error) {
+    }
+
+    @Override
+    public void handleChannelInactive(NettyResponseFuture<?> future) {
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/HttpProtocol.java b/client/src/main/java/org/asynchttpclient/netty/handler/HttpProtocol.java
deleted file mode 100755
index e3751df3b..000000000
--- a/client/src/main/java/org/asynchttpclient/netty/handler/HttpProtocol.java
+++ /dev/null
@@ -1,603 +0,0 @@
-/*
- * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at
- *     http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.netty.handler;
-
-import static io.netty.handler.codec.http.HttpResponseStatus.*;
-import static org.asynchttpclient.Dsl.realm;
-import static org.asynchttpclient.util.AuthenticatorUtils.getHeaderWithPrefix;
-import io.netty.buffer.ByteBuf;
-import io.netty.channel.Channel;
-import io.netty.handler.codec.http.DefaultHttpHeaders;
-import io.netty.handler.codec.http.HttpContent;
-import io.netty.handler.codec.http.HttpHeaders;
-import io.netty.handler.codec.http.HttpMethod;
-import io.netty.handler.codec.http.HttpRequest;
-import io.netty.handler.codec.http.HttpResponse;
-import io.netty.handler.codec.http.LastHttpContent;
-
-import java.io.IOException;
-import java.util.List;
-
-import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.AsyncHandler.State;
-import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.Realm;
-import org.asynchttpclient.Realm.AuthScheme;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.RequestBuilder;
-import org.asynchttpclient.handler.StreamedAsyncHandler;
-import org.asynchttpclient.netty.Callback;
-import org.asynchttpclient.netty.NettyResponseBodyPart;
-import org.asynchttpclient.netty.NettyResponseFuture;
-import org.asynchttpclient.netty.NettyResponseHeaders;
-import org.asynchttpclient.netty.NettyResponseStatus;
-import org.asynchttpclient.netty.channel.ChannelManager;
-import org.asynchttpclient.netty.channel.ChannelState;
-import org.asynchttpclient.netty.channel.Channels;
-import org.asynchttpclient.netty.request.NettyRequestSender;
-import org.asynchttpclient.ntlm.NtlmEngine;
-import org.asynchttpclient.proxy.ProxyServer;
-import org.asynchttpclient.spnego.SpnegoEngine;
-import org.asynchttpclient.spnego.SpnegoEngineException;
-import org.asynchttpclient.uri.Uri;
-
-public final class HttpProtocol extends Protocol {
-
-    public HttpProtocol(ChannelManager channelManager, AsyncHttpClientConfig config, NettyRequestSender requestSender) {
-        super(channelManager, config, requestSender);
-    }
-
-    private void kerberosChallenge(Channel channel,//
-            List<String> authHeaders,//
-            Request request,//
-            HttpHeaders headers,//
-            Realm realm,//
-            NettyResponseFuture<?> future) throws SpnegoEngineException {
-
-        Uri uri = request.getUri();
-        String host = request.getVirtualHost() == null ? uri.getHost() : request.getVirtualHost();
-        String challengeHeader = SpnegoEngine.instance().generateToken(host);
-        headers.set(HttpHeaders.Names.AUTHORIZATION, "Negotiate " + challengeHeader);
-    }
-
-    private void kerberosProxyChallenge(Channel channel,//
-            List<String> proxyAuth,//
-            Request request,//
-            ProxyServer proxyServer,//
-            Realm proxyRealm,//
-            HttpHeaders headers,//
-            NettyResponseFuture<?> future) throws SpnegoEngineException {
-
-        String challengeHeader = SpnegoEngine.instance().generateToken(proxyServer.getHost());
-        headers.set(HttpHeaders.Names.PROXY_AUTHORIZATION, "Negotiate " + challengeHeader);
-    }
-
-    private void ntlmChallenge(String authenticateHeader,//
-            Request request,//
-            HttpHeaders headers,//
-            Realm realm,//
-            NettyResponseFuture<?> future) {
-
-        if (authenticateHeader.equals("NTLM")) {
-            // server replied bare NTLM => we didn't preemptively sent Type1Msg
-            String challengeHeader = NtlmEngine.INSTANCE.generateType1Msg();
-            // FIXME we might want to filter current NTLM and add (leave other
-            // Authorization headers untouched)
-            headers.set(HttpHeaders.Names.AUTHORIZATION, "NTLM " + challengeHeader);
-            future.getInAuth().set(false);
-
-        } else {
-            String serverChallenge = authenticateHeader.substring("NTLM ".length()).trim();
-            String challengeHeader = NtlmEngine.INSTANCE.generateType3Msg(realm.getPrincipal(), realm.getPassword(), realm.getNtlmDomain(), realm.getNtlmHost(), serverChallenge);
-            // FIXME we might want to filter current NTLM and add (leave other
-            // Authorization headers untouched)
-            headers.set(HttpHeaders.Names.AUTHORIZATION, "NTLM " + challengeHeader);
-        }
-    }
-
-    private void ntlmProxyChallenge(String authenticateHeader,//
-            Request request,//
-            Realm proxyRealm,//
-            HttpHeaders headers,//
-            NettyResponseFuture<?> future) {
-
-        if (authenticateHeader.equals("NTLM")) {
-            // server replied bare NTLM => we didn't preemptively sent Type1Msg
-            String challengeHeader = NtlmEngine.INSTANCE.generateType1Msg();
-            // FIXME we might want to filter current NTLM and add (leave other
-            // Authorization headers untouched)
-            headers.set(HttpHeaders.Names.PROXY_AUTHORIZATION, "NTLM " + challengeHeader);
-            future.getInProxyAuth().set(false);
-
-        } else {
-            String serverChallenge = authenticateHeader.substring("NTLM ".length()).trim();
-            String challengeHeader = NtlmEngine.INSTANCE.generateType3Msg(proxyRealm.getPrincipal(), proxyRealm.getPassword(), proxyRealm.getNtlmDomain(),
-                    proxyRealm.getNtlmHost(), serverChallenge);
-            // FIXME we might want to filter current NTLM and add (leave other
-            // Authorization headers untouched)
-            headers.set(HttpHeaders.Names.PROXY_AUTHORIZATION, "NTLM " + challengeHeader);
-        }
-    }
-
-    private void finishUpdate(final NettyResponseFuture<?> future, Channel channel, boolean expectOtherChunks) throws IOException {
-
-        future.cancelTimeouts();
-
-        boolean keepAlive = future.isKeepAlive();
-        if (expectOtherChunks && keepAlive)
-            channelManager.drainChannelAndOffer(channel, future);
-        else
-            channelManager.tryToOfferChannelToPool(channel, future.getAsyncHandler(), keepAlive, future.getPartitionKey());
-
-        try {
-            future.done();
-        } catch (Exception t) {
-            // Never propagate exception once we know we are done.
-            logger.debug(t.getMessage(), t);
-        }
-    }
-
-    private boolean updateBodyAndInterrupt(NettyResponseFuture<?> future, AsyncHandler<?> handler, NettyResponseBodyPart bodyPart) throws Exception {
-        boolean interrupt = handler.onBodyPartReceived(bodyPart) != State.CONTINUE;
-        if (interrupt)
-            future.setKeepAlive(false);
-        return interrupt;
-    }
-
-    private boolean exitAfterHandling100(final Channel channel, final NettyResponseFuture<?> future, int statusCode) {
-        if (statusCode == CONTINUE.code()) {
-            future.setHeadersAlreadyWrittenOnContinue(true);
-            future.setDontWriteBodyBecauseExpectContinue(false);
-            // directly send the body
-            Channels.setAttribute(channel, new Callback(future) {
-                @Override
-                public void call() throws IOException {
-                    Channels.setAttribute(channel, future);
-                    requestSender.writeRequest(future, channel);
-                }
-            });
-            return true;
-        }
-        return false;
-    }
-
-    private boolean exitAfterHandling401(//
-            final Channel channel,//
-            final NettyResponseFuture<?> future,//
-            HttpResponse response,//
-            final Request request,//
-            int statusCode,//
-            Realm realm,//
-            ProxyServer proxyServer) {
-
-        if (statusCode != UNAUTHORIZED.code())
-            return false;
-
-        if (realm == null) {
-            logger.info("Can't handle 401 as there's no realm");
-            return false;
-        }
-
-        if (future.getInAuth().getAndSet(true)) {
-            logger.info("Can't handle 401 as auth was already performed");
-            return false;
-        }
-
-        List<String> wwwAuthHeaders = response.headers().getAll(HttpHeaders.Names.WWW_AUTHENTICATE);
-
-        if (wwwAuthHeaders.isEmpty()) {
-            logger.info("Can't handle 401 as response doesn't contain WWW-Authenticate headers");
-            return false;
-        }
-
-        // FIXME what's this???
-        future.setChannelState(ChannelState.NEW);
-        HttpHeaders requestHeaders = new DefaultHttpHeaders().add(request.getHeaders());
-
-        switch (realm.getScheme()) {
-        case BASIC:
-            if (getHeaderWithPrefix(wwwAuthHeaders, "Basic") == null) {
-                logger.info("Can't handle 401 with Basic realm as WWW-Authenticate headers don't match");
-                return false;
-            }
-
-            if (realm.isUsePreemptiveAuth()) {
-                // FIXME do we need this, as future.getAndSetAuth
-                // was tested above?
-                // auth was already performed, most likely auth
-                // failed
-                logger.info("Can't handle 401 with Basic realm as auth was preemptive and already performed");
-                return false;
-            }
-
-            // FIXME do we want to update the realm, or directly
-            // set the header?
-            Realm newBasicRealm = realm(realm)//
-                    .setUsePreemptiveAuth(true)//
-                    .build();
-            future.setRealm(newBasicRealm);
-            break;
-
-        case DIGEST:
-            String digestHeader = getHeaderWithPrefix(wwwAuthHeaders, "Digest");
-            if (digestHeader == null) {
-                logger.info("Can't handle 401 with Digest realm as WWW-Authenticate headers don't match");
-                return false;
-            }
-            Realm newDigestRealm = realm(realm)//
-                    .setUri(request.getUri())//
-                    .setMethodName(request.getMethod())//
-                    .setUsePreemptiveAuth(true)//
-                    .parseWWWAuthenticateHeader(digestHeader)//
-                    .build();
-            future.setRealm(newDigestRealm);
-            break;
-
-        case NTLM:
-            String ntlmHeader = getHeaderWithPrefix(wwwAuthHeaders, "NTLM");
-            if (ntlmHeader == null) {
-                logger.info("Can't handle 401 with NTLM realm as WWW-Authenticate headers don't match");
-                return false;
-            }
-
-            ntlmChallenge(ntlmHeader, request, requestHeaders, realm, future);
-            Realm newNtlmRealm = realm(realm)//
-                    .setUsePreemptiveAuth(true)//
-                    .build();
-            future.setRealm(newNtlmRealm);
-            break;
-
-        case KERBEROS:
-        case SPNEGO:
-            if (getHeaderWithPrefix(wwwAuthHeaders, "Negociate") == null) {
-                logger.info("Can't handle 401 with Kerberos or Spnego realm as WWW-Authenticate headers don't match");
-                return false;
-            }
-            try {
-                kerberosChallenge(channel, wwwAuthHeaders, request, requestHeaders, realm, future);
-
-            } catch (SpnegoEngineException e) {
-                // FIXME
-                String ntlmHeader2 = getHeaderWithPrefix(wwwAuthHeaders, "NTLM");
-                if (ntlmHeader2 != null) {
-                    logger.warn("Kerberos/Spnego auth failed, proceeding with NTLM");
-                    ntlmChallenge(ntlmHeader2, request, requestHeaders, realm, future);
-                    Realm newNtlmRealm2 = realm(realm)//
-                            .setScheme(AuthScheme.NTLM)//
-                            .setUsePreemptiveAuth(true)//
-                            .build();
-                    future.setRealm(newNtlmRealm2);
-                } else {
-                    requestSender.abort(channel, future, e);
-                    return false;
-                }
-            }
-            break;
-        default:
-            throw new IllegalStateException("Invalid Authentication scheme " + realm.getScheme());
-        }
-
-        final Request nextRequest = new RequestBuilder(future.getCurrentRequest()).setHeaders(requestHeaders).build();
-
-        logger.debug("Sending authentication to {}", request.getUri());
-        if (future.isKeepAlive() && !HttpHeaders.isTransferEncodingChunked(response)) {
-            future.setReuseChannel(true);
-            requestSender.drainChannelAndExecuteNextRequest(channel, future, nextRequest);
-        } else {
-            channelManager.closeChannel(channel);
-            requestSender.sendNextRequest(nextRequest, future);
-        }
-
-        return true;
-    }
-
-    private boolean exitAfterHandling407(//
-            Channel channel,//
-            NettyResponseFuture<?> future,//
-            HttpResponse response,//
-            Request request,//
-            int statusCode,//
-            ProxyServer proxyServer) {
-
-        if (statusCode != PROXY_AUTHENTICATION_REQUIRED.code())
-            return false;
-
-        if (future.getInProxyAuth().getAndSet(true)) {
-            logger.info("Can't handle 407 as auth was already performed");
-            return false;
-        }
-
-        Realm proxyRealm = future.getProxyRealm();
-
-        if (proxyRealm == null) {
-            logger.info("Can't handle 407 as there's no proxyRealm");
-            return false;
-        }
-
-        List<String> proxyAuthHeaders = response.headers().getAll(HttpHeaders.Names.PROXY_AUTHENTICATE);
-
-        if (proxyAuthHeaders.isEmpty()) {
-            logger.info("Can't handle 407 as response doesn't contain Proxy-Authenticate headers");
-            return false;
-        }
-
-        // FIXME what's this???
-        future.setChannelState(ChannelState.NEW);
-        HttpHeaders requestHeaders = new DefaultHttpHeaders().add(request.getHeaders());
-
-        switch (proxyRealm.getScheme()) {
-        case BASIC:
-            if (getHeaderWithPrefix(proxyAuthHeaders, "Basic") == null) {
-                logger.info("Can't handle 407 with Basic realm as Proxy-Authenticate headers don't match");
-                return false;
-            }
-
-            if (proxyRealm.isUsePreemptiveAuth()) {
-                // FIXME do we need this, as future.getAndSetAuth
-                // was tested above?
-                // auth was already performed, most likely auth
-                // failed
-                logger.info("Can't handle 407 with Basic realm as auth was preemptive and already performed");
-                return false;
-            }
-
-            // FIXME do we want to update the realm, or directly
-            // set the header?
-            Realm newBasicRealm = realm(proxyRealm)//
-                    .setUsePreemptiveAuth(true)//
-                    .build();
-            future.setProxyRealm(newBasicRealm);
-            break;
-
-        case DIGEST:
-            String digestHeader = getHeaderWithPrefix(proxyAuthHeaders, "Digest");
-            if (digestHeader == null) {
-                logger.info("Can't handle 407 with Digest realm as Proxy-Authenticate headers don't match");
-                return false;
-            }
-            Realm newDigestRealm = realm(proxyRealm)//
-                    .setUri(request.getUri())//
-                    .setMethodName(request.getMethod())//
-                    .setUsePreemptiveAuth(true)//
-                    .parseProxyAuthenticateHeader(digestHeader)//
-                    .build();
-            future.setProxyRealm(newDigestRealm);
-            break;
-
-        case NTLM:
-            String ntlmHeader = getHeaderWithPrefix(proxyAuthHeaders, "NTLM");
-            if (ntlmHeader == null) {
-                logger.info("Can't handle 407 with NTLM realm as Proxy-Authenticate headers don't match");
-                return false;
-            }
-            ntlmProxyChallenge(ntlmHeader, request, proxyRealm, requestHeaders, future);
-            Realm newNtlmRealm = realm(proxyRealm)//
-                    .setUsePreemptiveAuth(true)//
-                    .build();
-            future.setProxyRealm(newNtlmRealm);
-            break;
-
-        case KERBEROS:
-        case SPNEGO:
-            if (getHeaderWithPrefix(proxyAuthHeaders, "Negociate") == null) {
-                logger.info("Can't handle 407 with Kerberos or Spnego realm as Proxy-Authenticate headers don't match");
-                return false;
-            }
-            try {
-                kerberosProxyChallenge(channel, proxyAuthHeaders, request, proxyServer, proxyRealm, requestHeaders, future);
-
-            } catch (SpnegoEngineException e) {
-                // FIXME
-                String ntlmHeader2 = getHeaderWithPrefix(proxyAuthHeaders, "NTLM");
-                if (ntlmHeader2 != null) {
-                    logger.warn("Kerberos/Spnego proxy auth failed, proceeding with NTLM");
-                    ntlmChallenge(ntlmHeader2, request, requestHeaders, proxyRealm, future);
-                    Realm newNtlmRealm2 = realm(proxyRealm)//
-                            .setScheme(AuthScheme.NTLM)//
-                            .setUsePreemptiveAuth(true)//
-                            .build();
-                    future.setProxyRealm(newNtlmRealm2);
-                } else {
-                    requestSender.abort(channel, future, e);
-                    return false;
-                }
-            }
-            break;
-        default:
-            throw new IllegalStateException("Invalid Authentication scheme " + proxyRealm.getScheme());
-        }
-
-        RequestBuilder nextRequestBuilder = new RequestBuilder(future.getCurrentRequest()).setHeaders(requestHeaders);
-        if (future.getCurrentRequest().getUri().isSecured()) {
-            nextRequestBuilder.setMethod(HttpMethod.CONNECT.name());
-        }
-        final Request nextRequest = nextRequestBuilder.build();
-
-        logger.debug("Sending proxy authentication to {}", request.getUri());
-        if (future.isKeepAlive() && !HttpHeaders.isTransferEncodingChunked(response)) {
-            future.setConnectAllowed(true);
-            future.setReuseChannel(true);
-            requestSender.drainChannelAndExecuteNextRequest(channel, future, nextRequest);
-        } else {
-            channelManager.closeChannel(channel);
-            requestSender.sendNextRequest(nextRequest, future);
-        }
-
-        return true;
-    }
-
-    private boolean exitAfterHandlingConnect(//
-            final Channel channel,//
-            final NettyResponseFuture<?> future,//
-            final Request request,//
-            ProxyServer proxyServer,//
-            int statusCode,//
-            HttpRequest httpRequest) throws IOException {
-
-        if (statusCode == OK.code() && httpRequest.getMethod() == HttpMethod.CONNECT) {
-
-            if (future.isKeepAlive())
-                future.attachChannel(channel, true);
-
-            Uri requestUri = request.getUri();
-            logger.debug("Connecting to proxy {} for scheme {}", proxyServer, requestUri.getScheme());
-
-            channelManager.upgradeProtocol(channel.pipeline(), requestUri);
-            future.setReuseChannel(true);
-            future.setConnectAllowed(false);
-            requestSender.drainChannelAndExecuteNextRequest(channel, future, new RequestBuilder(future.getTargetRequest()).build());
-
-            return true;
-        }
-
-        return false;
-    }
-
-    private boolean exitAfterHandlingStatus(Channel channel, NettyResponseFuture<?> future, HttpResponse response, AsyncHandler<?> handler, NettyResponseStatus status)
-            throws IOException, Exception {
-        if (!future.getAndSetStatusReceived(true) && handler.onStatusReceived(status) != State.CONTINUE) {
-            finishUpdate(future, channel, HttpHeaders.isTransferEncodingChunked(response));
-            return true;
-        }
-        return false;
-    }
-
-    private boolean exitAfterHandlingHeaders(Channel channel, NettyResponseFuture<?> future, HttpResponse response, AsyncHandler<?> handler, NettyResponseHeaders responseHeaders)
-            throws IOException, Exception {
-        if (!response.headers().isEmpty() && handler.onHeadersReceived(responseHeaders) != State.CONTINUE) {
-            finishUpdate(future, channel, HttpHeaders.isTransferEncodingChunked(response));
-            return true;
-        }
-        return false;
-    }
-
-    private boolean exitAfterHandlingReactiveStreams(Channel channel, NettyResponseFuture<?> future, HttpResponse response, AsyncHandler<?> handler) throws IOException {
-        if (handler instanceof StreamedAsyncHandler) {
-            StreamedAsyncHandler<?> streamedAsyncHandler = (StreamedAsyncHandler<?>) handler;
-            StreamedResponsePublisher publisher = new StreamedResponsePublisher(channel.eventLoop(), channelManager, future, channel);
-            channel.pipeline().addLast(channel.eventLoop(), "streamedAsyncHandler", publisher);
-            Channels.setAttribute(channel, publisher);
-            if (streamedAsyncHandler.onStream(publisher) != State.CONTINUE) {
-                finishUpdate(future, channel, HttpHeaders.isTransferEncodingChunked(response));
-                return true;
-            }
-        }
-        return false;
-    }
-
-    private boolean handleHttpResponse(final HttpResponse response, final Channel channel, final NettyResponseFuture<?> future, AsyncHandler<?> handler) throws Exception {
-
-        HttpRequest httpRequest = future.getNettyRequest().getHttpRequest();
-        ProxyServer proxyServer = future.getProxyServer();
-        logger.debug("\n\nRequest {}\n\nResponse {}\n", httpRequest, response);
-
-        // store the original headers so we can re-send all them to
-        // the handler in case of trailing headers
-        future.setHttpHeaders(response.headers());
-
-        future.setKeepAlive(config.getKeepAliveStrategy().keepAlive(future.getTargetRequest(), httpRequest, response));
-
-        NettyResponseStatus status = new NettyResponseStatus(future.getUri(), config, response, channel);
-        int statusCode = response.getStatus().code();
-        Request request = future.getCurrentRequest();
-        Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
-        NettyResponseHeaders responseHeaders = new NettyResponseHeaders(response.headers());
-
-        return exitAfterProcessingFilters(channel, future, handler, status, responseHeaders) || //
-                exitAfterHandling401(channel, future, response, request, statusCode, realm, proxyServer) || //
-                exitAfterHandling407(channel, future, response, request, statusCode, proxyServer) || //
-                exitAfterHandling100(channel, future, statusCode) || //
-                exitAfterHandlingRedirect(channel, future, response, request, statusCode, realm) || //
-                exitAfterHandlingConnect(channel, future, request, proxyServer, statusCode, httpRequest) || //
-                exitAfterHandlingStatus(channel, future, response, handler, status) || //
-                exitAfterHandlingHeaders(channel, future, response, handler, responseHeaders) || exitAfterHandlingReactiveStreams(channel, future, response, handler);
-    }
-
-    private void handleChunk(HttpContent chunk,//
-            final Channel channel,//
-            final NettyResponseFuture<?> future,//
-            AsyncHandler<?> handler) throws IOException, Exception {
-
-        boolean interrupt = false;
-        boolean last = chunk instanceof LastHttpContent;
-
-        // Netty 4: the last chunk is not empty
-        if (last) {
-            LastHttpContent lastChunk = (LastHttpContent) chunk;
-            HttpHeaders trailingHeaders = lastChunk.trailingHeaders();
-            if (!trailingHeaders.isEmpty()) {
-                NettyResponseHeaders responseHeaders = new NettyResponseHeaders(future.getHttpHeaders(), trailingHeaders);
-                interrupt = handler.onHeadersReceived(responseHeaders) != State.CONTINUE;
-            }
-        }
-
-        ByteBuf buf = chunk.content();
-        if (!interrupt && !(handler instanceof StreamedAsyncHandler) && (buf.readableBytes() > 0 || last)) {
-            NettyResponseBodyPart part = config.getResponseBodyPartFactory().newResponseBodyPart(buf, last);
-            interrupt = updateBodyAndInterrupt(future, handler, part);
-        }
-
-        if (interrupt || last)
-            finishUpdate(future, channel, !last);
-    }
-
-    @Override
-    public void handle(final Channel channel, final NettyResponseFuture<?> future, final Object e) throws Exception {
-
-        future.touch();
-
-        // future is already done because of an exception or a timeout
-        if (future.isDone()) {
-            // FIXME isn't the channel already properly closed?
-            channelManager.closeChannel(channel);
-            return;
-        }
-
-        AsyncHandler<?> handler = future.getAsyncHandler();
-        try {
-            if (e instanceof HttpResponse) {
-                if (handleHttpResponse((HttpResponse) e, channel, future, handler))
-                    return;
-
-            } else if (e instanceof HttpContent) {
-                handleChunk((HttpContent) e, channel, future, handler);
-            }
-        } catch (Exception t) {
-            // e.g. an IOException when trying to open a connection and send the
-            // next request
-            if (hasIOExceptionFilters//
-                    && t instanceof IOException//
-                    && requestSender.applyIoExceptionFiltersAndReplayRequest(future, IOException.class.cast(t), channel)) {
-                return;
-            }
-
-            try {
-                requestSender.abort(channel, future, t);
-            } catch (Exception abortException) {
-                logger.debug("Abort failed", abortException);
-            } finally {
-                finishUpdate(future, channel, false);
-            }
-            throw t;
-        }
-    }
-
-    @Override
-    public void onError(NettyResponseFuture<?> future, Throwable error) {
-    }
-
-    @Override
-    public void onClose(NettyResponseFuture<?> future) {
-    }
-}
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/WebSocketProtocol.java b/client/src/main/java/org/asynchttpclient/netty/handler/WebSocketHandler.java
similarity index 81%
rename from client/src/main/java/org/asynchttpclient/netty/handler/WebSocketProtocol.java
rename to client/src/main/java/org/asynchttpclient/netty/handler/WebSocketHandler.java
index 32bfae054..cb0883c11 100755
--- a/client/src/main/java/org/asynchttpclient/netty/handler/WebSocketProtocol.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/WebSocketHandler.java
@@ -17,7 +17,9 @@
 import static org.asynchttpclient.ws.WebSocketUtils.getAcceptKey;
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.Channel;
+import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.HttpRequest;
 import io.netty.handler.codec.http.HttpResponse;
 import io.netty.handler.codec.http.websocketx.BinaryWebSocketFrame;
 import io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;
@@ -31,14 +33,11 @@
 
 import org.asynchttpclient.AsyncHandler.State;
 import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.HttpResponseHeaders;
 import org.asynchttpclient.HttpResponseStatus;
-import org.asynchttpclient.Realm;
-import org.asynchttpclient.Request;
 import org.asynchttpclient.netty.Callback;
-import org.asynchttpclient.netty.NettyResponseBodyPart;
 import org.asynchttpclient.netty.NettyResponseFuture;
-import org.asynchttpclient.netty.NettyResponseHeaders;
 import org.asynchttpclient.netty.NettyResponseStatus;
 import org.asynchttpclient.netty.channel.ChannelManager;
 import org.asynchttpclient.netty.channel.Channels;
@@ -46,12 +45,13 @@
 import org.asynchttpclient.netty.ws.NettyWebSocket;
 import org.asynchttpclient.ws.WebSocketUpgradeHandler;
 
-public final class WebSocketProtocol extends Protocol {
+@Sharable
+public final class WebSocketHandler extends AsyncHttpClientHandler {
 
-    public WebSocketProtocol(ChannelManager channelManager,//
-            AsyncHttpClientConfig config,//
+    public WebSocketHandler(AsyncHttpClientConfig config,//
+            ChannelManager channelManager,//
             NettyRequestSender requestSender) {
-        super(channelManager, config, requestSender);
+        super(config, channelManager, requestSender);
     }
 
     // We don't need to synchronize as replacing the "ws-decoder" will
@@ -70,30 +70,22 @@ private void invokeOnSucces(Channel channel, WebSocketUpgradeHandler h) {
 
         private final Channel channel;
         private final HttpResponse response;
-        
-        public UpgradeCallback(NettyResponseFuture<?> future, Channel channel, HttpResponse response) {
+        private final WebSocketUpgradeHandler handler;
+        private final HttpResponseStatus status;
+        private final HttpResponseHeaders responseHeaders;
+
+        public UpgradeCallback(NettyResponseFuture<?> future, Channel channel, HttpResponse response, WebSocketUpgradeHandler handler, HttpResponseStatus status,
+                HttpResponseHeaders responseHeaders) {
             super(future);
             this.channel = channel;
             this.response = response;
+            this.handler = handler;
+            this.status = status;
+            this.responseHeaders = responseHeaders;
         }
-        
+
         @Override
         public void call() throws Exception {
-            
-            WebSocketUpgradeHandler handler = WebSocketUpgradeHandler.class.cast(future.getAsyncHandler());
-            Request request = future.getCurrentRequest();
-            
-            HttpResponseStatus status = new NettyResponseStatus(future.getUri(), config, response, channel);
-            HttpResponseHeaders responseHeaders = new NettyResponseHeaders(response.headers());
-            Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
-
-            if (exitAfterProcessingFilters(channel, future, handler, status, responseHeaders)) {
-                return;
-            }
-
-            future.setHttpHeaders(response.headers());
-            if (exitAfterHandlingRedirect(channel, future, response, request, response.getStatus().code(), realm))
-                return;
 
             boolean validStatus = response.getStatus().equals(SWITCHING_PROTOCOLS);
             boolean validUpgrade = response.headers().get(HttpHeaders.Names.UPGRADE) != null;
@@ -131,15 +123,27 @@ public void call() throws Exception {
             // set back the future so the protocol gets notified of frames
             Channels.setAttribute(channel, future);
         }
-        
+
     }
-    
+
     @Override
-    public void handle(Channel channel, NettyResponseFuture<?> future, Object e) throws Exception {
+    public void handleRead(Channel channel, NettyResponseFuture<?> future, Object e) throws Exception {
 
         if (e instanceof HttpResponse) {
             HttpResponse response = (HttpResponse) e;
-            Channels.setAttribute(channel, new UpgradeCallback(future, channel, response));
+            if (logger.isDebugEnabled()) {
+                HttpRequest httpRequest = future.getNettyRequest().getHttpRequest();
+                logger.debug("\n\nRequest {}\n\nResponse {}\n", httpRequest, response);
+            }
+
+            WebSocketUpgradeHandler handler = WebSocketUpgradeHandler.class.cast(future.getAsyncHandler());
+            HttpResponseStatus status = new NettyResponseStatus(future.getUri(), config, response, channel);
+            HttpResponseHeaders responseHeaders = new HttpResponseHeaders(response.headers());
+
+            if (!interceptors.exitAfterIntercept(channel, future, handler, response, status, responseHeaders)) {
+                Channels.setAttribute(channel, new UpgradeCallback(future, channel, response, handler, status, responseHeaders));
+            }
+
 
         } else if (e instanceof WebSocketFrame) {
 
@@ -156,7 +160,7 @@ public void handle(Channel channel, NettyResponseFuture<?> future, Object e) thr
                 } else {
                     ByteBuf buf = frame.content();
                     if (buf != null && buf.readableBytes() > 0) {
-                        NettyResponseBodyPart part = config.getResponseBodyPartFactory().newResponseBodyPart(buf, frame.isFinalFragment());
+                        HttpResponseBodyPart part = config.getResponseBodyPartFactory().newResponseBodyPart(buf, frame.isFinalFragment());
                         handler.onBodyPartReceived(part);
 
                         if (frame instanceof BinaryWebSocketFrame) {
@@ -179,7 +183,7 @@ public void handle(Channel channel, NettyResponseFuture<?> future, Object e) thr
     }
 
     @Override
-    public void onError(NettyResponseFuture<?> future, Throwable e) {
+    public void handleException(NettyResponseFuture<?> future, Throwable e) {
         logger.warn("onError {}", e);
 
         try {
@@ -196,7 +200,7 @@ public void onError(NettyResponseFuture<?> future, Throwable e) {
     }
 
     @Override
-    public void onClose(NettyResponseFuture<?> future) {
+    public void handleChannelInactive(NettyResponseFuture<?> future) {
         logger.trace("onClose");
 
         try {
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/ConnectSuccessInterceptor.java b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/ConnectSuccessInterceptor.java
new file mode 100644
index 000000000..8da166e20
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/ConnectSuccessInterceptor.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.handler.intercept;
+
+import io.netty.channel.Channel;
+import io.netty.handler.codec.http.HttpRequest;
+
+import java.io.IOException;
+
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.channel.ChannelManager;
+import org.asynchttpclient.netty.request.NettyRequestSender;
+import org.asynchttpclient.proxy.ProxyServer;
+import org.asynchttpclient.uri.Uri;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class ConnectSuccessInterceptor {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(ConnectSuccessInterceptor.class);
+
+    private final ChannelManager channelManager;
+    private final NettyRequestSender requestSender;
+
+    public ConnectSuccessInterceptor(ChannelManager channelManager, NettyRequestSender requestSender) {
+        this.channelManager = channelManager;
+        this.requestSender = requestSender;
+    }
+
+    public boolean exitAfterHandlingConnect(//
+            final Channel channel,//
+            final NettyResponseFuture<?> future,//
+            final Request request,//
+            ProxyServer proxyServer,//
+            int statusCode,//
+            HttpRequest httpRequest) throws IOException {
+
+        if (future.isKeepAlive())
+            future.attachChannel(channel, true);
+
+        Uri requestUri = request.getUri();
+        LOGGER.debug("Connecting to proxy {} for scheme {}", proxyServer, requestUri.getScheme());
+
+        channelManager.upgradeProtocol(channel.pipeline(), requestUri);
+        future.setReuseChannel(true);
+        future.setConnectAllowed(false);
+        requestSender.drainChannelAndExecuteNextRequest(channel, future, new RequestBuilder(future.getTargetRequest()).build());
+
+        return true;
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Continue100Interceptor.java b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Continue100Interceptor.java
new file mode 100644
index 000000000..c4a654d17
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Continue100Interceptor.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.handler.intercept;
+
+import io.netty.channel.Channel;
+
+import java.io.IOException;
+
+import org.asynchttpclient.netty.Callback;
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.channel.Channels;
+import org.asynchttpclient.netty.request.NettyRequestSender;
+
+public class Continue100Interceptor {
+
+    private final NettyRequestSender requestSender;
+
+    public Continue100Interceptor(NettyRequestSender requestSender) {
+        this.requestSender = requestSender;
+    }
+
+    public boolean exitAfterHandling100(final Channel channel, final NettyResponseFuture<?> future, int statusCode) {
+        future.setHeadersAlreadyWrittenOnContinue(true);
+        future.setDontWriteBodyBecauseExpectContinue(false);
+        // directly send the body
+        Channels.setAttribute(channel, new Callback(future) {
+            @Override
+            public void call() throws IOException {
+                Channels.setAttribute(channel, future);
+                requestSender.writeRequest(future, channel);
+            }
+        });
+        return true;
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Interceptors.java b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Interceptors.java
new file mode 100644
index 000000000..ea31be0f8
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Interceptors.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.handler.intercept;
+
+import static org.asynchttpclient.util.HttpConstants.ResponseStatusCodes.*;
+import io.netty.channel.Channel;
+import io.netty.handler.codec.http.HttpMethod;
+import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.codec.http.HttpResponse;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.Realm;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.channel.ChannelManager;
+import org.asynchttpclient.netty.request.NettyRequestSender;
+import org.asynchttpclient.proxy.ProxyServer;
+
+public class Interceptors {
+
+    private final AsyncHttpClientConfig config;
+    private final Unauthorized401Interceptor unauthorized401Interceptor;
+    private final ProxyUnauthorized407Interceptor proxyUnauthorized407Interceptor;
+    private final Continue100Interceptor continue100Interceptor;
+    private final Redirect30xInterceptor redirect30xInterceptor;
+    private final ConnectSuccessInterceptor connectSuccessInterceptor;
+    private final ResponseFiltersInterceptor responseFiltersInterceptor;
+    private final boolean hasResponseFilters;
+
+    public Interceptors(//
+            AsyncHttpClientConfig config,//
+            ChannelManager channelManager,//
+            NettyRequestSender requestSender) {
+        this.config = config;
+        unauthorized401Interceptor = new Unauthorized401Interceptor(channelManager, requestSender);
+        proxyUnauthorized407Interceptor = new ProxyUnauthorized407Interceptor(channelManager, requestSender);
+        continue100Interceptor = new Continue100Interceptor(requestSender);
+        redirect30xInterceptor = new Redirect30xInterceptor(channelManager, config, requestSender);
+        connectSuccessInterceptor = new ConnectSuccessInterceptor(channelManager, requestSender);
+        responseFiltersInterceptor = new ResponseFiltersInterceptor(config, requestSender);
+        hasResponseFilters = !config.getResponseFilters().isEmpty();
+    }
+
+    public boolean exitAfterIntercept(//
+            Channel channel,//
+            NettyResponseFuture<?> future,//
+            AsyncHandler<?> handler,//
+            HttpResponse response,//
+            HttpResponseStatus status,//
+            HttpResponseHeaders responseHeaders) throws Exception {
+
+        HttpRequest httpRequest = future.getNettyRequest().getHttpRequest();
+        ProxyServer proxyServer = future.getProxyServer();
+        int statusCode = response.getStatus().code();
+        Request request = future.getCurrentRequest();
+        Realm realm = request.getRealm() != null ? request.getRealm() : config.getRealm();
+
+        if (hasResponseFilters && responseFiltersInterceptor.exitAfterProcessingFilters(channel, future, handler, status, responseHeaders)) {
+            return true;
+        }
+
+        if (statusCode == UNAUTHORIZED_401) {
+            return unauthorized401Interceptor.exitAfterHandling401(channel, future, response, request, statusCode, realm, proxyServer, httpRequest);
+
+        } else if (statusCode == PROXY_AUTHENTICATION_REQUIRED_407) {
+            return proxyUnauthorized407Interceptor.exitAfterHandling407(channel, future, response, request, statusCode, proxyServer, httpRequest);
+
+        } else if (statusCode == CONTINUE_100) {
+            return continue100Interceptor.exitAfterHandling100(channel, future, statusCode);
+
+        } else if (Redirect30xInterceptor.REDIRECT_STATUSES.contains(statusCode)) {
+            return redirect30xInterceptor.exitAfterHandlingRedirect(channel, future, response, request, statusCode, realm);
+
+        } else if (httpRequest.getMethod() == HttpMethod.CONNECT && statusCode == OK_200) {
+            return connectSuccessInterceptor.exitAfterHandlingConnect(channel, future, request, proxyServer, statusCode, httpRequest);
+
+        }
+        return false;
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/ProxyUnauthorized407Interceptor.java b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/ProxyUnauthorized407Interceptor.java
new file mode 100644
index 000000000..31e741239
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/ProxyUnauthorized407Interceptor.java
@@ -0,0 +1,224 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.handler.intercept;
+
+import static org.asynchttpclient.Dsl.realm;
+import static org.asynchttpclient.util.AuthenticatorUtils.*;
+import static org.asynchttpclient.util.HttpConstants.Methods.CONNECT;
+import io.netty.channel.Channel;
+import io.netty.handler.codec.http.DefaultHttpHeaders;
+import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.codec.http.HttpResponse;
+
+import java.util.List;
+
+import org.asynchttpclient.Realm;
+import org.asynchttpclient.Realm.AuthScheme;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.channel.ChannelManager;
+import org.asynchttpclient.netty.channel.ChannelState;
+import org.asynchttpclient.netty.request.NettyRequestSender;
+import org.asynchttpclient.ntlm.NtlmEngine;
+import org.asynchttpclient.proxy.ProxyServer;
+import org.asynchttpclient.spnego.SpnegoEngine;
+import org.asynchttpclient.spnego.SpnegoEngineException;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class ProxyUnauthorized407Interceptor {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(ProxyUnauthorized407Interceptor.class);
+
+    private final ChannelManager channelManager;
+    private final NettyRequestSender requestSender;
+
+    public ProxyUnauthorized407Interceptor(ChannelManager channelManager, NettyRequestSender requestSender) {
+        this.channelManager = channelManager;
+        this.requestSender = requestSender;
+    }
+
+    public boolean exitAfterHandling407(//
+            Channel channel,//
+            NettyResponseFuture<?> future,//
+            HttpResponse response,//
+            Request request,//
+            int statusCode,//
+            ProxyServer proxyServer,//
+            HttpRequest httpRequest) {
+
+        if (future.getInProxyAuth().getAndSet(true)) {
+            LOGGER.info("Can't handle 407 as auth was already performed");
+            return false;
+        }
+
+        Realm proxyRealm = future.getProxyRealm();
+
+        if (proxyRealm == null) {
+            LOGGER.info("Can't handle 407 as there's no proxyRealm");
+            return false;
+        }
+
+        List<String> proxyAuthHeaders = response.headers().getAll(HttpHeaders.Names.PROXY_AUTHENTICATE);
+
+        if (proxyAuthHeaders.isEmpty()) {
+            LOGGER.info("Can't handle 407 as response doesn't contain Proxy-Authenticate headers");
+            return false;
+        }
+
+        // FIXME what's this???
+        future.setChannelState(ChannelState.NEW);
+        HttpHeaders requestHeaders = new DefaultHttpHeaders(false).add(request.getHeaders());
+
+        switch (proxyRealm.getScheme()) {
+        case BASIC:
+            if (getHeaderWithPrefix(proxyAuthHeaders, "Basic") == null) {
+                LOGGER.info("Can't handle 407 with Basic realm as Proxy-Authenticate headers don't match");
+                return false;
+            }
+
+            if (proxyRealm.isUsePreemptiveAuth()) {
+                // FIXME do we need this, as future.getAndSetAuth
+                // was tested above?
+                // auth was already performed, most likely auth
+                // failed
+                LOGGER.info("Can't handle 407 with Basic realm as auth was preemptive and already performed");
+                return false;
+            }
+
+            // FIXME do we want to update the realm, or directly
+            // set the header?
+            Realm newBasicRealm = realm(proxyRealm)//
+                    .setUsePreemptiveAuth(true)//
+                    .build();
+            future.setProxyRealm(newBasicRealm);
+            break;
+
+        case DIGEST:
+            String digestHeader = getHeaderWithPrefix(proxyAuthHeaders, "Digest");
+            if (digestHeader == null) {
+                LOGGER.info("Can't handle 407 with Digest realm as Proxy-Authenticate headers don't match");
+                return false;
+            }
+            Realm newDigestRealm = realm(proxyRealm)//
+                    .setUri(request.getUri())//
+                    .setMethodName(request.getMethod())//
+                    .setUsePreemptiveAuth(true)//
+                    .parseProxyAuthenticateHeader(digestHeader)//
+                    .build();
+            future.setProxyRealm(newDigestRealm);
+            break;
+
+        case NTLM:
+            String ntlmHeader = getHeaderWithPrefix(proxyAuthHeaders, "NTLM");
+            if (ntlmHeader == null) {
+                LOGGER.info("Can't handle 407 with NTLM realm as Proxy-Authenticate headers don't match");
+                return false;
+            }
+            ntlmProxyChallenge(ntlmHeader, request, requestHeaders, proxyRealm, future);
+            Realm newNtlmRealm = realm(proxyRealm)//
+                    .setUsePreemptiveAuth(true)//
+                    .build();
+            future.setProxyRealm(newNtlmRealm);
+            break;
+
+        case KERBEROS:
+        case SPNEGO:
+            if (getHeaderWithPrefix(proxyAuthHeaders, NEGOTIATE) == null) {
+                LOGGER.info("Can't handle 407 with Kerberos or Spnego realm as Proxy-Authenticate headers don't match");
+                return false;
+            }
+            try {
+                kerberosProxyChallenge(channel, proxyAuthHeaders, request, proxyServer, proxyRealm, requestHeaders, future);
+
+            } catch (SpnegoEngineException e) {
+                // FIXME
+                String ntlmHeader2 = getHeaderWithPrefix(proxyAuthHeaders, "NTLM");
+                if (ntlmHeader2 != null) {
+                    LOGGER.warn("Kerberos/Spnego proxy auth failed, proceeding with NTLM");
+                    ntlmProxyChallenge(ntlmHeader2, request, requestHeaders, proxyRealm, future);
+                    Realm newNtlmRealm2 = realm(proxyRealm)//
+                            .setScheme(AuthScheme.NTLM)//
+                            .setUsePreemptiveAuth(true)//
+                            .build();
+                    future.setProxyRealm(newNtlmRealm2);
+                } else {
+                    requestSender.abort(channel, future, e);
+                    return false;
+                }
+            }
+            break;
+        default:
+            throw new IllegalStateException("Invalid Authentication scheme " + proxyRealm.getScheme());
+        }
+
+        RequestBuilder nextRequestBuilder = new RequestBuilder(future.getCurrentRequest()).setHeaders(requestHeaders);
+        if (future.getCurrentRequest().getUri().isSecured()) {
+            nextRequestBuilder.setMethod(CONNECT);
+        }
+        final Request nextRequest = nextRequestBuilder.build();
+
+        LOGGER.debug("Sending proxy authentication to {}", request.getUri());
+        if (future.isKeepAlive()//
+                && !HttpHeaders.isTransferEncodingChunked(httpRequest)//
+                && !HttpHeaders.isTransferEncodingChunked(response)) {
+            future.setConnectAllowed(true);
+            future.setReuseChannel(true);
+            requestSender.drainChannelAndExecuteNextRequest(channel, future, nextRequest);
+        } else {
+            channelManager.closeChannel(channel);
+            requestSender.sendNextRequest(nextRequest, future);
+        }
+
+        return true;
+    }
+
+    private void kerberosProxyChallenge(Channel channel,//
+            List<String> proxyAuth,//
+            Request request,//
+            ProxyServer proxyServer,//
+            Realm proxyRealm,//
+            HttpHeaders headers,//
+            NettyResponseFuture<?> future) throws SpnegoEngineException {
+
+        String challengeHeader = SpnegoEngine.instance().generateToken(proxyServer.getHost());
+        headers.set(HttpHeaders.Names.PROXY_AUTHORIZATION, NEGOTIATE + " " + challengeHeader);
+    }
+
+    private void ntlmProxyChallenge(String authenticateHeader,//
+            Request request,//
+            HttpHeaders requestHeaders,//
+            Realm proxyRealm,//
+            NettyResponseFuture<?> future) {
+
+        if (authenticateHeader.equals("NTLM")) {
+            // server replied bare NTLM => we didn't preemptively sent Type1Msg
+            String challengeHeader = NtlmEngine.INSTANCE.generateType1Msg();
+            // FIXME we might want to filter current NTLM and add (leave other
+            // Authorization headers untouched)
+            requestHeaders.set(HttpHeaders.Names.PROXY_AUTHORIZATION, "NTLM " + challengeHeader);
+            future.getInProxyAuth().set(false);
+
+        } else {
+            String serverChallenge = authenticateHeader.substring("NTLM ".length()).trim();
+            String challengeHeader = NtlmEngine.INSTANCE.generateType3Msg(proxyRealm.getPrincipal(), proxyRealm.getPassword(), proxyRealm.getNtlmDomain(),
+                    proxyRealm.getNtlmHost(), serverChallenge);
+            // FIXME we might want to filter current NTLM and add (leave other
+            // Authorization headers untouched)
+            requestHeaders.set(HttpHeaders.Names.PROXY_AUTHORIZATION, "NTLM " + challengeHeader);
+        }
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/Protocol.java b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Redirect30xInterceptor.java
old mode 100755
new mode 100644
similarity index 60%
rename from client/src/main/java/org/asynchttpclient/netty/handler/Protocol.java
rename to client/src/main/java/org/asynchttpclient/netty/handler/intercept/Redirect30xInterceptor.java
index ad8030591..5ed705096
--- a/client/src/main/java/org/asynchttpclient/netty/handler/Protocol.java
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Redirect30xInterceptor.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
  *
  * This program is licensed to you under the Apache License Version 2.0,
  * and you may not use this file except in compliance with the Apache License Version 2.0.
@@ -11,93 +11,61 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.netty.handler;
+package org.asynchttpclient.netty.handler.intercept;
 
 import static io.netty.handler.codec.http.HttpHeaders.Names.*;
-import static io.netty.handler.codec.http.HttpResponseStatus.*;
-import static org.asynchttpclient.util.Assertions.assertNotNull;
+import static org.asynchttpclient.util.HttpConstants.Methods.GET;
+import static org.asynchttpclient.util.HttpConstants.ResponseStatusCodes.*;
 import static org.asynchttpclient.util.HttpUtils.*;
-import io.netty.channel.Channel;
-import io.netty.handler.codec.http.HttpHeaders;
-import io.netty.handler.codec.http.HttpMethod;
-import io.netty.handler.codec.http.HttpResponse;
+import static org.asynchttpclient.util.MiscUtils.*;
 
 import java.util.HashSet;
 import java.util.Set;
 
-import org.asynchttpclient.AsyncHandler;
+import io.netty.channel.Channel;
+import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.HttpResponse;
+
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.asynchttpclient.HttpResponseHeaders;
-import org.asynchttpclient.HttpResponseStatus;
 import org.asynchttpclient.Realm;
-import org.asynchttpclient.Realm.AuthScheme;
 import org.asynchttpclient.Request;
 import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.Realm.AuthScheme;
 import org.asynchttpclient.cookie.Cookie;
 import org.asynchttpclient.cookie.CookieDecoder;
-import org.asynchttpclient.filter.FilterContext;
-import org.asynchttpclient.filter.FilterException;
-import org.asynchttpclient.filter.ResponseFilter;
 import org.asynchttpclient.handler.MaxRedirectException;
 import org.asynchttpclient.netty.NettyResponseFuture;
 import org.asynchttpclient.netty.channel.ChannelManager;
 import org.asynchttpclient.netty.request.NettyRequestSender;
 import org.asynchttpclient.uri.Uri;
-import org.asynchttpclient.util.MiscUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-public abstract class Protocol {
-
-    protected final Logger logger = LoggerFactory.getLogger(getClass());
-
-    protected final ChannelManager channelManager;
-    protected final AsyncHttpClientConfig config;
-    protected final NettyRequestSender requestSender;
-
-    private final boolean hasResponseFilters;
-    protected final boolean hasIOExceptionFilters;
-    private final MaxRedirectException maxRedirectException;
+public class Redirect30xInterceptor {
 
     public static final Set<Integer> REDIRECT_STATUSES = new HashSet<>();
     static {
-        REDIRECT_STATUSES.add(MOVED_PERMANENTLY.code());
-        REDIRECT_STATUSES.add(FOUND.code());
-        REDIRECT_STATUSES.add(SEE_OTHER.code());
-        REDIRECT_STATUSES.add(TEMPORARY_REDIRECT.code());
+        REDIRECT_STATUSES.add(MOVED_PERMANENTLY_301);
+        REDIRECT_STATUSES.add(FOUND_302);
+        REDIRECT_STATUSES.add(SEE_OTHER_303);
+        REDIRECT_STATUSES.add(TEMPORARY_REDIRECT_307);
     }
+    
+    private static final Logger LOGGER = LoggerFactory.getLogger(Redirect30xInterceptor.class);
 
-    public Protocol(ChannelManager channelManager, AsyncHttpClientConfig config, NettyRequestSender requestSender) {
+    private final ChannelManager channelManager;
+    private final AsyncHttpClientConfig config;
+    private final NettyRequestSender requestSender;
+    private final MaxRedirectException maxRedirectException;
+    
+    public Redirect30xInterceptor(ChannelManager channelManager, AsyncHttpClientConfig config, NettyRequestSender requestSender) {
         this.channelManager = channelManager;
         this.config = config;
         this.requestSender = requestSender;
-
-        hasResponseFilters = !config.getResponseFilters().isEmpty();
-        hasIOExceptionFilters = !config.getIoExceptionFilters().isEmpty();
-        maxRedirectException = new MaxRedirectException("Maximum redirect reached: " + config.getMaxRedirects());
+        maxRedirectException = trimStackTrace(new MaxRedirectException("Maximum redirect reached: " + config.getMaxRedirects()));
     }
-
-    public abstract void handle(Channel channel, NettyResponseFuture<?> future, Object message) throws Exception;
-
-    public abstract void onError(NettyResponseFuture<?> future, Throwable error);
-
-    public abstract void onClose(NettyResponseFuture<?> future);
-
-    private HttpHeaders propagatedHeaders(Request request, Realm realm, boolean switchToGet) {
-
-        HttpHeaders headers = request.getHeaders()//
-                .remove(HttpHeaders.Names.HOST)//
-                .remove(HttpHeaders.Names.CONTENT_LENGTH)//
-                .remove(HttpHeaders.Names.CONTENT_TYPE);
-
-        if (realm != null && realm.getScheme() == AuthScheme.NTLM) {
-            headers.remove(AUTHORIZATION)//
-                    .remove(PROXY_AUTHORIZATION);
-        }
-        return headers;
-    }
-
-    protected boolean exitAfterHandlingRedirect(//
+    
+    public boolean exitAfterHandlingRedirect(//
             Channel channel,//
             NettyResponseFuture<?> future,//
             HttpResponse response,//
@@ -105,7 +73,7 @@ protected boolean exitAfterHandlingRedirect(//
             int statusCode,//
             Realm realm) throws Exception {
 
-        if (followRedirect(config, request) && REDIRECT_STATUSES.contains(statusCode)) {
+        if (followRedirect(config, request)) {
             if (future.incrementAndGetCurrentRedirectCount() >= config.getMaxRedirects()) {
                 throw maxRedirectException;
 
@@ -115,12 +83,13 @@ protected boolean exitAfterHandlingRedirect(//
                 future.getInProxyAuth().set(false);
 
                 String originalMethod = request.getMethod();
-                boolean switchToGet = !originalMethod.equals(HttpMethod.GET.name()) && (statusCode == 301 || statusCode == 303 || (statusCode == 302 && !config.isStrict302Handling()));
-                boolean keepBody = statusCode == 307 || (statusCode == 302 && config.isStrict302Handling());
+                boolean switchToGet = !originalMethod.equals(GET)
+                        && (statusCode == MOVED_PERMANENTLY_301 || statusCode == SEE_OTHER_303 || (statusCode == FOUND_302 && !config.isStrict302Handling()));
+                boolean keepBody = statusCode == TEMPORARY_REDIRECT_307 || (statusCode == FOUND_302 && config.isStrict302Handling());
 
-                final RequestBuilder requestBuilder = new RequestBuilder(switchToGet ? HttpMethod.GET.name() : originalMethod)//
+                final RequestBuilder requestBuilder = new RequestBuilder(switchToGet ? GET : originalMethod)//
                         .setCookies(request.getCookies())//
-                        .setConnectionPoolPartitioning(request.getConnectionPoolPartitioning())//
+                        .setChannelPoolPartitioning(request.getChannelPoolPartitioning())//
                         .setFollowRedirect(true)//
                         .setLocalAddress(request.getLocalAddress())//
                         .setNameResolver(request.getNameResolver())//
@@ -130,7 +99,7 @@ protected boolean exitAfterHandlingRedirect(//
 
                 if (keepBody) {
                     requestBuilder.setCharset(request.getCharset());
-                    if (MiscUtils.isNonEmpty(request.getFormParams()))
+                    if (isNonEmpty(request.getFormParams()))
                         requestBuilder.setFormParams(request.getFormParams());
                     else if (request.getStringData() != null)
                         requestBuilder.setBody(request.getStringData());
@@ -142,7 +111,7 @@ else if (request.getBodyGenerator() != null)
                         requestBuilder.setBody(request.getBodyGenerator());
                 }
 
-                requestBuilder.setHeaders(propagatedHeaders(request, realm, switchToGet));
+                requestBuilder.setHeaders(propagatedHeaders(request, realm, keepBody));
 
                 // in case of a redirect from HTTP to HTTPS, future
                 // attributes might change
@@ -153,7 +122,7 @@ else if (request.getBodyGenerator() != null)
                 String location = responseHeaders.get(HttpHeaders.Names.LOCATION);
                 Uri newUri = Uri.create(future.getUri(), location);
 
-                logger.debug("Redirecting to {}", newUri);
+                LOGGER.debug("Redirecting to {}", newUri);
 
                 for (String cookieStr : responseHeaders.getAll(HttpHeaders.Names.SET_COOKIE)) {
                     Cookie c = CookieDecoder.decode(cookieStr);
@@ -161,8 +130,6 @@ else if (request.getBodyGenerator() != null)
                         requestBuilder.addOrReplaceCookie(c);
                 }
 
-                requestBuilder.setHeaders(propagatedHeaders(future.getCurrentRequest(), realm, switchToGet));
-
                 boolean sameBase = isSameBase(request.getUri(), newUri);
 
                 if (sameBase) {
@@ -173,7 +140,7 @@ else if (request.getBodyGenerator() != null)
                 final Request nextRequest = requestBuilder.setUri(newUri).build();
                 future.setTargetRequest(nextRequest);
 
-                logger.debug("Sending redirect to {}", newUri);
+                LOGGER.debug("Sending redirect to {}", newUri);
 
                 if (future.isKeepAlive() && !HttpHeaders.isTransferEncodingChunked(response)) {
 
@@ -197,38 +164,21 @@ else if (request.getBodyGenerator() != null)
         }
         return false;
     }
+    
+    private HttpHeaders propagatedHeaders(Request request, Realm realm, boolean keepBody) {
 
-    @SuppressWarnings({ "rawtypes", "unchecked" })
-    protected boolean exitAfterProcessingFilters(//
-            Channel channel,//
-            NettyResponseFuture<?> future,//
-            AsyncHandler<?> handler, //
-            HttpResponseStatus status,//
-            HttpResponseHeaders responseHeaders) {
-
-        if (hasResponseFilters) {
-            FilterContext fc = new FilterContext.FilterContextBuilder().asyncHandler(handler).request(future.getCurrentRequest()).responseStatus(status).responseHeaders(responseHeaders)
-                    .build();
-
-            for (ResponseFilter asyncFilter : config.getResponseFilters()) {
-                try {
-                    fc = asyncFilter.filter(fc);
-                    // FIXME Is it worth protecting against this?
-                    assertNotNull("fc", "filterContext");
-                } catch (FilterException efe) {
-                    requestSender.abort(channel, future, efe);
-                }
-            }
+        HttpHeaders headers = request.getHeaders()//
+                .remove(HttpHeaders.Names.HOST)//
+                .remove(HttpHeaders.Names.CONTENT_LENGTH);
 
-            // The handler may have been wrapped.
-            future.setAsyncHandler(fc.getAsyncHandler());
+        if (!keepBody) {
+            headers.remove(HttpHeaders.Names.CONTENT_TYPE);
+        }
 
-            // The request has changed
-            if (fc.replayRequest()) {
-                requestSender.replayRequest(future, fc, channel);
-                return true;
-            }
+        if (realm != null && realm.getScheme() == AuthScheme.NTLM) {
+            headers.remove(AUTHORIZATION)//
+                    .remove(PROXY_AUTHORIZATION);
         }
-        return false;
+        return headers;
     }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/ResponseFiltersInterceptor.java b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/ResponseFiltersInterceptor.java
new file mode 100644
index 000000000..bd78f35b9
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/ResponseFiltersInterceptor.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.handler.intercept;
+
+import static org.asynchttpclient.util.Assertions.assertNotNull;
+import io.netty.channel.Channel;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.filter.FilterContext;
+import org.asynchttpclient.filter.FilterException;
+import org.asynchttpclient.filter.ResponseFilter;
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.request.NettyRequestSender;
+
+public class ResponseFiltersInterceptor {
+
+    private final AsyncHttpClientConfig config;
+    private final NettyRequestSender requestSender;
+
+    public ResponseFiltersInterceptor(AsyncHttpClientConfig config, NettyRequestSender requestSender) {
+        this.config = config;
+        this.requestSender = requestSender;
+    }
+
+    @SuppressWarnings({ "rawtypes", "unchecked" })
+    public boolean exitAfterProcessingFilters(//
+            Channel channel,//
+            NettyResponseFuture<?> future,//
+            AsyncHandler<?> handler, //
+            HttpResponseStatus status,//
+            HttpResponseHeaders responseHeaders) {
+
+        FilterContext fc = new FilterContext.FilterContextBuilder().asyncHandler(handler).request(future.getCurrentRequest()).responseStatus(status)
+                .responseHeaders(responseHeaders).build();
+
+        for (ResponseFilter asyncFilter : config.getResponseFilters()) {
+            try {
+                fc = asyncFilter.filter(fc);
+                // FIXME Is it worth protecting against this?
+                assertNotNull("fc", "filterContext");
+            } catch (FilterException efe) {
+                requestSender.abort(channel, future, efe);
+            }
+        }
+
+        // The handler may have been wrapped.
+        future.setAsyncHandler(fc.getAsyncHandler());
+
+        // The request has changed
+        if (fc.replayRequest()) {
+            requestSender.replayRequest(future, fc, channel);
+            return true;
+        }
+        return false;
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Unauthorized401Interceptor.java b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Unauthorized401Interceptor.java
new file mode 100644
index 000000000..534ca8294
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/netty/handler/intercept/Unauthorized401Interceptor.java
@@ -0,0 +1,220 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.netty.handler.intercept;
+
+import static org.asynchttpclient.Dsl.realm;
+import static org.asynchttpclient.util.AuthenticatorUtils.*;
+import static org.asynchttpclient.util.MiscUtils.withDefault;
+import io.netty.channel.Channel;
+import io.netty.handler.codec.http.DefaultHttpHeaders;
+import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.codec.http.HttpResponse;
+
+import java.util.List;
+
+import org.asynchttpclient.Realm;
+import org.asynchttpclient.Realm.AuthScheme;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.channel.ChannelManager;
+import org.asynchttpclient.netty.channel.ChannelState;
+import org.asynchttpclient.netty.request.NettyRequestSender;
+import org.asynchttpclient.ntlm.NtlmEngine;
+import org.asynchttpclient.proxy.ProxyServer;
+import org.asynchttpclient.spnego.SpnegoEngine;
+import org.asynchttpclient.spnego.SpnegoEngineException;
+import org.asynchttpclient.uri.Uri;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class Unauthorized401Interceptor {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(Unauthorized401Interceptor.class);
+
+    private final ChannelManager channelManager;
+    private final NettyRequestSender requestSender;
+
+    public Unauthorized401Interceptor(ChannelManager channelManager, NettyRequestSender requestSender) {
+        this.channelManager = channelManager;
+        this.requestSender = requestSender;
+    }
+
+    public boolean exitAfterHandling401(//
+            final Channel channel,//
+            final NettyResponseFuture<?> future,//
+            HttpResponse response,//
+            final Request request,//
+            int statusCode,//
+            Realm realm,//
+            ProxyServer proxyServer,//
+            HttpRequest httpRequest) {
+
+        if (realm == null) {
+            LOGGER.info("Can't handle 401 as there's no realm");
+            return false;
+        }
+
+        if (future.getInAuth().getAndSet(true)) {
+            LOGGER.info("Can't handle 401 as auth was already performed");
+            return false;
+        }
+
+        List<String> wwwAuthHeaders = response.headers().getAll(HttpHeaders.Names.WWW_AUTHENTICATE);
+
+        if (wwwAuthHeaders.isEmpty()) {
+            LOGGER.info("Can't handle 401 as response doesn't contain WWW-Authenticate headers");
+            return false;
+        }
+
+        // FIXME what's this???
+        future.setChannelState(ChannelState.NEW);
+        HttpHeaders requestHeaders = new DefaultHttpHeaders(false).add(request.getHeaders());
+
+        switch (realm.getScheme()) {
+        case BASIC:
+            if (getHeaderWithPrefix(wwwAuthHeaders, "Basic") == null) {
+                LOGGER.info("Can't handle 401 with Basic realm as WWW-Authenticate headers don't match");
+                return false;
+            }
+
+            if (realm.isUsePreemptiveAuth()) {
+                // FIXME do we need this, as future.getAndSetAuth
+                // was tested above?
+                // auth was already performed, most likely auth
+                // failed
+                LOGGER.info("Can't handle 401 with Basic realm as auth was preemptive and already performed");
+                return false;
+            }
+
+            // FIXME do we want to update the realm, or directly
+            // set the header?
+            Realm newBasicRealm = realm(realm)//
+                    .setUsePreemptiveAuth(true)//
+                    .build();
+            future.setRealm(newBasicRealm);
+            break;
+
+        case DIGEST:
+            String digestHeader = getHeaderWithPrefix(wwwAuthHeaders, "Digest");
+            if (digestHeader == null) {
+                LOGGER.info("Can't handle 401 with Digest realm as WWW-Authenticate headers don't match");
+                return false;
+            }
+            Realm newDigestRealm = realm(realm)//
+                    .setUri(request.getUri())//
+                    .setMethodName(request.getMethod())//
+                    .setUsePreemptiveAuth(true)//
+                    .parseWWWAuthenticateHeader(digestHeader)//
+                    .build();
+            future.setRealm(newDigestRealm);
+            break;
+
+        case NTLM:
+            String ntlmHeader = getHeaderWithPrefix(wwwAuthHeaders, "NTLM");
+            if (ntlmHeader == null) {
+                LOGGER.info("Can't handle 401 with NTLM realm as WWW-Authenticate headers don't match");
+                return false;
+            }
+
+            ntlmChallenge(ntlmHeader, request, requestHeaders, realm, future);
+            Realm newNtlmRealm = realm(realm)//
+                    .setUsePreemptiveAuth(true)//
+                    .build();
+            future.setRealm(newNtlmRealm);
+            break;
+
+        case KERBEROS:
+        case SPNEGO:
+            if (getHeaderWithPrefix(wwwAuthHeaders, NEGOTIATE) == null) {
+                LOGGER.info("Can't handle 401 with Kerberos or Spnego realm as WWW-Authenticate headers don't match");
+                return false;
+            }
+            try {
+                kerberosChallenge(channel, wwwAuthHeaders, request, requestHeaders, realm, future);
+
+            } catch (SpnegoEngineException e) {
+                // FIXME
+                String ntlmHeader2 = getHeaderWithPrefix(wwwAuthHeaders, "NTLM");
+                if (ntlmHeader2 != null) {
+                    LOGGER.warn("Kerberos/Spnego auth failed, proceeding with NTLM");
+                    ntlmChallenge(ntlmHeader2, request, requestHeaders, realm, future);
+                    Realm newNtlmRealm2 = realm(realm)//
+                            .setScheme(AuthScheme.NTLM)//
+                            .setUsePreemptiveAuth(true)//
+                            .build();
+                    future.setRealm(newNtlmRealm2);
+                } else {
+                    requestSender.abort(channel, future, e);
+                    return false;
+                }
+            }
+            break;
+        default:
+            throw new IllegalStateException("Invalid Authentication scheme " + realm.getScheme());
+        }
+
+        final Request nextRequest = new RequestBuilder(future.getCurrentRequest()).setHeaders(requestHeaders).build();
+
+        LOGGER.debug("Sending authentication to {}", request.getUri());
+        if (future.isKeepAlive()//
+                && !HttpHeaders.isTransferEncodingChunked(httpRequest)//
+                && !HttpHeaders.isTransferEncodingChunked(response)) {
+            future.setReuseChannel(true);
+            requestSender.drainChannelAndExecuteNextRequest(channel, future, nextRequest);
+        } else {
+            channelManager.closeChannel(channel);
+            requestSender.sendNextRequest(nextRequest, future);
+        }
+
+        return true;
+    }
+
+    private void ntlmChallenge(String authenticateHeader,//
+            Request request,//
+            HttpHeaders requestHeaders,//
+            Realm realm,//
+            NettyResponseFuture<?> future) {
+
+        if (authenticateHeader.equals("NTLM")) {
+            // server replied bare NTLM => we didn't preemptively sent Type1Msg
+            String challengeHeader = NtlmEngine.INSTANCE.generateType1Msg();
+            // FIXME we might want to filter current NTLM and add (leave other
+            // Authorization headers untouched)
+            requestHeaders.set(HttpHeaders.Names.AUTHORIZATION, "NTLM " + challengeHeader);
+            future.getInAuth().set(false);
+
+        } else {
+            String serverChallenge = authenticateHeader.substring("NTLM ".length()).trim();
+            String challengeHeader = NtlmEngine.INSTANCE.generateType3Msg(realm.getPrincipal(), realm.getPassword(), realm.getNtlmDomain(), realm.getNtlmHost(), serverChallenge);
+            // FIXME we might want to filter current NTLM and add (leave other
+            // Authorization headers untouched)
+            requestHeaders.set(HttpHeaders.Names.AUTHORIZATION, "NTLM " + challengeHeader);
+        }
+    }
+
+    private void kerberosChallenge(Channel channel,//
+            List<String> authHeaders,//
+            Request request,//
+            HttpHeaders headers,//
+            Realm realm,//
+            NettyResponseFuture<?> future) throws SpnegoEngineException {
+
+        Uri uri = request.getUri();
+        String host = withDefault(request.getVirtualHost(), uri.getHost());
+        String challengeHeader = SpnegoEngine.instance().generateToken(host);
+        headers.set(HttpHeaders.Names.AUTHORIZATION, NEGOTIATE + " " + challengeHeader);
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/NettyChannelConnector.java b/client/src/main/java/org/asynchttpclient/netty/request/NettyChannelConnector.java
index 2534c8627..54c9f30dc 100644
--- a/client/src/main/java/org/asynchttpclient/netty/request/NettyChannelConnector.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/NettyChannelConnector.java
@@ -12,87 +12,86 @@
  */
 package org.asynchttpclient.netty.request;
 
+import static org.asynchttpclient.handler.AsyncHandlerExtensionsUtils.toAsyncHandlerExtensions;
 import io.netty.bootstrap.Bootstrap;
+import io.netty.channel.Channel;
 import io.netty.channel.ChannelFuture;
-import io.netty.channel.ChannelFutureListener;
 
+import java.net.InetAddress;
 import java.net.InetSocketAddress;
-import java.net.UnknownHostException;
+import java.util.List;
+import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 import org.asynchttpclient.AsyncHandler;
-import org.asynchttpclient.Request;
-import org.asynchttpclient.channel.NameResolution;
 import org.asynchttpclient.handler.AsyncHandlerExtensions;
-import org.asynchttpclient.proxy.ProxyServer;
-import org.asynchttpclient.uri.Uri;
+import org.asynchttpclient.netty.SimpleChannelFutureListener;
+import org.asynchttpclient.netty.channel.NettyConnectListener;
+import org.asynchttpclient.netty.timeout.TimeoutsHolder;
 
 public class NettyChannelConnector {
-    
+
     private final AsyncHandlerExtensions asyncHandlerExtensions;
     private final InetSocketAddress localAddress;
-    private final InetSocketAddress[] remoteAddresses;
+    private final List<InetSocketAddress> remoteAddresses;
+    private final TimeoutsHolder timeoutsHolder;
+    private final AtomicBoolean closed;
     private volatile int i = 0;
 
-    public NettyChannelConnector(Request request, ProxyServer proxy, AsyncHandler<?> asyncHandler) throws UnknownHostException {
-
-        this.asyncHandlerExtensions = asyncHandler instanceof AsyncHandlerExtensions ? (AsyncHandlerExtensions) asyncHandler : null;
-        NameResolution[] resolutions;
-        Uri uri = request.getUri();
-        int port = uri.getExplicitPort();
-
-        if (request.getAddress() != null) {
-            resolutions = new NameResolution[] { new NameResolution(request.getAddress()) };
+    public NettyChannelConnector(InetAddress localAddress, List<InetSocketAddress> remoteAddresses, AsyncHandler<?> asyncHandler, TimeoutsHolder timeoutsHolder,
+            AtomicBoolean closed) {
+        this.localAddress = localAddress != null ? new InetSocketAddress(localAddress, 0) : null;
+        this.remoteAddresses = remoteAddresses;
+        this.asyncHandlerExtensions = toAsyncHandlerExtensions(asyncHandler);
+        this.timeoutsHolder = timeoutsHolder;
+        this.closed = closed;
+    }
 
-        } else if (proxy != null && !proxy.isIgnoredForHost(uri.getHost())) {
-            resolutions = request.getNameResolver().resolve(proxy.getHost());
-            port = uri.isSecured() ? proxy.getSecuredPort(): proxy.getPort();
+    private boolean pickNextRemoteAddress() {
+        i++;
+        return i < remoteAddresses.size();
+    }
 
-        } else {
-            resolutions = request.getNameResolver().resolve(uri.getHost());
-        }
+    public void connect(final Bootstrap bootstrap, final NettyConnectListener<?> connectListener) {
+        final InetSocketAddress remoteAddress = remoteAddresses.get(i);
 
         if (asyncHandlerExtensions != null)
-            asyncHandlerExtensions.onDnsResolved(resolutions);
-        
-        remoteAddresses = new InetSocketAddress[resolutions.length];
-        for (int i = 0; i < resolutions.length; i ++) {
-            remoteAddresses[i] = new InetSocketAddress(resolutions[i].address, port);
-        }
-        
-        if (request.getLocalAddress() != null) {
-            localAddress = new InetSocketAddress(request.getLocalAddress(), 0);
-                    
-        } else {
-            localAddress = null;
+            asyncHandlerExtensions.onTcpConnectAttempt(remoteAddress);
+
+        try {
+            connect0(bootstrap, connectListener, remoteAddress);
+        } catch (RejectedExecutionException e) {
+            if (closed.get()) {
+                connectListener.onFailure(null, e);
+            } else {
+                throw e;
+            }
         }
     }
 
-    private boolean pickNextRemoteAddress() {
-        i++;
-        return i < remoteAddresses.length;
-    }
-    
-    public void connect(final Bootstrap bootstrap, final ChannelFutureListener listener) throws UnknownHostException {
-        final InetSocketAddress remoteAddress = remoteAddresses[i];
+    private void connect0(Bootstrap bootstrap, final NettyConnectListener<?> connectListener, InetSocketAddress remoteAddress) {
+        final ChannelFuture future = bootstrap.connect(remoteAddress, localAddress);
 
-        ChannelFuture future = localAddress != null ? bootstrap.connect(remoteAddress, localAddress) : bootstrap.connect(remoteAddress);
+        future.addListener(new SimpleChannelFutureListener() {
 
-        future.addListener(new ChannelFutureListener() {
             @Override
-            public void operationComplete(ChannelFuture future) throws Exception {
-                boolean retry = false;
-                if (future.isSuccess()) {
-                    if (asyncHandlerExtensions != null)
-                        asyncHandlerExtensions.onConnectionSuccess(future.channel(), remoteAddress.getAddress());
-                } else {
-                    if (asyncHandlerExtensions != null)
-                        asyncHandlerExtensions.onConnectionFailure(remoteAddress.getAddress());
-                    retry = pickNextRemoteAddress();
+            public void onSuccess(Channel channel) {
+                if (asyncHandlerExtensions != null) {
+                    asyncHandlerExtensions.onTcpConnectSuccess(remoteAddress, future.channel());
                 }
+                timeoutsHolder.initRemoteAddress(remoteAddress);
+                connectListener.onSuccess(channel);
+            }
+
+            @Override
+            public void onFailure(Channel channel, Throwable t) {
+                if (asyncHandlerExtensions != null)
+                    asyncHandlerExtensions.onTcpConnectFailure(remoteAddress, t);
+                boolean retry = pickNextRemoteAddress();
                 if (retry)
-                    NettyChannelConnector.this.connect(bootstrap, listener);
+                    NettyChannelConnector.this.connect(bootstrap, connectListener);
                 else
-                    listener.operationComplete(future);
+                    connectListener.onFailure(channel, t);
             }
         });
     }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactory.java b/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactory.java
index 736490a19..4f87c32ea 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactory.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestFactory.java
@@ -13,25 +13,10 @@
  */
 package org.asynchttpclient.netty.request;
 
-import static io.netty.handler.codec.http.HttpHeaders.Names.ACCEPT;
-import static io.netty.handler.codec.http.HttpHeaders.Names.ACCEPT_ENCODING;
-import static io.netty.handler.codec.http.HttpHeaders.Names.AUTHORIZATION;
-import static io.netty.handler.codec.http.HttpHeaders.Names.CONNECTION;
-import static io.netty.handler.codec.http.HttpHeaders.Names.CONTENT_LENGTH;
-import static io.netty.handler.codec.http.HttpHeaders.Names.CONTENT_TYPE;
-import static io.netty.handler.codec.http.HttpHeaders.Names.COOKIE;
-import static io.netty.handler.codec.http.HttpHeaders.Names.HOST;
-import static io.netty.handler.codec.http.HttpHeaders.Names.ORIGIN;
-import static io.netty.handler.codec.http.HttpHeaders.Names.PROXY_AUTHORIZATION;
-import static io.netty.handler.codec.http.HttpHeaders.Names.SEC_WEBSOCKET_KEY;
-import static io.netty.handler.codec.http.HttpHeaders.Names.SEC_WEBSOCKET_VERSION;
-import static io.netty.handler.codec.http.HttpHeaders.Names.TRANSFER_ENCODING;
-import static io.netty.handler.codec.http.HttpHeaders.Names.UPGRADE;
-import static io.netty.handler.codec.http.HttpHeaders.Names.USER_AGENT;
+import static io.netty.handler.codec.http.HttpHeaders.Names.*;
+import static org.asynchttpclient.util.AuthenticatorUtils.*;
 import static org.asynchttpclient.util.HttpUtils.*;
-import static org.asynchttpclient.util.AuthenticatorUtils.perRequestAuthorizationHeader;
-import static org.asynchttpclient.util.AuthenticatorUtils.perRequestProxyAuthorizationHeader;
-import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
+import static org.asynchttpclient.util.MiscUtils.*;
 import static org.asynchttpclient.ws.WebSocketUtils.getKey;
 import io.netty.buffer.ByteBuf;
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
@@ -67,7 +52,7 @@
 public final class NettyRequestFactory {
 
     public static final String GZIP_DEFLATE = HttpHeaders.Values.GZIP + "," + HttpHeaders.Values.DEFLATE;
-    
+
     private final AsyncHttpClientConfig config;
 
     public NettyRequestFactory(AsyncHttpClientConfig config) {
@@ -78,7 +63,7 @@ private NettyBody body(Request request, boolean connect) {
         NettyBody nettyBody = null;
         if (!connect) {
 
-            Charset bodyCharset = request.getCharset() == null ? DEFAULT_CHARSET : request.getCharset();
+            Charset bodyCharset = withDefault(request.getCharset(), DEFAULT_CHARSET);
 
             if (request.getByteData() != null)
                 nettyBody = new NettyByteArrayBody(request.getByteData());
@@ -141,9 +126,7 @@ public NettyRequest newNettyRequest(Request request, boolean forceConnect, Proxy
         HttpMethod method = forceConnect ? HttpMethod.CONNECT : HttpMethod.valueOf(request.getMethod());
         boolean connect = method == HttpMethod.CONNECT;
 
-        boolean allowConnectionPooling = config.isKeepAlive();
-
-        HttpVersion httpVersion = !allowConnectionPooling || (connect && proxyServer.isForceHttp10()) ? HttpVersion.HTTP_1_0 : HttpVersion.HTTP_1_1;
+        HttpVersion httpVersion = HttpVersion.HTTP_1_1;
         String requestUri = requestUri(uri, proxyServer, connect);
 
         NettyBody body = body(request, connect);
@@ -170,7 +153,7 @@ public NettyRequest newNettyRequest(Request request, boolean forceConnect, Proxy
         if (connect) {
             // assign proxy-auth as configured on request
             headers.set(PROXY_AUTHORIZATION, request.getHeaders().getAll(PROXY_AUTHORIZATION));
-        
+
         } else {
             // assign headers as configured on request
             headers.set(request.getHeaders());
@@ -201,7 +184,7 @@ public NettyRequest newNettyRequest(Request request, boolean forceConnect, Proxy
                     .set(SEC_WEBSOCKET_VERSION, "13");
 
         } else if (!headers.contains(CONNECTION)) {
-            String connectionHeaderValue = connectionHeader(allowConnectionPooling, httpVersion == HttpVersion.HTTP_1_1);
+            String connectionHeaderValue = connectionHeader(config.isKeepAlive(), httpVersion);
             if (connectionHeaderValue != null)
                 headers.set(CONNECTION, connectionHeaderValue);
         }
@@ -223,7 +206,7 @@ public NettyRequest newNettyRequest(Request request, boolean forceConnect, Proxy
 
         return nettyRequest;
     }
-    
+
     private String requestUri(Uri uri, ProxyServer proxyServer, boolean connect) {
         if (connect)
             // proxy tunnelling, connect need host and explicit port
@@ -243,12 +226,11 @@ else if (proxyServer != null)
         }
     }
 
-    private String connectionHeader(boolean allowConnectionPooling, boolean http11) {
-        if (allowConnectionPooling)
-            return HttpHeaders.Values.KEEP_ALIVE;
-        else if (http11)
-            return HttpHeaders.Values.CLOSE;
-        else
-            return null;
+    private String connectionHeader(boolean keepAlive, HttpVersion httpVersion) {
+        if (httpVersion.isKeepAliveDefault()) {
+            return keepAlive ? null : HttpHeaders.Values.CLOSE;
+        } else {
+            return keepAlive ? HttpHeaders.Values.KEEP_ALIVE : null;
+        }
     }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestSender.java b/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestSender.java
index 7a97d19f9..0c3d2068a 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestSender.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/NettyRequestSender.java
@@ -13,30 +13,33 @@
  */
 package org.asynchttpclient.netty.request;
 
-import static org.asynchttpclient.util.Assertions.*;
+import static org.asynchttpclient.util.Assertions.assertNotNull;
 import static org.asynchttpclient.util.AuthenticatorUtils.*;
-import static org.asynchttpclient.util.HttpUtils.*;
+import static org.asynchttpclient.util.HttpConstants.Methods.*;
+import static org.asynchttpclient.util.MiscUtils.getCause;
 import static org.asynchttpclient.util.ProxyUtils.getProxyServer;
 import io.netty.bootstrap.Bootstrap;
 import io.netty.channel.Channel;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelProgressivePromise;
 import io.netty.handler.codec.http.DefaultHttpHeaders;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpMethod;
 import io.netty.handler.codec.http.HttpRequest;
-import io.netty.util.Timeout;
 import io.netty.util.Timer;
-import io.netty.util.TimerTask;
 
 import java.io.IOException;
-import java.util.concurrent.TimeUnit;
+import java.net.InetSocketAddress;
+import java.util.List;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import org.asynchttpclient.AsyncHandler;
 import org.asynchttpclient.AsyncHttpClientConfig;
 import org.asynchttpclient.ListenableFuture;
 import org.asynchttpclient.Realm;
-import org.asynchttpclient.Request;
 import org.asynchttpclient.Realm.AuthScheme;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.exception.RemotelyClosedException;
 import org.asynchttpclient.filter.FilterContext;
 import org.asynchttpclient.filter.FilterException;
 import org.asynchttpclient.filter.IOExceptionFilter;
@@ -44,14 +47,14 @@
 import org.asynchttpclient.handler.TransferCompletionHandler;
 import org.asynchttpclient.netty.Callback;
 import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.SimpleFutureListener;
 import org.asynchttpclient.netty.channel.ChannelManager;
 import org.asynchttpclient.netty.channel.ChannelState;
 import org.asynchttpclient.netty.channel.Channels;
 import org.asynchttpclient.netty.channel.NettyConnectListener;
-import org.asynchttpclient.netty.timeout.ReadTimeoutTimerTask;
-import org.asynchttpclient.netty.timeout.RequestTimeoutTimerTask;
 import org.asynchttpclient.netty.timeout.TimeoutsHolder;
 import org.asynchttpclient.proxy.ProxyServer;
+import org.asynchttpclient.resolver.RequestHostnameResolver;
 import org.asynchttpclient.uri.Uri;
 import org.asynchttpclient.ws.WebSocketUpgradeHandler;
 import org.slf4j.Logger;
@@ -103,17 +106,16 @@ public NettyRequestSender(AsyncHttpClientConfig config,//
             return sendRequestWithCertainForceConnect(request, asyncHandler, future, reclaimCache, proxyServer, false);
     }
 
-    private boolean isConnectDone(Request request,NettyResponseFuture<?> future) {
+    private boolean isConnectDone(Request request, NettyResponseFuture<?> future) {
         return future != null //
                 && future.getNettyRequest() != null //
                 && future.getNettyRequest().getHttpRequest().getMethod() == HttpMethod.CONNECT //
-                && !request.getMethod().equals(HttpMethod.CONNECT.name());
+                && !request.getMethod().equals(CONNECT);
     }
 
     /**
-     * We know for sure if we have to force to connect or not, so we can build
-     * the HttpRequest right away This reduces the probability of having a
-     * pooled channel closed by the server by the time we build the request
+     * We know for sure if we have to force to connect or not, so we can build the HttpRequest right away This reduces the probability of having a pooled channel closed by the
+     * server by the time we build the request
      */
     private <T> ListenableFuture<T> sendRequestWithCertainForceConnect(//
             Request request,//
@@ -134,9 +136,7 @@ private boolean isConnectDone(Request request,NettyResponseFuture<?> future) {
     }
 
     /**
-     * Using CONNECT depends on wither we can fetch a valid channel or not Loop
-     * until we get a valid channel from the pool and it's still valid once the
-     * request is built @
+     * Using CONNECT depends on wither we can fetch a valid channel or not Loop until we get a valid channel from the pool and it's still valid once the request is built @
      */
     @SuppressWarnings("unused")
     private <T> ListenableFuture<T> sendRequestThroughSslProxy(//
@@ -172,16 +172,16 @@ private boolean isConnectDone(Request request,NettyResponseFuture<?> future) {
         Realm realm = null;
         if (originalFuture != null) {
             realm = originalFuture.getRealm();
-        } else if (config.getRealm() != null ){
+        } else if (config.getRealm() != null) {
             realm = config.getRealm();
         } else {
             realm = request.getRealm();
         }
-        
+
         Realm proxyRealm = null;
         if (originalFuture != null) {
             proxyRealm = originalFuture.getProxyRealm();
-        } else if (proxy != null){
+        } else if (proxy != null) {
             proxyRealm = proxy.getRealm();
         }
 
@@ -212,6 +212,7 @@ private Channel getOpenChannel(NettyResponseFuture<?> future, Request request, P
         if (asyncHandler instanceof AsyncHandlerExtensions)
             AsyncHandlerExtensions.class.cast(asyncHandler).onConnectionPooled(channel);
 
+        scheduleRequestTimeout(future);
         future.setChannelState(ChannelState.POOLED);
         future.attachChannel(channel, false);
 
@@ -243,7 +244,7 @@ private Channel getOpenChannel(NettyResponseFuture<?> future, Request request, P
         Realm proxyRealm = future.getProxyRealm();
         requestFactory.addAuthorizationHeader(headers, perConnectionAuthorizationHeader(request, proxy, realm));
         requestFactory.setProxyAuthorizationHeader(headers, perConnectionProxyAuthorizationHeader(request, proxyRealm));
-        
+
         future.getInAuth().set(realm != null && realm.isUsePreemptiveAuth() && realm.getScheme() != AuthScheme.NTLM);
         future.getInProxyAuth().set(proxyRealm != null && proxyRealm.isUsePreemptiveAuth() && proxyRealm.getScheme() != AuthScheme.NTLM);
 
@@ -251,29 +252,42 @@ private Channel getOpenChannel(NettyResponseFuture<?> future, Request request, P
         // FIXME why? This violate the max connection per host handling, right?
         Bootstrap bootstrap = channelManager.getBootstrap(request.getUri(), proxy);
 
-        boolean channelPreempted = false;
         Object partitionKey = future.getPartitionKey();
 
+        final boolean channelPreempted = !reclaimCache;
+
         try {
             // Do not throw an exception when we need an extra connection for a
             // redirect.
-            if (!reclaimCache) {
+            if (channelPreempted) {
+                // if there's an exception here, channel wasn't preempted and resolve won't happen
                 channelManager.preemptChannel(partitionKey);
-                channelPreempted = true;
             }
+        } catch (Throwable t) {
+            abort(null, future, getCause(t));
+            // exit and don't try to resolve address
+            return future;
+        }
 
-            if (asyncHandler instanceof AsyncHandlerExtensions)
-                AsyncHandlerExtensions.class.cast(asyncHandler).onConnectionOpen();
+        scheduleRequestTimeout(future);
 
-            new NettyChannelConnector(request, proxy, asyncHandler)
-                .connect(bootstrap, new NettyConnectListener<T>(future, this, channelManager, channelPreempted, partitionKey));
+        RequestHostnameResolver.INSTANCE.resolve(request, proxy, asyncHandler)//
+                .addListener(new SimpleFutureListener<List<InetSocketAddress>>() {
 
-        } catch (Throwable t) {
-            if (channelPreempted)
-                channelManager.abortChannelPreemption(partitionKey);
+                    @Override
+                    protected void onSuccess(List<InetSocketAddress> addresses) {
+                        NettyConnectListener<T> connectListener = new NettyConnectListener<>(future, NettyRequestSender.this, channelManager, channelPreempted, partitionKey);
+                        new NettyChannelConnector(request.getLocalAddress(), addresses, asyncHandler, future.getTimeoutsHolder(), closed).connect(bootstrap, connectListener);
+                    }
 
-            abort(null, future, t.getCause() == null ? t : t.getCause());
-        }
+                    @Override
+                    protected void onFailure(Throwable cause) {
+                        if (channelPreempted) {
+                            channelManager.abortChannelPreemption(partitionKey);
+                        }
+                        abort(null, future, getCause(cause));
+                    }
+                });
 
         return future;
     }
@@ -285,7 +299,7 @@ private Channel getOpenChannel(NettyResponseFuture<?> future, Request request, P
                 asyncHandler,//
                 nettyRequest,//
                 config.getMaxRequestRetry(),//
-                request.getConnectionPoolPartitioning(),//
+                request.getChannelPoolPartitioning(),//
                 proxyServer);
 
         String expectHeader = request.getHeaders().get(HttpHeaders.Names.EXPECT);
@@ -310,19 +324,23 @@ private Channel getOpenChannel(NettyResponseFuture<?> future, Request request, P
             if (handler instanceof TransferCompletionHandler)
                 configureTransferAdapter(handler, httpRequest);
 
+            boolean writeBody = !future.isDontWriteBodyBecauseExpectContinue() && httpRequest.getMethod() != HttpMethod.CONNECT && nettyRequest.getBody() != null;
+
             if (!future.isHeadersAlreadyWrittenOnContinue()) {
                 if (future.getAsyncHandler() instanceof AsyncHandlerExtensions)
                     AsyncHandlerExtensions.class.cast(future.getAsyncHandler()).onRequestSend(nettyRequest);
 
-                channel.writeAndFlush(httpRequest, channel.newProgressivePromise()).addListener(new ProgressListener(future.getAsyncHandler(), future, true, 0L));
+                ChannelProgressivePromise promise = channel.newProgressivePromise();
+                ChannelFuture f = writeBody ? channel.write(httpRequest, promise) : channel.writeAndFlush(httpRequest, promise);
+                f.addListener(new ProgressListener(future.getAsyncHandler(), future, true, 0L));
             }
 
-            if (!future.isDontWriteBodyBecauseExpectContinue() && httpRequest.getMethod() != HttpMethod.CONNECT && nettyRequest.getBody() != null)
+            if (writeBody)
                 nettyRequest.getBody().write(channel, future);
 
-            // don't bother scheduling timeouts if channel became invalid
+            // don't bother scheduling read timeout if channel became invalid
             if (Channels.isChannelValid(channel))
-                scheduleTimeouts(future);
+                scheduleReadTimeout(future);
 
         } catch (Exception e) {
             LOGGER.error("Can't write request", e);
@@ -331,31 +349,24 @@ private Channel getOpenChannel(NettyResponseFuture<?> future, Request request, P
     }
 
     private void configureTransferAdapter(AsyncHandler<?> handler, HttpRequest httpRequest) {
-        HttpHeaders h = new DefaultHttpHeaders().set(httpRequest.headers());
+        HttpHeaders h = new DefaultHttpHeaders(false).set(httpRequest.headers());
         TransferCompletionHandler.class.cast(handler).headers(h);
     }
 
-    private void scheduleTimeouts(NettyResponseFuture<?> nettyResponseFuture) {
-
+    private void scheduleRequestTimeout(NettyResponseFuture<?> nettyResponseFuture) {
         nettyResponseFuture.touch();
-        int requestTimeoutInMs = requestTimeout(config, nettyResponseFuture.getTargetRequest());
-        TimeoutsHolder timeoutsHolder = new TimeoutsHolder();
-        if (requestTimeoutInMs != -1) {
-            Timeout requestTimeout = newTimeout(new RequestTimeoutTimerTask(nettyResponseFuture, this, timeoutsHolder, requestTimeoutInMs), requestTimeoutInMs);
-            timeoutsHolder.requestTimeout = requestTimeout;
-        }
-
-        int readTimeoutValue = config.getReadTimeout();
-        if (readTimeoutValue != -1 && readTimeoutValue < requestTimeoutInMs) {
-            // no need to schedule a readTimeout if the requestTimeout happens first
-            Timeout readTimeout = newTimeout(new ReadTimeoutTimerTask(nettyResponseFuture, this, timeoutsHolder, requestTimeoutInMs, readTimeoutValue), readTimeoutValue);
-            timeoutsHolder.readTimeout = readTimeout;
-        }
+        TimeoutsHolder timeoutsHolder = new TimeoutsHolder(nettyTimer, nettyResponseFuture, this, config);
         nettyResponseFuture.setTimeoutsHolder(timeoutsHolder);
     }
 
-    public Timeout newTimeout(TimerTask task, long delay) {
-        return nettyTimer.newTimeout(task, delay, TimeUnit.MILLISECONDS);
+    private void scheduleReadTimeout(NettyResponseFuture<?> nettyResponseFuture) {
+        TimeoutsHolder timeoutsHolder = nettyResponseFuture.getTimeoutsHolder();
+        if (timeoutsHolder != null) {
+            // on very fast requests, it's entirely possible that the response has already been completed
+            // by the time we try to schedule the read timeout
+            nettyResponseFuture.touch();
+            timeoutsHolder.startReadTimeout();
+        }
     }
 
     public void abort(Channel channel, NettyResponseFuture<?> future, Throwable t) {
@@ -372,11 +383,13 @@ public void abort(Channel channel, NettyResponseFuture<?> future, Throwable t) {
     }
 
     public void handleUnexpectedClosedChannel(Channel channel, NettyResponseFuture<?> future) {
-        if (future.isDone())
+        if (future.isDone()) {
             channelManager.closeChannel(channel);
-
-        else if (!retry(future))
-            abort(channel, future, REMOTELY_CLOSED_EXCEPTION);
+        } else if (retry(future)) {
+            future.pendingException = null;
+        } else {
+            abort(channel, future, future.pendingException != null? future.pendingException : RemotelyClosedException.INSTANCE);
+        }
     }
 
     public boolean retry(NettyResponseFuture<?> future) {
@@ -385,6 +398,7 @@ public boolean retry(NettyResponseFuture<?> future) {
             return false;
 
         if (future.canBeReplayed()) {
+            // FIXME should we set future.setReuseChannel(false); ?
             future.setChannelState(ChannelState.RECONNECTED);
             future.getAndSetStatusReceived(false);
 
@@ -430,6 +444,12 @@ public boolean applyIoExceptionFiltersAndReplayRequest(NettyResponseFuture<?> fu
     }
 
     public <T> void sendNextRequest(final Request request, final NettyResponseFuture<T> future) {
+        // remove attribute in case the channel gets closed so it doesn't try to recover the previous future
+        Channel channel = future.channel();
+        if (channel != null) {
+            // channel can be null when it was closed by the server before it could be set
+            Channels.setAttribute(channel, null);
+        }
         sendRequest(request, future.getAsyncHandler(), future, true);
     }
 
@@ -439,8 +459,8 @@ private void validateWebSocketRequest(Request request, AsyncHandler<?> asyncHand
         if (asyncHandler instanceof WebSocketUpgradeHandler) {
             if (!isWs)
                 throw new IllegalArgumentException("WebSocketUpgradeHandler but scheme isn't ws or wss: " + uri.getScheme());
-            else if (!request.getMethod().equals(HttpMethod.GET.name()))
-                throw new IllegalArgumentException("WebSocketUpgradeHandler but method isn't GET: " + request.getMethod());
+            else if (!request.getMethod().equals(GET) && !request.getMethod().equals(CONNECT))
+                throw new IllegalArgumentException("WebSocketUpgradeHandler but method isn't GET or CONNECT: " + request.getMethod());
         } else if (isWs) {
             throw new IllegalArgumentException("No WebSocketUpgradeHandler but scheme is " + uri.getScheme());
         }
@@ -449,11 +469,11 @@ else if (!request.getMethod().equals(HttpMethod.GET.name()))
     private Channel pollPooledChannel(Request request, ProxyServer proxy, AsyncHandler<?> asyncHandler) {
 
         if (asyncHandler instanceof AsyncHandlerExtensions)
-            AsyncHandlerExtensions.class.cast(asyncHandler).onConnectionPool();
+            AsyncHandlerExtensions.class.cast(asyncHandler).onConnectionPoolAttempt();
 
         Uri uri = request.getUri();
         String virtualHost = request.getVirtualHost();
-        final Channel channel = channelManager.poll(uri, virtualHost, proxy, request.getConnectionPoolPartitioning());
+        final Channel channel = channelManager.poll(uri, virtualHost, proxy, request.getChannelPoolPartitioning());
 
         if (channel != null) {
             LOGGER.debug("Using polled Channel {}\n for uri {}\n", channel, uri);
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/body/BodyChunkedInput.java b/client/src/main/java/org/asynchttpclient/netty/request/body/BodyChunkedInput.java
index b20281339..72acdfb01 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/body/BodyChunkedInput.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/body/BodyChunkedInput.java
@@ -28,19 +28,17 @@
     public static final int DEFAULT_CHUNK_SIZE = 8 * 1024;
 
     private final Body body;
-    private final int contentLength;
     private final int chunkSize;
-
     private boolean endOfInput;
 
     public BodyChunkedInput(Body body) {
         assertNotNull(body, "body");
         this.body = body;
-        contentLength = (int) body.getContentLength();
+        long contentLength = body.getContentLength();
         if (contentLength <= 0)
             chunkSize = DEFAULT_CHUNK_SIZE;
         else
-            chunkSize = Math.min(contentLength, DEFAULT_CHUNK_SIZE);
+            chunkSize = (int) Math.min(contentLength, (long) DEFAULT_CHUNK_SIZE);
     }
 
     @Override
@@ -52,16 +50,17 @@ public ByteBuf readChunk(ChannelHandlerContext ctx) throws Exception {
         ByteBuf buffer = ctx.alloc().buffer(chunkSize);
         Body.BodyState state = body.transferTo(buffer);
         switch (state) {
-            case STOP:
-                endOfInput = true;
-                return buffer;
-            case SUSPEND:
-                //this will suspend the stream in ChunkedWriteHandler
-                return null;
-            case CONTINUE:
-                return buffer;
-            default:
-                throw new IllegalStateException("Unknown state: " + state);
+        case STOP:
+            endOfInput = true;
+            return buffer;
+        case SUSPEND:
+            // this will suspend the stream in ChunkedWriteHandler
+            buffer.release();
+            return null;
+        case CONTINUE:
+            return buffer;
+        default:
+            throw new IllegalStateException("Unknown state: " + state);
         }
     }
 
diff --git a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyBodyBody.java b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyBodyBody.java
index bfa69a299..4f85296a5 100755
--- a/client/src/main/java/org/asynchttpclient/netty/request/body/NettyBodyBody.java
+++ b/client/src/main/java/org/asynchttpclient/netty/request/body/NettyBodyBody.java
@@ -29,8 +29,9 @@
 import org.asynchttpclient.request.body.Body;
 import org.asynchttpclient.request.body.RandomAccessBody;
 import org.asynchttpclient.request.body.generator.BodyGenerator;
-import org.asynchttpclient.request.body.generator.SimpleFeedableBodyGenerator;
-import org.asynchttpclient.request.body.generator.FeedableBodyGenerator.FeedListener;
+import org.asynchttpclient.request.body.generator.FeedListener;
+import org.asynchttpclient.request.body.generator.FeedableBodyGenerator;
+import org.asynchttpclient.request.body.generator.ReactiveStreamsBodyGenerator;
 
 public class NettyBodyBody implements NettyBody {
 
@@ -54,7 +55,7 @@ public long getContentLength() {
     @Override
     public String getContentType() {
         return null;
-    };
+    }
 
     @Override
     public void write(final Channel channel, NettyResponseFuture<?> future) throws IOException {
@@ -67,11 +68,12 @@ public void write(final Channel channel, NettyResponseFuture<?> future) throws I
             msg = new BodyChunkedInput(body);
 
             BodyGenerator bg = future.getTargetRequest().getBodyGenerator();
-            if (bg instanceof SimpleFeedableBodyGenerator) {
-                SimpleFeedableBodyGenerator.class.cast(bg).setListener(new FeedListener() {
+            if (bg instanceof FeedableBodyGenerator && !(bg instanceof ReactiveStreamsBodyGenerator)) {
+                final ChunkedWriteHandler chunkedWriteHandler = channel.pipeline().get(ChunkedWriteHandler.class);
+                FeedableBodyGenerator.class.cast(bg).setListener(new FeedListener() {
                     @Override
                     public void onContentAdded() {
-                        channel.pipeline().get(ChunkedWriteHandler.class).resumeTransfer();
+                        chunkedWriteHandler.resumeTransfer();
                     }
                     @Override
                     public void onError(Throwable t) {}
diff --git a/client/src/main/java/org/asynchttpclient/netty/ssl/JsseSslEngineFactory.java b/client/src/main/java/org/asynchttpclient/netty/ssl/JsseSslEngineFactory.java
index 6e5b190f3..aa05d0262 100644
--- a/client/src/main/java/org/asynchttpclient/netty/ssl/JsseSslEngineFactory.java
+++ b/client/src/main/java/org/asynchttpclient/netty/ssl/JsseSslEngineFactory.java
@@ -32,5 +32,4 @@ public SSLEngine newSslEngine(AsyncHttpClientConfig config, String peerHost, int
         configureSslEngine(sslEngine, config);
         return sslEngine;
     }
-
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/timeout/ReadTimeoutTimerTask.java b/client/src/main/java/org/asynchttpclient/netty/timeout/ReadTimeoutTimerTask.java
index 715afadf6..58b5d8981 100755
--- a/client/src/main/java/org/asynchttpclient/netty/timeout/ReadTimeoutTimerTask.java
+++ b/client/src/main/java/org/asynchttpclient/netty/timeout/ReadTimeoutTimerTask.java
@@ -22,17 +22,14 @@
 public class ReadTimeoutTimerTask extends TimeoutTimerTask {
 
     private final long readTimeout;
-    private final long requestTimeoutInstant;
 
     public ReadTimeoutTimerTask(//
             NettyResponseFuture<?> nettyResponseFuture,//
             NettyRequestSender requestSender,//
             TimeoutsHolder timeoutsHolder,//
-            long requestTimeout,//
             long readTimeout) {
         super(nettyResponseFuture, requestSender, timeoutsHolder);
         this.readTimeout = readTimeout;
-        requestTimeoutInstant = requestTimeout >= 0 ? nettyResponseFuture.getStart() + requestTimeout : Long.MAX_VALUE;
     }
 
     public void run(Timeout timeout) throws Exception {
@@ -52,20 +49,15 @@ public void run(Timeout timeout) throws Exception {
 
         if (durationBeforeCurrentReadTimeout <= 0L) {
             // idleConnectTimeout reached
-            String message = "Read timeout to " + remoteAddress + " of " + readTimeout + " ms";
+            String message = "Read timeout to " + timeoutsHolder.remoteAddress() + " after " + readTimeout + " ms";
             long durationSinceLastTouch = now - nettyResponseFuture.getLastTouch();
             expire(message, durationSinceLastTouch);
             // cancel request timeout sibling
             timeoutsHolder.cancel();
 
-        } else if (currentReadTimeoutInstant < requestTimeoutInstant) {
-            // reschedule
-            done.set(false);
-            timeoutsHolder.readTimeout = requestSender.newTimeout(this, durationBeforeCurrentReadTimeout);
-
         } else {
-            // otherwise, no need to reschedule: requestTimeout will happen sooner
-            timeoutsHolder.readTimeout = null;
+            done.set(false);
+            timeoutsHolder.startReadTimeout(this);
         }
     }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/timeout/RequestTimeoutTimerTask.java b/client/src/main/java/org/asynchttpclient/netty/timeout/RequestTimeoutTimerTask.java
index 42ba4f16b..a076d7143 100755
--- a/client/src/main/java/org/asynchttpclient/netty/timeout/RequestTimeoutTimerTask.java
+++ b/client/src/main/java/org/asynchttpclient/netty/timeout/RequestTimeoutTimerTask.java
@@ -43,7 +43,7 @@ public void run(Timeout timeout) throws Exception {
         if (nettyResponseFuture.isDone())
             return;
 
-        String message = "Request timed out to " + remoteAddress + " of " + requestTimeout + " ms";
+        String message = "Request timeout to " + timeoutsHolder.remoteAddress() + " after " + requestTimeout + "ms";
         long age = millisTime() - nettyResponseFuture.getStart();
         expire(message, age);
     }
diff --git a/client/src/main/java/org/asynchttpclient/netty/timeout/TimeoutTimerTask.java b/client/src/main/java/org/asynchttpclient/netty/timeout/TimeoutTimerTask.java
index 1c411a7fa..01777f857 100755
--- a/client/src/main/java/org/asynchttpclient/netty/timeout/TimeoutTimerTask.java
+++ b/client/src/main/java/org/asynchttpclient/netty/timeout/TimeoutTimerTask.java
@@ -15,7 +15,6 @@
 
 import io.netty.util.TimerTask;
 
-import java.net.SocketAddress;
 import java.util.concurrent.TimeoutException;
 import java.util.concurrent.atomic.AtomicBoolean;
 
@@ -32,15 +31,11 @@
     protected volatile NettyResponseFuture<?> nettyResponseFuture;
     protected final NettyRequestSender requestSender;
     protected final TimeoutsHolder timeoutsHolder;
-    protected final String remoteAddress;
 
     public TimeoutTimerTask(NettyResponseFuture<?> nettyResponseFuture, NettyRequestSender requestSender, TimeoutsHolder timeoutsHolder) {
         this.nettyResponseFuture = nettyResponseFuture;
         this.requestSender = requestSender;
         this.timeoutsHolder = timeoutsHolder;
-        // saving remote address as the channel might be removed from the future when an exception occurs
-        SocketAddress sa = nettyResponseFuture.getChannelRemoteAddress();
-        remoteAddress = sa != null ? sa.toString() : "not-connected";
     }
 
     protected void expire(String message, long time) {
@@ -53,7 +48,8 @@ protected void expire(String message, long time) {
      * Holding a reference to the future might mean holding a reference to the channel, and heavy objects such as SslEngines
      */
     public void clean() {
-        if (done.compareAndSet(false, true))
+        if (done.compareAndSet(false, true)) {
             nettyResponseFuture = null;
+        }
     }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/timeout/TimeoutsHolder.java b/client/src/main/java/org/asynchttpclient/netty/timeout/TimeoutsHolder.java
index 6d424c23b..ae720e3df 100755
--- a/client/src/main/java/org/asynchttpclient/netty/timeout/TimeoutsHolder.java
+++ b/client/src/main/java/org/asynchttpclient/netty/timeout/TimeoutsHolder.java
@@ -13,28 +13,97 @@
  */
 package org.asynchttpclient.netty.timeout;
 
+import static org.asynchttpclient.util.DateUtils.millisTime;
 import io.netty.util.Timeout;
+import io.netty.util.Timer;
+import io.netty.util.TimerTask;
 
+import java.net.InetSocketAddress;
+import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.netty.NettyResponseFuture;
+import org.asynchttpclient.netty.request.NettyRequestSender;
+
 public class TimeoutsHolder {
 
     private final AtomicBoolean cancelled = new AtomicBoolean();
-    public volatile Timeout requestTimeout;
+
+    private final Timer nettyTimer;
+    private final NettyRequestSender requestSender;
+    private final long requestTimeoutMillisTime;
+    private final int readTimeoutValue;
+
+    private volatile NettyResponseFuture<?> nettyResponseFuture;
+    public final Timeout requestTimeout;
     public volatile Timeout readTimeout;
+    private volatile String remoteAddress = "not-connected";
+
+    public TimeoutsHolder(Timer nettyTimer, NettyResponseFuture<?> nettyResponseFuture, NettyRequestSender requestSender, AsyncHttpClientConfig config) {
+        this.nettyTimer = nettyTimer;
+        this.nettyResponseFuture = nettyResponseFuture;
+        this.requestSender = requestSender;
+        this.readTimeoutValue = config.getReadTimeout();
+
+        int requestTimeoutInMs = nettyResponseFuture.getTargetRequest().getRequestTimeout();
+        if (requestTimeoutInMs == 0) {
+            requestTimeoutInMs = config.getRequestTimeout();
+        }
+
+        if (requestTimeoutInMs != -1) {
+            requestTimeoutMillisTime = millisTime() + requestTimeoutInMs;
+            requestTimeout = newTimeout(new RequestTimeoutTimerTask(nettyResponseFuture, requestSender, this, requestTimeoutInMs), requestTimeoutInMs);
+        } else {
+            requestTimeoutMillisTime = -1L;
+            requestTimeout = null;
+        }
+    }
+
+    public void initRemoteAddress(InetSocketAddress address) {
+        remoteAddress = address.toString();
+    }
+
+    public void startReadTimeout() {
+        if (readTimeoutValue != -1) {
+            startReadTimeout(null);
+        }
+    }
+
+    void startReadTimeout(ReadTimeoutTimerTask task) {
+        if (requestTimeout == null || (!requestTimeout.isExpired() && readTimeoutValue > (requestTimeoutMillisTime - millisTime()))) {
+            // only schedule a new readTimeout if the requestTimeout doesn't happen first
+            if (task == null) {
+                // first call triggered from outside (else is read timeout is re-scheduling itself)
+                task = new ReadTimeoutTimerTask(nettyResponseFuture, requestSender, this, readTimeoutValue);
+            }
+            Timeout readTimeout = newTimeout(task, readTimeoutValue);
+            this.readTimeout = readTimeout;
+
+        } else if (task != null) {
+            // read timeout couldn't re-scheduling itself, clean up
+            task.clean();
+        }
+    }
 
     public void cancel() {
         if (cancelled.compareAndSet(false, true)) {
             if (requestTimeout != null) {
                 requestTimeout.cancel();
                 RequestTimeoutTimerTask.class.cast(requestTimeout.task()).clean();
-                requestTimeout = null;
             }
             if (readTimeout != null) {
                 readTimeout.cancel();
                 ReadTimeoutTimerTask.class.cast(readTimeout.task()).clean();
-                readTimeout = null;
             }
         }
     }
+
+    private Timeout newTimeout(TimerTask task, long delay) {
+        return nettyTimer.newTimeout(task, delay, TimeUnit.MILLISECONDS);
+    }
+    
+    String remoteAddress() {
+        return remoteAddress;
+    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/netty/util/ByteBufUtils.java b/client/src/main/java/org/asynchttpclient/netty/util/ByteBufUtils.java
deleted file mode 100755
index dc803e728..000000000
--- a/client/src/main/java/org/asynchttpclient/netty/util/ByteBufUtils.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Copyright 2010 Ning, Inc.
- *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package org.asynchttpclient.netty.util;
-
-import io.netty.buffer.ByteBuf;
-
-import java.util.List;
-
-public final class ByteBufUtils {
-
-    public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
-
-    private ByteBufUtils() {
-    }
-
-    public static byte[] byteBuf2Bytes(ByteBuf buf) {
-        int readable = buf.readableBytes();
-        int readerIndex = buf.readerIndex();
-        if (buf.hasArray()) {
-            byte[] array = buf.array();
-            if (buf.arrayOffset() == 0 && readerIndex == 0 && array.length == readable) {
-                return array;
-            }
-        }
-        byte[] array = new byte[readable];
-        buf.getBytes(readerIndex, array);
-        return array;
-    }
-
-    public static byte[] byteBufs2Bytes(List<ByteBuf> bufs) {
-
-        if (bufs.isEmpty()) {
-            return EMPTY_BYTE_ARRAY;
-
-        } else if (bufs.size() == 1) {
-            return byteBuf2Bytes(bufs.get(0));
-
-        } else {
-            int totalSize = 0;
-            for (ByteBuf buf : bufs) {
-                totalSize += buf.readableBytes();
-            }
-
-            byte[] bytes = new byte[totalSize];
-            int offset = 0;
-            for (ByteBuf buf : bufs) {
-                int readable = buf.readableBytes();
-                buf.getBytes(buf.readerIndex(), bytes, offset, readable);
-                offset += readable;
-            }
-            return bytes;
-        }
-    }
-}
diff --git a/client/src/main/java/org/asynchttpclient/ntlm/NtlmEngine.java b/client/src/main/java/org/asynchttpclient/ntlm/NtlmEngine.java
index 4d45f7485..31e81f209 100644
--- a/client/src/main/java/org/asynchttpclient/ntlm/NtlmEngine.java
+++ b/client/src/main/java/org/asynchttpclient/ntlm/NtlmEngine.java
@@ -795,7 +795,7 @@ protected int getPreambleLength() {
         }
 
         /** Get the message length */
-        protected int getMessageLength() {
+        protected final int getMessageLength() {
             return currentOutputPosition;
         }
 
@@ -808,7 +808,7 @@ protected byte readByte(final int position) throws NtlmEngineException {
         }
 
         /** Read a bunch of bytes from a position in the message buffer */
-        protected void readBytes(final byte[] buffer, final int position) throws NtlmEngineException {
+        protected final void readBytes(final byte[] buffer, final int position) throws NtlmEngineException {
             if (messageContents.length < position + buffer.length) {
                 throw new NtlmEngineException("NTLM: Message too short");
             }
@@ -821,12 +821,12 @@ protected int readUShort(final int position) throws NtlmEngineException {
         }
 
         /** Read a ulong from a position within the message buffer */
-        protected int readULong(final int position) throws NtlmEngineException {
+        protected final int readULong(final int position) throws NtlmEngineException {
             return NtlmEngine.readULong(messageContents, position);
         }
 
         /** Read a security buffer from a position within the message buffer */
-        protected byte[] readSecurityBuffer(final int position) throws NtlmEngineException {
+        protected final byte[] readSecurityBuffer(final int position) throws NtlmEngineException {
             return NtlmEngine.readSecurityBuffer(messageContents, position);
         }
 
diff --git a/client/src/main/java/org/asynchttpclient/proxy/ProxyServer.java b/client/src/main/java/org/asynchttpclient/proxy/ProxyServer.java
index a8a4f06fe..905ba9f60 100644
--- a/client/src/main/java/org/asynchttpclient/proxy/ProxyServer.java
+++ b/client/src/main/java/org/asynchttpclient/proxy/ProxyServer.java
@@ -35,15 +35,13 @@
     private final int securedPort;
     private final Realm realm;
     private final List<String> nonProxyHosts;
-    private final boolean forceHttp10;
 
-    public ProxyServer(String host, int port, int securedPort, Realm realm, List<String> nonProxyHosts, boolean forceHttp10) {
+    public ProxyServer(String host, int port, int securedPort, Realm realm, List<String> nonProxyHosts) {
         this.host = host;
         this.port = port;
         this.securedPort = securedPort;
         this.realm = realm;
         this.nonProxyHosts = nonProxyHosts;
-        this.forceHttp10 = forceHttp10;
     }
 
     public String getHost() {
@@ -62,18 +60,13 @@ public int getSecuredPort() {
         return nonProxyHosts;
     }
 
-    public boolean isForceHttp10() {
-        return forceHttp10;
-    }
-
     public Realm getRealm() {
         return realm;
     }
 
     /**
-     * Checks whether proxy should be used according to nonProxyHosts settings of it, or we want to go directly to
-     * target host. If <code>null</code> proxy is passed in, this method returns true -- since there is NO proxy, we
-     * should avoid to use it. Simple hostname pattern matching using "*" are supported, but only as prefixes.
+     * Checks whether proxy should be used according to nonProxyHosts settings of it, or we want to go directly to target host. If <code>null</code> proxy is passed in, this method
+     * returns true -- since there is NO proxy, we should avoid to use it. Simple hostname pattern matching using "*" are supported, but only as prefixes.
      * 
      * @param hostname the hostname
      * @return true if we have to ignore proxy use (obeying non-proxy hosts settings), false otherwise.
@@ -90,21 +83,19 @@ public boolean isIgnoredForHost(String hostname) {
 
         return false;
     }
-    
+
     private boolean matchNonProxyHost(String targetHost, String nonProxyHost) {
 
         if (nonProxyHost.length() > 1) {
             if (nonProxyHost.charAt(0) == '*') {
-                return targetHost.regionMatches(true, targetHost.length() - nonProxyHost.length() + 1, nonProxyHost, 1,
-                        nonProxyHost.length() - 1);
+                return targetHost.regionMatches(true, targetHost.length() - nonProxyHost.length() + 1, nonProxyHost, 1, nonProxyHost.length() - 1);
             } else if (nonProxyHost.charAt(nonProxyHost.length() - 1) == '*')
                 return targetHost.regionMatches(true, 0, nonProxyHost, 0, nonProxyHost.length() - 1);
         }
 
         return nonProxyHost.equalsIgnoreCase(targetHost);
     }
-    
-    
+
     public static class Builder {
 
         private String host;
@@ -112,7 +103,6 @@ private boolean matchNonProxyHost(String targetHost, String nonProxyHost) {
         private int securedPort;
         private Realm realm;
         private List<String> nonProxyHosts;
-        private boolean forceHttp10;
 
         public Builder(String host, int port) {
             this.host = host;
@@ -130,26 +120,26 @@ public Builder setRealm(Realm realm) {
             return this;
         }
 
+        public Builder setRealm(Realm.Builder realm) {
+            this.realm = realm.build();
+            return this;
+        }
+
         public Builder setNonProxyHost(String nonProxyHost) {
             if (nonProxyHosts == null)
                 nonProxyHosts = new ArrayList<String>(1);
             nonProxyHosts.add(nonProxyHost);
             return this;
         }
-        
+
         public Builder setNonProxyHosts(List<String> nonProxyHosts) {
             this.nonProxyHosts = nonProxyHosts;
             return this;
         }
 
-        public Builder setForceHttp10(boolean forceHttp10) {
-            this.forceHttp10 = forceHttp10;
-            return this;
-        }
-
         public ProxyServer build() {
             List<String> nonProxyHosts = this.nonProxyHosts != null ? Collections.unmodifiableList(this.nonProxyHosts) : Collections.emptyList();
-            return new ProxyServer(host, port, securedPort, realm, nonProxyHosts, forceHttp10);
+            return new ProxyServer(host, port, securedPort, realm, nonProxyHosts);
         }
     }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/BodyChunk.java b/client/src/main/java/org/asynchttpclient/request/body/generator/BodyChunk.java
new file mode 100644
index 000000000..1707132cc
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/BodyChunk.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.request.body.generator;
+
+import java.nio.ByteBuffer;
+
+public final class BodyChunk {
+    public final boolean last;
+    public final ByteBuffer buffer;
+
+    public BodyChunk(final ByteBuffer buffer, final boolean last) {
+        this.buffer = buffer;
+        this.last = last;
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/BoundedQueueFeedableBodyGenerator.java b/client/src/main/java/org/asynchttpclient/request/body/generator/BoundedQueueFeedableBodyGenerator.java
new file mode 100644
index 000000000..ff6ca2627
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/BoundedQueueFeedableBodyGenerator.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.request.body.generator;
+
+import java.util.concurrent.ArrayBlockingQueue;
+import java.util.concurrent.BlockingQueue;
+
+public final class BoundedQueueFeedableBodyGenerator extends QueueBasedFeedableBodyGenerator<BlockingQueue<BodyChunk>> {
+
+    public BoundedQueueFeedableBodyGenerator(int capacity) {
+        super(new ArrayBlockingQueue<>(capacity, true));
+    }
+
+    @Override
+    protected boolean offer(BodyChunk chunk) throws InterruptedException {
+        return queue.offer(chunk);
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/FeedListener.java b/client/src/main/java/org/asynchttpclient/request/body/generator/FeedListener.java
new file mode 100644
index 000000000..63c0c0262
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/FeedListener.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.request.body.generator;
+
+public interface FeedListener {
+    void onContentAdded();
+
+    void onError(Throwable t);
+}
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/FeedableBodyGenerator.java b/client/src/main/java/org/asynchttpclient/request/body/generator/FeedableBodyGenerator.java
index 1921b1b5b..5eea210b4 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/generator/FeedableBodyGenerator.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/FeedableBodyGenerator.java
@@ -17,15 +17,11 @@
 
 /**
  * {@link BodyGenerator} which may return just part of the payload at the time handler is requesting it.
- * If it happens, PartialBodyGenerator becomes responsible for finishing payload transferring asynchronously.
+ * If it happens, client becomes responsible for providing the rest of the chunks.
  */
 public interface FeedableBodyGenerator extends BodyGenerator {
-    void feed(ByteBuffer buffer, boolean isLast);
 
-    void setListener(FeedListener listener);
+    boolean feed(ByteBuffer buffer, boolean isLast) throws Exception;
 
-    interface FeedListener {
-        void onContentAdded();
-        void onError(Throwable t);
-    }
+    void setListener(FeedListener listener);
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/PushBody.java b/client/src/main/java/org/asynchttpclient/request/body/generator/PushBody.java
new file mode 100644
index 000000000..c61ce5411
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/PushBody.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.request.body.generator;
+
+import io.netty.buffer.ByteBuf;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.Queue;
+
+import org.asynchttpclient.request.body.Body;
+
+public final class PushBody implements Body {
+
+    private final Queue<BodyChunk> queue;
+    private BodyState state = BodyState.CONTINUE;
+
+    public PushBody(Queue<BodyChunk> queue) {
+        this.queue = queue;
+    }
+
+    @Override
+    public long getContentLength() {
+        return -1;
+    }
+
+    @Override
+    public BodyState transferTo(final ByteBuf target) throws IOException {
+        switch (state) {
+        case CONTINUE:
+            return readNextChunk(target);
+        case STOP:
+            return BodyState.STOP;
+        default:
+            throw new IllegalStateException("Illegal process state.");
+        }
+    }
+
+    private BodyState readNextChunk(ByteBuf target) throws IOException {
+        BodyState res = BodyState.SUSPEND;
+        while (target.isWritable() && state != BodyState.STOP) {
+            BodyChunk nextChunk = queue.peek();
+            if (nextChunk == null) {
+                // Nothing in the queue. suspend stream if nothing was read. (reads == 0)
+                return res;
+            } else if (!nextChunk.buffer.hasRemaining() && !nextChunk.last) {
+                // skip empty buffers
+                queue.remove();
+            } else {
+                res = BodyState.CONTINUE;
+                readChunk(target, nextChunk);
+            }
+        }
+        return res;
+    }
+
+    private void readChunk(ByteBuf target, BodyChunk part) {
+        move(target, part.buffer);
+
+        if (!part.buffer.hasRemaining()) {
+            if (part.last) {
+                state = BodyState.STOP;
+            }
+            queue.remove();
+        }
+    }
+
+    private void move(ByteBuf target, ByteBuffer source) {
+        int size = Math.min(target.writableBytes(), source.remaining());
+        if (size > 0) {
+            ByteBuffer slice = source.slice();
+            slice.limit(size);
+            target.writeBytes(slice);
+            source.position(source.position() + size);
+        }
+    }
+
+    @Override
+    public void close() {
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/QueueBasedFeedableBodyGenerator.java b/client/src/main/java/org/asynchttpclient/request/body/generator/QueueBasedFeedableBodyGenerator.java
new file mode 100644
index 000000000..06acfcbf4
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/QueueBasedFeedableBodyGenerator.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.request.body.generator;
+
+import java.nio.ByteBuffer;
+import java.util.Queue;
+
+import org.asynchttpclient.request.body.Body;
+
+public abstract class QueueBasedFeedableBodyGenerator<T extends Queue<BodyChunk>> implements FeedableBodyGenerator {
+
+    protected final T queue;
+    private FeedListener listener;
+
+    public QueueBasedFeedableBodyGenerator(T queue) {
+        this.queue = queue;
+    }
+
+    @Override
+    public Body createBody() {
+        return new PushBody(queue);
+    }
+
+    protected abstract boolean offer(BodyChunk chunk) throws Exception;
+
+    @Override
+    public boolean feed(final ByteBuffer buffer, final boolean isLast) throws Exception {
+        boolean offered = offer(new BodyChunk(buffer, isLast));
+        if (offered && listener != null) {
+            listener.onContentAdded();
+        }
+        return offered;
+    }
+
+    @Override
+    public void setListener(FeedListener listener) {
+        this.listener = listener;
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/ReactiveStreamsBodyGenerator.java b/client/src/main/java/org/asynchttpclient/request/body/generator/ReactiveStreamsBodyGenerator.java
index efddc0b73..f36d9beff 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/generator/ReactiveStreamsBodyGenerator.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/ReactiveStreamsBodyGenerator.java
@@ -17,7 +17,6 @@
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicReference;
 
 import org.asynchttpclient.request.body.Body;
 import org.reactivestreams.Publisher;
@@ -31,11 +30,11 @@
 
     private final Publisher<ByteBuffer> publisher;
     private final FeedableBodyGenerator feedableBodyGenerator;
-    private final AtomicReference<FeedListener> feedListener = new AtomicReference<>(null);
+    private volatile FeedListener feedListener;
 
     public ReactiveStreamsBodyGenerator(Publisher<ByteBuffer> publisher) {
         this.publisher = publisher;
-        this.feedableBodyGenerator = new SimpleFeedableBodyGenerator();
+        this.feedableBodyGenerator = new UnboundedQueueFeedableBodyGenerator();
     }
 
     public Publisher<ByteBuffer> getPublisher() {
@@ -43,13 +42,13 @@ public ReactiveStreamsBodyGenerator(Publisher<ByteBuffer> publisher) {
     }
 
     @Override
-    public void feed(ByteBuffer buffer, boolean isLast) {
-        feedableBodyGenerator.feed(buffer, isLast);
+    public boolean feed(ByteBuffer buffer, boolean isLast) throws Exception {
+        return feedableBodyGenerator.feed(buffer, isLast);
     }
 
     @Override
     public void setListener(FeedListener listener) {
-        feedListener.set(listener);
+        feedListener = listener;
         feedableBodyGenerator.setListener(listener);
     }
 
@@ -81,7 +80,7 @@ public long getContentLength() {
 
         @Override
         public BodyState transferTo(ByteBuf target) throws IOException {
-            if(initialized.compareAndSet(false, true))
+            if (initialized.compareAndSet(false, true))
                 publisher.subscribe(subscriber);
 
             return body.transferTo(target);
@@ -101,21 +100,22 @@ public SimpleSubscriber(FeedableBodyGenerator feeder) {
 
         @Override
         public void onSubscribe(Subscription s) {
-            if (s == null) throw null;
+            if (s == null)
+                throw null;
 
             // If someone has made a mistake and added this Subscriber multiple times, let's handle it gracefully
-            if (this.subscription != null) { 
+            if (this.subscription != null) {
                 s.cancel(); // Cancel the additional subscription
-            }
-            else {
-              subscription = s;
-              subscription.request(Long.MAX_VALUE);
+            } else {
+                subscription = s;
+                subscription.request(Long.MAX_VALUE);
             }
         }
 
         @Override
         public void onNext(ByteBuffer t) {
-            if (t == null) throw null;
+            if (t == null)
+                throw null;
             try {
                 feeder.feed(t, false);
             } catch (Exception e) {
@@ -126,18 +126,19 @@ public void onNext(ByteBuffer t) {
 
         @Override
         public void onError(Throwable t) {
-            if (t == null) throw null;
+            if (t == null)
+                throw null;
             LOGGER.debug("Error occurred while consuming body stream.", t);
-            FeedListener listener = feedListener.get();
-            if(listener != null) listener.onError(t);
+            FeedListener listener = feedListener;
+            if (listener != null)
+                listener.onError(t);
         }
 
         @Override
         public void onComplete() {
             try {
-              feeder.feed(EMPTY, true);
-            } 
-            catch (Exception e) {
+                feeder.feed(EMPTY, true);
+            } catch (Exception e) {
                 LOGGER.info("Ignoring exception occurred while completing stream processing.", e);
                 this.subscription.cancel();
             }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/generator/SimpleFeedableBodyGenerator.java b/client/src/main/java/org/asynchttpclient/request/body/generator/SimpleFeedableBodyGenerator.java
deleted file mode 100755
index 279b2771c..000000000
--- a/client/src/main/java/org/asynchttpclient/request/body/generator/SimpleFeedableBodyGenerator.java
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * Copyright (c) 2014 AsyncHttpClient Project. All rights reserved.
- *
- * This program is licensed to you under the Apache License Version 2.0,
- * and you may not use this file except in compliance with the Apache License Version 2.0.
- * You may obtain a copy of the Apache License Version 2.0 at
- *     http://www.apache.org/licenses/LICENSE-2.0.
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the Apache License Version 2.0 is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
- */
-package org.asynchttpclient.request.body.generator;
-
-import io.netty.buffer.ByteBuf;
-
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.util.Queue;
-import java.util.concurrent.ConcurrentLinkedQueue;
-
-import org.asynchttpclient.request.body.Body;
-
-public final class SimpleFeedableBodyGenerator implements FeedableBodyGenerator, BodyGenerator {
-    private final Queue<BodyPart> queue = new ConcurrentLinkedQueue<>();
-    private FeedListener listener;
-
-    @Override
-    public Body createBody() {
-        return new PushBody();
-    }
-
-    @Override
-    public void feed(final ByteBuffer buffer, final boolean isLast) {
-        queue.offer(new BodyPart(buffer, isLast));
-        if (listener != null) {
-            listener.onContentAdded();
-        }
-    }
-
-    @Override
-    public void setListener(FeedListener listener) {
-        this.listener = listener;
-    }
-
-    public final class PushBody implements Body {
-
-        private BodyState state = BodyState.CONTINUE;
-
-        @Override
-        public long getContentLength() {
-            return -1;
-        }
-
-        @Override
-        public BodyState transferTo(final ByteBuf target) throws IOException {
-            switch (state) {
-                case CONTINUE:
-                    return readNextPart(target);
-                case STOP:
-                    return BodyState.STOP;
-                default:
-                    throw new IllegalStateException("Illegal process state.");
-            }
-        }
-
-        private BodyState readNextPart(ByteBuf target) throws IOException {
-            BodyState res = BodyState.SUSPEND;
-            while (target.isWritable() && state != BodyState.STOP) {
-                BodyPart nextPart = queue.peek();
-                if (nextPart == null) {
-                    // Nothing in the queue. suspend stream if nothing was read. (reads == 0)
-                    return res;
-                } else if (!nextPart.buffer.hasRemaining() && !nextPart.isLast) {
-                    // skip empty buffers
-                    queue.remove();
-                } else {
-                    res = BodyState.CONTINUE;
-                    readBodyPart(target, nextPart);
-                }
-            }
-            return res;
-        }
-
-        private void readBodyPart(ByteBuf target, BodyPart part) {
-            move(target, part.buffer);
-
-            if (!part.buffer.hasRemaining()) {
-                if (part.isLast) {
-                    state = BodyState.STOP;
-                }
-                queue.remove();
-            }
-        }
-
-        @Override
-        public void close() {
-        }
-    }
-
-    private void move(ByteBuf target, ByteBuffer source) {
-        int size = Math.min(target.writableBytes(), source.remaining());
-        if (size > 0) {
-            ByteBuffer slice = source.slice();
-            slice.limit(size);
-            target.writeBytes(slice);
-            source.position(source.position() + size);
-        }
-    }
-
-    private final class BodyPart {
-        private final boolean isLast;
-        private final ByteBuffer buffer;
-
-        public BodyPart(final ByteBuffer buffer, final boolean isLast) {
-            this.buffer = buffer;
-            this.isLast = isLast;
-        }
-    }
-}
diff --git a/client/src/main/java/org/asynchttpclient/netty/NettyResponseBodyPart.java b/client/src/main/java/org/asynchttpclient/request/body/generator/UnboundedQueueFeedableBodyGenerator.java
similarity index 63%
rename from client/src/main/java/org/asynchttpclient/netty/NettyResponseBodyPart.java
rename to client/src/main/java/org/asynchttpclient/request/body/generator/UnboundedQueueFeedableBodyGenerator.java
index 9c375b328..d76ae9d03 100755
--- a/client/src/main/java/org/asynchttpclient/netty/NettyResponseBodyPart.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/generator/UnboundedQueueFeedableBodyGenerator.java
@@ -11,26 +11,18 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.netty;
+package org.asynchttpclient.request.body.generator;
 
-import org.asynchttpclient.HttpResponseBodyPart;
+import java.util.concurrent.ConcurrentLinkedQueue;
 
-/**
- * A callback class used when an HTTP response body is received.
- */
-public abstract class NettyResponseBodyPart implements HttpResponseBodyPart {
-
-    private final boolean last;
+public final class UnboundedQueueFeedableBodyGenerator extends QueueBasedFeedableBodyGenerator<ConcurrentLinkedQueue<BodyChunk>> {
 
-    public NettyResponseBodyPart(boolean last) {
-        this.last = last;
+    public UnboundedQueueFeedableBodyGenerator() {
+        super(new ConcurrentLinkedQueue<>());
     }
 
-    /**
-     * {@inheritDoc}
-     */
     @Override
-    public boolean isLast() {
-        return last;
+    protected boolean offer(BodyChunk chunk) throws Exception {
+        return queue.offer(chunk);
     }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/FileLikePart.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/FileLikePart.java
index 069e8189b..1fc7b1450 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/FileLikePart.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/FileLikePart.java
@@ -12,6 +12,9 @@
  */
 package org.asynchttpclient.request.body.multipart;
 
+import static org.asynchttpclient.util.MiscUtils.withDefault;
+import static io.netty.handler.codec.http.HttpHeaders.Values.*;
+
 import java.nio.charset.Charset;
 
 /**
@@ -24,11 +27,6 @@
      */
     public static final String DEFAULT_CONTENT_TYPE = "application/octet-stream";
 
-    /**
-     * Default transfer encoding of file attachments.
-     */
-    public static final String DEFAULT_TRANSFER_ENCODING = "binary";
-
     private String fileName;
 
     /**
@@ -42,13 +40,13 @@
      */
     public FileLikePart(String name, String contentType, Charset charset, String contentId, String transfertEncoding) {
         super(name,//
-                contentType == null ? DEFAULT_CONTENT_TYPE : contentType,//
+                withDefault(contentType, DEFAULT_CONTENT_TYPE),//
                 charset,//
                 contentId,//
-                transfertEncoding == null ? DEFAULT_TRANSFER_ENCODING : transfertEncoding);
+                withDefault(transfertEncoding, BINARY));
     }
 
-    public void setFileName(String fileName) {
+    public final void setFileName(String fileName) {
         this.fileName = fileName;
     }
 
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/MultipartUtils.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/MultipartUtils.java
index 784e714f3..75d2f1f1b 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/MultipartUtils.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/MultipartUtils.java
@@ -14,6 +14,7 @@
 package org.asynchttpclient.request.body.multipart;
 
 import static java.nio.charset.StandardCharsets.US_ASCII;
+import static io.netty.handler.codec.http.HttpHeaders.Values.*;
 import static org.asynchttpclient.util.Assertions.assertNotNull;
 import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 import io.netty.handler.codec.http.HttpHeaders;
@@ -30,11 +31,6 @@
 
 public class MultipartUtils {
 
-    /**
-     * The Content-Type for multipart/form-data.
-     */
-    private static final String MULTIPART_FORM_CONTENT_TYPE = "multipart/form-data";
-
     /**
      * The pool of ASCII chars to be used for generating a multipart boundary.
      */
@@ -67,7 +63,7 @@ public static MultipartBody newMultipartBody(List<Part> parts, HttpHeaders reque
             }
         } else {
             boundary = generateBoundary();
-            contentType = computeContentType(MULTIPART_FORM_CONTENT_TYPE, boundary);
+            contentType = computeContentType(MULTIPART_FORM_DATA, boundary);
         }
 
         List<MultipartPart<? extends Part>> multipartParts = generateMultipartParts(parts, boundary);
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/StringPart.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/StringPart.java
index e53fcf6ed..07bf8307d 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/StringPart.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/StringPart.java
@@ -12,8 +12,9 @@
  */
 package org.asynchttpclient.request.body.multipart;
 
-import static java.nio.charset.StandardCharsets.US_ASCII;
+import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.asynchttpclient.util.Assertions.assertNotNull;
+import static org.asynchttpclient.util.MiscUtils.withDefault;
 
 import java.nio.charset.Charset;
 
@@ -27,7 +28,7 @@
     /**
      * Default charset of string parameters
      */
-    public static final Charset DEFAULT_CHARSET = US_ASCII;
+    public static final Charset DEFAULT_CHARSET = UTF_8;
 
     /**
      * Default transfer encoding of string parameters
@@ -40,15 +41,15 @@
     private final String value;
 
     private static Charset charsetOrDefault(Charset charset) {
-        return charset == null ? DEFAULT_CHARSET : charset;
+        return withDefault(charset, DEFAULT_CHARSET);
     }
 
     private static String contentTypeOrDefault(String contentType) {
-        return contentType == null ? DEFAULT_CONTENT_TYPE : contentType;
+        return withDefault(contentType, DEFAULT_CONTENT_TYPE);
     }
 
     private static String transferEncodingOrDefault(String transferEncoding) {
-        return transferEncoding == null ? DEFAULT_TRANSFER_ENCODING : transferEncoding;
+        return withDefault(transferEncoding, DEFAULT_TRANSFER_ENCODING);
     }
 
     public StringPart(String name, String value) {
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/ByteArrayMultipartPart.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/ByteArrayMultipartPart.java
index a147e9a79..38d4de659 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/ByteArrayMultipartPart.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/ByteArrayMultipartPart.java
@@ -23,7 +23,8 @@
 
 public class ByteArrayMultipartPart extends MultipartPart<ByteArrayPart> {
 
-    private final ByteBuf contentBuffer;
+    // lazy
+    private ByteBuf contentBuffer;
 
     public ByteArrayMultipartPart(ByteArrayPart part, byte[] boundary) {
         super(part, boundary);
@@ -37,14 +38,20 @@ protected long getContentLength() {
 
     @Override
     protected long transferContentTo(ByteBuf target) throws IOException {
-        return transfer(contentBuffer, target, MultipartState.POST_CONTENT);
+        return transfer(lazyLoadContentBuffer(), target, MultipartState.POST_CONTENT);
     }
-    
+
     @Override
     protected long transferContentTo(WritableByteChannel target) throws IOException {
-        return transfer(contentBuffer, target, MultipartState.POST_CONTENT);
+        return transfer(lazyLoadContentBuffer(), target, MultipartState.POST_CONTENT);
+    }
+
+    private ByteBuf lazyLoadContentBuffer() {
+        if (contentBuffer == null)
+            contentBuffer = Unpooled.wrappedBuffer(part.getBytes());
+        return contentBuffer;
     }
-    
+
     @Override
     public void close() {
         super.close();
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MessageEndMultipartPart.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MessageEndMultipartPart.java
index 7c529c608..6c3b20133 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MessageEndMultipartPart.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MessageEndMultipartPart.java
@@ -25,33 +25,50 @@
 
 public class MessageEndMultipartPart extends MultipartPart<FileLikePart> {
 
-    private final ByteBuf buffer;
+    // lazy
+    private ByteBuf contentBuffer;
 
     public MessageEndMultipartPart(byte[] boundary) {
         super(null, boundary);
-        buffer = ByteBufAllocator.DEFAULT.buffer((int) length());
-        buffer.writeBytes(EXTRA_BYTES).writeBytes(boundary).writeBytes(EXTRA_BYTES).writeBytes(CRLF_BYTES);
         state = MultipartState.PRE_CONTENT;
     }
 
     @Override
     public long transferTo(ByteBuf target) throws IOException {
-        return transfer(buffer, target, MultipartState.DONE);
+        return transfer(lazyLoadContentBuffer(), target, MultipartState.DONE);
     }
 
     @Override
     public long transferTo(WritableByteChannel target) throws IOException {
         slowTarget = false;
-        return transfer(buffer, target, MultipartState.DONE);
+        return transfer(lazyLoadContentBuffer(), target, MultipartState.DONE);
+    }
+
+    private ByteBuf lazyLoadContentBuffer() {
+        if (contentBuffer == null) {
+            contentBuffer = ByteBufAllocator.DEFAULT.buffer((int) getContentLength());
+            contentBuffer.writeBytes(EXTRA_BYTES).writeBytes(boundary).writeBytes(EXTRA_BYTES).writeBytes(CRLF_BYTES);
+        }
+        return contentBuffer;
+    }
+
+    @Override
+    protected int computePreContentLength() {
+        return 0;
     }
 
     @Override
-    protected ByteBuf computePreContentBytes() {
+    protected ByteBuf computePreContentBytes(int preContentLength) {
         return Unpooled.EMPTY_BUFFER;
     }
 
     @Override
-    protected ByteBuf computePostContentBytes() {
+    protected int computePostContentLength() {
+        return 0;
+    }
+
+    @Override
+    protected ByteBuf computePostContentBytes(int postContentLength) {
         return Unpooled.EMPTY_BUFFER;
     }
 
@@ -72,6 +89,8 @@ protected long transferContentTo(WritableByteChannel target) throws IOException
 
     @Override
     public void close() {
-        buffer.release();
+        super.close();
+        if (contentBuffer != null)
+            contentBuffer.release();
     }
 }
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MultipartPart.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MultipartPart.java
index d2e76a63d..19ababce1 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MultipartPart.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/MultipartPart.java
@@ -90,23 +90,25 @@
     protected final T part;
     protected final byte[] boundary;
 
-    private final long length;
-    private ByteBuf preContentBuffer;
-    private ByteBuf postContentBuffer;
+    private final int preContentLength;
+    private final int postContentLength;
     protected MultipartState state;
     protected boolean slowTarget;
 
+    // lazy
+    private ByteBuf preContentBuffer;
+    private ByteBuf postContentBuffer;
+
     public MultipartPart(T part, byte[] boundary) {
         this.part = part;
         this.boundary = boundary;
-        preContentBuffer = computePreContentBytes();
-        postContentBuffer = computePostContentBytes();
-        length = preContentBuffer.readableBytes() + postContentBuffer.readableBytes() + getContentLength();
+        preContentLength = computePreContentLength();
+        postContentLength = computePostContentLength();
         state = MultipartState.PRE_CONTENT;
     }
 
     public long length() {
-        return length;
+        return preContentLength + postContentLength + getContentLength();
     }
 
     public MultipartState getState() {
@@ -124,13 +126,13 @@ public long transferTo(ByteBuf target) throws IOException {
             return 0L;
 
         case PRE_CONTENT:
-            return transfer(preContentBuffer, target, MultipartState.CONTENT);
+            return transfer(lazyLoadPreContentBuffer(), target, MultipartState.CONTENT);
 
         case CONTENT:
             return transferContentTo(target);
 
         case POST_CONTENT:
-            return transfer(postContentBuffer, target, MultipartState.DONE);
+            return transfer(lazyLoadPostContentBuffer(), target, MultipartState.DONE);
 
         default:
             throw new IllegalStateException("Unknown state " + state);
@@ -145,23 +147,37 @@ public long transferTo(WritableByteChannel target) throws IOException {
             return 0L;
 
         case PRE_CONTENT:
-            return transfer(preContentBuffer, target, MultipartState.CONTENT);
+            return transfer(lazyLoadPreContentBuffer(), target, MultipartState.CONTENT);
 
         case CONTENT:
             return transferContentTo(target);
 
         case POST_CONTENT:
-            return transfer(postContentBuffer, target, MultipartState.DONE);
+            return transfer(lazyLoadPostContentBuffer(), target, MultipartState.DONE);
 
         default:
             throw new IllegalStateException("Unknown state " + state);
         }
     }
 
+    private ByteBuf lazyLoadPreContentBuffer() {
+        if (preContentBuffer == null)
+            preContentBuffer = computePreContentBytes(preContentLength);
+        return preContentBuffer;
+    }
+
+    private ByteBuf lazyLoadPostContentBuffer() {
+        if (postContentBuffer == null)
+            postContentBuffer = computePostContentBytes(postContentLength);
+        return postContentBuffer;
+    }
+
     @Override
     public void close() {
-        preContentBuffer.release();
-        postContentBuffer.release();
+        if (preContentBuffer != null)
+            preContentBuffer.release();
+        if (postContentBuffer != null)
+            postContentBuffer.release();
     }
 
     protected abstract long getContentLength();
@@ -212,29 +228,27 @@ protected long transfer(ByteBuf source, WritableByteChannel target, MultipartSta
         return transferred;
     }
 
-    protected ByteBuf computePreContentBytes() {
-
-        // compute length
+    protected int computePreContentLength() {
         CounterPartVisitor counterVisitor = new CounterPartVisitor();
         visitPreContent(counterVisitor);
-        long length = counterVisitor.getCount();
+        return counterVisitor.getCount();
+    }
 
-        // compute bytes
-        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer((int) length);
+    protected ByteBuf computePreContentBytes(int preContentLength) {
+        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(preContentLength);
         ByteBufVisitor bytesVisitor = new ByteBufVisitor(buffer);
         visitPreContent(bytesVisitor);
         return buffer;
     }
 
-    protected ByteBuf computePostContentBytes() {
-
-        // compute length
+    protected int computePostContentLength() {
         CounterPartVisitor counterVisitor = new CounterPartVisitor();
         visitPostContent(counterVisitor);
-        long length = counterVisitor.getCount();
+        return counterVisitor.getCount();
+    }
 
-        // compute bytes
-        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer((int) length);
+    protected ByteBuf computePostContentBytes(int postContentLength) {
+        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(postContentLength);
         ByteBufVisitor bytesVisitor = new ByteBufVisitor(buffer);
         visitPostContent(bytesVisitor);
         return buffer;
diff --git a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/PartVisitor.java b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/PartVisitor.java
index e62ca9832..ec3f57d1e 100644
--- a/client/src/main/java/org/asynchttpclient/request/body/multipart/part/PartVisitor.java
+++ b/client/src/main/java/org/asynchttpclient/request/body/multipart/part/PartVisitor.java
@@ -24,7 +24,7 @@
 
     class CounterPartVisitor implements PartVisitor {
 
-        private long count = 0L;
+        private int count = 0;
 
         @Override
         public void withBytes(byte[] bytes) {
@@ -36,7 +36,7 @@ public void withByte(byte b) {
             count++;
         }
 
-        public long getCount() {
+        public int getCount() {
             return count;
         }
     }
diff --git a/client/src/main/java/org/asynchttpclient/resolver/RequestHostnameResolver.java b/client/src/main/java/org/asynchttpclient/resolver/RequestHostnameResolver.java
new file mode 100644
index 000000000..591b0199b
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/resolver/RequestHostnameResolver.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.resolver;
+
+import static org.asynchttpclient.handler.AsyncHandlerExtensionsUtils.toAsyncHandlerExtensions;
+import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.ImmediateEventExecutor;
+import io.netty.util.concurrent.Promise;
+
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.handler.AsyncHandlerExtensions;
+import org.asynchttpclient.netty.SimpleFutureListener;
+import org.asynchttpclient.proxy.ProxyServer;
+import org.asynchttpclient.uri.Uri;
+
+public enum RequestHostnameResolver {
+
+    INSTANCE;
+
+    public Future<List<InetSocketAddress>> resolve(Request request, ProxyServer proxy, AsyncHandler<?> asyncHandler) {
+
+        Uri uri = request.getUri();
+        final Promise<List<InetSocketAddress>> promise = ImmediateEventExecutor.INSTANCE.newPromise();
+
+        if (request.getAddress() != null) {
+            List<InetSocketAddress> resolved = Collections.singletonList(new InetSocketAddress(request.getAddress(), uri.getExplicitPort()));
+            return promise.setSuccess(resolved);
+        }
+
+        // don't notify on explicit address
+        final AsyncHandlerExtensions asyncHandlerExtensions = request.getAddress() == null ? toAsyncHandlerExtensions(asyncHandler) : null;
+        final String name;
+        final int port;
+
+        if (proxy != null && !proxy.isIgnoredForHost(uri.getHost())) {
+            name = proxy.getHost();
+            port = uri.isSecured() ? proxy.getSecuredPort() : proxy.getPort();
+        } else {
+            name = uri.getHost();
+            port = uri.getExplicitPort();
+        }
+
+        if (asyncHandlerExtensions != null)
+            asyncHandlerExtensions.onHostnameResolutionAttempt(name);
+
+        final Future<List<InetAddress>> whenResolved = request.getNameResolver().resolveAll(name);
+
+        whenResolved.addListener(new SimpleFutureListener<List<InetAddress>>() {
+
+            @Override
+            protected void onSuccess(List<InetAddress> value) throws Exception {
+                ArrayList<InetSocketAddress> socketAddresses = new ArrayList<>(value.size());
+                for (InetAddress a : value) {
+                    socketAddresses.add(new InetSocketAddress(a, port));
+                }
+                if (asyncHandlerExtensions != null) {
+                    asyncHandlerExtensions.onHostnameResolutionSuccess(name, socketAddresses);
+                }
+                promise.trySuccess(socketAddresses);
+            }
+
+            @Override
+            protected void onFailure(Throwable t) throws Exception {
+                if (asyncHandlerExtensions != null) {
+                    asyncHandlerExtensions.onHostnameResolutionFailure(name, t);
+                }
+                promise.tryFailure(t);
+            }
+        });
+
+        return promise;
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/uri/UriParser.java b/client/src/main/java/org/asynchttpclient/uri/UriParser.java
index 947c129b8..c69634af6 100644
--- a/client/src/main/java/org/asynchttpclient/uri/UriParser.java
+++ b/client/src/main/java/org/asynchttpclient/uri/UriParser.java
@@ -13,6 +13,7 @@
 package org.asynchttpclient.uri;
 
 import static org.asynchttpclient.util.Assertions.*;
+import static org.asynchttpclient.util.MiscUtils.*;
 
 final class UriParser {
 
@@ -85,7 +86,7 @@ private boolean overrideWithContext(Uri context, String originalUrl) {
 
             // see RFC2396 5.2.3
             String contextPath = context.getPath();
-            if (isNotEmpty(contextPath) && contextPath.charAt(0) == '/')
+            if (isNonEmpty(contextPath) && contextPath.charAt(0) == '/')
               scheme = null;
 
             if (scheme == null) {
@@ -242,7 +243,7 @@ private void removeTrailingDot() {
             path = path.substring(0, path.length() - 1);
     }
 
-    private void initRelativePath() {
+    private void handleRelativePath() {
         int lastSlashPosition = path.lastIndexOf('/');
         String pathEnd = urlWithoutQuery.substring(start, end);
 
@@ -280,27 +281,23 @@ private void parseAuthority() {
                 throw new IllegalArgumentException("Invalid port number :" + port);
 
             // see RFC2396 5.2.4: ignore context path if authority is defined
-            if (isNotEmpty(authority))
+            if (isNonEmpty(authority))
                 path = "";
         }
     }
 
-    private void handleRelativePath() {
-        initRelativePath();
-        handlePathDots();
-    }
-
     private void computeRegularPath() {
         if (urlWithoutQuery.charAt(start) == '/')
             path = urlWithoutQuery.substring(start, end);
 
-        else if (isNotEmpty(path))
+        else if (isNonEmpty(path))
             handleRelativePath();
 
         else {
             String pathEnd = urlWithoutQuery.substring(start, end);
             path = authority != null ? "/" + pathEnd : pathEnd;
         }
+        handlePathDots();
     }
 
     private void computeQueryOnlyPath() {
@@ -336,8 +333,4 @@ public void parse(Uri context, final String originalUrl) {
         parseAuthority();
         computePath(queryOnly);
     }
-
-    private static boolean isNotEmpty(String string) {
-        return string != null && string.length() > 0;
-    }
 }
\ No newline at end of file
diff --git a/client/src/main/java/org/asynchttpclient/util/AuthenticatorUtils.java b/client/src/main/java/org/asynchttpclient/util/AuthenticatorUtils.java
index c57098314..c32db50d3 100644
--- a/client/src/main/java/org/asynchttpclient/util/AuthenticatorUtils.java
+++ b/client/src/main/java/org/asynchttpclient/util/AuthenticatorUtils.java
@@ -12,6 +12,7 @@
  */
 package org.asynchttpclient.util;
 
+import static io.netty.handler.codec.http.HttpHeaders.Names.PROXY_AUTHORIZATION;
 import static java.nio.charset.StandardCharsets.ISO_8859_1;
 import static org.asynchttpclient.util.HttpUtils.getNonEmptyPath;
 import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
@@ -29,11 +30,11 @@
 
 public final class AuthenticatorUtils {
 
-    private static final String PROXY_AUTHORIZATION_HEADER = "Proxy-Authorization";
+    public static final String NEGOTIATE = "Negotiate";
 
     public static String getHeaderWithPrefix(List<String> authenticateHeaders, String prefix) {
         if (authenticateHeaders != null) {
-            for (String authenticateHeader: authenticateHeaders) {
+            for (String authenticateHeader : authenticateHeaders) {
                 if (authenticateHeader.regionMatches(true, 0, prefix, 0, prefix.length()))
                     return authenticateHeader;
             }
@@ -41,7 +42,7 @@ public static String getHeaderWithPrefix(List<String> authenticateHeaders, Strin
 
         return null;
     }
-    
+
     public static String computeBasicAuthentication(Realm realm) {
         return realm != null ? computeBasicAuthentication(realm.getPrincipal(), realm.getPassword(), realm.getCharset()) : null;
     }
@@ -101,10 +102,6 @@ private static StringBuilder append(StringBuilder builder, String name, String v
         return builder.append(", ");
     }
 
-    private static List<String> getProxyAuthorizationHeader(Request request) {
-        return request.getHeaders().getAll(PROXY_AUTHORIZATION_HEADER);
-    }
-
     public static String perConnectionProxyAuthorizationHeader(Request request, Realm proxyRealm) {
         String proxyAuthorization = null;
         if (proxyRealm != null && proxyRealm.isUsePreemptiveAuth()) {
@@ -112,7 +109,7 @@ public static String perConnectionProxyAuthorizationHeader(Request request, Real
             case NTLM:
             case KERBEROS:
             case SPNEGO:
-                List<String> auth = getProxyAuthorizationHeader(request);
+                List<String> auth = request.getHeaders().getAll(PROXY_AUTHORIZATION);
                 if (getHeaderWithPrefix(auth, "NTLM") == null) {
                     String msg = NtlmEngine.INSTANCE.generateType1Msg();
                     proxyAuthorization = "NTLM " + msg;
@@ -125,12 +122,12 @@ public static String perConnectionProxyAuthorizationHeader(Request request, Real
 
         return proxyAuthorization;
     }
-    
+
     public static String perRequestProxyAuthorizationHeader(Realm proxyRealm) {
 
         String proxyAuthorization = null;
         if (proxyRealm != null && proxyRealm.isUsePreemptiveAuth()) {
-    
+
             switch (proxyRealm.getScheme()) {
             case BASIC:
                 proxyAuthorization = computeBasicAuthentication(proxyRealm);
@@ -173,7 +170,7 @@ else if (request.getVirtualHost() != null)
                     host = request.getUri().getHost();
 
                 try {
-                    authorizationHeader = "Negotiate " + SpnegoEngine.instance().generateToken(host);
+                    authorizationHeader = NEGOTIATE + " " + SpnegoEngine.instance().generateToken(host);
                 } catch (SpnegoEngineException e) {
                     throw new RuntimeException(e);
                 }
diff --git a/client/src/main/java/org/asynchttpclient/util/ByteBufUtils.java b/client/src/main/java/org/asynchttpclient/util/ByteBufUtils.java
new file mode 100755
index 000000000..3ebebc85f
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/util/ByteBufUtils.java
@@ -0,0 +1,120 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.util;
+
+import io.netty.buffer.ByteBuf;
+
+import java.io.UTFDataFormatException;
+import java.nio.ByteBuffer;
+import java.nio.CharBuffer;
+import java.nio.charset.CharacterCodingException;
+import java.nio.charset.Charset;
+import java.nio.charset.CharsetDecoder;
+import java.nio.charset.CoderResult;
+import java.nio.charset.StandardCharsets;
+import java.util.List;
+
+public final class ByteBufUtils {
+
+    public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
+
+    private ByteBufUtils() {
+    }
+
+    public static String byteBuf2String(ByteBuf buf, Charset charset) throws UTFDataFormatException, IndexOutOfBoundsException, CharacterCodingException {
+
+        int byteLen = buf.readableBytes();
+
+        if (charset.equals(StandardCharsets.US_ASCII)) {
+            return Utf8Reader.readUtf8(buf, byteLen);
+        } else if (charset.equals(StandardCharsets.UTF_8)) {
+            try {
+                return Utf8Reader.readUtf8(buf.duplicate(), (int) (byteLen * 1.4));
+            } catch (IndexOutOfBoundsException e) {
+                // try again with 3 bytes per char
+                return Utf8Reader.readUtf8(buf, byteLen * 3);
+            }
+        } else {
+            return byteBuffersToString(buf.nioBuffers(), charset);
+        }
+    }
+
+    private static String byteBuffersToString(ByteBuffer[] bufs, Charset cs) throws CharacterCodingException {
+
+        CharsetDecoder cd = cs.newDecoder();
+        int len = 0;
+        for (ByteBuffer buf : bufs) {
+            len += buf.remaining();
+        }
+        int en = (int) (len * (double) cd.maxCharsPerByte());
+        char[] ca = new char[en];
+        cd.reset();
+        CharBuffer cb = CharBuffer.wrap(ca);
+
+        CoderResult cr = null;
+
+        for (int i = 0; i < bufs.length; i++) {
+
+            ByteBuffer buf = bufs[i];
+            cr = cd.decode(buf, cb, i < bufs.length - 1);
+            if (!cr.isUnderflow())
+                cr.throwException();
+        }
+
+        cr = cd.flush(cb);
+        if (!cr.isUnderflow())
+            cr.throwException();
+
+        return new String(ca, 0, cb.position());
+    }
+
+    public static byte[] byteBuf2Bytes(ByteBuf buf) {
+        int readable = buf.readableBytes();
+        int readerIndex = buf.readerIndex();
+        if (buf.hasArray()) {
+            byte[] array = buf.array();
+            if (buf.arrayOffset() == 0 && readerIndex == 0 && array.length == readable) {
+                return array;
+            }
+        }
+        byte[] array = new byte[readable];
+        buf.getBytes(readerIndex, array);
+        return array;
+    }
+
+    public static byte[] byteBufs2Bytes(List<ByteBuf> bufs) {
+
+        if (bufs.isEmpty()) {
+            return EMPTY_BYTE_ARRAY;
+
+        } else if (bufs.size() == 1) {
+            return byteBuf2Bytes(bufs.get(0));
+
+        } else {
+            int totalSize = 0;
+            for (ByteBuf buf : bufs) {
+                totalSize += buf.readableBytes();
+            }
+
+            byte[] bytes = new byte[totalSize];
+            int offset = 0;
+            for (ByteBuf buf : bufs) {
+                int readable = buf.readableBytes();
+                buf.getBytes(buf.readerIndex(), bytes, offset, readable);
+                offset += readable;
+            }
+            return bytes;
+        }
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/util/HttpConstants.java b/client/src/main/java/org/asynchttpclient/util/HttpConstants.java
new file mode 100644
index 000000000..09bcd9945
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/util/HttpConstants.java
@@ -0,0 +1,54 @@
+package org.asynchttpclient.util;
+
+import io.netty.handler.codec.http.HttpMethod;
+import io.netty.handler.codec.http.HttpResponseStatus;
+
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+public final class HttpConstants {
+
+    public static final class Methods {
+        public static final String CONNECT = HttpMethod.CONNECT.name();
+        public static final String DELETE = HttpMethod.DELETE.name();
+        public static final String GET = HttpMethod.GET.name();
+        public static final String HEAD = HttpMethod.HEAD.name();
+        public static final String OPTIONS = HttpMethod.OPTIONS.name();
+        public static final String PATCH = HttpMethod.PATCH.name();
+        public static final String POST = HttpMethod.POST.name();
+        public static final String PUT = HttpMethod.PUT.name();
+        public static final String TRACE = HttpMethod.TRACE.name();
+
+        private Methods() {
+        }
+    }
+
+    public static final class ResponseStatusCodes {
+        public static final int CONTINUE_100 = HttpResponseStatus.CONTINUE.code();
+        public static final int SWITCHING_PROTOCOLS_101 = HttpResponseStatus.SWITCHING_PROTOCOLS.code();
+        public static final int OK_200 = HttpResponseStatus.OK.code();
+        public static final int MOVED_PERMANENTLY_301 = HttpResponseStatus.MOVED_PERMANENTLY.code();
+        public static final int FOUND_302 = HttpResponseStatus.FOUND.code();
+        public static final int SEE_OTHER_303 = HttpResponseStatus.SEE_OTHER.code();
+        public static final int NOT_MODIFIED_304 = HttpResponseStatus.NOT_MODIFIED.code();
+        public static final int TEMPORARY_REDIRECT_307 = HttpResponseStatus.TEMPORARY_REDIRECT.code();
+        public static final int UNAUTHORIZED_401 = HttpResponseStatus.UNAUTHORIZED.code();
+        public static final int PROXY_AUTHENTICATION_REQUIRED_407 = HttpResponseStatus.PROXY_AUTHENTICATION_REQUIRED.code();
+
+        private ResponseStatusCodes() {
+        }
+    }
+
+    private HttpConstants() {
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/util/HttpUtils.java b/client/src/main/java/org/asynchttpclient/util/HttpUtils.java
index f9434c0b3..254453b6e 100644
--- a/client/src/main/java/org/asynchttpclient/util/HttpUtils.java
+++ b/client/src/main/java/org/asynchttpclient/util/HttpUtils.java
@@ -13,9 +13,8 @@
 package org.asynchttpclient.util;
 
 import static java.nio.charset.StandardCharsets.ISO_8859_1;
-import static org.asynchttpclient.util.MiscUtils.*;
+import static org.asynchttpclient.util.MiscUtils.isNonEmpty;
 
-import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.nio.charset.Charset;
 import java.util.List;
@@ -30,9 +29,6 @@
  */
 public class HttpUtils {
 
-    public static final IOException REMOTELY_CLOSED_EXCEPTION = buildStaticIOException("Remotely closed");
-    public static final IOException CHANNEL_CLOSED_EXCEPTION = buildStaticIOException("Channel closed");
-
     public final static Charset DEFAULT_CHARSET = ISO_8859_1;
 
     public static final void validateSupportedScheme(Uri uri) {
@@ -43,12 +39,12 @@ public static final void validateSupportedScheme(Uri uri) {
     }
 
     public final static String getBaseUrl(Uri uri) {
-        return uri.getScheme() + "://" + getAuthority(uri);
+        // getAuthority duplicate but we don't want to re-concatenate
+        return uri.getScheme() + "://" + uri.getHost() + ":" + uri.getExplicitPort();
     }
 
     public final static String getAuthority(Uri uri) {
-        int port = uri.getPort() != -1 ? uri.getPort() : uri.getExplicitPort();
-        return uri.getHost() + ":" + port;
+        return uri.getHost() + ":" + uri.getExplicitPort();
     }
 
     public final static boolean isSameBase(Uri uri1, Uri uri2) {
@@ -82,10 +78,6 @@ public static Charset parseCharset(String contentType) {
         return null;
     }
 
-    public static int requestTimeout(AsyncHttpClientConfig config, Request request) {
-        return request.getRequestTimeout() != 0 ? request.getRequestTimeout() : config.getRequestTimeout();
-    }
-
     public static boolean followRedirect(AsyncHttpClientConfig config, Request request) {
         return request.getFollowRedirect() != null ? request.getFollowRedirect().booleanValue() : config.isFollowRedirect();
     }
diff --git a/client/src/main/java/org/asynchttpclient/util/MiscUtils.java b/client/src/main/java/org/asynchttpclient/util/MiscUtils.java
index 75de53468..92544a001 100644
--- a/client/src/main/java/org/asynchttpclient/util/MiscUtils.java
+++ b/client/src/main/java/org/asynchttpclient/util/MiscUtils.java
@@ -47,8 +47,8 @@ public static boolean getBoolean(String systemPropName, boolean defaultValue) {
         return systemPropValue != null ? systemPropValue.equalsIgnoreCase("true") : defaultValue;
     }
 
-    public static <T> T withDefault(T value, T defaults) {
-        return value != null ? value : value;
+    public static <T> T withDefault(T value, T def) {
+        return value == null ? def : value;
     }
 
     public static void closeSilently(Closeable closeable) {
@@ -59,9 +59,13 @@ public static void closeSilently(Closeable closeable) {
             }
     }
 
-    public static IOException buildStaticIOException(String message) {
-        IOException ioe = new IOException(message);
-        ioe.setStackTrace(new StackTraceElement[] {});
-        return ioe;
+    public static <T extends Exception> T trimStackTrace(T e) {
+        e.setStackTrace(new StackTraceElement[] {});
+        return e;
+    }
+
+    public static Throwable getCause(Throwable t) {
+        Throwable cause = t.getCause();
+        return cause != null ? getCause(cause) : t;
     }
 }
diff --git a/client/src/main/java/org/asynchttpclient/util/Utf8Reader.java b/client/src/main/java/org/asynchttpclient/util/Utf8Reader.java
new file mode 100644
index 000000000..34c495adc
--- /dev/null
+++ b/client/src/main/java/org/asynchttpclient/util/Utf8Reader.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (c) 2015 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.util;
+
+import io.netty.buffer.AbstractByteBuf;
+import io.netty.buffer.ByteBuf;
+import io.netty.util.concurrent.FastThreadLocal;
+
+import java.io.UTFDataFormatException;
+
+public class Utf8Reader {
+
+    private static int SMALL_BUFFER_SIZE = 4096;
+    private static final IndexOutOfBoundsException STRING_DECODER_INDEX_OUT_OF_BOUNDS_EXCEPTION = new IndexOutOfBoundsException("String decoder index out of bounds");
+
+    private static final FastThreadLocal<char[]> CACHED_CHAR_BUFFERS = new FastThreadLocal<char[]>() {
+        @Override
+        protected char[] initialValue() throws Exception {
+            return new char[SMALL_BUFFER_SIZE];
+        }
+    };
+
+    public static String readUtf8(ByteBuf buf, int utflen) throws UTFDataFormatException, IndexOutOfBoundsException {
+
+        boolean small = utflen <= SMALL_BUFFER_SIZE;
+        char[] chararr = small ? CACHED_CHAR_BUFFERS.get() : new char[utflen];
+
+        int char1, char2, char3;
+        int count = 0, chararr_count = 0;
+
+        if (buf.readableBytes() > utflen) {
+            throw STRING_DECODER_INDEX_OUT_OF_BOUNDS_EXCEPTION;
+        }
+
+        if (buf instanceof AbstractByteBuf) {
+            AbstractByteBuf b = (AbstractByteBuf) buf;
+            int readerIndex = buf.readerIndex();
+
+            // fast-path
+            while (count < utflen) {
+                char1 = b.getByte(readerIndex + count) & 0xff;
+                if (char1 > 127)
+                    break;
+                count++;
+                chararr[chararr_count++] = (char) char1;
+            }
+
+            while (count < utflen) {
+                char1 = b.getByte(readerIndex + count) & 0xff;
+                switch (char1 >> 4) {
+                case 0:
+                case 1:
+                case 2:
+                case 3:
+                case 4:
+                case 5:
+                case 6:
+                case 7:
+                    /* 0xxxxxxx */
+                    count++;
+                    chararr[chararr_count++] = (char) char1;
+                    break;
+                case 12:
+                case 13:
+                    /* 110x xxxx 10xx xxxx */
+                    count += 2;
+                    if (count > utflen)
+                        throw new UTFDataFormatException("malformed input: partial character at end");
+                    char2 = b.getByte(readerIndex + count - 1);
+                    if ((char2 & 0xC0) != 0x80)
+                        throw new UTFDataFormatException("malformed input around byte " + count);
+                    chararr[chararr_count++] = (char) (((char1 & 0x1F) << 6) | (char2 & 0x3F));
+                    break;
+                case 14:
+                    /* 1110 xxxx 10xx xxxx 10xx xxxx */
+                    count += 3;
+                    if (count > utflen)
+                        throw new UTFDataFormatException("malformed input: partial character at end");
+                    char2 = b.getByte(readerIndex + count - 2);
+                    char3 = b.getByte(readerIndex + count - 1);
+                    if (((char2 & 0xC0) != 0x80) || ((char3 & 0xC0) != 0x80))
+                        throw new UTFDataFormatException("malformed input around byte " + (count - 1));
+                    chararr[chararr_count++] = (char) (((char1 & 0x0F) << 12) | ((char2 & 0x3F) << 6) | ((char3 & 0x3F) << 0));
+                    break;
+                default:
+                    /* 10xx xxxx, 1111 xxxx */
+                    throw new UTFDataFormatException("malformed input around byte " + count);
+                }
+            }
+
+            buf.readerIndex(buf.readerIndex() + count);
+
+            // The number of chars produced may be less than utflen
+            return new String(chararr, 0, chararr_count);
+
+        } else {
+            byte[] b = new byte[utflen];
+            buf.readBytes(b);
+
+            return new String(b);
+        }
+    }
+}
diff --git a/client/src/main/java/org/asynchttpclient/util/Utf8UrlEncoder.java b/client/src/main/java/org/asynchttpclient/util/Utf8UrlEncoder.java
index a1e0e6b85..f3a10dfef 100644
--- a/client/src/main/java/org/asynchttpclient/util/Utf8UrlEncoder.java
+++ b/client/src/main/java/org/asynchttpclient/util/Utf8UrlEncoder.java
@@ -111,11 +111,10 @@ private Utf8UrlEncoder() {
     }
 
     public static String encodePath(String input) {
-        StringBuilder sb = new StringBuilder(input.length() + 6);
-        appendEncoded(sb, input, BUILT_PATH_UNTOUCHED_CHARS, false);
-        return sb.toString();
+        StringBuilder sb = lazyAppendEncoded(null, input, BUILT_PATH_UNTOUCHED_CHARS, false);
+        return sb == null? input : sb.toString();
     }
-    
+
     public static StringBuilder encodeAndAppendQuery(StringBuilder sb, String query) {
         return appendEncoded(sb, query, BUILT_QUERY_UNTOUCHED_CHARS, false);
     }
@@ -134,17 +133,52 @@ public static StringBuilder encodeAndAppendFormElement(StringBuilder sb, CharSeq
         return appendEncoded(sb, input, FORM_URL_ENCODED_SAFE_CHARS, true);
     }
 
+    private static StringBuilder lazyInitStringBuilder(CharSequence input, int firstNonUsAsciiPosition) {
+        StringBuilder sb = new StringBuilder(input.length() + 6);
+        for (int i = 0; i < firstNonUsAsciiPosition; i++) {
+            sb.append(input.charAt(i));
+        }
+        return sb;
+    }
+    
+    private static StringBuilder lazyAppendEncoded(StringBuilder sb, CharSequence input, BitSet dontNeedEncoding, boolean encodeSpaceAsPlus) {
+        int c;
+        for (int i = 0; i < input.length(); i+= Character.charCount(c)) {
+            c = Character.codePointAt(input, i);
+            if (c <= 127) {
+                if (dontNeedEncoding.get(c)) {
+                    if (sb != null) {
+                        sb.append((char) c);
+                    }
+                } else {
+                    if (sb == null) {
+                        sb = lazyInitStringBuilder(input, i);
+                    }
+                    appendSingleByteEncoded(sb, c, encodeSpaceAsPlus);
+                }
+            } else {
+                if (sb == null) {
+                    sb = lazyInitStringBuilder(input, i);
+                }
+                appendMultiByteEncoded(sb, c);
+            }
+        }
+        return sb;
+    }
+    
     private static StringBuilder appendEncoded(StringBuilder sb, CharSequence input, BitSet dontNeedEncoding, boolean encodeSpaceAsPlus) {
         int c;
         for (int i = 0; i < input.length(); i+= Character.charCount(c)) {
             c = Character.codePointAt(input, i);
-            if (c <= 127)
-                if (dontNeedEncoding.get(c))
+            if (c <= 127) {
+                if (dontNeedEncoding.get(c)) {
                     sb.append((char) c);
-                else
+                } else {
                     appendSingleByteEncoded(sb, c, encodeSpaceAsPlus);
-            else
+                }
+            } else {
                 appendMultiByteEncoded(sb, c);
+            }
         }
         return sb;
     }
diff --git a/client/src/main/java/org/asynchttpclient/webdav/WebDavCompletionHandlerBase.java b/client/src/main/java/org/asynchttpclient/webdav/WebDavCompletionHandlerBase.java
index 37d9dcf8e..ceffb2747 100644
--- a/client/src/main/java/org/asynchttpclient/webdav/WebDavCompletionHandlerBase.java
+++ b/client/src/main/java/org/asynchttpclient/webdav/WebDavCompletionHandlerBase.java
@@ -13,13 +13,9 @@
 
 package org.asynchttpclient.webdav;
 
-import io.netty.handler.codec.http.HttpHeaders;
-
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.SocketAddress;
-import java.nio.ByteBuffer;
-import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -32,9 +28,7 @@
 import org.asynchttpclient.HttpResponseBodyPart;
 import org.asynchttpclient.HttpResponseHeaders;
 import org.asynchttpclient.HttpResponseStatus;
-import org.asynchttpclient.Response;
-import org.asynchttpclient.cookie.Cookie;
-import org.asynchttpclient.uri.Uri;
+import org.asynchttpclient.netty.NettyResponse;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.w3c.dom.Document;
@@ -51,16 +45,16 @@
 public abstract class WebDavCompletionHandlerBase<T> implements AsyncHandler<T> {
     private final Logger logger = LoggerFactory.getLogger(AsyncCompletionHandlerBase.class);
 
-    private final List<HttpResponseBodyPart> bodies = Collections.synchronizedList(new ArrayList<HttpResponseBodyPart>());
     private HttpResponseStatus status;
     private HttpResponseHeaders headers;
+    private final List<HttpResponseBodyPart> bodyParts = Collections.synchronizedList(new ArrayList<HttpResponseBodyPart>());
 
     /**
      * {@inheritDoc}
      */
     @Override
     public final State onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
-        bodies.add(content);
+        bodyParts.add(content);
         return State.CONTINUE;
     }
 
@@ -82,18 +76,50 @@ public final State onHeadersReceived(final HttpResponseHeaders headers) throws E
         return State.CONTINUE;
     }
 
+    private Document readXMLResponse(InputStream stream) {
+        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
+        Document document = null;
+        try {
+            document = factory.newDocumentBuilder().parse(stream);
+            parse(document);
+        } catch (SAXException e) {
+            logger.error(e.getMessage(), e);
+            throw new RuntimeException(e);
+        } catch (IOException e) {
+            logger.error(e.getMessage(), e);
+            throw new RuntimeException(e);
+        } catch (ParserConfigurationException e) {
+            logger.error(e.getMessage(), e);
+            throw new RuntimeException(e);
+        }
+        return document;
+    }
+
+    private void parse(Document document) {
+        Element element = document.getDocumentElement();
+        NodeList statusNode = element.getElementsByTagName("status");
+        for (int i = 0; i < statusNode.getLength(); i++) {
+            Node node = statusNode.item(i);
+
+            String value = node.getFirstChild().getNodeValue();
+            int statusCode = Integer.valueOf(value.substring(value.indexOf(" "), value.lastIndexOf(" ")).trim());
+            String statusText = value.substring(value.lastIndexOf(" "));
+            status = new HttpStatusWrapper(status, statusText, statusCode);
+        }
+    }
+    
     /**
      * {@inheritDoc}
      */
     @Override
     public final T onCompleted() throws Exception {
         if (status != null) {
-            Response response = status.prepareResponse(headers, bodies);
             Document document = null;
             if (status.getStatusCode() == 207) {
-                document = readXMLResponse(response.getResponseBodyAsStream());
+                document = readXMLResponse(new NettyResponse(status, headers, bodyParts).getResponseBodyAsStream());
             }
-            return onCompleted(new WebDavResponse(status.prepareResponse(headers, bodies), document));
+            // recompute response as readXMLResponse->parse might have updated it
+            return onCompleted(new WebDavResponse(new NettyResponse(status, headers, bodyParts), document));
         } else {
             throw new IllegalStateException("Status is null");
         }
@@ -131,109 +157,6 @@ public HttpStatusWrapper(HttpResponseStatus wrapper, String statusText, int stat
             this.statusCode = statusCode;
         }
 
-        @Override
-        public Response prepareResponse(HttpResponseHeaders headers, List<HttpResponseBodyPart> bodyParts) {
-            final Response wrappedResponse = wrapped.prepareResponse(headers, bodyParts);
-
-            return new Response() {
-
-                @Override
-                public int getStatusCode() {
-                    return statusCode;
-                }
-
-                @Override
-                public String getStatusText() {
-                    return statusText;
-                }
-
-                @Override
-                public byte[] getResponseBodyAsBytes() {
-                    return wrappedResponse.getResponseBodyAsBytes();
-                }
-
-                @Override
-                public ByteBuffer getResponseBodyAsByteBuffer() {
-                    return wrappedResponse.getResponseBodyAsByteBuffer();
-                }
-
-                @Override
-                public InputStream getResponseBodyAsStream() {
-                    return wrappedResponse.getResponseBodyAsStream();
-                }
-
-                @Override
-                public String getResponseBody(Charset charset) {
-                    return wrappedResponse.getResponseBody(charset);
-                }
-
-                @Override
-                public String getResponseBody() {
-                    return wrappedResponse.getResponseBody();
-                }
-
-                @Override
-                public Uri getUri() {
-                    return wrappedResponse.getUri();
-                }
-
-                @Override
-                public String getContentType() {
-                    return wrappedResponse.getContentType();
-                }
-
-                @Override
-                public String getHeader(String name) {
-                    return wrappedResponse.getHeader(name);
-                }
-
-                @Override
-                public List<String> getHeaders(String name) {
-                    return wrappedResponse.getHeaders(name);
-                }
-
-                @Override
-                public HttpHeaders getHeaders() {
-                    return wrappedResponse.getHeaders();
-                }
-
-                @Override
-                public boolean isRedirected() {
-                    return wrappedResponse.isRedirected();
-                }
-
-                @Override
-                public List<Cookie> getCookies() {
-                    return wrappedResponse.getCookies();
-                }
-
-                @Override
-                public boolean hasResponseStatus() {
-                    return wrappedResponse.hasResponseStatus();
-                }
-
-                @Override
-                public boolean hasResponseHeaders() {
-                    return wrappedResponse.hasResponseHeaders();
-                }
-
-                @Override
-                public boolean hasResponseBody() {
-                    return wrappedResponse.hasResponseBody();
-                }
-
-                @Override
-                public SocketAddress getRemoteAddress() {
-                    return wrappedResponse.getRemoteAddress();
-                }
-
-                @Override
-                public SocketAddress getLocalAddress() {
-                    return wrappedResponse.getLocalAddress();
-                }
-            };
-        }
-
         @Override
         public int getStatusCode() {
             return (statusText == null ? wrapped.getStatusCode() : statusCode);
@@ -274,36 +197,4 @@ public SocketAddress getLocalAddress() {
             return wrapped.getLocalAddress();
         }
     }
-
-    private Document readXMLResponse(InputStream stream) {
-        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
-        Document document = null;
-        try {
-            document = factory.newDocumentBuilder().parse(stream);
-            parse(document);
-        } catch (SAXException e) {
-            logger.error(e.getMessage(), e);
-            throw new RuntimeException(e);
-        } catch (IOException e) {
-            logger.error(e.getMessage(), e);
-            throw new RuntimeException(e);
-        } catch (ParserConfigurationException e) {
-            logger.error(e.getMessage(), e);
-            throw new RuntimeException(e);
-        }
-        return document;
-    }
-
-    private void parse(Document document) {
-        Element element = document.getDocumentElement();
-        NodeList statusNode = element.getElementsByTagName("status");
-        for (int i = 0; i < statusNode.getLength(); i++) {
-            Node node = statusNode.item(i);
-
-            String value = node.getFirstChild().getNodeValue();
-            int statusCode = Integer.valueOf(value.substring(value.indexOf(" "), value.lastIndexOf(" ")).trim());
-            String statusText = value.substring(value.lastIndexOf(" "));
-            status = new HttpStatusWrapper(status, statusText, statusCode);
-        }
-    }
 }
diff --git a/client/src/main/java/org/asynchttpclient/ws/WebSocketUtils.java b/client/src/main/java/org/asynchttpclient/ws/WebSocketUtils.java
index ee8b96882..489e130c9 100644
--- a/client/src/main/java/org/asynchttpclient/ws/WebSocketUtils.java
+++ b/client/src/main/java/org/asynchttpclient/ws/WebSocketUtils.java
@@ -13,6 +13,8 @@
  */
 package org.asynchttpclient.ws;
 
+import static java.nio.charset.StandardCharsets.US_ASCII;
+
 import java.io.UnsupportedEncodingException;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
@@ -24,13 +26,13 @@
 
     public static String getKey() {
         byte[] nonce = createRandomBytes(16);
-        return base64Encode(nonce);
+        return Base64.encode(nonce);
     }
 
     public static String getAcceptKey(String key) throws UnsupportedEncodingException {
         String acceptSeed = key + MAGIC_GUID;
-        byte[] sha1 = sha1(acceptSeed.getBytes("US-ASCII"));
-        return base64Encode(sha1);
+        byte[] sha1 = sha1(acceptSeed.getBytes(US_ASCII));
+        return Base64.encode(sha1);
     }
 
     public static byte[] md5(byte[] bytes) {
@@ -51,10 +53,6 @@ public static String getAcceptKey(String key) throws UnsupportedEncodingExceptio
         }
     }
 
-    public static String base64Encode(byte[] bytes) {
-        return Base64.encode(bytes);
-    }
-
     public static byte[] createRandomBytes(int size) {
         byte[] bytes = new byte[size];
 
@@ -70,4 +68,3 @@ public static int createRandomNumber(int min, int max) {
     }
 
 }
-
diff --git a/client/src/main/resources/ahc-default.properties b/client/src/main/resources/ahc-default.properties
index 67961dee5..ee526d80b 100644
--- a/client/src/main/resources/ahc-default.properties
+++ b/client/src/main/resources/ahc-default.properties
@@ -9,10 +9,11 @@ org.asynchttpclient.connectionTtl=-1
 org.asynchttpclient.followRedirect=false
 org.asynchttpclient.maxRedirects=5
 org.asynchttpclient.compressionEnforced=false
-org.asynchttpclient.userAgent=NING/1.0
+org.asynchttpclient.userAgent=AHC/2.0
 org.asynchttpclient.enabledProtocols=TLSv1.2, TLSv1.1, TLSv1
 org.asynchttpclient.useProxySelector=false
 org.asynchttpclient.useProxyProperties=false
+org.asynchttpclient.validateResponseHeaders=true
 org.asynchttpclient.strict302Handling=false
 org.asynchttpclient.keepAlive=true
 org.asynchttpclient.requestCompressionLevel=-1
@@ -23,6 +24,11 @@ org.asynchttpclient.useOpenSsl=false
 org.asynchttpclient.acceptAnyCertificate=false
 org.asynchttpclient.sslSessionCacheSize=0
 org.asynchttpclient.sslSessionTimeout=0
+org.asynchttpclient.tcpNoDelay=true
+org.asynchttpclient.soReuseAddress=false
+org.asynchttpclient.soLinger=-1
+org.asynchttpclient.soSndBuf=-1
+org.asynchttpclient.soRcvBuf=-1
 org.asynchttpclient.httpClientCodecMaxInitialLineLength=4096
 org.asynchttpclient.httpClientCodecMaxHeaderSize=8192
 org.asynchttpclient.httpClientCodecMaxChunkSize=8192
@@ -35,3 +41,4 @@ org.asynchttpclient.keepEncodingHeader=false
 org.asynchttpclient.shutdownQuietPeriod=2000
 org.asynchttpclient.shutdownTimeout=15000
 org.asynchttpclient.useNativeTransport=false
+org.asynchttpclient.usePooledMemory=true
diff --git a/client/src/test/java/org/asynchttpclient/AbstractBasicTest.java b/client/src/test/java/org/asynchttpclient/AbstractBasicTest.java
index b6a155c5a..aaea8f804 100644
--- a/client/src/test/java/org/asynchttpclient/AbstractBasicTest.java
+++ b/client/src/test/java/org/asynchttpclient/AbstractBasicTest.java
@@ -59,11 +59,11 @@ public void tearDownGlobal() throws Exception {
     }
 
     protected String getTargetUrl() {
-        return String.format("http://127.0.0.1:%d/foo/test", port1);
+        return String.format("http://localhost:%d/foo/test", port1);
     }
 
     protected String getTargetUrl2() {
-        return String.format("https://127.0.0.1:%d/foo/test", port2);
+        return String.format("https://localhost:%d/foo/test", port2);
     }
 
     public AbstractHandler configureHandler() throws Exception {
diff --git a/client/src/test/java/org/asynchttpclient/AsyncHttpClientDefaultsTest.java b/client/src/test/java/org/asynchttpclient/AsyncHttpClientDefaultsTest.java
index 00adc4a2e..00e4d7c4c 100644
--- a/client/src/test/java/org/asynchttpclient/AsyncHttpClientDefaultsTest.java
+++ b/client/src/test/java/org/asynchttpclient/AsyncHttpClientDefaultsTest.java
@@ -9,7 +9,7 @@
 
 import java.lang.reflect.Method;
 
-@Test(groups = "standalone")
+@Test
 public class AsyncHttpClientDefaultsTest {
 
     public void testDefaultMaxTotalConnections() {
@@ -63,7 +63,7 @@ public void testDefaultCompressionEnforced() {
     }
 
     public void testDefaultUserAgent() {
-        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultUserAgent(), "NING/1.0");
+        Assert.assertEquals(AsyncHttpClientConfigDefaults.defaultUserAgent(), "AHC/2.0");
         testStringSystemProperty("userAgent", "defaultUserAgent", "MyAHC");
     }
 
diff --git a/client/src/test/java/org/asynchttpclient/AsyncStreamHandlerTest.java b/client/src/test/java/org/asynchttpclient/AsyncStreamHandlerTest.java
index ad0596e49..2409b507d 100644
--- a/client/src/test/java/org/asynchttpclient/AsyncStreamHandlerTest.java
+++ b/client/src/test/java/org/asynchttpclient/AsyncStreamHandlerTest.java
@@ -15,454 +15,477 @@
  */
 package org.asynchttpclient;
 
+import static io.netty.handler.codec.http.HttpHeaders.Names.*;
+import static io.netty.handler.codec.http.HttpHeaders.Values.APPLICATION_X_WWW_FORM_URLENCODED;
+import static java.nio.charset.StandardCharsets.US_ASCII;
+import static org.asynchttpclient.test.TestUtils.*;
 import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.TestUtils.TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET;
 import static org.testng.Assert.*;
 import io.netty.handler.codec.http.HttpHeaders;
 
 import java.util.Arrays;
-import java.util.Locale;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
 
+import org.asynchttpclient.test.TestUtils.AsyncHandlerAdapter;
+import org.asynchttpclient.testserver.HttpServer;
+import org.asynchttpclient.testserver.HttpTest;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
-public class AsyncStreamHandlerTest extends AbstractBasicTest {
+public class AsyncStreamHandlerTest extends HttpTest {
 
     private static final String RESPONSE = "param_1_";
 
-    @Test(groups = "standalone")
-    public void asyncStreamGETTest() throws Exception {
-        final CountDownLatch l = new CountDownLatch(1);
-        final AtomicReference<HttpHeaders> responseHeaders = new AtomicReference<>();
-        final AtomicReference<Throwable> throwable = new AtomicReference<>();
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            c.prepareGet(getTargetUrl()).execute(new AsyncHandlerAdapter() {
-
-                @Override
-                public State onHeadersReceived(HttpResponseHeaders content) throws Exception {
-                    try {
-                        responseHeaders.set(content.getHeaders());
-                        return State.ABORT;
-                    } finally {
-                        l.countDown();
-                    }
-                }
-
-                @Override
-                public void onThrowable(Throwable t) {
-                    try {
-                        throwable.set(t);
-                    } finally {
-                        l.countDown();
-                    }
-                }
-            });
+    private static HttpServer server;
 
-            if (!l.await(5, TimeUnit.SECONDS)) {
-                fail("Timeout out");
-            }
-            
-            HttpHeaders h = responseHeaders.get();
-            assertNotNull(h, "No response headers");
-            assertEquals(h.get(HttpHeaders.Names.CONTENT_TYPE), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET, "Unexpected content-type");
-            assertNull(throwable.get(), "Unexpected exception");
-        }
+    @BeforeClass
+    public static void start() throws Throwable {
+        server = new HttpServer();
+        server.start();
     }
 
-    @Test(groups = "standalone")
-    public void asyncStreamPOSTTest() throws Exception {
+    @AfterClass
+    public static void stop() throws Throwable {
+        server.close();
+    }
 
-        final AtomicReference<HttpHeaders> responseHeaders = new AtomicReference<>();
+    private static String getTargetUrl() {
+        return server.getHttpUrl() + "/foo/bar";
+    }
 
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            Future<String> f = c.preparePost(getTargetUrl())//
-                    .setHeader("Content-Type", "application/x-www-form-urlencoded")//
-                    .addFormParam("param_1", "value_1")//
-                    .execute(new AsyncHandlerAdapter() {
-                private StringBuilder builder = new StringBuilder();
+    @Test
+    public void getWithOnHeadersReceivedAbort() throws Throwable {
 
-                @Override
-                public State onHeadersReceived(HttpResponseHeaders content) throws Exception {
-                    responseHeaders.set(content.getHeaders());
-                    return State.CONTINUE;
-                }
+        withClient().run(client -> {
+            withServer(server).run(server -> {
 
-                @Override
-                public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-                    builder.append(new String(content.getBodyPartBytes()));
-                    return State.CONTINUE;
-                }
+                server.enqueueEcho();
+                client.prepareGet(getTargetUrl()).execute(new AsyncHandlerAdapter() {
 
-                @Override
-                public String onCompleted() throws Exception {
-                    return builder.toString().trim();
-                }
+                    @Override
+                    public State onHeadersReceived(HttpResponseHeaders content) throws Exception {
+                        assertContentTypesEquals(content.getHeaders().get(CONTENT_TYPE), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
+                        return State.ABORT;
+                    }
+                }).get(5, TimeUnit.SECONDS);
             });
-
-            String responseBody = f.get(10, TimeUnit.SECONDS);
-            HttpHeaders h = responseHeaders.get();
-            assertNotNull(h);
-            assertEquals(h.get(HttpHeaders.Names.CONTENT_TYPE), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
-            assertEquals(responseBody, RESPONSE);
-        }
+        });
     }
 
-    @Test(groups = "standalone")
-    public void asyncStreamInterruptTest() throws Exception {
-        final CountDownLatch l = new CountDownLatch(1);
-        
-        final AtomicReference<HttpHeaders> responseHeaders = new AtomicReference<>();
-        final AtomicBoolean bodyReceived = new AtomicBoolean(false);
-        final AtomicReference<Throwable> throwable = new AtomicReference<>();
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            c.preparePost(getTargetUrl())//
-            .setHeader("Content-Type", "application/x-www-form-urlencoded")//
-            .addFormParam("param_1", "value_1")//
-            .execute(new AsyncHandlerAdapter() {
-
-                @Override
-                public State onHeadersReceived(HttpResponseHeaders content) throws Exception {
-                    responseHeaders.set(content.getHeaders());
-                    return State.ABORT;
-                }
+    @Test
+    public void asyncStreamPOSTTest() throws Throwable {
 
-                @Override
-                public State onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
-                    bodyReceived.set(true);
-                    return State.ABORT;
-                }
+        withClient().run(client -> {
+            withServer(server).run(server -> {
 
-                @Override
-                public void onThrowable(Throwable t) {
-                    throwable.set(t);
-                    l.countDown();
-                }
-            });
+                server.enqueueEcho();
 
-            l.await(5, TimeUnit.SECONDS);
-            assertTrue(!bodyReceived.get(), "Interrupted not working");
-            HttpHeaders h = responseHeaders.get();
-            assertNotNull(h, "Should receive non null headers");
-            assertEquals(h.get(HttpHeaders.Names.CONTENT_TYPE).toLowerCase(Locale.ENGLISH), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET.toLowerCase(Locale.ENGLISH), "Unexpected content-type");
-            assertNull(throwable.get(), "Should get an exception");
-        }
-    }
+                String responseBody = client.preparePost(getTargetUrl())//
+                        .setHeader(CONTENT_TYPE, APPLICATION_X_WWW_FORM_URLENCODED)//
+                        .addFormParam("param_1", "value_1")//
+                        .execute(new AsyncHandlerAdapter() {
+                            private StringBuilder builder = new StringBuilder();
 
-    @Test(groups = "standalone")
-    public void asyncStreamFutureTest() throws Exception {
-        final AtomicReference<HttpHeaders> responseHeaders = new AtomicReference<>();
-        final AtomicReference<Throwable> throwable = new AtomicReference<>();
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            Future<String> f = c.preparePost(getTargetUrl()).addFormParam("param_1", "value_1").execute(new AsyncHandlerAdapter() {
-                private StringBuilder builder = new StringBuilder();
-
-                @Override
-                public State onHeadersReceived(HttpResponseHeaders content) throws Exception {
-                    responseHeaders.set(content.getHeaders());
-                    return State.CONTINUE;
-                }
+                            @Override
+                            public State onHeadersReceived(HttpResponseHeaders content) throws Exception {
+                                assertContentTypesEquals(content.getHeaders().get(CONTENT_TYPE), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
+                                return State.CONTINUE;
+                            }
 
-                @Override
-                public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-                    builder.append(new String(content.getBodyPartBytes()));
-                    return State.CONTINUE;
-                }
+                            @Override
+                            public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+                                builder.append(new String(content.getBodyPartBytes(), US_ASCII));
+                                return State.CONTINUE;
+                            }
 
-                @Override
-                public String onCompleted() throws Exception {
-                    return builder.toString().trim();
-                }
+                            @Override
+                            public String onCompleted() throws Exception {
+                                return builder.toString().trim();
+                            }
+                        }).get(10, TimeUnit.SECONDS);
 
-                @Override
-                public void onThrowable(Throwable t) {
-                    throwable.set(t);
-                }
+                assertEquals(responseBody, RESPONSE);
             });
+        });
+    }
 
-            String responseBody = f.get(5, TimeUnit.SECONDS);
-            HttpHeaders h = responseHeaders.get();
-            assertNotNull(h, "Should receive non null headers");
-            assertEquals(h.get(HttpHeaders.Names.CONTENT_TYPE).toLowerCase(Locale.ENGLISH), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET.toLowerCase(Locale.ENGLISH), "Unexpected content-type");
-            assertNotNull(responseBody, "No response body");
-            assertEquals(responseBody.trim(), RESPONSE, "Unexpected response body");
-            assertNull(throwable.get(), "Unexpected exception");
-        }
+    @Test
+    public void asyncStreamInterruptTest() throws Throwable {
+
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+
+                server.enqueueEcho();
+
+                final AtomicBoolean onHeadersReceived = new AtomicBoolean();
+                final AtomicBoolean onBodyPartReceived = new AtomicBoolean();
+                final AtomicBoolean onThrowable = new AtomicBoolean();
+
+                client.preparePost(getTargetUrl())//
+                        .setHeader(CONTENT_TYPE, APPLICATION_X_WWW_FORM_URLENCODED)//
+                        .addFormParam("param_1", "value_1")//
+                        .execute(new AsyncHandlerAdapter() {
+
+                            @Override
+                            public State onHeadersReceived(HttpResponseHeaders content) throws Exception {
+                                onHeadersReceived.set(true);
+                                assertContentTypesEquals(content.getHeaders().get(CONTENT_TYPE), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
+                                return State.ABORT;
+                            }
+
+                            @Override
+                            public State onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
+                                onBodyPartReceived.set(true);
+                                return State.ABORT;
+                            }
+
+                            @Override
+                            public void onThrowable(Throwable t) {
+                                onThrowable.set(true);
+                            }
+                        }).get(5, TimeUnit.SECONDS);
+
+                assertTrue(onHeadersReceived.get(), "Headers weren't received");
+                assertFalse(onBodyPartReceived.get(), "Abort not working");
+                assertFalse(onThrowable.get(), "Shouldn't get an exception");
+            });
+        });
     }
 
-    @Test(groups = "standalone")
-    public void asyncStreamThrowableRefusedTest() throws Exception {
+    @Test
+    public void asyncStreamFutureTest() throws Throwable {
+
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+
+                server.enqueueEcho();
+
+                final AtomicBoolean onHeadersReceived = new AtomicBoolean();
+                final AtomicBoolean onThrowable = new AtomicBoolean();
+
+                String responseBody = client.preparePost(getTargetUrl())//
+                        .addFormParam("param_1", "value_1")//
+                        .execute(new AsyncHandlerAdapter() {
+                            private StringBuilder builder = new StringBuilder();
+
+                            @Override
+                            public State onHeadersReceived(HttpResponseHeaders content) throws Exception {
+                                assertContentTypesEquals(content.getHeaders().get(CONTENT_TYPE), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
+                                onHeadersReceived.set(true);
+                                return State.CONTINUE;
+                            }
+
+                            @Override
+                            public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+                                builder.append(new String(content.getBodyPartBytes()));
+                                return State.CONTINUE;
+                            }
+
+                            @Override
+                            public String onCompleted() throws Exception {
+                                return builder.toString().trim();
+                            }
+
+                            @Override
+                            public void onThrowable(Throwable t) {
+                                onThrowable.set(true);
+                            }
+                        }).get(5, TimeUnit.SECONDS);
+
+                assertTrue(onHeadersReceived.get(), "Headers weren't received");
+                assertFalse(onThrowable.get(), "Shouldn't get an exception");
+                assertEquals(responseBody, RESPONSE, "Unexpected response body");
+            });
+        });
+    }
 
-        final CountDownLatch l = new CountDownLatch(1);
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            c.prepareGet(getTargetUrl()).execute(new AsyncHandlerAdapter() {
+    @Test
+    public void asyncStreamThrowableRefusedTest() throws Throwable {
 
-                @Override
-                public State onHeadersReceived(HttpResponseHeaders content) throws Exception {
-                    throw new RuntimeException("FOO");
-                }
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+
+                server.enqueueEcho();
+
+                final CountDownLatch l = new CountDownLatch(1);
+                client.prepareGet(getTargetUrl()).execute(new AsyncHandlerAdapter() {
 
-                @Override
-                public void onThrowable(Throwable t) {
-                    try {
-                        if (t.getMessage() != null) {
-                            assertEquals(t.getMessage(), "FOO");
+                    @Override
+                    public State onHeadersReceived(HttpResponseHeaders content) throws Exception {
+                        throw new RuntimeException("FOO");
+                    }
+
+                    @Override
+                    public void onThrowable(Throwable t) {
+                        try {
+                            if (t.getMessage() != null) {
+                                assertEquals(t.getMessage(), "FOO");
+                            }
+                        } finally {
+                            l.countDown();
                         }
-                    } finally {
-                        l.countDown();
                     }
+                });
+
+                if (!l.await(10, TimeUnit.SECONDS)) {
+                    fail("Timed out");
                 }
             });
-
-            if (!l.await(10, TimeUnit.SECONDS)) {
-                fail("Timed out");
-            }
-        }
+        });
     }
 
-    @Test(groups = "standalone")
-    public void asyncStreamReusePOSTTest() throws Exception {
-
-        final AtomicReference<HttpHeaders> responseHeaders = new AtomicReference<>();
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            BoundRequestBuilder rb = c.preparePost(getTargetUrl())//
-                    .setHeader("Content-Type", "application/x-www-form-urlencoded")
-                    .addFormParam("param_1", "value_1");
-            
-            Future<String> f = rb.execute(new AsyncHandlerAdapter() {
-                private StringBuilder builder = new StringBuilder();
-
-                @Override
-                public State onHeadersReceived(HttpResponseHeaders content) throws Exception {
-                    responseHeaders.set(content.getHeaders());
-                    return State.CONTINUE;
-                }
+    @Test
+    public void asyncStreamReusePOSTTest() throws Throwable {
 
-                @Override
-                public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-                    builder.append(new String(content.getBodyPartBytes()));
-                    return State.CONTINUE;
-                }
+        withClient().run(client -> {
+            withServer(server).run(server -> {
 
-                @Override
-                public String onCompleted() throws Exception {
-                    return builder.toString();
-                }
-            });
+                server.enqueueEcho();
 
-            String r = f.get(5, TimeUnit.SECONDS);
-            HttpHeaders h = responseHeaders.get();
-            assertNotNull(h, "Should receive non null headers");
-            assertEquals(h.get(HttpHeaders.Names.CONTENT_TYPE).toLowerCase(Locale.ENGLISH), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET.toLowerCase(Locale.ENGLISH), "Unexpected content-type");
-            assertNotNull(r, "No response body");
-            assertEquals(r.trim(), RESPONSE, "Unexpected response body");
-            
-            responseHeaders.set(null);
-
-            // Let do the same again
-            f = rb.execute(new AsyncHandlerAdapter() {
-                private StringBuilder builder = new StringBuilder();
-
-                @Override
-                public State onHeadersReceived(HttpResponseHeaders content) throws Exception {
-                    responseHeaders.set(content.getHeaders());
-                    return State.CONTINUE;
-                }
+                final AtomicReference<HttpHeaders> responseHeaders = new AtomicReference<>();
 
-                @Override
-                public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-                    builder.append(new String(content.getBodyPartBytes()));
-                    return State.CONTINUE;
-                }
+                BoundRequestBuilder rb = client.preparePost(getTargetUrl())//
+                        .setHeader(CONTENT_TYPE, APPLICATION_X_WWW_FORM_URLENCODED)//
+                        .addFormParam("param_1", "value_1");
 
-                @Override
-                public String onCompleted() throws Exception {
-                    return builder.toString();
-                }
-            });
+                Future<String> f = rb.execute(new AsyncHandlerAdapter() {
+                    private StringBuilder builder = new StringBuilder();
+
+                    @Override
+                    public State onHeadersReceived(HttpResponseHeaders content) throws Exception {
+                        responseHeaders.set(content.getHeaders());
+                        return State.CONTINUE;
+                    }
+
+                    @Override
+                    public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+                        builder.append(new String(content.getBodyPartBytes()));
+                        return State.CONTINUE;
+                    }
+
+                    @Override
+                    public String onCompleted() throws Exception {
+                        return builder.toString();
+                    }
+                });
+
+                String r = f.get(5, TimeUnit.SECONDS);
+                HttpHeaders h = responseHeaders.get();
+                assertNotNull(h, "Should receive non null headers");
+                assertContentTypesEquals(h.get(CONTENT_TYPE), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
+                assertNotNull(r, "No response body");
+                assertEquals(r.trim(), RESPONSE, "Unexpected response body");
+
+                responseHeaders.set(null);
+
+                server.enqueueEcho();
+
+                // Let do the same again
+                    f = rb.execute(new AsyncHandlerAdapter() {
+                        private StringBuilder builder = new StringBuilder();
 
-            f.get(5, TimeUnit.SECONDS);
-            h = responseHeaders.get();
-            assertNotNull(h, "Should receive non null headers");
-            assertEquals(h.get(HttpHeaders.Names.CONTENT_TYPE).toLowerCase(Locale.ENGLISH), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET.toLowerCase(Locale.ENGLISH), "Unexpected content-type");
-            assertNotNull(r, "No response body");
-            assertEquals(r.trim(), RESPONSE, "Unexpected response body");
-        }
+                        @Override
+                        public State onHeadersReceived(HttpResponseHeaders content) throws Exception {
+                            responseHeaders.set(content.getHeaders());
+                            return State.CONTINUE;
+                        }
+
+                        @Override
+                        public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+                            builder.append(new String(content.getBodyPartBytes()));
+                            return State.CONTINUE;
+                        }
+
+                        @Override
+                        public String onCompleted() throws Exception {
+                            return builder.toString();
+                        }
+                    });
+
+                    f.get(5, TimeUnit.SECONDS);
+                    h = responseHeaders.get();
+                    assertNotNull(h, "Should receive non null headers");
+                    assertContentTypesEquals(h.get(CONTENT_TYPE), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
+                    assertNotNull(r, "No response body");
+                    assertEquals(r.trim(), RESPONSE, "Unexpected response body");
+                });
+        });
     }
 
-    @Test(groups = "online")
-    public void asyncStream302RedirectWithBody() throws Exception {
-        final AtomicReference<Integer> statusCode = new AtomicReference<>(0);
-        final AtomicReference<HttpHeaders> responseHeaders = new AtomicReference<>();
-        try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
-            Future<String> f = c.prepareGet("http://google.com/").execute(new AsyncHandlerAdapter() {
-
-                public State onStatusReceived(HttpResponseStatus status) throws Exception {
-                    statusCode.set(status.getStatusCode());
-                    return State.CONTINUE;
-                }
+    @Test
+    public void asyncStream302RedirectWithBody() throws Throwable {
 
-                @Override
-                public State onHeadersReceived(HttpResponseHeaders content) throws Exception {
-                    responseHeaders.set(content.getHeaders());
-                    return State.CONTINUE;
-                }
+        withClient(config().setFollowRedirect(true)).run(client -> {
+            withServer(server).run(server -> {
 
-                @Override
-                public String onCompleted() throws Exception {
-                    return null;
-                }
-            });
+                String originalUrl = server.getHttpUrl() + "/original";
+                String redirectUrl = server.getHttpUrl() + "/redirect";
+
+                server.enqueueResponse(response -> {
+                    response.setStatus(302);
+                    response.setHeader(LOCATION, redirectUrl);
+                    response.getOutputStream().println("You are being asked to redirect to " + redirectUrl);
+                });
+                server.enqueueOk();
 
-            f.get(20, TimeUnit.SECONDS);
-            assertTrue(statusCode.get() != 302);
-            HttpHeaders h = responseHeaders.get();
-            assertNotNull(h);
-            assertEquals(h.get("server"), "gws");
-            // This assertion below is not an invariant, since implicitly contains locale-dependant settings
-            // and fails when run in country having own localized Google site and it's locale relies on something
-            // other than ISO-8859-1.
-            // In Hungary for example, http://google.com/ redirects to http://www.google.hu/, a localized
-            // Google site, that uses ISO-8892-2 encoding (default for HU). Similar is true for other
-            // non-ISO-8859-1 using countries that have "localized" google, like google.hr, google.rs, google.cz, google.sk etc.
-            //
-            // assertEquals(h.get(HttpHeaders.Names.CONTENT_TYPE), "text/html; charset=ISO-8859-1");
-        }
+                Response response = client.prepareGet(originalUrl).execute().get(20, TimeUnit.SECONDS);
+
+                assertEquals(response.getStatusCode(), 200);
+                assertTrue(response.getResponseBody().isEmpty());
+            });
+        });
     }
 
-    @Test(groups = "standalone", timeOut = 3000, description = "Test behavior of 'read only status line' scenario.")
-    public void asyncStreamJustStatusLine() throws Exception {
-        final int STATUS = 0;
-        final int COMPLETED = 1;
-        final int OTHER = 2;
-        final boolean[] whatCalled = new boolean[] { false, false, false };
-        final CountDownLatch latch = new CountDownLatch(1);
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Future<Integer> statusCode = client.prepareGet(getTargetUrl()).execute(new AsyncHandler<Integer>() {
-                private int status = -1;
-
-                @Override
-                public void onThrowable(Throwable t) {
-                    whatCalled[OTHER] = true;
-                    latch.countDown();
-                }
+    @Test(timeOut = 3000)
+    public void asyncStreamJustStatusLine() throws Throwable {
 
-                @Override
-                public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
-                    whatCalled[OTHER] = true;
-                    latch.countDown();
-                    return State.ABORT;
-                }
+        withClient().run(client -> {
+            withServer(server).run(server -> {
 
-                @Override
-                public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
-                    whatCalled[STATUS] = true;
-                    status = responseStatus.getStatusCode();
-                    latch.countDown();
-                    return State.ABORT;
-                }
+                server.enqueueEcho();
+
+                final int STATUS = 0;
+                final int COMPLETED = 1;
+                final int OTHER = 2;
+                final boolean[] whatCalled = new boolean[] { false, false, false };
+                final CountDownLatch latch = new CountDownLatch(1);
+                Future<Integer> statusCode = client.prepareGet(getTargetUrl()).execute(new AsyncHandler<Integer>() {
+                    private int status = -1;
+
+                    @Override
+                    public void onThrowable(Throwable t) {
+                        whatCalled[OTHER] = true;
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public State onBodyPartReceived(HttpResponseBodyPart bodyPart) throws Exception {
+                        whatCalled[OTHER] = true;
+                        latch.countDown();
+                        return State.ABORT;
+                    }
+
+                    @Override
+                    public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+                        whatCalled[STATUS] = true;
+                        status = responseStatus.getStatusCode();
+                        latch.countDown();
+                        return State.ABORT;
+                    }
+
+                    @Override
+                    public State onHeadersReceived(HttpResponseHeaders headers) throws Exception {
+                        whatCalled[OTHER] = true;
+                        latch.countDown();
+                        return State.ABORT;
+                    }
 
-                @Override
-                public State onHeadersReceived(HttpResponseHeaders headers) throws Exception {
-                    whatCalled[OTHER] = true;
-                    latch.countDown();
-                    return State.ABORT;
+                    @Override
+                    public Integer onCompleted() throws Exception {
+                        whatCalled[COMPLETED] = true;
+                        latch.countDown();
+                        return status;
+                    }
+                });
+
+                if (!latch.await(2, TimeUnit.SECONDS)) {
+                    fail("Timeout");
+                    return;
                 }
+                Integer status = statusCode.get(TIMEOUT, TimeUnit.SECONDS);
+                assertEquals((int) status, 200, "Expected status code failed.");
 
-                @Override
-                public Integer onCompleted() throws Exception {
-                    whatCalled[COMPLETED] = true;
-                    latch.countDown();
-                    return status;
+                if (!whatCalled[STATUS]) {
+                    fail("onStatusReceived not called.");
+                }
+                if (!whatCalled[COMPLETED]) {
+                    fail("onCompleted not called.");
+                }
+                if (whatCalled[OTHER]) {
+                    fail("Other method of AsyncHandler got called.");
                 }
             });
-
-            if (!latch.await(2, TimeUnit.SECONDS)) {
-                fail("Timeout");
-                return;
-            }
-            Integer status = statusCode.get(TIMEOUT, TimeUnit.SECONDS);
-            assertEquals((int) status, 200, "Expected status code failed.");
-
-            if (!whatCalled[STATUS]) {
-                fail("onStatusReceived not called.");
-            }
-            if (!whatCalled[COMPLETED]) {
-                fail("onCompleted not called.");
-            }
-            if (whatCalled[OTHER]) {
-                fail("Other method of AsyncHandler got called.");
-            }
-        }
+        });
     }
 
     @Test(groups = "online")
-    public void asyncOptionsTest() throws Exception {
-        final AtomicReference<HttpHeaders> responseHeaders = new AtomicReference<>();
+    public void asyncOptionsTest() throws Throwable {
 
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            final String[] expected = { "GET", "HEAD", "OPTIONS", "POST", "TRACE" };
-            Future<String> f = c.prepareOptions("http://www.apache.org/").execute(new AsyncHandlerAdapter() {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
 
-                @Override
-                public State onHeadersReceived(HttpResponseHeaders content) throws Exception {
-                    responseHeaders.set(content.getHeaders());
-                    return State.ABORT;
-                }
+                final AtomicReference<HttpHeaders> responseHeaders = new AtomicReference<>();
 
-                @Override
-                public String onCompleted() throws Exception {
-                    return "OK";
-                }
-            });
+                final String[] expected = { "GET", "HEAD", "OPTIONS", "POST", "TRACE" };
+                Future<String> f = client.prepareOptions("http://www.apache.org/").execute(new AsyncHandlerAdapter() {
 
-            f.get(20, TimeUnit.SECONDS) ;
-            HttpHeaders h = responseHeaders.get();
-            assertNotNull(h);
-            String[] values = h.get(HttpHeaders.Names.ALLOW).split(",|, ");
-            assertNotNull(values);
-            assertEquals(values.length, expected.length);
-            Arrays.sort(values);
-            assertEquals(values, expected);
-        }
+                    @Override
+                    public State onHeadersReceived(HttpResponseHeaders content) throws Exception {
+                        responseHeaders.set(content.getHeaders());
+                        return State.ABORT;
+                    }
+
+                    @Override
+                    public String onCompleted() throws Exception {
+                        return "OK";
+                    }
+                });
+
+                f.get(20, TimeUnit.SECONDS);
+                HttpHeaders h = responseHeaders.get();
+                assertNotNull(h);
+                String[] values = h.get(ALLOW).split(",|, ");
+                assertNotNull(values);
+                assertEquals(values.length, expected.length);
+                Arrays.sort(values);
+                assertEquals(values, expected);
+            });
+        });
     }
 
-    @Test(groups = "standalone")
-    public void closeConnectionTest() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            Response r = c.prepareGet(getTargetUrl()).execute(new AsyncHandler<Response>() {
+    @Test
+    public void closeConnectionTest() throws Throwable {
 
-                private Response.ResponseBuilder builder = new Response.ResponseBuilder();
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                server.enqueueEcho();
 
-                public State onHeadersReceived(HttpResponseHeaders content) throws Exception {
-                    builder.accumulate(content);
-                    return State.CONTINUE;
-                }
+                Response r = client.prepareGet(getTargetUrl()).execute(new AsyncHandler<Response>() {
 
-                public void onThrowable(Throwable t) {
-                }
+                    private Response.ResponseBuilder builder = new Response.ResponseBuilder();
 
-                public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
-                    builder.accumulate(content);
-                    return content.isLast() ? State.ABORT : State.CONTINUE;
-                }
+                    public State onHeadersReceived(HttpResponseHeaders content) throws Exception {
+                        builder.accumulate(content);
+                        return State.CONTINUE;
+                    }
 
-                public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
-                    builder.accumulate(responseStatus);
+                    public void onThrowable(Throwable t) {
+                    }
 
-                    return State.CONTINUE;
-                }
+                    public State onBodyPartReceived(HttpResponseBodyPart content) throws Exception {
+                        builder.accumulate(content);
+                        return content.isLast() ? State.ABORT : State.CONTINUE;
+                    }
 
-                public Response onCompleted() throws Exception {
-                    return builder.build();
-                }
-            }).get();
+                    public State onStatusReceived(HttpResponseStatus responseStatus) throws Exception {
+                        builder.accumulate(responseStatus);
+
+                        return State.CONTINUE;
+                    }
 
-            assertNotNull(r);
-            assertEquals(r.getStatusCode(), 200);
-        }
+                    public Response onCompleted() throws Exception {
+                        return builder.build();
+                    }
+                }).get();
+
+                assertNotNull(r);
+                assertEquals(r.getStatusCode(), 200);
+            });
+        });
     }
 }
diff --git a/client/src/test/java/org/asynchttpclient/AuthTimeoutTest.java b/client/src/test/java/org/asynchttpclient/AuthTimeoutTest.java
index 992530e4d..1a108044c 100644
--- a/client/src/test/java/org/asynchttpclient/AuthTimeoutTest.java
+++ b/client/src/test/java/org/asynchttpclient/AuthTimeoutTest.java
@@ -16,6 +16,7 @@
 import static org.asynchttpclient.Dsl.*;
 import static org.asynchttpclient.test.TestUtils.*;
 import static org.testng.Assert.*;
+import io.netty.handler.codec.http.HttpHeaders;
 
 import java.io.IOException;
 import java.io.OutputStream;
@@ -26,7 +27,7 @@
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 
-import org.asynchttpclient.util.HttpUtils;
+import org.asynchttpclient.exception.RemotelyClosedException;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.handler.AbstractHandler;
@@ -69,7 +70,7 @@ public void handle(String s, Request r, HttpServletRequest request, HttpServletR
             OutputStream out = response.getOutputStream();
             if (request.getHeader("X-Content") != null) {
                 String content = request.getHeader("X-Content");
-                response.setHeader("Content-Length", String.valueOf(content.getBytes(UTF_8).length));
+                response.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(content.getBytes(UTF_8).length));
                 out.write(content.substring(1).getBytes(UTF_8));
             } else {
                 response.setStatus(200);
@@ -168,11 +169,7 @@ public void digestFuturePreemptiveAuthTimeoutTest() throws Exception {
     }
 
     protected void inspectException(Throwable t) {
-        assertNotNull(t.getCause());
-        assertEquals(t.getCause().getClass(), IOException.class);
-        if (t.getCause() != HttpUtils.REMOTELY_CLOSED_EXCEPTION) {
-            fail();
-        }
+        assertEquals(t.getCause(), RemotelyClosedException.INSTANCE);
     }
 
     private AsyncHttpClient newClient() {
@@ -189,7 +186,7 @@ private Realm realm(boolean preemptive) {
 
     @Override
     protected String getTargetUrl() {
-        return "http://127.0.0.1:" + port1 + "/";
+        return "http://localhost:" + port1 + "/";
     }
 
     @Override
diff --git a/client/src/test/java/org/asynchttpclient/BasicAuthTest.java b/client/src/test/java/org/asynchttpclient/BasicAuthTest.java
index b0b0f7c37..b3f8fafad 100644
--- a/client/src/test/java/org/asynchttpclient/BasicAuthTest.java
+++ b/client/src/test/java/org/asynchttpclient/BasicAuthTest.java
@@ -19,6 +19,7 @@
 import static org.asynchttpclient.Dsl.*;
 import static org.asynchttpclient.test.TestUtils.*;
 import static org.testng.Assert.*;
+import io.netty.handler.codec.http.HttpHeaders;
 
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
@@ -81,16 +82,16 @@ public void tearDownGlobal() throws Exception {
 
     @Override
     protected String getTargetUrl() {
-        return "http://127.0.0.1:" + port1 + "/";
+        return "http://localhost:" + port1 + "/";
     }
 
     @Override
     protected String getTargetUrl2() {
-        return "http://127.0.0.1:" + port2 + "/uff";
+        return "http://localhost:" + port2 + "/uff";
     }
 
     protected String getTargetUrlNoAuth() {
-        return "http://127.0.0.1:" + portNoAuth + "/";
+        return "http://localhost:" + portNoAuth + "/";
     }
 
     @Override
@@ -116,7 +117,7 @@ public void handle(String s, Request r, HttpServletRequest request, HttpServletR
                 LOGGER.info("got redirected" + request.getRequestURI());
                 response.setStatus(200);
                 response.addHeader("X-Auth", request.getHeader("Authorization"));
-                response.addHeader("X-Content-Length", String.valueOf(request.getContentLength()));
+                response.addHeader("X-" + HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(request.getContentLength()));
                 byte[] b = "content".getBytes(UTF_8);
                 response.setContentLength(b.length);
                 response.getOutputStream().write(b);
@@ -136,7 +137,7 @@ public void handle(String s, Request r, HttpServletRequest request, HttpServletR
 
             } else {
                 response.addHeader("X-Auth", request.getHeader("Authorization"));
-                response.addHeader("X-Content-Length", String.valueOf(request.getContentLength()));
+                response.addHeader("X-" + HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(request.getContentLength()));
                 response.setStatus(200);
 
                 int size = 10 * 1024;
@@ -173,7 +174,7 @@ public void basicAuthTest() throws IOException, ExecutionException, TimeoutExcep
     }
 
     @Test(groups = "standalone")
-    public void redirectAndDigestAuthTest() throws Exception, ExecutionException, TimeoutException, InterruptedException {
+    public void redirectAndBasicAuthTest() throws Exception, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient(config().setFollowRedirect(true).setMaxRedirects(10))) {
             Future<Response> f = client.prepareGet(getTargetUrl2())//
                     .setRealm(basicAuthRealm(USER, ADMIN).build())//
diff --git a/client/src/test/java/org/asynchttpclient/BasicHttpTest.java b/client/src/test/java/org/asynchttpclient/BasicHttpTest.java
index e7b8d5bec..312c8df70 100755
--- a/client/src/test/java/org/asynchttpclient/BasicHttpTest.java
+++ b/client/src/test/java/org/asynchttpclient/BasicHttpTest.java
@@ -1,36 +1,33 @@
 /*
- * Copyright 2010 Ning, Inc.
+ * Copyright (c) 2016 AsyncHttpClient Project. All rights reserved.
  *
- * Ning licenses this file to you under the Apache License, version 2.0
- * (the "License"); you may not use this file except in compliance with the
- * License.  You may obtain a copy of the License at:
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
- * License for the specific language governing permissions and limitations
- * under the License.
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
 package org.asynchttpclient;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
+import static io.netty.handler.codec.http.HttpHeaders.Names.*;
+import static io.netty.handler.codec.http.HttpHeaders.Values.*;
+import static java.nio.charset.StandardCharsets.*;
+import static java.util.concurrent.TimeUnit.SECONDS;
 import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.EventCollectingHandler.*;
 import static org.asynchttpclient.test.TestUtils.*;
 import static org.asynchttpclient.util.DateUtils.millisTime;
 import static org.testng.Assert.*;
-import io.netty.channel.ChannelOption;
 import io.netty.handler.codec.http.DefaultHttpHeaders;
 import io.netty.handler.codec.http.HttpHeaders;
 
 import java.io.ByteArrayInputStream;
-import java.io.IOException;
 import java.net.ConnectException;
-import java.net.HttpURLConnection;
-import java.net.URL;
 import java.net.UnknownHostException;
+import java.nio.charset.StandardCharsets;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.List;
@@ -39,7 +36,6 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -47,1357 +43,854 @@
 
 import org.asynchttpclient.cookie.Cookie;
 import org.asynchttpclient.handler.MaxRedirectException;
-import org.asynchttpclient.request.body.multipart.Part;
 import org.asynchttpclient.request.body.multipart.StringPart;
 import org.asynchttpclient.test.EventCollectingHandler;
+import org.asynchttpclient.test.TestUtils.AsyncCompletionHandlerAdapter;
+import org.asynchttpclient.testserver.HttpServer;
+import org.asynchttpclient.testserver.HttpTest;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
-public class BasicHttpTest extends AbstractBasicTest {
-
-    @Test(groups = "standalone")
-    public void asyncProviderEncodingTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Request request = get(getTargetUrl() + "?q=+%20x").build();
-            assertEquals(request.getUrl(), getTargetUrl() + "?q=+%20x");
+public class BasicHttpTest extends HttpTest {
 
-            String url = client.executeRequest(request, new AsyncCompletionHandler<String>() {
-                @Override
-                public String onCompleted(Response response) throws Exception {
-                    return response.getUri().toString();
-                }
+    private static HttpServer server;
 
-                @Override
-                public void onThrowable(Throwable t) {
-                    t.printStackTrace();
-                    fail("Unexpected exception: " + t.getMessage(), t);
-                }
-
-            }).get();
-            assertEquals(url, getTargetUrl() + "?q=+%20x");
-        }
+    @BeforeClass
+    public static void start() throws Throwable {
+        server = new HttpServer();
+        server.start();
     }
 
-    @Test(groups = "standalone")
-    public void asyncProviderEncodingTest2() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Request request = get(getTargetUrl() + "").addQueryParam("q", "a b").build();
-
-            String url = client.executeRequest(request, new AsyncCompletionHandler<String>() {
-                @Override
-                public String onCompleted(Response response) throws Exception {
-                    return response.getUri().toString();
-                }
-
-                @Override
-                public void onThrowable(Throwable t) {
-                    t.printStackTrace();
-                    fail("Unexpected exception: " + t.getMessage(), t);
-                }
-
-            }).get();
-            assertEquals(url, getTargetUrl() + "?q=a%20b");
-        }
+    @AfterClass
+    public static void stop() throws Throwable {
+        server.close();
     }
 
-    @Test(groups = "standalone")
-    public void emptyRequestURI() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Request request = get(getTargetUrl()).build();
-
-            String url = client.executeRequest(request, new AsyncCompletionHandler<String>() {
-                @Override
-                public String onCompleted(Response response) throws Exception {
-                    return response.getUri().toString();
-                }
-
-                @Override
-                public void onThrowable(Throwable t) {
-                    t.printStackTrace();
-                    fail("Unexpected exception: " + t.getMessage(), t);
-                }
-
-            }).get();
-            assertEquals(url, getTargetUrl());
-        }
+    private static String getTargetUrl() {
+        return server.getHttpUrl() + "/foo/bar";
     }
 
-    @Test(groups = "standalone")
-    public void asyncProviderContentLenghtGETTest() throws Exception {
-        final HttpURLConnection connection = (HttpURLConnection) new URL(getTargetUrl()).openConnection();
-        connection.connect();
-        final int ct = connection.getContentLength();
-        connection.disconnect();
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            final CountDownLatch l = new CountDownLatch(1);
-
-            Request request = get(getTargetUrl()).build();
-            client.executeRequest(request, new AsyncCompletionHandlerAdapter() {
-
-                @Override
-                public Response onCompleted(Response response) throws Exception {
-                    try {
-                        assertEquals(response.getStatusCode(), 200);
-                        int contentLenght = -1;
-                        if (response.getHeader("content-length") != null) {
-                            contentLenght = Integer.valueOf(response.getHeader("content-length"));
-                        }
-                        assertEquals(contentLenght, ct);
-                    } finally {
-                        l.countDown();
-                    }
-                    return response;
-                }
+    @Test
+    public void getRootUrl() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                String url = server.getHttpUrl();
+                server.enqueueOk();
 
-                @Override
-                public void onThrowable(Throwable t) {
-                    try {
-                        fail("Unexpected exception", t);
-                    } finally {
-                        l.countDown();
-                    }
-                }
-
-            }).get();
-
-            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                fail("Timeout out");
-            }
-        }
+                Response response = client.executeRequest(get(url), new AsyncCompletionHandlerAdapter()).get(TIMEOUT, SECONDS);
+                assertEquals(response.getUri().toUrl(), url);
+            });
+        });
     }
 
-    @Test(groups = "standalone")
-    public void asyncContentTypeGETTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            final CountDownLatch l = new CountDownLatch(1);
-            Request request = get(getTargetUrl()).build();
-            client.executeRequest(request, new AsyncCompletionHandlerAdapter() {
+    @Test
+    public void getUrlWithPathWithoutQuery() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                server.enqueueOk();
 
-                @Override
-                public Response onCompleted(Response response) throws Exception {
-                    try {
-                        assertEquals(response.getStatusCode(), 200);
-                        assertEquals(response.getContentType(), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
-                    } finally {
-                        l.countDown();
-                    }
-                    return response;
-                }
-            }).get();
-            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                fail("Timeout out");
-            }
-        }
+                Response response = client.executeRequest(get(getTargetUrl()), new AsyncCompletionHandlerAdapter()).get(TIMEOUT, SECONDS);
+                assertEquals(response.getUri().toUrl(), getTargetUrl());
+            });
+        });
     }
 
-    @Test(groups = "standalone")
-    public void asyncHeaderGETTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            final CountDownLatch l = new CountDownLatch(1);
-            Request request = get(getTargetUrl()).build();
-            client.executeRequest(request, new AsyncCompletionHandlerAdapter() {
-
-                @Override
-                public Response onCompleted(Response response) throws Exception {
-                    try {
-                        assertEquals(response.getStatusCode(), 200);
-                        assertEquals(response.getContentType(), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
-                    } finally {
-                        l.countDown();
-                    }
-                    return response;
-                }
-            }).get();
+    @Test
+    public void getUrlWithPathWithQuery() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                String targetUrl = getTargetUrl() + "?q=+%20x";
+                Request request = get(targetUrl).build();
+                assertEquals(request.getUrl(), targetUrl);
+                server.enqueueOk();
 
-            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                fail("Timeout out");
-            }
-        }
+                Response response = client.executeRequest(request, new AsyncCompletionHandlerAdapter()).get(TIMEOUT, SECONDS);
+                assertEquals(response.getUri().toUrl(), targetUrl);
+            });
+        });
     }
 
-    @Test(groups = "standalone")
-    public void asyncHeaderPOSTTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            final CountDownLatch l = new CountDownLatch(1);
-            HttpHeaders h = new DefaultHttpHeaders();
-            h.add("Test1", "Test1");
-            h.add("Test2", "Test2");
-            h.add("Test3", "Test3");
-            h.add("Test4", "Test4");
-            h.add("Test5", "Test5");
-            Request request = get(getTargetUrl()).setHeaders(h).build();
-
-            client.executeRequest(request, new AsyncCompletionHandlerAdapter() {
-
-                @Override
-                public Response onCompleted(Response response) throws Exception {
-                    try {
-                        assertEquals(response.getStatusCode(), 200);
-                        for (int i = 1; i < 5; i++) {
-                            assertEquals(response.getHeader("X-Test" + i), "Test" + i);
-                        }
-                    } finally {
-                        l.countDown();
-                    }
-                    return response;
-                }
-            }).get();
+    @Test
+    public void getUrlWithPathWithQueryParams() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                server.enqueueOk();
 
-            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                fail("Timeout out");
-            }
-        }
+                Response response = client.executeRequest(get(getTargetUrl()).addQueryParam("q", "a b"), new AsyncCompletionHandlerAdapter()).get(TIMEOUT, SECONDS);
+                assertEquals(response.getUri().toUrl(), getTargetUrl() + "?q=a%20b");
+            });
+        });
     }
 
-    @Test(groups = "standalone")
-    public void asyncParamPOSTTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            final CountDownLatch l = new CountDownLatch(1);
-            HttpHeaders h = new DefaultHttpHeaders();
-            h.add(HttpHeaders.Names.CONTENT_TYPE, HttpHeaders.Values.APPLICATION_X_WWW_FORM_URLENCODED);
-
-            Map<String, List<String>> m = new HashMap<>();
-            for (int i = 0; i < 5; i++) {
-                m.put("param_" + i, Arrays.asList("value_" + i));
-            }
-            Request request = post(getTargetUrl()).setHeaders(h).setFormParams(m).build();
-            client.executeRequest(request, new AsyncCompletionHandlerAdapter() {
-
-                @Override
-                public Response onCompleted(Response response) throws Exception {
-                    try {
-                        assertEquals(response.getStatusCode(), 200);
-                        for (int i = 1; i < 5; i++) {
-                            assertEquals(response.getHeader("X-param_" + i), "value_" + i);
-                        }
-                    } finally {
-                        l.countDown();
-                    }
-                    return response;
-                }
-            }).get();
+    @Test
+    public void getResponseBody() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                final String body = "Hello World";
 
-            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                fail("Timeout out");
-            }
-        }
-    }
+                server.enqueueResponse(response -> {
+                    response.setStatus(200);
+                    response.setContentType(TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
+                    writeResponseBody(response, body);
+                });
 
-    @Test(groups = "standalone")
-    public void asyncStatusHEADTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            final CountDownLatch l = new CountDownLatch(1);
-            Request request = head(getTargetUrl()).build();
-            Response response = client.executeRequest(request, new AsyncCompletionHandlerAdapter() {
+                client.executeRequest(get(getTargetUrl()), new AsyncCompletionHandlerAdapter() {
 
-                @Override
-                public Response onCompleted(Response response) throws Exception {
-                    try {
+                    @Override
+                    public Response onCompleted(Response response) throws Exception {
                         assertEquals(response.getStatusCode(), 200);
-                    } finally {
-                        l.countDown();
+                        String contentLengthHeader = response.getHeader(CONTENT_LENGTH);
+                        assertNotNull(contentLengthHeader);
+                        assertEquals(Integer.parseInt(contentLengthHeader), body.length());
+                        assertContentTypesEquals(response.getContentType(), TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
+                        assertEquals(response.getResponseBody(), body);
+                        return response;
                     }
-                    return response;
-                }
-            }).get();
-
-            try {
-                String s = response.getResponseBody();
-                assertEquals("", s);
-            } catch (IllegalStateException ex) {
-                fail();
-            }
-
-            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                fail("Timeout out");
-            }
-        }
+                }).get(TIMEOUT, SECONDS);
+            });
+        });
     }
 
-    // TODO: fix test
-    @Test(groups = "standalone", enabled = false)
-    public void asyncStatusHEADContentLenghtTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(120 * 1000))) {
-            final CountDownLatch l = new CountDownLatch(1);
-            Request request = head(getTargetUrl()).build();
-
-            client.executeRequest(request, new AsyncCompletionHandlerAdapter() {
-                @Override
-                public Response onCompleted(Response response) throws Exception {
-                    fail();
-                    return response;
-                }
-
-                @Override
-                public void onThrowable(Throwable t) {
-                    try {
-                        assertEquals(t.getClass(), IOException.class);
-                        assertEquals(t.getMessage(), "No response received. Connection timed out");
-                    } finally {
-                        l.countDown();
-                    }
-
+    @Test
+    public void getWithHeaders() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                HttpHeaders h = new DefaultHttpHeaders();
+                for (int i = 1; i < 5; i++) {
+                    h.add("Test" + i, "Test" + i);
                 }
-            }).get();
-
-            if (!l.await(10 * 5 * 1000, TimeUnit.SECONDS)) {
-                fail("Timeout out");
-            }
-        }
-    }
-
-    @Test(groups = "online", expectedExceptions = NullPointerException.class)
-    public void asyncNullSchemeTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            client.prepareGet("www.sun.com").execute();
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void asyncDoGetTransferEncodingTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            final CountDownLatch l = new CountDownLatch(1);
 
-            client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
+                server.enqueueEcho();
 
-                @Override
-                public Response onCompleted(Response response) throws Exception {
-                    try {
-                        assertEquals(response.getStatusCode(), 200);
-                        assertEquals(response.getHeader("Transfer-Encoding"), "chunked");
-                    } finally {
-                        l.countDown();
-                    }
-                    return response;
-                }
-            }).get();
-
-            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                fail("Timeout out");
-            }
-        }
-    }
+                client.executeRequest(get(getTargetUrl()).setHeaders(h), new AsyncCompletionHandlerAdapter() {
 
-    @Test(groups = "standalone")
-    public void asyncDoGetHeadersTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            final CountDownLatch l = new CountDownLatch(1);
-            HttpHeaders h = new DefaultHttpHeaders();
-            h.add("Test1", "Test1");
-            h.add("Test2", "Test2");
-            h.add("Test3", "Test3");
-            h.add("Test4", "Test4");
-            h.add("Test5", "Test5");
-            client.prepareGet(getTargetUrl()).setHeaders(h).execute(new AsyncCompletionHandlerAdapter() {
-
-                @Override
-                public Response onCompleted(Response response) throws Exception {
-                    try {
+                    @Override
+                    public Response onCompleted(Response response) throws Exception {
                         assertEquals(response.getStatusCode(), 200);
                         for (int i = 1; i < 5; i++) {
                             assertEquals(response.getHeader("X-Test" + i), "Test" + i);
                         }
-                    } finally {
-                        l.countDown();
-                    }
-                    return response;
-                }
-            }).get();
-            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                fail("Timeout out");
-            }
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void asyncDoGetCookieTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            final CountDownLatch l = new CountDownLatch(1);
-            HttpHeaders h = new DefaultHttpHeaders();
-            h.add("Test1", "Test1");
-            h.add("Test2", "Test2");
-            h.add("Test3", "Test3");
-            h.add("Test4", "Test4");
-            h.add("Test5", "Test5");
-
-            final Cookie coo = Cookie.newValidCookie("foo", "value", false, "/", "/", Long.MIN_VALUE, false, false);
-            client.prepareGet(getTargetUrl()).setHeaders(h).addCookie(coo).execute(new AsyncCompletionHandlerAdapter() {
-
-                @Override
-                public Response onCompleted(Response response) throws Exception {
-                    try {
-                        assertEquals(response.getStatusCode(), 200);
-                        List<Cookie> cookies = response.getCookies();
-                        assertEquals(cookies.size(), 1);
-                        assertEquals(cookies.get(0).toString(), "foo=value");
-                    } finally {
-                        l.countDown();
+                        return response;
                     }
-                    return response;
-                }
-            }).get();
-
-            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                fail("Timeout out");
-            }
-        }
+                }).get(TIMEOUT, SECONDS);
+            });
+        });
     }
 
-    @Test(groups = "standalone")
-    public void asyncDoPostDefaultContentType() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            final CountDownLatch l = new CountDownLatch(1);
-            client.preparePost(getTargetUrl()).addFormParam("foo", "bar").execute(new AsyncCompletionHandlerAdapter() {
+    @Test
+    public void postWithHeadersAndFormParams() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                HttpHeaders h = new DefaultHttpHeaders();
+                h.add(CONTENT_TYPE, APPLICATION_X_WWW_FORM_URLENCODED);
 
-                @Override
-                public Response onCompleted(Response response) throws Exception {
-                    try {
-                        assertEquals(response.getStatusCode(), 200);
-                        HttpHeaders h = response.getHeaders();
-                        assertEquals(h.get("X-Content-Type"), HttpHeaders.Values.APPLICATION_X_WWW_FORM_URLENCODED);
-                    } finally {
-                        l.countDown();
-                    }
-                    return response;
+                Map<String, List<String>> m = new HashMap<>();
+                for (int i = 0; i < 5; i++) {
+                    m.put("param_" + i, Arrays.asList("value_" + i));
                 }
-            }).get();
 
-            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                fail("Timeout out");
-            }
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void asyncDoPostBodyIsoTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Response response = client.preparePost(getTargetUrl()).addHeader("X-ISO", "true").setBody("\u017D\u017D\u017D\u017D\u017D\u017D").execute().get();
-            assertEquals(response.getResponseBody().getBytes("ISO-8859-1"), "\u017D\u017D\u017D\u017D\u017D\u017D".getBytes("ISO-8859-1"));
-        }
-    }
+                Request request = post(getTargetUrl()).setHeaders(h).setFormParams(m).build();
 
-    @Test(groups = "standalone")
-    public void asyncDoPostBytesTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            final CountDownLatch l = new CountDownLatch(1);
-            HttpHeaders h = new DefaultHttpHeaders();
-            h.add(HttpHeaders.Names.CONTENT_TYPE, HttpHeaders.Values.APPLICATION_X_WWW_FORM_URLENCODED);
-            StringBuilder sb = new StringBuilder();
-            for (int i = 0; i < 5; i++) {
-                sb.append("param_").append(i).append("=value_").append(i).append("&");
-            }
-            sb.setLength(sb.length() - 1);
+                server.enqueueEcho();
 
-            client.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
+                client.executeRequest(request, new AsyncCompletionHandlerAdapter() {
 
-                @Override
-                public Response onCompleted(Response response) throws Exception {
-                    try {
+                    @Override
+                    public Response onCompleted(Response response) throws Exception {
                         assertEquals(response.getStatusCode(), 200);
                         for (int i = 1; i < 5; i++) {
-                            System.out.println(">>>>> " + response.getHeader("X-param_" + i));
                             assertEquals(response.getHeader("X-param_" + i), "value_" + i);
-
                         }
-                    } finally {
-                        l.countDown();
+                        return response;
                     }
-                    return response;
-                }
-            }).get();
-
-            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                fail("Timeout out");
-            }
-        }
+                }).get(TIMEOUT, SECONDS);
+            });
+        });
     }
 
-    @Test(groups = "standalone")
-    public void asyncDoPostInputStreamTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            final CountDownLatch l = new CountDownLatch(1);
-            HttpHeaders h = new DefaultHttpHeaders();
-            h.add(HttpHeaders.Names.CONTENT_TYPE, HttpHeaders.Values.APPLICATION_X_WWW_FORM_URLENCODED);
-            StringBuilder sb = new StringBuilder();
-            for (int i = 0; i < 5; i++) {
-                sb.append("param_").append(i).append("=value_").append(i).append("&");
-            }
-            sb.setLength(sb.length() - 1);
-            ByteArrayInputStream is = new ByteArrayInputStream(sb.toString().getBytes());
-
-            client.preparePost(getTargetUrl()).setHeaders(h).setBody(is).execute(new AsyncCompletionHandlerAdapter() {
+    @Test
+    public void headHasEmptyBody() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                server.enqueueOk();
 
-                @Override
-                public Response onCompleted(Response response) throws Exception {
-                    try {
+                Response response = client.executeRequest(head(getTargetUrl()), new AsyncCompletionHandlerAdapter() {
+                    @Override
+                    public Response onCompleted(Response response) throws Exception {
                         assertEquals(response.getStatusCode(), 200);
-                        for (int i = 1; i < 5; i++) {
-                            System.out.println(">>>>> " + response.getHeader("X-param_" + i));
-                            assertEquals(response.getHeader("X-param_" + i), "value_" + i);
-
-                        }
-                    } finally {
-                        l.countDown();
+                        return response;
                     }
-                    return response;
-                }
-            }).get();
-            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                fail("Timeout out");
-            }
-        }
-    }
+                }).get(TIMEOUT, SECONDS);
 
-    @Test(groups = "standalone")
-    public void asyncDoPutInputStreamTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            final CountDownLatch l = new CountDownLatch(1);
-            HttpHeaders h = new DefaultHttpHeaders();
-            h.add(HttpHeaders.Names.CONTENT_TYPE, HttpHeaders.Values.APPLICATION_X_WWW_FORM_URLENCODED);
-            StringBuilder sb = new StringBuilder();
-            for (int i = 0; i < 5; i++) {
-                sb.append("param_").append(i).append("=value_").append(i).append("&");
-            }
-            sb.setLength(sb.length() - 1);
-            ByteArrayInputStream is = new ByteArrayInputStream(sb.toString().getBytes());
-
-            client.preparePut(getTargetUrl()).setHeaders(h).setBody(is).execute(new AsyncCompletionHandlerAdapter() {
-
-                @Override
-                public Response onCompleted(Response response) throws Exception {
-                    try {
-                        assertEquals(response.getStatusCode(), 200);
-                        for (int i = 1; i < 5; i++) {
-                            assertEquals(response.getHeader("X-param_" + i), "value_" + i);
-                        }
-                    } finally {
-                        l.countDown();
-                    }
-                    return response;
-                }
-            }).get();
-            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                fail("Timeout out");
-            }
-        }
+                assertTrue(response.getResponseBody().isEmpty());
+            });
+        });
+    }
+
+    @Test(expectedExceptions = NullPointerException.class)
+    public void nullSchemeThrowsNPE() throws Throwable {
+        withClient().run(client -> client.prepareGet("gatling.io").execute());
+    }
+
+    @Test
+    public void jettyRespondsWithChunkedTransferEncoding() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                server.enqueueEcho();
+                client.prepareGet(getTargetUrl())//
+                        .execute(new AsyncCompletionHandlerAdapter() {
+                            @Override
+                            public Response onCompleted(Response response) throws Exception {
+                                assertEquals(response.getStatusCode(), 200);
+                                assertEquals(response.getHeader(TRANSFER_ENCODING), CHUNKED);
+                                return response;
+                            }
+                        }).get(TIMEOUT, SECONDS);
+            });
+        });
+    }
+
+    @Test
+    public void getWithCookies() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                final Cookie coo = Cookie.newValidCookie("foo", "value", false, "/", "/", Long.MIN_VALUE, false, false);
+                server.enqueueEcho();
+
+                client.prepareGet(getTargetUrl())//
+                        .addCookie(coo)//
+                        .execute(new AsyncCompletionHandlerAdapter() {
+                            @Override
+                            public Response onCompleted(Response response) throws Exception {
+                                assertEquals(response.getStatusCode(), 200);
+                                List<Cookie> cookies = response.getCookies();
+                                assertEquals(cookies.size(), 1);
+                                assertEquals(cookies.get(0).toString(), "foo=value");
+                                return response;
+                            }
+                        }).get(TIMEOUT, SECONDS);
+            });
+        });
+    }
+
+    @Test
+    public void defaultRequestBodyEncodingIsIso() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                server.enqueueEcho();
+                Response response = client.preparePost(getTargetUrl())//
+                        .setBody("\u017D\u017D\u017D\u017D\u017D\u017D")//
+                        .execute().get();
+                assertEquals(response.getResponseBodyAsBytes(), "\u017D\u017D\u017D\u017D\u017D\u017D".getBytes(ISO_8859_1));
+            });
+        });
+    }
+
+    @Test
+    public void postFormParametersAsBodyString() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                HttpHeaders h = new DefaultHttpHeaders();
+                h.add(CONTENT_TYPE, APPLICATION_X_WWW_FORM_URLENCODED);
+
+                StringBuilder sb = new StringBuilder();
+                for (int i = 0; i < 5; i++) {
+                    sb.append("param_").append(i).append("=value_").append(i).append("&");
+                }
+                sb.setLength(sb.length() - 1);
+
+                server.enqueueEcho();
+                client.preparePost(getTargetUrl())//
+                        .setHeaders(h)//
+                        .setBody(sb.toString())//
+                        .execute(new AsyncCompletionHandlerAdapter() {
+
+                            @Override
+                            public Response onCompleted(Response response) throws Exception {
+                                assertEquals(response.getStatusCode(), 200);
+                                for (int i = 1; i < 5; i++) {
+                                    assertEquals(response.getHeader("X-param_" + i), "value_" + i);
+
+                                }
+                                return response;
+                            }
+                        }).get(TIMEOUT, SECONDS);
+            });
+        });
+    }
+
+    @Test
+    public void postFormParametersAsBodyStream() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                HttpHeaders h = new DefaultHttpHeaders();
+                h.add(CONTENT_TYPE, APPLICATION_X_WWW_FORM_URLENCODED);
+                StringBuilder sb = new StringBuilder();
+                for (int i = 0; i < 5; i++) {
+                    sb.append("param_").append(i).append("=value_").append(i).append("&");
+                }
+                sb.setLength(sb.length() - 1);
+
+                server.enqueueEcho();
+                client.preparePost(getTargetUrl())//
+                        .setHeaders(h)//
+                        .setBody(new ByteArrayInputStream(sb.toString().getBytes(StandardCharsets.UTF_8)))//
+                        .execute(new AsyncCompletionHandlerAdapter() {
+
+                            @Override
+                            public Response onCompleted(Response response) throws Exception {
+                                assertEquals(response.getStatusCode(), 200);
+                                for (int i = 1; i < 5; i++) {
+                                    assertEquals(response.getHeader("X-param_" + i), "value_" + i);
+
+                                }
+                                return response;
+                            }
+                        }).get(TIMEOUT, SECONDS);
+            });
+        });
+    }
+
+    @Test
+    public void putFormParametersAsBodyStream() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                HttpHeaders h = new DefaultHttpHeaders();
+                h.add(CONTENT_TYPE, APPLICATION_X_WWW_FORM_URLENCODED);
+                StringBuilder sb = new StringBuilder();
+                for (int i = 0; i < 5; i++) {
+                    sb.append("param_").append(i).append("=value_").append(i).append("&");
+                }
+                sb.setLength(sb.length() - 1);
+                ByteArrayInputStream is = new ByteArrayInputStream(sb.toString().getBytes());
+
+                server.enqueueEcho();
+                client.preparePut(getTargetUrl())//
+                        .setHeaders(h)//
+                        .setBody(is)//
+                        .execute(new AsyncCompletionHandlerAdapter() {
+
+                            @Override
+                            public Response onCompleted(Response response) throws Exception {
+                                assertEquals(response.getStatusCode(), 200);
+                                for (int i = 1; i < 5; i++) {
+                                    assertEquals(response.getHeader("X-param_" + i), "value_" + i);
+                                }
+                                return response;
+                            }
+                        }).get(TIMEOUT, SECONDS);
+            });
+        });
+    }
+
+    @Test
+    public void postSingleStringPart() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                server.enqueueEcho();
+                client.preparePost(getTargetUrl())//
+                        .addBodyPart(new StringPart("foo", "bar"))//
+                        .execute(new AsyncCompletionHandlerAdapter() {
+                            @Override
+                            public Response onCompleted(Response response) throws Exception {
+                                String requestContentType = response.getHeader("X-" + CONTENT_TYPE);
+                                String boundary = requestContentType.substring((requestContentType.indexOf("boundary") + "boundary".length() + 1));
+                                assertTrue(response.getResponseBody().regionMatches(false, "--".length(), boundary, 0, boundary.length()));
+                                return response;
+                            }
+                        }).get(TIMEOUT, SECONDS);
+            });
+        });
     }
 
-    @Test(groups = "standalone")
-    public void asyncDoPostMultiPartTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            final CountDownLatch l = new CountDownLatch(1);
-
-            Part p = new StringPart("foo", "bar");
-
-            client.preparePost(getTargetUrl()).addBodyPart(p).execute(new AsyncCompletionHandlerAdapter() {
+    @Test
+    public void getVirtualHost() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                String virtualHost = "localhost:" + server.getHttpPort();
 
-                @Override
-                public Response onCompleted(Response response) throws Exception {
-                    try {
-                        String xContentType = response.getHeader("X-Content-Type");
-                        String boundary = xContentType.substring((xContentType.indexOf("boundary") + "boundary".length() + 1));
+                server.enqueueEcho();
+                Response response = client.prepareGet(getTargetUrl())//
+                        .setVirtualHost(virtualHost)//
+                        .execute(new AsyncCompletionHandlerAdapter()).get(TIMEOUT, SECONDS);
 
-                        assertTrue(response.getResponseBody().regionMatches(false, "--".length(), boundary, 0, boundary.length()));
-                    } finally {
-                        l.countDown();
-                    }
-                    return response;
+                assertEquals(response.getStatusCode(), 200);
+                if (response.getHeader("X-" + HOST) == null) {
+                    System.err.println(response);
                 }
-            }).get();
-            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                fail("Timeout out");
-            }
-        }
+                assertEquals(response.getHeader("X-" + HOST), virtualHost);
+            });
+        });
     }
 
-    @Test(groups = "standalone")
-    public void asyncDoPostBasicGZIPTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient(config().setCompressionEnforced(true))) {
-            final CountDownLatch l = new CountDownLatch(1);
-            HttpHeaders h = new DefaultHttpHeaders();
-            h.add(HttpHeaders.Names.CONTENT_TYPE, HttpHeaders.Values.APPLICATION_X_WWW_FORM_URLENCODED);
-            StringBuilder sb = new StringBuilder();
-            for (int i = 0; i < 5; i++) {
-                sb.append("param_").append(i).append("=value_").append(i).append("&");
-            }
-            sb.setLength(sb.length() - 1);
-
-            client.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
+    @Test(expectedExceptions = CancellationException.class)
+    public void cancelledFutureThrowsCancellationException() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                HttpHeaders headers = new DefaultHttpHeaders();
+                headers.add("X-Delay", 5_000);
+                server.enqueueEcho();
 
-                @Override
-                public Response onCompleted(Response response) throws Exception {
-                    try {
-                        assertEquals(response.getStatusCode(), 200);
-                        assertEquals(response.getHeader("X-Accept-Encoding"), "gzip,deflate");
-                    } finally {
-                        l.countDown();
+                Future<Response> future = client.prepareGet(getTargetUrl()).setHeaders(headers).execute(new AsyncCompletionHandlerAdapter() {
+                    @Override
+                    public void onThrowable(Throwable t) {
                     }
-                    return response;
-                }
-            }).get();
-
-            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                fail("Timeout out");
-            }
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void asyncDoPostProxyTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient(config().setProxyServer(proxyServer("127.0.0.1", port2).build()))) {
-            HttpHeaders h = new DefaultHttpHeaders();
-            h.add(HttpHeaders.Names.CONTENT_TYPE, HttpHeaders.Values.APPLICATION_X_WWW_FORM_URLENCODED);
-            StringBuilder sb = new StringBuilder();
-            for (int i = 0; i < 5; i++) {
-                sb.append("param_").append(i).append("=value_").append(i).append("&");
-            }
-            sb.setLength(sb.length() - 1);
-
-            Response response = client.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandler<Response>() {
-                @Override
-                public Response onCompleted(Response response) throws Exception {
-                    return response;
-                }
-
-                @Override
-                public void onThrowable(Throwable t) {
-                }
-            }).get();
-
-            assertEquals(response.getStatusCode(), 200);
-            assertEquals(response.getHeader("X-Connection"), "keep-alive");
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void asyncRequestVirtualServerPOSTTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            HttpHeaders h = new DefaultHttpHeaders();
-            h.add(HttpHeaders.Names.CONTENT_TYPE, HttpHeaders.Values.APPLICATION_X_WWW_FORM_URLENCODED);
-
-            Map<String, List<String>> m = new HashMap<>();
-            for (int i = 0; i < 5; i++) {
-                m.put("param_" + i, Arrays.asList("value_" + i));
-            }
-            Request request = post(getTargetUrl()).setHeaders(h).setFormParams(m).setVirtualHost("localhost:" + port1).build();
-
-            Response response = client.executeRequest(request, new AsyncCompletionHandlerAdapter()).get();
-
-            assertEquals(response.getStatusCode(), 200);
-            if (response.getHeader("X-Host").startsWith("localhost")) {
-                assertEquals(response.getHeader("X-Host"), "localhost:" + port1);
-            } else {
-                assertEquals(response.getHeader("X-Host"), "127.0.0.1:" + port1);
-            }
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void asyncDoPutTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            HttpHeaders h = new DefaultHttpHeaders();
-            h.add(HttpHeaders.Names.CONTENT_TYPE, HttpHeaders.Values.APPLICATION_X_WWW_FORM_URLENCODED);
-            StringBuilder sb = new StringBuilder();
-            for (int i = 0; i < 5; i++) {
-                sb.append("param_").append(i).append("=value_").append(i).append("&");
-            }
-            sb.setLength(sb.length() - 1);
-
-            Response response = client.preparePut(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter()).get();
-
-            assertEquals(response.getStatusCode(), 200);
-        }
+                });
+                future.cancel(true);
+                future.get(TIMEOUT, SECONDS);
+            });
+        });
     }
 
-    @Test(groups = "standalone")
-    public void asyncDoPostLatchBytesTest() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient()) {
-            final CountDownLatch l = new CountDownLatch(1);
-            HttpHeaders h = new DefaultHttpHeaders();
-            h.add(HttpHeaders.Names.CONTENT_TYPE, HttpHeaders.Values.APPLICATION_X_WWW_FORM_URLENCODED);
-            StringBuilder sb = new StringBuilder();
-            for (int i = 0; i < 5; i++) {
-                sb.append("param_").append(i).append("=value_").append(i).append("&");
-            }
-            sb.setLength(sb.length() - 1);
-
-            c.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
+    @Test(expectedExceptions = TimeoutException.class)
+    public void futureTimeOutThrowsTimeoutException() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                HttpHeaders headers = new DefaultHttpHeaders();
+                headers.add("X-Delay", 5_000);
 
-                @Override
-                public Response onCompleted(Response response) throws Exception {
-                    try {
-                        assertEquals(response.getStatusCode(), 200);
-                        for (int i = 1; i < 5; i++) {
-                            assertEquals(response.getHeader("X-param_" + i), "value_" + i);
-                        }
-                        return response;
-                    } finally {
-                        l.countDown();
+                server.enqueueEcho();
+                Future<Response> future = client.prepareGet(getTargetUrl()).setHeaders(headers).execute(new AsyncCompletionHandlerAdapter() {
+                    @Override
+                    public void onThrowable(Throwable t) {
                     }
-                }
-            });
-
-            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                fail("Timeout out");
-            }
-        }
-    }
+                });
 
-    @Test(groups = "standalone", expectedExceptions = CancellationException.class)
-    public void asyncDoPostDelayCancelTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            HttpHeaders h = new DefaultHttpHeaders();
-            h.add(HttpHeaders.Names.CONTENT_TYPE, HttpHeaders.Values.APPLICATION_X_WWW_FORM_URLENCODED);
-            h.add("LockThread", "true");
-            StringBuilder sb = new StringBuilder();
-            sb.append("LockThread=true");
-
-            Future<Response> future = client.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
-                @Override
-                public void onThrowable(Throwable t) {
-                }
+                future.get(2, SECONDS);
             });
-            future.cancel(true);
-            future.get(TIMEOUT, TimeUnit.SECONDS);
-        }
+        });
     }
 
-    @Test(groups = "standalone")
-    public void asyncDoPostDelayBytesTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            HttpHeaders h = new DefaultHttpHeaders();
-            h.add(HttpHeaders.Names.CONTENT_TYPE, HttpHeaders.Values.APPLICATION_X_WWW_FORM_URLENCODED);
-            h.add("LockThread", "true");
-            StringBuilder sb = new StringBuilder();
-            sb.append("LockThread=true");
-
+    @Test(expectedExceptions = ConnectException.class)
+    public void connectFailureThrowsConnectException() throws Throwable {
+        withClient().run(client -> {
+            int dummyPort = findFreePort();
             try {
-                Future<Response> future = client.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
+                client.preparePost(String.format("http://localhost:%d/", dummyPort)).execute(new AsyncCompletionHandlerAdapter() {
                     @Override
                     public void onThrowable(Throwable t) {
-                        t.printStackTrace();
                     }
-                });
-
-                future.get(10, TimeUnit.SECONDS);
+                }).get(TIMEOUT, SECONDS);
             } catch (ExecutionException ex) {
-                if (ex.getCause() instanceof TimeoutException) {
-                    assertTrue(true);
-                }
-            } catch (TimeoutException te) {
-                assertTrue(true);
-            } catch (IllegalStateException ex) {
-                assertTrue(false);
+                throw ex.getCause();
             }
-        }
+        });
     }
 
-    @Test(groups = "standalone")
-    public void asyncDoPostNullBytesTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            HttpHeaders h = new DefaultHttpHeaders();
-            h.add(HttpHeaders.Names.CONTENT_TYPE, HttpHeaders.Values.APPLICATION_X_WWW_FORM_URLENCODED);
-            StringBuilder sb = new StringBuilder();
-            for (int i = 0; i < 5; i++) {
-                sb.append("param_").append(i).append("=value_").append(i).append("&");
-            }
-            sb.setLength(sb.length() - 1);
-
-            Future<Response> future = client.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter());
-
-            Response response = future.get();
-            assertNotNull(response);
-            assertEquals(response.getStatusCode(), 200);
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void asyncDoPostListenerBytesTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            HttpHeaders h = new DefaultHttpHeaders();
-            h.add(HttpHeaders.Names.CONTENT_TYPE, HttpHeaders.Values.APPLICATION_X_WWW_FORM_URLENCODED);
-            StringBuilder sb = new StringBuilder();
-            for (int i = 0; i < 5; i++) {
-                sb.append("param_").append(i).append("=value_").append(i).append("&");
-            }
-            sb.setLength(sb.length() - 1);
+    @Test
+    public void connectFailureNotifiesHandlerWithConnectException() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                final CountDownLatch l = new CountDownLatch(1);
+                int port = findFreePort();
 
-            final CountDownLatch l = new CountDownLatch(1);
-
-            client.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
-                @Override
-                public Response onCompleted(Response response) throws Exception {
-                    try {
-                        assertEquals(response.getStatusCode(), 200);
-                    } finally {
-                        l.countDown();
+                client.prepareGet(String.format("http://localhost:%d/", port)).execute(new AsyncCompletionHandlerAdapter() {
+                    @Override
+                    public void onThrowable(Throwable t) {
+                        try {
+                            assertTrue(t instanceof ConnectException);
+                        } finally {
+                            l.countDown();
+                        }
                     }
-                    return response;
+                });
+
+                if (!l.await(TIMEOUT, SECONDS)) {
+                    fail("Timed out");
                 }
             });
-
-            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                fail("Latch time out");
-            }
-        }
+        });
     }
 
-    @Test(groups = "standalone")
-    public void asyncConnectInvalidFuture() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            int dummyPort = findFreePort();
-            final AtomicInteger count = new AtomicInteger();
-            for (int i = 0; i < 20; i++) {
+    @Test(expectedExceptions = UnknownHostException.class)
+    public void unknownHostThrowsUnknownHostException() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
                 try {
-                    Response response = client.preparePost(String.format("http://127.0.0.1:%d/", dummyPort)).execute(new AsyncCompletionHandlerAdapter() {
+                    client.prepareGet("http://null.gatling.io").execute(new AsyncCompletionHandlerAdapter() {
                         @Override
                         public void onThrowable(Throwable t) {
-                            count.incrementAndGet();
                         }
-                    }).get();
-                    assertNull(response, "Should have thrown ExecutionException");
-                } catch (ExecutionException ex) {
-                    Throwable cause = ex.getCause();
-                    if (!(cause instanceof ConnectException)) {
-                        fail("Should have been caused by ConnectException, not by " + cause.getClass().getName());
-                    }
+                    }).get(TIMEOUT, SECONDS);
+                } catch (ExecutionException e) {
+                    throw e.getCause();
                 }
-            }
-            assertEquals(count.get(), 20);
-        }
+            });
+        });
     }
 
-    @Test(groups = "standalone")
-    public void asyncConnectInvalidPortFuture() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            int dummyPort = findFreePort();
-            try {
-                Response response = client.preparePost(String.format("http://127.0.0.1:%d/", dummyPort)).execute(new AsyncCompletionHandlerAdapter() {
-                    @Override
-                    public void onThrowable(Throwable t) {
-                        t.printStackTrace();
-                    }
-                }).get();
-                assertNull(response, "Should have thrown ExecutionException");
-            } catch (ExecutionException ex) {
-                Throwable cause = ex.getCause();
-                if (!(cause instanceof ConnectException)) {
-                    fail("Should have been caused by ConnectException, not by " + cause.getClass().getName());
-                }
-            }
-        }
+    @Test
+    public void getEmptyBody() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                server.enqueueOk();
+                Response response = client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter())//
+                        .get(TIMEOUT, SECONDS);
+                assertTrue(response.getResponseBody().isEmpty());
+            });
+        });
     }
 
-    @Test(groups = "standalone")
-    public void asyncConnectInvalidPort() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            // pick a random unused local port
-            int port = findFreePort();
+    @Test
+    public void getEmptyBodyNotifiesHandler() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                final AtomicBoolean handlerWasNotified = new AtomicBoolean();
+
+                server.enqueueOk();
+                client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
 
-            try {
-                Response response = client.preparePost(String.format("http://127.0.0.1:%d/", port)).execute(new AsyncCompletionHandlerAdapter() {
                     @Override
-                    public void onThrowable(Throwable t) {
-                        t.printStackTrace();
+                    public Response onCompleted(Response response) throws Exception {
+                        assertEquals(response.getStatusCode(), 200);
+                        handlerWasNotified.set(true);
+                        return response;
                     }
-                }).get();
-                assertNull(response, "No ExecutionException was thrown");
-            } catch (ExecutionException ex) {
-                assertEquals(ex.getCause().getClass(), ConnectException.class);
-            }
-        }
+                }).get(TIMEOUT, SECONDS);
+                assertTrue(handlerWasNotified.get());
+            });
+        });
     }
 
-    @Test(groups = "standalone")
-    public void asyncConnectInvalidHandlerPort() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            final CountDownLatch l = new CountDownLatch(1);
-            int port = findFreePort();
+    @Test
+    public void exceptionInOnCompletedGetNotifiedToOnThrowable() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                final CountDownLatch latch = new CountDownLatch(1);
+                final AtomicReference<String> message = new AtomicReference<String>();
 
-            client.prepareGet(String.format("http://127.0.0.1:%d/", port)).execute(new AsyncCompletionHandlerAdapter() {
-                @Override
-                public void onThrowable(Throwable t) {
-                    try {
-                        assertEquals(t.getClass(), ConnectException.class);
-                    } finally {
-                        l.countDown();
+                server.enqueueOk();
+                client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
+                    @Override
+                    public Response onCompleted(Response response) throws Exception {
+                        throw new IllegalStateException("FOO");
                     }
-                }
-            });
-
-            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                fail("Timed out");
-            }
-        }
-    }
-
-    @Test(groups = "online", expectedExceptions = UnknownHostException.class)
-    public void asyncConnectInvalidHandlerHost() throws Throwable {
-        try (AsyncHttpClient client = asyncHttpClient()) {
 
-            final AtomicReference<Throwable> e = new AtomicReference<>();
-            final CountDownLatch l = new CountDownLatch(1);
+                    @Override
+                    public void onThrowable(Throwable t) {
+                        message.set(t.getMessage());
+                        latch.countDown();
+                    }
+                });
 
-            client.prepareGet("http://null.apache.org:9999/").execute(new AsyncCompletionHandlerAdapter() {
-                @Override
-                public void onThrowable(Throwable t) {
-                    e.set(t);
-                    l.countDown();
+                if (!latch.await(TIMEOUT, SECONDS)) {
+                    fail("Timed out");
                 }
-            });
-
-            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                fail("Timed out");
-            }
 
-            assertNotNull(e.get());
-            throw e.get();
-        }
+                assertEquals(message.get(), "FOO");
+            });
+        });
     }
 
-    @Test(groups = "standalone")
-    public void asyncConnectInvalidFuturePort() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            final AtomicBoolean called = new AtomicBoolean(false);
-            final AtomicBoolean rightCause = new AtomicBoolean(false);
-            // pick a random unused local port
-            int port = findFreePort();
+    @Test(expectedExceptions = IllegalStateException.class)
+    public void exceptionInOnCompletedGetNotifiedToFuture() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                server.enqueueOk();
+                Future<Response> whenResponse = client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
+                    @Override
+                    public Response onCompleted(Response response) throws Exception {
+                        throw new IllegalStateException("FOO");
+                    }
 
-            try {
-                Response response = client.prepareGet(String.format("http://127.0.0.1:%d/", port)).execute(new AsyncCompletionHandlerAdapter() {
                     @Override
                     public void onThrowable(Throwable t) {
-                        called.set(true);
-                        if (t instanceof ConnectException) {
-                            rightCause.set(true);
-                        }
                     }
-                }).get();
-                assertNull(response, "No ExecutionException was thrown");
-            } catch (ExecutionException ex) {
-                assertEquals(ex.getCause().getClass(), ConnectException.class);
-            }
-            assertTrue(called.get(), "onThrowable should get called.");
-            assertTrue(rightCause.get(), "onThrowable should get called with ConnectionException");
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void asyncContentLenghtGETTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Response response = client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
+                });
 
-                @Override
-                public void onThrowable(Throwable t) {
-                    fail("Unexpected exception", t);
+                try {
+                    whenResponse.get(TIMEOUT, SECONDS);
+                } catch (ExecutionException e) {
+                    throw e.getCause();
                 }
-            }).get();
-
-            assertNotNull(response);
-            assertEquals(response.getStatusCode(), 200);
-        }
+            });
+        });
     }
 
-    @Test(groups = "standalone")
-    public void asyncResponseEmptyBody() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Response response = client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
+    @Test(expectedExceptions = TimeoutException.class)
+    public void configTimeoutNotifiesOnThrowableAndFuture() throws Throwable {
+        withClient(config().setRequestTimeout(1_000)).run(client -> {
+            withServer(server).run(server -> {
+                HttpHeaders headers = new DefaultHttpHeaders();
+                headers.add("X-Delay", 5_000); // delay greater than timeout
 
-                @Override
-                public void onThrowable(Throwable t) {
-                    fail("Unexpected exception", t);
-                }
-            }).get();
+                    final AtomicBoolean onCompletedWasNotified = new AtomicBoolean();
+                    final AtomicBoolean onThrowableWasNotifiedWithTimeoutException = new AtomicBoolean();
+                    final CountDownLatch latch = new CountDownLatch(1);
 
-            assertEquals(response.getResponseBody(), "");
-        }
-    }
+                    server.enqueueEcho();
+                    Future<Response> whenResponse = client.prepareGet(getTargetUrl()).setHeaders(headers).execute(new AsyncCompletionHandlerAdapter() {
 
-    @Test(groups = "standalone")
-    public void asyncAPIContentLenghtGETTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            // Use a l in case the assert fail
-            final CountDownLatch l = new CountDownLatch(1);
+                        @Override
+                        public Response onCompleted(Response response) throws Exception {
+                            onCompletedWasNotified.set(true);
+                            latch.countDown();
+                            return response;
+                        }
 
-            client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
+                        @Override
+                        public void onThrowable(Throwable t) {
+                            onThrowableWasNotifiedWithTimeoutException.set(t instanceof TimeoutException);
+                            latch.countDown();
+                        }
+                    });
 
-                @Override
-                public Response onCompleted(Response response) throws Exception {
-                    try {
-                        assertEquals(response.getStatusCode(), 200);
-                    } finally {
-                        l.countDown();
+                    if (!latch.await(TIMEOUT, SECONDS)) {
+                        fail("Timed out");
                     }
-                    return response;
-                }
 
-                @Override
-                public void onThrowable(Throwable t) {
-                }
-            });
+                    assertFalse(onCompletedWasNotified.get());
+                    assertTrue(onThrowableWasNotifiedWithTimeoutException.get());
 
-            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                fail("Timed out");
-            }
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void asyncAPIHandlerExceptionTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            // Use a l in case the assert fail
-            final CountDownLatch l = new CountDownLatch(1);
-
-            client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
-                @Override
-                public Response onCompleted(Response response) throws Exception {
-                    throw new IllegalStateException("FOO");
-                }
-
-                @Override
-                public void onThrowable(Throwable t) {
                     try {
-                        if (t.getMessage() != null) {
-                            assertEquals(t.getMessage(), "FOO");
-                        }
-                    } finally {
-                        l.countDown();
+                        whenResponse.get(TIMEOUT, SECONDS);
+                    } catch (ExecutionException e) {
+                        throw e.getCause();
                     }
-                }
-            });
-
-            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                fail("Timed out");
-            }
-        }
+                });
+        });
     }
 
-    @Test(groups = "standalone")
-    public void asyncDoGetDelayHandlerTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(5 * 1000))) {
-            HttpHeaders h = new DefaultHttpHeaders();
-            h.add("LockThread", "true");
-
-            // Use a l in case the assert fail
-            final CountDownLatch l = new CountDownLatch(1);
+    @Test(expectedExceptions = TimeoutException.class)
+    public void configRequestTimeoutHappensInDueTime() throws Throwable {
+        withClient(config().setRequestTimeout(1_000)).run(client -> {
+            withServer(server).run(server -> {
+                HttpHeaders h = new DefaultHttpHeaders();
+                h.add(CONTENT_TYPE, APPLICATION_X_WWW_FORM_URLENCODED);
+                h.add("X-Delay", 2_000);
 
-            client.prepareGet(getTargetUrl()).setHeaders(h).execute(new AsyncCompletionHandlerAdapter() {
-
-                @Override
-                public Response onCompleted(Response response) throws Exception {
-                    try {
-                        fail("Must not receive a response");
-                    } finally {
-                        l.countDown();
-                    }
-                    return response;
-                }
-
-                @Override
-                public void onThrowable(Throwable t) {
-                    try {
-                        if (t instanceof TimeoutException) {
-                            assertTrue(true);
-                        } else {
-                            fail("Unexpected exception", t);
-                        }
-                    } finally {
-                        l.countDown();
-                    }
+                server.enqueueEcho();
+                long start = millisTime();
+                try {
+                    client.prepareGet(getTargetUrl()).setHeaders(h).setUrl(getTargetUrl()).execute().get();
+                } catch (Throwable ex) {
+                    final long elapsedTime = millisTime() - start;
+                    assertTrue(elapsedTime >= 1_000 && elapsedTime <= 1_500);
+                    throw ex.getCause();
                 }
             });
-
-            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                fail("Timed out");
-            }
-        }
+        });
     }
 
-    @Test(groups = "standalone")
-    public void asyncDoGetQueryStringTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            // Use a l in case the assert fail
-            final CountDownLatch l = new CountDownLatch(1);
-
-            AsyncCompletionHandler<Response> handler = new AsyncCompletionHandlerAdapter() {
-
-                @Override
-                public Response onCompleted(Response response) throws Exception {
-                    try {
-                        assertTrue(response.getHeader("X-pathInfo") != null);
-                        assertTrue(response.getHeader("X-queryString") != null);
-                    } finally {
-                        l.countDown();
+    @Test
+    public void getProperPathAndQueryString() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                server.enqueueEcho();
+                client.prepareGet(getTargetUrl() + "?foo=bar").execute(new AsyncCompletionHandlerAdapter() {
+                    @Override
+                    public Response onCompleted(Response response) throws Exception {
+                        assertTrue(response.getHeader("X-PathInfo") != null);
+                        assertTrue(response.getHeader("X-QueryString") != null);
+                        return response;
                     }
-                    return response;
-                }
-            };
-
-            Request req = get(getTargetUrl() + "?foo=bar").build();
-
-            client.executeRequest(req, handler).get();
-
-            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                fail("Timed out");
-            }
-        }
+                }).get(TIMEOUT, SECONDS);
+            });
+        });
     }
 
-    @Test(groups = "standalone")
-    public void asyncDoGetKeepAliveHandlerTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            // Use a l in case the assert fail
-            final CountDownLatch l = new CountDownLatch(2);
+    @Test
+    public void connectionIsReusedForSequentialRequests() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                final CountDownLatch l = new CountDownLatch(2);
 
-            AsyncCompletionHandler<Response> handler = new AsyncCompletionHandlerAdapter() {
+                AsyncCompletionHandler<Response> handler = new AsyncCompletionHandlerAdapter() {
 
-                String remoteAddr = null;
+                    volatile String clientPort;
 
-                @Override
-                public Response onCompleted(Response response) throws Exception {
-                    try {
-                        assertEquals(response.getStatusCode(), 200);
-                        if (remoteAddr == null) {
-                            remoteAddr = response.getHeader("X-KEEP-ALIVE");
-                        } else {
-                            assertEquals(response.getHeader("X-KEEP-ALIVE"), remoteAddr);
+                    @Override
+                    public Response onCompleted(Response response) throws Exception {
+                        try {
+                            assertEquals(response.getStatusCode(), 200);
+                            if (clientPort == null) {
+                                clientPort = response.getHeader("X-ClientPort");
+                            } else {
+                                // verify that the server saw the same client remote address/port
+                                // so the same connection was used
+                                assertEquals(response.getHeader("X-ClientPort"), clientPort);
+                            }
+                        } finally {
+                            l.countDown();
                         }
-                    } finally {
-                        l.countDown();
+                        return response;
                     }
-                    return response;
-                }
-            };
+                };
 
-            client.prepareGet(getTargetUrl()).execute(handler).get();
-            client.prepareGet(getTargetUrl()).execute(handler);
+                server.enqueueEcho();
+                client.prepareGet(getTargetUrl()).execute(handler).get(TIMEOUT, SECONDS);
+                server.enqueueEcho();
+                client.prepareGet(getTargetUrl()).execute(handler);
 
-            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                fail("Timed out");
-            }
-        }
+                if (!l.await(TIMEOUT, SECONDS)) {
+                    fail("Timed out");
+                }
+            });
+        });
     }
 
-    @Test(groups = "online")
-    public void asyncDoGetMaxRedirectTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient(config().setMaxRedirects(0).setFollowRedirect(true))) {
-            // Use a l in case the assert fail
-            final CountDownLatch l = new CountDownLatch(1);
-
-            AsyncCompletionHandler<Response> handler = new AsyncCompletionHandlerAdapter() {
-
-                @Override
-                public Response onCompleted(Response response) throws Exception {
-                    fail("Should not be here");
-                    return response;
-                }
+    @Test(expectedExceptions = MaxRedirectException.class)
+    public void reachingMaxRedirectThrowsMaxRedirectException() throws Throwable {
+        withClient(config().setMaxRedirects(1).setFollowRedirect(true)).run(client -> {
+            withServer(server).run(server -> {
+                try {
+                    // max redirect is 1, so second redirect will fail
+                    server.enqueueRedirect(301, getTargetUrl());
+                    server.enqueueRedirect(301, getTargetUrl());
+                    client.prepareGet(getTargetUrl()).execute(new AsyncCompletionHandlerAdapter() {
+                        @Override
+                        public Response onCompleted(Response response) throws Exception {
+                            fail("Should not be here");
+                            return response;
+                        }
 
-                @Override
-                public void onThrowable(Throwable t) {
-                    t.printStackTrace();
-                    try {
-                        assertEquals(t.getClass(), MaxRedirectException.class);
-                    } finally {
-                        l.countDown();
-                    }
+                        @Override
+                        public void onThrowable(Throwable t) {
+                        }
+                    }).get(TIMEOUT, SECONDS);
+                } catch (ExecutionException e) {
+                    throw e.getCause();
                 }
-            };
-
-            client.prepareGet("http://google.com").execute(handler);
-
-            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                fail("Timed out");
-            }
-        }
+            });
+        });
     }
 
-    @Test(groups = "online")
-    public void asyncDoGetNestedTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            // FIXME find a proper website that redirects the same number of
-            // times whatever the language
-            // Use a l in case the assert fail
-            final CountDownLatch l = new CountDownLatch(2);
+    @Test
+    public void nonBlockingNestedRequetsFromIoThreadAreFine() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
 
-            final AsyncCompletionHandlerAdapter handler = new AsyncCompletionHandlerAdapter() {
+                final int maxNested = 5;
 
-                private final static int MAX_NESTED = 2;
+                final CountDownLatch latch = new CountDownLatch(2);
 
-                private AtomicInteger nestedCount = new AtomicInteger(0);
+                final AsyncCompletionHandlerAdapter handler = new AsyncCompletionHandlerAdapter() {
 
-                @Override
-                public Response onCompleted(Response response) throws Exception {
-                    try {
-                        if (nestedCount.getAndIncrement() < MAX_NESTED) {
-                            System.out.println("Executing a nested request: " + nestedCount);
-                            client.prepareGet("http://www.lemonde.fr").execute(this);
+                    private AtomicInteger nestedCount = new AtomicInteger(0);
+
+                    @Override
+                    public Response onCompleted(Response response) throws Exception {
+                        try {
+                            if (nestedCount.getAndIncrement() < maxNested) {
+                                client.prepareGet(getTargetUrl()).execute(this);
+                            }
+                        } finally {
+                            latch.countDown();
                         }
-                    } finally {
-                        l.countDown();
+                        return response;
                     }
-                    return response;
-                }
+                };
 
-                @Override
-                public void onThrowable(Throwable t) {
-                    t.printStackTrace();
+                for (int i = 0; i < maxNested + 1; i++) {
+                    server.enqueueOk();
                 }
-            };
-
-            client.prepareGet("http://www.lemonde.fr").execute(handler);
-
-            if (!l.await(TIMEOUT, TimeUnit.SECONDS)) {
-                fail("Timed out");
-            }
-        }
-    }
 
-    @Test(groups = "online")
-    public void asyncDoGetStreamAndBodyTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Response response = client.prepareGet("http://www.lemonde.fr").execute().get();
-            assertEquals(response.getStatusCode(), 200);
-        }
-    }
-
-    @Test(groups = "online")
-    public void asyncUrlWithoutPathTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Response response = client.prepareGet("http://www.lemonde.fr").execute().get();
-            assertEquals(response.getStatusCode(), 200);
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void optionsTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Response response = client.prepareOptions(getTargetUrl()).execute().get();
-
-            assertEquals(response.getStatusCode(), 200);
-            assertEquals(response.getHeader("Allow"), "GET,HEAD,POST,OPTIONS,TRACE");
-        }
-    }
+                client.prepareGet(getTargetUrl()).execute(handler);
 
-    @Test(groups = "online")
-    public void testAwsS3() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Response response = client.prepareGet("http://test.s3.amazonaws.com/").execute().get();
-            if (response.getResponseBody() == null || response.getResponseBody().equals("")) {
-                fail("No response Body");
-            } else {
-                assertEquals(response.getStatusCode(), 403);
-            }
-        }
+                if (!latch.await(TIMEOUT, SECONDS)) {
+                    fail("Timed out");
+                }
+            });
+        });
     }
 
-    @Test(groups = "online")
-    public void testAsyncHttpProviderConfig() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient(config().addChannelOption(ChannelOption.TCP_NODELAY, Boolean.TRUE))) {
-            Response response = client.prepareGet("http://test.s3.amazonaws.com/").execute().get();
-            if (response.getResponseBody() == null || response.getResponseBody().equals("")) {
-                fail("No response Body");
-            } else {
-                assertEquals(response.getStatusCode(), 403);
-            }
-        }
+    @Test
+    public void optionsIsSupported() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                server.enqueueEcho();
+                Response response = client.prepareOptions(getTargetUrl()).execute().get();
+                assertEquals(response.getStatusCode(), 200);
+                assertEquals(response.getHeader("Allow"), "GET,HEAD,POST,OPTIONS,TRACE");
+            });
+        });
     }
 
-    @Test(groups = "standalone")
-    public void idleRequestTimeoutTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient(config().setPooledConnectionIdleTimeout(5000).setRequestTimeout(10000))) {
-            HttpHeaders h = new DefaultHttpHeaders();
-            h.add(HttpHeaders.Names.CONTENT_TYPE, HttpHeaders.Values.APPLICATION_X_WWW_FORM_URLENCODED);
-            h.add("LockThread", "true");
+    @Test
+    public void cancellingFutureNotifiesOnThrowableWithCancellationException() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                HttpHeaders h = new DefaultHttpHeaders();
+                h.add(CONTENT_TYPE, APPLICATION_X_WWW_FORM_URLENCODED);
+                h.add("X-Delay", 2_000);
 
-            long t1 = millisTime();
-            try {
-                client.prepareGet(getTargetUrl()).setHeaders(h).setUrl(getTargetUrl()).execute().get();
-                fail();
-            } catch (Throwable ex) {
-                final long elapsedTime = millisTime() - t1;
-                System.out.println("EXPIRED: " + (elapsedTime));
-                assertNotNull(ex.getCause());
-                assertTrue(elapsedTime >= 10000 && elapsedTime <= 25000);
-            }
-        }
-    }
+                CountDownLatch latch = new CountDownLatch(1);
 
-    @Test(groups = "standalone")
-    public void asyncDoPostCancelTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            HttpHeaders h = new DefaultHttpHeaders();
-            h.add(HttpHeaders.Names.CONTENT_TYPE, HttpHeaders.Values.APPLICATION_X_WWW_FORM_URLENCODED);
-            h.add("LockThread", "true");
-            StringBuilder sb = new StringBuilder();
-            sb.append("LockThread=true");
-
-            final AtomicReference<CancellationException> ex = new AtomicReference<>();
-            ex.set(null);
-            try {
-                Future<Response> future = client.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandlerAdapter() {
+                Future<Response> future = client.preparePost(getTargetUrl()).setHeaders(h).setBody("Body").execute(new AsyncCompletionHandlerAdapter() {
 
                     @Override
                     public void onThrowable(Throwable t) {
                         if (t instanceof CancellationException) {
-                            ex.set((CancellationException) t);
+                            latch.countDown();
                         }
-                        t.printStackTrace();
                     }
-
                 });
 
                 future.cancel(true);
-            } catch (IllegalStateException ise) {
-                fail();
-            }
-            assertNotNull(ex.get());
-        }
-    }
-
-    @Test(groups = "standalone")
-    public void getShouldAllowBody() throws IOException {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            client.prepareGet(getTargetUrl()).setBody("Boo!").execute();
-        }
-    }
-
-    @Test(groups = "standalone", expectedExceptions = NullPointerException.class)
-    public void invalidUri() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            client.prepareGet(String.format("http:127.0.0.1:%d/foo/test", port1)).build();
-        }
+                if (!latch.await(TIMEOUT, SECONDS)) {
+                    fail("Timed out");
+                }
+            });
+        });
     }
 
-    @Test(groups = "standalone")
-    public void bodyAsByteTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Response response = client.prepareGet(getTargetUrl()).execute().get();
-            assertEquals(response.getStatusCode(), 200);
-            assertEquals(response.getResponseBodyAsBytes(), new byte[] {});
-        }
+    @Test
+    public void getShouldAllowBody() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                client.prepareGet(getTargetUrl()).setBody("Boo!").execute();
+            });
+        });
     }
 
-    @Test(groups = "standalone")
-    public void mirrorByteTest() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            Response response = client.preparePost(getTargetUrl()).setBody("MIRROR").execute().get();
-            assertEquals(response.getStatusCode(), 200);
-            assertEquals(new String(response.getResponseBodyAsBytes(), UTF_8), "MIRROR");
-        }
+    @Test(expectedExceptions = NullPointerException.class)
+    public void malformedUriThrowsException() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                client.prepareGet(String.format("http:localhost:%d/foo/test", server.getHttpPort())).build();
+            });
+        });
     }
 
-    @Test(groups = "standalone")
-    public void testNewConnectionEventsFired() throws Exception {
-        Request request = get("http://127.0.0.1:" + port1 + "/Test").build();
-
-        try (AsyncHttpClient client = asyncHttpClient()) {
-            EventCollectingHandler handler = new EventCollectingHandler();
-            client.executeRequest(request, handler).get(3, TimeUnit.SECONDS);
-            handler.waitForCompletion(3, TimeUnit.SECONDS);
-
-            Object[] expectedEvents = new Object[] { CONNECTION_POOL_EVENT, CONNECTION_OPEN_EVENT, DNS_RESOLVED_EVENT, CONNECTION_SUCCESS_EVENT, REQUEST_SEND_EVENT,
-                    HEADERS_WRITTEN_EVENT, STATUS_RECEIVED_EVENT, HEADERS_RECEIVED_EVENT, CONNECTION_OFFER_EVENT, COMPLETED_EVENT };
-
-            assertEquals(handler.firedEvents.toArray(), expectedEvents, "Got " + Arrays.toString(handler.firedEvents.toArray()));
-        }
+    @Test
+    public void emptyResponseBodyBytesAreEmpty() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+                server.enqueueEcho();
+                Response response = client.prepareGet(getTargetUrl()).execute().get();
+                assertEquals(response.getStatusCode(), 200);
+                assertEquals(response.getResponseBodyAsBytes(), new byte[] {});
+            });
+        });
+    }
+
+    @Test
+    public void newConnectionEventsAreFired() throws Throwable {
+        withClient().run(client -> {
+            withServer(server).run(server -> {
+
+                Request request = get(getTargetUrl()).build();
+
+                EventCollectingHandler handler = new EventCollectingHandler();
+                client.executeRequest(request, handler).get(3, SECONDS);
+                handler.waitForCompletion(3, SECONDS);
+
+                Object[] expectedEvents = new Object[] {//
+                CONNECTION_POOL_EVENT,//
+                        HOSTNAME_RESOLUTION_EVENT,//
+                        HOSTNAME_RESOLUTION_SUCCESS_EVENT,//
+                        CONNECTION_OPEN_EVENT,//
+                        CONNECTION_SUCCESS_EVENT,//
+                        REQUEST_SEND_EVENT,//
+                        HEADERS_WRITTEN_EVENT,//
+                        STATUS_RECEIVED_EVENT,//
+                        HEADERS_RECEIVED_EVENT,//
+                        CONNECTION_OFFER_EVENT,//
+                        COMPLETED_EVENT };
+
+                assertEquals(handler.firedEvents.toArray(), expectedEvents, "Got " + Arrays.toString(handler.firedEvents.toArray()));
+            });
+        });
     }
 }
diff --git a/client/src/test/java/org/asynchttpclient/BasicHttpsTest.java b/client/src/test/java/org/asynchttpclient/BasicHttpsTest.java
index 005ab2850..2a67973ea 100644
--- a/client/src/test/java/org/asynchttpclient/BasicHttpsTest.java
+++ b/client/src/test/java/org/asynchttpclient/BasicHttpsTest.java
@@ -15,131 +15,178 @@
  */
 package org.asynchttpclient;
 
-import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.test.EventCollectingHandler.*;
+import static io.netty.handler.codec.http.HttpHeaders.Names.CONTENT_TYPE;
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.asynchttpclient.Dsl.config;
 import static org.asynchttpclient.test.TestUtils.*;
 import static org.testng.Assert.*;
 import io.netty.handler.codec.http.HttpRequest;
 import io.netty.handler.codec.http.HttpResponse;
 
-import java.net.ConnectException;
 import java.util.Arrays;
 import java.util.concurrent.ExecutionException;
-import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import javax.net.ssl.SSLHandshakeException;
 import javax.servlet.http.HttpServletResponse;
 
-import org.asynchttpclient.channel.pool.KeepAliveStrategy;
+import org.asynchttpclient.channel.KeepAliveStrategy;
 import org.asynchttpclient.test.EventCollectingHandler;
+import org.asynchttpclient.testserver.HttpServer;
+import org.asynchttpclient.testserver.HttpTest;
+import org.testng.annotations.AfterClass;
+import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
-public class BasicHttpsTest extends AbstractBasicHttpsTest {
+public class BasicHttpsTest extends HttpTest {
 
-    protected String getTargetUrl() {
-        return String.format("https://127.0.0.1:%d/foo/test", port1);
+    private static HttpServer server;
+
+    @BeforeClass
+    public static void start() throws Throwable {
+        server = new HttpServer();
+        server.start();
     }
 
-    @Test(groups = "standalone")
-    public void zeroCopyPostTest() throws Exception {
-
-        try (AsyncHttpClient client = asyncHttpClient(config().setSslEngineFactory(createSslEngineFactory(new AtomicBoolean(true))))) {
-            Response resp = client.preparePost(getTargetUrl()).setBody(SIMPLE_TEXT_FILE).setHeader("Content-Type", "text/html").execute().get();
-            assertNotNull(resp);
-            assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
-            assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
-        }
+    @AfterClass
+    public static void stop() throws Throwable {
+        server.close();
     }
 
-    @Test(groups = "standalone")
-    public void multipleSSLRequestsTest() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient(config().setSslEngineFactory(createSslEngineFactory(new AtomicBoolean(true))))) {
-            String body = "hello there";
+    private static String getTargetUrl() {
+        return server.getHttpsUrl() + "/foo/bar";
+    }
 
-            // once
-            Response response = c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
+    @Test
+    public void postBodyOverHttps() throws Throwable {
+        withClient(config().setSslEngineFactory(createSslEngineFactory())).run(client -> {
+            withServer(server).run(server -> {
+                server.enqueueEcho();
+
+                Response resp = client.preparePost(getTargetUrl()).setBody(SIMPLE_TEXT_FILE).setHeader(CONTENT_TYPE, "text/html").execute().get();
+                assertNotNull(resp);
+                assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
+                assertEquals(resp.getResponseBody(), SIMPLE_TEXT_FILE_STRING);
+            });
+        });
+    }
 
-            assertEquals(response.getResponseBody(), body);
+    @Test
+    public void multipleSequentialPostRequestsOverHttps() throws Throwable {
+        withClient(config().setSslEngineFactory(createSslEngineFactory())).run(client -> {
+            withServer(server).run(server -> {
+                server.enqueueEcho();
+                server.enqueueEcho();
 
-            // twice
-            response = c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
+                String body = "hello there";
 
-            assertEquals(response.getResponseBody(), body);
-        }
+                Response response = client.preparePost(getTargetUrl()).setBody(body).setHeader(CONTENT_TYPE, "text/html").execute().get(TIMEOUT, SECONDS);
+                assertEquals(response.getResponseBody(), body);
+
+                response = client.preparePost(getTargetUrl()).setBody(body).setHeader(CONTENT_TYPE, "text/html").execute().get(TIMEOUT, SECONDS);
+                assertEquals(response.getResponseBody(), body);
+            });
+        });
     }
 
-    @Test(groups = "standalone")
-    public void multipleSSLWithoutCacheTest() throws Exception {
+    @Test
+    public void multipleConcurrentPostRequestsOverHttpsWithDisabledKeepAliveStrategy() throws Throwable {
 
         KeepAliveStrategy keepAliveStrategy = new KeepAliveStrategy() {
-
             @Override
             public boolean keepAlive(Request ahcRequest, HttpRequest nettyRequest, HttpResponse nettyResponse) {
                 return !ahcRequest.getUri().isSecured();
             }
         };
 
-        try (AsyncHttpClient c = asyncHttpClient(config().setSslEngineFactory(createSslEngineFactory(new AtomicBoolean(true))).setKeepAliveStrategy(keepAliveStrategy))) {
-            String body = "hello there";
-            c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute();
+        withClient(config().setSslEngineFactory(createSslEngineFactory()).setKeepAliveStrategy(keepAliveStrategy)).run(client -> {
+            withServer(server).run(server -> {
+                server.enqueueEcho();
+                server.enqueueEcho();
+                server.enqueueEcho();
 
-            c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute();
+                String body = "hello there";
 
-            Response response = c.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute().get();
+                client.preparePost(getTargetUrl()).setBody(body).setHeader(CONTENT_TYPE, "text/html").execute();
+                client.preparePost(getTargetUrl()).setBody(body).setHeader(CONTENT_TYPE, "text/html").execute();
 
-            assertEquals(response.getResponseBody(), body);
-        }
+                Response response = client.preparePost(getTargetUrl()).setBody(body).setHeader(CONTENT_TYPE, "text/html").execute().get();
+                assertEquals(response.getResponseBody(), body);
+            });
+        });
     }
 
-    @Test(groups = "standalone")
-    public void reconnectsAfterFailedCertificationPath() throws Exception {
-
-        AtomicBoolean trust = new AtomicBoolean(false);
-        try (AsyncHttpClient client = asyncHttpClient(config().setSslEngineFactory(createSslEngineFactory(trust)))) {
-            String body = "hello there";
-
-            // first request fails because server certificate is rejected
-            Throwable cause = null;
-            try {
-                client.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
-            } catch (final ExecutionException e) {
-                cause = e.getCause();
-            }
-            assertNotNull(cause);
+    @Test
+    public void reconnectAfterFailedCertificationPath() throws Throwable {
+
+        AtomicBoolean trust = new AtomicBoolean();
+
+        withClient(config().setSslEngineFactory(createSslEngineFactory(trust))).run(client -> {
+            withServer(server).run(server -> {
+                server.enqueueEcho();
+                server.enqueueEcho();
+
+                String body = "hello there";
+
+                // first request fails because server certificate is rejected
+                    Throwable cause = null;
+                    try {
+                        client.preparePost(getTargetUrl()).setBody(body).setHeader(CONTENT_TYPE, "text/html").execute().get(TIMEOUT, SECONDS);
+                    } catch (final ExecutionException e) {
+                        cause = e.getCause();
+                    }
+                    assertNotNull(cause);
 
-            // second request should succeed
-            trust.set(true);
-            Response response = client.preparePost(getTargetUrl()).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
+                    // second request should succeed
+                    trust.set(true);
+                    Response response = client.preparePost(getTargetUrl()).setBody(body).setHeader(CONTENT_TYPE, "text/html").execute().get(TIMEOUT, SECONDS);
 
-            assertEquals(response.getResponseBody(), body);
-        }
+                    assertEquals(response.getResponseBody(), body);
+                });
+        });
     }
 
-    @Test(groups = "standalone", timeOut = 2000)
+    @Test(timeOut = 2000, expectedExceptions = SSLHandshakeException.class)
     public void failInstantlyIfNotAllowedSelfSignedCertificate() throws Throwable {
-
-        try (AsyncHttpClient client = asyncHttpClient(config().setRequestTimeout(2000))) {
-            try {
-                client.prepareGet(getTargetUrl()).execute().get(TIMEOUT, TimeUnit.SECONDS);
-            } catch (ExecutionException e) {
-                assertTrue(e.getCause() instanceof ConnectException, "Expecting a ConnectException");
-                assertTrue(e.getCause().getCause() instanceof SSLHandshakeException, "Expecting SSLHandshakeException cause");
-            }
-        }
+        withClient(config().setRequestTimeout(2000)).run(client -> {
+            withServer(server).run(server -> {
+                server.enqueueEcho();
+                try {
+                    client.prepareGet(getTargetUrl()).execute().get(TIMEOUT, SECONDS);
+                } catch (ExecutionException e) {
+                    throw e.getCause().getCause();
+                }
+            });
+        });
     }
 
     @Test(groups = "standalone")
-    public void testNormalEventsFired() throws Exception {
-        try (AsyncHttpClient client = asyncHttpClient(config().setSslEngineFactory(createSslEngineFactory(new AtomicBoolean(true))))) {
-            EventCollectingHandler handler = new EventCollectingHandler();
-            client.preparePost(getTargetUrl()).setBody("whatever").execute(handler).get(3, TimeUnit.SECONDS);
-            handler.waitForCompletion(3, TimeUnit.SECONDS);
-
-            Object[] expectedEvents = new Object[] { CONNECTION_POOL_EVENT, CONNECTION_OPEN_EVENT, DNS_RESOLVED_EVENT, CONNECTION_SUCCESS_EVENT, SSL_HANDSHAKE_COMPLETED_EVENT,
-                    REQUEST_SEND_EVENT, HEADERS_WRITTEN_EVENT, STATUS_RECEIVED_EVENT, HEADERS_RECEIVED_EVENT, CONNECTION_OFFER_EVENT, COMPLETED_EVENT };
-
-            assertEquals(handler.firedEvents.toArray(), expectedEvents, "Got " + Arrays.toString(handler.firedEvents.toArray()));
-        }
+    public void testNormalEventsFired() throws Throwable {
+        withClient(config().setSslEngineFactory(createSslEngineFactory())).run(client -> {
+            withServer(server).run(server -> {
+                EventCollectingHandler handler = new EventCollectingHandler();
+
+                server.enqueueEcho();
+                client.preparePost(getTargetUrl()).setBody("whatever").execute(handler).get(3, SECONDS);
+                handler.waitForCompletion(3, SECONDS);
+
+                Object[] expectedEvents = new Object[] { //
+                CONNECTION_POOL_EVENT,//
+                        HOSTNAME_RESOLUTION_EVENT,//
+                        HOSTNAME_RESOLUTION_SUCCESS_EVENT,//
+                        CONNECTION_OPEN_EVENT,//
+                        CONNECTION_SUCCESS_EVENT,//
+                        TLS_HANDSHAKE_EVENT,//
+                        TLS_HANDSHAKE_SUCCESS_EVENT,//
+                        REQUEST_SEND_EVENT,//
+                        HEADERS_WRITTEN_EVENT,//
+                        STATUS_RECEIVED_EVENT,//
+                        HEADERS_RECEIVED_EVENT,//
+                        CONNECTION_OFFER_EVENT,//
+                        COMPLETED_EVENT };
+
+                assertEquals(handler.firedEvents.toArray(), expectedEvents, "Got " + Arrays.toString(handler.firedEvents.toArray()));
+            });
+        });
     }
 }
diff --git a/client/src/test/java/org/asynchttpclient/ByteBufferCapacityTest.java b/client/src/test/java/org/asynchttpclient/ByteBufferCapacityTest.java
index 8aecbe521..487faa8de 100644
--- a/client/src/test/java/org/asynchttpclient/ByteBufferCapacityTest.java
+++ b/client/src/test/java/org/asynchttpclient/ByteBufferCapacityTest.java
@@ -92,6 +92,6 @@ public State onBodyPartReceived(final HttpResponseBodyPart content) throws Excep
     }
 
     public String getTargetUrl() {
-        return String.format("http://127.0.0.1:%d/foo/test", port1);
+        return String.format("http://localhost:%d/foo/test", port1);
     }
 }
diff --git a/client/src/test/java/org/asynchttpclient/ComplexClientTest.java b/client/src/test/java/org/asynchttpclient/ComplexClientTest.java
index 82d135dfe..64ba61992 100644
--- a/client/src/test/java/org/asynchttpclient/ComplexClientTest.java
+++ b/client/src/test/java/org/asynchttpclient/ComplexClientTest.java
@@ -45,7 +45,7 @@ public void multipleRequestsTest() throws Exception {
     public void urlWithoutSlashTest() throws Exception {
         try (AsyncHttpClient c = asyncHttpClient()) {
             String body = "hello there";
-            Response response = c.preparePost(String.format("http://127.0.0.1:%d/foo/test", port1)).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
+            Response response = c.preparePost(String.format("http://localhost:%d/foo/test", port1)).setBody(body).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
             assertEquals(response.getResponseBody(), body);
         }
     }
diff --git a/client/src/test/java/org/asynchttpclient/DigestAuthTest.java b/client/src/test/java/org/asynchttpclient/DigestAuthTest.java
index b224bf324..b0c09e7aa 100644
--- a/client/src/test/java/org/asynchttpclient/DigestAuthTest.java
+++ b/client/src/test/java/org/asynchttpclient/DigestAuthTest.java
@@ -62,7 +62,7 @@ public AbstractHandler configureHandler() throws Exception {
     @Test(groups = "standalone")
     public void digestAuthTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient()) {
-            Future<Response> f = client.prepareGet("http://127.0.0.1:" + port1 + "/")//
+            Future<Response> f = client.prepareGet("http://localhost:" + port1 + "/")//
                     .setRealm(digestAuthRealm(USER, ADMIN).setRealmName("MyRealm").build())//
                     .execute();
             Response resp = f.get(60, TimeUnit.SECONDS);
@@ -75,7 +75,7 @@ public void digestAuthTest() throws IOException, ExecutionException, TimeoutExce
     @Test(groups = "standalone")
     public void digestAuthTestWithoutScheme() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient()) {
-            Future<Response> f = client.prepareGet("http://127.0.0.1:" + port1 + "/")//
+            Future<Response> f = client.prepareGet("http://localhost:" + port1 + "/")//
                     .setRealm(digestAuthRealm(USER, ADMIN).setRealmName("MyRealm").build())//
                     .execute();
             Response resp = f.get(60, TimeUnit.SECONDS);
@@ -88,7 +88,7 @@ public void digestAuthTestWithoutScheme() throws IOException, ExecutionException
     @Test(groups = "standalone")
     public void digestAuthNegativeTest() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient()) {
-            Future<Response> f = client.prepareGet("http://127.0.0.1:" + port1 + "/")//
+            Future<Response> f = client.prepareGet("http://localhost:" + port1 + "/")//
                     .setRealm(digestAuthRealm("fake", ADMIN).build())//
                     .execute();
             Response resp = f.get(20, TimeUnit.SECONDS);
diff --git a/client/src/test/java/org/asynchttpclient/ErrorResponseTest.java b/client/src/test/java/org/asynchttpclient/ErrorResponseTest.java
index 3af1b6d59..c271f401d 100644
--- a/client/src/test/java/org/asynchttpclient/ErrorResponseTest.java
+++ b/client/src/test/java/org/asynchttpclient/ErrorResponseTest.java
@@ -63,7 +63,7 @@ public AbstractHandler configureHandler() throws Exception {
     @Test(groups = "standalone")
     public void testQueryParameters() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
-            Future<Response> f = client.prepareGet("http://127.0.0.1:" + port1 + "/foo").addHeader("Accepts", "*/*").execute();
+            Future<Response> f = client.prepareGet("http://localhost:" + port1 + "/foo").addHeader("Accepts", "*/*").execute();
             Response resp = f.get(3, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), 400);
diff --git a/client/src/test/java/org/asynchttpclient/Expect100ContinueTest.java b/client/src/test/java/org/asynchttpclient/Expect100ContinueTest.java
index 69e0f44df..0ea397c33 100644
--- a/client/src/test/java/org/asynchttpclient/Expect100ContinueTest.java
+++ b/client/src/test/java/org/asynchttpclient/Expect100ContinueTest.java
@@ -18,6 +18,7 @@
 import static org.asynchttpclient.Dsl.*;
 import static org.asynchttpclient.test.TestUtils.*;
 import static org.testng.Assert.*;
+import io.netty.handler.codec.http.HttpHeaders;
 
 import java.io.IOException;
 import java.util.concurrent.Future;
@@ -61,7 +62,10 @@ public AbstractHandler configureHandler() throws Exception {
     @Test(groups = "standalone")
     public void Expect100Continue() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
-            Future<Response> f = client.preparePut("http://127.0.0.1:" + port1 + "/").setHeader("Expect", "100-continue").setBody(SIMPLE_TEXT_FILE).execute();
+            Future<Response> f = client.preparePut("http://localhost:" + port1 + "/")//
+                    .setHeader(HttpHeaders.Names.EXPECT, HttpHeaders.Values.CONTINUE)//
+                    .setBody(SIMPLE_TEXT_FILE)//
+                    .execute();
             Response resp = f.get();
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
diff --git a/client/src/test/java/org/asynchttpclient/Head302Test.java b/client/src/test/java/org/asynchttpclient/Head302Test.java
index 675d1d8ea..86c4a4076 100644
--- a/client/src/test/java/org/asynchttpclient/Head302Test.java
+++ b/client/src/test/java/org/asynchttpclient/Head302Test.java
@@ -66,7 +66,7 @@ public AbstractHandler configureHandler() throws Exception {
     public void testHEAD302() throws IOException, BrokenBarrierException, InterruptedException, ExecutionException, TimeoutException {
         try (AsyncHttpClient client = asyncHttpClient()) {
             final CountDownLatch l = new CountDownLatch(1);
-            Request request = head("http://127.0.0.1:" + port1 + "/Test").build();
+            Request request = head("http://localhost:" + port1 + "/Test").build();
 
             client.executeRequest(request, new AsyncCompletionHandlerBase() {
                 @Override
diff --git a/client/src/test/java/org/asynchttpclient/ParamEncodingTest.java b/client/src/test/java/org/asynchttpclient/ParamEncodingTest.java
index a6731b761..22ff7a38d 100644
--- a/client/src/test/java/org/asynchttpclient/ParamEncodingTest.java
+++ b/client/src/test/java/org/asynchttpclient/ParamEncodingTest.java
@@ -58,7 +58,7 @@ public void testParameters() throws IOException, ExecutionException, TimeoutExce
 
         String value = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKQLMNOPQRSTUVWXYZ1234567809`~!@#$%^&*()_+-=,.<>/?;:'\"[]{}\\| ";
         try (AsyncHttpClient client = asyncHttpClient()) {
-            Future<Response> f = client.preparePost("http://127.0.0.1:" + port1).addFormParam("test", value).execute();
+            Future<Response> f = client.preparePost("http://localhost:" + port1).addFormParam("test", value).execute();
             Response resp = f.get(10, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
diff --git a/client/src/test/java/org/asynchttpclient/PerRequestRelative302Test.java b/client/src/test/java/org/asynchttpclient/PerRequestRelative302Test.java
index 2c97f1caa..df46cb0aa 100644
--- a/client/src/test/java/org/asynchttpclient/PerRequestRelative302Test.java
+++ b/client/src/test/java/org/asynchttpclient/PerRequestRelative302Test.java
@@ -132,7 +132,7 @@ public void redirected302InvalidTest() throws Exception {
         isSet.getAndSet(false);
         try (AsyncHttpClient c = asyncHttpClient()) {
             // If the test hit a proxy, no ConnectException will be thrown and instead of 404 will be returned.
-            Response response = c.preparePost(getTargetUrl()).setFollowRedirect(true).setHeader("X-redirect", String.format("http://127.0.0.1:%d/", port2)).execute().get();
+            Response response = c.preparePost(getTargetUrl()).setFollowRedirect(true).setHeader("X-redirect", String.format("http://localhost:%d/", port2)).execute().get();
 
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 404);
diff --git a/client/src/test/java/org/asynchttpclient/PerRequestTimeoutTest.java b/client/src/test/java/org/asynchttpclient/PerRequestTimeoutTest.java
index 936f3347d..155ef642d 100644
--- a/client/src/test/java/org/asynchttpclient/PerRequestTimeoutTest.java
+++ b/client/src/test/java/org/asynchttpclient/PerRequestTimeoutTest.java
@@ -44,9 +44,9 @@
     private static final String MSG = "Enough is enough.";
 
     private void checkTimeoutMessage(String message) {
-        assertTrue(message.startsWith("Request timed out"), "error message indicates reason of error");
-        assertTrue(message.contains("127.0.0.1"), "error message contains remote ip address");
-        assertTrue(message.contains("of 100 ms"), "error message contains timeout configuration value");
+        assertTrue(message.startsWith("Request timeout"), "error message indicates reason of error but got: " + message);
+        assertTrue(message.contains("localhost"), "error message contains remote host address but got: " + message);
+        assertTrue(message.contains("after 100ms"), "error message contains timeout configuration value but got: " + message);
     }
 
     @Override
diff --git a/client/src/test/java/org/asynchttpclient/PostWithQSTest.java b/client/src/test/java/org/asynchttpclient/PostWithQSTest.java
index 6074b1386..ff6bf5525 100644
--- a/client/src/test/java/org/asynchttpclient/PostWithQSTest.java
+++ b/client/src/test/java/org/asynchttpclient/PostWithQSTest.java
@@ -70,7 +70,7 @@ public void handle(String s, Request r, HttpServletRequest request, HttpServletR
     @Test(groups = "standalone")
     public void postWithQS() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient()) {
-            Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/?a=b").setBody("abc".getBytes()).execute();
+            Future<Response> f = client.preparePost("http://localhost:" + port1 + "/?a=b").setBody("abc".getBytes()).execute();
             Response resp = f.get(3, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
@@ -80,11 +80,11 @@ public void postWithQS() throws IOException, ExecutionException, TimeoutExceptio
     @Test(groups = "standalone")
     public void postWithNulParamQS() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient()) {
-            Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/?a=").setBody("abc".getBytes()).execute(new AsyncCompletionHandlerBase() {
+            Future<Response> f = client.preparePost("http://localhost:" + port1 + "/?a=").setBody("abc".getBytes()).execute(new AsyncCompletionHandlerBase() {
 
                 @Override
                 public State onStatusReceived(final HttpResponseStatus status) throws Exception {
-                    if (!status.getUri().toUrl().equals("http://127.0.0.1:" + port1 + "/?a=")) {
+                    if (!status.getUri().toUrl().equals("http://localhost:" + port1 + "/?a=")) {
                         throw new IOException(status.getUri().toUrl());
                     }
                     return super.onStatusReceived(status);
@@ -100,11 +100,11 @@ public State onStatusReceived(final HttpResponseStatus status) throws Exception
     @Test(groups = "standalone")
     public void postWithNulParamsQS() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient()) {
-            Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/?a=b&c&d=e").setBody("abc".getBytes()).execute(new AsyncCompletionHandlerBase() {
+            Future<Response> f = client.preparePost("http://localhost:" + port1 + "/?a=b&c&d=e").setBody("abc".getBytes()).execute(new AsyncCompletionHandlerBase() {
 
                 @Override
                 public State onStatusReceived(final HttpResponseStatus status) throws Exception {
-                    if (!status.getUri().toUrl().equals("http://127.0.0.1:" + port1 + "/?a=b&c&d=e")) {
+                    if (!status.getUri().toUrl().equals("http://localhost:" + port1 + "/?a=b&c&d=e")) {
                         throw new IOException("failed to parse the query properly");
                     }
                     return super.onStatusReceived(status);
@@ -120,11 +120,11 @@ public State onStatusReceived(final HttpResponseStatus status) throws Exception
     @Test(groups = "standalone")
     public void postWithEmptyParamsQS() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient()) {
-            Future<Response> f = client.preparePost("http://127.0.0.1:" + port1 + "/?a=b&c=&d=e").setBody("abc".getBytes()).execute(new AsyncCompletionHandlerBase() {
+            Future<Response> f = client.preparePost("http://localhost:" + port1 + "/?a=b&c=&d=e").setBody("abc".getBytes()).execute(new AsyncCompletionHandlerBase() {
 
                 @Override
                 public State onStatusReceived(final HttpResponseStatus status) throws Exception {
-                    if (!status.getUri().toUrl().equals("http://127.0.0.1:" + port1 + "/?a=b&c=&d=e")) {
+                    if (!status.getUri().toUrl().equals("http://localhost:" + port1 + "/?a=b&c=&d=e")) {
                         throw new IOException("failed to parse the query properly");
                     }
                     return super.onStatusReceived(status);
diff --git a/client/src/test/java/org/asynchttpclient/QueryParametersTest.java b/client/src/test/java/org/asynchttpclient/QueryParametersTest.java
index 5e61810d5..8b3429f2c 100644
--- a/client/src/test/java/org/asynchttpclient/QueryParametersTest.java
+++ b/client/src/test/java/org/asynchttpclient/QueryParametersTest.java
@@ -70,7 +70,7 @@ public AbstractHandler configureHandler() throws Exception {
     @Test(groups = "standalone")
     public void testQueryParameters() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient()) {
-            Future<Response> f = client.prepareGet("http://127.0.0.1:" + port1).addQueryParam("a", "1").addQueryParam("b", "2").execute();
+            Future<Response> f = client.prepareGet("http://localhost:" + port1).addQueryParam("a", "1").addQueryParam("b", "2").execute();
             Response resp = f.get(3, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
@@ -97,7 +97,7 @@ public void testUrlRequestParametersEncoding() throws IOException, ExecutionExce
     public void urlWithColonTest() throws Exception {
         try (AsyncHttpClient c = asyncHttpClient()) {
             String query = "test:colon:";
-            Response response = c.prepareGet(String.format("http://127.0.0.1:%d/foo/test/colon?q=%s", port1, query)).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
+            Response response = c.prepareGet(String.format("http://localhost:%d/foo/test/colon?q=%s", port1, query)).setHeader("Content-Type", "text/html").execute().get(TIMEOUT, TimeUnit.SECONDS);
 
             assertEquals(response.getHeader("q"), query);
         }
diff --git a/client/src/test/java/org/asynchttpclient/RC10KTest.java b/client/src/test/java/org/asynchttpclient/RC10KTest.java
index ec745b463..f85bb3f59 100644
--- a/client/src/test/java/org/asynchttpclient/RC10KTest.java
+++ b/client/src/test/java/org/asynchttpclient/RC10KTest.java
@@ -96,7 +96,7 @@ public void rc10kProblem() throws IOException, ExecutionException, TimeoutExcept
             List<Future<Integer>> resps = new ArrayList<>(C10K);
             int i = 0;
             while (i < C10K) {
-                resps.add(ahc.prepareGet(String.format("http://127.0.0.1:%d/%d", ports[i % SRV_COUNT], i)).execute(new MyAsyncHandler(i++)));
+                resps.add(ahc.prepareGet(String.format("http://localhost:%d/%d", ports[i % SRV_COUNT], i)).execute(new MyAsyncHandler(i++)));
             }
             i = 0;
             for (Future<Integer> fResp : resps) {
diff --git a/client/src/test/java/org/asynchttpclient/RedirectBodyTest.java b/client/src/test/java/org/asynchttpclient/RedirectBodyTest.java
index 602d8b0e5..d406748bb 100644
--- a/client/src/test/java/org/asynchttpclient/RedirectBodyTest.java
+++ b/client/src/test/java/org/asynchttpclient/RedirectBodyTest.java
@@ -2,6 +2,7 @@
 
 import static org.asynchttpclient.Dsl.*;
 import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNull;
 
 import java.io.IOException;
 import java.util.concurrent.TimeUnit;
@@ -16,10 +17,18 @@
 import org.asynchttpclient.filter.ResponseFilter;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
+import org.testng.annotations.BeforeMethod;
 import org.testng.annotations.Test;
 
 public class RedirectBodyTest extends AbstractBasicTest {
 
+    private String receivedContentType;
+
+    @BeforeMethod
+    public void setUp() throws Exception {
+        receivedContentType = null;
+    }
+
     @Override
     public AbstractHandler configureHandler() throws Exception {
         return new AbstractHandler() {
@@ -41,6 +50,7 @@ public void handle(String pathInContext, Request request, HttpServletRequest htt
                         IOUtils.read(request.getInputStream(), buffer);
                         httpResponse.getOutputStream().write(buffer);
                     }
+                    receivedContentType = request.getContentType();
                 }
                 httpResponse.getOutputStream().flush();
                 httpResponse.getOutputStream().close();
@@ -60,9 +70,11 @@ public void handle(String pathInContext, Request request, HttpServletRequest htt
     public void regular301LosesBody() throws Exception {
         try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true).addResponseFilter(redirectOnce))) {
             String body = "hello there";
+            String contentType = "text/plain";
 
-            Response response = c.preparePost(getTargetUrl()).setBody(body).setHeader("X-REDIRECT", "301").execute().get(TIMEOUT, TimeUnit.SECONDS);
+            Response response = c.preparePost(getTargetUrl()).setHeader("Content-Type", contentType).setBody(body).setHeader("X-REDIRECT", "301").execute().get(TIMEOUT, TimeUnit.SECONDS);
             assertEquals(response.getResponseBody(), "");
+            assertNull(receivedContentType);
         }
     }
 
@@ -70,9 +82,11 @@ public void regular301LosesBody() throws Exception {
     public void regular302LosesBody() throws Exception {
         try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true).addResponseFilter(redirectOnce))) {
             String body = "hello there";
+            String contentType = "text/plain";
 
-            Response response = c.preparePost(getTargetUrl()).setBody(body).setHeader("X-REDIRECT", "302").execute().get(TIMEOUT, TimeUnit.SECONDS);
+            Response response = c.preparePost(getTargetUrl()).setHeader("Content-Type", contentType).setBody(body).setHeader("X-REDIRECT", "302").execute().get(TIMEOUT, TimeUnit.SECONDS);
             assertEquals(response.getResponseBody(), "");
+            assertNull(receivedContentType);
         }
     }
 
@@ -80,9 +94,11 @@ public void regular302LosesBody() throws Exception {
     public void regular302StrictKeepsBody() throws Exception {
         try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true).setStrict302Handling(true).addResponseFilter(redirectOnce))) {
             String body = "hello there";
+            String contentType = "text/plain";
 
-            Response response = c.preparePost(getTargetUrl()).setBody(body).setHeader("X-REDIRECT", "302").execute().get(TIMEOUT, TimeUnit.SECONDS);
+            Response response = c.preparePost(getTargetUrl()).setHeader("Content-Type", contentType).setBody(body).setHeader("X-REDIRECT", "302").execute().get(TIMEOUT, TimeUnit.SECONDS);
             assertEquals(response.getResponseBody(), body);
+            assertEquals(receivedContentType, contentType);
         }
     }
 
@@ -90,9 +106,11 @@ public void regular302StrictKeepsBody() throws Exception {
     public void regular307KeepsBody() throws Exception {
         try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true).addResponseFilter(redirectOnce))) {
             String body = "hello there";
+            String contentType = "text/plain";
 
-            Response response = c.preparePost(getTargetUrl()).setBody(body).setHeader("X-REDIRECT", "307").execute().get(TIMEOUT, TimeUnit.SECONDS);
+            Response response = c.preparePost(getTargetUrl()).setHeader("Content-Type", contentType).setBody(body).setHeader("X-REDIRECT", "307").execute().get(TIMEOUT, TimeUnit.SECONDS);
             assertEquals(response.getResponseBody(), body);
+            assertEquals(receivedContentType, contentType);
         }
     }
 }
diff --git a/client/src/test/java/org/asynchttpclient/Relative302Test.java b/client/src/test/java/org/asynchttpclient/Relative302Test.java
index e34647d76..584140cc9 100644
--- a/client/src/test/java/org/asynchttpclient/Relative302Test.java
+++ b/client/src/test/java/org/asynchttpclient/Relative302Test.java
@@ -100,7 +100,7 @@ public void redirected302InvalidTest() throws Exception {
 
         // If the test hit a proxy, no ConnectException will be thrown and instead of 404 will be returned.
         try (AsyncHttpClient c = asyncHttpClient(config().setFollowRedirect(true))) {
-            Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", String.format("http://127.0.0.1:%d/", port2)).execute().get();
+            Response response = c.prepareGet(getTargetUrl()).setHeader("X-redirect", String.format("http://localhost:%d/", port2)).execute().get();
 
             assertNotNull(response);
             assertEquals(response.getStatusCode(), 404);
diff --git a/client/src/test/java/org/asynchttpclient/RemoteSiteTest.java b/client/src/test/java/org/asynchttpclient/RemoteSiteTest.java
index 55bc31e6d..4b021fb36 100644
--- a/client/src/test/java/org/asynchttpclient/RemoteSiteTest.java
+++ b/client/src/test/java/org/asynchttpclient/RemoteSiteTest.java
@@ -18,6 +18,7 @@
 import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.asynchttpclient.Dsl.*;
 import static org.testng.Assert.*;
+import io.netty.handler.codec.http.HttpHeaders;
 
 import java.io.InputStream;
 import java.net.URLEncoder;
@@ -47,15 +48,6 @@ public void testGoogleCom() throws Exception {
         }
     }
 
-    @Test(groups = "online")
-    public void testMailGoogleCom() throws Exception {
-        try (AsyncHttpClient c = asyncHttpClient(config().setRequestTimeout(10000))) {
-            Response response = c.prepareGet("http://mail.google.com/").execute().get(10, TimeUnit.SECONDS);
-            assertNotNull(response);
-            assertEquals(response.getStatusCode(), 200);
-        }
-    }
-
     @Test(groups = "online", enabled = false)
     // FIXME
     public void testMicrosoftCom() throws Exception {
@@ -142,10 +134,10 @@ public void invalidStreamTest2() throws Exception {
     @Test(groups = "online")
     public void asyncFullBodyProperlyRead() throws Exception {
         try (AsyncHttpClient client = asyncHttpClient()) {
-            Response r = client.prepareGet("http://www.cyberpresse.ca/").execute().get();
+            Response r = client.prepareGet("http://www.typesafe.com/").execute().get();
 
             InputStream stream = r.getResponseBodyAsStream();
-            int contentLength = Integer.valueOf(r.getHeader("Content-Length"));
+            int contentLength = Integer.valueOf(r.getHeader(HttpHeaders.Names.CONTENT_LENGTH));
 
             assertEquals(contentLength, IOUtils.toByteArray(stream).length);
         }
diff --git a/client/src/test/java/org/asynchttpclient/RequestBuilderTest.java b/client/src/test/java/org/asynchttpclient/RequestBuilderTest.java
index de11fd92a..11961e11f 100644
--- a/client/src/test/java/org/asynchttpclient/RequestBuilderTest.java
+++ b/client/src/test/java/org/asynchttpclient/RequestBuilderTest.java
@@ -18,14 +18,22 @@
 import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.asynchttpclient.Dsl.get;
 import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
 
 import java.io.IOException;
 import java.io.UnsupportedEncodingException;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.concurrent.ExecutionException;
 
+import org.asynchttpclient.cookie.Cookie;
 import org.testng.annotations.Test;
 
+import io.netty.handler.codec.http.HttpMethod;
+
 public class RequestBuilderTest {
 
     private final static String SAFE_CHARS = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890-_~.";
@@ -107,4 +115,40 @@ public void testContentTypeCharsetToBodyEncoding() {
         final Request req2 = get("http://localhost").setHeader("Content-Type", "application/json; charset=\"utf-8\"").build();
         assertEquals(req2.getCharset(), UTF_8);
     }
+    
+    @Test
+    public void testDefaultMethod() {
+        RequestBuilder requestBuilder = new RequestBuilder();
+        String defaultMethodName = HttpMethod.GET.name();
+        assertEquals(requestBuilder.method, defaultMethodName, "Default HTTP method should be " + defaultMethodName);
+    }
+
+    @Test
+    public void testSetHeaders() {
+        RequestBuilder requestBuilder = new RequestBuilder();
+        assertTrue(requestBuilder.headers.isEmpty(), "Headers should be empty by default.");
+
+        Map<String, Collection<String>> headers = new HashMap<>();
+        headers.put("Content-Type", Collections.singleton("application/json"));
+        requestBuilder.setHeaders(headers);
+        assertTrue(requestBuilder.headers.contains("Content-Type"), "headers set by setHeaders have not been set");
+        assertEquals(requestBuilder.headers.get("Content-Type"), "application/json", "header value incorrect");
+    }
+
+    public void testAddOrReplaceCookies() {
+        RequestBuilder requestBuilder = new RequestBuilder();
+        Cookie cookie = new Cookie("name", "value", false, "google.com", "/", 1000, true, true);
+        requestBuilder.addOrReplaceCookie(cookie);
+        assertEquals(requestBuilder.cookies.size(), 1, "cookies size should be 1 after adding one cookie");
+        assertEquals(requestBuilder.cookies.get(0), cookie, "cookie does not match");
+
+        Cookie cookie2 = new Cookie("name", "value2", true, "google2.com", "/path", 1001, false, false);
+        requestBuilder.addOrReplaceCookie(cookie2);
+        assertEquals(requestBuilder.cookies.size(), 1, "cookies size should remain 1 as we just replaced a cookie with same name");
+        assertEquals(requestBuilder.cookies.get(0), cookie2, "cookie does not match");
+
+        Cookie cookie3 = new Cookie("name", "value", false, "google.com", "/", 1000, true, true);
+        requestBuilder.addOrReplaceCookie(cookie3);
+        assertEquals(requestBuilder.cookies.size(), 2, "cookie size must be 2 after adding 1 more cookie i.e. cookie3");
+    }
 }
diff --git a/client/src/test/java/org/asynchttpclient/RetryRequestTest.java b/client/src/test/java/org/asynchttpclient/RetryRequestTest.java
index a4bad984a..826ee9b42 100644
--- a/client/src/test/java/org/asynchttpclient/RetryRequestTest.java
+++ b/client/src/test/java/org/asynchttpclient/RetryRequestTest.java
@@ -22,7 +22,7 @@
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 
-import org.asynchttpclient.util.HttpUtils;
+import org.asynchttpclient.exception.RemotelyClosedException;
 import org.eclipse.jetty.server.Request;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.annotations.Test;
@@ -60,7 +60,7 @@ public void handle(String pathInContext, Request request, HttpServletRequest htt
     }
 
     protected String getTargetUrl() {
-        return String.format("http://127.0.0.1:%d/", port1);
+        return String.format("http://localhost:%d/", port1);
     }
 
     @Override
@@ -74,11 +74,7 @@ public void testMaxRetry() throws Exception {
             ahc.executeRequest(ahc.prepareGet(getTargetUrl()).build()).get();
             fail();
         } catch (Exception t) {
-            assertNotNull(t.getCause());
-            assertEquals(t.getCause().getClass(), IOException.class);
-            if (t.getCause() != HttpUtils.REMOTELY_CLOSED_EXCEPTION) {
-                fail();
-            }
+            assertEquals(t.getCause(), RemotelyClosedException.INSTANCE);
         }
     }
 }
diff --git a/client/src/test/java/org/asynchttpclient/ThreadNameTest.java b/client/src/test/java/org/asynchttpclient/ThreadNameTest.java
index 69aa1ee81..f3b68cd30 100644
--- a/client/src/test/java/org/asynchttpclient/ThreadNameTest.java
+++ b/client/src/test/java/org/asynchttpclient/ThreadNameTest.java
@@ -47,7 +47,7 @@
     public void testThreadName() throws Exception {
         String threadPoolName = "ahc-" + (new Random().nextLong() & 0x7fffffffffffffffL);
         try (AsyncHttpClient client = asyncHttpClient(config().setThreadPoolName(threadPoolName))) {
-            Future<Response> f = client.prepareGet("http://127.0.0.1:" + port1 + "/").execute();
+            Future<Response> f = client.prepareGet("http://localhost:" + port1 + "/").execute();
             f.get(3, TimeUnit.SECONDS);
 
             // We cannot assert that all threads are created with specified name,
diff --git a/client/src/test/java/org/asynchttpclient/channel/pool/ConnectionPoolTest.java b/client/src/test/java/org/asynchttpclient/channel/ConnectionPoolTest.java
similarity index 94%
rename from client/src/test/java/org/asynchttpclient/channel/pool/ConnectionPoolTest.java
rename to client/src/test/java/org/asynchttpclient/channel/ConnectionPoolTest.java
index 1cb37464d..5fbf469e6 100644
--- a/client/src/test/java/org/asynchttpclient/channel/pool/ConnectionPoolTest.java
+++ b/client/src/test/java/org/asynchttpclient/channel/ConnectionPoolTest.java
@@ -13,7 +13,7 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package org.asynchttpclient.channel.pool;
+package org.asynchttpclient.channel;
 
 import static org.asynchttpclient.Dsl.*;
 import static org.asynchttpclient.test.EventCollectingHandler.*;
@@ -37,6 +37,7 @@
 import org.asynchttpclient.ListenableFuture;
 import org.asynchttpclient.RequestBuilder;
 import org.asynchttpclient.Response;
+import org.asynchttpclient.exception.TooManyConnectionsException;
 import org.asynchttpclient.test.EventCollectingHandler;
 import org.testng.annotations.Test;
 
@@ -61,8 +62,8 @@ public void testMaxTotalConnections() throws Exception {
         }
     }
 
-    @Test(groups = "standalone")
-    public void testMaxTotalConnectionsException() throws IOException {
+    @Test(groups = "standalone", expectedExceptions = TooManyConnectionsException.class)
+    public void testMaxTotalConnectionsException() throws Throwable {
         try (AsyncHttpClient client = asyncHttpClient(config().setKeepAlive(true).setMaxConnections(1))) {
             String url = getTargetUrl();
 
@@ -83,8 +84,7 @@ public void testMaxTotalConnectionsException() throws IOException {
             }
 
             assertNotNull(exception);
-            assertNotNull(exception.getCause());
-            assertEquals(exception.getCause().getMessage(), "Too many connections 1");
+            throw exception.getCause();
         }
     }
 
@@ -124,8 +124,8 @@ public Response onCompleted(Response response) throws Exception {
         }
     }
 
-    @Test(groups = "standalone")
-    public void multipleMaxConnectionOpenTest() throws Exception {
+    @Test(groups = "standalone", expectedExceptions = TooManyConnectionsException.class)
+    public void multipleMaxConnectionOpenTest() throws Throwable {
         try (AsyncHttpClient c = asyncHttpClient(config().setKeepAlive(true).setConnectTimeout(5000).setMaxConnections(1))) {
             String body = "hello there";
 
@@ -137,15 +137,14 @@ public void multipleMaxConnectionOpenTest() throws Exception {
             // twice
             Exception exception = null;
             try {
-                c.preparePost(String.format("http://127.0.0.1:%d/foo/test", port2)).setBody(body).execute().get(TIMEOUT, TimeUnit.SECONDS);
+                c.preparePost(String.format("http://localhost:%d/foo/test", port2)).setBody(body).execute().get(TIMEOUT, TimeUnit.SECONDS);
                 fail("Should throw exception. Too many connections issued.");
             } catch (Exception ex) {
                 ex.printStackTrace();
                 exception = ex;
             }
             assertNotNull(exception);
-            assertNotNull(exception.getCause());
-            assertEquals(exception.getCause().getMessage(), "Too many connections 1");
+            throw exception.getCause();
         }
     }
 
@@ -262,7 +261,7 @@ public void nonPoolableConnectionReleaseSemaphoresTest() throws Throwable {
 
     @Test(groups = "standalone")
     public void testPooledEventsFired() throws Exception {
-        RequestBuilder request = get("http://127.0.0.1:" + port1 + "/Test");
+        RequestBuilder request = get("http://localhost:" + port1 + "/Test");
 
         try (AsyncHttpClient client = asyncHttpClient()) {
             EventCollectingHandler firstHandler = new EventCollectingHandler();
diff --git a/client/src/test/java/org/asynchttpclient/channel/MaxConnectionsInThreads.java b/client/src/test/java/org/asynchttpclient/channel/MaxConnectionsInThreads.java
index ee768bcbb..e036e1c8a 100644
--- a/client/src/test/java/org/asynchttpclient/channel/MaxConnectionsInThreads.java
+++ b/client/src/test/java/org/asynchttpclient/channel/MaxConnectionsInThreads.java
@@ -132,7 +132,7 @@ public void setUpGlobal() throws Exception {
     }
 
     public String getTargetUrl() {
-        return "http://127.0.0.1:" + port1 + "/timeout/";
+        return "http://localhost:" + port1 + "/timeout/";
     }
 
     @SuppressWarnings("serial")
diff --git a/client/src/test/java/org/asynchttpclient/filter/FilterTest.java b/client/src/test/java/org/asynchttpclient/filter/FilterTest.java
index b94b3998e..a8ff8f354 100644
--- a/client/src/test/java/org/asynchttpclient/filter/FilterTest.java
+++ b/client/src/test/java/org/asynchttpclient/filter/FilterTest.java
@@ -60,7 +60,7 @@ public AbstractHandler configureHandler() throws Exception {
     }
 
     public String getTargetUrl() {
-        return String.format("http://127.0.0.1:%d/foo/test", port1);
+        return String.format("http://localhost:%d/foo/test", port1);
     }
 
     @Test(groups = "standalone")
diff --git a/client/src/test/java/org/asynchttpclient/handler/BodyDeferringAsyncHandlerTest.java b/client/src/test/java/org/asynchttpclient/handler/BodyDeferringAsyncHandlerTest.java
index f591e033e..0b1cbade9 100644
--- a/client/src/test/java/org/asynchttpclient/handler/BodyDeferringAsyncHandlerTest.java
+++ b/client/src/test/java/org/asynchttpclient/handler/BodyDeferringAsyncHandlerTest.java
@@ -112,7 +112,7 @@ public AsyncHttpClientConfig getAsyncHttpClientConfig() {
     @Test(groups = "standalone")
     public void deferredSimple() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient(getAsyncHttpClientConfig())) {
-            BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/deferredSimple");
+            BoundRequestBuilder r = client.prepareGet("http://localhost:" + port1 + "/deferredSimple");
 
             CountingOutputStream cos = new CountingOutputStream();
             BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(cos);
@@ -136,7 +136,7 @@ public void deferredSimple() throws IOException, ExecutionException, TimeoutExce
     @Test(groups = "standalone", enabled = false)
     public void deferredSimpleWithFailure() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient(getAsyncHttpClientConfig())) {
-            BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/deferredSimpleWithFailure").addHeader("X-FAIL-TRANSFER",
+            BoundRequestBuilder r = client.prepareGet("http://localhost:" + port1 + "/deferredSimpleWithFailure").addHeader("X-FAIL-TRANSFER",
                     Boolean.TRUE.toString());
 
             CountingOutputStream cos = new CountingOutputStream();
@@ -166,7 +166,7 @@ public void deferredSimpleWithFailure() throws IOException, ExecutionException,
     @Test(groups = "standalone")
     public void deferredInputStreamTrick() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient(getAsyncHttpClientConfig())) {
-            BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/deferredInputStreamTrick");
+            BoundRequestBuilder r = client.prepareGet("http://localhost:" + port1 + "/deferredInputStreamTrick");
 
             PipedOutputStream pos = new PipedOutputStream();
             PipedInputStream pis = new PipedInputStream(pos);
@@ -199,7 +199,7 @@ public void deferredInputStreamTrick() throws IOException, ExecutionException, T
     @Test(groups = "standalone")
     public void deferredInputStreamTrickWithFailure() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient(getAsyncHttpClientConfig())) {
-            BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + port1 + "/deferredInputStreamTrickWithFailure").addHeader("X-FAIL-TRANSFER",
+            BoundRequestBuilder r = client.prepareGet("http://localhost:" + port1 + "/deferredInputStreamTrickWithFailure").addHeader("X-FAIL-TRANSFER",
                     Boolean.TRUE.toString());
             PipedOutputStream pos = new PipedOutputStream();
             PipedInputStream pis = new PipedInputStream(pos);
@@ -233,7 +233,7 @@ public void deferredInputStreamTrickWithFailure() throws IOException, ExecutionE
     public void testConnectionRefused() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         int newPortWithoutAnyoneListening = findFreePort();
         try (AsyncHttpClient client = asyncHttpClient(getAsyncHttpClientConfig())) {
-            BoundRequestBuilder r = client.prepareGet("http://127.0.0.1:" + newPortWithoutAnyoneListening + "/testConnectionRefused");
+            BoundRequestBuilder r = client.prepareGet("http://localhost:" + newPortWithoutAnyoneListening + "/testConnectionRefused");
 
             CountingOutputStream cos = new CountingOutputStream();
             BodyDeferringAsyncHandler bdah = new BodyDeferringAsyncHandler(cos);
diff --git a/client/src/test/java/org/asynchttpclient/handler/resumable/PropertiesBasedResumableProcesserTest.java b/client/src/test/java/org/asynchttpclient/handler/resumable/PropertiesBasedResumableProcesserTest.java
index e046d4cf8..6f5bbb33d 100644
--- a/client/src/test/java/org/asynchttpclient/handler/resumable/PropertiesBasedResumableProcesserTest.java
+++ b/client/src/test/java/org/asynchttpclient/handler/resumable/PropertiesBasedResumableProcesserTest.java
@@ -37,4 +37,17 @@ public void testSaveLoad() throws Exception {
         assertEquals(m.get("http://localhost/test.url"), Long.valueOf(15L));
         assertEquals(m.get("http://localhost/test2.url"), Long.valueOf(50L));
     }
+    
+    @Test
+    public void testRemove() {
+        PropertiesBasedResumableProcessor propertiesProcessor = new PropertiesBasedResumableProcessor();
+        propertiesProcessor.put("http://localhost/test.url", 15L);
+        propertiesProcessor.put("http://localhost/test2.url", 50L);
+        propertiesProcessor.remove("http://localhost/test.url");
+        propertiesProcessor.save(null);
+        propertiesProcessor = new PropertiesBasedResumableProcessor();
+        Map<String, Long> propertiesMap = propertiesProcessor.load();
+        assertEquals(propertiesMap.size(), 1);
+        assertEquals(propertiesMap.get("http://localhost/test2.url"), Long.valueOf(50L));
+    }
 }
diff --git a/client/src/test/java/org/asynchttpclient/handler/resumable/ResumableAsyncHandlerTest.java b/client/src/test/java/org/asynchttpclient/handler/resumable/ResumableAsyncHandlerTest.java
index 611c21341..9da7024cf 100644
--- a/client/src/test/java/org/asynchttpclient/handler/resumable/ResumableAsyncHandlerTest.java
+++ b/client/src/test/java/org/asynchttpclient/handler/resumable/ResumableAsyncHandlerTest.java
@@ -14,32 +14,186 @@
  */
 
 import static org.asynchttpclient.Dsl.get;
+import static org.mockito.Matchers.anyObject;
+import static org.mockito.Mockito.*;
+import static org.powermock.api.mockito.PowerMockito.mock;
 import static org.testng.Assert.*;
+import io.netty.handler.codec.http.DefaultHttpHeaders;
 import io.netty.handler.codec.http.HttpHeaders;
 
+import java.io.IOException;
+import java.nio.ByteBuffer;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHandler.State;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.HttpResponseStatus;
 import org.asynchttpclient.Request;
+import org.asynchttpclient.Response;
+import org.asynchttpclient.uri.Uri;
+import org.powermock.api.mockito.PowerMockito;
+import org.powermock.core.classloader.annotations.PrepareForTest;
+import org.powermock.modules.testng.PowerMockTestCase;
 import org.testng.annotations.Test;
 
 /**
  * @author Benjamin Hanzelmann
  */
-public class ResumableAsyncHandlerTest {
-
-    @Test(groups = "standalone")
+@PrepareForTest({ HttpResponseStatus.class, State.class })
+public class ResumableAsyncHandlerTest extends PowerMockTestCase {
+    @Test
     public void testAdjustRange() {
         MapResumableProcessor proc = new MapResumableProcessor();
 
-        ResumableAsyncHandler h = new ResumableAsyncHandler(proc);
+        ResumableAsyncHandler handler = new ResumableAsyncHandler(proc);
         Request request = get("http://test/url").build();
-        Request newRequest = h.adjustRequestRange(request);
+        Request newRequest = handler.adjustRequestRange(request);
         assertEquals(newRequest.getUri(), request.getUri());
         String rangeHeader = newRequest.getHeaders().get(HttpHeaders.Names.RANGE);
         assertNull(rangeHeader);
 
         proc.put("http://test/url", 5000);
-        newRequest = h.adjustRequestRange(request);
+        newRequest = handler.adjustRequestRange(request);
         assertEquals(newRequest.getUri(), request.getUri());
         rangeHeader = newRequest.getHeaders().get(HttpHeaders.Names.RANGE);
         assertEquals(rangeHeader, "bytes=5000-");
     }
+
+    @Test
+    public void testOnStatusReceivedOkStatus() throws Exception {
+        MapResumableProcessor processor = new MapResumableProcessor();
+        ResumableAsyncHandler handler = new ResumableAsyncHandler(processor);
+        HttpResponseStatus responseStatus200 = mock(HttpResponseStatus.class);
+        when(responseStatus200.getStatusCode()).thenReturn(200);
+        when(responseStatus200.getUri()).thenReturn(mock(Uri.class));
+        State state = handler.onStatusReceived(responseStatus200);
+        assertEquals(state, AsyncHandler.State.CONTINUE, "Status should be CONTINUE for a OK response");
+    }
+    
+    @Test
+    public void testOnStatusReceived206Status() throws Exception {
+        MapResumableProcessor processor = new MapResumableProcessor();
+        ResumableAsyncHandler handler = new ResumableAsyncHandler(processor);
+        HttpResponseStatus responseStatus206 = mock(HttpResponseStatus.class);
+        when(responseStatus206.getStatusCode()).thenReturn(206);
+        when(responseStatus206.getUri()).thenReturn(mock(Uri.class));
+        State state = handler.onStatusReceived(responseStatus206);
+        assertEquals(state, AsyncHandler.State.CONTINUE, "Status should be CONTINUE for a 'Partial Content' response");
+    }
+    
+    @Test
+    public void testOnStatusReceivedOkStatusWithDecoratedAsyncHandler() throws Exception {
+        HttpResponseStatus mockResponseStatus = mock(HttpResponseStatus.class);
+        when(mockResponseStatus.getStatusCode()).thenReturn(200);
+        when(mockResponseStatus.getUri()).thenReturn(mock(Uri.class));
+
+        @SuppressWarnings("unchecked")
+        AsyncHandler<Response> decoratedAsyncHandler = mock(AsyncHandler.class);
+        State mockState = mock(State.class);
+        when(decoratedAsyncHandler.onStatusReceived(mockResponseStatus)).thenReturn(mockState);
+
+        ResumableAsyncHandler handler = new ResumableAsyncHandler(decoratedAsyncHandler);
+
+        State state = handler.onStatusReceived(mockResponseStatus);
+        verify(decoratedAsyncHandler).onStatusReceived(mockResponseStatus);
+        assertEquals(state, mockState, "State returned should be equal to the one returned from decoratedAsyncHandler");
+    }
+    
+    @Test
+    public void testOnStatusReceived500Status() throws Exception{
+        MapResumableProcessor processor = new MapResumableProcessor();
+        ResumableAsyncHandler handler = new ResumableAsyncHandler(processor);
+        HttpResponseStatus mockResponseStatus = mock(HttpResponseStatus.class);
+        when(mockResponseStatus.getStatusCode()).thenReturn(500);
+        when(mockResponseStatus.getUri()).thenReturn(mock(Uri.class));
+        State state = handler.onStatusReceived(mockResponseStatus);
+        assertEquals(state, AsyncHandler.State.ABORT, "State should be ABORT for Internal Server Error status");
+    }
+    
+    @Test
+    public void testOnBodyPartReceived() throws Exception {
+        ResumableAsyncHandler handler = new ResumableAsyncHandler();
+        HttpResponseBodyPart bodyPart = PowerMockito.mock(HttpResponseBodyPart.class);
+        when(bodyPart.getBodyPartBytes()).thenReturn(new byte[0]);
+        ByteBuffer buffer = ByteBuffer.allocate(0);
+        when(bodyPart.getBodyByteBuffer()).thenReturn(buffer);
+        State state = handler.onBodyPartReceived(bodyPart);
+        assertEquals(state, AsyncHandler.State.CONTINUE, "State should be CONTINUE for a successful onBodyPartReceived");
+    }
+    
+    @Test
+    public void testOnBodyPartReceivedWithResumableListenerThrowsException() throws Exception {
+        ResumableAsyncHandler handler = new ResumableAsyncHandler();
+
+        ResumableListener resumableListener = PowerMockito.mock(ResumableListener.class);
+        doThrow(new IOException()).when(resumableListener).onBytesReceived(anyObject());
+        handler.setResumableListener(resumableListener);
+
+        HttpResponseBodyPart bodyPart = PowerMockito.mock(HttpResponseBodyPart.class);
+        State state = handler.onBodyPartReceived(bodyPart);
+        assertEquals(state, AsyncHandler.State.ABORT,
+                "State should be ABORT if the resumableListener threw an exception in onBodyPartReceived");
+    }
+    
+    @Test
+    public void testOnBodyPartReceivedWithDecoratedAsyncHandler() throws Exception {
+        HttpResponseBodyPart bodyPart = PowerMockito.mock(HttpResponseBodyPart.class);
+        when(bodyPart.getBodyPartBytes()).thenReturn(new byte[0]);
+        ByteBuffer buffer = ByteBuffer.allocate(0);
+        when(bodyPart.getBodyByteBuffer()).thenReturn(buffer);
+
+        @SuppressWarnings("unchecked")
+        AsyncHandler<Response> decoratedAsyncHandler = mock(AsyncHandler.class);
+        State mockState = mock(State.class);
+        when(decoratedAsyncHandler.onBodyPartReceived(bodyPart)).thenReturn(mockState);
+
+        // following is needed to set the url variable
+        HttpResponseStatus mockResponseStatus = mock(HttpResponseStatus.class);
+        when(mockResponseStatus.getStatusCode()).thenReturn(200);
+        Uri mockUri = mock(Uri.class);
+        when(mockUri.toUrl()).thenReturn("http://non.null");
+        when(mockResponseStatus.getUri()).thenReturn(mockUri);
+
+        ResumableAsyncHandler handler = new ResumableAsyncHandler(decoratedAsyncHandler);
+        handler.onStatusReceived(mockResponseStatus);
+
+        State state = handler.onBodyPartReceived(bodyPart);
+        assertEquals(state, mockState, "State should be equal to the state returned from decoratedAsyncHandler");
+
+    }
+    
+    @Test
+    public void testOnHeadersReceived() throws Exception {
+        ResumableAsyncHandler handler = new ResumableAsyncHandler();
+        HttpHeaders responseHeaders = new DefaultHttpHeaders();
+        HttpResponseHeaders headers = new HttpResponseHeaders(responseHeaders);
+        State status = handler.onHeadersReceived(headers);
+        assertEquals(status, AsyncHandler.State.CONTINUE, "State should be CONTINUE for a successful onHeadersReceived");
+    }
+    
+    @Test
+    public void testOnHeadersReceivedWithDecoratedAsyncHandler() throws Exception {
+        HttpHeaders responseHeaders = new DefaultHttpHeaders();
+        HttpResponseHeaders headers = new HttpResponseHeaders(responseHeaders);
+
+        @SuppressWarnings("unchecked")
+        AsyncHandler<Response> decoratedAsyncHandler = mock(AsyncHandler.class);
+        State mockState = mock(State.class);
+        when(decoratedAsyncHandler.onHeadersReceived(headers)).thenReturn(mockState);
+
+        ResumableAsyncHandler handler = new ResumableAsyncHandler(decoratedAsyncHandler);
+        State status = handler.onHeadersReceived(headers);
+        assertEquals(status, mockState, "State should be equal to the state returned from decoratedAsyncHandler");
+    }
+    
+    @Test
+    public void testOnHeadersReceivedContentLengthMinus() throws Exception {
+        ResumableAsyncHandler handler = new ResumableAsyncHandler();
+        HttpHeaders responseHeaders = new DefaultHttpHeaders();
+        responseHeaders.add(HttpHeaders.Names.CONTENT_LENGTH, -1);
+        HttpResponseHeaders headers = new HttpResponseHeaders(responseHeaders);
+        State status = handler.onHeadersReceived(headers);
+        assertEquals(status, AsyncHandler.State.ABORT, "State should be ABORT for content length -1");
+    }
 }
diff --git a/client/src/test/java/org/asynchttpclient/handler/resumable/ResumableRandomAccessFileListenerTest.java b/client/src/test/java/org/asynchttpclient/handler/resumable/ResumableRandomAccessFileListenerTest.java
new file mode 100644
index 000000000..f064c63dd
--- /dev/null
+++ b/client/src/test/java/org/asynchttpclient/handler/resumable/ResumableRandomAccessFileListenerTest.java
@@ -0,0 +1,37 @@
+package org.asynchttpclient.handler.resumable;
+
+import static org.mockito.Mockito.*;
+
+import java.io.IOException;
+import java.io.RandomAccessFile;
+import java.nio.ByteBuffer;
+
+import org.powermock.api.mockito.PowerMockito;
+import org.testng.annotations.Test;
+
+public class ResumableRandomAccessFileListenerTest {
+
+    @Test
+    public void testOnBytesReceivedBufferHasArray() throws IOException {
+        RandomAccessFile file = PowerMockito.mock(RandomAccessFile.class);
+        ResumableRandomAccessFileListener listener = new ResumableRandomAccessFileListener(file);
+        byte[] array = new byte[] { 1, 2, 23, 33 };
+        ByteBuffer buf = ByteBuffer.wrap(array);
+        listener.onBytesReceived(buf);
+        verify(file).write(array, 0, 4);
+    }
+
+    @Test
+    public void testOnBytesReceivedBufferHasNoArray() throws IOException {
+        RandomAccessFile file = PowerMockito.mock(RandomAccessFile.class);
+        ResumableRandomAccessFileListener listener = new ResumableRandomAccessFileListener(file);
+
+        byte[] byteArray = new byte[] { 1, 2, 23, 33 };
+        ByteBuffer buf = ByteBuffer.allocateDirect(4);
+        buf.put(byteArray);
+        buf.flip();
+        listener.onBytesReceived(buf);
+        verify(file).write(byteArray);
+    }
+
+}
diff --git a/client/src/test/java/org/asynchttpclient/netty/NettyAsyncResponseTest.java b/client/src/test/java/org/asynchttpclient/netty/NettyAsyncResponseTest.java
index 39061e10b..646a8326c 100644
--- a/client/src/test/java/org/asynchttpclient/netty/NettyAsyncResponseTest.java
+++ b/client/src/test/java/org/asynchttpclient/netty/NettyAsyncResponseTest.java
@@ -38,12 +38,8 @@ public void testCookieParseExpires() {
         Date date = new Date(System.currentTimeMillis() + 60000);
         final String cookieDef = String.format("efmembercheck=true; expires=%s; path=/; domain=.eclipse.org", sdf.format(date));
 
-        NettyResponse response = new NettyResponse(new NettyResponseStatus(null, null, null, null), new HttpResponseHeaders() {
-            @Override
-            public HttpHeaders getHeaders() {
-                return new DefaultHttpHeaders().add(HttpHeaders.Names.SET_COOKIE, cookieDef);
-            }
-        }, null);
+        HttpResponseHeaders responseHeaders = new HttpResponseHeaders(new DefaultHttpHeaders().add(HttpHeaders.Names.SET_COOKIE, cookieDef));
+        NettyResponse response = new NettyResponse(new NettyResponseStatus(null, null, null, null), responseHeaders, null);
 
         List<Cookie> cookies = response.getCookies();
         assertEquals(cookies.size(), 1);
@@ -55,12 +51,9 @@ public HttpHeaders getHeaders() {
     @Test(groups = "standalone")
     public void testCookieParseMaxAge() {
         final String cookieDef = "efmembercheck=true; max-age=60; path=/; domain=.eclipse.org";
-        NettyResponse response = new NettyResponse(new NettyResponseStatus(null, null, null, null), new HttpResponseHeaders() {
-            @Override
-            public HttpHeaders getHeaders() {
-                return new DefaultHttpHeaders().add(HttpHeaders.Names.SET_COOKIE, cookieDef);
-            }
-        }, null);
+        
+        HttpResponseHeaders responseHeaders = new HttpResponseHeaders(new DefaultHttpHeaders().add(HttpHeaders.Names.SET_COOKIE, cookieDef));
+        NettyResponse response = new NettyResponse(new NettyResponseStatus(null, null, null, null), responseHeaders, null);
         List<Cookie> cookies = response.getCookies();
         assertEquals(cookies.size(), 1);
 
@@ -71,12 +64,8 @@ public HttpHeaders getHeaders() {
     @Test(groups = "standalone")
     public void testCookieParseWeirdExpiresValue() {
         final String cookieDef = "efmembercheck=true; expires=60; path=/; domain=.eclipse.org";
-        NettyResponse response = new NettyResponse(new NettyResponseStatus(null, null, null, null), new HttpResponseHeaders() {
-            @Override
-            public HttpHeaders getHeaders() {
-                return new DefaultHttpHeaders().add(HttpHeaders.Names.SET_COOKIE, cookieDef);
-            }
-        }, null);
+        HttpResponseHeaders responseHeaders = new HttpResponseHeaders(new DefaultHttpHeaders().add(HttpHeaders.Names.SET_COOKIE, cookieDef));
+        NettyResponse response = new NettyResponse(new NettyResponseStatus(null, null, null, null), responseHeaders, null);
 
         List<Cookie> cookies = response.getCookies();
         assertEquals(cookies.size(), 1);
diff --git a/client/src/test/java/org/asynchttpclient/netty/NettyResponseFutureTest.java b/client/src/test/java/org/asynchttpclient/netty/NettyResponseFutureTest.java
new file mode 100644
index 000000000..748b10458
--- /dev/null
+++ b/client/src/test/java/org/asynchttpclient/netty/NettyResponseFutureTest.java
@@ -0,0 +1,74 @@
+package org.asynchttpclient.netty;
+
+import static org.testng.Assert.*;
+
+import java.util.concurrent.CancellationException;
+import java.util.concurrent.ExecutionException;
+
+import static org.mockito.Mockito.*;
+
+import org.asynchttpclient.AsyncHandler;
+import org.testng.annotations.Test;
+
+public class NettyResponseFutureTest {
+
+    @Test
+    public void testCancel() {
+        AsyncHandler<?> asyncHandler = mock(AsyncHandler.class);
+        NettyResponseFuture<?> nettyResponseFuture = new NettyResponseFuture<>(null, asyncHandler, null, 3, null, null);
+        boolean result = nettyResponseFuture.cancel(false);
+        verify(asyncHandler).onThrowable(anyObject());
+        assertTrue(result, "Cancel should return true if the Future was cancelled successfully");
+        assertTrue(nettyResponseFuture.isCancelled(), "isCancelled should return true for a cancelled Future");
+    }
+
+    @Test
+    public void testCancelOnAlreadyCancelled() {
+        AsyncHandler<?> asyncHandler = mock(AsyncHandler.class);
+        NettyResponseFuture<?> nettyResponseFuture = new NettyResponseFuture<>(null, asyncHandler, null, 3, null, null);
+        nettyResponseFuture.cancel(false);
+        boolean result = nettyResponseFuture.cancel(false);
+        assertFalse(result, "cancel should return false for an already cancelled Future");
+        assertTrue(nettyResponseFuture.isCancelled(), "isCancelled should return true for a cancelled Future");
+    }
+
+    @Test(expectedExceptions = CancellationException.class)
+    public void testGetContentThrowsCancellationExceptionIfCancelled() throws InterruptedException, ExecutionException {
+        AsyncHandler<?> asyncHandler = mock(AsyncHandler.class);
+        NettyResponseFuture<?> nettyResponseFuture = new NettyResponseFuture<>(null, asyncHandler, null, 3, null, null);
+        nettyResponseFuture.cancel(false);
+        nettyResponseFuture.get();
+        fail("A CancellationException must have occurred by now as 'cancel' was called before 'get'");
+    }
+
+    @Test
+    public void testGet() throws Exception {
+        @SuppressWarnings("unchecked")
+        AsyncHandler<Object> asyncHandler = mock(AsyncHandler.class);
+        Object value = new Object();
+        when(asyncHandler.onCompleted()).thenReturn(value);
+        NettyResponseFuture<?> nettyResponseFuture = new NettyResponseFuture<>(null, asyncHandler, null, 3, null, null);
+        nettyResponseFuture.done();
+        Object result = nettyResponseFuture.get();
+        assertEquals(result, value, "The Future should return the value given by asyncHandler#onCompleted");
+    }
+
+    @Test(expectedExceptions = ExecutionException.class)
+    public void testGetThrowsExceptionThrownByAsyncHandler() throws Exception {
+        AsyncHandler<?> asyncHandler = mock(AsyncHandler.class);
+        when(asyncHandler.onCompleted()).thenThrow(new RuntimeException());
+        NettyResponseFuture<?> nettyResponseFuture = new NettyResponseFuture<>(null, asyncHandler, null, 3, null, null);
+        nettyResponseFuture.done();
+        nettyResponseFuture.get();
+        fail("An ExecutionException must have occurred by now as asyncHandler threw an exception in 'onCompleted'");
+    }
+
+    @Test(expectedExceptions = ExecutionException.class)
+    public void testGetThrowsExceptionOnAbort() throws InterruptedException, ExecutionException {
+        AsyncHandler<?> asyncHandler = mock(AsyncHandler.class);
+        NettyResponseFuture<?> nettyResponseFuture = new NettyResponseFuture<>(null, asyncHandler, null, 3, null, null);
+        nettyResponseFuture.abort(new RuntimeException());
+        nettyResponseFuture.get();
+        fail("An ExecutionException must have occurred by now as 'abort' was called before 'get'");
+    }
+}
diff --git a/client/src/test/java/org/asynchttpclient/netty/RetryNonBlockingIssue.java b/client/src/test/java/org/asynchttpclient/netty/RetryNonBlockingIssue.java
index b09357987..f7b2c4b20 100644
--- a/client/src/test/java/org/asynchttpclient/netty/RetryNonBlockingIssue.java
+++ b/client/src/test/java/org/asynchttpclient/netty/RetryNonBlockingIssue.java
@@ -58,7 +58,7 @@ public void setUpGlobal() throws Exception {
     }
 
     protected String getTargetUrl() {
-        return String.format("http://127.0.0.1:%d/", port1);
+        return String.format("http://localhost:%d/", port1);
     }
 
     private ListenableFuture<Response> testMethodRequest(AsyncHttpClient client, int requests, String action, String id) throws IOException {
diff --git a/client/src/test/java/org/asynchttpclient/netty/reactivestreams/NettyReactiveStreamsTest.java b/client/src/test/java/org/asynchttpclient/netty/handler/NettyReactiveStreamsTest.java
similarity index 88%
rename from client/src/test/java/org/asynchttpclient/netty/reactivestreams/NettyReactiveStreamsTest.java
rename to client/src/test/java/org/asynchttpclient/netty/handler/NettyReactiveStreamsTest.java
index 2f3acce7e..413efc72e 100644
--- a/client/src/test/java/org/asynchttpclient/netty/reactivestreams/NettyReactiveStreamsTest.java
+++ b/client/src/test/java/org/asynchttpclient/netty/handler/NettyReactiveStreamsTest.java
@@ -10,9 +10,9 @@
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
  */
-package org.asynchttpclient.netty.reactivestreams;
+package org.asynchttpclient.netty.handler;
 
-import static org.asynchttpclient.Dsl.*;
+import static org.asynchttpclient.Dsl.asyncHttpClient;
 import static org.asynchttpclient.test.TestUtils.LARGE_IMAGE_BYTES;
 import static org.testng.Assert.assertTrue;
 import io.netty.channel.Channel;
@@ -20,13 +20,13 @@
 import io.netty.channel.ChannelFutureListener;
 
 import java.lang.reflect.Field;
-import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.util.List;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicReference;
 
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.HttpResponseBodyPart;
-import org.asynchttpclient.channel.NameResolution;
 import org.asynchttpclient.handler.AsyncHandlerExtensions;
 import org.asynchttpclient.netty.handler.StreamedResponsePublisher;
 import org.asynchttpclient.netty.request.NettyRequest;
@@ -127,13 +127,25 @@ public ReplayedSimpleAsyncHandler(CountDownLatch replaying, SimpleSubscriber<Htt
             this.replaying = replaying;
         }
         @Override
-        public void onConnectionOpen() {}
+        public void onHostnameResolutionAttempt(String name) {}
         @Override
-        public void onConnectionSuccess(Channel connection, InetAddress address) {}
+        public void onHostnameResolutionSuccess(String name, List<InetSocketAddress> addresses) {}
         @Override
-        public void onConnectionFailure(InetAddress address) {}
+        public void onHostnameResolutionFailure(String name, Throwable cause) {}
         @Override
-        public void onConnectionPool() {}
+        public void onTcpConnectAttempt(InetSocketAddress address) {}
+        @Override
+        public void onTcpConnectSuccess(InetSocketAddress address, Channel connection) {}
+        @Override
+        public void onTcpConnectFailure(InetSocketAddress address, Throwable cause) {}
+        @Override
+        public void onTlsHandshakeAttempt() {}
+        @Override
+        public void onTlsHandshakeSuccess() {}
+        @Override
+        public void onTlsHandshakeFailure(Throwable cause) {}
+        @Override
+        public void onConnectionPoolAttempt() {}
         @Override
         public void onConnectionPooled(Channel connection) {}
         @Override
@@ -142,9 +154,5 @@ public void onConnectionOffer(Channel connection) {}
         public void onRequestSend(NettyRequest request) {}
         @Override
         public void onRetry() { replaying.countDown(); }
-        @Override
-        public void onDnsResolved(NameResolution[] resolutions) {}
-        @Override
-        public void onSslHandshakeCompleted() {}
     }
 }
diff --git a/client/src/test/java/org/asynchttpclient/netty/util/ByteBufUtilsTest.java b/client/src/test/java/org/asynchttpclient/netty/util/ByteBufUtilsTest.java
new file mode 100644
index 000000000..02b303382
--- /dev/null
+++ b/client/src/test/java/org/asynchttpclient/netty/util/ByteBufUtilsTest.java
@@ -0,0 +1,65 @@
+package org.asynchttpclient.netty.util;
+
+import static org.testng.Assert.assertEquals;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+
+import java.util.Collections;
+import java.util.LinkedList;
+import java.util.List;
+
+import org.asynchttpclient.util.ByteBufUtils;
+import org.testng.annotations.Test;
+
+public class ByteBufUtilsTest {
+
+    @Test
+    public void testByteBuf2BytesHasBackingArray() {
+        byte[] input = "testdata".getBytes();
+        ByteBuf inputBuf = Unpooled.copiedBuffer(input);
+        byte[] output = ByteBufUtils.byteBuf2Bytes(inputBuf);
+        assertEquals(output, input, "The bytes returned by byteBuf2Bytes do not match the bytes in the ByteBuf parameter");
+    }
+
+    @Test
+    public void testByteBuf2BytesNoBackingArray() {
+        ByteBuf inputBuf = Unpooled.directBuffer();
+        byte[] inputBytes = "testdata".getBytes();
+        inputBuf.writeBytes(inputBytes);
+        byte[] output = ByteBufUtils.byteBuf2Bytes(inputBuf);
+        assertEquals(output, inputBytes, "The bytes returned by byteBuf2Bytes do not match the bytes in the ByteBuf parameter");
+    }
+
+    @Test
+    public void testByteBufs2BytesEmptyList() {
+        byte[] output = ByteBufUtils.byteBufs2Bytes(Collections.emptyList());
+        assertEquals(output, ByteBufUtils.EMPTY_BYTE_ARRAY,
+                "When an empty list is passed to byteBufs2Bytes, an empty byte array should be returned");
+    }
+
+    @Test
+    public void testByteBufs2BytesSize1List() {
+        byte[] inputBytes = "testdata".getBytes();
+        ByteBuf inputBuf = Unpooled.copiedBuffer(inputBytes);
+        byte[] output = ByteBufUtils.byteBufs2Bytes(Collections.singletonList(inputBuf));
+        assertEquals(output, inputBytes, "When a list of a single ByteBuf element is passed to byteBufs2Bytes,"
+                + " the returned byte array should contain the bytes in that ByteBUf");
+    }
+
+    @Test
+    public void testByteBufs2Bytes() {
+        byte[] input1 = "testdata".getBytes();
+        byte[] input2 = "testdata2".getBytes();
+        byte[] input3 = "testdata3333".getBytes();
+
+        List<ByteBuf> byteBufList = new LinkedList<>();
+        byteBufList.add(Unpooled.copiedBuffer(input1));
+        byteBufList.add(Unpooled.copiedBuffer(input2));
+        byteBufList.add(Unpooled.copiedBuffer(input3));
+
+        byte[] output = ByteBufUtils.byteBufs2Bytes(byteBufList);
+        assertEquals(output.length, input1.length + input2.length + input3.length,
+                "Returned bytes length should equal the sum of the parts");
+    }
+
+}
diff --git a/client/src/test/java/org/asynchttpclient/ntlm/NtlmTest.java b/client/src/test/java/org/asynchttpclient/ntlm/NtlmTest.java
index 81eb4fb1d..a3abf3642 100644
--- a/client/src/test/java/org/asynchttpclient/ntlm/NtlmTest.java
+++ b/client/src/test/java/org/asynchttpclient/ntlm/NtlmTest.java
@@ -14,8 +14,12 @@
 package org.asynchttpclient.ntlm;
 
 import static org.asynchttpclient.Dsl.*;
+import static org.testng.Assert.*;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
 
 import java.io.IOException;
+import java.nio.charset.StandardCharsets;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
 
@@ -27,6 +31,9 @@
 import org.asynchttpclient.AsyncHttpClient;
 import org.asynchttpclient.Realm;
 import org.asynchttpclient.Response;
+import org.asynchttpclient.ntlm.NtlmEngine.Type2Message;
+import org.asynchttpclient.util.Base64;
+import org.asynchttpclient.util.ByteBufUtils;
 import org.eclipse.jetty.server.handler.AbstractHandler;
 import org.testng.Assert;
 import org.testng.annotations.Test;
@@ -90,4 +97,97 @@ public void lazyNTLMAuthTest() throws IOException, InterruptedException, Executi
     public void preemptiveNTLMAuthTest() throws IOException, InterruptedException, ExecutionException {
         ntlmAuthTest(realmBuilderBase().setUsePreemptiveAuth(true));
     }
+    
+    @Test
+    public void testGenerateType1Msg() {
+        NtlmEngine engine = new NtlmEngine();
+        String message = engine.generateType1Msg();
+        assertEquals(message, "TlRMTVNTUAABAAAAAYIIogAAAAAoAAAAAAAAACgAAAAFASgKAAAADw==", "Incorrect type1 message generated");
+    }
+
+    @Test(expectedExceptions = NtlmEngineException.class)
+    public void testGenerateType3MsgThrowsExceptionWhenChallengeTooShort() {
+        NtlmEngine engine = new NtlmEngine();
+        engine.generateType3Msg("username", "passowrd", "localhost", "workstattion", Base64.encode("a".getBytes()));
+        fail("An NtlmEngineException must have occurred as challenge length is too short");
+    }
+
+    @Test(expectedExceptions = NtlmEngineException.class)
+    public void testGenerateType3MsgThrowsExceptionWhenChallengeDoesNotFollowCorrectFormat() {
+        NtlmEngine engine = new NtlmEngine();
+        engine.generateType3Msg("username", "passowrd", "localhost", "workstattion", Base64.encode("challenge".getBytes()));
+        fail("An NtlmEngineException must have occurred as challenge format is not correct");
+    }
+
+    @Test(expectedExceptions = NtlmEngineException.class)
+    public void testGenerateType3MsgThworsExceptionWhenType2IndicatorNotPresent() {
+        ByteBuf buf = Unpooled.directBuffer();
+        buf.writeBytes("NTLMSSP".getBytes(StandardCharsets.US_ASCII));
+        buf.writeByte(0);
+        // type 2 indicator
+        buf.writeByte(3).writeByte(0).writeByte(0).writeByte(0);
+        buf.writeBytes("challenge".getBytes());
+        NtlmEngine engine = new NtlmEngine();
+        engine.generateType3Msg("username", "passowrd", "localhost", "workstation", Base64.encode(ByteBufUtils.byteBuf2Bytes(buf)));
+        fail("An NtlmEngineException must have occurred as type 2 indicator is incorrect");
+    }
+
+    @Test(expectedExceptions = NtlmEngineException.class)
+    public void testGenerateType3MsgThrowsExceptionWhenUnicodeSupportNotIndicated() {
+        ByteBuf buf = Unpooled.directBuffer();
+        buf.writeBytes("NTLMSSP".getBytes(StandardCharsets.US_ASCII));
+        buf.writeByte(0);
+        // type 2 indicator
+        buf.writeByte(2).writeByte(0).writeByte(0).writeByte(0);
+        buf.writeLong(1);
+        // flags
+        buf.writeByte(0);// unicode support indicator
+        buf.writeByte(0).writeByte(0).writeByte(0);
+        buf.writeLong(1);// challenge
+        NtlmEngine engine = new NtlmEngine();
+        engine.generateType3Msg("username", "passowrd", "localhost", "workstattion", Base64.encode(ByteBufUtils.byteBuf2Bytes(buf)));
+        fail("An NtlmEngineException must have occurred as unicode support is not indicated");
+    }
+
+    @Test(groups="standalone")
+    public void testGenerateType2Msg(){
+        Type2Message type2Message = new Type2Message("TlRMTVNTUAACAAAAAAAAACgAAAABggAAU3J2Tm9uY2UAAAAAAAAAAA==");
+        Assert.assertEquals(type2Message.getMessageLength(), 40, "This is a sample challenge that should return 40");
+    }
+
+    @Test
+    public void testGenerateType3Msg() {
+        ByteBuf buf = Unpooled.directBuffer();
+        buf.writeBytes("NTLMSSP".getBytes(StandardCharsets.US_ASCII));
+        buf.writeByte(0);
+        // type 2 indicator
+        buf.writeByte(2).writeByte(0).writeByte(0).writeByte(0);
+        buf.writeLong(0);
+        // flags
+        buf.writeByte(1);// unicode support indicator
+        buf.writeByte(0).writeByte(0).writeByte(0);
+        buf.writeLong(1);// challenge
+        NtlmEngine engine = new NtlmEngine();
+        String type3Msg = engine.generateType3Msg("username", "passowrd", "localhost", "workstattion",
+                Base64.encode(ByteBufUtils.byteBuf2Bytes(buf)));
+        assertEquals(type3Msg,
+                "TlRMTVNTUAADAAAAGAAYAEgAAAAYABgAYAAAABIAEgB4AAAAEAAQAIoAAAAYABgAmgAAAAAAAACyAAAAAQAAAgUBKAoAAAAPmr/wN76Y0WPoSFkHghgpi0yh7/UexwVlCeoo1CQEl9d2alfPRld8KYeOkS0GdTuMTABPAEMAQQBMAEgATwBTAFQAdQBzAGUAcgBuAGEAbQBlAHcAbwByAGsAcwB0AGEAdAB0AGkAbwBuAA==",
+                "Incorrect type3 message generated");
+    }
+
+    @Test
+    public void testWriteULong() {
+        //test different combinations so that different positions in the byte array will be written
+        byte[] buffer = new byte[4];
+        NtlmEngine.writeULong(buffer, 1, 0);
+        assertEquals(buffer, new byte[] { 1, 0, 0, 0 }, "Unsigned long value 1 was not written correctly to the buffer");
+        
+        buffer = new byte[4];
+        NtlmEngine.writeULong(buffer, 257, 0);
+        assertEquals(buffer, new byte[] { 1, 1, 0, 0 }, "Unsigned long value 257 was not written correctly to the buffer");
+        
+        buffer = new byte[4];
+        NtlmEngine.writeULong(buffer, 16777216, 0);
+        assertEquals(buffer, new byte[] { 0, 0, 0, 1 }, "Unsigned long value 16777216 was not written correctly to the buffer");
+    }
 }
diff --git a/client/src/test/java/org/asynchttpclient/proxy/HttpsProxyTest.java b/client/src/test/java/org/asynchttpclient/proxy/HttpsProxyTest.java
index 1426e153c..73e84bf42 100644
--- a/client/src/test/java/org/asynchttpclient/proxy/HttpsProxyTest.java
+++ b/client/src/test/java/org/asynchttpclient/proxy/HttpsProxyTest.java
@@ -15,11 +15,6 @@
 import static org.asynchttpclient.Dsl.*;
 import static org.asynchttpclient.test.TestUtils.*;
 import static org.testng.Assert.assertEquals;
-import io.netty.handler.codec.http.HttpHeaders;
-
-import java.io.IOException;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.TimeoutException;
 
 import org.asynchttpclient.AbstractBasicTest;
 import org.asynchttpclient.AsyncHttpClient;
@@ -68,35 +63,33 @@ public void tearDownGlobal() throws Exception {
     }
 
     @Test(groups = "standalone")
-    public void testRequestProxy() throws IOException, InterruptedException, ExecutionException, TimeoutException {
+    public void testRequestProxy() throws Exception {
 
         try (AsyncHttpClient asyncHttpClient = asyncHttpClient(config().setFollowRedirect(true).setAcceptAnyCertificate(true))) {
-            RequestBuilder rb = get(getTargetUrl2()).setProxyServer(proxyServer("127.0.0.1", port1));
+            RequestBuilder rb = get(getTargetUrl2()).setProxyServer(proxyServer("localhost", port1));
             Response r = asyncHttpClient.executeRequest(rb.build()).get();
             assertEquals(r.getStatusCode(), 200);
-            assertEquals(r.getHeader("X-Connection"), HttpHeaders.Values.KEEP_ALIVE);
         }
     }
 
     @Test(groups = "standalone")
-    public void testConfigProxy() throws IOException, InterruptedException, ExecutionException, TimeoutException {
+    public void testConfigProxy() throws Exception {
         AsyncHttpClientConfig config = config()//
                 .setFollowRedirect(true)//
-                .setProxyServer(proxyServer("127.0.0.1", port1).build())//
+                .setProxyServer(proxyServer("localhost", port1).build())//
                 .setAcceptAnyCertificate(true)//
                 .build();
         try (AsyncHttpClient asyncHttpClient = asyncHttpClient(config)) {
             Response r = asyncHttpClient.executeRequest(get(getTargetUrl2())).get();
             assertEquals(r.getStatusCode(), 200);
-            assertEquals(r.getHeader("X-Connection"), HttpHeaders.Values.KEEP_ALIVE);
         }
     }
 
     @Test(groups = "standalone")
-    public void testPooledConnectionsWithProxy() throws IOException, InterruptedException, ExecutionException, TimeoutException {
+    public void testPooledConnectionsWithProxy() throws Exception {
 
         try (AsyncHttpClient asyncHttpClient = asyncHttpClient(config().setFollowRedirect(true).setAcceptAnyCertificate(true).setKeepAlive(true))) {
-            RequestBuilder rb = get(getTargetUrl2()).setProxyServer(proxyServer("127.0.0.1", port1));
+            RequestBuilder rb = get(getTargetUrl2()).setProxyServer(proxyServer("localhost", port1));
 
             Response r1 = asyncHttpClient.executeRequest(rb.build()).get();
             assertEquals(r1.getStatusCode(), 200);
diff --git a/client/src/test/java/org/asynchttpclient/proxy/NTLMProxyTest.java b/client/src/test/java/org/asynchttpclient/proxy/NTLMProxyTest.java
index 98d36f397..3462be244 100644
--- a/client/src/test/java/org/asynchttpclient/proxy/NTLMProxyTest.java
+++ b/client/src/test/java/org/asynchttpclient/proxy/NTLMProxyTest.java
@@ -106,6 +106,6 @@ private ProxyServer ntlmProxy() throws UnknownHostException {
                 .setNtlmDomain("Ursa-Minor")//
                 .setNtlmHost("LightCity")//
                 .build();
-        return proxyServer("127.0.0.1", port2).setRealm(realm).build();
+        return proxyServer("localhost", port2).setRealm(realm).build();
     }
 }
diff --git a/client/src/test/java/org/asynchttpclient/proxy/ProxyTest.java b/client/src/test/java/org/asynchttpclient/proxy/ProxyTest.java
index 71b421aa1..a7654f4ed 100644
--- a/client/src/test/java/org/asynchttpclient/proxy/ProxyTest.java
+++ b/client/src/test/java/org/asynchttpclient/proxy/ProxyTest.java
@@ -56,7 +56,7 @@
     public static class ProxyHandler extends AbstractHandler {
         public void handle(String s, org.eclipse.jetty.server.Request r, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
             if ("GET".equalsIgnoreCase(request.getMethod())) {
-                response.addHeader("target", r.getUri().getPath());
+                response.addHeader("target", r.getHttpURI().getPath());
                 response.setStatus(HttpServletResponse.SC_OK);
             } else {
                 // this handler is to handle POST request
@@ -71,11 +71,38 @@ public AbstractHandler configureHandler() throws Exception {
         return new ProxyHandler();
     }
 
+    // @Test
+    // public void asyncDoPostProxyTest() throws Throwable {
+    // try (AsyncHttpClient client = asyncHttpClient(config().setProxyServer(proxyServer("localhost", port2).build()))) {
+    // HttpHeaders h = new DefaultHttpHeaders();
+    // h.add(CONTENT_TYPE, APPLICATION_X_WWW_FORM_URLENCODED);
+    // StringBuilder sb = new StringBuilder();
+    // for (int i = 0; i < 5; i++) {
+    // sb.append("param_").append(i).append("=value_").append(i).append("&");
+    // }
+    // sb.setLength(sb.length() - 1);
+    //
+    // Response response = client.preparePost(getTargetUrl()).setHeaders(h).setBody(sb.toString()).execute(new AsyncCompletionHandler<Response>() {
+    // @Override
+    // public Response onCompleted(Response response) throws Throwable {
+    // return response;
+    // }
+    //
+    // @Override
+    // public void onThrowable(Throwable t) {
+    // }
+    // }).get();
+    //
+    // assertEquals(response.getStatusCode(), 200);
+    // assertEquals(response.getHeader("X-" + CONTENT_TYPE), APPLICATION_X_WWW_FORM_URLENCODED);
+    // }
+    // }
+    
     @Test(groups = "standalone")
     public void testRequestLevelProxy() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         try (AsyncHttpClient client = asyncHttpClient()) {
-            String target = "http://127.0.0.1:1234/";
-            Future<Response> f = client.prepareGet(target).setProxyServer(proxyServer("127.0.0.1", port1)).execute();
+            String target = "http://localhost:1234/";
+            Future<Response> f = client.prepareGet(target).setProxyServer(proxyServer("localhost", port1)).execute();
             Response resp = f.get(3, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
@@ -85,8 +112,8 @@ public void testRequestLevelProxy() throws IOException, ExecutionException, Time
 
     @Test(groups = "standalone")
     public void testGlobalProxy() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        try (AsyncHttpClient client = asyncHttpClient(config().setProxyServer(proxyServer("127.0.0.1", port1)))) {
-            String target = "http://127.0.0.1:1234/";
+        try (AsyncHttpClient client = asyncHttpClient(config().setProxyServer(proxyServer("localhost", port1)))) {
+            String target = "http://localhost:1234/";
             Future<Response> f = client.prepareGet(target).execute();
             Response resp = f.get(3, TimeUnit.SECONDS);
             assertNotNull(resp);
@@ -97,9 +124,9 @@ public void testGlobalProxy() throws IOException, ExecutionException, TimeoutExc
 
     @Test(groups = "standalone")
     public void testBothProxies() throws IOException, ExecutionException, TimeoutException, InterruptedException {
-        try (AsyncHttpClient client = asyncHttpClient(config().setProxyServer(proxyServer("127.0.0.1", port1 - 1)))) {
-            String target = "http://127.0.0.1:1234/";
-            Future<Response> f = client.prepareGet(target).setProxyServer(proxyServer("127.0.0.1", port1)).execute();
+        try (AsyncHttpClient client = asyncHttpClient(config().setProxyServer(proxyServer("localhost", port1 - 1)))) {
+            String target = "http://localhost:1234/";
+            Future<Response> f = client.prepareGet(target).setProxyServer(proxyServer("localhost", port1)).execute();
             Response resp = f.get(3, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
@@ -129,11 +156,11 @@ public void testNonProxyHost() {
     @Test(groups = "standalone")
     public void testNonProxyHostsRequestOverridesConfig() throws IOException, ExecutionException, TimeoutException, InterruptedException {
 
-        ProxyServer configProxy = proxyServer("127.0.0.1", port1 - 1).build();
-        ProxyServer requestProxy = proxyServer("127.0.0.1", port1).setNonProxyHost("127.0.0.1").build();
+        ProxyServer configProxy = proxyServer("localhost", port1 - 1).build();
+        ProxyServer requestProxy = proxyServer("localhost", port1).setNonProxyHost("localhost").build();
 
         try (AsyncHttpClient client = asyncHttpClient(config().setProxyServer(configProxy))) {
-            String target = "http://127.0.0.1:1234/";
+            String target = "http://localhost:1234/";
             client.prepareGet(target).setProxyServer(requestProxy).execute().get();
             assertFalse(true);
         } catch (Throwable e) {
@@ -145,9 +172,9 @@ public void testNonProxyHostsRequestOverridesConfig() throws IOException, Execut
     @Test(groups = "standalone")
     public void testRequestNonProxyHost() throws IOException, ExecutionException, TimeoutException, InterruptedException {
 
-        ProxyServer proxy = proxyServer("127.0.0.1", port1 - 1).setNonProxyHost("127.0.0.1").build();
+        ProxyServer proxy = proxyServer("localhost", port1 - 1).setNonProxyHost("localhost").build();
         try (AsyncHttpClient client = asyncHttpClient()) {
-            String target = "http://127.0.0.1:" + port1 + "/";
+            String target = "http://localhost:" + port1 + "/";
             Future<Response> f = client.prepareGet(target).setProxyServer(proxy).execute();
             Response resp = f.get(3, TimeUnit.SECONDS);
             assertNotNull(resp);
@@ -176,15 +203,15 @@ public void testProxyProperties() throws IOException, ExecutionException, Timeou
         AsyncHttpClientConfigHelper.reloadProperties();
 
         try (AsyncHttpClient client = asyncHttpClient(config().setUseProxyProperties(true))) {
-            String target = "http://127.0.0.1:1234/";
-            Future<Response> f = client.prepareGet(target).execute();
+            String proxifiedtarget = "http://127.0.0.1:1234/";
+            Future<Response> f = client.prepareGet(proxifiedtarget).execute();
             Response resp = f.get(3, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
             assertEquals(resp.getHeader("target"), "/");
 
-            target = "http://localhost:1234/";
-            f = client.prepareGet(target).execute();
+            String nonProxifiedtarget = "http://localhost:1234/";
+            f = client.prepareGet(nonProxifiedtarget).execute();
             try {
                 resp = f.get(3, TimeUnit.SECONDS);
                 fail("should not be able to connect");
@@ -201,13 +228,13 @@ public void testIgnoreProxyPropertiesByDefault() throws IOException, ExecutionEx
         // FIXME not threadsafe!
         Properties originalProps = new Properties();
         originalProps.putAll(System.getProperties());
-        System.setProperty(ProxyUtils.PROXY_HOST, "127.0.0.1");
+        System.setProperty(ProxyUtils.PROXY_HOST, "localhost");
         System.setProperty(ProxyUtils.PROXY_PORT, String.valueOf(port1));
         System.setProperty(ProxyUtils.PROXY_NONPROXYHOSTS, "localhost");
         AsyncHttpClientConfigHelper.reloadProperties();
 
         try (AsyncHttpClient client = asyncHttpClient()) {
-            String target = "http://127.0.0.1:1234/";
+            String target = "http://localhost:1234/";
             Future<Response> f = client.prepareGet(target).execute();
             try {
                 f.get(3, TimeUnit.SECONDS);
@@ -220,7 +247,7 @@ public void testIgnoreProxyPropertiesByDefault() throws IOException, ExecutionEx
         }
     }
 
-     @Test(groups = "standalone", enabled = false)
+    @Test(groups = "standalone", enabled = false)
     public void testProxyActivationProperty() throws IOException, ExecutionException, TimeoutException, InterruptedException {
         // FIXME not threadsafe!
         Properties originalProps = new Properties();
@@ -232,15 +259,15 @@ public void testProxyActivationProperty() throws IOException, ExecutionException
         AsyncHttpClientConfigHelper.reloadProperties();
 
         try (AsyncHttpClient client = asyncHttpClient()) {
-            String target = "http://127.0.0.1:1234/";
-            Future<Response> f = client.prepareGet(target).execute();
+            String proxifiedTarget = "http://127.0.0.1:1234/";
+            Future<Response> f = client.prepareGet(proxifiedTarget).execute();
             Response resp = f.get(3, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
             assertEquals(resp.getHeader("target"), "/");
 
-            target = "http://localhost:1234/";
-            f = client.prepareGet(target).execute();
+            String nonProxifiedTarget = "http://localhost:1234/";
+            f = client.prepareGet(nonProxifiedTarget).execute();
             try {
                 resp = f.get(3, TimeUnit.SECONDS);
                 fail("should not be able to connect");
@@ -263,8 +290,8 @@ public void testWildcardNonProxyHosts() throws IOException, ExecutionException,
         AsyncHttpClientConfigHelper.reloadProperties();
 
         try (AsyncHttpClient client = asyncHttpClient(config().setUseProxyProperties(true))) {
-            String target = "http://127.0.0.1:1234/";
-            Future<Response> f = client.prepareGet(target).execute();
+            String nonProxifiedTarget = "http://127.0.0.1:1234/";
+            Future<Response> f = client.prepareGet(nonProxifiedTarget).execute();
             try {
                 f.get(3, TimeUnit.SECONDS);
                 fail("should not be able to connect");
@@ -293,15 +320,15 @@ public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
         });
 
         try (AsyncHttpClient client = asyncHttpClient(config().setUseProxySelector(true))) {
-            String target = "http://127.0.0.1:1234/";
-            Future<Response> f = client.prepareGet(target).execute();
+            String proxifiedTarget = "http://127.0.0.1:1234/";
+            Future<Response> f = client.prepareGet(proxifiedTarget).execute();
             Response resp = f.get(3, TimeUnit.SECONDS);
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
             assertEquals(resp.getHeader("target"), "/");
 
-            target = "http://localhost:1234/";
-            f = client.prepareGet(target).execute();
+            String nonProxifiedTarget = "http://localhost:1234/";
+            f = client.prepareGet(nonProxifiedTarget).execute();
             try {
                 f.get(3, TimeUnit.SECONDS);
                 fail("should not be able to connect");
diff --git a/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServer.java b/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServer.java
index fb8479112..1a10e2896 100644
--- a/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServer.java
+++ b/client/src/test/java/org/asynchttpclient/reactivestreams/HttpStaticFileServer.java
@@ -43,7 +43,7 @@ public static void start(int port) throws Exception {
                 .childHandler(new HttpStaticFileServerInitializer());
 
         b.bind(port).sync().channel();
-        LOGGER.info("Open your web browser and navigate to " + ("http") + "://127.0.0.1:" + port + '/');
+        LOGGER.info("Open your web browser and navigate to " + ("http") + "://localhost:" + port + '/');
     }
 
     public static void shutdown() {
diff --git a/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsDownLoadTest.java b/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsDownLoadTest.java
index 6bee45f3e..f36894f61 100644
--- a/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsDownLoadTest.java
+++ b/client/src/test/java/org/asynchttpclient/reactivestreams/ReactiveStreamsDownLoadTest.java
@@ -49,7 +49,7 @@ public void tearDown() throws Exception {
     @Test(groups = "standalone")
     public void streamedResponseLargeFileTest() throws Throwable {
         try (AsyncHttpClient c = asyncHttpClient()) {
-            String largeFileName = "http://127.0.0.1:" + serverPort + "/" + largeFile.getName();
+            String largeFileName = "http://localhost:" + serverPort + "/" + largeFile.getName();
             ListenableFuture<SimpleStreamedAsyncHandler> future = c.prepareGet(largeFileName).execute(new SimpleStreamedAsyncHandler());
             byte[] result = future.get().getBytes();
             assertEquals(result.length, largeFile.length());
@@ -59,7 +59,7 @@ public void streamedResponseLargeFileTest() throws Throwable {
     @Test(groups = "standalone")
     public void streamedResponseSmallFileTest() throws Throwable {
         try (AsyncHttpClient c = asyncHttpClient()) {
-            String smallFileName = "http://127.0.0.1:" + serverPort + "/" + smallFile.getName();
+            String smallFileName = "http://localhost:" + serverPort + "/" + smallFile.getName();
             ListenableFuture<SimpleStreamedAsyncHandler> future = c.prepareGet(smallFileName).execute(new SimpleStreamedAsyncHandler());
             byte[] result = future.get().getBytes();
             LOGGER.debug("Result file size: " + result.length);
diff --git a/client/src/test/java/org/asynchttpclient/request/body/ChunkingTest.java b/client/src/test/java/org/asynchttpclient/request/body/ChunkingTest.java
index e9fb7dd25..adc76b0d6 100755
--- a/client/src/test/java/org/asynchttpclient/request/body/ChunkingTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/ChunkingTest.java
@@ -32,7 +32,7 @@
 import org.asynchttpclient.Response;
 import org.asynchttpclient.request.body.generator.FeedableBodyGenerator;
 import org.asynchttpclient.request.body.generator.InputStreamBodyGenerator;
-import org.asynchttpclient.request.body.generator.SimpleFeedableBodyGenerator;
+import org.asynchttpclient.request.body.generator.UnboundedQueueFeedableBodyGenerator;
 import org.testng.annotations.Test;
 
 public class ChunkingTest extends AbstractBasicTest {
@@ -74,7 +74,7 @@ public void doTestWithInputStreamBodyGenerator(InputStream is) throws Throwable
     public void doTestWithFeedableBodyGenerator(InputStream is) throws Throwable {
         try (AsyncHttpClient c = asyncHttpClient(httpClientBuilder())) {
 
-            final FeedableBodyGenerator feedableBodyGenerator = new SimpleFeedableBodyGenerator();
+            final FeedableBodyGenerator feedableBodyGenerator = new UnboundedQueueFeedableBodyGenerator();
             Request r = post(getTargetUrl()).setBody(feedableBodyGenerator).build();
 
             ListenableFuture<Response> responseFuture = c.executeRequest(r);
@@ -85,7 +85,7 @@ public void doTestWithFeedableBodyGenerator(InputStream is) throws Throwable {
         }
     }
 
-    private void feed(FeedableBodyGenerator feedableBodyGenerator, InputStream is) throws IOException {
+    private void feed(FeedableBodyGenerator feedableBodyGenerator, InputStream is) throws Exception {
         try (InputStream inputStream = is) {
             byte[] buffer = new byte[512];
             for (int i = 0; (i = inputStream.read(buffer)) > -1;) {
diff --git a/client/src/test/java/org/asynchttpclient/request/body/ZeroCopyFileTest.java b/client/src/test/java/org/asynchttpclient/request/body/ZeroCopyFileTest.java
index 08579f49d..a6d51010e 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/ZeroCopyFileTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/ZeroCopyFileTest.java
@@ -71,7 +71,7 @@ public void zeroCopyPostTest() throws IOException, ExecutionException, TimeoutEx
             final AtomicBoolean headerSent = new AtomicBoolean(false);
             final AtomicBoolean operationCompleted = new AtomicBoolean(false);
 
-            Response resp = client.preparePost("http://127.0.0.1:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute(new AsyncCompletionHandler<Response>() {
+            Response resp = client.preparePost("http://localhost:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute(new AsyncCompletionHandler<Response>() {
 
                 public State onHeadersWritten() {
                     headerSent.set(true);
@@ -99,7 +99,7 @@ public Response onCompleted(Response response) throws Exception {
     @Test(groups = "standalone")
     public void zeroCopyPutTest() throws IOException, ExecutionException, TimeoutException, InterruptedException, URISyntaxException {
         try (AsyncHttpClient client = asyncHttpClient()) {
-            Future<Response> f = client.preparePut("http://127.0.0.1:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute();
+            Future<Response> f = client.preparePut("http://localhost:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute();
             Response resp = f.get();
             assertNotNull(resp);
             assertEquals(resp.getStatusCode(), HttpServletResponse.SC_OK);
@@ -118,7 +118,7 @@ public void zeroCopyFileTest() throws IOException, ExecutionException, TimeoutEx
         tmp.deleteOnExit();
         try (AsyncHttpClient client = asyncHttpClient()) {
             try (FileOutputStream stream = new FileOutputStream(tmp)) {
-                Response resp = client.preparePost("http://127.0.0.1:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute(new AsyncHandler<Response>() {
+                Response resp = client.preparePost("http://localhost:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute(new AsyncHandler<Response>() {
                     public void onThrowable(Throwable t) {
                     }
 
@@ -151,7 +151,7 @@ public void zeroCopyFileWithBodyManipulationTest() throws IOException, Execution
         tmp.deleteOnExit();
         try (AsyncHttpClient client = asyncHttpClient()) {
             try (FileOutputStream stream = new FileOutputStream(tmp)) {
-                Response resp = client.preparePost("http://127.0.0.1:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute(new AsyncHandler<Response>() {
+                Response resp = client.preparePost("http://localhost:" + port1 + "/").setBody(SIMPLE_TEXT_FILE).execute(new AsyncHandler<Response>() {
                     public void onThrowable(Throwable t) {
                     }
 
diff --git a/client/src/test/java/org/asynchttpclient/request/body/generator/FeedableBodyGeneratorTest.java b/client/src/test/java/org/asynchttpclient/request/body/generator/FeedableBodyGeneratorTest.java
index f20799fe4..332e8b7a7 100755
--- a/client/src/test/java/org/asynchttpclient/request/body/generator/FeedableBodyGeneratorTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/generator/FeedableBodyGeneratorTest.java
@@ -28,12 +28,12 @@
 
 public class FeedableBodyGeneratorTest {
 
-    private SimpleFeedableBodyGenerator feedableBodyGenerator;
+    private UnboundedQueueFeedableBodyGenerator feedableBodyGenerator;
     private TestFeedListener listener;
 
     @BeforeMethod
     public void setUp() throws Exception {
-        feedableBodyGenerator = new SimpleFeedableBodyGenerator();
+        feedableBodyGenerator = new UnboundedQueueFeedableBodyGenerator();
         listener = new TestFeedListener();
         feedableBodyGenerator.setListener(listener);
     }
@@ -73,7 +73,7 @@ public void returnZeroToSuspendStreamWhenNothingIsInQueue() throws Exception {
         return readBytes;
     }
 
-    private static class TestFeedListener implements SimpleFeedableBodyGenerator.FeedListener {
+    private static class TestFeedListener implements FeedListener {
 
         private int calls;
 
diff --git a/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBodyTest.java b/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBodyTest.java
index 69b192dcb..499dcadf1 100644
--- a/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBodyTest.java
+++ b/client/src/test/java/org/asynchttpclient/request/body/multipart/MultipartBodyTest.java
@@ -13,6 +13,7 @@
 package org.asynchttpclient.request.body.multipart;
 
 import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.testng.Assert.*;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.handler.codec.http.HttpHeaders;
@@ -24,19 +25,19 @@
 import java.util.ArrayList;
 import java.util.List;
 
-import org.asynchttpclient.request.body.Body;
+import org.apache.commons.io.IOUtils;
 import org.asynchttpclient.request.body.Body.BodyState;
-import org.testng.Assert;
 import org.testng.annotations.Test;
 
 public class MultipartBodyTest {
 
     @Test(groups = "standalone")
-    public void testBasics() throws IOException {
+    public void testBasics() throws Exception {
         final List<Part> parts = new ArrayList<>();
 
         // add a file
         final File testFile = getTestfile();
+        System.err.println(testFile.length());
         parts.add(new FilePart("filePart", testFile));
 
         // add a byte array
@@ -48,38 +49,25 @@ public void testBasics() throws IOException {
         compareContentLength(parts);
     }
 
-    private static File getTestfile() {
+    private static File getTestfile() throws URISyntaxException {
         final ClassLoader cl = MultipartBodyTest.class.getClassLoader();
         final URL url = cl.getResource("textfile.txt");
-        Assert.assertNotNull(url);
-        File file = null;
-        try {
-            file = new File(url.toURI());
-        } catch (URISyntaxException use) {
-            Assert.fail("uri syntax error");
-        }
-        return file;
+        assertNotNull(url);
+        return new File(url.toURI());
     }
 
     private static void compareContentLength(final List<Part> parts) throws IOException {
-        Assert.assertNotNull(parts);
+        assertNotNull(parts);
         // get expected values
-        final Body multipartBody = MultipartUtils.newMultipartBody(parts, HttpHeaders.EMPTY_HEADERS);
+        final MultipartBody multipartBody = MultipartUtils.newMultipartBody(parts, HttpHeaders.EMPTY_HEADERS);
         final long expectedContentLength = multipartBody.getContentLength();
         try {
             final ByteBuf buffer = Unpooled.buffer(8192);
-            boolean last = false;
-            while (!last) {
-                if (multipartBody.transferTo(buffer) == BodyState.STOP) {
-                    last = true;
-                }
+            while (multipartBody.transferTo(buffer) != BodyState.STOP) {
             }
-            Assert.assertEquals(buffer.readableBytes(), expectedContentLength);
+            assertEquals(buffer.readableBytes(), expectedContentLength);
         } finally {
-            try {
-                multipartBody.close();
-            } catch (IOException ignore) {
-            }
+            IOUtils.closeQuietly(multipartBody);
         }
     }
 }
diff --git a/client/src/test/java/org/asynchttpclient/request/body/multipart/part/MultipartPartTest.java b/client/src/test/java/org/asynchttpclient/request/body/multipart/part/MultipartPartTest.java
new file mode 100644
index 000000000..d74f8ab36
--- /dev/null
+++ b/client/src/test/java/org/asynchttpclient/request/body/multipart/part/MultipartPartTest.java
@@ -0,0 +1,237 @@
+package org.asynchttpclient.request.body.multipart.part;
+
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.testng.Assert.assertEquals;
+
+import java.io.IOException;
+import java.nio.channels.WritableByteChannel;
+import java.nio.charset.Charset;
+
+import org.asynchttpclient.request.body.multipart.FileLikePart;
+import org.asynchttpclient.request.body.multipart.part.PartVisitor.CounterPartVisitor;
+import org.testng.annotations.Test;
+
+import io.netty.buffer.ByteBuf;
+
+public class MultipartPartTest {
+
+    @Test
+    public void testVisitStart() {
+        TestFileLikePart fileLikePart = new TestFileLikePart("Name");
+        try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[10])) {
+            CounterPartVisitor counterVisitor = new CounterPartVisitor();
+            multipartPart.visitStart(counterVisitor);
+            assertEquals(counterVisitor.getCount(), 12,
+                    "CounterPartVisitor count for visitStart should match EXTRA_BYTES count plus boundary bytes count");
+        }
+    }
+
+    @Test
+    public void testVisitStartZeroSizedByteArray() {
+        TestFileLikePart fileLikePart = new TestFileLikePart("Name");
+        try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
+            CounterPartVisitor counterVisitor = new CounterPartVisitor();
+            multipartPart.visitStart(counterVisitor);
+            assertEquals(counterVisitor.getCount(), 2,
+                    "CounterPartVisitor count for visitStart should match EXTRA_BYTES count when boundary byte array is of size zero");
+        }
+    }
+
+    @Test
+    public void testVisitDispositionHeaderWithoutFileName() {
+        TestFileLikePart fileLikePart = new TestFileLikePart("Name");
+        try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
+            CounterPartVisitor counterVisitor = new CounterPartVisitor();
+            multipartPart.visitDispositionHeader(counterVisitor);
+            assertEquals(counterVisitor.getCount(), 45, "CounterPartVisitor count for visitDispositionHeader should be equal to "
+                    + "CRLF_BYTES length + CONTENT_DISPOSITION_BYTES length + part name length when file name is not specified");
+        }
+    }
+
+    @Test
+    public void testVisitDispositionHeaderWithFileName() {
+        TestFileLikePart fileLikePart = new TestFileLikePart("baPart", null, null, null, null, "fileName");
+        try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
+            CounterPartVisitor counterVisitor = new CounterPartVisitor();
+            multipartPart.visitDispositionHeader(counterVisitor);
+            assertEquals(counterVisitor.getCount(), 68,
+                    "CounterPartVisitor count for visitDispositionHeader should be equal to "
+                            + "CRLF_BYTES length + CONTENT_DISPOSITION_BYTES length + part name length + file name length when"
+                            + " both part name and file name are present");
+        }
+    }
+
+    @Test
+    public void testVisitDispositionHeaderWithoutName() {
+        // with fileName
+        TestFileLikePart fileLikePart = new TestFileLikePart(null, null, null, null, null, "fileName");
+        try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
+            CounterPartVisitor counterVisitor = new CounterPartVisitor();
+            multipartPart.visitDispositionHeader(counterVisitor);
+            assertEquals(counterVisitor.getCount(), 53, "CounterPartVisitor count for visitDispositionHeader should be equal to "
+                    + "CRLF_BYTES length + CONTENT_DISPOSITION_BYTES length + file name length when part name is not specified");
+        }
+    }
+
+    @Test
+    public void testVisitContentTypeHeaderWithCharset() {
+        TestFileLikePart fileLikePart = new TestFileLikePart(null, "application/test", UTF_8, null, null);
+        try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
+            CounterPartVisitor counterVisitor = new CounterPartVisitor();
+            multipartPart.visitContentTypeHeader(counterVisitor);
+            assertEquals(counterVisitor.getCount(), 47, "CounterPartVisitor count for visitContentTypeHeader should be equal to "
+                    + "CRLF_BYTES length + CONTENT_TYPE_BYTES length + contentType length + charset length");
+        }
+    }
+
+    @Test
+    public void testVisitContentTypeHeaderWithoutCharset() {
+        TestFileLikePart fileLikePart = new TestFileLikePart(null, "application/test");
+        try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
+            CounterPartVisitor counterVisitor = new CounterPartVisitor();
+            multipartPart.visitContentTypeHeader(counterVisitor);
+            assertEquals(counterVisitor.getCount(), 32, "CounterPartVisitor count for visitContentTypeHeader should be equal to "
+                    + "CRLF_BYTES length + CONTENT_TYPE_BYTES length + contentType length when charset is not specified");
+        }
+    }
+
+    @Test
+    public void testVisitTransferEncodingHeader() {
+        TestFileLikePart fileLikePart = new TestFileLikePart(null, null, null, null, "transferEncoding");
+        try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
+            CounterPartVisitor counterVisitor = new CounterPartVisitor();
+            multipartPart.visitTransferEncodingHeader(counterVisitor);
+            assertEquals(counterVisitor.getCount(), 45, "CounterPartVisitor count for visitTransferEncodingHeader should be equal to "
+                    + "CRLF_BYTES length + CONTENT_TRANSFER_ENCODING_BYTES length + transferEncoding length");
+        }
+    }
+
+    @Test
+    public void testVisitContentIdHeader() {
+        TestFileLikePart fileLikePart = new TestFileLikePart(null, null, null, "contentId");
+        try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
+            CounterPartVisitor counterVisitor = new CounterPartVisitor();
+            multipartPart.visitContentIdHeader(counterVisitor);
+            assertEquals(counterVisitor.getCount(), 23, "CounterPartVisitor count for visitContentIdHeader should be equal to"
+                    + "CRLF_BYTES length + CONTENT_ID_BYTES length + contentId length");
+        }
+    }
+
+    @Test
+    public void testVisitCustomHeadersWhenNoCustomHeaders() {
+        TestFileLikePart fileLikePart = new TestFileLikePart(null);
+        try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
+            CounterPartVisitor counterVisitor = new CounterPartVisitor();
+            multipartPart.visitCustomHeaders(counterVisitor);
+            assertEquals(counterVisitor.getCount(), 0,
+                    "CounterPartVisitor count for visitCustomHeaders should be zero for visitCustomHeaders "
+                            + "when there are no custom headers");
+        }
+    }
+
+    @Test
+    public void testVisitCustomHeaders() {
+        TestFileLikePart fileLikePart = new TestFileLikePart(null);
+        fileLikePart.addCustomHeader("custom-header", "header-value");
+        try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
+            CounterPartVisitor counterVisitor = new CounterPartVisitor();
+            multipartPart.visitCustomHeaders(counterVisitor);
+            assertEquals(counterVisitor.getCount(), 27,
+                    "CounterPartVisitor count for visitCustomHeaders should include the length of the custom headers");
+        }
+    }
+
+    @Test
+    public void testVisitEndOfHeaders() {
+        TestFileLikePart fileLikePart = new TestFileLikePart(null);
+        try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
+            CounterPartVisitor counterVisitor = new CounterPartVisitor();
+            multipartPart.visitEndOfHeaders(counterVisitor);
+            assertEquals(counterVisitor.getCount(), 4, "CounterPartVisitor count for visitEndOfHeaders should be equal to 4");
+        }
+    }
+
+    @Test
+    public void testVisitPreContent() {
+        TestFileLikePart fileLikePart = new TestFileLikePart("Name", "application/test", UTF_8, "contentId", "transferEncoding",
+                "fileName");
+        fileLikePart.addCustomHeader("custom-header", "header-value");
+        try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
+            CounterPartVisitor counterVisitor = new CounterPartVisitor();
+            multipartPart.visitPreContent(counterVisitor);
+            assertEquals(counterVisitor.getCount(), 214, "CounterPartVisitor count for visitPreContent should "
+                    + "be equal to the sum of the lengths of precontent");
+        }
+    }
+
+    @Test
+    public void testVisitPostContents() {
+        TestFileLikePart fileLikePart = new TestFileLikePart(null);
+        try (TestMultipartPart multipartPart = new TestMultipartPart(fileLikePart, new byte[0])) {
+            CounterPartVisitor counterVisitor = new CounterPartVisitor();
+            multipartPart.visitPostContent(counterVisitor);
+            assertEquals(counterVisitor.getCount(), 2, "CounterPartVisitor count for visitPostContent should be equal to 2");
+        }
+    }
+
+    /**
+     * Concrete implementation of {@link FileLikePart} for use in unit tests
+     * 
+     */
+    private class TestFileLikePart extends FileLikePart {
+
+        public TestFileLikePart(String name) {
+            this(name, null, null, null, null);
+        }
+
+        public TestFileLikePart(String name, String contentType) {
+            this(name, contentType, null);
+        }
+
+        public TestFileLikePart(String name, String contentType, Charset charset) {
+            this(name, contentType, charset, null);
+        }
+
+        public TestFileLikePart(String name, String contentType, Charset charset, String contentId) {
+            this(name, contentType, charset, contentId, null);
+        }
+
+        public TestFileLikePart(String name, String contentType, Charset charset, String contentId, String transfertEncoding) {
+            this(name, contentType, charset, contentId, transfertEncoding, null);
+        }
+
+        public TestFileLikePart(String name, String contentType, Charset charset, String contentId, String transfertEncoding,
+                String fileName) {
+            super(name, contentType, charset, contentId, transfertEncoding);
+            setFileName(fileName);
+        }
+    }
+
+    /**
+     * Concrete implementation of MultipartPart for use in unit tests.
+     *
+     */
+    private class TestMultipartPart extends MultipartPart<TestFileLikePart> {
+
+        public TestMultipartPart(TestFileLikePart part, byte[] boundary) {
+            super(part, boundary);
+        }
+
+        @Override
+        protected long getContentLength() {
+            return 0;
+        }
+
+        @Override
+        protected long transferContentTo(ByteBuf target) throws IOException {
+            return 0;
+        }
+
+        @Override
+        protected long transferContentTo(WritableByteChannel target) throws IOException {
+            return 0;
+        }
+
+    }
+
+}
diff --git a/client/src/test/java/org/asynchttpclient/test/EchoHandler.java b/client/src/test/java/org/asynchttpclient/test/EchoHandler.java
index bbb97b342..cbc779688 100644
--- a/client/src/test/java/org/asynchttpclient/test/EchoHandler.java
+++ b/client/src/test/java/org/asynchttpclient/test/EchoHandler.java
@@ -29,7 +29,6 @@ public void handle(String pathInContext, Request request, HttpServletRequest htt
         if (request.getMethod().equalsIgnoreCase("OPTIONS")) {
             httpResponse.addHeader("Allow", "GET,HEAD,POST,OPTIONS,TRACE");
         }
-        ;
 
         Enumeration<?> e = httpRequest.getHeaderNames();
         String param;
diff --git a/client/src/test/java/org/asynchttpclient/test/EventCollectingHandler.java b/client/src/test/java/org/asynchttpclient/test/EventCollectingHandler.java
index c7f7644c4..3d33cbdbb 100644
--- a/client/src/test/java/org/asynchttpclient/test/EventCollectingHandler.java
+++ b/client/src/test/java/org/asynchttpclient/test/EventCollectingHandler.java
@@ -14,7 +14,8 @@
 
 import io.netty.channel.Channel;
 
-import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.util.List;
 import java.util.Queue;
 import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.CountDownLatch;
@@ -24,7 +25,6 @@
 import org.asynchttpclient.HttpResponseHeaders;
 import org.asynchttpclient.HttpResponseStatus;
 import org.asynchttpclient.Response;
-import org.asynchttpclient.channel.NameResolution;
 import org.asynchttpclient.handler.AsyncHandlerExtensions;
 import org.asynchttpclient.netty.request.NettyRequest;
 import org.testng.Assert;
@@ -37,10 +37,14 @@
     public static final String HEADERS_WRITTEN_EVENT = "HeadersWritten";
     public static final String CONTENT_WRITTEN_EVENT = "ContentWritten";
     public static final String CONNECTION_OPEN_EVENT = "ConnectionOpen";
-    public static final String DNS_RESOLVED_EVENT = "DnsResolved";
+    public static final String HOSTNAME_RESOLUTION_EVENT = "HostnameResolution";
+    public static final String HOSTNAME_RESOLUTION_SUCCESS_EVENT = "HostnameResolutionSuccess";
+    public static final String HOSTNAME_RESOLUTION_FAILURE_EVENT = "HostnameResolutionFailure";
     public static final String CONNECTION_SUCCESS_EVENT = "ConnectionSuccess";
     public static final String CONNECTION_FAILURE_EVENT = "ConnectionFailure";
-    public static final String SSL_HANDSHAKE_COMPLETED_EVENT = "SslHandshakeCompleted";
+    public static final String TLS_HANDSHAKE_EVENT = "TlsHandshake";
+    public static final String TLS_HANDSHAKE_SUCCESS_EVENT = "TlsHandshakeSuccess";
+    public static final String TLS_HANDSHAKE_FAILURE_EVENT = "TlsHandshakeFailure";
     public static final String CONNECTION_POOL_EVENT = "ConnectionPool";
     public static final String CONNECTION_POOLED_EVENT = "ConnectionPooled";
     public static final String CONNECTION_OFFER_EVENT = "ConnectionOffer";
@@ -91,32 +95,52 @@ public State onContentWritten() {
     }
 
     @Override
-    public void onConnectionOpen() {
+    public void onTcpConnectAttempt(InetSocketAddress address) {
         firedEvents.add(CONNECTION_OPEN_EVENT);
     }
 
     @Override
-    public void onDnsResolved(NameResolution[] nameResolutions) {
-        firedEvents.add(DNS_RESOLVED_EVENT);
+    public void onTcpConnectSuccess(InetSocketAddress address, Channel connection) {
+        firedEvents.add(CONNECTION_SUCCESS_EVENT);
     }
 
     @Override
-    public void onConnectionSuccess(Channel connection, InetAddress address) {
-        firedEvents.add(CONNECTION_SUCCESS_EVENT);
+    public void onTcpConnectFailure(InetSocketAddress address, Throwable t) {
+        firedEvents.add(CONNECTION_FAILURE_EVENT);
     }
 
     @Override
-    public void onConnectionFailure(InetAddress address) {
-        firedEvents.add(CONNECTION_FAILURE_EVENT);
+    public void onHostnameResolutionAttempt(String name) {
+        firedEvents.add(HOSTNAME_RESOLUTION_EVENT);
+    }
+
+    @Override
+    public void onHostnameResolutionSuccess(String name, List<InetSocketAddress> addresses) {
+        firedEvents.add(HOSTNAME_RESOLUTION_SUCCESS_EVENT);
+    }
+
+    @Override
+    public void onHostnameResolutionFailure(String name, Throwable cause) {
+        firedEvents.add(HOSTNAME_RESOLUTION_FAILURE_EVENT);
+    }
+
+    @Override
+    public void onTlsHandshakeAttempt() {
+        firedEvents.add(TLS_HANDSHAKE_EVENT);
+    }
+
+    @Override
+    public void onTlsHandshakeSuccess() {
+        firedEvents.add(TLS_HANDSHAKE_SUCCESS_EVENT);
     }
 
     @Override
-    public void onSslHandshakeCompleted() {
-        firedEvents.add(SSL_HANDSHAKE_COMPLETED_EVENT);
+    public void onTlsHandshakeFailure(Throwable cause) {
+        firedEvents.add(TLS_HANDSHAKE_FAILURE_EVENT);
     }
 
     @Override
-    public void onConnectionPool() {
+    public void onConnectionPoolAttempt() {
         firedEvents.add(CONNECTION_POOL_EVENT);
     }
 
diff --git a/client/src/test/java/org/asynchttpclient/test/TestUtils.java b/client/src/test/java/org/asynchttpclient/test/TestUtils.java
index 2cd9be945..561fa723a 100644
--- a/client/src/test/java/org/asynchttpclient/test/TestUtils.java
+++ b/client/src/test/java/org/asynchttpclient/test/TestUtils.java
@@ -1,7 +1,7 @@
 package org.asynchttpclient.test;
 
 import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.*;
 
 import java.io.File;
 import java.io.FileNotFoundException;
@@ -24,6 +24,7 @@
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Locale;
 import java.util.Set;
 import java.util.UUID;
 import java.util.concurrent.atomic.AtomicBoolean;
@@ -35,8 +36,15 @@
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.TrustManagerFactory;
 import javax.net.ssl.X509TrustManager;
+import javax.servlet.http.HttpServletResponse;
 
 import org.apache.commons.io.FileUtils;
+import org.asynchttpclient.AsyncCompletionHandler;
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseHeaders;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.Response;
 import org.asynchttpclient.SslEngineFactory;
 import org.asynchttpclient.netty.ssl.JsseSslEngineFactory;
 import org.eclipse.jetty.security.ConstraintMapping;
@@ -62,10 +70,11 @@
 
 public class TestUtils {
 
+    public final static int TIMEOUT = 30;
     public static final String USER = "user";
     public static final String ADMIN = "admin";
-    public static final String TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET = "text/html; charset=UTF-8";
-    public static final String TEXT_HTML_CONTENT_TYPE_WITH_ISO_8859_1_CHARSET = "text/html; charset=ISO-8859-1";
+    public static final String TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET = "text/html;charset=UTF-8";
+    public static final String TEXT_HTML_CONTENT_TYPE_WITH_ISO_8859_1_CHARSET = "text/html;charset=ISO-8859-1";
     public static final File TMP_DIR = new File(System.getProperty("java.io.tmpdir"), "ahc-tests-" + UUID.randomUUID().toString().substring(0, 8));
     public static final byte[] PATTERN_BYTES = "FooBarBazQixFooBarBazQixFooBarBazQixFooBarBazQixFooBarBazQixFooBarBazQix".getBytes(Charset.forName("UTF-16"));
     public static final File LARGE_IMAGE_FILE;
@@ -175,7 +184,6 @@ public static Server newJettyHttpServer(int port) {
     public static void addHttpConnector(Server server, int port) {
         ServerConnector connector = new ServerConnector(server);
         connector.setPort(port);
-
         server.addConnector(connector);
     }
 
@@ -271,6 +279,10 @@ private static void addAuthHandler(Server server, String auth, LoginAuthenticato
         tmf.init(ks);
         return tmf.getTrustManagers();
     }
+    
+    public static SslEngineFactory createSslEngineFactory() throws SSLException {
+        return createSslEngineFactory(new AtomicBoolean(true));
+    }
 
     public static SslEngineFactory createSslEngineFactory(AtomicBoolean trust) throws SSLException {
 
@@ -340,4 +352,62 @@ public static File getClasspathFile(String file) throws FileNotFoundException {
             throw new FileNotFoundException(file);
         }
     }
+
+    public static void assertContentTypesEquals(String actual, String expected) {
+        assertEquals(actual.replace("; ", "").toLowerCase(Locale.ENGLISH), expected.replace("; ", "").toLowerCase(Locale.ENGLISH), "Unexpected content-type");
+    }
+
+    public static String getLocalhostIp() {
+        return "127.0.0.1";
+    }
+
+    public static class AsyncCompletionHandlerAdapter extends AsyncCompletionHandler<Response> {
+
+        @Override
+        public Response onCompleted(Response response) throws Exception {
+            return response;
+        }
+
+        @Override
+        public void onThrowable(Throwable t) {
+            fail("Unexpected exception: " + t.getMessage(), t);
+        }
+    }
+
+    public static class AsyncHandlerAdapter implements AsyncHandler<String> {
+
+        @Override
+        public void onThrowable(Throwable t) {
+            fail("Unexpected exception", t);
+        }
+
+        @Override
+        public State onBodyPartReceived(final HttpResponseBodyPart content) throws Exception {
+            return State.CONTINUE;
+        }
+
+        @Override
+        public State onStatusReceived(final HttpResponseStatus responseStatus) throws Exception {
+            return State.CONTINUE;
+        }
+
+        @Override
+        public State onHeadersReceived(final HttpResponseHeaders headers) throws Exception {
+            return State.CONTINUE;
+        }
+
+        @Override
+        public String onCompleted() throws Exception {
+            return "";
+        }
+    }
+
+    public static void writeResponseBody(HttpServletResponse response, String body) {
+        response.setContentLength(body.length());
+        try {
+            response.getOutputStream().print(body);
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
 }
diff --git a/client/src/test/java/org/asynchttpclient/testserver/HttpServer.java b/client/src/test/java/org/asynchttpclient/testserver/HttpServer.java
new file mode 100644
index 000000000..0d38023bc
--- /dev/null
+++ b/client/src/test/java/org/asynchttpclient/testserver/HttpServer.java
@@ -0,0 +1,260 @@
+/*
+ * Copyright (c) 2016 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.testserver;
+
+import static org.asynchttpclient.test.TestUtils.*;
+import io.netty.handler.codec.http.HttpHeaders;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.util.Enumeration;
+import java.util.Map.Entry;
+import java.util.concurrent.ConcurrentLinkedQueue;
+
+import javax.servlet.ServletException;
+import javax.servlet.http.Cookie;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.eclipse.jetty.server.Handler;
+import org.eclipse.jetty.server.Request;
+import org.eclipse.jetty.server.Server;
+import org.eclipse.jetty.server.handler.AbstractHandler;
+
+public class HttpServer implements Closeable {
+
+    private int httpPort;
+    private int httpsPort;
+    private Server server;
+    private final ConcurrentLinkedQueue<Handler> handlers = new ConcurrentLinkedQueue<>();
+    
+    @FunctionalInterface
+    public interface HttpServletResponseConsumer {
+        
+        public void apply(HttpServletResponse response) throws IOException, ServletException;
+    }
+
+    public HttpServer() {
+    }
+
+    public HttpServer(int httpPort, int httpsPort) {
+        this.httpPort = httpPort;
+        this.httpsPort = httpsPort;
+    }
+
+    public void start() throws Exception {
+        if (httpPort == 0) {
+            httpPort = findFreePort();
+        }
+        if (httpsPort == 0) {
+            httpsPort = findFreePort();
+        }
+        server = newJettyHttpServer(httpPort);
+        server.setHandler(new QueueHandler());
+        addHttpsConnector(server, httpsPort);
+        server.start();
+    }
+
+    public void enqueue(Handler handler) {
+        handlers.offer(handler);
+    }
+
+    public void enqueueOk() {
+        enqueueResponse(response -> response.setStatus(200));
+    }
+
+    public void enqueueResponse(HttpServletResponseConsumer c) {
+        handlers.offer(new ConsumerHandler(c));
+    }
+
+    public void enqueueEcho() {
+        handlers.offer(new EchoHandler());
+    }
+
+    public void enqueueRedirect(int status, String location) {
+        enqueueResponse(response -> {
+            response.setStatus(status);
+            response.setHeader(HttpHeaders.Names.LOCATION, location);
+        });
+    }
+
+    public int getHttpPort() {
+        return httpPort;
+    }
+
+    public int getsHttpPort() {
+        return httpsPort;
+    }
+
+    public String getHttpUrl() {
+        return "http://localhost:" + httpPort;
+    }
+
+    public String getHttpsUrl() {
+        return "https://localhost:" + httpsPort;
+    }
+
+    public void reset() {
+        handlers.clear();
+    }
+
+    @Override
+    public void close() throws IOException {
+        if (server == null) {
+            try {
+                server.stop();
+            } catch (Exception e) {
+                throw new IOException(e);
+            }
+        }
+    }
+
+    private class QueueHandler extends AbstractHandler {
+
+        @Override
+        public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+
+            Handler handler = HttpServer.this.handlers.poll();
+            if (handler == null) {
+                response.sendError(500, "No handler enqueued");
+                response.getOutputStream().flush();
+                response.getOutputStream().close();
+
+            } else {
+                handler.handle(target, baseRequest, request, response);
+            }
+        }
+    }
+
+    public static abstract class AutoFlushHandler extends AbstractHandler {
+
+        private final boolean closeAfterResponse;
+
+        public AutoFlushHandler() {
+            this(false);
+        }
+
+        public AutoFlushHandler(boolean closeAfterResponse) {
+            this.closeAfterResponse = closeAfterResponse;
+        }
+
+        @Override
+        public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+            handle0(target, baseRequest, request, response);
+            response.getOutputStream().flush();
+            if (closeAfterResponse) {
+                response.getOutputStream().close();
+            }
+        }
+
+        protected abstract void handle0(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException;
+    }
+
+    private static class ConsumerHandler extends AutoFlushHandler {
+
+        private final HttpServletResponseConsumer c;
+
+        public ConsumerHandler(HttpServletResponseConsumer c) {
+            this(c, false);
+        }
+
+        public ConsumerHandler(HttpServletResponseConsumer c, boolean closeAfterResponse) {
+            super(closeAfterResponse);
+            this.c = c;
+        }
+
+        @Override
+        protected void handle0(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+            c.apply(response);
+        }
+    }
+
+    public static class EchoHandler extends AutoFlushHandler {
+
+        @Override
+        protected void handle0(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
+
+            String delay = request.getHeader("X-Delay");
+            if (delay != null) {
+                try {
+                    Thread.sleep(Long.parseLong(delay));
+                } catch (NumberFormatException | InterruptedException e1) {
+                    throw new ServletException(e1);
+                }
+            }
+
+            response.setStatus(200);
+
+            if (request.getMethod().equalsIgnoreCase("OPTIONS")) {
+                response.addHeader("Allow", "GET,HEAD,POST,OPTIONS,TRACE");
+            }
+
+            response.setContentType(request.getHeader("X-IsoCharset") != null ? TEXT_HTML_CONTENT_TYPE_WITH_ISO_8859_1_CHARSET : TEXT_HTML_CONTENT_TYPE_WITH_UTF_8_CHARSET);
+
+            response.addHeader("X-ClientPort", String.valueOf(request.getRemotePort()));
+
+            String pathInfo = request.getPathInfo();
+            if (pathInfo != null)
+                response.addHeader("X-PathInfo", pathInfo);
+
+            String queryString = request.getQueryString();
+            if (queryString != null)
+                response.addHeader("X-QueryString", queryString);
+
+            Enumeration<String> headerNames = request.getHeaderNames();
+            while (headerNames.hasMoreElements()) {
+                String headerName = headerNames.nextElement();
+                response.addHeader("X-" + headerName, request.getHeader(headerName));
+            }
+
+            for (Entry<String, String[]> e : baseRequest.getParameterMap().entrySet()) {
+                response.addHeader("X-" + e.getKey(), e.getValue()[0]);
+            }
+
+            Cookie[] cs = request.getCookies();
+            if (cs != null) {
+                for (Cookie c : cs) {
+                    response.addCookie(c);
+                }
+            }
+
+            Enumeration<String> parameterNames = request.getParameterNames();
+            StringBuilder requestBody = new StringBuilder();
+            while (parameterNames.hasMoreElements()) {
+                String param = parameterNames.nextElement().toString();
+                response.addHeader("X-" + param, request.getParameter(param));
+                requestBody.append(param);
+                requestBody.append("_");
+            }
+            if (requestBody.length() > 0) {
+                response.getOutputStream().write(requestBody.toString().getBytes());
+            }
+
+            int size = 16384;
+            if (request.getContentLength() > 0) {
+                size = request.getContentLength();
+            }
+            if (size > 0) {
+                byte[] bytes = new byte[size];
+                int read = 0;
+                while (read > -1) {
+                    read = request.getInputStream().read(bytes);
+                    if (read > 0) {
+                        response.getOutputStream().write(bytes, 0, read);
+                    }
+                }
+            }
+        }
+    }
+}
diff --git a/client/src/test/java/org/asynchttpclient/testserver/HttpTest.java b/client/src/test/java/org/asynchttpclient/testserver/HttpTest.java
new file mode 100644
index 000000000..378f11292
--- /dev/null
+++ b/client/src/test/java/org/asynchttpclient/testserver/HttpTest.java
@@ -0,0 +1,101 @@
+/*
+ * Copyright (c) 2016 AsyncHttpClient Project. All rights reserved.
+ *
+ * This program is licensed to you under the Apache License Version 2.0,
+ * and you may not use this file except in compliance with the Apache License Version 2.0.
+ * You may obtain a copy of the Apache License Version 2.0 at
+ *     http://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the Apache License Version 2.0 is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the Apache License Version 2.0 for the specific language governing permissions and limitations there under.
+ */
+package org.asynchttpclient.testserver;
+
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.DefaultAsyncHttpClientConfig;
+
+import static org.asynchttpclient.Dsl.*;
+
+public abstract class HttpTest {
+
+    protected static final String COMPLETED_EVENT = "Completed";
+    protected static final String STATUS_RECEIVED_EVENT = "StatusReceived";
+    protected static final String HEADERS_RECEIVED_EVENT = "HeadersReceived";
+    protected static final String HEADERS_WRITTEN_EVENT = "HeadersWritten";
+    protected static final String CONTENT_WRITTEN_EVENT = "ContentWritten";
+    protected static final String CONNECTION_OPEN_EVENT = "ConnectionOpen";
+    protected static final String HOSTNAME_RESOLUTION_EVENT = "HostnameResolution";
+    protected static final String HOSTNAME_RESOLUTION_SUCCESS_EVENT = "HostnameResolutionSuccess";
+    protected static final String HOSTNAME_RESOLUTION_FAILURE_EVENT = "HostnameResolutionFailure";
+    protected static final String CONNECTION_SUCCESS_EVENT = "ConnectionSuccess";
+    protected static final String CONNECTION_FAILURE_EVENT = "ConnectionFailure";
+    protected static final String TLS_HANDSHAKE_EVENT = "TlsHandshake";
+    protected static final String TLS_HANDSHAKE_SUCCESS_EVENT = "TlsHandshakeSuccess";
+    protected static final String TLS_HANDSHAKE_FAILURE_EVENT = "TlsHandshakeFailure";
+    protected static final String CONNECTION_POOL_EVENT = "ConnectionPool";
+    protected static final String CONNECTION_POOLED_EVENT = "ConnectionPooled";
+    protected static final String CONNECTION_OFFER_EVENT = "ConnectionOffer";
+    protected static final String REQUEST_SEND_EVENT = "RequestSend";
+    protected static final String RETRY_EVENT = "Retry";
+
+    @FunctionalInterface
+    protected interface ClientFunction {
+        void apply(AsyncHttpClient client) throws Throwable;
+    }
+
+    @FunctionalInterface
+    protected interface ServerFunction {
+        void apply(HttpServer server) throws Throwable;
+    }
+
+    protected static class ClientTestBody {
+
+        private final AsyncHttpClientConfig config;
+
+        private ClientTestBody(AsyncHttpClientConfig config) {
+            this.config = config;
+        }
+
+        public void run(ClientFunction f) throws Throwable {
+            try (AsyncHttpClient client = asyncHttpClient(config)) {
+                f.apply(client);
+            }
+        }
+    }
+
+    protected static class ServerTestBody {
+
+        private final HttpServer server;
+
+        private ServerTestBody(HttpServer server) {
+            this.server = server;
+        }
+
+        public void run(ServerFunction f) throws Throwable {
+            try {
+                f.apply(server);
+            } finally {
+                server.reset();
+            }
+        }
+    }
+
+    protected ClientTestBody withClient() {
+        return withClient(config().setMaxRedirects(0));
+    }
+
+    protected ClientTestBody withClient(DefaultAsyncHttpClientConfig.Builder builder) {
+        return withClient(builder.build());
+    }
+
+    protected ClientTestBody withClient(AsyncHttpClientConfig config) {
+        return new ClientTestBody(config);
+    }
+
+    protected ServerTestBody withServer(HttpServer server) {
+        return new ServerTestBody(server);
+    }
+}
diff --git a/client/src/test/java/org/asynchttpclient/uri/UriParserTest.java b/client/src/test/java/org/asynchttpclient/uri/UriParserTest.java
new file mode 100644
index 000000000..ff4c9adfc
--- /dev/null
+++ b/client/src/test/java/org/asynchttpclient/uri/UriParserTest.java
@@ -0,0 +1,125 @@
+package org.asynchttpclient.uri;
+
+import static org.testng.Assert.*;
+
+import org.testng.annotations.Test;
+
+public class UriParserTest {
+
+    @Test
+    public void testUrlHasLeadingAndTrailingWhiteSpace() {
+        UriParser parser = new UriParser();
+        parser.parse(null, "  http://user@example.com:8080/test?q=1  ");
+        assertEquals(parser.authority, "user@example.com:8080", "Incorrect authority assigned by the parse method");
+        assertEquals(parser.host, "example.com", "Incorrect host assigned by the parse method");
+        assertEquals(parser.path, "/test", "Incorrect path assigned by the parse method");
+        assertEquals(parser.port, 8080, "Incorrect port assigned by the parse method");
+        assertEquals(parser.query, "q=1", "Incorrect query assigned by the parse method");
+        assertEquals(parser.scheme, "http", "Incorrect scheme assigned by the parse method");
+        assertEquals(parser.userInfo, "user", "Incorrect userInfo assigned by the parse method");
+    }
+
+    @Test
+    public void testSchemeTakenFromUrlWhenValid() {
+        Uri context = new Uri("https", null, "example.com", 80, "/path", "");
+        UriParser parser = new UriParser();
+        parser.parse(context, "http://example.com/path");
+        assertEquals(parser.scheme, "http", "If URL has a valid scheme it should be given priority than the scheme in the context");
+    }
+
+    @Test
+    public void testRelativeURL() {
+        Uri context = new Uri("https", null, "example.com", 80, "/path", "q=2");
+        UriParser parser = new UriParser();
+        parser.parse(context, "/relativeUrl");
+        assertEquals(parser.host, "example.com", "Host should be taken from the context when parsing a relative URL");
+        assertEquals(parser.port, 80, "Port should be taken from the context when parsing a relative URL");
+        assertEquals(parser.scheme, "https", "Scheme should be taken from the context when parsing a relative URL");
+        assertEquals(parser.path, "/relativeUrl", "Path should be equal to the relative URL passed to the parse method");
+        assertEquals(parser.query, null, "Query should be empty if the relative URL did not have a query");
+    }
+
+    @Test
+    public void testUrlFragment() {
+        Uri context = new Uri("https", null, "example.com", 80, "/path", "q=2");
+        UriParser parser = new UriParser();
+        parser.parse(context, "#test");
+        assertEquals(parser.host, "example.com", "Host should be taken from the context when parsing a URL fragment");
+        assertEquals(parser.port, 80, "Port should be taken from the context when parsing a URL fragment");
+        assertEquals(parser.scheme, "https", "Scheme should be taken from the context when parsing a URL fragment");
+        assertEquals(parser.path, "/path", "Path should be taken from the context when parsing a URL fragment");
+        assertEquals(parser.query, null, "Query should be empty when parsing a URL fragment");
+    }
+
+    @Test
+    public void testRelativeUrlWithQuery() {
+        Uri context = new Uri("https", null, "example.com", 80, "/path", "q=2");
+        UriParser parser = new UriParser();
+        parser.parse(context, "/relativePath?q=3");
+        assertEquals(parser.host, "example.com", "Host should be taken from the contenxt when parsing a relative URL");
+        assertEquals(parser.port, 80, "Port should be taken from the context when parsing a relative URL");
+        assertEquals(parser.scheme, "https", "Scheme should be taken from the context when parsing a relative URL");
+        assertEquals(parser.path, "/relativePath", "Path should be same as relativePath passed to the parse method");
+        assertEquals(parser.query, "q=3", "Query should be taken from the relative URL");
+    }
+
+    @Test
+    public void testRelativeUrlWithQueryOnly() {
+        Uri context = new Uri("https", null, "example.com", 80, "/path", "q=2");
+        UriParser parser = new UriParser();
+        parser.parse(context, "?q=3");
+        assertEquals(parser.host, "example.com", "Host should be taken from the context when parsing a relative URL");
+        assertEquals(parser.port, 80, "Port should be taken from the context when parsing a relative URL");
+        assertEquals(parser.scheme, "https", "Scheme should be taken from the conxt when parsing a relative URL");
+        assertEquals(parser.path, "/", "Path should be '/' for a relative URL with only query");
+        assertEquals(parser.query, "q=3", "Query should be same as specified in the relative URL");
+    }
+
+    @Test
+    public void testRelativeURLWithDots() {
+        Uri context = new Uri("https", null, "example.com", 80, "/path", "q=2");
+        UriParser parser = new UriParser();
+        parser.parse(context, "./relative/./url");
+        assertEquals(parser.host, "example.com", "Host should be taken from the context when parsing a relative URL");
+        assertEquals(parser.port, 80, "Port should be taken from the context when parsing a relative URL");
+        assertEquals(parser.scheme, "https", "Scheme should be taken from the context when parsing a relative URL");
+        assertEquals(parser.path, "/relative/url", "Path should be equal to the path in the relative URL with dots removed");
+        assertEquals(parser.query, null, "Query should be null if the relative URL did not have a query");
+    }
+
+    @Test
+    public void testRelativeURLWithTwoEmbeddedDots() {
+        Uri context = new Uri("https", null, "example.com", 80, "/path", "q=2");
+        UriParser parser = new UriParser();
+        parser.parse(context, "./relative/../url");
+        assertEquals(parser.host, "example.com", "Host should be taken from the context when parsing a relative URL");
+        assertEquals(parser.port, 80, "Port should be taken from the context when parsing a relative URL");
+        assertEquals(parser.scheme, "https", "Scheme should be taken from the context when parsing a relative URL");
+        assertEquals(parser.path, "/url", "Path should be equal to the relative URL path with the embedded dots appropriately removed");
+        assertEquals(parser.query, null, "Query should be null if the relative URL does not have a query");
+    }
+
+    @Test
+    public void testRelativeURLWithTwoTrailingDots() {
+        Uri context = new Uri("https", null, "example.com", 80, "/path", "q=2");
+        UriParser parser = new UriParser();
+        parser.parse(context, "./relative/url/..");
+        assertEquals(parser.host, "example.com", "Host should be taken from the context when parsing a relative URL");
+        assertEquals(parser.port, 80, "Port should be taken from the context when parsing a relative URL");
+        assertEquals(parser.scheme, "https", "Scheme should be taken from the context when parsing a relative URL");
+        assertEquals(parser.path, "/relative/", "Path should be equal to the relative URL path with the trailing dots appropriately removed");
+        assertEquals(parser.query, null, "Query should be null if the relative URL does not have a query");
+    }
+    
+    @Test
+    public void testRelativeURLWithOneTrailingDot() {
+        Uri context = new Uri("https", null, "example.com", 80, "/path", "q=2");
+        UriParser parser = new UriParser();
+        parser.parse(context, "./relative/url/.");
+        assertEquals(parser.host, "example.com", "Host should be taken from the context when parsing a relative URL");
+        assertEquals(parser.port, 80, "Port should be taken from the context when parsing a relative URL");
+        assertEquals(parser.scheme, "https", "Scheme should be taken from the context when parsing a relative URL");
+        assertEquals(parser.path, "/relative/url/", "Path should be equal to the relative URL path with the trailing dot appropriately removed");
+        assertEquals(parser.query, null, "Query should be null if the relative URL does not have a query");
+    }
+}
diff --git a/client/src/test/java/org/asynchttpclient/uri/UriTest.java b/client/src/test/java/org/asynchttpclient/uri/UriTest.java
index 6ff410a07..4b53d52ed 100644
--- a/client/src/test/java/org/asynchttpclient/uri/UriTest.java
+++ b/client/src/test/java/org/asynchttpclient/uri/UriTest.java
@@ -14,8 +14,7 @@
 
 import org.testng.annotations.Test;
 
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertNull;
+import static org.testng.Assert.*;
 
 public class UriTest {
 
@@ -214,4 +213,107 @@ public void testRelativeUriWithConsecutiveDotsFromLevel3Resource() {
         assertEquals(url.getPath(), "/../other/content/img.png");
         assertNull(url.getQuery());
     }
+
+    @Test
+    public void testCreateAndToUrl() {
+        String url = "https://hello.com/level1/level2/level3";
+        Uri uri = Uri.create(url);
+        assertEquals(uri.toUrl(), url, "url used to create uri and url returned from toUrl do not match");
+    }
+
+    @Test
+    public void testToUrlWithUserInfoPortPathAndQuery() {
+        Uri uri = new Uri("http", "user", "example.com", 44, "/path/path2", "query=4");
+        assertEquals(uri.toUrl(), "http://user@example.com:44/path/path2?query=4", "toUrl returned incorrect url");
+    }
+
+    @Test
+    public void testWithNewScheme() {
+        Uri uri = new Uri("http", "user", "example.com", 44, "/path/path2", "query=4");
+        Uri newUri = uri.withNewScheme("https");
+        assertEquals(newUri.getScheme(), "https");
+        assertEquals(newUri.toUrl(), "https://user@example.com:44/path/path2?query=4", "toUrl returned incorrect url");
+    }
+
+    @Test
+    public void testWithNewQuery() {
+        Uri uri = new Uri("http", "user", "example.com", 44, "/path/path2", "query=4");
+        Uri newUri = uri.withNewQuery("query2=10&query3=20");
+        assertEquals(newUri.getQuery(), "query2=10&query3=20");
+        assertEquals(newUri.toUrl(), "http://user@example.com:44/path/path2?query2=10&query3=20", "toUrl returned incorrect url");
+    }
+
+    @Test
+    public void testToRelativeUrl() {
+        Uri uri = new Uri("http", "user", "example.com", 44, "/path/path2", "query=4");
+        String relativeUrl = uri.toRelativeUrl();
+        assertEquals(relativeUrl, "/path/path2?query=4", "toRelativeUrl returned incorrect url");
+    }
+    
+    @Test
+    public void testToRelativeUrlWithEmptyPath() {
+        Uri uri = new Uri("http", "user", "example.com", 44, null, "query=4");
+        String relativeUrl = uri.toRelativeUrl();
+        assertEquals(relativeUrl, "/?query=4", "toRelativeUrl returned incorrect url");
+    }
+    
+    @Test
+    public void tsetGetSchemeDefaultPortHttpScheme(){
+        String url = "https://hello.com/level1/level2/level3";
+        Uri uri = Uri.create(url);       
+        assertEquals(uri.getSchemeDefaultPort(), 443, "schema default port should be 443 for https url");
+
+        String url2 = "http://hello.com/level1/level2/level3";
+        Uri uri2 = Uri.create(url2);       
+        assertEquals(uri2.getSchemeDefaultPort(), 80, "schema default port should be 80 for http url");
+    }
+    
+    @Test
+    public void tsetGetSchemeDefaultPortWebSocketScheme(){
+        String url = "wss://hello.com/level1/level2/level3";
+        Uri uri = Uri.create(url);       
+        assertEquals(uri.getSchemeDefaultPort(), 443, "schema default port should be 443 for wss url");
+
+        String url2 = "ws://hello.com/level1/level2/level3";
+        Uri uri2 = Uri.create(url2);       
+        assertEquals(uri2.getSchemeDefaultPort(), 80, "schema default port should be 80 for ws url");
+    }
+    
+    @Test
+    public void testGetExplicitPort(){
+        String url = "http://hello.com/level1/level2/level3";
+        Uri uri = Uri.create(url);
+        assertEquals(uri.getExplicitPort(), 80, "getExplicitPort should return port 80 for http url when port is not specified in url");
+        
+        String url2 = "http://hello.com:8080/level1/level2/level3";
+        Uri uri2 = Uri.create(url2);
+        assertEquals(uri2.getExplicitPort(), 8080, "getExplicitPort should return the port given in the url");
+    }
+    
+    @Test
+    public void testEquals() {
+        String url = "http://user@hello.com:8080/level1/level2/level3?q=1";
+        Uri createdUri = Uri.create(url);
+        Uri constructedUri = new Uri("http", "user", "hello.com", 8080, "/level1/level2/level3", "q=1");
+        assertTrue(createdUri.equals(constructedUri), "The equals method returned false for two equal urls");
+    }
+    
+    @Test
+    public void testIsWebsocket() {
+        String url = "http://user@hello.com:8080/level1/level2/level3?q=1";
+        Uri uri = Uri.create(url);
+        assertFalse(uri.isWebSocket(), "isWebSocket should return false for http url");
+        
+        url = "https://user@hello.com:8080/level1/level2/level3?q=1";
+        uri = Uri.create(url);
+        assertFalse(uri.isWebSocket(), "isWebSocket should return false for https url");
+        
+        url = "ws://user@hello.com:8080/level1/level2/level3?q=1";
+        uri = Uri.create(url);
+        assertTrue(uri.isWebSocket(), "isWebSocket should return true for ws url");
+        
+        url = "wss://user@hello.com:8080/level1/level2/level3?q=1";
+        uri = Uri.create(url);
+        assertTrue(uri.isWebSocket(), "isWebSocket should return true for wss url");
+    }
 }
diff --git a/client/src/test/java/org/asynchttpclient/util/HttpUtilsTest.java b/client/src/test/java/org/asynchttpclient/util/HttpUtilsTest.java
new file mode 100644
index 000000000..d5afd7937
--- /dev/null
+++ b/client/src/test/java/org/asynchttpclient/util/HttpUtilsTest.java
@@ -0,0 +1,150 @@
+package org.asynchttpclient.util;
+
+import static org.testng.Assert.*;
+
+import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
+
+import org.asynchttpclient.DefaultAsyncHttpClientConfig;
+import org.asynchttpclient.Dsl;
+import org.asynchttpclient.Request;
+import org.asynchttpclient.uri.Uri;
+import org.testng.annotations.Test;
+
+public class HttpUtilsTest {
+
+    @Test
+    public void testGetAuthority() {
+        Uri uri = Uri.create("http://stackoverflow.com/questions/17814461/jacoco-maven-testng-0-test-coverage");
+        String authority = HttpUtils.getAuthority(uri);
+        assertEquals(authority, "stackoverflow.com:80", "Incorrect authority returned from getAuthority");
+    }
+
+    @Test
+    public void testGetAuthorityWithPortInUrl() {
+        Uri uri = Uri.create("http://stackoverflow.com:8443/questions/17814461/jacoco-maven-testng-0-test-coverage");
+        String authority = HttpUtils.getAuthority(uri);
+        assertEquals(authority, "stackoverflow.com:8443", "Incorrect authority returned from getAuthority");
+    }
+
+    @Test
+    public void testGetBaseUrl() {
+        Uri uri = Uri.create("http://stackoverflow.com:8443/questions/17814461/jacoco-maven-testng-0-test-coverage");
+        String baseUrl = HttpUtils.getBaseUrl(uri);
+        assertEquals(baseUrl, "http://stackoverflow.com:8443", "Incorrect base URL returned from getBaseURL");
+    }
+
+    @Test
+    public void testIsSameBaseUrlReturnsFalseWhenPortDifferent() {
+        Uri uri1 = Uri.create("http://stackoverflow.com:8443/questions/17814461/jacoco-maven-testng-0-test-coverage");
+        Uri uri2 = Uri.create("http://stackoverflow.com:8442/questions/1057564/pretty-git-branch-graphs");
+        assertFalse(HttpUtils.isSameBase(uri1, uri2), "Base URLs should be different, but true was returned from isSameBase");
+    }
+
+    @Test
+    public void testIsSameBaseUrlReturnsFalseWhenSchemeDifferent() {
+        Uri uri1 = Uri.create("http://stackoverflow.com:8443/questions/17814461/jacoco-maven-testng-0-test-coverage");
+        Uri uri2 = Uri.create("ws://stackoverflow.com:8443/questions/1057564/pretty-git-branch-graphs");
+        assertFalse(HttpUtils.isSameBase(uri1, uri2), "Base URLs should be different, but true was returned from isSameBase");
+    }
+
+    @Test
+    public void testIsSameBaseUrlReturnsFalseWhenHostDifferent() {
+        Uri uri1 = Uri.create("http://stackoverflow.com:8443/questions/17814461/jacoco-maven-testng-0-test-coverage");
+        Uri uri2 = Uri.create("http://example.com:8443/questions/1057564/pretty-git-branch-graphs");
+        assertFalse(HttpUtils.isSameBase(uri1, uri2), "Base URLs should be different, but true was returned from isSameBase");
+    }
+
+    @Test
+    public void testGetPathWhenPathIsNonEmpty() {
+        Uri uri = Uri.create("http://stackoverflow.com:8443/questions/17814461/jacoco-maven-testng-0-test-coverage");
+        String path = HttpUtils.getNonEmptyPath(uri);
+        assertEquals(path, "/questions/17814461/jacoco-maven-testng-0-test-coverage", "Incorrect path returned from getNonEmptyPath");
+    }
+
+    @Test
+    public void testGetPathWhenPathIsEmpty() {
+        Uri uri = Uri.create("http://stackoverflow.com");
+        String path = HttpUtils.getNonEmptyPath(uri);
+        assertEquals(path, "/", "Incorrect path returned from getNonEmptyPath");
+    }
+
+    @Test
+    public void testIsSameBaseUrlReturnsTrueWhenOneUriHasDefaultPort() {
+        Uri uri1 = Uri.create("http://stackoverflow.com:80/questions/17814461/jacoco-maven-testng-0-test-coverage");
+        Uri uri2 = Uri.create("http://stackoverflow.com/questions/1057564/pretty-git-branch-graphs");
+        assertTrue(HttpUtils.isSameBase(uri1, uri2), "Base URLs should be same, but false was returned from isSameBase");
+    }
+
+    @Test
+    public void testParseCharsetWithoutQuotes() {
+        Charset charset = HttpUtils.parseCharset("Content-type: application/json; charset=utf-8");
+        assertEquals(charset, StandardCharsets.UTF_8, "parseCharset returned wrong Charset");
+    }
+
+    @Test
+    public void testParseCharsetWithSingleQuotes() {
+        Charset charset = HttpUtils.parseCharset("Content-type: application/json; charset='utf-8'");
+        assertEquals(charset, StandardCharsets.UTF_8, "parseCharset returned wrong Charset");
+    }
+
+    @Test
+    public void testParseCharsetWithDoubleQuotes() {
+        Charset charset = HttpUtils.parseCharset("Content-type: application/json; charset=\"utf-8\"");
+        assertEquals(charset, StandardCharsets.UTF_8, "parseCharset returned wrong Charset");
+    }
+
+    @Test
+    public void testParseCharsetReturnsNullWhenNoCharset() {
+        Charset charset = HttpUtils.parseCharset("Content-type: application/json");
+        assertNull(charset, "parseCharset should return null when charset is not specified in header value");
+    }
+
+    @Test
+    public void testGetHostHeaderNoVirtualHost() {
+        Request request = Dsl.get("http://stackoverflow.com/questions/1057564/pretty-git-branch-graphs").build();
+        Uri uri = Uri.create("http://stackoverflow.com/questions/1057564/pretty-git-branch-graphs");
+        String hostHeader = HttpUtils.hostHeader(request, uri);
+        assertEquals(hostHeader, "stackoverflow.com", "Incorrect hostHeader returned");
+    }
+
+    @Test
+    public void testGetHostHeaderHasVirtualHost() {
+        Request request = Dsl.get("http://stackoverflow.com/questions/1057564").setVirtualHost("example.com").build();
+        Uri uri = Uri.create("http://stackoverflow.com/questions/1057564/pretty-git-branch-graphs");
+        String hostHeader = HttpUtils.hostHeader(request, uri);
+        assertEquals(hostHeader, "example.com", "Incorrect hostHeader returned");
+    }
+
+    @Test
+    public void testDefaultFollowRedirect() {
+        Request request = Dsl.get("http://stackoverflow.com/questions/1057564").setVirtualHost("example.com").build();
+        DefaultAsyncHttpClientConfig config = new DefaultAsyncHttpClientConfig.Builder().build();
+        boolean followRedirect = HttpUtils.followRedirect(config, request);
+        assertFalse(followRedirect, "Default value of redirect should be false");
+    }
+
+    @Test
+    public void testGetFollowRedirectInRequest() {
+        Request request = Dsl.get("http://stackoverflow.com/questions/1057564").setFollowRedirect(true).build();
+        DefaultAsyncHttpClientConfig config = new DefaultAsyncHttpClientConfig.Builder().build();
+        boolean followRedirect = HttpUtils.followRedirect(config, request);
+        assertTrue(followRedirect, "Follow redirect must be true as set in the request");
+    }
+
+    @Test
+    public void testGetFollowRedirectInConfig() {
+        Request request = Dsl.get("http://stackoverflow.com/questions/1057564").build();
+        DefaultAsyncHttpClientConfig config = new DefaultAsyncHttpClientConfig.Builder().setFollowRedirect(true).build();
+        boolean followRedirect = HttpUtils.followRedirect(config, request);
+        assertTrue(followRedirect, "Follow redirect should be equal to value specified in config when not specified in request");
+    }
+
+    @Test
+    public void testGetFollowRedirectPriorityGivenToRequest() {
+        Request request = Dsl.get("http://stackoverflow.com/questions/1057564").setFollowRedirect(false).build();
+        DefaultAsyncHttpClientConfig config = new DefaultAsyncHttpClientConfig.Builder().setFollowRedirect(true).build();
+        boolean followRedirect = HttpUtils.followRedirect(config, request);
+        assertFalse(followRedirect, "Follow redirect value set in request should be given priority");
+    }
+}
diff --git a/client/src/test/java/org/asynchttpclient/webdav/WebDavBasicTest.java b/client/src/test/java/org/asynchttpclient/webdav/WebDavBasicTest.java
index 3df819975..cd87c7126 100644
--- a/client/src/test/java/org/asynchttpclient/webdav/WebDavBasicTest.java
+++ b/client/src/test/java/org/asynchttpclient/webdav/WebDavBasicTest.java
@@ -50,9 +50,9 @@ public void setUpGlobal() throws Exception {
         embedded.setCatalinaHome(path);
 
         Engine engine = embedded.createEngine();
-        engine.setDefaultHost("127.0.0.1");
+        engine.setDefaultHost("localhost");
 
-        Host host = embedded.createHost("127.0.0.1", path);
+        Host host = embedded.createHost("localhost", path);
         engine.addChild(host);
 
         Context c = embedded.createContext("/", path);
@@ -68,7 +68,7 @@ public void setUpGlobal() throws Exception {
         c.addChild(w);
         host.addChild(c);
 
-        Connector connector = embedded.createConnector("127.0.0.1", port1, Http11NioProtocol.class.getName());
+        Connector connector = embedded.createConnector("localhost", port1, Http11NioProtocol.class.getName());
         connector.setContainer(host);
         embedded.addEngine(engine);
         embedded.addConnector(connector);
@@ -81,7 +81,7 @@ public void tearDownGlobal() throws InterruptedException, Exception {
     }
 
     protected String getTargetUrl() {
-        return String.format("http://127.0.0.1:%s/folder1", port1);
+        return String.format("http://localhost:%s/folder1", port1);
     }
 
     @AfterMethod(alwaysRun = true)
@@ -127,11 +127,11 @@ public void propFindWebDavTest() throws InterruptedException, IOException, Execu
             Response response = c.executeRequest(mkcolRequest).get();
             assertEquals(response.getStatusCode(), 201);
 
-            Request putRequest = put(String.format("http://127.0.0.1:%s/folder1/Test.txt", port1)).setBody("this is a test").build();
+            Request putRequest = put(String.format("http://localhost:%s/folder1/Test.txt", port1)).setBody("this is a test").build();
             response = c.executeRequest(putRequest).get();
             assertEquals(response.getStatusCode(), 201);
 
-            Request propFindRequest = new RequestBuilder("PROPFIND").setUrl(String.format("http://127.0.0.1:%s/folder1/Test.txt", port1)).build();
+            Request propFindRequest = new RequestBuilder("PROPFIND").setUrl(String.format("http://localhost:%s/folder1/Test.txt", port1)).build();
             response = c.executeRequest(propFindRequest).get();
 
             assertEquals(response.getStatusCode(), 207);
diff --git a/client/src/test/java/org/asynchttpclient/ws/AbstractBasicTest.java b/client/src/test/java/org/asynchttpclient/ws/AbstractBasicTest.java
index 2c74a0dfa..6f7709d0d 100644
--- a/client/src/test/java/org/asynchttpclient/ws/AbstractBasicTest.java
+++ b/client/src/test/java/org/asynchttpclient/ws/AbstractBasicTest.java
@@ -38,7 +38,7 @@ public void tearDownGlobal() throws Exception {
     }
 
     protected String getTargetUrl() {
-        return String.format("ws://127.0.0.1:%d/", port1);
+        return String.format("ws://localhost:%d/", port1);
     }
 
     public abstract WebSocketHandler getWebSocketHandler();
diff --git a/client/src/test/java/org/asynchttpclient/ws/ProxyTunnellingTest.java b/client/src/test/java/org/asynchttpclient/ws/ProxyTunnellingTest.java
index b6f2adad8..13a32318c 100644
--- a/client/src/test/java/org/asynchttpclient/ws/ProxyTunnellingTest.java
+++ b/client/src/test/java/org/asynchttpclient/ws/ProxyTunnellingTest.java
@@ -80,10 +80,10 @@ private void runTest(boolean secure) throws Exception {
 
         setUpServers(secure);
 
-        String targetUrl = String.format("%s://127.0.0.1:%d/", secure ? "wss" : "ws", port2);
+        String targetUrl = String.format("%s://localhost:%d/", secure ? "wss" : "ws", port2);
 
         // CONNECT happens over HTTP, not HTTPS
-        ProxyServer ps = proxyServer("127.0.0.1", port1).build();
+        ProxyServer ps = proxyServer("localhost", port1).build();
         try (AsyncHttpClient asyncHttpClient = asyncHttpClient(config().setProxyServer(ps).setAcceptAnyCertificate(true))) {
             final CountDownLatch latch = new CountDownLatch(1);
             final AtomicReference<String> text = new AtomicReference<>("");
diff --git a/client/src/test/java/org/asynchttpclient/ws/RedirectTest.java b/client/src/test/java/org/asynchttpclient/ws/RedirectTest.java
index 81f8e3359..addc2575d 100644
--- a/client/src/test/java/org/asynchttpclient/ws/RedirectTest.java
+++ b/client/src/test/java/org/asynchttpclient/ws/RedirectTest.java
@@ -104,6 +104,6 @@ public void onError(Throwable t) {
     }
 
     private String getRedirectURL() {
-        return String.format("ws://127.0.0.1:%d/", port2);
+        return String.format("ws://localhost:%d/", port2);
     }
 }
diff --git a/extras/guava/pom.xml b/extras/guava/pom.xml
index da1c721a8..864314ec4 100644
--- a/extras/guava/pom.xml
+++ b/extras/guava/pom.xml
@@ -2,7 +2,7 @@
     <parent>
         <groupId>org.asynchttpclient</groupId>
         <artifactId>async-http-client-extras-parent</artifactId>
-        <version>2.0.0-SNAPSHOT</version>
+        <version>2.0.0-RC9-SNAPSHOT</version>
     </parent>
     <modelVersion>4.0.0</modelVersion>
     <artifactId>async-http-client-extras-guava</artifactId>
diff --git a/extras/jdeferred/pom.xml b/extras/jdeferred/pom.xml
index 196cb4b59..f5a7eab24 100644
--- a/extras/jdeferred/pom.xml
+++ b/extras/jdeferred/pom.xml
@@ -18,7 +18,7 @@
   <parent>
     <artifactId>async-http-client-extras-parent</artifactId>
     <groupId>org.asynchttpclient</groupId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.0.0-RC9-SNAPSHOT</version>
   </parent>
   <artifactId>async-http-client-extras-jdeferred</artifactId>
   <name>Asynchronous Http Client JDeferred Extras</name>
diff --git a/extras/pom.xml b/extras/pom.xml
index 96c98b4a3..da78fa596 100644
--- a/extras/pom.xml
+++ b/extras/pom.xml
@@ -2,7 +2,7 @@
     <parent>
         <groupId>org.asynchttpclient</groupId>
         <artifactId>async-http-client-project</artifactId>
-        <version>2.0.0-SNAPSHOT</version>
+        <version>2.0.0-RC9-SNAPSHOT</version>
     </parent>
     <modelVersion>4.0.0</modelVersion>
     <artifactId>async-http-client-extras-parent</artifactId>
diff --git a/extras/registry/pom.xml b/extras/registry/pom.xml
index b7c94e460..59899814e 100644
--- a/extras/registry/pom.xml
+++ b/extras/registry/pom.xml
@@ -2,7 +2,7 @@
 	<parent>
 		<groupId>org.asynchttpclient</groupId>
 		<artifactId>async-http-client-extras-parent</artifactId>
-		<version>2.0.0-SNAPSHOT</version>
+		<version>2.0.0-RC9-SNAPSHOT</version>
 	</parent>
 	<modelVersion>4.0.0</modelVersion>
 	<artifactId>async-http-client-extras-registry</artifactId>
diff --git a/extras/rxjava/pom.xml b/extras/rxjava/pom.xml
index 5a71e766d..b8181cfac 100644
--- a/extras/rxjava/pom.xml
+++ b/extras/rxjava/pom.xml
@@ -3,7 +3,7 @@
     <parent>
         <artifactId>async-http-client-extras-parent</artifactId>
         <groupId>org.asynchttpclient</groupId>
-        <version>2.0.0-SNAPSHOT</version>
+        <version>2.0.0-RC9-SNAPSHOT</version>
     </parent>
     <artifactId>async-http-client-extras-rxjava</artifactId>
     <name>Asynchronous Http Client RxJava Extras</name>
diff --git a/extras/simple/pom.xml b/extras/simple/pom.xml
index 8aecdbd3c..ff872a556 100644
--- a/extras/simple/pom.xml
+++ b/extras/simple/pom.xml
@@ -3,7 +3,7 @@
     <parent>
         <artifactId>async-http-client-extras-parent</artifactId>
         <groupId>org.asynchttpclient</groupId>
-        <version>2.0.0-SNAPSHOT</version>
+        <version>2.0.0-RC9-SNAPSHOT</version>
     </parent>
     <artifactId>async-http-client-extras-simple</artifactId>
     <name>Asynchronous Http Simple Client</name>
diff --git a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClient.java b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClient.java
index 3ea07836b..fee51be4f 100644
--- a/extras/simple/src/main/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClient.java
+++ b/extras/simple/src/main/java/org/asynchttpclient/extras/simple/SimpleAsyncHttpClient.java
@@ -13,7 +13,7 @@
 package org.asynchttpclient.extras.simple;
 
 import static org.asynchttpclient.Dsl.*;
-import static org.asynchttpclient.util.MiscUtils.closeSilently;
+import static org.asynchttpclient.util.MiscUtils.*;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.ssl.SslContext;
 
@@ -660,7 +660,7 @@ public SimpleAsyncHttpClient build() {
             if (proxyHost != null) {
                 Realm realm = null;
                 if (proxyPrincipal != null) {
-                    AuthScheme proxyAuthScheme = this.proxyAuthScheme == null ? AuthScheme.BASIC : this.proxyAuthScheme;
+                    AuthScheme proxyAuthScheme = withDefault(this.proxyAuthScheme, AuthScheme.BASIC);
                     realm = realm(proxyAuthScheme, proxyPrincipal, proxyPassword).build();
                 }
 
diff --git a/extras/simple/src/test/java/org/asynchttpclient/extras/simple/HttpsProxyTest.java b/extras/simple/src/test/java/org/asynchttpclient/extras/simple/HttpsProxyTest.java
index 9adb88d1e..129f581ad 100644
--- a/extras/simple/src/test/java/org/asynchttpclient/extras/simple/HttpsProxyTest.java
+++ b/extras/simple/src/test/java/org/asynchttpclient/extras/simple/HttpsProxyTest.java
@@ -2,7 +2,6 @@
 
 import static org.asynchttpclient.test.TestUtils.*;
 import static org.testng.Assert.assertEquals;
-import io.netty.handler.codec.http.HttpHeaders;
 
 import java.io.IOException;
 import java.util.concurrent.ExecutionException;
@@ -52,7 +51,7 @@ public void tearDownGlobal() throws Exception {
     public void testSimpleAHCConfigProxy() throws IOException, InterruptedException, ExecutionException, TimeoutException {
 
         try (SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()//
-                .setProxyHost("127.0.0.1")//
+                .setProxyHost("localhost")//
                 .setProxyPort(port1)//
                 .setFollowRedirect(true)//
                 .setUrl(getTargetUrl2())//
@@ -62,7 +61,6 @@ public void testSimpleAHCConfigProxy() throws IOException, InterruptedException,
             Response r = client.get().get();
 
             assertEquals(r.getStatusCode(), 200);
-            assertEquals(r.getHeader("X-Connection"), HttpHeaders.Values.KEEP_ALIVE);
         }
     }
 }
diff --git a/make_credentials.py b/make_credentials.py
new file mode 100755
index 000000000..0036721f2
--- /dev/null
+++ b/make_credentials.py
@@ -0,0 +1,40 @@
+#!/usr/bin/env python
+import sys
+import os
+import os.path
+import xml.dom.minidom
+ 
+homedir = os.path.expanduser("~")
+ 
+m2 = xml.dom.minidom.parse(homedir + '/.m2/settings.xml')
+settings = m2.getElementsByTagName("settings")[0]
+ 
+serversNodes = settings.getElementsByTagName("servers")
+if not serversNodes:
+  serversNode = m2.createElement("servers")
+  settings.appendChild(serversNode)
+else:
+  serversNode = serversNodes[0]
+  
+sonatypeServerNode = m2.createElement("server")
+sonatypeServerId = m2.createElement("id")
+sonatypeServerUser = m2.createElement("username")
+sonatypeServerPass = m2.createElement("password")
+ 
+idNode = m2.createTextNode("sonatype-nexus-snapshots")
+userNode = m2.createTextNode(os.environ["SONATYPE_USERNAME"])
+passNode = m2.createTextNode(os.environ["SONATYPE_PASSWORD"])
+ 
+sonatypeServerId.appendChild(idNode)
+sonatypeServerUser.appendChild(userNode)
+sonatypeServerPass.appendChild(passNode)
+ 
+sonatypeServerNode.appendChild(sonatypeServerId)
+sonatypeServerNode.appendChild(sonatypeServerUser)
+sonatypeServerNode.appendChild(sonatypeServerPass)
+ 
+serversNode.appendChild(sonatypeServerNode)
+  
+m2Str = m2.toxml()
+with open(homedir + '/.m2/settings.xml', 'w') as f:
+  f.write(m2Str)
diff --git a/netty-bp/codec-dns/pom.xml b/netty-bp/codec-dns/pom.xml
new file mode 100644
index 000000000..3c5a3c50f
--- /dev/null
+++ b/netty-bp/codec-dns/pom.xml
@@ -0,0 +1,37 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  ~ Copyright 2014 The Netty Project
+  ~
+  ~ The Netty Project licenses this file to you under the Apache License,
+  ~ version 2.0 (the "License"); you may not use this file except in compliance
+  ~ with the License. You may obtain a copy of the License at:
+  ~
+  ~   http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+  ~ WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+  ~ License for the specific language governing permissions and limitations
+  ~ under the License.
+  -->
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+
+  <modelVersion>4.0.0</modelVersion>
+  <parent>
+    <groupId>org.asynchttpclient</groupId>
+    <artifactId>netty-bp</artifactId>
+    <version>2.0.0-RC9-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>netty-codec-dns</artifactId>
+
+  <name>Netty/Codec/DNS</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>io.netty</groupId>
+      <artifactId>netty-codec</artifactId>
+    </dependency>
+  </dependencies>
+</project>
+
diff --git a/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/AbstractDnsMessage.java b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/AbstractDnsMessage.java
new file mode 100644
index 000000000..697a33a80
--- /dev/null
+++ b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/AbstractDnsMessage.java
@@ -0,0 +1,457 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+import io.netty.util.AbstractReferenceCounted;
+import io.netty.util.ReferenceCountUtil;
+import io.netty.util.ReferenceCounted;
+import io.netty.util.ResourceLeak;
+import io.netty.util.ResourceLeakDetector;
+import io.netty.util.internal.StringUtil;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import static io.netty.util.internal.ObjectUtil.checkNotNull;
+
+/**
+ * A skeletal implementation of {@link DnsMessage}.
+ */
+public abstract class AbstractDnsMessage extends AbstractReferenceCounted implements DnsMessage {
+
+    private static final ResourceLeakDetector<DnsMessage> leakDetector =
+            new ResourceLeakDetector<DnsMessage>(DnsMessage.class);
+
+    private static final int SECTION_QUESTION = DnsSection.QUESTION.ordinal();
+    private static final int SECTION_COUNT = 4;
+
+    private final ResourceLeak leak = leakDetector.open(this);
+    private short id;
+    private DnsOpCode opCode;
+    private boolean recursionDesired;
+    private byte z;
+
+    // To reduce the memory footprint of a message,
+    // each of the following fields is a single record or a list of records.
+    private Object questions;
+    private Object answers;
+    private Object authorities;
+    private Object additionals;
+
+    /**
+     * Creates a new instance with the specified {@code id} and {@link DnsOpCode#QUERY} opCode.
+     */
+    protected AbstractDnsMessage(int id) {
+        this(id, DnsOpCode.QUERY);
+    }
+
+    /**
+     * Creates a new instance with the specified {@code id} and {@code opCode}.
+     */
+    protected AbstractDnsMessage(int id, DnsOpCode opCode) {
+        setId(id);
+        setOpCode(opCode);
+    }
+
+    @Override
+    public int id() {
+        return id & 0xFFFF;
+    }
+
+    @Override
+    public DnsMessage setId(int id) {
+        this.id = (short) id;
+        return this;
+    }
+
+    @Override
+    public DnsOpCode opCode() {
+        return opCode;
+    }
+
+    @Override
+    public DnsMessage setOpCode(DnsOpCode opCode) {
+        this.opCode = checkNotNull(opCode, "opCode");
+        return this;
+    }
+
+    @Override
+    public boolean isRecursionDesired() {
+        return recursionDesired;
+    }
+
+    @Override
+    public DnsMessage setRecursionDesired(boolean recursionDesired) {
+        this.recursionDesired = recursionDesired;
+        return this;
+    }
+
+    @Override
+    public int z() {
+        return z;
+    }
+
+    @Override
+    public DnsMessage setZ(int z) {
+        this.z = (byte) (z & 7);
+        return this;
+    }
+
+    @Override
+    public int count(DnsSection section) {
+        return count(sectionOrdinal(section));
+    }
+
+    private int count(int section) {
+        final Object records = sectionAt(section);
+        if (records == null) {
+            return 0;
+        }
+        if (records instanceof DnsRecord) {
+            return 1;
+        }
+
+        @SuppressWarnings("unchecked")
+        final List<DnsRecord> recordList = (List<DnsRecord>) records;
+        return recordList.size();
+    }
+
+    @Override
+    public int count() {
+        int count = 0;
+        for (int i = 0; i < SECTION_COUNT; i ++) {
+            count += count(i);
+        }
+        return count;
+    }
+
+    @Override
+    public <T extends DnsRecord> T recordAt(DnsSection section) {
+        return recordAt(sectionOrdinal(section));
+    }
+
+    private <T extends DnsRecord> T recordAt(int section) {
+        final Object records = sectionAt(section);
+        if (records == null) {
+            return null;
+        }
+
+        if (records instanceof DnsRecord) {
+            return castRecord(records);
+        }
+
+        @SuppressWarnings("unchecked")
+        final List<DnsRecord> recordList = (List<DnsRecord>) records;
+        if (recordList.isEmpty()) {
+            return null;
+        }
+
+        return castRecord(recordList.get(0));
+    }
+
+    @Override
+    public <T extends DnsRecord> T recordAt(DnsSection section, int index) {
+        return recordAt(sectionOrdinal(section), index);
+    }
+
+    private <T extends DnsRecord> T recordAt(int section, int index) {
+        final Object records = sectionAt(section);
+        if (records == null) {
+            throw new IndexOutOfBoundsException("index: " + index + " (expected: none)");
+        }
+
+        if (records instanceof DnsRecord) {
+            if (index == 0) {
+                return castRecord(records);
+            } else {
+                throw new IndexOutOfBoundsException("index: " + index + "' (expected: 0)");
+            }
+        }
+
+        @SuppressWarnings("unchecked")
+        final List<DnsRecord> recordList = (List<DnsRecord>) records;
+        return castRecord(recordList.get(index));
+    }
+
+    @Override
+    public DnsMessage setRecord(DnsSection section, DnsRecord record) {
+        setRecord(sectionOrdinal(section), record);
+        return this;
+    }
+
+    private void setRecord(int section, DnsRecord record) {
+        clear(section);
+        setSection(section, checkQuestion(section, record));
+    }
+
+    @Override
+    public <T extends DnsRecord> T setRecord(DnsSection section, int index, DnsRecord record) {
+        return setRecord(sectionOrdinal(section), index, record);
+    }
+
+    private <T extends DnsRecord> T setRecord(int section, int index, DnsRecord record) {
+        checkQuestion(section, record);
+
+        final Object records = sectionAt(section);
+        if (records == null) {
+            throw new IndexOutOfBoundsException("index: " + index + " (expected: none)");
+        }
+
+        if (records instanceof DnsRecord) {
+            if (index == 0) {
+                setSection(section, record);
+                return castRecord(records);
+            } else {
+                throw new IndexOutOfBoundsException("index: " + index + " (expected: 0)");
+            }
+        }
+
+        @SuppressWarnings("unchecked")
+        final List<DnsRecord> recordList = (List<DnsRecord>) records;
+        return castRecord(recordList.set(index, record));
+    }
+
+    @Override
+    public DnsMessage addRecord(DnsSection section, DnsRecord record) {
+        addRecord(sectionOrdinal(section), record);
+        return this;
+    }
+
+    private void addRecord(int section, DnsRecord record) {
+        checkQuestion(section, record);
+
+        final Object records = sectionAt(section);
+        if (records == null) {
+            setSection(section, record);
+            return;
+        }
+
+        if (records instanceof DnsRecord) {
+            final List<DnsRecord> recordList = newRecordList();
+            recordList.add(castRecord(records));
+            recordList.add(record);
+            setSection(section, recordList);
+            return;
+        }
+
+        @SuppressWarnings("unchecked")
+        final List<DnsRecord> recordList = (List<DnsRecord>) records;
+        recordList.add(record);
+    }
+
+    @Override
+    public DnsMessage addRecord(DnsSection section, int index, DnsRecord record) {
+        addRecord(sectionOrdinal(section), index, record);
+        return this;
+    }
+
+    private void addRecord(int section, int index, DnsRecord record) {
+        checkQuestion(section, record);
+
+        final Object records = sectionAt(section);
+        if (records == null) {
+            if (index != 0) {
+                throw new IndexOutOfBoundsException("index: " + index + " (expected: 0)");
+            }
+
+            setSection(section, record);
+            return;
+        }
+
+        if (records instanceof DnsRecord) {
+            final List<DnsRecord> recordList;
+            if (index == 0) {
+                recordList = newRecordList();
+                recordList.add(record);
+                recordList.add(castRecord(records));
+            } else if (index == 1) {
+                recordList = newRecordList();
+                recordList.add(castRecord(records));
+                recordList.add(record);
+            } else {
+                throw new IndexOutOfBoundsException("index: " + index + " (expected: 0 or 1)");
+            }
+            setSection(section, recordList);
+            return;
+        }
+
+        @SuppressWarnings("unchecked")
+        final List<DnsRecord> recordList = (List<DnsRecord>) records;
+        recordList.add(index, record);
+    }
+
+    @Override
+    public <T extends DnsRecord> T removeRecord(DnsSection section, int index) {
+        return removeRecord(sectionOrdinal(section), index);
+    }
+
+    private <T extends DnsRecord> T removeRecord(int section, int index) {
+        final Object records = sectionAt(section);
+        if (records == null) {
+            throw new IndexOutOfBoundsException("index: " + index + " (expected: none)");
+        }
+
+        if (records instanceof DnsRecord) {
+            if (index != 0) {
+                throw new IndexOutOfBoundsException("index: " + index + " (expected: 0)");
+            }
+
+            T record = castRecord(records);
+            setSection(section, null);
+            return record;
+        }
+
+        @SuppressWarnings("unchecked")
+        final List<DnsRecord> recordList = (List<DnsRecord>) records;
+        return castRecord(recordList.remove(index));
+    }
+
+    @Override
+    public DnsMessage clear(DnsSection section) {
+        clear(sectionOrdinal(section));
+        return this;
+    }
+
+    @Override
+    public DnsMessage clear() {
+        for (int i = 0; i < SECTION_COUNT; i ++) {
+            clear(i);
+        }
+        return this;
+    }
+
+    private void clear(int section) {
+        final Object recordOrList = sectionAt(section);
+        setSection(section, null);
+        if (recordOrList instanceof ReferenceCounted) {
+            ((ReferenceCounted) recordOrList).release();
+        } else if (recordOrList instanceof List) {
+            @SuppressWarnings("unchecked")
+            List<DnsRecord> list = (List<DnsRecord>) recordOrList;
+            if (!list.isEmpty()) {
+                for (Object r : list) {
+                    ReferenceCountUtil.release(r);
+                }
+            }
+        }
+    }
+
+    @Override
+    public DnsMessage retain() {
+        return (DnsMessage) super.retain();
+    }
+
+    @Override
+    public DnsMessage retain(int increment) {
+        return (DnsMessage) super.retain(increment);
+    }
+
+    @Override
+    protected void deallocate() {
+        clear();
+
+        final ResourceLeak leak = this.leak;
+        if (leak != null) {
+            leak.close();
+        }
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj) {
+            return true;
+        }
+
+        if (!(obj instanceof DnsMessage)) {
+            return false;
+        }
+
+        final DnsMessage that = (DnsMessage) obj;
+        if (id() != that.id()) {
+            return false;
+        }
+
+        if (this instanceof DnsQuery) {
+            if (!(that instanceof DnsQuery)) {
+                return false;
+            }
+        } else if (that instanceof DnsQuery) {
+            return false;
+        }
+
+        return true;
+    }
+
+    @Override
+    public int hashCode() {
+        return id() * 31 + (this instanceof DnsQuery? 0 : 1);
+    }
+
+    private Object sectionAt(int section) {
+        switch (section) {
+        case 0:
+            return questions;
+        case 1:
+            return answers;
+        case 2:
+            return authorities;
+        case 3:
+            return additionals;
+        }
+
+        throw new Error(); // Should never reach here.
+    }
+
+    private void setSection(int section, Object value) {
+        switch (section) {
+        case 0:
+            questions = value;
+            return;
+        case 1:
+            answers = value;
+            return;
+        case 2:
+            authorities = value;
+            return;
+        case 3:
+            additionals = value;
+            return;
+        }
+
+        throw new Error(); // Should never reach here.
+    }
+
+    private static int sectionOrdinal(DnsSection section) {
+        return checkNotNull(section, "section").ordinal();
+    }
+
+    private static DnsRecord checkQuestion(int section, DnsRecord record) {
+        if (section == SECTION_QUESTION && !(checkNotNull(record, "record") instanceof DnsQuestion)) {
+            throw new IllegalArgumentException(
+                    "record: " + record + " (expected: " + StringUtil.simpleClassName(DnsQuestion.class) + ')');
+        }
+        return record;
+    }
+
+    @SuppressWarnings("unchecked")
+    private static <T extends DnsRecord> T castRecord(Object record) {
+        return (T) record;
+    }
+
+    private static ArrayList<DnsRecord> newRecordList() {
+        return new ArrayList<DnsRecord>(2);
+    }
+}
diff --git a/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/AbstractDnsRecord.java b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/AbstractDnsRecord.java
new file mode 100644
index 000000000..6a62077bb
--- /dev/null
+++ b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/AbstractDnsRecord.java
@@ -0,0 +1,139 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+import io.netty.util.internal.StringUtil;
+
+import static io.netty.util.internal.ObjectUtil.checkNotNull;
+
+/**
+ * A skeletal implementation of {@link DnsRecord}.
+ */
+public abstract class AbstractDnsRecord implements DnsRecord {
+
+    private final String name;
+    private final DnsRecordType type;
+    private final short dnsClass;
+    private final long timeToLive;
+    private int hashCode;
+
+    /**
+     * Creates a new {@link #CLASS_IN IN-class} record.
+     *
+     * @param name the domain name
+     * @param type the type of the record
+     * @param timeToLive the TTL value of the record
+     */
+    protected AbstractDnsRecord(String name, DnsRecordType type, long timeToLive) {
+        this(name, type, CLASS_IN, timeToLive);
+    }
+
+    /**
+     * Creates a new record.
+     *
+     * @param name the domain name
+     * @param type the type of the record
+     * @param dnsClass the class of the record, usually one of the following:
+     *                 <ul>
+     *                     <li>{@link #CLASS_IN}</li>
+     *                     <li>{@link #CLASS_CSNET}</li>
+     *                     <li>{@link #CLASS_CHAOS}</li>
+     *                     <li>{@link #CLASS_HESIOD}</li>
+     *                     <li>{@link #CLASS_NONE}</li>
+     *                     <li>{@link #CLASS_ANY}</li>
+     *                 </ul>
+     * @param timeToLive the TTL value of the record
+     */
+    protected AbstractDnsRecord(String name, DnsRecordType type, int dnsClass, long timeToLive) {
+        if (timeToLive < 0) {
+            throw new IllegalArgumentException("timeToLive: " + timeToLive + " (expected: >= 0)");
+        }
+        this.name = checkNotNull(name, "name");
+        this.type = checkNotNull(type, "type");
+        this.dnsClass = (short) dnsClass;
+        this.timeToLive = timeToLive;
+    }
+
+    @Override
+    public String name() {
+        return name;
+    }
+
+    @Override
+    public DnsRecordType type() {
+        return type;
+    }
+
+    @Override
+    public int dnsClass() {
+        return dnsClass & 0xFFFF;
+    }
+
+    @Override
+    public long timeToLive() {
+        return timeToLive;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj) {
+            return true;
+        }
+
+        if (!(obj instanceof DnsRecord)) {
+            return false;
+        }
+
+        final DnsRecord that = (DnsRecord) obj;
+        final int hashCode = this.hashCode;
+        if (hashCode != 0 && hashCode != that.hashCode()) {
+            return false;
+        }
+
+        return type().intValue() == that.type().intValue() &&
+               dnsClass() == that.dnsClass() &&
+               name().equals(that.name());
+    }
+
+    @Override
+    public int hashCode() {
+        final int hashCode = this.hashCode;
+        if (hashCode != 0) {
+            return hashCode;
+        }
+
+        return this.hashCode = name.hashCode() * 31 + type().intValue() * 31 + dnsClass();
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder buf = new StringBuilder(64);
+
+        buf.append(StringUtil.simpleClassName(this))
+           .append('(')
+           .append(name())
+           .append(' ')
+           .append(timeToLive())
+           .append(' ');
+
+        DnsMessageUtil.appendRecordClass(buf, dnsClass())
+                      .append(' ')
+                      .append(type().name())
+                      .append(')');
+
+        return buf.toString();
+    }
+}
diff --git a/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsQuery.java b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsQuery.java
new file mode 100644
index 000000000..acd4810f6
--- /dev/null
+++ b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsQuery.java
@@ -0,0 +1,180 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+import io.netty.channel.AddressedEnvelope;
+
+import java.net.InetSocketAddress;
+import java.net.SocketAddress;
+
+/**
+ * A {@link DnsQuery} implementation for UDP/IP.
+ */
+public class DatagramDnsQuery extends DefaultDnsQuery
+        implements AddressedEnvelope<DatagramDnsQuery, InetSocketAddress> {
+
+    private final InetSocketAddress sender;
+    private final InetSocketAddress recipient;
+
+    /**
+     * Creates a new instance with the {@link DnsOpCode#QUERY} {@code opCode}.
+     *
+     * @param sender the address of the sender
+     * @param recipient the address of the recipient
+     * @param id the {@code ID} of the DNS query
+     */
+    public DatagramDnsQuery(
+            InetSocketAddress sender, InetSocketAddress recipient, int id) {
+        this(sender, recipient, id, DnsOpCode.QUERY);
+    }
+
+    /**
+     * Creates a new instance.
+     *
+     * @param sender the address of the sender
+     * @param recipient the address of the recipient
+     * @param id the {@code ID} of the DNS query
+     * @param opCode the {@code opCode} of the DNS query
+     */
+    public DatagramDnsQuery(
+            InetSocketAddress sender, InetSocketAddress recipient, int id, DnsOpCode opCode) {
+        super(id, opCode);
+
+        if (recipient == null && sender == null) {
+            throw new NullPointerException("recipient and sender");
+        }
+
+        this.sender = sender;
+        this.recipient = recipient;
+    }
+
+    @Override
+    public DatagramDnsQuery content() {
+        return this;
+    }
+
+    @Override
+    public InetSocketAddress sender() {
+        return sender;
+    }
+
+    @Override
+    public InetSocketAddress recipient() {
+        return recipient;
+    }
+
+    @Override
+    public DatagramDnsQuery setId(int id) {
+        return (DatagramDnsQuery) super.setId(id);
+    }
+
+    @Override
+    public DatagramDnsQuery setOpCode(DnsOpCode opCode) {
+        return (DatagramDnsQuery) super.setOpCode(opCode);
+    }
+
+    @Override
+    public DatagramDnsQuery setRecursionDesired(boolean recursionDesired) {
+        return (DatagramDnsQuery) super.setRecursionDesired(recursionDesired);
+    }
+
+    @Override
+    public DatagramDnsQuery setZ(int z) {
+        return (DatagramDnsQuery) super.setZ(z);
+    }
+
+    @Override
+    public DatagramDnsQuery setRecord(DnsSection section, DnsRecord record) {
+        return (DatagramDnsQuery) super.setRecord(section, record);
+    }
+
+    @Override
+    public DatagramDnsQuery addRecord(DnsSection section, DnsRecord record) {
+        return (DatagramDnsQuery) super.addRecord(section, record);
+    }
+
+    @Override
+    public DatagramDnsQuery addRecord(DnsSection section, int index, DnsRecord record) {
+        return (DatagramDnsQuery) super.addRecord(section, index, record);
+    }
+
+    @Override
+    public DatagramDnsQuery clear(DnsSection section) {
+        return (DatagramDnsQuery) super.clear(section);
+    }
+
+    @Override
+    public DatagramDnsQuery clear() {
+        return (DatagramDnsQuery) super.clear();
+    }
+
+    @Override
+    public DatagramDnsQuery retain() {
+        return (DatagramDnsQuery) super.retain();
+    }
+
+    @Override
+    public DatagramDnsQuery retain(int increment) {
+        return (DatagramDnsQuery) super.retain(increment);
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj) {
+            return true;
+        }
+
+        if (!super.equals(obj)) {
+            return false;
+        }
+
+        if (!(obj instanceof AddressedEnvelope)) {
+            return false;
+        }
+
+        @SuppressWarnings("unchecked")
+        final AddressedEnvelope<?, SocketAddress> that = (AddressedEnvelope<?, SocketAddress>) obj;
+        if (sender() == null) {
+            if (that.sender() != null) {
+                return false;
+            }
+        } else if (!sender().equals(that.sender())) {
+            return false;
+        }
+
+        if (recipient() == null) {
+            if (that.recipient() != null) {
+                return false;
+            }
+        } else if (!recipient().equals(that.recipient())) {
+            return false;
+        }
+
+        return true;
+    }
+
+    @Override
+    public int hashCode() {
+        int hashCode = super.hashCode();
+        if (sender() != null) {
+            hashCode = hashCode * 31 + sender().hashCode();
+        }
+        if (recipient() != null) {
+            hashCode = hashCode * 31 + recipient().hashCode();
+        }
+        return hashCode;
+    }
+}
diff --git a/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsQueryEncoder.java b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsQueryEncoder.java
new file mode 100644
index 000000000..62b607324
--- /dev/null
+++ b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsQueryEncoder.java
@@ -0,0 +1,120 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.AddressedEnvelope;
+import io.netty.channel.ChannelHandler;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.socket.DatagramPacket;
+import io.netty.handler.codec.MessageToMessageEncoder;
+
+import java.net.InetSocketAddress;
+import java.util.List;
+
+import static io.netty.util.internal.ObjectUtil.checkNotNull;
+
+/**
+ * Encodes a {@link DatagramDnsQuery} (or an {@link AddressedEnvelope} of {@link DnsQuery}} into a
+ * {@link DatagramPacket}.
+ */
+@ChannelHandler.Sharable
+public class DatagramDnsQueryEncoder extends MessageToMessageEncoder<AddressedEnvelope<DnsQuery, InetSocketAddress>> {
+
+    private final DnsRecordEncoder recordEncoder;
+
+    /**
+     * Creates a new encoder with {@linkplain DnsRecordEncoder#DEFAULT the default record encoder}.
+     */
+    public DatagramDnsQueryEncoder() {
+        this(DnsRecordEncoder.DEFAULT);
+    }
+
+    /**
+     * Creates a new encoder with the specified {@code recordEncoder}.
+     */
+    public DatagramDnsQueryEncoder(DnsRecordEncoder recordEncoder) {
+        this.recordEncoder = checkNotNull(recordEncoder, "recordEncoder");
+    }
+
+    @Override
+    protected void encode(
+            ChannelHandlerContext ctx,
+            AddressedEnvelope<DnsQuery, InetSocketAddress> in, List<Object> out) throws Exception {
+
+        final InetSocketAddress recipient = in.recipient();
+        final DnsQuery query = in.content();
+        final ByteBuf buf = allocateBuffer(ctx, in);
+
+        boolean success = false;
+        try {
+            encodeHeader(query, buf);
+            encodeQuestions(query, buf);
+            encodeRecords(query, DnsSection.ADDITIONAL, buf);
+            success = true;
+        } finally {
+            if (!success) {
+                buf.release();
+            }
+        }
+
+        out.add(new DatagramPacket(buf, recipient, null));
+    }
+
+    /**
+     * Allocate a {@link ByteBuf} which will be used for constructing a datagram packet.
+     * Sub-classes may override this method to return a {@link ByteBuf} with a perfect matching initial capacity.
+     */
+    protected ByteBuf allocateBuffer(
+            ChannelHandlerContext ctx,
+            @SuppressWarnings("unused") AddressedEnvelope<DnsQuery, InetSocketAddress> msg) throws Exception {
+        return ctx.alloc().ioBuffer(1024);
+    }
+
+    /**
+     * Encodes the header that is always 12 bytes long.
+     *
+     * @param query
+     *            the query header being encoded
+     * @param buf
+     *            the buffer the encoded data should be written to
+     */
+    private static void encodeHeader(DnsQuery query, ByteBuf buf) {
+        buf.writeShort(query.id());
+        int flags = 0;
+        flags |= (query.opCode().byteValue() & 0xFF) << 14;
+        flags |= query.isRecursionDesired()? 1 << 8 : 0;
+        buf.writeShort(flags);
+        buf.writeShort(query.count(DnsSection.QUESTION));
+        buf.writeShort(0); // answerCount
+        buf.writeShort(0); // authorityResourceCount
+        buf.writeShort(query.count(DnsSection.ADDITIONAL));
+    }
+
+    private void encodeQuestions(DnsQuery query, ByteBuf buf) throws Exception {
+        final int count = query.count(DnsSection.QUESTION);
+        for (int i = 0; i < count; i ++) {
+            recordEncoder.encodeQuestion((DnsQuestion) query.recordAt(DnsSection.QUESTION, i), buf);
+        }
+    }
+
+    private void encodeRecords(DnsQuery query, DnsSection section, ByteBuf buf) throws Exception {
+        final int count = query.count(section);
+        for (int i = 0; i < count; i ++) {
+            recordEncoder.encodeRecord(query.recordAt(section, i), buf);
+        }
+    }
+}
diff --git a/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsResponse.java b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsResponse.java
new file mode 100644
index 000000000..0c01970ed
--- /dev/null
+++ b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsResponse.java
@@ -0,0 +1,214 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+import io.netty.channel.AddressedEnvelope;
+
+import java.net.InetSocketAddress;
+import java.net.SocketAddress;
+
+/**
+ * A {@link DnsResponse} implementation for UDP/IP.
+ */
+public class DatagramDnsResponse extends DefaultDnsResponse
+        implements AddressedEnvelope<DatagramDnsResponse, InetSocketAddress> {
+
+    private final InetSocketAddress sender;
+    private final InetSocketAddress recipient;
+
+    /**
+     * Creates a new instance with the {@link DnsOpCode#QUERY} {@code opCode} and
+     * the {@link DnsResponseCode#NOERROR} {@code RCODE}.
+     *
+     * @param sender the address of the sender
+     * @param recipient the address of the recipient
+     * @param id the {@code ID} of the DNS response
+     */
+    public DatagramDnsResponse(InetSocketAddress sender, InetSocketAddress recipient, int id) {
+        this(sender, recipient, id, DnsOpCode.QUERY, DnsResponseCode.NOERROR);
+    }
+
+    /**
+     * Creates a new instance with the {@link DnsResponseCode#NOERROR} responseCode.
+     *
+     * @param sender the address of the sender
+     * @param recipient the address of the recipient
+     * @param id the {@code ID} of the DNS response
+     * @param opCode the {@code opCode} of the DNS response
+     */
+    public DatagramDnsResponse(InetSocketAddress sender, InetSocketAddress recipient, int id, DnsOpCode opCode) {
+        this(sender, recipient, id, opCode, DnsResponseCode.NOERROR);
+    }
+
+    /**
+     * Creates a new instance.
+     *
+     * @param sender the address of the sender
+     * @param recipient the address of the recipient
+     * @param id the {@code ID} of the DNS response
+     * @param opCode the {@code opCode} of the DNS response
+     * @param responseCode the {@code RCODE} of the DNS response
+     */
+    public DatagramDnsResponse(
+            InetSocketAddress sender, InetSocketAddress recipient,
+            int id, DnsOpCode opCode, DnsResponseCode responseCode) {
+        super(id, opCode, responseCode);
+
+        if (recipient == null && sender == null) {
+            throw new NullPointerException("recipient and sender");
+        }
+
+        this.sender = sender;
+        this.recipient = recipient;
+    }
+
+    @Override
+    public DatagramDnsResponse content() {
+        return this;
+    }
+
+    @Override
+    public InetSocketAddress sender() {
+        return sender;
+    }
+
+    @Override
+    public InetSocketAddress recipient() {
+        return recipient;
+    }
+
+    @Override
+    public DatagramDnsResponse setAuthoritativeAnswer(boolean authoritativeAnswer) {
+        return (DatagramDnsResponse) super.setAuthoritativeAnswer(authoritativeAnswer);
+    }
+
+    @Override
+    public DatagramDnsResponse setTruncated(boolean truncated) {
+        return (DatagramDnsResponse) super.setTruncated(truncated);
+    }
+
+    @Override
+    public DatagramDnsResponse setRecursionAvailable(boolean recursionAvailable) {
+        return (DatagramDnsResponse) super.setRecursionAvailable(recursionAvailable);
+    }
+
+    @Override
+    public DatagramDnsResponse setCode(DnsResponseCode code) {
+        return (DatagramDnsResponse) super.setCode(code);
+    }
+
+    @Override
+    public DatagramDnsResponse setId(int id) {
+        return (DatagramDnsResponse) super.setId(id);
+    }
+
+    @Override
+    public DatagramDnsResponse setOpCode(DnsOpCode opCode) {
+        return (DatagramDnsResponse) super.setOpCode(opCode);
+    }
+
+    @Override
+    public DatagramDnsResponse setRecursionDesired(boolean recursionDesired) {
+        return (DatagramDnsResponse) super.setRecursionDesired(recursionDesired);
+    }
+
+    @Override
+    public DatagramDnsResponse setZ(int z) {
+        return (DatagramDnsResponse) super.setZ(z);
+    }
+
+    @Override
+    public DatagramDnsResponse setRecord(DnsSection section, DnsRecord record) {
+        return (DatagramDnsResponse) super.setRecord(section, record);
+    }
+
+    @Override
+    public DatagramDnsResponse addRecord(DnsSection section, DnsRecord record) {
+        return (DatagramDnsResponse) super.addRecord(section, record);
+    }
+
+    @Override
+    public DatagramDnsResponse addRecord(DnsSection section, int index, DnsRecord record) {
+        return (DatagramDnsResponse) super.addRecord(section, index, record);
+    }
+
+    @Override
+    public DatagramDnsResponse clear(DnsSection section) {
+        return (DatagramDnsResponse) super.clear(section);
+    }
+
+    @Override
+    public DatagramDnsResponse clear() {
+        return (DatagramDnsResponse) super.clear();
+    }
+
+    @Override
+    public DatagramDnsResponse retain() {
+        return (DatagramDnsResponse) super.retain();
+    }
+
+    @Override
+    public DatagramDnsResponse retain(int increment) {
+        return (DatagramDnsResponse) super.retain(increment);
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj) {
+            return true;
+        }
+
+        if (!super.equals(obj)) {
+            return false;
+        }
+
+        if (!(obj instanceof AddressedEnvelope)) {
+            return false;
+        }
+
+        @SuppressWarnings("unchecked")
+        final AddressedEnvelope<?, SocketAddress> that = (AddressedEnvelope<?, SocketAddress>) obj;
+        if (sender() == null) {
+            if (that.sender() != null) {
+                return false;
+            }
+        } else if (!sender().equals(that.sender())) {
+            return false;
+        }
+
+        if (recipient() == null) {
+            if (that.recipient() != null) {
+                return false;
+            }
+        } else if (!recipient().equals(that.recipient())) {
+            return false;
+        }
+
+        return true;
+    }
+
+    @Override
+    public int hashCode() {
+        int hashCode = super.hashCode();
+        if (sender() != null) {
+            hashCode = hashCode * 31 + sender().hashCode();
+        }
+        if (recipient() != null) {
+            hashCode = hashCode * 31 + recipient().hashCode();
+        }
+        return hashCode;
+    }
+}
diff --git a/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsResponseDecoder.java b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsResponseDecoder.java
new file mode 100644
index 000000000..b4c1fd09e
--- /dev/null
+++ b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsResponseDecoder.java
@@ -0,0 +1,117 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandler;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.socket.DatagramPacket;
+import io.netty.handler.codec.CorruptedFrameException;
+import io.netty.handler.codec.MessageToMessageDecoder;
+
+import java.net.InetSocketAddress;
+import java.util.List;
+
+import static io.netty.util.internal.ObjectUtil.checkNotNull;
+
+/**
+ * Decodes a {@link DatagramPacket} into a {@link DatagramDnsResponse}.
+ */
+@ChannelHandler.Sharable
+public class DatagramDnsResponseDecoder extends MessageToMessageDecoder<DatagramPacket> {
+
+    private final DnsRecordDecoder recordDecoder;
+
+    /**
+     * Creates a new decoder with {@linkplain DnsRecordDecoder#DEFAULT the default record decoder}.
+     */
+    public DatagramDnsResponseDecoder() {
+        this(DnsRecordDecoder.DEFAULT);
+    }
+
+    /**
+     * Creates a new decoder with the specified {@code recordDecoder}.
+     */
+    public DatagramDnsResponseDecoder(DnsRecordDecoder recordDecoder) {
+        this.recordDecoder = checkNotNull(recordDecoder, "recordDecoder");
+    }
+
+    @Override
+    protected void decode(ChannelHandlerContext ctx, DatagramPacket packet, List<Object> out) throws Exception {
+        final InetSocketAddress sender = packet.sender();
+        final ByteBuf buf = packet.content();
+
+        final DnsResponse response = newResponse(sender, buf);
+        boolean success = false;
+        try {
+            final int questionCount = buf.readUnsignedShort();
+            final int answerCount = buf.readUnsignedShort();
+            final int authorityRecordCount = buf.readUnsignedShort();
+            final int additionalRecordCount = buf.readUnsignedShort();
+
+            decodeQuestions(response, buf, questionCount);
+            decodeRecords(response, DnsSection.ANSWER, buf, answerCount);
+            decodeRecords(response, DnsSection.AUTHORITY, buf, authorityRecordCount);
+            decodeRecords(response, DnsSection.ADDITIONAL, buf, additionalRecordCount);
+
+            out.add(response);
+            success = true;
+        } finally {
+            if (!success) {
+                response.release();
+            }
+        }
+    }
+
+    private static DnsResponse newResponse(InetSocketAddress sender, ByteBuf buf) {
+        final int id = buf.readUnsignedShort();
+
+        final int flags = buf.readUnsignedShort();
+        if (flags >> 15 == 0) {
+            throw new CorruptedFrameException("not a response");
+        }
+
+        final DnsResponse response = new DatagramDnsResponse(
+                sender, null,
+                id, DnsOpCode.valueOf((byte) (flags >> 11 & 0xf)), DnsResponseCode.valueOf((byte) (flags & 0xf)));
+
+        response.setRecursionDesired((flags >> 8 & 1) == 1);
+        response.setAuthoritativeAnswer((flags >> 10 & 1) == 1);
+        response.setTruncated((flags >> 9 & 1) == 1);
+        response.setRecursionAvailable((flags >> 7 & 1) == 1);
+        response.setZ(flags >> 4 & 0x7);
+        return response;
+    }
+
+    private void decodeQuestions(DnsResponse response, ByteBuf buf, int questionCount) throws Exception {
+        for (int i = questionCount; i > 0; i --) {
+            response.addRecord(DnsSection.QUESTION, recordDecoder.decodeQuestion(buf));
+        }
+    }
+
+    private void decodeRecords(
+            DnsResponse response, DnsSection section, ByteBuf buf, int count) throws Exception {
+        for (int i = count; i > 0; i --) {
+            final DnsRecord r = recordDecoder.decodeRecord(buf);
+            if (r == null) {
+                // Truncated response
+                break;
+            }
+
+            response.addRecord(section, r);
+        }
+    }
+}
diff --git a/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsQuery.java b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsQuery.java
new file mode 100644
index 000000000..93920ad8f
--- /dev/null
+++ b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsQuery.java
@@ -0,0 +1,101 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+/**
+ * The default {@link DnsQuery} implementation.
+ */
+public class DefaultDnsQuery extends AbstractDnsMessage implements DnsQuery {
+
+    /**
+     * Creates a new instance with the {@link DnsOpCode#QUERY} {@code opCode}.
+     *
+     * @param id the {@code ID} of the DNS query
+     */
+    public DefaultDnsQuery(int id) {
+        super(id);
+    }
+
+    /**
+     * Creates a new instance.
+     *
+     * @param id the {@code ID} of the DNS query
+     * @param opCode the {@code opCode} of the DNS query
+     */
+    public DefaultDnsQuery(int id, DnsOpCode opCode) {
+        super(id, opCode);
+    }
+
+    @Override
+    public DnsQuery setId(int id) {
+        return (DnsQuery) super.setId(id);
+    }
+
+    @Override
+    public DnsQuery setOpCode(DnsOpCode opCode) {
+        return (DnsQuery) super.setOpCode(opCode);
+    }
+
+    @Override
+    public DnsQuery setRecursionDesired(boolean recursionDesired) {
+        return (DnsQuery) super.setRecursionDesired(recursionDesired);
+    }
+
+    @Override
+    public DnsQuery setZ(int z) {
+        return (DnsQuery) super.setZ(z);
+    }
+
+    @Override
+    public DnsQuery setRecord(DnsSection section, DnsRecord record) {
+        return (DnsQuery) super.setRecord(section, record);
+    }
+
+    @Override
+    public DnsQuery addRecord(DnsSection section, DnsRecord record) {
+        return (DnsQuery) super.addRecord(section, record);
+    }
+
+    @Override
+    public DnsQuery addRecord(DnsSection section, int index, DnsRecord record) {
+        return (DnsQuery) super.addRecord(section, index, record);
+    }
+
+    @Override
+    public DnsQuery clear(DnsSection section) {
+        return (DnsQuery) super.clear(section);
+    }
+
+    @Override
+    public DnsQuery clear() {
+        return (DnsQuery) super.clear();
+    }
+
+    @Override
+    public DnsQuery retain() {
+        return (DnsQuery) super.retain();
+    }
+
+    @Override
+    public DnsQuery retain(int increment) {
+        return (DnsQuery) super.retain(increment);
+    }
+
+    @Override
+    public String toString() {
+        return DnsMessageUtil.appendQuery(new StringBuilder(128), this).toString();
+    }
+}
diff --git a/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsQuestion.java b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsQuestion.java
new file mode 100644
index 000000000..09ceb1e62
--- /dev/null
+++ b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsQuestion.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+import io.netty.util.internal.StringUtil;
+
+/**
+ * The default {@link DnsQuestion} implementation.
+ */
+public class DefaultDnsQuestion extends AbstractDnsRecord implements DnsQuestion {
+
+    /**
+     * Creates a new {@link #CLASS_IN IN-class} question.
+     *
+     * @param name the domain name of the DNS question
+     * @param type the type of the DNS question
+     */
+    public DefaultDnsQuestion(String name, DnsRecordType type) {
+        super(name, type, 0);
+    }
+
+    /**
+     * Creates a new question.
+     *
+     * @param name the domain name of the DNS question
+     * @param type the type of the DNS question
+     * @param dnsClass the class of the record, usually one of the following:
+     *                 <ul>
+     *                     <li>{@link #CLASS_IN}</li>
+     *                     <li>{@link #CLASS_CSNET}</li>
+     *                     <li>{@link #CLASS_CHAOS}</li>
+     *                     <li>{@link #CLASS_HESIOD}</li>
+     *                     <li>{@link #CLASS_NONE}</li>
+     *                     <li>{@link #CLASS_ANY}</li>
+     *                 </ul>
+     */
+    public DefaultDnsQuestion(String name, DnsRecordType type, int dnsClass) {
+        super(name, type, dnsClass, 0);
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder buf = new StringBuilder(64);
+
+        buf.append(StringUtil.simpleClassName(this))
+           .append('(')
+           .append(name())
+           .append(' ');
+
+        DnsMessageUtil.appendRecordClass(buf, dnsClass())
+                      .append(' ')
+                      .append(type().name())
+                      .append(')');
+
+        return buf.toString();
+    }
+}
diff --git a/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRawRecord.java b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRawRecord.java
new file mode 100644
index 000000000..f37b7ba88
--- /dev/null
+++ b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRawRecord.java
@@ -0,0 +1,131 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.util.internal.StringUtil;
+
+import static io.netty.util.internal.ObjectUtil.checkNotNull;
+
+/**
+ * The default {@code DnsRawRecord} implementation.
+ */
+public class DefaultDnsRawRecord extends AbstractDnsRecord implements DnsRawRecord {
+
+    private final ByteBuf content;
+
+    /**
+     * Creates a new {@link #CLASS_IN IN-class} record.
+     *
+     * @param name the domain name
+     * @param type the type of the record
+     * @param timeToLive the TTL value of the record
+     */
+    public DefaultDnsRawRecord(String name, DnsRecordType type, long timeToLive, ByteBuf content) {
+        this(name, type, DnsRecord.CLASS_IN, timeToLive, content);
+    }
+
+    /**
+     * Creates a new record.
+     *
+     * @param name the domain name
+     * @param type the type of the record
+     * @param dnsClass the class of the record, usually one of the following:
+     *                 <ul>
+     *                     <li>{@link #CLASS_IN}</li>
+     *                     <li>{@link #CLASS_CSNET}</li>
+     *                     <li>{@link #CLASS_CHAOS}</li>
+     *                     <li>{@link #CLASS_HESIOD}</li>
+     *                     <li>{@link #CLASS_NONE}</li>
+     *                     <li>{@link #CLASS_ANY}</li>
+     *                 </ul>
+     * @param timeToLive the TTL value of the record
+     */
+    public DefaultDnsRawRecord(
+            String name, DnsRecordType type, int dnsClass, long timeToLive, ByteBuf content) {
+        super(name, type, dnsClass, timeToLive);
+        this.content = checkNotNull(content, "content");
+    }
+
+    @Override
+    public ByteBuf content() {
+        return content;
+    }
+
+    @Override
+    public DnsRawRecord copy() {
+        return new DefaultDnsRawRecord(name(), type(), dnsClass(), timeToLive(), content().copy());
+    }
+
+    @Override
+    public DnsRawRecord duplicate() {
+        return new DefaultDnsRawRecord(name(), type(), dnsClass(), timeToLive(), content().duplicate());
+    }
+
+    @Override
+    public int refCnt() {
+        return content().refCnt();
+    }
+
+    @Override
+    public DnsRawRecord retain() {
+        content().retain();
+        return this;
+    }
+
+    @Override
+    public DnsRawRecord retain(int increment) {
+        content().retain(increment);
+        return this;
+    }
+
+    @Override
+    public boolean release() {
+        return content().release();
+    }
+
+    @Override
+    public boolean release(int decrement) {
+        return content().release(decrement);
+    }
+
+    @Override
+    public String toString() {
+        final StringBuilder buf = new StringBuilder(64).append(StringUtil.simpleClassName(this)).append('(');
+        final DnsRecordType type = type();
+        if (type != DnsRecordType.OPT) {
+            buf.append(name().isEmpty()? "<root>" : name())
+               .append(' ')
+               .append(timeToLive())
+               .append(' ');
+
+            DnsMessageUtil.appendRecordClass(buf, dnsClass())
+                          .append(' ')
+                          .append(type.name());
+        } else {
+            buf.append("OPT flags:")
+               .append(timeToLive())
+               .append(" udp:")
+               .append(dnsClass());
+        }
+
+        buf.append(' ')
+           .append(content().readableBytes())
+           .append("B)");
+
+        return buf.toString();
+    }
+}
diff --git a/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordDecoder.java b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordDecoder.java
new file mode 100644
index 000000000..6d6beea4e
--- /dev/null
+++ b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordDecoder.java
@@ -0,0 +1,139 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.handler.codec.CorruptedFrameException;
+import io.netty.util.CharsetUtil;
+import io.netty.util.internal.StringUtil;
+
+/**
+ * The default {@link DnsRecordDecoder} implementation.
+ *
+ * @see DefaultDnsRecordEncoder
+ */
+public class DefaultDnsRecordDecoder implements DnsRecordDecoder {
+
+    /**
+     * Creates a new instance.
+     */
+    protected DefaultDnsRecordDecoder() { }
+
+    @Override
+    public final DnsQuestion decodeQuestion(ByteBuf in) throws Exception {
+        String name = decodeName(in);
+        DnsRecordType type = DnsRecordType.valueOf(in.readUnsignedShort());
+        int qClass = in.readUnsignedShort();
+        return new DefaultDnsQuestion(name, type, qClass);
+    }
+
+    @Override
+    public final <T extends DnsRecord> T decodeRecord(ByteBuf in) throws Exception {
+        final int startOffset = in.readerIndex();
+        final String name = decodeName(in);
+
+        final int endOffset = in.writerIndex();
+        if (endOffset - startOffset < 10) {
+            // Not enough data
+            in.readerIndex(startOffset);
+            return null;
+        }
+
+        final DnsRecordType type = DnsRecordType.valueOf(in.readUnsignedShort());
+        final int aClass = in.readUnsignedShort();
+        final long ttl = in.readUnsignedInt();
+        final int length = in.readUnsignedShort();
+        final int offset = in.readerIndex();
+
+        if (endOffset - offset < length) {
+            // Not enough data
+            in.readerIndex(startOffset);
+            return null;
+        }
+
+        @SuppressWarnings("unchecked")
+        T record = (T) decodeRecord(name, type, aClass, ttl, in, offset, length);
+        in.readerIndex(offset + length);
+        return record;
+    }
+
+    /**
+     * Decodes a record from the information decoded so far by {@link #decodeRecord(ByteBuf)}.
+     *
+     * @param name the domain name of the record
+     * @param type the type of the record
+     * @param dnsClass the class of the record
+     * @param timeToLive the TTL of the record
+     * @param in the {@link ByteBuf} that contains the RDATA
+     * @param offset the start offset of the RDATA in {@code in}
+     * @param length the length of the RDATA
+     *
+     * @return a {@link DnsRawRecord}. Override this method to decode RDATA and return other record implementation.
+     */
+    protected DnsRecord decodeRecord(
+            String name, DnsRecordType type, int dnsClass, long timeToLive,
+            ByteBuf in, int offset, int length) throws Exception {
+
+        return new DefaultDnsRawRecord(
+                name, type, dnsClass, timeToLive, in.duplicate().setIndex(offset, offset + length).retain());
+    }
+
+    /**
+     * Retrieves a domain name given a buffer containing a DNS packet. If the
+     * name contains a pointer, the position of the buffer will be set to
+     * directly after the pointer's index after the name has been read.
+     *
+     * @param in the byte buffer containing the DNS packet
+     * @return the domain name for an entry
+     */
+    protected String decodeName(ByteBuf in) {
+        int position = -1;
+        int checked = 0;
+        final int end = in.writerIndex();
+        final StringBuilder name = new StringBuilder(in.readableBytes() << 1);
+        for (int len = in.readUnsignedByte(); in.isReadable() && len != 0; len = in.readUnsignedByte()) {
+            boolean pointer = (len & 0xc0) == 0xc0;
+            if (pointer) {
+                if (position == -1) {
+                    position = in.readerIndex() + 1;
+                }
+
+                final int next = (len & 0x3f) << 8 | in.readUnsignedByte();
+                if (next >= end) {
+                    throw new CorruptedFrameException("name has an out-of-range pointer");
+                }
+                in.readerIndex(next);
+
+                // check for loops
+                checked += 2;
+                if (checked >= end) {
+                    throw new CorruptedFrameException("name contains a loop.");
+                }
+            } else {
+                name.append(in.toString(in.readerIndex(), len, CharsetUtil.UTF_8)).append('.');
+                in.skipBytes(len);
+            }
+        }
+        if (position != -1) {
+            in.readerIndex(position);
+        }
+        if (name.length() == 0) {
+            return StringUtil.EMPTY_STRING;
+        }
+
+        return name.substring(0, name.length() - 1);
+    }
+}
diff --git a/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordEncoder.java b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordEncoder.java
new file mode 100644
index 000000000..055ac2f34
--- /dev/null
+++ b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordEncoder.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufUtil;
+import io.netty.handler.codec.UnsupportedMessageTypeException;
+import io.netty.util.internal.StringUtil;
+
+/**
+ * The default {@link DnsRecordEncoder} implementation.
+ *
+ * @see DefaultDnsRecordDecoder
+ */
+public class DefaultDnsRecordEncoder implements DnsRecordEncoder {
+
+    /**
+     * Creates a new instance.
+     */
+    protected DefaultDnsRecordEncoder() { }
+
+    @Override
+    public final void encodeQuestion(DnsQuestion question, ByteBuf out) throws Exception {
+        encodeName(question.name(), out);
+        out.writeShort(question.type().intValue());
+        out.writeShort(question.dnsClass());
+    }
+
+    @Override
+    public void encodeRecord(DnsRecord record, ByteBuf out) throws Exception {
+        if (record instanceof DnsQuestion) {
+            encodeQuestion((DnsQuestion) record, out);
+        } else if (record instanceof DnsRawRecord) {
+            encodeRawRecord((DnsRawRecord) record, out);
+        } else {
+            throw new UnsupportedMessageTypeException(StringUtil.simpleClassName(record));
+        }
+    }
+
+    private void encodeRawRecord(DnsRawRecord record, ByteBuf out) throws Exception {
+        encodeName(record.name(), out);
+
+        out.writeShort(record.type().intValue());
+        out.writeShort(record.dnsClass());
+        out.writeInt((int) record.timeToLive());
+
+        ByteBuf content = record.content();
+        int contentLen = content.readableBytes();
+
+        out.writeShort(contentLen);
+        out.writeBytes(content, content.readerIndex(), contentLen);
+    }
+
+    protected void encodeName(String name, ByteBuf buf) throws Exception {
+        String[] parts = StringUtil.split(name, '.');
+        for (String part: parts) {
+            final int partLen = part.length();
+            if (partLen == 0) {
+                continue;
+            }
+            buf.writeByte(partLen);
+            ByteBufUtil.writeAscii(buf, part);
+        }
+        buf.writeByte(0); // marks end of name field
+    }
+}
diff --git a/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsResponse.java b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsResponse.java
new file mode 100644
index 000000000..5832aa755
--- /dev/null
+++ b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsResponse.java
@@ -0,0 +1,165 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+import static io.netty.util.internal.ObjectUtil.checkNotNull;
+
+/**
+ * The default {@link DnsResponse} implementation.
+ */
+public class DefaultDnsResponse extends AbstractDnsMessage implements DnsResponse {
+
+    private boolean authoritativeAnswer;
+    private boolean truncated;
+    private boolean recursionAvailable;
+    private DnsResponseCode code;
+
+    /**
+     * Creates a new instance with the {@link DnsOpCode#QUERY} {@code opCode} and
+     * the {@link DnsResponseCode#NOERROR} {@code RCODE}.
+     *
+     * @param id the {@code ID} of the DNS response
+     */
+    public DefaultDnsResponse(int id) {
+        this(id, DnsOpCode.QUERY, DnsResponseCode.NOERROR);
+    }
+
+    /**
+     * Creates a new instance with the {@link DnsResponseCode#NOERROR} {@code RCODE}.
+     *
+     * @param id the {@code ID} of the DNS response
+     * @param opCode the {@code opCode} of the DNS response
+     */
+    public DefaultDnsResponse(int id, DnsOpCode opCode) {
+        this(id, opCode, DnsResponseCode.NOERROR);
+    }
+
+    /**
+     * Creates a new instance.
+     *
+     * @param id the {@code ID} of the DNS response
+     * @param opCode the {@code opCode} of the DNS response
+     * @param code the {@code RCODE} of the DNS response
+     */
+    public DefaultDnsResponse(int id, DnsOpCode opCode, DnsResponseCode code) {
+        super(id, opCode);
+        setCode(code);
+    }
+
+    @Override
+    public boolean isAuthoritativeAnswer() {
+        return authoritativeAnswer;
+    }
+
+    @Override
+    public DnsResponse setAuthoritativeAnswer(boolean authoritativeAnswer) {
+        this.authoritativeAnswer = authoritativeAnswer;
+        return this;
+    }
+
+    @Override
+    public boolean isTruncated() {
+        return truncated;
+    }
+
+    @Override
+    public DnsResponse setTruncated(boolean truncated) {
+        this.truncated = truncated;
+        return this;
+    }
+
+    @Override
+    public boolean isRecursionAvailable() {
+        return recursionAvailable;
+    }
+
+    @Override
+    public DnsResponse setRecursionAvailable(boolean recursionAvailable) {
+        this.recursionAvailable = recursionAvailable;
+        return this;
+    }
+
+    @Override
+    public DnsResponseCode code() {
+        return code;
+    }
+
+    @Override
+    public DnsResponse setCode(DnsResponseCode code) {
+        this.code = checkNotNull(code, "code");
+        return this;
+    }
+
+    @Override
+    public DnsResponse setId(int id) {
+        return (DnsResponse) super.setId(id);
+    }
+
+    @Override
+    public DnsResponse setOpCode(DnsOpCode opCode) {
+        return (DnsResponse) super.setOpCode(opCode);
+    }
+
+    @Override
+    public DnsResponse setRecursionDesired(boolean recursionDesired) {
+        return (DnsResponse) super.setRecursionDesired(recursionDesired);
+    }
+
+    @Override
+    public DnsResponse setZ(int z) {
+        return (DnsResponse) super.setZ(z);
+    }
+
+    @Override
+    public DnsResponse setRecord(DnsSection section, DnsRecord record) {
+        return (DnsResponse) super.setRecord(section, record);
+    }
+
+    @Override
+    public DnsResponse addRecord(DnsSection section, DnsRecord record) {
+        return (DnsResponse) super.addRecord(section, record);
+    }
+
+    @Override
+    public DnsResponse addRecord(DnsSection section, int index, DnsRecord record) {
+        return (DnsResponse) super.addRecord(section, index, record);
+    }
+
+    @Override
+    public DnsResponse clear(DnsSection section) {
+        return (DnsResponse) super.clear(section);
+    }
+
+    @Override
+    public DnsResponse clear() {
+        return (DnsResponse) super.clear();
+    }
+
+    @Override
+    public DnsResponse retain() {
+        return (DnsResponse) super.retain();
+    }
+
+    @Override
+    public DnsResponse retain(int increment) {
+        return (DnsResponse) super.retain(increment);
+    }
+
+    @Override
+    public String toString() {
+        return DnsMessageUtil.appendResponse(new StringBuilder(128), this).toString();
+    }
+}
diff --git a/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsMessage.java b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsMessage.java
new file mode 100644
index 000000000..268e56a2b
--- /dev/null
+++ b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsMessage.java
@@ -0,0 +1,150 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+import io.netty.util.ReferenceCounted;
+
+/**
+ * The superclass which contains core information concerning a {@link DnsQuery} and a {@link DnsResponse}.
+ */
+public interface DnsMessage extends ReferenceCounted {
+
+    /**
+     * Returns the {@code ID} of this DNS message.
+     */
+    int id();
+
+    /**
+     * Sets the {@code ID} of this DNS message.
+     */
+    DnsMessage setId(int id);
+
+    /**
+     * Returns the {@code opCode} of this DNS message.
+     */
+    DnsOpCode opCode();
+
+    /**
+     * Sets the {@code opCode} of this DNS message.
+     */
+    DnsMessage setOpCode(DnsOpCode opCode);
+
+    /**
+     * Returns the {@code RD} (recursion desired} field of this DNS message.
+     */
+    boolean isRecursionDesired();
+
+    /**
+     * Sets the {@code RD} (recursion desired} field of this DNS message.
+     */
+    DnsMessage setRecursionDesired(boolean recursionDesired);
+
+    /**
+     * Returns the {@code Z} (reserved for future use) field of this DNS message.
+     */
+    int z();
+
+    /**
+     * Sets the {@code Z} (reserved for future use) field of this DNS message.
+     */
+    DnsMessage setZ(int z);
+
+    /**
+     * Returns the number of records in the specified {@code section} of this DNS message.
+     */
+    int count(DnsSection section);
+
+    /**
+     * Returns the number of records in this DNS message.
+     */
+    int count();
+
+    /**
+     * Returns the first record in the specified {@code section} of this DNS message.
+     * When the specified {@code section} is {@link DnsSection#QUESTION}, the type of the returned record is
+     * always {@link DnsQuestion}.
+     *
+     * @return {@code null} if this message doesn't have any records in the specified {@code section}
+     */
+    <T extends DnsRecord> T recordAt(DnsSection section);
+
+    /**
+     * Returns the record at the specified {@code index} of the specified {@code section} of this DNS message.
+     * When the specified {@code section} is {@link DnsSection#QUESTION}, the type of the returned record is
+     * always {@link DnsQuestion}.
+     *
+     * @throws IndexOutOfBoundsException if the specified {@code index} is out of bounds
+     */
+    <T extends DnsRecord> T recordAt(DnsSection section, int index);
+
+    /**
+     * Sets the specified {@code section} of this DNS message to the specified {@code record},
+     * making it a single-record section. When the specified {@code section} is {@link DnsSection#QUESTION},
+     * the specified {@code record} must be a {@link DnsQuestion}.
+     */
+    DnsMessage setRecord(DnsSection section, DnsRecord record);
+
+    /**
+     * Sets the specified {@code record} at the specified {@code index} of the specified {@code section}
+     * of this DNS message. When the specified {@code section} is {@link DnsSection#QUESTION},
+     * the specified {@code record} must be a {@link DnsQuestion}.
+     *
+     * @return the old record
+     * @throws IndexOutOfBoundsException if the specified {@code index} is out of bounds
+     */
+    <T extends DnsRecord> T setRecord(DnsSection section, int index, DnsRecord record);
+
+    /**
+     * Adds the specified {@code record} at the end of the specified {@code section} of this DNS message.
+     * When the specified {@code section} is {@link DnsSection#QUESTION}, the specified {@code record}
+     * must be a {@link DnsQuestion}.
+     */
+    DnsMessage addRecord(DnsSection section, DnsRecord record);
+
+    /**
+     * Adds the specified {@code record} at the specified {@code index} of the specified {@code section}
+     * of this DNS message. When the specified {@code section} is {@link DnsSection#QUESTION}, the specified
+     * {@code record} must be a {@link DnsQuestion}.
+     *
+     * @throws IndexOutOfBoundsException if the specified {@code index} is out of bounds
+     */
+    DnsMessage addRecord(DnsSection section, int index, DnsRecord record);
+
+    /**
+     * Removes the record at the specified {@code index} of the specified {@code section} from this DNS message.
+     * When the specified {@code section} is {@link DnsSection#QUESTION}, the type of the returned record is
+     * always {@link DnsQuestion}.
+     *
+     * @return the removed record
+     */
+    <T extends DnsRecord> T removeRecord(DnsSection section, int index);
+
+    /**
+     * Removes all the records in the specified {@code section} of this DNS message.
+     */
+    DnsMessage clear(DnsSection section);
+
+    /**
+     * Removes all the records in this DNS message.
+     */
+    DnsMessage clear();
+
+    @Override
+    DnsMessage retain();
+
+    @Override
+    DnsMessage retain(int increment);
+}
diff --git a/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsMessageUtil.java b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsMessageUtil.java
new file mode 100644
index 000000000..b5db80a1b
--- /dev/null
+++ b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsMessageUtil.java
@@ -0,0 +1,181 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+import io.netty.channel.AddressedEnvelope;
+import io.netty.util.internal.StringUtil;
+
+import java.net.SocketAddress;
+
+/**
+ * Provides some utility methods for DNS message implementations.
+ */
+final class DnsMessageUtil {
+
+    static StringBuilder appendQuery(StringBuilder buf, DnsQuery query) {
+        appendQueryHeader(buf, query);
+        appendAllRecords(buf, query);
+        return buf;
+    }
+
+    static StringBuilder appendResponse(StringBuilder buf, DnsResponse response) {
+        appendResponseHeader(buf, response);
+        appendAllRecords(buf, response);
+        return buf;
+    }
+
+    static StringBuilder appendRecordClass(StringBuilder buf, int dnsClass) {
+        final String name;
+        switch (dnsClass &= 0xFFFF) {
+        case DnsRecord.CLASS_IN:
+            name = "IN";
+            break;
+        case DnsRecord.CLASS_CSNET:
+            name = "CSNET";
+            break;
+        case DnsRecord.CLASS_CHAOS:
+            name = "CHAOS";
+            break;
+        case DnsRecord.CLASS_HESIOD:
+            name = "HESIOD";
+            break;
+        case DnsRecord.CLASS_NONE:
+            name = "NONE";
+            break;
+        case DnsRecord.CLASS_ANY:
+            name = "ANY";
+            break;
+        default:
+            name = null;
+            break;
+        }
+
+        if (name != null) {
+            buf.append(name);
+        } else {
+            buf.append("UNKNOWN(").append(dnsClass).append(')');
+        }
+
+        return buf;
+    }
+
+    private static void appendQueryHeader(StringBuilder buf, DnsQuery msg) {
+        buf.append(StringUtil.simpleClassName(msg))
+           .append('(');
+
+        appendAddresses(buf, msg)
+           .append(msg.id())
+           .append(", ")
+           .append(msg.opCode());
+
+        if (msg.isRecursionDesired()) {
+            buf.append(", RD");
+        }
+        if (msg.z() != 0) {
+            buf.append(", Z: ")
+               .append(msg.z());
+        }
+        buf.append(')');
+    }
+
+    private static void appendResponseHeader(StringBuilder buf, DnsResponse msg) {
+        buf.append(StringUtil.simpleClassName(msg))
+           .append('(');
+
+        appendAddresses(buf, msg)
+           .append(msg.id())
+           .append(", ")
+           .append(msg.opCode())
+           .append(", ")
+           .append(msg.code())
+           .append(',');
+
+        boolean hasComma = true;
+        if (msg.isRecursionDesired()) {
+            hasComma = false;
+            buf.append(" RD");
+        }
+        if (msg.isAuthoritativeAnswer()) {
+            hasComma = false;
+            buf.append(" AA");
+        }
+        if (msg.isTruncated()) {
+            hasComma = false;
+            buf.append(" TC");
+        }
+        if (msg.isRecursionAvailable()) {
+            hasComma = false;
+            buf.append(" RA");
+        }
+        if (msg.z() != 0) {
+            if (!hasComma) {
+                buf.append(',');
+            }
+            buf.append(" Z: ")
+               .append(msg.z());
+        }
+
+        if (hasComma) {
+            buf.setCharAt(buf.length() - 1, ')');
+        } else {
+            buf.append(')');
+        }
+    }
+
+    private static StringBuilder appendAddresses(StringBuilder buf, DnsMessage msg) {
+
+        if (!(msg instanceof AddressedEnvelope)) {
+            return buf;
+        }
+
+        @SuppressWarnings("unchecked")
+        AddressedEnvelope<?, SocketAddress> envelope = (AddressedEnvelope<?, SocketAddress>) msg;
+
+        SocketAddress addr = envelope.sender();
+        if (addr != null) {
+            buf.append("from: ")
+               .append(addr)
+               .append(", ");
+        }
+
+        addr = envelope.recipient();
+        if (addr != null) {
+            buf.append("to: ")
+               .append(addr)
+               .append(", ");
+        }
+
+        return buf;
+    }
+
+    private static void appendAllRecords(StringBuilder buf, DnsMessage msg) {
+        appendRecords(buf, msg, DnsSection.QUESTION);
+        appendRecords(buf, msg, DnsSection.ANSWER);
+        appendRecords(buf, msg, DnsSection.AUTHORITY);
+        appendRecords(buf, msg, DnsSection.ADDITIONAL);
+    }
+
+    private static void appendRecords(StringBuilder buf, DnsMessage message, DnsSection section) {
+        final int count = message.count(section);
+        for (int i = 0; i < count; i ++) {
+            buf.append(StringUtil.NEWLINE)
+               .append('\t')
+               .append(message.recordAt(section, i).toString());
+        }
+    }
+
+    private DnsMessageUtil() { }
+}
diff --git a/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsOpCode.java b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsOpCode.java
new file mode 100644
index 000000000..4140b2e3f
--- /dev/null
+++ b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsOpCode.java
@@ -0,0 +1,118 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+import static io.netty.util.internal.ObjectUtil.checkNotNull;
+
+/**
+ * The DNS {@code OpCode} as defined in <a href="https://tools.ietf.org/html/rfc2929">RFC2929</a>.
+ */
+public class DnsOpCode implements Comparable<DnsOpCode> {
+
+    /**
+     * The 'Query' DNS OpCode, as defined in <a href="https://tools.ietf.org/html/rfc1035">RFC1035</a>.
+     */
+    public static final DnsOpCode QUERY = new DnsOpCode(0x00, "QUERY");
+
+    /**
+     * The 'IQuery' DNS OpCode, as defined in <a href="https://tools.ietf.org/html/rfc1035">RFC1035</a>.
+     */
+    public static final DnsOpCode IQUERY = new DnsOpCode(0x01, "IQUERY");
+
+    /**
+     * The 'Status' DNS OpCode, as defined in <a href="https://tools.ietf.org/html/rfc1035">RFC1035</a>.
+     */
+    public static final DnsOpCode STATUS = new DnsOpCode(0x02, "STATUS");
+
+    /**
+     * The 'Notify' DNS OpCode, as defined in <a href="https://tools.ietf.org/html/rfc1996">RFC1996</a>.
+     */
+    public static final DnsOpCode NOTIFY = new DnsOpCode(0x04, "NOTIFY");
+
+    /**
+     * The 'Update' DNS OpCode, as defined in <a href="https://tools.ietf.org/html/rfc2136">RFC2136</a>.
+     */
+    public static final DnsOpCode UPDATE = new DnsOpCode(0x05, "UPDATE");
+
+    /**
+     * Returns the {@link DnsOpCode} instance of the specified byte value.
+     */
+    public static DnsOpCode valueOf(int b) {
+        switch (b) {
+        case 0x00:
+            return QUERY;
+        case 0x01:
+            return IQUERY;
+        case 0x02:
+            return STATUS;
+        case 0x04:
+            return NOTIFY;
+        case 0x05:
+            return UPDATE;
+        }
+
+        return new DnsOpCode(b);
+    }
+
+    private final byte byteValue;
+    private final String name;
+    private String text;
+
+    private DnsOpCode(int byteValue) {
+        this(byteValue, "UNKNOWN");
+    }
+
+    public DnsOpCode(int byteValue, String name) {
+        this.byteValue = (byte) byteValue;
+        this.name = checkNotNull(name, "name");
+    }
+
+    public byte byteValue() {
+        return byteValue;
+    }
+
+    @Override
+    public int hashCode() {
+        return byteValue;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj) {
+            return true;
+        }
+
+        if (!(obj instanceof DnsOpCode)) {
+            return false;
+        }
+
+        return byteValue == ((DnsOpCode) obj).byteValue;
+    }
+
+    @Override
+    public int compareTo(DnsOpCode o) {
+        return byteValue - o.byteValue;
+    }
+
+    @Override
+    public String toString() {
+        String text = this.text;
+        if (text == null) {
+            this.text = text = name + '(' + (byteValue & 0xFF) + ')';
+        }
+        return text;
+    }
+}
diff --git a/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsQuery.java b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsQuery.java
new file mode 100644
index 000000000..28de3d2a8
--- /dev/null
+++ b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsQuery.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+/**
+ * A DNS query message.
+ */
+public interface DnsQuery extends DnsMessage {
+    @Override
+    DnsQuery setId(int id);
+
+    @Override
+    DnsQuery setOpCode(DnsOpCode opCode);
+
+    @Override
+    DnsQuery setRecursionDesired(boolean recursionDesired);
+
+    @Override
+    DnsQuery setZ(int z);
+
+    @Override
+    DnsQuery setRecord(DnsSection section, DnsRecord record);
+
+    @Override
+    DnsQuery addRecord(DnsSection section, DnsRecord record);
+
+    @Override
+    DnsQuery addRecord(DnsSection section, int index, DnsRecord record);
+
+    @Override
+    DnsQuery clear(DnsSection section);
+
+    @Override
+    DnsQuery clear();
+
+    @Override
+    DnsQuery retain();
+
+    @Override
+    DnsQuery retain(int increment);
+}
diff --git a/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsQuestion.java b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsQuestion.java
new file mode 100644
index 000000000..082ca3a11
--- /dev/null
+++ b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsQuestion.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+/**
+ * A DNS question.
+ */
+public interface DnsQuestion extends DnsRecord {
+    /**
+     * An unused property. This method will always return {@code 0}.
+     */
+    @Override
+    long timeToLive();
+}
diff --git a/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsRawRecord.java b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsRawRecord.java
new file mode 100644
index 000000000..eb96dee27
--- /dev/null
+++ b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsRawRecord.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+import io.netty.buffer.ByteBufHolder;
+
+/**
+ * A generic {@link DnsRecord} that contains an undecoded {@code RDATA}.
+ */
+public interface DnsRawRecord extends DnsRecord, ByteBufHolder {
+    @Override
+    DnsRawRecord copy();
+
+    @Override
+    DnsRawRecord duplicate();
+
+    @Override
+    DnsRawRecord retain();
+
+    @Override
+    DnsRawRecord retain(int increment);
+}
diff --git a/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsRecord.java b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsRecord.java
new file mode 100644
index 000000000..eb1c06049
--- /dev/null
+++ b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsRecord.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+/**
+ * A DNS resource record.
+ */
+public interface DnsRecord {
+
+    /**
+     * DNS resource record class: {@code IN}
+     */
+    int CLASS_IN = 0x0001;
+
+    /**
+     * DNS resource record class: {@code CSNET}
+     */
+    int CLASS_CSNET = 0x0002;
+
+    /**
+     * DNS resource record class: {@code CHAOS}
+     */
+    int CLASS_CHAOS = 0x0003;
+
+    /**
+     * DNS resource record class: {@code HESIOD}
+     */
+    int CLASS_HESIOD = 0x0004;
+
+    /**
+     * DNS resource record class: {@code NONE}
+     */
+    int CLASS_NONE = 0x00fe;
+
+    /**
+     * DNS resource record class: {@code ANY}
+     */
+    int CLASS_ANY = 0x00ff;
+
+    /**
+     * Returns the name of this resource record.
+     */
+    String name();
+
+    /**
+     * Returns the type of this resource record.
+     */
+    DnsRecordType type();
+
+    /**
+     * Returns the class of this resource record.
+     *
+     * @return the class value, usually one of the following:
+     *         <ul>
+     *             <li>{@link #CLASS_IN}</li>
+     *             <li>{@link #CLASS_CSNET}</li>
+     *             <li>{@link #CLASS_CHAOS}</li>
+     *             <li>{@link #CLASS_HESIOD}</li>
+     *             <li>{@link #CLASS_NONE}</li>
+     *             <li>{@link #CLASS_ANY}</li>
+     *         </ul>
+     */
+    int dnsClass();
+
+    /**
+     * Returns the time to live after reading for this resource record.
+     */
+    long timeToLive();
+}
diff --git a/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsRecordDecoder.java b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsRecordDecoder.java
new file mode 100644
index 000000000..a2b6315ac
--- /dev/null
+++ b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsRecordDecoder.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+import io.netty.buffer.ByteBuf;
+
+/**
+ * Decodes a DNS record into its object representation.
+ *
+ * @see DatagramDnsResponseDecoder
+ */
+public interface DnsRecordDecoder {
+
+    DnsRecordDecoder DEFAULT = new DefaultDnsRecordDecoder();
+
+    /**
+     * Decodes a DNS question into its object representation.
+     *
+     * @param in the input buffer which contains a DNS question at its reader index
+     */
+    DnsQuestion decodeQuestion(ByteBuf in) throws Exception;
+
+    /**
+     * Decodes a DNS record into its object representation.
+     *
+     * @param in the input buffer which contains a DNS record at its reader index
+     *
+     * @return the decoded record, or {@code null} if there are not enough data in the input buffer
+     */
+    <T extends DnsRecord> T decodeRecord(ByteBuf in) throws Exception;
+}
diff --git a/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsRecordEncoder.java b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsRecordEncoder.java
new file mode 100644
index 000000000..56b7fa1a0
--- /dev/null
+++ b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsRecordEncoder.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+import io.netty.buffer.ByteBuf;
+
+/**
+ * Encodes a {@link DnsRecord} into binary representation.
+ *
+ * @see DatagramDnsQueryEncoder
+ */
+public interface DnsRecordEncoder {
+
+    DnsRecordEncoder DEFAULT = new DefaultDnsRecordEncoder();
+
+    /**
+     * Encodes a {@link DnsQuestion}.
+     *
+     * @param out the output buffer where the encoded question will be written to
+     */
+    void encodeQuestion(DnsQuestion question, ByteBuf out) throws Exception;
+
+    /**
+     * Encodes a {@link DnsRecord}.
+     *
+     * @param out the output buffer where the encoded record will be written to
+     */
+    void encodeRecord(DnsRecord record, ByteBuf out) throws Exception;
+}
diff --git a/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsRecordType.java b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsRecordType.java
new file mode 100644
index 000000000..77f3d3c5a
--- /dev/null
+++ b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsRecordType.java
@@ -0,0 +1,402 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+import io.netty.util.collection.IntObjectHashMap;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Represents a DNS record type.
+ */
+public class DnsRecordType implements Comparable<DnsRecordType> {
+
+    /**
+     * Address record RFC 1035 Returns a 32-bit IPv4 address, most commonly used
+     * to map hostnames to an IP address of the host, but also used for DNSBLs,
+     * storing subnet masks in RFC 1101, etc.
+     */
+    public static final DnsRecordType A = new DnsRecordType(0x0001, "A");
+
+    /**
+     * Name server record RFC 1035 Delegates a DNS zone to use the given
+     * authoritative name servers
+     */
+    public static final DnsRecordType NS = new DnsRecordType(0x0002, "NS");
+
+    /**
+     * Canonical name record RFC 1035 Alias of one name to another: the DNS
+     * lookup will continue by retrying the lookup with the new name.
+     */
+    public static final DnsRecordType CNAME = new DnsRecordType(0x0005, "CNAME");
+
+    /**
+     * Start of [a zone of] authority record RFC 1035 and RFC 2308 Specifies
+     * authoritative information about a DNS zone, including the primary name
+     * server, the email of the domain administrator, the domain serial number,
+     * and several timers relating to refreshing the zone.
+     */
+    public static final DnsRecordType SOA = new DnsRecordType(0x0006, "SOA");
+
+    /**
+     * Pointer record RFC 1035 Pointer to a canonical name. Unlike a CNAME, DNS
+     * processing does NOT proceed, just the name is returned. The most common
+     * use is for implementing reverse DNS lookups, but other uses include such
+     * things as DNS-SD.
+     */
+    public static final DnsRecordType PTR = new DnsRecordType(0x000c, "PTR");
+
+    /**
+     * Mail exchange record RFC 1035 Maps a domain name to a list of message
+     * transfer agents for that domain.
+     */
+    public static final DnsRecordType MX = new DnsRecordType(0x000f, "MX");
+
+    /**
+     * Text record RFC 1035 Originally for arbitrary human-readable text in a
+     * DNS record. Since the early 1990s, however, this record more often
+     * carries machine-readable data, such as specified by RFC 1464,
+     * opportunistic encryption, Sender Policy Framework, DKIM, DMARC DNS-SD,
+     * etc.
+     */
+    public static final DnsRecordType TXT = new DnsRecordType(0x0010, "TXT");
+
+    /**
+     * Responsible person record RFC 1183 Information about the responsible
+     * person(s) for the domain. Usually an email address with the @ replaced by
+     * a .
+     */
+    public static final DnsRecordType RP = new DnsRecordType(0x0011, "RP");
+
+    /**
+     * AFS database record RFC 1183 Location of database servers of an AFS cell.
+     * This record is commonly used by AFS clients to contact AFS cells outside
+     * their local domain. A subtype of this record is used by the obsolete
+     * DCE/DFS file system.
+     */
+    public static final DnsRecordType AFSDB = new DnsRecordType(0x0012, "AFSDB");
+
+    /**
+     * Signature record RFC 2535 Signature record used in SIG(0) (RFC 2931) and
+     * TKEY (RFC 2930). RFC 3755 designated RRSIG as the replacement for SIG for
+     * use within DNSSEC.
+     */
+    public static final DnsRecordType SIG = new DnsRecordType(0x0018, "SIG");
+
+    /**
+     * key record RFC 2535 and RFC 2930 Used only for SIG(0) (RFC 2931) and TKEY
+     * (RFC 2930). RFC 3445 eliminated their use for application keys and
+     * limited their use to DNSSEC. RFC 3755 designates DNSKEY as the
+     * replacement within DNSSEC. RFC 4025 designates IPSECKEY as the
+     * replacement for use with IPsec.
+     */
+    public static final DnsRecordType KEY = new DnsRecordType(0x0019, "KEY");
+
+    /**
+     * IPv6 address record RFC 3596 Returns a 128-bit IPv6 address, most
+     * commonly used to map hostnames to an IP address of the host.
+     */
+    public static final DnsRecordType AAAA = new DnsRecordType(0x001c, "AAAA");
+
+    /**
+     * Location record RFC 1876 Specifies a geographical location associated
+     * with a domain name.
+     */
+    public static final DnsRecordType LOC = new DnsRecordType(0x001d, "LOC");
+
+    /**
+     * Service locator RFC 2782 Generalized service location record, used for
+     * newer protocols instead of creating protocol-specific records such as MX.
+     */
+    public static final DnsRecordType SRV = new DnsRecordType(0x0021, "SRV");
+
+    /**
+     * Naming Authority Pointer record RFC 3403 Allows regular expression based
+     * rewriting of domain names which can then be used as URIs, further domain
+     * names to lookups, etc.
+     */
+    public static final DnsRecordType NAPTR = new DnsRecordType(0x0023, "NAPTR");
+
+    /**
+     * Key eXchanger record RFC 2230 Used with some cryptographic systems (not
+     * including DNSSEC) to identify a key management agent for the associated
+     * domain-name. Note that this has nothing to do with DNS Security. It is
+     * Informational status, rather than being on the IETF standards-track. It
+     * has always had limited deployment, but is still in use.
+     */
+    public static final DnsRecordType KX = new DnsRecordType(0x0024, "KX");
+
+    /**
+     * Certificate record RFC 4398 Stores PKIX, SPKI, PGP, etc.
+     */
+    public static final DnsRecordType CERT = new DnsRecordType(0x0025, "CERT");
+
+    /**
+     * Delegation name record RFC 2672 DNAME creates an alias for a name and all
+     * its subnames, unlike CNAME, which aliases only the exact name in its
+     * label. Like the CNAME record, the DNS lookup will continue by retrying
+     * the lookup with the new name.
+     */
+    public static final DnsRecordType DNAME = new DnsRecordType(0x0027, "DNAME");
+
+    /**
+     * Option record RFC 2671 This is a pseudo DNS record type needed to support
+     * EDNS.
+     */
+    public static final DnsRecordType OPT = new DnsRecordType(0x0029, "OPT");
+
+    /**
+     * Address Prefix List record RFC 3123 Specify lists of address ranges, e.g.
+     * in CIDR format, for various address families. Experimental.
+     */
+    public static final DnsRecordType APL = new DnsRecordType(0x002a, "APL");
+
+    /**
+     * Delegation signer record RFC 4034 The record used to identify the DNSSEC
+     * signing key of a delegated zone.
+     */
+    public static final DnsRecordType DS = new DnsRecordType(0x002b, "DS");
+
+    /**
+     * SSH Public Key Fingerprint record RFC 4255 Resource record for publishing
+     * SSH public host key fingerprints in the DNS System, in order to aid in
+     * verifying the authenticity of the host. RFC 6594 defines ECC SSH keys and
+     * SHA-256 hashes. See the IANA SSHFP RR parameters registry for details.
+     */
+    public static final DnsRecordType SSHFP = new DnsRecordType(0x002c, "SSHFP");
+
+    /**
+     * IPsec Key record RFC 4025 Key record that can be used with IPsec.
+     */
+    public static final DnsRecordType IPSECKEY = new DnsRecordType(0x002d, "IPSECKEY");
+
+    /**
+     * DNSSEC signature record RFC 4034 Signature for a DNSSEC-secured record
+     * set. Uses the same format as the SIG record.
+     */
+    public static final DnsRecordType RRSIG = new DnsRecordType(0x002e, "RRSIG");
+
+    /**
+     * Next-Secure record RFC 4034 Part of DNSSEC, used to prove a name does not
+     * exist. Uses the same format as the (obsolete) NXT record.
+     */
+    public static final DnsRecordType NSEC = new DnsRecordType(0x002f, "NSEC");
+
+    /**
+     * DNS Key record RFC 4034 The key record used in DNSSEC. Uses the same
+     * format as the KEY record.
+     */
+    public static final DnsRecordType DNSKEY = new DnsRecordType(0x0030, "DNSKEY");
+
+    /**
+     * DHCP identifier record RFC 4701 Used in conjunction with the FQDN option
+     * to DHCP.
+     */
+    public static final DnsRecordType DHCID = new DnsRecordType(0x0031, "DHCID");
+
+    /**
+     * NSEC record version 3 RFC 5155 An extension to DNSSEC that allows proof
+     * of nonexistence for a name without permitting zonewalking.
+     */
+    public static final DnsRecordType NSEC3 = new DnsRecordType(0x0032, "NSEC3");
+
+    /**
+     * NSEC3 parameters record RFC 5155 Parameter record for use with NSEC3.
+     */
+    public static final DnsRecordType NSEC3PARAM = new DnsRecordType(0x0033, "NSEC3PARAM");
+
+    /**
+     * TLSA certificate association record RFC 6698 A record for DNS-based
+     * Authentication of Named Entities (DANE). RFC 6698 defines The TLSA DNS
+     * resource record is used to associate a TLS server certificate or public
+     * key with the domain name where the record is found, thus forming a 'TLSA
+     * certificate association'.
+     */
+    public static final DnsRecordType TLSA = new DnsRecordType(0x0034, "TLSA");
+
+    /**
+     * Host Identity Protocol record RFC 5205 Method of separating the end-point
+     * identifier and locator roles of IP addresses.
+     */
+    public static final DnsRecordType HIP = new DnsRecordType(0x0037, "HIP");
+
+    /**
+     * Sender Policy Framework record RFC 4408 Specified as part of the SPF
+     * protocol as an alternative to of storing SPF data in TXT records. Uses
+     * the same format as the earlier TXT record.
+     */
+    public static final DnsRecordType SPF = new DnsRecordType(0x0063, "SPF");
+
+    /**
+     * Secret key record RFC 2930 A method of providing keying material to be
+     * used with TSIG that is encrypted under the public key in an accompanying
+     * KEY RR..
+     */
+    public static final DnsRecordType TKEY = new DnsRecordType(0x00f9, "TKEY");
+
+    /**
+     * Transaction Signature record RFC 2845 Can be used to authenticate dynamic
+     * updates as coming from an approved client, or to authenticate responses
+     * as coming from an approved recursive name server similar to DNSSEC.
+     */
+    public static final DnsRecordType TSIG = new DnsRecordType(0x00fa, "TSIG");
+
+    /**
+     * Incremental Zone Transfer record RFC 1996 Requests a zone transfer of the
+     * given zone but only differences from a previous serial number. This
+     * request may be ignored and a full (AXFR) sent in response if the
+     * authoritative server is unable to fulfill the request due to
+     * configuration or lack of required deltas.
+     */
+    public static final DnsRecordType IXFR = new DnsRecordType(0x00fb, "IXFR");
+
+    /**
+     * Authoritative Zone Transfer record RFC 1035 Transfer entire zone file
+     * from the master name server to secondary name servers.
+     */
+    public static final DnsRecordType AXFR = new DnsRecordType(0x00fc, "AXFR");
+
+    /**
+     * All cached records RFC 1035 Returns all records of all types known to the
+     * name server. If the name server does not have any information on the
+     * name, the request will be forwarded on. The records returned may not be
+     * complete. For example, if there is both an A and an MX for a name, but
+     * the name server has only the A record cached, only the A record will be
+     * returned. Sometimes referred to as ANY, for example in Windows nslookup
+     * and Wireshark.
+     */
+    public static final DnsRecordType ANY = new DnsRecordType(0x00ff, "ANY");
+
+    /**
+     * Certification Authority Authorization record RFC 6844 CA pinning,
+     * constraining acceptable CAs for a host/domain.
+     */
+    public static final DnsRecordType CAA = new DnsRecordType(0x0101, "CAA");
+
+    /**
+     * DNSSEC Trust Authorities record N/A Part of a deployment proposal for
+     * DNSSEC without a signed DNS root. See the IANA database and Weiler Spec
+     * for details. Uses the same format as the DS record.
+     */
+    public static final DnsRecordType TA = new DnsRecordType(0x8000, "TA");
+
+    /**
+     * DNSSEC Lookaside Validation record RFC 4431 For publishing DNSSEC trust
+     * anchors outside of the DNS delegation chain. Uses the same format as the
+     * DS record. RFC 5074 describes a way of using these records.
+     */
+    public static final DnsRecordType DLV = new DnsRecordType(0x8001, "DLV");
+
+    private static final Map<String, DnsRecordType> BY_NAME = new HashMap<String, DnsRecordType>();
+    private static final IntObjectHashMap<DnsRecordType> BY_TYPE = new IntObjectHashMap<DnsRecordType>();
+    private static final String EXPECTED;
+
+    static {
+        DnsRecordType[] all = {
+                A, NS, CNAME, SOA, PTR, MX, TXT, RP, AFSDB, SIG, KEY, AAAA, LOC, SRV, NAPTR, KX, CERT, DNAME, OPT, APL,
+                DS, SSHFP, IPSECKEY, RRSIG, NSEC, DNSKEY, DHCID, NSEC3, NSEC3PARAM, TLSA, HIP, SPF, TKEY, TSIG, IXFR,
+                AXFR, ANY, CAA, TA, DLV
+        };
+
+        final StringBuilder expected = new StringBuilder(512);
+
+        expected.append(" (expected: ");
+        for (DnsRecordType type: all) {
+            BY_NAME.put(type.name(), type);
+            BY_TYPE.put(type.intValue(), type);
+
+            expected.append(type.name())
+                    .append('(')
+                    .append(type.intValue())
+                    .append("), ");
+        }
+
+        expected.setLength(expected.length() - 2);
+        expected.append(')');
+        EXPECTED = expected.toString();
+    }
+
+    public static DnsRecordType valueOf(int intValue) {
+        DnsRecordType result = BY_TYPE.get(intValue);
+        if (result == null) {
+            return new DnsRecordType(intValue);
+        }
+        return result;
+    }
+
+    public static DnsRecordType valueOf(String name) {
+        DnsRecordType result = BY_NAME.get(name);
+        if (result == null) {
+            throw new IllegalArgumentException("name: " + name + EXPECTED);
+        }
+        return result;
+    }
+
+    private final int intValue;
+    private final String name;
+    private String text;
+
+    private DnsRecordType(int intValue) {
+        this(intValue, "UNKNOWN");
+    }
+
+    public DnsRecordType(int intValue, String name) {
+        if ((intValue & 0xffff) != intValue) {
+            throw new IllegalArgumentException("intValue: " + intValue + " (expected: 0 ~ 65535)");
+        }
+        this.intValue = intValue;
+        this.name = name;
+    }
+
+    /**
+     * Returns the name of this type, as seen in bind config files
+     */
+    public String name() {
+        return name;
+    }
+
+    /**
+     * Returns the value of this DnsType as it appears in DNS protocol
+     */
+    public int intValue() {
+        return intValue;
+    }
+
+    @Override
+    public int hashCode() {
+        return intValue;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        return o instanceof DnsRecordType && ((DnsRecordType) o).intValue == intValue;
+    }
+
+    @Override
+    public int compareTo(DnsRecordType o) {
+        return intValue() - o.intValue();
+    }
+
+    @Override
+    public String toString() {
+        String text = this.text;
+        if (text == null) {
+            this.text = text = name + '(' + intValue() + ')';
+        }
+        return text;
+    }
+}
diff --git a/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResponse.java b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResponse.java
new file mode 100644
index 000000000..bf85fdee8
--- /dev/null
+++ b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResponse.java
@@ -0,0 +1,107 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+/**
+ * A DNS response message.
+ */
+public interface DnsResponse extends DnsMessage {
+
+    /**
+     * Returns {@code true} if responding server is authoritative for the domain
+     * name in the query message.
+     */
+    boolean isAuthoritativeAnswer();
+
+    /**
+     * Set to {@code true} if responding server is authoritative for the domain
+     * name in the query message.
+     *
+     * @param authoritativeAnswer flag for authoritative answer
+     */
+    DnsResponse setAuthoritativeAnswer(boolean authoritativeAnswer);
+
+    /**
+     * Returns {@code true} if response has been truncated, usually if it is
+     * over 512 bytes.
+     */
+    boolean isTruncated();
+
+    /**
+     * Set to {@code true} if response has been truncated (usually happens for
+     * responses over 512 bytes).
+     *
+     * @param truncated flag for truncation
+     */
+    DnsResponse setTruncated(boolean truncated);
+
+    /**
+     * Returns {@code true} if DNS server can handle recursive queries.
+     */
+    boolean isRecursionAvailable();
+
+    /**
+     * Set to {@code true} if DNS server can handle recursive queries.
+     *
+     * @param recursionAvailable flag for recursion availability
+     */
+    DnsResponse setRecursionAvailable(boolean recursionAvailable);
+
+    /**
+     * Returns the 4 bit return code.
+     */
+    DnsResponseCode code();
+
+    /**
+     * Sets the response code for this message.
+     *
+     * @param code the response code
+     */
+    DnsResponse setCode(DnsResponseCode code);
+
+    @Override
+    DnsResponse setId(int id);
+
+    @Override
+    DnsResponse setOpCode(DnsOpCode opCode);
+
+    @Override
+    DnsResponse setRecursionDesired(boolean recursionDesired);
+
+    @Override
+    DnsResponse setZ(int z);
+
+    @Override
+    DnsResponse setRecord(DnsSection section, DnsRecord record);
+
+    @Override
+    DnsResponse addRecord(DnsSection section, DnsRecord record);
+
+    @Override
+    DnsResponse addRecord(DnsSection section, int index, DnsRecord record);
+
+    @Override
+    DnsResponse clear(DnsSection section);
+
+    @Override
+    DnsResponse clear();
+
+    @Override
+    DnsResponse retain();
+
+    @Override
+    DnsResponse retain(int increment);
+}
diff --git a/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResponseCode.java b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResponseCode.java
new file mode 100644
index 000000000..dcd4c945a
--- /dev/null
+++ b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResponseCode.java
@@ -0,0 +1,216 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+import static io.netty.util.internal.ObjectUtil.checkNotNull;
+
+/**
+ * The DNS {@code RCODE}, as defined in <a href="https://tools.ietf.org/html/rfc2929">RFC2929</a>.
+ */
+public class DnsResponseCode implements Comparable<DnsResponseCode> {
+
+    /**
+     * The 'NoError' DNS RCODE (0), as defined in <a href="https://tools.ietf.org/html/rfc1035">RFC1035</a>.
+     */
+    public static final DnsResponseCode NOERROR = new DnsResponseCode(0, "NoError");
+
+    /**
+     * The 'FormErr' DNS RCODE (1), as defined in <a href="https://tools.ietf.org/html/rfc1035">RFC1035</a>.
+     */
+    public static final DnsResponseCode FORMERR = new DnsResponseCode(1, "FormErr");
+
+    /**
+     * The 'ServFail' DNS RCODE (2), as defined in <a href="https://tools.ietf.org/html/rfc1035">RFC1035</a>.
+     */
+    public static final DnsResponseCode SERVFAIL = new DnsResponseCode(2, "ServFail");
+
+    /**
+     * The 'NXDomain' DNS RCODE (3), as defined in <a href="https://tools.ietf.org/html/rfc1035">RFC1035</a>.
+     */
+    public static final DnsResponseCode NXDOMAIN = new DnsResponseCode(3, "NXDomain");
+
+    /**
+     * The 'NotImp' DNS RCODE (4), as defined in <a href="https://tools.ietf.org/html/rfc1035">RFC1035</a>.
+     */
+    public static final DnsResponseCode NOTIMP = new DnsResponseCode(4, "NotImp");
+
+    /**
+     * The 'Refused' DNS RCODE (5), as defined in <a href="https://tools.ietf.org/html/rfc1035">RFC1035</a>.
+     */
+    public static final DnsResponseCode REFUSED = new DnsResponseCode(5, "Refused");
+
+    /**
+     * The 'YXDomain' DNS RCODE (6), as defined in <a href="https://tools.ietf.org/html/rfc2136">RFC2136</a>.
+     */
+    public static final DnsResponseCode YXDOMAIN = new DnsResponseCode(6, "YXDomain");
+
+    /**
+     * The 'YXRRSet' DNS RCODE (7), as defined in <a href="https://tools.ietf.org/html/rfc2136">RFC2136</a>.
+     */
+    public static final DnsResponseCode YXRRSET = new DnsResponseCode(7, "YXRRSet");
+
+    /**
+     * The 'NXRRSet' DNS RCODE (8), as defined in <a href="https://tools.ietf.org/html/rfc2136">RFC2136</a>.
+     */
+    public static final DnsResponseCode NXRRSET = new DnsResponseCode(8, "NXRRSet");
+
+    /**
+     * The 'NotAuth' DNS RCODE (9), as defined in <a href="https://tools.ietf.org/html/rfc2136">RFC2136</a>.
+     */
+    public static final DnsResponseCode NOTAUTH = new DnsResponseCode(9, "NotAuth");
+
+    /**
+     * The 'NotZone' DNS RCODE (10), as defined in <a href="https://tools.ietf.org/html/rfc2136">RFC2136</a>.
+     */
+    public static final DnsResponseCode NOTZONE = new DnsResponseCode(10, "NotZone");
+
+    /**
+     * The 'BADVERS' or 'BADSIG' DNS RCODE (16), as defined in <a href="https://tools.ietf.org/html/rfc2671">RFC2671</a>
+     * and <a href="https://tools.ietf.org/html/rfc2845">RFC2845</a>.
+     */
+    public static final DnsResponseCode BADVERS_OR_BADSIG = new DnsResponseCode(16, "BADVERS_OR_BADSIG");
+
+    /**
+     * The 'BADKEY' DNS RCODE (17), as defined in <a href="https://tools.ietf.org/html/rfc2845">RFC2845</a>.
+     */
+    public static final DnsResponseCode BADKEY = new DnsResponseCode(17, "BADKEY");
+
+    /**
+     * The 'BADTIME' DNS RCODE (18), as defined in <a href="https://tools.ietf.org/html/rfc2845">RFC2845</a>.
+     */
+    public static final DnsResponseCode BADTIME = new DnsResponseCode(18, "BADTIME");
+
+    /**
+     * The 'BADMODE' DNS RCODE (19), as defined in <a href="https://tools.ietf.org/html/rfc2930">RFC2930</a>.
+     */
+    public static final DnsResponseCode BADMODE = new DnsResponseCode(19, "BADMODE");
+
+    /**
+     * The 'BADNAME' DNS RCODE (20), as defined in <a href="https://tools.ietf.org/html/rfc2930">RFC2930</a>.
+     */
+    public static final DnsResponseCode BADNAME = new DnsResponseCode(20, "BADNAME");
+
+    /**
+     * The 'BADALG' DNS RCODE (21), as defined in <a href="https://tools.ietf.org/html/rfc2930">RFC2930</a>.
+     */
+    public static final DnsResponseCode BADALG = new DnsResponseCode(21, "BADALG");
+
+    /**
+     * Returns the {@link DnsResponseCode} that corresponds with the given {@code responseCode}.
+     *
+     * @param responseCode the DNS RCODE
+     *
+     * @return the corresponding {@link DnsResponseCode}
+     */
+    public static DnsResponseCode valueOf(int responseCode) {
+        switch (responseCode) {
+        case 0:
+            return NOERROR;
+        case 1:
+            return FORMERR;
+        case 2:
+            return SERVFAIL;
+        case 3:
+            return NXDOMAIN;
+        case 4:
+            return NOTIMP;
+        case 5:
+            return REFUSED;
+        case 6:
+            return YXDOMAIN;
+        case 7:
+            return YXRRSET;
+        case 8:
+            return NXRRSET;
+        case 9:
+            return NOTAUTH;
+        case 10:
+            return NOTZONE;
+        case 16:
+            return BADVERS_OR_BADSIG;
+        case 17:
+            return BADKEY;
+        case 18:
+            return BADTIME;
+        case 19:
+            return BADMODE;
+        case 20:
+            return BADNAME;
+        case 21:
+            return BADALG;
+        default:
+            return new DnsResponseCode(responseCode);
+        }
+    }
+
+    private final int code;
+    private final String name;
+    private String text;
+
+    private DnsResponseCode(int code) {
+        this(code, "UNKNOWN");
+    }
+
+    public DnsResponseCode(int code, String name) {
+        if (code < 0 || code > 65535) {
+            throw new IllegalArgumentException("code: " + code + " (expected: 0 ~ 65535)");
+        }
+
+        this.code = code;
+        this.name = checkNotNull(name, "name");
+    }
+
+    /**
+     * Returns the error code for this {@link DnsResponseCode}.
+     */
+    public int intValue() {
+        return code;
+    }
+
+    @Override
+    public int compareTo(DnsResponseCode o) {
+        return intValue() - o.intValue();
+    }
+
+    @Override
+    public int hashCode() {
+        return intValue();
+    }
+
+    /**
+     * Equality of {@link DnsResponseCode} only depends on {@link #intValue()}.
+     */
+    @Override
+    public boolean equals(Object o) {
+        if (!(o instanceof DnsResponseCode)) {
+            return false;
+        }
+
+        return intValue() == ((DnsResponseCode) o).intValue();
+    }
+
+    /**
+     * Returns a formatted error message for this {@link DnsResponseCode}.
+     */
+    @Override
+    public String toString() {
+        String text = this.text;
+        if (text == null) {
+            this.text = text = name + '(' + intValue() + ')';
+        }
+        return text;
+    }
+}
diff --git a/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsSection.java b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsSection.java
new file mode 100644
index 000000000..1d0c842d1
--- /dev/null
+++ b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsSection.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+/**
+ * Represents a section of a {@link DnsMessage}.
+ */
+public enum DnsSection {
+    /**
+     * The section that contains {@link DnsQuestion}s.
+     */
+    QUESTION,
+    /**
+     * The section that contains the answer {@link DnsRecord}s.
+     */
+    ANSWER,
+    /**
+     * The section that contains the authority {@link DnsRecord}s.
+     */
+    AUTHORITY,
+    /**
+     * The section that contains the additional {@link DnsRecord}s.
+     */
+    ADDITIONAL
+}
diff --git a/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/package-info.java b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/package-info.java
new file mode 100644
index 000000000..e45c7dfca
--- /dev/null
+++ b/netty-bp/codec-dns/src/main/java/io/netty/handler/codec/dns/package-info.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+/**
+ * DNS codec.
+ */
+package io.netty.handler.codec.dns;
diff --git a/netty-bp/codec-dns/src/test/java/io/netty/handler/codec/dns/DnsQueryTest.java b/netty-bp/codec-dns/src/test/java/io/netty/handler/codec/dns/DnsQueryTest.java
new file mode 100644
index 000000000..48cb948f4
--- /dev/null
+++ b/netty-bp/codec-dns/src/test/java/io/netty/handler/codec/dns/DnsQueryTest.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+import io.netty.channel.embedded.EmbeddedChannel;
+
+import io.netty.channel.socket.DatagramPacket;
+import org.junit.Assert;
+import org.junit.Test;
+
+import java.net.InetSocketAddress;
+import java.util.ArrayList;
+import java.util.List;
+
+import static org.hamcrest.Matchers.is;
+import static org.junit.Assert.assertThat;
+
+public class DnsQueryTest {
+
+    @Test
+    public void writeQueryTest() throws Exception {
+        InetSocketAddress addr = new InetSocketAddress("8.8.8.8", 53);
+        EmbeddedChannel embedder = new EmbeddedChannel(new DatagramDnsQueryEncoder());
+        List<DnsQuery> queries = new ArrayList<DnsQuery>(5);
+        queries.add(new DatagramDnsQuery(null, addr, 1).setRecord(
+                DnsSection.QUESTION,
+                new DefaultDnsQuestion("1.0.0.127.in-addr.arpa", DnsRecordType.PTR)));
+        queries.add(new DatagramDnsQuery(null, addr, 1).setRecord(
+                DnsSection.QUESTION,
+                new DefaultDnsQuestion("www.example.com", DnsRecordType.A)));
+        queries.add(new DatagramDnsQuery(null, addr, 1).setRecord(
+                DnsSection.QUESTION,
+                new DefaultDnsQuestion("example.com", DnsRecordType.AAAA)));
+        queries.add(new DatagramDnsQuery(null, addr, 1).setRecord(
+                DnsSection.QUESTION,
+                new DefaultDnsQuestion("example.com", DnsRecordType.MX)));
+        queries.add(new DatagramDnsQuery(null, addr, 1).setRecord(
+                DnsSection.QUESTION,
+                new DefaultDnsQuestion("example.com", DnsRecordType.CNAME)));
+
+        for (DnsQuery query: queries) {
+            assertThat(query.count(DnsSection.QUESTION), is(1));
+            assertThat(query.count(DnsSection.ANSWER), is(0));
+            assertThat(query.count(DnsSection.AUTHORITY), is(0));
+            assertThat(query.count(DnsSection.ADDITIONAL), is(0));
+
+            embedder.writeOutbound(query);
+
+            DatagramPacket packet = (DatagramPacket) embedder.readOutbound();
+            Assert.assertTrue(packet.content().isReadable());
+            packet.release();
+            Assert.assertNull(embedder.readOutbound());
+        }
+    }
+}
diff --git a/netty-bp/codec-dns/src/test/java/io/netty/handler/codec/dns/DnsRecordTypeTest.java b/netty-bp/codec-dns/src/test/java/io/netty/handler/codec/dns/DnsRecordTypeTest.java
new file mode 100644
index 000000000..aeeab95b0
--- /dev/null
+++ b/netty-bp/codec-dns/src/test/java/io/netty/handler/codec/dns/DnsRecordTypeTest.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+import org.junit.Test;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+
+import static org.junit.Assert.*;
+
+public class DnsRecordTypeTest {
+
+    private static List<DnsRecordType> allTypes() throws Exception {
+        List<DnsRecordType> result = new ArrayList<DnsRecordType>();
+        for (Field field : DnsRecordType.class.getFields()) {
+            if ((field.getModifiers() & Modifier.STATIC) != 0 && field.getType() == DnsRecordType.class) {
+                result.add((DnsRecordType) field.get(null));
+            }
+        }
+        assertFalse(result.isEmpty());
+        return result;
+    }
+
+    @Test
+    public void testSanity() throws Exception {
+        assertEquals("More than one type has the same int value",
+                allTypes().size(), new HashSet<DnsRecordType>(allTypes()).size());
+    }
+
+    /**
+     * Test of hashCode method, of class DnsRecordType.
+     */
+    @Test
+    public void testHashCode() throws Exception {
+        for (DnsRecordType t : allTypes()) {
+            assertEquals(t.intValue(), t.hashCode());
+        }
+    }
+
+    /**
+     * Test of equals method, of class DnsRecordType.
+     */
+    @Test
+    public void testEquals() throws Exception {
+        for (DnsRecordType t1 : allTypes()) {
+            for (DnsRecordType t2 : allTypes()) {
+                if (t1 != t2) {
+                    assertNotEquals(t1, t2);
+                }
+            }
+        }
+    }
+
+    /**
+     * Test of find method, of class DnsRecordType.
+     */
+    @Test
+    public void testFind() throws Exception {
+        for (DnsRecordType t : allTypes()) {
+            DnsRecordType found = DnsRecordType.valueOf(t.intValue());
+            assertSame(t, found);
+            found = DnsRecordType.valueOf(t.name());
+            assertSame(t.name(), t, found);
+        }
+    }
+}
diff --git a/netty-bp/codec-dns/src/test/java/io/netty/handler/codec/dns/DnsResponseTest.java b/netty-bp/codec-dns/src/test/java/io/netty/handler/codec/dns/DnsResponseTest.java
new file mode 100644
index 000000000..e0d1ec1a3
--- /dev/null
+++ b/netty-bp/codec-dns/src/test/java/io/netty/handler/codec/dns/DnsResponseTest.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.AddressedEnvelope;
+import io.netty.channel.embedded.EmbeddedChannel;
+import io.netty.channel.socket.DatagramPacket;
+import io.netty.handler.codec.CorruptedFrameException;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+
+import java.net.InetSocketAddress;
+
+import static org.hamcrest.Matchers.*;
+import static org.junit.Assert.*;
+
+public class DnsResponseTest {
+
+    private static final byte[][] packets = {
+            {
+                    0, 1, -127, -128, 0, 1, 0, 1, 0, 0, 0, 0, 3, 119, 119, 119, 7, 101, 120, 97, 109, 112, 108, 101, 3,
+                    99, 111, 109, 0, 0, 1, 0, 1, -64, 12, 0, 1, 0, 1, 0, 0, 16, -113, 0, 4, -64, 0, 43, 10
+            },
+            {
+                    0, 1, -127, -128, 0, 1, 0, 1, 0, 0, 0, 0, 3, 119, 119, 119, 7, 101, 120, 97, 109, 112, 108, 101, 3,
+                    99, 111, 109, 0, 0, 28, 0, 1, -64, 12, 0, 28, 0, 1, 0, 0, 69, -8, 0, 16, 32, 1, 5, 0, 0, -120, 2,
+                    0, 0, 0, 0, 0, 0, 0, 0, 16
+            },
+            {
+                    0, 2, -127, -128, 0, 1, 0, 0, 0, 1, 0, 0, 3, 119, 119, 119, 7, 101, 120, 97, 109, 112, 108, 101, 3,
+                    99, 111, 109, 0, 0, 15, 0, 1, -64, 16, 0, 6, 0, 1, 0, 0, 3, -43, 0, 45, 3, 115, 110, 115, 3, 100,
+                    110, 115, 5, 105, 99, 97, 110, 110, 3, 111, 114, 103, 0, 3, 110, 111, 99, -64, 49, 119, -4, 39,
+                    112, 0, 0, 28, 32, 0, 0, 14, 16, 0, 18, 117, 0, 0, 0, 14, 16
+            },
+            {
+                    0, 3, -127, -128, 0, 1, 0, 1, 0, 0, 0, 0, 3, 119, 119, 119, 7, 101, 120, 97, 109, 112, 108, 101, 3,
+                    99, 111, 109, 0, 0, 16, 0, 1, -64, 12, 0, 16, 0, 1, 0, 0, 84, 75, 0, 12, 11, 118, 61, 115, 112,
+                    102, 49, 32, 45, 97, 108, 108
+            },
+            {
+                    -105, 19, -127, 0, 0, 1, 0, 0, 0, 13, 0, 0, 2, 104, 112, 11, 116, 105, 109, 98, 111, 117, 100, 114,
+                    101, 97, 117, 3, 111, 114, 103, 0, 0, 1, 0, 1, 0, 0, 2, 0, 1, 0, 7, -23, 0, 0, 20, 1, 68, 12, 82,
+                    79, 79, 84, 45, 83, 69, 82, 86, 69, 82, 83, 3, 78, 69, 84, 0, 0, 0, 2, 0, 1, 0, 7, -23, 0, 0, 4, 1,
+                    70, -64, 49, 0, 0, 2, 0, 1, 0, 7, -23, 0, 0, 4, 1, 69, -64, 49, 0, 0, 2, 0, 1, 0, 7, -23, 0, 0, 4,
+                    1, 75, -64, 49, 0, 0, 2, 0, 1, 0, 7, -23, 0, 0, 4, 1, 67, -64, 49, 0, 0, 2, 0, 1, 0, 7, -23, 0, 0,
+                    4, 1, 76, -64, 49, 0, 0, 2, 0, 1, 0, 7, -23, 0, 0, 4, 1, 71, -64, 49, 0, 0, 2, 0, 1, 0, 7, -23, 0,
+                    0, 4, 1, 73, -64, 49, 0, 0, 2, 0, 1, 0, 7, -23, 0, 0, 4, 1, 66, -64, 49, 0, 0, 2, 0, 1, 0, 7, -23,
+                    0, 0, 4, 1, 77, -64, 49, 0, 0, 2, 0, 1, 0, 7, -23, 0, 0, 4, 1, 65, -64, 49, 0, 0, 2, 0, 1, 0, 7,
+                    -23, 0, 0, 4, 1, 72, -64, 49, 0, 0, 2, 0, 1, 0, 7, -23, 0, 0, 4, 1, 74, -64, 49
+            }
+    };
+
+    private static final byte[] malformedLoopPacket = {
+            0, 4, -127, -128, 0, 1, 0, 0, 0, 0, 0, 0, -64, 12, 0, 1, 0, 1
+    };
+
+    @Test
+    public void readResponseTest() throws Exception {
+        EmbeddedChannel embedder = new EmbeddedChannel(new DatagramDnsResponseDecoder());
+        for (byte[] p: packets) {
+            ByteBuf packet = embedder.alloc().buffer(512).writeBytes(p);
+            embedder.writeInbound(new DatagramPacket(packet, null, new InetSocketAddress(0)));
+            AddressedEnvelope<DnsResponse, InetSocketAddress> envelope = (AddressedEnvelope<DnsResponse, InetSocketAddress>) embedder.readInbound();
+            assertThat(envelope, is(instanceOf(DatagramDnsResponse.class)));
+            DnsResponse response = envelope.content();
+            assertThat(response, is(sameInstance((Object) envelope)));
+
+            ByteBuf raw = Unpooled.wrappedBuffer(p);
+            assertThat(response.id(), is(raw.getUnsignedShort(0)));
+            assertThat(response.count(DnsSection.QUESTION), is(raw.getUnsignedShort(4)));
+            assertThat(response.count(DnsSection.ANSWER), is(raw.getUnsignedShort(6)));
+            assertThat(response.count(DnsSection.AUTHORITY), is(raw.getUnsignedShort(8)));
+            assertThat(response.count(DnsSection.ADDITIONAL), is(raw.getUnsignedShort(10)));
+
+            envelope.release();
+        }
+    }
+
+    @Rule
+    public ExpectedException exception = ExpectedException.none();
+
+    @Test
+    public void readMalormedResponseTest() throws Exception {
+        EmbeddedChannel embedder = new EmbeddedChannel(new DatagramDnsResponseDecoder());
+        ByteBuf packet = embedder.alloc().buffer(512).writeBytes(malformedLoopPacket);
+        exception.expect(CorruptedFrameException.class);
+        embedder.writeInbound(new DatagramPacket(packet, null, new InetSocketAddress(0)));
+    }
+}
diff --git a/netty-bp/pom.xml b/netty-bp/pom.xml
new file mode 100644
index 000000000..d3c5833f7
--- /dev/null
+++ b/netty-bp/pom.xml
@@ -0,0 +1,52 @@
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+	<parent>
+		<groupId>org.asynchttpclient</groupId>
+		<artifactId>async-http-client-project</artifactId>
+		<version>2.0.0-RC9-SNAPSHOT</version>
+	</parent>
+	<modelVersion>4.0.0</modelVersion>
+	<artifactId>netty-bp</artifactId>
+	<name>Asynchronous Http Client Extras Parent</name>
+	<packaging>pom</packaging>
+	<description>
+        The Async Http Client Netty Backport parent.
+    </description>
+
+	<modules>
+		<module>codec-dns</module>
+		<module>resolver</module>
+		<module>resolver-dns</module>
+	</modules>
+
+	<dependencies>
+		<dependency>
+			<groupId>org.apache.directory.server</groupId>
+			<artifactId>apacheds-protocol-dns</artifactId>
+			<version>1.5.7</version>
+			<scope>test</scope>
+		</dependency>
+		<dependency>
+			<groupId>junit</groupId>
+			<artifactId>junit</artifactId>
+			<version>4.12</version>
+			<scope>test</scope>
+		</dependency>
+		<dependency>
+			<groupId>org.hamcrest</groupId>
+			<artifactId>hamcrest-library</artifactId>
+			<version>1.3</version>
+			<scope>test</scope>
+		</dependency>
+	</dependencies>
+
+	<build>
+		<plugins>
+			<plugin>
+				<artifactId>maven-javadoc-plugin</artifactId>
+				<configuration>
+					<additionalparam>-Xdoclint:none</additionalparam>
+				</configuration>
+			</plugin>
+		</plugins>
+	</build>
+</project>
diff --git a/netty-bp/resolver-dns/pom.xml b/netty-bp/resolver-dns/pom.xml
new file mode 100644
index 000000000..e45cdf8fe
--- /dev/null
+++ b/netty-bp/resolver-dns/pom.xml
@@ -0,0 +1,36 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- ~ Copyright 2014 The Netty Project ~ ~ The Netty Project licenses this file to you under the Apache License, ~ version 2.0 (the "License"); you may not use this file except in 
+	compliance ~ with the License. You may obtain a copy of the License at: ~ ~ http://www.apache.org/licenses/LICENSE-2.0 ~ ~ Unless required by applicable law or agreed to in writing, 
+	software ~ distributed under the License is distributed on an "AS IS" BASIS, WITHOUT ~ WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the ~ License for the specific 
+	language governing permissions and limitations ~ under the License. -->
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+
+	<modelVersion>4.0.0</modelVersion>
+	<parent>
+		<groupId>org.asynchttpclient</groupId>
+		<artifactId>netty-bp</artifactId>
+		<version>2.0.0-RC9-SNAPSHOT</version>
+	</parent>
+
+	<artifactId>netty-resolver-dns</artifactId>
+
+	<name>Netty/Resolver/DNS</name>
+
+	<dependencies>
+		<dependency>
+			<groupId>${project.groupId}</groupId>
+			<artifactId>netty-resolver</artifactId>
+			<version>${project.version}</version>
+		</dependency>
+		<dependency>
+			<groupId>${project.groupId}</groupId>
+			<artifactId>netty-codec-dns</artifactId>
+			<version>${project.version}</version>
+		</dependency>
+		<dependency>
+			<groupId>io.netty</groupId>
+			<artifactId>netty-transport</artifactId>
+		</dependency>
+	</dependencies>
+</project>
+
diff --git a/netty-bp/resolver-dns/src/main/java/io/netty/channel/ReflectiveChannelFactory.java b/netty-bp/resolver-dns/src/main/java/io/netty/channel/ReflectiveChannelFactory.java
new file mode 100644
index 000000000..18c0ab762
--- /dev/null
+++ b/netty-bp/resolver-dns/src/main/java/io/netty/channel/ReflectiveChannelFactory.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.channel;
+
+import io.netty.bootstrap.ChannelFactory;
+import io.netty.util.internal.StringUtil;
+
+/**
+ * A {@link ChannelFactory} that instantiates a new {@link Channel} by invoking its default constructor reflectively.
+ */
+public class ReflectiveChannelFactory<T extends Channel> implements ChannelFactory<T> {
+
+    private final Class<? extends T> clazz;
+
+    public ReflectiveChannelFactory(Class<? extends T> clazz) {
+        if (clazz == null) {
+            throw new NullPointerException("clazz");
+        }
+        this.clazz = clazz;
+    }
+
+    @Override
+    public T newChannel() {
+        try {
+            return clazz.newInstance();
+        } catch (Throwable t) {
+            throw new ChannelException("Unable to create Channel from class " + clazz, t);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return StringUtil.simpleClassName(clazz) + ".class";
+    }
+}
diff --git a/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java
new file mode 100644
index 000000000..2ddefcd79
--- /dev/null
+++ b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java
@@ -0,0 +1,221 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.resolver.dns;
+
+import io.netty.channel.EventLoop;
+import io.netty.util.internal.OneTimeTask;
+import io.netty.util.internal.PlatformDependent;
+
+import java.net.InetAddress;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.TimeUnit;
+
+import static io.netty.util.internal.ObjectUtil2.*;
+
+/**
+ * Default implementation of {@link DnsCache}, backed by a {@link ConcurrentMap}.
+ */
+public class DefaultDnsCache implements DnsCache {
+
+    private final ConcurrentMap<String, List<DnsCacheEntry>> resolveCache = PlatformDependent.newConcurrentHashMap();
+    private final int minTtl;
+    private final int maxTtl;
+    private final int negativeTtl;
+
+    /**
+     * Create a cache that respects the TTL returned by the DNS server
+     * and doesn't cache negative responses.
+     */
+    public DefaultDnsCache() {
+        this(0, Integer.MAX_VALUE, 0);
+    }
+
+    /**
+     * Create a cache.
+     * @param minTtl the minimum TTL
+     * @param maxTtl the maximum TTL
+     * @param negativeTtl the TTL for failed queries
+     */
+    public DefaultDnsCache(int minTtl, int maxTtl, int negativeTtl) {
+        this.minTtl = checkPositiveOrZero(minTtl, "minTtl");
+        this.maxTtl = checkPositiveOrZero(maxTtl, "maxTtl");
+        if (minTtl > maxTtl) {
+            throw new IllegalArgumentException(
+                    "minTtl: " + minTtl + ", maxTtl: " + maxTtl + " (expected: 0 <= minTtl <= maxTtl)");
+        }
+        this.negativeTtl = checkPositiveOrZero(negativeTtl, "negativeTtl");
+    }
+
+    /**
+     * Returns the minimum TTL of the cached DNS resource records (in seconds).
+     *
+     * @see #maxTtl()
+     */
+    public int minTtl() {
+        return minTtl;
+    }
+
+    /**
+     * Returns the maximum TTL of the cached DNS resource records (in seconds).
+     *
+     * @see #minTtl()
+     */
+    public int maxTtl() {
+        return maxTtl;
+    }
+
+    /**
+     * Returns the TTL of the cache for the failed DNS queries (in seconds). The default value is {@code 0}, which
+     * disables the cache for negative results.
+     */
+    public int negativeTtl() {
+        return negativeTtl;
+    }
+
+    @Override
+    public void clear() {
+        for (Iterator<Map.Entry<String, List<DnsCacheEntry>>> i = resolveCache.entrySet().iterator(); i.hasNext();) {
+            final Map.Entry<String, List<DnsCacheEntry>> e = i.next();
+            i.remove();
+            cancelExpiration(e.getValue());
+        }
+    }
+
+    @Override
+    public boolean clear(String hostname) {
+        checkNotNull(hostname, "hostname");
+        boolean removed = false;
+        for (Iterator<Map.Entry<String, List<DnsCacheEntry>>> i = resolveCache.entrySet().iterator(); i.hasNext();) {
+            final Map.Entry<String, List<DnsCacheEntry>> e = i.next();
+            if (e.getKey().equals(hostname)) {
+                i.remove();
+                cancelExpiration(e.getValue());
+                removed = true;
+            }
+        }
+        return removed;
+    }
+
+    @Override
+    public List<DnsCacheEntry> get(String hostname) {
+        checkNotNull(hostname, "hostname");
+        return resolveCache.get(hostname);
+    }
+
+    private List<DnsCacheEntry> cachedEntries(String hostname) {
+        List<DnsCacheEntry> oldEntries = resolveCache.get(hostname);
+        final List<DnsCacheEntry> entries;
+        if (oldEntries == null) {
+            List<DnsCacheEntry> newEntries = new ArrayList<DnsCacheEntry>(8);
+            oldEntries = resolveCache.putIfAbsent(hostname, newEntries);
+            entries = oldEntries != null? oldEntries : newEntries;
+        } else {
+            entries = oldEntries;
+        }
+        return entries;
+    }
+
+    @Override
+    public void cache(String hostname, InetAddress address, long originalTtl, EventLoop loop) {
+        if (maxTtl == 0) {
+            return;
+        }
+        checkNotNull(hostname, "hostname");
+        checkNotNull(address, "address");
+        checkNotNull(loop, "loop");
+
+        final int ttl = Math.max(minTtl, (int) Math.min(maxTtl, originalTtl));
+        final List<DnsCacheEntry> entries = cachedEntries(hostname);
+        final DnsCacheEntry e = new DnsCacheEntry(hostname, address);
+
+        synchronized (entries) {
+            if (!entries.isEmpty()) {
+                final DnsCacheEntry firstEntry = entries.get(0);
+                if (firstEntry.cause() != null) {
+                    assert entries.size() == 1;
+                    firstEntry.cancelExpiration();
+                    entries.clear();
+                }
+            }
+            entries.add(e);
+        }
+
+        scheduleCacheExpiration(entries, e, ttl, loop);
+    }
+
+    @Override
+    public void cache(String hostname, Throwable cause, EventLoop loop) {
+        if (negativeTtl == 0) {
+            return;
+        }
+        checkNotNull(hostname, "hostname");
+        checkNotNull(cause, "cause");
+        checkNotNull(loop, "loop");
+
+        final List<DnsCacheEntry> entries = cachedEntries(hostname);
+        final DnsCacheEntry e = new DnsCacheEntry(hostname, cause);
+
+        synchronized (entries) {
+            final int numEntries = entries.size();
+            for (int i = 0; i < numEntries; i ++) {
+                entries.get(i).cancelExpiration();
+            }
+            entries.clear();
+            entries.add(e);
+        }
+
+        scheduleCacheExpiration(entries, e, negativeTtl, loop);
+    }
+
+    private static void cancelExpiration(List<DnsCacheEntry> entries) {
+        final int numEntries = entries.size();
+        for (int i = 0; i < numEntries; i++) {
+            entries.get(i).cancelExpiration();
+        }
+    }
+
+    private void scheduleCacheExpiration(final List<DnsCacheEntry> entries,
+                                         final DnsCacheEntry e,
+                                         int ttl,
+                                         EventLoop loop) {
+        e.scheduleExpiration(loop, new OneTimeTask() {
+                    @Override
+                    public void run() {
+                        synchronized (entries) {
+                            entries.remove(e);
+                            if (entries.isEmpty()) {
+                                resolveCache.remove(e.hostname());
+                            }
+                        }
+                    }
+                }, ttl, TimeUnit.SECONDS);
+    }
+
+    @Override
+    public String toString() {
+        return new StringBuilder()
+                .append("DefaultDnsCache(minTtl=")
+                .append(minTtl).append(", maxTtl=")
+                .append(maxTtl).append(", negativeTtl=")
+                .append(negativeTtl).append(", cached resolved hostname=")
+                .append(resolveCache.size()).append(")")
+                .toString();
+    }
+}
diff --git a/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsNameResolverBuilder.java b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsNameResolverBuilder.java
new file mode 100644
index 000000000..cc69db868
--- /dev/null
+++ b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsNameResolverBuilder.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.resolver.dns;
+
+import io.netty.channel.EventLoop;
+
+public class DefaultDnsNameResolverBuilder extends DnsNameResolverBuilder<DefaultDnsNameResolverBuilder> {
+
+    public DefaultDnsNameResolverBuilder(EventLoop eventLoop) {
+        super(eventLoop);
+    }
+
+    @Override
+    protected DnsNameResolver build0(DnsCache cache) {
+        return new DnsNameResolver(
+                eventLoop,
+                channelFactory,
+                localAddress,
+                nameServerAddresses,
+                cache,
+                queryTimeoutMillis,
+                resolvedAddressTypes,
+                recursionDesired,
+                maxQueriesPerResolve,
+                traceEnabled,
+                maxPayloadSize,
+                optResourceEnabled,
+                hostsFileEntriesResolver);
+    }
+}
diff --git a/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddresses.java b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddresses.java
new file mode 100644
index 000000000..0efd24491
--- /dev/null
+++ b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddresses.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.resolver.dns;
+
+import java.net.InetSocketAddress;
+
+abstract class DefaultDnsServerAddresses extends DnsServerAddresses {
+
+    protected final InetSocketAddress[] addresses;
+    private final String strVal;
+
+    DefaultDnsServerAddresses(String type, InetSocketAddress[] addresses) {
+        this.addresses = addresses;
+
+        final StringBuilder buf = new StringBuilder(type.length() + 2 + addresses.length * 16);
+        buf.append(type).append('(');
+
+        for (InetSocketAddress a: addresses) {
+            buf.append(a).append(", ");
+        }
+
+        buf.setLength(buf.length() - 2);
+        buf.append(')');
+
+        strVal = buf.toString();
+    }
+
+    @Override
+    public String toString() {
+        return strVal;
+    }
+}
diff --git a/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java
new file mode 100644
index 000000000..363a35843
--- /dev/null
+++ b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.resolver.dns;
+
+import io.netty.bootstrap.ChannelFactory;
+import io.netty.channel.EventLoop;
+import io.netty.channel.ReflectiveChannelFactory;
+import io.netty.channel.socket.DatagramChannel;
+import io.netty.resolver.AddressResolver;
+import io.netty.resolver.AddressResolverGroup;
+import io.netty.util.concurrent.EventExecutor;
+import io.netty.util.internal.StringUtil;
+
+import java.net.InetSocketAddress;
+
+import static io.netty.resolver.dns.DnsNameResolver.ANY_LOCAL_ADDR;
+
+/**
+ * A {@link AddressResolverGroup} of {@link DnsNameResolver}s.
+ */
+public class DnsAddressResolverGroup extends AddressResolverGroup<InetSocketAddress> {
+
+    private final ChannelFactory<? extends DatagramChannel> channelFactory;
+    private final InetSocketAddress localAddress;
+    private final DnsServerAddresses nameServerAddresses;
+
+    public DnsAddressResolverGroup(
+            Class<? extends DatagramChannel> channelType, DnsServerAddresses nameServerAddresses) {
+        this(channelType, ANY_LOCAL_ADDR, nameServerAddresses);
+    }
+
+    public DnsAddressResolverGroup(
+            Class<? extends DatagramChannel> channelType,
+            InetSocketAddress localAddress, DnsServerAddresses nameServerAddresses) {
+        this(new ReflectiveChannelFactory<DatagramChannel>(channelType), localAddress, nameServerAddresses);
+    }
+
+    public DnsAddressResolverGroup(
+            ChannelFactory<? extends DatagramChannel> channelFactory, DnsServerAddresses nameServerAddresses) {
+        this(channelFactory, ANY_LOCAL_ADDR, nameServerAddresses);
+    }
+
+    public DnsAddressResolverGroup(
+            ChannelFactory<? extends DatagramChannel> channelFactory,
+            InetSocketAddress localAddress, DnsServerAddresses nameServerAddresses) {
+        this.channelFactory = channelFactory;
+        this.localAddress = localAddress;
+        this.nameServerAddresses = nameServerAddresses;
+    }
+
+    @Override
+    protected final AddressResolver<InetSocketAddress> newResolver(EventExecutor executor) throws Exception {
+        if (!(executor instanceof EventLoop)) {
+            throw new IllegalStateException(
+                    "unsupported executor type: " + StringUtil.simpleClassName(executor) +
+                    " (expected: " + StringUtil.simpleClassName(EventLoop.class));
+        }
+
+        return newResolver((EventLoop) executor, channelFactory, localAddress, nameServerAddresses);
+    }
+
+    /**
+     * Creates a new {@link DnsNameResolver}. Override this method to create an alternative {@link DnsNameResolver}
+     * implementation or override the default configuration.
+     */
+    protected AddressResolver<InetSocketAddress> newResolver(
+            EventLoop eventLoop, ChannelFactory<? extends DatagramChannel> channelFactory,
+            InetSocketAddress localAddress, DnsServerAddresses nameServerAddresses) throws Exception {
+
+        return new DefaultDnsNameResolverBuilder(eventLoop)
+                .channelFactory(channelFactory)
+                .localAddress(localAddress)
+                .nameServerAddresses(nameServerAddresses)
+                .build()
+                .asAddressResolver();
+    }
+}
diff --git a/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCache.java b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCache.java
new file mode 100644
index 000000000..276cb5af8
--- /dev/null
+++ b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCache.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.resolver.dns;
+
+import io.netty.channel.EventLoop;
+
+import java.net.InetAddress;
+import java.util.List;
+
+/**
+ * A cache for DNS resolution entries.
+ */
+public interface DnsCache {
+
+    /**
+     * Clears all the resolved addresses cached by this resolver.
+     *
+     * @return {@code this}
+     *
+     * @see #clear(String)
+     */
+    void clear();
+
+    /**
+     * Clears the resolved addresses of the specified host name from the cache of this resolver.
+     *
+     * @return {@code true} if and only if there was an entry for the specified host name in the cache and
+     *         it has been removed by this method
+     */
+    boolean clear(String hostname);
+
+    /**
+     * Return the cached entries for the given hostname.
+     * @param hostname the hostname
+     * @return the cached entries
+     */
+    List<DnsCacheEntry> get(String hostname);
+
+    /**
+     * Cache a resolved address for a given hostname.
+     * @param hostname the hostname
+     * @param address the resolved adresse
+     * @param originalTtl the TLL as returned by the DNS server
+     * @param loop the {@link EventLoop} used to register the TTL timeout
+     */
+    void cache(String hostname, InetAddress address, long originalTtl, EventLoop loop);
+
+    /**
+     * Cache the resolution failure for a given hostname.
+     * @param hostname the hostname
+     * @param cause the resolution failure
+     * @param loop the {@link EventLoop} used to register the TTL timeout
+     */
+    void cache(String hostname, Throwable cause, EventLoop loop);
+}
diff --git a/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCacheEntry.java b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCacheEntry.java
new file mode 100644
index 000000000..789ef7ab8
--- /dev/null
+++ b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCacheEntry.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.resolver.dns;
+
+import static io.netty.util.internal.ObjectUtil.checkNotNull;
+
+import io.netty.channel.EventLoop;
+import io.netty.util.concurrent.ScheduledFuture;
+
+import java.net.InetAddress;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Entry in {@link DnsCache}.
+ */
+public final class DnsCacheEntry {
+
+    private final String hostname;
+    private final InetAddress address;
+    private final Throwable cause;
+    private volatile ScheduledFuture<?> expirationFuture;
+
+    public DnsCacheEntry(String hostname, InetAddress address) {
+        this.hostname = checkNotNull(hostname, "hostname");
+        this.address = checkNotNull(address, "address");
+        cause = null;
+    }
+
+    public DnsCacheEntry(String hostname, Throwable cause) {
+        this.hostname = checkNotNull(hostname, "hostname");
+        this.cause = checkNotNull(cause, "cause");
+        address = null;
+    }
+
+    public String hostname() {
+        return hostname;
+    }
+
+    public InetAddress address() {
+        return address;
+    }
+
+    public Throwable cause() {
+        return cause;
+    }
+
+    void scheduleExpiration(EventLoop loop, Runnable task, long delay, TimeUnit unit) {
+        assert expirationFuture == null: "expiration task scheduled already";
+        expirationFuture = loop.schedule(task, delay, unit);
+    }
+
+    void cancelExpiration() {
+        ScheduledFuture<?> expirationFuture = this.expirationFuture;
+        if (expirationFuture != null) {
+            expirationFuture.cancel(false);
+        }
+    }
+
+    @Override
+    public String toString() {
+        if (cause != null) {
+            return hostname + '/' + cause;
+        } else {
+            return address.toString();
+        }
+    }
+}
diff --git a/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java
new file mode 100644
index 000000000..581fc6ab3
--- /dev/null
+++ b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java
@@ -0,0 +1,594 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.resolver.dns;
+
+import io.netty.bootstrap.Bootstrap;
+import io.netty.channel.AddressedEnvelope;
+import io.netty.bootstrap.ChannelFactory;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelFutureListener;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.ChannelInitializer;
+import io.netty.channel.EventLoop;
+import io.netty.channel.FixedRecvByteBufAllocator;
+import io.netty.channel.socket.DatagramChannel;
+import io.netty.channel.socket.InternetProtocolFamily;
+import io.netty.handler.codec.dns.DatagramDnsQueryEncoder;
+import io.netty.handler.codec.dns.DatagramDnsResponse;
+import io.netty.handler.codec.dns.DatagramDnsResponseDecoder;
+import io.netty.handler.codec.dns.DnsQuestion;
+import io.netty.handler.codec.dns.DnsResponse;
+import io.netty.resolver.HostsFileEntriesResolver;
+import io.netty.resolver.InetNameResolver;
+import io.netty.util.NetUtil;
+import io.netty.util.ReferenceCountUtil;
+import io.netty.util.concurrent.FastThreadLocal;
+import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.Promise;
+import io.netty.util.internal.logging.InternalLogger;
+import io.netty.util.internal.logging.InternalLoggerFactory;
+
+import java.net.IDN;
+import java.net.Inet4Address;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
+import static io.netty.util.internal.ObjectUtil2.*;
+
+/**
+ * A DNS-based {@link InetNameResolver}.
+ */
+public class DnsNameResolver extends InetNameResolver {
+
+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(DnsNameResolver.class);
+
+    static final InetSocketAddress ANY_LOCAL_ADDR = new InetSocketAddress(0);
+
+    static final InternetProtocolFamily[] DEFAULT_RESOLVE_ADDRESS_TYPES = new InternetProtocolFamily[2];
+
+    static {
+        // Note that we did not use SystemPropertyUtil.getBoolean() here to emulate the behavior of JDK.
+        if (Boolean.getBoolean("java.net.preferIPv6Addresses")) {
+            DEFAULT_RESOLVE_ADDRESS_TYPES[0] = InternetProtocolFamily.IPv6;
+            DEFAULT_RESOLVE_ADDRESS_TYPES[1] = InternetProtocolFamily.IPv4;
+            logger.debug("-Djava.net.preferIPv6Addresses: true");
+        } else {
+            DEFAULT_RESOLVE_ADDRESS_TYPES[0] = InternetProtocolFamily.IPv4;
+            DEFAULT_RESOLVE_ADDRESS_TYPES[1] = InternetProtocolFamily.IPv6;
+            logger.debug("-Djava.net.preferIPv6Addresses: false");
+        }
+    }
+
+    private static final DatagramDnsResponseDecoder DECODER = new DatagramDnsResponseDecoder();
+    private static final DatagramDnsQueryEncoder ENCODER = new DatagramDnsQueryEncoder();
+
+    final DnsServerAddresses nameServerAddresses;
+    final ChannelFuture bindFuture;
+    final DatagramChannel ch;
+
+    /**
+     * Manages the {@link DnsQueryContext}s in progress and their query IDs.
+     */
+    final DnsQueryContextManager queryContextManager = new DnsQueryContextManager();
+
+    /**
+     * Cache for {@link #doResolve(String, Promise)} and {@link #doResolveAll(String, Promise)}.
+     */
+    private final DnsCache resolveCache;
+
+    private final FastThreadLocal<DnsServerAddressStream> nameServerAddrStream =
+            new FastThreadLocal<DnsServerAddressStream>() {
+                @Override
+                protected DnsServerAddressStream initialValue() throws Exception {
+                    return nameServerAddresses.stream();
+                }
+            };
+
+    private final long queryTimeoutMillis;
+    private final int maxQueriesPerResolve;
+    private final boolean traceEnabled;
+    private final InternetProtocolFamily[] resolvedAddressTypes;
+    private final boolean recursionDesired;
+    private final int maxPayloadSize;
+    private final boolean optResourceEnabled;
+    private final HostsFileEntriesResolver hostsFileEntriesResolver;
+
+    /**
+     * Creates a new DNS-based name resolver that communicates with the specified list of DNS servers.
+     *
+     * @param eventLoop the {@link EventLoop} which will perform the communication with the DNS servers
+     * @param channelFactory the {@link ChannelFactory} that will create a {@link DatagramChannel}
+     * @param localAddress the local address of the {@link DatagramChannel}
+     * @param nameServerAddresses the addresses of the DNS server. For each DNS query, a new stream is created from
+     *                            this to determine which DNS server should be contacted for the next retry in case
+     *                            of failure.
+     * @param resolveCache the DNS resolved entries cache
+     * @param queryTimeoutMillis timeout of each DNS query in millis
+     * @param resolvedAddressTypes list of the protocol families
+     * @param recursionDesired if recursion desired flag must be set
+     * @param maxQueriesPerResolve the maximum allowed number of DNS queries for a given name resolution
+     * @param traceEnabled if trace is enabled
+     * @param maxPayloadSize the capacity of the datagram packet buffer
+     * @param optResourceEnabled if automatic inclusion of a optional records is enabled
+     * @param hostsFileEntriesResolver the {@link HostsFileEntriesResolver} used to check for local aliases
+     */
+    public DnsNameResolver(
+            EventLoop eventLoop,
+            ChannelFactory<? extends DatagramChannel> channelFactory,
+            InetSocketAddress localAddress,
+            DnsServerAddresses nameServerAddresses,
+            DnsCache resolveCache,
+            long queryTimeoutMillis,
+            InternetProtocolFamily[] resolvedAddressTypes,
+            boolean recursionDesired,
+            int maxQueriesPerResolve,
+            boolean traceEnabled,
+            int maxPayloadSize,
+            boolean optResourceEnabled,
+            HostsFileEntriesResolver hostsFileEntriesResolver) {
+
+        super(eventLoop);
+        checkNotNull(channelFactory, "channelFactory");
+        checkNotNull(localAddress, "localAddress");
+        this.nameServerAddresses = checkNotNull(nameServerAddresses, "nameServerAddresses");
+        this.queryTimeoutMillis = checkPositive(queryTimeoutMillis, "queryTimeoutMillis");
+        this.resolvedAddressTypes = checkNonEmpty(resolvedAddressTypes, "resolvedAddressTypes");
+        this.recursionDesired = recursionDesired;
+        this.maxQueriesPerResolve = checkPositive(maxQueriesPerResolve, "maxQueriesPerResolve");
+        this.traceEnabled = traceEnabled;
+        this.maxPayloadSize = checkPositive(maxPayloadSize, "maxPayloadSize");
+        this.optResourceEnabled = optResourceEnabled;
+        this.hostsFileEntriesResolver = checkNotNull(hostsFileEntriesResolver, "hostsFileEntriesResolver");
+        this.resolveCache = resolveCache;
+
+        bindFuture = newChannel(channelFactory, localAddress);
+        ch = (DatagramChannel) bindFuture.channel();
+        ch.config().setRecvByteBufAllocator(new FixedRecvByteBufAllocator(maxPayloadSize));
+    }
+
+    private ChannelFuture newChannel(
+            ChannelFactory<? extends DatagramChannel> channelFactory, InetSocketAddress localAddress) {
+
+        Bootstrap b = new Bootstrap();
+        b.group(executor());
+        b.channelFactory(channelFactory);
+        final DnsResponseHandler responseHandler = new DnsResponseHandler();
+        b.handler(new ChannelInitializer<DatagramChannel>() {
+            @Override
+            protected void initChannel(DatagramChannel ch) throws Exception {
+                ch.pipeline().addLast(DECODER, ENCODER, responseHandler);
+            }
+        });
+
+        ChannelFuture bindFuture = b.bind(localAddress);
+        bindFuture.channel().closeFuture().addListener(new ChannelFutureListener() {
+            @Override
+            public void operationComplete(ChannelFuture future) throws Exception {
+                resolveCache.clear();
+            }
+        });
+
+        return bindFuture;
+    }
+
+    /**
+     * Returns the resolution cache.
+     */
+    public DnsCache resolveCache() {
+        return resolveCache;
+    }
+
+    /**
+     * Returns the timeout of each DNS query performed by this resolver (in milliseconds).
+     * The default value is 5 seconds.
+     */
+    public long queryTimeoutMillis() {
+        return queryTimeoutMillis;
+    }
+
+    /**
+     * Returns the list of the protocol families of the address resolved by {@link #resolve(String)}
+     * in the order of preference.
+     * The default value depends on the value of the system property {@code "java.net.preferIPv6Addresses"}.
+     */
+    public List<InternetProtocolFamily> resolvedAddressTypes() {
+        return Arrays.asList(resolvedAddressTypes);
+    }
+
+    InternetProtocolFamily[] resolveAddressTypesUnsafe() {
+        return resolvedAddressTypes;
+    }
+
+    /**
+     * Returns {@code true} if and only if this resolver sends a DNS query with the RD (recursion desired) flag set.
+     * The default value is {@code true}.
+     */
+    public boolean isRecursionDesired() {
+        return recursionDesired;
+    }
+
+    /**
+     * Returns the maximum allowed number of DNS queries to send when resolving a host name.
+     * The default value is {@code 8}.
+     */
+    public int maxQueriesPerResolve() {
+        return maxQueriesPerResolve;
+    }
+
+    /**
+     * Returns if this resolver should generate the detailed trace information in an exception message so that
+     * it is easier to understand the cause of resolution failure. The default value if {@code true}.
+     */
+    public boolean isTraceEnabled() {
+        return traceEnabled;
+    }
+
+    /**
+     * Returns the capacity of the datagram packet buffer (in bytes).  The default value is {@code 4096} bytes.
+     */
+    public int maxPayloadSize() {
+        return maxPayloadSize;
+    }
+
+    /**
+     * Returns the automatic inclusion of a optional records that tries to give the remote DNS server a hint about how
+     * much data the resolver can read per response is enabled.
+     */
+    public boolean isOptResourceEnabled() {
+        return optResourceEnabled;
+    }
+
+    /**
+     * Returns the component that tries to resolve hostnames against the hosts file prior to asking to
+     * remotes DNS servers.
+     */
+    public HostsFileEntriesResolver hostsFileEntriesResolver() {
+        return hostsFileEntriesResolver;
+    }
+
+    /**
+     * Closes the internal datagram channel used for sending and receiving DNS messages, and clears all DNS resource
+     * records from the cache. Attempting to send a DNS query or to resolve a domain name will fail once this method
+     * has been called.
+     */
+    @Override
+    public void close() {
+        ch.close();
+    }
+
+    @Override
+    protected EventLoop executor() {
+        return (EventLoop) super.executor();
+    }
+
+    private InetAddress resolveHostsFileEntry(String hostname) {
+        return hostsFileEntriesResolver != null ? hostsFileEntriesResolver.address(hostname) : null;
+    }
+
+    @Override
+    protected void doResolve(String inetHost, Promise<InetAddress> promise) throws Exception {
+        doResolve(inetHost, promise, resolveCache);
+    }
+
+    /**
+     * Hook designed for extensibility so one can pass a different cache on each resolution attempt
+     * instead of using the global one.
+     */
+    protected void doResolve(String inetHost,
+                             Promise<InetAddress> promise,
+                             DnsCache resolveCache) throws Exception {
+        final byte[] bytes = NetUtil.createByteArrayFromIpAddressString(inetHost);
+        if (bytes != null) {
+            // The inetHost is actually an ipaddress.
+            promise.setSuccess(InetAddress.getByAddress(bytes));
+            return;
+        }
+
+        final String hostname = hostname(inetHost);
+
+        InetAddress hostsFileEntry = resolveHostsFileEntry(hostname);
+        if (hostsFileEntry != null) {
+            promise.setSuccess(hostsFileEntry);
+            return;
+        }
+
+        if (!doResolveCached(hostname, promise, resolveCache)) {
+            doResolveUncached(hostname, promise, resolveCache);
+        }
+    }
+
+    private boolean doResolveCached(String hostname,
+                                    Promise<InetAddress> promise,
+                                    DnsCache resolveCache) {
+        final List<DnsCacheEntry> cachedEntries = resolveCache.get(hostname);
+        if (cachedEntries == null) {
+            return false;
+        }
+
+        InetAddress address = null;
+        Throwable cause = null;
+        synchronized (cachedEntries) {
+            final int numEntries = cachedEntries.size();
+            assert numEntries > 0;
+
+            if (cachedEntries.get(0).cause() != null) {
+                cause = cachedEntries.get(0).cause();
+            } else {
+                // Find the first entry with the preferred address type.
+                for (InternetProtocolFamily f : resolvedAddressTypes) {
+                    for (int i = 0; i < numEntries; i++) {
+                        final DnsCacheEntry e = cachedEntries.get(i);
+                        if (addressMatchFamily(e.address(), f)) {
+                            address = e.address();
+                            break;
+                        }
+                    }
+                }
+            }
+        }
+
+        if (address != null) {
+            setSuccess(promise, address);
+        } else if (cause != null) {
+            if (!promise.tryFailure(cause)) {
+                logger.warn("Failed to notify failure to a promise: {}", promise, cause);
+            }
+        } else {
+            return false;
+        }
+
+        return true;
+    }
+
+    private static void setSuccess(Promise<InetAddress> promise, InetAddress result) {
+        if (!promise.trySuccess(result)) {
+            logger.warn("Failed to notify success ({}) to a promise: {}", result, promise);
+        }
+    }
+
+    private void doResolveUncached(String hostname,
+                                   Promise<InetAddress> promise,
+                                   DnsCache resolveCache) {
+        final DnsNameResolverContext<InetAddress> ctx =
+                new DnsNameResolverContext<InetAddress>(this, hostname, promise, resolveCache) {
+                    @Override
+                    protected boolean finishResolve(
+                            InternetProtocolFamily f, List<DnsCacheEntry> resolvedEntries) {
+
+                        final int numEntries = resolvedEntries.size();
+                        for (int i = 0; i < numEntries; i++) {
+                            final InetAddress a = resolvedEntries.get(i).address();
+                            if (addressMatchFamily(a, f)) {
+                                setSuccess(promise(), a);
+                                return true;
+                            }
+                        }
+                        return false;
+                    }
+                };
+
+        ctx.resolve();
+    }
+
+    @Override
+    protected void doResolveAll(String inetHost, Promise<List<InetAddress>> promise) throws Exception {
+        doResolveAll(inetHost, promise, resolveCache);
+    }
+
+    /**
+     * Hook designed for extensibility so one can pass a different cache on each resolution attempt
+     * instead of using the global one.
+     */
+    protected void doResolveAll(String inetHost,
+                                Promise<List<InetAddress>> promise,
+                                DnsCache resolveCache) throws Exception {
+
+        final byte[] bytes = NetUtil.createByteArrayFromIpAddressString(inetHost);
+        if (bytes != null) {
+            // The unresolvedAddress was created via a String that contains an ipaddress.
+            promise.setSuccess(Collections.singletonList(InetAddress.getByAddress(bytes)));
+            return;
+        }
+
+        final String hostname = hostname(inetHost);
+
+        InetAddress hostsFileEntry = resolveHostsFileEntry(hostname);
+        if (hostsFileEntry != null) {
+            promise.setSuccess(Collections.singletonList(hostsFileEntry));
+            return;
+        }
+
+        if (!doResolveAllCached(hostname, promise, resolveCache)) {
+            doResolveAllUncached(hostname, promise, resolveCache);
+        }
+    }
+
+    private boolean doResolveAllCached(String hostname,
+                                       Promise<List<InetAddress>> promise,
+                                       DnsCache resolveCache) {
+        final List<DnsCacheEntry> cachedEntries = resolveCache.get(hostname);
+        if (cachedEntries == null) {
+            return false;
+        }
+
+        List<InetAddress> result = null;
+        Throwable cause = null;
+        synchronized (cachedEntries) {
+            final int numEntries = cachedEntries.size();
+            assert numEntries > 0;
+
+            if (cachedEntries.get(0).cause() != null) {
+                cause = cachedEntries.get(0).cause();
+            } else {
+                for (InternetProtocolFamily f : resolvedAddressTypes) {
+                    for (int i = 0; i < numEntries; i++) {
+                        final DnsCacheEntry e = cachedEntries.get(i);
+                        if (addressMatchFamily(e.address(), f)) {
+                            if (result == null) {
+                                result = new ArrayList<InetAddress>(numEntries);
+                            }
+                            result.add(e.address());
+                        }
+                    }
+                }
+            }
+        }
+
+        if (result != null) {
+            promise.trySuccess(result);
+        } else if (cause != null) {
+            promise.tryFailure(cause);
+        } else {
+            return false;
+        }
+
+        return true;
+    }
+
+    private void doResolveAllUncached(final String hostname,
+                                      final Promise<List<InetAddress>> promise,
+                                      DnsCache resolveCache) {
+        final DnsNameResolverContext<List<InetAddress>> ctx =
+                new DnsNameResolverContext<List<InetAddress>>(this, hostname, promise, resolveCache) {
+                    @Override
+                    protected boolean finishResolve(
+                            InternetProtocolFamily f, List<DnsCacheEntry> resolvedEntries) {
+
+                        List<InetAddress> result = null;
+                        final int numEntries = resolvedEntries.size();
+                        for (int i = 0; i < numEntries; i++) {
+                            final InetAddress a = resolvedEntries.get(i).address();
+                            if (addressMatchFamily(a, f)) {
+                                if (result == null) {
+                                    result = new ArrayList<InetAddress>(numEntries);
+                                }
+                                result.add(a);
+                            }
+                        }
+
+                        if (result != null) {
+                            promise().trySuccess(result);
+                            return true;
+                        }
+                        return false;
+                    }
+                };
+
+        ctx.resolve();
+    }
+
+    private static String hostname(String inetHost) {
+        return IDN.toASCII(inetHost);
+    }
+
+    /**
+     * Sends a DNS query with the specified question.
+     */
+    public Future<AddressedEnvelope<DnsResponse, InetSocketAddress>> query(DnsQuestion question) {
+        return query(nextNameServerAddress(), question);
+    }
+
+    /**
+     * Sends a DNS query with the specified question.
+     */
+    public Future<AddressedEnvelope<DnsResponse, InetSocketAddress>> query(
+            DnsQuestion question, Promise<AddressedEnvelope<? extends DnsResponse, InetSocketAddress>> promise) {
+        return query(nextNameServerAddress(), question, promise);
+    }
+
+    private InetSocketAddress nextNameServerAddress() {
+        return nameServerAddrStream.get().next();
+    }
+
+    /**
+     * Sends a DNS query with the specified question using the specified name server list.
+     */
+    public Future<AddressedEnvelope<DnsResponse, InetSocketAddress>> query(
+            InetSocketAddress nameServerAddr, DnsQuestion question) {
+
+        return query0(checkNotNull(nameServerAddr, "nameServerAddr"),
+                      checkNotNull(question, "question"),
+                      ch.eventLoop().<AddressedEnvelope<? extends DnsResponse, InetSocketAddress>>newPromise());
+    }
+
+    /**
+     * Sends a DNS query with the specified question using the specified name server list.
+     */
+    public Future<AddressedEnvelope<DnsResponse, InetSocketAddress>> query(
+            InetSocketAddress nameServerAddr, DnsQuestion question,
+            Promise<AddressedEnvelope<? extends DnsResponse, InetSocketAddress>> promise) {
+
+        return query0(checkNotNull(nameServerAddr, "nameServerAddr"),
+                      checkNotNull(question, "question"),
+                      checkNotNull(promise, "promise"));
+    }
+
+    private Future<AddressedEnvelope<DnsResponse, InetSocketAddress>> query0(
+            InetSocketAddress nameServerAddr, DnsQuestion question,
+            Promise<AddressedEnvelope<? extends DnsResponse, InetSocketAddress>> promise) {
+
+        final Promise<AddressedEnvelope<DnsResponse, InetSocketAddress>> castPromise = cast(promise);
+        try {
+            new DnsQueryContext(this, nameServerAddr, question, castPromise).query();
+            return castPromise;
+        } catch (Exception e) {
+            return castPromise.setFailure(e);
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    private static Promise<AddressedEnvelope<DnsResponse, InetSocketAddress>> cast(Promise<?> promise) {
+        return (Promise<AddressedEnvelope<DnsResponse, InetSocketAddress>>) promise;
+    }
+
+    private final class DnsResponseHandler extends ChannelInboundHandlerAdapter {
+        @Override
+        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
+            try {
+                final DatagramDnsResponse res = (DatagramDnsResponse) msg;
+                final int queryId = res.id();
+
+                if (logger.isDebugEnabled()) {
+                    logger.debug("{} RECEIVED: [{}: {}], {}", ch, queryId, res.sender(), res);
+                }
+
+                final DnsQueryContext qCtx = queryContextManager.get(res.sender(), queryId);
+                if (qCtx == null) {
+                    logger.warn("{} Received a DNS response with an unknown ID: {}", ch, queryId);
+                    return;
+                }
+
+                qCtx.finish(res);
+            } finally {
+                ReferenceCountUtil.safeRelease(msg);
+            }
+        }
+
+        @Override
+        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
+            logger.warn("{} Unexpected exception: ", ch, cause);
+        }
+    }
+
+    static boolean addressMatchFamily(InetAddress a, InternetProtocolFamily f) {
+        return (f == InternetProtocolFamily.IPv4 && a instanceof Inet4Address) || f == InternetProtocolFamily.IPv6;
+    }
+}
diff --git a/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java
new file mode 100644
index 000000000..586710163
--- /dev/null
+++ b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java
@@ -0,0 +1,324 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.resolver.dns;
+
+import static io.netty.util.internal.ObjectUtil2.*;
+import io.netty.bootstrap.ChannelFactory;
+import io.netty.channel.EventLoop;
+import io.netty.channel.ReflectiveChannelFactory;
+import io.netty.channel.socket.DatagramChannel;
+import io.netty.channel.socket.InternetProtocolFamily;
+import io.netty.resolver.HostsFileEntriesResolver;
+
+import java.net.InetSocketAddress;
+import java.util.ArrayList;
+import java.util.List;
+
+import static io.netty.util.internal.ObjectUtil.checkNotNull;
+
+/**
+ * A {@link DnsNameResolver} builder.
+ */
+public abstract class DnsNameResolverBuilder<T extends DnsNameResolverBuilder<T>> {
+
+    protected final EventLoop eventLoop;
+    protected ChannelFactory<? extends DatagramChannel> channelFactory;
+    protected InetSocketAddress localAddress = DnsNameResolver.ANY_LOCAL_ADDR;
+    protected DnsServerAddresses nameServerAddresses = DnsServerAddresses.defaultAddresses();
+    protected DnsCache resolveCache;
+    protected Integer minTtl;
+    protected Integer maxTtl;
+    protected Integer negativeTtl;
+    protected long queryTimeoutMillis = 5000;
+    protected InternetProtocolFamily[] resolvedAddressTypes = DnsNameResolver.DEFAULT_RESOLVE_ADDRESS_TYPES;
+    protected boolean recursionDesired = true;
+    protected int maxQueriesPerResolve = 3;
+    protected boolean traceEnabled;
+    protected int maxPayloadSize = 4096;
+    protected boolean optResourceEnabled = true;
+    protected HostsFileEntriesResolver hostsFileEntriesResolver = HostsFileEntriesResolver.DEFAULT;
+
+    /**
+     * Creates a new builder.
+     *
+     * @param eventLoop the {@link EventLoop} the {@link EventLoop} which will perform the communication with the DNS
+     * servers.
+     */
+    public DnsNameResolverBuilder(EventLoop eventLoop) {
+        this.eventLoop = eventLoop;
+    }
+
+    @SuppressWarnings("unchecked")
+    private T cast() {
+        return (T) this;
+    }
+    
+    /**
+     * Sets the {@link ChannelFactory} that will create a {@link DatagramChannel}.
+     *
+     * @param channelFactory the {@link ChannelFactory}
+     * @return {@code this}
+     */
+    public T channelFactory(ChannelFactory<? extends DatagramChannel> channelFactory) {
+        this.channelFactory = channelFactory;
+        return cast();
+    }
+
+    /**
+     * Sets the {@link ChannelFactory} as a {@link ReflectiveChannelFactory} of this type.
+     * Use as an alternative to {@link #channelFactory(ChannelFactory)}.
+     *
+     * @param channelType
+     * @return {@code this}
+     */
+    public T channelType(Class<? extends DatagramChannel> channelType) {
+        return channelFactory(new ReflectiveChannelFactory<DatagramChannel>(channelType));
+    }
+
+    /**
+     * Sets the local address of the {@link DatagramChannel}
+     *
+     * @param localAddress the local address
+     * @return {@code this}
+     */
+    public T localAddress(InetSocketAddress localAddress) {
+        this.localAddress = localAddress;
+        return cast();
+    }
+
+    /**
+     * Sets the addresses of the DNS server.
+     *
+     * @param nameServerAddresses the DNS server addresses
+     * @return {@code this}
+     */
+    public T nameServerAddresses(DnsServerAddresses nameServerAddresses) {
+        this.nameServerAddresses = nameServerAddresses;
+        return cast();
+    }
+
+    /**
+     * Sets the cache for resolution results.
+     *
+     * @param resolveCache the DNS resolution results cache
+     * @return {@code this}
+     */
+    public T resolveCache(DnsCache resolveCache) {
+        this.resolveCache  = resolveCache;
+        return cast();
+    }
+
+    /**
+     * Sets the minimum and maximum TTL of the cached DNS resource records (in seconds). If the TTL of the DNS
+     * resource record returned by the DNS server is less than the minimum TTL or greater than the maximum TTL,
+     * this resolver will ignore the TTL from the DNS server and use the minimum TTL or the maximum TTL instead
+     * respectively.
+     * The default value is {@code 0} and {@link Integer#MAX_VALUE}, which practically tells this resolver to
+     * respect the TTL from the DNS server.
+     *
+     * @param minTtl the minimum TTL
+     * @param maxTtl the maximum TTL
+     * @return {@code this}
+     */
+    public T ttl(int minTtl, int maxTtl) {
+        this.maxTtl = maxTtl;
+        this.minTtl = minTtl;
+        return cast();
+    }
+
+    /**
+     * Sets the TTL of the cache for the failed DNS queries (in seconds).
+     *
+     * @param negativeTtl the TTL for failed cached queries
+     * @return {@code this}
+     */
+    public T negativeTtl(int negativeTtl) {
+        this.negativeTtl = negativeTtl;
+        return cast();
+    }
+
+    /**
+     * Sets the timeout of each DNS query performed by this resolver (in milliseconds).
+     *
+     * @param queryTimeoutMillis the query timeout
+     * @return {@code this}
+     */
+    public T queryTimeoutMillis(long queryTimeoutMillis) {
+        this.queryTimeoutMillis = queryTimeoutMillis;
+        return cast();
+    }
+
+    /**
+     * Sets the list of the protocol families of the address resolved.
+     * Usually, both {@link InternetProtocolFamily#IPv4} and {@link InternetProtocolFamily#IPv6} are specified in
+     * the order of preference.  To enforce the resolve to retrieve the address of a specific protocol family,
+     * specify only a single {@link InternetProtocolFamily}.
+     *
+     * @param resolvedAddressTypes the address types
+     * @return {@code this}
+     */
+    public T resolvedAddressTypes(InternetProtocolFamily... resolvedAddressTypes) {
+        checkNotNull(resolvedAddressTypes, "resolvedAddressTypes");
+
+        final List<InternetProtocolFamily> list =
+                new ArrayList<InternetProtocolFamily>(InternetProtocolFamily.values().length);
+
+        for (InternetProtocolFamily f : resolvedAddressTypes) {
+            if (f == null) {
+                break;
+            }
+
+            // Avoid duplicate entries.
+            if (list.contains(f)) {
+                continue;
+            }
+
+            list.add(f);
+        }
+
+        if (list.isEmpty()) {
+            throw new IllegalArgumentException("no protocol family specified");
+        }
+
+        this.resolvedAddressTypes = list.toArray(new InternetProtocolFamily[list.size()]);
+
+        return cast();
+    }
+
+    /**
+     * Sets the list of the protocol families of the address resolved.
+     * Usually, both {@link InternetProtocolFamily#IPv4} and {@link InternetProtocolFamily#IPv6} are specified in
+     * the order of preference.  To enforce the resolve to retrieve the address of a specific protocol family,
+     * specify only a single {@link InternetProtocolFamily}.
+     *
+     * @param resolvedAddressTypes the address types
+     * @return {@code this}
+     */
+    public T resolvedAddressTypes(Iterable<InternetProtocolFamily> resolvedAddressTypes) {
+        checkNotNull(resolvedAddressTypes, "resolveAddressTypes");
+
+        final List<InternetProtocolFamily> list =
+                new ArrayList<InternetProtocolFamily>(InternetProtocolFamily.values().length);
+
+        for (InternetProtocolFamily f : resolvedAddressTypes) {
+            if (f == null) {
+                break;
+            }
+
+            // Avoid duplicate entries.
+            if (list.contains(f)) {
+                continue;
+            }
+
+            list.add(f);
+        }
+
+        if (list.isEmpty()) {
+            throw new IllegalArgumentException("no protocol family specified");
+        }
+
+        this.resolvedAddressTypes = list.toArray(new InternetProtocolFamily[list.size()]);
+
+        return cast();
+    }
+
+    /**
+     * Sets if this resolver has to send a DNS query with the RD (recursion desired) flag set.
+     *
+     * @param recursionDesired true if recursion is desired
+     * @return {@code this}
+     */
+    public T recursionDesired(boolean recursionDesired) {
+        this.recursionDesired = recursionDesired;
+        return cast();
+    }
+
+    /**
+     * Sets the maximum allowed number of DNS queries to send when resolving a host name.
+     *
+     * @param maxQueriesPerResolve the max number of queries
+     * @return {@code this}
+     */
+    public T maxQueriesPerResolve(int maxQueriesPerResolve) {
+        this.maxQueriesPerResolve = maxQueriesPerResolve;
+        return cast();
+    }
+
+    /**
+     * Sets if this resolver should generate the detailed trace information in an exception message so that
+     * it is easier to understand the cause of resolution failure.
+     *
+     * @param traceEnabled true if trace is enabled
+     * @return {@code this}
+     */
+    public T traceEnabled(boolean traceEnabled) {
+        this.traceEnabled = traceEnabled;
+        return cast();
+    }
+
+    /**
+     * Sets the capacity of the datagram packet buffer (in bytes).  The default value is {@code 4096} bytes.
+     *
+     * @param maxPayloadSize the capacity of the datagram packet buffer
+     * @return {@code this}
+     */
+    public T maxPayloadSize(int maxPayloadSize) {
+        this.maxPayloadSize = maxPayloadSize;
+        return cast();
+    }
+
+    /**
+     * Enable the automatic inclusion of a optional records that tries to give the remote DNS server a hint about
+     * how much data the resolver can read per response. Some DNSServer may not support this and so fail to answer
+     * queries. If you find problems you may want to disable this.
+     *
+     * @param optResourceEnabled if optional records inclusion is enabled
+     * @return {@code this}
+     */
+    public T optResourceEnabled(boolean optResourceEnabled) {
+        this.optResourceEnabled = optResourceEnabled;
+        return cast();
+    }
+
+    /**
+     * @param hostsFileEntriesResolver the {@link HostsFileEntriesResolver} used to first check
+     *                                 if the hostname is locally aliased.
+     * @return {@code this}
+     */
+    public T hostsFileEntriesResolver(HostsFileEntriesResolver hostsFileEntriesResolver) {
+        this.hostsFileEntriesResolver = hostsFileEntriesResolver;
+        return cast();
+    }
+
+    /**
+     * Returns a new {@link DnsNameResolver} instance.
+     *
+     * @return a {@link DnsNameResolver}
+     */
+    public DnsNameResolver build() {
+
+        if (resolveCache != null && (minTtl != null || maxTtl != null || negativeTtl != null)) {
+            throw new IllegalStateException("resolveCache and TTLs are mutually exclusive");
+        }
+
+        DnsCache cache = resolveCache != null ? resolveCache :
+                new DefaultDnsCache(intValue(minTtl, 0), intValue(maxTtl, Integer.MAX_VALUE), intValue(negativeTtl, 0));
+
+        return build0(cache);
+    }
+    
+    protected abstract DnsNameResolver build0(DnsCache cache);
+}
diff --git a/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverContext.java b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverContext.java
new file mode 100644
index 000000000..3a548d60c
--- /dev/null
+++ b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverContext.java
@@ -0,0 +1,537 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.resolver.dns;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufHolder;
+import io.netty.channel.AddressedEnvelope;
+import io.netty.channel.socket.InternetProtocolFamily;
+import io.netty.handler.codec.dns.DefaultDnsQuestion;
+import io.netty.handler.codec.dns.DefaultDnsRecordDecoder;
+import io.netty.handler.codec.dns.DnsResponseCode;
+import io.netty.handler.codec.dns.DnsSection;
+import io.netty.handler.codec.dns.DnsQuestion;
+import io.netty.handler.codec.dns.DnsRawRecord;
+import io.netty.handler.codec.dns.DnsRecord;
+import io.netty.handler.codec.dns.DnsRecordType;
+import io.netty.handler.codec.dns.DnsResponse;
+import io.netty.util.CharsetUtil;
+import io.netty.util.ReferenceCountUtil;
+import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.FutureListener;
+import io.netty.util.concurrent.Promise;
+import io.netty.util.internal.StringUtil;
+
+import java.net.Inet4Address;
+import java.net.Inet6Address;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.UnknownHostException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.IdentityHashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Set;
+
+abstract class DnsNameResolverContext<T> {
+
+    private static final int INADDRSZ4 = 4;
+    private static final int INADDRSZ6 = 16;
+
+    private static final FutureListener<AddressedEnvelope<DnsResponse, InetSocketAddress>> RELEASE_RESPONSE =
+            new FutureListener<AddressedEnvelope<DnsResponse, InetSocketAddress>>() {
+                @Override
+                public void operationComplete(Future<AddressedEnvelope<DnsResponse, InetSocketAddress>> future) {
+                    if (future.isSuccess()) {
+                        future.getNow().release();
+                    }
+                }
+            };
+
+    private final DnsNameResolver parent;
+    private final DnsServerAddressStream nameServerAddrs;
+    private final Promise<T> promise;
+    private final String hostname;
+    private final DnsCache resolveCache;
+    private final boolean traceEnabled;
+    private final int maxAllowedQueries;
+    private final InternetProtocolFamily[] resolveAddressTypes;
+
+    private final Set<Future<AddressedEnvelope<DnsResponse, InetSocketAddress>>> queriesInProgress =
+            Collections.newSetFromMap(
+                    new IdentityHashMap<Future<AddressedEnvelope<DnsResponse, InetSocketAddress>>, Boolean>());
+
+    private List<DnsCacheEntry> resolvedEntries;
+    private StringBuilder trace;
+    private int allowedQueries;
+    private boolean triedCNAME;
+
+    protected DnsNameResolverContext(DnsNameResolver parent,
+                                     String hostname,
+                                     Promise<T> promise,
+                                     DnsCache resolveCache) {
+        this.parent = parent;
+        this.promise = promise;
+        this.hostname = hostname;
+        this.resolveCache = resolveCache;
+
+        nameServerAddrs = parent.nameServerAddresses.stream();
+        maxAllowedQueries = parent.maxQueriesPerResolve();
+        resolveAddressTypes = parent.resolveAddressTypesUnsafe();
+        traceEnabled = parent.isTraceEnabled();
+        allowedQueries = maxAllowedQueries;
+    }
+
+    protected Promise<T> promise() {
+        return promise;
+    }
+
+    void resolve() {
+        InetSocketAddress nameServerAddrToTry = nameServerAddrs.next();
+        for (InternetProtocolFamily f: resolveAddressTypes) {
+            final DnsRecordType type;
+            switch (f) {
+            case IPv4:
+                type = DnsRecordType.A;
+                break;
+            case IPv6:
+                type = DnsRecordType.AAAA;
+                break;
+            default:
+                throw new Error();
+            }
+
+            query(nameServerAddrToTry, new DefaultDnsQuestion(hostname, type));
+        }
+    }
+
+    private void query(InetSocketAddress nameServerAddr, final DnsQuestion question) {
+        if (allowedQueries == 0 || promise.isCancelled()) {
+            tryToFinishResolve();
+            return;
+        }
+
+        allowedQueries --;
+
+        final Future<AddressedEnvelope<DnsResponse, InetSocketAddress>> f = parent.query(nameServerAddr, question);
+        queriesInProgress.add(f);
+
+        f.addListener(new FutureListener<AddressedEnvelope<DnsResponse, InetSocketAddress>>() {
+            @Override
+            public void operationComplete(Future<AddressedEnvelope<DnsResponse, InetSocketAddress>> future) {
+                queriesInProgress.remove(future);
+
+                if (promise.isDone() || future.isCancelled()) {
+                    return;
+                }
+
+                try {
+                    if (future.isSuccess()) {
+                        onResponse(question, future.getNow());
+                    } else {
+                        // Server did not respond or I/O error occurred; try again.
+                        if (traceEnabled) {
+                            addTrace(future.cause());
+                        }
+                        query(nameServerAddrs.next(), question);
+                    }
+                } finally {
+                    tryToFinishResolve();
+                }
+            }
+        });
+    }
+
+    void onResponse(final DnsQuestion question, AddressedEnvelope<DnsResponse, InetSocketAddress> envelope) {
+        try {
+            final DnsResponse res = envelope.content();
+            final DnsResponseCode code = res.code();
+            if (code == DnsResponseCode.NOERROR) {
+                final DnsRecordType type = question.type();
+                if (type == DnsRecordType.A || type == DnsRecordType.AAAA) {
+                    onResponseAorAAAA(type, question, envelope);
+                } else if (type == DnsRecordType.CNAME) {
+                    onResponseCNAME(question, envelope);
+                }
+                return;
+            }
+
+            if (traceEnabled) {
+                addTrace(envelope.sender(),
+                         "response code: " + code + " with " + res.count(DnsSection.ANSWER) + " answer(s) and " +
+                         res.count(DnsSection.AUTHORITY) + " authority resource(s)");
+            }
+
+            // Retry with the next server if the server did not tell us that the domain does not exist.
+            if (code != DnsResponseCode.NXDOMAIN) {
+                query(nameServerAddrs.next(), question);
+            }
+        } finally {
+            ReferenceCountUtil.safeRelease(envelope);
+        }
+    }
+
+    private void onResponseAorAAAA(
+            DnsRecordType qType, DnsQuestion question, AddressedEnvelope<DnsResponse, InetSocketAddress> envelope) {
+
+        // We often get a bunch of CNAMES as well when we asked for A/AAAA.
+        final DnsResponse response = envelope.content();
+        final Map<String, String> cnames = buildAliasMap(response);
+        final int answerCount = response.count(DnsSection.ANSWER);
+
+        boolean found = false;
+        for (int i = 0; i < answerCount; i ++) {
+            final DnsRecord r = response.recordAt(DnsSection.ANSWER, i);
+            final DnsRecordType type = r.type();
+            if (type != DnsRecordType.A && type != DnsRecordType.AAAA) {
+                continue;
+            }
+
+            final String qName = question.name().toLowerCase(Locale.US);
+            final String rName = r.name().toLowerCase(Locale.US);
+
+            // Make sure the record is for the questioned domain.
+            if (!rName.equals(qName)) {
+                // Even if the record's name is not exactly same, it might be an alias defined in the CNAME records.
+                String resolved = qName;
+                do {
+                    resolved = cnames.get(resolved);
+                    if (rName.equals(resolved)) {
+                        break;
+                    }
+                } while (resolved != null);
+
+                if (resolved == null) {
+                    continue;
+                }
+            }
+
+            if (!(r instanceof DnsRawRecord)) {
+                continue;
+            }
+
+            final ByteBuf content = ((ByteBufHolder) r).content();
+            final int contentLen = content.readableBytes();
+            if (contentLen != INADDRSZ4 && contentLen != INADDRSZ6) {
+                continue;
+            }
+
+            final byte[] addrBytes = new byte[contentLen];
+            content.getBytes(content.readerIndex(), addrBytes);
+
+            final InetAddress resolved;
+            try {
+                resolved = InetAddress.getByAddress(hostname, addrBytes);
+            } catch (UnknownHostException e) {
+                // Should never reach here.
+                throw new Error(e);
+            }
+
+            if (resolvedEntries == null) {
+                resolvedEntries = new ArrayList<DnsCacheEntry>(8);
+            }
+
+            final DnsCacheEntry e = new DnsCacheEntry(hostname, resolved);
+            resolveCache.cache(hostname, resolved, r.timeToLive(), parent.ch.eventLoop());
+            resolvedEntries.add(e);
+            found = true;
+
+            // Note that we do not break from the loop here, so we decode/cache all A/AAAA records.
+        }
+
+        if (found) {
+            return;
+        }
+
+        if (traceEnabled) {
+            addTrace(envelope.sender(), "no matching " + qType + " record found");
+        }
+
+        // We aked for A/AAAA but we got only CNAME.
+        if (!cnames.isEmpty()) {
+            onResponseCNAME(question, envelope, cnames, false);
+        }
+    }
+
+    private void onResponseCNAME(DnsQuestion question, AddressedEnvelope<DnsResponse, InetSocketAddress> envelope) {
+        onResponseCNAME(question, envelope, buildAliasMap(envelope.content()), true);
+    }
+
+    private void onResponseCNAME(
+            DnsQuestion question, AddressedEnvelope<DnsResponse, InetSocketAddress> response,
+            Map<String, String> cnames, boolean trace) {
+
+        // Resolve the host name in the question into the real host name.
+        final String name = question.name().toLowerCase(Locale.US);
+        String resolved = name;
+        boolean found = false;
+        for (;;) {
+            String next = cnames.get(resolved);
+            if (next != null) {
+                found = true;
+                resolved = next;
+            } else {
+                break;
+            }
+        }
+
+        if (found) {
+            followCname(response.sender(), name, resolved);
+        } else if (trace && traceEnabled) {
+            addTrace(response.sender(), "no matching CNAME record found");
+        }
+    }
+
+    private static Map<String, String> buildAliasMap(DnsResponse response) {
+        final int answerCount = response.count(DnsSection.ANSWER);
+        Map<String, String> cnames = null;
+        for (int i = 0; i < answerCount; i ++) {
+            final DnsRecord r = response.recordAt(DnsSection.ANSWER, i);
+            final DnsRecordType type = r.type();
+            if (type != DnsRecordType.CNAME) {
+                continue;
+            }
+
+            if (!(r instanceof DnsRawRecord)) {
+                continue;
+            }
+
+            final ByteBuf recordContent = ((ByteBufHolder) r).content();
+            final String domainName = decodeDomainName(recordContent);
+            if (domainName == null) {
+                continue;
+            }
+
+            if (cnames == null) {
+                cnames = new HashMap<String, String>();
+            }
+
+            cnames.put(r.name().toLowerCase(Locale.US), domainName.toLowerCase(Locale.US));
+        }
+
+        return cnames != null? cnames : Collections.<String, String>emptyMap();
+    }
+
+    void tryToFinishResolve() {
+        if (!queriesInProgress.isEmpty()) {
+            // There are still some queries we did not receive responses for.
+            if (gotPreferredAddress()) {
+                // But it's OK to finish the resolution process if we got a resolved address of the preferred type.
+                finishResolve();
+            }
+
+            // We did not get any resolved address of the preferred type, so we can't finish the resolution process.
+            return;
+        }
+
+        // There are no queries left to try.
+        if (resolvedEntries == null) {
+            // .. and we could not find any A/AAAA records.
+            if (!triedCNAME) {
+                // As the last resort, try to query CNAME, just in case the name server has it.
+                triedCNAME = true;
+                query(nameServerAddrs.next(), new DefaultDnsQuestion(hostname, DnsRecordType.CNAME));
+                return;
+            }
+        }
+
+        // We have at least one resolved address or tried CNAME as the last resort..
+        finishResolve();
+    }
+
+    private boolean gotPreferredAddress() {
+        if (resolvedEntries == null) {
+            return false;
+        }
+
+        final int size = resolvedEntries.size();
+        switch (resolveAddressTypes[0]) {
+        case IPv4:
+            for (int i = 0; i < size; i ++) {
+                if (resolvedEntries.get(i).address() instanceof Inet4Address) {
+                    return true;
+                }
+            }
+            break;
+        case IPv6:
+            for (int i = 0; i < size; i ++) {
+                if (resolvedEntries.get(i).address() instanceof Inet6Address) {
+                    return true;
+                }
+            }
+            break;
+        }
+
+        return false;
+    }
+
+    private void finishResolve() {
+        if (!queriesInProgress.isEmpty()) {
+            // If there are queries in progress, we should cancel it because we already finished the resolution.
+            for (Iterator<Future<AddressedEnvelope<DnsResponse, InetSocketAddress>>> i = queriesInProgress.iterator();
+                 i.hasNext();) {
+                Future<AddressedEnvelope<DnsResponse, InetSocketAddress>> f = i.next();
+                i.remove();
+
+                if (!f.cancel(false)) {
+                    f.addListener(RELEASE_RESPONSE);
+                }
+            }
+        }
+
+        if (resolvedEntries != null) {
+            // Found at least one resolved address.
+            for (InternetProtocolFamily f: resolveAddressTypes) {
+                if (finishResolve(f, resolvedEntries)) {
+                    return;
+                }
+            }
+        }
+
+        // No resolved address found.
+        final int tries = maxAllowedQueries - allowedQueries;
+        final StringBuilder buf = new StringBuilder(64);
+
+        buf.append("failed to resolve ");
+        buf.append(hostname);
+
+        if (tries > 1) {
+            buf.append(" after ");
+            buf.append(tries);
+            if (trace != null) {
+                buf.append(" queries:");
+                buf.append(trace);
+            } else {
+                buf.append(" queries");
+            }
+        } else {
+            if (trace != null) {
+                buf.append(':');
+                buf.append(trace);
+            }
+        }
+
+        final UnknownHostException cause = new UnknownHostException(buf.toString());
+
+        resolveCache.cache(hostname, cause, parent.ch.eventLoop());
+        promise.tryFailure(cause);
+    }
+
+    protected abstract boolean finishResolve(
+            InternetProtocolFamily f, List<DnsCacheEntry> resolvedEntries);
+
+    /**
+     * Adapted from {@link DefaultDnsRecordDecoder#decodeName(ByteBuf)}.
+     */
+    static String decodeDomainName(ByteBuf buf) {
+        buf.markReaderIndex();
+        try {
+            int position = -1;
+            int checked = 0;
+            final int end = buf.writerIndex();
+            final StringBuilder name = new StringBuilder(buf.readableBytes() << 1);
+            for (int len = buf.readUnsignedByte(); buf.isReadable() && len != 0; len = buf.readUnsignedByte()) {
+                boolean pointer = (len & 0xc0) == 0xc0;
+                if (pointer) {
+                    if (position == -1) {
+                        position = buf.readerIndex() + 1;
+                    }
+
+                    final int next = (len & 0x3f) << 8 | buf.readUnsignedByte();
+                    if (next >= end) {
+                        // Should not happen.
+                        return null;
+                    }
+                    buf.readerIndex(next);
+
+                    // check for loops
+                    checked += 2;
+                    if (checked >= end) {
+                        // Name contains a loop; give up.
+                        return null;
+                    }
+                } else {
+                    name.append(buf.toString(buf.readerIndex(), len, CharsetUtil.UTF_8)).append('.');
+                    buf.skipBytes(len);
+                }
+            }
+
+            if (position != -1) {
+                buf.readerIndex(position);
+            }
+
+            if (name.length() == 0) {
+                return null;
+            }
+
+            return name.substring(0, name.length() - 1);
+        } finally {
+            buf.resetReaderIndex();
+        }
+    }
+
+    private void followCname(InetSocketAddress nameServerAddr, String name, String cname) {
+
+        if (traceEnabled) {
+            if (trace == null) {
+                trace = new StringBuilder(128);
+            }
+
+            trace.append(StringUtil.NEWLINE);
+            trace.append("\tfrom ");
+            trace.append(nameServerAddr);
+            trace.append(": ");
+            trace.append(name);
+            trace.append(" CNAME ");
+            trace.append(cname);
+        }
+
+        final InetSocketAddress nextAddr = nameServerAddrs.next();
+        query(nextAddr, new DefaultDnsQuestion(cname, DnsRecordType.A));
+        query(nextAddr, new DefaultDnsQuestion(cname, DnsRecordType.AAAA));
+    }
+
+    private void addTrace(InetSocketAddress nameServerAddr, String msg) {
+        assert traceEnabled;
+
+        if (trace == null) {
+            trace = new StringBuilder(128);
+        }
+
+        trace.append(StringUtil.NEWLINE);
+        trace.append("\tfrom ");
+        trace.append(nameServerAddr);
+        trace.append(": ");
+        trace.append(msg);
+    }
+
+    private void addTrace(Throwable cause) {
+        assert traceEnabled;
+
+        if (trace == null) {
+            trace = new StringBuilder(128);
+        }
+
+        trace.append(StringUtil.NEWLINE);
+        trace.append("Caused by: ");
+        trace.append(cause);
+    }
+}
diff --git a/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverException.java b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverException.java
new file mode 100644
index 000000000..05eb8757b
--- /dev/null
+++ b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverException.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.resolver.dns;
+
+import io.netty.handler.codec.dns.DnsQuestion;
+import io.netty.util.internal.EmptyArrays;
+import io.netty.util.internal.ObjectUtil;
+
+import java.net.InetSocketAddress;
+
+/**
+ * A {@link RuntimeException} raised when {@link DnsNameResolver} failed to perform a successful query.
+ */
+public final class DnsNameResolverException extends RuntimeException {
+
+    private static final long serialVersionUID = -8826717909627131850L;
+
+    private final InetSocketAddress remoteAddress;
+    private final DnsQuestion question;
+
+    public DnsNameResolverException(InetSocketAddress remoteAddress, DnsQuestion question, String message) {
+        super(message);
+        this.remoteAddress = validateRemoteAddress(remoteAddress);
+        this.question = validateQuestion(question);
+    }
+
+    public DnsNameResolverException(
+            InetSocketAddress remoteAddress, DnsQuestion question, String message, Throwable cause) {
+        super(message, cause);
+        this.remoteAddress = validateRemoteAddress(remoteAddress);
+        this.question = validateQuestion(question);
+    }
+
+    private static InetSocketAddress validateRemoteAddress(InetSocketAddress remoteAddress) {
+        return ObjectUtil.checkNotNull(remoteAddress, "remoteAddress");
+    }
+
+    private static DnsQuestion validateQuestion(DnsQuestion question) {
+        return ObjectUtil.checkNotNull(question, "question");
+    }
+
+    /**
+     * Returns the {@link InetSocketAddress} of the DNS query that has failed.
+     */
+    public InetSocketAddress remoteAddress() {
+        return remoteAddress;
+    }
+
+    /**
+     * Returns the {@link DnsQuestion} of the DNS query that has failed.
+     */
+    public DnsQuestion question() {
+        return question;
+    }
+
+    @Override
+    public Throwable fillInStackTrace() {
+        setStackTrace(EmptyArrays.EMPTY_STACK_TRACE);
+        return this;
+    }
+}
diff --git a/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java
new file mode 100644
index 000000000..8217c82ea
--- /dev/null
+++ b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java
@@ -0,0 +1,205 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.resolver.dns;
+
+import io.netty.buffer.Unpooled;
+import io.netty.channel.AddressedEnvelope;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelFutureListener;
+import io.netty.handler.codec.dns.DatagramDnsQuery;
+import io.netty.handler.codec.dns.DefaultDnsRawRecord;
+import io.netty.handler.codec.dns.DnsQuery;
+import io.netty.handler.codec.dns.DnsQuestion;
+import io.netty.handler.codec.dns.DnsRecord;
+import io.netty.handler.codec.dns.DnsRecordType;
+import io.netty.handler.codec.dns.DnsResponse;
+import io.netty.handler.codec.dns.DnsSection;
+import io.netty.util.concurrent.Promise;
+import io.netty.util.concurrent.ScheduledFuture;
+import io.netty.util.internal.OneTimeTask;
+import io.netty.util.internal.StringUtil;
+import io.netty.util.internal.logging.InternalLogger;
+import io.netty.util.internal.logging.InternalLoggerFactory;
+
+import java.net.InetSocketAddress;
+import java.util.concurrent.TimeUnit;
+
+final class DnsQueryContext {
+
+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(DnsQueryContext.class);
+
+    private final DnsNameResolver parent;
+    private final Promise<AddressedEnvelope<DnsResponse, InetSocketAddress>> promise;
+    private final int id;
+    private final DnsQuestion question;
+    private final DnsRecord optResource;
+    private final InetSocketAddress nameServerAddr;
+
+    private final boolean recursionDesired;
+    private volatile ScheduledFuture<?> timeoutFuture;
+
+    DnsQueryContext(DnsNameResolver parent,
+                    InetSocketAddress nameServerAddr,
+                    DnsQuestion question, Promise<AddressedEnvelope<DnsResponse, InetSocketAddress>> promise) {
+
+        this.parent = parent;
+        this.nameServerAddr = nameServerAddr;
+        this.question = question;
+        this.promise = promise;
+        recursionDesired = parent.isRecursionDesired();
+        id = parent.queryContextManager.add(this);
+
+        if (parent.isOptResourceEnabled()) {
+            optResource = new DefaultDnsRawRecord(
+                    StringUtil.EMPTY_STRING, DnsRecordType.OPT, parent.maxPayloadSize(), 0, Unpooled.EMPTY_BUFFER);
+        } else {
+            optResource = null;
+        }
+    }
+
+    InetSocketAddress nameServerAddr() {
+        return nameServerAddr;
+    }
+
+    DnsQuestion question() {
+        return question;
+    }
+
+    void query() {
+        final DnsQuestion question = question();
+        final InetSocketAddress nameServerAddr = nameServerAddr();
+        final DatagramDnsQuery query = new DatagramDnsQuery(null, nameServerAddr, id);
+        query.setRecursionDesired(recursionDesired);
+        query.setRecord(DnsSection.QUESTION, question);
+        if (optResource != null) {
+            query.setRecord(DnsSection.ADDITIONAL, optResource);
+        }
+
+        if (logger.isDebugEnabled()) {
+            logger.debug("{} WRITE: [{}: {}], {}", parent.ch, id, nameServerAddr, question);
+        }
+
+        sendQuery(query);
+    }
+
+    private void sendQuery(final DnsQuery query) {
+        if (parent.bindFuture.isDone()) {
+            writeQuery(query);
+        } else {
+            parent.bindFuture.addListener(new ChannelFutureListener() {
+                @Override
+                public void operationComplete(ChannelFuture future) throws Exception {
+                    if (future.isSuccess()) {
+                        writeQuery(query);
+                    } else {
+                        promise.tryFailure(future.cause());
+                    }
+                }
+            });
+        }
+    }
+
+    private void writeQuery(final DnsQuery query) {
+        final ChannelFuture writeFuture = parent.ch.writeAndFlush(query);
+        if (writeFuture.isDone()) {
+            onQueryWriteCompletion(writeFuture);
+        } else {
+            writeFuture.addListener(new ChannelFutureListener() {
+                @Override
+                public void operationComplete(ChannelFuture future) throws Exception {
+                    onQueryWriteCompletion(writeFuture);
+                }
+            });
+        }
+    }
+
+    private void onQueryWriteCompletion(ChannelFuture writeFuture) {
+        if (!writeFuture.isSuccess()) {
+            setFailure("failed to send a query", writeFuture.cause());
+            return;
+        }
+
+        // Schedule a query timeout task if necessary.
+        final long queryTimeoutMillis = parent.queryTimeoutMillis();
+        if (queryTimeoutMillis > 0) {
+            timeoutFuture = parent.ch.eventLoop().schedule(new OneTimeTask() {
+                @Override
+                public void run() {
+                    if (promise.isDone()) {
+                        // Received a response before the query times out.
+                        return;
+                    }
+
+                    setFailure("query timed out after " + queryTimeoutMillis + " milliseconds", null);
+                }
+            }, queryTimeoutMillis, TimeUnit.MILLISECONDS);
+        }
+    }
+
+    void finish(AddressedEnvelope<? extends DnsResponse, InetSocketAddress> envelope) {
+        final DnsResponse res = envelope.content();
+        if (res.count(DnsSection.QUESTION) != 1) {
+            logger.warn("Received a DNS response with invalid number of questions: {}", envelope);
+            return;
+        }
+
+        if (!question().equals(res.recordAt(DnsSection.QUESTION))) {
+            logger.warn("Received a mismatching DNS response: {}", envelope);
+            return;
+        }
+
+        setSuccess(envelope);
+    }
+
+    private void setSuccess(AddressedEnvelope<? extends DnsResponse, InetSocketAddress> envelope) {
+        parent.queryContextManager.remove(nameServerAddr(), id);
+
+        // Cancel the timeout task.
+        final ScheduledFuture<?> timeoutFuture = this.timeoutFuture;
+        if (timeoutFuture != null) {
+            timeoutFuture.cancel(false);
+        }
+
+        Promise<AddressedEnvelope<DnsResponse, InetSocketAddress>> promise = this.promise;
+        if (promise.setUncancellable()) {
+            @SuppressWarnings("unchecked")
+            AddressedEnvelope<DnsResponse, InetSocketAddress> castResponse =
+                    (AddressedEnvelope<DnsResponse, InetSocketAddress>) envelope.retain();
+            promise.setSuccess(castResponse);
+        }
+    }
+
+    private void setFailure(String message, Throwable cause) {
+        final InetSocketAddress nameServerAddr = nameServerAddr();
+        parent.queryContextManager.remove(nameServerAddr, id);
+
+        final StringBuilder buf = new StringBuilder(message.length() + 64);
+        buf.append('[')
+           .append(nameServerAddr)
+           .append("] ")
+           .append(message)
+           .append(" (no stack trace available)");
+
+        final DnsNameResolverException e;
+        if (cause != null) {
+            e = new DnsNameResolverException(nameServerAddr, question(), buf.toString(), cause);
+        } else {
+            e = new DnsNameResolverException(nameServerAddr, question(), buf.toString());
+        }
+
+        promise.tryFailure(e);
+    }
+}
diff --git a/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContextManager.java b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContextManager.java
new file mode 100644
index 000000000..9c3946c72
--- /dev/null
+++ b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContextManager.java
@@ -0,0 +1,148 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.resolver.dns;
+
+import io.netty.util.NetUtil;
+import io.netty.util.collection.IntObjectHashMap;
+import io.netty.util.collection.IntObjectMap;
+import io.netty.util.internal.ThreadLocalRandom;
+
+import java.net.Inet4Address;
+import java.net.Inet6Address;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.UnknownHostException;
+import java.util.HashMap;
+import java.util.Map;
+
+final class DnsQueryContextManager {
+
+    /**
+     * A map whose key is the DNS server address and value is the map of the DNS query ID and its corresponding
+     * {@link DnsQueryContext}.
+     */
+    final Map<InetSocketAddress, IntObjectMap<DnsQueryContext>> map =
+            new HashMap<InetSocketAddress, IntObjectMap<DnsQueryContext>>();
+
+    int add(DnsQueryContext qCtx) {
+        final IntObjectMap<DnsQueryContext> contexts = getOrCreateContextMap(qCtx.nameServerAddr());
+
+        int id = ThreadLocalRandom.current().nextInt(1, 65536);
+        final int maxTries = 65535 << 1;
+        int tries = 0;
+
+        synchronized (contexts) {
+            for (;;) {
+                if (!contexts.containsKey(id)) {
+                    contexts.put(id, qCtx);
+                    return id;
+                }
+
+                id = id + 1 & 0xFFFF;
+
+                if (++tries >= maxTries) {
+                    throw new IllegalStateException("query ID space exhausted: " + qCtx.question());
+                }
+            }
+        }
+    }
+
+    DnsQueryContext get(InetSocketAddress nameServerAddr, int id) {
+        final IntObjectMap<DnsQueryContext> contexts = getContextMap(nameServerAddr);
+        final DnsQueryContext qCtx;
+        if (contexts != null) {
+            synchronized (contexts) {
+                qCtx = contexts.get(id);
+            }
+        } else {
+            qCtx = null;
+        }
+
+        return qCtx;
+    }
+
+    DnsQueryContext remove(InetSocketAddress nameServerAddr, int id) {
+        final IntObjectMap<DnsQueryContext> contexts = getContextMap(nameServerAddr);
+        if (contexts == null) {
+            return null;
+        }
+
+        synchronized (contexts) {
+            return  contexts.remove(id);
+        }
+    }
+
+    private IntObjectMap<DnsQueryContext> getContextMap(InetSocketAddress nameServerAddr) {
+        synchronized (map) {
+            return map.get(nameServerAddr);
+        }
+    }
+
+    private IntObjectMap<DnsQueryContext> getOrCreateContextMap(InetSocketAddress nameServerAddr) {
+        synchronized (map) {
+            final IntObjectMap<DnsQueryContext> contexts = map.get(nameServerAddr);
+            if (contexts != null) {
+                return contexts;
+            }
+
+            final IntObjectMap<DnsQueryContext> newContexts = new IntObjectHashMap<DnsQueryContext>();
+            final InetAddress a = nameServerAddr.getAddress();
+            final int port = nameServerAddr.getPort();
+            map.put(nameServerAddr, newContexts);
+
+            if (a instanceof Inet4Address) {
+                // Also add the mapping for the IPv4-compatible IPv6 address.
+                final Inet4Address a4 = (Inet4Address) a;
+                if (a4.isLoopbackAddress()) {
+                    map.put(new InetSocketAddress(NetUtil.LOCALHOST6, port), newContexts);
+                } else {
+                    map.put(new InetSocketAddress(toCompatAddress(a4), port), newContexts);
+                }
+            } else if (a instanceof Inet6Address) {
+                // Also add the mapping for the IPv4 address if this IPv6 address is compatible.
+                final Inet6Address a6 = (Inet6Address) a;
+                if (a6.isLoopbackAddress()) {
+                    map.put(new InetSocketAddress(NetUtil.LOCALHOST4, port), newContexts);
+                } else if (a6.isIPv4CompatibleAddress()) {
+                    map.put(new InetSocketAddress(toIPv4Address(a6), port), newContexts);
+                }
+            }
+
+            return newContexts;
+        }
+    }
+
+    private static Inet6Address toCompatAddress(Inet4Address a4) {
+        byte[] b4 = a4.getAddress();
+        byte[] b6 = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, b4[0], b4[1], b4[2], b4[3] };
+        try {
+            return (Inet6Address) InetAddress.getByAddress(b6);
+        } catch (UnknownHostException e) {
+            throw new Error(e);
+        }
+    }
+
+    private static Inet4Address toIPv4Address(Inet6Address a6) {
+        byte[] b6 = a6.getAddress();
+        byte[] b4 = { b6[12], b6[13], b6[14], b6[15] };
+        try {
+            return (Inet4Address) InetAddress.getByAddress(b4);
+        } catch (UnknownHostException e) {
+            throw new Error(e);
+        }
+    }
+}
diff --git a/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStream.java b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStream.java
new file mode 100644
index 000000000..2e806ef78
--- /dev/null
+++ b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStream.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.resolver.dns;
+
+import java.net.InetSocketAddress;
+
+/**
+ * An infinite stream of DNS server addresses.
+ */
+public interface DnsServerAddressStream {
+    /**
+     * Retrieves the next DNS server address from the stream.
+     */
+    InetSocketAddress next();
+}
diff --git a/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java
new file mode 100644
index 000000000..4561b6425
--- /dev/null
+++ b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java
@@ -0,0 +1,267 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.resolver.dns;
+
+import io.netty.util.internal.logging.InternalLogger;
+import io.netty.util.internal.logging.InternalLoggerFactory;
+
+import java.lang.reflect.Method;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.SocketAddress;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * Provides an infinite sequence of DNS server addresses to {@link DnsNameResolver}.
+ */
+@SuppressWarnings("IteratorNextCanNotThrowNoSuchElementException")
+public abstract class DnsServerAddresses {
+
+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(DnsServerAddresses.class);
+
+    private static final List<InetSocketAddress> DEFAULT_NAME_SERVER_LIST;
+    private static final InetSocketAddress[] DEFAULT_NAME_SERVER_ARRAY;
+    private static final DnsServerAddresses DEFAULT_NAME_SERVERS;
+
+    static {
+        final int DNS_PORT = 53;
+        final List<InetSocketAddress> defaultNameServers = new ArrayList<InetSocketAddress>(2);
+        try {
+            Class<?> configClass = Class.forName("sun.net.dns.ResolverConfiguration");
+            Method open = configClass.getMethod("open");
+            Method nameservers = configClass.getMethod("nameservers");
+            Object instance = open.invoke(null);
+
+            @SuppressWarnings("unchecked")
+            final List<String> list = (List<String>) nameservers.invoke(instance);
+            for (String a: list) {
+                if (a != null) {
+                    defaultNameServers.add(new InetSocketAddress(InetAddress.getByName(a), DNS_PORT));
+                }
+            }
+        } catch (Exception ignore) {
+            // Failed to get the system name server list.
+            // Will add the default name servers afterwards.
+        }
+
+        if (!defaultNameServers.isEmpty()) {
+            if (logger.isDebugEnabled()) {
+                logger.debug(
+                        "Default DNS servers: {} (sun.net.dns.ResolverConfiguration)", defaultNameServers);
+            }
+        } else {
+            Collections.addAll(
+                    defaultNameServers,
+                    new InetSocketAddress("8.8.8.8", DNS_PORT),
+                    new InetSocketAddress("8.8.4.4", DNS_PORT));
+
+            if (logger.isWarnEnabled()) {
+                logger.warn(
+                        "Default DNS servers: {} (Google Public DNS as a fallback)", defaultNameServers);
+            }
+        }
+
+        DEFAULT_NAME_SERVER_LIST = Collections.unmodifiableList(defaultNameServers);
+        DEFAULT_NAME_SERVER_ARRAY = defaultNameServers.toArray(new InetSocketAddress[defaultNameServers.size()]);
+        DEFAULT_NAME_SERVERS = sequential(DEFAULT_NAME_SERVER_ARRAY);
+    }
+
+    /**
+     * Returns the list of the system DNS server addresses. If it failed to retrieve the list of the system DNS server
+     * addresses from the environment, it will return {@code "8.8.8.8"} and {@code "8.8.4.4"}, the addresses of the
+     * Google public DNS servers.
+     */
+    public static List<InetSocketAddress> defaultAddressList() {
+        return DEFAULT_NAME_SERVER_LIST;
+    }
+
+    /**
+     * Returns the {@link DnsServerAddresses} that yields the system DNS server addresses sequentially. If it failed to
+     * retrieve the list of the system DNS server addresses from the environment, it will use {@code "8.8.8.8"} and
+     * {@code "8.8.4.4"}, the addresses of the Google public DNS servers.
+     * <p>
+     * This method has the same effect with the following code:
+     * <pre>
+     * DnsServerAddresses.sequential(DnsServerAddresses.defaultAddressList());
+     * </pre>
+     * </p>
+     */
+    public static DnsServerAddresses defaultAddresses() {
+        return DEFAULT_NAME_SERVERS;
+    }
+
+    /**
+     * Returns the {@link DnsServerAddresses} that yields the specified {@code addresses} sequentially. Once the
+     * last address is yielded, it will start again from the first address.
+     */
+    public static DnsServerAddresses sequential(Iterable<? extends InetSocketAddress> addresses) {
+        return sequential0(sanitize(addresses));
+    }
+
+    /**
+     * Returns the {@link DnsServerAddresses} that yields the specified {@code addresses} sequentially. Once the
+     * last address is yielded, it will start again from the first address.
+     */
+    public static DnsServerAddresses sequential(InetSocketAddress... addresses) {
+        return sequential0(sanitize(addresses));
+    }
+
+    private static DnsServerAddresses sequential0(final InetSocketAddress... addresses) {
+        if (addresses.length == 1) {
+            return singleton(addresses[0]);
+        }
+
+        return new DefaultDnsServerAddresses("sequential", addresses) {
+            @Override
+            public DnsServerAddressStream stream() {
+                return new SequentialDnsServerAddressStream(addresses, 0);
+            }
+        };
+    }
+
+    /**
+     * Returns the {@link DnsServerAddresses} that yields the specified {@code address} in a shuffled order. Once all
+     * addresses are yielded, the addresses are shuffled again.
+     */
+    public static DnsServerAddresses shuffled(Iterable<? extends InetSocketAddress> addresses) {
+        return shuffled0(sanitize(addresses));
+    }
+
+    /**
+     * Returns the {@link DnsServerAddresses} that yields the specified {@code addresses} in a shuffled order. Once all
+     * addresses are yielded, the addresses are shuffled again.
+     */
+    public static DnsServerAddresses shuffled(InetSocketAddress... addresses) {
+        return shuffled0(sanitize(addresses));
+    }
+
+    private static DnsServerAddresses shuffled0(final InetSocketAddress[] addresses) {
+        if (addresses.length == 1) {
+            return singleton(addresses[0]);
+        }
+
+        return new DefaultDnsServerAddresses("shuffled", addresses) {
+            @Override
+            public DnsServerAddressStream stream() {
+                return new ShuffledDnsServerAddressStream(addresses);
+            }
+        };
+    }
+
+    /**
+     * Returns the {@link DnsServerAddresses} that yields the specified {@code addresses} in a rotational sequential
+     * order. It is similar to {@link #sequential(Iterable)}, but each {@link DnsServerAddressStream} starts from
+     * a different starting point.  For example, the first {@link #stream()} will start from the first address, the
+     * second one will start from the second address, and so on.
+     */
+    public static DnsServerAddresses rotational(Iterable<? extends InetSocketAddress> addresses) {
+        return rotational0(sanitize(addresses));
+    }
+
+    /**
+     * Returns the {@link DnsServerAddresses} that yields the specified {@code addresses} in a rotational sequential
+     * order. It is similar to {@link #sequential(Iterable)}, but each {@link DnsServerAddressStream} starts from
+     * a different starting point.  For example, the first {@link #stream()} will start from the first address, the
+     * second one will start from the second address, and so on.
+     */
+    public static DnsServerAddresses rotational(InetSocketAddress... addresses) {
+        return rotational0(sanitize(addresses));
+    }
+
+    private static DnsServerAddresses rotational0(final InetSocketAddress[] addresses) {
+        if (addresses.length == 1) {
+            return singleton(addresses[0]);
+        }
+
+        return new RotationalDnsServerAddresses(addresses);
+    }
+
+    /**
+     * Returns the {@link DnsServerAddresses} that yields only a single {@code address}.
+     */
+    public static DnsServerAddresses singleton(final InetSocketAddress address) {
+        if (address == null) {
+            throw new NullPointerException("address");
+        }
+        if (address.isUnresolved()) {
+            throw new IllegalArgumentException("cannot use an unresolved DNS server address: " + address);
+        }
+
+        return new SingletonDnsServerAddresses(address);
+    }
+
+    private static InetSocketAddress[] sanitize(Iterable<? extends InetSocketAddress> addresses) {
+        if (addresses == null) {
+            throw new NullPointerException("addresses");
+        }
+
+        final List<InetSocketAddress> list;
+        if (addresses instanceof Collection) {
+            list = new ArrayList<InetSocketAddress>(((Collection<?>) addresses).size());
+        } else {
+            list = new ArrayList<InetSocketAddress>(4);
+        }
+
+        for (InetSocketAddress a : addresses) {
+            if (a == null) {
+                break;
+            }
+            if (a.isUnresolved()) {
+                throw new IllegalArgumentException("cannot use an unresolved DNS server address: " + a);
+            }
+            list.add(a);
+        }
+
+        if (list.isEmpty()) {
+            throw new IllegalArgumentException("empty addresses");
+        }
+
+        return list.toArray(new InetSocketAddress[list.size()]);
+    }
+
+    private static InetSocketAddress[] sanitize(InetSocketAddress[] addresses) {
+        if (addresses == null) {
+            throw new NullPointerException("addresses");
+        }
+
+        List<InetSocketAddress> list = new ArrayList<InetSocketAddress>(addresses.length);
+        for (InetSocketAddress a: addresses) {
+            if (a == null) {
+                break;
+            }
+            if (a.isUnresolved()) {
+                throw new IllegalArgumentException("cannot use an unresolved DNS server address: " + a);
+            }
+            list.add(a);
+        }
+
+        if (list.isEmpty()) {
+            return DEFAULT_NAME_SERVER_ARRAY;
+        }
+
+        return list.toArray(new InetSocketAddress[list.size()]);
+    }
+
+    /**
+     * Starts a new infinite stream of DNS server addresses. This method is invoked by {@link DnsNameResolver} on every
+     * uncached {@link DnsNameResolver#resolve(SocketAddress)} or {@link DnsNameResolver#resolveAll(SocketAddress)}.
+     */
+    public abstract DnsServerAddressStream stream();
+}
diff --git a/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsCache.java b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsCache.java
new file mode 100644
index 000000000..0fbcf4869
--- /dev/null
+++ b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsCache.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.resolver.dns;
+
+import io.netty.channel.EventLoop;
+
+import java.net.InetAddress;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * A noop DNS cache that actually never caches anything.
+ */
+public final class NoopDnsCache implements DnsCache {
+
+    public static final NoopDnsCache INSTANCE = new NoopDnsCache();
+
+    /**
+     * Private singleton constructor.
+     */
+    private NoopDnsCache() {
+    }
+
+    @Override
+    public void clear() {
+    }
+
+    @Override
+    public boolean clear(String hostname) {
+        return false;
+    }
+
+    @Override
+    public List<DnsCacheEntry> get(String hostname) {
+        return Collections.emptyList();
+    }
+
+    @Override
+    public void cache(String hostname, InetAddress address, long originalTtl, EventLoop loop) {
+    }
+
+    @Override
+    public void cache(String hostname, Throwable cause, EventLoop loop) {
+    }
+
+    @Override
+    public String toString() {
+        return NoopDnsCache.class.getSimpleName();
+    }
+}
diff --git a/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/RotationalDnsServerAddresses.java b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/RotationalDnsServerAddresses.java
new file mode 100644
index 000000000..f9613987a
--- /dev/null
+++ b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/RotationalDnsServerAddresses.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.resolver.dns;
+
+import io.netty.util.internal.PlatformDependent;
+
+import java.net.InetSocketAddress;
+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
+
+final class RotationalDnsServerAddresses extends DefaultDnsServerAddresses {
+
+    private static final AtomicIntegerFieldUpdater<RotationalDnsServerAddresses> startIdxUpdater;
+
+    static {
+        AtomicIntegerFieldUpdater<RotationalDnsServerAddresses> updater =
+                PlatformDependent.newAtomicIntegerFieldUpdater(RotationalDnsServerAddresses.class, "startIdx");
+
+        if (updater == null) {
+            updater = AtomicIntegerFieldUpdater.newUpdater(RotationalDnsServerAddresses.class, "startIdx");
+        }
+
+        startIdxUpdater = updater;
+    }
+
+    @SuppressWarnings("UnusedDeclaration")
+    private volatile int startIdx;
+
+    RotationalDnsServerAddresses(InetSocketAddress[] addresses) {
+        super("rotational", addresses);
+    }
+
+    @Override
+    public DnsServerAddressStream stream() {
+        for (;;) {
+            int curStartIdx = startIdx;
+            int nextStartIdx = curStartIdx + 1;
+            if (nextStartIdx >= addresses.length) {
+                nextStartIdx = 0;
+            }
+            if (startIdxUpdater.compareAndSet(this, curStartIdx, nextStartIdx)) {
+                return new SequentialDnsServerAddressStream(addresses, curStartIdx);
+            }
+        }
+    }
+}
diff --git a/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/SequentialDnsServerAddressStream.java b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/SequentialDnsServerAddressStream.java
new file mode 100644
index 000000000..6c1d84a01
--- /dev/null
+++ b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/SequentialDnsServerAddressStream.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.resolver.dns;
+
+import java.net.InetSocketAddress;
+
+final class SequentialDnsServerAddressStream implements DnsServerAddressStream {
+
+    private final InetSocketAddress[] addresses;
+    private int i;
+
+    SequentialDnsServerAddressStream(InetSocketAddress[] addresses, int startIdx) {
+        this.addresses = addresses;
+        i = startIdx;
+    }
+
+    @Override
+    public InetSocketAddress next() {
+        int i = this.i;
+        InetSocketAddress next = addresses[i];
+        if (++ i < addresses.length) {
+            this.i = i;
+        } else {
+            this.i = 0;
+        }
+        return next;
+    }
+
+    @Override
+    public String toString() {
+        return toString("sequential", i, addresses);
+    }
+
+    static String toString(String type, int index, InetSocketAddress[] addresses) {
+        final StringBuilder buf = new StringBuilder(type.length() + 2 + addresses.length * 16);
+        buf.append(type).append("(index: ").append(index);
+        buf.append(", addrs: (");
+        for (InetSocketAddress a: addresses) {
+            buf.append(a).append(", ");
+        }
+
+        buf.setLength(buf.length() - 2);
+        buf.append("))");
+
+        return buf.toString();
+    }
+}
diff --git a/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/ShuffledDnsServerAddressStream.java b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/ShuffledDnsServerAddressStream.java
new file mode 100644
index 000000000..9b1f24138
--- /dev/null
+++ b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/ShuffledDnsServerAddressStream.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.resolver.dns;
+
+import io.netty.util.internal.ThreadLocalRandom;
+
+import java.net.InetSocketAddress;
+import java.util.Random;
+
+final class ShuffledDnsServerAddressStream implements DnsServerAddressStream {
+
+    private final InetSocketAddress[] addresses;
+    private int i;
+
+    ShuffledDnsServerAddressStream(InetSocketAddress[] addresses) {
+        this.addresses = addresses.clone();
+
+        shuffle();
+    }
+
+    private void shuffle() {
+        final InetSocketAddress[] addresses = this.addresses;
+        final Random r = ThreadLocalRandom.current();
+
+        for (int i = addresses.length - 1; i >= 0; i --) {
+            InetSocketAddress tmp = addresses[i];
+            int j = r.nextInt(i + 1);
+            addresses[i] = addresses[j];
+            addresses[j] = tmp;
+        }
+    }
+
+    @Override
+    public InetSocketAddress next() {
+        int i = this.i;
+        InetSocketAddress next = addresses[i];
+        if (++ i < addresses.length) {
+            this.i = i;
+        } else {
+            this.i = 0;
+            shuffle();
+        }
+        return next;
+    }
+
+    @Override
+    public String toString() {
+        return SequentialDnsServerAddressStream.toString("shuffled", i, addresses);
+    }
+}
diff --git a/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/SingletonDnsServerAddresses.java b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/SingletonDnsServerAddresses.java
new file mode 100644
index 000000000..4936d3889
--- /dev/null
+++ b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/SingletonDnsServerAddresses.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.resolver.dns;
+
+import java.net.InetSocketAddress;
+
+final class SingletonDnsServerAddresses extends DnsServerAddresses {
+
+    private final InetSocketAddress address;
+    private final String strVal;
+
+    private final DnsServerAddressStream stream = new DnsServerAddressStream() {
+        @Override
+        public InetSocketAddress next() {
+            return address;
+        }
+
+        @Override
+        public String toString() {
+            return SingletonDnsServerAddresses.this.toString();
+        }
+    };
+
+    SingletonDnsServerAddresses(InetSocketAddress address) {
+        this.address = address;
+        strVal = new StringBuilder(32).append("singleton(").append(address).append(')').toString();
+    }
+
+    @Override
+    public DnsServerAddressStream stream() {
+        return stream;
+    }
+
+    @Override
+    public String toString() {
+        return strVal;
+    }
+}
diff --git a/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/package-info.java b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/package-info.java
new file mode 100644
index 000000000..63825ba87
--- /dev/null
+++ b/netty-bp/resolver-dns/src/main/java/io/netty/resolver/dns/package-info.java
@@ -0,0 +1,21 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+/**
+ * An alternative to Java's built-in domain name lookup mechanism that resolves a domain name asynchronously,
+ * which supports the queries of an arbitrary DNS record type as well.
+ */
+package io.netty.resolver.dns;
diff --git a/netty-bp/resolver-dns/src/main/java/io/netty/util/internal/ObjectUtil2.java b/netty-bp/resolver-dns/src/main/java/io/netty/util/internal/ObjectUtil2.java
new file mode 100644
index 000000000..5ff5d3473
--- /dev/null
+++ b/netty-bp/resolver-dns/src/main/java/io/netty/util/internal/ObjectUtil2.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package io.netty.util.internal;
+
+/**
+ * A grab-bag of useful utility methods.
+ */
+public final class ObjectUtil2 {
+
+    private ObjectUtil2() {
+    }
+
+    /**
+     * Checks that the given argument is not null. If it is, throws {@link NullPointerException}.
+     * Otherwise, returns the argument.
+     */
+    public static <T> T checkNotNull(T arg, String text) {
+        if (arg == null) {
+            throw new NullPointerException(text);
+        }
+        return arg;
+    }
+
+    /**
+     * Checks that the given argument is strictly positive. If it is, throws {@link IllegalArgumentException}.
+     * Otherwise, returns the argument.
+     */
+    public static int checkPositive(int i, String name) {
+        if (i <= 0) {
+            throw new IllegalArgumentException(name + ": " + i + " (expected: > 0)");
+        }
+        return i;
+    }
+
+    /**
+     * Checks that the given argument is strictly positive. If it is, throws {@link IllegalArgumentException}.
+     * Otherwise, returns the argument.
+     */
+    public static long checkPositive(long i, String name) {
+        if (i <= 0) {
+            throw new IllegalArgumentException(name + ": " + i + " (expected: > 0)");
+        }
+        return i;
+    }
+
+    /**
+     * Checks that the given argument is positive or zero. If it is, throws {@link IllegalArgumentException}.
+     * Otherwise, returns the argument.
+     */
+    public static int checkPositiveOrZero(int i, String name) {
+        if (i < 0) {
+            throw new IllegalArgumentException(name + ": " + i + " (expected: >= 0)");
+        }
+        return i;
+    }
+
+    /**
+     * Checks that the given argument is neither null nor empty.
+     * If it is, throws {@link NullPointerException} or {@link IllegalArgumentException}.
+     * Otherwise, returns the argument.
+     */
+    public static <T> T[] checkNonEmpty(T[] array, String name) {
+        checkNotNull(array, name);
+        checkPositive(array.length, name + ".length");
+        return array;
+    }
+
+    /**
+     * Resolves a possibly null Integer to a primitive int, using a default value.
+     * @param wrapper the wrapper
+     * @param defaultValue the default value
+     * @return the primitive value
+     */
+    public static int intValue(Integer wrapper, int defaultValue) {
+        return wrapper != null ? wrapper.intValue() : defaultValue;
+    }
+
+    /**
+     * Resolves a possibly null Long to a primitive long, using a default value.
+     * @param wrapper the wrapper
+     * @param defaultValue the default value
+     * @return the primitive value
+     */
+    public static long longValue(Long wrapper, long defaultValue) {
+        return wrapper != null ? wrapper.longValue() : defaultValue;
+    }
+}
\ No newline at end of file
diff --git a/netty-bp/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java b/netty-bp/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java
new file mode 100644
index 000000000..2fc852dbf
--- /dev/null
+++ b/netty-bp/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java
@@ -0,0 +1,689 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.resolver.dns;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufHolder;
+import io.netty.channel.AddressedEnvelope;
+import io.netty.channel.EventLoopGroup;
+import io.netty.channel.nio.NioEventLoopGroup;
+import io.netty.channel.socket.InternetProtocolFamily;
+import io.netty.channel.socket.nio.NioDatagramChannel;
+import io.netty.handler.codec.dns.DefaultDnsQuestion;
+import io.netty.handler.codec.dns.DnsRecord;
+import io.netty.handler.codec.dns.DnsRecordType;
+import io.netty.handler.codec.dns.DnsResponse;
+import io.netty.handler.codec.dns.DnsResponseCode;
+import io.netty.handler.codec.dns.DnsSection;
+import io.netty.util.NetUtil;
+import io.netty.util.concurrent.Future;
+import io.netty.util.internal.StringUtil;
+import io.netty.util.internal.ThreadLocalRandom;
+import io.netty.util.internal.logging.InternalLogger;
+import io.netty.util.internal.logging.InternalLoggerFactory;
+import org.apache.directory.server.dns.DnsServer;
+import org.apache.directory.server.dns.io.encoder.DnsMessageEncoder;
+import org.apache.directory.server.dns.io.encoder.ResourceRecordEncoder;
+import org.apache.directory.server.dns.messages.DnsMessage;
+import org.apache.directory.server.dns.messages.QuestionRecord;
+import org.apache.directory.server.dns.messages.RecordClass;
+import org.apache.directory.server.dns.messages.RecordType;
+import org.apache.directory.server.dns.messages.ResourceRecord;
+import org.apache.directory.server.dns.messages.ResourceRecordModifier;
+import org.apache.directory.server.dns.protocol.DnsProtocolHandler;
+import org.apache.directory.server.dns.protocol.DnsUdpDecoder;
+import org.apache.directory.server.dns.protocol.DnsUdpEncoder;
+import org.apache.directory.server.dns.store.DnsAttribute;
+import org.apache.directory.server.dns.store.RecordStore;
+import org.apache.directory.server.protocol.shared.transport.UdpTransport;
+import org.apache.mina.core.buffer.IoBuffer;
+import org.apache.mina.core.session.IoSession;
+import org.apache.mina.filter.codec.ProtocolCodecFactory;
+import org.apache.mina.filter.codec.ProtocolCodecFilter;
+import org.apache.mina.filter.codec.ProtocolDecoder;
+import org.apache.mina.filter.codec.ProtocolEncoder;
+import org.apache.mina.filter.codec.ProtocolEncoderOutput;
+import org.apache.mina.transport.socket.DatagramAcceptor;
+import org.apache.mina.transport.socket.DatagramSessionConfig;
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.UnknownHostException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+
+import static org.hamcrest.Matchers.greaterThan;
+import static org.hamcrest.Matchers.hasSize;
+import static org.hamcrest.Matchers.instanceOf;
+import static org.hamcrest.Matchers.is;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertThat;
+import static org.junit.Assert.fail;
+
+public class DnsNameResolverTest {
+
+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(DnsNameResolver.class);
+
+    // Using the top-100 web sites ranked in Alexa.com (Oct 2014)
+    // Please use the following series of shell commands to get this up-to-date:
+    // $ curl -O http://s3.amazonaws.com/alexa-static/top-1m.csv.zip
+    // $ unzip -o top-1m.csv.zip top-1m.csv
+    // $ head -100 top-1m.csv | cut -d, -f2 | cut -d/ -f1 | while read L; do echo '"'"$L"'",'; done > topsites.txt
+    private static final Set<String> DOMAINS = Collections.unmodifiableSet(new HashSet<String>(Arrays.asList(
+            "google.com",
+            "facebook.com",
+            "youtube.com",
+            "yahoo.com",
+            "baidu.com",
+            "wikipedia.org",
+            "amazon.com",
+            "twitter.com",
+            "qq.com",
+            "taobao.com",
+            "linkedin.com",
+            "google.co.in",
+            "live.com",
+            "hao123.com",
+            "sina.com.cn",
+            "blogspot.com",
+            "weibo.com",
+            "yahoo.co.jp",
+            "tmall.com",
+            "yandex.ru",
+            "sohu.com",
+            "bing.com",
+            "ebay.com",
+            "pinterest.com",
+            "vk.com",
+            "google.de",
+            "wordpress.com",
+            "apple.com",
+            "google.co.jp",
+            "google.co.uk",
+            "360.cn",
+            "instagram.com",
+            "google.fr",
+            "msn.com",
+            "ask.com",
+            "soso.com",
+            "google.com.br",
+            "tumblr.com",
+            "paypal.com",
+            "mail.ru",
+            "xvideos.com",
+            "microsoft.com",
+            "google.ru",
+            "reddit.com",
+            "google.it",
+            "imgur.com",
+            "163.com",
+            "google.es",
+            "imdb.com",
+            "aliexpress.com",
+            "t.co",
+            "go.com",
+            "adcash.com",
+            "craigslist.org",
+            "amazon.co.jp",
+            "alibaba.com",
+            "google.com.mx",
+            "stackoverflow.com",
+            "xhamster.com",
+            "fc2.com",
+            "google.ca",
+            "bbc.co.uk",
+            "espn.go.com",
+            "cnn.com",
+            "google.co.id",
+            "people.com.cn",
+            "gmw.cn",
+            "pornhub.com",
+            "blogger.com",
+            "huffingtonpost.com",
+            "flipkart.com",
+            "akamaihd.net",
+            "google.com.tr",
+            "amazon.de",
+            "netflix.com",
+            "onclickads.net",
+            "googleusercontent.com",
+            "kickass.to",
+            "google.com.au",
+            "google.pl",
+            "xinhuanet.com",
+            "ebay.de",
+            "wordpress.org",
+            "odnoklassniki.ru",
+            "google.com.hk",
+            "adobe.com",
+            "dailymotion.com",
+            "dailymail.co.uk",
+            "indiatimes.com",
+            "amazon.co.uk",
+            "xnxx.com",
+            "rakuten.co.jp",
+            "dropbox.com",
+            "tudou.com",
+            "about.com",
+            "cnet.com",
+            "vimeo.com",
+            "redtube.com",
+            "blogspot.in")));
+
+    /**
+     * The list of the domain names to exclude from {@link #testResolveAorAAAA()}.
+     */
+    private static final Set<String> EXCLUSIONS_RESOLVE_A = new HashSet<String>();
+    static {
+        Collections.addAll(
+                EXCLUSIONS_RESOLVE_A,
+                "akamaihd.net",
+                "googleusercontent.com",
+                StringUtil.EMPTY_STRING);
+    }
+
+    /**
+     * The list of the domain names to exclude from {@link #testResolveAAAA()}.
+     * Unfortunately, there are only handful of domain names with IPv6 addresses.
+     */
+    private static final Set<String> EXCLUSIONS_RESOLVE_AAAA = new HashSet<String>();
+    static {
+        EXCLUSIONS_RESOLVE_AAAA.addAll(EXCLUSIONS_RESOLVE_A);
+        EXCLUSIONS_RESOLVE_AAAA.addAll(DOMAINS);
+        EXCLUSIONS_RESOLVE_AAAA.removeAll(Arrays.asList(
+                "google.com",
+                "facebook.com",
+                "youtube.com",
+                "wikipedia.org",
+                "google.co.in",
+                "blogspot.com",
+                "vk.com",
+                "google.de",
+                "google.co.jp",
+                "google.co.uk",
+                "google.fr",
+                "google.com.br",
+                "google.ru",
+                "google.it",
+                "google.es",
+                "google.com.mx",
+                "xhamster.com",
+                "google.ca",
+                "google.co.id",
+                "blogger.com",
+                "flipkart.com",
+                "google.com.tr",
+                "google.com.au",
+                "google.pl",
+                "google.com.hk",
+                "blogspot.in"
+        ));
+    }
+
+    /**
+     * The list of the domain names to exclude from {@link #testQueryMx()}.
+     */
+    private static final Set<String> EXCLUSIONS_QUERY_MX = new HashSet<String>();
+    static {
+        Collections.addAll(
+                EXCLUSIONS_QUERY_MX,
+                "hao123.com",
+                "blogspot.com",
+                "t.co",
+                "espn.go.com",
+                "people.com.cn",
+                "googleusercontent.com",
+                "blogspot.in",
+                StringUtil.EMPTY_STRING);
+    }
+
+    private static final TestDnsServer dnsServer = new TestDnsServer();
+    private static final EventLoopGroup group = new NioEventLoopGroup(1);
+
+    private DnsNameResolverBuilder<?> newResolver() {
+        return new DefaultDnsNameResolverBuilder(group.next())
+                .channelType(NioDatagramChannel.class)
+                .nameServerAddresses(DnsServerAddresses.singleton(dnsServer.localAddress()))
+                .maxQueriesPerResolve(1)
+                .optResourceEnabled(false);
+    }
+
+    private DnsNameResolverBuilder<?> newResolver(InternetProtocolFamily... resolvedAddressTypes) {
+        return newResolver()
+                .resolvedAddressTypes(resolvedAddressTypes);
+    }
+
+    @BeforeClass
+    public static void init() throws Exception {
+        dnsServer.start();
+    }
+    @AfterClass
+    public static void destroy() {
+        dnsServer.stop();
+        group.shutdownGracefully();
+    }
+
+    @Test
+    public void testResolveAorAAAA() throws Exception {
+        DnsNameResolver resolver = newResolver(InternetProtocolFamily.IPv4, InternetProtocolFamily.IPv6).build();
+        try {
+            testResolve0(resolver, EXCLUSIONS_RESOLVE_A);
+        } finally {
+            resolver.close();
+        }
+    }
+
+    @Test
+    public void testResolveAAAAorA() throws Exception {
+        DnsNameResolver resolver = newResolver(InternetProtocolFamily.IPv6, InternetProtocolFamily.IPv4).build();
+        try {
+            testResolve0(resolver, EXCLUSIONS_RESOLVE_A);
+        } finally {
+            resolver.close();
+        }
+    }
+
+    @Test
+    public void  testResolveA() throws Exception {
+        DnsNameResolver resolver = newResolver(InternetProtocolFamily.IPv4)
+                // Cache for eternity
+                .ttl(Integer.MAX_VALUE, Integer.MAX_VALUE)
+                .build();
+        try {
+            final Map<String, InetAddress> resultA = testResolve0(resolver, EXCLUSIONS_RESOLVE_A);
+
+            // Now, try to resolve again to see if it's cached.
+            // This test works because the DNS servers usually randomizes the order of the records in a response.
+            // If cached, the resolved addresses must be always same, because we reuse the same response.
+
+            final Map<String, InetAddress> resultB = testResolve0(resolver, EXCLUSIONS_RESOLVE_A);
+
+            // Ensure the result from the cache is identical from the uncached one.
+            assertThat(resultB.size(), is(resultA.size()));
+            for (Entry<String, InetAddress> e: resultA.entrySet()) {
+                InetAddress expected = e.getValue();
+                InetAddress actual = resultB.get(e.getKey());
+                if (!actual.equals(expected)) {
+                    // Print the content of the cache when test failure is expected.
+                    System.err.println("Cache for " + e.getKey() + ": " + resolver.resolveAll(e.getKey()).getNow());
+                }
+                assertThat(actual, is(expected));
+            }
+        } finally {
+            resolver.close();
+        }
+    }
+
+    @Test
+    public void testResolveAAAA() throws Exception {
+        DnsNameResolver resolver = newResolver(InternetProtocolFamily.IPv6).build();
+        try {
+            testResolve0(resolver, EXCLUSIONS_RESOLVE_AAAA);
+        } finally {
+            resolver.close();
+        }
+    }
+
+    private Map<String, InetAddress> testResolve0(DnsNameResolver resolver, Set<String> excludedDomains)
+            throws InterruptedException {
+
+        assertThat(resolver.isRecursionDesired(), is(true));
+
+        final Map<String, InetAddress> results = new HashMap<String, InetAddress>();
+        final Map<String, Future<InetAddress>> futures =
+                new LinkedHashMap<String, Future<InetAddress>>();
+
+        for (String name : DOMAINS) {
+            if (excludedDomains.contains(name)) {
+                continue;
+            }
+
+            resolve(resolver, futures, name);
+        }
+
+        for (Entry<String, Future<InetAddress>> e : futures.entrySet()) {
+            String unresolved = e.getKey();
+            InetAddress resolved = e.getValue().sync().getNow();
+
+            logger.info("{}: {}", unresolved, resolved.getHostAddress());
+
+            assertThat(resolved.getHostName(), is(unresolved));
+
+            boolean typeMatches = false;
+            for (InternetProtocolFamily f: resolver.resolvedAddressTypes()) {
+                if (DnsNameResolver.addressMatchFamily(resolved, f)) {
+                    typeMatches = true;
+                }
+            }
+
+            assertThat(typeMatches, is(true));
+
+            results.put(resolved.getHostName(), resolved);
+        }
+
+        return results;
+    }
+
+    @Test
+    public void testQueryMx() throws Exception {
+        DnsNameResolver resolver = newResolver().build();
+        try {
+            assertThat(resolver.isRecursionDesired(), is(true));
+
+            Map<String, Future<AddressedEnvelope<DnsResponse, InetSocketAddress>>> futures =
+                    new LinkedHashMap<String, Future<AddressedEnvelope<DnsResponse, InetSocketAddress>>>();
+            for (String name: DOMAINS) {
+                if (EXCLUSIONS_QUERY_MX.contains(name)) {
+                    continue;
+                }
+
+                queryMx(resolver, futures, name);
+            }
+
+            for (Entry<String, Future<AddressedEnvelope<DnsResponse, InetSocketAddress>>> e: futures.entrySet()) {
+                String hostname = e.getKey();
+                Future<AddressedEnvelope<DnsResponse, InetSocketAddress>> f = e.getValue().awaitUninterruptibly();
+
+                DnsResponse response = f.getNow().content();
+                assertThat(response.code(), is(DnsResponseCode.NOERROR));
+
+                final int answerCount = response.count(DnsSection.ANSWER);
+                final List<DnsRecord> mxList = new ArrayList<DnsRecord>(answerCount);
+                for (int i = 0; i < answerCount; i ++) {
+                    final DnsRecord r = response.recordAt(DnsSection.ANSWER, i);
+                    if (r.type() == DnsRecordType.MX) {
+                        mxList.add(r);
+                    }
+                }
+
+                assertThat(mxList.size(), is(greaterThan(0)));
+                StringBuilder buf = new StringBuilder();
+                for (DnsRecord r: mxList) {
+                    ByteBuf recordContent = ((ByteBufHolder) r).content();
+
+                    buf.append(StringUtil.NEWLINE);
+                    buf.append('\t');
+                    buf.append(r.name());
+                    buf.append(' ');
+                    buf.append(r.type().name());
+                    buf.append(' ');
+                    buf.append(recordContent.readUnsignedShort());
+                    buf.append(' ');
+                    buf.append(DnsNameResolverContext.decodeDomainName(recordContent));
+                }
+
+                logger.info("{} has the following MX records:{}", hostname, buf);
+                response.release();
+            }
+        } finally {
+            resolver.close();
+        }
+    }
+
+    @Test
+    public void testNegativeTtl() throws Exception {
+        final DnsNameResolver resolver = newResolver().negativeTtl(10).build();
+        try {
+            resolveNonExistentDomain(resolver);
+
+            final int size = 10000;
+            final List<UnknownHostException> exceptions = new ArrayList<UnknownHostException>();
+
+            // If negative cache works, this thread should be done really quickly.
+            final Thread negativeLookupThread = new Thread() {
+                @Override
+                public void run() {
+                    for (int i = 0; i < size; i++) {
+                        exceptions.add(resolveNonExistentDomain(resolver));
+                        if (isInterrupted()) {
+                            break;
+                        }
+                    }
+                }
+            };
+
+            negativeLookupThread.start();
+            negativeLookupThread.join(5000);
+
+            if (negativeLookupThread.isAlive()) {
+                negativeLookupThread.interrupt();
+                fail("Cached negative lookups did not finish quickly.");
+            }
+
+            assertThat(exceptions, hasSize(size));
+        } finally {
+            resolver.close();
+        }
+    }
+
+    private UnknownHostException resolveNonExistentDomain(DnsNameResolver resolver) {
+        try {
+            resolver.resolve("non-existent.netty.io").sync();
+            fail();
+            return null;
+        } catch (Exception e) {
+            assertThat(e, is(instanceOf(UnknownHostException.class)));
+            return (UnknownHostException) e;
+        }
+    }
+
+    @Test
+    public void testResolveIp() {
+        DnsNameResolver resolver = newResolver().build();
+        try {
+            InetAddress address = resolver.resolve("10.0.0.1").syncUninterruptibly().getNow();
+
+            assertEquals("10.0.0.1", address.getHostAddress());
+        } finally {
+            resolver.close();
+        }
+    }
+
+    private void resolve(DnsNameResolver resolver, Map<String, Future<InetAddress>> futures, String hostname) {
+
+        futures.put(hostname, resolver.resolve(hostname));
+    }
+
+    private static void queryMx(
+            DnsNameResolver resolver,
+            Map<String, Future<AddressedEnvelope<DnsResponse, InetSocketAddress>>> futures,
+            String hostname) throws Exception {
+        futures.put(hostname, resolver.query(new DefaultDnsQuestion(hostname, DnsRecordType.MX)));
+    }
+
+    private static final class TestDnsServer extends DnsServer {
+        private static final Map<String, byte[]> BYTES = new HashMap<String, byte[]>();
+        private static final String[] IPV6_ADDRESSES;
+        static {
+            BYTES.put("::1", new byte[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1});
+            BYTES.put("0:0:0:0:0:0:1:1", new byte[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1});
+            BYTES.put("0:0:0:0:0:1:1:1", new byte[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1});
+            BYTES.put("0:0:0:0:1:1:1:1", new byte[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1});
+            BYTES.put("0:0:0:1:1:1:1:1", new byte[] {0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1});
+            BYTES.put("0:0:1:1:1:1:1:1", new byte[] {0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1});
+            BYTES.put("0:1:1:1:1:1:1:1", new byte[] {0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1});
+            BYTES.put("1:1:1:1:1:1:1:1", new byte[] {0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1});
+
+            IPV6_ADDRESSES = BYTES.keySet().toArray(new String[BYTES.size()]);
+        }
+
+        @Override
+        public void start() throws IOException {
+            InetSocketAddress address = new InetSocketAddress(NetUtil.LOCALHOST4, 0);
+            UdpTransport transport = new UdpTransport(address.getHostName(), address.getPort());
+            setTransports(transport);
+
+            DatagramAcceptor acceptor = transport.getAcceptor();
+
+            acceptor.setHandler(new DnsProtocolHandler(this, new TestRecordStore()) {
+                @Override
+                public void sessionCreated(IoSession session) throws Exception {
+                    // USe our own codec to support AAAA testing
+                    session.getFilterChain()
+                           .addFirst("codec", new ProtocolCodecFilter(new TestDnsProtocolUdpCodecFactory()));
+                }
+            });
+
+            ((DatagramSessionConfig) acceptor.getSessionConfig()).setReuseAddress(true);
+
+            // Start the listener
+            acceptor.bind();
+        }
+
+        public InetSocketAddress localAddress() {
+            return (InetSocketAddress) getTransports()[0].getAcceptor().getLocalAddress();
+        }
+
+        /**
+         * {@link ProtocolCodecFactory} which allows to test AAAA resolution.
+         */
+        private static final class TestDnsProtocolUdpCodecFactory implements ProtocolCodecFactory {
+            private final DnsMessageEncoder encoder = new DnsMessageEncoder();
+            private final TestAAAARecordEncoder recordEncoder = new TestAAAARecordEncoder();
+
+            @Override
+            public ProtocolEncoder getEncoder(IoSession session) throws Exception {
+                return new DnsUdpEncoder() {
+
+                    @Override
+                    public void encode(IoSession session, Object message, ProtocolEncoderOutput out) {
+                        IoBuffer buf = IoBuffer.allocate(1024);
+                        DnsMessage dnsMessage = (DnsMessage) message;
+                        encoder.encode(buf, dnsMessage);
+                        for (ResourceRecord record: dnsMessage.getAnswerRecords()) {
+                            // This is a hack to allow to also test for AAAA resolution as DnsMessageEncoder
+                            // does not support it and it is hard to extend, because the interesting methods
+                            // are private...
+                            // In case of RecordType.AAAA we need to encode the RecordType by ourself.
+                            if (record.getRecordType() == RecordType.AAAA) {
+                                try {
+                                    recordEncoder.put(buf, record);
+                                } catch (IOException e) {
+                                    // Should never happen
+                                    throw new IllegalStateException(e);
+                                }
+                            }
+                        }
+                        buf.flip();
+
+                        out.write(buf);
+                    }
+                };
+            }
+
+            @Override
+            public ProtocolDecoder getDecoder(IoSession session) throws Exception {
+                return new DnsUdpDecoder();
+            }
+
+            private static final class TestAAAARecordEncoder extends ResourceRecordEncoder {
+
+                @Override
+                protected void putResourceRecordData(IoBuffer ioBuffer, ResourceRecord resourceRecord) {
+                    byte[] bytes = BYTES.get(resourceRecord.get(DnsAttribute.IP_ADDRESS));
+                    if (bytes == null) {
+                        throw new IllegalStateException();
+                    }
+                    // encode the ::1
+                    ioBuffer.put(bytes);
+                }
+            }
+        }
+
+        private static final class TestRecordStore implements RecordStore {
+            private static final int[] NUMBERS = new int[254];
+            private static final char[] CHARS = new char[26];
+
+            static {
+                for (int i = 0; i < NUMBERS.length; i++) {
+                    NUMBERS[i] = i + 1;
+                }
+
+                for (int i = 0; i < CHARS.length; i++) {
+                    CHARS[i] =  (char) ('a' + i);
+                }
+            }
+
+            private static int index(int arrayLength) {
+                return Math.abs(ThreadLocalRandom.current().nextInt()) % arrayLength;
+            }
+
+            private static String nextDomain() {
+               return CHARS[index(CHARS.length)] + ".netty.io";
+            }
+
+            private static String nextIp() {
+                return ippart() + "." + ippart() + '.' + ippart() + '.' + ippart();
+            }
+
+            private static int ippart() {
+                return NUMBERS[index(NUMBERS.length)];
+            }
+
+            private static String nextIp6() {
+                return IPV6_ADDRESSES[index(IPV6_ADDRESSES.length)];
+            }
+
+            @Override
+            public Set<ResourceRecord> getRecords(QuestionRecord questionRecord) {
+                String name = questionRecord.getDomainName();
+                if (DOMAINS.contains(name)) {
+                    ResourceRecordModifier rm = new ResourceRecordModifier();
+                    rm.setDnsClass(RecordClass.IN);
+                    rm.setDnsName(name);
+                    rm.setDnsTtl(100);
+                    rm.setDnsType(questionRecord.getRecordType());
+
+                    switch (questionRecord.getRecordType()) {
+                    case A:
+                        do {
+                            rm.put(DnsAttribute.IP_ADDRESS, nextIp());
+                        } while (ThreadLocalRandom.current().nextBoolean());
+                        break;
+                    case AAAA:
+                        do {
+                            rm.put(DnsAttribute.IP_ADDRESS, nextIp6());
+                        } while (ThreadLocalRandom.current().nextBoolean());
+                        break;
+                    case MX:
+                        int prioritity = 0;
+                        do {
+                            rm.put(DnsAttribute.DOMAIN_NAME, nextDomain());
+                            rm.put(DnsAttribute.MX_PREFERENCE, String.valueOf(++prioritity));
+                        } while (ThreadLocalRandom.current().nextBoolean());
+                        break;
+                    default:
+                        return null;
+                    }
+                    return Collections.singleton(rm.getEntry());
+                }
+                return null;
+            }
+        }
+    }
+}
diff --git a/netty-bp/resolver-dns/src/test/java/io/netty/resolver/dns/DnsServerAddressesTest.java b/netty-bp/resolver-dns/src/test/java/io/netty/resolver/dns/DnsServerAddressesTest.java
new file mode 100644
index 000000000..69a72907e
--- /dev/null
+++ b/netty-bp/resolver-dns/src/test/java/io/netty/resolver/dns/DnsServerAddressesTest.java
@@ -0,0 +1,126 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.resolver.dns;
+
+import io.netty.util.NetUtil;
+import org.junit.Test;
+
+import java.net.InetSocketAddress;
+import java.util.Collections;
+import java.util.IdentityHashMap;
+import java.util.Set;
+
+import static org.hamcrest.Matchers.*;
+import static org.junit.Assert.*;
+
+public class DnsServerAddressesTest {
+
+    private static final InetSocketAddress ADDR1 = new InetSocketAddress(NetUtil.LOCALHOST, 1);
+    private static final InetSocketAddress ADDR2 = new InetSocketAddress(NetUtil.LOCALHOST, 2);
+    private static final InetSocketAddress ADDR3 = new InetSocketAddress(NetUtil.LOCALHOST, 3);
+
+    @Test
+    public void testDefaultAddresses() {
+        assertThat(DnsServerAddresses.defaultAddressList().size(), is(greaterThan(0)));
+    }
+
+    @Test
+    public void testSequential() {
+        DnsServerAddresses seq = DnsServerAddresses.sequential(ADDR1, ADDR2, ADDR3);
+        assertThat(seq.stream(), is(not(sameInstance(seq.stream()))));
+
+        for (int j = 0; j < 2; j ++) {
+            DnsServerAddressStream i = seq.stream();
+            assertNext(i, ADDR1);
+            assertNext(i, ADDR2);
+            assertNext(i, ADDR3);
+            assertNext(i, ADDR1);
+            assertNext(i, ADDR2);
+            assertNext(i, ADDR3);
+        }
+    }
+
+    @Test
+    public void testRotational() {
+        DnsServerAddresses seq = DnsServerAddresses.rotational(ADDR1, ADDR2, ADDR3);
+
+        DnsServerAddressStream i = seq.stream();
+        assertNext(i, ADDR1);
+        assertNext(i, ADDR2);
+        assertNext(i, ADDR3);
+        assertNext(i, ADDR1);
+        assertNext(i, ADDR2);
+        assertNext(i, ADDR3);
+
+        i = seq.stream();
+        assertNext(i, ADDR2);
+        assertNext(i, ADDR3);
+        assertNext(i, ADDR1);
+        assertNext(i, ADDR2);
+        assertNext(i, ADDR3);
+        assertNext(i, ADDR1);
+
+        i = seq.stream();
+        assertNext(i, ADDR3);
+        assertNext(i, ADDR1);
+        assertNext(i, ADDR2);
+        assertNext(i, ADDR3);
+        assertNext(i, ADDR1);
+        assertNext(i, ADDR2);
+
+        i = seq.stream();
+        assertNext(i, ADDR1);
+        assertNext(i, ADDR2);
+        assertNext(i, ADDR3);
+        assertNext(i, ADDR1);
+        assertNext(i, ADDR2);
+        assertNext(i, ADDR3);
+    }
+
+    @Test
+    public void testShuffled() {
+        DnsServerAddresses seq = DnsServerAddresses.shuffled(ADDR1, ADDR2, ADDR3);
+
+        // Ensure that all three addresses are returned by the iterator.
+        // In theory, this test can fail at extremely low chance, but we don't really care.
+        Set<InetSocketAddress> set = Collections.newSetFromMap(new IdentityHashMap<InetSocketAddress, Boolean>());
+        DnsServerAddressStream i = seq.stream();
+        for (int j = 0; j < 1048576; j ++) {
+            set.add(i.next());
+        }
+
+        assertThat(set.size(), is(3));
+        assertThat(seq.stream(), is(not(sameInstance(seq.stream()))));
+    }
+
+    @Test
+    public void testSingleton() {
+        DnsServerAddresses seq = DnsServerAddresses.singleton(ADDR1);
+
+        // Should return the same iterator instance for least possible footprint.
+        assertThat(seq.stream(), is(sameInstance(seq.stream())));
+
+        DnsServerAddressStream i = seq.stream();
+        assertNext(i, ADDR1);
+        assertNext(i, ADDR1);
+        assertNext(i, ADDR1);
+    }
+
+    private static void assertNext(DnsServerAddressStream i, InetSocketAddress addr) {
+        assertThat(i.next(), is(sameInstance(addr)));
+    }
+}
diff --git a/netty-bp/resolver-dns/src/test/resources/logback-test.xml b/netty-bp/resolver-dns/src/test/resources/logback-test.xml
new file mode 100644
index 000000000..86ce77963
--- /dev/null
+++ b/netty-bp/resolver-dns/src/test/resources/logback-test.xml
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  ~ Copyright 2015 The Netty Project
+  ~
+  ~ The Netty Project licenses this file to you under the Apache License,
+  ~ version 2.0 (the "License"); you may not use this file except in compliance
+  ~ with the License. You may obtain a copy of the License at:
+  ~
+  ~   http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+  ~ WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+  ~ License for the specific language governing permissions and limitations
+  ~ under the License.
+  -->
+<configuration>
+
+  <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
+    <!-- encoders are assigned the type
+         ch.qos.logback.classic.encoder.PatternLayoutEncoder by default -->
+    <encoder>
+      <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
+    </encoder>
+  </appender>
+
+  <root level="info">
+    <appender-ref ref="STDOUT" />
+  </root>
+
+  // Disable logging for apacheds to reduce noise.
+  <logger name="org.apache.directory" level="off"/>
+</configuration>
diff --git a/netty-bp/resolver/pom.xml b/netty-bp/resolver/pom.xml
new file mode 100644
index 000000000..9c7f0c2ba
--- /dev/null
+++ b/netty-bp/resolver/pom.xml
@@ -0,0 +1,37 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  ~ Copyright 2014 The Netty Project
+  ~
+  ~ The Netty Project licenses this file to you under the Apache License,
+  ~ version 2.0 (the "License"); you may not use this file except in compliance
+  ~ with the License. You may obtain a copy of the License at:
+  ~
+  ~   http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+  ~ WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+  ~ License for the specific language governing permissions and limitations
+  ~ under the License.
+  -->
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+
+  <modelVersion>4.0.0</modelVersion>
+  <parent>
+    <groupId>org.asynchttpclient</groupId>
+    <artifactId>netty-bp</artifactId>
+    <version>2.0.0-RC9-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>netty-resolver</artifactId>
+
+  <name>Netty/Resolver</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>io.netty</groupId>
+      <artifactId>netty-common</artifactId>
+    </dependency>
+  </dependencies>
+</project>
+
diff --git a/netty-bp/resolver/src/main/java/io/netty/resolver/AbstractAddressResolver.java b/netty-bp/resolver/src/main/java/io/netty/resolver/AbstractAddressResolver.java
new file mode 100644
index 000000000..35ed52e3a
--- /dev/null
+++ b/netty-bp/resolver/src/main/java/io/netty/resolver/AbstractAddressResolver.java
@@ -0,0 +1,206 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.resolver;
+
+import io.netty.util.concurrent.EventExecutor;
+import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.Promise;
+import io.netty.util.internal.TypeParameterMatcher;
+
+import java.net.SocketAddress;
+import java.nio.channels.UnsupportedAddressTypeException;
+import java.util.Collections;
+import java.util.List;
+
+import static io.netty.util.internal.ObjectUtil.checkNotNull;
+
+/**
+ * A skeletal {@link AddressResolver} implementation.
+ */
+public abstract class AbstractAddressResolver<T extends SocketAddress> implements AddressResolver<T> {
+
+    private final EventExecutor executor;
+    private final TypeParameterMatcher matcher;
+
+    /**
+     * @param executor the {@link EventExecutor} which is used to notify the listeners of the {@link Future} returned
+     *                 by {@link #resolve(SocketAddress)}
+     */
+    protected AbstractAddressResolver(EventExecutor executor) {
+        this.executor = checkNotNull(executor, "executor");
+        matcher = TypeParameterMatcher.find(this, AbstractAddressResolver.class, "T");
+    }
+
+    /**
+     * @param executor the {@link EventExecutor} which is used to notify the listeners of the {@link Future} returned
+     *                 by {@link #resolve(SocketAddress)}
+     * @param addressType the type of the {@link SocketAddress} supported by this resolver
+     */
+    protected AbstractAddressResolver(EventExecutor executor, Class<? extends T> addressType) {
+        this.executor = checkNotNull(executor, "executor");
+        matcher = TypeParameterMatcher.get(addressType);
+    }
+
+    /**
+     * Returns the {@link EventExecutor} which is used to notify the listeners of the {@link Future} returned
+     * by {@link #resolve(SocketAddress)}.
+     */
+    protected EventExecutor executor() {
+        return executor;
+    }
+
+    @Override
+    public boolean isSupported(SocketAddress address) {
+        return matcher.match(address);
+    }
+
+    @Override
+    public final boolean isResolved(SocketAddress address) {
+        if (!isSupported(address)) {
+            throw new UnsupportedAddressTypeException();
+        }
+
+        @SuppressWarnings("unchecked")
+        final T castAddress = (T) address;
+        return doIsResolved(castAddress);
+    }
+
+    /**
+     * Invoked by {@link #isResolved(SocketAddress)} to check if the specified {@code address} has been resolved
+     * already.
+     */
+    protected abstract boolean doIsResolved(T address);
+
+    @Override
+    public final Future<T> resolve(SocketAddress address) {
+        if (!isSupported(checkNotNull(address, "address"))) {
+            // Address type not supported by the resolver
+            return executor().newFailedFuture(new UnsupportedAddressTypeException());
+        }
+
+        if (isResolved(address)) {
+            // Resolved already; no need to perform a lookup
+            @SuppressWarnings("unchecked")
+            final T cast = (T) address;
+            return executor.newSucceededFuture(cast);
+        }
+
+        try {
+            @SuppressWarnings("unchecked")
+            final T cast = (T) address;
+            final Promise<T> promise = executor().newPromise();
+            doResolve(cast, promise);
+            return promise;
+        } catch (Exception e) {
+            return executor().newFailedFuture(e);
+        }
+    }
+
+    @Override
+    public final Future<T> resolve(SocketAddress address, Promise<T> promise) {
+        checkNotNull(address, "address");
+        checkNotNull(promise, "promise");
+
+        if (!isSupported(address)) {
+            // Address type not supported by the resolver
+            return promise.setFailure(new UnsupportedAddressTypeException());
+        }
+
+        if (isResolved(address)) {
+            // Resolved already; no need to perform a lookup
+            @SuppressWarnings("unchecked")
+            final T cast = (T) address;
+            return promise.setSuccess(cast);
+        }
+
+        try {
+            @SuppressWarnings("unchecked")
+            final T cast = (T) address;
+            doResolve(cast, promise);
+            return promise;
+        } catch (Exception e) {
+            return promise.setFailure(e);
+        }
+    }
+
+    @Override
+    public final Future<List<T>> resolveAll(SocketAddress address) {
+        if (!isSupported(checkNotNull(address, "address"))) {
+            // Address type not supported by the resolver
+            return executor().newFailedFuture(new UnsupportedAddressTypeException());
+        }
+
+        if (isResolved(address)) {
+            // Resolved already; no need to perform a lookup
+            @SuppressWarnings("unchecked")
+            final T cast = (T) address;
+            return executor.newSucceededFuture(Collections.singletonList(cast));
+        }
+
+        try {
+            @SuppressWarnings("unchecked")
+            final T cast = (T) address;
+            final Promise<List<T>> promise = executor().newPromise();
+            doResolveAll(cast, promise);
+            return promise;
+        } catch (Exception e) {
+            return executor().newFailedFuture(e);
+        }
+    }
+
+    @Override
+    public final Future<List<T>> resolveAll(SocketAddress address, Promise<List<T>> promise) {
+        checkNotNull(address, "address");
+        checkNotNull(promise, "promise");
+
+        if (!isSupported(address)) {
+            // Address type not supported by the resolver
+            return promise.setFailure(new UnsupportedAddressTypeException());
+        }
+
+        if (isResolved(address)) {
+            // Resolved already; no need to perform a lookup
+            @SuppressWarnings("unchecked")
+            final T cast = (T) address;
+            return promise.setSuccess(Collections.singletonList(cast));
+        }
+
+        try {
+            @SuppressWarnings("unchecked")
+            final T cast = (T) address;
+            doResolveAll(cast, promise);
+            return promise;
+        } catch (Exception e) {
+            return promise.setFailure(e);
+        }
+    }
+
+    /**
+     * Invoked by {@link #resolve(SocketAddress)} to perform the actual name
+     * resolution.
+     */
+    protected abstract void doResolve(T unresolvedAddress, Promise<T> promise) throws Exception;
+
+    /**
+     * Invoked by {@link #resolveAll(SocketAddress)} to perform the actual name
+     * resolution.
+     */
+    protected abstract void doResolveAll(T unresolvedAddress, Promise<List<T>> promise) throws Exception;
+
+    @Override
+    public void close() { }
+}
diff --git a/netty-bp/resolver/src/main/java/io/netty/resolver/AddressResolver.java b/netty-bp/resolver/src/main/java/io/netty/resolver/AddressResolver.java
new file mode 100644
index 000000000..adb613a50
--- /dev/null
+++ b/netty-bp/resolver/src/main/java/io/netty/resolver/AddressResolver.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.resolver;
+
+import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.Promise;
+
+import java.io.Closeable;
+import java.net.SocketAddress;
+import java.nio.channels.UnsupportedAddressTypeException;
+import java.util.List;
+
+/**
+ * Resolves a possibility unresolved {@link SocketAddress}.
+ */
+public interface AddressResolver<T extends SocketAddress> extends Closeable {
+
+  /**
+   * Returns {@code true} if and only if the specified address is supported by this resolved.
+   */
+  boolean isSupported(SocketAddress address);
+
+  /**
+   * Returns {@code true} if and only if the specified address has been resolved.
+   *
+   * @throws UnsupportedAddressTypeException if the specified address is not supported by this resolver
+   */
+  boolean isResolved(SocketAddress address);
+
+  /**
+   * Resolves the specified address. If the specified address is resolved already, this method does nothing
+   * but returning the original address.
+   *
+   * @param address the address to resolve
+   *
+   * @return the {@link SocketAddress} as the result of the resolution
+   */
+  Future<T> resolve(SocketAddress address);
+
+  /**
+   * Resolves the specified address. If the specified address is resolved already, this method does nothing
+   * but returning the original address.
+   *
+   * @param address the address to resolve
+   * @param promise the {@link Promise} which will be fulfilled when the name resolution is finished
+   *
+   * @return the {@link SocketAddress} as the result of the resolution
+   */
+  Future<T> resolve(SocketAddress address, Promise<T> promise);
+
+  /**
+   * Resolves the specified address. If the specified address is resolved already, this method does nothing
+   * but returning the original address.
+   *
+   * @param address the address to resolve
+   *
+   * @return the list of the {@link SocketAddress}es as the result of the resolution
+   */
+  Future<List<T>> resolveAll(SocketAddress address);
+
+  /**
+   * Resolves the specified address. If the specified address is resolved already, this method does nothing
+   * but returning the original address.
+   *
+   * @param address the address to resolve
+   * @param promise the {@link Promise} which will be fulfilled when the name resolution is finished
+   *
+   * @return the list of the {@link SocketAddress}es as the result of the resolution
+   */
+  Future<List<T>> resolveAll(SocketAddress address, Promise<List<T>> promise);
+
+  /**
+   * Closes all the resources allocated and used by this resolver.
+   */
+  @Override
+  void close();
+}
diff --git a/netty-bp/resolver/src/main/java/io/netty/resolver/AddressResolverGroup.java b/netty-bp/resolver/src/main/java/io/netty/resolver/AddressResolverGroup.java
new file mode 100644
index 000000000..89b00dfa0
--- /dev/null
+++ b/netty-bp/resolver/src/main/java/io/netty/resolver/AddressResolverGroup.java
@@ -0,0 +1,113 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.resolver;
+
+import io.netty.util.concurrent.EventExecutor;
+import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.FutureListener;
+import io.netty.util.internal.logging.InternalLogger;
+import io.netty.util.internal.logging.InternalLoggerFactory;
+
+import java.io.Closeable;
+import java.net.SocketAddress;
+import java.util.IdentityHashMap;
+import java.util.Map;
+import java.util.concurrent.ConcurrentMap;
+
+/**
+ * Creates and manages {@link NameResolver}s so that each {@link EventExecutor} has its own resolver instance.
+ */
+public abstract class AddressResolverGroup<T extends SocketAddress> implements Closeable {
+
+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(AddressResolverGroup.class);
+
+    /**
+     * Note that we do not use a {@link ConcurrentMap} here because it is usually expensive to instantiate a resolver.
+     */
+    private final Map<EventExecutor, AddressResolver<T>> resolvers =
+            new IdentityHashMap<EventExecutor, AddressResolver<T>>();
+
+    protected AddressResolverGroup() { }
+
+    /**
+     * Returns the {@link AddressResolver} associated with the specified {@link EventExecutor}. If there's no associated
+     * resolved found, this method creates and returns a new resolver instance created by
+     * {@link #newResolver(EventExecutor)} so that the new resolver is reused on another
+     * {@link #getResolver(EventExecutor)} call with the same {@link EventExecutor}.
+     */
+    public AddressResolver<T> getResolver(final EventExecutor executor) {
+        if (executor == null) {
+            throw new NullPointerException("executor");
+        }
+
+        if (executor.isShuttingDown()) {
+            throw new IllegalStateException("executor not accepting a task");
+        }
+
+        AddressResolver<T> r;
+        synchronized (resolvers) {
+            r = resolvers.get(executor);
+            if (r == null) {
+                final AddressResolver<T> newResolver;
+                try {
+                    newResolver = newResolver(executor);
+                } catch (Exception e) {
+                    throw new IllegalStateException("failed to create a new resolver", e);
+                }
+
+                resolvers.put(executor, newResolver);
+                executor.terminationFuture().addListener(new FutureListener<Object>() {
+                    @Override
+                    public void operationComplete(Future<Object> future) throws Exception {
+                        resolvers.remove(executor);
+                        newResolver.close();
+                    }
+                });
+
+                r = newResolver;
+            }
+        }
+
+        return r;
+    }
+
+    /**
+     * Invoked by {@link #getResolver(EventExecutor)} to create a new {@link AddressResolver}.
+     */
+    protected abstract AddressResolver<T> newResolver(EventExecutor executor) throws Exception;
+
+    /**
+     * Closes all {@link NameResolver}s created by this group.
+     */
+    @Override
+    @SuppressWarnings({ "unchecked", "SuspiciousToArrayCall" })
+    public void close() {
+        final AddressResolver<T>[] rArray;
+        synchronized (resolvers) {
+            rArray = (AddressResolver<T>[]) resolvers.values().toArray(new AddressResolver[resolvers.size()]);
+            resolvers.clear();
+        }
+
+        for (AddressResolver<T> r: rArray) {
+            try {
+                r.close();
+            } catch (Throwable t) {
+                logger.warn("Failed to close a resolver:", t);
+            }
+        }
+    }
+}
diff --git a/netty-bp/resolver/src/main/java/io/netty/resolver/CompositeNameResolver.java b/netty-bp/resolver/src/main/java/io/netty/resolver/CompositeNameResolver.java
new file mode 100644
index 000000000..7f5abdf0d
--- /dev/null
+++ b/netty-bp/resolver/src/main/java/io/netty/resolver/CompositeNameResolver.java
@@ -0,0 +1,108 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.resolver;
+
+import io.netty.util.concurrent.EventExecutor;
+import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.FutureListener;
+import io.netty.util.concurrent.Promise;
+
+import java.util.Arrays;
+import java.util.List;
+
+import static io.netty.util.internal.ObjectUtil.*;
+
+/**
+ * A composite {@link SimpleNameResolver} that resolves a host name against a sequence of {@link NameResolver}s.
+ *
+ * In case of a failure, only the last one will be reported.
+ */
+public final class CompositeNameResolver<T> extends SimpleNameResolver<T> {
+
+    private final NameResolver<T>[] resolvers;
+
+    /**
+     * @param executor the {@link EventExecutor} which is used to notify the listeners of the {@link Future} returned
+     *                 by {@link #resolve(String)}
+     * @param resolvers the {@link NameResolver}s to be tried sequentially
+     */
+    public CompositeNameResolver(EventExecutor executor, NameResolver<T>... resolvers) {
+        super(executor);
+        checkNotNull(resolvers, "resolvers");
+        for (int i = 0; i < resolvers.length; i++) {
+            if (resolvers[i] == null) {
+                throw new NullPointerException("resolvers[" + i + ']');
+            }
+        }
+        if (resolvers.length < 2) {
+            throw new IllegalArgumentException("resolvers: " + Arrays.asList(resolvers) +
+                    " (expected: at least 2 resolvers)");
+        }
+        this.resolvers = resolvers.clone();
+    }
+
+    @Override
+    protected void doResolve(String inetHost, Promise<T> promise) throws Exception {
+        doResolveRec(inetHost, promise, 0, null);
+    }
+
+    private void doResolveRec(final String inetHost,
+                              final Promise<T> promise,
+                              final int resolverIndex,
+                              Throwable lastFailure) throws Exception {
+        if (resolverIndex >= resolvers.length) {
+            promise.setFailure(lastFailure);
+        } else {
+            NameResolver resolver = resolvers[resolverIndex];
+            resolver.resolve(inetHost).addListener(new FutureListener<T>() {
+                @Override
+                public void operationComplete(Future<T> future) throws Exception {
+                    if (future.isSuccess()) {
+                        promise.setSuccess(future.getNow());
+                    } else {
+                        doResolveRec(inetHost, promise, resolverIndex + 1, future.cause());
+                    }
+                }
+            });
+        }
+    }
+
+    @Override
+    protected void doResolveAll(String inetHost, Promise<List<T>> promise) throws Exception {
+        doResolveAllRec(inetHost, promise, 0, null);
+    }
+
+    private void doResolveAllRec(final String inetHost,
+                              final Promise<List<T>> promise,
+                              final int resolverIndex,
+                              Throwable lastFailure) throws Exception {
+        if (resolverIndex >= resolvers.length) {
+            promise.setFailure(lastFailure);
+        } else {
+            NameResolver resolver = resolvers[resolverIndex];
+            resolver.resolveAll(inetHost).addListener(new FutureListener<List<T>>() {
+                @Override
+                public void operationComplete(Future<List<T>> future) throws Exception {
+                    if (future.isSuccess()) {
+                        promise.setSuccess(future.getNow());
+                    } else {
+                        doResolveAllRec(inetHost, promise, resolverIndex + 1, future.cause());
+                    }
+                }
+            });
+        }
+    }
+}
diff --git a/netty-bp/resolver/src/main/java/io/netty/resolver/DefaultAddressResolverGroup.java b/netty-bp/resolver/src/main/java/io/netty/resolver/DefaultAddressResolverGroup.java
new file mode 100644
index 000000000..1b6fb5317
--- /dev/null
+++ b/netty-bp/resolver/src/main/java/io/netty/resolver/DefaultAddressResolverGroup.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.resolver;
+
+import io.netty.util.concurrent.EventExecutor;
+
+import java.net.InetSocketAddress;
+
+/**
+ * A {@link AddressResolverGroup} of {@link DefaultNameResolver}s.
+ */
+public final class DefaultAddressResolverGroup extends AddressResolverGroup<InetSocketAddress> {
+
+    public static final DefaultAddressResolverGroup INSTANCE = new DefaultAddressResolverGroup();
+
+    private DefaultAddressResolverGroup() { }
+
+    @Override
+    protected AddressResolver<InetSocketAddress> newResolver(EventExecutor executor) throws Exception {
+        return new DefaultNameResolver(executor).asAddressResolver();
+    }
+}
diff --git a/netty-bp/resolver/src/main/java/io/netty/resolver/DefaultHostsFileEntriesResolver.java b/netty-bp/resolver/src/main/java/io/netty/resolver/DefaultHostsFileEntriesResolver.java
new file mode 100644
index 000000000..3d19042e5
--- /dev/null
+++ b/netty-bp/resolver/src/main/java/io/netty/resolver/DefaultHostsFileEntriesResolver.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.resolver;
+
+import java.net.InetAddress;
+import java.util.Map;
+
+/**
+ * Default {@link HostsFileEntriesResolver} that resolves hosts file entries only once.
+ */
+public final class DefaultHostsFileEntriesResolver implements HostsFileEntriesResolver {
+
+    private final Map<String, InetAddress> entries = HostsFileParser.parseSilently();
+
+    @Override
+    public InetAddress address(String inetHost) {
+        return entries.get(inetHost);
+    }
+}
diff --git a/netty-bp/resolver/src/main/java/io/netty/resolver/DefaultNameResolver.java b/netty-bp/resolver/src/main/java/io/netty/resolver/DefaultNameResolver.java
new file mode 100644
index 000000000..944cea277
--- /dev/null
+++ b/netty-bp/resolver/src/main/java/io/netty/resolver/DefaultNameResolver.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.resolver;
+
+import io.netty.util.concurrent.EventExecutor;
+import io.netty.util.concurrent.Promise;
+
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * A {@link InetNameResolver} that resolves using JDK's built-in domain name lookup mechanism.
+ * Note that this resolver performs a blocking name lookup from the caller thread.
+ */
+public class DefaultNameResolver extends InetNameResolver {
+
+    public DefaultNameResolver(EventExecutor executor) {
+        super(executor);
+    }
+
+    @Override
+    protected void doResolve(String inetHost, Promise<InetAddress> promise) throws Exception {
+        try {
+            promise.setSuccess(InetAddress.getByName(inetHost));
+        } catch (UnknownHostException e) {
+            promise.setFailure(e);
+        }
+    }
+
+    @Override
+    protected void doResolveAll(String inetHost, Promise<List<InetAddress>> promise) throws Exception {
+        try {
+            promise.setSuccess(Arrays.asList(InetAddress.getAllByName(inetHost)));
+        } catch (UnknownHostException e) {
+            promise.setFailure(e);
+        }
+    }
+}
diff --git a/netty-bp/resolver/src/main/java/io/netty/resolver/HostsFileEntriesResolver.java b/netty-bp/resolver/src/main/java/io/netty/resolver/HostsFileEntriesResolver.java
new file mode 100644
index 000000000..35bae47ac
--- /dev/null
+++ b/netty-bp/resolver/src/main/java/io/netty/resolver/HostsFileEntriesResolver.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.resolver;
+
+import java.net.InetAddress;
+
+/**
+ * Resolves a hostname against the hosts file entries.
+ */
+public interface HostsFileEntriesResolver {
+
+    /**
+     * Default instance: a {@link DefaultHostsFileEntriesResolver}.
+     */
+    HostsFileEntriesResolver DEFAULT = new DefaultHostsFileEntriesResolver();
+
+    InetAddress address(String inetHost);
+}
diff --git a/netty-bp/resolver/src/main/java/io/netty/resolver/HostsFileParser.java b/netty-bp/resolver/src/main/java/io/netty/resolver/HostsFileParser.java
new file mode 100644
index 000000000..0e8b9163c
--- /dev/null
+++ b/netty-bp/resolver/src/main/java/io/netty/resolver/HostsFileParser.java
@@ -0,0 +1,176 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.resolver;
+
+import io.netty.util.NetUtil;
+import io.netty.util.internal.PlatformDependent;
+import io.netty.util.internal.logging.InternalLogger;
+import io.netty.util.internal.logging.InternalLoggerFactory;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileReader;
+import java.io.IOException;
+import java.io.Reader;
+import java.net.InetAddress;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.regex.Pattern;
+
+import static io.netty.util.internal.ObjectUtil.*;
+
+/**
+ * A parser for hosts files.
+ */
+public final class HostsFileParser {
+
+    private static final String WINDOWS_DEFAULT_SYSTEM_ROOT = "C:\\Windows";
+    private static final String WINDOWS_HOSTS_FILE_RELATIVE_PATH = "\\system32\\drivers\\etc\\hosts";
+    private static final String X_PLATFORMS_HOSTS_FILE_PATH = "/etc/hosts";
+
+    private static final Pattern WHITESPACES = Pattern.compile("[ \t]+");
+
+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(HostsFileParser.class);
+
+    private static File locateHostsFile() {
+        File hostsFile;
+        if (PlatformDependent.isWindows()) {
+            hostsFile = new File(System.getenv("SystemRoot") + WINDOWS_HOSTS_FILE_RELATIVE_PATH);
+            if (!hostsFile.exists()) {
+                hostsFile = new File(WINDOWS_DEFAULT_SYSTEM_ROOT + WINDOWS_HOSTS_FILE_RELATIVE_PATH);
+            }
+        } else {
+            hostsFile = new File(X_PLATFORMS_HOSTS_FILE_PATH);
+        }
+        return hostsFile;
+    }
+
+    /**
+     * Parse hosts file at standard OS location.
+     *
+     * @return a map of hostname or alias to {@link InetAddress}
+     */
+    public static Map<String, InetAddress> parseSilently() {
+        File hostsFile = locateHostsFile();
+        try {
+            return parse(hostsFile);
+        } catch (IOException e) {
+            logger.warn("Failed to load and parse hosts file at " + hostsFile.getPath(), e);
+            return Collections.emptyMap();
+        }
+    }
+
+    /**
+     * Parse hosts file at standard OS location.
+     *
+     * @return a map of hostname or alias to {@link InetAddress}
+     * @throws IOException file could not be read
+     */
+    public static Map<String, InetAddress> parse() throws IOException {
+        return parse(locateHostsFile());
+    }
+
+    /**
+     * Parse a hosts file.
+     *
+     * @param file the file to be parsed
+     * @return a map of hostname or alias to {@link InetAddress}
+     * @throws IOException file could not be read
+     */
+    public static Map<String, InetAddress> parse(File file) throws IOException {
+        checkNotNull(file, "file");
+        if (file.exists() && file.isFile()) {
+            return parse(new BufferedReader(new FileReader(file)));
+        } else {
+            return Collections.emptyMap();
+        }
+    }
+
+    /**
+     * Parse a reader of hosts file format.
+     *
+     * @param reader the file to be parsed
+     * @return a map of hostname or alias to {@link InetAddress}
+     * @throws IOException file could not be read
+     */
+    public static Map<String, InetAddress> parse(Reader reader) throws IOException {
+        checkNotNull(reader, "reader");
+        BufferedReader buff = new BufferedReader(reader);
+        try {
+            Map<String, InetAddress> entries = new HashMap<String, InetAddress>();
+            String line;
+            while ((line = buff.readLine()) != null) {
+                // remove comment
+                int commentPosition = line.indexOf('#');
+                if (commentPosition != -1) {
+                    line = line.substring(0, commentPosition);
+                }
+                // skip empty lines
+                line = line.trim();
+                if (line.isEmpty()) {
+                    continue;
+                }
+
+                // split
+                List<String> lineParts = new ArrayList<String>();
+                for (String s: WHITESPACES.split(line)) {
+                    if (!s.isEmpty()) {
+                        lineParts.add(s);
+                    }
+                }
+
+                // a valid line should be [IP, hostname, alias*]
+                if (lineParts.size() < 2) {
+                    // skip invalid line
+                    continue;
+                }
+
+                byte[] ipBytes = NetUtil.createByteArrayFromIpAddressString(lineParts.get(0));
+
+                if (ipBytes == null) {
+                    // skip invalid IP
+                    continue;
+                }
+
+                // loop over hostname and aliases
+                for (int i = 1; i < lineParts.size(); i ++) {
+                    String hostname = lineParts.get(i);
+                    if (!entries.containsKey(hostname)) {
+                        // trying to map a host to multiple IPs is wrong
+                        // only the first entry is honored
+                        entries.put(hostname, InetAddress.getByAddress(hostname, ipBytes));
+                    }
+                }
+            }
+            return entries;
+        } finally {
+            try {
+                buff.close();
+            } catch (IOException e) {
+                logger.warn("Failed to close a reader", e);
+            }
+        }
+    }
+
+    /**
+     * Can't be instantiated.
+     */
+    private HostsFileParser() {
+    }
+}
diff --git a/netty-bp/resolver/src/main/java/io/netty/resolver/InetNameResolver.java b/netty-bp/resolver/src/main/java/io/netty/resolver/InetNameResolver.java
new file mode 100644
index 000000000..c0ca21c72
--- /dev/null
+++ b/netty-bp/resolver/src/main/java/io/netty/resolver/InetNameResolver.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.resolver;
+
+import io.netty.util.concurrent.EventExecutor;
+import io.netty.util.concurrent.Future;
+
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+
+/**
+ * A skeletal {@link NameResolver} implementation that resolves {@link InetAddress}.
+ */
+public abstract class InetNameResolver extends SimpleNameResolver<InetAddress> {
+
+    private volatile AddressResolver<InetSocketAddress> addressResolver;
+
+    /**
+     * @param executor the {@link EventExecutor} which is used to notify the listeners of the {@link Future} returned
+     *                 by {@link #resolve(String)}
+     */
+    protected InetNameResolver(EventExecutor executor) {
+        super(executor);
+    }
+
+    /**
+     * Return a {@link AddressResolver} that will use this name resolver underneath.
+     * It's cached internally, so the same instance is always returned.
+     */
+    public AddressResolver<InetSocketAddress> asAddressResolver() {
+        AddressResolver<InetSocketAddress> result = addressResolver;
+        if (result == null) {
+            synchronized (this) {
+                result = addressResolver;
+                if (result == null) {
+                    addressResolver = result = new InetSocketAddressResolver(executor(), this);
+                }
+            }
+        }
+        return result;
+    }
+}
diff --git a/netty-bp/resolver/src/main/java/io/netty/resolver/InetSocketAddressResolver.java b/netty-bp/resolver/src/main/java/io/netty/resolver/InetSocketAddressResolver.java
new file mode 100644
index 000000000..80d4c51f8
--- /dev/null
+++ b/netty-bp/resolver/src/main/java/io/netty/resolver/InetSocketAddressResolver.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.resolver;
+
+import io.netty.util.concurrent.EventExecutor;
+import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.FutureListener;
+import io.netty.util.concurrent.Promise;
+
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * A {@link AbstractAddressResolver} that resolves {@link InetAddress}.
+ */
+public class InetSocketAddressResolver extends AbstractAddressResolver<InetSocketAddress> {
+
+    private final NameResolver<InetAddress> nameResolver;
+
+    /**
+     * @param executor the {@link EventExecutor} which is used to notify the listeners of the {@link Future} returned
+     *                 by {@link #resolve(java.net.SocketAddress)}
+     * @param nameResolver the {@link NameResolver} used for name resolution
+     */
+    public InetSocketAddressResolver(EventExecutor executor, NameResolver<InetAddress> nameResolver) {
+        super(executor, InetSocketAddress.class);
+        this.nameResolver = nameResolver;
+    }
+
+    @Override
+    protected boolean doIsResolved(InetSocketAddress address) {
+        return !address.isUnresolved();
+    }
+
+    @Override
+    protected void doResolve(final InetSocketAddress unresolvedAddress, final Promise<InetSocketAddress> promise)
+            throws Exception {
+        // Note that InetSocketAddress.getHostName() will never incur a reverse lookup here,
+        // because an unresolved address always has a host name.
+        nameResolver.resolve(unresolvedAddress.getHostName())
+                .addListener(new FutureListener<InetAddress>() {
+                    @Override
+                    public void operationComplete(Future<InetAddress> future) throws Exception {
+                        if (future.isSuccess()) {
+                            promise.setSuccess(new InetSocketAddress(future.getNow(), unresolvedAddress.getPort()));
+                        } else {
+                            promise.setFailure(future.cause());
+                        }
+                    }
+                });
+    }
+
+    @Override
+    protected void doResolveAll(final InetSocketAddress unresolvedAddress,
+                                final Promise<List<InetSocketAddress>> promise) throws Exception {
+        // Note that InetSocketAddress.getHostName() will never incur a reverse lookup here,
+        // because an unresolved address always has a host name.
+        nameResolver.resolveAll(unresolvedAddress.getHostName())
+                .addListener(new FutureListener<List<InetAddress>>() {
+                    @Override
+                    public void operationComplete(Future<List<InetAddress>> future) throws Exception {
+                        if (future.isSuccess()) {
+                            List<InetAddress> inetAddresses = future.getNow();
+                            List<InetSocketAddress> socketAddresses =
+                                    new ArrayList<InetSocketAddress>(inetAddresses.size());
+                            for (InetAddress inetAddress : inetAddresses) {
+                                socketAddresses.add(new InetSocketAddress(inetAddress, unresolvedAddress.getPort()));
+                            }
+                            promise.setSuccess(socketAddresses);
+                        } else {
+                            promise.setFailure(future.cause());
+                        }
+                    }
+                });
+    }
+}
diff --git a/netty-bp/resolver/src/main/java/io/netty/resolver/NameResolver.java b/netty-bp/resolver/src/main/java/io/netty/resolver/NameResolver.java
new file mode 100644
index 000000000..818122c4a
--- /dev/null
+++ b/netty-bp/resolver/src/main/java/io/netty/resolver/NameResolver.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.resolver;
+
+import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.Promise;
+
+import java.io.Closeable;
+import java.util.List;
+
+/**
+ * Resolves an arbitrary string that represents the name of an endpoint into an address.
+ */
+public interface NameResolver<T> extends Closeable {
+
+    /**
+     * Resolves the specified name into an address.
+     *
+     * @param inetHost the name to resolve
+     *
+     * @return the address as the result of the resolution
+     */
+    Future<T> resolve(String inetHost);
+
+    /**
+     * Resolves the specified name into an address.
+     *
+     * @param inetHost the name to resolve
+     * @param promise the {@link Promise} which will be fulfilled when the name resolution is finished
+     *
+     * @return the address as the result of the resolution
+     */
+    Future<T> resolve(String inetHost, Promise<T> promise);
+
+    /**
+     * Resolves the specified host name and port into a list of address.
+     *
+     * @param inetHost the name to resolve
+     *
+     * @return the list of the address as the result of the resolution
+     */
+    Future<List<T>> resolveAll(String inetHost);
+
+    /**
+     * Resolves the specified host name and port into a list of address.
+     *
+     * @param inetHost the name to resolve
+     * @param promise the {@link Promise} which will be fulfilled when the name resolution is finished
+     *
+     * @return the list of the address as the result of the resolution
+     */
+    Future<List<T>> resolveAll(String inetHost, Promise<List<T>> promise);
+
+    /**
+     * Closes all the resources allocated and used by this resolver.
+     */
+    @Override
+    void close();
+}
diff --git a/netty-bp/resolver/src/main/java/io/netty/resolver/NoopAddressResolver.java b/netty-bp/resolver/src/main/java/io/netty/resolver/NoopAddressResolver.java
new file mode 100644
index 000000000..c34bb576f
--- /dev/null
+++ b/netty-bp/resolver/src/main/java/io/netty/resolver/NoopAddressResolver.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.resolver;
+
+import io.netty.util.concurrent.EventExecutor;
+import io.netty.util.concurrent.Promise;
+
+import java.net.SocketAddress;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * A {@link AddressResolver} that does not perform any resolution but always reports successful resolution.
+ * This resolver is useful when name resolution is performed by a handler in a pipeline, such as a proxy handler.
+ */
+public class NoopAddressResolver extends AbstractAddressResolver<SocketAddress> {
+
+    public NoopAddressResolver(EventExecutor executor) {
+        super(executor);
+    }
+
+    @Override
+    protected boolean doIsResolved(SocketAddress address) {
+        return true;
+    }
+
+    @Override
+    protected void doResolve(SocketAddress unresolvedAddress, Promise<SocketAddress> promise) throws Exception {
+        promise.setSuccess(unresolvedAddress);
+    }
+
+    @Override
+    protected void doResolveAll(
+            SocketAddress unresolvedAddress, Promise<List<SocketAddress>> promise) throws Exception {
+        promise.setSuccess(Collections.singletonList(unresolvedAddress));
+    }
+}
diff --git a/netty-bp/resolver/src/main/java/io/netty/resolver/NoopAddressResolverGroup.java b/netty-bp/resolver/src/main/java/io/netty/resolver/NoopAddressResolverGroup.java
new file mode 100644
index 000000000..980cc50d8
--- /dev/null
+++ b/netty-bp/resolver/src/main/java/io/netty/resolver/NoopAddressResolverGroup.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.resolver;
+
+import io.netty.util.concurrent.EventExecutor;
+
+import java.net.SocketAddress;
+
+/**
+ * A {@link AddressResolverGroup} of {@link NoopAddressResolver}s.
+ */
+public final class NoopAddressResolverGroup extends AddressResolverGroup<SocketAddress> {
+
+    public static final NoopAddressResolverGroup INSTANCE = new NoopAddressResolverGroup();
+
+    private NoopAddressResolverGroup() { }
+
+    @Override
+    protected AddressResolver<SocketAddress> newResolver(EventExecutor executor) throws Exception {
+        return new NoopAddressResolver(executor);
+    }
+}
diff --git a/netty-bp/resolver/src/main/java/io/netty/resolver/SimpleNameResolver.java b/netty-bp/resolver/src/main/java/io/netty/resolver/SimpleNameResolver.java
new file mode 100644
index 000000000..e5083975f
--- /dev/null
+++ b/netty-bp/resolver/src/main/java/io/netty/resolver/SimpleNameResolver.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.resolver;
+
+import io.netty.util.concurrent.EventExecutor;
+import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.Promise;
+
+import java.util.List;
+
+import static io.netty.util.internal.ObjectUtil.*;
+
+/**
+ * A skeletal {@link NameResolver} implementation.
+ */
+public abstract class SimpleNameResolver<T> implements NameResolver<T> {
+
+    private final EventExecutor executor;
+
+    /**
+     * @param executor the {@link EventExecutor} which is used to notify the listeners of the {@link Future} returned
+     *                 by {@link #resolve(String)}
+     */
+    protected SimpleNameResolver(EventExecutor executor) {
+        this.executor = checkNotNull(executor, "executor");
+    }
+
+    /**
+     * Returns the {@link EventExecutor} which is used to notify the listeners of the {@link Future} returned
+     * by {@link #resolve(String)}.
+     */
+    protected EventExecutor executor() {
+        return executor;
+    }
+
+    @Override
+    public final Future<T> resolve(String inetHost) {
+        final Promise<T> promise = executor().newPromise();
+        return resolve(inetHost, promise);
+    }
+
+    @Override
+    public Future<T> resolve(String inetHost, Promise<T> promise) {
+        checkNotNull(inetHost, "inetHost");
+        checkNotNull(promise, "promise");
+
+        try {
+            doResolve(inetHost, promise);
+            return promise;
+        } catch (Exception e) {
+            return promise.setFailure(e);
+        }
+    }
+
+    @Override
+    public final Future<List<T>> resolveAll(String inetHost) {
+        final Promise<List<T>> promise = executor().newPromise();
+        return resolveAll(inetHost, promise);
+    }
+
+    @Override
+    public Future<List<T>> resolveAll(String inetHost, Promise<List<T>> promise) {
+        checkNotNull(inetHost, "inetHost");
+        checkNotNull(promise, "promise");
+
+        try {
+            doResolveAll(inetHost, promise);
+            return promise;
+        } catch (Exception e) {
+            return promise.setFailure(e);
+        }
+    }
+
+    /**
+     * Invoked by {@link #resolve(String)} to perform the actual name resolution.
+     */
+    protected abstract void doResolve(String inetHost, Promise<T> promise) throws Exception;
+
+    /**
+     * Invoked by {@link #resolveAll(String)} to perform the actual name resolution.
+     */
+    protected abstract void doResolveAll(String inetHost, Promise<List<T>> promise) throws Exception;
+
+    @Override
+    public void close() { }
+}
diff --git a/netty-bp/resolver/src/main/java/io/netty/resolver/package-info.java b/netty-bp/resolver/src/main/java/io/netty/resolver/package-info.java
new file mode 100644
index 000000000..a92459842
--- /dev/null
+++ b/netty-bp/resolver/src/main/java/io/netty/resolver/package-info.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+/**
+ * Resolves an arbitrary string that represents the name of an endpoint into an address.
+ */
+package io.netty.resolver;
diff --git a/netty-bp/resolver/src/test/java/io/netty/resolver/HostsFileParserTest.java b/netty-bp/resolver/src/test/java/io/netty/resolver/HostsFileParserTest.java
new file mode 100644
index 000000000..d32613389
--- /dev/null
+++ b/netty-bp/resolver/src/test/java/io/netty/resolver/HostsFileParserTest.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2015 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.resolver;
+
+import org.junit.Test;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.StringReader;
+import java.net.InetAddress;
+import java.util.Map;
+
+import static org.junit.Assert.*;
+
+public class HostsFileParserTest {
+
+    @Test
+    public void testParse() throws IOException {
+        String hostsString = new StringBuilder()
+                .append("127.0.0.1 host1").append("\n") // single hostname, separated with blanks
+                .append("\n") // empty line
+                .append("192.168.0.1\thost2").append("\n") // single hostname, separated with tabs
+                .append("#comment").append("\n") // comment at the beginning of the line
+                .append(" #comment  ").append("\n") // comment in the middle of the line
+                .append("192.168.0.2  host3  #comment").append("\n") // comment after hostname
+                .append("192.168.0.3  host4  host5 host6").append("\n") // multiple aliases
+                .append("192.168.0.4  host4").append("\n") // host mapped to a second address, must be ignored
+                .toString();
+
+        Map<String, InetAddress> entries = HostsFileParser.parse(new BufferedReader(new StringReader(hostsString)));
+
+        assertEquals("Expected 6 entries", 6, entries.size());
+        assertEquals("127.0.0.1", entries.get("host1").getHostAddress());
+        assertEquals("192.168.0.1", entries.get("host2").getHostAddress());
+        assertEquals("192.168.0.2", entries.get("host3").getHostAddress());
+        assertEquals("192.168.0.3", entries.get("host4").getHostAddress());
+        assertEquals("192.168.0.3", entries.get("host5").getHostAddress());
+        assertEquals("192.168.0.3", entries.get("host6").getHostAddress());
+    }
+}
diff --git a/pom.xml b/pom.xml
index c752a3898..87ee9d29a 100644
--- a/pom.xml
+++ b/pom.xml
@@ -9,7 +9,7 @@
 	<groupId>org.asynchttpclient</groupId>
 	<artifactId>async-http-client-project</artifactId>
 	<name>Asynchronous Http Client Project</name>
-	<version>2.0.0-SNAPSHOT</version>
+	<version>2.0.0-RC9-SNAPSHOT</version>
 	<packaging>pom</packaging>
 	<description>
         The Async Http Client (AHC) library's purpose is to allow Java
@@ -37,45 +37,15 @@
 	</mailingLists>
 
 	<prerequisites>
-		<maven>2.0.9</maven>
+		<maven>3.0.0</maven>
 	</prerequisites>
 	<developers>
-		<developer>
-			<id>brianm</id>
-			<name>Brian McCallister</name>
-			<email>brianm@skife.org</email>
-		</developer>
-		<developer>
-			<id>jfarcand</id>
-			<name>Jeanfrancois Arcand</name>
-			<email>jfarcand@apache.org</email>
-		</developer>
-		<developer>
-			<id>thomd</id>
-			<name>Thomas Dudziak</name>
-			<email>tomdz@apache.org</email>
-		</developer>
-		<developer>
-			<id>neotyk</id>
-			<name>Hubert Iwaniuk</name>
-		</developer>
-		<developer>
-			<id>rlubke</id>
-			<name>Ryan Lubke</name>
-			<email>ryan.lubke@gmail.com</email>
-		</developer>
 		<developer>
 			<id>slandelle</id>
 			<name>Stephane Landelle</name>
-			<email>slandelle@excilys.com</email>
+			<email>slandelle@gatling.io</email>
 		</developer>
 	</developers>
-	<contributors>
-		<contributor>
-			<name>Simone Tripodi</name>
-			<email>simonetripodi@apache.org</email>
-		</contributor>
-	</contributors>
 	<licenses>
 		<license>
 			<name>Apache License 2.0</name>
@@ -117,7 +87,6 @@
 					<source>${source.property}</source>
 					<target>${target.property}</target>
 					<maxmem>1024m</maxmem>
-
 				</configuration>
 			</plugin>
 			<plugin>
@@ -162,9 +131,6 @@
 						</goals>
 						<configuration>
 							<rules>
-								<requireMavenVersion>
-									<version>2.0.9</version>
-								</requireMavenVersion>
 								<requireJavaVersion>
 									<version>${source.property}</version>
 								</requireJavaVersion>
@@ -290,9 +256,34 @@
 		</repository>
 	</repositories>
 	<modules>
+		<module>netty-bp</module>
 		<module>client</module>
 		<module>extras</module>
 	</modules>
+	<dependencyManagement>
+		<dependencies>
+			<dependency>
+				<groupId>io.netty</groupId>
+				<artifactId>netty-codec-http</artifactId>
+				<version>${netty.version}</version>
+			</dependency>
+			<dependency>
+				<groupId>io.netty</groupId>
+				<artifactId>netty-codec</artifactId>
+				<version>${netty.version}</version>
+			</dependency>
+			<dependency>
+				<groupId>io.netty</groupId>
+				<artifactId>netty-common</artifactId>
+				<version>${netty.version}</version>
+			</dependency>
+			<dependency>
+				<groupId>io.netty</groupId>
+				<artifactId>netty-transport</artifactId>
+				<version>${netty.version}</version>
+			</dependency>
+		</dependencies>
+	</dependencyManagement>
 	<dependencies>
 		<dependency>
 			<groupId>org.slf4j</groupId>
@@ -402,22 +393,36 @@
 			<version>${rxjava-reactive-streams.version}</version>
 			<scope>test</scope>
 		</dependency>
+		<dependency>
+			<groupId>org.powermock</groupId>
+			<artifactId>powermock-module-testng</artifactId>
+			<version>${powermock.version}</version>
+			<scope>test</scope>
+		</dependency>
+		<dependency>
+			<groupId>org.powermock</groupId>
+			<artifactId>powermock-api-mockito</artifactId>
+			<version>${powermock.version}</version>
+			<scope>test</scope>
+		</dependency>
 	</dependencies>
 	<properties>
 		<distMgmtSnapshotsUrl>http://oss.sonatype.org/content/repositories/snapshots</distMgmtSnapshotsUrl>
 		<surefire.redirectTestOutputToFile>true</surefire.redirectTestOutputToFile>
 		<source.property>1.8</source.property>
 		<target.property>1.8</target.property>
-		<slf4j.version>1.7.12</slf4j.version>
+		<netty.version>4.0.34.Final</netty.version>
+		<slf4j.version>1.7.14</slf4j.version>
 		<logback.version>1.1.3</logback.version>
 		<log4j.version>1.2.17</log4j.version>
 		<testng.version>6.9.9</testng.version>
-		<jetty.version>9.2.11.v20150529</jetty.version>
+		<jetty.version>9.3.6.v20151106</jetty.version>
 		<tomcat.version>6.0.29</tomcat.version>
 		<commons-io.version>2.4</commons-io.version>
 		<commons-fileupload.version>1.3</commons-fileupload.version>
 		<privilegedaccessor.version>1.2.2</privilegedaccessor.version>
 		<rxjava-reactive-streams.version>1.0.1</rxjava-reactive-streams.version>
+		<powermock.version>1.6.4</powermock.version>
 	</properties>
 </project>
 
