diff --git a/yhook/.gitignore b/yhook/.gitignore
new file mode 100644
index 0000000..a2f3d0b
--- /dev/null
+++ b/yhook/.gitignore
@@ -0,0 +1,2 @@
+build
+.externalNativeBuild
\ No newline at end of file
diff --git a/yhook/build.gradle b/yhook/build.gradle
new file mode 100644
index 0000000..eeeee29
--- /dev/null
+++ b/yhook/build.gradle
@@ -0,0 +1,43 @@
+apply plugin: 'com.android.library'
+
+android {
+    compileSdkVersion rootProject.ext.compileSdkVersion
+    buildToolsVersion rootProject.ext.buildToolsVersion
+
+    defaultConfig {
+        minSdkVersion rootProject.ext.minSdkVersion
+        targetSdkVersion rootProject.ext.targetSdkVersion
+        versionCode 1
+        versionName "1.0"
+        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+        externalNativeBuild {
+            ndkBuild {
+                abiFilters 'armeabi', 'armeabi-v7a', 'x86', 'arm64-v8a'
+                //c++ need
+                //cppFlags "-std=gnu++11"
+            }
+        }
+    }
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+    externalNativeBuild {
+        ndkBuild {
+            path 'src/main/jni/Android.mk'
+        }
+    }
+    productFlavors {
+    }
+}
+
+dependencies {
+    compile fileTree(include: ['*.jar'], dir: 'libs')
+    androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', {
+        exclude group: 'com.android.support', module: 'support-annotations'
+    })
+    testCompile 'junit:junit:4.12'
+    compile "com.android.support:support-v4:${rootProject.ext.supportLibVersion}"
+}
diff --git a/yhook/proguard-rules.pro b/yhook/proguard-rules.pro
new file mode 100644
index 0000000..4980a9a
--- /dev/null
+++ b/yhook/proguard-rules.pro
@@ -0,0 +1,25 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in /usr/local/opt/android-sdk-macosx/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
+
+# Uncomment this to preserve the line number information for
+# debugging stack traces.
+#-keepattributes SourceFile,LineNumberTable
+
+# If you keep the line number information, uncomment this to
+# hide the original source file name.
+#-renamesourcefileattribute SourceFile
diff --git a/yhook/src/main/AndroidManifest.xml b/yhook/src/main/AndroidManifest.xml
new file mode 100644
index 0000000..e1f7038
--- /dev/null
+++ b/yhook/src/main/AndroidManifest.xml
@@ -0,0 +1,9 @@
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+
+    package="com.kunpeng.pit">
+
+    <application >
+
+    </application>
+
+</manifest>
diff --git a/yhook/src/main/java/com/kunpeng/pit/FragmentHookList_v4.java b/yhook/src/main/java/com/kunpeng/pit/FragmentHookList_v4.java
new file mode 100644
index 0000000..5196f1a
--- /dev/null
+++ b/yhook/src/main/java/com/kunpeng/pit/FragmentHookList_v4.java
@@ -0,0 +1,474 @@
+package com.kunpeng.pit;
+
+import android.app.Activity;
+import android.content.Context;
+import android.support.v4.app.Fragment;
+import android.util.Log;
+
+
+/**
+ * HOOK列表
+ * <p>
+ * Created by elvis on 2017/2/20.
+ * 这个仅仅 是用作例子滴
+ */
+
+public class FragmentHookList_v4 {
+
+    private static final String TAG = "HookList_Fragment_V4";
+
+
+    /**
+     * Fragment 生命周期:
+     **/
+    @HookAnnotation(className = "android.support.v4.app.Fragment",
+            methodName = "onAttach",
+            methodSig = "(Landroid/content/Context;)V")
+    public static void onAttach(Object thiz, Context context) {
+        Log.d(TAG, "onAttach");
+        long start = System.currentTimeMillis();
+//        KHookManager.getInstance().callOriginalMethod("android.support.v4.app.Fragment.onAttach", this, context);
+//        HookMain.UpdateTargetCopy("android.support.v4.app.Fragment","onAttach","(Landroid/content/Context;)V");
+        onAttach_backup(thiz, context);
+        long end = System.currentTimeMillis();
+        String activityClassName = "";
+        String activityHashCode = "";
+        String fragmentClassName = "";
+        String fragmentHashCode = "";
+        Log.d(TAG, "onAttach_backup  finsih 1");
+        new Fragment();
+        Log.d(TAG, "onAttach_backup  finsih 2");
+        fragmentClassName = ((android.support.v4.app.Fragment) thiz).getClass().getName();
+        Log.d(TAG, "onAttach_backup  finsih 2");
+        fragmentHashCode = "" + thiz.hashCode();
+        Log.d(TAG, "onAttach_backup  finsih 3");
+        Activity activity = ((android.support.v4.app.Fragment) thiz).getActivity();
+        if (activity != null) {
+            activityClassName = activity.getClass().getName();
+            activityHashCode = "" + activity.hashCode();
+        }
+        Log.d(TAG, "onAttach_backup all finsih ");
+//        GTRClient.saveData(
+//                new StringBuilder().append("FragmentV4.onAttach")
+//                        .append(GTRConfig.separator).append(activityClassName)
+//                        .append(GTRConfig.separator).append(activityHashCode)
+//                        .append(GTRConfig.separator).append(fragmentClassName)
+//                        .append(GTRConfig.separator).append(fragmentHashCode)
+//                        .append(GTRConfig.separator).append(start)
+//                        .append(GTRConfig.separator).append(end)
+//                        .toString());
+    }
+
+    public static void onAttach_backup(Object thiz, Context context) {
+        Log.d(TAG, "这个日志出现了就爆炸了");
+    }
+    public static void onAttach_tmp(Object thiz, Context context) {
+        Log.d(TAG, "这个日志出现了就爆炸了");
+    }
+
+    @HookAnnotation(className = "com.gtr.test.ClassWithVirtualMethod",
+            methodName = "tac",
+            methodSig = "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;")
+    public static String tac(Object thiz, String a, String b, String c, String d) {
+//        Log.d("YAHFA", "in ClassWithVirtualMethod.tac(): " + a + ", " + b + ", " + c + ", " + d);
+//        HookMain.getInstance().UpdateTargetCopy("com.gtr.test.ClassWithVirtualMethod",
+//                "tac",
+//                "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");
+        Log.d("YAHFA", "in ClassWithVirtualMethod.tac(): " + a + ", " + b + ", " + c + ", " + d);
+        return tac_backup(thiz, a, b, c, d);
+    }
+
+    public static String tac_backup(Object thiz, String a, String b, String c, String d) {
+        Log.d(TAG, "tac_backup这个日志出现了就爆炸了");
+        return null;
+    }
+    public static String tac_tmp(Object thiz, String a, String b, String c, String d) {
+        Log.d(TAG, "tac_backup这个日志出现了就爆炸了");
+        return null;
+    }
+    /**
+     * View绘制相关：
+     **/
+//    @HookAnnotation(className = "android.view.ViewGroup", methodName = "dispatchDraw", methodSig = "(Landroid/graphics/Canvas;)V")
+//    public static void dispatchDraw(Object thiz, Canvas canvas) {
+////        android.view.ViewGroup
+////        Log.e(TAG,"ViewGroup.dispatchDraw");
+//        Object view = thiz;
+//        String drawClassName = view.getClass().getName();//当前绘制类名（包含包名）
+//        Log.e(TAG, "ViewGroup.dispatchDraw ，call Calss = " + drawClassName);
+//        String objectHashCode = "" + view.hashCode();//当前绘制的对象名（包含包名和对象地址）
+//        dispatchDraw_backup(thiz, canvas);
+////        ViewDrawUtil.onViewGroup_dispatchDraw_before(drawClassName,objectHashCode);
+////        KHookManager.getInstance().callOriginalMethod("android.view.ViewGroup.dispatchDraw", this, canvas);
+////        ViewDrawUtil.onViewGroup_dispatchDraw_after();
+//    }
+//
+//    public static void dispatchDraw_backup(Object thiz, Canvas canvas) {
+//        Log.e(TAG, "ViewGroup.dispatchDraw 爆炸");
+//    }
+
+//    @HookAnnotation(className = "android.support.v4.app.Fragment")
+//    void performCreate(Bundle savedInstanceState) {
+//        Log.e("ElvisElvis","performCreate");
+//        Log.e(TAG,"performCreate");
+//        long start = System.currentTimeMillis();
+//        KHookManager.getInstance().callOriginalMethod("android.support.v4.app.Fragment.performCreate", this, savedInstanceState);
+//        long end = System.currentTimeMillis();
+//        String activityClassName = "";
+//        String activityHashCode = "";
+//        String fragmentClassName = "";
+//        String fragmentHashCode = "";
+//        Object fragment = this;
+//        if (fragment instanceof android.support.v4.app.Fragment){
+//            fragmentClassName =  ((android.support.v4.app.Fragment)fragment).getClass().getName();
+//            fragmentHashCode = ""+this.hashCode();
+//            Activity activity = ((android.support.v4.app.Fragment) fragment).getActivity();
+//            if (activity!=null){
+//                activityClassName  = activity.getClass().getName();
+//                activityHashCode = ""+activity.hashCode();
+//            }
+//        }
+////        GTRClient.saveData(
+////                new StringBuilder().append("FragmentV4.performCreate")
+////                        .append(GTRConfig.separator).append(activityClassName)
+////                        .append(GTRConfig.separator).append(activityHashCode)
+////                        .append(GTRConfig.separator).append(fragmentClassName)
+////                        .append(GTRConfig.separator).append(fragmentHashCode)
+////                        .append(GTRConfig.separator).append(start)
+////                        .append(GTRConfig.separator).append(end)
+////                        .toString());
+//    }
+//
+//    @HookAnnotation(className = "android.support.v4.app.Fragment")
+//    View performCreateView(LayoutInflater inflater, ViewGroup container,Bundle savedInstanceState) {
+//        Log.e(TAG,"performCreateView");
+//        long start = System.currentTimeMillis();
+//        View resultView = KHookManager.getInstance().callOriginalMethod("android.support.v4.app.Fragment.performCreateView", this, inflater, container, savedInstanceState);
+//        long end = System.currentTimeMillis();
+//        String activityClassName = "";
+//        String activityHashCode = "";
+//        String fragmentClassName = "";
+//        String fragmentHashCode = "";
+//        Object fragment = this;
+//        if (fragment instanceof android.support.v4.app.Fragment){
+//            fragmentClassName =  ((android.support.v4.app.Fragment)fragment).getClass().getName();
+//            fragmentHashCode = ""+this.hashCode();
+//            Activity activity = ((android.support.v4.app.Fragment) fragment).getActivity();
+//            if (activity!=null){
+//                activityClassName  = activity.getClass().getName();
+//                activityHashCode = ""+activity.hashCode();
+//            }
+//        }
+////        GTRClient.saveData(
+////                new StringBuilder().append("FragmentV4.performCreateView")
+////                        .append(GTRConfig.separator).append(activityClassName)
+////                        .append(GTRConfig.separator).append(activityHashCode)
+////                        .append(GTRConfig.separator).append(fragmentClassName)
+////                        .append(GTRConfig.separator).append(fragmentHashCode)
+////                        .append(GTRConfig.separator).append(start)
+////                        .append(GTRConfig.separator).append(end)
+////                        .toString());
+//        return resultView;
+//    }
+//    @HookAnnotation(className = "android.support.v4.app.Fragment")
+//    void performActivityCreated(Bundle savedInstanceState) {
+//        Log.e(TAG,"performActivityCreated");
+//        long start = System.currentTimeMillis();
+//        KHookManager.getInstance().callOriginalMethod("android.support.v4.app.Fragment.performActivityCreated", this, savedInstanceState);
+//        long end = System.currentTimeMillis();
+//        String activityClassName = "";
+//        String activityHashCode = "";
+//        String fragmentClassName = "";
+//        String fragmentHashCode = "";
+//        Object fragment = this;
+//        if (fragment instanceof android.support.v4.app.Fragment){
+//            fragmentClassName =  ((android.support.v4.app.Fragment)fragment).getClass().getName();
+//            fragmentHashCode = ""+this.hashCode();
+//            Activity activity = ((android.support.v4.app.Fragment) fragment).getActivity();
+//            if (activity!=null){
+//                activityClassName  = activity.getClass().getName();
+//                activityHashCode = ""+activity.hashCode();
+//            }
+//        }
+////        GTRClient.saveData(
+////                new StringBuilder().append("FragmentV4.performActivityCreated")
+////                        .append(GTRConfig.separator).append(activityClassName)
+////                        .append(GTRConfig.separator).append(activityHashCode)
+////                        .append(GTRConfig.separator).append(fragmentClassName)
+////                        .append(GTRConfig.separator).append(fragmentHashCode)
+////                        .append(GTRConfig.separator).append(start)
+////                        .append(GTRConfig.separator).append(end)
+////                        .toString());
+//    }
+//    @HookAnnotation(className = "android.support.v4.app.Fragment")
+//    void performStart() {
+//        Log.e(TAG,"performStart");
+//        long start = System.currentTimeMillis();
+//        KHookManager.getInstance().callOriginalMethod("android.support.v4.app.Fragment.performStart", this);
+//        long end = System.currentTimeMillis();
+//        String activityClassName = "";
+//        String activityHashCode = "";
+//        String fragmentClassName = "";
+//        String fragmentHashCode = "";
+//        Object fragment = this;
+//        if (fragment instanceof android.support.v4.app.Fragment){
+//            fragmentClassName =  ((android.support.v4.app.Fragment)fragment).getClass().getName();
+//            fragmentHashCode = ""+this.hashCode();
+//            Activity activity = ((android.support.v4.app.Fragment) fragment).getActivity();
+//            if (activity!=null){
+//                activityClassName  = activity.getClass().getName();
+//                activityHashCode = ""+activity.hashCode();
+//            }
+//        }
+////        GTRClient.saveData(
+////                new StringBuilder().append("FragmentV4.performStart")
+////                        .append(GTRConfig.separator).append(activityClassName)
+////                        .append(GTRConfig.separator).append(activityHashCode)
+////                        .append(GTRConfig.separator).append(fragmentClassName)
+////                        .append(GTRConfig.separator).append(fragmentHashCode)
+////                        .append(GTRConfig.separator).append(start)
+////                        .append(GTRConfig.separator).append(end)
+////                        .toString());
+//    }
+//    @HookAnnotation(className = "android.support.v4.app.Fragment")
+//    void performResume() {
+//        Log.e(TAG,"performResume");
+//        long start = System.currentTimeMillis();
+//        KHookManager.getInstance().callOriginalMethod("android.support.v4.app.Fragment.performResume", this);
+//        long end = System.currentTimeMillis();
+//        String activityClassName = "";
+//        String activityHashCode = "";
+//        String fragmentClassName = "";
+//        String fragmentHashCode = "";
+//        Object fragment = this;
+//        if (fragment instanceof android.support.v4.app.Fragment){
+//            fragmentClassName =  ((android.support.v4.app.Fragment)fragment).getClass().getName();
+//            fragmentHashCode = ""+this.hashCode();
+//            Activity activity = ((android.support.v4.app.Fragment) fragment).getActivity();
+//            if (activity!=null){
+//                activityClassName  = activity.getClass().getName();
+//                activityHashCode = ""+activity.hashCode();
+//            }
+//        }
+////        GTRClient.saveData(
+////                new StringBuilder().append("FragmentV4.performResume")
+////                        .append(GTRConfig.separator).append(activityClassName)
+////                        .append(GTRConfig.separator).append(activityHashCode)
+////                        .append(GTRConfig.separator).append(fragmentClassName)
+////                        .append(GTRConfig.separator).append(fragmentHashCode)
+////                        .append(GTRConfig.separator).append(start)
+////                        .append(GTRConfig.separator).append(end)
+////                        .toString());
+//    }
+//    @HookAnnotation(className = "android.support.v4.app.Fragment")
+//    void performPause() {
+//        Log.e(TAG,"performPause");
+//        long start = System.currentTimeMillis();
+//        KHookManager.getInstance().callOriginalMethod("android.support.v4.app.Fragment.performPause", this);
+//        long end = System.currentTimeMillis();
+//        String activityClassName = "";
+//        String activityHashCode = "";
+//        String fragmentClassName = "";
+//        String fragmentHashCode = "";
+//        Object fragment = this;
+//        if (fragment instanceof android.support.v4.app.Fragment){
+//            fragmentClassName =  ((android.support.v4.app.Fragment)fragment).getClass().getName();
+//            fragmentHashCode = ""+this.hashCode();
+//            Activity activity = ((android.support.v4.app.Fragment) fragment).getActivity();
+//            if (activity!=null){
+//                activityClassName  = activity.getClass().getName();
+//                activityHashCode = ""+activity.hashCode();
+//            }
+//        }
+////        GTRClient.saveData(
+////                new StringBuilder().append("FragmentV4.performPause")
+////                        .append(GTRConfig.separator).append(activityClassName)
+////                        .append(GTRConfig.separator).append(activityHashCode)
+////                        .append(GTRConfig.separator).append(fragmentClassName)
+////                        .append(GTRConfig.separator).append(fragmentHashCode)
+////                        .append(GTRConfig.separator).append(start)
+////                        .append(GTRConfig.separator).append(end)
+////                        .toString());
+//    }
+//    @HookAnnotation(className = "android.support.v4.app.Fragment")
+//    void performStop() {
+//        Log.e(TAG,"performStop");
+//        long start = System.currentTimeMillis();
+//        KHookManager.getInstance().callOriginalMethod("android.support.v4.app.Fragment.performStop", this);
+//        long end = System.currentTimeMillis();
+//        String activityClassName = "";
+//        String activityHashCode = "";
+//        String fragmentClassName = "";
+//        String fragmentHashCode = "";
+//        Object fragment = this;
+//        if (fragment instanceof android.support.v4.app.Fragment){
+//            fragmentClassName =  ((android.support.v4.app.Fragment)fragment).getClass().getName();
+//            fragmentHashCode = ""+this.hashCode();
+//            Activity activity = ((android.support.v4.app.Fragment) fragment).getActivity();
+//            if (activity!=null){
+//                activityClassName  = activity.getClass().getName();
+//                activityHashCode = ""+activity.hashCode();
+//            }
+//        }
+////        GTRClient.saveData(
+////                new StringBuilder().append("FragmentV4.performStop")
+////                        .append(GTRConfig.separator).append(activityClassName)
+////                        .append(GTRConfig.separator).append(activityHashCode)
+////                        .append(GTRConfig.separator).append(fragmentClassName)
+////                        .append(GTRConfig.separator).append(fragmentHashCode)
+////                        .append(GTRConfig.separator).append(start)
+////                        .append(GTRConfig.separator).append(end)
+////                        .toString());
+//    }
+//    @HookAnnotation(className = "android.support.v4.app.Fragment")
+//    void performDestroyView() {
+//        Log.e(TAG,"performDestroyView");
+//        long start = System.currentTimeMillis();
+//        KHookManager.getInstance().callOriginalMethod("android.support.v4.app.Fragment.performDestroyView", this);
+//        long end = System.currentTimeMillis();
+//        String activityClassName = "";
+//        String activityHashCode = "";
+//        String fragmentClassName = "";
+//        String fragmentHashCode = "";
+//        Object fragment = this;
+//        if (fragment instanceof android.support.v4.app.Fragment){
+//            fragmentClassName =  ((android.support.v4.app.Fragment)fragment).getClass().getName();
+//            fragmentHashCode = ""+this.hashCode();
+//            Activity activity = ((android.support.v4.app.Fragment) fragment).getActivity();
+//            if (activity!=null){
+//                activityClassName  = activity.getClass().getName();
+//                activityHashCode = ""+activity.hashCode();
+//            }
+//        }
+////        GTRClient.saveData(
+////                new StringBuilder().append("FragmentV4.performDestroyView")
+////                        .append(GTRConfig.separator).append(activityClassName)
+////                        .append(GTRConfig.separator).append(activityHashCode)
+////                        .append(GTRConfig.separator).append(fragmentClassName)
+////                        .append(GTRConfig.separator).append(fragmentHashCode)
+////                        .append(GTRConfig.separator).append(start)
+////                        .append(GTRConfig.separator).append(end)
+////                        .toString());
+//    }
+//    @HookAnnotation(className = "android.support.v4.app.Fragment")
+//    void performDestroy() {
+//        Log.e(TAG,"performDestroy");
+//        long start = System.currentTimeMillis();
+//        KHookManager.getInstance().callOriginalMethod("android.support.v4.app.Fragment.performDestroy", this);
+//        long end = System.currentTimeMillis();
+//        String activityClassName = "";
+//        String activityHashCode = "";
+//        String fragmentClassName = "";
+//        String fragmentHashCode = "";
+//        Object fragment = this;
+//        if (fragment instanceof android.support.v4.app.Fragment){
+//            fragmentClassName =  ((android.support.v4.app.Fragment)fragment).getClass().getName();
+//            fragmentHashCode = ""+this.hashCode();
+//            Activity activity = ((android.support.v4.app.Fragment) fragment).getActivity();
+//            if (activity!=null){
+//                activityClassName  = activity.getClass().getName();
+//                activityHashCode = ""+activity.hashCode();
+//            }
+//        }
+////        GTRClient.saveData(
+////                new StringBuilder().append("FragmentV4.performDestroy")
+////                        .append(GTRConfig.separator).append(activityClassName)
+////                        .append(GTRConfig.separator).append(activityHashCode)
+////                        .append(GTRConfig.separator).append(fragmentClassName)
+////                        .append(GTRConfig.separator).append(fragmentHashCode)
+////                        .append(GTRConfig.separator).append(start)
+////                        .append(GTRConfig.separator).append(end)
+////                        .toString());
+//    }
+//    @HookAnnotation(className = "android.support.v4.app.Fragment")
+//    void performDetach() {
+//        Log.e(TAG,"performDetach");
+//        long start = System.currentTimeMillis();
+//        KHookManager.getInstance().callOriginalMethod("android.support.v4.app.Fragment.performDetach", this);
+//        long end = System.currentTimeMillis();
+//        String activityClassName = "";
+//        String activityHashCode = "";
+//        String fragmentClassName = "";
+//        String fragmentHashCode = "";
+//        Object fragment = this;
+//        if (fragment instanceof android.support.v4.app.Fragment){
+//            fragmentClassName =  ((android.support.v4.app.Fragment)fragment).getClass().getName();
+//            fragmentHashCode = ""+this.hashCode();
+//            Activity activity = ((android.support.v4.app.Fragment) fragment).getActivity();
+//            if (activity!=null){
+//                activityClassName  = activity.getClass().getName();
+//                activityHashCode = ""+activity.hashCode();
+//            }
+//        }
+////        GTRClient.saveData(
+////                new StringBuilder().append("FragmentV4.performDetach")
+////                        .append(GTRConfig.separator).append(activityClassName)
+////                        .append(GTRConfig.separator).append(activityHashCode)
+////                        .append(GTRConfig.separator).append(fragmentClassName)
+////                        .append(GTRConfig.separator).append(fragmentHashCode)
+////                        .append(GTRConfig.separator).append(start)
+////                        .append(GTRConfig.separator).append(end)
+////                        .toString());
+//    }
+//
+//
+//    @HookAnnotation(className = "android.support.v4.app.Fragment")
+//    public void onHiddenChanged(boolean hidden) {
+//        Log.e(TAG,"onHiddenChanged:"+hidden);
+//        long time = System.currentTimeMillis();
+//        KHookManager.getInstance().callOriginalMethod("android.support.v4.app.Fragment.onHiddenChanged", this,hidden);
+//        String activityClassName = "";
+//        String activityHashCode = "";
+//        String fragmentClassName = "";
+//        String fragmentHashCode = "";
+//        Object fragment = this;
+//        if (fragment instanceof android.support.v4.app.Fragment){
+//            fragmentClassName =  ((android.support.v4.app.Fragment)fragment).getClass().getName();
+//            fragmentHashCode = ""+this.hashCode();
+//            Activity activity = ((android.support.v4.app.Fragment) fragment).getActivity();
+//            if (activity!=null){
+//                activityClassName  = activity.getClass().getName();
+//                activityHashCode = ""+activity.hashCode();
+//            }
+//        }
+////        GTRClient.saveData(
+////                new StringBuilder().append("FragmentV4.onHiddenChanged")
+////                        .append(GTRConfig.separator).append(activityClassName)
+////                        .append(GTRConfig.separator).append(activityHashCode)
+////                        .append(GTRConfig.separator).append(fragmentClassName)
+////                        .append(GTRConfig.separator).append(fragmentHashCode)
+////                        .append(GTRConfig.separator).append(time)
+////                        .append(GTRConfig.separator).append(hidden)
+////                        .toString());
+//    }
+//
+//    @HookAnnotation(className = "android.support.v4.app.Fragment")
+//    public void setUserVisibleHint(boolean isVisibleToUser) {
+//        Log.e(TAG,"setUserVisibleHint:"+isVisibleToUser);
+//        long time = System.currentTimeMillis();
+//        KHookManager.getInstance().callOriginalMethod("android.support.v4.app.Fragment.setUserVisibleHint", this,isVisibleToUser);
+//        String activityClassName = "";
+//        String activityHashCode = "";
+//        String fragmentClassName = "";
+//        String fragmentHashCode = "";
+//        Object fragment = this;
+//        if (fragment instanceof android.support.v4.app.Fragment){
+//            fragmentClassName =  ((android.support.v4.app.Fragment)fragment).getClass().getName();
+//            fragmentHashCode = ""+this.hashCode();
+//            Activity activity = ((android.support.v4.app.Fragment) fragment).getActivity();
+//            if (activity!=null){
+//                activityClassName  = activity.getClass().getName();
+//                activityHashCode = ""+activity.hashCode();
+//            }
+//        }
+////        GTRClient.saveData(
+////                new StringBuilder().append("FragmentV4.setUserVisibleHint")
+////                        .append(GTRConfig.separator).append(activityClassName)
+////                        .append(GTRConfig.separator).append(activityHashCode)
+////                        .append(GTRConfig.separator).append(fragmentClassName)
+////                        .append(GTRConfig.separator).append(fragmentHashCode)
+////                        .append(GTRConfig.separator).append(time)
+////                        .append(GTRConfig.separator).append(isVisibleToUser)
+////                        .toString());
+//    }
+}
diff --git a/yhook/src/main/java/com/kunpeng/pit/HookAnnotation.java b/yhook/src/main/java/com/kunpeng/pit/HookAnnotation.java
new file mode 100644
index 0000000..0d4b2d4
--- /dev/null
+++ b/yhook/src/main/java/com/kunpeng/pit/HookAnnotation.java
@@ -0,0 +1,25 @@
+package com.kunpeng.pit;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+/**
+ * Created by yuchaofei on 16/3/16.
+ */
+@Retention(RetentionPolicy.RUNTIME)
+public @interface HookAnnotation {
+
+    public final static byte MATACH_EQUAL = 0x01;
+    public final static byte MATACH_LESS = 0x02;
+    public final static byte MATACH_GREATER = 0x04;
+
+    int sdkVersion() default -1;
+
+    byte sdkType() default MATACH_EQUAL;//配合sdkVersion使用
+
+    String className();
+
+    String methodName();
+
+    String methodSig();
+}
diff --git a/yhook/src/main/java/com/kunpeng/pit/HookMain.java b/yhook/src/main/java/com/kunpeng/pit/HookMain.java
new file mode 100644
index 0000000..9d36a39
--- /dev/null
+++ b/yhook/src/main/java/com/kunpeng/pit/HookMain.java
@@ -0,0 +1,180 @@
+package com.kunpeng.pit;
+
+import android.os.Build;
+import android.util.Log;
+
+import java.lang.reflect.AccessibleObject;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.List;
+
+/**
+ * Created by liuruikai756 on 28/03/2017.
+ */
+
+public class HookMain {
+    private static final String TAG = "YHOOK";
+    private static List<Class<?>> hookInfoClasses = new LinkedList<>();
+    public static HashMap<String, Method> targetMethods = new HashMap<>();
+    public static HashMap<String, Long> targetCopyMethods = new HashMap<>();
+
+    static {
+        System.loadLibrary("yhook");
+        init(android.os.Build.VERSION.SDK_INT);
+    }
+
+    public static void doHookDefault(Class hookClazz) {
+        if (hookClazz == null) {
+            throw new IllegalArgumentException("Class cannot be null!");
+        }
+        Method[] methods = hookClazz.getDeclaredMethods();
+        for (Method method : methods) {
+            HookAnnotation annotation = method.getAnnotation(HookAnnotation.class);
+            if (annotation != null && isSDKMatach(annotation)) {
+                String className = annotation.className();
+                String methodName = annotation.methodName();
+                String methodSig = annotation.methodSig();
+                String backupMethodName = methodName + "_backup";
+                Method backup = null;
+                for (Method method1 : methods) {
+                    if (method1.getName().equals(backupMethodName)) {
+                        backup = method1;
+                        break;
+                    }
+                }
+                Method tmp = null;
+                String tmpMethodName = methodName + "_tmp";
+                for (Method method1 : methods) {
+                    if (method1.getName().equals(tmpMethodName)) {
+                        tmp = method1;
+                        break;
+                    }
+                }
+                try {
+                    Class<?> clazz = Class.forName(className);
+                    findAndBackupAndHook(clazz, methodName, methodSig, method, backup,tmp);
+                } catch (ClassNotFoundException e) {
+                    e.printStackTrace();
+                }
+            }
+
+        }
+    }
+
+    static void findAndBackupAndHook(Class targetClass, String methodName, String methodSig,
+                                            Method hook, Method backup,Method tmp) {
+        try {
+            int hookParamCount = hook.getParameterTypes().length;
+            int targetParamCount = getParamCountFromSignature(methodSig);
+            Log.d(TAG, "target method param count is " + targetParamCount);
+            boolean isStatic = (hookParamCount == targetParamCount);
+            // virtual method has 'thiz' object as the first parameter
+//            Method tmp = generateTempMethod(backup);
+            findAndBackupAndHook(targetClass, methodName, methodSig, isStatic, hook, backup, tmp);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    static int getParamCountFromSignature(String signature) throws Exception {
+        int index;
+        int count = 0;
+        int seg;
+        try { // Read all declarations between for `(' and `)'
+            if (signature.charAt(0) != '(') {
+                throw new Exception("Invalid method signature: " + signature);
+            }
+            index = 1; // current string position
+            while (signature.charAt(index) != ')') {
+                seg = parseSignature(signature.substring(index));
+                index += seg;
+                count++;
+            }
+
+        } catch (final StringIndexOutOfBoundsException e) { // Should never occur
+            throw new Exception("Invalid method signature: " + signature, e);
+        }
+        return count;
+    }
+
+    static int parseSignature(String signature) throws Exception {
+        int count = 0;
+        switch (signature.charAt(0)) {
+            case 'B': // byte
+            case 'C': // char
+            case 'D': // double
+            case 'F': // float
+            case 'I': // int
+            case 'J': // long
+            case 'S': // short
+            case 'Z': // boolean
+            case 'V': // void
+                count++;
+                break;
+            case 'L': // class
+                count++; // char L
+                while (signature.charAt(count) != ';') {
+                    count++;
+                }
+                count++; // char ;
+                break;
+            case '[': // array
+                count++; // char [
+                count += parseSignature(signature.substring(count));
+                break;
+            default:
+                throw new Exception("Invalid type: " + signature);
+        }
+        return count;
+    }
+
+    /**
+     * 判断当前系统版本是否与hook方法匹配
+     *
+     * @param annotation
+     * @return
+     */
+    static boolean isSDKMatach(HookAnnotation annotation) {
+        int sdkVersion = annotation.sdkVersion();
+        if (sdkVersion > -1) {
+            byte type = annotation.sdkType();
+            int current = Build.VERSION.SDK_INT;
+            switch (type) {
+                case HookAnnotation.MATACH_EQUAL:
+                    return current == sdkVersion;
+                case HookAnnotation.MATACH_LESS:
+                    return current < sdkVersion;
+                case HookAnnotation.MATACH_GREATER:
+                    return current > sdkVersion;
+                default:
+                    return false;
+            }
+        }
+        return true;
+    }
+
+     /**
+     * AccessibleObject权限绕过
+     * Build.VERSION.SDK_INT == 24
+     * @param obj
+     */
+    static void setAccessible(AccessibleObject obj){
+        try {
+            Field override = obj.getClass().getSuperclass().getSuperclass().getDeclaredField("override");
+            override.setAccessible(true);
+            override.set(obj, true);
+        } catch (NoSuchFieldException e) {
+            e.printStackTrace();
+        } catch (IllegalAccessException e) {
+            e.printStackTrace();
+        }
+    }
+
+    private static native void findAndBackupAndHook(Class targetClass, String methodName, String methodSig,
+                                                    boolean isStatic,
+                                                    Method hook, Method backup, Method temp);
+
+    private static native void init(int SDK_version);
+}
diff --git a/yhook/src/main/jni/Android.mk b/yhook/src/main/jni/Android.mk
new file mode 100644
index 0000000..97a7132
--- /dev/null
+++ b/yhook/src/main/jni/Android.mk
@@ -0,0 +1,12 @@
+LOCAL_PATH:= $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES:= HookMain.c trampoline.c
+
+LOCAL_LDLIBS    := -llog
+
+LOCAL_MODULE:= yhook
+
+LOCAL_ARM_MODE := arm
+
+include $(BUILD_SHARED_LIBRARY)
diff --git a/yhook/src/main/jni/Application.mk b/yhook/src/main/jni/Application.mk
new file mode 100644
index 0000000..9a33c2e
--- /dev/null
+++ b/yhook/src/main/jni/Application.mk
@@ -0,0 +1 @@
+APP_ABI := arm64-v8a armeabi-v7a x86
diff --git a/yhook/src/main/jni/HookMain.c b/yhook/src/main/jni/HookMain.c
new file mode 100644
index 0000000..165dd40
--- /dev/null
+++ b/yhook/src/main/jni/HookMain.c
@@ -0,0 +1,242 @@
+#include "jni.h"
+#include <string.h>
+#include <sys/mman.h>
+#include <stdlib.h>
+
+#include "common.h"
+#include "env.h"
+#include "trampoline.h"
+
+static uint32_t kAccNative = 0x0100;  // method
+
+static int SDKVersion;
+static int OFFSET_entry_point_from_interpreter_in_ArtMethod;
+static int OFFSET_entry_point_from_quick_compiled_code_in_ArtMethod;
+static int OFFSET_hotness_count_in_ArtMethod;
+static int OFFSET_ArtMehod_in_Object;
+static int OFFSET_access_flags_;
+static int ArtMethodSize;
+
+static inline uint32_t read32(void *addr) {
+    LOGD("read32");
+    return *((uint32_t *) addr);
+}
+
+static inline uint64_t read64(void *addr) {
+    LOGD("read64");
+    return *((uint64_t *) addr);
+}
+
+void Java_com_kunpeng_pit_HookMain_init(JNIEnv *env, jclass clazz, jint sdkVersion) {
+    int i;
+    SDKVersion = sdkVersion;
+    LOGI("init to SDK %d", sdkVersion);
+    switch (sdkVersion) {
+        case ANDROID_O:
+        case ANDROID_O2:
+            OFFSET_ArtMehod_in_Object = 0;
+            OFFSET_access_flags_ = 4;
+            OFFSET_hotness_count_in_ArtMethod = 4 * 4 + 2;
+            OFFSET_entry_point_from_quick_compiled_code_in_ArtMethod =
+                    roundUpToPtrSize(4 * 4 + 2 * 2) + pointer_size * 2;
+            ArtMethodSize = roundUpToPtrSize(4 * 4 + 2 * 2) + pointer_size * 3;
+            break;
+        case ANDROID_N2:
+        case ANDROID_N:
+            OFFSET_ArtMehod_in_Object = 0;
+            OFFSET_hotness_count_in_ArtMethod = 4 * 4 + 2; // sizeof(GcRoot<mirror::Class>) = 4
+            // ptr_sized_fields_ is rounded up to pointer_size in ArtMethod
+            OFFSET_entry_point_from_quick_compiled_code_in_ArtMethod =
+                    roundUpToPtrSize(4 * 4 + 2 * 2) + pointer_size * 3;
+
+            ArtMethodSize = roundUpToPtrSize(4 * 4 + 2 * 2) + pointer_size * 4;
+            break;
+        case ANDROID_M:
+            OFFSET_ArtMehod_in_Object = 0;
+            OFFSET_entry_point_from_interpreter_in_ArtMethod = roundUpToPtrSize(4 * 7);
+            OFFSET_entry_point_from_quick_compiled_code_in_ArtMethod =
+                    OFFSET_entry_point_from_interpreter_in_ArtMethod + pointer_size * 2;
+            ArtMethodSize = roundUpToPtrSize(4 * 7) + pointer_size * 3;
+            break;
+        case ANDROID_L2:
+            OFFSET_ArtMehod_in_Object = 4 * 2;
+            OFFSET_entry_point_from_interpreter_in_ArtMethod = roundUpToPtrSize(
+                    OFFSET_ArtMehod_in_Object + 4 * 7);
+            OFFSET_entry_point_from_quick_compiled_code_in_ArtMethod =
+                    OFFSET_entry_point_from_interpreter_in_ArtMethod + pointer_size * 2;//56
+            ArtMethodSize = OFFSET_entry_point_from_interpreter_in_ArtMethod + pointer_size * 3;
+            break;
+        case ANDROID_L:
+            OFFSET_ArtMehod_in_Object = 4 * 2;
+            OFFSET_entry_point_from_interpreter_in_ArtMethod = OFFSET_ArtMehod_in_Object + 4 * 4;
+            OFFSET_entry_point_from_quick_compiled_code_in_ArtMethod =
+                    OFFSET_entry_point_from_interpreter_in_ArtMethod + 8 * 2;
+            ArtMethodSize = OFFSET_ArtMehod_in_Object + 4 * 4 + 8 * 4 + 4 * 4;
+            break;
+        default:
+            LOGE("not compatible with SDK %d", sdkVersion);
+            break;
+    }
+#if defined(__i386__)
+    trampoline1[13] = OFFSET_entry_point_from_quick_compiled_code_in_ArtMethod;
+    if(SDKVersion < ANDROID_N) { // do not set hotness_count before N
+        memset(trampoline2+5, '\x90', 6);
+    }
+#elif defined(__arm__)
+    trampoline1[24] = (unsigned char)OFFSET_entry_point_from_quick_compiled_code_in_ArtMethod;
+//trampoline1[4] = (unsigned char)OFFSET_entry_point_from_quick_compiled_code_in_ArtMethod;
+    if(SDKVersion < ANDROID_N) { // do not set hotness_count before N
+        for(i=0; i<=16; i+=4) {
+            memcpy(trampoline1+i, "\x00\x00\xa0\xe1", 4); // mov r0, r0
+        }
+        for(i=4; i<=16; i+=4) {
+            memcpy(trampoline2+i, "\x00\x00\xa0\xe1", 4); // mov r0, r0
+        }
+    }
+#elif defined(__aarch64__)
+    if (SDKVersion == ANDROID_O || SDKVersion == ANDROID_O2){
+        //101440f9 ; ldr x16, [x0, #40] set entry point offset
+        memcpy(trampoline1 + 8, "\x10\x14\x40\xf9", 4);
+    }
+    if (SDKVersion < ANDROID_N) { // do not set hotness_count before N
+        memcpy(trampoline2 + 4, "\x1f\x20\x03\xd5", 4); // nop
+        memcpy(trampoline1 + 4, "\x1f\x20\x03\xd5", 4); // nop
+    }
+    if (SDKVersion == ANDROID_L2) {
+        //101c40f9 ; ldr x16, [x0, #56] set entry point offset
+        memcpy(trampoline1 + 8, "\x10\x1c\x40\xf9", 4);
+    } else if (SDKVersion == ANDROID_L) {
+        //101440f9 ; ldr x16, [x0, #40] set entry point offset
+        memcpy(trampoline1 + 8, "\x10\x14\x40\xf9", 4);
+    }
+#endif
+}
+
+static int doBackupAndHook(void *originMethod, void *hookMethod, void *backupMethod, void *tmpMethod) {
+    if (hookCount >= hookCap) {
+        LOGW("not enough capacity. Allocating...");
+        if (doInitHookCap(DEFAULT_CAP)) {
+            LOGE("cannot hook method");
+            return 1;
+        }
+        LOGI("Allocating done");
+    }
+
+//    LOGI("origin method is at %p, hook method is at %p, backup method is at %p",
+//         originMethod, hookMethod, backupMethod);
+    LOGD("tmpMethod = %x" , tmpMethod);
+    if (!backupMethod) {
+        LOGW("backup method is null");
+    } else { //do method backup
+        // have to copy the whole origin ArtMethod here
+        // if the origin method calls other methods which are to be resolved
+        // then ToDexPC would be invoked for the caller(origin method)
+        // in which case ToDexPC would use the entrypoint as a base for mapping pc to dex offset
+        // so any changes to the origin method's entrypoint would result in a wrong dex offset
+        // and artQuickResolutionTrampoline would fail for methods called by the origin method
+//        void *originMethodCopy = malloc(ArtMethodSize);
+//        LOGD("ArtMethodSize = %d", ArtMethodSize);
+//        if (!originMethodCopy) {
+//            LOGE("malloc failed for copying origin method");
+//            return 1;
+//        }
+        memcpy(tmpMethod, originMethod, ArtMethodSize);
+
+        void *realEntryPoint = (void *) readAddr((char *) originMethod +
+                                                 OFFSET_entry_point_from_quick_compiled_code_in_ArtMethod);
+        void *newEntryPoint = genTrampoline2(tmpMethod, realEntryPoint);
+        if (newEntryPoint) {
+            memcpy((char *) backupMethod + OFFSET_entry_point_from_quick_compiled_code_in_ArtMethod,
+                   &newEntryPoint, pointer_size);
+        } else {
+            LOGE("failed to allocate space for backup method trampoline");
+            return 1;
+        }
+        //set _access_flags_ to native for Android O, otherwise hook will invalid;
+        uint32_t access_flags_ = read32((char *) backupMethod + OFFSET_access_flags_);
+        access_flags_ |= kAccNative;
+        if (OFFSET_access_flags_) {
+            memcpy((char *) backupMethod + OFFSET_access_flags_, &access_flags_, sizeof(uint32_t));
+        }
+    }
+
+    // replace entry point
+    void *newEntrypoint = genTrampoline1(hookMethod);
+//    LOGI("origin ep is %p, new ep is %p",
+//         readAddr((char *) originMethod + OFFSET_entry_point_from_quick_compiled_code_in_ArtMethod),
+//         newEntrypoint
+//    );
+    if (newEntrypoint) {
+        memcpy((char *) originMethod + OFFSET_entry_point_from_quick_compiled_code_in_ArtMethod,
+               &newEntrypoint,
+               pointer_size);
+    } else {
+        LOGW("failed to allocate space for trampoline");
+        return 1;
+    }
+
+    if (OFFSET_entry_point_from_interpreter_in_ArtMethod != 0) {
+        memcpy((char *) originMethod + OFFSET_entry_point_from_interpreter_in_ArtMethod,
+               (char *) hookMethod + OFFSET_entry_point_from_interpreter_in_ArtMethod,
+               pointer_size);
+    }
+    //set _access_flags_ to native for Android O, otherwise hook will invalid;
+    uint32_t access_flags_ = read32((char *) originMethod + OFFSET_access_flags_);
+    access_flags_ |= kAccNative;
+    if (OFFSET_access_flags_) {
+        memcpy((char *) originMethod + OFFSET_access_flags_, &access_flags_, sizeof(uint32_t));
+    }
+
+    LOGI("hook and backup done");
+    hookCount += 1;
+    return 0;
+}
+
+void Java_com_kunpeng_pit_HookMain_findAndBackupAndHook(JNIEnv *env, jclass clazz,
+                                                         jclass targetClass, jstring methodName,
+                                                         jstring methodSig, jboolean isStatic,
+                                                         jobject hook, jobject backup, jobject tmp) {
+    LOGD("findAndBackupAndHook");
+    if (!methodName || !methodSig) {
+        LOGE("empty method name or signature");
+        return;
+    }
+    const char *c_methodName = (*env)->GetStringUTFChars(env, methodName, NULL);
+    const char *c_methodSig = (*env)->GetStringUTFChars(env, methodSig, NULL);
+    if (c_methodName == NULL || c_methodSig == NULL) {
+        LOGE("failed to get c string");
+        return;
+    }
+    void *targetMethod = NULL;
+    LOGI("Start findAndBackupAndHook for method %s%s", c_methodName, c_methodSig);
+    if (ArtMethodSize == 0) {
+        LOGE("Not initialized");
+        goto end;
+    }
+    if (!isStatic) { // non-static
+        targetMethod = (void *) (*env)->GetMethodID(env, targetClass, c_methodName, c_methodSig);
+    } else {// static
+        targetMethod = (void *) (*env)->GetStaticMethodID(env, targetClass, c_methodName,
+                                                          c_methodSig);
+    }
+    LOGD("findAndBackupAndHook ,targetMethod = %x", targetMethod ? targetMethod : 0);
+    if ((*env)->ExceptionCheck(env)) {
+        (*env)->ExceptionClear(env);
+        LOGE("Cannot find target method %s%s%s", isStatic ? "static " : "", c_methodName,
+             c_methodSig);
+        goto end;
+    }
+
+    if (!doBackupAndHook(targetMethod, (void *) (*env)->FromReflectedMethod(env, hook),
+                         (void *) (*env)->FromReflectedMethod(env, backup),
+                         (void *) (*env)->FromReflectedMethod(env, tmp))) {
+        LOGD("keep a global ref so that the hook and backup method would not be GCed");
+        (*env)->NewGlobalRef(env, hook);
+        (*env)->NewGlobalRef(env, backup);
+        (*env)->NewGlobalRef(env, tmp);
+
+    }
+    end:
+    (*env)->ReleaseStringUTFChars(env, methodName, c_methodName);
+    (*env)->ReleaseStringUTFChars(env, methodSig, c_methodSig);
+}
diff --git a/yhook/src/main/jni/common.h b/yhook/src/main/jni/common.h
new file mode 100644
index 0000000..6cbe7b0
--- /dev/null
+++ b/yhook/src/main/jni/common.h
@@ -0,0 +1,15 @@
+//
+// Created by liuruikai756 on 05/07/2017.
+//
+#include <android/log.h>
+
+#ifndef YAHFA_COMMON_H
+#define YAHFA_COMMON_H
+
+#define LOG_TAG "YAHFA-Native"
+#define LOGI(...) __android_log_print(ANDROID_LOG_INFO,LOG_TAG,__VA_ARGS__)
+#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG,LOG_TAG,__VA_ARGS__)
+#define LOGW(...) __android_log_print(ANDROID_LOG_WARN,LOG_TAG,__VA_ARGS__)
+#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR,LOG_TAG,__VA_ARGS__)
+
+#endif //YAHFA_COMMON_H
diff --git a/yhook/src/main/jni/env.h b/yhook/src/main/jni/env.h
new file mode 100644
index 0000000..b8db04d
--- /dev/null
+++ b/yhook/src/main/jni/env.h
@@ -0,0 +1,30 @@
+//
+// Created by liuruikai756 on 05/07/2017.
+//
+
+#ifndef YAHFA_ENV_H
+#define YAHFA_ENV_H
+
+#define ANDROID_L 21
+#define ANDROID_L2 22
+#define ANDROID_M 23
+#define ANDROID_N 24
+#define ANDROID_N2 25
+#define ANDROID_O 26
+#define ANDROID_O2 27
+
+#define roundUpTo4(v) ((v+4-1) - ((v+4-1)&3))
+#define roundUpTo8(v) ((v+8-1) - ((v+8-1)&7))
+#if defined(__i386__) || defined(__arm__)
+#define pointer_size 4
+#define readAddr(addr) read32(addr)
+#define roundUpToPtrSize(x) roundUpTo4(x)
+#elif defined(__aarch64__)
+#define pointer_size 8
+#define readAddr(addr) read64(addr)
+#define roundUpToPtrSize(x) roundUpTo8(x)
+#else
+#error Unsupported architecture
+#endif
+
+#endif //YAHFA_ENV_H
diff --git a/yhook/src/main/jni/trampoline.c b/yhook/src/main/jni/trampoline.c
new file mode 100644
index 0000000..614017d
--- /dev/null
+++ b/yhook/src/main/jni/trampoline.c
@@ -0,0 +1,214 @@
+//
+// Created by liuruikai756 on 05/07/2017.
+//
+#include <sys/mman.h>
+#include <string.h>
+
+#include "common.h"
+#include "env.h"
+#include "trampoline.h"
+
+static unsigned char *trampolineCode; // place where trampolines are saved
+static unsigned int trampolineCodeSize; // total size of trampoline code area
+static unsigned int trampolineSize; // trampoline size required for each hook
+
+unsigned int hookCap = 0;
+unsigned int hookCount = 0;
+
+// trampoline1: set eax/r0/x0 to the hook ArtMethod addr and then jump into its entry point
+#if defined(__i386__)
+// b8 78 56 34 12 ; mov eax, 0x12345678
+// 66 c7 40 12 00 00 ; mov word [eax + 0x12], 0
+// ff 70 20 ; push dword [eax + 0x20]
+// c3 ; ret
+unsigned char trampoline1[] = {
+        0xb8, 0x78, 0x56, 0x34, 0x12,
+        0x66, 0xc7, 0x40, 0x12, 0x00, 0x00,
+        0xff, 0x70, 0x20,
+        0xc3
+};
+static unsigned int t1Size = roundUpToPtrSize(sizeof(trampoline1)); // for alignment
+
+#elif defined(__arm__)
+    //------------------------------> 10 00 9f e5 ; ldr r0, [pc, #20]
+    //------------------------------> 04 40 2d e5 ; push {r4}
+    //------------------------------> 00 40 a0 e3 ; mov r4, #0
+    //------------------------------> b2 41 c0 e1 ; strh r4, [r0, #18]
+    //------------------------------> 04 40 9d e4 ; pop {r4}
+// 00 00 9F E5 ; ldr r0, [pc]
+// 20 F0 90 E5 ; ldr pc, [r0, 0x20]
+// 78 56 34 12 ; 0x12345678
+unsigned char trampoline1[] = {
+        0x14, 0x00, 0x9f, 0xe5,
+        0x04, 0x40, 0x2d, 0xe5,
+        0x00, 0x40, 0xa0, 0xe3,
+        0xb2, 0x41, 0xc0, 0xe1,
+        0x04, 0x40, 0x9d, 0xe4,
+        0x00, 0x00, 0x9f, 0xe5,
+        0x20, 0xf0, 0x90, 0xe5,
+        0x78, 0x56, 0x34, 0x12
+};
+static unsigned int t1Size = sizeof(trampoline1);
+
+#elif defined(__aarch64__)
+// 60 00 00 58 ; ldr x0, 12    ------->// 80 00 00 58 ; ldr x0, 16  解决同dex时hotness的问题
+                                       // 1f 24 00 79 ; strh wzr, [x0, #18]
+
+// 10 18 40 f9 ; ldr x16, [x0, #48]
+// 00 02 1f d6 ; br x16
+// 78 56 34 12
+// 89 67 45 23 ; 0x2345678912345678
+unsigned char trampoline1[] = {
+        0x80, 0x00, 0x00, 0x58,
+        0x1f, 0x24, 0x00, 0x79,
+//        0x60, 0x00, 0x00, 0x58,
+        0x10, 0x18, 0x40, 0xf9,
+        0x00, 0x02, 0x1f, 0xd6,
+        0x78, 0x56, 0x34, 0x12,
+        0x89, 0x67, 0x45, 0x23
+};
+static unsigned int t1Size = roundUpToPtrSize(sizeof(trampoline1));
+#endif
+
+// trampoline2:
+// 1.1 set eax/r0/x0 to the copy of origin ArtMethod addr,
+// 2. clear hotness_count of the copy origin ArtMethod(only after Android N)
+// 3. jump into origin's real entry point
+#if defined(__i386__)
+// b8 21 43 65 87 ; mov eax, 0x87654321
+// 66 c7 40 12 00 00 ; mov word [eax + 0x12], 0
+// 68 78 56 34 12 ; push 0x12345678
+// c3 ; ret
+unsigned char trampoline2[] = {
+        0xb8, 0x21, 0x43, 0x65, 0x87,
+        0x66, 0xc7, 0x40, 0x12, 0x00, 0x00,
+        0x68, 0x78, 0x56, 0x34, 0x12,
+        0xc3
+};
+static unsigned int t2Size = roundUpToPtrSize(sizeof(trampoline2)); // for alignment
+
+#elif defined(__arm__)
+// 10 00 9f e5 ; ldr r0, [pc, #16]
+// 04 40 2d e5 ; push {r4}
+// 00 40 a0 e3 ; mov r4, #0
+// b2 41 c0 e1 ; strh r4, [r0, #18]
+// 04 40 9d e4 ; pop {r4}
+// 00 f0 9f e5 ; ldr pc, [pc, #0]
+// 21 43 65 87 ; 0x87654321
+// 78 56 34 12 ; 0x12345678
+unsigned char trampoline2[] = {
+        0x10, 0x00, 0x9f, 0xe5,
+        0x04, 0x40, 0x2d, 0xe5,
+        0x00, 0x40, 0xa0, 0xe3,
+        0xb2, 0x41, 0xc0, 0xe1,
+        0x04, 0x40, 0x9d, 0xe4,
+        0x00, 0xf0, 0x9f, 0xe5,
+        0x21, 0x43, 0x65, 0x87,
+        0x78, 0x56, 0x34, 0x12
+};
+static unsigned int t2Size = sizeof(trampoline2);
+
+#elif defined(__aarch64__)
+// 80 00 00 58 ; ldr x0, [pc, #16]
+// 1f 24 00 79 ; strh wzr, [x0, #18]
+// 90 00 00 58 ; ldr x16, [pc, #16]
+// 00 02 1f d6 ; br x16
+// 89 67 45 23
+// 78 56 34 12 ; 0x1234567823456789
+// 78 56 34 12
+// 89 67 45 23 ; 0x2345678912345678
+unsigned char trampoline2[] = {
+        0x80, 0x00, 0x00, 0x58,
+        0x1f, 0x24, 0x00, 0x79,
+        0x90, 0x00, 0x00, 0x58,
+        0x00, 0x02, 0x1f, 0xd6,
+        0x89, 0x67, 0x45, 0x23,
+        0x78, 0x56, 0x34, 0x12,
+        0x78, 0x56, 0x34, 0x12,
+        0x89, 0x67, 0x45, 0x23
+};
+static unsigned int t2Size = roundUpToPtrSize(sizeof(trampoline2));
+#endif
+
+void *genTrampoline1(void *hookMethod) {
+    void *targetAddr;
+    /*
+    if(mprotect(trampolineCode, trampolineCodeSize, PROT_READ | PROT_WRITE) == -1) {
+        LOGE("mprotect RW failed");
+        return NULL;
+    }*/
+    targetAddr = trampolineCode + trampolineSize*hookCount;
+    memcpy(targetAddr, trampoline1, sizeof(trampoline1)); // do not use t1size since it's a rounded size
+
+    // replace with the hook ArtMethod addr
+#if defined(__i386__)
+    memcpy(targetAddr+1, &hookMethod, pointer_size);
+#elif defined(__arm__)
+    memcpy(targetAddr+28, &hookMethod, pointer_size);
+//    memcpy(targetAddr+8, &hookMethod, pointer_size);
+#elif defined(__aarch64__)
+    memcpy(targetAddr+16, &hookMethod, pointer_size);
+#endif
+/*
+    if(mprotect(trampolineCode, trampolineCodeSize, PROT_READ | PROT_EXEC) == -1) {
+        LOGE("mprotect RX failed");
+        return NULL;
+    }
+    */
+    return targetAddr;
+}
+
+void *genTrampoline2(void *originMethod, void *entryPoint) {
+    int i;
+    void *targetAddr;
+    /*
+    if(mprotect(trampolineCode, trampolineCodeSize, PROT_READ | PROT_WRITE) == -1) {
+        LOGE("mprotect RW failed");
+        return NULL;
+    }
+     */
+    targetAddr = trampolineCode + trampolineSize*hookCount + t1Size;
+    memcpy(targetAddr, trampoline2, sizeof(trampoline2)); // do not use t2size since it's a rounded size
+
+    // set eax/r0/x0 and the real entrypoint
+#if defined(__i386__)
+    memcpy(targetAddr+1, &originMethod, pointer_size);
+    memcpy(targetAddr+12, &entryPoint, pointer_size);
+#elif defined(__arm__)
+    memcpy(targetAddr+24, &originMethod, pointer_size);
+    memcpy(targetAddr+28, &entryPoint, pointer_size);
+#elif defined(__aarch64__)
+    memcpy(targetAddr+16, &originMethod, pointer_size);
+    memcpy(targetAddr+24, &entryPoint, pointer_size);
+#endif
+/*
+    if(mprotect(trampolineCode, trampolineCodeSize, PROT_READ | PROT_EXEC) == -1) {
+        LOGE("mprotect RX failed");
+        return NULL;
+    }
+    */
+//    LOGI("trampoline 2 is at %p", targetAddr);
+    return targetAddr;
+}
+
+int doInitHookCap(unsigned int cap) {
+    trampolineSize = t1Size + t2Size;
+    if(cap == 0) {
+        LOGE("invalid capacity: %d", cap);
+        return 1;
+    }
+    if(hookCap) {
+        LOGW("allocating new space for trampoline code");
+    }
+    unsigned int allSize = trampolineSize*cap;
+    unsigned char *buf = mmap(NULL, allSize, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANON | MAP_PRIVATE, -1, 0);
+    if(buf == MAP_FAILED) {
+        LOGE("mmap failed");
+        return 1;
+    }
+    hookCap = cap;
+    hookCount = 0;
+    trampolineCode = buf;
+    trampolineCodeSize = allSize;
+    return 0;
+}
diff --git a/yhook/src/main/jni/trampoline.h b/yhook/src/main/jni/trampoline.h
new file mode 100644
index 0000000..2cad667
--- /dev/null
+++ b/yhook/src/main/jni/trampoline.h
@@ -0,0 +1,22 @@
+//
+// Created by liuruikai756 on 05/07/2017.
+//
+
+#ifndef YAHFA_TAMPOLINE_H
+#define YAHFA_TAMPOLINE_H
+
+extern unsigned int hookCap; // capacity for trampolines
+extern unsigned int hookCount; // current count of used trampolines
+
+extern unsigned char trampoline1[];
+extern unsigned char trampoline2[];
+
+int doInitHookCap(unsigned int cap);
+
+void *genTrampoline1(void *hookMethod);
+
+void *genTrampoline2(void *originMethod, void *entryPoint);
+
+#define DEFAULT_CAP 64 //size of each trampoline area would be no more than 4k Bytes(one page)
+
+#endif //YAHFA_TAMPOLINE_H
diff --git a/yhook/src/main/res/values/strings.xml b/yhook/src/main/res/values/strings.xml
new file mode 100644
index 0000000..c8301ed
--- /dev/null
+++ b/yhook/src/main/res/values/strings.xml
@@ -0,0 +1,3 @@
+<resources>
+    <string name="app_name">YAHFA</string>
+</resources>
