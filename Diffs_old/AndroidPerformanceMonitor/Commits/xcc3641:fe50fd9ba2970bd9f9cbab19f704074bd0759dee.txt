diff --git a/blockcanary-analyzer/build.gradle b/blockcanary-analyzer/build.gradle
index 8bb5c8b..1de00db 100644
--- a/blockcanary-analyzer/build.gradle
+++ b/blockcanary-analyzer/build.gradle
@@ -22,7 +22,7 @@ android {
 
 dependencies {
     implementation fileTree(dir: 'libs', include: ['*.jar'])
-    compile "org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version"
+    api "org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version"
 }
 
 group = GROUP_NAME
diff --git a/blockcanary-analyzer/src/main/java/com/github/moduth/blockcanary/AbstractSampler.java b/blockcanary-analyzer/src/main/java/com/github/moduth/blockcanary/AbstractSampler.kt
similarity index 51%
rename from blockcanary-analyzer/src/main/java/com/github/moduth/blockcanary/AbstractSampler.java
rename to blockcanary-analyzer/src/main/java/com/github/moduth/blockcanary/AbstractSampler.kt
index 862116b..2d84b54 100644
--- a/blockcanary-analyzer/src/main/java/com/github/moduth/blockcanary/AbstractSampler.java
+++ b/blockcanary-analyzer/src/main/java/com/github/moduth/blockcanary/AbstractSampler.kt
@@ -13,56 +13,54 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.github.moduth.blockcanary;
+package com.github.moduth.blockcanary
 
-import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicBoolean
 
 /**
- * {@link AbstractSampler} sampler defines sampler work flow.
+ * [AbstractSampler] sampler defines sampler work flow.
  */
-abstract class AbstractSampler {
+internal abstract class AbstractSampler(sampleInterval: Long) {
 
-    private static final int DEFAULT_SAMPLE_INTERVAL = 300;
-
-    protected AtomicBoolean mShouldSample = new AtomicBoolean(false);
-    protected long mSampleInterval;
-
-    private Runnable mRunnable = new Runnable() {
-        @Override
-        public void run() {
-            doSample();
+    protected var mShouldSample = AtomicBoolean(false)
+    protected var mSampleInterval: Long = 0
 
+    private val mRunnable = object : Runnable {
+        override fun run() {
+            doSample()
             if (mShouldSample.get()) {
                 HandlerThreadFactory.getTimerThreadHandler()
-                        .postDelayed(mRunnable, mSampleInterval);
+                        .postDelayed(this, mSampleInterval)
             }
         }
-    };
+    }
 
-    public AbstractSampler(long sampleInterval) {
-        if (sampleInterval == 0) {
-            sampleInterval = DEFAULT_SAMPLE_INTERVAL;
-        }
-        mSampleInterval = sampleInterval;
+    init {
+        mSampleInterval = if (sampleInterval == 0L) DEFAULT_SAMPLE_INTERVAL.toLong() else sampleInterval
     }
 
-    public void start() {
+    open fun start() {
         if (mShouldSample.get()) {
-            return;
+            return
         }
-        mShouldSample.set(true);
+        mShouldSample.set(true)
 
-        HandlerThreadFactory.getTimerThreadHandler().removeCallbacks(mRunnable);
-        HandlerThreadFactory.getTimerThreadHandler().postDelayed(mRunnable, BlockCanaryInternals.getInstance().getSampleDelay());
+        HandlerThreadFactory.getTimerThreadHandler().removeCallbacks(mRunnable)
+        HandlerThreadFactory.getTimerThreadHandler().postDelayed(mRunnable, BlockCanaryInternals.getInstance().sampleDelay)
     }
 
-    public void stop() {
+    fun stop() {
         if (!mShouldSample.get()) {
-            return;
+            return
         }
-        mShouldSample.set(false);
-        HandlerThreadFactory.getTimerThreadHandler().removeCallbacks(mRunnable);
+        mShouldSample.set(false)
+        HandlerThreadFactory.getTimerThreadHandler().removeCallbacks(mRunnable)
     }
 
-    abstract void doSample();
+    protected abstract fun doSample()
+
+    companion object {
+
+        private const val DEFAULT_SAMPLE_INTERVAL = 300
+    }
 }
diff --git a/blockcanary-analyzer/src/main/java/com/github/moduth/blockcanary/CpuSampler.java b/blockcanary-analyzer/src/main/java/com/github/moduth/blockcanary/CpuSampler.java
deleted file mode 100644
index 01f0455..0000000
--- a/blockcanary-analyzer/src/main/java/com/github/moduth/blockcanary/CpuSampler.java
+++ /dev/null
@@ -1,217 +0,0 @@
-/*
- * Copyright (C) 2016 MarkZhai (http://zhaiyifan.cn).
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.github.moduth.blockcanary;
-
-import android.os.Build;
-import android.util.Log;
-import com.github.moduth.blockcanary.internal.BlockInfo;
-
-import java.io.BufferedReader;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.LinkedHashMap;
-import java.util.Map;
-
-/**
- * Dumps cpu usage.
- */
-class CpuSampler extends AbstractSampler {
-
-    private static final String TAG = "CpuSampler";
-    private static final int BUFFER_SIZE = 1000;
-
-    /**
-     * TODO: Explain how we define cpu busy in README
-     */
-    private final int BUSY_TIME;
-    private static final int MAX_ENTRY_COUNT = 10;
-
-    private final LinkedHashMap<Long, String> mCpuInfoEntries = new LinkedHashMap<>();
-    private int mPid = 0;
-    private long mUserLast = 0;
-    private long mSystemLast = 0;
-    private long mIdleLast = 0;
-    private long mIoWaitLast = 0;
-    private long mTotalLast = 0;
-    private long mAppCpuTimeLast = 0;
-
-    public CpuSampler(long sampleInterval) {
-        super(sampleInterval);
-        BUSY_TIME = (int) (mSampleInterval * 1.2f);
-    }
-
-    @Override
-    public void start() {
-        if (Build.VERSION.SDK_INT < 26) {
-            super.start();
-            reset();
-        }
-    }
-
-    /**
-     * Get cpu rate information
-     *
-     * @return string show cpu rate information
-     */
-    public String getCpuRateInfo() {
-        StringBuilder sb = new StringBuilder();
-        synchronized (mCpuInfoEntries) {
-            for (Map.Entry<Long, String> entry : mCpuInfoEntries.entrySet()) {
-                long time = entry.getKey();
-                sb.append(BlockInfo.TIME_FORMATTER.format(time))
-                        .append(' ')
-                        .append(entry.getValue())
-                        .append(BlockInfo.SEPARATOR);
-            }
-        }
-        return sb.toString();
-    }
-
-    public boolean isCpuBusy(long start, long end) {
-        if (end - start > mSampleInterval) {
-            long s = start - mSampleInterval;
-            long e = start + mSampleInterval;
-            long last = 0;
-            synchronized (mCpuInfoEntries) {
-                for (Map.Entry<Long, String> entry : mCpuInfoEntries.entrySet()) {
-                    long time = entry.getKey();
-                    if (s < time && time < e) {
-                        if (last != 0 && time - last > BUSY_TIME) {
-                            return true;
-                        }
-                        last = time;
-                    }
-                }
-            }
-        }
-        return false;
-    }
-
-    @Override
-    protected void doSample() {
-        BufferedReader cpuReader = null;
-        BufferedReader pidReader = null;
-
-        try {
-            cpuReader = new BufferedReader(new InputStreamReader(
-                    new FileInputStream("/proc/stat")), BUFFER_SIZE);
-            String cpuRate = cpuReader.readLine();
-            if (cpuRate == null) {
-                cpuRate = "";
-            }
-
-            if (mPid == 0) {
-                mPid = android.os.Process.myPid();
-            }
-            pidReader = new BufferedReader(new InputStreamReader(
-                    new FileInputStream("/proc/" + mPid + "/stat")), BUFFER_SIZE);
-            String pidCpuRate = pidReader.readLine();
-            if (pidCpuRate == null) {
-                pidCpuRate = "";
-            }
-
-            parse(cpuRate, pidCpuRate);
-        } catch (Throwable throwable) {
-            Log.e(TAG, "doSample: ", throwable);
-        } finally {
-            try {
-                if (cpuReader != null) {
-                    cpuReader.close();
-                }
-                if (pidReader != null) {
-                    pidReader.close();
-                }
-            } catch (IOException exception) {
-                Log.e(TAG, "doSample: ", exception);
-            }
-        }
-    }
-
-    private void reset() {
-        mUserLast = 0;
-        mSystemLast = 0;
-        mIdleLast = 0;
-        mIoWaitLast = 0;
-        mTotalLast = 0;
-        mAppCpuTimeLast = 0;
-    }
-
-    private void parse(String cpuRate, String pidCpuRate) {
-        String[] cpuInfoArray = cpuRate.split(" ");
-        if (cpuInfoArray.length < 9) {
-            return;
-        }
-
-        long user = Long.parseLong(cpuInfoArray[2]);
-        long nice = Long.parseLong(cpuInfoArray[3]);
-        long system = Long.parseLong(cpuInfoArray[4]);
-        long idle = Long.parseLong(cpuInfoArray[5]);
-        long ioWait = Long.parseLong(cpuInfoArray[6]);
-        long total = user + nice + system + idle + ioWait
-                + Long.parseLong(cpuInfoArray[7])
-                + Long.parseLong(cpuInfoArray[8]);
-
-        String[] pidCpuInfoList = pidCpuRate.split(" ");
-        if (pidCpuInfoList.length < 17) {
-            return;
-        }
-
-        long appCpuTime = Long.parseLong(pidCpuInfoList[13])
-                + Long.parseLong(pidCpuInfoList[14])
-                + Long.parseLong(pidCpuInfoList[15])
-                + Long.parseLong(pidCpuInfoList[16]);
-
-        if (mTotalLast != 0) {
-            StringBuilder stringBuilder = new StringBuilder();
-            long idleTime = idle - mIdleLast;
-            long totalTime = total - mTotalLast;
-
-            stringBuilder
-                    .append("cpu:")
-                    .append((totalTime - idleTime) * 100L / totalTime)
-                    .append("% ")
-                    .append("app:")
-                    .append((appCpuTime - mAppCpuTimeLast) * 100L / totalTime)
-                    .append("% ")
-                    .append("[")
-                    .append("user:").append((user - mUserLast) * 100L / totalTime)
-                    .append("% ")
-                    .append("system:").append((system - mSystemLast) * 100L / totalTime)
-                    .append("% ")
-                    .append("ioWait:").append((ioWait - mIoWaitLast) * 100L / totalTime)
-                    .append("% ]");
-
-            synchronized (mCpuInfoEntries) {
-                mCpuInfoEntries.put(System.currentTimeMillis(), stringBuilder.toString());
-                if (mCpuInfoEntries.size() > MAX_ENTRY_COUNT) {
-                    for (Map.Entry<Long, String> entry : mCpuInfoEntries.entrySet()) {
-                        Long key = entry.getKey();
-                        mCpuInfoEntries.remove(key);
-                        break;
-                    }
-                }
-            }
-        }
-        mUserLast = user;
-        mSystemLast = system;
-        mIdleLast = idle;
-        mIoWaitLast = ioWait;
-        mTotalLast = total;
-
-        mAppCpuTimeLast = appCpuTime;
-    }
-}
\ No newline at end of file
diff --git a/blockcanary-analyzer/src/main/java/com/github/moduth/blockcanary/CpuSampler.kt b/blockcanary-analyzer/src/main/java/com/github/moduth/blockcanary/CpuSampler.kt
new file mode 100644
index 0000000..a50aaba
--- /dev/null
+++ b/blockcanary-analyzer/src/main/java/com/github/moduth/blockcanary/CpuSampler.kt
@@ -0,0 +1,198 @@
+/*
+ * Copyright (C) 2016 MarkZhai (http://zhaiyifan.cn).
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.github.moduth.blockcanary
+
+import android.os.Build
+import android.util.Log
+import com.github.moduth.blockcanary.internal.BlockInfo
+import java.io.BufferedReader
+import java.io.FileInputStream
+import java.io.IOException
+import java.io.InputStreamReader
+import java.util.*
+
+/**
+ * Dumps cpu usage.
+ */
+internal class CpuSampler(sampleInterval: Long) : AbstractSampler(sampleInterval) {
+
+    /**
+     * TODO: Explain how we define cpu busy in README
+     */
+    private val BUSY_TIME: Int = (mSampleInterval * 1.2f).toInt()
+
+    private val mCpuInfoEntries = LinkedHashMap<Long, String>()
+    private var mPid = 0
+    private var mUserLast: Long = 0
+    private var mSystemLast: Long = 0
+    private var mIdleLast: Long = 0
+    private var mIoWaitLast: Long = 0
+    private var mTotalLast: Long = 0
+    private var mAppCpuTimeLast: Long = 0
+
+    /**
+     * Get cpu rate information
+     *
+     * @return string show cpu rate information
+     */
+    val cpuRateInfo: String
+        get() {
+            val sb = StringBuilder()
+            synchronized(mCpuInfoEntries) {
+                mCpuInfoEntries.forEach { (time, value) ->
+                    sb.append(BlockInfo.TIME_FORMATTER.format(time))
+                            .append(' ')
+                            .append(value)
+                            .append(BlockInfo.SEPARATOR)
+                }
+            }
+            return sb.toString()
+        }
+
+    override fun start() {
+        if (Build.VERSION.SDK_INT < 26) {
+            super.start()
+            reset()
+        }
+    }
+
+    fun isCpuBusy(start: Long, end: Long): Boolean {
+        if (end - start > mSampleInterval) {
+            val s = start - mSampleInterval
+            val e = start + mSampleInterval
+            var last: Long = 0
+            synchronized(mCpuInfoEntries) {
+                for ((time) in mCpuInfoEntries) {
+                    if (time in (s + 1)..(e - 1)) {
+                        if (last != 0L && time - last > BUSY_TIME) {
+                            return true
+                        }
+                        last = time
+                    }
+                }
+            }
+        }
+        return false
+    }
+
+    override fun doSample() {
+        var cpuReader: BufferedReader? = null
+        var pidReader: BufferedReader? = null
+
+        try {
+            cpuReader = BufferedReader(InputStreamReader(
+                    FileInputStream("/proc/stat")), BUFFER_SIZE)
+            val cpuRate: String = cpuReader.readLine() ?: ""
+
+            if (mPid == 0) {
+                mPid = android.os.Process.myPid()
+            }
+            pidReader = BufferedReader(InputStreamReader(FileInputStream("/proc/$mPid/stat")), BUFFER_SIZE)
+            val pidCpuRate: String = pidReader.readLine() ?: ""
+            parse(cpuRate, pidCpuRate)
+        } catch (throwable: Throwable) {
+            Log.e(TAG, "doSample: ", throwable)
+        } finally {
+            try {
+                cpuReader?.close()
+                pidReader?.close()
+            } catch (exception: IOException) {
+                Log.e(TAG, "doSample: ", exception)
+            }
+
+        }
+    }
+
+    private fun reset() {
+        mUserLast = 0
+        mSystemLast = 0
+        mIdleLast = 0
+        mIoWaitLast = 0
+        mTotalLast = 0
+        mAppCpuTimeLast = 0
+    }
+
+    private fun parse(cpuRate: String, pidCpuRate: String) {
+        val cpuInfoArray = cpuRate.split(" ".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()
+        if (cpuInfoArray.size < 9) {
+            return
+        }
+
+        val user = java.lang.Long.parseLong(cpuInfoArray[2])
+        val nice = java.lang.Long.parseLong(cpuInfoArray[3])
+        val system = java.lang.Long.parseLong(cpuInfoArray[4])
+        val idle = java.lang.Long.parseLong(cpuInfoArray[5])
+        val ioWait = java.lang.Long.parseLong(cpuInfoArray[6])
+        val total = (user + nice + system + idle + ioWait
+                + java.lang.Long.parseLong(cpuInfoArray[7])
+                + java.lang.Long.parseLong(cpuInfoArray[8]))
+
+        val pidCpuInfoList = pidCpuRate.split(" ".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()
+        if (pidCpuInfoList.size < 17) {
+            return
+        }
+
+        val appCpuTime = (java.lang.Long.parseLong(pidCpuInfoList[13])
+                + java.lang.Long.parseLong(pidCpuInfoList[14])
+                + java.lang.Long.parseLong(pidCpuInfoList[15])
+                + java.lang.Long.parseLong(pidCpuInfoList[16]))
+
+        if (mTotalLast != 0L) {
+            val stringBuilder = StringBuilder()
+            val idleTime = idle - mIdleLast
+            val totalTime = total - mTotalLast
+
+            stringBuilder
+                    .append("cpu:")
+                    .append((totalTime - idleTime) * 100L / totalTime)
+                    .append("% ")
+                    .append("app:")
+                    .append((appCpuTime - mAppCpuTimeLast) * 100L / totalTime)
+                    .append("% ")
+                    .append("[")
+                    .append("user:").append((user - mUserLast) * 100L / totalTime)
+                    .append("% ")
+                    .append("system:").append((system - mSystemLast) * 100L / totalTime)
+                    .append("% ")
+                    .append("ioWait:").append((ioWait - mIoWaitLast) * 100L / totalTime)
+                    .append("% ]")
+
+            synchronized(mCpuInfoEntries) {
+                mCpuInfoEntries[System.currentTimeMillis()] = stringBuilder.toString()
+                if (mCpuInfoEntries.size > MAX_ENTRY_COUNT) {
+                    for ((key) in mCpuInfoEntries) {
+                        mCpuInfoEntries.remove(key)
+                        break
+                    }
+                }
+            }
+        }
+        mUserLast = user
+        mSystemLast = system
+        mIdleLast = idle
+        mIoWaitLast = ioWait
+        mTotalLast = total
+
+        mAppCpuTimeLast = appCpuTime
+    }
+
+    companion object {
+
+        private const val TAG = "CpuSampler"
+        private const val BUFFER_SIZE = 1000
+        private const val MAX_ENTRY_COUNT = 10
+    }
+}
\ No newline at end of file
diff --git a/blockcanary-analyzer/src/main/java/com/github/moduth/blockcanary/LooperMonitor.java b/blockcanary-analyzer/src/main/java/com/github/moduth/blockcanary/LooperMonitor.java
deleted file mode 100644
index e101c92..0000000
--- a/blockcanary-analyzer/src/main/java/com/github/moduth/blockcanary/LooperMonitor.java
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- * Copyright (C) 2016 MarkZhai (http://zhaiyifan.cn).
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.github.moduth.blockcanary;
-
-import android.os.Debug;
-import android.os.SystemClock;
-import android.util.Printer;
-
-class LooperMonitor implements Printer {
-
-    private static final int DEFAULT_BLOCK_THRESHOLD_MILLIS = 3000;
-
-    private long mBlockThresholdMillis = DEFAULT_BLOCK_THRESHOLD_MILLIS;
-    private long mStartTimestamp = 0;
-    private long mStartThreadTimestamp = 0;
-    private BlockListener mBlockListener;
-    private boolean mPrintingStarted = false;
-    private final boolean mStopWhenDebugging;
-
-    public interface BlockListener {
-        void onBlockEvent(long realStartTime,
-                          long realTimeEnd,
-                          long threadTimeStart,
-                          long threadTimeEnd);
-    }
-
-    public LooperMonitor(BlockListener blockListener, long blockThresholdMillis, boolean stopWhenDebugging) {
-        if (blockListener == null) {
-            throw new IllegalArgumentException("blockListener should not be null.");
-        }
-        mBlockListener = blockListener;
-        mBlockThresholdMillis = blockThresholdMillis;
-        mStopWhenDebugging = stopWhenDebugging;
-    }
-
-    @Override
-    public void println(String x) {
-        if (mStopWhenDebugging && Debug.isDebuggerConnected()) {
-            return;
-        }
-        if (!mPrintingStarted) {
-            mStartTimestamp = System.currentTimeMillis();
-            mStartThreadTimestamp = SystemClock.currentThreadTimeMillis();
-            mPrintingStarted = true;
-            startDump();
-        } else {
-            final long endTime = System.currentTimeMillis();
-            mPrintingStarted = false;
-            if (isBlock(endTime)) {
-                notifyBlockEvent(endTime);
-            }
-            stopDump();
-        }
-    }
-
-    private boolean isBlock(long endTime) {
-        return endTime - mStartTimestamp > mBlockThresholdMillis;
-    }
-
-    private void notifyBlockEvent(final long endTime) {
-        final long startTime = mStartTimestamp;
-        final long startThreadTime = mStartThreadTimestamp;
-        final long endThreadTime = SystemClock.currentThreadTimeMillis();
-        HandlerThreadFactory.getWriteLogThreadHandler().post(new Runnable() {
-            @Override
-            public void run() {
-                mBlockListener.onBlockEvent(startTime, endTime, startThreadTime, endThreadTime);
-            }
-        });
-    }
-
-    private void startDump() {
-        if (BlockCanaryInternals.getInstance().stackSampler != null) {
-            BlockCanaryInternals.getInstance().stackSampler.start();
-        }
-
-        if (BlockCanaryInternals.getInstance().cpuSampler != null) {
-            BlockCanaryInternals.getInstance().cpuSampler.start();
-        }
-    }
-
-    private void stopDump() {
-        if (BlockCanaryInternals.getInstance().stackSampler != null) {
-            BlockCanaryInternals.getInstance().stackSampler.stop();
-        }
-
-        if (BlockCanaryInternals.getInstance().cpuSampler != null) {
-            BlockCanaryInternals.getInstance().cpuSampler.stop();
-        }
-    }
-}
\ No newline at end of file
diff --git a/blockcanary-analyzer/src/main/java/com/github/moduth/blockcanary/LooperMonitor.kt b/blockcanary-analyzer/src/main/java/com/github/moduth/blockcanary/LooperMonitor.kt
new file mode 100644
index 0000000..5f1b280
--- /dev/null
+++ b/blockcanary-analyzer/src/main/java/com/github/moduth/blockcanary/LooperMonitor.kt
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2016 MarkZhai (http://zhaiyifan.cn).
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.github.moduth.blockcanary
+
+import android.os.Debug
+import android.os.SystemClock
+import android.util.Printer
+
+internal class LooperMonitor(private val mBlockListener: BlockListener, blockThresholdMillis: Long, private val mStopWhenDebugging: Boolean) : Printer {
+
+    private var mBlockThresholdMillis = DEFAULT_BLOCK_THRESHOLD_MILLIS.toLong()
+    private var mStartTimestamp: Long = 0
+    private var mStartThreadTimestamp: Long = 0
+    private var mPrintingStarted = false
+
+    interface BlockListener {
+        fun onBlockEvent(realStartTime: Long, realTimeEnd: Long, threadTimeStart: Long, threadTimeEnd: Long)
+    }
+
+    init {
+        mBlockThresholdMillis = blockThresholdMillis
+    }
+
+    override fun println(x: String) {
+        if (mStopWhenDebugging && Debug.isDebuggerConnected()) {
+            return
+        }
+        if (!mPrintingStarted) {
+            mStartTimestamp = System.currentTimeMillis()
+            mStartThreadTimestamp = SystemClock.currentThreadTimeMillis()
+            mPrintingStarted = true
+            startDump()
+        } else {
+            val endTime = System.currentTimeMillis()
+            mPrintingStarted = false
+            if (isBlock(endTime)) {
+                notifyBlockEvent(endTime)
+            }
+            stopDump()
+        }
+    }
+
+    private fun isBlock(endTime: Long): Boolean {
+        return endTime - mStartTimestamp > mBlockThresholdMillis
+    }
+
+    private fun notifyBlockEvent(endTime: Long) {
+        val startTime = mStartTimestamp
+        val startThreadTime = mStartThreadTimestamp
+        val endThreadTime = SystemClock.currentThreadTimeMillis()
+        HandlerThreadFactory.getWriteLogThreadHandler().post { mBlockListener.onBlockEvent(startTime, endTime, startThreadTime, endThreadTime) }
+    }
+
+    private fun startDump() {
+        BlockCanaryInternals.getInstance().stackSampler?.start()
+        BlockCanaryInternals.getInstance().cpuSampler?.start()
+    }
+
+    private fun stopDump() {
+        BlockCanaryInternals.getInstance().stackSampler?.stop()
+        BlockCanaryInternals.getInstance().cpuSampler?.stop()
+    }
+
+    companion object {
+        private const val DEFAULT_BLOCK_THRESHOLD_MILLIS = 3000
+    }
+}
\ No newline at end of file
diff --git a/blockcanary-analyzer/src/main/java/com/github/moduth/blockcanary/StackSampler.java b/blockcanary-analyzer/src/main/java/com/github/moduth/blockcanary/StackSampler.java
deleted file mode 100644
index a6f43d4..0000000
--- a/blockcanary-analyzer/src/main/java/com/github/moduth/blockcanary/StackSampler.java
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * Copyright (C) 2016 MarkZhai (http://zhaiyifan.cn).
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.github.moduth.blockcanary;
-
-import com.github.moduth.blockcanary.internal.BlockInfo;
-
-import java.util.ArrayList;
-import java.util.LinkedHashMap;
-
-/**
- * Dumps thread stack.
- */
-class StackSampler extends AbstractSampler {
-
-    private static final int DEFAULT_MAX_ENTRY_COUNT = 100;
-    private static final LinkedHashMap<Long, String> sStackMap = new LinkedHashMap<>();
-
-    private int mMaxEntryCount = DEFAULT_MAX_ENTRY_COUNT;
-    private Thread mCurrentThread;
-
-    public StackSampler(Thread thread, long sampleIntervalMillis) {
-        this(thread, DEFAULT_MAX_ENTRY_COUNT, sampleIntervalMillis);
-    }
-
-    public StackSampler(Thread thread, int maxEntryCount, long sampleIntervalMillis) {
-        super(sampleIntervalMillis);
-        mCurrentThread = thread;
-        mMaxEntryCount = maxEntryCount;
-    }
-
-    public ArrayList<String> getThreadStackEntries(long startTime, long endTime) {
-        ArrayList<String> result = new ArrayList<>();
-        synchronized (sStackMap) {
-            for (Long entryTime : sStackMap.keySet()) {
-                if (startTime < entryTime && entryTime < endTime) {
-                    result.add(BlockInfo.TIME_FORMATTER.format(entryTime)
-                            + BlockInfo.SEPARATOR
-                            + BlockInfo.SEPARATOR
-                            + sStackMap.get(entryTime));
-                }
-            }
-        }
-        return result;
-    }
-
-    @Override
-    protected void doSample() {
-        StringBuilder stringBuilder = new StringBuilder();
-
-        for (StackTraceElement stackTraceElement : mCurrentThread.getStackTrace()) {
-            stringBuilder.append(stackTraceElement.toString()).append(BlockInfo.SEPARATOR);
-        }
-
-        synchronized (sStackMap) {
-            if (sStackMap.size() == mMaxEntryCount && mMaxEntryCount > 0) {
-                sStackMap.remove(sStackMap.keySet().iterator().next());
-            }
-            sStackMap.put(System.currentTimeMillis(), stringBuilder.toString());
-        }
-    }
-}
\ No newline at end of file
diff --git a/blockcanary-analyzer/src/main/java/com/github/moduth/blockcanary/StackSampler.kt b/blockcanary-analyzer/src/main/java/com/github/moduth/blockcanary/StackSampler.kt
new file mode 100644
index 0000000..94a7071
--- /dev/null
+++ b/blockcanary-analyzer/src/main/java/com/github/moduth/blockcanary/StackSampler.kt
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2016 MarkZhai (http://zhaiyifan.cn).
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.github.moduth.blockcanary
+
+import com.github.moduth.blockcanary.internal.BlockInfo
+import java.util.*
+
+/**
+ * Dumps thread stack.
+ */
+internal class StackSampler(private val mCurrentThread: Thread, maxEntryCount: Int, sampleIntervalMillis: Long) : AbstractSampler(sampleIntervalMillis) {
+
+    private var mMaxEntryCount = DEFAULT_MAX_ENTRY_COUNT
+
+    constructor(thread: Thread, sampleIntervalMillis: Long) : this(thread, DEFAULT_MAX_ENTRY_COUNT, sampleIntervalMillis) {}
+
+    init {
+        mMaxEntryCount = maxEntryCount
+    }
+
+    fun getThreadStackEntries(startTime: Long, endTime: Long): ArrayList<String> {
+        val result = ArrayList<String>()
+        synchronized(sStackMap) {
+            sStackMap.keys
+                    .filter { it in (startTime + 1)..(endTime - 1) }
+                    .forEach {
+                        result.add(BlockInfo.TIME_FORMATTER.format(it)
+                                + BlockInfo.SEPARATOR
+                                + BlockInfo.SEPARATOR
+                                + sStackMap[it])
+                    }
+        }
+        return result
+    }
+
+    override fun doSample() {
+        val stringBuilder = StringBuilder()
+        mCurrentThread.stackTrace.forEach { stringBuilder.append(it.toString()).append(BlockInfo.SEPARATOR) }
+        synchronized(sStackMap) {
+            if (sStackMap.size == mMaxEntryCount && mMaxEntryCount > 0) {
+                sStackMap.remove(sStackMap.keys.iterator().next())
+            }
+            sStackMap.put(System.currentTimeMillis(), stringBuilder.toString())
+        }
+    }
+
+    companion object {
+
+        private const val DEFAULT_MAX_ENTRY_COUNT = 100
+        private val sStackMap = LinkedHashMap<Long, String>()
+    }
+}
\ No newline at end of file
diff --git a/blockcanary-android-no-op/build.gradle b/blockcanary-android-no-op/build.gradle
index 8bb5c8b..1de00db 100644
--- a/blockcanary-android-no-op/build.gradle
+++ b/blockcanary-android-no-op/build.gradle
@@ -22,7 +22,7 @@ android {
 
 dependencies {
     implementation fileTree(dir: 'libs', include: ['*.jar'])
-    compile "org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version"
+    api "org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version"
 }
 
 group = GROUP_NAME
diff --git a/blockcanary-android/build.gradle b/blockcanary-android/build.gradle
index 61d7946..95768be 100644
--- a/blockcanary-android/build.gradle
+++ b/blockcanary-android/build.gradle
@@ -23,8 +23,6 @@ android {
 dependencies {
     implementation fileTree(include: ['*.jar'], dir: 'libs')
     api project(':blockcanary-analyzer')
-    compile "org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version"
-//    api 'com.github.xcc3641.BlockCanary:blockcanary-analyzer:1.4.0'
 }
 
 group = GROUP_NAME
diff --git a/blockcanary-sample/build.gradle b/blockcanary-sample/build.gradle
index d6962c6..a104b21 100644
--- a/blockcanary-sample/build.gradle
+++ b/blockcanary-sample/build.gradle
@@ -27,7 +27,6 @@ dependencies {
 
     implementation 'com.android.support:appcompat-v7:27.1.1'
     implementation 'com.android.support:design:27.1.1'
-    compile "org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version"
 }
 repositories {
     mavenCentral()
