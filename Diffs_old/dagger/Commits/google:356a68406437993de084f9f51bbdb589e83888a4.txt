diff --git a/java/dagger/internal/codegen/AndroidModeBindingMethodImplementation.java b/java/dagger/internal/codegen/AndroidModeBindingMethodImplementation.java
deleted file mode 100644
index 9283a3e17..000000000
--- a/java/dagger/internal/codegen/AndroidModeBindingMethodImplementation.java
+++ /dev/null
@@ -1,177 +0,0 @@
-/*
- * Copyright (C) 2017 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.CodeBlocks.anonymousProvider;
-import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.SINGLETON_INSTANCE;
-import static dagger.internal.codegen.DelegateBindingExpression.isBindsScopeStrongerThanDependencyScope;
-import static dagger.internal.codegen.GeneratedComponentModel.FieldSpecKind.PRIVATE_METHOD_SCOPED_FIELD;
-import static dagger.model.BindingKind.DELEGATE;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.VOLATILE;
-
-import com.google.common.base.Supplier;
-import com.google.common.base.Suppliers;
-import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.CodeBlock;
-import com.squareup.javapoet.FieldSpec;
-import com.squareup.javapoet.TypeName;
-import com.squareup.javapoet.TypeSpec;
-import dagger.internal.MemoizedSentinel;
-import dagger.model.RequestKind;
-import dagger.model.Scope;
-import javax.lang.model.util.Elements;
-
-/**
- * Defines a method body and return type for a given {@link BindingExpression} in Android mode,
- * which optionally inlines provider and locking optimizations.
- */
-final class AndroidModeBindingMethodImplementation extends BindingMethodImplementation {
-  private final BindingGraph graph;
-  private final GeneratedComponentModel generatedComponentModel;
-  private final ComponentBindingExpressions componentBindingExpressions;
-  private final BindingExpression bindingExpression;
-  private final ContributionBinding binding;
-  private final ReferenceReleasingManagerFields referenceReleasingManagerFields;
-  private final ClassName componentName;
-  private final Supplier<String> fieldName = Suppliers.memoize(this::createField);
-
-  AndroidModeBindingMethodImplementation(
-      BindingExpression bindingExpression,
-      DaggerTypes types,
-      Elements elements,
-      BindingGraph graph,
-      GeneratedComponentModel generatedComponentModel,
-      ComponentBindingExpressions componentBindingExpressions,
-      ReferenceReleasingManagerFields referenceReleasingManagerFields) {
-    super(bindingExpression, generatedComponentModel.name(), types, elements);
-    this.graph = graph;
-    this.generatedComponentModel = generatedComponentModel;
-    this.componentName = generatedComponentModel.name();
-    this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
-    this.bindingExpression = bindingExpression;
-    this.binding = bindingExpression.resolvedBindings().contributionBinding();
-    this.referenceReleasingManagerFields = checkNotNull(referenceReleasingManagerFields);
-  }
-
-  @Override
-  CodeBlock body() {
-    // TODO(user): split this class into 1 class for each request?
-    switch (requestKind()) {
-      case PROVIDER:
-        if (shouldInlineProvider()) {
-          // TODO(user): Cache provider field instead of recreating each time.
-          return CodeBlock.of("return $L;", anonymousProviderClass());
-        }
-        break;
-      case INSTANCE:
-        if (binding.scope().isPresent()) {
-          Scope scope = binding.scope().get();
-          if (shouldInlineScope(scope)) {
-            return scope.isReusable() ? singleCheck() : doubleCheck();
-          }
-        }
-        break;
-      default:
-        break;
-    }
-    return super.body();
-  }
-
-  /**
-   * Providers should be inlined if:
-   *
-   * <ul>
-   *   <li>the binding is scoped, or
-   *   <li>the binding is not scoped and a singleton factory class does not exist for it. If a
-   *       singleton factory class exists for a non-scoped binding, we use that instead since it's
-   *       more efficient than potentially classloading another anonymous provider class.
-   * </ul>
-   */
-  private boolean shouldInlineProvider() {
-    return binding.scope().isPresent()
-        || !binding.factoryCreationStrategy().equals(SINGLETON_INSTANCE);
-  }
-
-  private boolean shouldInlineScope(Scope scope) {
-    if (referenceReleasingManagerFields.requiresReleasableReferences(scope)) {
-      // TODO(user): enable for releasable references.
-      return false;
-    } else if (binding.kind().equals(DELEGATE)) {
-      // Only scope a delegate binding if its scope is stronger than its dependency's scope.
-      return isBindsScopeStrongerThanDependencyScope(resolvedBindings(), graph);
-    } else {
-      return true;
-    }
-  }
-
-  private CodeBlock singleCheck() {
-    return CodeBlock.builder()
-        .beginControlFlow("if ($N instanceof $T)", fieldName.get(), MemoizedSentinel.class)
-        .addStatement(
-            "$N = $L",
-            fieldName.get(),
-            bindingExpression.getDependencyExpression(componentName).codeBlock())
-        .endControlFlow()
-        .addStatement("return ($T) $N", returnType(), fieldName.get())
-        .build();
-  }
-
-  private CodeBlock doubleCheck() {
-    String fieldExpression =
-        fieldName.get().equals("local") ? "this." + fieldName.get() : fieldName.get();
-    return CodeBlock.builder()
-        .addStatement("$T local = $L", TypeName.OBJECT, fieldExpression)
-        .beginControlFlow("if (local instanceof $T)", MemoizedSentinel.class)
-        .beginControlFlow("synchronized (local)")
-        // TODO(user): benchmark to see if this is really faster than instanceof check?
-        .beginControlFlow("if (local == $L)", fieldExpression)
-        .addStatement(
-            "$L = $L",
-            fieldExpression,
-            bindingExpression.getDependencyExpression(componentName).codeBlock())
-        .endControlFlow()
-        .addStatement("local = $L", fieldExpression)
-        .endControlFlow()
-        .endControlFlow()
-        .addStatement("return ($T) local", returnType())
-        .build();
-  }
-
-  private String createField() {
-    String name = generatedComponentModel.getUniqueFieldName(BindingVariableNamer.name(binding));
-    generatedComponentModel.addField(
-        PRIVATE_METHOD_SCOPED_FIELD,
-        FieldSpec.builder(TypeName.OBJECT, name, PRIVATE, VOLATILE)
-            .initializer("new $T()", MemoizedSentinel.class)
-            .build());
-    return name;
-  }
-
-  /** Returns a {@link TypeSpec} for an anonymous provider class. */
-  private CodeBlock anonymousProviderClass() {
-    // TODO(user): For scoped bindings that have already been created, use InstanceFactory?
-    return anonymousProvider(
-        TypeName.get(accessibleType(binding.contributedType())),
-        CodeBlock.of(
-            "return $L;",
-            componentBindingExpressions
-                .getDependencyExpression(key(), RequestKind.INSTANCE, componentName)
-                .codeBlock()));
-  }
-}
diff --git a/java/dagger/internal/codegen/AnonymousProviderBindingExpression.java b/java/dagger/internal/codegen/AnonymousProviderBindingExpression.java
new file mode 100644
index 000000000..9678d35f5
--- /dev/null
+++ b/java/dagger/internal/codegen/AnonymousProviderBindingExpression.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static dagger.internal.codegen.CodeBlocks.anonymousProvider;
+import static dagger.internal.codegen.RequestKinds.requestType;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.TypeName;
+import dagger.model.RequestKind;
+import javax.lang.model.type.TypeMirror;
+
+/** A {@link BindingExpression} that returns an anonymous inner {@code Provider} instance. */
+final class AnonymousProviderBindingExpression extends BindingExpression {
+
+  private final ComponentBindingExpressions componentBindingExpressions;
+  private final DaggerTypes types;
+  private final ContributionBinding binding;
+
+  AnonymousProviderBindingExpression(
+      ResolvedBindings resolvedBindings,
+      ComponentBindingExpressions componentBindingExpressions,
+      DaggerTypes types) {
+    this.componentBindingExpressions = componentBindingExpressions;
+    this.types = types;
+    this.binding = resolvedBindings.contributionBinding();
+  }
+
+  @Override
+  Expression getDependencyExpression(ClassName requestingClass) {
+    TypeMirror providedType = types.accessibleType(binding.contributedType(), requestingClass);
+    return Expression.create(
+        requestType(RequestKind.PROVIDER, providedType, types),
+        anonymousProvider(
+            TypeName.get(providedType),
+            CodeBlock.of(
+                "return $L;",
+                componentBindingExpressions
+                    .getDependencyExpression(binding.key(), RequestKind.INSTANCE, requestingClass)
+                    .codeBlock())));
+  }
+
+  @Override
+  boolean requiresMethodEncapsulation() {
+    return true;
+  }
+}
diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index b786ab767..e54bba852 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -201,8 +201,8 @@ java_library(
 java_library(
     name = "writing",
     srcs = [
-        "AndroidModeBindingMethodImplementation.java",
         "AnnotationCreatorGenerator.java",
+        "AnonymousProviderBindingExpression.java",
         "BindingExpression.java",
         "BindingMethodImplementation.java",
         "ComponentBindingExpressions.java",
@@ -214,20 +214,22 @@ java_library(
         "ComponentRequirementBindingExpression.java",
         "ComponentRequirementField.java",
         "ComponentRequirementFields.java",
-        "ComponentRequirementProviderCreationExpression.java",
         "ComponentWriter.java",
         "DelegateBindingExpression.java",
         "DelegatingFrameworkInstanceCreationExpression.java",
         "DependencyMethodProducerCreationExpression.java",
         "DependencyMethodProviderCreationExpression.java",
+        "DerivedFromProviderBindingExpression.java",
         "FactoryGenerator.java",
         "FrameworkFieldInitializer.java",
         "FrameworkInstanceBindingExpression.java",
         "FrameworkInstanceSupplier.java",
         "GeneratedComponentModel.java",
         "GwtCompatibility.java",
+        "ImmediateFutureBindingExpression.java",
         "InjectionMethods.java",
         "InjectionOrProvisionProviderCreationExpression.java",
+        "InstanceFactoryCreationExpression.java",
         "MapBindingExpression.java",
         "MapFactoryCreationExpression.java",
         "MemberSelect.java",
@@ -247,6 +249,7 @@ java_library(
         "ReferenceReleasingManagerFields.java",
         "ReleasableReferenceManagerProviderCreationExpression.java",
         "ReleasableReferenceManagerSetProviderCreationExpression.java",
+        "ScopedInstanceMethodImplementation.java",
         "SetBindingExpression.java",
         "SetFactoryCreationExpression.java",
         "SimpleInvocationBindingExpression.java",
diff --git a/java/dagger/internal/codegen/BindingExpression.java b/java/dagger/internal/codegen/BindingExpression.java
index 3a8b81326..d92cd97e0 100644
--- a/java/dagger/internal/codegen/BindingExpression.java
+++ b/java/dagger/internal/codegen/BindingExpression.java
@@ -16,41 +16,13 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
-
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
-import dagger.model.DependencyRequest;
-import dagger.model.Key;
-import dagger.model.RequestKind;
 
 /** A factory of code expressions used to access a single request for a binding in a component. */
 // TODO(user): Rename this to RequestExpression?
 abstract class BindingExpression {
-  private final ResolvedBindings resolvedBindings;
-  private final RequestKind requestKind;
-
-  BindingExpression(ResolvedBindings resolvedBindings, RequestKind requestKind) {
-    this.resolvedBindings = checkNotNull(resolvedBindings);
-    this.requestKind = checkNotNull(requestKind);
-  }
-
-  /** Returns the {@link Key} for this expression. */
-  final Key key() {
-    return resolvedBindings.key();
-  }
-
-  /** Returns the {@link RequestKind} handled by this expression. */
-  final RequestKind requestKind() {
-    return requestKind;
-  }
-
-  /** The binding this instance uses to fulfill requests. */
-  final ResolvedBindings resolvedBindings() {
-    return resolvedBindings;
-  }
 
   /**
    * Returns an expression that evaluates to the value of a request based on the given requesting
@@ -60,28 +32,17 @@ final ResolvedBindings resolvedBindings() {
    */
   abstract Expression getDependencyExpression(ClassName requestingClass);
 
-  /**
-   * Returns an expression for the implementation of a component method with the given request.
-   *
-   * @param componentName the component that will contain the implemented method
-   */
-  final CodeBlock getComponentMethodImplementation(
-      ComponentMethodDescriptor componentMethod, ClassName componentName) {
-    DependencyRequest request = componentMethod.dependencyRequest().get();
-    checkArgument(request.key().equals(key()));
-    checkArgument(request.kind().equals(requestKind()));
-    return doGetComponentMethodImplementation(componentMethod, componentName);
+  /** Returns {@code true} if this binding expression should be encapsulated in a method. */
+  boolean requiresMethodEncapsulation() {
+    return false;
   }
 
   /**
    * Returns an expression for the implementation of a component method with the given request.
    *
-   * <p>This method is called only if {@code componentMethod}'s request key and kind matches this
-   * binding expression's.
-   *
    * @param componentName the component that will contain the implemented method
    */
-  protected CodeBlock doGetComponentMethodImplementation(
+  CodeBlock getComponentMethodImplementation(
       ComponentMethodDescriptor componentMethod, ClassName componentName) {
     // By default, just delegate to #getDependencyExpression().
     return CodeBlock.of("return $L;", getDependencyExpression(componentName).codeBlock());
diff --git a/java/dagger/internal/codegen/BindingMethodImplementation.java b/java/dagger/internal/codegen/BindingMethodImplementation.java
index 8ac498b34..b1d8aaae0 100644
--- a/java/dagger/internal/codegen/BindingMethodImplementation.java
+++ b/java/dagger/internal/codegen/BindingMethodImplementation.java
@@ -19,35 +19,30 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.RequestKinds.requestType;
 
-import com.google.auto.common.MoreTypes;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
-import dagger.model.Key;
 import dagger.model.RequestKind;
-import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
 
 /** Defines a method body and return type for a given {@link BindingExpression}. */
 class BindingMethodImplementation {
+  private final ContributionBinding binding;
+  private final RequestKind requestKind;
   private final BindingExpression bindingExpression;
   private final ClassName componentName;
-  private final ResolvedBindings resolvedBindings;
-  private final RequestKind requestKind;
   private final DaggerTypes types;
-  private final Elements elements;
 
   BindingMethodImplementation(
+      ResolvedBindings resolvedBindings,
+      RequestKind requestKind,
       BindingExpression bindingExpression,
       ClassName componentName,
-      DaggerTypes types,
-      Elements elements) {
+      DaggerTypes types) {
+    this.binding = resolvedBindings.contributionBinding();
+    this.requestKind = checkNotNull(requestKind);
     this.bindingExpression = checkNotNull(bindingExpression);
     this.componentName = checkNotNull(componentName);
     this.types = checkNotNull(types);
-    this.elements = checkNotNull(elements);
-    this.resolvedBindings = bindingExpression.resolvedBindings();
-    this.requestKind = bindingExpression.requestKind();
   }
 
   /**
@@ -57,45 +52,21 @@
    * return} statement.
    */
   CodeBlock body() {
-    return CodeBlock.of(
-        "return $L;", bindingExpression.getDependencyExpression(componentName).codeBlock());
+    return CodeBlock.of("return $L;", simpleBindingExpression());
+  }
+
+  /** Returns the code for the binding expression. */
+  protected final CodeBlock simpleBindingExpression() {
+    return bindingExpression.getDependencyExpression(componentName).codeBlock();
   }
 
   /** Returns the return type for the dependency request. */
   final TypeMirror returnType() {
-    ContributionBinding binding = resolvedBindings.contributionBinding();
     if (requestKind.equals(RequestKind.INSTANCE)
         && binding.contributedPrimitiveType().isPresent()) {
       return binding.contributedPrimitiveType().get();
     }
-    return accessibleType(requestType(requestKind, binding.contributedType(), types));
-  }
-
-  /** Returns the {@linkplain Key} for this expression. */
-  protected final Key key() {
-    return resolvedBindings.key();
-  }
-
-  /** Returns the {#linkplain RequestKind request kind} handled by this expression. */
-  protected final RequestKind requestKind() {
-    return requestKind;
-  }
-
-  /** The binding this instance uses to fulfill requests. */
-  protected final ResolvedBindings resolvedBindings() {
-    return resolvedBindings;
-  }
-
-  // TODO(user): Move this to Accessibility.java or DaggerTypes.java?
-  /** Returns a {@link TypeMirror} for the binding that is accessible to the component. */
-  protected final TypeMirror accessibleType(TypeMirror type) {
-    if (Accessibility.isTypeAccessibleFrom(type, componentName.packageName())) {
-      return type;
-    } else if (type.getKind().equals(TypeKind.DECLARED)
-        && Accessibility.isRawTypeAccessible(type, componentName.packageName())) {
-      return types.getDeclaredType(MoreTypes.asTypeElement(type));
-    } else {
-      return elements.getTypeElement(Object.class.getName()).asType();
-    }
+    return types.accessibleType(
+        requestType(requestKind, binding.contributedType(), types), componentName);
   }
 }
diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index 5cbc8ce04..5ed8402b1 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -23,41 +23,30 @@
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
 import static dagger.internal.codegen.BindingType.MEMBERS_INJECTION;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
-import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.SINGLETON_INSTANCE;
 import static dagger.internal.codegen.DaggerStreams.toImmutableList;
 import static dagger.internal.codegen.DelegateBindingExpression.isBindsScopeStrongerThanDependencyScope;
-import static dagger.internal.codegen.MemberSelect.staticMemberSelect;
+import static dagger.internal.codegen.MemberSelect.staticFactoryCreation;
 import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
 import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
 import static dagger.internal.codegen.TypeNames.REFERENCE_RELEASING_PROVIDER;
 import static dagger.internal.codegen.TypeNames.SINGLE_CHECK;
-import static dagger.model.BindingKind.COMPONENT;
-import static dagger.model.BindingKind.COMPONENT_DEPENDENCY;
 import static dagger.model.BindingKind.DELEGATE;
-import static dagger.model.BindingKind.INJECTION;
-import static dagger.model.BindingKind.MULTIBOUND_MAP;
-import static dagger.model.BindingKind.MULTIBOUND_SET;
-import static dagger.model.BindingKind.PROVISION;
 
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.HashBasedTable;
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Table;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.MethodSpec;
-import dagger.internal.InstanceFactory;
 import dagger.internal.MembersInjectors;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
-import dagger.model.BindingKind;
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
 import dagger.model.RequestKind;
-import dagger.model.Scope;
-import java.util.EnumSet;
 import java.util.Optional;
+import javax.inject.Provider;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 
@@ -252,13 +241,9 @@ private BindingExpression getBindingExpression(Key key, RequestKind requestKind)
                     String.format("no expression found for %s-%s", key, requestKind)));
   }
 
+  // TODO(dpb): Move to its own file.
   /** Factory for building a {@link BindingExpression}. */
   private static final class BindingExpressionFactory {
-    // TODO(user): Consider using PrivateMethodBindingExpression for other/all BEs?
-    private static final ImmutableSet<BindingKind> PRIVATE_METHOD_KINDS =
-        ImmutableSet.copyOf(
-            EnumSet.of(MULTIBOUND_SET, MULTIBOUND_MAP, INJECTION, PROVISION, DELEGATE));
-
     private final BindingGraph graph;
     private final GeneratedComponentModel generatedComponentModel;
     private final ComponentBindingExpressions componentBindingExpressions;
@@ -327,12 +312,10 @@ private MembersInjectionBindingExpression membersInjectionBindingExpression(
      */
     private FrameworkInstanceBindingExpression frameworkInstanceBindingExpression(
         ResolvedBindings resolvedBindings, RequestKind requestKind) {
-      Optional<MemberSelect> staticMethod = staticMemberSelect(resolvedBindings);
+      Optional<MemberSelect> staticMethod = staticFactoryCreation(resolvedBindings);
       FrameworkInstanceCreationExpression frameworkInstanceCreationExpression =
           resolvedBindings.scope().isPresent()
-              ? scope(
-                  resolvedBindings.scope().get(),
-                  frameworkInstanceCreationExpression(resolvedBindings))
+              ? scope(resolvedBindings, frameworkInstanceCreationExpression(resolvedBindings))
               : frameworkInstanceCreationExpression(resolvedBindings);
       return new FrameworkInstanceBindingExpression(
           resolvedBindings,
@@ -348,20 +331,20 @@ private FrameworkInstanceBindingExpression frameworkInstanceBindingExpression(
     }
 
     private FrameworkInstanceCreationExpression scope(
-        Scope scope, FrameworkInstanceCreationExpression unscoped) {
-      if (referenceReleasingManagerFields.requiresReleasableReferences(scope)) {
+        ResolvedBindings resolvedBindings, FrameworkInstanceCreationExpression unscoped) {
+      if (requiresReleasableReferences(resolvedBindings)) {
         return () ->
             CodeBlock.of(
                 "$T.create($L, $L)",
                 REFERENCE_RELEASING_PROVIDER,
                 unscoped.creationExpression(),
                 referenceReleasingManagerFields.getExpression(
-                    scope, generatedComponentModel.name()));
+                    resolvedBindings.scope().get(), generatedComponentModel.name()));
       } else {
         return () ->
             CodeBlock.of(
                 "$T.provider($L)",
-                scope.isReusable() ? SINGLE_CHECK : DOUBLE_CHECK,
+                resolvedBindings.scope().get().isReusable() ? SINGLE_CHECK : DOUBLE_CHECK,
                 unscoped.creationExpression());
       }
     }
@@ -376,14 +359,17 @@ private FrameworkInstanceCreationExpression frameworkInstanceCreationExpression(
       ContributionBinding binding = resolvedBindings.contributionBinding();
       switch (binding.kind()) {
         case COMPONENT:
-          // The type parameter can be removed when we drop java 7 source support
-          return () ->
-              CodeBlock.of("$T.<$T>create(this)", InstanceFactory.class, binding.key().type());
+          // The cast can be removed when we drop java 7 source support
+          return new InstanceFactoryCreationExpression(
+              () -> CodeBlock.of("($T) this", binding.key().type()));
 
         case BOUND_INSTANCE:
+          return instanceFactoryCreationExpression(
+              binding, ComponentRequirement.forBoundInstance(binding));
+
         case COMPONENT_DEPENDENCY:
-          return new ComponentRequirementProviderCreationExpression(
-              binding, generatedComponentModel, componentRequirementFields);
+          return instanceFactoryCreationExpression(
+              binding, ComponentRequirement.forDependency(binding.key().type()));
 
         case COMPONENT_PROVISION:
           return new DependencyMethodProviderCreationExpression(
@@ -451,22 +437,18 @@ private FrameworkInstanceCreationExpression frameworkInstanceCreationExpression(
               getOnlyElement(MoreTypes.asDeclared(binding.key().type()).getTypeArguments());
 
           if (((ProvisionBinding) binding).injectionSites().isEmpty()) {
-            return () ->
+            return new InstanceFactoryCreationExpression(
                 // The type parameter can be removed when we drop Java 7 source support.
-                CodeBlock.of(
-                    "$T.create($T.<$T>noOp())",
-                    InstanceFactory.class,
-                    MembersInjectors.class,
-                    membersInjectedType);
+                () -> CodeBlock.of("$T.<$T>noOp()", MembersInjectors.class, membersInjectedType));
           } else {
-            return () ->
-                CodeBlock.of(
-                    "$T.create($T.create($L))",
-                    InstanceFactory.class,
-                    membersInjectorNameForType(MoreTypes.asTypeElement(membersInjectedType)),
-                    makeParametersCodeBlock(
-                        componentBindingExpressions.getDependencyExpressions(
-                            binding.frameworkDependencies(), generatedComponentModel.name())));
+            return new InstanceFactoryCreationExpression(
+                () ->
+                    CodeBlock.of(
+                        "$T.create($L)",
+                        membersInjectorNameForType(MoreTypes.asTypeElement(membersInjectedType)),
+                        makeParametersCodeBlock(
+                            componentBindingExpressions.getDependencyExpressions(
+                                binding.frameworkDependencies(), generatedComponentModel.name()))));
           }
 
         default:
@@ -474,125 +456,50 @@ private FrameworkInstanceCreationExpression frameworkInstanceCreationExpression(
       }
     }
 
+    private InstanceFactoryCreationExpression instanceFactoryCreationExpression(
+        ContributionBinding binding, ComponentRequirement componentRequirement) {
+      return new InstanceFactoryCreationExpression(
+          binding.nullableType().isPresent(),
+          () ->
+              componentRequirementFields.getExpressionDuringInitialization(
+                  componentRequirement, generatedComponentModel.name()));
+    }
+
     /** Returns a binding expression for a provision binding. */
     private BindingExpression provisionBindingExpression(
         ResolvedBindings resolvedBindings, RequestKind requestKind) {
-      BindingExpression bindingExpression =
-          basicProvisionBindingExpression(resolvedBindings, requestKind);
-
-      Optional<ComponentMethodDescriptor> componentMethod =
-          findMatchingComponentMethod(resolvedBindings.key(), requestKind);
-      BindingKind bindingKind = resolvedBindings.contributionBinding().kind();
-      if (componentMethod.isPresent()
-          // Requests for a component or a component field should access the component or field
-          // directly, even if a component method exists.
-          && !bindingKind.equals(COMPONENT)
-          && !bindingKind.equals(COMPONENT_DEPENDENCY)) {
-        return new ComponentMethodBindingExpression(
-            resolvedBindings,
-            requestKind,
-            methodImplementation(bindingExpression),
-            generatedComponentModel,
-            componentMethod.get(),
-            componentBindingExpressions);
-      }
+      switch (requestKind) {
+        case PRODUCER:
+          return producerFromProviderBindingExpression(resolvedBindings, requestKind);
 
-      if (shouldUsePrivateMethod(resolvedBindings, requestKind)) {
-        return new PrivateMethodBindingExpression(
-            resolvedBindings,
-            requestKind,
-            methodImplementation(bindingExpression),
-            generatedComponentModel);
-      }
+        case INSTANCE:
+          return instanceBindingExpression(resolvedBindings);
 
-      return bindingExpression;
-    }
+        case FUTURE:
+          return new ImmediateFutureBindingExpression(
+              resolvedBindings, componentBindingExpressions, types);
 
-    private BindingMethodImplementation methodImplementation(BindingExpression bindingExpression) {
-      return compilerOptions.experimentalAndroidMode()
-          ? new AndroidModeBindingMethodImplementation(
-              bindingExpression,
-              types,
-              elements,
-              graph,
-              generatedComponentModel,
-              componentBindingExpressions,
-              referenceReleasingManagerFields)
-          : new BindingMethodImplementation(
-              bindingExpression, generatedComponentModel.name(), types, elements);
-    }
+        case LAZY:
+        case PRODUCED:
+        case PROVIDER_OF_LAZY:
+          return new DerivedFromProviderBindingExpression(
+              resolvedBindings, requestKind, componentBindingExpressions, types);
 
-    /**
-     * Returns true if requesters should call a no-arg, private method.
-     *
-     * <p>In default mode, private methods are used for unscoped {@code INSTANCE} and {@code FUTURE}
-     * requests that require at least one dependency. (Those with no dependencies can simply use
-     * their factory class's single instance.)
-     *
-     * <p>In Android mode, private methods are used for all provision bindings unless the request:
-     *
-     * <ul>
-     *   <li>is a delegate binding with a scope that is not stronger than its dependency scope,
-     *   <li>has releasable reference scope; TODO(user): enable for releasable reference scope,
-     *   <li>is for an unscoped framework type (Provider, Lazy, ProviderOfLazy) that can use the
-     *       singleton instance of the factory class,
-     *   <li>is for an unscoped non-framework type that has no dependencies, which means users can
-     *       call a nullary method anyway.
-     * </ul>
-     */
-    private boolean shouldUsePrivateMethod(
-        ResolvedBindings resolvedBindings, RequestKind requestKind) {
-      ContributionBinding binding = resolvedBindings.contributionBinding();
-      if (!PRIVATE_METHOD_KINDS.contains(binding.kind())
-          || (binding.kind().equals(DELEGATE)
-              && !isBindsScopeStrongerThanDependencyScope(resolvedBindings, graph))) {
-        return false;
-      }
-      if (useExperimentalAndroidMode(binding)) {
-        switch (requestKind) {
-          case PROVIDER:
-          case LAZY:
-          case PROVIDER_OF_LAZY:
-            return binding.scope().isPresent()
-                || !binding.factoryCreationStrategy().equals(SINGLETON_INSTANCE);
-          default:
-            return binding.scope().isPresent() || !binding.dependencies().isEmpty();
-        }
-      } else {
-        return (requestKind.equals(RequestKind.INSTANCE) || requestKind.equals(RequestKind.FUTURE))
-            && !binding.scope().isPresent()
-            && !binding.dependencies().isEmpty();
-      }
-    }
+        case PROVIDER:
+          return providerBindingExpression(resolvedBindings);
 
-    /** Returns the first component method associated with this request kind, if one exists. */
-    private Optional<ComponentMethodDescriptor> findMatchingComponentMethod(
-        Key key, RequestKind requestKind) {
-      Optional<ComponentMethodDescriptor> componentMethod =
-          graph
-              .componentDescriptor()
-              .componentMethods()
-              .stream()
-              .filter(method -> doesComponentMethodMatch(method, key, requestKind))
-              .findFirst();
-      return componentMethod;
-    }
+        case MEMBERS_INJECTION:
+          throw new IllegalArgumentException();
+      }
 
-    /** Returns true if the component method matches the dependency request binding key and kind. */
-    private boolean doesComponentMethodMatch(
-        ComponentMethodDescriptor componentMethod, Key key, RequestKind requestKind) {
-      return componentMethod
-          .dependencyRequest()
-          .filter(request -> request.key().equals(key))
-          .filter(request -> request.kind().equals(requestKind))
-          .isPresent();
+      throw new AssertionError();
     }
 
     /**
      * Returns a binding expression that uses a {@link dagger.producers.Producer} field for a
      * provision binding.
      */
-    private FrameworkInstanceBindingExpression producerFromProviderInstanceBindingExpression(
+    private FrameworkInstanceBindingExpression producerFromProviderBindingExpression(
         ResolvedBindings resolvedBindings, RequestKind requestKind) {
       checkArgument(resolvedBindings.bindingType().frameworkType().equals(FrameworkType.PROVIDER));
       return new FrameworkInstanceBindingExpression(
@@ -612,135 +519,263 @@ private FrameworkInstanceBindingExpression producerFromProviderInstanceBindingEx
     }
 
     /**
-     * Returns a binding expression that does not create a private method on the component or use a
-     * component provision method.
+     * Returns a binding expression for {@link RequestKind#INSTANCE} requests.
+     *
+     * <p>If there is a direct expression (not calling {@link Provider#get()}) we can use for an
+     * instance of this binding, return it, wrapped in a method if the binding {@linkplain
+     * #needsCaching(ResolvedBindings) needs to be cached} or the expression has dependencies.
+     *
+     * <p>In default mode, we can use direct expressions for bindings that don't need to be cached
+     * in a reference-releasing scope.
+     *
+     * <p>In Android mode, we can use direct expressions unless the binding needs to be cached.
      */
-    private BindingExpression basicProvisionBindingExpression(
-        ResolvedBindings resolvedBindings, RequestKind requestKind) {
-      if (shouldUseDelegateBindingExpression(resolvedBindings)) {
-        return new DelegateBindingExpression(
-            resolvedBindings, requestKind, componentBindingExpressions, types, elements);
-      }
-
-      switch (requestKind) {
-        case PRODUCER:
-          return producerFromProviderInstanceBindingExpression(resolvedBindings, requestKind);
-
-        case INSTANCE:
-        case FUTURE:
-          return instanceOrFutureBindingExpression(resolvedBindings, requestKind);
-
-        default:
-          return frameworkInstanceBindingExpression(resolvedBindings, requestKind);
+    private BindingExpression instanceBindingExpression(ResolvedBindings resolvedBindings) {
+      Optional<BindingExpression> maybeDirectInstanceExpression =
+          unscopedDirectInstanceExpression(resolvedBindings);
+      if (canUseDirectInstanceExpression(resolvedBindings)
+          && maybeDirectInstanceExpression.isPresent()) {
+        BindingExpression directInstanceExpression = maybeDirectInstanceExpression.get();
+        return directInstanceExpression.requiresMethodEncapsulation()
+                || needsCaching(resolvedBindings)
+            ? wrapInMethod(resolvedBindings, RequestKind.INSTANCE, directInstanceExpression)
+            : directInstanceExpression;
       }
+      return new DerivedFromProviderBindingExpression(
+          resolvedBindings, RequestKind.INSTANCE, componentBindingExpressions, types);
     }
 
     /**
-     * Returns a binding expression for an {@link RequestKind#INSTANCE} or {@link
-     * RequestKind#FUTURE}, which might be a {@link SimpleInvocationBindingExpression}.
+     * Returns an unscoped binding expression for an {@link RequestKind#INSTANCE} that does not call
+     * {@code get()} on its provider, if there is one.
      */
-    private BindingExpression instanceOrFutureBindingExpression(
-        ResolvedBindings resolvedBindings, RequestKind requestKind) {
+    private Optional<BindingExpression> unscopedDirectInstanceExpression(
+        ResolvedBindings resolvedBindings) {
       switch (resolvedBindings.contributionBinding().kind()) {
+        case DELEGATE:
+          return Optional.of(
+              new DelegateBindingExpression(
+                  resolvedBindings,
+                  RequestKind.INSTANCE,
+                  componentBindingExpressions,
+                  types,
+                  elements));
+
         case COMPONENT:
-          return new ComponentInstanceBindingExpression(
-              resolvedBindings, requestKind, generatedComponentModel.name(), types);
+          return Optional.of(
+              new ComponentInstanceBindingExpression(
+                  resolvedBindings, generatedComponentModel.name()));
 
         case COMPONENT_DEPENDENCY:
-          return new ComponentRequirementBindingExpression(
-              resolvedBindings,
-              requestKind,
-              ComponentRequirement.forDependency(resolvedBindings.key().type()),
-              componentRequirementFields,
-              types);
+          return Optional.of(
+              new ComponentRequirementBindingExpression(
+                  resolvedBindings,
+                  ComponentRequirement.forDependency(resolvedBindings.key().type()),
+                  componentRequirementFields));
 
         case COMPONENT_PROVISION:
-          return new ComponentProvisionBindingExpression(
-              resolvedBindings,
-              requestKind,
-              graph,
-              componentRequirementFields,
-              compilerOptions,
-              types);
+          return Optional.of(
+              new ComponentProvisionBindingExpression(
+                  resolvedBindings, graph, componentRequirementFields, compilerOptions));
 
         case SUBCOMPONENT_BUILDER:
-          return new SubcomponentBuilderBindingExpression(
-              resolvedBindings, requestKind, subcomponentNames.get(resolvedBindings.key()), types);
+          return Optional.of(
+              new SubcomponentBuilderBindingExpression(
+                  resolvedBindings, subcomponentNames.get(resolvedBindings.key())));
 
         case MULTIBOUND_SET:
-          return new SetBindingExpression(
-              resolvedBindings, requestKind, graph, componentBindingExpressions, types, elements);
+          return Optional.of(
+              new SetBindingExpression(
+                  resolvedBindings, graph, componentBindingExpressions, types, elements));
 
         case MULTIBOUND_MAP:
-          return new MapBindingExpression(
-              resolvedBindings, requestKind, graph, componentBindingExpressions, types, elements);
+          return Optional.of(
+              new MapBindingExpression(
+                  resolvedBindings, graph, componentBindingExpressions, types, elements));
 
         case OPTIONAL:
-          return new OptionalBindingExpression(
-              resolvedBindings, requestKind, componentBindingExpressions, types);
+          return Optional.of(
+              new OptionalBindingExpression(resolvedBindings, componentBindingExpressions, types));
 
         case BOUND_INSTANCE:
-          return new ComponentRequirementBindingExpression(
-              resolvedBindings,
-              requestKind,
-              ComponentRequirement.forBoundInstance(resolvedBindings.contributionBinding()),
-              componentRequirementFields,
-              types);
+          return Optional.of(
+              new ComponentRequirementBindingExpression(
+                  resolvedBindings,
+                  ComponentRequirement.forBoundInstance(resolvedBindings.contributionBinding()),
+                  componentRequirementFields));
 
         case INJECTION:
         case PROVISION:
-          if (canCallSimpleMethod(resolvedBindings)) {
-            return new SimpleMethodBindingExpression(
-                resolvedBindings,
-                requestKind,
-                compilerOptions,
-                componentBindingExpressions,
-                membersInjectionMethods,
-                componentRequirementFields,
-                types,
-                elements);
-          }
-          break;
+          return Optional.of(
+              new SimpleMethodBindingExpression(
+                  resolvedBindings,
+                  compilerOptions,
+                  componentBindingExpressions,
+                  membersInjectionMethods,
+                  componentRequirementFields,
+                  elements));
 
-        default:
-          break;
+        case MEMBERS_INJECTOR:
+        case RELEASABLE_REFERENCE_MANAGER:
+        case RELEASABLE_REFERENCE_MANAGERS:
+          // TODO(dpb): Implement direct expressions for these.
+          return Optional.empty();
+
+        case MEMBERS_INJECTION:
+        case COMPONENT_PRODUCTION:
+        case PRODUCTION:
+          throw new IllegalArgumentException(
+              resolvedBindings.contributionBinding().kind().toString());
       }
-      return frameworkInstanceBindingExpression(resolvedBindings, requestKind);
+      throw new AssertionError();
     }
 
-    private boolean shouldUseDelegateBindingExpression(ResolvedBindings resolvedBindings) {
-      if (!resolvedBindings.contributionBinding().kind().equals(DELEGATE)) {
-        return false;
-      }
-      if (useExperimentalAndroidMode(resolvedBindings.contributionBinding())) {
-        // In Android mode, we should always use the delegate binding expression.
-        return true;
-      } else {
-        // In default mode, we should only use delegate binding expressions if
-        // bindsScope <= dependencyScope.
-        return !isBindsScopeStrongerThanDependencyScope(resolvedBindings, graph);
-      }
+    /**
+     * Returns {@code true} if we can use a direct (not {@code Provider.get()}) expression for this
+     * binding. If the binding doesn't {@linkplain #needsCaching(ResolvedBindings) need to be
+     * cached}, we can.
+     *
+     * <p>In Android mode, we can use a direct expression even if the binding {@linkplain
+     * #needsCaching(ResolvedBindings) needs to be cached} as long as it's not in a
+     * reference-releasing scope.
+     */
+    private boolean canUseDirectInstanceExpression(ResolvedBindings resolvedBindings) {
+      return !needsCaching(resolvedBindings)
+          || (compilerOptions.experimentalAndroidMode()
+              && !requiresReleasableReferences(resolvedBindings));
     }
 
-    private boolean canCallSimpleMethod(ResolvedBindings resolvedBindings) {
-      Binding binding = resolvedBindings.contributionBinding();
-      if (useExperimentalAndroidMode(binding)) {
-        // In Android mode, always call simple methods.
-        return true;
-      } else {
-        // In default mode, we can call simple methods unless the binding is scoped.
-        return !binding.scope().isPresent();
+    /**
+     * Returns a binding expression for {@link RequestKind#PROVIDER} requests.
+     *
+     * <p>In default mode, {@code @Binds} bindings that don't {@linkplain
+     * #needsCaching(ResolvedBindings) need to be cached} can use a {@link
+     * DelegateBindingExpression}.
+     *
+     * <p>In Android mode, if {@linkplain #instanceBindingExpression(ResolvedBindings) instance
+     * binding expressions} don't call {@code Provider.get()} on the provider binding expression,
+     * and there's no {@linkplain #isFactorySimple(ResolvedBindings) simple factory}, then return an
+     * {@link AnonymousProviderBindingExpression} wrapped in a method.
+     *
+     * <p>Otherwise, return a {@link FrameworkInstanceBindingExpression}.
+     */
+    private BindingExpression providerBindingExpression(ResolvedBindings resolvedBindings) {
+      if (compilerOptions.experimentalAndroidMode()) {
+        if (!isFactorySimple(resolvedBindings)
+            && !(instanceBindingExpression(resolvedBindings)
+                instanceof DerivedFromProviderBindingExpression)) {
+          final AnonymousProviderBindingExpression bindingExpression =
+              new AnonymousProviderBindingExpression(
+                  resolvedBindings, componentBindingExpressions, types);
+          return wrapInMethod(resolvedBindings, RequestKind.PROVIDER, bindingExpression);
+        }
+      } else if (resolvedBindings.contributionBinding().kind().equals(DELEGATE)
+          && !needsCaching(resolvedBindings)) {
+        return new DelegateBindingExpression(
+            resolvedBindings, RequestKind.PROVIDER, componentBindingExpressions, types, elements);
       }
+      return frameworkInstanceBindingExpression(resolvedBindings, RequestKind.PROVIDER);
     }
 
-    // TODO(user): Enable releasable references in experimentalAndroidMode
-    private boolean useExperimentalAndroidMode(Binding binding) {
-      return compilerOptions.experimentalAndroidMode() && !usesReleasableReferences(binding);
+    /**
+     * Returns {@code true} if the factory created for a binding is not worth inlining because it's
+     * a singleton or an {@link dagger.internal.InstanceFactory} or a nested {@code Provider} for a
+     * component dependency provision method.
+     */
+    // TODO(dpb): Lazily create the component dependency provision method provider.
+    private boolean isFactorySimple(ResolvedBindings resolvedBindings) {
+      return staticFactoryCreation(resolvedBindings).isPresent()
+          || frameworkInstanceCreationExpression(resolvedBindings).isSimpleFactory();
+    }
+
+    /**
+     * Returns a binding expression that uses a given one as the body of a method that users call.
+     * If a component provision method matches it, it will be the method implemented. If not, a new
+     * private method will be written.
+     */
+    private BindingExpression wrapInMethod(
+        ResolvedBindings resolvedBindings,
+        RequestKind requestKind,
+        BindingExpression bindingExpression) {
+      BindingMethodImplementation methodImplementation =
+          methodImplementation(resolvedBindings, requestKind, bindingExpression);
+
+      return findMatchingComponentMethod(resolvedBindings.key(), requestKind)
+          .<BindingExpression>map(
+              componentMethod ->
+                  new ComponentMethodBindingExpression(
+                      methodImplementation,
+                      generatedComponentModel,
+                      componentMethod,
+                      componentBindingExpressions))
+          .orElseGet(
+              () ->
+                  new PrivateMethodBindingExpression(
+                      resolvedBindings,
+                      requestKind,
+                      methodImplementation,
+                      generatedComponentModel));
+    }
+
+    /** Returns the first component method associated with this request kind, if one exists. */
+    private Optional<ComponentMethodDescriptor> findMatchingComponentMethod(
+        Key key, RequestKind requestKind) {
+      return graph
+          .componentDescriptor()
+          .componentMethods()
+          .stream()
+          .filter(method -> doesComponentMethodMatch(method, key, requestKind))
+          .findFirst();
+    }
+
+    /** Returns true if the component method matches the dependency request binding key and kind. */
+    private boolean doesComponentMethodMatch(
+        ComponentMethodDescriptor componentMethod, Key key, RequestKind requestKind) {
+      return componentMethod
+          .dependencyRequest()
+          .filter(request -> request.key().equals(key))
+          .filter(request -> request.kind().equals(requestKind))
+          .isPresent();
     }
 
-    private boolean usesReleasableReferences(Binding binding) {
-      return binding.scope().isPresent()
-          && referenceReleasingManagerFields.requiresReleasableReferences(binding.scope().get());
+    private BindingMethodImplementation methodImplementation(
+        ResolvedBindings resolvedBindings,
+        RequestKind requestKind,
+        BindingExpression bindingExpression) {
+      return compilerOptions.experimentalAndroidMode()
+              && requestKind.equals(RequestKind.INSTANCE)
+              && needsCaching(resolvedBindings)
+          ? new ScopedInstanceMethodImplementation(
+              resolvedBindings, requestKind, bindingExpression, types, generatedComponentModel)
+          : new BindingMethodImplementation(
+              resolvedBindings,
+              requestKind,
+              bindingExpression,
+              generatedComponentModel.name(),
+              types);
+    }
+
+    /**
+     * Returns {@code true} if the component needs to make sure the provided value is cached.
+     *
+     * <p>The component needs to cache the value for scoped bindings except for {@code @Binds}
+     * bindings whose scope is no stronger than their delegate's.
+     */
+    private boolean needsCaching(ResolvedBindings resolvedBindings) {
+      if (!resolvedBindings.scope().isPresent()) {
+        return false;
+      }
+      if (resolvedBindings.contributionBinding().kind().equals(DELEGATE)) {
+        return isBindsScopeStrongerThanDependencyScope(resolvedBindings, graph);
+      }
+      return true;
+    }
+
+    // TODO(user): Enable releasable references in experimentalAndroidMode
+    private boolean requiresReleasableReferences(ResolvedBindings resolvedBindings) {
+      return resolvedBindings.scope().isPresent()
+          && referenceReleasingManagerFields.requiresReleasableReferences(
+              resolvedBindings.scope().get());
     }
   }
 }
diff --git a/java/dagger/internal/codegen/ComponentInstanceBindingExpression.java b/java/dagger/internal/codegen/ComponentInstanceBindingExpression.java
index 0febe94b1..552a0b2cc 100644
--- a/java/dagger/internal/codegen/ComponentInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/ComponentInstanceBindingExpression.java
@@ -18,25 +18,20 @@
 
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
-import dagger.model.RequestKind;
 
 /** A binding expression for the instance of the component itself, i.e. {@code this}. */
 final class ComponentInstanceBindingExpression extends SimpleInvocationBindingExpression {
   private final ClassName componentName;
   private final ContributionBinding binding;
 
-  ComponentInstanceBindingExpression(
-      ResolvedBindings resolvedBindings,
-      RequestKind requestKind,
-      ClassName componentName,
-      DaggerTypes types) {
-    super(resolvedBindings, requestKind, types);
+  ComponentInstanceBindingExpression(ResolvedBindings resolvedBindings, ClassName componentName) {
+    super(resolvedBindings);
     this.componentName = componentName;
     this.binding = resolvedBindings.contributionBinding();
   }
 
   @Override
-  Expression getInstanceDependencyExpression(ClassName requestingClass) {
+  Expression getDependencyExpression(ClassName requestingClass) {
     return Expression.create(
         binding.key().type(),
         componentName.equals(requestingClass)
diff --git a/java/dagger/internal/codegen/ComponentMethodBindingExpression.java b/java/dagger/internal/codegen/ComponentMethodBindingExpression.java
index d4aeb8fc3..cdd92c918 100644
--- a/java/dagger/internal/codegen/ComponentMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/ComponentMethodBindingExpression.java
@@ -22,7 +22,6 @@
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.MethodSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
-import dagger.model.RequestKind;
 
 /**
  * A binding expression that implements and uses a component method.
@@ -36,13 +35,10 @@
   private final ComponentBindingExpressions componentBindingExpressions;
 
   ComponentMethodBindingExpression(
-      ResolvedBindings resolvedBindings,
-      RequestKind requestKind,
       BindingMethodImplementation methodImplementation,
       GeneratedComponentModel generatedComponentModel,
       ComponentMethodDescriptor componentMethod,
       ComponentBindingExpressions componentBindingExpressions) {
-    super(resolvedBindings, requestKind);
     this.methodImplementation = checkNotNull(methodImplementation);
     this.generatedComponentModel = checkNotNull(generatedComponentModel);
     this.componentMethod = checkNotNull(componentMethod);
@@ -50,12 +46,12 @@
   }
 
   @Override
-  protected CodeBlock doGetComponentMethodImplementation(
+  protected CodeBlock getComponentMethodImplementation(
       ComponentMethodDescriptor componentMethod, ClassName componentName) {
     // There could be several methods on the component for the same request key and kind.
     // Only one should use the BindingMethodImplementation; the others can delegate that one. So
     // use methodImplementation.body() only if componentMethod equals the method for this instance.
-    
+
     // Separately, the method might be defined on a supertype that is also a supertype of some
     // parent component. In that case, the same ComponentMethodDescriptor will be used to add a CMBE
     // for the parent and the child. Only the parent's should use the BindingMethodImplementation;
@@ -64,7 +60,7 @@ protected CodeBlock doGetComponentMethodImplementation(
     return componentMethod.equals(this.componentMethod)
             && componentName.equals(generatedComponentModel.name())
         ? methodImplementation.body()
-        : super.doGetComponentMethodImplementation(componentMethod, componentName);
+        : super.getComponentMethodImplementation(componentMethod, componentName);
   }
 
   @Override
diff --git a/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java b/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java
index c3e53e8d8..b0a2df9c0 100644
--- a/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java
+++ b/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java
@@ -22,7 +22,6 @@
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import dagger.internal.Preconditions;
-import dagger.model.RequestKind;
 
 /** A binding expression for component provision methods. */
 final class ComponentProvisionBindingExpression extends SimpleInvocationBindingExpression {
@@ -33,12 +32,10 @@
 
   ComponentProvisionBindingExpression(
       ResolvedBindings resolvedBindings,
-      RequestKind requestKind,
       BindingGraph bindingGraph,
       ComponentRequirementFields componentRequirementFields,
-      CompilerOptions compilerOptions,
-      DaggerTypes types) {
-    super(resolvedBindings, requestKind, types);
+      CompilerOptions compilerOptions) {
+    super(resolvedBindings);
     this.binding = (ProvisionBinding) resolvedBindings.contributionBinding();
     this.bindingGraph = checkNotNull(bindingGraph);
     this.componentRequirementFields = checkNotNull(componentRequirementFields);
@@ -46,7 +43,7 @@
   }
 
   @Override
-  Expression getInstanceDependencyExpression(ClassName requestingClass) {
+  Expression getDependencyExpression(ClassName requestingClass) {
     CodeBlock invocation =
         CodeBlock.of(
             "$L.$L()",
diff --git a/java/dagger/internal/codegen/ComponentRequirementBindingExpression.java b/java/dagger/internal/codegen/ComponentRequirementBindingExpression.java
index 68abf5d4c..f00502bdc 100644
--- a/java/dagger/internal/codegen/ComponentRequirementBindingExpression.java
+++ b/java/dagger/internal/codegen/ComponentRequirementBindingExpression.java
@@ -17,7 +17,6 @@
 package dagger.internal.codegen;
 
 import com.squareup.javapoet.ClassName;
-import dagger.model.RequestKind;
 
 /**
  * A binding expression for instances bound with {@link dagger.BindsInstance} and instances of
@@ -30,17 +29,15 @@
 
   ComponentRequirementBindingExpression(
       ResolvedBindings resolvedBindings,
-      RequestKind requestKind,
       ComponentRequirement componentRequirement,
-      ComponentRequirementFields componentRequirementFields,
-      DaggerTypes types) {
-    super(resolvedBindings, requestKind, types);
+      ComponentRequirementFields componentRequirementFields) {
+    super(resolvedBindings);
     this.componentRequirement = componentRequirement;
     this.componentRequirementFields = componentRequirementFields;
   }
 
   @Override
-  Expression getInstanceDependencyExpression(ClassName requestingClass) {
+  Expression getDependencyExpression(ClassName requestingClass) {
     return Expression.create(
         componentRequirement.type(),
         componentRequirementFields.getExpression(componentRequirement, requestingClass));
diff --git a/java/dagger/internal/codegen/ComponentRequirementProviderCreationExpression.java b/java/dagger/internal/codegen/ComponentRequirementProviderCreationExpression.java
deleted file mode 100644
index c6c174641..000000000
--- a/java/dagger/internal/codegen/ComponentRequirementProviderCreationExpression.java
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-
-import com.squareup.javapoet.CodeBlock;
-import dagger.internal.InstanceFactory;
-import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
-
-/**
- * A {@link javax.inject.Provider} creation expression for a {@linkplain
- * dagger.Component#dependencies() component dependency} or an instance passed to a {@link
- * dagger.BindsInstance @BindsInstance} builder method.
- */
-final class ComponentRequirementProviderCreationExpression
-    implements FrameworkInstanceCreationExpression {
-
-  private final ContributionBinding binding;
-  private final GeneratedComponentModel generatedComponentModel;
-  private final ComponentRequirementFields componentRequirementFields;
-
-  ComponentRequirementProviderCreationExpression(
-      ContributionBinding binding,
-      GeneratedComponentModel generatedComponentModel,
-      ComponentRequirementFields componentRequirementFields) {
-    this.binding = checkNotNull(binding);
-    this.generatedComponentModel = checkNotNull(generatedComponentModel);
-    this.componentRequirementFields = checkNotNull(componentRequirementFields);
-  }
-
-  @Override
-  public CodeBlock creationExpression() {
-    return CodeBlock.of(
-        "$T.$L($L)",
-        InstanceFactory.class,
-        binding.nullableType().isPresent() ? "createNullable" : "create",
-        componentRequirementFields.getExpressionDuringInitialization(
-            componentRequirement(), generatedComponentModel.name()));
-  }
-
-  private ComponentRequirement componentRequirement() {
-    switch (binding.kind()) {
-      case COMPONENT_DEPENDENCY:
-        return ComponentRequirement.forDependency(binding.key().type());
-
-      case BOUND_INSTANCE:
-        return ComponentRequirement.forBoundInstance(binding);
-
-      default:
-        throw new IllegalArgumentException(
-            "binding must be for a bound instance or a dependency: " + binding);
-    }
-  }
-}
diff --git a/java/dagger/internal/codegen/DaggerTypes.java b/java/dagger/internal/codegen/DaggerTypes.java
index 269e32658..db483760d 100644
--- a/java/dagger/internal/codegen/DaggerTypes.java
+++ b/java/dagger/internal/codegen/DaggerTypes.java
@@ -25,6 +25,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.FluentFuture;
 import com.google.common.util.concurrent.ListenableFuture;
+import com.squareup.javapoet.ClassName;
 import java.util.List;
 import java.util.Optional;
 import javax.annotation.processing.ProcessingEnvironment;
@@ -140,6 +141,18 @@ DeclaredType rewrapType(TypeMirror type, Class<?> wrappingClass) {
     }
   }
 
+  /** Returns a {@link TypeMirror} for the binding that is accessible to the component. */
+  protected final TypeMirror accessibleType(TypeMirror type, ClassName requestingClass) {
+    if (Accessibility.isTypeAccessibleFrom(type, requestingClass.packageName())) {
+      return type;
+    } else if (type.getKind().equals(TypeKind.DECLARED)
+        && Accessibility.isRawTypeAccessible(type, requestingClass.packageName())) {
+      return getDeclaredType(MoreTypes.asTypeElement(type));
+    } else {
+      return elements.getTypeElement(Object.class.getName()).asType();
+    }
+  }
+
   /**
    * Throws {@link TypeNotPresentException} if {@code type} is an {@link
    * javax.lang.model.type.ErrorType}.
diff --git a/java/dagger/internal/codegen/DelegateBindingExpression.java b/java/dagger/internal/codegen/DelegateBindingExpression.java
index 562cfba8f..a23b685ce 100644
--- a/java/dagger/internal/codegen/DelegateBindingExpression.java
+++ b/java/dagger/internal/codegen/DelegateBindingExpression.java
@@ -32,6 +32,7 @@
 /** A {@link BindingExpression} for {@code @Binds} methods. */
 final class DelegateBindingExpression extends BindingExpression {
   private final ContributionBinding binding;
+  private final RequestKind requestKind;
   private final ComponentBindingExpressions componentBindingExpressions;
   private final DaggerTypes types;
   private final BindsTypeChecker bindsTypeChecker;
@@ -42,8 +43,8 @@
       ComponentBindingExpressions componentBindingExpressions,
       DaggerTypes types,
       Elements elements) {
-    super(resolvedBindings, requestKind);
     this.binding = checkNotNull(resolvedBindings.contributionBinding());
+    this.requestKind = checkNotNull(requestKind);
     this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
     this.types = checkNotNull(types);
     this.bindsTypeChecker = new BindsTypeChecker(types, elements);
@@ -71,17 +72,17 @@ static boolean isBindsScopeStrongerThanDependencyScope(
   Expression getDependencyExpression(ClassName requestingClass) {
     Expression delegateExpression =
         componentBindingExpressions.getDependencyExpression(
-            getOnlyElement(binding.dependencies()).key(), requestKind(), requestingClass);
+            getOnlyElement(binding.dependencies()).key(), requestKind, requestingClass);
 
     TypeMirror contributedType = binding.contributedType();
-    switch (requestKind()) {
+    switch (requestKind) {
       case INSTANCE:
         return instanceRequiresCast(delegateExpression, requestingClass)
             ? delegateExpression.castTo(contributedType)
             : delegateExpression;
       default:
         return castToRawTypeIfNecessary(
-            delegateExpression, requestType(requestKind(), contributedType, types));
+            delegateExpression, requestType(requestKind, contributedType, types));
     }
   }
 
diff --git a/java/dagger/internal/codegen/DependencyMethodProviderCreationExpression.java b/java/dagger/internal/codegen/DependencyMethodProviderCreationExpression.java
index e76400ae9..af8381590 100644
--- a/java/dagger/internal/codegen/DependencyMethodProviderCreationExpression.java
+++ b/java/dagger/internal/codegen/DependencyMethodProviderCreationExpression.java
@@ -108,6 +108,11 @@ public CodeBlock creationExpression() {
             dependency(), generatedComponentModel.name()));
   }
 
+  @Override
+  public boolean isSimpleFactory() {
+    return true;
+  }
+
   private ClassName factoryClassName() {
     String factoryName =
         ClassName.get(dependency().typeElement()).toString().replace('.', '_')
diff --git a/java/dagger/internal/codegen/DerivedFromProviderBindingExpression.java b/java/dagger/internal/codegen/DerivedFromProviderBindingExpression.java
new file mode 100644
index 000000000..2dfa992f5
--- /dev/null
+++ b/java/dagger/internal/codegen/DerivedFromProviderBindingExpression.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+import com.squareup.javapoet.ClassName;
+import dagger.model.Key;
+import dagger.model.RequestKind;
+
+/** A binding expression that depends on the expression for the {@link RequestKind#PROVIDER}. */
+final class DerivedFromProviderBindingExpression extends BindingExpression {
+
+  private final Key key;
+  private final RequestKind requestKind;
+  private final ComponentBindingExpressions componentBindingExpressions;
+  private final DaggerTypes types;
+
+  DerivedFromProviderBindingExpression(
+      ResolvedBindings resolvedBindings,
+      RequestKind requestKind,
+      ComponentBindingExpressions componentBindingExpressions,
+      DaggerTypes types) {
+    this.key = resolvedBindings.key();
+    this.requestKind = checkNotNull(requestKind);
+    this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
+    this.types = checkNotNull(types);
+  }
+
+  @Override
+  Expression getDependencyExpression(ClassName requestingClass) {
+    return FrameworkType.PROVIDER.to(
+        requestKind,
+        componentBindingExpressions.getDependencyExpression(
+            key, RequestKind.PROVIDER, requestingClass),
+        types);
+  }
+}
diff --git a/java/dagger/internal/codegen/FrameworkFieldInitializer.java b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
index ca444eac6..f5531b3b7 100644
--- a/java/dagger/internal/codegen/FrameworkFieldInitializer.java
+++ b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
@@ -57,6 +57,15 @@
     default Optional<ClassName> alternativeFrameworkClass() {
       return Optional.empty();
     }
+
+    /**
+     * Returns {@code true} if the factory created for a binding is not worth inlining because it's
+     * a singleton or an {@link dagger.internal.InstanceFactory} or a nested {@code Provider} for a
+     * component dependency provision method.
+     */
+    default boolean isSimpleFactory() {
+      return false;
+    }
   }
 
   private final GeneratedComponentModel generatedComponentModel;
diff --git a/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
index 4cb3a734c..b5016819c 100644
--- a/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
@@ -16,6 +16,7 @@
 
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
 
 import com.squareup.javapoet.ClassName;
@@ -28,6 +29,8 @@
 
 /** A binding expression that uses an instance of a {@link FrameworkType}. */
 final class FrameworkInstanceBindingExpression extends BindingExpression {
+  private final ResolvedBindings resolvedBindings;
+  private final RequestKind requestKind;
   private final ComponentBindingExpressions componentBindingExpressions;
   private final FrameworkInstanceSupplier frameworkInstanceSupplier;
   private final FrameworkType frameworkType;
@@ -42,12 +45,13 @@
       FrameworkInstanceSupplier frameworkInstanceSupplier,
       DaggerTypes types,
       Elements elements) {
-    super(resolvedBindings, requestKind);
-    this.componentBindingExpressions = componentBindingExpressions;
-    this.frameworkType = frameworkType;
-    this.frameworkInstanceSupplier = frameworkInstanceSupplier;
-    this.types = types;
-    this.elements = elements;
+    this.resolvedBindings = checkNotNull(resolvedBindings);
+    this.requestKind = checkNotNull(requestKind);
+    this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
+    this.frameworkType = checkNotNull(frameworkType);
+    this.frameworkInstanceSupplier = checkNotNull(frameworkInstanceSupplier);
+    this.types = checkNotNull(types);
+    this.elements = checkNotNull(elements);
   }
 
   /**
@@ -58,14 +62,14 @@
    */
   @Override
   Expression getDependencyExpression(ClassName requestingClass) {
-    if (requestKind().equals(frameworkRequestKind())) {
+    if (requestKind.equals(frameworkRequestKind())) {
       MemberSelect memberSelect = frameworkInstanceSupplier.memberSelect();
-      TypeMirror contributedType = resolvedBindings().contributionBinding().contributedType();
+      TypeMirror contributedType = resolvedBindings.contributionBinding().contributedType();
       TypeMirror expressionType =
           frameworkInstanceSupplier.specificType().isPresent()
                   || isTypeAccessibleFrom(contributedType, requestingClass.packageName())
                   || isInlinedFactoryCreation(memberSelect)
-              ? types.wrapType(contributedType, resolvedBindings().frameworkClass())
+              ? types.wrapType(contributedType, resolvedBindings.frameworkClass())
               : rawFrameworkType();
       return Expression.create(expressionType, memberSelect.getExpressionFor(requestingClass));
     }
@@ -75,9 +79,9 @@ Expression getDependencyExpression(ClassName requestingClass) {
     // RequestKind.PROVIDER (the framework type):
     //    lazyExpression = DoubleCheck.lazy(providerExpression);
     return frameworkType.to(
-        requestKind(),
+        requestKind,
         componentBindingExpressions.getDependencyExpression(
-            key(), frameworkRequestKind(), requestingClass),
+            resolvedBindings.key(), frameworkRequestKind(), requestingClass),
         types);
   }
 
@@ -110,6 +114,6 @@ private static boolean isInlinedFactoryCreation(MemberSelect memberSelect) {
 
   private DeclaredType rawFrameworkType() {
     return types.getDeclaredType(
-        elements.getTypeElement(resolvedBindings().frameworkClass().getCanonicalName()));
+        elements.getTypeElement(resolvedBindings.frameworkClass().getCanonicalName()));
   }
 }
diff --git a/java/dagger/internal/codegen/ImmediateFutureBindingExpression.java b/java/dagger/internal/codegen/ImmediateFutureBindingExpression.java
new file mode 100644
index 000000000..661063425
--- /dev/null
+++ b/java/dagger/internal/codegen/ImmediateFutureBindingExpression.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import dagger.model.Key;
+import dagger.model.RequestKind;
+
+final class ImmediateFutureBindingExpression extends BindingExpression {
+
+  private final ComponentBindingExpressions componentBindingExpressions;
+  private final DaggerTypes types;
+  private final Key key;
+
+  ImmediateFutureBindingExpression(
+      ResolvedBindings resolvedBindings,
+      ComponentBindingExpressions componentBindingExpressions,
+      DaggerTypes types) {
+    this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
+    this.types = checkNotNull(types);
+    this.key = resolvedBindings.key();
+  }
+
+  @Override
+  Expression getDependencyExpression(ClassName requestingClass) {
+    return Expression.create(
+        types.wrapType(key.type(), ListenableFuture.class),
+        CodeBlock.of("$T.immediateFuture($L)", Futures.class, instanceExpression(requestingClass)));
+  }
+
+  private CodeBlock instanceExpression(ClassName requestingClass) {
+    Expression expression =
+        componentBindingExpressions.getDependencyExpression(
+            key, RequestKind.INSTANCE, requestingClass);
+    // Java 7 type inference is not as strong as in Java 8, and therefore some generated code must
+    // cast.
+    //
+    // For example, javac7 cannot detect that Futures.immediateFuture(ImmutableSet.of("T"))
+    // can safely be assigned to ListenableFuture<Set<T>>.
+    if (!types.isSameType(expression.type(), key.type())) {
+      return CodeBlock.of(
+          "($T) $L", types.accessibleType(key.type(), requestingClass), expression.codeBlock());
+    }
+    return expression.codeBlock();
+  }
+}
diff --git a/java/dagger/internal/codegen/InstanceFactoryCreationExpression.java b/java/dagger/internal/codegen/InstanceFactoryCreationExpression.java
new file mode 100644
index 000000000..3aefff16a
--- /dev/null
+++ b/java/dagger/internal/codegen/InstanceFactoryCreationExpression.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+import com.squareup.javapoet.CodeBlock;
+import dagger.internal.InstanceFactory;
+import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
+import java.util.function.Supplier;
+
+/**
+ * A {@link FrameworkInstanceCreationExpression} that creates an {@link InstanceFactory} for an
+ * instance.
+ */
+final class InstanceFactoryCreationExpression implements FrameworkInstanceCreationExpression {
+
+  private final boolean nullable;
+  private final Supplier<CodeBlock> instanceExpression;
+
+  InstanceFactoryCreationExpression(Supplier<CodeBlock> instanceExpression) {
+    this(false, instanceExpression);
+  }
+
+  InstanceFactoryCreationExpression(boolean nullable, Supplier<CodeBlock> instanceExpression) {
+    this.nullable = nullable;
+    this.instanceExpression = checkNotNull(instanceExpression);
+  }
+
+  @Override
+  public CodeBlock creationExpression() {
+    return CodeBlock.of(
+        "$T.$L($L)",
+        InstanceFactory.class,
+        nullable ? "createNullable" : "create",
+        instanceExpression.get());
+  }
+
+  @Override
+  public boolean isSimpleFactory() {
+    return true;
+  }
+}
diff --git a/java/dagger/internal/codegen/MapBindingExpression.java b/java/dagger/internal/codegen/MapBindingExpression.java
index 5de5038ec..e8edefc87 100644
--- a/java/dagger/internal/codegen/MapBindingExpression.java
+++ b/java/dagger/internal/codegen/MapBindingExpression.java
@@ -30,9 +30,8 @@
 import dagger.internal.MapBuilder;
 import dagger.model.BindingKind;
 import dagger.model.DependencyRequest;
-import dagger.model.RequestKind;
 import java.util.Collections;
-import java.util.Map;
+import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 
@@ -44,20 +43,21 @@
   private final ProvisionBinding binding;
   private final ImmutableMap<DependencyRequest, ContributionBinding> dependencies;
   private final ComponentBindingExpressions componentBindingExpressions;
+  private final DaggerTypes types;
   private final Elements elements;
 
   MapBindingExpression(
       ResolvedBindings resolvedBindings,
-      RequestKind requestKind,
       BindingGraph graph,
       ComponentBindingExpressions componentBindingExpressions,
       DaggerTypes types,
       Elements elements) {
-    super(resolvedBindings, requestKind, types);
+    super(resolvedBindings);
     this.binding = (ProvisionBinding) resolvedBindings.contributionBinding();
     BindingKind bindingKind = this.binding.kind();
     checkArgument(bindingKind.equals(MULTIBOUND_MAP), bindingKind);
     this.componentBindingExpressions = componentBindingExpressions;
+    this.types = types;
     this.elements = elements;
     this.dependencies =
         Maps.toMap(
@@ -66,26 +66,24 @@
   }
 
   @Override
-  Expression getInstanceDependencyExpression(ClassName requestingClass) {
-    return Expression.create(binding.key().type(), mapExpression(requestingClass));
-  }
-
-  private CodeBlock mapExpression(ClassName requestingClass) {
+  Expression getDependencyExpression(ClassName requestingClass) {
     // TODO(ronshapiro): We should also make an ImmutableMap version of MapFactory
     boolean isImmutableMapAvailable = isImmutableMapAvailable();
     // TODO(ronshapiro, gak): Use Maps.immutableEnumMap() if it's available?
     if (isImmutableMapAvailable && dependencies.size() <= MAX_IMMUTABLE_MAP_OF_KEY_VALUE_PAIRS) {
-      return CodeBlock.builder()
-          .add("$T.", ImmutableMap.class)
-          .add(maybeTypeParameters(requestingClass))
-          .add(
-              "of($L)",
-              dependencies
-                  .keySet()
-                  .stream()
-                  .map(dependency -> keyAndValueExpression(dependency, requestingClass))
-                  .collect(toParametersCodeBlock()))
-          .build();
+      return Expression.create(
+          immutableMapType(),
+          CodeBlock.builder()
+              .add("$T.", ImmutableMap.class)
+              .add(maybeTypeParameters(requestingClass))
+              .add(
+                  "of($L)",
+                  dependencies
+                      .keySet()
+                      .stream()
+                      .map(dependency -> keyAndValueExpression(dependency, requestingClass))
+                      .collect(toParametersCodeBlock()))
+              .build());
     }
     switch (dependencies.size()) {
       case 0:
@@ -110,10 +108,20 @@ private CodeBlock mapExpression(ClassName requestingClass) {
         for (DependencyRequest dependency : dependencies.keySet()) {
           instantiation.add(".put($L)", keyAndValueExpression(dependency, requestingClass));
         }
-        return instantiation.add(".build()").build();
+        return Expression.create(
+            isImmutableMapAvailable ? immutableMapType() : binding.key().type(),
+            instantiation.add(".build()").build());
     }
   }
 
+  private DeclaredType immutableMapType() {
+    MapType mapType = MapType.from(binding.key());
+    return types.getDeclaredType(
+        elements.getTypeElement(ImmutableMap.class.getName()),
+        mapType.keyType(),
+        mapType.valueType());
+  }
+
   private CodeBlock keyAndValueExpression(DependencyRequest dependency, ClassName requestingClass) {
     return CodeBlock.of(
         "$L, $L",
@@ -123,13 +131,15 @@ private CodeBlock keyAndValueExpression(DependencyRequest dependency, ClassName
             .codeBlock());
   }
 
-  private CodeBlock collectionsStaticFactoryInvocation(
+  private Expression collectionsStaticFactoryInvocation(
       ClassName requestingClass, CodeBlock methodInvocation) {
-    return CodeBlock.builder()
-        .add("$T.", Collections.class)
-        .add(maybeTypeParameters(requestingClass))
-        .add(methodInvocation)
-        .build();
+    return Expression.create(
+        binding.key().type(),
+        CodeBlock.builder()
+            .add("$T.", Collections.class)
+            .add(maybeTypeParameters(requestingClass))
+            .add(methodInvocation)
+            .build());
   }
 
   private CodeBlock maybeTypeParameters(ClassName requestingClass) {
@@ -143,15 +153,4 @@ private CodeBlock maybeTypeParameters(ClassName requestingClass) {
   private boolean isImmutableMapAvailable() {
     return elements.getTypeElement(ImmutableMap.class.getCanonicalName()) != null;
   }
-
-  @Override
-  protected CodeBlock explicitTypeParameter(ClassName requestingClass) {
-    if (isImmutableMapAvailable()) {
-      TypeMirror keyType = binding.key().type();
-      return CodeBlock.of(
-          "<$T>",
-          isTypeAccessibleFrom(keyType, requestingClass.packageName()) ? keyType : Map.class);
-    }
-    return CodeBlock.of("");
-  }
 }
diff --git a/java/dagger/internal/codegen/MemberSelect.java b/java/dagger/internal/codegen/MemberSelect.java
index 43232d5c0..0dd9170e9 100644
--- a/java/dagger/internal/codegen/MemberSelect.java
+++ b/java/dagger/internal/codegen/MemberSelect.java
@@ -79,7 +79,7 @@ CodeBlock getExpressionFor(ClassName usingClass) {
    * this method returns the static member select that returns the factory or no-op members
    * injector.
    */
-  static Optional<MemberSelect> staticMemberSelect(ResolvedBindings resolvedBindings) {
+  static Optional<MemberSelect> staticFactoryCreation(ResolvedBindings resolvedBindings) {
     if (resolvedBindings.contributionBindings().isEmpty()) {
       throw new AssertionError(
           "Expected a contribution binding, but none found. *THIS IS A DAGGER BUG* - please "
diff --git a/java/dagger/internal/codegen/MembersInjectionBindingExpression.java b/java/dagger/internal/codegen/MembersInjectionBindingExpression.java
index faa230d6d..32992e73b 100644
--- a/java/dagger/internal/codegen/MembersInjectionBindingExpression.java
+++ b/java/dagger/internal/codegen/MembersInjectionBindingExpression.java
@@ -23,7 +23,6 @@
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.ParameterSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
-import dagger.model.RequestKind;
 import javax.lang.model.element.ExecutableElement;
 
 /**
@@ -36,8 +35,7 @@
 
   MembersInjectionBindingExpression(
       ResolvedBindings resolvedBindings, MembersInjectionMethods membersInjectionMethods) {
-    super(resolvedBindings, RequestKind.MEMBERS_INJECTION);
-    this.binding = resolvedBindings().membersInjectionBinding().get();
+    this.binding = resolvedBindings.membersInjectionBinding().get();
     this.membersInjectionMethods = membersInjectionMethods;
   }
 
@@ -50,7 +48,7 @@ Expression getDependencyExpression(ClassName requestingClass) {
   // getDependencyExpression() should never be called for members injection methods. It's probably
   // better suited as a method on MembersInjectionMethods
   @Override
-  protected CodeBlock doGetComponentMethodImplementation(
+  protected CodeBlock getComponentMethodImplementation(
       ComponentMethodDescriptor componentMethod, ClassName componentName) {
     ExecutableElement methodElement = componentMethod.methodElement();
     ParameterSpec parameter = ParameterSpec.get(getOnlyElement(methodElement.getParameters()));
diff --git a/java/dagger/internal/codegen/OptionalBindingExpression.java b/java/dagger/internal/codegen/OptionalBindingExpression.java
index a6aa38073..68941dd0f 100644
--- a/java/dagger/internal/codegen/OptionalBindingExpression.java
+++ b/java/dagger/internal/codegen/OptionalBindingExpression.java
@@ -23,7 +23,6 @@
 import com.squareup.javapoet.CodeBlock;
 import dagger.internal.codegen.OptionalType.OptionalKind;
 import dagger.model.DependencyRequest;
-import dagger.model.RequestKind;
 import javax.inject.Inject;
 import javax.lang.model.util.Types;
 
@@ -36,17 +35,16 @@
   @Inject
   OptionalBindingExpression(
       ResolvedBindings resolvedBindings,
-      RequestKind requestKind,
       ComponentBindingExpressions componentBindingExpressions,
       DaggerTypes types) {
-    super(resolvedBindings, requestKind, types);
+    super(resolvedBindings);
     this.binding = (ProvisionBinding) resolvedBindings.contributionBinding();
     this.componentBindingExpressions = componentBindingExpressions;
     this.types = types;
   }
 
   @Override
-  Expression getInstanceDependencyExpression(ClassName requestingClass) {
+  Expression getDependencyExpression(ClassName requestingClass) {
     OptionalType optionalType = OptionalType.from(binding.key());
     OptionalKind optionalKind = optionalType.kind();
     if (binding.dependencies().isEmpty()) {
@@ -78,4 +76,10 @@ Expression getInstanceDependencyExpression(ClassName requestingClass) {
             types.erasure(binding.key().type()),
             optionalKind.presentObjectExpression(dependencyExpression));
   }
+
+  @Override
+  boolean requiresMethodEncapsulation() {
+    // TODO(dpb): Maybe require it for present bindings.
+    return false;
+  }
 }
diff --git a/java/dagger/internal/codegen/PrivateMethodBindingExpression.java b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
index 224c89289..88aee7ac7 100644
--- a/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
@@ -35,6 +35,8 @@
  * <p>Dependents of this binding expression will just call the no-arg private method.
  */
 final class PrivateMethodBindingExpression extends BindingExpression {
+  private final ContributionBinding binding;
+  private final RequestKind requestKind;
   private final BindingMethodImplementation methodImplementation;
   private final GeneratedComponentModel generatedComponentModel;
   private String methodName;
@@ -44,7 +46,8 @@
       RequestKind requestKind,
       BindingMethodImplementation methodImplementation,
       GeneratedComponentModel generatedComponentModel) {
-    super(resolvedBindings, requestKind);
+    this.binding = resolvedBindings.contributionBinding();
+    this.requestKind = checkNotNull(requestKind);
     this.methodImplementation = checkNotNull(methodImplementation);
     this.generatedComponentModel = checkNotNull(generatedComponentModel);
   }
@@ -83,15 +86,14 @@ private void createMethod(String name) {
   private String methodName() {
     // TODO(user): Use a better name for @MapKey binding instances.
     // TODO(user): Include the binding method as part of the method name.
-    if (requestKind().equals(RequestKind.INSTANCE)) {
+    if (requestKind.equals(RequestKind.INSTANCE)) {
       return "get" + bindingName();
     }
-    return "get" + bindingName() + dependencyKindName(requestKind());
+    return "get" + bindingName() + dependencyKindName(requestKind);
   }
 
   /** Returns the canonical name for the {@link Binding}. */
   private String bindingName() {
-    ContributionBinding binding = resolvedBindings().contributionBinding();
     return LOWER_CAMEL.to(UPPER_CAMEL, BindingVariableNamer.name(binding));
   }
 
diff --git a/java/dagger/internal/codegen/ScopedInstanceMethodImplementation.java b/java/dagger/internal/codegen/ScopedInstanceMethodImplementation.java
new file mode 100644
index 000000000..02a872231
--- /dev/null
+++ b/java/dagger/internal/codegen/ScopedInstanceMethodImplementation.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static dagger.internal.codegen.GeneratedComponentModel.FieldSpecKind.PRIVATE_METHOD_SCOPED_FIELD;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.VOLATILE;
+
+import com.google.common.base.Supplier;
+import com.google.common.base.Suppliers;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.TypeName;
+import dagger.internal.MemoizedSentinel;
+import dagger.model.RequestKind;
+
+/** Defines a scoping method body and return type for a given instance {@link BindingExpression}. */
+final class ScopedInstanceMethodImplementation extends BindingMethodImplementation {
+
+  private final GeneratedComponentModel generatedComponentModel;
+  private final ContributionBinding binding;
+  private final Supplier<String> fieldName = Suppliers.memoize(this::createField);
+
+  ScopedInstanceMethodImplementation(
+      ResolvedBindings resolvedBindings,
+      RequestKind requestKind,
+      BindingExpression bindingExpression,
+      DaggerTypes types,
+      GeneratedComponentModel generatedComponentModel) {
+    super(resolvedBindings, requestKind, bindingExpression, generatedComponentModel.name(), types);
+    this.generatedComponentModel = generatedComponentModel;
+    this.binding = resolvedBindings.contributionBinding();
+    checkArgument(binding.scope().isPresent(), "expected binding to be scoped: %s", binding);
+  }
+
+  @Override
+  CodeBlock body() {
+    return binding.scope().get().isReusable() ? singleCheck() : doubleCheck();
+  }
+
+  private CodeBlock singleCheck() {
+    return CodeBlock.builder()
+        .beginControlFlow("if ($N instanceof $T)", fieldName.get(), MemoizedSentinel.class)
+        .addStatement("$N = $L", fieldName.get(), simpleBindingExpression())
+        .endControlFlow()
+        .addStatement("return ($T) $N", returnType(), fieldName.get())
+        .build();
+  }
+
+  private CodeBlock doubleCheck() {
+    String fieldExpression =
+        fieldName.get().equals("local") ? "this." + fieldName.get() : fieldName.get();
+    return CodeBlock.builder()
+        .addStatement("$T local = $L", TypeName.OBJECT, fieldExpression)
+        .beginControlFlow("if (local instanceof $T)", MemoizedSentinel.class)
+        .beginControlFlow("synchronized (local)")
+        // TODO(user): benchmark to see if this is really faster than instanceof check?
+        .beginControlFlow("if (local == $L)", fieldExpression)
+        .addStatement("$L = $L", fieldExpression, simpleBindingExpression())
+        .endControlFlow()
+        .addStatement("local = $L", fieldExpression)
+        .endControlFlow()
+        .endControlFlow()
+        .addStatement("return ($T) local", returnType())
+        .build();
+  }
+
+  private String createField() {
+    String name = generatedComponentModel.getUniqueFieldName(BindingVariableNamer.name(binding));
+    generatedComponentModel.addField(
+        PRIVATE_METHOD_SCOPED_FIELD,
+        FieldSpec.builder(TypeName.OBJECT, name, PRIVATE, VOLATILE)
+            .initializer("new $T()", MemoizedSentinel.class)
+            .build());
+    return name;
+  }
+}
diff --git a/java/dagger/internal/codegen/SetBindingExpression.java b/java/dagger/internal/codegen/SetBindingExpression.java
index 091f6f0fd..7833282e8 100644
--- a/java/dagger/internal/codegen/SetBindingExpression.java
+++ b/java/dagger/internal/codegen/SetBindingExpression.java
@@ -25,9 +25,8 @@
 import com.squareup.javapoet.CodeBlock;
 import dagger.internal.SetBuilder;
 import dagger.model.DependencyRequest;
-import dagger.model.RequestKind;
 import java.util.Collections;
-import java.util.Set;
+import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 
@@ -36,43 +35,42 @@
   private final ProvisionBinding binding;
   private final BindingGraph graph;
   private final ComponentBindingExpressions componentBindingExpressions;
+  private final DaggerTypes types;
   private final Elements elements;
 
   SetBindingExpression(
       ResolvedBindings resolvedBindings,
-      RequestKind requestKind,
       BindingGraph graph,
       ComponentBindingExpressions componentBindingExpressions,
       DaggerTypes types,
       Elements elements) {
-    super(resolvedBindings, requestKind, types);
+    super(resolvedBindings);
     this.binding = (ProvisionBinding) resolvedBindings.contributionBinding();
     this.graph = graph;
     this.componentBindingExpressions = componentBindingExpressions;
+    this.types = types;
     this.elements = elements;
   }
 
   @Override
-  Expression getInstanceDependencyExpression(ClassName requestingClass) {
-    return Expression.create(binding.key().type(), setExpression(requestingClass));
-  }
-
-  private CodeBlock setExpression(ClassName requestingClass) {
+  Expression getDependencyExpression(ClassName requestingClass) {
     // TODO(ronshapiro): We should also make an ImmutableSet version of SetFactory
     boolean isImmutableSetAvailable = isImmutableSetAvailable();
     // TODO(ronshapiro, gak): Use Sets.immutableEnumSet() if it's available?
     if (isImmutableSetAvailable && binding.dependencies().stream().allMatch(this::isSingleValue)) {
-      return CodeBlock.builder()
-          .add("$T.", ImmutableSet.class)
-          .add(maybeTypeParameter(requestingClass))
-          .add(
-              "of($L)",
-              binding
-                  .dependencies()
-                  .stream()
-                  .map(dependency -> getContributionExpression(dependency, requestingClass))
-                  .collect(toParametersCodeBlock()))
-          .build();
+      return Expression.create(
+          immutableSetType(),
+          CodeBlock.builder()
+              .add("$T.", ImmutableSet.class)
+              .add(maybeTypeParameter(requestingClass))
+              .add(
+                  "of($L)",
+                  binding
+                      .dependencies()
+                      .stream()
+                      .map(dependency -> getContributionExpression(dependency, requestingClass))
+                      .collect(toParametersCodeBlock()))
+              .build());
     }
     switch (binding.dependencies().size()) {
       case 0:
@@ -85,11 +83,13 @@ private CodeBlock setExpression(ClassName requestingClass) {
             return collectionsStaticFactoryInvocation(
                 requestingClass, CodeBlock.of("singleton($L)", contributionExpression));
           } else if (isImmutableSetAvailable) {
-            return CodeBlock.builder()
-                .add("$T.", ImmutableSet.class)
-                .add(maybeTypeParameter(requestingClass))
-                .add("copyOf($L)", contributionExpression)
-                .build();
+            return Expression.create(
+                immutableSetType(),
+                CodeBlock.builder()
+                    .add("$T.", ImmutableSet.class)
+                    .add(maybeTypeParameter(requestingClass))
+                    .add("copyOf($L)", contributionExpression)
+                    .build());
           }
         }
         // fall through
@@ -108,10 +108,19 @@ private CodeBlock setExpression(ClassName requestingClass) {
           instantiation.add(
               ".$L($L)", builderMethod, getContributionExpression(dependency, requestingClass));
         }
-        return instantiation.add(".build()").build();
+        instantiation.add(".build()");
+        return Expression.create(
+            isImmutableSetAvailable ? immutableSetType() : binding.key().type(),
+            instantiation.build());
     }
   }
 
+  private DeclaredType immutableSetType() {
+    return types.getDeclaredType(
+        elements.getTypeElement(ImmutableSet.class.getName()),
+        SetType.from(binding.key()).elementType());
+  }
+
   private CodeBlock getContributionExpression(
       DependencyRequest dependency, ClassName requestingClass) {
     return componentBindingExpressions
@@ -119,13 +128,15 @@ private CodeBlock getContributionExpression(
         .codeBlock();
   }
 
-  private CodeBlock collectionsStaticFactoryInvocation(
+  private Expression collectionsStaticFactoryInvocation(
       ClassName requestingClass, CodeBlock methodInvocation) {
-    return CodeBlock.builder()
-        .add("$T.", Collections.class)
-        .add(maybeTypeParameter(requestingClass))
-        .add(methodInvocation)
-        .build();
+    return Expression.create(
+        binding.key().type(),
+        CodeBlock.builder()
+            .add("$T.", Collections.class)
+            .add(maybeTypeParameter(requestingClass))
+            .add(methodInvocation)
+            .build());
   }
 
   private CodeBlock maybeTypeParameter(ClassName requestingClass) {
@@ -147,15 +158,4 @@ private boolean isSingleValue(DependencyRequest dependency) {
   private boolean isImmutableSetAvailable() {
     return elements.getTypeElement(ImmutableSet.class.getCanonicalName()) != null;
   }
-
-  @Override
-  protected CodeBlock explicitTypeParameter(ClassName requestingClass) {
-    if (isImmutableSetAvailable()) {
-      TypeMirror keyType = binding.key().type();
-      return CodeBlock.of(
-          "<$T>",
-          isTypeAccessibleFrom(keyType, requestingClass.packageName()) ? keyType : Set.class);
-    }
-    return CodeBlock.of("");
-  }
 }
diff --git a/java/dagger/internal/codegen/SimpleInvocationBindingExpression.java b/java/dagger/internal/codegen/SimpleInvocationBindingExpression.java
index d2f692b68..909d7ae84 100644
--- a/java/dagger/internal/codegen/SimpleInvocationBindingExpression.java
+++ b/java/dagger/internal/codegen/SimpleInvocationBindingExpression.java
@@ -16,67 +16,19 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.collect.ImmutableSet;
-import com.google.common.util.concurrent.Futures;
-import com.google.common.util.concurrent.ListenableFuture;
-import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.CodeBlock;
-import dagger.model.RequestKind;
-
-/**
- * A binding expression that can use a simple expression for instance requests, and delegates to
- * another expression for other requests.
- */
+/** A simple binding expression for instance requests. Does not scope. */
 abstract class SimpleInvocationBindingExpression extends BindingExpression {
+  // TODO(dpb): Take ContributionBinding instead of ResolvedBindings.
+  private final ResolvedBindings resolvedBindings;
 
-  private static final ImmutableSet<RequestKind> REQUEST_KINDS =
-      ImmutableSet.of(RequestKind.INSTANCE, RequestKind.FUTURE);
-
-  private final DaggerTypes types;
-
-  SimpleInvocationBindingExpression(
-      ResolvedBindings resolvedBindings, RequestKind requestKind, DaggerTypes types) {
-    super(resolvedBindings, requestKind);
-    checkArgument(REQUEST_KINDS.contains(requestKind));
-    this.types = types;
-  }
-
-  /**
-   * Returns an expression that evaluates to an instance of a dependency.
-   *
-   * @param requestingClass the class that will contain the expression
-   */
-  abstract Expression getInstanceDependencyExpression(ClassName requestingClass);
-
-  /**
-   * Java 7 type inference is not as strong as in Java 8, and therefore some generated code must
-   * make type parameters for {@link Futures#immediateFuture(Object)} explicit.
-   *
-   * <p>For example, {@code javac7} cannot detect that Futures.immediateFuture(ImmutableSet.of(T))}
-   * can safely be assigned to {@code ListenableFuture<Set<T>>}.
-   */
-  protected CodeBlock explicitTypeParameter(ClassName requestingClass) {
-    return CodeBlock.of("");
+  SimpleInvocationBindingExpression(ResolvedBindings resolvedBindings) {
+    this.resolvedBindings = checkNotNull(resolvedBindings);
   }
 
   @Override
-  final Expression getDependencyExpression(ClassName requestingClass) {
-    switch (requestKind()) {
-      case INSTANCE:
-        return getInstanceDependencyExpression(requestingClass);
-      case FUTURE:
-        Expression expression = getInstanceDependencyExpression(requestingClass);
-        return Expression.create(
-            types.wrapType(expression.type(), ListenableFuture.class),
-            CodeBlock.builder()
-                .add("$T.", Futures.class)
-                .add(explicitTypeParameter(requestingClass))
-                .add("immediateFuture($L)", expression.codeBlock())
-                .build());
-      default:
-        throw new AssertionError(requestKind());
-    }
+  boolean requiresMethodEncapsulation() {
+    return !resolvedBindings.contributionBinding().dependencies().isEmpty();
   }
 }
diff --git a/java/dagger/internal/codegen/SimpleMethodBindingExpression.java b/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
index 69734437d..6809643ae 100644
--- a/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
@@ -30,7 +30,6 @@
 import com.squareup.javapoet.TypeName;
 import dagger.internal.codegen.InjectionMethods.ProvisionMethod;
 import dagger.model.DependencyRequest;
-import dagger.model.RequestKind;
 import java.util.Optional;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
@@ -39,8 +38,8 @@
 import javax.lang.model.util.Elements;
 
 /**
- * A binding expression that invokes methods or constructors directly for a provision binding when
- * possible.
+ * A binding expression that invokes methods or constructors directly (without attempting to scope)
+ * {@link dagger.model.RequestKind#INSTANCE} requests.
  */
 final class SimpleMethodBindingExpression extends SimpleInvocationBindingExpression {
   private final CompilerOptions compilerOptions;
@@ -52,14 +51,12 @@
 
   SimpleMethodBindingExpression(
       ResolvedBindings resolvedBindings,
-      RequestKind requestKind,
       CompilerOptions compilerOptions,
       ComponentBindingExpressions componentBindingExpressions,
       MembersInjectionMethods membersInjectionMethods,
       ComponentRequirementFields componentRequirementFields,
-      DaggerTypes types,
       Elements elements) {
-    super(resolvedBindings, requestKind, types);
+    super(resolvedBindings);
     this.compilerOptions = compilerOptions;
     this.provisionBinding = (ProvisionBinding) resolvedBindings.contributionBinding();
     checkArgument(
@@ -73,7 +70,7 @@
   }
 
   @Override
-  Expression getInstanceDependencyExpression(ClassName requestingClass) {
+  Expression getDependencyExpression(ClassName requestingClass) {
     return requiresInjectionMethod(provisionBinding, compilerOptions, requestingClass.packageName())
         ? invokeInjectionMethod(requestingClass)
         : invokeMethod(requestingClass);
diff --git a/java/dagger/internal/codegen/SubcomponentBuilderBindingExpression.java b/java/dagger/internal/codegen/SubcomponentBuilderBindingExpression.java
index 9df3502d6..08b618051 100644
--- a/java/dagger/internal/codegen/SubcomponentBuilderBindingExpression.java
+++ b/java/dagger/internal/codegen/SubcomponentBuilderBindingExpression.java
@@ -18,7 +18,6 @@
 
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
-import dagger.model.RequestKind;
 
 /** A binding expression for a subcomponent builder that just invokes the constructor. */
 final class SubcomponentBuilderBindingExpression extends SimpleInvocationBindingExpression {
@@ -26,17 +25,14 @@
   private final ContributionBinding binding;
 
   SubcomponentBuilderBindingExpression(
-      ResolvedBindings resolvedBindings,
-      RequestKind requestKind,
-      String subcomponentBuilderName,
-      DaggerTypes types) {
-    super(resolvedBindings, requestKind, types);
+      ResolvedBindings resolvedBindings, String subcomponentBuilderName) {
+    super(resolvedBindings);
     this.subcomponentBuilderName = subcomponentBuilderName;
     this.binding = resolvedBindings.contributionBinding();
   }
 
   @Override
-  Expression getInstanceDependencyExpression(ClassName requestingClass) {
+  Expression getDependencyExpression(ClassName requestingClass) {
     return Expression.create(
         binding.key().type(), CodeBlock.of("new $LBuilder()", subcomponentBuilderName));
   }
diff --git a/javatests/dagger/internal/codegen/ComponentProcessorTest.java b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
index 3f5674e89..fdb8b44c8 100644
--- a/javatests/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
@@ -307,7 +307,7 @@ public void componentWithInvalidModule() {
                 "",
                 "  @Override",
                 "  public Lazy<SomeInjectableType> lazySomeInjectableType() {",
-                "    return DoubleCheck.lazy(someInjectableTypeProvider());",
+                "    return DoubleCheck.lazy(SomeInjectableType_Factory.create());",
                 "  }",
                 "",
                 "  @Override",
@@ -398,18 +398,20 @@ public void componentWithInvalidModule() {
                 "    }",
                 "    return (SomeInjectableType) local;")
             .addLinesIn(
-                DEFAULT_MODE,
-                // TODO(ronshapiro): It's a little weird that the component method is used instead
-                // of the instance. This only really happens because the same key is scoped and
-                // exposed as a component method for both an instance and a Provider, so probably
-                // not so common. Are there any other cases where this might come up?
-                "    return someInjectableTypeProvider().get();")
+                DEFAULT_MODE, //
+                "    return someInjectableTypeProvider.get();")
             .addLines(
                 "  }",
                 "",
                 "  @Override",
-                "  public Lazy<SomeInjectableType> lazySomeInjectableType() {",
-                "    return DoubleCheck.lazy(someInjectableTypeProvider());",
+                "  public Lazy<SomeInjectableType> lazySomeInjectableType() {")
+            .addLinesIn(
+                DEFAULT_MODE, //
+                "    return DoubleCheck.lazy(someInjectableTypeProvider);")
+            .addLinesIn(
+                EXPERIMENTAL_ANDROID_MODE,
+                "    return DoubleCheck.lazy(someInjectableTypeProvider());")
+            .addLines(
                 "  }",
                 "",
                 "  @Override",
@@ -482,7 +484,7 @@ public void componentWithInvalidModule() {
                 "",
                 "  @CanIgnoreReturnValue",
                 "  private OuterType.B injectB(OuterType.B instance) {",
-                "    OuterType_B_MembersInjector.injectA(instance, a());",
+                "    OuterType_B_MembersInjector.injectA(instance, new OuterType.A());",
                 "    return instance;",
                 "  }",
                 "}")
@@ -1113,7 +1115,7 @@ public void testDefaultPackage() {
             "",
             "  @SuppressWarnings(\"unchecked\")",
             "  private void initialize(final Builder builder) {",
-            "    this.simpleComponentProvider = InstanceFactory.<SimpleComponent>create(this);",
+            "    this.simpleComponentProvider = InstanceFactory.create((SimpleComponent) this);",
             "  }",
             "",
             "  @Override",
@@ -1558,7 +1560,7 @@ public void testDefaultPackage() {
                 GENERATED_ANNOTATION,
                 "public final class DaggerTestComponent implements TestComponent {",
                 "  private B getB() {",
-                "    return new B(c());",
+                "    return new B(new C());",
                 "  }",
                 "",
                 "  @Override",
@@ -1573,7 +1575,7 @@ public void testDefaultPackage() {
                 "",
                 "  @Override",
                 "  public X x() {",
-                "    return new X(c());",
+                "    return new X(new C());",
                 "  }",
                 "}")
             .build();
@@ -2488,7 +2490,8 @@ public void nullIncorrectlyReturnedFromNonNullableInlinedProvider() {
                 "",
                 "  @CanIgnoreReturnValue",
                 "  private InjectsMember injectInjectsMember(InjectsMember instance) {",
-                "    InjectsMember_MembersInjector.injectMember(instance, nonNullableString());",
+                "    InjectsMember_MembersInjector.injectMember(instance,",
+                "        TestModule_NonNullableStringFactory.proxyNonNullableString());",
                 "    return instance;",
                 "  }",
                 "}")
@@ -2578,7 +2581,8 @@ public void nullCheckingIgnoredWhenProviderReturnsPrimitive() {
                 "",
                 "  @CanIgnoreReturnValue",
                 "  private InjectsMember injectInjectsMember(InjectsMember instance) {",
-                "    InjectsMember_MembersInjector.injectMember(instance, nonNullableInteger());",
+                "    InjectsMember_MembersInjector.injectMember(",
+                "        instance, TestModule.primitiveInteger());",
                 "    return instance;",
                 "  }",
                 "}")
diff --git a/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java b/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java
index 4ba6f0d65..cdd0cfbdf 100644
--- a/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java
+++ b/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java
@@ -770,7 +770,7 @@ public void doubleBinds() {
                 "  }",
                 "  @Override",
                 "  public Provider<Object> object() {",
-                "    return (Provider) charSequence();",
+                "    return (Provider) TestModule_ProvideStringFactory.create();",
                 "  }",
                 "}"));
   }
diff --git a/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java b/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java
index 3537bcda7..0d0e050fa 100644
--- a/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java
+++ b/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java
@@ -380,8 +380,8 @@ public void productionComponents() {
             "public final class DaggerTestComponent implements TestComponent {",
             "  @Override",
             "  public ListenableFuture<Map<String, String>> stringMap() {",
-            "    return Futures.<Map<String, String>>immediateFuture(",
-            "        ImmutableMap.<String, String>of());",
+            "    return Futures.immediateFuture(",
+            "        (Map<String, String>) ImmutableMap.<String, String>of());",
             "  }",
             "}");
     Compilation compilation =
diff --git a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
index e3e3d35cc..ed8101f03 100644
--- a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -326,22 +326,18 @@ public void simpleComponent() {
                 "    };",
                 "  }",
                 "",
-                "  private Producer<TestClass.B> getBProducer() {",
-                "    return bProducer;",
-                "  }",
-                "",
                 "  @SuppressWarnings(\"unchecked\")",
                 "  private void initialize(final Builder builder) {",
                 "    this.bModule = builder.bModule;",
                 "    this.simpleComponentProvider =",
-                "        InstanceFactory.<TestClass.SimpleComponent>create(this);",
+                "        InstanceFactory.create((TestClass.SimpleComponent) this);",
                 "    this.bProducer = Producers.producerFromProvider(getBProvider());",
                 "    this.aProducer =",
                 "        new TestClass_AModule_AFactory(",
                 "            builder.aModule,",
                 "            getProductionImplementationExecutorProvider(),",
                 "            getProductionComponentMonitorProvider(),",
-                "            getBProducer());",
+                "            bProducer);",
                 "  }",
                 "",
                 "  @Override",
@@ -438,7 +434,7 @@ public void simpleComponent() {
                 "            TestClass_SimpleComponent_ProductionExecutorModule_ExecutorFactory",
                 "                .create(executorProvider));",
                 "    this.simpleComponentProvider = ",
-                "        InstanceFactory.<TestClass.SimpleComponent>create(this);",
+                "        InstanceFactory.create((TestClass.SimpleComponent) this);",
                 "    this.monitorProvider =",
                 "        DoubleCheck.provider(",
                 "            TestClass_SimpleComponent_MonitoringModule_MonitorFactory.create(",
diff --git a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
index f94859984..d321f48bd 100644
--- a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
+++ b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
@@ -349,11 +349,14 @@ public void productionComponents() {
             "    return new Builder().build();",
             "  }",
             "",
+            "  private Set<String> getSetOfString() {",
+            "    return ImmutableSet.<String>copyOf(",
+            "        EmptySetModule_EmptySetFactory.proxyEmptySet());",
+            "  }",
+            "",
             "  @Override",
             "  public ListenableFuture<Set<String>> strings() {",
-            "    return Futures.<Set<String>>immediateFuture(",
-
-            "        ImmutableSet.<String>copyOf(EmptySetModule_EmptySetFactory.proxyEmptySet());",
+            "    return Futures.immediateFuture(getSetOfString());",
             "  }",
             "",
             "  public static final class Builder {",
diff --git a/javatests/dagger/internal/codegen/SubcomponentBuilderRequestFulfillmentTest.java b/javatests/dagger/internal/codegen/SubcomponentBuilderRequestFulfillmentTest.java
index f33eaa967..d391622b8 100644
--- a/javatests/dagger/internal/codegen/SubcomponentBuilderRequestFulfillmentTest.java
+++ b/javatests/dagger/internal/codegen/SubcomponentBuilderRequestFulfillmentTest.java
@@ -108,8 +108,7 @@ public void testInlinedSubcomponentBuilders_componentMethod() {
             "",
             "  @Override",
             "  public UsesSubcomponent usesSubcomponent() {",
-            // TODO(ronshapiro): Should component methods not be used when deps == 0?
-            "    return new UsesSubcomponent(sBuilder());",
+            "    return new UsesSubcomponent(new SubBuilder());",
             "  }",
             "",
             "  public static final class Builder {",
diff --git a/javatests/dagger/internal/codegen/SubcomponentValidationTest.java b/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
index 8beb5ea74..a8b36be32 100644
--- a/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
+++ b/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
@@ -472,17 +472,31 @@ public void delegateFactoryNotCreatedForSubcomponentWhenProviderExistsInParent()
                 "    private ChildComponentImpl() {",
                 "      this.childModule = new ChildModule();",
                 "    }",
-                "",
+                "")
+            .addLinesIn(
+                DEFAULT_MODE,
+                "    private NeedsDep1 getNeedsDep1() {",
+                "      return new NeedsDep1(DaggerParentComponent.this.dep1Provider.get());",
+                "    }")
+            .addLinesIn(
+                EXPERIMENTAL_ANDROID_MODE,
                 "    private NeedsDep1 getNeedsDep1() {",
                 "      return new NeedsDep1(DaggerParentComponent.this.getDep1());",
-                "    }",
-                "",
+                "    }")
+            .addLines(
                 "    private A getA() {",
                 "      return injectA(",
                 "          A_Factory.newA(",
-                "              getNeedsDep1(),",
+                "              getNeedsDep1(),")
+            .addLinesIn(
+                DEFAULT_MODE,
+                "              DaggerParentComponent.this.dep1Provider.get(),",
+                "              DaggerParentComponent.this.dep2Provider.get()));")
+            .addLinesIn(
+                EXPERIMENTAL_ANDROID_MODE,
                 "              DaggerParentComponent.this.getDep1(),",
-                "              DaggerParentComponent.this.getDep2()));",
+                "              DaggerParentComponent.this.getDep2()));")
+            .addLines(
                 "    }",
                 "",
                 "    @Override",
