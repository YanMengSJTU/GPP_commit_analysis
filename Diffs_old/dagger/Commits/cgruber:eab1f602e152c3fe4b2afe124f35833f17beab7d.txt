diff --git a/compiler/src/it/functional-tests/src/main/java/test/PrimitivesModule.java b/compiler/src/it/functional-tests/src/main/java/test/PrimitivesModule.java
index 907287dd3..acbf271df 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/PrimitivesModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/PrimitivesModule.java
@@ -27,67 +27,67 @@
   static final float[] BOUND_FLOAT_ARRAY = {(float) 0.1, (float) 0.01, (float) 0.001};
   static final double[] BOUND_DOUBLE_ARRAY = {0.2, 0.02, 0.002};
 
-  @Provides byte provideByte() {
+  @Provides static byte provideByte() {
     return BOUND_BYTE;
   }
 
-  @Provides char provideChar() {
+  @Provides static char provideChar() {
     return BOUND_CHAR;
   }
 
-  @Provides short provideShort() {
+  @Provides static short provideShort() {
     return BOUND_SHORT;
   }
 
-  @Provides int provideInt() {
+  @Provides static int provideInt() {
     return BOUND_INT;
   }
 
-  @Provides long provideLong() {
+  @Provides static long provideLong() {
     return BOUND_LONG;
   }
 
-  @Provides boolean provideBoolean() {
+  @Provides static boolean provideBoolean() {
     return BOUND_BOOLEAN;
   }
 
-  @Provides float provideFloat() {
+  @Provides static float provideFloat() {
     return BOUND_FLOAT;
   }
 
-  @Provides double boundDouble() {
+  @Provides static double boundDouble() {
     return BOUND_DOUBLE;
   }
 
-  @Provides byte[] provideByteArray() {
+  @Provides static byte[] provideByteArray() {
     return BOUND_BYTE_ARRAY;
   }
 
-  @Provides char[] provideCharArray() {
+  @Provides static char[] provideCharArray() {
     return BOUND_CHAR_ARRAY;
   }
 
-  @Provides short[] provideShortArray() {
+  @Provides static short[] provideShortArray() {
     return BOUND_SHORT_ARRAY;
   }
 
-  @Provides int[] provideIntArray() {
+  @Provides static int[] provideIntArray() {
     return BOUND_INT_ARRAY;
   }
 
-  @Provides long[] provideLongArray() {
+  @Provides static long[] provideLongArray() {
     return BOUND_LONG_ARRAY;
   }
 
-  @Provides boolean[] provideBooleanArray() {
+  @Provides static boolean[] provideBooleanArray() {
     return BOUND_BOOLEAN_ARRAY;
   }
 
-  @Provides float[] provideFloatArray() {
+  @Provides static float[] provideFloatArray() {
     return BOUND_FLOAT_ARRAY;
   }
 
-  @Provides double[] boundDoubleArray() {
+  @Provides static double[] boundDoubleArray() {
     return BOUND_DOUBLE_ARRAY;
   }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/staticprovides/AllStaticModule.java b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/AllStaticModule.java
new file mode 100644
index 000000000..9c6953a41
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/AllStaticModule.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.staticprovides;
+
+import static dagger.Provides.Type.SET;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+final class AllStaticModule {
+  @Provides(type = SET) static String contributeString() {
+    return AllStaticModule.class + ".contributeString";
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/staticprovides/SomeStaticModule.java b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/SomeStaticModule.java
new file mode 100644
index 000000000..53ee14d95
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/SomeStaticModule.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.staticprovides;
+
+import static dagger.Provides.Type.SET;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+final class SomeStaticModule {
+  @Provides(type = SET) static String contributeStringFromAStaticMethod() {
+    return SomeStaticModule.class + ".contributeStringFromAStaticMethod";
+  }
+
+  @Provides(type = SET) String contributeStringFromAnInstanceMethod() {
+    return SomeStaticModule.class + ".contributeStringFromAnInstanceMethod";
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponent.java b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponent.java
new file mode 100644
index 000000000..9d3a94588
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponent.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.staticprovides;
+
+import dagger.Component;
+
+import java.util.Set;
+
+/**
+ * A simple component that demonstrates both static an non-static provides methods.
+ */
+@Component(modules = {AllStaticModule.class, SomeStaticModule.class})
+interface StaticTestComponent {
+  Set<String> getMultiboundStrings();
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/staticprovides/StaticProvidesTest.java b/compiler/src/it/functional-tests/src/test/java/test/staticprovides/StaticProvidesTest.java
new file mode 100644
index 000000000..53185f8fc
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/staticprovides/StaticProvidesTest.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.staticprovides;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.common.collect.ImmutableSet;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class StaticProvidesTest {
+  private final StaticTestComponent component = DaggerStaticTestComponent.create();
+
+  @Test public void setMultibinding() {
+    assertThat(component.getMultiboundStrings()).isEqualTo(ImmutableSet.of(
+        AllStaticModule.class + ".contributeString",
+        SomeStaticModule.class + ".contributeStringFromAStaticMethod",
+        SomeStaticModule.class + ".contributeStringFromAnInstanceMethod"));
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 62fd4f46d..d3a85b498 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -114,6 +114,7 @@
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
+import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.VOID;
 
 /**
@@ -862,8 +863,8 @@ private void writeInterfaceMethods(BindingGraph input, ClassWriter componentWrit
               break;
             case INSTANCE:
               if (enumBindingKeys.contains(bindingKey)
-                  && !MoreTypes.asDeclared(bindingKey.key().type())
-                          .getTypeArguments().isEmpty()) {
+                  && (bindingKey.key().type().getKind().equals(DECLARED)
+                      && !((DeclaredType) bindingKey.key().type()).getTypeArguments().isEmpty())) {
                 // If using a parameterized enum type, then we need to store the factory
                 // in a temporary variable, in order to help javac be able to infer
                 // the generics of the Factory.create methods.
@@ -1215,7 +1216,8 @@ private Snippet initializeFactoryForProvisionBinding(ProvisionBinding binding,
       case PROVISION:
         List<Snippet> parameters =
             Lists.newArrayListWithCapacity(binding.dependencies().size() + 1);
-        if (binding.bindingKind().equals(PROVISION)) {
+        if (binding.bindingKind().equals(PROVISION)
+            && !binding.bindingElement().getModifiers().contains(STATIC)) {
           parameters.add(contributionFields.get(binding.contributedBy().get())
               .getSnippetFor(componentName));
         }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index a55dce46d..5e5e57478 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -118,8 +118,6 @@
 
   static final String BINDING_METHOD_ABSTRACT = "@%s methods cannot be abstract";
 
-  static final String BINDING_METHOD_STATIC = "@%s methods cannot be static";
-
   static final String BINDING_METHOD_PRIVATE = "@%s methods cannot be private";
 
   static final String BINDING_METHOD_TYPE_PARAMETER =
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 28987e1d0..75ff023e8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -61,6 +61,7 @@
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
 
 /**
  * Generates {@link Factory} implementations from {@link ProvisionBinding} instances for
@@ -132,7 +133,8 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
         constructorWriter = Optional.of(classWriter.addConstructor());
         constructorWriter.get().addModifiers(PUBLIC);
         factoryWriter = classWriter;
-        if (binding.bindingKind().equals(PROVISION)) {
+        if (binding.bindingKind().equals(PROVISION)
+            && !binding.bindingElement().getModifiers().contains(STATIC)) {
           TypeName enclosingType = TypeNames.forTypeMirror(binding.bindingTypeElement().asType());
           factoryWriter.addField(enclosingType, "module").addModifiers(PRIVATE, FINAL);
           constructorWriter.get().addParameter(enclosingType, "module");
@@ -227,32 +229,34 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     Snippet parametersSnippet = makeParametersSnippet(parameters);
 
     if (binding.bindingKind().equals(PROVISION)) {
+      Snippet providesMethodInvocation = Snippet.format("%s.%s(%s)",
+          binding.bindingElement().getModifiers().contains(STATIC)
+              ? ClassName.fromTypeElement(binding.bindingTypeElement())
+              : "module",
+          binding.bindingElement().getSimpleName(),
+          parametersSnippet);
+
       if (binding.provisionType().equals(SET)) {
-        getMethodWriter.body().addSnippet("return %s.singleton(module.%s(%s));",
-            ClassName.fromClass(Collections.class),
-            binding.bindingElement().getSimpleName(),
-            parametersSnippet);
+        getMethodWriter.body().addSnippet("return %s.singleton(%s);",
+            ClassName.fromClass(Collections.class), providesMethodInvocation);
       } else if (binding.nullableType().isPresent()
           || nullableValidationType.equals(Diagnostic.Kind.WARNING)) {
         if (binding.nullableType().isPresent()) {
           getMethodWriter.annotate(
               (ClassName) TypeNames.forTypeMirror(binding.nullableType().get()));
         }
-        getMethodWriter.body().addSnippet("return module.%s(%s);",
-            binding.bindingElement().getSimpleName(),
-            parametersSnippet);
+        getMethodWriter.body().addSnippet("return %s;", providesMethodInvocation);
       } else {
         StringLiteral failMsg =
             StringLiteral.forValue(CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
         getMethodWriter.body().addSnippet(Snippet.format(Joiner.on('\n').join(
-            "%s provided = module.%s(%s);",
+            "%s provided = %s;",
             "if (provided == null) {",
             "  throw new NullPointerException(%s);",
             "}",
             "return provided;"),
             getMethodWriter.returnType(),
-            binding.bindingElement().getSimpleName(),
-            parametersSnippet,
+            providesMethodInvocation,
             failMsg));
       }
     } else if (binding.memberInjectionRequest().isPresent()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
index d9cd793b4..cf4b43ec7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
@@ -42,7 +42,6 @@
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_MAP_HAS_MAP_KEY;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_STATIC;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_MULTIPLE_MAP_KEY;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_NO_MAP_KEY;
@@ -51,7 +50,6 @@
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.STATIC;
 import static javax.lang.model.type.TypeKind.ARRAY;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.VOID;
@@ -97,10 +95,6 @@ private TypeElement getSetElement() {
     if (modifiers.contains(PRIVATE)) {
       builder.addItem(formatErrorMessage(BINDING_METHOD_PRIVATE), producesMethodElement);
     }
-    if (modifiers.contains(STATIC)) {
-      // TODO(gak): why not?
-      builder.addItem(formatErrorMessage(BINDING_METHOD_STATIC), producesMethodElement);
-    }
     if (modifiers.contains(ABSTRACT)) {
       builder.addItem(formatErrorMessage(BINDING_METHOD_ABSTRACT), producesMethodElement);
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
index 32bf8d0a0..535c5fa26 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
@@ -40,7 +40,6 @@
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_MAP_HAS_MAP_KEY;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_STATIC;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_MULTIPLE_MAP_KEY;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_NO_MAP_KEY;
@@ -96,10 +95,6 @@ private TypeElement getSetElement() {
       builder.addItem(formatErrorMessage(BINDING_METHOD_PRIVATE),
           providesMethodElement);
     }
-    if (modifiers.contains(STATIC)) {
-      // TODO(gak): why not?
-      builder.addItem(formatErrorMessage(BINDING_METHOD_STATIC), providesMethodElement);
-    }
     if (modifiers.contains(ABSTRACT)) {
       builder.addItem(formatErrorMessage(BINDING_METHOD_ABSTRACT), providesMethodElement);
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 1d660a9e4..89383a292 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -45,11 +45,13 @@
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
 import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
 import static dagger.internal.codegen.ProvisionBinding.Kind.INJECTION;
+import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.Util.unwrapOptionalEquivalence;
 import static dagger.internal.codegen.Util.wrapOptionalInEquivalence;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.ElementKind.FIELD;
 import static javax.lang.model.element.ElementKind.METHOD;
+import static javax.lang.model.element.Modifier.STATIC;
 
 /**
  * A value object representing the mechanism by which a {@link Key} can be provided. New instances
@@ -139,10 +141,15 @@ boolean isSyntheticBinding() {
   }
 
   FactoryCreationStrategy factoryCreationStrategy() {
-    return (bindingKind().equals(INJECTION)
-          && implicitDependencies().isEmpty())
-          ? FactoryCreationStrategy.ENUM_INSTANCE
-          : FactoryCreationStrategy.CLASS_CONSTRUCTOR;
+    if (bindingKind().equals(INJECTION) && implicitDependencies().isEmpty()) {
+      return FactoryCreationStrategy.ENUM_INSTANCE;
+    }
+    if (bindingKind().equals(PROVISION)
+        && implicitDependencies().isEmpty()
+        && bindingElement().getModifiers().contains(STATIC)) {
+      return FactoryCreationStrategy.ENUM_INSTANCE;
+    }
+    return FactoryCreationStrategy.CLASS_CONSTRUCTOR;
   }
 
   static final class Factory {
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ArrayTypeName.java b/compiler/src/main/java/dagger/internal/codegen/writer/ArrayTypeName.java
index 041cdc625..e7960629e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ArrayTypeName.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ArrayTypeName.java
@@ -38,7 +38,7 @@ public Appendable write(Appendable appendable, Context context) throws IOExcepti
   @Override
   public boolean equals(Object obj) {
     return (obj instanceof ArrayTypeName)
-        & this.componentType.equals(((ArrayTypeName) obj).componentType);
+        && this.componentType.equals(((ArrayTypeName) obj).componentType);
   }
 
   @Override
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index 56a51df7b..2642497f2 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -31,7 +31,6 @@
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_STATIC;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;
 import static dagger.internal.codegen.ErrorMessages.MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT;
@@ -113,25 +112,6 @@ private String formatModuleErrorMessage(String msg) {
         .withErrorContaining(formatErrorMessage(BINDING_METHOD_PRIVATE));
   }
 
-  @Test public void providesMethodStatic() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class TestModule {",
-        "  @Provides static String provideString() {",
-        "    return \"\";",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(formatErrorMessage(BINDING_METHOD_STATIC));
-  }
-
   @Test public void providesMethodReturnVoid() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index 0878f42a4..9e209bb00 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -30,7 +30,6 @@
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_STATIC;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RAW_FUTURE;
@@ -101,25 +100,6 @@ private String formatModuleErrorMessage(String msg) {
         .withErrorContaining(formatErrorMessage(BINDING_METHOD_PRIVATE));
   }
 
-  @Test public void producesMethodStatic() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces static String produceString() {",
-        "    return \"\";",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(formatErrorMessage(BINDING_METHOD_STATIC));
-  }
-
   @Test public void producesMethodReturnVoid() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
