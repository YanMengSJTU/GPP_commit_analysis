diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/BuildMethodCovariantReturn.java b/compiler/src/it/functional-tests/src/main/java/test/builder/BuildMethodCovariantReturn.java
new file mode 100644
index 000000000..be522f5fa
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/BuildMethodCovariantReturn.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.builder;
+
+import dagger.Component;
+
+@Component
+interface BuildMethodCovariantReturn {
+
+  @Component.Builder
+  interface Builder {
+    Object build();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/BuildMethodCovariantReturnInherited.java b/compiler/src/it/functional-tests/src/main/java/test/builder/BuildMethodCovariantReturnInherited.java
new file mode 100644
index 000000000..a02ddf75a
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/BuildMethodCovariantReturnInherited.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.builder;
+
+import dagger.Component;
+
+interface BuildMethodCovariantReturnInherited {
+  @Component
+  interface Simple {
+    interface BuilderSupertype {
+      Object build();
+    }
+
+    @Component.Builder
+    interface Builder extends BuilderSupertype {}
+  }
+
+  interface ComponentSupertype {}
+
+  @Component
+  interface GenericBuilderType extends ComponentSupertype {
+    interface GenericBuilderSupertype<T> {
+      T build();
+    }
+
+    @Component.Builder
+    interface Builder extends GenericBuilderSupertype<ComponentSupertype> {}
+  }
+
+  interface ParameterizedComponentSupertype<T> {}
+
+  @Component
+  interface GenericComponentSupertypeAndBuilderSupertype
+      extends ParameterizedComponentSupertype<Object> {
+
+    interface GenericBuilderSupertype<T> {
+      ParameterizedComponentSupertype<T> build();
+    }
+
+    @Component.Builder
+    interface Builder extends GenericBuilderSupertype<Object> {}
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java b/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
index edad7b733..72df34e5c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
@@ -23,9 +23,15 @@
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
+import static javax.lang.model.util.ElementFilter.methodsIn;
 
+import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableSet;
+import dagger.internal.codegen.ErrorMessages.ComponentBuilderMessages;
+import dagger.internal.codegen.ValidationReport.Builder;
 import java.lang.annotation.Annotation;
+import java.util.Arrays;
 import java.util.List;
 import java.util.Set;
 import javax.lang.model.element.Element;
@@ -45,6 +51,7 @@
  * @author sameb@google.com (Sam Berlin)
  */
 class BuilderValidator {
+
   private final Elements elements;
   private final Types types;
 
@@ -102,20 +109,34 @@
     }
 
     ExecutableElement buildMethod = null;
-    for (ExecutableElement method : getUnimplementedMethods(elements, types, subject)) {
+    for (ExecutableElement method : getUnimplementedMethods(subject, types, elements)) {
       ExecutableType resolvedMethodType =
           MoreTypes.asExecutable(types.asMemberOf(MoreTypes.asDeclared(subject.asType()), method));
       TypeMirror returnType = resolvedMethodType.getReturnType();
       if (method.getParameters().size() == 0) {
         // If this is potentially a build() method, validate it returns the correct type.
-        if (types.isSameType(returnType, componentElement.asType())) {
+        if (types.isSubtype(componentElement.asType(), returnType)) {
+          validateBuildMethodReturnType(
+              builder,
+              // since types.isSubtype() passed, componentElement cannot be a PackageElement
+              MoreElements.asType(componentElement),
+              msgs,
+              method,
+              returnType);
           if (buildMethod != null) {
             // If we found more than one build-like method, fail.
-            error(builder, method, msgs.twoBuildMethods(), msgs.inheritedTwoBuildMethods(),
+            error(
+                builder,
+                method,
+                msgs.twoBuildMethods(),
+                msgs.inheritedTwoBuildMethods(),
                 buildMethod);
           }
         } else {
-          error(builder, method, msgs.buildMustReturnComponentType(),
+          error(
+              builder,
+              method,
+              msgs.buildMustReturnComponentType(),
               msgs.inheritedBuildMustReturnComponentType());
         }
         // We set the buildMethod regardless of the return type to reduce error spam.
@@ -151,6 +172,25 @@
     return builder.build();
   }
 
+  private void validateBuildMethodReturnType(
+      ValidationReport.Builder<TypeElement> builder,
+      TypeElement componentElement,
+      ComponentBuilderMessages msgs,
+      ExecutableElement method,
+      TypeMirror returnType) {
+    if (types.isSameType(componentElement.asType(), returnType)) {
+      return;
+    }
+    ImmutableSet<ExecutableElement> methodsOnlyInComponent =
+        methodsOnlyInComponent(componentElement);
+    if (!methodsOnlyInComponent.isEmpty()) {
+      builder.addWarning(
+          msgs.buildMethodReturnsSupertypeWithMissingMethods(
+              componentElement, builder.getSubject(), returnType, method, methodsOnlyInComponent),
+          method);
+    }
+  }
+
   /**
    * Generates one of two error messages. If the method is enclosed in the subject, we target the
    * error to the method itself. Otherwise we target the error to the subject and list the method as
@@ -169,7 +209,7 @@
    * This check is a little more strict than necessary -- ideally we'd check if method's enclosing
    * class was included in this compile run.  But that's hard, and this is close enough.
    */
-  private void error(
+  private static void error(
       ValidationReport.Builder<TypeElement> builder,
       ExecutableElement method,
       String enclosedError,
@@ -178,10 +218,37 @@ private void error(
     if (method.getEnclosingElement().equals(builder.getSubject())) {
       builder.addError(String.format(enclosedError, extraArgs), method);
     } else {
-      Object[] newArgs = new Object[extraArgs.length + 1];
-      newArgs[0] = method;
-      System.arraycopy(extraArgs, 0, newArgs, 1, extraArgs.length);
-      builder.addError(String.format(inheritedError, newArgs));
+      builder.addError(String.format(inheritedError, append(extraArgs, method)));
     }
   }
+
+  /** @see #error(Builder, ExecutableElement, String, String, Object...) */
+  private static void warning(
+      ValidationReport.Builder<TypeElement> builder,
+      ExecutableElement method,
+      String enclosedWarning,
+      String inheritedWarning,
+      Object... extraArgs) {
+    if (method.getEnclosingElement().equals(builder.getSubject())) {
+      builder.addWarning(String.format(enclosedWarning, extraArgs), method);
+    } else {
+      builder.addWarning(String.format(inheritedWarning, append(extraArgs, method)), method);
+    }
+  }
+
+  private static Object[] append(Object[] initial, Object additional) {
+    Object[] newArray = Arrays.copyOf(initial, initial.length + 1);
+    newArray[initial.length] = additional;
+    return newArray;
+  }
+
+  /**
+   * Returns all methods defind in {@code componentType} which are not inherited from a supertype.
+   */
+  private ImmutableSet<ExecutableElement> methodsOnlyInComponent(TypeElement componentType) {
+    // TODO(ronshapiro): Ideally this shouldn't return methods which are redeclared from a
+    // supertype, but do not change the return type. We don't have a good/simple way of checking
+    // that, and it doesn't seem likely, so the warning won't be too bad.
+    return ImmutableSet.copyOf(methodsIn(componentType.getEnclosedElements()));
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 86f4a48ba..2a58dcecb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -521,7 +521,7 @@ private ComponentDescriptor create(
         }
       }
       ImmutableSet<ExecutableElement> unimplementedMethods =
-          getUnimplementedMethods(elements, types, componentDefinitionType);
+          getUnimplementedMethods(componentDefinitionType, types, elements);
 
       ImmutableSet.Builder<ComponentMethodDescriptor> componentMethodsBuilder =
           ImmutableSet.builder();
@@ -667,7 +667,7 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(
         return Optional.empty();
       }
       TypeElement element = MoreTypes.asTypeElement(builderType.get());
-      ImmutableSet<ExecutableElement> methods = getUnimplementedMethods(elements, types, element);
+      ImmutableSet<ExecutableElement> methods = getUnimplementedMethods(element, types, elements);
       ImmutableSet.Builder<BuilderRequirementMethod> requirementMethods = ImmutableSet.builder();
       ExecutableElement buildMethod = null;
       for (ExecutableElement method : methods) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
index 67ffa5e5e..577362213 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
@@ -182,7 +182,7 @@ protected void addFactoryMethods() {
           methodBuilder("create")
               .returns(componentDefinitionTypeName())
               .addModifiers(PUBLIC, STATIC)
-              .addStatement("return builder().$L()", buildMethodName)
+              .addStatement("return new Builder().$L()", buildMethodName)
               .build());
     }
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/DaggerElements.java b/compiler/src/main/java/dagger/internal/codegen/DaggerElements.java
index f88dcdecc..8c8e0952f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DaggerElements.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DaggerElements.java
@@ -49,7 +49,7 @@
 final class DaggerElements {
 
   static ImmutableSet<ExecutableElement> getUnimplementedMethods(
-      Elements elements, Types types, TypeElement type) {
+      TypeElement type, Types types, Elements elements) {
     return FluentIterable.from(getLocalAndInheritedMethods(type, types, elements))
         .filter(hasModifiers(ABSTRACT))
         .toSet();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 9e398c4a6..0168e112a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -23,12 +23,14 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
+import com.google.common.base.Joiner;
 import dagger.Multibindings;
 import dagger.multibindings.Multibinds;
 import dagger.releasablereferences.CanReleaseReferences;
 import dagger.releasablereferences.ForReleasableReferences;
 import java.lang.annotation.Annotation;
 import java.util.Collection;
+import java.util.Set;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 import javax.lang.model.element.AnnotationMirror;
@@ -486,13 +488,12 @@ final String inheritedTwoBuildMethods() {
 
     final String buildMustReturnComponentType() {
       return process(
-          "@Component.Builder methods that have no arguments must return the @Component type");
+          "@Component.Builder methods that have no arguments must return the @Component type or a "
+              + "supertype of the @Component");
     }
 
     final String inheritedBuildMustReturnComponentType() {
-      return process(
-          "@Component.Builder methods that have no arguments must return the @Component type"
-          + " Inherited method: %s");
+      return process(buildMustReturnComponentType() + ". Inherited method: %s");
     }
 
     final String methodsMustTakeOneArg() {
@@ -522,6 +523,23 @@ final String inheritedMethodsMayNotHaveTypeParameters() {
       return process(
           "@Component.Builder methods must not have type parameters. Inherited method: %s");
     }
+
+    final String buildMethodReturnsSupertypeWithMissingMethods(
+        TypeElement component,
+        TypeElement componentBuilder,
+        TypeMirror returnType,
+        ExecutableElement buildMethod,
+        Set<ExecutableElement> additionalMethods) {
+      return String.format(
+          "%1$s.%2$s() returns %3$s, but %4$s declares additional component method(s): %5$s. In "
+              + "order to provide type-safe access to these methods, override %2$s() to return "
+              + "%4$s",
+          componentBuilder.getQualifiedName(),
+          buildMethod.getSimpleName(),
+          returnType,
+          component.getQualifiedName(),
+          Joiner.on(", ").join(additionalMethods));
+    }
   }
 
   static final class SubcomponentBuilderMessages extends ComponentBuilderMessages {
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
index 9a2343ad9..f5af32957 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
@@ -17,11 +17,14 @@
 package dagger.internal.codegen;
 
 import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
 import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
@@ -37,29 +40,33 @@
 
   @Test
   public void testEmptyBuilder() {
-    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class SomeInjectableType {",
-        "  @Inject SomeInjectableType() {}",
-        "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface SimpleComponent {",
-        "  SomeInjectableType someInjectableType();",
-        "",
-        "  @Component.Builder",
-        "  static interface Builder {",
-        "     SimpleComponent build();",
-        "  }",
-        "}");
+    JavaFileObject injectableTypeFile =
+        JavaFileObjects.forSourceLines(
+            "test.SomeInjectableType",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class SomeInjectableType {",
+            "  @Inject SomeInjectableType() {}",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "interface SimpleComponent {",
+            "  SomeInjectableType someInjectableType();",
+            "",
+            "  @Component.Builder",
+            "  static interface Builder {",
+            "     SimpleComponent build();",
+            "  }",
+            "}");
     JavaFileObject generatedComponent =
         JavaFileObjects.forSourceLines(
             "test.DaggerSimpleComponent",
@@ -78,7 +85,7 @@ public void testEmptyBuilder() {
             "  }",
             "",
             "  public static SimpleComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @Override",
@@ -93,254 +100,278 @@ public void testEmptyBuilder() {
             "    }",
             "  }",
             "}");
-    assertAbout(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
+    assertAbout(javaSources())
+        .that(ImmutableList.of(injectableTypeFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(generatedComponent);
+        .and()
+        .generatesSources(generatedComponent);
   }
 
   @Test
   public void testUsesBuildAndSetterNames() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class TestModule {",
-        "  @Provides String string() { return null; }",
-        "}");
-
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component(modules = TestModule.class)",
-        "interface TestComponent {",
-        "  String string();",
-        "",
-        "  @Component.Builder",
-        "  interface Builder {",
-        "    Builder setTestModule(TestModule testModule);",
-        "    TestComponent create();",
-        "  }",
-        "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import dagger.internal.Preconditions;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private Provider<String> stringProvider;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static TestComponent.Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return builder().create();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.stringProvider = TestModule_StringFactory.create(builder.testModule);",
-        "  }",
-        "",
-        "  @Override",
-        "  public String string() {",
-        "    return stringProvider.get();",
-        "  }",
-        "",
-        "  private static final class Builder implements TestComponent.Builder {",
-        "    private TestModule testModule;",
-        "",
-        "    @Override",
-        "    public TestComponent create() {",
-        "      if (testModule == null) {",
-        "        this.testModule = new TestModule();",
-        "      }",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "",
-        "    @Override",
-        "    public Builder setTestModule(TestModule testModule) {",
-        "      this.testModule = Preconditions.checkNotNull(testModule);",
-        "      return this;",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  @Provides String string() { return null; }",
+            "}");
+
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  String string();",
+            "",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    Builder setTestModule(TestModule testModule);",
+            "    TestComponent create();",
+            "  }",
+            "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.internal.Preconditions;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private Provider<String> stringProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static TestComponent.Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return new Builder().create();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.stringProvider = TestModule_StringFactory.create(builder.testModule);",
+            "  }",
+            "",
+            "  @Override",
+            "  public String string() {",
+            "    return stringProvider.get();",
+            "  }",
+            "",
+            "  private static final class Builder implements TestComponent.Builder {",
+            "    private TestModule testModule;",
+            "",
+            "    @Override",
+            "    public TestComponent create() {",
+            "      if (testModule == null) {",
+            "        this.testModule = new TestModule();",
+            "      }",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "",
+            "    @Override",
+            "    public Builder setTestModule(TestModule testModule) {",
+            "      this.testModule = Preconditions.checkNotNull(testModule);",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(moduleFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(generatedComponent);
+        .and()
+        .generatesSources(generatedComponent);
   }
 
   @Test
   public void testIgnoresModulesNotInApi() {
-    JavaFileObject module1 = JavaFileObjects.forSourceLines("test.TestModule1",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class TestModule1 {",
-        "  @Provides String string() { return null; }",
-        "}");
-    JavaFileObject module2 = JavaFileObjects.forSourceLines("test.TestModule2",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class TestModule2 {",
-        "  @Provides Integer integer() { return null; }",
-        "}");
-
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component(modules = {TestModule1.class, TestModule2.class})",
-        "interface TestComponent {",
-        "  String string();",
-        "  Integer integer();",
-        "",
-        "  @Component.Builder",
-        "  interface Builder {",
-        "    Builder testModule1(TestModule1 testModule1);",
-        "    TestComponent build();",
-        "  }",
-        "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import dagger.internal.Preconditions;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private Provider<String> stringProvider;",
-        "  private Provider<Integer> integerProvider;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static TestComponent.Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.stringProvider = TestModule1_StringFactory.create(builder.testModule1);",
-        "    this.integerProvider = TestModule2_IntegerFactory.create(builder.testModule2);",
-        "  }",
-        "",
-        "  @Override",
-        "  public String string() {",
-        "    return stringProvider.get();",
-        "  }",
-        "",
-        "  @Override",
-        "  public Integer integer() {",
-        "    return integerProvider.get();",
-        "  }",
-        "",
-        "  private static final class Builder implements TestComponent.Builder {",
-        "    private TestModule1 testModule1;",
-        "    private TestModule2 testModule2;",
-        "",
-        "    @Override",
-        "    public TestComponent build() {",
-        "      if (testModule1 == null) {",
-        "        this.testModule1 = new TestModule1();",
-        "      }",
-        "      if (testModule2 == null) {",
-        "        this.testModule2 = new TestModule2();",
-        "      }",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "",
-        "    @Override",
-        "    public Builder testModule1(TestModule1 testModule1) {",
-        "      this.testModule1 = Preconditions.checkNotNull(testModule1);",
-        "      return this;",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject module1 =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule1",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule1 {",
+            "  @Provides String string() { return null; }",
+            "}");
+    JavaFileObject module2 =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule2",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule2 {",
+            "  @Provides Integer integer() { return null; }",
+            "}");
+
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = {TestModule1.class, TestModule2.class})",
+            "interface TestComponent {",
+            "  String string();",
+            "  Integer integer();",
+            "",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    Builder testModule1(TestModule1 testModule1);",
+            "    TestComponent build();",
+            "  }",
+            "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.internal.Preconditions;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private Provider<String> stringProvider;",
+            "  private Provider<Integer> integerProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static TestComponent.Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.stringProvider = TestModule1_StringFactory.create(builder.testModule1);",
+            "    this.integerProvider = TestModule2_IntegerFactory.create(builder.testModule2);",
+            "  }",
+            "",
+            "  @Override",
+            "  public String string() {",
+            "    return stringProvider.get();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Integer integer() {",
+            "    return integerProvider.get();",
+            "  }",
+            "",
+            "  private static final class Builder implements TestComponent.Builder {",
+            "    private TestModule1 testModule1;",
+            "    private TestModule2 testModule2;",
+            "",
+            "    @Override",
+            "    public TestComponent build() {",
+            "      if (testModule1 == null) {",
+            "        this.testModule1 = new TestModule1();",
+            "      }",
+            "      if (testModule2 == null) {",
+            "        this.testModule2 = new TestModule2();",
+            "      }",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "",
+            "    @Override",
+            "    public Builder testModule1(TestModule1 testModule1) {",
+            "      this.testModule1 = Preconditions.checkNotNull(testModule1);",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(module1, module2, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(generatedComponent);
+        .and()
+        .generatesSources(generatedComponent);
   }
 
   @Test
   public void testMoreThanOneBuilderFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface SimpleComponent {",
-        "  @Component.Builder",
-        "  static interface Builder {",
-        "     SimpleComponent build();",
-        "  }",
-        "",
-        "  @Component.Builder",
-        "  interface Builder2 {",
-        "     SimpleComponent build();",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "interface SimpleComponent {",
+            "  @Component.Builder",
+            "  static interface Builder {",
+            "     SimpleComponent build();",
+            "  }",
+            "",
+            "  @Component.Builder",
+            "  interface Builder2 {",
+            "     SimpleComponent build();",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(String.format(MSGS.moreThanOne(),
-            "[test.SimpleComponent.Builder, test.SimpleComponent.Builder2]"))
+        .withErrorContaining(
+            String.format(
+                MSGS.moreThanOne(),
+                "[test.SimpleComponent.Builder, test.SimpleComponent.Builder2]"))
         .in(componentFile);
   }
 
   @Test
   public void testBuilderGenericsFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface SimpleComponent {",
-        "  @Component.Builder",
-        "  interface Builder<T> {",
-        "     SimpleComponent build();",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "interface SimpleComponent {",
+            "  @Component.Builder",
+            "  interface Builder<T> {",
+            "     SimpleComponent build();",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(MSGS.generics())
@@ -349,14 +380,17 @@ public void testBuilderGenericsFails() {
 
   @Test
   public void testBuilderNotInComponentFails() {
-    JavaFileObject builder = JavaFileObjects.forSourceLines("test.Builder",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component.Builder",
-        "interface Builder {}");
-    assertAbout(javaSource()).that(builder)
+    JavaFileObject builder =
+        JavaFileObjects.forSourceLines(
+            "test.Builder",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component.Builder",
+            "interface Builder {}");
+    assertAbout(javaSource())
+        .that(builder)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(MSGS.mustBeInComponent())
@@ -365,18 +399,21 @@ public void testBuilderNotInComponentFails() {
 
   @Test
   public void testBuilderMissingBuildMethodFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface SimpleComponent {",
-        "  @Component.Builder",
-        "  interface Builder {}",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "interface SimpleComponent {",
+            "  @Component.Builder",
+            "  interface Builder {}",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(MSGS.missingBuildMethod())
@@ -385,18 +422,21 @@ public void testBuilderMissingBuildMethodFails() {
 
   @Test
   public void testPrivateBuilderFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  private interface Builder {}",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  private interface Builder {}",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(MSGS.isPrivate())
@@ -405,18 +445,21 @@ public void testPrivateBuilderFails() {
 
   @Test
   public void testNonStaticBuilderFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  abstract class Builder {}",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  abstract class Builder {}",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(MSGS.mustBeStatic())
@@ -425,18 +468,21 @@ public void testNonStaticBuilderFails() {
 
   @Test
   public void testNonAbstractBuilderFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  static class Builder {}",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  static class Builder {}",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(MSGS.mustBeAbstract());
@@ -444,20 +490,23 @@ public void testNonAbstractBuilderFails() {
 
   @Test
   public void testBuilderOneCxtorWithArgsFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  static abstract class Builder {",
-        "    Builder(String unused) {}",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  static abstract class Builder {",
+            "    Builder(String unused) {}",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
@@ -466,21 +515,24 @@ public void testBuilderOneCxtorWithArgsFails() {
 
   @Test
   public void testBuilderMoreThanOneCxtorFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  static abstract class Builder {",
-        "    Builder() {}",
-        "    Builder(String unused) {}",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  static abstract class Builder {",
+            "    Builder() {}",
+            "    Builder(String unused) {}",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
@@ -489,18 +541,21 @@ public void testBuilderMoreThanOneCxtorFails() {
 
   @Test
   public void testBuilderEnumFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  enum Builder {}",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  enum Builder {}",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(MSGS.mustBeClassOrInterface())
@@ -509,250 +564,289 @@ public void testBuilderEnumFails() {
 
   @Test
   public void testBuilderBuildReturnsWrongTypeFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  interface Builder {",
-        "    String build();",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    String build();",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(MSGS.buildMustReturnComponentType())
-            .in(componentFile).onLine(10);
+        .in(componentFile)
+        .onLine(10);
   }
 
   @Test
   public void testInheritedBuilderBuildReturnsWrongTypeFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  interface Parent {",
-        "    String build();",
-        "  }",
-        "",
-        "  @Component.Builder",
-        "  interface Builder extends Parent {}",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  interface Parent {",
+            "    String build();",
+            "  }",
+            "",
+            "  @Component.Builder",
+            "  interface Builder extends Parent {}",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(
-            String.format(MSGS.inheritedBuildMustReturnComponentType(), "build"))
-            .in(componentFile).onLine(13);
+        .withErrorContaining(String.format(MSGS.inheritedBuildMustReturnComponentType(), "build"))
+        .in(componentFile)
+        .onLine(13);
   }
 
   @Test
   public void testTwoBuildMethodsFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  interface Builder {",
-        "    SimpleComponent build();",
-        "    SimpleComponent create();",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    SimpleComponent build();",
+            "    SimpleComponent create();",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(String.format(MSGS.twoBuildMethods(), "build()"))
-            .in(componentFile).onLine(11);
+        .in(componentFile)
+        .onLine(11);
   }
 
   @Test
   public void testInheritedTwoBuildMethodsFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  interface Parent {",
-        "    SimpleComponent build();",
-        "    SimpleComponent create();",
-        "  }",
-        "",
-        "  @Component.Builder",
-        "  interface Builder extends Parent {}",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  interface Parent {",
+            "    SimpleComponent build();",
+            "    SimpleComponent create();",
+            "  }",
+            "",
+            "  @Component.Builder",
+            "  interface Builder extends Parent {}",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(
-            String.format(MSGS.inheritedTwoBuildMethods(), "create()", "build()"))
-            .in(componentFile).onLine(14);
+        .withErrorContaining(String.format(MSGS.inheritedTwoBuildMethods(), "build()", "create()"))
+        .in(componentFile)
+        .onLine(14);
   }
 
   @Test
   public void testMoreThanOneArgFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  interface Builder {",
-        "    SimpleComponent build();",
-        "    Builder set(String s, Integer i);",
-        "    Builder set(Number n, Double d);",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    SimpleComponent build();",
+            "    Builder set(String s, Integer i);",
+            "    Builder set(Number n, Double d);",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(MSGS.methodsMustTakeOneArg())
-            .in(componentFile).onLine(11)
-        .and().withErrorContaining(MSGS.methodsMustTakeOneArg())
-            .in(componentFile).onLine(12);
+        .in(componentFile)
+        .onLine(11)
+        .and()
+        .withErrorContaining(MSGS.methodsMustTakeOneArg())
+        .in(componentFile)
+        .onLine(12);
   }
 
   @Test
   public void testInheritedMoreThanOneArgFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  interface Parent {",
-        "    SimpleComponent build();",
-        "    Builder set1(String s, Integer i);",
-        "  }",
-        "",
-        "  @Component.Builder",
-        "  interface Builder extends Parent {}",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  interface Parent {",
+            "    SimpleComponent build();",
+            "    Builder set1(String s, Integer i);",
+            "  }",
+            "",
+            "  @Component.Builder",
+            "  interface Builder extends Parent {}",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
-            String.format(MSGS.inheritedMethodsMustTakeOneArg(),
-                "set1(java.lang.String,java.lang.Integer)"))
-            .in(componentFile).onLine(14);
+            String.format(
+                MSGS.inheritedMethodsMustTakeOneArg(), "set1(java.lang.String,java.lang.Integer)"))
+        .in(componentFile)
+        .onLine(14);
   }
 
   @Test
   public void testSetterReturningNonVoidOrBuilderFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  interface Builder {",
-        "    SimpleComponent build();",
-        "    String set(Integer i);",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    SimpleComponent build();",
+            "    String set(Integer i);",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(MSGS.methodsMustReturnVoidOrBuilder())
-            .in(componentFile).onLine(11);
+        .in(componentFile)
+        .onLine(11);
   }
 
   @Test
   public void testInheritedSetterReturningNonVoidOrBuilderFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  interface Parent {",
-        "    SimpleComponent build();",
-        "    String set(Integer i);",
-        "  }",
-        "",
-        "  @Component.Builder",
-        "  interface Builder extends Parent {}",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  interface Parent {",
+            "    SimpleComponent build();",
+            "    String set(Integer i);",
+            "  }",
+            "",
+            "  @Component.Builder",
+            "  interface Builder extends Parent {}",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
-            String.format(MSGS.inheritedMethodsMustReturnVoidOrBuilder(),
-                "set(java.lang.Integer)"))
-            .in(componentFile).onLine(14);
+            String.format(MSGS.inheritedMethodsMustReturnVoidOrBuilder(), "set(java.lang.Integer)"))
+        .in(componentFile)
+        .onLine(14);
   }
 
   @Test
   public void testGenericsOnSetterMethodFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  interface Builder {",
-        "    SimpleComponent build();",
-        "    <T> Builder set(T t);",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    SimpleComponent build();",
+            "    <T> Builder set(T t);",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(MSGS.methodsMayNotHaveTypeParameters())
-            .in(componentFile).onLine(11);
+        .in(componentFile)
+        .onLine(11);
   }
 
   @Test
   public void testGenericsOnInheritedSetterMethodFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  interface Parent {",
-        "    SimpleComponent build();",
-        "    <T> Builder set(T t);",
-        "  }",
-        "",
-        "  @Component.Builder",
-        "  interface Builder extends Parent {}",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  interface Parent {",
+            "    SimpleComponent build();",
+            "    <T> Builder set(T t);",
+            "  }",
+            "",
+            "  @Component.Builder",
+            "  interface Builder extends Parent {}",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
             String.format(MSGS.inheritedMethodsMayNotHaveTypeParameters(), "<T>set(T)"))
-            .in(componentFile).onLine(14);
+        .in(componentFile)
+        .onLine(14);
   }
 
   @Test
@@ -892,61 +986,71 @@ public void testExtraSettersFails() {
 
   @Test
   public void testMissingSettersFail() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class TestModule {",
-        "  TestModule(String unused) {}",
-        "  @Provides String s() { return null; }",
-        "}");
-    JavaFileObject module2File = JavaFileObjects.forSourceLines("test.Test2Module",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class Test2Module {",
-        "  @Provides Integer i() { return null; }",
-        "}");
-    JavaFileObject module3File = JavaFileObjects.forSourceLines("test.Test3Module",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class Test3Module {",
-        "  Test3Module(String unused) {}",
-        "  @Provides Double d() { return null; }",
-        "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component(modules = {TestModule.class, Test2Module.class, Test3Module.class},",
-        "           dependencies = OtherComponent.class)",
-        "interface TestComponent {",
-        "  String string();",
-        "  Integer integer();",
-        "",
-        "  @Component.Builder",
-        "  interface Builder {",
-        "    TestComponent create();",
-        "  }",
-        "}");
-    JavaFileObject otherComponent = JavaFileObjects.forSourceLines("test.OtherComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component",
-        "interface OtherComponent {}");
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  TestModule(String unused) {}",
+            "  @Provides String s() { return null; }",
+            "}");
+    JavaFileObject module2File =
+        JavaFileObjects.forSourceLines(
+            "test.Test2Module",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class Test2Module {",
+            "  @Provides Integer i() { return null; }",
+            "}");
+    JavaFileObject module3File =
+        JavaFileObjects.forSourceLines(
+            "test.Test3Module",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class Test3Module {",
+            "  Test3Module(String unused) {}",
+            "  @Provides Double d() { return null; }",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = {TestModule.class, Test2Module.class, Test3Module.class},",
+            "           dependencies = OtherComponent.class)",
+            "interface TestComponent {",
+            "  String string();",
+            "  Integer integer();",
+            "",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    TestComponent create();",
+            "  }",
+            "}");
+    JavaFileObject otherComponent =
+        JavaFileObjects.forSourceLines(
+            "test.OtherComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface OtherComponent {}");
     assertAbout(javaSources())
         .that(ImmutableList.of(moduleFile, module2File, module3File, componentFile, otherComponent))
         .processedWith(new ComponentProcessor())
@@ -954,8 +1058,174 @@ public void testMissingSettersFail() {
         .withErrorContaining(
             // Ignores Test2Module because we can construct it ourselves.
             // TODO(sameb): Ignore Test3Module because it's not used within transitive dependencies.
-            String.format(MSGS.missingSetters(),
-                "[test.TestModule, test.Test3Module, test.OtherComponent]"))
-            .in(componentFile).onLine(12);
+            String.format(
+                MSGS.missingSetters(), "[test.TestModule, test.Test3Module, test.OtherComponent]"))
+        .in(componentFile)
+        .onLine(12);
+  }
+
+  @Test
+  public void covariantBuildMethodReturnType() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Foo {",
+            "  @Inject Foo() {}",
+            "}");
+    JavaFileObject supertype =
+        JavaFileObjects.forSourceLines(
+            "test.Supertype",
+            "package test;",
+            "",
+            "interface Supertype {",
+            "  Foo foo();",
+            "}");
+
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.HasSupertype",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface HasSupertype extends Supertype {",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    Supertype build();",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(foo, supertype, component);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void covariantBuildMethodReturnType_hasNewMethod() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Foo {",
+            "  @Inject Foo() {}",
+            "}");
+    JavaFileObject bar =
+        JavaFileObjects.forSourceLines(
+            "test.Bar",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Bar {",
+            "  @Inject Bar() {}",
+            "}");
+    JavaFileObject supertype =
+        JavaFileObjects.forSourceLines(
+            "test.Supertype",
+            "package test;",
+            "",
+            "interface Supertype {",
+            "  Foo foo();",
+            "}");
+
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.HasSupertype",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface HasSupertype extends Supertype {",
+            "  Bar bar();",
+            "",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    Supertype build();",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(foo, bar, supertype, component);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .hadWarningContaining(
+            "test.HasSupertype.Builder.build() returns test.Supertype, but test.HasSupertype "
+                + "declares additional component method(s): bar(). In order to provide type-safe "
+                + "access to these methods, override build() to return test.HasSupertype")
+        .inFile(component)
+        .onLine(11);
+  }
+
+  @Test
+  public void covariantBuildMethodReturnType_hasNewMethod_buildMethodInherited() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Foo {",
+            "  @Inject Foo() {}",
+            "}");
+    JavaFileObject bar =
+        JavaFileObjects.forSourceLines(
+            "test.Bar",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Bar {",
+            "  @Inject Bar() {}",
+            "}");
+    JavaFileObject supertype =
+        JavaFileObjects.forSourceLines(
+            "test.Supertype",
+            "package test;",
+            "",
+            "interface Supertype {",
+            "  Foo foo();",
+            "}");
+
+    JavaFileObject builderSupertype =
+        JavaFileObjects.forSourceLines(
+            "test.BuilderSupertype",
+            "package test;",
+            "",
+            "interface BuilderSupertype {",
+            "  Supertype build();",
+            "}");
+
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.HasSupertype",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface HasSupertype extends Supertype {",
+            "  Bar bar();",
+            "",
+            "  @Component.Builder",
+            "  interface Builder extends BuilderSupertype {}",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler().compile(foo, bar, supertype, builderSupertype, component);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .hadWarningContaining(
+            "[test.BuilderSupertype.build()] test.HasSupertype.Builder.build() returns "
+                + "test.Supertype, but test.HasSupertype declares additional component method(s): "
+                + "bar(). In order to provide type-safe access to these methods, override build() "
+                + "to return test.HasSupertype");
   }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index b095819e5..69f2523bd 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -269,7 +269,7 @@ public void componentWithInvalidModule() {
             "  }",
             "",
             "  public static SimpleComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @Override",
@@ -353,7 +353,7 @@ public void componentWithInvalidModule() {
             "  }",
             "",
             "  public static SimpleComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -436,7 +436,7 @@ public void componentWithInvalidModule() {
             "  }",
             "",
             "  public static OuterType.SimpleComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -538,7 +538,7 @@ public void componentWithInvalidModule() {
             "  }",
             "",
             "  public static TestComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -656,7 +656,7 @@ public void componentWithAbstractModule() {
             "  }",
             "",
             "  public static TestComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -776,7 +776,7 @@ public void componentWithAbstractModule() {
         "  }",
         "",
         "  public static TestComponent create() {",
-        "    return builder().build();",
+        "    return new Builder().build();",
         "  }",
         "",
         "  public static final class Builder {",
@@ -986,7 +986,7 @@ public void subcomponentOmitsInheritedBindings() {
             "  }",
             "",
             "  public static Parent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -1119,7 +1119,7 @@ public void subcomponentNotGeneratedIfNotUsedInGraph() {
             "  }",
             "",
             "  public static Parent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @Override",
@@ -1242,7 +1242,7 @@ public void testDefaultPackage() {
             "  }",
             "",
             "  public static TestComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -1350,7 +1350,7 @@ public void testDefaultPackage() {
         "  }",
         "",
         "  public static SimpleComponent create() {",
-        "    return builder().build();",
+        "    return new Builder().build();",
         "  }",
         "",
         "  @SuppressWarnings(\"unchecked\")",
@@ -1431,7 +1431,7 @@ public void testDefaultPackage() {
             "  }",
             "",
             "  public static SimpleComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -1512,7 +1512,7 @@ public void testDefaultPackage() {
         "  }",
         "",
         "  public static SimpleComponent create() {",
-        "    return builder().build();",
+        "    return new Builder().build();",
         "  }",
         "",
         "  @SuppressWarnings(\"unchecked\")",
@@ -1590,7 +1590,7 @@ public void testDefaultPackage() {
         "  }",
         "",
         "  public static SimpleComponent create() {",
-        "    return builder().build();",
+        "    return new Builder().build();",
         "  }",
         "",
         "  @SuppressWarnings(\"unchecked\")",
@@ -1793,7 +1793,7 @@ public void testDefaultPackage() {
         "  }",
         "",
         "  public static TestComponent create() {",
-        "    return builder().build();",
+        "    return new Builder().build();",
         "  }",
         "",
         "  @SuppressWarnings(\"unchecked\")",
@@ -1918,7 +1918,7 @@ public void testDefaultPackage() {
             "  }",
             "",
             "  public static TestComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -2018,7 +2018,7 @@ public void testDefaultPackage() {
             "  }",
             "",
             "  public static SimpleComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @Override",
@@ -2107,7 +2107,7 @@ public void testDefaultPackage() {
             "  }",
             "",
             "  public static SimpleComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @Override",
@@ -2313,7 +2313,7 @@ public void genericTestToLetMeDebugInEclipse() {
          "  }",
          "",
          "  public static SimpleComponent create() {",
-         "    return builder().build();",
+         "    return new Builder().build();",
          "  }",
          "",
          "  @SuppressWarnings(\"unchecked\")",
@@ -2588,7 +2588,7 @@ public void unusedSubcomponents_dontResolveExtraBindingsInParentComponents() {
             "  }",
             "",
             "  public static Parent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  public static final class Builder {",
diff --git a/compiler/src/test/java/dagger/internal/codegen/InaccessibleTypeTest.java b/compiler/src/test/java/dagger/internal/codegen/InaccessibleTypeTest.java
index b57fcb3a1..4f2932e41 100644
--- a/compiler/src/test/java/dagger/internal/codegen/InaccessibleTypeTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/InaccessibleTypeTest.java
@@ -105,7 +105,7 @@
             "  }",
             "",
             "  public static TestComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -236,7 +236,7 @@
             "  }",
             "",
             "  public static TestComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
index 46ffa2f60..5c4f98214 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -137,7 +137,7 @@ public void mapBindingsWithEnumKey() {
             "  }",
             "",
             "  public static TestComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -290,7 +290,7 @@ public void mapBindingsWithStringKey() {
             "  }",
             "",
             "  public static TestComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -452,7 +452,7 @@ public void mapBindingsWithWrappedKey() {
             "  }",
             "",
             "  public static TestComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -620,7 +620,7 @@ public void mapBindingsWithNonProviderValue() {
             "  }",
             "",
             "  public static TestComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -735,7 +735,7 @@ public void injectMapWithoutMapBinding() {
         "  }",
         "",
         "  public static TestComponent create() {",
-        "    return builder().build();",
+        "    return new Builder().build();",
         "  }",
         "",
         "  @SuppressWarnings(\"unchecked\")",
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
index a271187ef..62fe2fdb6 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
@@ -235,7 +235,7 @@ public void mapKeyComponentFileWithDisorderedKeyField() {
             "  }",
             "",
             "  public static TestComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -410,7 +410,7 @@ public void mapKeyComponentFileWithDefaultField() {
             "  }",
             "",
             "  public static TestComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
diff --git a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
index 34ee72c2f..35337fce5 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
@@ -88,7 +88,7 @@ public void parentClass_noInjectedMembers() {
         "  }",
         "",
         "  public static TestComponent create() {",
-        "    return builder().build();",
+        "    return new Builder().build();",
         "  }",
         "",
         "  @SuppressWarnings(\"unchecked\")",
@@ -178,7 +178,7 @@ public void parentClass_injectedMembersInSupertype() {
             "  }",
             "",
             "  public static TestComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
index 1a1bb6474..561795632 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -236,7 +236,7 @@ public void simpleComponent() {
             "  }",
             "",
             "  public static TestClass.SimpleComponent create() {",
-            "    return builder().build()",
+            "    return new Builder().build()",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
diff --git a/compiler/src/test/java/dagger/internal/codegen/SubcomponentBuilderValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
index 01389933f..f4cb9ed51 100644
--- a/compiler/src/test/java/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
@@ -17,11 +17,14 @@
 package dagger.internal.codegen;
 
 import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
 
 import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
@@ -421,7 +424,7 @@ public void testInheritedTwoBuildMethodsFails() {
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
-            String.format(MSGS.inheritedTwoBuildMethods(), "create()", "build()"))
+            String.format(MSGS.inheritedTwoBuildMethods(), "build()", "create()"))
             .in(childComponentFile).onLine(13);
   }
 
@@ -839,4 +842,169 @@ public void testMissingSettersFail() {
             String.format(MSGS.missingSetters(), "[test.TestModule, test.Test3Module]"))
             .in(childComponentFile).onLine(11);
   }
+
+  @Test
+  public void covariantBuildMethodReturnType() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Foo {",
+            "  @Inject Foo() {}",
+            "}");
+    JavaFileObject supertype =
+        JavaFileObjects.forSourceLines(
+            "test.Supertype",
+            "package test;",
+            "",
+            "interface Supertype {",
+            "  Foo foo();",
+            "}");
+
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.HasSupertype",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface HasSupertype extends Supertype {",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Supertype build();",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(foo, supertype, subcomponent);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void covariantBuildMethodReturnType_hasNewMethod() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Foo {",
+            "  @Inject Foo() {}",
+            "}");
+    JavaFileObject bar =
+        JavaFileObjects.forSourceLines(
+            "test.Bar",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Bar {",
+            "  @Inject Bar() {}",
+            "}");
+    JavaFileObject supertype =
+        JavaFileObjects.forSourceLines(
+            "test.Supertype",
+            "package test;",
+            "",
+            "interface Supertype {",
+            "  Foo foo();",
+            "}");
+
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.HasSupertype",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface HasSupertype extends Supertype {",
+            "  Bar bar();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Supertype build();",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(foo, bar, supertype, subcomponent);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .hadWarningContaining(
+            "test.HasSupertype.Builder.build() returns test.Supertype, but test.HasSupertype "
+                + "declares additional component method(s): bar(). In order to provide type-safe "
+                + "access to these methods, override build() to return test.HasSupertype")
+        .inFile(subcomponent)
+        .onLine(11);
+  }
+
+  @Test
+  public void covariantBuildMethodReturnType_hasNewMethod_buildMethodInherited() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Foo {",
+            "  @Inject Foo() {}",
+            "}");
+    JavaFileObject bar =
+        JavaFileObjects.forSourceLines(
+            "test.Bar",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Bar {",
+            "  @Inject Bar() {}",
+            "}");
+    JavaFileObject supertype =
+        JavaFileObjects.forSourceLines(
+            "test.Supertype",
+            "package test;",
+            "",
+            "interface Supertype {",
+            "  Foo foo();",
+            "}");
+
+    JavaFileObject builderSupertype =
+        JavaFileObjects.forSourceLines(
+            "test.BuilderSupertype",
+            "package test;",
+            "",
+            "interface BuilderSupertype {",
+            "  Supertype build();",
+            "}");
+
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.HasSupertype",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface HasSupertype extends Supertype {",
+            "  Bar bar();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder extends BuilderSupertype {}",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler().compile(foo, bar, supertype, builderSupertype, subcomponent);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .hadWarningContaining(
+            "[test.BuilderSupertype.build()] test.HasSupertype.Builder.build() returns "
+                + "test.Supertype, but test.HasSupertype declares additional component method(s): "
+                + "bar(). In order to provide type-safe access to these methods, override build() "
+                + "to return test.HasSupertype");
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
index fb3a38873..d79d65e41 100644
--- a/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
@@ -371,7 +371,7 @@ public void delegateFactoryNotCreatedForSubcomponentWhenProviderExistsInParent()
             "  }",
             "",
             "  public static ParentComponent create() {  ",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -528,7 +528,7 @@ public void multipleSubcomponentsWithSameSimpleNamesCanExistInSameComponent() {
             "  }",
             "",
             "  public static ParentComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @Override",
@@ -635,7 +635,7 @@ public void subcomponentSimpleNamesDisambiguated() {
             "  }",
             "",
             "  public static ParentComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @Override",
@@ -733,7 +733,7 @@ public void subcomponentImplNameUsesFullyQualifiedClassNameIfNecessary() {
             "  }",
             "",
             "  public static ParentComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @Override",
@@ -812,7 +812,7 @@ public void parentComponentNameShouldNotBeDisambiguatedWhenItConflictsWithASubco
             "  }",
             "",
             "  public static C create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @Override",
@@ -901,7 +901,7 @@ public void subcomponentBuilderNamesShouldNotConflict() {
             "  }",
             "",
             "  public static C create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -990,7 +990,7 @@ public void duplicateBindingWithSubcomponentDeclaration() {
             "class TestModule {",
             "  @Provides Sub.Builder providesConflictsWithModuleSubcomponents() { return null; }",
             "  @Provides Object usesSubcomponentBuilder(Sub.Builder builder) {",
-            "    return builder.toString();",
+            "    return new Builder().toString();",
             "  }",
             "}");
 
diff --git a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
index da1eca604..67beb03dd 100644
--- a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
@@ -93,7 +93,7 @@
           "  }",
           "",
           "  public static PrimitiveComponent create() {",
-          "    return builder().build();",
+          "    return new Builder().build();",
           "  }",
           "",
           "  @SuppressWarnings(\"unchecked\")",
