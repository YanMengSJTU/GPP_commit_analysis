diff --git a/java/dagger/internal/codegen/ComponentHjarProcessingStep.java b/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
index 8ae79d2a5..f2a585162 100644
--- a/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
+++ b/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
@@ -20,11 +20,15 @@
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Predicates.in;
+import static com.google.common.collect.Sets.union;
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static dagger.internal.codegen.ComponentGenerator.componentName;
 import static dagger.internal.codegen.base.ComponentAnnotation.rootComponentAnnotations;
+import static dagger.internal.codegen.binding.ComponentCreatorAnnotation.rootComponentCreatorAnnotations;
 import static dagger.internal.codegen.binding.ComponentCreatorKind.BUILDER;
 import static dagger.internal.codegen.javapoet.TypeSpecs.addSupertype;
+import static java.util.Collections.disjoint;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -34,7 +38,10 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Ascii;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Multimaps;
+import com.google.common.collect.SetMultimap;
 import com.google.common.collect.Sets;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.MethodSpec;
@@ -52,11 +59,15 @@
 import dagger.internal.codegen.kotlin.KotlinMetadataUtil;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.internal.codegen.langmodel.DaggerTypes;
+import dagger.internal.codegen.validation.ComponentCreatorValidator;
 import dagger.internal.codegen.validation.ComponentValidator;
 import dagger.internal.codegen.validation.ComponentValidator.ComponentValidationReport;
 import dagger.internal.codegen.validation.TypeCheckingProcessingStep;
+import dagger.internal.codegen.validation.ValidationReport;
 import dagger.producers.internal.CancellationListener;
 import java.lang.annotation.Annotation;
+import java.util.HashMap;
+import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
 import java.util.stream.Stream;
@@ -89,8 +100,10 @@
   private final Filer filer;
   private final Messager messager;
   private final ComponentValidator componentValidator;
+  private final ComponentCreatorValidator creatorValidator;
   private final ComponentDescriptorFactory componentDescriptorFactory;
   private final KotlinMetadataUtil metadataUtil;
+  private ImmutableMap<Element, ValidationReport<TypeElement>> creatorReportsByComponent;
 
   @Inject
   ComponentHjarProcessingStep(
@@ -100,6 +113,7 @@
       Filer filer,
       Messager messager,
       ComponentValidator componentValidator,
+      ComponentCreatorValidator creatorValidator,
       ComponentDescriptorFactory componentDescriptorFactory,
       KotlinMetadataUtil metadataUtil) {
     super(MoreElements::asType);
@@ -109,30 +123,64 @@
     this.filer = filer;
     this.messager = messager;
     this.componentValidator = componentValidator;
+    this.creatorValidator = creatorValidator;
     this.componentDescriptorFactory = componentDescriptorFactory;
     this.metadataUtil = metadataUtil;
   }
 
   @Override
   public Set<Class<? extends Annotation>> annotations() {
-    return rootComponentAnnotations();
+    return union(rootComponentAnnotations(), rootComponentCreatorAnnotations());
+  }
+
+  // TODO(ronshapiro): Validation might not even be necessary. We should measure it and figure out
+  // if it's worth seeing if removing it will still work. We could potentially add a new catch
+  // clause for any exception that's not TypeNotPresentException and ignore the component entirely
+  // in that case.
+  @Override
+  public ImmutableSet<Element> process(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    creatorReportsByComponent = creatorReportsByComponent(elementsByAnnotation);
+    return super.process(elementsByAnnotation);
   }
 
   @Override
   protected void process(
-      TypeElement componentTypeElement, ImmutableSet<Class<? extends Annotation>> annotations) {
-    // TODO(ronshapiro): component validation might not be necessary. We should measure it and
-    // figure out if it's worth seeing if removing it will still work. We could potentially add a
-    // new catch clause for any exception that's not TypeNotPresentException and ignore the
-    // component entirely in that case.
+      TypeElement element, ImmutableSet<Class<? extends Annotation>> annotations) {
+    // Skip creator validation because those have already been validated.
+    if (!disjoint(annotations, rootComponentCreatorAnnotations())) {
+      return;
+    }
+    // Skip component validation if its creator validation already failed.
+    if (creatorReportsByComponent.get(element) != null
+            && !creatorReportsByComponent.get(element).isClean()) {
+      return;
+    }
     ComponentValidationReport validationReport =
-        componentValidator.validate(componentTypeElement, ImmutableSet.of(), ImmutableSet.of());
+        componentValidator.validate(element, ImmutableSet.of(), ImmutableSet.of());
     validationReport.report().printMessagesTo(messager);
     if (validationReport.report().isClean()) {
       new EmptyComponentGenerator(filer, elements, sourceVersion)
-          .generate(
-              componentDescriptorFactory.rootComponentDescriptor(componentTypeElement), messager);
+          .generate(componentDescriptorFactory.rootComponentDescriptor(element), messager);
+    }
+  }
+
+  private ImmutableMap<Element, ValidationReport<TypeElement>> creatorReportsByComponent(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    ImmutableSet<Element> creatorElements =
+        ImmutableSet.copyOf(
+            Multimaps.filterKeys(elementsByAnnotation, in(rootComponentCreatorAnnotations()))
+                .values());
+    // Can't use an ImmutableMap.Builder here because a component may have (invalidly) more than one
+    // builder type, and that would make ImmutableMap.Builder throw.
+    Map<Element, ValidationReport<TypeElement>> reports = new HashMap<>();
+    for (Element element : creatorElements) {
+      ValidationReport<TypeElement> report =
+          creatorValidator.validate(MoreElements.asType(element));
+      report.printMessagesTo(messager);
+      reports.put(element.getEnclosingElement(), report);
     }
+    return ImmutableMap.copyOf(reports);
   }
 
   private final class EmptyComponentGenerator extends SourceFileGenerator<ComponentDescriptor> {
diff --git a/java/dagger/internal/codegen/ComponentProcessingStep.java b/java/dagger/internal/codegen/ComponentProcessingStep.java
index 3dfa78e21..a983548cc 100644
--- a/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -170,7 +170,7 @@ private void generateComponent(BindingGraph bindingGraph) {
     componentGenerator.generate(bindingGraph, messager);
   }
 
-  static ImmutableSet<Element> getElementsFromAnnotations(
+  private static ImmutableSet<Element> getElementsFromAnnotations(
       final SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation,
       Set<Class<? extends Annotation>> annotations) {
     return ImmutableSet.copyOf(
diff --git a/javatests/dagger/internal/codegen/ComponentCreatorTest.java b/javatests/dagger/internal/codegen/ComponentCreatorTest.java
index e3d4c3c8e..c19d87bdb 100644
--- a/javatests/dagger/internal/codegen/ComponentCreatorTest.java
+++ b/javatests/dagger/internal/codegen/ComponentCreatorTest.java
@@ -16,11 +16,12 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.collect.Sets.immutableEnumSet;
+import static com.google.common.truth.TruthJUnit.assume;
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static dagger.internal.codegen.CompilerMode.DEFAULT_MODE;
 import static dagger.internal.codegen.CompilerMode.FAST_INIT_MODE;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.ComponentCreatorTest.CompilerType.JAVAC;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_CODE_ANNOTATIONS;
 import static dagger.internal.codegen.GeneratedLines.IMPORT_GENERATED_ANNOTATION;
 import static dagger.internal.codegen.binding.ComponentCreatorAnnotation.COMPONENT_BUILDER;
@@ -31,14 +32,10 @@
 import static dagger.internal.codegen.binding.ErrorMessages.componentMessagesFor;
 
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Iterables;
-import com.google.common.collect.Sets;
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import dagger.internal.codegen.binding.ComponentCreatorAnnotation;
 import java.util.Collection;
-import java.util.List;
-import java.util.Set;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -48,22 +45,34 @@
 /** Tests for properties of component creators shared by both builders and factories. */
 @RunWith(Parameterized.class)
 public class ComponentCreatorTest extends ComponentCreatorTestHelper {
+  enum CompilerType {
+    JAVAC
+  }
+
+  private final CompilerType compilerType;
+  private final CompilerMode compilerMode;
+
   @Parameters(name = "compilerMode={0}, creatorKind={1}")
   public static Collection<Object[]> parameters() {
-    Set<List<Object>> params =
-        Sets.<Object>cartesianProduct(
-            immutableEnumSet(DEFAULT_MODE, FAST_INIT_MODE),
-            immutableEnumSet(COMPONENT_BUILDER, COMPONENT_FACTORY));
-    return ImmutableList.copyOf(Iterables.transform(params, Collection::toArray));
+    return ImmutableList.of(
+      new Object[]{DEFAULT_MODE, COMPONENT_BUILDER, JAVAC},
+      new Object[]{DEFAULT_MODE, COMPONENT_FACTORY, JAVAC},
+      new Object[]{FAST_INIT_MODE, COMPONENT_BUILDER, JAVAC},
+      new Object[]{FAST_INIT_MODE, COMPONENT_FACTORY, JAVAC});
   }
 
   public ComponentCreatorTest(
-      CompilerMode compilerMode, ComponentCreatorAnnotation componentCreatorAnnotation) {
+      CompilerMode compilerMode,
+      ComponentCreatorAnnotation componentCreatorAnnotation,
+      CompilerType compilerType) {
     super(compilerMode, componentCreatorAnnotation);
+    this.compilerMode = compilerMode;
+    this.compilerType = compilerType;
   }
 
   @Test
   public void testEmptyCreator() {
+    assume().that(compilerType).isEqualTo(JAVAC);
     JavaFileObject injectableTypeFile =
         JavaFileObjects.forSourceLines(
             "test.SomeInjectableType",
@@ -114,6 +123,7 @@ public void testEmptyCreator() {
 
   @Test
   public void testCanInstantiateModulesUserCannotSet() {
+    assume().that(compilerType).isEqualTo(JAVAC);
     JavaFileObject module =
         JavaFileObjects.forSourceLines(
             "test.TestModule",
@@ -311,6 +321,7 @@ public void testCreatorMissingFactoryMethodFails() {
 
   @Test
   public void testCreatorWithBindsInstanceNoStaticCreateGenerated() {
+    assume().that(compilerType).isEqualTo(JAVAC);
     JavaFileObject componentFile =
         javaFileBuilder("test.SimpleComponent")
             .addLines(
@@ -411,6 +422,7 @@ public void testCreatorWithBindsInstanceNoStaticCreateGenerated() {
 
   @Test
   public void testCreatorWithPrimitiveBindsInstance() {
+    assume().that(compilerType).isEqualTo(JAVAC);
     JavaFileObject componentFile =
         javaFileBuilder("test.SimpleComponent")
             .addLines(
@@ -780,6 +792,7 @@ public void testInheritedTwoFactoryMethodsFails() {
 
   @Test
   public void testMultipleSettersPerTypeFails() {
+    assume().that(compilerType).isEqualTo(JAVAC);
     JavaFileObject moduleFile =
         JavaFileObjects.forSourceLines(
             "test.TestModule",
@@ -838,6 +851,7 @@ public void testMultipleSettersPerTypeFails() {
 
   @Test
   public void testMultipleSettersPerTypeIncludingResolvedGenericsFails() {
+    assume().that(compilerType).isEqualTo(JAVAC);
     JavaFileObject moduleFile =
         JavaFileObjects.forSourceLines(
             "test.TestModule",
@@ -901,6 +915,7 @@ public void testMultipleSettersPerTypeIncludingResolvedGenericsFails() {
 
   @Test
   public void testExtraSettersFails() {
+    assume().that(compilerType).isEqualTo(JAVAC);
     JavaFileObject componentFile =
         javaFileBuilder("test.SimpleComponent")
             .addLines(
@@ -1033,6 +1048,7 @@ public void testMissingSettersFail() {
 
   @Test
   public void covariantFactoryMethodReturnType() {
+    assume().that(compilerType).isEqualTo(JAVAC);
     JavaFileObject foo =
         JavaFileObjects.forSourceLines(
             "test.Foo",
@@ -1073,6 +1089,7 @@ public void covariantFactoryMethodReturnType() {
 
   @Test
   public void covariantFactoryMethodReturnType_hasNewMethod() {
+    assume().that(compilerType).isEqualTo(JAVAC);
     JavaFileObject foo =
         JavaFileObjects.forSourceLines(
             "test.Foo",
@@ -1134,6 +1151,7 @@ public void covariantFactoryMethodReturnType_hasNewMethod() {
 
   @Test
   public void covariantFactoryMethodReturnType_hasNewMethod_factoryMethodInherited() {
+    assume().that(compilerType).isEqualTo(JAVAC);
     JavaFileObject foo =
         JavaFileObjects.forSourceLines(
             "test.Foo",
@@ -1251,4 +1269,13 @@ public void testGenericsOnInheritedFactoryMethodFails() {
         .inFile(componentFile)
         .onLineContaining(process("interface Builder"));
   }
+
+  /** Compiles the given files with the set compiler mode's javacopts. */
+  @Override
+  Compilation compile(JavaFileObject... files) {
+    ImmutableList.Builder<Object> options =
+        ImmutableList.builder().addAll(compilerMode.javacopts());
+
+    return daggerCompiler().withOptions(options.build()).compile(files);
+  }
 }
