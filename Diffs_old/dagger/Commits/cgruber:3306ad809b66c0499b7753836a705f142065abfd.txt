diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 32b71f861..ea1406b2d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -66,6 +66,7 @@
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.AnnotationValueVisitor;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.Name;
@@ -197,7 +198,7 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
           .addSnippet("}")
           .addSnippet("this.%s = %s;", builderField.name(), contributionName)
           .addSnippet("return this;");
-      if (Util.getNoArgsConstructor(contributionElement) == null) {
+      if (getNoArgsConstructor(contributionElement) == null) {
         requiresBuilder = true;
         buildMethod.body()
             .addSnippet("if (%s == null) {", builderField.name())
@@ -603,4 +604,17 @@ private boolean isNonProviderMap(ProvisionBinding binding) {
     }
     return false;
   }
+
+  private ExecutableElement getNoArgsConstructor(TypeElement type) {
+    for (Element enclosed : type.getEnclosedElements()) {
+      if (enclosed.getKind() != ElementKind.CONSTRUCTOR) {
+        continue;
+      }
+      ExecutableElement constructor = (ExecutableElement) enclosed;
+      if (constructor.getParameters().isEmpty()) {
+        return constructor;
+      }
+    }
+    return null;
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
index 586dfab1c..6cf1ced26 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
@@ -61,8 +61,8 @@
     for (TypeMirror moduleType : moduleTypes) {
       moduleType.accept(new SimpleTypeVisitor6<Void, Void>() {
         @Override
-        protected Void defaultAction(TypeMirror e, Void p) {
-          builder.addItem(Util.typeToString(e) + " is not a valid module type.", subject);
+        protected Void defaultAction(TypeMirror mirror, Void p) {
+          builder.addItem(mirror + " is not a valid module type.", subject);
           return null;
         }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 4104893eb..8082c912a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -18,37 +18,20 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.common.collect.Iterables;
-import dagger.internal.Keys;
-import java.lang.reflect.Method;
-import java.util.Arrays;
-import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.AnnotationValueVisitor;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.PackageElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.ErrorType;
-import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.type.TypeVariable;
-import javax.lang.model.type.WildcardType;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleAnnotationValueVisitor6;
-import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
-
 /**
  * Utilities for handling types in annotation processors
  */
@@ -56,338 +39,6 @@
   private Util() {
   }
 
-  public static PackageElement getPackage(Element type) {
-    while (type.getKind() != ElementKind.PACKAGE) {
-      type = type.getEnclosingElement();
-    }
-    return (PackageElement) type;
-  }
-
-  /**
-   * Returns the supertype, or {@code null} if the supertype is a platform
-   * class. This is intended for annotation processors that assume platform
-   * classes will never be annotated with application annotations.
-   */
-  public static TypeMirror getApplicationSupertype(TypeElement type) {
-    TypeMirror supertype = type.getSuperclass();
-    return Keys.isPlatformType(supertype.toString()) ? null : supertype;
-  }
-
-  /** Returns a fully qualified class name to complement {@code type}. */
-  public static String adapterName(TypeElement typeElement, String suffix) {
-    StringBuilder builder = new StringBuilder();
-    rawTypeToString(builder, typeElement, '$');
-    builder.append(suffix);
-    return builder.toString();
-  }
-
-  /** Returns a string for {@code type}. Primitive types are always boxed. */
-  public static String typeToString(TypeMirror type) {
-    StringBuilder result = new StringBuilder();
-    typeToString(type, result, '.');
-    return result.toString();
-  }
-
-  /** Returns a string for the raw type of {@code type}. Primitive types are always boxed. */
-  public static String rawTypeToString(TypeMirror type, char innerClassSeparator) {
-    if (!(type instanceof DeclaredType)) {
-      throw new IllegalArgumentException("Unexpected type: " + type);
-    }
-    StringBuilder result = new StringBuilder();
-    DeclaredType declaredType = (DeclaredType) type;
-    rawTypeToString(result, (TypeElement) declaredType.asElement(), innerClassSeparator);
-    return result.toString();
-  }
-
-  /**
-   * Appends a string for {@code type} to {@code result}. Primitive types are
-   * always boxed.
-   *
-   * @param innerClassSeparator either '.' or '$', which will appear in a
-   *     class name like "java.lang.Map.Entry" or "java.lang.Map$Entry".
-   *     Use '.' for references to existing types in code. Use '$' to define new
-   *     class names and for strings that will be used by runtime reflection.
-   */
-  public static void typeToString(final TypeMirror type, final StringBuilder result,
-      final char innerClassSeparator) {
-    type.accept(new SimpleTypeVisitor6<Void, Void>() {
-      @Override public Void visitDeclared(DeclaredType declaredType, Void v) {
-        TypeElement typeElement = (TypeElement) declaredType.asElement();
-        rawTypeToString(result, typeElement, innerClassSeparator);
-        List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();
-        if (!typeArguments.isEmpty()) {
-          result.append("<");
-          for (int i = 0; i < typeArguments.size(); i++) {
-            if (i != 0) {
-              result.append(", ");
-            }
-            typeToString(typeArguments.get(i), result, innerClassSeparator);
-          }
-          result.append(">");
-        }
-        return null;
-      }
-      @Override public Void visitPrimitive(PrimitiveType primitiveType, Void v) {
-        result.append(box((PrimitiveType) type).getName());
-        return null;
-      }
-      @Override public Void visitArray(ArrayType arrayType, Void v) {
-        TypeMirror type = arrayType.getComponentType();
-        if (type instanceof PrimitiveType) {
-          result.append(type.toString()); // Don't box, since this is an array.
-        } else {
-          typeToString(arrayType.getComponentType(), result, innerClassSeparator);
-        }
-        result.append("[]");
-        return null;
-      }
-      @Override public Void visitTypeVariable(TypeVariable typeVariable, Void v) {
-        result.append(typeVariable.asElement().getSimpleName());
-        return null;
-      }
-      @Override public Void visitError(ErrorType errorType, Void v) {
-        // Error type found, a type may not yet have been generated, but we need the type
-        // so we can generate the correct code in anticipation of the type being available
-        // to the compiler.
-
-        // Paramterized types which don't exist are returned as an error type whose name is "<any>"
-        if ("<any>".equals(errorType.toString())) {
-          throw new CodeGenerationIncompleteException(
-              "Type reported as <any> is likely a not-yet generated parameterized type.");
-        }
-        // TODO(user): Figure out a strategy for non-FQCN cases.
-        result.append(errorType.toString());
-        return null;
-      }
-      public Void visitWildcard(WildcardType wildcardType, Void v) {
-        result.append("?");
-        if (wildcardType.getExtendsBound() != null) {
-          result.append(" extends ");
-          typeToString(wildcardType.getExtendsBound(), result, innerClassSeparator);
-        } else if (wildcardType.getSuperBound() != null) {
-          result.append(" super ");
-          typeToString(wildcardType.getSuperBound(), result, innerClassSeparator);
-        }
-        return null;
-      }
-      @Override protected Void defaultAction(TypeMirror typeMirror, Void v) {
-        throw new UnsupportedOperationException(
-            "Unexpected TypeKind " + typeMirror.getKind() + " for "  + typeMirror);
-      }
-    }, null);
-  }
-
-  private static final AnnotationValueVisitor<Object, Void> VALUE_EXTRACTOR =
-      new SimpleAnnotationValueVisitor6<Object, Void>() {
-        @Override public Object visitString(String s, Void p) {
-          if ("<error>".equals(s)) {
-            throw new CodeGenerationIncompleteException("Unknown type returned as <error>.");
-          } else if ("<any>".equals(s)) {
-            throw new CodeGenerationIncompleteException("Unknown type returned as <any>.");
-          }
-          return s;
-        }
-        @Override public Object visitType(TypeMirror t, Void p) {
-          return t;
-        }
-        @Override protected Object defaultAction(Object o, Void v) {
-          return o;
-        }
-        @Override public Object visitArray(List<? extends AnnotationValue> values, Void v) {
-          Object[] result = new Object[values.size()];
-          for (int i = 0; i < values.size(); i++) {
-            result[i] = values.get(i).accept(this, null);
-          }
-          return result;
-        }
-      };
-
-  /**
-   * Returns the annotation on {@code element} formatted as a Map. This returns
-   * a Map rather than an instance of the annotation interface to work-around
-   * the fact that Class and Class[] fields won't work at code generation time.
-   * See http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5089128
-   */
-  public static Map<String, Object> getAnnotation(Class<?> annotationType, Element element) {
-    for (AnnotationMirror annotation : element.getAnnotationMirrors()) {
-      if (!rawTypeToString(annotation.getAnnotationType(), '$')
-          .equals(annotationType.getName())) {
-        continue;
-      }
-
-      Map<String, Object> result = new LinkedHashMap<String, Object>();
-      for (Method m : annotationType.getMethods()) {
-        result.put(m.getName(), m.getDefaultValue());
-      }
-      for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> e
-          : annotation.getElementValues().entrySet()) {
-        String name = e.getKey().getSimpleName().toString();
-        Object value = e.getValue().accept(VALUE_EXTRACTOR, null);
-        Object defaultValue = result.get(name);
-        if (!lenientIsInstance(defaultValue.getClass(), value)) {
-          throw new IllegalStateException(String.format(
-              "Value of %s.%s is a %s but expected a %s\n    value: %s",
-              annotationType, name, value.getClass().getName(), defaultValue.getClass().getName(),
-              value instanceof Object[] ? Arrays.toString((Object[]) value) : value));
-        }
-        result.put(name, value);
-      }
-      return result;
-    }
-    return null; // Annotation not found.
-  }
-
-  /**
-   * Returns true if {@code value} can be assigned to {@code expectedClass}.
-   * Like {@link Class#isInstance} but more lenient for {@code Class<?>} values.
-   */
-  private static boolean lenientIsInstance(Class<?> expectedClass, Object value) {
-    if (expectedClass.isArray()) {
-      Class<?> componentType = expectedClass.getComponentType();
-      if (!(value instanceof Object[])) {
-        return false;
-      }
-      for (Object element : (Object[]) value) {
-        if (!lenientIsInstance(componentType, element)) return false;
-      }
-      return true;
-    } else if (expectedClass == Class.class) {
-      return value instanceof TypeMirror;
-    } else {
-      return expectedClass == value.getClass();
-    }
-  }
-
-  // TODO(user): better format for other types of elements?
-  static String elementToString(Element element) {
-    switch (element.getKind()) {
-      case FIELD:
-      // fall through
-      case CONSTRUCTOR:
-      // fall through
-      case METHOD:
-        return element.getEnclosingElement() + "." + element;
-      default:
-        return element.toString();
-    }
-  }
-
-  static void rawTypeToString(StringBuilder result, TypeElement type,
-      char innerClassSeparator) {
-    String packageName = getPackage(type).getQualifiedName().toString();
-    String qualifiedName = type.getQualifiedName().toString();
-    if (packageName.isEmpty()) {
-        result.append(qualifiedName.replace('.', innerClassSeparator));
-    } else {
-      result.append(packageName);
-      result.append('.');
-      result.append(
-          qualifiedName.substring(packageName.length() + 1).replace('.', innerClassSeparator));
-    }
-  }
-
-  private static Class<?> box(PrimitiveType primitiveType) {
-    switch (primitiveType.getKind()) {
-      case BYTE:
-        return Byte.class;
-      case SHORT:
-        return Short.class;
-      case INT:
-        return Integer.class;
-      case LONG:
-        return Long.class;
-      case FLOAT:
-        return Float.class;
-      case DOUBLE:
-        return Double.class;
-      case BOOLEAN:
-        return Boolean.class;
-      case CHAR:
-        return Character.class;
-      case VOID:
-        return Void.class;
-      default:
-        throw new AssertionError();
-    }
-  }
-
-  /**
-   * Returns the no-args constructor for {@code type}, or null if no such
-   * constructor exists.
-   */
-  public static ExecutableElement getNoArgsConstructor(TypeElement type) {
-    for (Element enclosed : type.getEnclosedElements()) {
-      if (enclosed.getKind() != ElementKind.CONSTRUCTOR) {
-        continue;
-      }
-      ExecutableElement constructor = (ExecutableElement) enclosed;
-      if (constructor.getParameters().isEmpty()) {
-        return constructor;
-      }
-    }
-    return null;
-  }
-
-  /**
-   * Returns true if generated code can invoke {@code constructor}. That is, if
-   * the constructor is non-private and its enclosing class is either a
-   * top-level class or a static nested class.
-   */
-  public static boolean isCallableConstructor(ExecutableElement constructor) {
-    if (constructor.getModifiers().contains(Modifier.PRIVATE)) {
-      return false;
-    }
-    TypeElement type = (TypeElement) constructor.getEnclosingElement();
-    return type.getEnclosingElement().getKind() == ElementKind.PACKAGE
-        || type.getModifiers().contains(Modifier.STATIC);
-  }
-
-  /**
-   * Returns a user-presentable string like {@code coffee.CoffeeModule}.
-   */
-  public static String className(ExecutableElement method) {
-    return ((TypeElement) method.getEnclosingElement()).getQualifiedName().toString();
-  }
-
-  public static boolean isInterface(TypeMirror typeMirror) {
-    return typeMirror instanceof DeclaredType
-        && ((DeclaredType) typeMirror).asElement().getKind() == ElementKind.INTERFACE;
-  }
-
-  static boolean isStatic(Element element) {
-    for (Modifier modifier : element.getModifiers()) {
-      if (modifier.equals(Modifier.STATIC)) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  static boolean isValidJavaIdentifier(String possibleIdentifier) {
-    checkNotNull(possibleIdentifier);
-    checkArgument(!possibleIdentifier.isEmpty());
-    if (!Character.isJavaIdentifierStart(possibleIdentifier.charAt(0))) {
-      return false;
-    }
-    for (int i = 1; i < possibleIdentifier.length(); i++) {
-      if (!Character.isJavaIdentifierPart(possibleIdentifier.charAt(i))) {
-        return false;
-      }
-    }
-    return true;
-  }
-
-  /**
-   * An exception thrown when a type is not extant (returns as an error type),
-   * usually as a result of another processor not having yet generated its types upon
-   * which a dagger-annotated type depends.
-   */
-  final static class CodeGenerationIncompleteException extends IllegalStateException {
-    public CodeGenerationIncompleteException(String s) {
-      super(s);
-    }
-  }
-
   /**
    * Returns the value type for a {@link Map} type like Map<K, Provider<V>>}.
    */
diff --git a/compiler/src/main/java/dagger/internal/codegen/AdapterJavadocs.java b/compiler/src/main/java/dagger/internal/codegen/dagger1/AdapterJavadocs.java
similarity index 98%
rename from compiler/src/main/java/dagger/internal/codegen/AdapterJavadocs.java
rename to compiler/src/main/java/dagger/internal/codegen/dagger1/AdapterJavadocs.java
index 5f0b52af6..bd289ec31 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AdapterJavadocs.java
+++ b/compiler/src/main/java/dagger/internal/codegen/dagger1/AdapterJavadocs.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.internal.codegen.dagger1;
 
 /**
  * Utility class providing some commonly used boilerplate between {@code InjectAdapterProcessor}
diff --git a/compiler/src/main/java/dagger/internal/codegen/GeneratorKeys.java b/compiler/src/main/java/dagger/internal/codegen/dagger1/GeneratorKeys.java
similarity index 95%
rename from compiler/src/main/java/dagger/internal/codegen/GeneratorKeys.java
rename to compiler/src/main/java/dagger/internal/codegen/dagger1/GeneratorKeys.java
index 17f1800b5..cddc4390f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GeneratorKeys.java
+++ b/compiler/src/main/java/dagger/internal/codegen/dagger1/GeneratorKeys.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.internal.codegen.dagger1;
 
 import java.util.List;
 import java.util.Map;
@@ -25,8 +25,8 @@
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.TypeMirror;
 
-import static dagger.internal.codegen.Util.rawTypeToString;
-import static dagger.internal.codegen.Util.typeToString;
+import static dagger.internal.codegen.dagger1.Util.rawTypeToString;
+import static dagger.internal.codegen.dagger1.Util.typeToString;
 
 /**
  * Creates keys using javac's mirror APIs. Unlike {@code Keys}, this class uses
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisErrorHandler.java b/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisErrorHandler.java
similarity index 97%
rename from compiler/src/main/java/dagger/internal/codegen/GraphAnalysisErrorHandler.java
rename to compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisErrorHandler.java
index 121bbaebd..d7ba79704 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisErrorHandler.java
+++ b/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisErrorHandler.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.internal.codegen.dagger1;
 
 import dagger.internal.Linker;
 import java.util.List;
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisInjectBinding.java b/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisInjectBinding.java
similarity index 97%
rename from compiler/src/main/java/dagger/internal/codegen/GraphAnalysisInjectBinding.java
rename to compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisInjectBinding.java
index cbda5a496..4bd7106f3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisInjectBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisInjectBinding.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.internal.codegen.dagger1;
 
 import dagger.internal.Binding;
 import dagger.internal.Linker;
@@ -31,7 +31,7 @@
 import javax.lang.model.type.TypeMirror;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static dagger.internal.codegen.Util.getApplicationSupertype;
+import static dagger.internal.codegen.dagger1.Util.getApplicationSupertype;
 
 /**
  * A build time binding that injects the constructor and fields of a class.
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisLoader.java b/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisLoader.java
similarity index 98%
rename from compiler/src/main/java/dagger/internal/codegen/GraphAnalysisLoader.java
rename to compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisLoader.java
index c3cd022d9..78ac9ecd9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisLoader.java
+++ b/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisLoader.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.internal.codegen.dagger1;
 
 import dagger.internal.Binding;
 import dagger.internal.Loader;
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java b/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisProcessor.java
similarity index 97%
rename from compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
rename to compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisProcessor.java
index f577a399e..a2ee6a642 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisProcessor.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.internal.codegen.dagger1;
 
 import com.google.auto.service.AutoService;
 import dagger.Module;
@@ -25,7 +25,7 @@
 import dagger.internal.ProblemDetector;
 import dagger.internal.ProvidesBinding;
 import dagger.internal.SetBinding;
-import dagger.internal.codegen.Util.CodeGenerationIncompleteException;
+import dagger.internal.codegen.dagger1.Util.CodeGenerationIncompleteException;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.io.StringWriter;
@@ -61,10 +61,10 @@
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static dagger.Provides.Type.SET;
 import static dagger.Provides.Type.SET_VALUES;
-import static dagger.internal.codegen.Util.className;
-import static dagger.internal.codegen.Util.getAnnotation;
-import static dagger.internal.codegen.Util.getPackage;
-import static dagger.internal.codegen.Util.isInterface;
+import static dagger.internal.codegen.dagger1.Util.className;
+import static dagger.internal.codegen.dagger1.Util.getAnnotation;
+import static dagger.internal.codegen.dagger1.Util.getPackage;
+import static dagger.internal.codegen.dagger1.Util.isInterface;
 import static java.util.Arrays.asList;
 
 /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisStaticInjection.java b/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisStaticInjection.java
similarity index 93%
rename from compiler/src/main/java/dagger/internal/codegen/GraphAnalysisStaticInjection.java
rename to compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisStaticInjection.java
index dee437651..5ca2d422f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisStaticInjection.java
+++ b/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisStaticInjection.java
@@ -13,14 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.internal.codegen.dagger1;
 
 import dagger.internal.Linker;
 import dagger.internal.StaticInjection;
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
 
-import static dagger.internal.codegen.Util.isStatic;
+import static dagger.internal.codegen.dagger1.Util.isStatic;
 
 public final class GraphAnalysisStaticInjection extends StaticInjection {
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java b/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphVisualizer.java
similarity index 99%
rename from compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java
rename to compiler/src/main/java/dagger/internal/codegen/dagger1/GraphVisualizer.java
index a0fe29ce7..e0c251c9c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java
+++ b/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphVisualizer.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.internal.codegen.dagger1;
 
 import dagger.internal.Binding;
 import java.io.IOException;
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphVizWriter.java b/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphVizWriter.java
similarity index 99%
rename from compiler/src/main/java/dagger/internal/codegen/GraphVizWriter.java
rename to compiler/src/main/java/dagger/internal/codegen/dagger1/GraphVizWriter.java
index d149d167e..624d1963e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphVizWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphVizWriter.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.internal.codegen.dagger1;
 
 import com.squareup.javawriter.JavaWriter;
 import java.io.Closeable;
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/dagger1/InjectAdapterProcessor.java
similarity index 97%
rename from compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
rename to compiler/src/main/java/dagger/internal/codegen/dagger1/InjectAdapterProcessor.java
index 955d5bd64..7c3b9e271 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/dagger1/InjectAdapterProcessor.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.internal.codegen.dagger1;
 
 import com.google.auto.common.SuperficialValidation;
 import com.google.auto.service.AutoService;
@@ -50,14 +50,14 @@
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static dagger.internal.Keys.isPlatformType;
-import static dagger.internal.codegen.AdapterJavadocs.bindingTypeDocs;
-import static dagger.internal.codegen.Util.adapterName;
-import static dagger.internal.codegen.Util.elementToString;
-import static dagger.internal.codegen.Util.getNoArgsConstructor;
-import static dagger.internal.codegen.Util.getPackage;
-import static dagger.internal.codegen.Util.isCallableConstructor;
-import static dagger.internal.codegen.Util.rawTypeToString;
-import static dagger.internal.codegen.Util.typeToString;
+import static dagger.internal.codegen.dagger1.AdapterJavadocs.bindingTypeDocs;
+import static dagger.internal.codegen.dagger1.Util.adapterName;
+import static dagger.internal.codegen.dagger1.Util.elementToString;
+import static dagger.internal.codegen.dagger1.Util.getNoArgsConstructor;
+import static dagger.internal.codegen.dagger1.Util.getPackage;
+import static dagger.internal.codegen.dagger1.Util.isCallableConstructor;
+import static dagger.internal.codegen.dagger1.Util.rawTypeToString;
+import static dagger.internal.codegen.dagger1.Util.typeToString;
 import static dagger.internal.loaders.GeneratedAdapters.INJECT_ADAPTER_SUFFIX;
 import static dagger.internal.loaders.GeneratedAdapters.STATIC_INJECTION_SUFFIX;
 import static javax.lang.model.element.Modifier.ABSTRACT;
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/dagger1/ModuleAdapterProcessor.java
similarity index 96%
rename from compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
rename to compiler/src/main/java/dagger/internal/codegen/dagger1/ModuleAdapterProcessor.java
index 63f78068a..3ec8b41e8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/dagger1/ModuleAdapterProcessor.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.internal.codegen.dagger1;
 
 import com.google.auto.service.AutoService;
 import com.squareup.javawriter.JavaWriter;
@@ -26,7 +26,7 @@
 import dagger.internal.ModuleAdapter;
 import dagger.internal.ProvidesBinding;
 import dagger.internal.SetBinding;
-import dagger.internal.codegen.Util.CodeGenerationIncompleteException;
+import dagger.internal.codegen.dagger1.Util.CodeGenerationIncompleteException;
 import java.io.IOException;
 import java.io.StringWriter;
 import java.io.Writer;
@@ -64,15 +64,15 @@
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static dagger.Provides.Type.SET;
 import static dagger.Provides.Type.SET_VALUES;
-import static dagger.internal.codegen.AdapterJavadocs.bindingTypeDocs;
-import static dagger.internal.codegen.Util.adapterName;
-import static dagger.internal.codegen.Util.elementToString;
-import static dagger.internal.codegen.Util.getAnnotation;
-import static dagger.internal.codegen.Util.getNoArgsConstructor;
-import static dagger.internal.codegen.Util.getPackage;
-import static dagger.internal.codegen.Util.isCallableConstructor;
-import static dagger.internal.codegen.Util.isInterface;
-import static dagger.internal.codegen.Util.typeToString;
+import static dagger.internal.codegen.dagger1.AdapterJavadocs.bindingTypeDocs;
+import static dagger.internal.codegen.dagger1.Util.adapterName;
+import static dagger.internal.codegen.dagger1.Util.elementToString;
+import static dagger.internal.codegen.dagger1.Util.getAnnotation;
+import static dagger.internal.codegen.dagger1.Util.getNoArgsConstructor;
+import static dagger.internal.codegen.dagger1.Util.getPackage;
+import static dagger.internal.codegen.dagger1.Util.isCallableConstructor;
+import static dagger.internal.codegen.dagger1.Util.isInterface;
+import static dagger.internal.codegen.dagger1.Util.typeToString;
 import static dagger.internal.loaders.GeneratedAdapters.MODULE_ADAPTER_SUFFIX;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
diff --git a/compiler/src/main/java/dagger/internal/codegen/dagger1/Util.java b/compiler/src/main/java/dagger/internal/codegen/dagger1/Util.java
new file mode 100644
index 000000000..1afad0dcb
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/dagger1/Util.java
@@ -0,0 +1,386 @@
+/*
+ * Copyright (C) 2013 Google, Inc.
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen.dagger1;
+
+import dagger.internal.Keys;
+import java.lang.reflect.Method;
+import java.util.Arrays;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.AnnotationValueVisitor;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.PackageElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.ArrayType;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ErrorType;
+import javax.lang.model.type.PrimitiveType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.TypeVariable;
+import javax.lang.model.type.WildcardType;
+import javax.lang.model.util.SimpleAnnotationValueVisitor6;
+import javax.lang.model.util.SimpleTypeVisitor6;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+
+/**
+ * Utilities for handling types in annotation processors
+ */
+final class Util {
+  private Util() {
+  }
+
+  public static PackageElement getPackage(Element type) {
+    while (type.getKind() != ElementKind.PACKAGE) {
+      type = type.getEnclosingElement();
+    }
+    return (PackageElement) type;
+  }
+
+  /**
+   * Returns the supertype, or {@code null} if the supertype is a platform
+   * class. This is intended for annotation processors that assume platform
+   * classes will never be annotated with application annotations.
+   */
+  public static TypeMirror getApplicationSupertype(TypeElement type) {
+    TypeMirror supertype = type.getSuperclass();
+    return Keys.isPlatformType(supertype.toString()) ? null : supertype;
+  }
+
+  /** Returns a fully qualified class name to complement {@code type}. */
+  public static String adapterName(TypeElement typeElement, String suffix) {
+    StringBuilder builder = new StringBuilder();
+    rawTypeToString(builder, typeElement, '$');
+    builder.append(suffix);
+    return builder.toString();
+  }
+
+  /** Returns a string for {@code type}. Primitive types are always boxed. */
+  public static String typeToString(TypeMirror type) {
+    StringBuilder result = new StringBuilder();
+    typeToString(type, result, '.');
+    return result.toString();
+  }
+
+  /** Returns a string for the raw type of {@code type}. Primitive types are always boxed. */
+  public static String rawTypeToString(TypeMirror type, char innerClassSeparator) {
+    if (!(type instanceof DeclaredType)) {
+      throw new IllegalArgumentException("Unexpected type: " + type);
+    }
+    StringBuilder result = new StringBuilder();
+    DeclaredType declaredType = (DeclaredType) type;
+    rawTypeToString(result, (TypeElement) declaredType.asElement(), innerClassSeparator);
+    return result.toString();
+  }
+
+  /**
+   * Appends a string for {@code type} to {@code result}. Primitive types are
+   * always boxed.
+   *
+   * @param innerClassSeparator either '.' or '$', which will appear in a
+   *     class name like "java.lang.Map.Entry" or "java.lang.Map$Entry".
+   *     Use '.' for references to existing types in code. Use '$' to define new
+   *     class names and for strings that will be used by runtime reflection.
+   */
+  public static void typeToString(final TypeMirror type, final StringBuilder result,
+      final char innerClassSeparator) {
+    type.accept(new SimpleTypeVisitor6<Void, Void>() {
+      @Override public Void visitDeclared(DeclaredType declaredType, Void v) {
+        TypeElement typeElement = (TypeElement) declaredType.asElement();
+        rawTypeToString(result, typeElement, innerClassSeparator);
+        List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();
+        if (!typeArguments.isEmpty()) {
+          result.append("<");
+          for (int i = 0; i < typeArguments.size(); i++) {
+            if (i != 0) {
+              result.append(", ");
+            }
+            typeToString(typeArguments.get(i), result, innerClassSeparator);
+          }
+          result.append(">");
+        }
+        return null;
+      }
+      @Override public Void visitPrimitive(PrimitiveType primitiveType, Void v) {
+        result.append(box((PrimitiveType) type).getName());
+        return null;
+      }
+      @Override public Void visitArray(ArrayType arrayType, Void v) {
+        TypeMirror type = arrayType.getComponentType();
+        if (type instanceof PrimitiveType) {
+          result.append(type.toString()); // Don't box, since this is an array.
+        } else {
+          typeToString(arrayType.getComponentType(), result, innerClassSeparator);
+        }
+        result.append("[]");
+        return null;
+      }
+      @Override public Void visitTypeVariable(TypeVariable typeVariable, Void v) {
+        result.append(typeVariable.asElement().getSimpleName());
+        return null;
+      }
+      @Override public Void visitError(ErrorType errorType, Void v) {
+        // Error type found, a type may not yet have been generated, but we need the type
+        // so we can generate the correct code in anticipation of the type being available
+        // to the compiler.
+
+        // Paramterized types which don't exist are returned as an error type whose name is "<any>"
+        if ("<any>".equals(errorType.toString())) {
+          throw new CodeGenerationIncompleteException(
+              "Type reported as <any> is likely a not-yet generated parameterized type.");
+        }
+        // TODO(user): Figure out a strategy for non-FQCN cases.
+        result.append(errorType.toString());
+        return null;
+      }
+      public Void visitWildcard(WildcardType wildcardType, Void v) {
+        result.append("?");
+        if (wildcardType.getExtendsBound() != null) {
+          result.append(" extends ");
+          typeToString(wildcardType.getExtendsBound(), result, innerClassSeparator);
+        } else if (wildcardType.getSuperBound() != null) {
+          result.append(" super ");
+          typeToString(wildcardType.getSuperBound(), result, innerClassSeparator);
+        }
+        return null;
+      }
+      @Override protected Void defaultAction(TypeMirror typeMirror, Void v) {
+        throw new UnsupportedOperationException(
+            "Unexpected TypeKind " + typeMirror.getKind() + " for "  + typeMirror);
+      }
+    }, null);
+  }
+
+  private static final AnnotationValueVisitor<Object, Void> VALUE_EXTRACTOR =
+      new SimpleAnnotationValueVisitor6<Object, Void>() {
+        @Override public Object visitString(String s, Void p) {
+          if ("<error>".equals(s)) {
+            throw new CodeGenerationIncompleteException("Unknown type returned as <error>.");
+          } else if ("<any>".equals(s)) {
+            throw new CodeGenerationIncompleteException("Unknown type returned as <any>.");
+          }
+          return s;
+        }
+        @Override public Object visitType(TypeMirror t, Void p) {
+          return t;
+        }
+        @Override protected Object defaultAction(Object o, Void v) {
+          return o;
+        }
+        @Override public Object visitArray(List<? extends AnnotationValue> values, Void v) {
+          Object[] result = new Object[values.size()];
+          for (int i = 0; i < values.size(); i++) {
+            result[i] = values.get(i).accept(this, null);
+          }
+          return result;
+        }
+      };
+
+  /**
+   * Returns the annotation on {@code element} formatted as a Map. This returns
+   * a Map rather than an instance of the annotation interface to work-around
+   * the fact that Class and Class[] fields won't work at code generation time.
+   * See http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5089128
+   */
+  public static Map<String, Object> getAnnotation(Class<?> annotationType, Element element) {
+    for (AnnotationMirror annotation : element.getAnnotationMirrors()) {
+      if (!rawTypeToString(annotation.getAnnotationType(), '$')
+          .equals(annotationType.getName())) {
+        continue;
+      }
+
+      Map<String, Object> result = new LinkedHashMap<String, Object>();
+      for (Method m : annotationType.getMethods()) {
+        result.put(m.getName(), m.getDefaultValue());
+      }
+      for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> e
+          : annotation.getElementValues().entrySet()) {
+        String name = e.getKey().getSimpleName().toString();
+        Object value = e.getValue().accept(VALUE_EXTRACTOR, null);
+        Object defaultValue = result.get(name);
+        if (!lenientIsInstance(defaultValue.getClass(), value)) {
+          throw new IllegalStateException(String.format(
+              "Value of %s.%s is a %s but expected a %s\n    value: %s",
+              annotationType, name, value.getClass().getName(), defaultValue.getClass().getName(),
+              value instanceof Object[] ? Arrays.toString((Object[]) value) : value));
+        }
+        result.put(name, value);
+      }
+      return result;
+    }
+    return null; // Annotation not found.
+  }
+
+  /**
+   * Returns true if {@code value} can be assigned to {@code expectedClass}.
+   * Like {@link Class#isInstance} but more lenient for {@code Class<?>} values.
+   */
+  private static boolean lenientIsInstance(Class<?> expectedClass, Object value) {
+    if (expectedClass.isArray()) {
+      Class<?> componentType = expectedClass.getComponentType();
+      if (!(value instanceof Object[])) {
+        return false;
+      }
+      for (Object element : (Object[]) value) {
+        if (!lenientIsInstance(componentType, element)) return false;
+      }
+      return true;
+    } else if (expectedClass == Class.class) {
+      return value instanceof TypeMirror;
+    } else {
+      return expectedClass == value.getClass();
+    }
+  }
+
+  // TODO(user): better format for other types of elements?
+  static String elementToString(Element element) {
+    switch (element.getKind()) {
+      case FIELD:
+      // fall through
+      case CONSTRUCTOR:
+      // fall through
+      case METHOD:
+        return element.getEnclosingElement() + "." + element;
+      default:
+        return element.toString();
+    }
+  }
+
+  static void rawTypeToString(StringBuilder result, TypeElement type,
+      char innerClassSeparator) {
+    String packageName = getPackage(type).getQualifiedName().toString();
+    String qualifiedName = type.getQualifiedName().toString();
+    if (packageName.isEmpty()) {
+        result.append(qualifiedName.replace('.', innerClassSeparator));
+    } else {
+      result.append(packageName);
+      result.append('.');
+      result.append(
+          qualifiedName.substring(packageName.length() + 1).replace('.', innerClassSeparator));
+    }
+  }
+
+  private static Class<?> box(PrimitiveType primitiveType) {
+    switch (primitiveType.getKind()) {
+      case BYTE:
+        return Byte.class;
+      case SHORT:
+        return Short.class;
+      case INT:
+        return Integer.class;
+      case LONG:
+        return Long.class;
+      case FLOAT:
+        return Float.class;
+      case DOUBLE:
+        return Double.class;
+      case BOOLEAN:
+        return Boolean.class;
+      case CHAR:
+        return Character.class;
+      case VOID:
+        return Void.class;
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  /**
+   * Returns the no-args constructor for {@code type}, or null if no such
+   * constructor exists.
+   */
+  public static ExecutableElement getNoArgsConstructor(TypeElement type) {
+    for (Element enclosed : type.getEnclosedElements()) {
+      if (enclosed.getKind() != ElementKind.CONSTRUCTOR) {
+        continue;
+      }
+      ExecutableElement constructor = (ExecutableElement) enclosed;
+      if (constructor.getParameters().isEmpty()) {
+        return constructor;
+      }
+    }
+    return null;
+  }
+
+  /**
+   * Returns true if generated code can invoke {@code constructor}. That is, if
+   * the constructor is non-private and its enclosing class is either a
+   * top-level class or a static nested class.
+   */
+  public static boolean isCallableConstructor(ExecutableElement constructor) {
+    if (constructor.getModifiers().contains(Modifier.PRIVATE)) {
+      return false;
+    }
+    TypeElement type = (TypeElement) constructor.getEnclosingElement();
+    return type.getEnclosingElement().getKind() == ElementKind.PACKAGE
+        || type.getModifiers().contains(Modifier.STATIC);
+  }
+
+  /**
+   * Returns a user-presentable string like {@code coffee.CoffeeModule}.
+   */
+  public static String className(ExecutableElement method) {
+    return ((TypeElement) method.getEnclosingElement()).getQualifiedName().toString();
+  }
+
+  public static boolean isInterface(TypeMirror typeMirror) {
+    return typeMirror instanceof DeclaredType
+        && ((DeclaredType) typeMirror).asElement().getKind() == ElementKind.INTERFACE;
+  }
+
+  static boolean isStatic(Element element) {
+    for (Modifier modifier : element.getModifiers()) {
+      if (modifier.equals(Modifier.STATIC)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  static boolean isValidJavaIdentifier(String possibleIdentifier) {
+    checkNotNull(possibleIdentifier);
+    checkArgument(!possibleIdentifier.isEmpty());
+    if (!Character.isJavaIdentifierStart(possibleIdentifier.charAt(0))) {
+      return false;
+    }
+    for (int i = 1; i < possibleIdentifier.length(); i++) {
+      if (!Character.isJavaIdentifierPart(possibleIdentifier.charAt(i))) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  /**
+   * An exception thrown when a type is not extant (returns as an error type),
+   * usually as a result of another processor not having yet generated its types upon
+   * which a dagger-annotated type depends.
+   */
+  final static class CodeGenerationIncompleteException extends IllegalStateException {
+    public CodeGenerationIncompleteException(String s) {
+      super(s);
+    }
+  }
+
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ValidationProcessor.java b/compiler/src/main/java/dagger/internal/codegen/dagger1/ValidationProcessor.java
similarity index 97%
rename from compiler/src/main/java/dagger/internal/codegen/ValidationProcessor.java
rename to compiler/src/main/java/dagger/internal/codegen/dagger1/ValidationProcessor.java
index 75cf77a40..e58e1a080 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ValidationProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/dagger1/ValidationProcessor.java
@@ -14,12 +14,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.internal.codegen.dagger1;
 
 import com.google.auto.service.AutoService;
 import dagger.Module;
 import dagger.Provides;
-import dagger.internal.codegen.Util.CodeGenerationIncompleteException;
+import dagger.internal.codegen.dagger1.Util.CodeGenerationIncompleteException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.LinkedHashMap;
@@ -41,7 +41,7 @@
 import javax.tools.Diagnostic;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static dagger.internal.codegen.Util.elementToString;
+import static dagger.internal.codegen.dagger1.Util.elementToString;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.ElementKind.METHOD;
 import static javax.lang.model.element.Modifier.ABSTRACT;
diff --git a/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
similarity index 99%
rename from compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java
rename to compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
index ca8f7ec87..29675bb16 100644
--- a/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
@@ -40,7 +40,7 @@
 
 @RunWith(JUnit4.class)
 // TODO(gak): add tests for generation in the default package.
-public final class InjectProcessorTest {
+public final class InjectConstructorFactoryGeneratorTest {
   private static final JavaFileObject QUALIFIER_A =
       JavaFileObjects.forSourceLines("test.QualifierA",
           "package test;",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
similarity index 99%
rename from compiler/src/test/java/dagger/internal/codegen/ModuleProcessorTest.java
rename to compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index 1c06564ee..b1bb0ef43 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -37,7 +37,7 @@
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_WITH_SAME_NAME;
 
 @RunWith(JUnit4.class)
-public class ModuleProcessorTest {
+public class ModuleFactoryGeneratorTest {
   // TODO(gak): add tests for invalid combinations of scope and qualifier annotations like we have
   // for @Inject
 
diff --git a/compiler/src/test/java/dagger/internal/codegen/DotWriterTest.java b/compiler/src/test/java/dagger/internal/codegen/dagger1/DotWriterTest.java
similarity index 98%
rename from compiler/src/test/java/dagger/internal/codegen/DotWriterTest.java
rename to compiler/src/test/java/dagger/internal/codegen/dagger1/DotWriterTest.java
index e1ce8e261..5eecefbfc 100644
--- a/compiler/src/test/java/dagger/internal/codegen/DotWriterTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/dagger1/DotWriterTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.internal.codegen.dagger1;
 
 import java.io.IOException;
 import java.io.StringWriter;
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphVisualizerTest.java b/compiler/src/test/java/dagger/internal/codegen/dagger1/GraphVisualizerTest.java
similarity index 98%
rename from compiler/src/test/java/dagger/internal/codegen/GraphVisualizerTest.java
rename to compiler/src/test/java/dagger/internal/codegen/dagger1/GraphVisualizerTest.java
index e511c65ca..8afd7b9bc 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphVisualizerTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/dagger1/GraphVisualizerTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.internal.codegen.dagger1;
 
 import dagger.internal.Keys;
 import java.lang.reflect.Field;
diff --git a/compiler/src/test/java/dagger/testing/it/BuildLogValidator.java b/compiler/src/test/java/dagger/testing/it/BuildLogValidator.java
index 9eb15cfe4..ebd11b68e 100644
--- a/compiler/src/test/java/dagger/testing/it/BuildLogValidator.java
+++ b/compiler/src/test/java/dagger/testing/it/BuildLogValidator.java
@@ -22,6 +22,7 @@
 import java.nio.channels.FileChannel;
 import java.nio.charset.Charset;
 
+// TODO(user) remove when invoker tests are deleted.
 public class BuildLogValidator {
 
   /**
diff --git a/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/dagger1/InjectAdapterGenerationTest.java
similarity index 95%
rename from compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
rename to compiler/src/test/java/dagger/tests/integration/codegen/dagger1/InjectAdapterGenerationTest.java
index 8dacf9592..257f99d8e 100644
--- a/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/codegen/dagger1/InjectAdapterGenerationTest.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.tests.integration.codegen;
+package dagger.tests.integration.codegen.dagger1;
 
 import com.google.common.base.Joiner;
 import com.google.testing.compile.JavaFileObjects;
@@ -25,7 +25,7 @@
 
 import static com.google.common.truth.Truth.assert_;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
+import static dagger.tests.integration.dagger1.ProcessorTestUtils.daggerProcessors;
 
 @RunWith(JUnit4.class)
 public final class InjectAdapterGenerationTest {
diff --git a/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/dagger1/ModuleAdapterGenerationTest.java
similarity index 98%
rename from compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
rename to compiler/src/test/java/dagger/tests/integration/codegen/dagger1/ModuleAdapterGenerationTest.java
index d4f6ec639..17dfa7ce0 100644
--- a/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/codegen/dagger1/ModuleAdapterGenerationTest.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.tests.integration.codegen;
+package dagger.tests.integration.codegen.dagger1;
 
 import com.google.common.base.Joiner;
 import com.google.testing.compile.JavaFileObjects;
@@ -26,7 +26,7 @@
 import static com.google.common.truth.Truth.assert_;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
+import static dagger.tests.integration.dagger1.ProcessorTestUtils.daggerProcessors;
 import static java.util.Arrays.asList;
 
 @RunWith(JUnit4.class)
diff --git a/compiler/src/test/java/dagger/tests/integration/ProcessorTestUtils.java b/compiler/src/test/java/dagger/tests/integration/dagger1/ProcessorTestUtils.java
similarity index 77%
rename from compiler/src/test/java/dagger/tests/integration/ProcessorTestUtils.java
rename to compiler/src/test/java/dagger/tests/integration/dagger1/ProcessorTestUtils.java
index 12ff02dda..ea4c6f6d5 100644
--- a/compiler/src/test/java/dagger/tests/integration/ProcessorTestUtils.java
+++ b/compiler/src/test/java/dagger/tests/integration/dagger1/ProcessorTestUtils.java
@@ -14,12 +14,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.tests.integration;
+package dagger.tests.integration.dagger1;
 
-import dagger.internal.codegen.GraphAnalysisProcessor;
-import dagger.internal.codegen.InjectAdapterProcessor;
-import dagger.internal.codegen.ModuleAdapterProcessor;
-import dagger.internal.codegen.ValidationProcessor;
+import dagger.internal.codegen.dagger1.GraphAnalysisProcessor;
+import dagger.internal.codegen.dagger1.InjectAdapterProcessor;
+import dagger.internal.codegen.dagger1.ModuleAdapterProcessor;
+import dagger.internal.codegen.dagger1.ValidationProcessor;
 import java.util.Arrays;
 import javax.annotation.processing.Processor;
 
diff --git a/compiler/src/test/java/dagger/tests/integration/operation/FailureModeErrorsTest.java b/compiler/src/test/java/dagger/tests/integration/operation/dagger1/FailureModeErrorsTest.java
similarity index 87%
rename from compiler/src/test/java/dagger/tests/integration/operation/FailureModeErrorsTest.java
rename to compiler/src/test/java/dagger/tests/integration/operation/dagger1/FailureModeErrorsTest.java
index 30340a249..fd530d9ad 100644
--- a/compiler/src/test/java/dagger/tests/integration/operation/FailureModeErrorsTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/operation/dagger1/FailureModeErrorsTest.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.tests.integration.operation;
+package dagger.tests.integration.operation.dagger1;
 
 import dagger.Module;
 import dagger.ObjectGraph;
@@ -49,7 +49,7 @@
       assertThat(e.getMessage()).contains(
           "java.lang.String[] is a generic class or an array and can only be bound with "
               + "concrete type parameter(s) in a @Provides method. required by class "
-              + "dagger.tests.integration.operation.FailureModeErrorsTest$ArrayFoo");
+              + FailureModeErrorsTest.class.getCanonicalName() + "$ArrayFoo");
     }
   }
 
@@ -68,9 +68,10 @@
       fail("Should have thrown.");
     } catch (IllegalStateException e) {
       assertThat(e.getMessage()).contains(
-          "@dagger.tests.integration.operation.FailureModeErrorsTest$MyFoo()/java.lang.String "
+          "@" + FailureModeErrorsTest.class.getCanonicalName() + "$MyFoo()/java.lang.String "
               + "is a @Qualifier-annotated type and must be bound by a @Provides method. required "
-              + "by class dagger.tests.integration.operation.FailureModeErrorsTest$QualifyingFoo");
+              + "by class "
+              + FailureModeErrorsTest.class.getCanonicalName() + "$QualifyingFoo");
     }
   }
 }
diff --git a/compiler/src/test/java/dagger/tests/integration/operation/SimpleInjectionTest.java b/compiler/src/test/java/dagger/tests/integration/operation/dagger1/SimpleInjectionTest.java
similarity index 97%
rename from compiler/src/test/java/dagger/tests/integration/operation/SimpleInjectionTest.java
rename to compiler/src/test/java/dagger/tests/integration/operation/dagger1/SimpleInjectionTest.java
index 7e38052c5..c5b3acd0b 100644
--- a/compiler/src/test/java/dagger/tests/integration/operation/SimpleInjectionTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/operation/dagger1/SimpleInjectionTest.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.tests.integration.operation;
+package dagger.tests.integration.operation.dagger1;
 
 import dagger.Module;
 import dagger.ObjectGraph;
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/CyclicDependencyTest.java b/compiler/src/test/java/dagger/tests/integration/validation/dagger1/CyclicDependencyTest.java
similarity index 96%
rename from compiler/src/test/java/dagger/tests/integration/validation/CyclicDependencyTest.java
rename to compiler/src/test/java/dagger/tests/integration/validation/dagger1/CyclicDependencyTest.java
index bc03d96f0..f09be125d 100644
--- a/compiler/src/test/java/dagger/tests/integration/validation/CyclicDependencyTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/dagger1/CyclicDependencyTest.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.tests.integration.validation;
+package dagger.tests.integration.validation.dagger1;
 
 import com.google.common.base.Joiner;
 import com.google.testing.compile.JavaFileObjects;
@@ -25,7 +25,7 @@
 
 import static com.google.common.truth.Truth.assert_;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
+import static dagger.tests.integration.dagger1.ProcessorTestUtils.daggerProcessors;
 
 @RunWith(JUnit4.class)
 public class CyclicDependencyTest {
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/CyclicModuleIncludesTest.java b/compiler/src/test/java/dagger/tests/integration/validation/dagger1/CyclicModuleIncludesTest.java
similarity index 96%
rename from compiler/src/test/java/dagger/tests/integration/validation/CyclicModuleIncludesTest.java
rename to compiler/src/test/java/dagger/tests/integration/validation/dagger1/CyclicModuleIncludesTest.java
index 708097e2e..b7e43f4dc 100644
--- a/compiler/src/test/java/dagger/tests/integration/validation/CyclicModuleIncludesTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/dagger1/CyclicModuleIncludesTest.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.tests.integration.validation;
+package dagger.tests.integration.validation.dagger1;
 
 import com.google.common.base.Joiner;
 import com.google.testing.compile.JavaFileObjects;
@@ -25,7 +25,7 @@
 
 import static com.google.common.truth.Truth.assert_;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
+import static dagger.tests.integration.dagger1.ProcessorTestUtils.daggerProcessors;
 
 @RunWith(JUnit4.class)
 public class CyclicModuleIncludesTest {
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/GeneratedTypesNotReadyTest.java b/compiler/src/test/java/dagger/tests/integration/validation/dagger1/GeneratedTypesNotReadyTest.java
similarity index 98%
rename from compiler/src/test/java/dagger/tests/integration/validation/GeneratedTypesNotReadyTest.java
rename to compiler/src/test/java/dagger/tests/integration/validation/dagger1/GeneratedTypesNotReadyTest.java
index 2bd19cdca..1e41f2292 100644
--- a/compiler/src/test/java/dagger/tests/integration/validation/GeneratedTypesNotReadyTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/dagger1/GeneratedTypesNotReadyTest.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.tests.integration.validation;
+package dagger.tests.integration.validation.dagger1;
 
 import com.google.common.base.Joiner;
 import com.google.testing.compile.JavaFileObjects;
@@ -34,7 +34,7 @@
 import static com.google.common.collect.Iterables.concat;
 import static com.google.common.truth.Truth.assert_;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
+import static dagger.tests.integration.dagger1.ProcessorTestUtils.daggerProcessors;
 import static java.util.Arrays.asList;
 
 /**
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/LibraryModuleTest.java b/compiler/src/test/java/dagger/tests/integration/validation/dagger1/LibraryModuleTest.java
similarity index 96%
rename from compiler/src/test/java/dagger/tests/integration/validation/LibraryModuleTest.java
rename to compiler/src/test/java/dagger/tests/integration/validation/dagger1/LibraryModuleTest.java
index 36e3ed36e..32368f24e 100644
--- a/compiler/src/test/java/dagger/tests/integration/validation/LibraryModuleTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/dagger1/LibraryModuleTest.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.tests.integration.validation;
+package dagger.tests.integration.validation.dagger1;
 
 import com.google.common.base.Joiner;
 import com.google.testing.compile.JavaFileObjects;
@@ -27,7 +27,7 @@
 import static com.google.common.truth.Truth.assert_;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
+import static dagger.tests.integration.dagger1.ProcessorTestUtils.daggerProcessors;
 
 @RunWith(JUnit4.class)
 public final class LibraryModuleTest {
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/ScopeAnnotationUseTest.java b/compiler/src/test/java/dagger/tests/integration/validation/dagger1/ScopeAnnotationUseTest.java
similarity index 98%
rename from compiler/src/test/java/dagger/tests/integration/validation/ScopeAnnotationUseTest.java
rename to compiler/src/test/java/dagger/tests/integration/validation/dagger1/ScopeAnnotationUseTest.java
index 8cca1daaf..8895778ae 100644
--- a/compiler/src/test/java/dagger/tests/integration/validation/ScopeAnnotationUseTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/dagger1/ScopeAnnotationUseTest.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.tests.integration.validation;
+package dagger.tests.integration.validation.dagger1;
 
 import com.google.common.base.Joiner;
 import com.google.testing.compile.JavaFileObjects;
@@ -26,7 +26,7 @@
 import static com.google.common.truth.Truth.assert_;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
+import static dagger.tests.integration.dagger1.ProcessorTestUtils.daggerProcessors;
 import static java.util.Arrays.asList;
 
 /**
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/SimpleMissingDependencyTest.java b/compiler/src/test/java/dagger/tests/integration/validation/dagger1/SimpleMissingDependencyTest.java
similarity index 93%
rename from compiler/src/test/java/dagger/tests/integration/validation/SimpleMissingDependencyTest.java
rename to compiler/src/test/java/dagger/tests/integration/validation/dagger1/SimpleMissingDependencyTest.java
index e0907a939..0534ba42d 100644
--- a/compiler/src/test/java/dagger/tests/integration/validation/SimpleMissingDependencyTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/dagger1/SimpleMissingDependencyTest.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.tests.integration.validation;
+package dagger.tests.integration.validation.dagger1;
 
 import com.google.common.base.Joiner;
 import com.google.testing.compile.JavaFileObjects;
@@ -25,7 +25,7 @@
 
 import static com.google.common.truth.Truth.assert_;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
+import static dagger.tests.integration.dagger1.ProcessorTestUtils.daggerProcessors;
 
 @RunWith(JUnit4.class)
 public class SimpleMissingDependencyTest {
