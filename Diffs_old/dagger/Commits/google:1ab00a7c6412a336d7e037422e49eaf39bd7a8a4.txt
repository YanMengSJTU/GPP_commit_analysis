diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 4d5926aff..c8dbd98e7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -83,7 +83,6 @@
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.Preconditions.checkState;
-import static com.google.common.collect.Iterables.any;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.DELEGATED;
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.INITIALIZED;
@@ -756,7 +755,8 @@ private Snippet initializeSetMultibindings(ResolvedBindings resolvedBindings) {
       parameterSnippets.add(snippet);
     }
     Class<?> factoryClass =
-        Iterables.all(resolvedBindings.contributionBindings(), Binding.Type.PROVISION)
+        Iterables.all(
+                resolvedBindings.contributionBindings(), Binding.isOfType(Binding.Type.PROVISION))
             ? SetFactory.class
             : Util.isSetOfProduced(resolvedBindings.bindingKey().key().type())
                 ? SetOfProducedProducer.class
@@ -775,7 +775,8 @@ private Snippet initializeSetMultibindings(ResolvedBindings resolvedBindings) {
   private Snippet initializeMapMultibindings(ResolvedBindings resolvedBindings) {
     ImmutableList.Builder<Snippet> initializationSnippets = ImmutableList.builder();
 
-    if (any(resolvedBindings.contributionBindings(), Binding.Type.PRODUCTION)) {
+    if (Iterables.any(
+        resolvedBindings.contributionBindings(), Binding.isOfType(Binding.Type.PRODUCTION))) {
       // TODO(beder): Implement producer map bindings.
       throw new IllegalStateException("producer map bindings not implemented yet");
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Binding.java b/compiler/src/main/java/dagger/internal/codegen/Binding.java
index 0a6b84052..d6b6d9f38 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Binding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Binding.java
@@ -54,9 +54,9 @@
 abstract class Binding {
   
   /**
-   * The subtype of this binding.
+   * A binding subtype.
    */
-  enum Type implements Predicate<Binding> {
+  enum Type {
     /** A binding with this type is a {@link ProvisionBinding}. */
     PROVISION(Provider.class),
     /** A binding with this type is a {@link MembersInjectionBinding}. */
@@ -89,15 +89,25 @@ private Type(Class<?> frameworkClass) {
           throw new AssertionError();
       }
     }
-
-    @Override
-    public boolean apply(Binding binding) {
-      return this.equals(binding.bindingType());
-    }
   }
 
+  /**
+   * The subtype of this binding.
+   */
   abstract Binding.Type bindingType();
 
+  /**
+   * A predicate that passes for bindings of a given subtype.
+   */
+  static Predicate<Binding> isOfType(final Type type) {
+    return new Predicate<Binding>() {
+      @Override
+      public boolean apply(Binding binding) {
+        return binding.bindingType().equals(type);
+      }
+    };
+  }
+
   /**
    * Returns the framework class associated with this binding.
    */
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 701f8b21b..e8a1e8f8b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -58,7 +58,6 @@
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.common.base.Predicates.in;
 import static com.google.common.base.Verify.verify;
-import static com.google.common.collect.Iterables.any;
 import static com.google.common.collect.Sets.union;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
@@ -342,7 +341,8 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
               }
               return ResolvedBindings.forContributionBindings(
                   bindingKey, componentDescriptor, bindings.build());
-            } else if (any(explicitMapBindings, Binding.Type.PRODUCTION)) {
+            } else if (Iterables.any(
+                explicitMapBindings, Binding.isOfType(Binding.Type.PRODUCTION))) {
               /* If this binding is for Map<K, V> and there are no explicit Map<K, V> bindings but
                * some explicit Map<K, Producer<V>> bindings, then this binding must have only the
                * implicit dependency on Map<K, Producer<V>>. */
@@ -350,7 +350,8 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
                   bindingKey,
                   componentDescriptor,
                   productionBindingFactory.implicitMapOfProducerBinding(request));
-            } else if (any(explicitMapBindings, Binding.Type.PROVISION)) {
+            } else if (Iterables.any(
+                explicitMapBindings, Binding.isOfType(Binding.Type.PROVISION))) {
               /* If this binding is for Map<K, V> and there are no explicit Map<K, V> bindings but
                * some explicit Map<K, Provider<V>> bindings, then this binding must have only the
                * implicit dependency on Map<K, Provider<V>>. */
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 90c27c3fd..8594fbad4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -74,8 +74,6 @@
 import static com.google.common.base.Predicates.in;
 import static com.google.common.base.Predicates.not;
 import static com.google.common.base.Verify.verify;
-import static com.google.common.collect.Iterables.all;
-import static com.google.common.collect.Iterables.any;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.google.common.collect.Iterables.indexOf;
 import static com.google.common.collect.Iterables.skip;
@@ -286,14 +284,15 @@ private boolean validateResolvedBinding(
         case CONTRIBUTION:
           ImmutableSet<ContributionBinding> contributionBindings =
               resolvedBinding.contributionBindings();
-          if (any(contributionBindings, Binding.Type.MEMBERS_INJECTION)) {
+          if (Iterables.any(
+              contributionBindings, Binding.isOfType(Binding.Type.MEMBERS_INJECTION))) {
             throw new IllegalArgumentException(
                 "contribution binding keys should never have members injection bindings");
           }
           if (!validateNullability(path.peek().request(), contributionBindings)) {
             return false;
           }
-          if (any(contributionBindings, Binding.Type.PRODUCTION)
+          if (Iterables.any(contributionBindings, Binding.isOfType(Binding.Type.PRODUCTION))
               && doesPathRequireProvisionOnly(path)) {
             reportProviderMayNotDependOnProducer(path);
             return false;
@@ -323,7 +322,8 @@ private boolean validateResolvedBinding(
           }
           break;
         case MEMBERS_INJECTION:
-          if (!all(resolvedBinding.bindings(), Binding.Type.MEMBERS_INJECTION)) {
+          if (!Iterables.all(
+              resolvedBinding.bindings(), Binding.isOfType(Binding.Type.MEMBERS_INJECTION))) {
             throw new IllegalArgumentException(
                 "members injection binding keys should never have contribution bindings");
           }
@@ -1084,7 +1084,7 @@ private boolean doesPathRequireProvisionOnly(Deque<ResolvedRequest> path) {
     final DependencyRequest request = iterator.next().request();
     ResolvedRequest previousResolvedRequest = iterator.next();
     return FluentIterable.from(previousResolvedRequest.binding().bindings())
-        .filter(Binding.Type.PROVISION)
+        .filter(Binding.isOfType(Binding.Type.PROVISION))
         .filter(
             new Predicate<Binding>() {
               @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
index 38e8f026a..5c6c4c52c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
@@ -19,6 +19,7 @@
 import com.google.auto.value.AutoValue;
 import com.google.common.base.CaseFormat;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
 import dagger.MembersInjector;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.ParameterizedTypeName;
@@ -29,7 +30,6 @@
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementKindVisitor6;
 
-import static com.google.common.collect.Iterables.any;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.ContributionBinding.contributionTypeFor;
 
@@ -148,7 +148,8 @@ public String visitType(TypeElement e, Void p) {
   static Class<?> frameworkClassForResolvedBindings(ResolvedBindings resolvedBindings) {
     switch (resolvedBindings.bindingKey().kind()) {
       case CONTRIBUTION:
-        return any(resolvedBindings.contributionBindings(), Binding.Type.PRODUCTION)
+        return Iterables.any(
+                resolvedBindings.contributionBindings(), Binding.isOfType(Binding.Type.PRODUCTION))
             ? Binding.Type.PRODUCTION.frameworkClass()
             : Binding.Type.PROVISION.frameworkClass();
       case MEMBERS_INJECTION:
