diff --git a/java/dagger/internal/codegen/BindingDeclaration.java b/java/dagger/internal/codegen/BindingDeclaration.java
index 3c5da0da5..dcf63a561 100644
--- a/java/dagger/internal/codegen/BindingDeclaration.java
+++ b/java/dagger/internal/codegen/BindingDeclaration.java
@@ -16,15 +16,44 @@
 
 package dagger.internal.codegen;
 
+import static dagger.internal.codegen.Optionals.emptiesLast;
+import static java.util.Comparator.comparing;
+
 import dagger.internal.codegen.langmodel.DaggerElements;
 import dagger.model.BindingKind;
 import dagger.model.Key;
+import java.util.Comparator;
 import java.util.Optional;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 
 /** An object that declares or specifies a binding. */
 abstract class BindingDeclaration {
+  /**
+    * A comparator that compares binding declarations with elements.
+    *
+    * Compares, in order:
+    *
+    * <ol>
+    * <li>Contributing module or enclosing type name
+    * <li>Binding element's simple name
+    * <li>Binding element's type
+    * </ol>
+    *
+    * Any binding declarations without elements are last.
+    */
+  static final Comparator<BindingDeclaration> COMPARATOR =
+      comparing(
+              (BindingDeclaration declaration) ->
+                  declaration.contributingModule().isPresent()
+                      ? declaration.contributingModule()
+                      : declaration.bindingTypeElement(),
+              emptiesLast(comparing((TypeElement type) -> type.getQualifiedName().toString())))
+          .thenComparing(
+              (BindingDeclaration declaration) -> declaration.bindingElement(),
+              emptiesLast(
+                  comparing((Element element) -> element.getSimpleName().toString())
+                      .thenComparing((Element element) -> element.asType().toString())));
 
   /** The {@link Key} of this declaration. */
   abstract Key key();
@@ -48,7 +77,7 @@
   final Optional<TypeElement> bindingTypeElement() {
     return bindingElement().map(DaggerElements::closestEnclosingTypeElement);
   }
-  
+
   /**
    * The installed module class that contributed the {@link #bindingElement()}. May be a subclass of
    * the class that contains {@link #bindingElement()}. Absent if {@link #bindingElement()} is
diff --git a/java/dagger/internal/codegen/ContributionBinding.java b/java/dagger/internal/codegen/ContributionBinding.java
index 0958bc8c0..1a29d0062 100644
--- a/java/dagger/internal/codegen/ContributionBinding.java
+++ b/java/dagger/internal/codegen/ContributionBinding.java
@@ -16,11 +16,9 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.CLASS_CONSTRUCTOR;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.DELEGATE;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.SINGLETON_INSTANCE;
-import static dagger.internal.codegen.MapKeys.unwrapValue;
 import static dagger.internal.codegen.MoreAnnotationMirrors.unwrapOptionalEquivalence;
 import static java.util.Arrays.asList;
 
@@ -34,7 +32,6 @@
 import dagger.model.Key;
 import java.util.Optional;
 import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -56,17 +53,6 @@
     return unwrapOptionalEquivalence(wrappedMapKeyAnnotation());
   }
 
-  /**
-   * If this is a map contribution, returns the key of its map entry.
-   *
-   * @throws IllegalStateException if {@link #mapKeyAnnotation()} returns an empty value.
-   */
-  final Object mapKey() {
-    checkState(mapKeyAnnotation().isPresent());
-    AnnotationMirror mapKeyAnnotation = mapKeyAnnotation().get();
-    return unwrapValue(mapKeyAnnotation).map(AnnotationValue::getValue).orElse(mapKeyAnnotation);
-  }
-
   /** If {@link #bindingElement()} is a method that returns a primitive type, returns that type. */
   final Optional<TypeMirror> contributedPrimitiveType() {
     return bindingElement()
diff --git a/java/dagger/internal/codegen/DuplicateBindingsValidator.java b/java/dagger/internal/codegen/DuplicateBindingsValidator.java
index 3eed45fdb..0373c47e1 100644
--- a/java/dagger/internal/codegen/DuplicateBindingsValidator.java
+++ b/java/dagger/internal/codegen/DuplicateBindingsValidator.java
@@ -21,7 +21,6 @@
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSetMultimap;
 import static dagger.internal.codegen.Formatter.INDENT;
-import static dagger.internal.codegen.Optionals.emptiesLast;
 import static dagger.model.BindingKind.INJECTION;
 import static dagger.model.BindingKind.MEMBERS_INJECTION;
 import static java.util.Comparator.comparing;
@@ -58,22 +57,6 @@
 /** Reports errors for conflicting bindings with the same key. */
 final class DuplicateBindingsValidator implements BindingGraphPlugin {
 
-  // 1. contributing module or enclosing type
-  // 2. binding element's simple name
-  // 3. binding element's type
-  private static final Comparator<BindingDeclaration> BINDING_DECLARATION_COMPARATOR =
-      comparing(
-              (BindingDeclaration declaration) ->
-                  declaration.contributingModule().isPresent()
-                      ? declaration.contributingModule()
-                      : declaration.bindingTypeElement(),
-              emptiesLast(comparing((TypeElement type) -> type.getQualifiedName().toString())))
-          .thenComparing(
-              (BindingDeclaration declaration) -> declaration.bindingElement(),
-              emptiesLast(
-                  comparing((Element element) -> element.getSimpleName().toString())
-                      .thenComparing((Element element) -> element.asType().toString())));
-
   private static final Comparator<Binding> BY_LENGTH_OF_COMPONENT_PATH =
       comparing(binding -> binding.componentPath().components().size());
 
@@ -267,7 +250,7 @@ private void formatDeclarations(
     return bindings.stream()
         .flatMap(binding -> declarations(graph, binding).stream())
         .distinct()
-        .sorted(BINDING_DECLARATION_COMPARATOR)
+        .sorted(BindingDeclaration.COMPARATOR)
         .collect(toImmutableSet());
   }
 
diff --git a/java/dagger/internal/codegen/MapMultibindingValidator.java b/java/dagger/internal/codegen/MapMultibindingValidator.java
index 346d27145..f4df025d1 100644
--- a/java/dagger/internal/codegen/MapMultibindingValidator.java
+++ b/java/dagger/internal/codegen/MapMultibindingValidator.java
@@ -26,6 +26,7 @@
 
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Equivalence;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Multimaps;
@@ -133,8 +134,9 @@ private void checkForDuplicateMapKeys(
       dagger.model.Binding multiboundMapBinding,
       ImmutableSet<ContributionBinding> contributions,
       DiagnosticReporter diagnosticReporter) {
-    ImmutableSetMultimap<Object, ContributionBinding> contributionsByMapKey =
-        ImmutableSetMultimap.copyOf(Multimaps.index(contributions, ContributionBinding::mapKey));
+    ImmutableSetMultimap<?, ContributionBinding> contributionsByMapKey =
+        ImmutableSetMultimap.copyOf(
+            Multimaps.index(contributions, ContributionBinding::wrappedMapKeyAnnotation));
 
     for (Set<ContributionBinding> contributionsForOneMapKey :
         Multimaps.asMap(contributionsByMapKey).values()) {
@@ -193,7 +195,11 @@ private String duplicateMapKeyErrorMessage(
       Set<ContributionBinding> contributionsForOneMapKey, Key mapBindingKey) {
     StringBuilder message =
         new StringBuilder("The same map key is bound more than once for ").append(mapBindingKey);
-    bindingDeclarationFormatter.formatIndentedList(message, contributionsForOneMapKey, 1);
+
+    bindingDeclarationFormatter.formatIndentedList(
+        message,
+        ImmutableList.sortedCopyOf(BindingDeclaration.COMPARATOR, contributionsForOneMapKey),
+        1);
     return message.toString();
   }
 }
diff --git a/javatests/dagger/internal/codegen/MapMultibindingValidationTest.java b/javatests/dagger/internal/codegen/MapMultibindingValidationTest.java
index 04b0986e8..106778d13 100644
--- a/javatests/dagger/internal/codegen/MapMultibindingValidationTest.java
+++ b/javatests/dagger/internal/codegen/MapMultibindingValidationTest.java
@@ -18,6 +18,7 @@
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.TestUtils.message;
 
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.Compilation;
@@ -30,7 +31,7 @@
 @RunWith(JUnit4.class)
 public class MapMultibindingValidationTest {
   @Test
-  public void duplicateMapKeys() {
+  public void duplicateMapKeys_UnwrappedMapKey() {
     JavaFileObject module =
         JavaFileObjects.forSourceLines(
             "test.MapModule",
@@ -158,6 +159,56 @@ public void duplicateMapKeys() {
     assertThat(compilation).hadErrorCount(1);
   }
 
+  @Test
+  public void duplicateMapKeys_WrappedMapKey() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.MapModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.MapKey;",
+            "",
+            "@Module",
+            "abstract class MapModule {",
+            "",
+            "  @MapKey(unwrapValue = false)",
+            "  @interface WrappedMapKey {",
+            "    String value();",
+            "  }",
+            "",
+            "  @Provides",
+            "  @IntoMap",
+            "  @WrappedMapKey(\"foo\")",
+            "  static String stringMapEntry1() { return \"\"; }",
+            "",
+            "  @Provides",
+            "  @IntoMap",
+            "  @WrappedMapKey(\"foo\")",
+            "  static String stringMapEntry2() { return \"\"; }",
+            "}");
+
+    JavaFileObject component = component("Map<test.MapModule.WrappedMapKey, String> objects();");
+
+    Compilation compilation = daggerCompiler().compile(component, module);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "[Dagger/MapKeys] The same map key is bound more than once for "
+                    + "java.util.Map<test.MapModule.WrappedMapKey,java.lang.String>",
+                "    @Provides @dagger.multibindings.IntoMap "
+                    + "@test.MapModule.WrappedMapKey(\"foo\") String "
+                    + "test.MapModule.stringMapEntry1()",
+                "    @Provides @dagger.multibindings.IntoMap "
+                    + "@test.MapModule.WrappedMapKey(\"foo\") String "
+                    + "test.MapModule.stringMapEntry2()"))
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+  }
+
   @Test
   public void inconsistentMapKeyAnnotations() {
     JavaFileObject module =
