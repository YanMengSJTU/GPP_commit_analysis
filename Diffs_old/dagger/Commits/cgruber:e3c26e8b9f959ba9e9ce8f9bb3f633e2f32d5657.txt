diff --git a/.travis.yml b/.travis.yml
index a8e4a4308..2de719e8d 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,8 +1,6 @@
 language: android
 
 jdk:
-  - oraclejdk7
-  - openjdk7
   - oraclejdk8
 
 android:
diff --git a/compiler/pom.xml b/compiler/pom.xml
index b232f4928..5a39f86a8 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -116,6 +116,13 @@
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
+        <configuration>
+          <source>1.8</source>
+          <target>1.8</target>
+          <compilerArgument>-Xlint:all</compilerArgument>
+          <showWarnings>true</showWarnings>
+          <showDeprecation>true</showDeprecation>
+        </configuration>
         <executions>
           <execution>
             <id>default-compile</id>
@@ -170,7 +177,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-shade-plugin</artifactId>
-        <version>2.3</version>
+        <version>2.4.3</version>
         <executions>
           <execution>
             <phase>package</phase>
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index aa0b91f63..4e4249670 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -494,9 +494,7 @@ private boolean graphHasContributionBinding(Key key) {
   }
 
   private void addFrameworkFields() {
-    for (ResolvedBindings resolvedBindings : graph.resolvedBindings().values()) {
-      addField(resolvedBindings);
-    }
+    graph.resolvedBindings().values().forEach(this::addField);
   }
 
   private void addField(ResolvedBindings resolvedBindings) {
@@ -936,7 +934,7 @@ private CodeBlock initializeDelegateFactoriesForUninitializedDependencies(Bindin
 
     for (BindingKey dependencyKey :
         FluentIterable.from(binding.implicitDependencies())
-            .transform(DependencyRequest.BINDING_KEY_FUNCTION)
+            .transform(DependencyRequest::bindingKey)
             .toSet()) {
       if (!getMemberSelect(dependencyKey).staticMember()
           && getInitializationState(dependencyKey).equals(UNINITIALIZED)) {
@@ -1304,7 +1302,7 @@ private CodeBlock initializeFactoryForSyntheticOptionalBinding(ContributionBindi
           binding.bindingType().equals(BindingType.PROVISION),
           "Absent optional bindings should be provisions: %s",
           binding);
-      return optionalFactories.absentOptionalProvider();
+      return optionalFactories.absentOptionalProvider(binding);
     } else {
       return optionalFactories.presentOptionalFactory(
           binding, getOnlyElement(getDependencyArguments(binding)));
diff --git a/compiler/src/main/java/dagger/internal/codegen/AnnotationCreatorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/AnnotationCreatorGenerator.java
index b4d3726c3..7c89b3340 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AnnotationCreatorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AnnotationCreatorGenerator.java
@@ -149,7 +149,7 @@ static String createMethodName(TypeElement annotationType) {
    * should be written.
    */
   protected Set<TypeElement> annotationsToCreate(TypeElement annotationElement) {
-    return nestedAnnotationElements(annotationElement, new LinkedHashSet<TypeElement>());
+    return nestedAnnotationElements(annotationElement, new LinkedHashSet<>());
   }
 
   @CanIgnoreReturnValue
diff --git a/compiler/src/main/java/dagger/internal/codegen/AnnotationExpression.java b/compiler/src/main/java/dagger/internal/codegen/AnnotationExpression.java
index a3bb91caf..6d3692636 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AnnotationExpression.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AnnotationExpression.java
@@ -17,21 +17,18 @@
 package dagger.internal.codegen;
 
 import static com.google.auto.common.AnnotationMirrors.getAnnotationValuesWithDefaults;
-import static com.google.common.collect.Iterables.transform;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static java.util.stream.Collectors.toList;
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
-import com.google.common.base.Function;
 import com.google.common.collect.ImmutableList;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.TypeName;
 import java.util.List;
-import java.util.Map;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
-import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
@@ -77,14 +74,11 @@ private CodeBlock getAnnotationInstanceExpression(AnnotationMirror annotation) {
         AnnotationCreatorGenerator.createMethodName(
             MoreElements.asType(annotation.getAnnotationType().asElement())),
         makeParametersCodeBlock(
-            transform(
-                getAnnotationValuesWithDefaults(annotation).entrySet(),
-                new Function<Map.Entry<ExecutableElement, AnnotationValue>, CodeBlock>() {
-                  @Override
-                  public CodeBlock apply(Map.Entry<ExecutableElement, AnnotationValue> entry) {
-                    return getValueExpression(entry.getKey().getReturnType(), entry.getValue());
-                  }
-                })));
+            getAnnotationValuesWithDefaults(annotation)
+                .entrySet()
+                .stream()
+                .map(entry -> getValueExpression(entry.getKey().getReturnType(), entry.getValue()))
+                .collect(toList())));
   }
 
   /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/BindingDeclaration.java
index 7c2096668..8bb460855 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingDeclaration.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingDeclaration.java
@@ -18,11 +18,8 @@
 
 import static dagger.internal.codegen.Util.ENCLOSING_TYPE_ELEMENT;
 
-import com.google.common.base.Function;
 import com.google.common.base.Optional;
-import com.google.common.base.Predicate;
 import dagger.internal.codegen.Key.HasKey;
-import java.util.Set;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 
@@ -40,14 +37,7 @@
    * #bindingElement()} is absent.
    */
   Optional<TypeElement> bindingTypeElement() {
-    return bindingElement()
-        .transform(
-            new Function<Element, TypeElement>() {
-              @Override
-              public TypeElement apply(Element element) {
-                return element.accept(ENCLOSING_TYPE_ELEMENT, null);
-              }
-            });
+    return bindingElement().transform(element -> element.accept(ENCLOSING_TYPE_ELEMENT, null));
   }
   
   /**
@@ -56,28 +46,4 @@ public TypeElement apply(Element element) {
    * absent.
    */
   abstract Optional<TypeElement> contributingModule();
-
-  /**
-   * A function that returns a singleton set containing the {@link #contributingModule()} for
-   * binding declarations that have one, and an empty set for those that don't.
-   */
-  static final Function<BindingDeclaration, Set<TypeElement>> CONTRIBUTING_MODULE =
-      new Function<BindingDeclaration, Set<TypeElement>>() {
-        @Override
-        public Set<TypeElement> apply(BindingDeclaration bindingDeclaration) {
-          return bindingDeclaration.contributingModule().asSet();
-        }
-      };
-
-  /**
-   * A predicate that passes for binding declarations for which {@link #bindingElement()} is
-   * present.
-   */
-  static final Predicate<BindingDeclaration> HAS_BINDING_ELEMENT =
-      new Predicate<BindingDeclaration>() {
-        @Override
-        public boolean apply(BindingDeclaration bindingDeclaration) {
-          return bindingDeclaration.bindingElement().isPresent();
-        }
-      };
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 196486780..c4161f773 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -25,12 +25,11 @@
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.isEmpty;
 import static dagger.internal.codegen.BindingKey.contribution;
-import static dagger.internal.codegen.BindingType.isOfType;
 import static dagger.internal.codegen.ComponentDescriptor.Kind.PRODUCTION_COMPONENT;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
-import static dagger.internal.codegen.ContributionBinding.Kind.IS_SYNTHETIC_MULTIBINDING_KIND;
+import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_KINDS;
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_OPTIONAL_BINDING;
 import static dagger.internal.codegen.Key.indexByKey;
 import static dagger.internal.codegen.Scope.reusableScope;
@@ -38,9 +37,7 @@
 
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Function;
 import com.google.common.base.Optional;
-import com.google.common.base.Predicate;
 import com.google.common.base.VerifyException;
 import com.google.common.cache.Cache;
 import com.google.common.cache.CacheBuilder;
@@ -72,7 +69,6 @@
 import java.util.Map;
 import java.util.Queue;
 import java.util.Set;
-import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutionException;
 import javax.inject.Inject;
 import javax.inject.Provider;
@@ -104,9 +100,7 @@
   abstract ImmutableSet<ModuleDescriptor> ownedModules();
 
   ImmutableSet<TypeElement> ownedModuleTypes() {
-    return FluentIterable.from(ownedModules())
-        .transform(ModuleDescriptor.getModuleElement())
-        .toSet();
+    return FluentIterable.from(ownedModules()).transform(ModuleDescriptor::moduleElement).toSet();
   }
 
   private static final TreeTraverser<BindingGraph> SUBGRAPH_TRAVERSER =
@@ -128,38 +122,24 @@
   ImmutableSet<TypeElement> componentRequirements() {
     return SUBGRAPH_TRAVERSER
         .preOrderTraversal(this)
-        .transformAndConcat(RESOLVED_BINDINGS)
-        .transformAndConcat(ResolvedBindings.CONTRIBUTION_BINDINGS)
-        .filter(ContributionBinding.REQUIRES_MODULE_INSTANCE)
-        .transformAndConcat(BindingDeclaration.CONTRIBUTING_MODULE)
+        .transformAndConcat(graph -> graph.resolvedBindings().values())
+        .transformAndConcat(ResolvedBindings::contributionBindings)
+        .filter(ContributionBinding::requiresModuleInstance)
+        .transformAndConcat(bindingDeclaration -> bindingDeclaration.contributingModule().asSet())
         .filter(in(ownedModuleTypes()))
         .append(componentDescriptor().dependencies())
         .toSet();
   }
-
-  private static final Function<BindingGraph, Iterable<ResolvedBindings>> RESOLVED_BINDINGS =
-      new Function<BindingGraph, Iterable<ResolvedBindings>>() {
-        @Override
-        public Iterable<ResolvedBindings> apply(BindingGraph graph) {
-          return graph.resolvedBindings().values();
-        }
-      };
-
   /**
    * Returns the {@link ComponentDescriptor}s for this component and its subcomponents.
    */
   ImmutableSet<ComponentDescriptor> componentDescriptors() {
-    return SUBGRAPH_TRAVERSER.preOrderTraversal(this).transform(COMPONENT_DESCRIPTOR).toSet();
+    return SUBGRAPH_TRAVERSER
+        .preOrderTraversal(this)
+        .transform(BindingGraph::componentDescriptor)
+        .toSet();
   }
 
-  static final Function<BindingGraph, ComponentDescriptor> COMPONENT_DESCRIPTOR =
-      new Function<BindingGraph, ComponentDescriptor>() {
-        @Override
-        public ComponentDescriptor apply(BindingGraph graph) {
-          return graph.componentDescriptor();
-        }
-      };
-
   ImmutableSet<TypeElement> availableDependencies() {
     return FluentIterable.from(componentDescriptor().transitiveModuleTypes())
         .filter(not(hasModifiers(ABSTRACT)))
@@ -479,19 +459,16 @@ private void addSubcomponentToOwningResolver(ProvisionBinding subcomponentBuilde
                 multibindingContributionsForValueMap(key),
                 multibindingDeclarationsForValueMap(key))
             .transform(
-                new Function<ContributionBinding, ContributionBinding>() {
-                  @Override
-                  public ContributionBinding apply(ContributionBinding syntheticMultibinding) {
-                    switch (syntheticMultibinding.bindingType()) {
-                      case PROVISION:
-                        return provisionBindingFactory.syntheticMapOfValuesBinding(key);
-
-                      case PRODUCTION:
-                        return productionBindingFactory.syntheticMapOfValuesOrProducedBinding(key);
-
-                      default:
-                        throw new VerifyException(syntheticMultibinding.toString());
-                    }
+                syntheticMultibinding -> {
+                  switch (syntheticMultibinding.bindingType()) {
+                    case PROVISION:
+                      return provisionBindingFactory.syntheticMapOfValuesBinding(key);
+
+                    case PRODUCTION:
+                      return productionBindingFactory.syntheticMapOfValuesOrProducedBinding(key);
+
+                    default:
+                      throw new VerifyException(syntheticMultibinding.toString());
                   }
                 });
       }
@@ -505,13 +482,7 @@ public ContributionBinding apply(ContributionBinding syntheticMultibinding) {
           Key requestKey) {
         return keyFactory
             .implicitFrameworkMapKeys(requestKey)
-            .transformAndConcat(
-                new Function<Key, Iterable<ContributionBinding>>() {
-                  @Override
-                  public Iterable<ContributionBinding> apply(Key key) {
-                    return getExplicitMultibindings(key);
-                  }
-                });
+            .transformAndConcat(this::getExplicitMultibindings);
       }
 
       /**
@@ -523,13 +494,7 @@ public ContributionBinding apply(ContributionBinding syntheticMultibinding) {
           Key requestKey) {
         return keyFactory
             .implicitFrameworkMapKeys(requestKey)
-            .transformAndConcat(
-                new Function<Key, Iterable<MultibindingDeclaration>>() {
-                  @Override
-                  public Iterable<MultibindingDeclaration> apply(Key key) {
-                    return getMultibindingDeclarations(key);
-                  }
-                });
+            .transformAndConcat(this::getMultibindingDeclarations);
       }
 
       /**
@@ -575,7 +540,8 @@ private boolean multibindingsRequireProduction(
             && SetType.from(requestKey).elementsAreTypeOf(Produced.class)) {
           return true;
         }
-        return Iterables.any(multibindingContributions, isOfType(BindingType.PRODUCTION));
+        return Iterables.any(multibindingContributions,
+            hasBindingType -> hasBindingType.bindingType().equals(BindingType.PRODUCTION));
       }
 
       private Optional<ProvisionBinding> syntheticSubcomponentBuilderBinding(
@@ -956,14 +922,10 @@ void resolve(BindingKey bindingKey) {
       private boolean hasLocallyPresentOptionalBinding(BindingKey bindingKey) {
         return Iterables.any(
             getPreviouslyResolvedBindings(bindingKey).get().contributionBindings(),
-            new Predicate<ContributionBinding>() {
-              @Override
-              public boolean apply(ContributionBinding binding) {
-                return binding.bindingKind().equals(SYNTHETIC_OPTIONAL_BINDING)
+            binding ->
+                binding.bindingKind().equals(SYNTHETIC_OPTIONAL_BINDING)
                     && !getLocalExplicitBindings(keyFactory.unwrapOptional(binding.key()).get())
-                        .isEmpty();
-              }
-            });
+                        .isEmpty());
       }
 
       private final class MultibindingDependencies {
@@ -994,22 +956,19 @@ boolean dependsOnLocalMultibindings(final BindingKey bindingKey) {
           try {
             return dependsOnLocalMultibindingsCache.get(
                 bindingKey,
-                new Callable<Boolean>() {
-                  @Override
-                  public Boolean call() {
-                    ResolvedBindings previouslyResolvedBindings =
-                        getPreviouslyResolvedBindings(bindingKey).get();
-                    if (isMultibindingsWithLocalContributions(previouslyResolvedBindings)) {
-                      return true;
-                    }
+                () -> {
+                  ResolvedBindings previouslyResolvedBindings =
+                      getPreviouslyResolvedBindings(bindingKey).get();
+                  if (isMultibindingsWithLocalContributions(previouslyResolvedBindings)) {
+                    return true;
+                  }
 
-                    for (Binding binding : previouslyResolvedBindings.bindings()) {
-                      if (dependsOnLocalMultibindings(binding)) {
-                        return true;
-                      }
+                  for (Binding binding : previouslyResolvedBindings.bindings()) {
+                    if (dependsOnLocalMultibindings(binding)) {
+                      return true;
                     }
-                    return false;
                   }
+                  return false;
                 });
           } catch (ExecutionException e) {
             throw new AssertionError(e);
@@ -1032,21 +991,18 @@ boolean dependsOnLocalMultibindings(final Binding binding) {
           try {
             return bindingDependsOnLocalMultibindingsCache.get(
                 binding,
-                new Callable<Boolean>() {
-                  @Override
-                  public Boolean call() {
-                    if ((!binding.scope().isPresent()
-                            || binding.scope().get().equals(reusableScope(elements)))
-                        // TODO(beder): Figure out what happens with production subcomponents.
-                        && !binding.bindingType().equals(BindingType.PRODUCTION)) {
-                      for (DependencyRequest dependency : binding.implicitDependencies()) {
-                        if (dependsOnLocalMultibindings(dependency.bindingKey())) {
-                          return true;
-                        }
+                () -> {
+                  if ((!binding.scope().isPresent()
+                          || binding.scope().get().equals(reusableScope(elements)))
+                      // TODO(beder): Figure out what happens with production subcomponents.
+                      && !binding.bindingType().equals(BindingType.PRODUCTION)) {
+                    for (DependencyRequest dependency : binding.implicitDependencies()) {
+                      if (dependsOnLocalMultibindings(dependency.bindingKey())) {
+                        return true;
                       }
                     }
-                    return false;
                   }
+                  return false;
                 });
           } catch (ExecutionException e) {
             throw new AssertionError(e);
@@ -1055,11 +1011,12 @@ public Boolean call() {
 
         private boolean isMultibindingsWithLocalContributions(ResolvedBindings resolvedBindings) {
           Key key = resolvedBindings.key();
-          return FluentIterable.from(resolvedBindings.contributionBindings())
-                  .transform(ContributionBinding.KIND)
-                  .anyMatch(IS_SYNTHETIC_MULTIBINDING_KIND)
+          return resolvedBindings.contributionBindings()
+              .stream()
+              .map(ContributionBinding::bindingKind)
+              .anyMatch(SYNTHETIC_MULTIBOUND_KINDS::contains)
               && !getExplicitMultibindings(key)
-                  .equals(parentResolver.get().getExplicitMultibindings(key));
+              .equals(parentResolver.get().getExplicitMultibindings(key));
         }
       }
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index cf744ecff..d9f155dc9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -22,22 +22,21 @@
 import static com.google.auto.common.MoreTypes.asTypeElements;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkState;
-import static com.google.common.base.Predicates.equalTo;
-import static com.google.common.base.Predicates.in;
-import static com.google.common.base.Predicates.not;
-import static com.google.common.base.Predicates.or;
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.google.common.collect.Iterables.indexOf;
-import static dagger.internal.codegen.BindingDeclaration.HAS_BINDING_ELEMENT;
+import static dagger.internal.codegen.BindingType.MEMBERS_INJECTION;
+import static dagger.internal.codegen.BindingType.PRODUCTION;
+import static dagger.internal.codegen.BindingType.PROVISION;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentAnnotation;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
+import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MAP;
+import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_KINDS;
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_MAP;
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_OPTIONAL_BINDING;
 import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByAnnotationType;
 import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByMapKey;
-import static dagger.internal.codegen.ContributionType.indexByContributionType;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_INJECT_WILDCARD_TYPE;
 import static dagger.internal.codegen.ErrorMessages.CONTAINS_DEPENDENCY_CYCLE_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.DEPENDS_ON_PRODUCTION_EXECUTOR_FORMAT;
@@ -58,14 +57,14 @@
 import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
 import static dagger.internal.codegen.Scope.reusableScope;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
+import static java.util.stream.Collectors.joining;
+import static java.util.stream.Collectors.toSet;
 import static javax.tools.Diagnostic.Kind.ERROR;
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
-import com.google.common.base.Function;
-import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
 import com.google.common.base.Predicate;
 import com.google.common.base.Predicates;
@@ -80,6 +79,7 @@
 import com.google.common.collect.LinkedHashMultiset;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Multimap;
+import com.google.common.collect.Multimaps;
 import com.google.common.collect.Ordering;
 import com.google.common.collect.Sets;
 import com.squareup.javapoet.TypeName;
@@ -88,7 +88,7 @@
 import dagger.MapKey;
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
-import dagger.internal.codegen.ContributionBinding.Kind;
+import dagger.internal.codegen.ContributionType.HasContributionType;
 import java.util.ArrayDeque;
 import java.util.Collection;
 import java.util.Deque;
@@ -255,7 +255,7 @@ int size() {
           ValidationReport.about(subject.componentDescriptor().componentDefinitionType());
       this.parent = parent;
       this.subgraphsByComponentDescriptor =
-          Maps.uniqueIndex(subject.subgraphs(), BindingGraph.COMPONENT_DESCRIPTOR);
+          Maps.uniqueIndex(subject.subgraphs(), BindingGraph::componentDescriptor);
     }
 
     Validation(BindingGraph topLevelGraph) {
@@ -299,23 +299,19 @@ void validateSubgraph() {
 
     private void validateSubcomponentFactoryMethod(
         ExecutableElement factoryMethod, BindingGraph subgraph) {
-      FluentIterable<TypeElement> missingModules =
-          FluentIterable.from(subgraph.componentRequirements())
-              .filter(not(in(subgraphFactoryMethodParameters(factoryMethod))))
-              .filter(
-                  new Predicate<TypeElement>() {
-                    @Override
-                    public boolean apply(TypeElement moduleType) {
-                      return !componentCanMakeNewInstances(moduleType);
-                    }
-                  });
+      Set<TypeElement> missingModules = subgraph.componentRequirements()
+          .stream()
+          .filter(componentRequirement -> !subgraphFactoryMethodParameters(factoryMethod)
+              .contains(componentRequirement))
+          .filter(moduleType -> !componentCanMakeNewInstances(moduleType))
+          .collect(toSet());
       if (!missingModules.isEmpty()) {
         reportBuilder.addError(
             String.format(
                 "%s requires modules which have no visible default constructors. "
                     + "Add the following modules as parameters to this method: %s",
                 subgraph.componentDescriptor().componentDefinitionType().getQualifiedName(),
-                Joiner.on(", ").join(missingModules.toSet())),
+                missingModules.stream().map(Object::toString).collect(joining(", "))),
             factoryMethod);
       }
     }
@@ -396,7 +392,7 @@ private void validateResolvedBindings(DependencyPath path) {
       switch (resolvedBindings.bindingKey().kind()) {
         case CONTRIBUTION:
           if (Iterables.any(
-              resolvedBindings.bindings(), BindingType.isOfType(BindingType.MEMBERS_INJECTION))) {
+              resolvedBindings.bindings(), MEMBERS_INJECTION::isOfType)) {
             // TODO(dpb): How could this ever happen, even in an invalid graph?
             throw new AssertionError(
                 "contribution binding keys should never have members injection bindings");
@@ -416,7 +412,7 @@ private void validateResolvedBindings(DependencyPath path) {
               return;
             }
           }
-          if (contributionBinding.bindingType().equals(BindingType.PRODUCTION)
+          if (contributionBinding.bindingType().equals(PRODUCTION)
               && doesPathRequireProvisionOnly(path)) {
             reportProviderMayNotDependOnProducer(path);
             return;
@@ -442,8 +438,7 @@ private void validateResolvedBindings(DependencyPath path) {
           }
           break;
         case MEMBERS_INJECTION:
-          if (!Iterables.all(
-              resolvedBindings.bindings(), BindingType.isOfType(BindingType.MEMBERS_INJECTION))) {
+          if (!Iterables.all(resolvedBindings.bindings(), MEMBERS_INJECTION::isOfType)) {
             // TODO(dpb): How could this ever happen, even in an invalid graph?
             throw new AssertionError(
                 "members injection binding keys should never have contribution bindings");
@@ -482,7 +477,8 @@ private void validateResolvedBindings(DependencyPath path) {
      */
     private ResolvedBindings inlineContributionsWithoutBindingElements(
         ResolvedBindings resolvedBinding) {
-      if (Iterables.all(resolvedBinding.bindings(), HAS_BINDING_ELEMENT)) {
+      if (Iterables.all(resolvedBinding.bindings(),
+          bindingDeclaration -> bindingDeclaration.bindingElement().isPresent())) {
         return resolvedBinding;
       }
 
@@ -528,8 +524,10 @@ private ResolvedBindings inlineContributionsWithoutBindingElements(
         ResolvedBindings resolvedBinding) {
       ResolvedBindings inlined = inlineContributionsWithoutBindingElements(resolvedBinding);
       return new ImmutableListMultimap.Builder<ContributionType, BindingDeclaration>()
-          .putAll(indexByContributionType(inlined.contributionBindings()))
-          .putAll(indexByContributionType(inlined.multibindingDeclarations()))
+          .putAll(Multimaps
+              .index(inlined.contributionBindings(), HasContributionType::contributionType))
+          .putAll(Multimaps
+              .index(inlined.multibindingDeclarations(), HasContributionType::contributionType))
           .build();
     }
 
@@ -816,14 +814,7 @@ private void validateBuilders() {
 
       Set<TypeElement> availableDependencies = subject.availableDependencies();
       Set<TypeElement> requiredDependencies =
-          Sets.filter(
-              availableDependencies,
-              new Predicate<TypeElement>() {
-                @Override
-                public boolean apply(TypeElement input) {
-                  return !Util.componentCanMakeNewInstances(input);
-                }
-              });
+          Sets.filter(availableDependencies, input -> !componentCanMakeNewInstances(input));
       final BuilderSpec spec = componentDesc.builderSpec().get();
       Map<TypeElement, ExecutableElement> allSetters = spec.methodMap();
 
@@ -833,12 +824,14 @@ public boolean apply(TypeElement input) {
       if (!extraSetters.isEmpty()) {
         Collection<ExecutableElement> excessMethods =
             Maps.filterKeys(allSetters, Predicates.in(extraSetters)).values();
-        Iterable<String> formatted = FluentIterable.from(excessMethods).transform(
-            new Function<ExecutableElement, String>() {
-              @Override public String apply(ExecutableElement input) {
-                return methodSignatureFormatter.format(input,
-                    Optional.of(MoreTypes.asDeclared(spec.builderDefinitionType().asType())));
-              }});
+        Iterable<String> formatted =
+            FluentIterable.from(excessMethods)
+                .transform(
+                    method ->
+                        methodSignatureFormatter.format(
+                            method,
+                            Optional.of(
+                                MoreTypes.asDeclared(spec.builderDefinitionType().asType()))));
         reportBuilder.addError(
             String.format(msgs.extraSetters(), formatted), spec.builderDefinitionType());
       }
@@ -1051,9 +1044,10 @@ private void reportDependsOnProductionExecutor(DependencyPath path) {
     private void reportDuplicateBindings(DependencyPath path) {
       ResolvedBindings resolvedBindings = path.currentResolvedBindings();
       if (FluentIterable.from(resolvedBindings.contributionBindings())
-          .transform(ContributionBinding.KIND)
+          .transform(ContributionBinding::bindingKind)
           // TODO(dpb): Kill with fire.
-          .anyMatch(or(Kind.IS_SYNTHETIC_MULTIBINDING_KIND, equalTo(Kind.SYNTHETIC_MAP)))) {
+          .anyMatch(
+              kind -> SYNTHETIC_MULTIBOUND_KINDS.contains(kind) || SYNTHETIC_MAP.equals(kind))) {
         // If any of the duplicate bindings results from multibinding contributions or declarations,
         // report the conflict using those contributions and declarations.
         reportMultipleContributionTypes(path);
@@ -1237,7 +1231,7 @@ private boolean breaksCycle(
                   }
                 }
               })
-          .transform(ResolvedRequest.DEPENDENCY_REQUEST)
+          .transform(ResolvedRequest::dependencyRequest)
           .toSet();
     }
   }
@@ -1267,11 +1261,7 @@ private void appendIndentedComponentsList(StringBuilder message, Iterable<TypeEl
    * a scoping annotation.
    */
   private ImmutableSet<TypeElement> scopedTypesIn(Set<TypeElement> types) {
-    return FluentIterable.from(types).filter(new Predicate<TypeElement>() {
-      @Override public boolean apply(TypeElement input) {
-        return !Scope.scopesOf(input).isEmpty();
-      }
-    }).toSet();
+    return FluentIterable.from(types).filter(type -> !Scope.scopesOf(type).isEmpty()).toSet();
   }
 
   /**
@@ -1307,14 +1297,8 @@ private boolean doesPathRequireProvisionOnly(DependencyPath path) {
   private FluentIterable<ContributionBinding> provisionsDependingOnLatestRequest(
       final DependencyPath path) {
     return FluentIterable.from(path.previousResolvedBindings().bindings())
-        .filter(BindingType.isOfType(BindingType.PROVISION))
-        .filter(
-            new Predicate<Binding>() {
-              @Override
-              public boolean apply(Binding binding) {
-                return binding.implicitDependencies().contains(path.currentDependencyRequest());
-              }
-            })
+        .filter(PROVISION::isOfType)
+        .filter(binding -> binding.implicitDependencies().contains(path.currentDependencyRequest()))
         .filter(ContributionBinding.class);
   }
 
@@ -1373,13 +1357,5 @@ private static ResolvedRequest create(
       return new AutoValue_BindingGraphValidator_ResolvedRequest(
           request, resolvedBindings, dependentBindings);
     }
-
-    static final Function<ResolvedRequest, DependencyRequest> DEPENDENCY_REQUEST =
-        new Function<ResolvedRequest, DependencyRequest>() {
-          @Override
-          public DependencyRequest apply(ResolvedRequest resolvedRequest) {
-            return resolvedRequest.dependencyRequest();
-          }
-        };
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java
index 446262f68..abe98cff0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java
@@ -46,7 +46,6 @@
 import static javax.lang.model.type.TypeKind.TYPEVAR;
 import static javax.lang.model.type.TypeKind.VOID;
 
-import com.google.common.base.Function;
 import com.google.common.base.Joiner;
 import com.google.common.cache.CacheBuilder;
 import com.google.common.cache.CacheLoader;
@@ -192,13 +191,7 @@ protected void checkEnclosingElement(ValidationReport.Builder<ExecutableElement>
           formatErrorMessage(
               BINDING_METHOD_NOT_IN_MODULE,
               FluentIterable.from(enclosingElementAnnotations)
-                  .transform(
-                      new Function<Class<?>, String>() {
-                        @Override
-                        public String apply(Class<?> clazz) {
-                          return clazz.getSimpleName();
-                        }
-                      })
+                  .transform(Class::getSimpleName)
                   .join(Joiner.on(" or @"))));
     }
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingType.java b/compiler/src/main/java/dagger/internal/codegen/BindingType.java
index 06baa23b2..e654b04a4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingType.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingType.java
@@ -16,9 +16,6 @@
 
 package dagger.internal.codegen;
 
-import com.google.common.base.Function;
-import com.google.common.base.Predicate;
-import com.google.common.base.Predicates;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import com.squareup.javapoet.ClassName;
@@ -42,6 +39,10 @@
   PRODUCTION(Producer.class),
   ;
 
+  boolean isOfType(HasBindingType hasBindingType) {
+    return this.equals(hasBindingType.bindingType());
+  }
+
   static final ImmutableSet<BindingType> CONTRIBUTION_TYPES =
       Sets.immutableEnumSet(PROVISION, PRODUCTION);
 
@@ -66,18 +67,4 @@
   ParameterizedTypeName frameworkClassOf(TypeName valueType) {
     return ParameterizedTypeName.get(ClassName.get(frameworkClass()), valueType);
   }
-
-  /** A predicate that passes for {@link HasBindingType}s with a given type. */
-  static Predicate<HasBindingType> isOfType(BindingType type) {
-    return Predicates.compose(Predicates.equalTo(type), BINDING_TYPE);
-  }
-
-  /** A function that returns {@link HasBindingType#bindingType()}. */
-  static final Function<HasBindingType, BindingType> BINDING_TYPE =
-      new Function<HasBindingType, BindingType>() {
-        @Override
-        public BindingType apply(HasBindingType hasBindingType) {
-          return hasBindingType.bindingType();
-        }
-      };
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingTypeMapper.java b/compiler/src/main/java/dagger/internal/codegen/BindingTypeMapper.java
index e5c2bbdfe..d40881a96 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingTypeMapper.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingTypeMapper.java
@@ -22,7 +22,6 @@
 import static dagger.internal.codegen.BindingType.PRODUCTION;
 import static dagger.internal.codegen.BindingType.PROVISION;
 
-import com.google.common.base.Function;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
 import dagger.producers.Producer;
@@ -82,13 +81,8 @@ static BindingTypeMapper forBindingType(BindingType bindingType) {
    * of the same key.
    */
   BindingType getBindingType(Iterable<DependencyRequest> requests) {
-    ImmutableSet<BindingType> classes = FluentIterable.from(requests)
-        .transform(new Function<DependencyRequest, BindingType>() {
-          @Override public BindingType apply(DependencyRequest request) {
-            return getBindingType(request.kind());
-          }
-        })
-        .toSet();
+    ImmutableSet<BindingType> classes =
+        FluentIterable.from(requests).transform(request -> getBindingType(request.kind())).toSet();
     if (classes.size() == 1) {
       return getOnlyElement(classes);
     } else if (classes.equals(CONTRIBUTION_TYPES)) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java b/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
index 1404536ab..7c8bf0eec 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
+++ b/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
@@ -16,10 +16,8 @@
 
 package dagger.internal.codegen;
 
-import com.google.common.base.Function;
 import com.google.common.collect.FluentIterable;
 import com.squareup.javapoet.CodeBlock;
-import com.squareup.javapoet.ParameterSpec;
 import java.util.Iterator;
 import javax.lang.model.type.TypeMirror;
 
@@ -57,28 +55,12 @@ static CodeBlock join(Iterable<CodeBlock> codeBlocks, String delimiter) {
   }
 
   static FluentIterable<CodeBlock> toCodeBlocks(Iterable<? extends TypeMirror> typeMirrors) {
-    return FluentIterable.from(typeMirrors).transform(TYPE_MIRROR_TO_CODE_BLOCK);
+    return FluentIterable.from(typeMirrors).transform(typeMirror -> CodeBlock.of("$T", typeMirror));
   }
 
   static CodeBlock stringLiteral(String toWrap) {
     return CodeBlock.of("$S", toWrap);
   }
 
-  private static final Function<TypeMirror, CodeBlock> TYPE_MIRROR_TO_CODE_BLOCK =
-      new Function<TypeMirror, CodeBlock>() {
-        @Override
-        public CodeBlock apply(TypeMirror typeMirror) {
-          return CodeBlock.of("$T", typeMirror);
-        }
-      };
-
-  static final Function<ParameterSpec, CodeBlock> PARAMETER_NAME =
-      new Function<ParameterSpec, CodeBlock>() {
-        @Override
-        public CodeBlock apply(ParameterSpec input) {
-          return CodeBlock.of("$N", input);
-        }
-      };
-
   private CodeBlocks() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 7b649b1d9..1d19ee815 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -33,9 +33,7 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Function;
 import com.google.common.base.Optional;
-import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableBiMap;
 import com.google.common.collect.ImmutableList;
@@ -188,30 +186,6 @@ boolean isProducer() {
           throw new AssertionError();
       }
     }
-
-    private static final Function<Kind, Class<? extends Annotation>> TO_ANNOTATION_TYPE =
-        new Function<Kind, Class<? extends Annotation>>() {
-          @Override
-          public Class<? extends Annotation> apply(Kind kind) {
-            return kind.annotationType();
-          }
-        };
-
-    static Function<Kind, Class<? extends Annotation>> toAnnotationType() {
-      return TO_ANNOTATION_TYPE;
-    }
-
-    private static final Function<Kind, Class<? extends Annotation>> TO_BUILDER_ANNOTATION_TYPE =
-        new Function<Kind, Class<? extends Annotation>>() {
-          @Override
-          public Class<? extends Annotation> apply(Kind kind) {
-            return kind.builderAnnotationType();
-          }
-        };
-
-    static Function<Kind, Class<? extends Annotation>> toBuilderAnnotationType() {
-      return TO_BUILDER_ANNOTATION_TYPE;
-    }
   }
 
   abstract Kind kind();
@@ -247,7 +221,7 @@ boolean isProducer() {
 
   ImmutableSet<TypeElement> transitiveModuleTypes() {
     return FluentIterable.from(transitiveModules())
-        .transform(ModuleDescriptor.getModuleElement())
+        .transform(ModuleDescriptor::moduleElement)
         .toSet();
   }
 
@@ -355,25 +329,13 @@ private static void addTransitiveModules(
   // interaction between the spec & generation
   abstract Optional<BuilderSpec> builderSpec();
 
+  /** A function that returns all {@link #scopes()} of its input. */
   @AutoValue
   abstract static class ComponentMethodDescriptor {
     abstract ComponentMethodKind kind();
     abstract Optional<DependencyRequest> dependencyRequest();
     abstract ExecutableElement methodElement();
 
-    /**
-     * A predicate that passes for {@link ComponentMethodDescriptor}s of one of the given kinds.
-     */
-    static Predicate<ComponentMethodDescriptor> isOfKind(ComponentMethodKind... kinds) {
-      final ImmutableSet<ComponentMethodKind> kindSet = ImmutableSet.copyOf(kinds);
-      return new Predicate<ComponentMethodDescriptor>() {
-        @Override
-        public boolean apply(ComponentMethodDescriptor descriptor) {
-          return kindSet.contains(descriptor.kind());
-        }
-      };
-    }
-
     static ComponentMethodDescriptor create(
         ComponentMethodKind kind,
         Optional<DependencyRequest> dependencyRequest,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
index 933ebd332..3d4f062d6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -103,7 +103,7 @@
         getElementsFromAnnotations(
             elementsByAnnotation,
             FluentIterable.from(componentKind.subcomponentKinds())
-                .transform(ComponentDescriptor.Kind.toBuilderAnnotationType())
+                .transform(ComponentDescriptor.Kind::builderAnnotationType)
                 .toSet());
     Map<Element, ValidationReport<TypeElement>> builderReportsBySubcomponent =
         processBuilders(subcomponentBuilderElements);
@@ -111,7 +111,7 @@
         getElementsFromAnnotations(
             elementsByAnnotation,
             FluentIterable.from(componentKind.subcomponentKinds())
-                .transform(ComponentDescriptor.Kind.toAnnotationType())
+                .transform(ComponentDescriptor.Kind::annotationType)
                 .toSet());
     Map<Element, ValidationReport<TypeElement>> reportsBySubcomponent =
         processSubcomponents(subcomponentElements, subcomponentBuilderElements);
@@ -156,7 +156,7 @@ private void generateComponent(BindingGraph bindingGraph) {
 
   private ImmutableSet<Element> getElementsFromAnnotations(
       final SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation,
-      ImmutableSet<Class<? extends Annotation>> annotations) {
+      ImmutableSet<? extends Class<? extends Annotation>> annotations) {
     return ImmutableSet.copyOf(
         Multimaps.filterKeys(elementsByAnnotation, Predicates.in(annotations)).values());
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
index bee627f5f..acced9d23 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
@@ -41,6 +41,7 @@
 import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.Reusable;
+import dagger.internal.codegen.ComponentDescriptor.Kind;
 import dagger.producers.ProductionComponent;
 import java.lang.annotation.Annotation;
 import java.util.Collection;
@@ -172,13 +173,13 @@ public ComponentValidationReport validate(final TypeElement subject,
             checkForAnnotations(
                 returnType,
                 FluentIterable.from(componentKind.subcomponentKinds())
-                    .transform(ComponentDescriptor.Kind.toAnnotationType())
+                    .transform(Kind::annotationType)
                     .toSet());
         Optional<AnnotationMirror> subcomponentBuilderAnnotation =
             checkForAnnotations(
                 returnType,
                 FluentIterable.from(componentKind.subcomponentKinds())
-                    .transform(ComponentDescriptor.Kind.toBuilderAnnotationType())
+                    .transform(Kind::builderAnnotationType)
                     .toSet());
         if (subcomponentAnnotation.isPresent()) {
           referencedSubcomponents.put(MoreTypes.asElement(returnType), method);
@@ -359,7 +360,7 @@ private void validateSubcomponentBuilderMethod(ValidationReport.Builder<TypeElem
   }
 
   private Optional<AnnotationMirror> checkForAnnotations(
-      TypeMirror type, final Set<Class<? extends Annotation>> annotations) {
+      TypeMirror type, final Set<? extends Class<? extends Annotation>> annotations) {
     return type.accept(
         new SimpleTypeVisitor6<Optional<AnnotationMirror>, Void>() {
           @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
index f14e3ffbc..635dbeefc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
@@ -24,9 +24,7 @@
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
 
-import com.google.common.base.Function;
 import com.google.common.base.Joiner;
-import com.google.common.base.Predicate;
 import com.google.common.base.Splitter;
 import com.google.common.collect.ImmutableBiMap;
 import com.google.common.collect.ImmutableListMultimap;
@@ -41,7 +39,6 @@
 import java.util.Map;
 import java.util.Map.Entry;
 import javax.lang.model.element.Name;
-import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
@@ -87,12 +84,8 @@ private UniqueSubcomponentNamesGenerator(BindingGraph graph) {
       componentDescriptorsBySimpleName =
           Multimaps.index(
               graph.componentDescriptors(),
-              new Function<ComponentDescriptor, String>() {
-                @Override
-                public String apply(ComponentDescriptor componentDescriptor) {
-                  return componentDescriptor.componentDefinitionType().getSimpleName().toString();
-                }
-              });
+              componentDescriptor ->
+                  componentDescriptor.componentDefinitionType().getSimpleName().toString());
       componentQualifiedNamePieces = qualifiedNames(graph.componentDescriptors());
     }
 
@@ -197,12 +190,6 @@ protected void addFactoryMethods() {
   /** {@code true} if all of the graph's required dependencies can be automatically constructed. */
   private boolean canInstantiateAllRequirements() {
     return !Iterables.any(
-        graph.componentRequirements(),
-        new Predicate<TypeElement>() {
-          @Override
-          public boolean apply(TypeElement dependency) {
-            return requiresAPassedInstance(elements, dependency);
-          }
-        });
+        graph.componentRequirements(), dependency -> requiresAPassedInstance(elements, dependency));
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
index 5c91e2ace..9ab8dd89b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -25,7 +25,6 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
-import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
@@ -186,15 +185,7 @@ public Void visitDeclared(DeclaredType t, Void aVoid) {
         @Override
         public ImmutableList<TypeMirror> visitArray(
             List<? extends AnnotationValue> vals, String elementName) {
-          return FluentIterable.from(vals)
-              .transform(
-                  new Function<AnnotationValue, TypeMirror>() {
-                    @Override
-                    public TypeMirror apply(AnnotationValue typeValue) {
-                      return TO_TYPE.visit(typeValue);
-                    }
-                  })
-              .toList();
+          return FluentIterable.from(vals).transform(TO_TYPE::visit).toList();
         }
 
         @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index 88436bbc5..7f89dd28e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -28,10 +28,8 @@
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Equivalence.Wrapper;
-import com.google.common.base.Function;
 import com.google.common.base.Optional;
-import com.google.common.base.Predicate;
-import com.google.common.base.Predicates;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Multimaps;
 import com.google.common.util.concurrent.ListenableFuture;
@@ -63,17 +61,6 @@
   /** Returns the type that specifies this' nullability, absent if not nullable. */
   abstract Optional<DeclaredType> nullableType();
 
-  /**
-   * A function that returns the kind of a binding.
-   */
-  static final Function<ContributionBinding, Kind> KIND =
-      new Function<ContributionBinding, Kind>() {
-        @Override
-        public Kind apply(ContributionBinding binding) {
-          return binding.bindingKind();
-        }
-      };
-
   abstract Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedMapKey();
 
   final Optional<AnnotationMirror> mapKey() {
@@ -152,11 +139,8 @@ public Kind apply(ContributionBinding binding) {
     COMPONENT_PRODUCTION,
     ;
 
-    /**
-     * A predicate that tests whether a kind is for synthetic multibindings.
-     */
-    static final Predicate<Kind> IS_SYNTHETIC_MULTIBINDING_KIND =
-        Predicates.in(immutableEnumSet(SYNTHETIC_MULTIBOUND_SET, SYNTHETIC_MULTIBOUND_MAP));
+    static final ImmutableSet<Kind> SYNTHETIC_MULTIBOUND_KINDS =
+        immutableEnumSet(SYNTHETIC_MULTIBOUND_SET, SYNTHETIC_MULTIBOUND_MAP);
 
     /**
      * {@link #SYNTHETIC_MULTIBOUND_SET} or {@link #SYNTHETIC_MULTIBOUND_MAP}, depending on the key.
@@ -189,18 +173,6 @@ boolean requiresModuleInstance() {
     return !modifiers.contains(ABSTRACT) && !modifiers.contains(STATIC);
   }
 
-  /**
-   * A predicate that passes for binding declarations for which {@link #requiresModuleInstance()} is
-   * {@code true}.
-   */
-  static final Predicate<ContributionBinding> REQUIRES_MODULE_INSTANCE =
-      new Predicate<ContributionBinding>() {
-        @Override
-        public boolean apply(ContributionBinding bindingDeclaration) {
-          return bindingDeclaration.requiresModuleInstance();
-        }
-      };
-
   /**
    * The strategy for getting an instance of a factory for a {@link ContributionBinding}.
    */
@@ -269,13 +241,10 @@ final TypeMirror factoryType() {
     return ImmutableSetMultimap.copyOf(
         Multimaps.index(
             mapBindings,
-            new Function<ContributionBinding, Object>() {
-              @Override
-              public Object apply(ContributionBinding mapBinding) {
-                AnnotationMirror mapKey = mapBinding.mapKey().get();
-                Optional<? extends AnnotationValue> unwrappedValue = unwrapValue(mapKey);
-                return unwrappedValue.isPresent() ? unwrappedValue.get().getValue() : mapKey;
-              }
+            mapBinding -> {
+              AnnotationMirror mapKey = mapBinding.mapKey().get();
+              Optional<? extends AnnotationValue> unwrappedValue = unwrapValue(mapKey);
+              return unwrappedValue.isPresent() ? unwrappedValue.get().getValue() : mapKey;
             }));
   }
 
@@ -287,13 +256,8 @@ public Object apply(ContributionBinding mapBinding) {
     return ImmutableSetMultimap.copyOf(
         Multimaps.index(
             mapBindings,
-            new Function<ContributionBinding, Equivalence.Wrapper<DeclaredType>>() {
-              @Override
-              public Equivalence.Wrapper<DeclaredType> apply(ContributionBinding mapBinding) {
-                return MoreTypes.equivalence()
-                    .wrap(mapBinding.mapKey().get().getAnnotationType());
-              }
-            }));
+            mapBinding ->
+                MoreTypes.equivalence().wrap(mapBinding.mapKey().get().getAnnotationType())));
   }
 
   /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionType.java b/compiler/src/main/java/dagger/internal/codegen/ContributionType.java
index ebf26e91c..5b184aedb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionType.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionType.java
@@ -18,9 +18,6 @@
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 
-import com.google.common.base.Function;
-import com.google.common.collect.ImmutableListMultimap;
-import com.google.common.collect.Multimaps;
 import dagger.Provides;
 import dagger.multibindings.ElementsIntoSet;
 import dagger.multibindings.IntoMap;
@@ -111,18 +108,4 @@ static ContributionType fromBindingMethod(ExecutableElement method) {
       return ContributionType.UNIQUE;
     }
   }
-
-  /** Indexes objects by their contribution type. */
-  static <T extends HasContributionType>
-      ImmutableListMultimap<ContributionType, T> indexByContributionType(
-          Iterable<T> haveContributionTypes) {
-    return Multimaps.index(
-        haveContributionTypes,
-        new Function<HasContributionType, ContributionType>() {
-          @Override
-          public ContributionType apply(HasContributionType hasContributionType) {
-            return hasContributionType.contributionType();
-          }
-        });
-  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index fea0f29cc..3eceffff5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -32,7 +32,6 @@
 
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
@@ -69,12 +68,6 @@
 // TODO(gak): Set bindings and the permutations thereof need to be addressed
 @AutoValue
 abstract class DependencyRequest {
-  static final Function<DependencyRequest, BindingKey> BINDING_KEY_FUNCTION =
-      new Function<DependencyRequest, BindingKey>() {
-        @Override public BindingKey apply(DependencyRequest request) {
-          return request.bindingKey();
-        }
-      };
 
   enum Kind {
     /** A default request for an instance.  E.g.: {@code Blah} */
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
index 6c809dfd4..bbd10b320 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
@@ -21,7 +21,6 @@
 import static dagger.internal.codegen.ErrorMessages.INDENT;
 
 import com.google.auto.common.MoreElements;
-import com.google.common.base.Function;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
 import com.google.common.base.Predicates;
@@ -31,7 +30,6 @@
 import dagger.Lazy;
 import dagger.Provides;
 import dagger.internal.codegen.BindingGraphValidator.DependencyPath;
-import dagger.internal.codegen.BindingGraphValidator.ResolvedRequest;
 import dagger.producers.Produces;
 import java.util.List;
 import javax.inject.Inject;
@@ -90,15 +88,12 @@ String toDependencyTrace(DependencyPath dependencyPath) {
             dependencyPath
                 .resolvedRequests()
                 .transform(
-                    new Function<ResolvedRequest, String>() {
-                      @Override
-                      public String apply(ResolvedRequest resolvedRequest) {
-                        ImmutableSet<OptionalBindingDeclaration> optionalBindingDeclarations =
-                            resolvedRequest.dependentOptionalBindingDeclarations();
-                        return optionalBindingDeclarations.isEmpty()
-                            ? format(resolvedRequest.dependencyRequest())
-                            : formatSyntheticOptionalBindingDependency(optionalBindingDeclarations);
-                      }
+                    resolvedRequest -> {
+                      ImmutableSet<OptionalBindingDeclaration> optionalBindingDeclarations =
+                          resolvedRequest.dependentOptionalBindingDeclarations();
+                      return optionalBindingDeclarations.isEmpty()
+                          ? format(resolvedRequest.dependencyRequest())
+                          : formatSyntheticOptionalBindingDependency(optionalBindingDeclarations);
                     })
                 .filter(Predicates.not(Predicates.equalTo("")))
                 .toList()
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 0796afb42..653a0538a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -205,7 +205,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
                 "return new $T($L)",
                 parameterizedGeneratedTypeNameForBinding(binding),
                 makeParametersCodeBlock(
-                    Lists.transform(params, CodeBlocks.PARAMETER_NAME)));
+                    Lists.transform(params, input -> CodeBlock.of("$N", input))));
             break;
           default:
             throw new AssertionError();
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkDependency.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkDependency.java
index ceb820350..1e0b02e5e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkDependency.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkDependency.java
@@ -109,9 +109,7 @@
       frameworkDependencies.add(
           new AutoValue_FrameworkDependency(
               getOnlyElement(
-                  FluentIterable.from(requests)
-                      .transform(DependencyRequest.BINDING_KEY_FUNCTION)
-                      .toSet()),
+                  FluentIterable.from(requests).transform(DependencyRequest::bindingKey).toSet()),
               bindingTypeMapper.getBindingType(requests),
               ImmutableSet.copyOf(requests)));
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectValidator.java b/compiler/src/main/java/dagger/internal/codegen/InjectValidator.java
index c22e38a32..ca489c1d4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectValidator.java
@@ -38,6 +38,7 @@
 import static dagger.internal.codegen.ErrorMessages.provisionMayNotDependOnProducerType;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
 import static dagger.internal.codegen.InjectionAnnotations.getScopes;
+import static dagger.internal.codegen.InjectionAnnotations.injectedConstructors;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -47,8 +48,6 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Optional;
-import com.google.common.base.Predicate;
-import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
 import java.util.Set;
 import javax.inject.Inject;
@@ -157,13 +156,7 @@ InjectValidator whenGeneratingCode() {
     }
 
     // This is computationally expensive, but probably preferable to a giant index
-    FluentIterable<ExecutableElement> injectConstructors = FluentIterable.from(
-        ElementFilter.constructorsIn(enclosingElement.getEnclosedElements()))
-            .filter(new Predicate<ExecutableElement>() {
-              @Override public boolean apply(ExecutableElement input) {
-                return isAnnotationPresent(input, Inject.class);
-              }
-            });
+    ImmutableSet<ExecutableElement> injectConstructors = injectedConstructors(enclosingElement);
 
     if (injectConstructors.size() > 1) {
       builder.addError(MULTIPLE_INJECT_CONSTRUCTORS, constructorElement);
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
index 403f2e7d5..9b2df2a06 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
@@ -22,7 +22,6 @@
 
 import com.google.auto.common.AnnotationMirrors;
 import com.google.common.base.Optional;
-import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
 import javax.inject.Inject;
@@ -65,13 +64,7 @@
   /** Returns the constructors in {@code type} that are annotated with {@link Inject}. */
   static ImmutableSet<ExecutableElement> injectedConstructors(TypeElement type) {
     return FluentIterable.from(constructorsIn(type.getEnclosedElements()))
-        .filter(
-            new Predicate<ExecutableElement>() {
-              @Override
-              public boolean apply(ExecutableElement constructor) {
-                return isAnnotationPresent(constructor, Inject.class);
-              }
-            })
+        .filter(constructor -> isAnnotationPresent(constructor, Inject.class))
         .toSet();
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index a05ae0bc9..8bc1f1bef 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -36,7 +36,6 @@
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
-import com.google.common.base.Function;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
@@ -295,15 +294,7 @@ public String toString() {
    * Indexes {@code haveKeys} by {@link HasKey#key()}.
    */
   static <T extends HasKey> ImmutableSetMultimap<Key, T> indexByKey(Iterable<T> haveKeys) {
-    return ImmutableSetMultimap.copyOf(
-        Multimaps.index(
-            haveKeys,
-            new Function<HasKey, Key>() {
-              @Override
-              public Key apply(HasKey hasKey) {
-                return hasKey.key();
-              }
-            }));
+    return ImmutableSetMultimap.copyOf(Multimaps.index(haveKeys, HasKey::key));
   }
 
   static final class Factory {
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index d441ce7ba..24404c6aa 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -26,10 +26,7 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Function;
 import com.google.common.base.Optional;
-import com.google.common.base.Predicate;
-import com.google.common.collect.ComparisonChain;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSortedSet;
@@ -106,12 +103,8 @@ public BindingType bindingType() {
   boolean hasLocalInjectionSites() {
     return FluentIterable.from(injectionSites())
         .anyMatch(
-            new Predicate<InjectionSite>() {
-              @Override
-              public boolean apply(InjectionSite injectionSite) {
-                return injectionSite.element().getEnclosingElement().equals(membersInjectedType());
-              }
-            });
+            injectionSite ->
+                injectionSite.element().getEnclosingElement().equals(membersInjectedType()));
   }
 
   @AutoValue
@@ -127,7 +120,7 @@ public boolean apply(InjectionSite injectionSite) {
 
     abstract ImmutableSet<DependencyRequest> dependencies();
     
-    protected int indexAmongSiblingMembers(InjectionSite injectionSite) {
+    static int indexAmongSiblingMembers(InjectionSite injectionSite) {
       return injectionSite
           .element()
           .getEnclosingElement()
@@ -202,24 +195,12 @@ MembersInjectionBinding forInjectedType(
       ImmutableSortedSet<InjectionSite> injectionSites = getInjectionSites(declaredType);
       ImmutableSet<DependencyRequest> dependencies =
           FluentIterable.from(injectionSites)
-              .transformAndConcat(
-                  new Function<InjectionSite, Set<DependencyRequest>>() {
-                    @Override
-                    public Set<DependencyRequest> apply(InjectionSite input) {
-                      return input.dependencies();
-                    }
-                  })
+              .transformAndConcat(InjectionSite::dependencies)
               .toSet();
 
       Optional<Key> parentKey =
           MoreTypes.nonObjectSuperclass(types, elements, declaredType)
-              .transform(
-                  new Function<DeclaredType, Key>() {
-                    @Override
-                    public Key apply(DeclaredType superclass) {
-                      return keyFactory.forMembersInjectedType(superclass);
-                    }
-                  });
+              .transform(keyFactory::forMembersInjectedType);
 
       Key key = keyFactory.forMembersInjectedType(declaredType);
       TypeElement typeElement = MoreElements.asType(declaredType.asElement());
@@ -263,23 +244,16 @@ public Key apply(DeclaredType superclass) {
         }
       }
       return ImmutableSortedSet.copyOf(
-          new Comparator<InjectionSite>() {
-            @Override
-            public int compare(InjectionSite left, InjectionSite right) {
-              return ComparisonChain.start()
-                  // supertypes before subtypes
-                  .compare(
-                      ancestors.indexOf(right.element().getEnclosingElement()),
-                      ancestors.indexOf(left.element().getEnclosingElement()))
-                  // fields before methods
-                  .compare(left.element().getKind(), right.element().getKind())
-                  // then sort by whichever element comes first in the parent
-                  // this isn't necessary, but makes the processor nice and predictable
-                  .compare(
-                      left.indexAmongSiblingMembers(left), right.indexAmongSiblingMembers(right))
-                  .result();
-            }
-          },
+          // supertypes before subtypes
+          Comparator.comparing(
+                  (InjectionSite injectionSite) ->
+                      ancestors.indexOf(injectionSite.element().getEnclosingElement()))
+              .reversed()
+              // fields before methods
+              .thenComparing(injectionSite -> injectionSite.element().getKind())
+              // then sort by whichever element comes first in the parent
+              // this isn't necessary, but makes the processor nice and predictable
+              .thenComparing(InjectionSite::indexAmongSiblingMembers),
           injectionSites);
     }
 
@@ -311,8 +285,7 @@ private boolean shouldBeInjected(
     }
 
     private final ElementVisitor<Optional<InjectionSite>, DeclaredType> injectionSiteVisitor =
-        new ElementKindVisitor6<Optional<InjectionSite>, DeclaredType>(
-            Optional.<InjectionSite>absent()) {
+        new ElementKindVisitor6<Optional<InjectionSite>, DeclaredType>(Optional.absent()) {
           @Override
           public Optional<InjectionSite> visitExecutableAsMethod(
               ExecutableElement e, DeclaredType type) {
@@ -326,7 +299,7 @@ private boolean shouldBeInjected(
                     && !e.getModifiers().contains(PRIVATE)
                     && !e.getModifiers().contains(STATIC))
                 ? Optional.of(injectionSiteForInjectField(e, type))
-                : Optional.<InjectionSite>absent();
+                : Optional.absent();
           }
         };
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
index d50fa054a..647b65c59 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
@@ -30,7 +30,6 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
@@ -55,13 +54,6 @@
 
 @AutoValue
 abstract class ModuleDescriptor {
-  static final Function<ModuleDescriptor, TypeElement> getModuleElement() {
-    return new Function<ModuleDescriptor, TypeElement>() {
-      @Override public TypeElement apply(ModuleDescriptor input) {
-        return input.moduleElement();
-      }
-    };
-  }
 
   abstract TypeElement moduleElement();
 
@@ -201,8 +193,7 @@ ModuleDescriptor create(TypeElement moduleElement) {
 
       return new AutoValue_ModuleDescriptor(
           moduleElement,
-          ImmutableSet.copyOf(
-              collectIncludedModules(new LinkedHashSet<ModuleDescriptor>(), moduleElement)),
+          ImmutableSet.copyOf(collectIncludedModules(new LinkedHashSet<>(), moduleElement)),
           bindings.build(),
           multibindingDeclarations.build(),
           subcomponentDeclarationFactory.forModule(moduleElement),
@@ -223,9 +214,11 @@ ModuleDescriptor create(TypeElement moduleElement) {
       }
       Optional<AnnotationMirror> moduleAnnotation = getModuleAnnotation(moduleElement);
       if (moduleAnnotation.isPresent()) {
-        for (TypeMirror moduleIncludesType : getModuleIncludes(moduleAnnotation.get())) {
-          includedModules.add(create(MoreTypes.asTypeElement(moduleIncludesType)));
-        }
+        getModuleIncludes(moduleAnnotation.get())
+            .stream()
+            .map(MoreTypes::asTypeElement)
+            .map(this::create)
+            .forEach(includedModules::add);
       }
       return includedModules;
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
index ea58b7013..51e85504c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
@@ -36,15 +36,14 @@
 import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS;
 import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULE_NOT_ANNOTATED;
 import static dagger.internal.codegen.Util.isAnyAnnotationPresent;
+import static java.util.stream.Collectors.joining;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.STATIC;
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.common.Visibility;
-import com.google.common.base.Function;
 import com.google.common.base.Joiner;
-import com.google.common.base.Predicate;
 import com.google.common.collect.ArrayListMultimap;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
@@ -54,6 +53,7 @@
 import dagger.Binds;
 import dagger.Module;
 import dagger.Subcomponent;
+import dagger.internal.codegen.ModuleDescriptor.Kind;
 import dagger.multibindings.Multibinds;
 import dagger.producers.ProducerModule;
 import dagger.producers.ProductionSubcomponent;
@@ -243,16 +243,7 @@ private void validateReferencedModules(
 
   private static ImmutableSet<? extends Class<? extends Annotation>> includedModuleClasses(
       ImmutableSet<ModuleDescriptor.Kind> validModuleKinds) {
-    return FluentIterable.from(validModuleKinds)
-        .transformAndConcat(
-            new Function<ModuleDescriptor.Kind, Set<? extends Class<? extends Annotation>>>() {
-              @Override
-              public Set<? extends Class<? extends Annotation>> apply(
-                  ModuleDescriptor.Kind moduleKind) {
-                return moduleKind.includesTypes();
-              }
-            })
-        .toSet();
+    return FluentIterable.from(validModuleKinds).transformAndConcat(Kind::includesTypes).toSet();
   }
 
   /**
@@ -287,29 +278,16 @@ public Void visitDeclared(DeclaredType t, Void p) {
               boolean isIncludedModule =
                   any(
                       includedModuleClasses,
-                      new Predicate<Class<? extends Annotation>>() {
-                        @Override
-                        public boolean apply(Class<? extends Annotation> otherClass) {
-                          return MoreElements.isAnnotationPresent(element, otherClass);
-                        }
-                      });
+                      otherClass -> MoreElements.isAnnotationPresent(element, otherClass));
               if (!isIncludedModule) {
                 builder.addError(
                     String.format(
                         REFERENCED_MODULE_NOT_ANNOTATED,
                         element.getQualifiedName(),
                         (includedModuleClasses.size() > 1 ? "one of " : "")
-                            + Joiner.on(", ")
-                                .join(
-                                    FluentIterable.from(includedModuleClasses)
-                                        .transform(
-                                            new Function<Class<? extends Annotation>, String>() {
-                                              @Override
-                                              public String apply(
-                                                  Class<? extends Annotation> otherClass) {
-                                                return "@" + otherClass.getSimpleName();
-                                              }
-                                            }))),
+                            + includedModuleClasses.stream()
+                                .map(otherClass -> "@" + otherClass.getSimpleName())
+                                .collect(joining(", "))),
                     subject);
               }
               return null;
@@ -406,20 +384,8 @@ private void validateModuleVisibility(
               FluentIterable.from(
                       getModuleIncludes(
                           getAnnotationMirror(moduleElement, moduleKind.moduleAnnotation()).get()))
-                  .transform(
-                      new Function<TypeMirror, Element>() {
-                        @Override
-                        public Element apply(TypeMirror input) {
-                          return types.asElement(input);
-                        }
-                      })
-                  .filter(
-                      new Predicate<Element>() {
-                        @Override
-                        public boolean apply(Element input) {
-                          return effectiveVisibilityOfElement(input).compareTo(PUBLIC) < 0;
-                        }
-                      })
+                  .transform(types::asElement)
+                  .filter(element -> effectiveVisibilityOfElement(element).compareTo(PUBLIC) < 0)
                   .toSet();
           if (!nonPublicModules.isEmpty()) {
             reportBuilder.addError(
diff --git a/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
index 4a489aab7..dc9d3f0f6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
@@ -16,23 +16,23 @@
 
 package dagger.internal.codegen;
 
+import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
-import static dagger.internal.codegen.TypeNames.SET_OF_FACTORIES;
+import static dagger.internal.codegen.TypeNames.PRODUCTION_COMPONENT_MONITOR_FACTORY;
 import static dagger.internal.codegen.TypeNames.providerOf;
+import static dagger.internal.codegen.TypeNames.setOf;
 import static javax.lang.model.element.Modifier.ABSTRACT;
-import static javax.lang.model.element.Modifier.FINAL;
-import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
 
 import com.google.common.base.Optional;
-import com.squareup.javapoet.AnnotationSpec;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.TypeSpec;
 import dagger.Module;
-import dagger.Multibindings;
 import dagger.Provides;
+import dagger.multibindings.Multibinds;
 import dagger.producers.ProductionScope;
 import dagger.producers.monitoring.ProductionComponentMonitor;
 import dagger.producers.monitoring.internal.Monitors;
@@ -62,29 +62,36 @@ ClassName nameGeneratedType(TypeElement componentElement) {
   Optional<TypeSpec.Builder> write(ClassName generatedTypeName, TypeElement componentElement) {
     return Optional.of(
         classBuilder(generatedTypeName)
-            .addAnnotation(
-                AnnotationSpec.builder(Module.class)
-                    .build())
-            .addModifiers(FINAL)
-            .addType(
-                TypeSpec.interfaceBuilder("DefaultSetOfFactories")
-                    .addAnnotation(Multibindings.class)
-                    .addMethod(
-                        MethodSpec.methodBuilder("setOfFactories")
-                            .addModifiers(PUBLIC, ABSTRACT)
-                            .returns(SET_OF_FACTORIES)
-                            .build())
-                    .build())
-            .addMethod(
-                methodBuilder("monitor")
-                    .returns(ProductionComponentMonitor.class)
-                    .addModifiers(STATIC)
-                    .addAnnotation(Provides.class)
-                    .addAnnotation(ProductionScope.class)
-                    .addParameter(providerOf(ClassName.get(componentElement.asType())), "component")
-                    .addParameter(providerOf(SET_OF_FACTORIES), "factories")
-                    .addStatement(
-                        "return $T.createMonitorForComponent(component, factories)", Monitors.class)
-                    .build()));
+.addAnnotation(Module.class)
+            .addModifiers(ABSTRACT)
+            .addMethod(privateConstructor())
+            .addMethod(setOfFactories())
+            .addMethod(monitor(componentElement)));
+  }
+
+  private MethodSpec privateConstructor() {
+    return constructorBuilder().addModifiers(PRIVATE).build();
+  }
+
+  private MethodSpec setOfFactories() {
+    return methodBuilder("setOfFactories")
+        .addAnnotation(Multibinds.class)
+        .addModifiers(ABSTRACT)
+        .returns(setOf(PRODUCTION_COMPONENT_MONITOR_FACTORY))
+        .build();
+  }
+
+  private MethodSpec monitor(TypeElement componentElement) {
+    return methodBuilder("monitor")
+        .returns(ProductionComponentMonitor.class)
+        .addModifiers(STATIC)
+        .addAnnotation(Provides.class)
+        .addAnnotation(ProductionScope.class)
+        .addParameter(providerOf(ClassName.get(componentElement.asType())), "component")
+        .addParameter(
+            providerOf(setOf(PRODUCTION_COMPONENT_MONITOR_FACTORY)), "factories")
+        .addStatement(
+            "return $T.createMonitorForComponent(component, factories)", Monitors.class)
+        .build();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/OptionalFactories.java b/compiler/src/main/java/dagger/internal/codegen/OptionalFactories.java
index fea103f09..d0a268e12 100644
--- a/compiler/src/main/java/dagger/internal/codegen/OptionalFactories.java
+++ b/compiler/src/main/java/dagger/internal/codegen/OptionalFactories.java
@@ -26,17 +26,14 @@
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
 import static dagger.internal.codegen.TypeNames.PROVIDER;
 import static dagger.internal.codegen.TypeNames.listenableFutureOf;
-import static dagger.internal.codegen.TypeNames.optionalOf;
 import static dagger.internal.codegen.TypeNames.providerOf;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
 
+import com.google.auto.value.AutoValue;
 import com.google.common.base.Function;
-import com.google.common.base.Optional;
-import com.google.common.collect.HashBasedTable;
-import com.google.common.collect.Table;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.squareup.javapoet.ClassName;
@@ -50,76 +47,153 @@
 import com.squareup.javapoet.TypeVariableName;
 import dagger.internal.InstanceFactory;
 import dagger.internal.Preconditions;
+import dagger.internal.codegen.OptionalType.OptionalKind;
 import dagger.producers.Producer;
 import dagger.producers.internal.Producers;
+import java.util.Comparator;
+import java.util.Map;
+import java.util.TreeMap;
 import javax.inject.Provider;
-import javax.lang.model.type.TypeMirror;
 
 /** The nested class and static methods required by the component to implement optional bindings. */
-// TODO(dpb): Name classes correctly if a component uses both Guava and JDK Optional.
+// TODO(dpb): Name members simply if a component uses only one of Guava or JDK Optional.
 final class OptionalFactories {
 
-  /**
-   * A field specification for a {@link Provider<Optional<T>>} that always returns {@code
-   * Optional.absent()}.
-   */
-  private static final FieldSpec ABSENT_OPTIONAL_PROVIDER_FIELD =
-      FieldSpec.builder(PROVIDER, "ABSENT_OPTIONAL_PROVIDER", PRIVATE, STATIC, FINAL)
-          .addAnnotation(SUPPRESS_WARNINGS_RAWTYPES)
-          .initializer("$T.create($T.absent())", InstanceFactory.class, Optional.class)
-          .addJavadoc(
-              "A {@link $T} that returns {@code $T.absent()}.", Provider.class, Optional.class)
-          .build();
-
-  /**
-   * A method specification for a {@link Provider<Optional<T>>} that always returns {@code
-   * Optional.absent()}.
-   */
-  private static final MethodSpec ABSENT_OPTIONAL_PROVIDER_METHOD =
-      methodBuilder("absentOptionalProvider")
-          .addModifiers(PRIVATE, STATIC)
-          .addTypeVariable(TypeVariableName.get("T"))
-          .returns(providerOf(optionalOf(TypeVariableName.get("T"))))
-          .addJavadoc(
-              "Returns a {@link $T} that returns {@code $T.absent()}.",
-              Provider.class,
-              Optional.class)
-          .addCode("$L // safe covariant cast\n", SUPPRESS_WARNINGS_UNCHECKED)
-          .addCode(
-              "$1T provider = ($1T) $2N;",
-              providerOf(optionalOf(TypeVariableName.get("T"))),
-              ABSENT_OPTIONAL_PROVIDER_FIELD)
-          .addCode("return provider;")
-          .build();
-
   /**
    * The factory classes that implement {@code Provider<Optional<T>>} or {@code
    * Producer<Optional<T>>} for present optional bindings for a given kind of dependency request
    * within the component.
    *
-   * <p>The row key specifies whether the class implements {@link Provider} or {@link Producer}, and
-   * the column key specifies the kind of dependency request represented by {@code T}.
+   * <p>The key is the {@code Provider<Optional<T>>} type.
    */
-  private final Table<BindingType, DependencyRequest.Kind, TypeSpec> presentFactoryClasses =
-      HashBasedTable.create();
+  private final Map<PresentFactorySpec, TypeSpec> presentFactoryClasses =
+      new TreeMap<>(
+          Comparator.comparing(PresentFactorySpec::valueKind)
+              .thenComparing(PresentFactorySpec::bindingType)
+              .thenComparing(PresentFactorySpec::optionalKind));
 
   /**
-   * If the component contains any absent optional bindings, this will be the member select for a
-   * static method that returns a Provider<Optional<T>> that always returns {@link
-   * Optional#absent()}.
+   * The static methods that return a {@code Provider<Optional<T>>} that always returns an absent
+   * value.
    */
-  private Optional<CodeBlock> absentOptionalProviderMethod = Optional.absent();
+  private final Map<OptionalKind, MethodSpec> absentOptionalProviderMethods = new TreeMap<>();
+
+  /**
+   * The static fields for {@code Provider<Optional<T>>} objects that always return an absent value.
+   */
+  private final Map<OptionalKind, FieldSpec> absentOptionalProviderFields = new TreeMap<>();
 
   /**
    * Returns an expression that calls a static method that returns a {@code Provider<Optional<T>>}
    * for absent optional bindings.
    */
-  CodeBlock absentOptionalProvider() {
-    if (!absentOptionalProviderMethod.isPresent()) {
-      absentOptionalProviderMethod =
-          Optional.of(CodeBlock.of("$N()", ABSENT_OPTIONAL_PROVIDER_METHOD));
+  CodeBlock absentOptionalProvider(ContributionBinding binding) {
+    OptionalKind optionalKind = OptionalType.from(binding.key()).kind();
+    return CodeBlock.of(
+        "$N()",
+        absentOptionalProviderMethods.computeIfAbsent(
+            optionalKind, this::absentOptionalProviderMethod));
+  }
+
+  /**
+   * Creates a method specification for a {@link Provider<Optional<T>>} that always returns an
+   * absent value.
+   */
+  private MethodSpec absentOptionalProviderMethod(OptionalKind optionalKind) {
+    TypeVariableName typeVariable = TypeVariableName.get("T");
+    return methodBuilder(
+            String.format(
+                "absent%sProvider", UPPER_UNDERSCORE.to(UPPER_CAMEL, optionalKind.name())))
+        .addModifiers(PRIVATE, STATIC)
+        .addTypeVariable(typeVariable)
+        .returns(providerOf(optionalKind.of(typeVariable)))
+        .addJavadoc(
+            "Returns a {@link $T} that returns {@code $L}.",
+            Provider.class,
+            optionalKind.absentValueExpression())
+        .addCode("$L // safe covariant cast\n", SUPPRESS_WARNINGS_UNCHECKED)
+        .addCode(
+            "$1T provider = ($1T) $2N;",
+            providerOf(optionalKind.of(typeVariable)),
+            absentOptionalProviderFields.computeIfAbsent(
+                optionalKind, this::absentOptionalProviderField))
+        .addCode("return provider;")
+        .build();
+  }
+
+  /**
+   * Creates a field specification for a {@link Provider<Optional<T>>} that always returns an absent
+   * value.
+   */
+  private FieldSpec absentOptionalProviderField(OptionalKind optionalKind) {
+    return FieldSpec.builder(
+            PROVIDER,
+            String.format("ABSENT_%s_PROVIDER", optionalKind.name()),
+            PRIVATE,
+            STATIC,
+            FINAL)
+        .addAnnotation(SUPPRESS_WARNINGS_RAWTYPES)
+        .initializer("$T.create($L)", InstanceFactory.class, optionalKind.absentValueExpression())
+        .addJavadoc(
+            "A {@link $T} that returns {@code $L}.",
+            Provider.class,
+            optionalKind.absentValueExpression())
+        .build();
+  }
+
+  /** Information about the type of a factory for present bindings. */
+  @AutoValue
+  abstract static class PresentFactorySpec {
+    /** Whether the factory is a {@link Provider} or a {@link Producer}. */
+    abstract BindingType bindingType();
+
+    /** What kind of {@code Optional} is returned. */
+    abstract OptionalKind optionalKind();
+
+    /** The kind of request satisfied by the value of the {@code Optional}. */
+    abstract DependencyRequest.Kind valueKind();
+
+    /** The type variable for the factory class. */
+    TypeVariableName typeVariable() {
+      return TypeVariableName.get("T");
+    }
+
+    /** The type contained by the {@code Optional}. */
+    TypeName valueType() {
+      return valueKind().typeName(typeVariable());
+    }
+
+    /** The type provided or produced by the factory. */
+    ParameterizedTypeName optionalType() {
+      return optionalKind().of(valueType());
+    }
+
+    /** The type of the factory. */
+    ParameterizedTypeName factoryType() {
+      return bindingType().frameworkClassOf(optionalType());
+    }
+
+    /** The type of the delegate provider or producer. */
+    ParameterizedTypeName delegateType() {
+      return bindingType().frameworkClassOf(typeVariable());
+    }
+
+    /** The name of the factory class. */
+    String factoryClassName() {
+      return new StringBuilder("Present")
+          .append(UPPER_UNDERSCORE.to(UPPER_CAMEL, optionalKind().name()))
+          .append(UPPER_UNDERSCORE.to(UPPER_CAMEL, valueKind().toString()))
+          .append(bindingType().frameworkClass().getSimpleName())
+          .toString();
+    }
+
+    private static PresentFactorySpec of(ContributionBinding binding) {
+      OptionalKind optionalKind = OptionalType.from(binding.key()).kind();
+      DependencyRequest.Kind valueKind =
+          DependencyRequest.extractKindAndType(OptionalType.from(binding.key()).valueType()).kind();
+      return new AutoValue_OptionalFactories_PresentFactorySpec(
+          binding.bindingType(), optionalKind, valueKind);
     }
-    return absentOptionalProviderMethod.get();
   }
   
   /**
@@ -146,104 +220,82 @@ CodeBlock absentOptionalProvider() {
    *     underlying type
    */
   CodeBlock presentOptionalFactory(ContributionBinding binding, CodeBlock delegateFactory) {
-    TypeMirror valueType = OptionalType.from(binding.key()).valueType();
-    DependencyRequest.Kind valueKind = DependencyRequest.extractKindAndType(valueType).kind();
-    if (!presentFactoryClasses.contains(binding.bindingType(), valueKind)) {
-      presentFactoryClasses.put(
-          binding.bindingType(),
-          valueKind,
-          createPresentFactoryClass(binding.bindingType(), valueKind));
-    }
     return CodeBlock.of(
-        "$N.of($L)", presentFactoryClasses.get(binding.bindingType(), valueKind), delegateFactory);
-  }
-  /**
-   * Adds classes and methods required by previous calls to {@link #absentOptionalProvider()} and
-   * {@link #presentOptionalProvider(DependencyRequest.Kind, CodeBlock)} to the top-level {@code
-   * component}.
-   */
-  void addMembers(TypeSpec.Builder component) {
-    if (absentOptionalProviderMethod.isPresent()) {
-      component.addField(ABSENT_OPTIONAL_PROVIDER_FIELD).addMethod(ABSENT_OPTIONAL_PROVIDER_METHOD);
-    }
-    for (TypeSpec presentFactoryClass : presentFactoryClasses.values()) {
-      component.addType(presentFactoryClass);
-    }
+        "$N.of($L)",
+        presentFactoryClasses.computeIfAbsent(
+            PresentFactorySpec.of(binding), this::presentOptionalFactoryClass),
+        delegateFactory);
   }
 
-  private TypeSpec createPresentFactoryClass(
-      BindingType bindingType, DependencyRequest.Kind valueKind) {
-    TypeVariableName typeVariable = TypeVariableName.get("T");
-    TypeName valueType = valueKind.typeName(typeVariable);
-    ParameterizedTypeName factoryType = bindingType.frameworkClassOf(optionalOf(valueType));
-
+  private TypeSpec presentOptionalFactoryClass(PresentFactorySpec spec) {
     FieldSpec delegateField =
-        FieldSpec.builder(bindingType.frameworkClassOf(typeVariable), "delegate", PRIVATE, FINAL)
-            .build();
+        FieldSpec.builder(spec.delegateType(), "delegate", PRIVATE, FINAL).build();
     ParameterSpec delegateParameter = ParameterSpec.builder(delegateField.type, "delegate").build();
 
     MethodSpec.Builder getMethodBuilder =
         methodBuilder("get").addAnnotation(Override.class).addModifiers(PUBLIC);
-    switch (bindingType) {
+    switch (spec.bindingType()) {
       case PROVISION:
         getMethodBuilder
-            .returns(optionalOf(valueType))
+            .returns(spec.optionalType())
             .addCode(
-                "return $T.of($L);",
-                Optional.class,
-                FrameworkType.PROVIDER.to(valueKind, CodeBlock.of("$N", delegateField)));
+                "return $L;",
+                spec.optionalKind()
+                    .presentExpression(
+                        FrameworkType.PROVIDER.to(
+                            spec.valueKind(), CodeBlock.of("$N", delegateField))));
         break;
 
       case PRODUCTION:
-        getMethodBuilder.returns(listenableFutureOf(optionalOf(valueType)));
+        getMethodBuilder.returns(listenableFutureOf(spec.optionalType()));
 
-        switch (valueKind) {
+        switch (spec.valueKind()) {
           case FUTURE: // return a ListenableFuture<Optional<ListenableFuture<T>>>
           case PRODUCER: // return a ListenableFuture<Optional<Producer<T>>>
             getMethodBuilder.addCode(
-                "return $T.immediateFuture($T.of($L));",
+                "return $T.immediateFuture($L);",
                 Futures.class,
-                Optional.class,
-                FrameworkType.PRODUCER.to(valueKind, CodeBlock.of("$N", delegateField)));
+                spec.optionalKind()
+                    .presentExpression(
+                        FrameworkType.PRODUCER.to(
+                            spec.valueKind(), CodeBlock.of("$N", delegateField))));
             break;
 
           case INSTANCE: // return a ListenableFuture<Optional<T>>
             getMethodBuilder.addCode(
                 "return $L;",
-                transformFutureToOptional(typeVariable, CodeBlock.of("$N.get()", delegateField)));
+                transformFutureToOptional(
+                    spec.optionalKind(),
+                    spec.typeVariable(),
+                    CodeBlock.of("$N.get()", delegateField)));
             break;
 
           case PRODUCED: // return a ListenableFuture<Optional<Produced<T>>>
             getMethodBuilder.addCode(
                 "return $L;",
                 transformFutureToOptional(
-                    valueType,
+                    spec.optionalKind(),
+                    spec.valueType(),
                     CodeBlock.of(
                         "$T.createFutureProduced($N.get())", Producers.class, delegateField)));
             break;
 
           default:
-            throw new UnsupportedOperationException(factoryType + " objects are not supported");
+            throw new UnsupportedOperationException(
+                spec.factoryType() + " objects are not supported");
         }
         break;
 
       default:
-        throw new AssertionError(bindingType);
+        throw new AssertionError(spec.bindingType());
     }
-    MethodSpec getMethod = getMethodBuilder.build();
-
-    String factoryClassName =
-        String.format(
-            "PresentOptional%s%s",
-            UPPER_UNDERSCORE.to(UPPER_CAMEL, valueKind.toString()),
-            bindingType.frameworkClass().getSimpleName());
 
-    return classBuilder(factoryClassName)
-        .addTypeVariable(typeVariable)
+    return classBuilder(spec.factoryClassName())
+        .addTypeVariable(spec.typeVariable())
         .addModifiers(PRIVATE, STATIC, FINAL)
-        .addSuperinterface(factoryType)
+        .addSuperinterface(spec.factoryType())
         .addJavadoc(
-            "A {@link $T} that uses a delegate {@code $T}.", factoryType, delegateField.type)
+            "A {@link $T} that uses a delegate {@code $T}.", spec.factoryType(), delegateField.type)
         .addField(delegateField)
         .addMethod(
             constructorBuilder()
@@ -255,15 +307,18 @@ private TypeSpec createPresentFactoryClass(
                     Preconditions.class,
                     delegateParameter)
                 .build())
-        .addMethod(getMethod)
+        .addMethod(getMethodBuilder.build())
         .addMethod(
             methodBuilder("of")
                 .addModifiers(PRIVATE, STATIC)
-                .addTypeVariable(typeVariable)
-                .returns(factoryType)
+                .addTypeVariable(spec.typeVariable())
+                .returns(spec.factoryType())
                 .addParameter(delegateParameter)
                 .addCode(
-                    "return new $L<$T>($N);", factoryClassName, typeVariable, delegateParameter)
+                    "return new $L<$T>($N);",
+                    spec.factoryClassName(),
+                    spec.typeVariable(),
+                    delegateParameter)
                 .build())
         .build();
   }
@@ -274,7 +329,8 @@ private TypeSpec createPresentFactoryClass(
    *
    * @param inputFuture an expression of type {@code ListenableFuture<inputType>}
    */
-  private static CodeBlock transformFutureToOptional(TypeName inputType, CodeBlock inputFuture) {
+  private static CodeBlock transformFutureToOptional(
+      OptionalKind optionalKind, TypeName inputType, CodeBlock inputFuture) {
     return CodeBlock.of(
         "$T.transform($L, $L)",
         Futures.class,
@@ -282,15 +338,26 @@ private static CodeBlock transformFutureToOptional(TypeName inputType, CodeBlock
         anonymousClassBuilder("")
             .addSuperinterface(
                 ParameterizedTypeName.get(
-                    ClassName.get(Function.class), inputType, optionalOf(inputType)))
+                    ClassName.get(Function.class), inputType, optionalKind.of(inputType)))
             .addMethod(
                 methodBuilder("apply")
                     .addAnnotation(Override.class)
                     .addModifiers(PUBLIC)
-                    .returns(optionalOf(inputType))
+                    .returns(optionalKind.of(inputType))
                     .addParameter(inputType, "input")
-                    .addCode("return $T.of(input);", Optional.class)
+                    .addCode("return $L;", optionalKind.presentExpression(CodeBlock.of("input")))
                     .build())
             .build());
   }
+
+  /**
+   * Adds classes and methods required by previous calls to {@link
+   * #absentOptionalProvider(ContributionBinding)} and {@link
+   * #presentOptionalFactory(ContributionBinding, CodeBlock)} to the top-level {@code component}.
+   */
+  void addMembers(TypeSpec.Builder component) {
+    component.addTypes(presentFactoryClasses.values());
+    component.addMethods(absentOptionalProviderMethods.values());
+    component.addFields(absentOptionalProviderFields.values());
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/OptionalType.java b/compiler/src/main/java/dagger/internal/codegen/OptionalType.java
index d7e23b17c..2a76b05ee 100644
--- a/compiler/src/main/java/dagger/internal/codegen/OptionalType.java
+++ b/compiler/src/main/java/dagger/internal/codegen/OptionalType.java
@@ -22,26 +22,69 @@
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
+import com.google.common.base.Optional;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
+import javax.lang.model.element.Name;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.SimpleTypeVisitor7;
+import javax.lang.model.type.TypeVisitor;
+import javax.lang.model.util.SimpleTypeVisitor8;
 
 /**
  * Information about an {@code Optional} {@link TypeMirror}.
  *
- * <p>Only {@link com.google.common.base.Optional} is supported.
+ * <p>{@link com.google.common.base.Optional} and {@link java.util.Optional} are supported.
  */
-// TODO(dpb): Support java.util.Optional.
 @AutoValue
 abstract class OptionalType {
 
-  private static final String OPTIONAL_TYPE = "com.google.common.base.Optional";
+  /** A variant of {@code Optional}. */
+  enum OptionalKind {
+    /** {@link com.google.common.base.Optional}. */
+    GUAVA_OPTIONAL(com.google.common.base.Optional.class, "absent"),
 
-  private static final SimpleTypeVisitor7<Boolean, Void> IS_OPTIONAL =
-      new SimpleTypeVisitor7<Boolean, Void>(false) {
+    /** {@link java.util.Optional}. */
+    JDK_OPTIONAL(java.util.Optional.class, "empty"),
+    ;
+
+    private final Class<?> clazz;
+    private final String absentFactoryMethodName;
+
+    OptionalKind(Class<?> clazz, String absentFactoryMethodName) {
+      this.clazz = clazz;
+      this.absentFactoryMethodName = absentFactoryMethodName;
+    }
+
+    /** Returns {@code valueType} wrapped in the correct class. */
+    ParameterizedTypeName of(TypeName valueType) {
+      return ParameterizedTypeName.get(ClassName.get(clazz), valueType);
+    }
+
+    /** Returns an expression for the absent/empty value. */
+    CodeBlock absentValueExpression() {
+      return CodeBlock.of("$T.$L()", clazz, absentFactoryMethodName);
+    }
+
+    /** Returns an expression for the present {@code value}. */
+    CodeBlock presentExpression(CodeBlock value) {
+      return CodeBlock.of("$T.of($L)", clazz, value);
+    }
+  }
+
+  private static final TypeVisitor<Optional<OptionalKind>, Void> OPTIONAL_KIND =
+      new SimpleTypeVisitor8<Optional<OptionalKind>, Void>(Optional.absent()) {
         @Override
-        public Boolean visitDeclared(DeclaredType t, Void p) {
-          return MoreElements.asType(t.asElement()).getQualifiedName().contentEquals(OPTIONAL_TYPE);
+        public Optional<OptionalKind> visitDeclared(DeclaredType t, Void p) {
+          for (OptionalKind optionalKind : OptionalKind.values()) {
+            Name qualifiedName = MoreElements.asType(t.asElement()).getQualifiedName();
+            if (qualifiedName.contentEquals(optionalKind.clazz.getCanonicalName())) {
+              return Optional.of(optionalKind);
+            }
+          }
+          return Optional.absent();
         }
       };
 
@@ -58,6 +101,11 @@ public Boolean visitDeclared(DeclaredType t, Void p) {
   DeclaredType declaredOptionalType() {
     return wrappedDeclaredOptionalType().get();
   }
+  
+  /** Which {@code Optional} type is used. */
+  OptionalKind kind() {
+    return declaredOptionalType().accept(OPTIONAL_KIND, null).get();
+  }
 
   /** The value type. */
   TypeMirror valueType() {
@@ -66,7 +114,7 @@ TypeMirror valueType() {
 
   /** Returns {@code true} if {@code type} is an {@code Optional} type. */
   static boolean isOptional(TypeMirror type) {
-    return type.accept(IS_OPTIONAL, null);
+    return type.accept(OPTIONAL_KIND, null).isPresent();
   }
 
   /** Returns {@code true} if {@code key.type()} is an {@code Optional} type. */
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 7605e4d49..bfea77daf 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -35,15 +35,14 @@
 import static dagger.internal.codegen.TypeNames.listOf;
 import static dagger.internal.codegen.TypeNames.listenableFutureOf;
 import static dagger.internal.codegen.TypeNames.producedOf;
+import static java.util.stream.Collectors.joining;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PROTECTED;
 import static javax.lang.model.element.Modifier.PUBLIC;
 
-import com.google.common.base.Function;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
-import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
@@ -225,16 +224,12 @@ private static void assignField(MethodSpec.Builder constructorBuilder, FieldSpec
             FrameworkDependency.frameworkDependenciesForBinding(binding));
     return FluentIterable.from(binding.implicitDependencies())
         .filter(
-            new Predicate<DependencyRequest>() {
-              @Override
-              public boolean apply(DependencyRequest dependency) {
-                return isAsyncDependency(dependency)
+            dependency ->
+                isAsyncDependency(dependency)
                     && frameworkDependencies
                         .get(dependency)
                         .frameworkClass()
-                        .equals(Producer.class);
-              }
-            })
+                        .equals(Producer.class))
         .toList();
   }
 
@@ -393,15 +388,10 @@ CodeBlock futureCodeBlock() {
           "$T.<$T>allAsList($L)",
           FUTURES,
           OBJECT,
-          makeParametersCodeBlock(
-              FluentIterable.from(asyncDependencies)
-                  .transform(
-                      new Function<DependencyRequest, CodeBlock>() {
-                        @Override
-                        public CodeBlock apply(DependencyRequest dependency) {
-                          return CodeBlock.of("$L", dependencyFutureName(dependency));
-                        }
-                      })));
+          asyncDependencies
+              .stream()
+              .map(ProducerFactoryGenerator::dependencyFutureName)
+              .collect(joining(", ")));
     }
 
     @Override
@@ -518,13 +508,6 @@ private CodeBlock getInvocationCodeBlock(
    */
   private FluentIterable<? extends TypeName> getThrownTypeNames(
       Iterable<? extends TypeMirror> thrownTypes) {
-    return FluentIterable.from(thrownTypes)
-        .transform(
-            new Function<TypeMirror, TypeName>() {
-              @Override
-              public TypeName apply(TypeMirror type) {
-                return TypeName.get(type);
-              }
-            });
+    return FluentIterable.from(thrownTypes).transform(TypeName::get);
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
index f372858a4..69704da09 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
@@ -21,7 +21,6 @@
 import static com.google.common.collect.Iterables.getOnlyElement;
 
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
@@ -34,7 +33,6 @@
 import dagger.internal.codegen.ContributionType.HasContributionType;
 import dagger.internal.codegen.Key.HasKey;
 import java.util.Map;
-import java.util.Set;
 
 /**
  * The collection of bindings that have been resolved for a binding key. For valid graphs, contains
@@ -309,7 +307,7 @@ public BindingType bindingType() {
 
   /** The binding types for {@link #bindings()}. */
   ImmutableSet<BindingType> bindingTypes() {
-    return FluentIterable.from(bindings()).transform(BindingType.BINDING_TYPE).toSet();
+    return FluentIterable.from(bindings()).transform(HasBindingType::bindingType).toSet();
   }
 
   /**
@@ -360,12 +358,4 @@ public ContributionType contributionType() {
   Optional<Scope> scope() {
     return getOnlyElement(bindings()).scope();
   }
-
-  static final Function<ResolvedBindings, Set<ContributionBinding>> CONTRIBUTION_BINDINGS =
-      new Function<ResolvedBindings, Set<ContributionBinding>>() {
-        @Override
-        public Set<ContributionBinding> apply(ResolvedBindings resolvedBindings) {
-          return resolvedBindings.contributionBindings();
-        }
-      };
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Scope.java b/compiler/src/main/java/dagger/internal/codegen/Scope.java
index 49c1e01a0..d2d7f55c4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Scope.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Scope.java
@@ -25,7 +25,6 @@
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
-import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
@@ -69,15 +68,7 @@ private static Scope scope(Elements elements, Class<? extends Annotation> scopeA
 
   /** Returns all of the associated scopes for a source code element. */
   static ImmutableSet<Scope> scopesOf(Element element) {
-    return FluentIterable.from(getScopes(element))
-        .transform(
-            new Function<AnnotationMirror, Scope>() {
-              @Override
-              public Scope apply(AnnotationMirror annotationMirror) {
-                return scope(annotationMirror);
-              }
-            })
-        .toSet();
+    return FluentIterable.from(getScopes(element)).transform(Scope::scope).toSet();
   }
 
   /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 5683b38a0..5b61872e0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -19,7 +19,6 @@
 import static dagger.internal.codegen.FrameworkDependency.frameworkDependenciesForBinding;
 import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
 import static dagger.internal.codegen.TypeNames.PROVIDER_OF_LAZY;
-import static dagger.internal.codegen.Util.ELEMENT_KIND;
 import static dagger.internal.codegen.Util.ELEMENT_SIMPLE_NAME;
 
 import com.google.common.base.CaseFormat;
@@ -38,6 +37,7 @@
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeVariableName;
 import java.util.Iterator;
+import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.TypeParameterElement;
@@ -64,8 +64,8 @@ public int compare(DependencyRequest left, DependencyRequest right) {
           return ComparisonChain.start()
               // put fields before parameters
               .compare(
-                  left.requestElement().transform(ELEMENT_KIND),
-                  right.requestElement().transform(ELEMENT_KIND),
+                  left.requestElement().transform(Element::getKind),
+                  right.requestElement().transform(Element::getKind),
                   Util.<ElementKind>optionalComparator())
               // order by dependency kind
               .compare(left.kind(), right.kind())
diff --git a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
index c1e7883c0..9899952bd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
@@ -78,6 +78,8 @@
   static final ClassName PRODUCED = ClassName.get(Produced.class);
   static final ClassName PRODUCER = ClassName.get(Producer.class);
   static final ClassName PRODUCERS = ClassName.get(Producers.class);
+  static final ClassName PRODUCTION_COMPONENT_MONITOR_FACTORY =
+      ClassName.get(ProductionComponentMonitor.Factory.class);
   static final ClassName PROVIDER = ClassName.get(Provider.class);
   static final ClassName PROVIDER_OF_LAZY = ClassName.get(ProviderOfLazy.class);
 
@@ -97,9 +99,6 @@
    */
   static final ClassName VOID_CLASS = ClassName.get(Void.class);
 
-  static final TypeName SET_OF_FACTORIES =
-      ParameterizedTypeName.get(Set.class, ProductionComponentMonitor.Factory.class);
-
   static ParameterizedTypeName abstractProducerOf(TypeName typeName) {
     return ParameterizedTypeName.get(ABSTRACT_PRODUCER, typeName);
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 2637f4196..0db1ca3cf 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -19,16 +19,15 @@
 import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
 import static com.google.auto.common.MoreElements.hasModifiers;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.auto.common.MoreTypes.asDeclared;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
 
 import com.google.auto.common.MoreElements;
-import com.google.auto.common.MoreTypes;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
-import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
@@ -39,7 +38,6 @@
 import java.util.Comparator;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ElementVisitor;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -137,25 +135,9 @@ private static boolean requiresEnclosingInstance(TypeElement typeElement) {
         .toSet();
   }
 
-  // TODO(ronshapiro): add into auto/common/AnnotationMirrors.java
-  static Predicate<AnnotationMirror> hasAnnotationType(
-      final Class<? extends Annotation> annotation) {
-    return new Predicate<AnnotationMirror>() {
-      @Override
-      public boolean apply(AnnotationMirror input) {
-        return MoreTypes.isTypeOf(annotation, input.getAnnotationType());
-      }
-    };
-  }
-
   /** A function that returns the input as a {@link DeclaredType}. */
   static final Function<TypeElement, DeclaredType> AS_DECLARED_TYPE =
-      new Function<TypeElement, DeclaredType>() {
-        @Override
-        public DeclaredType apply(TypeElement typeElement) {
-          return MoreTypes.asDeclared(typeElement.asType());
-        }
-      };
+      typeElement -> asDeclared(typeElement.asType());
 
   /**
    * A visitor that returns the input or the closest enclosing element that is a
@@ -206,53 +188,20 @@ static boolean isAnyAnnotationPresent(
   static <E extends Element> FluentIterable<E> elementsWithAnnotation(
       Iterable<E> elements, final Class<? extends Annotation> annotation) {
     return FluentIterable.from(elements)
-        .filter(
-            new Predicate<Element>() {
-              @Override
-              public boolean apply(Element element) {
-                return MoreElements.isAnnotationPresent(element, annotation);
-              }
-            });
+        .filter(element -> MoreElements.isAnnotationPresent(element, annotation));
   }
 
   /** A function that returns the simple name of an element. */
   static final Function<Element, String> ELEMENT_SIMPLE_NAME =
-      new Function<Element, String>() {
-        @Override
-        public String apply(Element element) {
-          return element.getSimpleName().toString();
-        }
-      };
-
-  /** A function that returns the kind of an element. */
-  static final Function<Element, ElementKind> ELEMENT_KIND =
-      new Function<Element, ElementKind>() {
-        @Override
-        public ElementKind apply(Element element) {
-          return element.getKind();
-        }
-      };
-
-  @SuppressWarnings("rawtypes")
-  private static final Comparator OPTIONAL_COMPARATOR =
-      new Comparator<Optional<Comparable>>() {
-        @SuppressWarnings("unchecked") // Only used as a Comparator<Optional<SomeType>>.
-        @Override
-        public int compare(Optional<Comparable> o1, Optional<Comparable> o2) {
-          if (o1.isPresent() && o2.isPresent()) {
-            return o1.get().compareTo(o2.get());
-          }
-          return o1.isPresent() ? -1 : 1;
-        }
-      };
+      element -> element.getSimpleName().toString();
 
   /**
    * A {@link Comparator} that puts absent {@link Optional}s before present ones, and compares
    * present {@link Optional}s by their values.
    */
-  @SuppressWarnings("unchecked") // Fully covariant.
   static <C extends Comparable<C>> Comparator<Optional<C>> optionalComparator() {
-    return OPTIONAL_COMPARATOR;
+    return Comparator.comparing((Optional<C> optional) -> optional.isPresent())
+        .thenComparing(Optional::get);
   }
 
   private Util() {}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java b/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
index de060d603..019bc07a4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
@@ -132,7 +132,7 @@ private static boolean isEnclosedIn(Element parent, Element child) {
   }
 
   static <T extends Element> Builder<T> about(T subject) {
-    return new Builder<T>(subject);
+    return new Builder<>(subject);
   }
 
   @CanIgnoreReturnValue
@@ -212,7 +212,7 @@ T getSubject() {
 
     @CheckReturnValue
     ValidationReport<T> build() {
-      return new AutoValue_ValidationReport<T>(subject, items.build(), subreports.build());
+      return new AutoValue_ValidationReport<>(subject, items.build(), subreports.build());
     }
   }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index 98049a7f4..ba44cc802 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -2397,14 +2397,10 @@ public void unprocessedMembersInjectorNotes() {
         .processedWith(
             new ElementFilteringComponentProcessor(
                 Predicates.not(
-                    new Predicate<Element>() {
-                      @Override
-                      public boolean apply(Element element) {
-                        return MoreElements.getPackage(element)
+                    element ->
+                        MoreElements.getPackage(element)
                             .getQualifiedName()
-                            .contentEquals("test.inject");
-                      }
-                    })))
+                            .contentEquals("test.inject"))))
         .compilesWithoutWarnings()
         .withNoteContaining(
             "Generating a MembersInjector for "
diff --git a/compiler/src/test/java/dagger/internal/codegen/DaggerModuleMethodSubject.java b/compiler/src/test/java/dagger/internal/codegen/DaggerModuleMethodSubject.java
index 7814c82f5..171d36511 100644
--- a/compiler/src/test/java/dagger/internal/codegen/DaggerModuleMethodSubject.java
+++ b/compiler/src/test/java/dagger/internal/codegen/DaggerModuleMethodSubject.java
@@ -19,10 +19,8 @@
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 
-import com.google.common.base.Function;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Iterables;
 import com.google.common.truth.FailureStrategy;
 import com.google.common.truth.Subject;
 import com.google.common.truth.SubjectFactory;
@@ -34,6 +32,7 @@
 import java.io.PrintWriter;
 import java.io.StringWriter;
 import java.util.Arrays;
+import java.util.List;
 import javax.tools.JavaFileObject;
 
 /** A {@link Truth} subject for testing Dagger module methods. */
@@ -108,7 +107,7 @@ private DaggerModuleMethodSubject(FailureStrategy failureStrategy, String subjec
    * </ul>
    */
   DaggerModuleMethodSubject importing(Class<?>... imports) {
-    return importing(FluentIterable.from(Arrays.asList(imports)));
+    return importing(Arrays.asList(imports));
   }
 
   /**
@@ -121,8 +120,10 @@ DaggerModuleMethodSubject importing(Class<?>... imports) {
    * <li>{@code javax.inject.*}
    * </ul>
    */
-  DaggerModuleMethodSubject importing(Iterable<? extends Class<?>> imports) {
-    this.imports.addAll(Iterables.transform(imports, IMPORT));
+  DaggerModuleMethodSubject importing(List<? extends Class<?>> imports) {
+    imports.stream()
+        .map(clazz -> String.format("import %s;", clazz.getCanonicalName()))
+        .forEachOrdered(this.imports::add);
     return this;
   }
 
@@ -183,11 +184,4 @@ private String moduleSource() {
     return stringWriter.toString();
   }
 
-  private static final Function<Class<?>, String> IMPORT =
-      new Function<Class<?>, String>() {
-        @Override
-        public String apply(Class<?> clazz) {
-          return String.format("import %s;", clazz.getCanonicalName());
-        }
-      };
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
index 1ad716b58..1a1bb6474 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -297,14 +297,6 @@ public void simpleComponent() {
             "    }",
             "",
             "    @Deprecated",
-            "    public Builder testClass_SimpleComponent_MonitoringModule(",
-            "        TestClass_SimpleComponent_MonitoringModule",
-            "        testClass_SimpleComponent_MonitoringModule) {",
-            "      Preconditions.checkNotNull(testClass_SimpleComponent_MonitoringModule);",
-            "      return this;",
-            "    }",
-            "",
-            "    @Deprecated",
             "    public Builder testClass_SimpleComponent_ProductionExecutorModule(",
             "        TestClass_SimpleComponent_ProductionExecutorModule",
             "        testClass_SimpleComponent_ProductionExecutorModule) {",
diff --git a/core/src/main/java/dagger/BindsOptionalOf.java b/core/src/main/java/dagger/BindsOptionalOf.java
index a104cb916..887d9ae8f 100644
--- a/core/src/main/java/dagger/BindsOptionalOf.java
+++ b/core/src/main/java/dagger/BindsOptionalOf.java
@@ -25,8 +25,8 @@
 import javax.inject.Qualifier;
 
 /**
- * Annotates methods that declare bindings for {@code com.google.common.base.Optional} containers of
- * values from bindings that may or may not be present in the component.
+ * Annotates methods that declare bindings for {@code Optional} containers of values from bindings
+ * that may or may not be present in the component.
  *
  * <p>If a module contains a method declaration like this:
  *
@@ -69,6 +69,8 @@
  * <li>{@code Optional<Producer<Foo>>}
  * <li>{@code Optional<Produced<Foo>>}
  * </ul>
+ *
+ * <p>You can inject either {@code com.google.common.base.Optional} or {@code java.util.Optional}.
  */
 @Documented
 @Beta
diff --git a/pom.xml b/pom.xml
index ba8f0ea23..79b297e2c 100644
--- a/pom.xml
+++ b/pom.xml
@@ -44,7 +44,6 @@
     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
 
     <!-- Compilation -->
-    <java.version>1.7</java.version>
     <javax.inject.version>1</javax.inject.version>
     <javax.annotation.version>3.0.1</javax.annotation.version>
     <auto.common.version>0.7</auto.common.version>
@@ -184,8 +183,8 @@
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
         <configuration>
-          <source>${java.version}</source>
-          <target>${java.version}</target>
+          <source>1.7</source>
+          <target>1.7</target>
           <compilerArgument>-Xlint:all</compilerArgument>
           <showWarnings>true</showWarnings>
           <showDeprecation>true</showDeprecation>
diff --git a/util/generate-latest-docs.sh b/util/generate-latest-docs.sh
index 573576999..8c651e322 100755
--- a/util/generate-latest-docs.sh
+++ b/util/generate-latest-docs.sh
@@ -1,7 +1,7 @@
 # see http://benlimmer.com/2013/12/26/automatically-publish-javadoc-to-gh-pages-with-travis-ci/ for details
 
 if [ "$TRAVIS_REPO_SLUG" == "google/dagger" ] && \
-   [ "$TRAVIS_JDK_VERSION" == "oraclejdk7" ] && \
+   [ "$TRAVIS_JDK_VERSION" == "oraclejdk8" ] && \
    [ "$TRAVIS_PULL_REQUEST" == "false" ] && \
    [ "$TRAVIS_BRANCH" == "master" ]; then
   echo -e "Publishing javadoc...\n"
@@ -10,11 +10,11 @@ if [ "$TRAVIS_REPO_SLUG" == "google/dagger" ] && \
 
   cd $HOME
   git clone --quiet --branch=gh-pages https://${GH_TOKEN}@github.com/google/dagger gh-pages > /dev/null
-  
+
   cd gh-pages
   git config --global user.email "travis@travis-ci.org"
   git config --global user.name "travis-ci"
-  git rm -rf api/latest 
+  git rm -rf api/latest
   mkdir -p api
   mv ${TARGET}/site/apidocs api/latest
   git add -f api/latest
diff --git a/util/mvn-deploy.sh b/util/mvn-deploy.sh
index 93e975c24..165c22fe7 100755
--- a/util/mvn-deploy.sh
+++ b/util/mvn-deploy.sh
@@ -1,4 +1,7 @@
 #!/bin/bash
+
+set -eu
+
 if [ $# -lt 2 ]; then
   echo "usage $0 <ssl-key> <version-name> [<param> ...]"
   exit 1;
@@ -32,3 +35,15 @@ fi
 mvn "$@" -P '!examples' -P sonatype-oss-release \
     -Dgpg.skip=false -Dgpg.keyname=${key} \
     clean site:jar deploy
+
+# Publish javadocs to gh-pages
+mvn javadoc:aggregate -P!examples -DexcludePackageNames=*.internal
+git clone --quiet --branch gh-pages \
+    https://git@github.com/google/dagger gh-pages > /dev/null
+cd gh-pages
+cp -r ../target/site/apidocs api/$version_name
+git add api/$version_name
+git commit -m "$version_name docs"
+git push origin gh-pages
+cd ..
+rm -rf gh-pages
