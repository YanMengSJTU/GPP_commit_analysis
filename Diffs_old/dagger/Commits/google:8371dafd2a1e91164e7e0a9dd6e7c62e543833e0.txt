diff --git a/.travis.yml b/.travis.yml
index 140bc5580..c9880c178 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -38,5 +38,6 @@ after_success:
   - util/publish-snapshot-on-commit.sh
 
 branches:
-  except:
-    - gh-pages
+  only:
+    - master
+    - /^release.*$/
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/MultibindingSubcomponents.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/MultibindingSubcomponents.java
index 1df73db75..a9f0a1e0f 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/MultibindingSubcomponents.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/MultibindingSubcomponents.java
@@ -160,7 +160,9 @@ static BoundInChild onlyInChildEntry() {
     Set<RequiresMultibindings<BoundInParentAndChild>> setOfRequiresMultibindingsInParentAndChild();
   }
 
-  interface ParentWithProvision extends ProvidesBoundInParent, ProvidesBoundInParentAndChild {}
+  interface ParentWithProvision
+      extends ProvidesBoundInParent, ProvidesBoundInParentAndChild,
+          ProvidesSetOfRequiresMultibindings {}
 
   interface HasChildWithProvision {
     ChildWithProvision childWithProvision();
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithRepeatedModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithRepeatedModule.java
index 94f27be02..279bc954c 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithRepeatedModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithRepeatedModule.java
@@ -30,7 +30,6 @@
 
   @Subcomponent.Builder
   interface Builder {
-    @SuppressWarnings("repeated-module")
     Builder repeatedModule(RepeatedModule repeatedModule);
 
     SubcomponentWithRepeatedModule build();
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 66203083e..6b944466b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -133,7 +133,7 @@
   protected final CompilerOptions compilerOptions;
   protected final ClassName name;
   protected final BindingGraph graph;
-  protected final ImmutableMap<ComponentDescriptor, String> subcomponentImplNames;
+  protected final ImmutableMap<ComponentDescriptor, String> subcomponentNames;
   private final Map<BindingKey, InitializationState> initializationStates = new HashMap<>();
   protected TypeSpec.Builder component;
   private final UniqueNameSet componentFieldNames = new UniqueNameSet();
@@ -162,14 +162,14 @@
       CompilerOptions compilerOptions,
       ClassName name,
       BindingGraph graph,
-      ImmutableMap<ComponentDescriptor, String> subcomponentImplNames) {
+      ImmutableMap<ComponentDescriptor, String> subcomponentNames) {
     this.types = types;
     this.elements = elements;
     this.keyFactory = keyFactory;
     this.compilerOptions = compilerOptions;
     this.name = name;
     this.graph = graph;
-    this.subcomponentImplNames = subcomponentImplNames;
+    this.subcomponentNames = subcomponentNames;
   }
 
   protected final TypeElement componentDefinitionType() {
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 869af2334..5b06e828a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -605,13 +605,26 @@ void resolve(DependencyRequest request) {
           return;
         }
 
-        // If the binding was previously resolved in a supercomponent, then test to see if it
-        // depends on multibindings with contributions from this subcomponent. If it does, then we
-        // have to resolve it in this subcomponent so that it sees the local contributions. If it
-        // does not, then we can stop resolving it in this subcomponent and rely on the
-        // supercomponent resolution.
+        /* If the binding was previously resolved in a supercomponent, then we may be able to avoid
+         * resolving it here and just depend on the supercomponent resolution.
+         *
+         * 1. If it depends on multibindings with contributions from this subcomponent, then we have
+         *    to resolve it in this subcomponent so that it sees the local contributions.
+         *
+         * 2. If there are any explicit bindings in this component, they may conflict with those in
+         *    the supercomponent, so resolve them here so that conflicts can be caught.
+         */
         if (getPreviouslyResolvedBindings(bindingKey).isPresent()
-            && !new MultibindingDependencies().dependsOnLocalMultibindings(bindingKey)) {
+            && !new MultibindingDependencies().dependsOnLocalMultibindings(bindingKey)
+            && getExplicitBindings(bindingKey.key()).isEmpty()) {
+          /* Resolve in the parent in case there are multibinding contributions or conflicts in some
+           * component between this one and the previously-resolved one. */
+          parentResolver.get().resolve(request);
+          /* Cache the inherited parent component's bindings in case resolving at the parent found
+           * bindings in some component between this one and the previously-resolved one. */
+          ResolvedBindings inheritedBindings =
+              getPreviouslyResolvedBindings(bindingKey).get().asInheritedIn(componentDescriptor);
+          resolvedBindings.put(bindingKey, inheritedBindings);
           return;
         }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 90a897d0f..68a78e783 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -44,7 +44,6 @@
 import dagger.internal.codegen.SourceElement.HasSourceElement;
 import dagger.producers.ProductionComponent;
 import java.util.ArrayDeque;
-import java.util.Arrays;
 import java.util.Collection;
 import java.util.Deque;
 import java.util.Formatter;
@@ -67,7 +66,6 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
-import javax.tools.Diagnostic;
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreTypes.asDeclared;
@@ -89,6 +87,7 @@
 import static dagger.internal.codegen.ContributionBinding.Kind.IS_SYNTHETIC_KIND;
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_MAP;
 import static dagger.internal.codegen.ContributionType.indexByContributionType;
+import static dagger.internal.codegen.ErrorMessages.CONTAINS_DEPENDENCY_CYCLE_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.DUPLICATE_SIZE_LIMIT;
 import static dagger.internal.codegen.ErrorMessages.INDENT;
 import static dagger.internal.codegen.ErrorMessages.MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE;
@@ -102,7 +101,6 @@
 import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
 import static javax.tools.Diagnostic.Kind.ERROR;
-import static javax.tools.Diagnostic.Kind.WARNING;
 
 public class BindingGraphValidator {
 
@@ -138,19 +136,23 @@
   }
 
   private class Validation {
-    final BindingGraph topLevelGraph;
     final BindingGraph subject;
     final ValidationReport.Builder<TypeElement> reportBuilder;
+    final Optional<Validation> parent;
 
-    Validation(BindingGraph topLevelGraph, BindingGraph subject) {
-      this.topLevelGraph = topLevelGraph;
+    Validation(BindingGraph subject, Optional<Validation> parent) {
       this.subject = subject;
       this.reportBuilder =
           ValidationReport.about(subject.componentDescriptor().componentDefinitionType());
+      this.parent = parent;
     }
 
     Validation(BindingGraph topLevelGraph) {
-      this(topLevelGraph, topLevelGraph);
+      this(topLevelGraph, Optional.<Validation>absent());
+    }
+
+    BindingGraph topLevelGraph() {
+      return parent.isPresent() ? parent.get().topLevelGraph() : subject;
     }
 
     ValidationReport<TypeElement> buildReport() {
@@ -186,8 +188,7 @@ void validateSubgraph() {
       }
 
       for (BindingGraph subgraph : subject.subgraphs().values()) {
-        Validation subgraphValidation =
-            new Validation(topLevelGraph, subgraph);
+        Validation subgraphValidation = new Validation(subgraph, Optional.of(this));
         subgraphValidation.validateSubgraph();
         reportBuilder.addSubreport(subgraphValidation.buildReport());
       }
@@ -294,9 +295,7 @@ private boolean validateResolvedBinding(
             throw new AssertionError(
                 "contribution binding keys should never have members injection bindings");
           }
-          if (!validateNullability(path.peek().request(), resolvedBinding.contributionBindings())) {
-            return false;
-          }
+          validateNullability(path.peek().request(), resolvedBinding.contributionBindings());
           if (resolvedBinding.contributionBindings().size() > 1) {
             reportDuplicateBindings(path);
             return false;
@@ -416,10 +415,9 @@ private ResolvedBindings inlineSyntheticContributions(ResolvedBindings resolvedB
     }
 
     /** Ensures that if the request isn't nullable, then each contribution is also not nullable. */
-    private boolean validateNullability(
-        DependencyRequest request, Set<ContributionBinding> bindings) {
+    private void validateNullability(DependencyRequest request, Set<ContributionBinding> bindings) {
       if (request.isNullable()) {
-        return true;
+        return;
       }
 
       // Note: the method signature will include the @Nullable in it!
@@ -429,7 +427,6 @@ private boolean validateNullability(
        * message is kind of useless. */
       String typeName = TypeName.get(request.key().type()).toString();
 
-      boolean valid = true;
       for (ContributionBinding binding : bindings) {
         if (binding.nullableType().isPresent()) {
           reportBuilder.addItem(
@@ -438,10 +435,8 @@ private boolean validateNullability(
                   + dependencyRequestFormatter.format(request),
               compilerOptions.nullableValidationKind(),
               request.requestElement());
-          valid = false;
         }
       }
-      return valid;
     }
 
     /**
@@ -913,7 +908,7 @@ private void reportMissingBinding(Deque<ResolvedRequest> path) {
           printableDependencyPath.subList(1, printableDependencyPath.size())) {
         errorMessage.append('\n').append(dependency);
       }
-      for (String suggestion : MissingBindingSuggestions.forKey(topLevelGraph, bindingKey)) {
+      for (String suggestion : MissingBindingSuggestions.forKey(topLevelGraph(), bindingKey)) {
         errorMessage.append('\n').append(suggestion);
       }
       reportBuilder.addError(errorMessage.toString(), path.getLast().request().requestElement());
@@ -939,12 +934,48 @@ private void reportDuplicateBindings(Deque<ResolvedRequest> path) {
       StringBuilder builder = new StringBuilder();
       new Formatter(builder)
           .format(ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT, formatRootRequestKey(path));
+      ImmutableSet<ContributionBinding> duplicateBindings =
+          inlineSyntheticContributions(resolvedBinding).contributionBindings();
       hasSourceElementFormatter.formatIndentedList(
-          builder,
-          inlineSyntheticContributions(resolvedBinding).contributionBindings(),
-          1,
-          DUPLICATE_SIZE_LIMIT);
-      reportBuilder.addError(builder.toString(), path.getLast().request().requestElement());
+          builder, duplicateBindings, 1, DUPLICATE_SIZE_LIMIT);
+      owningReportBuilder(duplicateBindings)
+          .addError(builder.toString(), path.getLast().request().requestElement());
+    }
+
+    /**
+     * Returns the report builder for the rootmost component that contains any of the duplicate
+     * bindings.
+     */
+    private ValidationReport.Builder<TypeElement> owningReportBuilder(
+        Iterable<ContributionBinding> duplicateBindings) {
+      ImmutableSet.Builder<ComponentDescriptor> owningComponentsBuilder = ImmutableSet.builder();
+      for (ContributionBinding binding : duplicateBindings) {
+        BindingKey bindingKey = BindingKey.create(BindingKey.Kind.CONTRIBUTION, binding.key());
+        ResolvedBindings resolvedBindings = subject.resolvedBindings().get(bindingKey);
+        owningComponentsBuilder.addAll(
+            resolvedBindings.allContributionBindings().inverse().get(binding));
+      }
+      ImmutableSet<ComponentDescriptor> owningComponents = owningComponentsBuilder.build();
+      for (Validation validation : validationPath()) {
+        if (owningComponents.contains(validation.subject.componentDescriptor())) {
+          return validation.reportBuilder;
+        }
+      }
+      throw new AssertionError(
+          "cannot find owning component for duplicate bindings: " + duplicateBindings);
+    }
+
+    /**
+     * The path from the {@link Validation} of the root graph down to this {@link Validation}.
+     */
+    private ImmutableList<Validation> validationPath() {
+      ImmutableList.Builder<Validation> validationPath = ImmutableList.builder();
+      for (Optional<Validation> validation = Optional.of(this);
+          validation.isPresent();
+          validation = validation.get().parent) {
+        validationPath.add(validation.get());
+      }
+      return validationPath.build().reverse();
     }
 
     @SuppressWarnings("resource") // Appendable is a StringBuilder.
@@ -1024,18 +1055,14 @@ private void reportCycle(
       Element rootRequestElement = requestPath.get(0).requestElement();
       ImmutableList<DependencyRequest> cycle =
           requestPath.subList(indexOfDuplicatedKey, requestPath.size());
-      Diagnostic.Kind kind = cycleHasProviderOrLazy(cycle) ? WARNING : ERROR;
-      if (kind == WARNING
-          && (suppressCycleWarnings(rootRequestElement)
-              || suppressCycleWarnings(rootRequestElement.getEnclosingElement())
-              || suppressCycleWarnings(cycle))) {
+      if (!providersBreakingCycle(cycle).isEmpty()) {
         return;
       }
       // TODO(cgruber): Provide a hint for the start and end of the cycle.
       TypeElement componentType = MoreElements.asType(rootRequestElement.getEnclosingElement());
       reportBuilder.addItem(
           String.format(
-              ErrorMessages.CONTAINS_DEPENDENCY_CYCLE_FORMAT,
+              CONTAINS_DEPENDENCY_CYCLE_FORMAT,
               componentType.getQualifiedName(),
               rootRequestElement.getSimpleName(),
               Joiner.on("\n")
@@ -1044,20 +1071,23 @@ private void reportCycle(
                           .transform(dependencyRequestFormatter)
                           .filter(not(equalTo("")))
                           .skip(1))),
-          kind,
+          ERROR,
           rootRequestElement);
     }
 
     /**
-     * Returns {@code true} if any step of a dependency cycle after the first is a {@link Provider}
-     * or {@link Lazy} or a {@code Map<K, Provider<V>>}.
+     * Returns any steps in a dependency cycle that "break" the cycle. These are any
+     * {@link Provider}, {@link Lazy}, or {@code Map<K, Provider<V>>} requests after the first
+     * request in the cycle.
      *
      * <p>If an implicit {@link Provider} dependency on {@code Map<K, Provider<V>>} is immediately
      * preceded by a dependency on {@code Map<K, V>}, which means that the map's {@link Provider}s'
      * {@link Provider#get() get()} methods are called during provision and so the cycle is not
      * really broken.
      */
-    private boolean cycleHasProviderOrLazy(ImmutableList<DependencyRequest> cycle) {
+    private ImmutableSet<DependencyRequest> providersBreakingCycle(
+        ImmutableList<DependencyRequest> cycle) {
+      ImmutableSet.Builder<DependencyRequest> providers = ImmutableSet.builder();
       for (int i = 1; i < cycle.size(); i++) {
         DependencyRequest dependencyRequest = cycle.get(i);
         switch (dependencyRequest.kind()) {
@@ -1065,17 +1095,18 @@ private boolean cycleHasProviderOrLazy(ImmutableList<DependencyRequest> cycle) {
             if (isImplicitProviderMapForValueMap(dependencyRequest, cycle.get(i - 1))) {
               i++; // Skip the Provider requests in the Map<K, Provider<V>> too.
             } else {
-              return true;
+              providers.add(dependencyRequest);
             }
             break;
 
           case LAZY:
-            return true;
+            providers.add(dependencyRequest);
+            break;
 
           case INSTANCE:
             TypeMirror type = dependencyRequest.key().type();
             if (MapType.isMap(type) && MapType.from(type).valuesAreTypeOf(Provider.class)) {
-              return true;
+              providers.add(dependencyRequest);
             }
             break;
 
@@ -1083,7 +1114,7 @@ private boolean cycleHasProviderOrLazy(ImmutableList<DependencyRequest> cycle) {
             break;
         }
       }
-      return false;
+      return providers.build();
     }
 
     /**
@@ -1100,20 +1131,6 @@ private boolean isImplicitProviderMapForValueMap(
     }
   }
 
-  private boolean suppressCycleWarnings(Element requestElement) {
-    SuppressWarnings suppressions = requestElement.getAnnotation(SuppressWarnings.class);
-    return suppressions != null && Arrays.asList(suppressions.value()).contains("dependency-cycle");
-  }
-
-  private boolean suppressCycleWarnings(ImmutableList<DependencyRequest> pathElements) {
-    for (DependencyRequest dependencyRequest : pathElements) {
-      if (suppressCycleWarnings(dependencyRequest.requestElement())) {
-        return true;
-      }
-    }
-    return false;
-  }
-
   ValidationReport<TypeElement> validate(BindingGraph subject) {
     Validation validation = new Validation(subject);
     validation.validateSubgraph();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentHierarchyValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentHierarchyValidator.java
index f9318a106..99b8ce49c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentHierarchyValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentHierarchyValidator.java
@@ -15,21 +15,16 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
-import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import java.util.Map;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 
 import static com.google.common.base.Functions.constant;
-import static java.util.Arrays.asList;
 
 /**
  * Validates the relationships between parent components and subcomponents.
@@ -73,41 +68,14 @@
             }
           }
           break;
+          
         case SUBCOMPONENT_BUILDER:
         case PRODUCTION_SUBCOMPONENT_BUILDER:
-          BuilderSpec subcomponentBuilderSpec = subcomponentDescriptor.builderSpec().get();
-          for (Map.Entry<TypeElement, ExecutableElement> builderMethodEntry :
-              subcomponentBuilderSpec.methodMap().entrySet()) {
-            TypeElement moduleType = builderMethodEntry.getKey();
-            TypeElement originatingComponent = existingModuleToOwners.get(moduleType);
-            /* A subcomponent builder allows you to pass a module that is already present in the
-             * parent.  This can't be an error because it might be valid in _other_ components, so
-             * we warn here, unless the warning is suppressed on the subcomponent method or the
-             * builder method. */
-            ExecutableElement builderMethodElement = builderMethodEntry.getValue();
-            if (originatingComponent != null
-                && !repeatedModuleWarningsSuppressed(subcomponentMethodDescriptor.methodElement())
-                && !repeatedModuleWarningsSuppressed(builderMethodElement)) {
-              /* TODO(gak): consider putting this on the builder method directly if it's in the
-               * component being compiled */
-              reportBuilder.addWarning(
-                  String.format(
-                      "%1$s is installed in %2$s. A subcomponent cannot use an instance of a "
-                          + "module that differs from its parent. The implementation of %4$s "
-                          + "in %5$s will throw %6$s. To suppress this warning, annotate "
-                          + "either %4$s, %3$s, %5$s.%7$s, or %5$s with "
-                          + "@SuppressWarnings(\"repeated-module\").",
-                      moduleType.getSimpleName(),
-                      originatingComponent.getQualifiedName(),
-                      subcomponentBuilderSpec.builderDefinitionType().getQualifiedName(),
-                      builderMethodElement.getSimpleName(),
-                      componentDescriptor.componentDefinitionType().getQualifiedName(),
-                      UnsupportedOperationException.class.getSimpleName(),
-                      subcomponentMethodDescriptor.methodElement().getSimpleName()),
-                  builderMethodElement);
-            }
-          }
+          /* A subcomponent builder allows you to pass a module that is already present in the
+           * parent.  This can't be an error because it might be valid in _other_ components. Don't
+           * bother warning, because there's nothing to do except suppress the warning. */
           break;
+          
         default:
           throw new AssertionError();
       }
@@ -126,19 +94,4 @@
     }
     return reportBuilder.build();
   }
-
-  private boolean repeatedModuleWarningsSuppressed(Element element) {
-    while (true) {
-      // TODO(dpb): Extract a method to check whether a warning is suppressed on an element.
-      SuppressWarnings suppressWarnings = element.getAnnotation(SuppressWarnings.class);
-      if (suppressWarnings != null
-          && asList(suppressWarnings.value()).contains("repeated-module")) {
-        return true;
-      }
-      if (MoreElements.isType(element)) {
-        return false;
-      }
-      element = element.getEnclosingElement();
-    }
-  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
index d6492f41d..9e46214e5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
@@ -116,8 +116,7 @@ public String apply(ComponentDescriptor componentDescriptor) {
           List<String> pieces = componentQualifiedNamePieces.get(component);
           String simpleName =
               QUALIFIED_NAME_JOINER.join(
-                      pieces.subList(Math.max(0, pieces.size() - levels - 1), pieces.size()))
-                  + "Impl";
+                  pieces.subList(Math.max(0, pieces.size() - levels - 1), pieces.size()));
           ComponentDescriptor conflict = generatedSimpleNames.put(simpleName, component);
           if (conflict != null) {
             // if the map previously contained an entry for the same simple name, stop early since
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index 59726f214..88b982588 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -68,9 +68,14 @@
   private final MembersInjectionBinding.Factory membersInjectionBindingFactory;
 
   final class BindingsCollection<B extends Binding> {
+    private final BindingType bindingType;
     private final Map<Key, B> bindingsByKey = Maps.newLinkedHashMap();
     private final Deque<B> bindingsRequiringGeneration = new ArrayDeque<>();
     private final Set<Key> materializedBindingKeys = Sets.newLinkedHashSet();
+    
+    BindingsCollection(BindingType bindingType) {
+      this.bindingType = bindingType;
+    }
 
     void generateBindings(JavaPoetSourceFileGenerator<B> generator)
         throws SourceFileGenerationException {
@@ -105,10 +110,13 @@ void tryToGenerateBinding(B binding, boolean warnIfNotAlreadyGenerated) {
       if (shouldGenerateBinding(binding, generatedClassNameForBinding(binding))) {
         bindingsRequiringGeneration.offer(binding);
         if (warnIfNotAlreadyGenerated) {
-          messager.printMessage(Kind.NOTE, String.format(
-              "Generating a MembersInjector or Factory for %s. "
-                    + "Prefer to run the dagger processor over that class instead.",
-              types.erasure(binding.key().type()))); // erasure to strip <T> from msgs.
+          messager.printMessage(
+              Kind.NOTE,
+              String.format(
+                  "Generating a %s for %s. "
+                      + "Prefer to run the dagger processor over that class instead.",
+                  bindingType.frameworkClass().getSimpleName(),
+                  types.erasure(binding.key().type()))); // erasure to strip <T> from msgs.
         }
       }
     }
@@ -136,9 +144,10 @@ private void tryToCacheBinding(B binding) {
     }
   }
 
-  private final BindingsCollection<ProvisionBinding> provisionBindings = new BindingsCollection<>();
+  private final BindingsCollection<ProvisionBinding> provisionBindings =
+      new BindingsCollection<>(BindingType.PROVISION);
   private final BindingsCollection<MembersInjectionBinding> membersInjectionBindings =
-      new BindingsCollection<>();
+      new BindingsCollection<>(BindingType.MEMBERS_INJECTION);
 
   InjectBindingRegistry(
       Elements elements,
diff --git a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
index 641fefd7f..17af901fe 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
@@ -67,14 +67,14 @@ public SubcomponentWriter(
         parent.compilerOptions,
         subcomponentName(parent, subgraph),
         subgraph,
-        parent.subcomponentImplNames);
+        parent.subcomponentNames);
     this.parent = parent;
     this.subcomponentFactoryMethod = subcomponentFactoryMethod;
   }
 
   private static ClassName subcomponentName(AbstractComponentWriter parent, BindingGraph subgraph) {
     return parent.name.nestedClass(
-        parent.subcomponentImplNames.get(subgraph.componentDescriptor()));
+        parent.subcomponentNames.get(subgraph.componentDescriptor()) + "Impl");
   }
 
   @Override
@@ -128,7 +128,7 @@ protected void addBuilder() {
 
   @Override
   protected ClassName builderName() {
-    return name.peerClass(componentDefinitionTypeName().simpleName() + "Builder");
+    return name.peerClass(subcomponentNames.get(graph.componentDescriptor()) + "Builder");
   }
 
   @Override
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index 7cb18f3e5..dbf7987c4 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -2202,6 +2202,7 @@ public void unprocessedMembersInjectorNotes() {
                     "    extends LocalInjectMemberNoConstructor {",
                     "  @Inject ParentInjectMemberWithConstructor() {}",
                     "}")))
+        .withCompilerOptions("-Xlint:-processing")
         .processedWith(
             new ElementFilteringComponentProcessor(
                 Predicates.not(
@@ -2213,26 +2214,23 @@ public boolean apply(Element element) {
                             .contentEquals("test.inject");
                       }
                     })))
-        .compilesWithoutError();
-        /* TODO(b/23108801): Uncomment when compilesWithoutWarnings() is implemented.
         .compilesWithoutWarnings()
         .withNoteContaining(
-            "Generating a MembersInjector or Factory for "
+            "Generating a MembersInjector for "
                 + "test.inject.LocalInjectMemberNoConstructor. "
                 + "Prefer to run the dagger processor over that class instead.")
         .and()
         .withNoteContaining(
-            "Generating a MembersInjector or Factory for "
+            "Generating a MembersInjector for "
                 + "test.inject.LocalInjectMemberWithConstructor. "
                 + "Prefer to run the dagger processor over that class instead.")
         .and()
         .withNoteContaining(
-            "Generating a MembersInjector or Factory for "
+            "Generating a MembersInjector for "
                 + "test.inject.ParentInjectMemberWithConstructor. "
                 + "Prefer to run the dagger processor over that class instead.")
         .and()
         .withNoteCount(3);
-         */
   }
 
   /**
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index 33a897670..e49c00d89 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -20,7 +20,6 @@
 import com.google.testing.compile.JavaFileObjects;
 import java.util.Arrays;
 import javax.tools.JavaFileObject;
-import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -385,100 +384,6 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
         .onLine(28);
   }
 
-  @Ignore @Test public void cyclicDependencySimpleProviderIndirectionWarning() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.Outer",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import javax.inject.Inject;",
-            "import javax.inject.Provider;",
-            "",
-            "final class Outer {",
-            "  static class A {",
-            "    @Inject A(B bParam) {}",
-            "  }",
-            "",
-            "  static class B {",
-            "    @Inject B(C bParam, D dParam) {}",
-            "  }",
-            "",
-            "  static class C {",
-            "    @Inject C(Provider<A> aParam) {}",
-            "  }",
-            "",
-            "  static class D {",
-            "    @Inject D() {}",
-            "  }",
-            "",
-            "  @Component()",
-            "  interface CComponent {",
-            "    C get();",
-            "  }",
-            "}");
-
-    /* String expectedWarning =
-     "test.Outer.CComponent.get() contains a dependency cycle:"
-     + "      test.Outer.C.<init>(javax.inject.Provider<test.Outer.A> aParam)"
-     + "          [parameter: javax.inject.Provider<test.Outer.A> aParam]"
-     + "      test.Outer.A.<init>(test.Outer.B bParam)"
-     + "          [parameter: test.Outer.B bParam]"
-     + "      test.Outer.B.<init>(test.Outer.C bParam, test.Outer.D dParam)"
-     + "          [parameter: test.Outer.C bParam]";
-     */
-    assertAbout(javaSource()) // TODO(cgruber): Implement warning checks.
-        .that(component)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
-        //.withWarningContaining(expectedWarning).in(component).onLine(X);
-  }
-
-  @Ignore @Test public void cyclicDependencySimpleProviderIndirectionWarningSuppressed() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.Outer",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import javax.inject.Inject;",
-            "import javax.inject.Provider;",
-            "",
-            "final class Outer {",
-            "  static class A {",
-            "    @Inject A(B bParam) {}",
-            "  }",
-            "",
-            "  static class B {",
-            "    @Inject B(C bParam, D dParam) {}",
-            "  }",
-            "",
-            "  static class C {",
-            "    @Inject C(Provider<A> aParam) {}",
-            "  }",
-            "",
-            "  static class D {",
-            "    @Inject D() {}",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"dependency-cycle\")",
-            "  @Component()",
-            "  interface CComponent {",
-            "    C get();",
-            "  }",
-            "}");
-
-    assertAbout(javaSource())
-        .that(component)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
-        //.compilesWithoutWarning(); //TODO(cgruber)
-  }
-
   @Test public void duplicateExplicitBindings_ProvidesAndComponentProvision() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
         "package test;",
@@ -562,7 +467,7 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
         .failsToCompile()
         .withErrorContaining(expectedError).in(component).onLine(24);
   }
-
+  
   @Test public void duplicateExplicitBindings_MultipleProvisionTypes() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
         "package test;",
@@ -714,7 +619,7 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration()
         .in(component)
         .onLine(38);
   }
-
+  
   @Test public void duplicateBindings_TruncateAfterLimit() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
         "package test;",
@@ -1223,9 +1128,8 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration()
         .and()
         .withErrorContaining(shortErrorMessage).in(shortLifetime);
   }
-
+  
   @Test
-  @Ignore
   public void subcomponentBindingConflictsWithParent() {
     JavaFileObject parentChildConflict =
         JavaFileObjects.forSourceLines(
@@ -1251,19 +1155,23 @@ public void subcomponentBindingConflictsWithParent() {
             "import javax.inject.Qualifier;",
             "",
             "@Qualifier @interface ChildGrandchildConflict {}");
-    JavaFileObject parent =
+    
+    /* Some annotation processor implementations do not report more than one error per element. So
+     * separate parents for testing parent-conflicts-with-child and
+     * parent-conflicts-with-grandchild.
+     */
+    JavaFileObject parentConflictsWithChild =
         JavaFileObjects.forSourceLines(
-            "test.Parent",
+            "test.ParentConflictsWithChild",
             "package test;",
             "",
             "import dagger.Component;",
             "import dagger.Module;",
             "import dagger.Provides;",
             "",
-            "@Component(modules = Parent.ParentModule.class)",
-            "interface Parent {",
+            "@Component(modules = ParentConflictsWithChild.ParentModule.class)",
+            "interface ParentConflictsWithChild {",
             "  @ParentChildConflict Object parentChildConflict();",
-            "  @ParentGrandchildConflict Object parentGrandchildConflict();",
             "",
             "  Child child();",
             "",
@@ -1272,7 +1180,25 @@ public void subcomponentBindingConflictsWithParent() {
             "    @Provides @ParentChildConflict static Object parentChildConflict() {",
             "      return \"parent\";",
             "    }",
+            "  }",
+            "}");
+    JavaFileObject parentConflictsWithGrandchild =
+        JavaFileObjects.forSourceLines(
+            "test.ParentConflictsWithGrandchild",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
             "",
+            "@Component(modules = ParentConflictsWithGrandchild.ParentModule.class)",
+            "interface ParentConflictsWithGrandchild {",
+            "  @ParentGrandchildConflict Object parentGrandchildConflict();",
+            "",
+            "  Child child();",
+            "",
+            "  @Module",
+            "  static class ParentModule {",
             "    @Provides @ParentGrandchildConflict static Object parentGrandchildConflict() {",
             "      return \"parent\";",
             "    }",
@@ -1337,36 +1263,99 @@ public void subcomponentBindingConflictsWithParent() {
                 parentChildConflict,
                 parentGrandchildConflict,
                 childGrandchildConflict,
-                parent,
+                parentConflictsWithChild,
+                parentConflictsWithGrandchild,
                 child,
                 grandchild))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
-            "@ParentChildConflict Object is rebound in test.Child:\n"
-                + "      @Provides @ParentChildConflict Object"
-                + " test.Parent.ParentModule.parentChildConflict()\n"
-                + "      @Provides @ParentChildConflict Object"
-                + " test.Child.ChildModule.parentChildConflict()\n")
-        .in(parent)
-        .onLine(12)
+            "[test.Child.parentChildConflict()] "
+                + "@test.ParentChildConflict java.lang.Object is bound multiple times:\n"
+                + "      @Provides @test.ParentChildConflict Object"
+                + " test.ParentConflictsWithChild.ParentModule.parentChildConflict()\n"
+                + "      @Provides @test.ParentChildConflict Object"
+                + " test.Child.ChildModule.parentChildConflict()")
+        .in(parentConflictsWithChild)
+        .onLine(8)
         .and()
         .withErrorContaining(
-            "@ParentGrandchildConflict Object is rebound in test.Grandchild:\n"
-                + "      @Provides @ParentGrandchildConflict Object"
-                + " test.Parent.ParentModule.parentGrandchildConflict()\n"
-                + "      @Provides @ParentGrandchildConflict Object"
-                + " test.Grandchild.GrandchildModule.parentGrandchildConflict()\n")
-        .in(parent)
-        .onLine(12)
+            "[test.Grandchild.parentGrandchildConflict()] "
+                + "@test.ParentGrandchildConflict java.lang.Object is bound multiple times:\n"
+                + "      @Provides @test.ParentGrandchildConflict Object"
+                + " test.ParentConflictsWithGrandchild.ParentModule.parentGrandchildConflict()\n"
+                + "      @Provides @test.ParentGrandchildConflict Object"
+                + " test.Grandchild.GrandchildModule.parentGrandchildConflict()")
+        .in(parentConflictsWithGrandchild)
+        .onLine(8)
         .and()
         .withErrorContaining(
-            "@ChildGrandchildConflict Object is rebound in test.Grandchild:\n"
-                + "      @Provides @ChildGrandchildConflict Object"
+            "[test.Grandchild.childGrandchildConflict()] "
+                + "@test.ChildGrandchildConflict java.lang.Object is bound multiple times:\n"
+                + "      @Provides @test.ChildGrandchildConflict Object"
                 + " test.Child.ChildModule.childGrandchildConflict()\n"
-                + "      @Provides @ChildGrandchildConflict Object"
-                + " test.Grandchild.GrandchildModule.childGrandchildConflict()\n")
+                + "      @Provides @test.ChildGrandchildConflict Object"
+                + " test.Grandchild.GrandchildModule.childGrandchildConflict()")
         .in(child)
-        .onLine(12);
+        .onLine(8);
+  }
+
+  @Test
+  public void subcomponentBindingConflictsWithParentWithNullableViolationAsWarning() {
+    JavaFileObject parentConflictsWithChild =
+        JavaFileObjects.forSourceLines(
+            "test.ParentConflictsWithChild",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.annotation.Nullable;",
+            "",
+            "@Component(modules = ParentConflictsWithChild.ParentModule.class)",
+            "interface ParentConflictsWithChild {",
+            "  Child child();",
+            "",
+            "  @Module",
+            "  static class ParentModule {",
+            "    @Provides @Nullable static Object nullableParentChildConflict() {",
+            "      return \"parent\";",
+            "    }",
+            "  }",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = Child.ChildModule.class)",
+            "interface Child {",
+            "  Object parentChildConflictThatViolatesNullability();",
+            "",
+            "  @Module",
+            "  static class ChildModule {",
+            "    @Provides static Object nonNullableParentChildConflict() {",
+            "      return \"child\";",
+            "    }",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(parentConflictsWithChild, child))
+        .withCompilerOptions("-Adagger.nullableValidation=WARNING")
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "[test.Child.parentChildConflictThatViolatesNullability()] "
+                + "java.lang.Object is bound multiple times:\n"
+                + "      @Provides @javax.annotation.Nullable Object"
+                + " test.ParentConflictsWithChild.ParentModule.nullableParentChildConflict()\n"
+                + "      @Provides Object"
+                + " test.Child.ChildModule.nonNullableParentChildConflict()")
+        .in(parentConflictsWithChild)
+        .onLine(9);
   }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
index a0ec1be51..c2d7d1d16 100644
--- a/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
@@ -768,7 +768,7 @@ public void subcomponentImplNameUsesFullyQualifiedClassNameIfNecessary() {
   public void parentComponentNameShouldNotBeDisambiguatedWhenItConflictsWithASubcomponent() {
     JavaFileObject parent =
         JavaFileObjects.forSourceLines(
-            "test.ParentComponent",
+            "test.C",
             "package test;",
             "",
             "import dagger.Component;",
@@ -790,7 +790,7 @@ public void parentComponentNameShouldNotBeDisambiguatedWhenItConflictsWithASubco
 
     JavaFileObject componentGeneratedFile =
         JavaFileObjects.forSourceLines(
-            "test.DaggerParentComponent",
+            "test.DaggerC",
             "package test;",
             "",
             "import javax.annotation.Generated;",
@@ -834,4 +834,113 @@ public void parentComponentNameShouldNotBeDisambiguatedWhenItConflictsWithASubco
         .and()
         .generatesSources(componentGeneratedFile);
   }
+
+  @Test
+  public void subcomponentBuilderNamesShouldNotConflict() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.C",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Subcomponent;",
+            "",
+            "@Component",
+            "interface C {",
+            "  Foo.Sub.Builder fooBuilder();",
+            "  Bar.Sub.Builder barBuilder();",
+            "",
+            "  interface Foo {",
+            "    @Subcomponent",
+            "    interface Sub {",
+            "      @Subcomponent.Builder",
+            "      interface Builder {",
+            "        Sub build();",
+            "      }",
+            "    }",
+            "  }",
+            "",
+            "  interface Bar {",
+            "    @Subcomponent",
+            "    interface Sub {",
+            "      @Subcomponent.Builder",
+            "      interface Builder {",
+            "        Sub build();",
+            "      }",
+            "    }",
+            "  }",
+            "}");
+    JavaFileObject componentGeneratedFile =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerC",
+            "package test;",
+            "",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerC implements C {",
+            "  private DaggerC(Builder builder) {",
+            "    assert builder != null;",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static C create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public C.Foo.Sub.Builder fooBuilder() {",
+            "    return new Foo_SubBuilder();",
+            "  }",
+            "",
+            "  @Override",
+            "  public C.Bar.Sub.Builder barBuilder() {",
+            "    return new Bar_SubBuilder();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public C build() {",
+            "      return new DaggerC(this);",
+            "    }",
+            "  }",
+            "",
+            "  private final class Foo_SubBuilder implements C.Foo.Sub.Builder {",
+            "    @Override",
+            "    public C.Foo.Sub build() {",
+            "      return new Foo_SubImpl(this);",
+            "    }",
+            "  }",
+            "",
+            "  private final class Foo_SubImpl implements C.Foo.Sub {",
+            "    private Foo_SubImpl(Foo_SubBuilder builder) {",
+            "      assert builder != null;",
+            "    }",
+            "  }",
+            "",
+            "  private final class Bar_SubBuilder implements C.Bar.Sub.Builder {",
+            "    @Override",
+            "    public C.Bar.Sub build() {",
+            "      return new Bar_SubImpl(this);",
+            "    }",
+            "  }",
+            "",
+            "  private final class Bar_SubImpl implements C.Bar.Sub {",
+            "    private Bar_SubImpl(Bar_SubBuilder builder) {",
+            "      assert builder != null;",
+            "    }",
+            "  }",
+            "}");
+
+    assertAbout(javaSources())
+        .that(ImmutableList.of(parent))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(componentGeneratedFile);
+  }
 }
diff --git a/pom.xml b/pom.xml
index 851aaea16..c2b1fd922 100644
--- a/pom.xml
+++ b/pom.xml
@@ -56,7 +56,7 @@
 
 
     <!-- Test Dependencies -->
-    <compile-testing.version>0.8</compile-testing.version>
+    <compile-testing.version>0.9</compile-testing.version>
     <junit.version>4.11</junit.version>
     <mockito.version>1.9.5</mockito.version>
     <truth.version>0.26</truth.version>
