diff --git a/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java b/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java
index 9ee15b5d2..a04607dd4 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java
@@ -21,7 +21,7 @@
 import javax.inject.Provider;
 
 @Component(modules = PrimitivesModule.class)
-interface BasicComponent {
+interface BasicComponent extends Injector<Thing> {
   byte getByte();
   char getChar();
   short getShort();
diff --git a/compiler/src/it/functional-tests/src/main/java/test/Injector.java b/compiler/src/it/functional-tests/src/main/java/test/Injector.java
new file mode 100644
index 000000000..2a5798a03
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/Injector.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Lazy;
+import dagger.MembersInjector;
+import javax.inject.Provider;
+
+/**
+ * A simple interface that exercises all forms of injection for a given type.
+ */
+interface Injector<T> {
+  T instance();
+  Provider<T> provider();
+  Lazy<T> lazy();
+  MembersInjector<T> membersInjector();
+  void injectMembers(T t);
+  T injectMembersAndReturn(T t);
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 218e3b340..03f759a2e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -39,11 +39,12 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
@@ -140,10 +141,12 @@
 
   static final class Factory {
     private final Elements elements;
+    private final Types types;
     private final DependencyRequest.Factory dependencyRequestFactory;
 
-    Factory(Elements elements, DependencyRequest.Factory dependencyRequestFactory) {
+    Factory(Elements elements, Types types, DependencyRequest.Factory dependencyRequestFactory) {
       this.elements = elements;
+      this.types = types;
       this.dependencyRequestFactory = dependencyRequestFactory;
     }
 
@@ -193,7 +196,7 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
           ImmutableMap.builder();
       for (ExecutableElement componentMethod : unimplementedMethods) {
         ComponentMethodDescriptor componentMethodDescriptor =
-            getDescriptorForComponentMethod(kind, componentMethod);
+            getDescriptorForComponentMethod(componentDefinitionType, kind, componentMethod);
         componentMethodsBuilder.add(componentMethodDescriptor);
         if (componentMethodDescriptor.kind().equals(ComponentMethodKind.SUBCOMPONENT)) {
           subcomponentDescriptors.put(componentMethod,
@@ -215,21 +218,26 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
           componentMethodsBuilder.build());
     }
 
-    private ComponentMethodDescriptor getDescriptorForComponentMethod(Kind componentKind,
+    private ComponentMethodDescriptor getDescriptorForComponentMethod(TypeElement componentElement,
+        Kind componentKind,
         ExecutableElement componentMethod) {
-      TypeMirror returnType = componentMethod.getReturnType();
+      ExecutableType resolvedComponentMethod = MoreTypes.asExecutable(types.asMemberOf(
+          MoreTypes.asDeclared(componentElement.asType()), componentMethod));
+      TypeMirror returnType = resolvedComponentMethod.getReturnType();
       if (returnType.getKind().equals(DECLARED)) {
         if (MoreTypes.isTypeOf(Provider.class, returnType)
             || MoreTypes.isTypeOf(Lazy.class, returnType)) {
           return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
               ComponentMethodKind.PROVISON,
-              Optional.of(dependencyRequestFactory.forComponentProvisionMethod(componentMethod)),
+              Optional.of(dependencyRequestFactory.forComponentProvisionMethod(componentMethod,
+                  resolvedComponentMethod)),
               componentMethod);
         } else if (MoreTypes.isTypeOf(MembersInjector.class, returnType)) {
           return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
               ComponentMethodKind.MEMBERS_INJECTION,
               Optional.of(dependencyRequestFactory.forComponentMembersInjectionMethod(
-                  componentMethod)),
+                  componentMethod,
+                  resolvedComponentMethod)),
               componentMethod);
         } else if (getAnnotationMirror(MoreTypes.asElement(returnType), Subcomponent.class)
             .isPresent()) {
@@ -247,26 +255,29 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(Kind component
           case COMPONENT:
             return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
                 ComponentMethodKind.PROVISON,
-                Optional.of(dependencyRequestFactory.forComponentProvisionMethod(componentMethod)),
+                Optional.of(dependencyRequestFactory.forComponentProvisionMethod(componentMethod,
+                    resolvedComponentMethod)),
                 componentMethod);
           case PRODUCTION_COMPONENT:
             return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
                 ComponentMethodKind.PRODUCTION,
-                Optional.of(dependencyRequestFactory.forComponentProductionMethod(componentMethod)),
+                Optional.of(dependencyRequestFactory.forComponentProductionMethod(componentMethod,
+                    resolvedComponentMethod)),
                 componentMethod);
           default:
             throw new AssertionError();
         }
       }
 
-      List<? extends VariableElement> parameters = componentMethod.getParameters();
-      if (parameters.size() == 1
+      List<? extends TypeMirror> parameterTypes = resolvedComponentMethod.getParameterTypes();
+      if (parameterTypes.size() == 1
           && (returnType.getKind().equals(VOID)
-              || MoreTypes.equivalence().equivalent(returnType, parameters.get(0).asType()))) {
+              || MoreTypes.equivalence().equivalent(returnType, parameterTypes.get(0)))) {
         return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
             ComponentMethodKind.MEMBERS_INJECTION,
             Optional.of(dependencyRequestFactory.forComponentMembersInjectionMethod(
-                componentMethod)),
+                componentMethod,
+                resolvedComponentMethod)),
             componentMethod);
       }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 17d079c10..2a9f434a7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -84,6 +84,7 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementKindVisitor6;
 import javax.lang.model.util.SimpleAnnotationValueVisitor6;
@@ -662,12 +663,17 @@ private void writeInterfaceMethods(BindingGraph input, ClassWriter componentWrit
         DependencyRequest interfaceRequest = componentMethod.dependencyRequest().get();
         ExecutableElement requestElement =
             MoreElements.asExecutable(interfaceRequest.requestElement());
-        MethodSignature signature = MethodSignature.fromExecutableElement(requestElement);
+        ExecutableType requestType = MoreTypes.asExecutable(types.asMemberOf(
+            MoreTypes.asDeclared(input.componentDescriptor().componentDefinitionType().asType()),
+            requestElement));
+        MethodSignature signature = MethodSignature.fromExecutableType(
+            requestElement.getSimpleName().toString(),
+            requestType);
         if (!interfaceMethods.contains(signature)) {
           interfaceMethods.add(signature);
-          MethodWriter interfaceMethod = requestElement.getReturnType().getKind().equals(VOID)
+          MethodWriter interfaceMethod = requestType.getReturnType().getKind().equals(VOID)
               ? componentWriter.addMethod(VoidName.VOID, requestElement.getSimpleName().toString())
-                  : componentWriter.addMethod(requestElement.getReturnType(),
+                  : componentWriter.addMethod(requestType.getReturnType(),
                       requestElement.getSimpleName().toString());
           interfaceMethod.annotate(Override.class);
           interfaceMethod.addModifiers(PUBLIC);
@@ -684,14 +690,15 @@ private void writeInterfaceMethods(BindingGraph input, ClassWriter componentWrit
                 VariableElement parameter = Iterables.getOnlyElement(parameters);
                 Name parameterName = parameter.getSimpleName();
                 interfaceMethod.addParameter(
-                    TypeNames.forTypeMirror(parameter.asType()), parameterName.toString());
-                interfaceMethod.body()
-                .addSnippet("%s.injectMembers(%s);",
+                    TypeNames.forTypeMirror(
+                        Iterables.getOnlyElement(requestType.getParameterTypes())),
+                    parameterName.toString());
+                interfaceMethod.body().addSnippet("%s.injectMembers(%s);",
                     // in this case we know we won't need the cast because we're never going to pass
                     // the reference to anything
                     membersInjectorSelect.getSnippetFor(componentWriter.name()),
                     parameterName);
-                if (!requestElement.getReturnType().getKind().equals(VOID)) {
+                if (!requestType.getReturnType().getKind().equals(VOID)) {
                   interfaceMethod.body().addSnippet("return %s;", parameterName);
                 }
               }
@@ -704,7 +711,7 @@ private void writeInterfaceMethods(BindingGraph input, ClassWriter componentWrit
                 // in a temporary variable, in order to help javac be able to infer
                 // the generics of the Factory.create methods.
                 TypeName factoryType = ParameterizedTypeName.create(Provider.class,
-                    TypeNames.forTypeMirror(requestElement.getReturnType()));
+                    TypeNames.forTypeMirror(requestType.getReturnType()));
                 interfaceMethod.body().addSnippet("%s factory = %s;", factoryType,
                     memberSelectSnippets.get(bindingKey).getSnippetFor(componentWriter.name()));
                 interfaceMethod.body().addSnippet("return factory.get();");
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index fa18be53d..401681c72 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -117,7 +117,7 @@ public SourceVersion getSupportedSourceVersion() {
         membersInjectionBindingFactory, membersInjectorGenerator);
 
     ComponentDescriptor.Factory componentDescriptorFactory =
-        new ComponentDescriptor.Factory(elements, dependencyRequestFactory);
+        new ComponentDescriptor.Factory(elements, types, dependencyRequestFactory);
 
     BindingGraph.Factory bindingGraphFactory = new BindingGraph.Factory(
         elements, types, injectBindingRegistry, keyFactory,
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index 9b42030e8..2fbb507c2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -37,6 +37,7 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 
@@ -164,21 +165,24 @@ DependencyRequest forRequiredResolvedVariable(DeclaredType container,
       return newDependencyRequest(variableElement, resolvedType, qualifier, container);
     }
 
-    DependencyRequest forComponentProvisionMethod(ExecutableElement provisionMethod) {
+    DependencyRequest forComponentProvisionMethod(ExecutableElement provisionMethod,
+        ExecutableType provisionMethodType) {
       checkNotNull(provisionMethod);
+      checkNotNull(provisionMethodType);
       checkArgument(provisionMethod.getParameters().isEmpty(),
           "Component provision methods must be empty: " + provisionMethod);
-      TypeMirror type = provisionMethod.getReturnType();
       Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(provisionMethod);
-      return newDependencyRequest(provisionMethod, type, qualifier,
+      return newDependencyRequest(provisionMethod, provisionMethodType.getReturnType(), qualifier,
           getEnclosingType(provisionMethod));
     }
 
-    DependencyRequest forComponentProductionMethod(ExecutableElement productionMethod) {
+    DependencyRequest forComponentProductionMethod(ExecutableElement productionMethod,
+        ExecutableType productionMethodType) {
       checkNotNull(productionMethod);
+      checkNotNull(productionMethodType);
       checkArgument(productionMethod.getParameters().isEmpty(),
           "Component production methods must be empty: %s", productionMethod);
-      TypeMirror type = productionMethod.getReturnType();
+      TypeMirror type = productionMethodType.getReturnType();
       Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(productionMethod);
       DeclaredType container = getEnclosingType(productionMethod);
       // Only a component production method can be a request for a ListenableFuture, so we
@@ -196,12 +200,14 @@ DependencyRequest forComponentProductionMethod(ExecutableElement productionMetho
       }
     }
 
-    DependencyRequest forComponentMembersInjectionMethod(ExecutableElement membersInjectionMethod) {
+    DependencyRequest forComponentMembersInjectionMethod(ExecutableElement membersInjectionMethod,
+        ExecutableType membersInjectionMethodType) {
       checkNotNull(membersInjectionMethod);
+      checkNotNull(membersInjectionMethodType);
       Optional<AnnotationMirror> qualifier =
           InjectionAnnotations.getQualifier(membersInjectionMethod);
       checkArgument(!qualifier.isPresent());
-      TypeMirror returnType = membersInjectionMethod.getReturnType();
+      TypeMirror returnType = membersInjectionMethodType.getReturnType();
       if (returnType.getKind().equals(DECLARED)
           && MoreTypes.isTypeOf(MembersInjector.class, returnType)) {
         return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR,
@@ -213,7 +219,7 @@ DependencyRequest forComponentMembersInjectionMethod(ExecutableElement membersIn
       } else {
         return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR,
             keyFactory.forMembersInjectedType(
-                Iterables.getOnlyElement(membersInjectionMethod.getParameters()).asType()),
+                Iterables.getOnlyElement(membersInjectionMethodType.getParameterTypes())),
                 membersInjectionMethod,
                 getEnclosingType(membersInjectionMethod),
                 false /* doesn't allow null */);
diff --git a/compiler/src/main/java/dagger/internal/codegen/MethodSignature.java b/compiler/src/main/java/dagger/internal/codegen/MethodSignature.java
index d45fd8758..447ed24ef 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MethodSignature.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MethodSignature.java
@@ -4,8 +4,7 @@
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
 import com.google.common.collect.ImmutableList;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
 
 import static com.google.common.base.Preconditions.checkNotNull;
@@ -16,18 +15,18 @@
   abstract ImmutableList<Equivalence.Wrapper<TypeMirror>> parameterTypes();
   abstract ImmutableList<Equivalence.Wrapper<TypeMirror>> thrownTypes();
 
-  static MethodSignature fromExecutableElement(ExecutableElement method) {
-    checkNotNull(method);
+  static MethodSignature fromExecutableType(String methodName, ExecutableType methodType) {
+    checkNotNull(methodType);
     ImmutableList.Builder<Equivalence.Wrapper<TypeMirror>> parameters = ImmutableList.builder();
     ImmutableList.Builder<Equivalence.Wrapper<TypeMirror>> thrownTypes = ImmutableList.builder();
-    for (VariableElement parameter : method.getParameters()) {
-      parameters.add(MoreTypes.equivalence().wrap(parameter.asType()));
+    for (TypeMirror parameter : methodType.getParameterTypes()) {
+      parameters.add(MoreTypes.equivalence().wrap(parameter));
     }
-    for (TypeMirror thrownType : method.getThrownTypes()) {
+    for (TypeMirror thrownType : methodType.getThrownTypes()) {
       thrownTypes.add(MoreTypes.equivalence().wrap(thrownType));
     }
     return new AutoValue_MethodSignature(
-        method.getSimpleName().toString(),
+        methodName,
         parameters.build(),
         thrownTypes.build());
   }
