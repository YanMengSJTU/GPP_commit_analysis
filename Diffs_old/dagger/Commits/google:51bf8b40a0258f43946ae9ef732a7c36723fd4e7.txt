diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
index ac0624f83..92355088b 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
@@ -50,4 +50,23 @@
   Map<StringKey, String> unwrappedAnnotationKeyMap();
   Map<WrappedAnnotationKey, String> wrappedAnnotationKeyMap();
   @Named("complexQualifier") Set<String> complexQualifierStringSet();
+  Set<Object> emptySet();
+
+  @Named("complexQualifier")
+  Set<Object> emptyQualifiedSet();
+
+  Map<String, Object> emptyMap();
+
+  @Named("complexQualifier")
+  Map<String, Object> emptyQualifiedMap();
+
+  Set<CharSequence> maybeEmptySet();
+
+  @Named("complexQualifier")
+  Set<CharSequence> maybeEmptyQualifiedSet();
+
+  Map<String, CharSequence> maybeEmptyMap();
+
+  @Named("complexQualifier")
+  Map<String, CharSequence> maybeEmptyQualifiedMap();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
index 4a7577e76..08433a988 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
@@ -16,6 +16,7 @@
 package test;
 
 import dagger.Module;
+import dagger.Multibindings;
 import dagger.Provides;
 import dagger.mapkeys.ClassKey;
 import dagger.mapkeys.IntKey;
@@ -178,4 +179,53 @@ static String valueForWrappedAnnotationKeyFoo() {
   static String valueForComplexQualifierSet() {
     return "foo";
   }
+
+  @Provides(type = SET)
+  static CharSequence setContribution() {
+    return "foo";
+  }
+
+  @Provides(type = SET)
+  @Named("complexQualifier")
+  static CharSequence qualifiedSetContribution() {
+    return "qualified foo";
+  }
+
+  @Provides(type = MAP)
+  @StringKey("key")
+  static CharSequence mapContribution() {
+    return "foo value";
+  }
+
+  @Provides(type = MAP)
+  @Named("complexQualifier")
+  @StringKey("key")
+  static CharSequence qualifiedMapContribution() {
+    return "qualified foo value";
+  }
+
+  interface EmptiesSupertype {
+    Set<Object> emptySet();
+
+    Map<String, Object> emptyMap();
+
+    Set<CharSequence> maybeEmptySet();
+
+    Map<String, CharSequence> maybeEmptyMap();
+  }
+
+  @Multibindings
+  interface Empties extends EmptiesSupertype {
+    @Named("complexQualifier")
+    Set<Object> emptyQualifiedSet();
+
+    @Named("complexQualifier")
+    Map<String, Object> emptyQualifiedMap();
+
+    @Named("complexQualifier")
+    Set<CharSequence> maybeEmptyQualifiedSet();
+
+    @Named("complexQualifier")
+    Map<String, CharSequence> maybeEmptyQualifiedMap();
+  }
 }
diff --git a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
index 1b7e30233..e0ad8e651 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
@@ -154,6 +154,47 @@ public void shortKeyMap() {
   @Test public void complexQualifierSet() {
     assertThat(multibindingComponent.complexQualifierStringSet()).containsExactly("foo");
   }
+  
+  @Test
+  public void emptySet() {
+    assertThat(multibindingComponent.emptySet()).isEmpty();
+  }
+
+  @Test
+  public void emptyQualifiedSet() {
+    assertThat(multibindingComponent.emptyQualifiedSet()).isEmpty();
+  }
+
+  @Test
+  public void emptyMap() {
+    assertThat(multibindingComponent.emptyMap()).isEmpty();
+  }
+
+  @Test
+  public void emptyQualifiedMap() {
+    assertThat(multibindingComponent.emptyQualifiedMap()).isEmpty();
+  }
+
+  @Test
+  public void maybeEmptySet() {
+    assertThat(multibindingComponent.maybeEmptySet()).containsExactly("foo");
+  }
+
+  @Test
+  public void maybeEmptyQualifiedSet() {
+    assertThat(multibindingComponent.maybeEmptyQualifiedSet()).containsExactly("qualified foo");
+  }
+
+  @Test
+  public void maybeEmptyMap() {
+    assertThat(multibindingComponent.maybeEmptyMap()).containsEntry("key", "foo value");
+  }
+
+  @Test
+  public void maybeEmptyQualifiedMap() {
+    assertThat(multibindingComponent.maybeEmptyQualifiedMap())
+        .containsEntry("key", "qualified foo value");
+  }
 
   @AutoAnnotation
   static StringKey testStringKey(String value) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index a97a59eb5..581aab618 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -454,18 +454,19 @@ private void addFields() {
 
   private void addField(ResolvedBindings resolvedBindings) {
     BindingKey bindingKey = resolvedBindings.bindingKey();
-
-    // No field needed if there are no owned bindings.
-    if (resolvedBindings.ownedBindings().isEmpty()) {
-      return;
-    }
     
-    // No field needed for bindings with no dependencies or state.
+    // If the binding can be satisfied with a static method call without dependencies or state,
+    // no field is necessary.
     Optional<MemberSelect> staticMemberSelect = staticMemberSelect(resolvedBindings);
     if (staticMemberSelect.isPresent()) {
       memberSelectSnippets.put(bindingKey, staticMemberSelect.get());
       return;
     }
+    
+    // No field needed if there are no owned bindings.
+    if (resolvedBindings.ownedBindings().isEmpty()) {
+      return;
+    }
 
     Optional<String> bindingPackage = resolvedBindings.bindingPackage();
     boolean useRawType = bindingPackage.isPresent()
@@ -527,6 +528,20 @@ private FieldWriter addFrameworkField(boolean useRawType,
   private Optional<MemberSelect> staticMemberSelect(ResolvedBindings resolvedBindings) {
     switch (resolvedBindings.bindingKey().kind()) {
       case CONTRIBUTION:
+        if (resolvedBindings.isMultibindings()
+            && resolvedBindings.contributionBindings().isEmpty()) {
+          switch (resolvedBindings.contributionType()) {
+            case MAP:
+              return Optional.of(emptyMapProviderFactoryStaticMemberSelect());
+
+            case SET:
+              return Optional.of(emptySetFactoryStaticMemberSelect(resolvedBindings));
+
+            case UNIQUE:
+            default:
+              throw new AssertionError("Multibindings must be map or set, not " + resolvedBindings);
+          }
+        }
         if (resolvedBindings.contributionBindings().size() != 1) {
           return Optional.absent();
         }
@@ -563,6 +578,48 @@ private FieldWriter addFrameworkField(boolean useRawType,
     return Optional.absent();
   }
 
+  /**
+   * A static member select for a call to {@link MapProviderFactory#empty()}.
+   */
+  private MemberSelect emptyMapProviderFactoryStaticMemberSelect() {
+    return staticMethodInvocationWithCast(
+        ClassName.fromClass(MapProviderFactory.class),
+        Snippet.format("empty()"),
+        ClassName.fromClass(MapProviderFactory.class));
+  }
+
+  /**
+   * A static member select for a call to {@code F.create()} where {@code F} is either
+   * {@link SetFactory}, {@link SetProducer}, or {@link SetOfProducedProducer}, depending on the
+   * set bindings.
+   */
+  private MemberSelect emptySetFactoryStaticMemberSelect(ResolvedBindings setBindings) {
+    ClassName setFactoryClassName = setFactoryClassName(setBindings);
+    return staticMethodInvocationWithCast(
+        setFactoryClassName, Snippet.format("create()"), setFactoryClassName);
+  }
+
+  /**
+   * Returns a {@link Set} factory class name appropriate for the set bindings.
+   *
+   * <ul>
+   * <li>{@link SetFactory} for provision bindings.
+   * <li>{@link SetProducer} for production bindings for {@code Set<T>}.
+   * <li>{@link SetOfProducedProducer} for production bindings for {@code Set<Produced<T>>}.
+   * </ul>
+   */
+  private ClassName setFactoryClassName(ResolvedBindings setBindings) {
+    if (setBindings.bindingType().equals(BindingType.PROVISION)) {
+      return ClassName.fromClass(SetFactory.class);
+    } else {
+      SetType setType = SetType.from(setBindings.bindingKey().key().type());
+      return ClassName.fromClass(
+          setType.elementsAreTypeOf(Produced.class)
+              ? SetOfProducedProducer.class
+              : SetProducer.class);
+    }
+  }
+
   private void implementInterfaceMethods() {
     Set<MethodSignature> interfaceMethods = Sets.newHashSet();
     for (ComponentMethodDescriptor componentMethod :
@@ -745,19 +802,10 @@ private Snippet initializeSetMultibindings(ResolvedBindings resolvedBindings) {
       }
       parameterSnippets.add(snippet);
     }
-    SetType setType = SetType.from(resolvedBindings.bindingKey().key().type());
-    Class<?> factoryClass =
-        Iterables.all(
-                resolvedBindings.contributionBindings(),
-                BindingType.isOfType(BindingType.PROVISION))
-            ? SetFactory.class
-            : setType.elementsAreTypeOf(Produced.class)
-                ? SetOfProducedProducer.class
-                : SetProducer.class;
     Snippet initializeSetSnippet =
         Snippet.format(
             "%s.create(%s)",
-            ClassName.fromClass(factoryClass),
+            setFactoryClassName(resolvedBindings),
             makeParametersSnippet(parameterSnippets.build()));
     initializationSnippets.add(
         initializeMember(resolvedBindings.bindingKey(), initializeSetSnippet));
@@ -1022,7 +1070,8 @@ private Snippet initializeFactoryForContributionBinding(ContributionBinding bind
         return Snippet.format(
             "%s.create(%s)",
             ClassName.fromClass(MapFactory.class),
-            getMemberSelectSnippet(getOnlyElement(binding.dependencies()).bindingKey()));
+            getMemberSelect(getOnlyElement(binding.dependencies()).bindingKey())
+                .getSnippetWithRawTypeCastFor(name));
 
       default:
         throw new AssertionError();
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 915c30b85..b4fc2dc40 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -39,6 +39,7 @@
 import java.util.Collection;
 import java.util.Deque;
 import java.util.HashSet;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
@@ -225,16 +226,21 @@ private BindingGraph create(
                 componentDescriptor.componentDefinitionType()));
       }
 
-      // Collect transitive module bindings.
+      ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarations =
+          ImmutableSet.builder();
+
+      // Collect transitive module bindings and multibinding declarations.
       for (ModuleDescriptor moduleDescriptor : componentDescriptor.transitiveModules()) {
-        for (ContributionBinding binding : moduleDescriptor.bindings()) {
-          explicitBindingsBuilder.add(binding);
-        }
+        explicitBindingsBuilder.addAll(moduleDescriptor.bindings());
+        multibindingDeclarations.addAll(moduleDescriptor.multibindingDeclarations());
       }
 
       Resolver requestResolver =
           new Resolver(
-              parentResolver, componentDescriptor, indexByKey(explicitBindingsBuilder.build()));
+              parentResolver,
+              componentDescriptor,
+              indexByKey(explicitBindingsBuilder.build()),
+              indexByKey(multibindingDeclarations.build()));
       for (ComponentMethodDescriptor componentMethod : componentDescriptor.componentMethods()) {
         Optional<DependencyRequest> componentMethodRequest = componentMethod.dependencyRequest();
         if (componentMethodRequest.isPresent()) {
@@ -271,15 +277,16 @@ private BindingGraph create(
       final ComponentDescriptor componentDescriptor;
       final ImmutableSetMultimap<Key, ContributionBinding> explicitBindings;
       final ImmutableSet<ContributionBinding> explicitBindingsSet;
+      final ImmutableSetMultimap<Key, MultibindingDeclaration> multibindingDeclarations;
       final Map<BindingKey, ResolvedBindings> resolvedBindings;
       final Deque<BindingKey> cycleStack = new ArrayDeque<>();
       final Cache<BindingKey, Boolean> dependsOnLocalMultibindingsCache =
           CacheBuilder.newBuilder().<BindingKey, Boolean>build();
-
       Resolver(
           Optional<Resolver> parentResolver,
           ComponentDescriptor componentDescriptor,
-          ImmutableSetMultimap<Key, ContributionBinding> explicitBindings) {
+          ImmutableSetMultimap<Key, ContributionBinding> explicitBindings,
+          ImmutableSetMultimap<Key, MultibindingDeclaration> multibindingDeclarations) {
         assert parentResolver != null;
         this.parentResolver = parentResolver;
         assert componentDescriptor != null;
@@ -287,6 +294,8 @@ private BindingGraph create(
         assert explicitBindings != null;
         this.explicitBindings = explicitBindings;
         this.explicitBindingsSet = ImmutableSet.copyOf(explicitBindings.values());
+        assert multibindingDeclarations != null;
+        this.multibindingDeclarations = multibindingDeclarations;
         this.resolvedBindings = Maps.newLinkedHashMap();
       }
 
@@ -315,51 +324,69 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
         BindingKey bindingKey = request.bindingKey();
         switch (bindingKey.kind()) {
           case CONTRIBUTION:
-            ImmutableSet.Builder<ContributionBinding> explicitBindingsBuilder =
+            Set<ContributionBinding> contributionBindings = new LinkedHashSet<>();
+            ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarationsBuilder =
                 ImmutableSet.builder();
-            // Add explicit bindings (those from modules and components).
-            explicitBindingsBuilder.addAll(getExplicitBindings(bindingKey.key()));
-            // If the key is Set<Produced<T>>, then add explicit bindings for Set<T>.
-            explicitBindingsBuilder.addAll(
-                getExplicitBindings(keyFactory.implicitSetKeyFromProduced(bindingKey.key())));
-
-            // If the key is Map<K, V>, get its implicit binding keys, which are either
-            // Map<K, Provider<V>> or Map<K, Producer<V>>, and grab their explicit bindings.
+
+            // Add explicit bindings and declarations (those from modules and components).
+            contributionBindings.addAll(getExplicitBindings(bindingKey.key()));
+            multibindingDeclarationsBuilder.addAll(getMultibindingDeclarations(bindingKey.key()));
+
+            // If the key is Set<Produced<T>>, then add explicit bindings and declarations for
+            // Set<T>.
+            Optional<Key> implicitSetKey = keyFactory.implicitSetKeyFromProduced(bindingKey.key());
+            contributionBindings.addAll(getExplicitBindings(implicitSetKey));
+            multibindingDeclarationsBuilder.addAll(getMultibindingDeclarations(implicitSetKey));
+
+            ImmutableSet<MultibindingDeclaration> multibindingDeclarations =
+                multibindingDeclarationsBuilder.build();
+
+            // If the key is Map<K, V>, get its map-of-framework-type binding keys, which are either
+            // Map<K, Provider<V>> or Map<K, Producer<V>>, and grab their explicit bindings and
+            // declarations.
+            Optional<Key> implicitMapProviderKey =
+                keyFactory.implicitMapProviderKeyFrom(bindingKey.key());
             ImmutableSet<ContributionBinding> explicitProviderMapBindings =
-                getExplicitBindings(keyFactory.implicitMapProviderKeyFrom(bindingKey.key()));
+                getExplicitBindings(implicitMapProviderKey);
+            ImmutableSet<MultibindingDeclaration> explicitProviderMultibindingDeclarations =
+                getMultibindingDeclarations(implicitMapProviderKey);
+
+            Optional<Key> implicitMapProducerKey =
+                keyFactory.implicitMapProducerKeyFrom(bindingKey.key());
             ImmutableSet<ContributionBinding> explicitProducerMapBindings =
-                getExplicitBindings(keyFactory.implicitMapProducerKeyFrom(bindingKey.key()));
+                getExplicitBindings(implicitMapProducerKey);
+            ImmutableSet<MultibindingDeclaration> explicitProducerMultibindingDeclarations =
+                getMultibindingDeclarations(implicitMapProducerKey);
 
-            if (!explicitProducerMapBindings.isEmpty()) {
+            if (!explicitProducerMapBindings.isEmpty()
+                || !explicitProducerMultibindingDeclarations.isEmpty()) {
               /* If the binding key is Map<K, V>, and there are some explicit Map<K, Producer<V>>
-               * bindings, then add the synthetic binding that depends on Map<K, Producer<V>>. */
-              explicitBindingsBuilder.add(
+               * bindings or multibinding declarations, then add the synthetic binding that depends
+               * on Map<K, Producer<V>>. */
+              contributionBindings.add(
                   productionBindingFactory.implicitMapOfProducerBinding(request));
-            } else if (!explicitProviderMapBindings.isEmpty()) {
+            } else if (!explicitProviderMapBindings.isEmpty()
+                || !explicitProviderMultibindingDeclarations.isEmpty()) {
               /* If the binding key is Map<K, V>, and there are some explicit Map<K, Provider<V>>
-               * bindings but no explicit Map<K, Producer<V>> bindings, then add the synthetic
-               * binding that depends on Map<K, Provider<V>>. */
-              explicitBindingsBuilder.add(
+               * bindings or multibinding declarations but no explicit Map<K, Producer<V>> bindings
+               * or multibinding declarations, then add the synthetic binding that depends on
+               * Map<K, Provider<V>>. */
+              contributionBindings.add(
                   provisionBindingFactory.implicitMapOfProviderBinding(request));
             }
 
-            ImmutableSet<ContributionBinding> explicitBindings = explicitBindingsBuilder.build();
-
-            final Set<? extends ContributionBinding> resolvedContributionBindings;
-            if (explicitBindings.isEmpty()) {
-              /* If there are no explicit or synthetic bindings, use an implicit @Inject-
-               * constructed binding if there is one. */
-              resolvedContributionBindings =
-                  injectBindingRegistry.getOrFindProvisionBinding(bindingKey.key()).asSet();
-            } else {
-              /* Otherwise there is at least one binding. If the graph is invalid, the validator
-               * will report that. */
-              resolvedContributionBindings = explicitBindings;
+            /* If there are no explicit or synthetic bindings or multibinding declarations, use an
+             * implicit @Inject- constructed binding if there is one. */
+            if (contributionBindings.isEmpty() && multibindingDeclarations.isEmpty()) {
+              contributionBindings.addAll(
+                  injectBindingRegistry.getOrFindProvisionBinding(bindingKey.key()).asSet());
             }
+
             return ResolvedBindings.forContributionBindings(
                 bindingKey,
                 componentDescriptor,
-                indexBindingsByOwningComponent(request, resolvedContributionBindings));
+                indexBindingsByOwningComponent(request, ImmutableSet.copyOf(contributionBindings)),
+                multibindingDeclarations);
 
           case MEMBERS_INJECTION:
             // no explicit deps for members injection, so just look it up
@@ -471,6 +498,26 @@ private boolean shouldOwnParentBinding(
             : ImmutableSet.<ContributionBinding>of();
       }
 
+      /**
+       * Returns the {@link MultibindingDeclaration}s that match the {@code key} from this and all
+       * ancestor resolvers.
+       */
+      private ImmutableSet<MultibindingDeclaration> getMultibindingDeclarations(Key key) {
+        ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarations =
+            ImmutableSet.builder();
+        for (Resolver resolver : getResolverLineage()) {
+          multibindingDeclarations.addAll(resolver.multibindingDeclarations.get(key));
+        }
+        return multibindingDeclarations.build();
+      }
+
+      private ImmutableSet<MultibindingDeclaration> getMultibindingDeclarations(
+          Optional<Key> optionalKey) {
+        return optionalKey.isPresent()
+            ? getMultibindingDeclarations(optionalKey.get())
+            : ImmutableSet.<MultibindingDeclaration>of();
+      }
+
       private Optional<ResolvedBindings> getPreviouslyResolvedBindings(
           final BindingKey bindingKey) {
         Optional<ResolvedBindings> result = Optional.fromNullable(resolvedBindings.get(bindingKey));
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index d8b1d2358..d4c3b391b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -40,6 +40,7 @@
 import dagger.MapKey;
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.SourceElement.HasSourceElement;
 import dagger.internal.codegen.writer.TypeNames;
 import java.util.ArrayDeque;
 import java.util.Arrays;
@@ -275,7 +276,7 @@ private void traverseRequest(
      */
     private boolean validateResolvedBinding(
         Deque<ResolvedRequest> path, ResolvedBindings resolvedBinding) {
-      if (resolvedBinding.bindings().isEmpty()) {
+      if (resolvedBinding.isEmpty()) {
         reportMissingBinding(path);
         return false;
       }
@@ -298,15 +299,15 @@ private boolean validateResolvedBinding(
             reportProviderMayNotDependOnProducer(path);
             return false;
           }
-          if (contributionBindings.size() <= 1) {
-            return true;
-          }
           ImmutableSet<ContributionType> contributionTypes =
-              contributionBindingsByType(resolvedBinding).keySet();
+              declarationsByType(resolvedBinding).keySet();
           if (contributionTypes.size() > 1) {
             reportMultipleBindingTypes(path);
             return false;
           }
+          if (contributionBindings.size() <= 1) {
+            return true;
+          }
           switch (getOnlyElement(contributionTypes)) {
             case UNIQUE:
               reportDuplicateBindings(path);
@@ -343,52 +344,67 @@ private boolean validateResolvedBinding(
     /**
      * Returns an object that contains all the same bindings as {@code resolvedBindings}, except
      * that any {@link #SYNTHETIC_MAP} {@link ContributionBinding}s are replaced by the contribution
-     * bindings of their dependencies.
+     * bindings and multibinding declarations of their dependencies.
      *
      * <p>For example, if:
      *
      * <ul>
-     * <li>The bindings for {@code key1} are {@code A} and {@code B}.
+     * <li>The bindings for {@code key1} are {@code A} and {@code B}, with multibinding declaration
+     *     {@code X}.
      * <li>{@code B} is a synthetic binding with a dependency on {@code key2}.
-     * <li>The bindings for {@code key2} are {@code C} and {@code D}.
+     * <li>The bindings for {@code key2} are {@code C} and {@code D}, with multibinding declaration
+     *     {@code Y}.
      * </ul>
      *
      * then {@code inlineSyntheticBindings(bindingsForKey1)} has bindings {@code A}, {@code C}, and
-     * {@code D}.
+     * {@code D}, with multibinding declarations {@code X} and {@code Y}.
      *
      * <p>The replacement is repeated until none of the bindings are synthetic.
      */
-    private ImmutableSet<ContributionBinding> inlineSyntheticContributions(
-        ResolvedBindings resolvedBinding) {
+    private ResolvedBindings inlineSyntheticContributions(ResolvedBindings resolvedBinding) {
       if (!Iterables.any(
           resolvedBinding.contributionBindings(), ContributionBinding.isOfKind(SYNTHETIC_MAP))) {
-        return resolvedBinding.contributionBindings();
+        return resolvedBinding;
       }
-
-      ImmutableSet.Builder<ContributionBinding> inlinedBindings = ImmutableSet.builder();
-
-      Queue<ContributionBinding> bindings =
-          new ArrayDeque<>(resolvedBinding.contributionBindings());
-
-      for (ContributionBinding binding = bindings.poll();
-          binding != null;
-          binding = bindings.poll()) {
+      
+      ImmutableSetMultimap.Builder<ComponentDescriptor, ContributionBinding> contributions =
+          ImmutableSetMultimap.builder();
+      ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarations =
+          ImmutableSet.builder();
+
+      Queue<Map.Entry<ComponentDescriptor, ContributionBinding>> contributionQueue =
+          new ArrayDeque<>(resolvedBinding.allContributionBindings().entries());
+
+      for (Map.Entry<ComponentDescriptor, ContributionBinding> bindingEntry =
+              contributionQueue.poll();
+          bindingEntry != null;
+          bindingEntry = contributionQueue.poll()) {
+        ContributionBinding binding = bindingEntry.getValue();
         if (binding.bindingKind().equals(SYNTHETIC_MAP)) {
           BindingKey syntheticBindingDependency =
-              Iterables.getOnlyElement(binding.dependencies()).bindingKey();
-          ResolvedBindings syntheticBindingDependencyBindings =
+              getOnlyElement(binding.dependencies()).bindingKey();
+          ResolvedBindings dependencyBindings =
               subject.resolvedBindings().get(syntheticBindingDependency);
-          bindings.addAll(syntheticBindingDependencyBindings.contributionBindings());
+          multibindingDeclarations.addAll(dependencyBindings.multibindingDeclarations());
+          contributionQueue.addAll(dependencyBindings.allContributionBindings().entries());
         } else {
-          inlinedBindings.add(binding);
+          contributions.put(bindingEntry);
         }
       }
-      return inlinedBindings.build();
+      return ResolvedBindings.forContributionBindings(
+          resolvedBinding.bindingKey(),
+          resolvedBinding.owningComponent(),
+          contributions.build(),
+          multibindingDeclarations.build());
     }
 
-    private ImmutableListMultimap<ContributionType, ContributionBinding> contributionBindingsByType(
+    private ImmutableListMultimap<ContributionType, HasSourceElement> declarationsByType(
         ResolvedBindings resolvedBinding) {
-      return indexByContributionType(inlineSyntheticContributions(resolvedBinding));
+      ResolvedBindings inlined = inlineSyntheticContributions(resolvedBinding);
+      return new ImmutableListMultimap.Builder<ContributionType, HasSourceElement>()
+          .putAll(indexByContributionType(inlined.contributionBindings()))
+          .putAll(indexByContributionType(inlined.multibindingDeclarations()))
+          .build();
     }
 
     /** Ensures that if the request isn't nullable, then each contribution is also not nullable. */
@@ -878,7 +894,10 @@ private void reportDuplicateBindings(Deque<ResolvedRequest> path) {
       new Formatter(builder)
           .format(ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT, formatRootRequestKey(path));
       hasSourceElementFormatter.formatIndentedList(
-          builder, inlineSyntheticContributions(resolvedBinding), 1, DUPLICATE_SIZE_LIMIT);
+          builder,
+          inlineSyntheticContributions(resolvedBinding).contributionBindings(),
+          1,
+          DUPLICATE_SIZE_LIMIT);
       reportBuilder.addError(builder.toString(), path.getLast().request().requestElement());
     }
 
@@ -888,15 +907,15 @@ private void reportMultipleBindingTypes(Deque<ResolvedRequest> path) {
       new Formatter(builder)
           .format(ErrorMessages.MULTIPLE_BINDING_TYPES_FOR_KEY_FORMAT, formatRootRequestKey(path));
       ResolvedBindings resolvedBinding = path.peek().binding();
-      ImmutableListMultimap<ContributionType, ContributionBinding> bindingsByType =
-          contributionBindingsByType(resolvedBinding);
+      ImmutableListMultimap<ContributionType, HasSourceElement> declarationsByType =
+          declarationsByType(resolvedBinding);
       for (ContributionType type :
-          Ordering.natural().immutableSortedCopy(bindingsByType.keySet())) {
+          Ordering.natural().immutableSortedCopy(declarationsByType.keySet())) {
         builder.append(INDENT);
         builder.append(formatContributionType(type));
-        builder.append(" bindings:");
+        builder.append(" bindings and declarations:");
         hasSourceElementFormatter.formatIndentedList(
-            builder, bindingsByType.get(type), 2, DUPLICATE_SIZE_LIMIT);
+            builder, declarationsByType.get(type), 2, DUPLICATE_SIZE_LIMIT);
         builder.append('\n');
       }
       reportBuilder.addError(builder.toString(), path.getLast().request().requestElement());
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index dfc77efe4..369fb7c49 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -102,6 +102,9 @@ public SourceVersion getSupportedSourceVersion() {
 
     Key.Factory keyFactory = new Key.Factory(types, elements);
 
+    MultibindingsValidator multibindingsValidator =
+        new MultibindingsValidator(elements, keyFactory, keyFormatter, methodSignatureFormatter);
+
     this.factoryGenerator =
         new FactoryGenerator(
             filer, elements, DependencyRequestMapper.FOR_PROVIDER, nullableDiagnosticType);
@@ -120,6 +123,8 @@ public SourceVersion getSupportedSourceVersion() {
         new ProvisionBinding.Factory(elements, types, keyFactory, dependencyRequestFactory);
     ProductionBinding.Factory productionBindingFactory =
         new ProductionBinding.Factory(types, keyFactory, dependencyRequestFactory);
+    MultibindingDeclaration.Factory multibindingDeclarationFactory =
+        new MultibindingDeclaration.Factory(elements, types, keyFactory);
 
     MembersInjectionBinding.Factory membersInjectionBindingFactory =
         new MembersInjectionBinding.Factory(elements, types, keyFactory, dependencyRequestFactory);
@@ -127,8 +132,12 @@ public SourceVersion getSupportedSourceVersion() {
     this.injectBindingRegistry = new InjectBindingRegistry(
         elements, types, messager, provisionBindingFactory, membersInjectionBindingFactory);
 
-    ModuleDescriptor.Factory moduleDescriptorFactory = new ModuleDescriptor.Factory(
-        elements, provisionBindingFactory, productionBindingFactory);
+    ModuleDescriptor.Factory moduleDescriptorFactory =
+        new ModuleDescriptor.Factory(
+            elements,
+            provisionBindingFactory,
+            productionBindingFactory,
+            multibindingDeclarationFactory);
 
     ComponentDescriptor.Factory componentDescriptorFactory = new ComponentDescriptor.Factory(
         elements, types, dependencyRequestFactory, moduleDescriptorFactory);
@@ -166,6 +175,7 @@ public SourceVersion getSupportedSourceVersion() {
             membersInjectionBindingFactory,
             injectBindingRegistry),
         new MonitoringModuleProcessingStep(messager, monitoringModuleGenerator),
+        new MultibindingsProcessingStep(messager, multibindingsValidator),
         new ModuleProcessingStep(
             messager,
             moduleValidator,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 3468ee398..f18318572 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import dagger.Multibindings;
 import dagger.Provides;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
@@ -195,7 +196,7 @@ static String inconsistentMapKeyAnnotationsError(String key) {
       "More than one binding present of different types %s";
 
   static final String MULTIPLE_BINDING_TYPES_FOR_KEY_FORMAT =
-      "%s has incompatible bindings:\n";
+      "%s has incompatible bindings or declarations:\n";
 
   static final String PROVIDER_ENTRY_POINT_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT =
       "%s is a provision entry-point, which cannot depend on a production.";
@@ -393,6 +394,30 @@ String moreThanOneRefToSubcomponent() {
     }
   }
 
+  /** Error messages related to {@link Multibindings @Multibindings}. */
+  static final class MultibindingsMessages {
+    static final String MUST_BE_INTERFACE = "@Multibindings can be applied only to interfaces";
+
+    static final String MUST_NOT_HAVE_TYPE_PARAMETERS =
+        "@Multibindings types must not have type parameters";
+
+    static final String MUST_BE_IN_MODULE =
+        "@Multibindings types must be nested within a @Module or @ProducerModule";
+
+    static final String METHOD_MUST_RETURN_MAP_OR_SET =
+        "@Multibindings methods must return Map<K, V> or Set<T>";
+
+    static final String TOO_MANY_QUALIFIERS =
+        "Cannot use more than one @Qualifier on a method in an @Multibindings type";
+
+    static String tooManyMethodsForKey(String formattedKey) {
+      return String.format(
+          "Too many @Multibindings methods for %s", stripCommonTypePrefixes(formattedKey));
+    }
+
+    private MultibindingsMessages() {}
+  }
+
   /**
    * A regular expression to match a small list of specific packages deemed to
    * be unhelpful to display in fully qualified types in error messages.
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 346169f27..042edc5e9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -28,6 +28,7 @@
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Multimaps;
 import com.google.common.util.concurrent.ListenableFuture;
+import dagger.Multibindings;
 import dagger.Provides;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
@@ -293,6 +294,28 @@ Key forProducesMethod(ExecutableType executableType, ExecutableElement method) {
               Optional.of(producesAnnotation.type()));
       return forMethod(method, keyType);
     }
+    
+    /**
+     * Returns the key for a method in a {@link Multibindings @Multibindings} interface.
+     *
+     * The key's type is either {@code Set<T>} or {@code Map<K, F<V>>}, where {@code F} is either
+     * {@link Provider} or {@link Producer}, depending on {@code bindingType}.
+     */
+    Key forMultibindingsMethod(
+        BindingType bindingType, ExecutableType executableType, ExecutableElement method) {
+      checkArgument(method.getKind().equals(METHOD), "%s must be a method", method);
+      TypeElement factoryType =
+          elements.getTypeElement(bindingType.frameworkClass().getCanonicalName());
+      TypeMirror returnType = normalize(types, executableType.getReturnType());
+      TypeMirror keyType =
+          MapType.isMap(returnType)
+              ? mapOfFrameworkType(
+                  MapType.from(returnType).keyType(),
+                  factoryType,
+                  MapType.from(returnType).valueType())
+              : returnType;
+      return forMethod(method, keyType);
+    }
 
     private TypeMirror providesOrProducesKeyType(
         TypeMirror returnType,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
index 58a75e5f7..e423f55ee 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
@@ -1,3 +1,18 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package dagger.internal.codegen;
 
 import com.google.auto.common.MoreElements;
@@ -8,6 +23,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import dagger.Module;
+import dagger.Multibindings;
 import dagger.Provides;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
@@ -30,6 +46,7 @@
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.NONE;
 import static javax.lang.model.util.ElementFilter.methodsIn;
+import static javax.lang.model.util.ElementFilter.typesIn;
 
 @AutoValue
 abstract class ModuleDescriptor {
@@ -48,6 +65,11 @@
   abstract ImmutableSet<ModuleDescriptor> includedModules();
 
   abstract ImmutableSet<ContributionBinding> bindings();
+  
+  /**
+   * The multibinding declarations contained in this module.
+   */
+  abstract ImmutableSet<MultibindingDeclaration> multibindingDeclarations();
 
   enum DefaultCreationStrategy {
     PASSED,
@@ -113,14 +135,17 @@
     private final Elements elements;
     private final ProvisionBinding.Factory provisionBindingFactory;
     private final ProductionBinding.Factory productionBindingFactory;
+    private final MultibindingDeclaration.Factory multibindingDeclarationFactory;
 
     Factory(
         Elements elements,
         ProvisionBinding.Factory provisionBindingFactory,
-        ProductionBinding.Factory productionBindingFactory) {
+        ProductionBinding.Factory productionBindingFactory,
+        MultibindingDeclaration.Factory multibindingDeclarationFactory) {
       this.elements = elements;
       this.provisionBindingFactory = provisionBindingFactory;
       this.productionBindingFactory = productionBindingFactory;
+      this.multibindingDeclarationFactory = multibindingDeclarationFactory;
     }
 
     ModuleDescriptor create(TypeElement moduleElement) {
@@ -137,6 +162,15 @@ ModuleDescriptor create(TypeElement moduleElement) {
               productionBindingFactory.forProducesMethod(moduleMethod, moduleElement.asType()));
         }
       }
+      
+      ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarations =
+          ImmutableSet.builder();
+      for (TypeElement memberType : typesIn(elements.getAllMembers(moduleElement))) {
+        if (isAnnotationPresent(memberType, Multibindings.class)) {
+          multibindingDeclarations.addAll(
+              multibindingDeclarationFactory.forDeclaredInterface(memberType));
+        }
+      }
 
       DefaultCreationStrategy defaultCreationStrategy =
           (componentCanMakeNewInstances(moduleElement)
@@ -150,6 +184,7 @@ ModuleDescriptor create(TypeElement moduleElement) {
           ImmutableSet.copyOf(
               collectIncludedModules(new LinkedHashSet<ModuleDescriptor>(), moduleElement)),
           bindings.build(),
+          multibindingDeclarations.build(),
           defaultCreationStrategy);
     }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java
new file mode 100644
index 000000000..e708e35e9
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java
@@ -0,0 +1,160 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.ImmutableSet;
+import dagger.Module;
+import dagger.Multibindings;
+import dagger.internal.codegen.BindingType.HasBindingType;
+import dagger.internal.codegen.ContributionType.HasContributionType;
+import dagger.internal.codegen.Key.HasKey;
+import dagger.internal.codegen.SourceElement.HasSourceElement;
+import dagger.producers.Producer;
+import dagger.producers.ProducerModule;
+import java.util.Map;
+import java.util.Set;
+import javax.inject.Provider;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
+import static javax.lang.model.element.ElementKind.INTERFACE;
+
+/**
+ * A declaration that a multibinding with a certain key is available to be injected in a component
+ * even if the component has no multibindings for that key. Identified by a map- or set-returning
+ * method in a {@link Multibindings @Multibindings}-annotated interface nested within a module.
+ */
+@AutoValue
+abstract class MultibindingDeclaration
+    implements HasBindingType, HasKey, HasSourceElement, HasContributionType {
+
+  /**
+   * The method in a {@link Multibindings @Multibindings} interface that declares that this map or
+   * set is available to be injected.
+   */
+  @Override
+  public abstract SourceElement sourceElement();
+
+  /**
+   * The map or set key whose availability is declared. For maps, this will be {@code Map<K, F<V>>},
+   * where {@code F} is either {@link Provider} or {@link Producer}. For sets, this will be
+   * {@code Set<T>}.
+   */
+  @Override
+  public abstract Key key();
+
+  /**
+   * {@link ContributionType#SET} if the declared type is a {@link Set}, or
+   * {@link ContributionType#MAP} if it is a {@link Map}.
+   */
+  @Override
+  public abstract ContributionType contributionType();
+
+  /**
+   * {@link BindingType#PROVISION} if the {@link Multibindings @Multibindings}-annotated interface
+   * is nested in a {@link Module @Module}, or {@link BindingType#PROVISION} if it is nested in a
+   * {@link ProducerModule @ProducerModule}.
+   */
+  @Override
+  public abstract BindingType bindingType();
+
+  /**
+   * A factory for {@link MultibindingDeclaration}s.
+   */
+  static final class Factory {
+    private final Elements elements;
+    private final Types types;
+    private final Key.Factory keyFactory;
+    private final TypeElement objectElement;
+
+    Factory(Elements elements, Types types, Key.Factory keyFactory) {
+      this.elements = elements;
+      this.types = types;
+      this.keyFactory = keyFactory;
+      this.objectElement = elements.getTypeElement(Object.class.getCanonicalName());
+    }
+
+    /**
+     * Creates multibinding declarations for each method in a
+     * {@link Multibindings @Multibindings}-annotated interface.
+     */
+    ImmutableSet<MultibindingDeclaration> forDeclaredInterface(TypeElement interfaceElement) {
+      checkArgument(interfaceElement.getKind().equals(INTERFACE));
+      checkArgument(isAnnotationPresent(interfaceElement, Multibindings.class));
+      BindingType bindingType = bindingType(interfaceElement);
+      DeclaredType interfaceType = MoreTypes.asDeclared(interfaceElement.asType());
+
+      ImmutableSet.Builder<MultibindingDeclaration> declarations = ImmutableSet.builder();
+      for (ExecutableElement method : getLocalAndInheritedMethods(interfaceElement, elements)) {
+        if (!method.getEnclosingElement().equals(objectElement)) {
+          ExecutableType methodType =
+              MoreTypes.asExecutable(types.asMemberOf(interfaceType, method));
+          declarations.add(forDeclaredMethod(bindingType, method, methodType, interfaceElement));
+        }
+      }
+      return declarations.build();
+    }
+
+    private BindingType bindingType(TypeElement interfaceElement) {
+      if (isAnnotationPresent(interfaceElement.getEnclosingElement(), Module.class)) {
+        return BindingType.PROVISION;
+      } else if (isAnnotationPresent(
+          interfaceElement.getEnclosingElement(), ProducerModule.class)) {
+        return BindingType.PRODUCTION;
+      } else {
+        throw new IllegalArgumentException(
+            "Expected " + interfaceElement + " to be nested in a @Module or @ProducerModule");
+      }
+    }
+
+    private MultibindingDeclaration forDeclaredMethod(
+        BindingType bindingType,
+        ExecutableElement method,
+        ExecutableType methodType,
+        TypeElement interfaceElement) {
+      TypeMirror returnType = methodType.getReturnType();
+      checkArgument(
+          SetType.isSet(returnType) || MapType.isMap(returnType),
+          "%s must return a set or map",
+          method);
+      return new AutoValue_MultibindingDeclaration(
+          SourceElement.forElement(method, interfaceElement),
+          keyFactory.forMultibindingsMethod(bindingType, methodType, method),
+          contributionType(returnType),
+          bindingType);
+    }
+
+    private ContributionType contributionType(TypeMirror returnType) {
+      if (MapType.isMap(returnType)) {
+        return ContributionType.MAP;
+      } else if (SetType.isSet(returnType)) {
+        return ContributionType.SET;
+      } else {
+        throw new IllegalArgumentException("Must be Map or Set: " + returnType);
+      }
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingsProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingsProcessingStep.java
new file mode 100644
index 000000000..db14a695b
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingsProcessingStep.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import dagger.Multibindings;
+import java.lang.annotation.Annotation;
+import java.util.Set;
+import javax.annotation.processing.Messager;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+
+import static javax.lang.model.util.ElementFilter.typesIn;
+
+/**
+ * Processes elements annotated with {@link Multibindings @Multibindings}.
+ */
+class MultibindingsProcessingStep implements ProcessingStep {
+  private final Messager messager;
+  private final MultibindingsValidator multibindingsValidator;
+
+  MultibindingsProcessingStep(Messager messager, MultibindingsValidator multibindingsValidator) {
+    this.messager = messager;
+    this.multibindingsValidator = multibindingsValidator;
+  }
+
+  @Override
+  public Set<? extends Class<? extends Annotation>> annotations() {
+    return ImmutableSet.of(Multibindings.class);
+  }
+
+  @Override
+  public Set<Element> process(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    for (TypeElement element : typesIn(elementsByAnnotation.values())) {
+      multibindingsValidator.validate(element).printMessagesTo(messager);
+    }
+    return ImmutableSet.of();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java
new file mode 100644
index 000000000..d68e1dec3
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java
@@ -0,0 +1,165 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableListMultimap;
+import com.google.common.collect.ImmutableSet;
+import dagger.Module;
+import dagger.Multibindings;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import dagger.producers.ProducerModule;
+import java.util.Collection;
+import java.util.Map;
+import javax.inject.Provider;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+
+import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.auto.common.MoreTypes.asExecutable;
+import static dagger.internal.codegen.ErrorMessages.DUPLICATE_SIZE_LIMIT;
+import static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.METHOD_MUST_RETURN_MAP_OR_SET;
+import static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.MUST_BE_INTERFACE;
+import static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.MUST_BE_IN_MODULE;
+import static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.MUST_NOT_HAVE_TYPE_PARAMETERS;
+import static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.TOO_MANY_QUALIFIERS;
+import static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.tooManyMethodsForKey;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
+import static javax.lang.model.element.ElementKind.INTERFACE;
+
+/**
+ * A {@linkplain ValidationReport validator} for {@link Multibindings @Multibindings}-annotated
+ * types.
+ */
+final class MultibindingsValidator {
+  private final Elements elements;
+  private final Key.Factory keyFactory;
+  private final KeyFormatter keyFormatter;
+  private final MethodSignatureFormatter methodSignatureFormatter;
+  private final TypeElement objectElement;
+
+  MultibindingsValidator(
+      Elements elements,
+      Key.Factory keyFactory,
+      KeyFormatter keyFormatter,
+      MethodSignatureFormatter methodSignatureFormatter) {
+    this.elements = elements;
+    this.keyFactory = keyFactory;
+    this.keyFormatter = keyFormatter;
+    this.methodSignatureFormatter = methodSignatureFormatter;
+    this.objectElement = elements.getTypeElement(Object.class.getCanonicalName());
+  }
+
+  /**
+   * Returns a report containing validation errors for a
+   * {@link Multibindings @Multibindings}-annotated type.
+   */
+  public ValidationReport<TypeElement> validate(TypeElement multibindingsType) {
+    ValidationReport.Builder<TypeElement> validation = ValidationReport.about(multibindingsType);
+    if (!multibindingsType.getKind().equals(INTERFACE)) {
+      validation.addError(MUST_BE_INTERFACE, multibindingsType);
+    }
+    if (!multibindingsType.getTypeParameters().isEmpty()) {
+      validation.addError(MUST_NOT_HAVE_TYPE_PARAMETERS, multibindingsType);
+    }
+    Optional<BindingType> bindingType = bindingType(multibindingsType);
+    if (!bindingType.isPresent()) {
+      validation.addError(MUST_BE_IN_MODULE, multibindingsType);
+    }
+
+    ImmutableListMultimap.Builder<Key, ExecutableElement> methodsByKey =
+        ImmutableListMultimap.builder();
+    for (ExecutableElement method : getLocalAndInheritedMethods(multibindingsType, elements)) {
+      // Skip methods in Object.
+      if (method.getEnclosingElement().equals(objectElement)) {
+        continue;
+      }
+      if (!isPlainMap(method.getReturnType()) && !isPlainSet(method.getReturnType())) {
+        validation.addError(METHOD_MUST_RETURN_MAP_OR_SET, method);
+        continue;
+      }
+      ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(method);
+      if (qualifiers.size() > 1) {
+        for (AnnotationMirror qualifier : qualifiers) {
+          validation.addError(TOO_MANY_QUALIFIERS, method, qualifier);
+        }
+        continue;
+      }
+      if (bindingType.isPresent()) {
+        methodsByKey.put(
+            keyFactory.forMultibindingsMethod(
+                bindingType.get(), asExecutable(method.asType()), method),
+            method);
+      }
+    }
+    for (Map.Entry<Key, Collection<ExecutableElement>> entry :
+        methodsByKey.build().asMap().entrySet()) {
+      Collection<ExecutableElement> methods = entry.getValue();
+      if (methods.size() > 1) {
+        Key key = entry.getKey();
+        validation.addError(tooManyMultibindingsMethodsForKey(key, methods), multibindingsType);
+      }
+    }
+    return validation.build();
+  }
+
+  private String tooManyMultibindingsMethodsForKey(Key key, Collection<ExecutableElement> methods) {
+    StringBuilder builder = new StringBuilder(tooManyMethodsForKey(keyFormatter.format(key)));
+    builder.append(':');
+    methodSignatureFormatter.formatIndentedList(builder, methods, 1, DUPLICATE_SIZE_LIMIT);
+    return builder.toString();
+  }
+
+  private Optional<BindingType> bindingType(TypeElement multibindingsType) {
+    if (isAnnotationPresent(multibindingsType.getEnclosingElement(), Module.class)) {
+      return Optional.of(BindingType.PROVISION);
+    } else if (isAnnotationPresent(multibindingsType.getEnclosingElement(), ProducerModule.class)) {
+      return Optional.of(BindingType.PRODUCTION);
+    } else {
+      return Optional.<BindingType>absent();
+    }
+  }
+
+  private boolean isPlainMap(TypeMirror returnType) {
+    if (!MapType.isMap(returnType)) {
+      return false;
+    }
+    MapType mapType = MapType.from(returnType);
+    return !mapType.isRawType()
+        && MoreTypes.isType(mapType.valueType()) // No wildcards.
+        && !mapType.valuesAreTypeOf(Provider.class)
+        && !mapType.valuesAreTypeOf(Producer.class)
+        && !mapType.valuesAreTypeOf(Produced.class);
+  }
+
+  private boolean isPlainSet(TypeMirror returnType) {
+    if (!SetType.isSet(returnType)) {
+      return false;
+    }
+    SetType setType = SetType.from(returnType);
+    return !setType.isRawType()
+        && MoreTypes.isType(setType.elementType()) // No wildcards.
+        && !setType.elementsAreTypeOf(Provider.class)
+        && !setType.elementsAreTypeOf(Producer.class)
+        && !setType.elementsAreTypeOf(Produced.class);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
index 7b7b6eeaa..62b102245 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
@@ -18,6 +18,7 @@
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
@@ -27,9 +28,11 @@
 import dagger.internal.codegen.BindingType.HasBindingType;
 import dagger.internal.codegen.ContributionType.HasContributionType;
 import dagger.internal.codegen.Key.HasKey;
+import dagger.internal.codegen.SourceElement.HasSourceElement;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.collect.Iterables.concat;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.ContributionType.indexByContributionType;
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_CONTRIBUTION_TYPES_FORMAT;
@@ -74,6 +77,12 @@ public Key key() {
     return bindingKey().key();
   }
   
+  /**
+   * The multibinding declarations for {@link #bindingKey()}. If {@link #bindingKey()}'s kind is not
+   * {@link BindingKey.Kind#CONTRIBUTION}, this is empty.
+   */
+  abstract ImmutableSet<MultibindingDeclaration> multibindingDeclarations();
+  
   /**
    * All bindings for {@link #bindingKey()}, regardless of in which component they were resolved.
    */
@@ -90,6 +99,13 @@ public Key key() {
     }
   }
 
+  /**
+   * {@code true} if there are no {@link #bindings()} or {@link #multibindingDeclarations()}.
+   */
+  boolean isEmpty() {
+    return bindings().isEmpty() && multibindingDeclarations().isEmpty();
+  }
+
   /**
    * All bindings for {@link #bindingKey()} that were resolved in {@link #owningComponent()}.
    */
@@ -148,13 +164,15 @@ public Key key() {
   static ResolvedBindings forContributionBindings(
       BindingKey bindingKey,
       ComponentDescriptor owningComponent,
-      Multimap<ComponentDescriptor, ? extends ContributionBinding> contributionBindings) {
+      Multimap<ComponentDescriptor, ? extends ContributionBinding> contributionBindings,
+      Iterable<MultibindingDeclaration> multibindings) {
     checkArgument(bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION));
     return new AutoValue_ResolvedBindings(
         bindingKey,
         owningComponent,
         ImmutableSetMultimap.<ComponentDescriptor, ContributionBinding>copyOf(contributionBindings),
-        ImmutableMap.<ComponentDescriptor, MembersInjectionBinding>of());
+        ImmutableMap.<ComponentDescriptor, MembersInjectionBinding>of(),
+        ImmutableSet.copyOf(multibindings));
   }
 
   /**
@@ -169,7 +187,8 @@ static ResolvedBindings forContributionBindings(
         owningComponent,
         ImmutableSetMultimap.<ComponentDescriptor, ContributionBinding>builder()
             .putAll(owningComponent, ownedContributionBindings)
-            .build());
+            .build(),
+        ImmutableSet.<MultibindingDeclaration>of());
   }
 
   /**
@@ -184,7 +203,8 @@ static ResolvedBindings forMembersInjectionBinding(
         bindingKey,
         owningComponent,
         ImmutableSetMultimap.<ComponentDescriptor, ContributionBinding>of(),
-        ImmutableMap.of(owningComponent, ownedMembersInjectionBinding));
+        ImmutableMap.of(owningComponent, ownedMembersInjectionBinding),
+        ImmutableSet.<MultibindingDeclaration>of());
   }
 
   /**
@@ -195,7 +215,8 @@ static ResolvedBindings noBindings(BindingKey bindingKey, ComponentDescriptor ow
         bindingKey,
         owningComponent,
         ImmutableSetMultimap.<ComponentDescriptor, ContributionBinding>of(),
-        ImmutableMap.<ComponentDescriptor, MembersInjectionBinding>of());
+        ImmutableMap.<ComponentDescriptor, MembersInjectionBinding>of(),
+        ImmutableSet.<MultibindingDeclaration>of());
   }
 
   /**
@@ -204,14 +225,19 @@ static ResolvedBindings noBindings(BindingKey bindingKey, ComponentDescriptor ow
    */
   ResolvedBindings asInheritedIn(ComponentDescriptor owningComponent) {
     return new AutoValue_ResolvedBindings(
-        bindingKey(), owningComponent, allContributionBindings(), allMembersInjectionBindings());
+        bindingKey(),
+        owningComponent,
+        allContributionBindings(),
+        allMembersInjectionBindings(),
+        multibindingDeclarations());
   }
 
   /**
    * {@code true} if this is a multibindings contribution.
    */
   boolean isMultibindings() {
-    return !contributionBindings().isEmpty() && contributionType().isMultibinding();
+    return !(contributionBindings().isEmpty() && multibindingDeclarations().isEmpty())
+        && contributionType().isMultibinding();
   }
 
   /**
@@ -222,15 +248,17 @@ boolean isUniqueContribution() {
   }
 
   /**
-   * The binding type for all {@link #bindings()}.
+   * The binding type for all {@link #bindings()} and {@link #multibindingDeclarations()}.
    *
-   * @throws IllegalStateException if {@link #bindings()} is empty or the binding types conflict
+   * @throws IllegalStateException if {@link #isEmpty()} or the binding types conflict
    */
   @Override
   public BindingType bindingType() {
+    checkState(!isEmpty(), "empty bindings for %s", bindingKey());
     ImmutableSet<BindingType> bindingTypes =
-        FluentIterable.from(bindings()).transform(BindingType.BINDING_TYPE).toSet();
-    checkState(!bindingTypes.isEmpty(), "no bindings for %s", bindingKey());
+        FluentIterable.from(concat(bindings(), multibindingDeclarations()))
+            .transform(BindingType.BINDING_TYPE)
+            .toSet();
     checkState(bindingTypes.size() == 1, "conflicting binding types: %s", this);
     return getOnlyElement(bindingTypes);
   }
@@ -238,16 +266,36 @@ public BindingType bindingType() {
   /**
    * The contribution type for these bindings.
    *
-   * @throws IllegalStateException if the bindings are not all of one contribution type
+   * @throws IllegalStateException if {@link #isEmpty()} or the contribution types conflict
    */
   @Override
   public ContributionType contributionType() {
-    ImmutableSet<ContributionType> types = indexByContributionType(contributionBindings()).keySet();
-    checkState(!types.isEmpty(), "no bindings for %s", bindingKey());
+    ImmutableSet<ContributionType> types = contributionTypes();
+    checkState(!types.isEmpty(), "no bindings or declarations for %s", bindingKey());
     checkState(types.size() == 1, MULTIPLE_CONTRIBUTION_TYPES_FORMAT, types);
     return getOnlyElement(types);
   }
 
+  /**
+   * The contribution types represented by {@link #contributionBindings()} and
+   * {@link #multibindingDeclarations()}.
+   */
+  ImmutableSet<ContributionType> contributionTypes() {
+    return bindingsAndDeclarationsByContributionType().keySet();
+  }
+
+  /**
+   * The {@link #contributionBindings()} and {@link #multibindingDeclarations()}, indexed by
+   * {@link ContributionType}.
+   */
+  ImmutableListMultimap<ContributionType, HasSourceElement>
+      bindingsAndDeclarationsByContributionType() {
+    return new ImmutableListMultimap.Builder<ContributionType, HasSourceElement>()
+        .putAll(indexByContributionType(contributionBindings()))
+        .putAll(indexByContributionType(multibindingDeclarations()))
+        .build();
+  }
+
   /**
    * The name of the package in which these bindings must be managed, for
    * example if a binding references non-public types.
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index 036d20fce..bc00e1e6d 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -611,25 +611,106 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
         "}");
 
     String expectedSetError =
-        "java.util.Set<java.lang.String> has incompatible bindings:\n"
-            + "      Set bindings:\n"
+        "java.util.Set<java.lang.String> has incompatible bindings or declarations:\n"
+            + "      Set bindings and declarations:\n"
             + "          @Provides(type=SET) String test.Outer.TestModule1.stringSetElement()\n"
-            + "      Unique bindings:\n"
+            + "      Unique bindings and declarations:\n"
             + "          @Provides Set<String> test.Outer.TestModule2.stringSet()";
 
     String expectedMapError =
-        "java.util.Map<java.lang.String,java.lang.String> has incompatible bindings:\n"
-            + "      Map bindings:\n"
+        "java.util.Map<java.lang.String,java.lang.String> has incompatible bindings "
+            + "or declarations:\n"
+            + "      Map bindings and declarations:\n"
             + "          @Provides(type=MAP) @test.Outer.StringKey(\"foo\") String"
             + " test.Outer.TestModule1.stringMapEntry()\n"
-            + "      Unique bindings:\n"
+            + "      Unique bindings and declarations:\n"
             + "          @Provides Map<String,String> test.Outer.TestModule2.stringMap()";
 
-    assertAbout(javaSource()).that(component)
+    assertAbout(javaSource())
+        .that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedSetError)
+        .in(component)
+        .onLine(43)
+        .and()
+        .withErrorContaining(expectedMapError)
+        .in(component)
+        .onLine(44);
+  }
+
+  @Test
+  public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Multibindings;",
+            "import dagger.Provides;",
+            "import java.util.HashMap;",
+            "import java.util.HashSet;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "",
+            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+            "import static dagger.Provides.Type.MAP;",
+            "import static dagger.Provides.Type.SET;",
+            "",
+            "final class Outer {",
+            "  @Module",
+            "  static class TestModule1 {",
+            "    @Multibindings",
+            "    interface Empties {",
+            "      Map<String, String> stringMap();",
+            "      Set<String> stringSet();",
+            "    }",
+            "  }",
+            "",
+            "  @Module",
+            "  static class TestModule2 {",
+            "    @Provides Set<String> stringSet() { return new HashSet<String>(); }",
+            "",
+            "    @Provides Map<String, String> stringMap() {",
+            "      return new HashMap<String, String>();",
+            "    }",
+            "  }",
+            "",
+            "  @Component(modules = { TestModule1.class, TestModule2.class })",
+            "  interface TestComponent {",
+            "    Set<String> getStringSet();",
+            "    Map<String, String> getStringMap();",
+            "  }",
+            "}");
+
+    String expectedSetError =
+        "java.util.Set<java.lang.String> has incompatible bindings or declarations:\n"
+            + "      Set bindings and declarations:\n"
+            + "          Set<String> test.Outer.TestModule1.Empties.stringSet()\n"
+            + "      Unique bindings and declarations:\n"
+            + "          @Provides Set<String> test.Outer.TestModule2.stringSet()";
+
+    String expectedMapError =
+        "java.util.Map<java.lang.String,java.lang.String> has incompatible bindings "
+            + "or declarations:\n"
+            + "      Map bindings and declarations:\n"
+            + "          Map<String,String> test.Outer.TestModule1.Empties.stringMap()\n"
+            + "      Unique bindings and declarations:\n"
+            + "          @Provides Map<String,String> test.Outer.TestModule2.stringMap()";
+
+    assertAbout(javaSource())
+        .that(component)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(expectedSetError).in(component).onLine(43)
-        .and().withErrorContaining(expectedMapError).in(component).onLine(44);
+        .withErrorContaining(expectedSetError)
+        .in(component)
+        .onLine(37)
+        .and()
+        .withErrorContaining(expectedMapError)
+        .in(component)
+        .onLine(38);
   }
 
   @Test public void duplicateBindings_TruncateAfterLimit() {
diff --git a/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java b/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java
new file mode 100644
index 000000000..9ec7469a5
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java
@@ -0,0 +1,394 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static java.util.Arrays.asList;
+
+@RunWith(JUnit4.class)
+public class MultibindingsValidatorTest {
+
+  private static final JavaFileObject SOME_QUALIFIER =
+      JavaFileObjects.forSourceLines(
+          "test.SomeQualifier",
+          "package test;",
+          "",
+          "import javax.inject.Qualifier;",
+          "",
+          "@Qualifier",
+          "@interface SomeQualifier {}");
+
+  private static final JavaFileObject OTHER_QUALIFIER =
+      JavaFileObjects.forSourceLines(
+          "test.OtherQualifier",
+          "package test;",
+          "",
+          "import javax.inject.Qualifier;",
+          "",
+          "@Qualifier",
+          "@interface OtherQualifier {}");
+
+  @Test
+  public void abstractClass() {
+    JavaFileObject testModule =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Multibindings;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "class TestModule {",
+            "  @Multibindings",
+            "  static abstract class Empties {",
+            "    abstract Set<Object> emptySet();",
+            "    @SomeQualifier abstract Set<Object> emptyQualifiedSet();",
+            "    abstract Map<String, Object> emptyMap();",
+            "    @SomeQualifier abstract Map<String, Object> emptyQualifiedMap();",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(asList(testModule, SOME_QUALIFIER))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("@Multibindings can be applied only to interfaces")
+        .in(testModule)
+        .onLine(11);
+  }
+
+  @Test
+  public void concreteClass() {
+    JavaFileObject testModule =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Multibindings;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "class TestModule {",
+            "  @Multibindings",
+            "  static class Empties {",
+            "    Set<Object> emptySet() { return null; }",
+            "    @SomeQualifier Set<Object> emptyQualifiedSet() { return null; }",
+            "    Map<String, Object> emptyMap() { return null; }",
+            "    @SomeQualifier Map<String, Object> emptyQualifiedMap() { return null; }",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(asList(testModule, SOME_QUALIFIER))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("@Multibindings can be applied only to interfaces")
+        .in(testModule)
+        .onLine(11);
+  }
+
+  @Test
+  public void interfaceHasTypeParameters() {
+    JavaFileObject testModule =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Multibindings;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "class TestModule {",
+            "  @Multibindings",
+            "  interface Empties<T> {",
+            "    Set<T> emptySet();",
+            "    @SomeQualifier Set<T> emptyQualifiedSet();",
+            "    Map<String, T> emptyMap();",
+            "    @SomeQualifier Map<String, T> emptyQualifiedMap();",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(asList(testModule, SOME_QUALIFIER))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("@Multibindings types must not have type parameters")
+        .in(testModule)
+        .onLine(11);
+  }
+
+  @Test
+  public void topLevel() {
+    JavaFileObject testInterface =
+        JavaFileObjects.forSourceLines(
+            "test.TestInterface",
+            "package test;",
+            "",
+            "import dagger.Multibindings;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "",
+            "@Multibindings",
+            "interface Empties {",
+            "  Set<Object> emptySet();",
+            "  @SomeQualifier Set<Object> emptyQualifiedSet();",
+            "  Map<String, Object> emptyMap();",
+            "  @SomeQualifier Map<String, Object> emptyQualifiedMap();",
+            "}");
+    assertAbout(javaSources())
+        .that(asList(testInterface, SOME_QUALIFIER))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "@Multibindings types must be nested within a @Module or @ProducerModule")
+        .in(testInterface)
+        .onLine(8);
+  }
+
+  @Test
+  public void notWithinModule() {
+    JavaFileObject testModule =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Multibindings;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "",
+            "class TestModule {",
+            "  @Multibindings",
+            "  interface Empties {",
+            "    Set<Object> emptySet();",
+            "    @SomeQualifier Set<Object> emptyQualifiedSet();",
+            "    Map<String, Object> emptyMap();",
+            "    @SomeQualifier Map<String, Object> emptyQualifiedMap();",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(asList(testModule, SOME_QUALIFIER))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "@Multibindings types must be nested within a @Module or @ProducerModule")
+        .in(testModule)
+        .onLine(9);
+  }
+
+  @Test
+  public void badMethods() {
+    JavaFileObject testModule =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Multibindings;",
+            "import dagger.producers.Produced;",
+            "import dagger.producers.Producer;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "import javax.inject.Provider;",
+            "",
+            "@Module",
+            "class TestModule {",
+            "  @Multibindings",
+            "  interface Empties {",
+            "    void voidMethod();",
+            "    int primitive();",
+            "    Map rawMap();",
+            "    Map<?, ?> wildcardMap();",
+            "    Map<String, Provider<Object>> providerMap();",
+            "    Map<String, Producer<Object>> producerMap();",
+            "    Map<String, Produced<Object>> producedMap();",
+            "    Set rawSet();",
+            "    Set<?> wildcardSet();",
+            "    Set<Provider<Object>> providerSet();",
+            "    Set<Producer<Object>> producerSet();",
+            "    Set<Produced<Object>> producedSet();",
+            "    @SomeQualifier @OtherQualifier Set<Object> tooManyQualifiersSet();",
+            "    @SomeQualifier @OtherQualifier Map<String, Object> tooManyQualifiersMap();",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(asList(testModule, SOME_QUALIFIER, OTHER_QUALIFIER))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
+        .in(testModule)
+        .onLine(15)
+        .and()
+        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
+        .in(testModule)
+        .onLine(16)
+        .and()
+        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
+        .in(testModule)
+        .onLine(17)
+        .and()
+        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
+        .in(testModule)
+        .onLine(18)
+        .and()
+        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
+        .in(testModule)
+        .onLine(19)
+        .and()
+        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
+        .in(testModule)
+        .onLine(20)
+        .and()
+        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
+        .in(testModule)
+        .onLine(21)
+        .and()
+        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
+        .in(testModule)
+        .onLine(22)
+        .and()
+        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
+        .in(testModule)
+        .onLine(23)
+        .and()
+        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
+        .in(testModule)
+        .onLine(24)
+        .and()
+        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
+        .in(testModule)
+        .onLine(25)
+        .and()
+        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
+        .in(testModule)
+        .onLine(26)
+        .and()
+        .withErrorContaining(
+            "Cannot use more than one @Qualifier on a method in an @Multibindings type")
+        .in(testModule)
+        .onLine(27)
+        .and()
+        .withErrorContaining(
+            "Cannot use more than one @Qualifier on a method in an @Multibindings type")
+        .in(testModule)
+        .onLine(28);
+  }
+
+  @Test
+  public void badMethodsOnSupertype() {
+    JavaFileObject testModule =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Multibindings;",
+            "import dagger.producers.Produced;",
+            "import dagger.producers.Producer;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "import javax.inject.Provider;",
+            "",
+            "@Module",
+            "class TestModule {",
+            "  interface BaseEmpties {",
+            "    void voidMethod();",
+            "  }",
+            "",
+            "  @Multibindings",
+            "  interface Empties extends BaseEmpties {}",
+            "}");
+    assertAbout(javaSources())
+        .that(asList(testModule, SOME_QUALIFIER, OTHER_QUALIFIER))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "[test.TestModule.BaseEmpties.voidMethod()] "
+                + "@Multibindings methods must return Map<K, V> or Set<T>")
+        .in(testModule)
+        .onLine(18);
+  }
+
+  @Test
+  public void duplicateKeys() {
+    JavaFileObject testModule =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Multibindings;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "class TestModule {",
+            "  @Multibindings",
+            "  interface EmptySets {",
+            "    Set<Object> emptySet();",
+            "    Set<Object> emptySet2();",
+            "  }",
+            "",
+            "  @Multibindings",
+            "  interface EmptyQualifiedSets {",
+            "    @SomeQualifier Set<Object> emptyQualifiedSet();",
+            "    @SomeQualifier Set<Object> emptyQualifiedSet2();",
+            "  }",
+            "",
+            "  @Multibindings",
+            "  interface EmptyMaps {",
+            "    Map<String, Object> emptyMap();",
+            "    Map<String, Object> emptyMap2();",
+            "  }",
+            "",
+            "  @Multibindings",
+            "  interface EmptyQualifiedMaps {",
+            "    @SomeQualifier Map<String, Object> emptyQualifiedMap();",
+            "    @SomeQualifier Map<String, Object> emptyQualifiedMap2();",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(asList(testModule, SOME_QUALIFIER))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("Too many @Multibindings methods for Set<Object>:")
+        .in(testModule)
+        .onLine(11)
+        .and()
+        .withErrorContaining("Too many @Multibindings methods for @test.SomeQualifier Set<Object>:")
+        .in(testModule)
+        .onLine(17)
+        .and()
+        .withErrorContaining("Too many @Multibindings methods for Map<String,Provider<Object>>:")
+        .in(testModule)
+        .onLine(23)
+        .and()
+        .withErrorContaining(
+            "Too many @Multibindings methods for @test.SomeQualifier Map<String,Provider<Object>>:")
+        .in(testModule)
+        .onLine(29);
+  }
+}
diff --git a/core/src/main/java/dagger/Multibindings.java b/core/src/main/java/dagger/Multibindings.java
new file mode 100644
index 000000000..d02d4177b
--- /dev/null
+++ b/core/src/main/java/dagger/Multibindings.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger;
+
+import dagger.internal.Beta;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.TYPE;
+
+@Documented
+@Target(TYPE)
+@Beta
+public @interface Multibindings {}
diff --git a/core/src/main/java/dagger/internal/MapProviderFactory.java b/core/src/main/java/dagger/internal/MapProviderFactory.java
index 00c0fd33a..b5c96e702 100644
--- a/core/src/main/java/dagger/internal/MapProviderFactory.java
+++ b/core/src/main/java/dagger/internal/MapProviderFactory.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal;
 
+import java.util.Collections;
 import java.util.LinkedHashMap;
 import java.util.Map;
 import javax.inject.Provider;
@@ -31,6 +32,9 @@
  *
  */
 public final class MapProviderFactory<K, V> implements Factory<Map<K, Provider<V>>> {
+  private static final MapProviderFactory<Object, Object> EMPTY =
+      new MapProviderFactory<Object, Object>(Collections.<Object, Provider<Object>>emptyMap());
+
   private final Map<K, Provider<V>> contributingMap;
 
   /**
@@ -40,7 +44,15 @@
     return new Builder<K, V>(size);
   }
 
-  private MapProviderFactory(LinkedHashMap<K, Provider<V>> contributingMap) {
+  /**
+   * Returns a factory of an empty map.
+   */
+  @SuppressWarnings("unchecked") // safe contravariant cast
+  public static <K, V> MapProviderFactory<K, V> empty() {
+    return (MapProviderFactory<K, V>) EMPTY;
+  }
+
+  private MapProviderFactory(Map<K, Provider<V>> contributingMap) {
     this.contributingMap = unmodifiableMap(contributingMap);
   }
 
