diff --git a/java/dagger/internal/codegen/ComponentDescriptor.java b/java/dagger/internal/codegen/ComponentDescriptor.java
index c25c44da5..de979dfd8 100644
--- a/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -32,6 +32,8 @@
 import com.google.common.collect.ImmutableBiMap;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import com.google.errorprone.annotations.CheckReturnValue;
 import dagger.Component;
 import dagger.Module;
 import dagger.Subcomponent;
@@ -287,43 +289,20 @@ public int hashCode() {
   @Override
   public abstract boolean equals(Object obj);
 
-  /** A function that returns all {@link #scopes()} of its input. */
+  /** A component method. */
   @AutoValue
   abstract static class ComponentMethodDescriptor {
-    abstract ComponentMethodKind kind();
-    abstract Optional<DependencyRequest> dependencyRequest();
+    /** The method itself. Note that this may be declared on a supertype of the component. */
     abstract ExecutableElement methodElement();
 
-    static ComponentMethodDescriptor create(
-        ComponentMethodKind kind,
-        Optional<DependencyRequest> dependencyRequest,
-        ExecutableElement methodElement) {
-      return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
-          kind, dependencyRequest, methodElement);
-    }
-
-    static ComponentMethodDescriptor forProvision(
-        ExecutableElement methodElement, DependencyRequest dependencyRequest) {
-      return create(ComponentMethodKind.PROVISION, Optional.of(dependencyRequest), methodElement);
-    }
-
-    static ComponentMethodDescriptor forMembersInjection(
-        ExecutableElement methodElement, DependencyRequest dependencyRequest) {
-      return create(
-          ComponentMethodKind.MEMBERS_INJECTION, Optional.of(dependencyRequest), methodElement);
-    }
-
-    static ComponentMethodDescriptor forSubcomponent(
-        ComponentMethodKind kind, ExecutableElement methodElement) {
-      return create(kind, Optional.empty(), methodElement);
-    }
+    /**
+     * The dependency request for production, provision, and subcomponent creator methods. Absent
+     * for subcomponent factory methods.
+     */
+    abstract Optional<DependencyRequest> dependencyRequest();
 
-    static ComponentMethodDescriptor forSubcomponentCreator(
-        ComponentMethodKind kind,
-        DependencyRequest dependencyRequestForBuilder,
-        ExecutableElement methodElement) {
-      return create(kind, Optional.of(dependencyRequestForBuilder), methodElement);
-    }
+    /** The subcomponent for subcomponent factory methods and subcomponent creator methods. */
+    abstract Optional<ComponentDescriptor> subcomponent();
 
     /**
      * Returns the return type of {@link #methodElement()} as resolved in the {@link
@@ -340,32 +319,29 @@ TypeMirror resolvedReturnType(DaggerTypes types) {
       return BindingRequest.bindingRequest(dependencyRequest().get())
           .requestedType(dependencyRequest().get().key().type(), types);
     }
-  }
 
-  enum ComponentMethodKind {
-    PROVISION,
-    PRODUCTION,
-    MEMBERS_INJECTION,
-    SUBCOMPONENT,
-    SUBCOMPONENT_CREATOR,
-    PRODUCTION_SUBCOMPONENT,
-    PRODUCTION_SUBCOMPONENT_CREATOR;
+    /** A {@link ComponentMethodDescriptor}builder for a method. */
+    static Builder builder(ExecutableElement method) {
+      return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor.Builder()
+          .methodElement(method);
+    }
 
-    /**
-     * Returns the component kind associated with this component method, if it exists. Otherwise,
-     * throws.
-     */
-    ComponentKind componentKind() {
-      switch (this) {
-        case SUBCOMPONENT:
-        case SUBCOMPONENT_CREATOR:
-          return ComponentKind.SUBCOMPONENT;
-        case PRODUCTION_SUBCOMPONENT:
-        case PRODUCTION_SUBCOMPONENT_CREATOR:
-          return ComponentKind.PRODUCTION_SUBCOMPONENT;
-        default:
-          throw new IllegalStateException("no component associated with method " + this);
-      }
+    /** A builder of {@link ComponentMethodDescriptor}s. */
+    @AutoValue.Builder
+    @CanIgnoreReturnValue
+    interface Builder {
+      /** @see ComponentMethodDescriptor#methodElement() */
+      Builder methodElement(ExecutableElement methodElement);
+
+      /** @see ComponentMethodDescriptor#dependencyRequest() */
+      Builder dependencyRequest(DependencyRequest dependencyRequest);
+
+      /** @see ComponentMethodDescriptor#subcomponent() */
+      Builder subcomponent(ComponentDescriptor subcomponent);
+
+      /** Builds the descriptor. */
+      @CheckReturnValue
+      ComponentMethodDescriptor build();
     }
   }
 
diff --git a/java/dagger/internal/codegen/ComponentDescriptorFactory.java b/java/dagger/internal/codegen/ComponentDescriptorFactory.java
index 431d7848f..e120ade8e 100644
--- a/java/dagger/internal/codegen/ComponentDescriptorFactory.java
+++ b/java/dagger/internal/codegen/ComponentDescriptorFactory.java
@@ -16,8 +16,9 @@
 
 package dagger.internal.codegen;
 
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.auto.common.MoreTypes.isTypeOf;
+import static com.google.auto.common.MoreElements.asType;
+import static com.google.auto.common.MoreTypes.asTypeElement;
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.ComponentAnnotation.subcomponentAnnotation;
 import static dagger.internal.codegen.ComponentCreatorAnnotation.creatorAnnotationsFor;
@@ -32,23 +33,15 @@
 import static javax.lang.model.type.TypeKind.VOID;
 import static javax.lang.model.util.ElementFilter.methodsIn;
 
-import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableBiMap;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
-import dagger.Lazy;
-import dagger.Subcomponent;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
-import dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind;
-import dagger.model.DependencyRequest;
 import dagger.model.Scope;
-import java.util.List;
 import java.util.Optional;
 import java.util.function.Function;
 import javax.inject.Inject;
-import javax.inject.Provider;
-import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
@@ -163,31 +156,21 @@ private ComponentDescriptor create(
       ImmutableSet<ExecutableElement> unimplementedMethods =
           elements.getUnimplementedMethods(typeElement);
       for (ExecutableElement componentMethod : unimplementedMethods) {
-        ExecutableType resolvedMethod =
-            MoreTypes.asExecutable(types.asMemberOf(declaredComponentType, componentMethod));
         ComponentMethodDescriptor componentMethodDescriptor =
             getDescriptorForComponentMethod(typeElement, componentAnnotation, componentMethod);
         componentMethodsBuilder.add(componentMethodDescriptor);
-        switch (componentMethodDescriptor.kind()) {
-          case SUBCOMPONENT:
-          case PRODUCTION_SUBCOMPONENT:
-            subcomponentsByFactoryMethod.put(
-                componentMethodDescriptor,
-                subcomponentDescriptor(MoreTypes.asTypeElement(resolvedMethod.getReturnType())));
-            break;
-
-          case SUBCOMPONENT_CREATOR:
-          case PRODUCTION_SUBCOMPONENT_CREATOR:
-            subcomponentsByBuilderMethod.put(
-                componentMethodDescriptor,
-                subcomponentDescriptor(
-                    MoreElements.asType(
-                        MoreTypes.asElement(resolvedMethod.getReturnType())
-                            .getEnclosingElement())));
-            break;
-
-          default: // nothing special to do for other methods.
-        }
+        componentMethodDescriptor
+            .subcomponent()
+            .ifPresent(
+                subcomponent -> {
+                  // If the dependency request is present, that means the method returns the
+                  // subcomponent factory.
+                  if (componentMethodDescriptor.dependencyRequest().isPresent()) {
+                    subcomponentsByBuilderMethod.put(componentMethodDescriptor, subcomponent);
+                  } else {
+                    subcomponentsByFactoryMethod.put(componentMethodDescriptor, subcomponent);
+                  }
+                });
       }
     }
 
@@ -228,63 +211,57 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(
       TypeElement componentElement,
       ComponentAnnotation componentAnnotation,
       ExecutableElement componentMethod) {
+    ComponentMethodDescriptor.Builder descriptor =
+        ComponentMethodDescriptor.builder(componentMethod);
+
     ExecutableType resolvedComponentMethod =
         MoreTypes.asExecutable(
             types.asMemberOf(MoreTypes.asDeclared(componentElement.asType()), componentMethod));
     TypeMirror returnType = resolvedComponentMethod.getReturnType();
-    if (returnType.getKind().equals(DECLARED)) {
-      if (isTypeOf(Provider.class, returnType) || isTypeOf(Lazy.class, returnType)) {
-        return ComponentMethodDescriptor.forProvision(
-            componentMethod,
-            dependencyRequestFactory.forComponentProvisionMethod(
-                componentMethod, resolvedComponentMethod));
-      } else if (!getQualifier(componentMethod).isPresent()) {
-        Element returnTypeElement = MoreTypes.asElement(returnType);
-        Optional<ComponentAnnotation> subcomponentAnnotation =
-            subcomponentAnnotation(MoreElements.asType(returnTypeElement));
-        if (subcomponentAnnotation.isPresent()) {
-          return ComponentMethodDescriptor.forSubcomponent(
-              subcomponentAnnotation.get().isProduction()
-                  // TODO(dpb): Do we really need all these enums?
-                  ? ComponentMethodKind.PRODUCTION_SUBCOMPONENT
-                  : ComponentMethodKind.SUBCOMPONENT,
-              componentMethod);
-        } else if (isSubcomponentCreator(returnTypeElement)) {
-          DependencyRequest dependencyRequest =
-              dependencyRequestFactory.forComponentProvisionMethod(
-                  componentMethod, resolvedComponentMethod);
-          return ComponentMethodDescriptor.forSubcomponentCreator(
-              isAnnotationPresent(returnTypeElement, Subcomponent.Builder.class)
-                  ? ComponentMethodKind.SUBCOMPONENT_CREATOR
-                  : ComponentMethodKind.PRODUCTION_SUBCOMPONENT_CREATOR,
-              dependencyRequest,
-              componentMethod);
-        }
+    if (returnType.getKind().equals(DECLARED) && !getQualifier(componentMethod).isPresent()) {
+      TypeElement returnTypeElement = asTypeElement(returnType);
+      if (subcomponentAnnotation(returnTypeElement).isPresent()) {
+        // It's a subcomponent factory method. There is no dependency request, and there could be
+        // any number of parameters. Just return the descriptor.
+        return descriptor.subcomponent(subcomponentDescriptor(returnTypeElement)).build();
+      }
+      if (isSubcomponentCreator(returnTypeElement)) {
+        descriptor.subcomponent(
+            subcomponentDescriptor(asType(returnTypeElement.getEnclosingElement())));
       }
     }
 
-    // a typical provision method
-    if (componentMethod.getParameters().isEmpty()
-        && !componentMethod.getReturnType().getKind().equals(VOID)) {
-      return ComponentMethodDescriptor.forProvision(
-          componentMethod,
-          componentAnnotation.isProduction()
-              ? dependencyRequestFactory.forComponentProductionMethod(
-                  componentMethod, resolvedComponentMethod)
-              : dependencyRequestFactory.forComponentProvisionMethod(
-                  componentMethod, resolvedComponentMethod));
-    }
+    switch (componentMethod.getParameters().size()) {
+      case 0:
+        checkArgument(
+            !returnType.getKind().equals(VOID),
+            "component method cannot be void: %s",
+            componentMethod);
+        descriptor.dependencyRequest(
+            componentAnnotation.isProduction()
+                ? dependencyRequestFactory.forComponentProductionMethod(
+                    componentMethod, resolvedComponentMethod)
+                : dependencyRequestFactory.forComponentProvisionMethod(
+                    componentMethod, resolvedComponentMethod));
+        break;
+
+      case 1:
+        checkArgument(
+            returnType.getKind().equals(VOID)
+                || MoreTypes.equivalence()
+                    .equivalent(returnType, resolvedComponentMethod.getParameterTypes().get(0)),
+            "members injection method must return void or parameter type: %s",
+            componentMethod);
+        descriptor.dependencyRequest(
+            dependencyRequestFactory.forComponentMembersInjectionMethod(
+                componentMethod, resolvedComponentMethod));
+        break;
 
-    List<? extends TypeMirror> parameterTypes = resolvedComponentMethod.getParameterTypes();
-    if (parameterTypes.size() == 1
-        && (returnType.getKind().equals(VOID)
-            || MoreTypes.equivalence().equivalent(returnType, parameterTypes.get(0)))) {
-      return ComponentMethodDescriptor.forMembersInjection(
-          componentMethod,
-          dependencyRequestFactory.forComponentMembersInjectionMethod(
-              componentMethod, resolvedComponentMethod));
+      default:
+        throw new IllegalArgumentException(
+            "component method has too many parameters: " + componentMethod);
     }
 
-    throw new IllegalArgumentException("not a valid component method: " + componentMethod);
+    return descriptor.build();
   }
 }
diff --git a/java/dagger/internal/codegen/ResolvedBindings.java b/java/dagger/internal/codegen/ResolvedBindings.java
index d9d11a296..814995a42 100644
--- a/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/java/dagger/internal/codegen/ResolvedBindings.java
@@ -41,9 +41,8 @@
  *
  * <p>Separate {@link ResolvedBindings} instances should be used if a {@link
  * MembersInjectionBinding} and a {@link ProvisionBinding} for the same key exist in the same
- * component. (this will only happen if a type has an {@code @Inject} constructor and members, the
- * component has a {@link ComponentDescriptor.ComponentMethodKind#MEMBERS_INJECTION members
- * injection method}, and the type is also requested normally.
+ * component. (This will only happen if a type has an {@code @Inject} constructor and members, the
+ * component has a members injection method, and the type is also requested normally.)
  */
 @AutoValue
 abstract class ResolvedBindings implements HasContributionType {
