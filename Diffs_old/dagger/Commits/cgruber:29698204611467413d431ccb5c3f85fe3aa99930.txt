diff --git a/compiler/src/main/java/dagger/internal/codegen/Binding.java b/compiler/src/main/java/dagger/internal/codegen/Binding.java
index 89dbc6bac..7d34dc270 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Binding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Binding.java
@@ -16,7 +16,7 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.MoreElements;
-import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
@@ -52,14 +52,15 @@ public TypeElement visitType(TypeElement e, Void p) {
     }, null);
   }
 
-  /** The list of {@link DependencyRequest dependencies} required to satisfy this binding. */
-  abstract ImmutableList<DependencyRequest> dependencies();
+  /** The set of {@link DependencyRequest dependencies} required to satisfy this binding. */
+  abstract ImmutableSet<DependencyRequest> dependencies();
 
   /** Returns the {@link #dependencies()} indexed by {@link Key}. */
-  ImmutableSetMultimap<Key, DependencyRequest> dependenciesByKey() {
-    ImmutableSetMultimap.Builder<Key, DependencyRequest> builder = ImmutableSetMultimap.builder();
+  ImmutableSetMultimap<FrameworkKey, DependencyRequest> dependenciesByKey() {
+    ImmutableSetMultimap.Builder<FrameworkKey, DependencyRequest> builder =
+        ImmutableSetMultimap.builder();
     for (DependencyRequest dependency : dependencies()) {
-      builder.put(dependency.key(), dependency);
+      builder.put(FrameworkKey.forDependencyRequest(dependency), dependency);
     }
     return builder.build();
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 5c0423716..6536e0d71 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -21,8 +21,8 @@
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
-import com.google.common.collect.LinkedHashMultimap;
-import com.google.common.collect.Maps;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.MultimapBuilder;
 import com.google.common.collect.Queues;
 import com.google.common.collect.SetMultimap;
 import com.google.common.collect.Sets;
@@ -33,7 +33,6 @@
 import java.util.Deque;
 import java.util.LinkedHashSet;
 import java.util.List;
-import java.util.Map;
 import java.util.Queue;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
@@ -45,7 +44,6 @@
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static dagger.internal.codegen.DependencyRequest.Kind.MEMBERS_INJECTOR;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.type.TypeKind.VOID;
 
@@ -216,66 +214,99 @@ ComponentDescriptor create(TypeElement componentDefinitionType) {
         }
       }
 
-      SetMultimap<Key, ProvisionBinding> resolvedProvisionBindings = LinkedHashMultimap.create();
-      Map<Key, MembersInjectionBinding> resolvedMembersInjectionBindings = Maps.newLinkedHashMap();
-      // TODO(gak): we're really going to need to test this ordering
-      ImmutableSet.Builder<FrameworkKey> resolutionOrder = ImmutableSet.builder();
+      ImmutableSetMultimap.Builder<Key, ProvisionBinding> resolvedProvisionBindings =
+          ImmutableSetMultimap.builder();
+      ImmutableMap.Builder<Key, MembersInjectionBinding> resolvedMembersInjectionBindings =
+          ImmutableMap.builder();
+      SetMultimap<FrameworkKey, Binding> resolvedBindings =
+          MultimapBuilder.linkedHashKeys().linkedHashSetValues().build();
 
-      for (DependencyRequest requestToResolve = requestsToResolve.pollLast();
-          requestToResolve != null;
-          requestToResolve = requestsToResolve.pollLast()) {
-        Key key = requestToResolve.key();
-        if (requestToResolve.kind().equals(MEMBERS_INJECTOR)) {
-          if (!resolvedMembersInjectionBindings.containsKey(key)) {
-            Optional<MembersInjectionBinding> binding =
-                injectBindingRegistry.getMembersInjectionBindingForKey(key);
-            if (binding.isPresent()) {
-              requestsToResolve.addAll(binding.get().dependencySet());
-              resolvedMembersInjectionBindings.put(key, binding.get());
+      ImmutableList<DependencyRequest> interfaceRequests = interfaceRequestsBuilder.build();
+
+      for (DependencyRequest interfaceRequest : interfaceRequests) {
+        resolveRequest(interfaceRequest, explicitBindings, resolvedBindings,
+            resolvedProvisionBindings, resolvedMembersInjectionBindings);
+      }
+
+      return new AutoValue_ComponentDescriptor(
+          componentDefinitionType,
+          componentDependencyTypes,
+          interfaceRequests,
+          moduleTypes,
+          resolvedProvisionBindings.build(),
+          resolvedMembersInjectionBindings.build(),
+          ImmutableList.copyOf(resolvedBindings.keySet()));
+    }
+
+    private void resolveRequest(DependencyRequest request,
+        ImmutableSetMultimap<Key, ProvisionBinding> explicitBindings,
+        SetMultimap<FrameworkKey, Binding> resolvedBindings,
+        ImmutableSetMultimap.Builder<Key, ProvisionBinding> resolvedProvisionsBindingBuilder,
+        ImmutableMap.Builder<Key, MembersInjectionBinding> resolvedMembersIjectionBindingsBuilder) {
+      FrameworkKey frameworkKey = FrameworkKey.forDependencyRequest(request);
+      Key requestKey = request.key();
+      if (resolvedBindings.containsKey(frameworkKey)) {
+        return;
+      }
+      switch (request.kind()) {
+        case INSTANCE:
+        case LAZY:
+        case PROVIDER:
+          // First, check for explicit keys (those from modules and components)
+          ImmutableSet<ProvisionBinding> explicitBindingsForKey =
+              explicitBindings.get(requestKey);
+          if (explicitBindingsForKey.isEmpty()) {
+            // no explicit binding, look it up
+            Optional<ProvisionBinding> provisionBinding =
+                injectBindingRegistry.getProvisionBindingForKey(requestKey);
+            if (provisionBinding.isPresent()) {
+              // found a binding, resolve its deps and then mark it resolved
+              for (DependencyRequest dependency : Iterables.concat(
+                  provisionBinding.get().dependencies(),
+                  provisionBinding.get().memberInjectionRequest().asSet())) {
+                resolveRequest(dependency, explicitBindings, resolvedBindings,
+                    resolvedProvisionsBindingBuilder, resolvedMembersIjectionBindingsBuilder);
+              }
+              resolvedBindings.put(frameworkKey, provisionBinding.get());
+              resolvedProvisionsBindingBuilder.put(requestKey, provisionBinding.get());
             } else {
-              // check and generate.
+              throw new UnsupportedOperationException(
+                  "@Injected classes that weren't run with the compoenent processor are "
+                      + "(briefly) unsupported: " + requestKey);
+
             }
-          }
-        } else { // all other requests are provision requests
-          if (!resolvedProvisionBindings.containsKey(key)) {
-            ImmutableSet<ProvisionBinding> explicitBindingsForKey = explicitBindings.get(key);
-            if (explicitBindingsForKey.isEmpty()) {
-              Optional<ProvisionBinding> injectBinding =
-                  injectBindingRegistry.getProvisionBindingForKey(key);
-              if (injectBinding.isPresent()) {
-                requestsToResolve.addAll(injectBinding.get().dependencies());
-                resolvedProvisionBindings.put(key, injectBinding.get());
-                if (injectBinding.get().requiresMemberInjection()) {
-                  DependencyRequest forMembersInjectedType =
-                      dependencyRequestFactory.forMembersInjectedType(
-                          injectBinding.get().providedKey().type());
-                  requestsToResolve.add(forMembersInjectedType);
-                }
-              } else {
-                // TODO(gak): support this
-                throw new UnsupportedOperationException(
-                    "@Injected classes that weren't run with the compoenent processor are "
-                        + "(briefly) unsupported: " + key);
+          } else {
+            // we found explicit bindings. resolve the deps and them mark them resolved
+            for (ProvisionBinding explicitBinding : explicitBindingsForKey) {
+              for (DependencyRequest dependency : explicitBinding.dependencies()) {
+                resolveRequest(dependency, explicitBindings, resolvedBindings,
+                    resolvedProvisionsBindingBuilder, resolvedMembersIjectionBindingsBuilder);
               }
-            } else {
-              resolvedProvisionBindings.putAll(key, explicitBindingsForKey);
             }
-            for (ProvisionBinding binding : explicitBindingsForKey) {
-              requestsToResolve.addAll(binding.dependencies());
+            resolvedBindings.putAll(frameworkKey, explicitBindingsForKey);
+            resolvedProvisionsBindingBuilder.putAll(requestKey, explicitBindingsForKey);
+          }
+          break;
+        case MEMBERS_INJECTOR:
+          // no explicit deps for members injection, so just look it up
+          Optional<MembersInjectionBinding> membersInjectionBinding =
+              injectBindingRegistry.getMembersInjectionBindingForKey(requestKey);
+          if (membersInjectionBinding.isPresent()) {
+            // found a binding, resolve its deps and then mark it resolved
+            for (DependencyRequest dependency : membersInjectionBinding.get().dependencies()) {
+              resolveRequest(dependency, explicitBindings, resolvedBindings,
+                  resolvedProvisionsBindingBuilder, resolvedMembersIjectionBindingsBuilder);
             }
+            resolvedBindings.put(frameworkKey, membersInjectionBinding.get());
+            resolvedMembersIjectionBindingsBuilder.put(requestKey, membersInjectionBinding.get());
+          } else {
+            // TOOD(gak): make an implicit injector for cases where we need one, but it has no
+            // members
           }
-        }
-        resolutionOrder.add(FrameworkKey.forDependencyRequest(requestToResolve));
+          break;
+        default:
+          throw new AssertionError();
       }
-
-      return new AutoValue_ComponentDescriptor(
-          componentDefinitionType,
-          componentDependencyTypes,
-          interfaceRequestsBuilder.build(),
-          moduleTypes,
-          ImmutableSetMultimap.copyOf(resolvedProvisionBindings),
-          ImmutableMap.copyOf(resolvedMembersInjectionBindings),
-          resolutionOrder.build().asList().reverse());
     }
 
     private static boolean isComponentProvisionMethod(ExecutableElement method) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 134f79e3d..cd7c5247f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -320,7 +320,7 @@ private Snippet initializeFactoryForBinding(ProvisionBinding binding,
       if (binding.bindingKind().equals(PROVISION)) {
         parameters.add(contributionFields.get(binding.bindingTypeElement()).name());
       }
-      if (binding.requiresMemberInjection()) {
+      if (binding.memberInjectionRequest().isPresent()) {
         FieldWriter membersInjectorField =
             membersInjectorFields.get(keyFactory.forType(binding.providedKey().type()));
         if (membersInjectorField != null) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index 7c61d5143..013830eb8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -19,7 +19,7 @@
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import dagger.Lazy;
 import dagger.MembersInjector;
@@ -76,7 +76,7 @@
       this.keyFactory = keyFactory;
     }
 
-    ImmutableList<DependencyRequest> forRequiredVariables(
+    ImmutableSet<DependencyRequest> forRequiredVariables(
         List<? extends VariableElement> variables) {
       return FluentIterable.from(variables)
           .transform(new Function<VariableElement, DependencyRequest>() {
@@ -84,7 +84,7 @@
               return forRequiredVariable(input);
             }
           })
-          .toList();
+          .toSet();
     }
 
     DependencyRequest forRequiredVariable(VariableElement variableElement) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 5c1f07e6a..09c07a393 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -103,7 +103,7 @@ JavaWriter write(ClassName generatedTypeName, ProvisionBinding binding) {
           .addSnippet("this.module = module;");
     }
 
-    if (binding.requiresMemberInjection()) {
+    if (binding.memberInjectionRequest().isPresent()) {
       ParameterizedTypeName membersInjectorType = ParameterizedTypeName.create(
           MembersInjector.class, providedTypeName);
       factoryWriter.addField(membersInjectorType, "membersInjector").addModifiers(PRIVATE, FINAL);
@@ -160,7 +160,7 @@ JavaWriter write(ClassName generatedTypeName, ProvisionBinding binding) {
         default:
           throw new AssertionError();
       }
-    } else if (binding.requiresMemberInjection()) {
+    } else if (binding.memberInjectionRequest().isPresent()) {
       getMethodWriter.body().addSnippet("%1$s instance = new %1$s(%2$s);",
           providedTypeName, parametersSnippet);
       getMethodWriter.body().addSnippet("membersInjector.injectMembers(instance);");
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkKey.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkKey.java
index afb4c0280..ba4f0d003 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkKey.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkKey.java
@@ -16,6 +16,7 @@
 package dagger.internal.codegen;
 
 import com.google.auto.value.AutoValue;
+import com.google.common.base.Function;
 import dagger.MembersInjector;
 import javax.inject.Provider;
 
@@ -30,6 +31,14 @@
  */
 @AutoValue
 abstract class FrameworkKey {
+  static final Function<DependencyRequest, FrameworkKey> REQUEST_TO_FRAMEWORK_KEY =
+      new Function<DependencyRequest, FrameworkKey>() {
+        @Override public FrameworkKey apply(DependencyRequest input) {
+          return forDependencyRequest(input);
+        }
+      };
+
+  // TODO(gak): maybe just put this on DependencyRequest?
   static FrameworkKey forDependencyRequest(DependencyRequest dependencyRequest) {
     final Class<?> frameworkClass;
     switch (dependencyRequest.kind()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index e4fb2586e..836d33cca 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -47,7 +47,7 @@ void registerProvisionBinding(ProvisionBinding binding) {
 
   void registerMembersInjectionBinding(MembersInjectionBinding binding) {
     MembersInjectionBinding previousValue = membersInjectionBindingsByKey.put(
-        keyFactory.forType(binding.injectedType().asType()), binding);
+        keyFactory.forType(binding.bindingElement().asType()), binding);
     checkState(previousValue == null);
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index 2beac8126..d55980e7c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -20,13 +20,11 @@
 import com.google.common.base.Function;
 import com.google.common.collect.ComparisonChain;
 import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.ImmutableSortedSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Ordering;
-import java.util.List;
+import java.util.Set;
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
@@ -46,7 +44,9 @@
  * @since 2.0
  */
 @AutoValue
-abstract class MembersInjectionBinding {
+abstract class MembersInjectionBinding extends Binding {
+  @Override abstract TypeElement bindingElement();
+
   /**
    * Creates a {@link MembersInjectionBinding} for the given bindings.
    *
@@ -62,32 +62,23 @@ static MembersInjectionBinding create(Iterable<InjectionSite> injectionSites) {
           }
         })
         .toSet());
-    return new AutoValue_MembersInjectionBinding(injectedTypeElement, injectionSiteSet);
+    ImmutableSet<DependencyRequest> dependencies = FluentIterable.from(injectionSiteSet)
+        .transformAndConcat(new Function<InjectionSite, Set<DependencyRequest>>() {
+          @Override public Set<DependencyRequest> apply(InjectionSite input) {
+            return input.dependencies();
+          }
+        })
+        .toSet();
+    return new AutoValue_MembersInjectionBinding(
+        dependencies, injectedTypeElement, injectionSiteSet);
   }
 
-  /** The type on which members are injected. */
-  abstract TypeElement injectedType();
-
   /** The set of individual sites where {@link Inject} is applied. */
   abstract ImmutableSortedSet<InjectionSite> injectionSites();
 
   /** The total set of dependencies required by all injection sites. */
   final ImmutableSet<DependencyRequest> dependencySet() {
-    return FluentIterable.from(injectionSites())
-        .transformAndConcat(new Function<InjectionSite, List<DependencyRequest>>() {
-          @Override public List<DependencyRequest> apply(InjectionSite input) {
-            return input.dependencies();
-          }
-        })
-        .toSet();
-  }
-
-  ImmutableSetMultimap<Key, DependencyRequest> dependenciesByKey() {
-    ImmutableSetMultimap.Builder<Key, DependencyRequest> builder = ImmutableSetMultimap.builder();
-    for (DependencyRequest dependency : dependencySet()) {
-      builder.put(dependency.key(), dependency);
-    }
-    return builder.build();
+    return ImmutableSet.copyOf(dependencies());
   }
 
   private static final Ordering<InjectionSite> INJECTION_ORDERING =
@@ -122,7 +113,7 @@ private int targetIndexInEnclosing(InjectionSite injectionSite)  {
 
     abstract Element element();
 
-    abstract ImmutableList<DependencyRequest> dependencies();
+    abstract ImmutableSet<DependencyRequest> dependencies();
 
     static final class Factory {
       private final DependencyRequest.Factory dependencyRequestFactory;
@@ -144,7 +135,7 @@ InjectionSite forInjectField(VariableElement fieldElement) {
         checkArgument(fieldElement.getKind().equals(ElementKind.FIELD));
         checkArgument(isAnnotationPresent(fieldElement, Inject.class));
         return new AutoValue_MembersInjectionBinding_InjectionSite(Kind.FIELD, fieldElement,
-            ImmutableList.of(dependencyRequestFactory.forRequiredVariable(fieldElement)));
+            ImmutableSet.of(dependencyRequestFactory.forRequiredVariable(fieldElement)));
       }
     }
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index 05970210b..773903b45 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -86,12 +86,12 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
 
   @Override
   Optional<? extends Element> getElementForErrorReporting(MembersInjectionBinding binding) {
-    return Optional.of(binding.injectedType());
+    return Optional.of(binding.bindingElement());
   }
 
   @Override
   JavaWriter write(ClassName injectorClassName, MembersInjectionBinding binding) {
-    ClassName injectedClassName = ClassName.fromTypeElement(binding.injectedType());
+    ClassName injectedClassName = ClassName.fromTypeElement(binding.bindingElement());
 
     JavaWriter writer = JavaWriter.inPackage(injectedClassName.packageName());
 
@@ -114,7 +114,7 @@ JavaWriter write(ClassName injectorClassName, MembersInjectionBinding binding) {
         "}"));
 
 
-    Optional<TypeElement> supertype = supertype(binding.injectedType());
+    Optional<TypeElement> supertype = supertype(binding.bindingElement());
     if (supertype.isPresent()) {
       ParameterizedTypeName supertypeMemebersInjectorType = ParameterizedTypeName.create(
           MembersInjector.class, ClassName.fromTypeElement(supertype.get()));
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 4405d0569..0d02cb879 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -18,7 +18,6 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Optional;
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import dagger.Component;
@@ -79,8 +78,8 @@
   /** The scope in which the binding declares the {@link #providedKey()}. */
   abstract Optional<AnnotationMirror> scope();
 
-  /** Returns {@code true} if this provision binding requires members to be injected implicitly. */
-  abstract boolean requiresMemberInjection();
+  /** If this provision requires members injeciton, this will be the corresonding request. */
+  abstract Optional<DependencyRequest> memberInjectionRequest();
 
   private static ImmutableSet<Provides.Type> SET_BINDING_TYPES = immutableEnumSet(SET, SET_VALUES);
 
@@ -130,25 +129,25 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement) {
           Provides.Type.UNIQUE,
           key,
           getScopeAnnotation(constructorElement.getEnclosingElement()),
-          requiresMemeberInjection(
+          membersInjectionRequest(
               MoreElements.asType(constructorElement.getEnclosingElement())));
     }
 
     private static final ImmutableSet<ElementKind> MEMBER_KINDS =
         Sets.immutableEnumSet(METHOD, FIELD);
 
-    private boolean requiresMemeberInjection(TypeElement type) {
+    private Optional<DependencyRequest> membersInjectionRequest(TypeElement type) {
       if (!types.isSameType(elements.getTypeElement(Object.class.getCanonicalName()).asType(),
           type.getSuperclass())) {
-        return true;
+        return Optional.of(dependencyRequestFactory.forMembersInjectedType(type.asType()));
       }
       for (Element enclosedElement : type.getEnclosedElements()) {
         if (MEMBER_KINDS.contains(enclosedElement.getKind())
             && (isAnnotationPresent(enclosedElement, Inject.class))) {
-          return true;
+          return Optional.of(dependencyRequestFactory.forMembersInjectedType(type.asType()));
         }
       }
-      return false;
+      return Optional.absent();
     }
 
     ProvisionBinding forProvidesMethod(ExecutableElement providesMethod) {
@@ -163,7 +162,7 @@ ProvisionBinding forProvidesMethod(ExecutableElement providesMethod) {
           providesAnnotation.type(),
           keyFactory.forProvidesMethod(providesMethod),
           getScopeAnnotation(providesMethod),
-          false);
+          Optional.<DependencyRequest>absent());
     }
 
     ProvisionBinding forComponent(TypeElement componentDefinitionType) {
@@ -172,12 +171,12 @@ ProvisionBinding forComponent(TypeElement componentDefinitionType) {
       checkArgument(componentAnnotation != null);
       return new AutoValue_ProvisionBinding(
           componentDefinitionType,
-          ImmutableList.<DependencyRequest>of(),
+          ImmutableSet.<DependencyRequest>of(),
           Kind.COMPONENT,
           Provides.Type.UNIQUE,
           keyFactory.forType(componentDefinitionType.asType()),
           Optional.<AnnotationMirror>absent(),
-          false);
+          Optional.<DependencyRequest>absent());
     }
 
     ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
@@ -186,12 +185,12 @@ ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
       checkArgument(componentMethod.getParameters().isEmpty());
       return new AutoValue_ProvisionBinding(
           componentMethod,
-          ImmutableList.<DependencyRequest>of(),
+          ImmutableSet.<DependencyRequest>of(),
           Kind.COMPONENT_PROVISION,
           Provides.Type.UNIQUE,
           keyFactory.forComponentMethod(componentMethod),
           getScopeAnnotation(componentMethod),
-          false);
+          Optional.<DependencyRequest>absent());
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index c72b24ce8..e91408159 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -230,7 +230,7 @@ public String apply(Entry<?, String> input) {
         new Function<MembersInjectionBinding, String>() {
           @Override public String apply(MembersInjectionBinding input) {
             return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL,
-                input.injectedType().getSimpleName().toString()) + "MembersInjector";
+                input.bindingElement().getSimpleName().toString()) + "MembersInjector";
           }
         }));
   }
@@ -265,7 +265,7 @@ static ClassName factoryNameForProvisionBinding(ProvisionBinding binding) {
   }
 
   static ClassName membersInjectorNameForMembersInjectionBinding(MembersInjectionBinding binding) {
-    ClassName injectedClassName = ClassName.fromTypeElement(binding.injectedType());
+    ClassName injectedClassName = ClassName.fromTypeElement(binding.bindingElement());
     return injectedClassName.topLevelClassName().peerNamed(
         injectedClassName.classFileName() + "$$MembersInjector");
   }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index dcd0de0b4..badd5912f 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -979,15 +979,15 @@
         "public final class Dagger_TestComponent implements TestComponent {",
         "  private final test.TestModule testModule;",
         "  private final TestModule testModule1;",
-        "  private final Provider<A> aProvider;",
-        "  private final Provider<test.A> aProvider1;",
+        "  private final Provider<test.A> aProvider;",
+        "  private final Provider<A> aProvider1;",
         "",
         "  private Dagger_TestComponent(Builder builder) {",
         "    assert builder != null;",
         "    this.testModule = builder.testModule;",
         "    this.testModule1 = builder.testModule1;",
-        "    this.aProvider1 = new test.TestModule$$AFactory(testModule);",
-        "    this.aProvider = new TestModule$$AFactory(testModule1);",
+        "    this.aProvider = new test.TestModule$$AFactory(testModule);",
+        "    this.aProvider1 = new TestModule$$AFactory(testModule1);",
         "  }",
         "",
         "  public static Builder builder() {",
@@ -999,11 +999,11 @@
         "  }",
         "",
         "  @Override public test.A a() {",
-        "    return aProvider1.get();",
+        "    return aProvider.get();",
         "  }",
         "",
         "  @Override public A otherA() {",
-        "    return aProvider.get();",
+        "    return aProvider1.get();",
         "  }",
         "",
         "  public static final class Builder {",
@@ -1045,4 +1045,108 @@
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
   }
+
+  @Test public void resolutionOrder() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject A(B b) {}",
+        "}");
+    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class B {",
+        "  @Inject B(C c) {}",
+        "}");
+    JavaFileObject cFile = JavaFileObjects.forSourceLines("test.C",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class C {",
+        "  @Inject C() {}",
+        "}");
+    JavaFileObject xFile = JavaFileObjects.forSourceLines("test.X",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class X {",
+        "  @Inject X(C c) {}",
+        "}");
+
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  A a();",
+        "  C c();",
+        "  X x();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.Dagger_TestComponent",
+        "package test;",
+        "",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_TestComponent implements TestComponent {",
+        "  private final Provider<A> aProvider;",
+        "  private final Provider<B> bProvider;",
+        "  private final Provider<C> cProvider;",
+        "  private final Provider<X> xProvider;",
+        "",
+        "  private Dagger_TestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    this.cProvider = new C$$Factory();",
+        "    this.bProvider = new B$$Factory(cProvider);",
+        "    this.aProvider = new A$$Factory(bProvider);",
+        "    this.xProvider = new X$$Factory(cProvider);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  @Override public A a() {",
+        "    return aProvider.get();",
+        "  }",
+        "",
+        "  @Override public C c() {",
+        "    return cProvider.get();",
+        "  }",
+        "",
+        "  @Override public X x() {",
+        "    return xProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {}",
+        "",
+        "    public TestComponent build() {",
+        "      return new Dagger_TestComponent(this);",
+        "    }",
+        "  }",
+        "}");
+    assert_().about(javaSources())
+        .that(ImmutableList.of(aFile, bFile, cFile, xFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
 }
