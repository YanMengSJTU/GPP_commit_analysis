diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentInfo.java b/compiler/src/main/java/dagger/internal/codegen/ComponentInfo.java
index 61659e1ac..ca5f70959 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentInfo.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentInfo.java
@@ -133,7 +133,11 @@ public BindingGraph getBindingGraph() {
     protected ClassName getBuilderClassName(TypeElement component) {
         ClassName builderClassName;
         if (descriptor.kind() == ComponentDescriptor.Kind.COMPONENT) {
-            builderClassName = Util.getDaggerComponentClassName(ClassName.get(component)).nestedClass("Builder");
+            if (descriptor.builderSpec().isPresent()) {
+                builderClassName = ClassName.get(descriptor.builderSpec().get().builderDefinitionType());
+            }else {
+                builderClassName = Util.getDaggerComponentClassName(ClassName.get(component)).nestedClass("Builder");
+            }
         }else {
             if (descriptor.builderSpec().isPresent()) {
                 builderClassName = ClassName.get(descriptor.builderSpec().get().builderDefinitionType());
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index b4c4bcbc4..811244f07 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -270,7 +270,7 @@ public SourceVersion getSupportedSourceVersion() {
             new InjectorProcessingStep(
                     types,
                     messager,
-                    new InjectorGenerator(filer, types, elements, componentDescriptorFactory, bindingGraphFactory, new TestClassGenerator(filer, elements), testRegistry, new Decorator.Factory(filer, elements, bindingGraphFactory)),
+                    new InjectorGenerator(filer, types, elements, componentDescriptorFactory, bindingGraphFactory, new TestClassGenerator(filer, elements), testRegistry, new Decorator.Factory(filer, elements, bindingGraphFactory, testRegistry)),
                     ComponentDescriptor.Kind.COMPONENT,
                     bindingGraphFactory,
                     componentDescriptorFactory,
diff --git a/compiler/src/main/java/dagger/internal/codegen/Decorator.java b/compiler/src/main/java/dagger/internal/codegen/Decorator.java
index 0d940b7d5..416c6e1b1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Decorator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Decorator.java
@@ -8,21 +8,31 @@
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.Elements;
+import java.io.IOException;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
+import java.util.Set;
 
 public class Decorator  extends SourceFileGenerator<BindingGraph>{
 
     private BindingGraph.Factory factory;
+    private ClassName appClass;
+    private TestRegistry testRegistry;
 
-    private Decorator(Filer filer, Elements elements, BindingGraph.Factory factory) {
+    private Decorator(Filer filer, Elements elements, BindingGraph.Factory factory, ClassName appClass, TestRegistry testRegistry) {
         super(filer, elements);
         this.factory = factory;
+        this.appClass = appClass;
+        this.testRegistry = testRegistry;
     }
 
     @Override
     ClassName nameGeneratedType(BindingGraph input) {
+        return getClassName(input);
+    }
+
+    private ClassName getClassName(BindingGraph input) {
         final TypeElement component = input.componentDescriptor().componentDefinitionType();
         return ClassName.bestGuess("factories." + component.getSimpleName().toString() + "Decorator");
     }
@@ -39,14 +49,22 @@ ClassName nameGeneratedType(BindingGraph input) {
 
         final String daggerBuilderClassName = TriggerComponentInfo.resolveClassName(factory, input.componentDescriptor());
 
+        builder.addField(appClass, "app", Modifier.PRIVATE);
+
         addDecoratorType(builder, generatedTypeName, daggerBuilderClassName, input);
 
         return Optional.of(builder);
     }
 
     private void addDecoratorType(TypeSpec.Builder builder, ClassName returnType, String className, BindingGraph bindingGraph) {
+
         builder.addModifiers(Modifier.PUBLIC);
-        builder.addMethod(MethodSpec.constructorBuilder().addModifiers(Modifier.PUBLIC).build());
+        builder.addMethod(MethodSpec.constructorBuilder()
+                .addModifiers(Modifier.PUBLIC)
+                .addParameter(appClass, "app")
+                .addStatement("this.app = app")
+                .build());
+
         List<CodeBlock> statements = new ArrayList<>();
         for (ContributionBinding contributionBinding : bindingGraph.delegateRequirements()) {
             Util.createDelegateFieldAndMethod(returnType, builder, contributionBinding, new HashMap<>(1));
@@ -55,6 +73,12 @@ private void addDecoratorType(TypeSpec.Builder builder, ClassName returnType, St
             statements.add(CodeBlock.of("builder.$L(this.$L);", Util.getDelegateMethodName(delegateTypeName), delegateFieldName));
         }
 
+        builder.addMethod(MethodSpec.methodBuilder("and")
+                .addModifiers(Modifier.PUBLIC)
+                .addStatement("return app")
+                .returns(appClass)
+                .build());
+
         builder.addMethod(MethodSpec.methodBuilder("decorate")
                 .addModifiers(Modifier.PUBLIC)
                 .addParameter(ClassName.bestGuess(className), "builder")
@@ -63,21 +87,33 @@ private void addDecoratorType(TypeSpec.Builder builder, ClassName returnType, St
                 .build());
     }
 
+    @Override
+    void generate(BindingGraph input) throws SourceFileGenerationException {
+        final ClassName generatedTypeName = getClassName(input);
+        final Optional<TypeSpec.Builder> builder = write(generatedTypeName, input);
+        try {
+            testRegistry.addEncodedClass(generatedTypeName, buildJavaFile(generatedTypeName, builder.get()));
+        } catch (IOException e) {
+            throw new IllegalStateException(e);
+        }
+    }
 
     public static class Factory {
 
         private final Filer filer;
         private final Elements elements;
         private final BindingGraph.Factory bindingGraphFactory;
+        private TestRegistry testRegistry;
 
-        Factory(Filer filer, Elements elements, BindingGraph.Factory bindingGraphFactory) {
+        Factory(Filer filer, Elements elements, BindingGraph.Factory bindingGraphFactory, TestRegistry testRegistry) {
             this.filer = filer;
             this.elements = elements;
             this.bindingGraphFactory = bindingGraphFactory;
+            this.testRegistry = testRegistry;
         }
 
-        public Decorator create() {
-            return new Decorator(filer, elements, bindingGraphFactory);
+        public Decorator create(ClassName appClass) {
+            return new Decorator(filer, elements, bindingGraphFactory, appClass, testRegistry);
         }
 
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 44772cad7..368ea4406 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -150,7 +150,8 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
                   getDelegateTypeName(binding.key()),
                   getDelegateFieldName(binding.key()),
                   factoryBuilder,
-                  constructorBuilder.get()
+                  constructorBuilder.get(),
+                  false
           );
         }
         if (binding.requiresModuleInstance()) {
@@ -159,7 +160,8 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
               TypeName.get(binding.bindingTypeElement().get().asType()),
               "module",
               factoryBuilder,
-              constructorBuilder.get());
+              constructorBuilder.get(),
+              true);
         }
         for (Map.Entry<BindingKey, FrameworkField> entry : generateBindingFieldsForDependencies(binding).entrySet()) {
           BindingKey bindingKey = entry.getKey();
@@ -169,7 +171,8 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
                   bindingField.type(),
                   uniqueFieldNames.getUniqueName(bindingField.name()),
                   factoryBuilder,
-                  constructorBuilder.get());
+                  constructorBuilder.get(),
+                  true);
           fieldsBuilder.put(bindingKey, field);
         }
         break;
@@ -347,12 +350,17 @@ private FieldSpec addConstructorParameterAndTypeField(
       TypeName typeName,
       String variableName,
       TypeSpec.Builder factoryBuilder,
-      MethodSpec.Builder constructorBuilder) {
+      MethodSpec.Builder constructorBuilder,
+      boolean assertCheck) {
     FieldSpec field = FieldSpec.builder(typeName, variableName, PRIVATE, FINAL).build();
     factoryBuilder.addField(field);
     ParameterSpec parameter = ParameterSpec.builder(typeName, variableName).build();
     constructorBuilder.addParameter(parameter);
-    constructorBuilder.addCode("assert $1N != null; this.$2N = $1N;", parameter, field);
+    if (assertCheck) {
+      constructorBuilder.addCode("assert $1N != null; this.$2N = $1N;", parameter, field);
+    }else {
+      constructorBuilder.addCode("this.$2N = $1N;", parameter, field);
+    }
     return field;
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java
index b48979ceb..9f42a15e7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java
@@ -57,7 +57,7 @@ ClassName nameGeneratedType(DI input) {
             throw new IllegalStateException("onCreate method not found!");
         }
         final MethodSpec.Builder overriding = MethodSpec.overriding(onCreateMethod.get());
-        createDecoratorClasses(builder, overriding, components);
+        createDecoratorClasses(builder, overriding, components, input.getAppClass());
         overriding.addStatement("super.onCreate()");
 
         //builder.addMethod(overriding.build());
@@ -68,44 +68,40 @@ ClassName nameGeneratedType(DI input) {
             componentInfo.process(builder);
         }
 
-        builder.addMethod(MethodSpec.methodBuilder("apply")
-                .addModifiers(Modifier.PUBLIC)
-                .returns(void.class)
-                .addStatement("this.onCreate()")
-                .build());
-
         return Optional.of(builder);
     }
 
-    private void createDecoratorClasses(TypeSpec.Builder builder, MethodSpec.Builder methodBuilder, Set<TypeElement> components) {
+    private void createDecoratorClasses(TypeSpec.Builder builder, MethodSpec.Builder methodBuilder, Set<TypeElement> components, TypeElement appClass) {
         for (TypeElement component : components) {
             ComponentDescriptor componentDescriptor = componentDescriptorFactory.forComponent(component);
             final BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
-            createDecoratorClass(builder, methodBuilder, bindingGraph);
+            createDecoratorClass(builder, methodBuilder, bindingGraph, appClass);
         }
     }
 
-    private void createDecoratorClass(TypeSpec.Builder builder, MethodSpec.Builder methodBuilder, BindingGraph bindingGraph) {
-        final Decorator decorator = decoratorFactory.create();
+    private void createDecoratorClass(TypeSpec.Builder builder, MethodSpec.Builder methodBuilder, BindingGraph bindingGraph, TypeElement appClass) {
+        final ClassName appClassName = ClassName.get(appClass);
+        ClassName testAppClassName = appClassName.topLevelClassName().peerClass("Test" + appClassName.simpleName());
+        final Decorator decorator = decoratorFactory.create(testAppClassName);
         try {
             decorator.generate(bindingGraph);
             final ClassName decoratorName = decorator.nameGeneratedType(bindingGraph);
-            String name = Util.lowerCaseFirstLetter(decoratorName.simpleName());
-            final FieldSpec.Builder fieldBuilder = FieldSpec.builder(decoratorName, name, Modifier.PRIVATE);
+            final String fieldName = Util.lowerCaseFirstLetter(decoratorName.simpleName());
+            final String methodName = "decorate" + Util.capitalize(fieldName.replaceAll("Decorator$", ""));
+            final FieldSpec.Builder fieldBuilder = FieldSpec.builder(decoratorName, fieldName, Modifier.PRIVATE);
             fieldBuilder.addAnnotation(AnnotationSpec.builder(ClassName.bestGuess("android.support.annotation.NonNull")).build());
-            final FieldSpec field = fieldBuilder.initializer("new $T()", decoratorName).build();
-            //methodBuilder.addStatement("this.$N = new $T()", field, decoratorName);
+            final FieldSpec field = fieldBuilder.initializer("new $T(this)", decoratorName).build();
             builder.addField(field);
-            builder.addMethod(MethodSpec.methodBuilder(name)
+            builder.addMethod(MethodSpec.methodBuilder(methodName)
                     .addModifiers(Modifier.PUBLIC)
                     .returns(decoratorName)
-                    .addStatement("return this.$L", name)
+                    .addStatement("return this.$L", fieldName)
                     .build());
         } catch (SourceFileGenerationException e) {
             throw new IllegalStateException("Exception while generating decorator: " + e);
         }
         for (BindingGraph subGraph : bindingGraph.subgraphs()) {
-            createDecoratorClass(builder, methodBuilder, subGraph);
+            createDecoratorClass(builder, methodBuilder, subGraph, appClass);
         }
     }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 03fe88d49..cb791e49b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -209,13 +209,27 @@ public ClassName getDelegateTypeName() {
       }else {
         final java.util.Optional<? extends AnnotationMirror> annotationMirror = getAnnotationMirror(bindingMethod);
         if(annotationMirror.isPresent()) {
-          return ClassName.bestGuess("swagger" + "." + getCapitalizedAnnotationValue(annotationMirror.get()) + "In" + contributingModule.getSimpleName().toString() + "Delegate");
+          String capitalizedAnnotationValue = getCapitalizedAnnotationValue(annotationMirror.get());
+          if (isInteger(capitalizedAnnotationValue)) {
+            final String annotationName = annotationMirror.get().getAnnotationType().asElement().getSimpleName().toString();
+            capitalizedAnnotationValue = annotationName + capitalizedAnnotationValue;
+          }
+          return ClassName.bestGuess("swagger" + "." + capitalizedAnnotationValue + "In" + contributingModule.getSimpleName().toString() + "Delegate");
         }else {
           return ClassName.bestGuess("swagger" + "." + capitalizeFirstLetter(bindingMethod.getSimpleName().toString()) + "For" + contributingModule.getSimpleName().toString() + "Delegate");
         }
       }
     }
 
+    private boolean isInteger(String str) {
+      try{
+        Integer.parseInt(str);
+        return true;
+      } catch (Exception e) {
+        return false;
+      }
+    }
+
     public String getDelegateFieldName() {
       final TypeMirror returnType = bindingMethod.getReturnType();
       final Named annotation = bindingMethod.getAnnotation(Named.class);
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index ac7a4ac1f..d2da7dfa8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -48,7 +48,6 @@
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.function.Predicate;
 import java.util.stream.Collector;
 import javax.inject.Named;
 import javax.lang.model.element.*;
@@ -280,7 +279,7 @@ static ClassName getDelegateTypeName(Key key) {
                         .findFirst();
                 if (qualifier.isPresent()) {
                     final PackageElement packageElement = getPackage(MoreTypes.asElement(key.type()));
-                    final String classNameString = "delegates" + "." + capitalizeFirstLetter(qualifier.get()) + "Delegate";
+                    final String classNameString = "delegates" + "." + capitalize(qualifier.get()) + "Delegate";
                     return ClassName.bestGuess(classNameString);
                 }
             }
@@ -487,14 +486,14 @@ private static String getCapitalizedAnnotationValue(AnnotationMirror annotation)
             if (entry.getKey().getSimpleName().toString().equals("value")) {
                 final String original = entry.getValue().getValue().toString();
                 if (!original.isEmpty()) {
-                    return capitalizeFirstLetter(original);
+                    return capitalize(original);
                 }
             }
         }
         throw new IllegalStateException("value not found");
     }
 
-    public static String capitalizeFirstLetter(String original) {
+    public static String capitalize(String original) {
         if (original == null || original.length() == 0) {
             return original;
         }
diff --git a/core/src/main/java/dagger/Trigger.java b/core/src/main/java/dagger/Trigger.java
index 43a27d3dc..24deb6e97 100644
--- a/core/src/main/java/dagger/Trigger.java
+++ b/core/src/main/java/dagger/Trigger.java
@@ -2,13 +2,16 @@
 
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.CLASS;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
+import static java.lang.annotation.RetentionPolicy.SOURCE;
 
-@Retention(RUNTIME)
+@Retention(CLASS)
 @Target({METHOD, TYPE})
 @Documented
 public @interface Trigger {
