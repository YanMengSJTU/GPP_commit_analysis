diff --git a/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java b/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java
index 608b4c0a1..e34da5d2f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java
@@ -15,24 +15,27 @@
  */
 package dagger.internal.codegen;
 
-import static com.google.common.base.Preconditions.checkNotNull;
-
 import com.google.auto.common.MoreElements;
+import com.google.common.base.Equivalence;
+import com.google.common.base.Objects;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
-
+import com.google.common.collect.Maps;
 import java.lang.annotation.Annotation;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
-
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
+import javax.lang.model.util.ElementFilter;
+
+import static com.google.common.base.Preconditions.checkNotNull;
 
 /**
  * A utility class for working with {@link AnnotationMirror} instances.
@@ -77,7 +80,7 @@
     ImmutableMap<String, AnnotationValue> valueMap =
         simplifyAnnotationValueMap(elements.getElementValuesWithDefaults(annotationMirror));
     ImmutableList.Builder<TypeMirror> builder = ImmutableList.builder();
-    @SuppressWarnings("unchecked")
+
     List<? extends AnnotationValue> typeValues =
         (List<? extends AnnotationValue>) valueMap.get(attributeName).getValue();
     for (AnnotationValue typeValue : typeValues) {
@@ -86,5 +89,55 @@
     return builder.build();
   }
 
+  private static final Equivalence<AnnotationMirror> ANNOTATION_MIRROR_EQUIVALENCE =
+    new Equivalence<AnnotationMirror>() {
+      @Override protected boolean doEquivalent(AnnotationMirror left, AnnotationMirror right) {
+        return MoreTypes.equivalence()
+            .equivalent(left.getAnnotationType(), right.getAnnotationType())
+            && AnnotationValues.equivalence().pairwise().equivalent(
+                getAnnotationValuesWithDefaults(left),
+                getAnnotationValuesWithDefaults(right));
+      }
+
+      @Override protected int doHash(AnnotationMirror annotation) {
+        DeclaredType type = annotation.getAnnotationType();
+        Iterable<AnnotationValue> annotationValues = getAnnotationValuesWithDefaults(annotation);
+        return Objects.hashCode(type,
+            AnnotationValues.equivalence().pairwise().hash(annotationValues));
+      }
+    };
+
+  /**
+   * Returns an {@link Equivalence} for {@link AnnotationMirror} as some implementations
+   * delegate equality tests to {@link Object#equals} whereas the documentation explicitly
+   * states that instance/reference equality is not the proper test.
+   *
+   * Note: The contract of this equivalence is not quite that described in the javadoc, as
+   * hashcode values returned by {@link Equivalence#hash(T)} are not the same as would
+   * be returned from {@link AnnotationMirror#hashCode()}, though the proper invariants
+   * relating hashCode() and equals() hold for {@code hash(T)} and {@code equivalent(T, T)}.
+   */
+  static Equivalence<AnnotationMirror> equivalence() {
+    return ANNOTATION_MIRROR_EQUIVALENCE;
+  }
+
+  /**
+   * Returns the {@link AnnotationMirror}'s map of {@link AnnotationValue} indexed by
+   * {@link ExecutableElement}, supplying default values from the annotation if the
+   * annotation property has not been set.  This is equivalent to
+   * {@link Elements#getElementValuesWithDefaults(AnnotationMirror)} but can be called
+   * statically without an {@Elements} instance.
+   */
+  static Iterable<AnnotationValue> getAnnotationValuesWithDefaults(
+      AnnotationMirror annotation) {
+    Map<ExecutableElement, AnnotationValue> values = Maps.newHashMap();
+    for (ExecutableElement method :
+        ElementFilter.methodsIn(annotation.getAnnotationType().asElement().getEnclosedElements())) {
+      values.put(method, method.getDefaultValue());
+    }
+    values.putAll(annotation.getElementValues());
+    return values.values();
+  }
+
   private AnnotationMirrors() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/AnnotationValues.java b/compiler/src/main/java/dagger/internal/codegen/AnnotationValues.java
new file mode 100644
index 000000000..44071ac37
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/AnnotationValues.java
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Equivalence;
+import com.google.common.collect.Sets;
+import java.util.List;
+import java.util.Map;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.util.SimpleAnnotationValueVisitor6;
+
+/**
+ * A utility class for working with {@link AnnotationValue} instances.
+ *
+ * @author Christian Gruber
+ */
+final class AnnotationValues {
+  private static final Equivalence<AnnotationValue> ANNOTATION_VALUE_EQUIVALENCE =
+      new Equivalence<AnnotationValue>() {
+        @Override protected boolean doEquivalent(AnnotationValue left, AnnotationValue right) {
+          return left.accept(new SimpleAnnotationValueVisitor6<Boolean, AnnotationValue>() {
+            // LHS is not an annotation or array of annotation values, so just test equality.
+            @Override protected Boolean defaultAction(Object left, AnnotationValue right) {
+              return left.equals(right.accept(
+                  new SimpleAnnotationValueVisitor6<Object, Void>() {
+                    @Override protected Object defaultAction(Object object, Void unused) {
+                      return object;
+                    }
+                  }, null));
+            }
+
+            // LHS is an annotation mirror so test equivalence for RHS annotation mirrors
+            // and false for other types.
+            @Override public Boolean visitAnnotation(AnnotationMirror left, AnnotationValue right) {
+              return right.accept(
+                  new SimpleAnnotationValueVisitor6<Boolean, AnnotationMirror>() {
+                    @Override protected Boolean defaultAction(Object right, AnnotationMirror left) {
+                      return false; // Not an annotation mirror, so can't be equal to such.
+                    }
+                    @Override
+                    public Boolean visitAnnotation(AnnotationMirror right, AnnotationMirror left) {
+                      return AnnotationMirrors.equivalence().equivalent(left, right);
+                    }
+                  }, left);
+            }
+
+            // LHS is a list of annotation values have to collect-test equivalences, or false
+            // for any other types.
+            @Override
+            public Boolean visitArray(List<? extends AnnotationValue> left, AnnotationValue right) {
+              return right.accept(
+                  new SimpleAnnotationValueVisitor6<Boolean, List<? extends AnnotationValue>>() {
+                    @Override protected Boolean defaultAction(
+                        Object ignored, List<? extends AnnotationValue> alsoIgnored) {
+                      return false; // Not an annotation mirror, so can't be equal to such.
+                    }
+
+                    @Override public Boolean visitArray(
+                        List<? extends AnnotationValue> right ,
+                        List<? extends AnnotationValue> left) {
+                      return AnnotationValues.equivalence().pairwise().equivalent(
+                          (List<AnnotationValue>) left, (List<AnnotationValue>) right);
+                    }
+                  }, left);
+            }
+          }, right);
+        }
+
+        @Override protected int doHash(AnnotationValue value) {
+          return value.accept(new SimpleAnnotationValueVisitor6<Integer, Void>() {
+            @Override public Integer visitAnnotation(AnnotationMirror value, Void ignore) {
+              return AnnotationMirrors.equivalence().hash(value);
+            }
+
+            @SuppressWarnings("unchecked") // safe covariant cast
+            @Override public Integer visitArray(
+                List<? extends AnnotationValue> values, Void ignore) {
+              return AnnotationValues.equivalence().pairwise().hash((List<AnnotationValue>) values);
+            }
+
+            @Override protected Integer defaultAction(Object value, Void ignored) {
+              return value.hashCode();
+            }
+          }, null);
+        }
+      };
+
+  static Equivalence<AnnotationValue> equivalence() {
+    return ANNOTATION_VALUE_EQUIVALENCE;
+  }
+
+  private AnnotationValues() {}
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index e960aa07c..7c61d5143 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -119,27 +119,18 @@ DependencyRequest forMembersInjectedType(TypeMirror type) {
 
     private DependencyRequest newDependencyRequest(Element requestElement, TypeMirror type,
         Optional<AnnotationMirror> qualifier) {
-      if (elements.getTypeElement(Provider.class.getCanonicalName())
-          .equals(types.asElement(type))) {
-        DeclaredType providerType = (DeclaredType) type;
+      if (isTypeOf(Provider.class, type)) {
         return new AutoValue_DependencyRequest(Kind.PROVIDER,
-            keyFactory.forQualifiedType(qualifier,
-                Iterables.getOnlyElement(providerType.getTypeArguments())),
+            qualifiedTypeForParameter(qualifier, (DeclaredType) type),
             requestElement);
-      } else if (elements.getTypeElement(Lazy.class.getCanonicalName())
-          .equals(types.asElement(type))) {
-        DeclaredType lazyType = (DeclaredType) type;
+      } else if (isTypeOf(Lazy.class, type)) {
         return new AutoValue_DependencyRequest(Kind.LAZY,
-            keyFactory.forQualifiedType(qualifier,
-                Iterables.getOnlyElement(lazyType.getTypeArguments())),
+            qualifiedTypeForParameter(qualifier, (DeclaredType) type),
             requestElement);
-      } else if (elements.getTypeElement(MembersInjector.class.getCanonicalName())
-          .equals(types.asElement(type))) {
+      } else if (isTypeOf(MembersInjector.class, type)) {
         checkArgument(!qualifier.isPresent());
-        DeclaredType membersInjectorType = (DeclaredType) type;
         return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR,
-            keyFactory.forQualifiedType(qualifier,
-                Iterables.getOnlyElement(membersInjectorType.getTypeArguments())),
+            qualifiedTypeForParameter(qualifier, (DeclaredType) type),
             requestElement);
       } else {
         return new AutoValue_DependencyRequest(Kind.INSTANCE,
@@ -147,5 +138,15 @@ private DependencyRequest newDependencyRequest(Element requestElement, TypeMirro
             requestElement);
       }
     }
+
+    private Key qualifiedTypeForParameter(
+        Optional<AnnotationMirror> qualifier, DeclaredType type) {
+      return keyFactory.forQualifiedType(qualifier,
+          Iterables.getOnlyElement(type.getTypeArguments()));
+    }
+
+    private boolean isTypeOf(Class<?> type, TypeMirror mirror) {
+      return elements.getTypeElement(type.getCanonicalName()).equals(types.asElement(mirror));
+    }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 216fcb2fd..3effcc6fe 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -17,6 +17,7 @@
 
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
+import com.google.common.base.Function;
 import com.google.common.base.Objects;
 import com.google.common.base.Optional;
 import dagger.Provides;
@@ -50,8 +51,12 @@
   /**
    * A {@link javax.inject.Qualifier} annotation that provides a unique namespace prefix
    * for the type of this key.
+   *
+   * Despite documentation in {@link AnnotationMirror}, equals and hashCode aren't implemented
+   * to represent logical equality, so {@link MoreTypes#annotationMirrorEquivalence()}
+   * provides this facility.
    */
-  abstract Optional<AnnotationMirror> qualifier();
+  abstract Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedQualifier();
 
   /**
    * The type represented by this key.
@@ -61,6 +66,15 @@
    */
   abstract Equivalence.Wrapper<TypeMirror> wrappedType();
 
+  Optional<AnnotationMirror> qualifier() {
+    return wrappedQualifier().transform(
+        new Function<Equivalence.Wrapper<AnnotationMirror>, AnnotationMirror>() {
+          @Override public AnnotationMirror apply(Equivalence.Wrapper<AnnotationMirror> wrapper) {
+            return wrapper.get();
+          }
+        });
+  }
+
   TypeMirror type() {
     return wrappedType().get();
   }
@@ -101,15 +115,15 @@ Key forProvidesMethod(ExecutableElement e) {
       Optional<AnnotationMirror> qualifier = getQualifier(e);
       switch (providesAnnotation.type()) {
         case UNIQUE:
-          return new AutoValue_Key(qualifier, MoreTypes.equivalence().wrap(returnType));
+          return new AutoValue_Key(rewrap(qualifier), MoreTypes.equivalence().wrap(returnType));
         case SET:
           TypeMirror setType = types.getDeclaredType(getSetElement(), returnType);
-          return new AutoValue_Key(qualifier, MoreTypes.equivalence().wrap(setType));
+          return new AutoValue_Key(rewrap(qualifier), MoreTypes.equivalence().wrap(setType));
         case SET_VALUES:
           // TODO(gak): do we want to allow people to use "covariant return" here?
           checkArgument(returnType.getKind().equals(DECLARED));
           checkArgument(((DeclaredType) returnType).asElement().equals(getSetElement()));
-          return new AutoValue_Key(qualifier, MoreTypes.equivalence().wrap(returnType));
+          return new AutoValue_Key(rewrap(qualifier), MoreTypes.equivalence().wrap(returnType));
         default:
           throw new AssertionError();
       }
@@ -121,17 +135,26 @@ Key forInjectConstructor(ExecutableElement e) {
       checkArgument(!getQualifier(e).isPresent());
       // Must use the enclosing element.  The return type is void for constructors(?!)
       TypeMirror type = e.getEnclosingElement().asType();
-      return new AutoValue_Key(Optional.<AnnotationMirror>absent(),
+      return new AutoValue_Key(
+          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           MoreTypes.equivalence().wrap(type));
     }
 
     Key forType(TypeMirror type) {
-      return new AutoValue_Key(Optional.<AnnotationMirror>absent(),
+      return new AutoValue_Key(
+          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           MoreTypes.equivalence().wrap(normalize(type)));
     }
 
     Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
-      return new AutoValue_Key(qualifier, MoreTypes.equivalence().wrap(normalize(type)));
+      return new AutoValue_Key(rewrap(qualifier), MoreTypes.equivalence().wrap(normalize(type)));
+    }
+
+    private Optional<Equivalence.Wrapper<AnnotationMirror>>
+        rewrap(Optional<AnnotationMirror> qualifier) {
+      return qualifier.isPresent()
+          ? Optional.of(AnnotationMirrors.equivalence().wrap(qualifier.get()))
+          : Optional.<Equivalence.Wrapper<AnnotationMirror>>absent();
     }
   }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/AnnotationMirrorsTest.java b/compiler/src/test/java/dagger/internal/codegen/AnnotationMirrorsTest.java
new file mode 100644
index 000000000..7138a197c
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/AnnotationMirrorsTest.java
@@ -0,0 +1,179 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.testing.EquivalenceTester;
+import com.google.testing.compile.CompilationRule;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.SimpleAnnotationValueVisitor6;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.AnnotationMirrorsTest.SimpleEnum.BLAH;
+import static dagger.internal.codegen.AnnotationMirrorsTest.SimpleEnum.FOO;
+import static org.truth0.Truth.ASSERT;
+
+/**
+ * Tests {@link AnnotationMirrors}.
+ */
+@RunWith(JUnit4.class)
+public class AnnotationMirrorsTest {
+  @Rule public CompilationRule compilationRule = new CompilationRule();
+
+  private Elements elements;
+
+  @Before public void setUp() {
+    this.elements = compilationRule.getElements();
+  }
+
+  enum SimpleEnum{
+    BLAH, FOO
+  }
+
+  @interface Outer {
+    SimpleEnum value();
+  }
+
+  @Outer(BLAH) static class TestClassBlah {}
+  @Outer(BLAH) static class TestClassBlah2 {}
+  @Outer(FOO) static class TestClassFoo {}
+
+  @interface DefaultingOuter {
+    SimpleEnum value() default SimpleEnum.BLAH;
+  }
+
+  @DefaultingOuter class TestWithDefaultingOuterDefault {}
+  @DefaultingOuter(BLAH) class TestWithDefaultingOuterBlah {}
+  @DefaultingOuter(FOO) class TestWithDefaultingOuterFoo {}
+
+  @interface SimpleAnnotation {}
+
+  @interface AnnotatedOuter {
+    DefaultingOuter value();
+  }
+
+  @AnnotatedOuter(@DefaultingOuter) class TestDefaultNestedAnnotated {}
+  @AnnotatedOuter(@DefaultingOuter(BLAH)) class TestBlahNestedAnnotated {}
+  @AnnotatedOuter(@DefaultingOuter(FOO)) class TestFooNestedAnnotated {}
+
+  @interface OuterWithValueArray {
+    DefaultingOuter[] value() default {};
+  }
+
+  @OuterWithValueArray class TestValueArrayWithDefault {}
+  @OuterWithValueArray({}) class TestValueArrayWithEmpty {}
+
+  @OuterWithValueArray({@DefaultingOuter}) class TestValueArrayWithOneDefault {}
+  @OuterWithValueArray(@DefaultingOuter(BLAH)) class TestValueArrayWithOneBlah {}
+  @OuterWithValueArray(@DefaultingOuter(FOO)) class TestValueArrayWithOneFoo {}
+
+  @OuterWithValueArray({@DefaultingOuter(FOO), @DefaultingOuter})
+  class TestValueArrayWithFooAndDefaultBlah {}
+  @OuterWithValueArray({@DefaultingOuter(FOO), @DefaultingOuter(BLAH)})
+  class TestValueArrayWithFooBlah {}
+  @OuterWithValueArray({@DefaultingOuter(FOO), @DefaultingOuter(BLAH)})
+  class TestValueArrayWithFooBlah2 {} // Different instances than on TestValueArrayWithFooBlah.
+  @OuterWithValueArray({@DefaultingOuter(BLAH), @DefaultingOuter(FOO)})
+  class TestValueArrayWithBlahFoo {}
+
+
+  @Test public void testEquivalences() {
+    EquivalenceTester<AnnotationMirror> tester =
+        EquivalenceTester.of(AnnotationMirrors.equivalence());
+
+    tester.addEquivalenceGroup(
+        annotationOn(TestClassBlah.class),
+        annotationOn(TestClassBlah2.class));
+
+    tester.addEquivalenceGroup(
+        annotationOn(TestClassFoo.class));
+
+    tester.addEquivalenceGroup(
+        annotationOn(TestWithDefaultingOuterDefault.class),
+        annotationOn(TestWithDefaultingOuterBlah.class));
+
+    tester.addEquivalenceGroup(
+        annotationOn(TestWithDefaultingOuterFoo.class));
+
+    tester.addEquivalenceGroup(
+        annotationOn(TestDefaultNestedAnnotated.class),
+        annotationOn(TestBlahNestedAnnotated.class));
+
+    tester.addEquivalenceGroup(
+        annotationOn(TestFooNestedAnnotated.class));
+
+    tester.addEquivalenceGroup(
+        annotationOn(TestValueArrayWithDefault.class),
+        annotationOn(TestValueArrayWithEmpty.class));
+
+    tester.addEquivalenceGroup(
+        annotationOn(TestValueArrayWithOneDefault.class),
+        annotationOn(TestValueArrayWithOneBlah.class));
+
+    tester.addEquivalenceGroup(
+        annotationOn(TestValueArrayWithOneFoo.class));
+
+    tester.addEquivalenceGroup(
+        annotationOn(TestValueArrayWithFooAndDefaultBlah.class),
+        annotationOn(TestValueArrayWithFooBlah.class),
+        annotationOn(TestValueArrayWithFooBlah2.class));
+
+    tester.addEquivalenceGroup(
+        annotationOn(TestValueArrayWithBlahFoo.class));
+
+    tester.test();
+  }
+
+  @interface Stringy {
+    String value() default "default";
+  }
+
+  @Stringy class StringyUnset {}
+  @Stringy("foo") class StringySet {}
+
+  @Test public void testGetDefaultValuesUnset() {
+    ASSERT.that(annotationOn(StringyUnset.class).getElementValues()).isEmpty();
+    Iterable<AnnotationValue> values = AnnotationMirrors.getAnnotationValuesWithDefaults(
+        annotationOn(StringyUnset.class));
+    String value = getOnlyElement(values).accept(new SimpleAnnotationValueVisitor6<String, Void>() {
+          @Override public String visitString(String value, Void ignored) {
+            return value;
+          }
+        }, null);
+    ASSERT.that(value).isEqualTo("default");
+  }
+
+  @Test public void testGetDefaultValuesSet() {
+    Iterable<AnnotationValue> values = AnnotationMirrors.getAnnotationValuesWithDefaults(
+        annotationOn(StringySet.class));
+    String value = getOnlyElement(values).accept(new SimpleAnnotationValueVisitor6<String, Void>() {
+          @Override public String visitString(String value, Void ignored) {
+            return value;
+          }
+        }, null);
+    ASSERT.that(value).isEqualTo("foo");
+  }
+
+  private AnnotationMirror annotationOn(Class<?> clazz) {
+    return getOnlyElement(elements.getTypeElement(clazz.getCanonicalName()).getAnnotationMirrors());
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
index fc7a911f6..2bd53bbd2 100644
--- a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import com.google.common.base.Optional;
 import com.google.common.collect.Iterables;
 import com.google.testing.compile.CompilationRule;
 import dagger.Module;
@@ -23,6 +24,8 @@
 import java.util.Set;
 import javax.inject.Inject;
 import javax.inject.Qualifier;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
@@ -52,8 +55,8 @@
   private Key.Factory keyFactory;
 
   @Before public void setUp() {
-    this.elements = compilationRule.getElements();
     this.types = compilationRule.getTypes();
+    this.elements = compilationRule.getElements();
     this.keyFactory = new Key.Factory(types, elements);
   }
 
@@ -102,15 +105,43 @@
     ASSERT.that(key.wrappedType()).isEqualTo(MoreTypes.equivalence().wrap(stringType));
   }
 
+  @Test public void qualifiedKeyEquivalents() {
+    TypeElement moduleElement =
+        elements.getTypeElement(QualifiedProvidesMethodModule.class.getCanonicalName());
+    ExecutableElement providesMethod =
+        Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
+    Key provisionKey = keyFactory.forProvidesMethod(providesMethod);
+
+    TypeMirror type = elements.getTypeElement(String.class.getCanonicalName()).asType();
+    TypeElement injectableElement =
+        elements.getTypeElement(QualifiedFieldHolder.class.getCanonicalName());
+    Element injectionField =
+        Iterables.getOnlyElement(ElementFilter.fieldsIn(injectableElement.getEnclosedElements()));
+    AnnotationMirror qualifier = Iterables.getOnlyElement(injectionField.getAnnotationMirrors());
+    Key injectionKey = keyFactory.forQualifiedType(Optional.<AnnotationMirror>of(qualifier), type);
+
+    ASSERT.that(provisionKey).isEqualTo(injectionKey);
+  }
+
   @Module(library = true)
   static final class QualifiedProvidesMethodModule {
-    @Provides @TestQualifier String provideQualifiedString() {
+    @Provides
+    @TestQualifier(@InnerAnnotation)
+    String provideQualifiedString() {
       return null;
     }
   }
 
+  static final class QualifiedFieldHolder {
+    @TestQualifier(@InnerAnnotation) String aString;
+  }
+
   @Qualifier
-  @interface TestQualifier {}
+  @interface TestQualifier {
+    InnerAnnotation[] value();
+  }
+
+  @interface InnerAnnotation {}
 
   @Test public void forProvidesMethod_sets() {
     TypeElement setElement = elements.getTypeElement(Set.class.getCanonicalName());
