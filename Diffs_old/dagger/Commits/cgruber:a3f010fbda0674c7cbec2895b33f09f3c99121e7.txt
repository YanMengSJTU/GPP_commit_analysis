diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
index 95ddf0c39..edaba3a2d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
@@ -138,17 +138,16 @@ private boolean isDefaultConstructor(ConstructorWriter constructorWriter) {
 
   @Override
   public Set<ClassName> referencedClasses() {
-    @SuppressWarnings("unchecked")
-    Iterable<? extends HasClassReferences> concat =
-        Iterables.concat(nestedTypeWriters, fieldWriters.values(), constructorWriters,
-            methodWriters, implementedTypes, superclass.asSet(), annotations, typeParameters);
-    return FluentIterable.from(concat)
-        .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
-          @Override
-          public Set<ClassName> apply(HasClassReferences input) {
-            return input.referencedClasses();
-          }
-        })
+    return FluentIterable.from(ImmutableList.<HasClassReferences>of())
+        .append(nestedTypeWriters)
+        .append(fieldWriters.values())
+        .append(constructorWriters)
+        .append(methodWriters)
+        .append(implementedTypes)
+        .append(superclass.asSet())
+        .append(annotations)
+        .append(typeParameters)
+        .transformAndConcat(HasClassReferences.COMBINER)
         .toSet();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ConstructorWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/ConstructorWriter.java
index 34860ab33..387c1ddf1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ConstructorWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ConstructorWriter.java
@@ -15,11 +15,9 @@
  */
 package dagger.internal.codegen.writer;
 
-import com.google.common.base.Function;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
 import java.io.IOException;
 import java.util.Map;
@@ -78,15 +76,12 @@ private VariableWriter addParameter(ClassName type, String name) {
 
   @Override
   public Set<ClassName> referencedClasses() {
-    return FluentIterable.from(
-        Iterables.concat(parameterWriters.values(), ImmutableList.of(blockWriter)))
-            .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
-              @Override
-              public Set<ClassName> apply(HasClassReferences input) {
-                return input.referencedClasses();
-              }
-            })
-            .toSet();
+    return FluentIterable.from(ImmutableList.<HasClassReferences>of())
+        .append(parameterWriters.values())
+        .append(annotations)
+        .append(blockWriter)
+        .transformAndConcat(HasClassReferences.COMBINER)
+        .toSet();
   }
 
   @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/EnumWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/EnumWriter.java
index cb0d75e73..4ab017d79 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/EnumWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/EnumWriter.java
@@ -18,7 +18,6 @@
 import com.google.common.base.Function;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
@@ -123,17 +122,15 @@ private boolean isDefaultConstructor(ConstructorWriter constructorWriter) {
 
   @Override
   public Set<ClassName> referencedClasses() {
-    @SuppressWarnings("unchecked")
-    Iterable<? extends HasClassReferences> concat =
-        Iterables.concat(nestedTypeWriters, constantWriters.values(), fieldWriters.values(),
-            constructorWriters, methodWriters, implementedTypes, annotations);
-    return FluentIterable.from(concat)
-        .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
-          @Override
-          public Set<ClassName> apply(HasClassReferences input) {
-            return input.referencedClasses();
-          }
-        })
+    return FluentIterable.from(ImmutableList.<HasClassReferences>of())
+        .append(nestedTypeWriters)
+        .append(constantWriters.values())
+        .append(fieldWriters.values())
+        .append(constructorWriters)
+        .append(methodWriters)
+        .append(implementedTypes)
+        .append(annotations)
+        .transformAndConcat(HasClassReferences.COMBINER)
         .toSet();
   }
 
@@ -170,12 +167,7 @@ public Appendable write(Appendable appendable, Context context) throws IOExcepti
     @Override
     public Set<ClassName> referencedClasses() {
       return FluentIterable.from(constructorSnippets)
-          .transformAndConcat(new Function<Snippet, Set<ClassName>>() {
-            @Override
-            public Set<ClassName> apply(Snippet input) {
-              return input.referencedClasses();
-            }
-          })
+          .transformAndConcat(HasClassReferences.COMBINER)
           .toSet();
     }
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/HasClassReferences.java b/compiler/src/main/java/dagger/internal/codegen/writer/HasClassReferences.java
index 15b412068..e463ea2cb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/HasClassReferences.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/HasClassReferences.java
@@ -15,8 +15,17 @@
  */
 package dagger.internal.codegen.writer;
 
+import com.google.common.base.Function;
 import java.util.Set;
 
 public interface HasClassReferences {
   Set<ClassName> referencedClasses();
+
+  static final Function<HasClassReferences, Set<ClassName>> COMBINER =
+      new Function<HasClassReferences, Set<ClassName>>() {
+        @Override
+        public Set<ClassName> apply(HasClassReferences input) {
+          return input.referencedClasses();
+        }
+      };
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java
index 5eac8a9ee..ffcfc7562 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java
@@ -18,7 +18,7 @@
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;
 import com.google.common.collect.FluentIterable;
-import com.google.common.collect.Iterables;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
 import java.io.IOException;
 import java.util.Iterator;
@@ -76,16 +76,12 @@ public Appendable write(Appendable appendable, Context context) throws IOExcepti
 
   @Override
   public Set<ClassName> referencedClasses() {
-    @SuppressWarnings("unchecked")
-    Iterable<? extends HasClassReferences> concat =
-        Iterables.concat(nestedTypeWriters, methodWriters, implementedTypes, annotations);
-    return FluentIterable.from(concat)
-        .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
-          @Override
-          public Set<ClassName> apply(HasClassReferences input) {
-            return input.referencedClasses();
-          }
-        })
+    return FluentIterable.from(ImmutableList.<HasClassReferences>of())
+        .append(nestedTypeWriters)
+        .append(methodWriters)
+        .append(implementedTypes)
+        .append(annotations)
+        .transformAndConcat(HasClassReferences.COMBINER)
         .toSet();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java
index 7831fe816..eb4ff8d51 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java
@@ -15,7 +15,6 @@
  */
 package dagger.internal.codegen.writer;
 
-import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
@@ -111,14 +110,12 @@ public Appendable write(Appendable appendable, Context context) throws IOExcepti
 
   @Override
   public Set<ClassName> referencedClasses() {
-    return FluentIterable.from(
-        Iterables.concat(ImmutableList.of(returnType), parameterWriters.values(), body.asSet()))
-            .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
-              @Override
-              public Set<ClassName> apply(HasClassReferences input) {
-                return input.referencedClasses();
-              }
-            })
-            .toSet();
+    return FluentIterable.from(ImmutableList.<HasClassReferences>of())
+        .append(parameterWriters.values())
+        .append(returnType)
+        .append(body.asSet())
+        .append(annotations)
+        .transformAndConcat(HasClassReferences.COMBINER)
+        .toSet();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java
index 2071574d1..58ee1e494 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java
@@ -15,6 +15,8 @@
  */
 package dagger.internal.codegen.writer;
 
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
 import java.io.IOException;
 import java.util.Set;
 
@@ -47,6 +49,10 @@ public Appendable write(Appendable appendable, Context context) throws IOExcepti
 
   @Override
   public Set<ClassName> referencedClasses() {
-    return type.referencedClasses();
+    return FluentIterable.from(ImmutableList.<HasClassReferences>of())
+        .append(annotations)
+        .append(type)
+        .transformAndConcat(HasClassReferences.COMBINER)
+        .toSet();
   }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
index 531ae722b..70f6479d5 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
@@ -23,7 +23,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assert_;
+import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 
 @RunWith(JUnit4.class)
@@ -49,26 +49,27 @@ public void mapKeyCreatorFile() {
         "    ADMIN,",
         "    LOGIN;",
         "}");
-    JavaFileObject generatedKeyCreator = JavaFileObjects.forSourceLines("test.PathKeyCreator",
-        "package test;",
-        "",
-        "import javax.annotation.Generated;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class PathKeyCreator {",
-        "  @com.google.auto.value.AutoAnnotation",
-        "  public static PathKey createPathKey(PathEnum value, String relativePath) {",
-        "    return new AutoAnnotation_PathKeyCreator_createPathKey(value, relativePath);",
-        "  }",
-        "}");
-    assert_().about(javaSources())
-    .that(ImmutableList.of(
-        enumKeyFile,
-        pathEnumFile))
-    .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
-    .compilesWithoutError()
-    .and()
-    .generatesSources(generatedKeyCreator);
+    JavaFileObject generatedKeyCreator =
+        JavaFileObjects.forSourceLines(
+            "test.PathKeyCreator",
+            "package test;",
+            "",
+            "import com.google.auto.value.AutoAnnotation;",
+            "import javax.annotation.Generated;",
+            "",
+            "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+            "public final class PathKeyCreator {",
+            "  @AutoAnnotation",
+            "  public static PathKey createPathKey(PathEnum value, String relativePath) {",
+            "    return new AutoAnnotation_PathKeyCreator_createPathKey(value, relativePath);",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(enumKeyFile, pathEnumFile))
+        .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedKeyCreator);
   }
 
   @Test
@@ -95,28 +96,28 @@ public void nestedMapKeyCreatorFile() {
         "    LOGIN;",
         "}");
     JavaFileObject generatedKeyCreator =
-        JavaFileObjects.forSourceLines("test.Container$PathKeyCreator",
+        JavaFileObjects.forSourceLines(
+            "test.Container$PathKeyCreator",
             "package test;",
             "",
+            "import com.google.auto.value.AutoAnnotation;",
             "import javax.annotation.Generated;",
             "import test.Container.PathKey",
             "",
             "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
             "public final class Container$PathKeyCreator {",
-            "  @com.google.auto.value.AutoAnnotation",
+            "  @AutoAnnotation",
             "  public static PathKey createPathKey(PathEnum value, String relativePath) {",
             "    return new AutoAnnotation_Container$PathKeyCreator_createPathKey(",
             "        value, relativePath);",
             "  }",
             "}");
-    assert_().about(javaSources())
-    .that(ImmutableList.of(
-        enumKeyFile,
-        pathEnumFile))
-    .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
-    .compilesWithoutError()
-    .and()
-    .generatesSources(generatedKeyCreator);
+    assertAbout(javaSources())
+        .that(ImmutableList.of(enumKeyFile, pathEnumFile))
+        .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedKeyCreator);
   }
 
   @Test
@@ -278,16 +279,17 @@ public void mapKeyComponentFileWithDisorderedKeyField() {
         "    }",
         "  }",
         "}");
-    assert_().about(javaSources())
-        .that(ImmutableList.of(
-            mapModuleOneFile,
-            mapModuleTwoFile,
-            enumKeyFile,
-            pathEnumFile,
-            handlerFile,
-            loginHandlerFile,
-            adminHandlerFile,
-            componentFile))
+    assertAbout(javaSources())
+        .that(
+            ImmutableList.of(
+                mapModuleOneFile,
+                mapModuleTwoFile,
+                enumKeyFile,
+                pathEnumFile,
+                handlerFile,
+                loginHandlerFile,
+                adminHandlerFile,
+                componentFile))
         .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
         .compilesWithoutError()
         .and()
@@ -452,16 +454,17 @@ public void mapKeyComponentFileWithDefaultField() {
         "    }",
         "  }",
         "}");
-    assert_().about(javaSources())
-        .that(ImmutableList.of(
-            mapModuleOneFile,
-            mapModuleTwoFile,
-            enumKeyFile,
-            pathEnumFile,
-            handlerFile,
-            loginHandlerFile,
-            adminHandlerFile,
-            componentFile))
+    assertAbout(javaSources())
+        .that(
+            ImmutableList.of(
+                mapModuleOneFile,
+                mapModuleTwoFile,
+                enumKeyFile,
+                pathEnumFile,
+                handlerFile,
+                loginHandlerFile,
+                adminHandlerFile,
+                componentFile))
         .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
         .compilesWithoutError()
         .and()
