diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index ef091ee0f..d6b79e250 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -74,8 +74,10 @@
       "@Inject constructors are invalid on inner classes";
   static final String INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS =
       "@Inject is nonsense on the constructor of an abstract class";
-    static final String QUALIFIER_ON_INJECT_CONSTRUCTOR =
+  static final String QUALIFIER_ON_INJECT_CONSTRUCTOR =
       "@Qualifier annotations are not allowed on @Inject constructors.";
+  static final String SCOPE_ON_INJECT_CONSTRUCTOR =
+      "@Scope annotations are not allowed on @Inject constructors. Annotate the class instead.";
 
   /* fields */
   static final String PRIVATE_INJECT_FIELD =
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java b/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java
index 23b2edcab..dceeb52c8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java
@@ -37,6 +37,7 @@
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_QUALIFIERS;
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_SCOPES;
 import static dagger.internal.codegen.ErrorMessages.QUALIFIER_ON_INJECT_CONSTRUCTOR;
+import static dagger.internal.codegen.ErrorMessages.SCOPE_ON_INJECT_CONSTRUCTOR;
 import static dagger.internal.codegen.ErrorMessages.provisionMayNotDependOnProducerType;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
 import static dagger.internal.codegen.InjectionAnnotations.getScopes;
@@ -62,6 +63,10 @@
       builder.addError(QUALIFIER_ON_INJECT_CONSTRUCTOR, constructorElement, qualifier);
     }
 
+    for (AnnotationMirror scope : getScopes(constructorElement)) {
+      builder.addError(SCOPE_ON_INJECT_CONSTRUCTOR, constructorElement, scope);
+    }
+
     for (VariableElement parameter : constructorElement.getParameters()) {
       ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(parameter);
       if (qualifiers.size() > 1) {
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index 59b1b4a8c..9b81750f0 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -2234,6 +2234,36 @@ public boolean apply(Element element) {
         .withNoteCount(3);
   }
 
+  @Test
+  public void scopeAnnotationOnInjectConstructorNotValid() {
+    JavaFileObject aScope =
+        JavaFileObjects.forSourceLines(
+            "test.AScope",
+            "package test;",
+            "",
+            "import javax.inject.Scope;",
+            "",
+            "@Scope",
+            "@interface AScope {}");
+    JavaFileObject aClass =
+        JavaFileObjects.forSourceLines(
+            "test.AClass",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class AClass {",
+            "  @Inject @AScope AClass() {}",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(aScope, aClass))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("@Scope annotations are not allowed on @Inject constructors.")
+        .in(aClass)
+        .onLine(6);
+  }
+
   /**
    * A {@link ComponentProcessor} that excludes elements using a {@link Predicate}.
    */
