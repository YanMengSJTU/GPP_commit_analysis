diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/FooComponent.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/FooComponent.java
index f3021bd1a..afbc3f05f 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/FooComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/FooComponent.java
@@ -20,6 +20,7 @@
 import java.util.Set;
 import test.multipackage.a.AModule;
 import test.multipackage.a.UsesInaccessible;
+import test.multipackage.a.UsesInaccessibleInGenericsOnly;
 import test.multipackage.sub.FooChildComponent;
 
 /**
@@ -42,4 +43,6 @@
   FooChildComponent fooChildComponent();
 
   UsesInaccessible usesInaccessible();
+
+  UsesInaccessibleInGenericsOnly accessibleConstructorUsesInaccessibleInGenericsOnly();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/UsesInaccessible.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/UsesInaccessible.java
index 762492913..3ee3a5e06 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/UsesInaccessible.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/UsesInaccessible.java
@@ -23,7 +23,7 @@
 @SuppressWarnings("unused")
 public class UsesInaccessible {
   @Inject
-  UsesInaccessible(
+  public UsesInaccessible(
       Inaccessible inaccessible,
       Set<Inaccessible> inaccessibleSet,
       Map<String, Inaccessible> inaccessibleMap) {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/UsesInaccessibleInGenericsOnly.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/UsesInaccessibleInGenericsOnly.java
new file mode 100644
index 000000000..f212a0c66
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/UsesInaccessibleInGenericsOnly.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.multipackage.a;
+
+import java.util.Map;
+import java.util.Set;
+import javax.inject.Inject;
+
+@SuppressWarnings("unused")
+public class UsesInaccessibleInGenericsOnly {
+  @Inject
+  public UsesInaccessibleInGenericsOnly(
+      Set<Inaccessible> inaccessibleSet, Map<String, Inaccessible> inaccessibleMap) {}
+}
diff --git a/compiler/src/it/guava-functional-tests/src/main/java/test/optional/OptionalBindingComponents.java b/compiler/src/it/guava-functional-tests/src/main/java/test/optional/OptionalBindingComponents.java
index fcebac6fb..d130a5e6e 100644
--- a/compiler/src/it/guava-functional-tests/src/main/java/test/optional/OptionalBindingComponents.java
+++ b/compiler/src/it/guava-functional-tests/src/main/java/test/optional/OptionalBindingComponents.java
@@ -116,31 +116,12 @@ static Value value(Optional<Provider<Value>> cycle) {
     }
   }
 
-  interface OptionalBindingComponent {
+  /** Interface for components used to test optional bindings. */
+  public interface OptionalBindingComponent {
     Values values();
 
-    Optional<Value> optionalInstance();
-
-    Optional<Provider<Value>> optionalProvider();
-
-    Optional<Lazy<Value>> optionalLazy();
-
-    Optional<Provider<Lazy<Value>>> optionalLazyProvider();
-
     @SomeQualifier
     Values qualifiedValues();
-
-    @SomeQualifier
-    Optional<Value> qualifiedOptionalInstance();
-
-    @SomeQualifier
-    Optional<Provider<Value>> qualifiedOptionalProvider();
-
-    @SomeQualifier
-    Optional<Lazy<Value>> qualifiedOptionalLazy();
-
-    @SomeQualifier
-    Optional<Provider<Lazy<Value>>> qualifiedOptionalLazyProvider();
   }
 
   @Component(modules = OptionalBindingModule.class)
diff --git a/compiler/src/it/guava-functional-tests/src/main/java/test/optional/a/OptionalBindingComponentsWithInaccessibleTypes.java b/compiler/src/it/guava-functional-tests/src/main/java/test/optional/a/OptionalBindingComponentsWithInaccessibleTypes.java
index f9a2f758c..c3beaef79 100644
--- a/compiler/src/it/guava-functional-tests/src/main/java/test/optional/a/OptionalBindingComponentsWithInaccessibleTypes.java
+++ b/compiler/src/it/guava-functional-tests/src/main/java/test/optional/a/OptionalBindingComponentsWithInaccessibleTypes.java
@@ -18,19 +18,11 @@
 
 import dagger.Component;
 import test.optional.OptionalBindingComponents.ConcreteBindingModule;
+import test.optional.OptionalBindingComponents.OptionalBindingComponent;
 import test.optional.OptionalBindingComponents.OptionalBindingModule;
-import test.optional.OptionalBindingComponents.SomeQualifier;
-import test.optional.OptionalBindingComponents.Values;
 
 final class OptionalBindingComponentsWithInaccessibleTypes {
 
-  interface OptionalBindingComponent {
-    Values values();
-
-    @SomeQualifier
-    Values qualifiedValues();
-  }
-
   @Component(modules = OptionalBindingModule.class)
   interface AbsentOptionalBindingComponent extends OptionalBindingComponent {}
 
diff --git a/compiler/src/it/guava-functional-tests/src/test/java/test/optional/OptionalBindingComponentsAbsentTest.java b/compiler/src/it/guava-functional-tests/src/test/java/test/optional/OptionalBindingComponentsAbsentTest.java
index cd74d09e7..491cf85e7 100644
--- a/compiler/src/it/guava-functional-tests/src/test/java/test/optional/OptionalBindingComponentsAbsentTest.java
+++ b/compiler/src/it/guava-functional-tests/src/test/java/test/optional/OptionalBindingComponentsAbsentTest.java
@@ -36,41 +36,41 @@ public void setUp() {
 
   @Test
   public void optional() {
-    assertThat(absent.optionalInstance()).isAbsent();
+    assertThat(absent.values().optionalInstance()).isAbsent();
   }
 
   @Test
   public void optionalProvider() {
-    assertThat(absent.optionalProvider()).isAbsent();
+    assertThat(absent.values().optionalProvider()).isAbsent();
   }
 
   @Test
   public void optionalLazy() {
-    assertThat(absent.optionalLazy()).isAbsent();
+    assertThat(absent.values().optionalLazy()).isAbsent();
   }
 
   @Test
   public void optionalLazyProvider() {
-    assertThat(absent.optionalLazyProvider()).isAbsent();
+    assertThat(absent.values().optionalLazyProvider()).isAbsent();
   }
 
   @Test
   public void qualifiedOptional() {
-    assertThat(absent.qualifiedOptionalInstance()).isAbsent();
+    assertThat(absent.qualifiedValues().optionalInstance()).isAbsent();
   }
 
   @Test
   public void qualifiedOptionalProvider() {
-    assertThat(absent.qualifiedOptionalProvider()).isAbsent();
+    assertThat(absent.qualifiedValues().optionalProvider()).isAbsent();
   }
 
   @Test
   public void qualifiedOptionalLazy() {
-    assertThat(absent.qualifiedOptionalLazy()).isAbsent();
+    assertThat(absent.qualifiedValues().optionalLazy()).isAbsent();
   }
 
   @Test
   public void qualifiedOptionalLazyProvider() {
-    assertThat(absent.qualifiedOptionalLazyProvider()).isAbsent();
+    assertThat(absent.qualifiedValues().optionalLazyProvider()).isAbsent();
   }
 }
diff --git a/compiler/src/it/guava-functional-tests/src/test/java/test/optional/OptionalBindingComponentsPresentTest.java b/compiler/src/it/guava-functional-tests/src/test/java/test/optional/OptionalBindingComponentsPresentTest.java
index c10853120..448329092 100644
--- a/compiler/src/it/guava-functional-tests/src/test/java/test/optional/OptionalBindingComponentsPresentTest.java
+++ b/compiler/src/it/guava-functional-tests/src/test/java/test/optional/OptionalBindingComponentsPresentTest.java
@@ -48,37 +48,38 @@ public OptionalBindingComponentsPresentTest(OptionalBindingComponent component)
 
   @Test
   public void optionalProvider() {
-    assertThat(component.optionalProvider().get().get()).isEqualTo(VALUE);
+    assertThat(component.values().optionalProvider().get().get()).isEqualTo(VALUE);
   }
 
   @Test
   public void optionalLazy() {
-    assertThat(component.optionalLazy().get().get()).isEqualTo(VALUE);
+    assertThat(component.values().optionalLazy().get().get()).isEqualTo(VALUE);
   }
 
   @Test
   public void optionalLazyProvider() {
-    assertThat(component.optionalLazyProvider().get().get().get()).isEqualTo(VALUE);
+    assertThat(component.values().optionalLazyProvider().get().get().get()).isEqualTo(VALUE);
   }
 
   @Test
   public void qualifiedOptional() {
-    assertThat(component.qualifiedOptionalInstance()).hasValue(QUALIFIED_VALUE);
+    assertThat(component.qualifiedValues().optionalInstance()).hasValue(QUALIFIED_VALUE);
   }
 
   @Test
   public void qualifiedOptionalProvider() {
-    assertThat(component.qualifiedOptionalProvider().get().get()).isEqualTo(QUALIFIED_VALUE);
+    assertThat(component.qualifiedValues().optionalProvider().get().get())
+        .isEqualTo(QUALIFIED_VALUE);
   }
 
   @Test
   public void qualifiedOptionalLazy() {
-    assertThat(component.qualifiedOptionalLazy().get().get()).isEqualTo(QUALIFIED_VALUE);
+    assertThat(component.qualifiedValues().optionalLazy().get().get()).isEqualTo(QUALIFIED_VALUE);
   }
 
   @Test
   public void qualifiedOptionalLazyProvider() {
-    assertThat(component.qualifiedOptionalLazyProvider().get().get().get())
+    assertThat(component.qualifiedValues().optionalLazyProvider().get().get().get())
         .isEqualTo(QUALIFIED_VALUE);
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 3e92d661a..869d3be59 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -27,15 +27,11 @@
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.DELEGATED;
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.INITIALIZED;
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.UNINITIALIZED;
-import static dagger.internal.codegen.Accessibility.isElementAccessibleFrom;
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
 import static dagger.internal.codegen.BindingKey.contribution;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
-import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
-import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
-import static dagger.internal.codegen.FrameworkDependency.frameworkDependenciesForBinding;
 import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
 import static dagger.internal.codegen.MemberSelect.emptyFrameworkMapFactory;
 import static dagger.internal.codegen.MemberSelect.emptySetProvider;
@@ -128,10 +124,8 @@
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
 
-/**
- * Creates the implementation class for a component or subcomponent.
- */
-abstract class AbstractComponentWriter {
+/** Creates the implementation class for a component or subcomponent. */
+abstract class AbstractComponentWriter implements HasBindingMembers {
   private static final String NOOP_BUILDER_METHOD_JAVADOC =
       "This module is declared, but an instance is not used in the component. This method is a "
           + "no-op. For more, see https://google.github.io/dagger/unused-modules.\n";
@@ -149,7 +143,7 @@
   private final UniqueNameSet componentFieldNames = new UniqueNameSet();
   private final Map<BindingKey, MemberSelect> memberSelects = new HashMap<>();
   private final Map<BindingKey, MemberSelect> producerFromProviderMemberSelects = new HashMap<>();
-  private final Map<BindingKey, RequestFulfillment> requestFulfillments = Maps.newLinkedHashMap();
+  private final RequestFulfillmentRegistry requestFulfillmentRegistry;
   protected final MethodSpec.Builder constructor = constructorBuilder().addModifiers(PRIVATE);
   protected Optional<ClassName> builderName = Optional.absent();
   private final OptionalFactories optionalFactories;
@@ -187,6 +181,8 @@
     this.graph = graph;
     this.subcomponentNames = subcomponentNames;
     this.optionalFactories = optionalFactories;
+    this.requestFulfillmentRegistry =
+        new RequestFulfillmentRegistry(graph.resolvedBindings(), this);
   }
 
   protected AbstractComponentWriter(
@@ -260,7 +256,8 @@ private CodeBlock getMemberSelectExpression(BindingKey key) {
     return getMemberSelect(key).getExpressionFor(name);
   }
 
-  protected MemberSelect getMemberSelect(BindingKey key) {
+  @Override
+  public MemberSelect getMemberSelect(BindingKey key) {
     return memberSelects.get(key);
   }
 
@@ -688,41 +685,6 @@ private static ClassName frameworkMapFactoryClassName(BindingType bindingType) {
         ? MAP_OF_PRODUCER_PRODUCER : MAP_PROVIDER_FACTORY;
   }
 
-  // TODO(gak): extract this into a proper factory class
-  private RequestFulfillment createRequestFulfillment(BindingKey bindingKey) {
-    /* TODO(gak): it is super convoluted that we create the member selects separately and then
-     * look them up again this way. Now that we have RequestFulfillment, the next step is to
-     * create it and the MemberSelect and the field on demand rather than in a first pass. */
-    MemberSelect memberSelect = getMemberSelect(bindingKey);
-    ResolvedBindings resolvedBindings = graph.resolvedBindings().get(bindingKey);
-    switch (resolvedBindings.bindingType()) {
-      case MEMBERS_INJECTION:
-        return new MembersInjectorRequestFulfillment(bindingKey, memberSelect);
-      case PRODUCTION:
-        return new ProducerFieldRequestFulfillment(bindingKey, memberSelect);
-      case PROVISION:
-        ProvisionBinding provisionBinding =
-            (ProvisionBinding) resolvedBindings.contributionBinding();
-        ProviderFieldRequestFulfillment providerFieldRequestFulfillment =
-            new ProviderFieldRequestFulfillment(bindingKey, memberSelect);
-        if (provisionBinding.implicitDependencies().isEmpty()
-            && !provisionBinding.scope().isPresent()
-            && !provisionBinding.requiresModuleInstance()
-            && provisionBinding.bindingElement().isPresent()
-            && (provisionBinding.bindingKind().equals(INJECTION)
-                || provisionBinding.bindingKind().equals(PROVISION))
-            // TODO(gak): the accessibility limitation here needs to be addressed
-            && isElementAccessibleFrom(
-                provisionBinding.bindingElement().get(), name.packageName())) {
-          return new SimpleMethodRequestFulfillment(
-              bindingKey, provisionBinding, providerFieldRequestFulfillment);
-        }
-        return providerFieldRequestFulfillment;
-      default:
-        throw new AssertionError();
-    }
-  }
-
   private void implementInterfaceMethods() {
     Set<MethodSignature> interfaceMethods = Sets.newHashSet();
     for (ComponentMethodDescriptor componentMethod :
@@ -743,8 +705,7 @@ private void implementInterfaceMethods() {
           MethodSpec.Builder interfaceMethod =
               methodSpecForComponentMethod(methodElement, requestType);
           RequestFulfillment fulfillment =
-              requestFulfillments.computeIfAbsent(
-                  interfaceRequest.bindingKey(), this::createRequestFulfillment);
+              requestFulfillmentRegistry.getRequestFulfillment(interfaceRequest.bindingKey());
           CodeBlock codeBlock = fulfillment.getSnippetForDependencyRequest(interfaceRequest, name);
           switch (interfaceRequest.kind()) {
             case MEMBERS_INJECTOR:
@@ -879,11 +840,12 @@ private void initializeFrameworkTypes() {
      * called before we get the code block that initializes the member. */
     switch (binding.factoryCreationStrategy()) {
       case DELEGATE:
-        CodeBlock delegatingCodeBlock = CodeBlock.of(
-            "($T) $L",
-            binding.bindingType().frameworkClass(),
-            getMemberSelect(
-                Iterables.getOnlyElement(binding.dependencies()).bindingKey())
+        CodeBlock delegatingCodeBlock =
+            CodeBlock.of(
+                "($T) $L",
+                binding.bindingType().frameworkClass(),
+                getMemberSelect(
+                        Iterables.getOnlyElement(binding.explicitDependencies()).bindingKey())
                     .getExpressionFor(name));
         return Optional.of(
             CodeBlocks.concat(
@@ -945,7 +907,7 @@ private CodeBlock initializeDelegateFactoriesForUninitializedDependencies(Bindin
     ImmutableList.Builder<CodeBlock> initializations = ImmutableList.builder();
 
     for (BindingKey dependencyKey :
-        FluentIterable.from(binding.implicitDependencies())
+        FluentIterable.from(binding.dependencies())
             .transform(DependencyRequest::bindingKey)
             .toSet()) {
       if (!getMemberSelect(dependencyKey).staticMember()
@@ -962,7 +924,7 @@ private CodeBlock initializeDelegateFactoriesForUninitializedDependencies(Bindin
 
   private CodeBlock initializeProducersFromProviderDependencies(Binding binding) {
     ImmutableList.Builder<CodeBlock> initializations = ImmutableList.builder();
-    for (FrameworkDependency frameworkDependency : frameworkDependenciesForBinding(binding)) {
+    for (FrameworkDependency frameworkDependency : binding.frameworkDependencies()) {
       ResolvedBindings resolvedBindings =
           graph.resolvedBindings().get(frameworkDependency.bindingKey());
       if (resolvedBindings.frameworkClass().equals(Provider.class)
@@ -1086,7 +1048,7 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
       case PROVISION:
         {
           List<CodeBlock> arguments =
-              Lists.newArrayListWithCapacity(binding.dependencies().size() + 1);
+              Lists.newArrayListWithCapacity(binding.explicitDependencies().size() + 1);
           if (binding.requiresModuleInstance()) {
             arguments.add(getComponentContributionExpression(binding.contributingModule().get()));
           }
@@ -1126,7 +1088,7 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
       case PRODUCTION:
         {
           List<CodeBlock> arguments =
-              Lists.newArrayListWithCapacity(binding.implicitDependencies().size() + 2);
+              Lists.newArrayListWithCapacity(binding.dependencies().size() + 2);
           if (binding.requiresModuleInstance()) {
             arguments.add(getComponentContributionExpression(binding.contributingModule().get()));
           }
@@ -1142,7 +1104,7 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
         return CodeBlock.of(
             "$T.create($L)",
             mapFactoryClassName(binding),
-            getMemberSelectExpression(getOnlyElement(binding.dependencies()).bindingKey()));
+            getMemberSelectExpression(getOnlyElement(binding.explicitDependencies()).bindingKey()));
 
       case SYNTHETIC_MULTIBOUND_SET:
         return initializeFactoryForSetMultibinding(binding);
@@ -1194,7 +1156,7 @@ private CodeBlock initializeMembersInjectorForBinding(MembersInjectionBinding bi
    */
   private ImmutableList<CodeBlock> getDependencyArguments(Binding binding) {
     ImmutableList.Builder<CodeBlock> parameters = ImmutableList.builder();
-    for (FrameworkDependency frameworkDependency : frameworkDependenciesForBinding(binding)) {
+    for (FrameworkDependency frameworkDependency : binding.frameworkDependencies()) {
       parameters.add(getDependencyArgument(frameworkDependency).getExpressionFor(name));
     }
     return parameters.build();
@@ -1227,7 +1189,7 @@ private CodeBlock initializeFactoryForSetMultibinding(ContributionBinding bindin
     int individualProviders = 0;
     int setProviders = 0;
     CodeBlock.Builder builderMethodCalls = CodeBlock.builder();
-    for (FrameworkDependency frameworkDependency : frameworkDependenciesForBinding(binding)) {
+    for (FrameworkDependency frameworkDependency : binding.frameworkDependencies()) {
       ContributionType contributionType =
           graph.resolvedBindings().get(frameworkDependency.bindingKey()).contributionType();
       String methodName;
@@ -1259,8 +1221,7 @@ private CodeBlock initializeFactoryForSetMultibinding(ContributionBinding bindin
   }
 
   private CodeBlock initializeFactoryForMapMultibinding(ContributionBinding binding) {
-    ImmutableSet<FrameworkDependency> frameworkDependencies =
-        FrameworkDependency.frameworkDependenciesForBinding(binding);
+    ImmutableList<FrameworkDependency> frameworkDependencies = binding.frameworkDependencies();
 
     ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
     MapType mapType = MapType.from(binding.key().type());
@@ -1304,7 +1265,7 @@ private CodeBlock potentiallyCast(boolean shouldCast, Class<?> classToCast, Code
    * binding.
    */
   private CodeBlock initializeFactoryForSyntheticOptionalBinding(ContributionBinding binding) {
-    if (binding.dependencies().isEmpty()) {
+    if (binding.explicitDependencies().isEmpty()) {
       verify(
           binding.bindingType().equals(BindingType.PROVISION),
           "Absent optional bindings should be provisions: %s",
diff --git a/compiler/src/main/java/dagger/internal/codegen/Binding.java b/compiler/src/main/java/dagger/internal/codegen/Binding.java
index 159745000..e70b5df8d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Binding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Binding.java
@@ -16,16 +16,25 @@
 
 package dagger.internal.codegen;
 
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static java.util.stream.Collectors.toList;
 import static javax.lang.model.element.Modifier.PUBLIC;
 
 import com.google.auto.common.MoreElements;
+import com.google.auto.value.AutoValue;
 import com.google.common.base.Optional;
+import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
 import dagger.internal.codegen.BindingType.HasBindingType;
+import java.util.Collection;
+import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.Name;
@@ -58,27 +67,148 @@
    * The explicit set of {@link DependencyRequest dependencies} required to satisfy this binding as
    * defined by the user-defined injection sites.
    */
-  abstract ImmutableSet<DependencyRequest> dependencies();
+  abstract ImmutableSet<DependencyRequest> explicitDependencies();
 
   /**
    * The set of {@link DependencyRequest dependencies} that are added by the framework rather than a
    * user-defined injection site. This returns an unmodifiable set.
    */
-  // TODO(gak): this will eventually get migrated to FrameworkDependency
-  Set<DependencyRequest> frameworkDependencies() {
+  // TODO(gak): this will eventually get changed to return a set of FrameworkDependency
+  Set<DependencyRequest> implicitDependencies() {
     return ImmutableSet.of();
   }
 
   /**
    * The set of {@link DependencyRequest dependencies} required to satisfy this binding. This is the
-   * union of {@link #dependencies()} and {@link #frameworkDependencies()}. This returns an
+   * union of {@link #explicitDependencies()} and {@link #implicitDependencies()}. This returns an
    * unmodifiable set.
    */
-  final Set<DependencyRequest> implicitDependencies() {
-    Set<DependencyRequest> frameworkDependencies = frameworkDependencies();
-    return frameworkDependencies.isEmpty()
-        ? dependencies()
-        : Sets.union(frameworkDependencies, dependencies());
+  final Set<DependencyRequest> dependencies() {
+    Set<DependencyRequest> implicitDependencies = implicitDependencies();
+    return implicitDependencies.isEmpty()
+        ? explicitDependencies()
+        : Sets.union(implicitDependencies, explicitDependencies());
+  }
+
+  /**
+   * The framework dependencies of {@code binding}. There will be one element for each different
+   * binding key in the <em>{@linkplain Binding#unresolved() unresolved}</em> version of {@code
+   * binding}.
+   *
+   * <p>For example, given the following modules:
+   *
+   * <pre><code>
+   *   {@literal @Module} abstract class {@literal BaseModule<T>} {
+   *     {@literal @Provides} Foo provideFoo(T t, String string) {
+   *       return …;
+   *     }
+   *   }
+   *
+   *   {@literal @Module} class StringModule extends {@literal BaseModule<String>} {}
+   * </code></pre>
+   *
+   * Both dependencies of {@code StringModule.provideFoo} have the same binding key: {@code String}.
+   * But there are still two dependencies, because in the unresolved binding they have different
+   * binding keys:
+   *
+   * <dl>
+   * <dt>{@code T}
+   * <dd>{@code String t}
+   * <dt>{@code String}
+   * <dd>{@code String string}
+   * </dl>
+   *
+   * <p>Note that the sets returned by this method when called on the same binding will be equal,
+   * and their elements will be in the same order.
+   */
+  /* TODO(dpb): The stable-order postcondition is actually hard to verify in code for two equal
+   * instances of Binding, because it really depends on the order of the binding's dependencies,
+   * and two equal instances of Binding may have the same dependencies in a different order. */
+  ImmutableList<FrameworkDependency> frameworkDependencies() {
+    return ImmutableList.copyOf(
+        dependencyAssociations()
+            .stream()
+            .map(DependencyAssociation::frameworkDependency)
+            .collect(toList()));
+  }
+
+  /**
+   * Associates a {@link FrameworkDependency} with the set of {@link DependencyRequest} instances
+   * that correlate for a binding.
+   */
+  @AutoValue
+  abstract static class DependencyAssociation {
+    abstract FrameworkDependency frameworkDependency();
+
+    abstract ImmutableSet<DependencyRequest> dependencyRequests();
+
+    static DependencyAssociation create(
+        FrameworkDependency frameworkDependency, Iterable<DependencyRequest> dependencyRequests) {
+      return new AutoValue_Binding_DependencyAssociation(
+          frameworkDependency, ImmutableSet.copyOf(dependencyRequests));
+    }
+  }
+
+  /**
+   * Returns the same {@link FrameworkDependency} instances from {@link #frameworkDependencies}, but
+   * with the set of {@link DependencyRequest} instances with which each is associated.
+   *
+   * <p>Ths method returns a list of {@link Map.Entry entries} rather than a {@link Map} or {@link
+   * com.google.common.collect.Multimap} because any given {@link FrameworkDependency} may appear
+   * multiple times if the {@linkplain Binding#unresolved() unresolved} binding requires it. If that
+   * distinction is not important, the entries can be merged into a single mapping.
+   */
+  ImmutableList<DependencyAssociation> dependencyAssociations() {
+    BindingTypeMapper bindingTypeMapper = BindingTypeMapper.forBindingType(bindingType());
+    ImmutableList.Builder<DependencyAssociation> frameworkDependencies = ImmutableList.builder();
+    for (Collection<DependencyRequest> requests : groupByUnresolvedKey()) {
+      frameworkDependencies.add(
+          DependencyAssociation.create(
+              FrameworkDependency.create(
+                  getOnlyElement(
+                      FluentIterable.from(requests)
+                          .transform(DependencyRequest::bindingKey)
+                          .toSet()),
+                  bindingTypeMapper.getBindingType(requests)),
+              requests));
+    }
+    return frameworkDependencies.build();
+  }
+
+  /**
+   * Returns the mapping from each {@linkplain #dependencies dependency} to its associated {@link
+   * FrameworkDependency}.
+   */
+  ImmutableMap<DependencyRequest, FrameworkDependency> dependenciesToFrameworkDependenciesMap() {
+    ImmutableMap.Builder<DependencyRequest, FrameworkDependency> frameworkDependencyMap =
+        ImmutableMap.builder();
+    for (DependencyAssociation dependencyAssociation : dependencyAssociations()) {
+      for (DependencyRequest dependencyRequest : dependencyAssociation.dependencyRequests()) {
+        frameworkDependencyMap.put(dependencyRequest, dependencyAssociation.frameworkDependency());
+      }
+    }
+    return frameworkDependencyMap.build();
+  }
+
+  /**
+   * Groups {@code binding}'s implicit dependencies by their binding key, using the dependency keys
+   * from the {@link Binding#unresolved()} binding if it exists.
+   */
+  private ImmutableList<Collection<DependencyRequest>> groupByUnresolvedKey() {
+    ImmutableSetMultimap.Builder<BindingKey, DependencyRequest> dependenciesByKeyBuilder =
+        ImmutableSetMultimap.builder();
+    Iterator<DependencyRequest> dependencies = dependencies().iterator();
+    Binding unresolved = unresolved().isPresent() ? unresolved().get() : this;
+    Iterator<DependencyRequest> unresolvedDependencies = unresolved.dependencies().iterator();
+    while (dependencies.hasNext()) {
+      dependenciesByKeyBuilder.put(unresolvedDependencies.next().bindingKey(), dependencies.next());
+    }
+    return ImmutableList.copyOf(
+        dependenciesByKeyBuilder
+            .orderValuesBy(SourceFiles.DEPENDENCY_ORDERING)
+            .build()
+            .asMap()
+            .values());
   }
 
   /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index c4161f773..a1305bb9c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -33,6 +33,7 @@
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_OPTIONAL_BINDING;
 import static dagger.internal.codegen.Key.indexByKey;
 import static dagger.internal.codegen.Scope.reusableScope;
+import static java.util.function.Predicate.isEqual;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 
 import com.google.auto.common.MoreTypes;
@@ -289,9 +290,9 @@ private BindingGraph create(
       final ImmutableSetMultimap<Key, DelegateDeclaration> delegateMultibindingDeclarations;
       final Map<BindingKey, ResolvedBindings> resolvedBindings;
       final Deque<BindingKey> cycleStack = new ArrayDeque<>();
-      final Cache<BindingKey, Boolean> dependsOnLocalMultibindingsCache =
+      final Cache<BindingKey, Boolean> bindingKeyDependsOnLocalBindingsCache =
           CacheBuilder.newBuilder().build();
-      final Cache<Binding, Boolean> bindingDependsOnLocalMultibindingsCache =
+      final Cache<Binding, Boolean> bindingDependsOnLocalBindingsCache =
           CacheBuilder.newBuilder().build();
       final Queue<ComponentDescriptor> subcomponentsToResolve = new ArrayDeque<>();
 
@@ -474,26 +475,24 @@ private void addSubcomponentToOwningResolver(ProvisionBinding subcomponentBuilde
       }
 
       /**
-       * If {@code requestKey} is for {@code Map<K, V>} or {@code Map<K, Produced<V>>}, returns all
+       * If {@code key} is for {@code Map<K, V>} or {@code Map<K, Produced<V>>}, returns all
        * multibinding contributions whose key is for {@code Map<K, Provider<V>>} or {@code Map<K,
        * Producer<V>>} with the same qualifier and {@code K} and {@code V}.
        */
-      private FluentIterable<ContributionBinding> multibindingContributionsForValueMap(
-          Key requestKey) {
+      private FluentIterable<ContributionBinding> multibindingContributionsForValueMap(Key key) {
         return keyFactory
-            .implicitFrameworkMapKeys(requestKey)
+            .implicitFrameworkMapKeys(key)
             .transformAndConcat(this::getExplicitMultibindings);
       }
 
       /**
-       * If {@code requestKey} is for {@code Map<K, V>} or {@code Map<K, Produced<V>>}, returns all
+       * If {@code key} is for {@code Map<K, V>} or {@code Map<K, Produced<V>>}, returns all
        * multibinding declarations whose key is for {@code Map<K, Provider<V>>} or {@code Map<K,
        * Producer<V>>} with the same qualifier and {@code K} and {@code V}.
        */
-      private FluentIterable<MultibindingDeclaration> multibindingDeclarationsForValueMap(
-          Key requestKey) {
+      private FluentIterable<MultibindingDeclaration> multibindingDeclarationsForValueMap(Key key) {
         return keyFactory
-            .implicitFrameworkMapKeys(requestKey)
+            .implicitFrameworkMapKeys(key)
             .transformAndConcat(this::getMultibindingDeclarations);
       }
 
@@ -530,14 +529,13 @@ private void addSubcomponentToOwningResolver(ProvisionBinding subcomponentBuilde
       }
 
       private boolean multibindingsRequireProduction(
-          Iterable<ContributionBinding> multibindingContributions, Key requestKey) {
-        if (MapType.isMap(requestKey)) {
-          MapType mapType = MapType.from(requestKey);
+          Iterable<ContributionBinding> multibindingContributions, Key key) {
+        if (MapType.isMap(key)) {
+          MapType mapType = MapType.from(key);
           if (mapType.valuesAreTypeOf(Producer.class) || mapType.valuesAreTypeOf(Produced.class)) {
             return true;
           }
-        } else if (SetType.isSet(requestKey)
-            && SetType.from(requestKey).elementsAreTypeOf(Produced.class)) {
+        } else if (SetType.isSet(key) && SetType.from(key).elementsAreTypeOf(Produced.class)) {
           return true;
         }
         return Iterables.any(multibindingContributions,
@@ -651,8 +649,8 @@ private ContributionBinding createDelegateBinding(DelegateDeclaration delegateDe
       /**
        * Returns the component that should contain the framework field for {@code binding}.
        *
-       * <p>If {@code binding} is either not bound in an ancestor component or depends on
-       * multibinding contributions in this component, returns this component.
+       * <p>If {@code binding} is either not bound in an ancestor component or depends transitively
+       * on bindings in this component, returns this component.
        *
        * <p>Otherwise, resolves {@code request} in this component's parent in order to resolve any
        * multibinding contributions in the parent, and returns the parent-resolved {@link
@@ -661,7 +659,7 @@ private ContributionBinding createDelegateBinding(DelegateDeclaration delegateDe
       private ComponentDescriptor getOwningComponent(
           BindingKey bindingKey, ContributionBinding binding) {
         if (isResolvedInParent(bindingKey, binding)
-            && !new MultibindingDependencies().dependsOnLocalMultibindings(binding)) {
+            && !new LocalDependencyChecker().dependsOnLocalBindings(binding)) {
           ResolvedBindings parentResolvedBindings =
               parentResolver.get().resolvedBindings.get(bindingKey);
           return parentResolvedBindings.owningComponent(binding);
@@ -731,46 +729,55 @@ private boolean isResolvedInParent(BindingKey bindingKey, ContributionBinding bi
       }
 
       /**
-       * Returns the explicit {@link ContributionBinding}s that match the {@code requestKey} from
-       * this and all ancestor resolvers.
+       * Returns the explicit {@link ContributionBinding}s that match the {@code key} from this and
+       * all ancestor resolvers.
        */
-      private ImmutableSet<ContributionBinding> getExplicitBindings(Key requestKey) {
+      private ImmutableSet<ContributionBinding> getExplicitBindings(Key key) {
         ImmutableSet.Builder<ContributionBinding> bindings = ImmutableSet.builder();
         for (Resolver resolver : getResolverLineage()) {
-          bindings.addAll(resolver.getLocalExplicitBindings(requestKey));
+          bindings.addAll(resolver.getLocalExplicitBindings(key));
         }
         return bindings.build();
       }
 
       /**
-       * Returns the explicit {@link ContributionBinding}s that match the {@code requestKey} from
-       * this resolver.
+       * Returns the explicit {@link ContributionBinding}s that match the {@code key} from this
+       * resolver.
        */
-      private ImmutableSet<ContributionBinding> getLocalExplicitBindings(Key requestKey) {
+      private ImmutableSet<ContributionBinding> getLocalExplicitBindings(Key key) {
         return new ImmutableSet.Builder<ContributionBinding>()
-            .addAll(explicitBindings.get(requestKey))
+            .addAll(explicitBindings.get(key))
             .addAll(
                 createDelegateBindings(
-                    delegateDeclarations.get(keyFactory.convertToDelegateKey(requestKey))))
+                    delegateDeclarations.get(keyFactory.convertToDelegateKey(key))))
             .build();
       }
 
       /**
        * Returns the explicit multibinding contributions that contribute to the map or set requested
-       * by {@code requestKey} from this and all ancestor resolvers.
+       * by {@code key} from this and all ancestor resolvers.
        */
-      private ImmutableSet<ContributionBinding> getExplicitMultibindings(Key requestKey) {
+      private ImmutableSet<ContributionBinding> getExplicitMultibindings(Key key) {
         ImmutableSet.Builder<ContributionBinding> multibindings = ImmutableSet.builder();
-        Key delegateDeclarationKey = keyFactory.convertToDelegateKey(requestKey);
         for (Resolver resolver : getResolverLineage()) {
-          multibindings.addAll(resolver.explicitMultibindings.get(requestKey));
-          if (!MapType.isMap(requestKey) || MapType.from(requestKey).valuesAreFrameworkType()) {
-            // There are no @Binds @IntoMap delegate declarations for Map<K, V> requests. All
-            // @IntoMap requests must be for Map<K, Framework<V>>.
-            multibindings.addAll(
-                createDelegateBindings(
-                    resolver.delegateMultibindingDeclarations.get(delegateDeclarationKey)));
-          }
+          multibindings.addAll(resolver.getLocalExplicitMultibindings(key));
+        }
+        return multibindings.build();
+      }
+
+      /**
+       * Returns the explicit multibinding contributions that contribute to the map or set requested
+       * by {@code key} from this resolver.
+       */
+      private ImmutableSet<ContributionBinding> getLocalExplicitMultibindings(Key key) {
+        ImmutableSet.Builder<ContributionBinding> multibindings = ImmutableSet.builder();
+        multibindings.addAll(explicitMultibindings.get(key));
+        if (!MapType.isMap(key) || MapType.from(key).valuesAreFrameworkType()) {
+          // There are no @Binds @IntoMap delegate declarations for Map<K, V> requests. All
+          // @IntoMap requests must be for Map<K, Framework<V>>.
+          multibindings.addAll(
+              createDelegateBindings(
+                  delegateMultibindingDeclarations.get(keyFactory.convertToDelegateKey(key))));
         }
         return multibindings.build();
       }
@@ -843,23 +850,19 @@ void resolve(BindingKey bindingKey) {
         /* If the binding was previously resolved in a supercomponent, then we may be able to avoid
          * resolving it here and just depend on the supercomponent resolution.
          *
-         * 1. If it depends on multibindings with contributions from this subcomponent, then we have
-         *    to resolve it in this subcomponent so that it sees the local contributions.
+         * 1. If it depends transitively on multibinding contributions or optional bindings with
+         *    bindings from this subcomponent, then we have to resolve it in this subcomponent so
+         *    that it sees the local bindings.
          *
          * 2. If there are any explicit bindings in this component, they may conflict with those in
          *    the supercomponent, so resolve them here so that conflicts can be caught.
-         *
-         * 3. If the previously resolved binding is an optional binding, and there are any explicit
-         *    bindings for the underlying key in this component, resolve here so that absent
-         *    bindings in the parent can be overridden by present bindings here.
          */
         if (getPreviouslyResolvedBindings(bindingKey).isPresent()) {
           /* Resolve in the parent in case there are multibinding contributions or conflicts in some
            * component between this one and the previously-resolved one. */
           parentResolver.get().resolve(bindingKey);
-          if (!new MultibindingDependencies().dependsOnLocalMultibindings(bindingKey)
-              && getLocalExplicitBindings(bindingKey.key()).isEmpty()
-              && !hasLocallyPresentOptionalBinding(bindingKey)) {
+          if (!new LocalDependencyChecker().dependsOnLocalBindings(bindingKey)
+              && getLocalExplicitBindings(bindingKey.key()).isEmpty()) {
             /* Cache the inherited parent component's bindings in case resolving at the parent found
              * bindings in some component between this one and the previously-resolved one. */
             ResolvedBindings inheritedBindings =
@@ -873,7 +876,7 @@ void resolve(BindingKey bindingKey) {
         try {
           ResolvedBindings bindings = lookUpBindings(bindingKey);
           for (Binding binding : bindings.ownedBindings()) {
-            for (DependencyRequest dependency : binding.implicitDependencies()) {
+            for (DependencyRequest dependency : binding.dependencies()) {
               resolve(dependency.bindingKey());
             }
           }
@@ -915,34 +918,22 @@ void resolve(BindingKey bindingKey) {
             .immutableCopy();
       }
 
-      /**
-       * Returns {@code true} if {@code bindingKey} was previously resolved to an optional binding
-       * for which there is an explicit present binding in this component.
-       */
-      private boolean hasLocallyPresentOptionalBinding(BindingKey bindingKey) {
-        return Iterables.any(
-            getPreviouslyResolvedBindings(bindingKey).get().contributionBindings(),
-            binding ->
-                binding.bindingKind().equals(SYNTHETIC_OPTIONAL_BINDING)
-                    && !getLocalExplicitBindings(keyFactory.unwrapOptional(binding.key()).get())
-                        .isEmpty());
-      }
-
-      private final class MultibindingDependencies {
+      private final class LocalDependencyChecker {
         private final Set<Object> cycleChecker = new HashSet<>();
 
         /**
-         * Returns {@code true} if {@code bindingKey} previously resolved to multibindings with
-         * contributions declared within this component's modules, or if any of its unscoped
-         * dependencies depend on such local multibindings.
+         * Returns {@code true} if any of the bindings resolved for {@code bindingKey} are
+         * multibindings with contributions declared within this component's modules or optional
+         * bindings with present values declared within this component's modules, or if any of its
+         * unscoped dependencies depend on such bindings.
          *
-         * <p>We don't care about scoped dependencies because they will never depend on
-         * multibindings with contributions from subcomponents.
+         * <p>We don't care about scoped dependencies because they will never depend on bindings
+         * from subcomponents.
          *
          * @throws IllegalArgumentException if {@link #getPreviouslyResolvedBindings(BindingKey)} is
          *     absent
          */
-        boolean dependsOnLocalMultibindings(final BindingKey bindingKey) {
+        boolean dependsOnLocalBindings(BindingKey bindingKey) {
           checkArgument(
               getPreviouslyResolvedBindings(bindingKey).isPresent(),
               "no previously resolved bindings in %s for %s",
@@ -954,17 +945,18 @@ boolean dependsOnLocalMultibindings(final BindingKey bindingKey) {
             return false;
           }
           try {
-            return dependsOnLocalMultibindingsCache.get(
+            return bindingKeyDependsOnLocalBindingsCache.get(
                 bindingKey,
                 () -> {
                   ResolvedBindings previouslyResolvedBindings =
                       getPreviouslyResolvedBindings(bindingKey).get();
-                  if (isMultibindingsWithLocalContributions(previouslyResolvedBindings)) {
+                  if (hasLocalMultibindingContributions(previouslyResolvedBindings)
+                      || hasLocallyPresentOptionalBinding(previouslyResolvedBindings)) {
                     return true;
                   }
 
                   for (Binding binding : previouslyResolvedBindings.bindings()) {
-                    if (dependsOnLocalMultibindings(binding)) {
+                    if (dependsOnLocalBindings(binding)) {
                       return true;
                     }
                   }
@@ -984,20 +976,20 @@ boolean dependsOnLocalMultibindings(final BindingKey bindingKey) {
          * <p>We don't care about non-reusable scoped dependencies because they will never depend on
          * multibindings with contributions from subcomponents.
          */
-        boolean dependsOnLocalMultibindings(final Binding binding) {
+        boolean dependsOnLocalBindings(Binding binding) {
           if (!cycleChecker.add(binding)) {
             return false;
           }
           try {
-            return bindingDependsOnLocalMultibindingsCache.get(
+            return bindingDependsOnLocalBindingsCache.get(
                 binding,
                 () -> {
                   if ((!binding.scope().isPresent()
                           || binding.scope().get().equals(reusableScope(elements)))
                       // TODO(beder): Figure out what happens with production subcomponents.
                       && !binding.bindingType().equals(BindingType.PRODUCTION)) {
-                    for (DependencyRequest dependency : binding.implicitDependencies()) {
-                      if (dependsOnLocalMultibindings(dependency.bindingKey())) {
+                    for (DependencyRequest dependency : binding.dependencies()) {
+                      if (dependsOnLocalBindings(dependency.bindingKey())) {
                         return true;
                       }
                     }
@@ -1009,14 +1001,31 @@ boolean dependsOnLocalMultibindings(final Binding binding) {
           }
         }
 
-        private boolean isMultibindingsWithLocalContributions(ResolvedBindings resolvedBindings) {
-          Key key = resolvedBindings.key();
-          return resolvedBindings.contributionBindings()
-              .stream()
-              .map(ContributionBinding::bindingKind)
-              .anyMatch(SYNTHETIC_MULTIBOUND_KINDS::contains)
-              && !getExplicitMultibindings(key)
-              .equals(parentResolver.get().getExplicitMultibindings(key));
+        /**
+         * Returns {@code true} if {@code resolvedBindings} contains a synthetic multibinding with
+         * at least one contribution declared within this component's modules.
+         */
+        private boolean hasLocalMultibindingContributions(ResolvedBindings resolvedBindings) {
+          return resolvedBindings
+                  .contributionBindings()
+                  .stream()
+                  .map(ContributionBinding::bindingKind)
+                  .anyMatch(SYNTHETIC_MULTIBOUND_KINDS::contains)
+              && !getLocalExplicitMultibindings(resolvedBindings.key()).isEmpty();
+        }
+
+        /**
+         * Returns {@code true} if {@code resolvedBindings} contains a synthetic optional binding
+         * for which there is an explicit present binding in this component.
+         */
+        private boolean hasLocallyPresentOptionalBinding(ResolvedBindings resolvedBindings) {
+          return resolvedBindings
+                  .contributionBindings()
+                  .stream()
+                  .map(ContributionBinding::bindingKind)
+                  .anyMatch(isEqual(SYNTHETIC_OPTIONAL_BINDING))
+              && !getLocalExplicitBindings(keyFactory.unwrapOptional(resolvedBindings.key()).get())
+                  .isEmpty();
         }
       }
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index e4095a92e..831fba7b0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -34,7 +34,6 @@
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MAP;
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_KINDS;
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_MAP;
-import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_OPTIONAL_BINDING;
 import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByAnnotationType;
 import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByMapKey;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_INJECT_WILDCARD_TYPE;
@@ -75,7 +74,6 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Iterables;
-import com.google.common.collect.Iterators;
 import com.google.common.collect.LinkedHashMultiset;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Multimap;
@@ -160,40 +158,9 @@ Element entryPointElement() {
       return path.getFirst().dependencyRequest().requestElement().get();
     }
 
-    /** The current dependency request, which is a transitive dependency of the entry point. */
-    DependencyRequest currentDependencyRequest() {
-      return path.getLast().dependencyRequest();
-    }
-
-    /**
-     * The resolved bindings for the {@linkplain #currentDependencyRequest() current dependency
-     * request.
-     */
-    ResolvedBindings currentResolvedBindings() {
-      return path.getLast().resolvedBindings();
-    }
-
-    /**
-     * The binding that depends on the {@linkplain #currentDependencyRequest() current request}.
-     *
-     * @throws IllegalStateException if there are fewer than two requests in the path
-     */
-    ResolvedBindings previousResolvedBindings() {
-      checkState(size() > 1);
-      return Iterators.get(path.descendingIterator(), 1).resolvedBindings();
-    }
-
-    /**
-     * Returns the contribution bindings resolved for the second-most-recent request in the given
-     * path; that is, returns those bindings that depend on the latest request in the path.
-     */
-    FluentIterable<ContributionBinding> contributionsDependingOnLatestRequest() {
-      if (size() <= 1) {
-        return FluentIterable.from(ImmutableList.<ContributionBinding>of());
-      }
-      return FluentIterable.from(previousResolvedBindings().bindings())
-          .filter(binding -> binding.implicitDependencies().contains(currentDependencyRequest()))
-          .filter(ContributionBinding.class);
+    /** The the current dependency request and resolved bindings. */
+    ResolvedRequest current() {
+      return path.getLast();
     }
 
     /**
@@ -202,7 +169,7 @@ ResolvedBindings previousResolvedBindings() {
      * path.
      */
     boolean hasCycle() {
-      return keyPath.count(currentDependencyRequest().bindingKey()) > 1;
+      return keyPath.count(current().dependencyRequest().bindingKey()) > 1;
     }
 
     /**
@@ -215,7 +182,7 @@ boolean hasCycle() {
     FluentIterable<ResolvedRequest> cycle() {
       checkState(hasCycle(), "no cycle");
       return resolvedRequests()
-          .skip(indexOf(keyPath, Predicates.equalTo(currentDependencyRequest().bindingKey())));
+          .skip(indexOf(keyPath, Predicates.equalTo(current().dependencyRequest().bindingKey())));
     }
 
     /**
@@ -229,7 +196,7 @@ void push(DependencyRequest request, ResolvedBindings resolvedBindings) {
               resolvedBindings,
               path.isEmpty()
                   ? Optional.<ResolvedBindings>absent()
-                  : Optional.of(currentResolvedBindings())));
+                  : Optional.of(current().resolvedBindings())));
       keyPath.add(request.bindingKey());
     }
 
@@ -243,7 +210,7 @@ void pop() {
      * requests, and returns {@code true} if the set didn't already contain it.
      */
     boolean visitCurrentDependencyRequest() {
-      return resolvedDependencyRequests.add(currentDependencyRequest());
+      return resolvedDependencyRequests.add(current().dependencyRequest());
     }
 
     int size() {
@@ -360,14 +327,15 @@ private void traverseDependencyRequest(DependencyRequest request, DependencyPath
           validateResolvedBindings(path);
 
           // Validate all dependencies within the component that owns the binding.
-          path.currentResolvedBindings()
+          path.current()
+              .resolvedBindings()
               .allBindings()
               .asMap()
               .forEach(
                   (component, bindings) -> {
                     Validation validation = validationForComponent(component);
                     for (Binding binding : bindings) {
-                      for (DependencyRequest nextRequest : binding.implicitDependencies()) {
+                      for (DependencyRequest nextRequest : binding.dependencies()) {
                         validation.traverseDependencyRequest(nextRequest, path);
                       }
                     }
@@ -404,7 +372,7 @@ private Validation validationForComponent(ComponentDescriptor component) {
      * Reports errors if the set of bindings resolved is inconsistent with the type of the binding.
      */
     private void validateResolvedBindings(DependencyPath path) {
-      ResolvedBindings resolvedBindings = path.currentResolvedBindings();
+      ResolvedBindings resolvedBindings = path.current().resolvedBindings();
       if (resolvedBindings.isEmpty()) {
         reportMissingBinding(path);
         return;
@@ -446,7 +414,7 @@ private void validateResolvedBindings(DependencyPath path) {
             // binding to the implementation
             if (!contributionBinding.key().equals(productionImplementationExecutorKey)) {
               Key productionExecutorKey = keyFactory.forProductionExecutor();
-              for (DependencyRequest request : contributionBinding.dependencies()) {
+              for (DependencyRequest request : contributionBinding.explicitDependencies()) {
                 if (request.key().equals(productionExecutorKey)
                     || request.key().equals(productionImplementationExecutorKey)) {
                   reportDependsOnProductionExecutor(path);
@@ -527,7 +495,7 @@ private ResolvedBindings inlineContributionsWithoutBindingElements(
           if (binding.bindingElement().isPresent()) {
             contributions.put(bindingEntry);
           } else {
-            for (DependencyRequest dependency : binding.dependencies()) {
+            for (DependencyRequest dependency : binding.explicitDependencies()) {
               queue.add(owningGraph.resolvedBindings().get(dependency.bindingKey()));
             }
           }
@@ -558,7 +526,7 @@ private ResolvedBindings inlineContributionsWithoutBindingElements(
      * nullable.
      */
     private void validateNullability(DependencyPath path, Set<ContributionBinding> bindings) {
-      if (path.currentDependencyRequest().isNullable()) {
+      if (path.current().dependencyRequest().isNullable()) {
         return;
       }
 
@@ -567,11 +535,15 @@ private void validateNullability(DependencyPath path, Set<ContributionBinding> b
        * (Maybe this happens if the code was already compiled before this point?)
        * ... we manually print out the request in that case, otherwise the error
        * message is kind of useless. */
-      String typeName = TypeName.get(path.currentDependencyRequest().key().type()).toString();
+      String typeName = TypeName.get(path.current().dependencyRequest().key().type()).toString();
 
       for (ContributionBinding binding : bindings) {
         if (binding.nullableType().isPresent()) {
-          owningReportBuilder(path.contributionsDependingOnLatestRequest().append(binding))
+          owningReportBuilder(
+                  path.current()
+                      .dependentBindings()
+                      .filter(ContributionBinding.class)
+                      .append(binding))
               .addItem(
                   nullableToNonNullable(typeName, bindingDeclarationFormatter.format(binding))
                       + "\n at: "
@@ -589,7 +561,7 @@ private void validateMapKeys(
           binding);
       ImmutableSet.Builder<ContributionBinding> multibindingContributionsBuilder =
           ImmutableSet.builder();
-      for (DependencyRequest dependency : binding.dependencies()) {
+      for (DependencyRequest dependency : binding.explicitDependencies()) {
         multibindingContributionsBuilder.add(
             subject.resolvedBindings().get(dependency.bindingKey()).contributionBinding());
       }
@@ -1015,7 +987,7 @@ private void reportProviderMayNotDependOnProducer(
      * filename. Not static because it uses the instance field types.
      */
     private StringBuilder requiresErrorMessageBase(DependencyPath path) {
-      Key key = path.currentDependencyRequest().key();
+      Key key = path.current().dependencyRequest().key();
       String requiresErrorMessageFormat;
       // TODO(dpb): Check for wildcard injection somewhere else first?
       if (key.type().getKind().equals(TypeKind.WILDCARD)) {
@@ -1052,7 +1024,7 @@ private void reportMissingBinding(DependencyPath path) {
           requiresErrorMessageBase(path).append(dependencyRequestFormatter.toDependencyTrace(path));
       for (String suggestion :
           MissingBindingSuggestions.forKey(
-              topLevelGraph(), path.currentDependencyRequest().bindingKey())) {
+              topLevelGraph(), path.current().dependencyRequest().bindingKey())) {
         errorMessage.append('\n').append(suggestion);
       }
       topLevelReport().addError(errorMessage.toString(), path.entryPointElement());
@@ -1068,7 +1040,7 @@ private void reportDependsOnProductionExecutor(DependencyPath path) {
 
     @SuppressWarnings("resource") // Appendable is a StringBuilder.
     private void reportDuplicateBindings(DependencyPath path) {
-      ResolvedBindings resolvedBindings = path.currentResolvedBindings();
+      ResolvedBindings resolvedBindings = path.current().resolvedBindings();
       if (FluentIterable.from(resolvedBindings.contributionBindings())
           .transform(ContributionBinding::bindingKind)
           // TODO(dpb): Kill with fire.
@@ -1132,7 +1104,7 @@ private void reportMultipleContributionTypes(DependencyPath path) {
       new Formatter(builder)
           .format(
               MULTIPLE_CONTRIBUTION_TYPES_FOR_KEY_FORMAT, formatCurrentDependencyRequestKey(path));
-      ResolvedBindings resolvedBindings = path.currentResolvedBindings();
+      ResolvedBindings resolvedBindings = path.current().resolvedBindings();
       ImmutableListMultimap<ContributionType, BindingDeclaration> declarationsByType =
           declarationsByType(resolvedBindings);
       verify(
@@ -1226,11 +1198,15 @@ public boolean apply(ResolvedRequest resolvedRequest) {
                   if (dependencyRequest.requestElement().isPresent()) {
                     // Non-synthetic request
                     return breaksCycle(dependencyRequest.key().type(), dependencyRequest.kind());
-                  } else if (!resolvedRequest.dependentOptionalBindingDeclarations().isEmpty()) {
+                  } else if (!resolvedRequest
+                      .dependentResolvedBindings()
+                      .transform(ResolvedBindings::optionalBindingDeclarations)
+                      .or(ImmutableSet.of())
+                      .isEmpty()) {
                     // Synthetic request from a @BindsOptionalOf: test the type inside the Optional.
                     // Optional<Provider or Lazy or Provider of Lazy> breaks the cycle.
                     TypeMirror requestedOptionalType =
-                        resolvedRequest.dependentBindings().get().key().type();
+                        resolvedRequest.dependentResolvedBindings().get().key().type();
                     DependencyRequest.KindAndType kindAndType =
                         DependencyRequest.extractKindAndType(
                             OptionalType.from(requestedOptionalType).valueType());
@@ -1298,7 +1274,7 @@ private void appendIndentedComponentsList(StringBuilder message, Iterable<TypeEl
   private boolean doesPathRequireProvisionOnly(DependencyPath path) {
     if (path.size() == 1) {
       // if this is an entry-point, then we check the request
-      switch (path.currentDependencyRequest().kind()) {
+      switch (path.current().dependencyRequest().kind()) {
         case INSTANCE:
         case PROVIDER:
         case LAZY:
@@ -1323,7 +1299,10 @@ private boolean doesPathRequireProvisionOnly(DependencyPath path) {
    */
   private FluentIterable<ContributionBinding> provisionsDependingOnLatestRequest(
       DependencyPath path) {
-    return path.contributionsDependingOnLatestRequest().filter(PROVISION::isOfType);
+    return path.current()
+        .dependentBindings()
+        .filter(ContributionBinding.class)
+        .filter(PROVISION::isOfType);
   }
 
   private String formatContributionType(ContributionType type) {
@@ -1341,7 +1320,7 @@ private String formatContributionType(ContributionType type) {
   }
 
   private String formatCurrentDependencyRequestKey(DependencyPath path) {
-    return keyFormatter.format(path.currentDependencyRequest().key());
+    return keyFormatter.format(path.current().dependencyRequest().key());
   }
 
   @AutoValue
@@ -1355,23 +1334,16 @@ private String formatCurrentDependencyRequestKey(DependencyPath path) {
      * The {@link #resolvedBindings()} of the previous entry in the {@link DependencyPath}. One of
      * these bindings depends directly on {@link #dependencyRequest()}.
      */
-    abstract Optional<ResolvedBindings> dependentBindings();
+    abstract Optional<ResolvedBindings> dependentResolvedBindings();
 
     /**
-     * If the binding that depends on {@link #dependencyRequest()} is a synthetic optional binding,
-     * returns its {@code @BindsOptionalOf} methods.
+     * Returns the bindings that depend on this {@linkplain #dependencyRequest() dependency
+     * request}.
      */
-    ImmutableSet<OptionalBindingDeclaration> dependentOptionalBindingDeclarations() {
-      if (dependentBindings().isPresent()) {
-        ResolvedBindings dependentBindings = dependentBindings().get();
-        for (ContributionBinding dependentBinding : dependentBindings.contributionBindings()) {
-          if (dependentBinding.bindingKind().equals(SYNTHETIC_OPTIONAL_BINDING)
-              && dependentBinding.dependencies().contains(dependencyRequest())) {
-            return dependentBindings.optionalBindingDeclarations();
-          }
-        }
-      }
-      return ImmutableSet.<OptionalBindingDeclaration>of();
+    FluentIterable<? extends Binding> dependentBindings() {
+      return FluentIterable.from(dependentResolvedBindings().asSet())
+          .transformAndConcat(ResolvedBindings::bindings)
+          .filter(binding -> binding.dependencies().contains(dependencyRequest()));
     }
 
     private static ResolvedRequest create(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index da7398b3a..235b99a2e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -197,13 +197,13 @@ FactoryCreationStrategy factoryCreationStrategy() {
       case SYNTHETIC_DELEGATE_BINDING:
         return DELEGATE;
       case PROVISION:
-        return implicitDependencies().isEmpty() && !requiresModuleInstance()
+        return dependencies().isEmpty() && !requiresModuleInstance()
             ? ENUM_INSTANCE
             : CLASS_CONSTRUCTOR;
       case INJECTION:
       case SYNTHETIC_MULTIBOUND_SET:
       case SYNTHETIC_MULTIBOUND_MAP:
-        return implicitDependencies().isEmpty() ? ENUM_INSTANCE : CLASS_CONSTRUCTOR;
+        return dependencies().isEmpty() ? ENUM_INSTANCE : CLASS_CONSTRUCTOR;
       default:
         return CLASS_CONSTRUCTOR;
     }
@@ -271,9 +271,9 @@ final TypeMirror factoryType() {
 
     abstract B key(Key key);
 
-    abstract B dependencies(Iterable<DependencyRequest> dependencies);
+    abstract B explicitDependencies(Iterable<DependencyRequest> dependencies);
 
-    abstract B dependencies(DependencyRequest... dependencies);
+    abstract B explicitDependencies(DependencyRequest... dependencies);
 
     abstract B nullableType(Optional<DeclaredType> nullableType);
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
index bbd10b320..3848f6727 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
@@ -90,7 +90,10 @@ String toDependencyTrace(DependencyPath dependencyPath) {
                 .transform(
                     resolvedRequest -> {
                       ImmutableSet<OptionalBindingDeclaration> optionalBindingDeclarations =
-                          resolvedRequest.dependentOptionalBindingDeclarations();
+                          resolvedRequest
+                              .dependentResolvedBindings()
+                              .transform(ResolvedBindings::optionalBindingDeclarations)
+                              .or(ImmutableSet.of());
                       return optionalBindingDeclarations.isEmpty()
                           ? format(resolvedRequest.dependencyRequest())
                           : formatSyntheticOptionalBindingDependency(optionalBindingDeclarations);
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 653a0538a..332562b61 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -221,7 +221,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     }
 
     List<CodeBlock> parameters = Lists.newArrayList();
-    for (DependencyRequest dependency : binding.dependencies()) {
+    for (DependencyRequest dependency : binding.explicitDependencies()) {
       parameters.add(
           frameworkTypeUsageStatement(
               CodeBlock.of("$N", fields.get(dependency.bindingKey())), dependency.kind()));
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkDependency.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkDependency.java
index 1e0b02e5e..0cd593d6b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkDependency.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkDependency.java
@@ -16,16 +16,7 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.collect.Iterables.getOnlyElement;
-
 import com.google.auto.value.AutoValue;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.ImmutableSetMultimap;
-import java.util.Collection;
-import java.util.Iterator;
 import javax.inject.Provider;
 
 /**
@@ -65,90 +56,8 @@
     return bindingType().frameworkClass();
   }
 
-  /**
-   * The dependency requests that are all satisfied by one framework instance.
-   */
-  abstract ImmutableSet<DependencyRequest> dependencyRequests();
-
-  /**
-   * The framework dependencies of {@code binding}. There will be one element for each
-   * different binding key in the <em>{@linkplain Binding#unresolved() unresolved}</em> version of
-   * {@code binding}.
-   *
-   * <p>For example, given the following modules:
-   * <pre><code>
-   *   {@literal @Module} abstract class {@literal BaseModule<T>} {
-   *     {@literal @Provides} Foo provideFoo(T t, String string) {
-   *       return …;
-   *     }
-   *   }
-   *
-   *   {@literal @Module} class StringModule extends {@literal BaseModule<String>} {}
-   * </code></pre>
-   *
-   * Both dependencies of {@code StringModule.provideFoo} have the same binding key:
-   * {@code String}. But there are still two dependencies, because in the unresolved binding they
-   * have different binding keys:
-   *
-   * <dl>
-   * <dt>{@code T} <dd>{@code String t}
-   * <dt>{@code String} <dd>{@code String string}
-   * </dl>
-   * 
-   * <p>Note that the sets returned by this method when called on the same binding will be equal,
-   * and their elements will be in the same order.
-   */
-  /* TODO(dpb): The stable-order postcondition is actually hard to verify in code for two equal
-   * instances of Binding, because it really depends on the order of the binding's dependencies,
-   * and two equal instances of Binding may have the same dependencies in a different order. */
-  static ImmutableSet<FrameworkDependency> frameworkDependenciesForBinding(Binding binding) {
-    BindingTypeMapper bindingTypeMapper =
-        BindingTypeMapper.forBindingType(binding.bindingType());
-    ImmutableSet.Builder<FrameworkDependency> frameworkDependencies = ImmutableSet.builder();
-    for (Collection<DependencyRequest> requests : groupByUnresolvedKey(binding)) {
-      frameworkDependencies.add(
-          new AutoValue_FrameworkDependency(
-              getOnlyElement(
-                  FluentIterable.from(requests).transform(DependencyRequest::bindingKey).toSet()),
-              bindingTypeMapper.getBindingType(requests),
-              ImmutableSet.copyOf(requests)));
-    }
-    return frameworkDependencies.build();
-  }
-
-  /** Indexes {@code dependencies} by their {@link #dependencyRequests()}. */
-  static ImmutableMap<DependencyRequest, FrameworkDependency> indexByDependencyRequest(
-      Iterable<FrameworkDependency> dependencies) {
-    ImmutableMap.Builder<DependencyRequest, FrameworkDependency> frameworkDependencyMap =
-        ImmutableMap.builder();
-    for (FrameworkDependency dependency : dependencies) {
-      for (DependencyRequest request : dependency.dependencyRequests()) {
-        frameworkDependencyMap.put(request, dependency);
-      }
-    }
-    return frameworkDependencyMap.build();
-  }
-
-  /**
-   * Groups {@code binding}'s implicit dependencies by their binding key, using the dependency keys
-   * from the {@link Binding#unresolved()} binding if it exists.
-   */
-  private static ImmutableList<Collection<DependencyRequest>> groupByUnresolvedKey(
-      Binding binding) {
-    ImmutableSetMultimap.Builder<BindingKey, DependencyRequest> dependenciesByKeyBuilder =
-        ImmutableSetMultimap.builder();
-    Iterator<DependencyRequest> dependencies = binding.implicitDependencies().iterator();
-    Binding unresolved = binding.unresolved().isPresent() ? binding.unresolved().get() : binding;
-    Iterator<DependencyRequest> unresolvedDependencies =
-        unresolved.implicitDependencies().iterator();
-    while (dependencies.hasNext()) {
-      dependenciesByKeyBuilder.put(unresolvedDependencies.next().bindingKey(), dependencies.next());
-    }
-    return ImmutableList.copyOf(
-        dependenciesByKeyBuilder
-            .orderValuesBy(SourceFiles.DEPENDENCY_ORDERING)
-            .build()
-            .asMap()
-            .values());
+  /** Returns a new instance with the given key and type. */
+  static FrameworkDependency create(BindingKey bindingKey, BindingType bindingType) {
+    return new AutoValue_FrameworkDependency(bindingKey, bindingType);
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/HasBindingMembers.java b/compiler/src/main/java/dagger/internal/codegen/HasBindingMembers.java
new file mode 100644
index 000000000..bc260d65d
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/HasBindingMembers.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import javax.annotation.Nullable;
+
+/** An object which associates a {@link MemberSelect} instance with a {@link BindingKey}. */
+// TODO(gak): this isn't a particularly good abstraction. This should go away when MS is reworked.
+interface HasBindingMembers {
+
+  /**
+   * Returns the {@link MemberSelect} associated with the given {@link BindingKey} or {@code null}
+   * if no association exists.
+   */
+  @Nullable
+  MemberSelect getMemberSelect(BindingKey bindingKey);
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index c2a53148d..c759af798 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -220,9 +220,8 @@ private static void assignField(MethodSpec.Builder constructorBuilder, FieldSpec
   /** Returns a list of dependencies that are generated asynchronously. */
   private static ImmutableList<DependencyRequest> asyncDependencies(Binding binding) {
     final ImmutableMap<DependencyRequest, FrameworkDependency> frameworkDependencies =
-        FrameworkDependency.indexByDependencyRequest(
-            FrameworkDependency.frameworkDependenciesForBinding(binding));
-    return FluentIterable.from(binding.implicitDependencies())
+        binding.dependenciesToFrameworkDependenciesMap();
+    return FluentIterable.from(binding.dependencies())
         .filter(
             dependency ->
                 isAsyncDependency(dependency)
@@ -317,7 +316,7 @@ String applyArgName() {
     @Override
     ImmutableList<CodeBlock> parameterCodeBlocks() {
       ImmutableList.Builder<CodeBlock> parameterCodeBlocks = ImmutableList.builder();
-      for (DependencyRequest dependency : binding.dependencies()) {
+      for (DependencyRequest dependency : binding.explicitDependencies()) {
         parameterCodeBlocks.add(
             frameworkTypeUsageStatement(
                 CodeBlock.of("$N", fields.get(dependency.bindingKey())), dependency.kind()));
@@ -355,7 +354,7 @@ String applyArgName() {
     @Override
     ImmutableList<CodeBlock> parameterCodeBlocks() {
       ImmutableList.Builder<CodeBlock> parameterCodeBlocks = ImmutableList.builder();
-      for (DependencyRequest dependency : binding.dependencies()) {
+      for (DependencyRequest dependency : binding.explicitDependencies()) {
         // We really want to compare instances here, because asyncDependency is an element in the
         // set binding.dependencies().
         if (dependency == asyncDependency) {
@@ -441,7 +440,7 @@ private static TypeName asyncDependencyType(DependencyRequest dependency) {
       ProductionBinding binding, ImmutableMap<BindingKey, FieldSpec> fields, String listArgName) {
     int argIndex = 0;
     ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
-    for (DependencyRequest dependency : binding.dependencies()) {
+    for (DependencyRequest dependency : binding.explicitDependencies()) {
       if (isAsyncDependency(dependency)) {
         codeBlocks.add(
             CodeBlock.of(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index a25d339a2..bbcabc679 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -59,7 +59,7 @@ public BindingType bindingType() {
   }
 
   @Override
-  Set<DependencyRequest> frameworkDependencies() {
+  Set<DependencyRequest> implicitDependencies() {
     return new ImmutableSet.Builder<DependencyRequest>()
         .addAll(executorRequest().asSet())
         .addAll(monitorRequest().asSet())
@@ -101,7 +101,7 @@ public BindingType bindingType() {
 
   private static Builder builder() {
     return new AutoValue_ProductionBinding.Builder()
-        .dependencies(ImmutableList.<DependencyRequest>of())
+        .explicitDependencies(ImmutableList.<DependencyRequest>of())
         .thrownTypes(ImmutableList.<TypeMirror>of());
   }
 
@@ -163,7 +163,7 @@ ProductionBinding forProducesMethod(
           .bindingElement(producesMethod)
           .contributingModule(contributedBy)
           .key(key)
-          .dependencies(dependencies)
+          .explicitDependencies(dependencies)
           .wrappedMapKey(wrapOptionalInEquivalence(getMapKey(producesMethod)))
           .bindingKind(Kind.PRODUCTION)
           .productionKind(productionKind)
@@ -190,7 +190,7 @@ ProductionBinding syntheticMapOfValuesOrProducedBinding(Key mapOfValuesOrProduce
       return ProductionBinding.builder()
           .contributionType(ContributionType.UNIQUE)
           .key(mapOfValuesOrProducedKey)
-          .dependencies(requestForMapOfProducers)
+          .explicitDependencies(requestForMapOfProducers)
           .bindingKind(Kind.SYNTHETIC_MAP)
           .build();
     }
@@ -206,7 +206,7 @@ ProductionBinding syntheticMultibinding(
       return ProductionBinding.builder()
           .contributionType(ContributionType.UNIQUE)
           .key(key)
-          .dependencies(
+          .explicitDependencies(
               dependencyRequestFactory.forMultibindingContributions(multibindingContributions))
           .bindingKind(Kind.forMultibindingKey(key))
           .build();
@@ -233,7 +233,7 @@ ProductionBinding delegate(
           .bindingElement(delegateDeclaration.bindingElement().get())
           .contributingModule(delegateDeclaration.contributingModule().get())
           .key(keyFactory.forDelegateBinding(delegateDeclaration, Producer.class))
-          .dependencies(delegateDeclaration.delegateRequest())
+          .explicitDependencies(delegateDeclaration.delegateRequest())
           .nullableType(delegateBinding.nullableType())
           .wrappedMapKey(delegateDeclaration.wrappedMapKey())
           .bindingKind(Kind.SYNTHETIC_DELEGATE_BINDING)
@@ -249,7 +249,7 @@ ProductionBinding syntheticPresentBinding(Key key) {
           .contributionType(ContributionType.UNIQUE)
           .key(key)
           .bindingKind(Kind.SYNTHETIC_OPTIONAL_BINDING)
-          .dependencies(
+          .explicitDependencies(
               dependencyRequestFactory.forSyntheticPresentOptionalBinding(
                   key, DependencyRequest.Kind.PRODUCER))
           .build();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index b6e459ab9..d913c4351 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -60,7 +60,7 @@
 abstract class ProvisionBinding extends ContributionBinding {
 
   @Override
-  Set<DependencyRequest> frameworkDependencies() {
+  Set<DependencyRequest> implicitDependencies() {
     return membersInjectionRequest().asSet();
   }
 
@@ -80,7 +80,7 @@ public BindingType bindingType() {
 
   private static Builder builder() {
     return new AutoValue_ProvisionBinding.Builder()
-        .dependencies(ImmutableSet.<DependencyRequest>of());
+        .explicitDependencies(ImmutableSet.<DependencyRequest>of());
   }
 
   abstract Builder toBuilder();
@@ -152,7 +152,7 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
               .contributionType(ContributionType.UNIQUE)
               .bindingElement(constructorElement)
               .key(key)
-              .dependencies(dependencies)
+              .explicitDependencies(dependencies)
               .membersInjectionRequest(membersInjectionRequest)
               .bindingKind(Kind.INJECTION)
               .scope(Scope.uniqueScopeOf(constructorElement.getEnclosingElement()));
@@ -199,7 +199,7 @@ ProvisionBinding forProvidesMethod(
           .bindingElement(providesMethod)
           .contributingModule(contributedBy)
           .key(key)
-          .dependencies(dependencies)
+          .explicitDependencies(dependencies)
           .nullableType(ConfigurationAnnotations.getNullableType(providesMethod))
           .wrappedMapKey(wrapOptionalInEquivalence(getMapKey(providesMethod)))
           .bindingKind(Kind.PROVISION)
@@ -217,7 +217,7 @@ ProvisionBinding syntheticMapOfValuesBinding(Key mapOfValuesKey) {
       return ProvisionBinding.builder()
           .contributionType(ContributionType.UNIQUE)
           .key(mapOfValuesKey)
-          .dependencies(requestForMapOfProviders)
+          .explicitDependencies(requestForMapOfProviders)
           .bindingKind(Kind.SYNTHETIC_MAP)
           .build();
     }
@@ -233,7 +233,7 @@ ProvisionBinding syntheticMultibinding(
       return ProvisionBinding.builder()
           .contributionType(ContributionType.UNIQUE)
           .key(key)
-          .dependencies(
+          .explicitDependencies(
               dependencyRequestFactory.forMultibindingContributions(multibindingContributions))
           .bindingKind(Kind.forMultibindingKey(key))
           .build();
@@ -307,7 +307,7 @@ ProvisionBinding missingDelegate(DelegateDeclaration delegateDeclaration) {
           .bindingElement(delegateDeclaration.bindingElement().get())
           .contributingModule(delegateDeclaration.contributingModule().get())
           .key(keyFactory.forDelegateBinding(delegateDeclaration, Provider.class))
-          .dependencies(delegateDeclaration.delegateRequest())
+          .explicitDependencies(delegateDeclaration.delegateRequest())
           .wrappedMapKey(delegateDeclaration.wrappedMapKey())
           .bindingKind(Kind.SYNTHETIC_DELEGATE_BINDING)
           .scope(Scope.uniqueScopeOf(delegateDeclaration.bindingElement().get()));
@@ -332,7 +332,7 @@ ProvisionBinding syntheticAbsentBinding(Key key) {
     ProvisionBinding syntheticPresentBinding(Key key) {
       return syntheticAbsentBinding(key)
           .toBuilder()
-          .dependencies(
+          .explicitDependencies(
               dependencyRequestFactory.forSyntheticPresentOptionalBinding(
                   key, DependencyRequest.Kind.PROVIDER))
           .build();
diff --git a/compiler/src/main/java/dagger/internal/codegen/RequestFulfillmentRegistry.java b/compiler/src/main/java/dagger/internal/codegen/RequestFulfillmentRegistry.java
new file mode 100644
index 000000000..941d314e6
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/RequestFulfillmentRegistry.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.collect.Maps.newLinkedHashMapWithExpectedSize;
+import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
+import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
+
+import com.google.common.collect.ImmutableMap;
+import java.util.Map;
+
+/**
+ * A registry that associates a {@link BindingKey} with a {@link RequestFulfillment}. The registry
+ * is responsible for choosing the most appropriate {@link RequestFulfillment} implementation based
+ * on the properties of the binding and how it is used throughout the component.
+ */
+final class RequestFulfillmentRegistry {
+  private final ImmutableMap<BindingKey, ResolvedBindings> resolvedBindingsMap;
+  private final HasBindingMembers hasBindingMembers;
+  /** This map is mutated as {@link #getRequestFulfillment} is invoked. */
+  private final Map<BindingKey, RequestFulfillment> requestFulfillments;
+
+  RequestFulfillmentRegistry(
+      ImmutableMap<BindingKey, ResolvedBindings> resolvedBindingsMap,
+      HasBindingMembers hasBindingMembers) {
+    this.resolvedBindingsMap = resolvedBindingsMap;
+    this.hasBindingMembers = hasBindingMembers;
+    this.requestFulfillments = newLinkedHashMapWithExpectedSize(resolvedBindingsMap.size());
+  }
+
+  /** Returns a {@link RequestFulfillment} implementation for the given {@link BindingKey} */
+  RequestFulfillment getRequestFulfillment(BindingKey bindingKey) {
+    return requestFulfillments.computeIfAbsent(bindingKey, this::createRequestFulfillment);
+  }
+
+  private RequestFulfillment createRequestFulfillment(BindingKey bindingKey) {
+    /* TODO(gak): it is super convoluted that we create the member selects separately and then
+     * look them up again this way. Now that we have RequestFulfillment, the next step is to
+     * create it and the MemberSelect and the field on demand rather than in a first pass. */
+    MemberSelect memberSelect = hasBindingMembers.getMemberSelect(bindingKey);
+    ResolvedBindings resolvedBindings = resolvedBindingsMap.get(bindingKey);
+    switch (resolvedBindings.bindingType()) {
+      case MEMBERS_INJECTION:
+        return new MembersInjectorRequestFulfillment(bindingKey, memberSelect);
+      case PRODUCTION:
+        return new ProducerFieldRequestFulfillment(bindingKey, memberSelect);
+      case PROVISION:
+        ProvisionBinding provisionBinding =
+            (ProvisionBinding) resolvedBindings.contributionBinding();
+
+        ProviderFieldRequestFulfillment providerFieldRequestFulfillment =
+            new ProviderFieldRequestFulfillment(bindingKey, memberSelect);
+        if (provisionBinding.implicitDependencies().isEmpty()
+            && !provisionBinding.scope().isPresent()
+            && !provisionBinding.requiresModuleInstance()
+            && provisionBinding.bindingElement().isPresent()
+            && (provisionBinding.bindingKind().equals(INJECTION)
+                || provisionBinding.bindingKind().equals(PROVISION))) {
+          return new SimpleMethodRequestFulfillment(
+              bindingKey, provisionBinding, providerFieldRequestFulfillment, this);
+        }
+        return providerFieldRequestFulfillment;
+      default:
+        throw new AssertionError();
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java b/compiler/src/main/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java
index 9eb91f534..e6f040984 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java
@@ -19,12 +19,20 @@
 import static com.google.auto.common.MoreElements.asExecutable;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkState;
+import static dagger.internal.codegen.Accessibility.isElementAccessibleFrom;
+import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+import static java.util.stream.Collectors.toList;
 import static javax.lang.model.element.Modifier.STATIC;
 
 import com.google.common.util.concurrent.Futures;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.SimpleTypeVisitor8;
 
 /**
  * A request fulfillment implementation that invokes methods or constructors directly to fulfill
@@ -32,47 +40,116 @@
  * delegates to one that uses a {@link javax.inject.Provider}.
  */
 final class SimpleMethodRequestFulfillment extends RequestFulfillment {
+
   private final ProvisionBinding provisionBinding;
   private final RequestFulfillment providerDelegate;
+  private final RequestFulfillmentRegistry registry;
 
   SimpleMethodRequestFulfillment(
       BindingKey bindingKey,
       ProvisionBinding provisionBinding,
-      RequestFulfillment providerDelegate) {
+      RequestFulfillment providerDelegate,
+      RequestFulfillmentRegistry registry) {
     super(bindingKey);
-    checkArgument(provisionBinding.implicitDependencies().isEmpty());
+    checkArgument(
+        provisionBinding.implicitDependencies().isEmpty(),
+        "framework deps are not currently supported");
     checkArgument(!provisionBinding.scope().isPresent());
     checkArgument(!provisionBinding.requiresModuleInstance());
     checkArgument(provisionBinding.bindingElement().isPresent());
     this.provisionBinding = provisionBinding;
     this.providerDelegate = providerDelegate;
+    this.registry = registry;
   }
 
   @Override
   CodeBlock getSnippetForDependencyRequest(DependencyRequest request, ClassName requestingClass) {
+    String requestingPackage = requestingClass.packageName();
+    /* This is where we do some checking to make sure we honor and/or dodge accessibility
+     * restrictions:
+     *
+     * 1. Check to make sure that the method/constructor that we're trying to invoke is accessible.
+     * 2. Check that the *raw type* of each parameter is accessible.  If something is only
+     *    inaccessible due to a type variable, we do a raw type cast just like we do for framework
+     *    types.
+     */
+    // TODO(gak): the accessibility limitation here needs to be addressed
+    if (!isElementAccessibleFrom(provisionBinding.bindingElement().get(), requestingPackage)
+        || provisionBinding
+            .dependencies()
+            .stream()
+            .anyMatch(
+                dependencyRequest ->
+                    !isRawTypeAccessible(dependencyRequest.key().type(), requestingPackage))) {
+      return providerDelegate.getSnippetForDependencyRequest(request, requestingClass);
+    }
     switch (request.kind()) {
       case INSTANCE:
-        return invokeMethod();
+        return invokeMethod(requestingClass);
       case FUTURE:
-        return CodeBlock.of("$T.immediateFuture($L)", Futures.class, invokeMethod());
+        return CodeBlock.of("$T.immediateFuture($L)", Futures.class, invokeMethod(requestingClass));
       default:
         return providerDelegate.getSnippetForDependencyRequest(request, requestingClass);
     }
   }
 
-  private CodeBlock invokeMethod() {
+  public static final SimpleTypeVisitor8<Boolean, String> RAW_TYPE_ACCESSIBILITY_VISITOR =
+      new SimpleTypeVisitor8<Boolean, String>() {
+        @Override
+        protected Boolean defaultAction(TypeMirror e, String requestingPackage) {
+          return isTypeAccessibleFrom(e, requestingPackage);
+        }
+
+        @Override
+        public Boolean visitDeclared(DeclaredType t, String requestingPackage) {
+          return isElementAccessibleFrom(t.asElement(), requestingPackage);
+        }
+      };
+
+  private static boolean isRawTypeAccessible(TypeMirror type, String requestingPackage) {
+    return type.accept(RAW_TYPE_ACCESSIBILITY_VISITOR, requestingPackage);
+  }
+
+  private CodeBlock invokeMethod(ClassName requestingClass) {
+    CodeBlock parametersCodeBlock =
+        CodeBlocks.makeParametersCodeBlock(
+            provisionBinding
+                .explicitDependencies()
+                .stream()
+                .map(
+                    request -> {
+                      CodeBlock snippet =
+                          registry
+                              .getRequestFulfillment(request.bindingKey())
+                              .getSnippetForDependencyRequest(request, requestingClass);
+                      return isTypeAccessibleFrom(
+                              request.key().type(), requestingClass.packageName())
+                          ? snippet
+                          : CodeBlock.of(
+                              "($T) $L", rawTypeName(TypeName.get(request.key().type())), snippet);
+                    })
+                .collect(toList()));
     // we use the type from the key to ensure we get the right generics
     // TODO(gak): use <>?
     ExecutableElement method = asExecutable(provisionBinding.bindingElement().get());
     switch (method.getKind()) {
       case CONSTRUCTOR:
-        return CodeBlock.of("new $T()", provisionBinding.key().type());
+        return CodeBlock.of("new $T($L)", provisionBinding.key().type(), parametersCodeBlock);
       case METHOD:
         checkState(method.getModifiers().contains(STATIC));
         return CodeBlock.of(
-            "$T.$L()", provisionBinding.bindingTypeElement().get(), method.getSimpleName());
+            "$T.$L($L)",
+            provisionBinding.bindingTypeElement().get(),
+            method.getSimpleName(),
+            parametersCodeBlock);
       default:
         throw new IllegalStateException();
     }
   }
+
+  private static TypeName rawTypeName(TypeName typeName) {
+    return (typeName instanceof ParameterizedTypeName)
+        ? ((ParameterizedTypeName) typeName).rawType
+        : typeName;
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 62571bdb9..2b7aebda5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -16,7 +16,6 @@
 
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.Preconditions.checkArgument;
-import static dagger.internal.codegen.FrameworkDependency.frameworkDependenciesForBinding;
 import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
 import static dagger.internal.codegen.TypeNames.PROVIDER_OF_LAZY;
 import static dagger.internal.codegen.Util.ELEMENT_SIMPLE_NAME;
@@ -85,23 +84,22 @@
     checkArgument(!binding.unresolved().isPresent(), "binding must be unresolved: %s", binding);
 
     ImmutableMap.Builder<BindingKey, FrameworkField> bindingFields = ImmutableMap.builder();
-    for (FrameworkDependency frameworkDependency : frameworkDependenciesForBinding(binding)) {
+    for (Binding.DependencyAssociation dependencyAssociation : binding.dependencyAssociations()) {
+      FrameworkDependency frameworkDependency = dependencyAssociation.frameworkDependency();
       bindingFields.put(
           frameworkDependency.bindingKey(),
           FrameworkField.create(
               ClassName.get(frameworkDependency.frameworkClass()),
               TypeName.get(frameworkDependency.bindingKey().key().type()),
-              fieldNameForDependency(frameworkDependency)));
+              fieldNameForDependency(dependencyAssociation.dependencyRequests())));
     }
     return bindingFields.build();
   }
 
-  private static String fieldNameForDependency(FrameworkDependency frameworkDependency) {
+  private static String fieldNameForDependency(ImmutableSet<DependencyRequest> dependencyRequests) {
     // collect together all of the names that we would want to call the provider
     ImmutableSet<String> dependencyNames =
-        FluentIterable.from(frameworkDependency.dependencyRequests())
-            .transform(new DependencyVariableNamer())
-            .toSet();
+        FluentIterable.from(dependencyRequests).transform(new DependencyVariableNamer()).toSet();
 
     if (dependencyNames.size() == 1) {
       // if there's only one name, great! use it!
diff --git a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
index 7a4b7155f..9555ba055 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
@@ -92,7 +92,7 @@ protected InitializationState getInitializationState(BindingKey bindingKey) {
   }
 
   @Override
-  protected MemberSelect getMemberSelect(BindingKey key) {
+  public MemberSelect getMemberSelect(BindingKey key) {
     MemberSelect memberSelect = super.getMemberSelect(key);
     return memberSelect == null ? parent.getMemberSelect(key) : memberSelect;
   }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index 0c79fb47f..9a4ab1c2d 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -482,63 +482,64 @@
         "interface TestComponent {",
         "  A a();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import dagger.internal.Preconditions;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private Provider<B> bProvider;",
-        "  private Provider<A> aProvider;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.bProvider = TestModule_BFactory.create(builder.testModule,",
-        "        C_Factory.create());",
-        "    this.aProvider = A_Factory.create(bProvider);",
-        "  }",
-        "",
-        "  @Override",
-        "  public A a() {",
-        "    return aProvider.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private TestModule testModule;",
-        "",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public TestComponent build() {",
-        "      if (testModule == null) {",
-        "        this.testModule = new TestModule();",
-        "      }",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "",
-        "    public Builder testModule(TestModule testModule) {",
-        "      this.testModule = Preconditions.checkNotNull(testModule);",
-        "      return this;",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.internal.Preconditions;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private Provider<B> bProvider;",
+            "  private Provider<A> aProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.bProvider = TestModule_BFactory.create(builder.testModule,",
+            "        C_Factory.create());",
+            "    this.aProvider = A_Factory.create(bProvider);",
+            "  }",
+            "",
+            "  @Override",
+            "  public A a() {",
+            "    return new A(bProvider.get());",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private TestModule testModule;",
+            "",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      if (testModule == null) {",
+            "        this.testModule = new TestModule();",
+            "      }",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "",
+            "    public Builder testModule(TestModule testModule) {",
+            "      this.testModule = Preconditions.checkNotNull(testModule);",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(aFile, bFile, cFile, moduleFile, componentFile))
         .processedWith(new ComponentProcessor())
@@ -633,7 +634,7 @@ public void componentWithAbstractModule() {
             "",
             "  @Override",
             "  public A a() {",
-            "    return aProvider.get();",
+            "    return new A(TestModule.b(new C()));",
             "  }",
             "",
             "  public static final class Builder {",
@@ -1382,53 +1383,54 @@ public void testDefaultPackage() {
         "interface SimpleComponent {",
         "  SomeInjectableType someInjectableType();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerSimpleComponent",
-        "package test;",
-        "",
-        "import dagger.internal.InstanceFactory;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerSimpleComponent implements SimpleComponent {",
-        "  private Provider<SimpleComponent> simpleComponentProvider;",
-        "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
-        "",
-        "  private DaggerSimpleComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static SimpleComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.simpleComponentProvider = InstanceFactory.<SimpleComponent>create(this);",
-        "    this.someInjectableTypeProvider =",
-        "        SomeInjectableType_Factory.create(simpleComponentProvider);",
-        "  }",
-        "",
-        "  @Override",
-        "  public SomeInjectableType someInjectableType() {",
-        "    return someInjectableTypeProvider.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public SimpleComponent build() {",
-        "      return new DaggerSimpleComponent(this);",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerSimpleComponent",
+            "package test;",
+            "",
+            "import dagger.internal.InstanceFactory;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerSimpleComponent implements SimpleComponent {",
+            "  private Provider<SimpleComponent> simpleComponentProvider;",
+            "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
+            "",
+            "  private DaggerSimpleComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static SimpleComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.simpleComponentProvider = InstanceFactory.<SimpleComponent>create(this);",
+            "    this.someInjectableTypeProvider =",
+            "        SomeInjectableType_Factory.create(simpleComponentProvider);",
+            "  }",
+            "",
+            "  @Override",
+            "  public SomeInjectableType someInjectableType() {",
+            "    return new SomeInjectableType(simpleComponentProvider.get())",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public SimpleComponent build() {",
+            "      return new DaggerSimpleComponent(this);",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -1631,65 +1633,66 @@ public void testDefaultPackage() {
         "interface BComponent {",
         "  B b();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerBComponent",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import dagger.internal.Preconditions;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerBComponent implements BComponent {",
-        "  private Provider<A> aProvider;",
-        "  private Provider<B> bProvider;",
-        "",
-        "  private DaggerBComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.aProvider = new Factory<A>() {",
-        "      private final AComponent aComponent = builder.aComponent;",
-        "      @Override public A get() {",
-        "        return Preconditions.checkNotNull(aComponent.a(), " + NPE_LITERAL + ");",
-        "      }",
-        "    };",
-        "    this.bProvider = B_Factory.create(aProvider);",
-        "  }",
-        "",
-        "  @Override",
-        "  public B b() {",
-        "    return bProvider.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private AComponent aComponent;",
-        "",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public BComponent build() {",
-        "      if (aComponent == null) {",
-        "        throw new IllegalStateException(AComponent.class.getCanonicalName()",
-        "            + \" must be set\");",
-        "      }",
-        "      return new DaggerBComponent(this);",
-        "    }",
-        "",
-        "    public Builder aComponent(AComponent aComponent) {",
-        "      this.aComponent = Preconditions.checkNotNull(aComponent);",
-        "      return this;",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerBComponent",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import dagger.internal.Preconditions;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerBComponent implements BComponent {",
+            "  private Provider<A> aProvider;",
+            "  private Provider<B> bProvider;",
+            "",
+            "  private DaggerBComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.aProvider = new Factory<A>() {",
+            "      private final AComponent aComponent = builder.aComponent;",
+            "      @Override public A get() {",
+            "        return Preconditions.checkNotNull(aComponent.a(), " + NPE_LITERAL + ");",
+            "      }",
+            "    };",
+            "    this.bProvider = B_Factory.create(aProvider);",
+            "  }",
+            "",
+            "  @Override",
+            "  public B b() {",
+            "    return new B(aProvider.get());",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private AComponent aComponent;",
+            "",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public BComponent build() {",
+            "      if (aComponent == null) {",
+            "        throw new IllegalStateException(AComponent.class.getCanonicalName()",
+            "            + \" must be set\");",
+            "      }",
+            "      return new DaggerBComponent(this);",
+            "    }",
+            "",
+            "    public Builder aComponent(AComponent aComponent) {",
+            "      this.aComponent = Preconditions.checkNotNull(aComponent);",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(aFile, bFile, aComponentFile, bComponentFile))
         .processedWith(new ComponentProcessor())
@@ -1898,7 +1901,7 @@ public void testDefaultPackage() {
             "",
             "  @Override",
             "  public A a() {",
-            "    return aProvider.get();",
+            "    return new A(new B(new C()));",
             "  }",
             "",
             "  @Override",
@@ -1908,7 +1911,7 @@ public void testDefaultPackage() {
             "",
             "  @Override",
             "  public X x() {",
-            "    return xProvider.get();",
+            "    return new X(new C());",
             "  }",
             "",
             "  public static final class Builder {",
diff --git a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
index 4cf5a9122..da1eca604 100644
--- a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
@@ -49,14 +49,16 @@
       "  @Inject PrimitiveInjectable(int ignored) {}",
       "}");
 
-  JavaFileObject primitiveModule = JavaFileObjects.forSourceLines("test.PrimitiveModule",
-      "package test;",
-      "import dagger.Module;",
-      "import dagger.Provides;",
-      "@Module",
-      "class PrimitiveModule {",
-      "  @Provides int primitiveInt() { return Integer.MAX_VALUE; }",
-      "}");
+  JavaFileObject primitiveModule =
+      JavaFileObjects.forSourceLines(
+          "test.PrimitiveModule",
+          "package test;",
+          "import dagger.Module;",
+          "import dagger.Provides;",
+          "@Module",
+          "class PrimitiveModule {",
+          "  @Provides static int primitiveInt() { return Integer.MAX_VALUE; }",
+          "}");
 
   JavaFileObject component = JavaFileObjects.forSourceLines("test.PrimitiveComponent",
       "package test;",
@@ -68,69 +70,63 @@
       "  PrimitiveInjectable primitiveInjectable();",
       "}");
 
-  JavaFileObject expectedComponent = JavaFileObjects.forSourceLines(
-      "test.DaggerPrimitiveComponent",
-      "package test;",
-      "",
-      "import dagger.internal.Preconditions;",
-      "import javax.annotation.Generated;",
-      "import javax.inject.Provider;",
-      "",
-      GENERATED_ANNOTATION,
-      "public final class DaggerPrimitiveComponent implements PrimitiveComponent {",
-      "  private Provider<Integer> primitiveIntProvider;",
-      "  private Provider<PrimitiveInjectable> primitiveInjectableProvider;",
-      "",
-      "  private DaggerPrimitiveComponent(Builder builder) {",
-      "    assert builder != null;",
-      "    initialize(builder);",
-      "  }",
-      "",
-      "  public static Builder builder() {",
-      "    return new Builder();",
-      "  }",
-      "",
-      "  public static PrimitiveComponent create() {",
-      "    return builder().build();",
-      "  }",
-      "",
-      "  @SuppressWarnings(\"unchecked\")",
-      "  private void initialize(final Builder builder) {",
-      "    this.primitiveIntProvider =",
-      "        PrimitiveModule_PrimitiveIntFactory.create(builder.primitiveModule);",
-      "    this.primitiveInjectableProvider =",
-      "        PrimitiveInjectable_Factory.create(primitiveIntProvider);",
-      "  }",
-      "",
-      "  @Override",
-      "  public int primitiveInt() {",
-      "    return primitiveIntProvider.get();",
-      "  }",
-      "",
-      "  @Override",
-      "  public PrimitiveInjectable primitiveInjectable() {",
-      "    return primitiveInjectableProvider.get();",
-      "  }",
-      "",
-      "  public static final class Builder {",
-      "    private PrimitiveModule primitiveModule;",
-      "",
-      "    private Builder() {",
-      "    }",
-      "",
-      "    public PrimitiveComponent build() {",
-      "      if (primitiveModule == null) {",
-      "        this.primitiveModule = new PrimitiveModule();",
-      "      }",
-      "      return new DaggerPrimitiveComponent(this);",
-      "    }",
-      "",
-      "    public Builder primitiveModule(PrimitiveModule primitiveModule) {",
-      "      this.primitiveModule = Preconditions.checkNotNull(primitiveModule);",
-      "      return this;",
-      "    }",
-      "  }",
-      "}");
+  JavaFileObject expectedComponent =
+      JavaFileObjects.forSourceLines(
+          "test.DaggerPrimitiveComponent",
+          "package test;",
+          "",
+          "import dagger.internal.Preconditions;",
+          "import javax.annotation.Generated;",
+          "import javax.inject.Provider;",
+          "",
+          GENERATED_ANNOTATION,
+          "public final class DaggerPrimitiveComponent implements PrimitiveComponent {",
+          "  private Provider<PrimitiveInjectable> primitiveInjectableProvider;",
+          "",
+          "  private DaggerPrimitiveComponent(Builder builder) {",
+          "    assert builder != null;",
+          "    initialize(builder);",
+          "  }",
+          "",
+          "  public static Builder builder() {",
+          "    return new Builder();",
+          "  }",
+          "",
+          "  public static PrimitiveComponent create() {",
+          "    return builder().build();",
+          "  }",
+          "",
+          "  @SuppressWarnings(\"unchecked\")",
+          "  private void initialize(final Builder builder) {",
+          "    this.primitiveInjectableProvider = PrimitiveInjectable_Factory.create(",
+          "        PrimitiveModule_PrimitiveIntFactory.create());",
+          "  }",
+          "",
+          "  @Override",
+          "  public int primitiveInt() {",
+          "    return PrimitiveModule.primitiveInt();",
+          "  }",
+          "",
+          "  @Override",
+          "  public PrimitiveInjectable primitiveInjectable() {",
+          "    return new PrimitiveInjectable(PrimitiveModule.primitiveInt());",
+          "  }",
+          "",
+          "  public static final class Builder {",
+          "",
+          "    private Builder() {}",
+          "",
+          "    public PrimitiveComponent build() {",
+          "      return new DaggerPrimitiveComponent(this);",
+          "    }",
+          "",
+          "    @Deprecated",
+          "    public Builder primitiveModule(PrimitiveModule primitiveModule) {",
+          "      Preconditions.checkNotNull(primitiveModule);",
+          "      return this;",
+          "    }",
+          "  }",
+          "}");
 
   @Test public void primitiveArrayTypesAllInjected() {
     assertAbout(javaSources())
