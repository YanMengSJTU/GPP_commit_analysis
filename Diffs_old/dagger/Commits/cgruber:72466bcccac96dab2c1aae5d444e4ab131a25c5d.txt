diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index de754ba2b..e626e13a5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -28,7 +28,7 @@
 import com.google.common.collect.Queues;
 import dagger.Provides;
 import dagger.internal.codegen.BindingGraph.ResolvedBindings.State;
-import dagger.internal.codegen.ProvisionBinding.BindingType;
+import dagger.internal.codegen.ContributionBinding.BindingType;
 import java.util.Deque;
 import java.util.List;
 import java.util.Map;
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index d63c12989..45eebb087 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -15,7 +15,7 @@
 import com.google.common.collect.Ordering;
 import dagger.internal.codegen.BindingGraph.ResolvedBindings;
 import dagger.internal.codegen.BindingGraph.ResolvedBindings.State;
-import dagger.internal.codegen.ProvisionBinding.BindingType;
+import dagger.internal.codegen.ContributionBinding.BindingType;
 import java.util.Deque;
 import java.util.Formatter;
 import java.util.LinkedList;
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 62091e02b..02783dde4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -41,7 +41,7 @@
 import dagger.internal.ScopedProvider;
 import dagger.internal.SetFactory;
 import dagger.internal.codegen.BindingGraph.ResolvedBindings;
-import dagger.internal.codegen.ProvisionBinding.BindingType;
+import dagger.internal.codegen.ContributionBinding.BindingType;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.ClassWriter;
 import dagger.internal.codegen.writer.ConstructorWriter;
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
new file mode 100644
index 000000000..57089a36d
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableListMultimap;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Ordering;
+import java.util.Set;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+/**
+ * An abstract class for a value object representing the mechanism by which a {@link Key} can be
+ * contributed to a dependency graph.
+ *
+ * @author Jesse Beder
+ * @since 2.0
+ */
+abstract class ContributionBinding extends Binding {
+  static enum BindingType {
+    /** Represents map bindings. */
+    MAP,
+    /** Represents set bindings. */
+    SET,
+    /** Represents a valid non-collection binding. */
+    UNIQUE;
+  }
+
+  abstract BindingType bindingType();
+
+  /**
+   * Returns the set of {@link BindingType} enum values implied by a given
+   * {@link ContributionBinding} collection.
+   */
+  static <B extends ContributionBinding> ImmutableListMultimap<BindingType, B> bindingTypesFor(
+      Iterable<B> bindings) {
+    ImmutableListMultimap.Builder<BindingType, B> builder =
+        ImmutableListMultimap.builder();
+    builder.orderKeysBy(Ordering.<BindingType>natural());
+    for (B binding : bindings) {
+      builder.put(binding.bindingType(), binding);
+    }
+    return builder.build();
+  }
+
+  /**
+   * Returns a single {@code BindingsType} represented by a given collection of
+   * {@code ContributionBindings} or throws an IllegalArgumentException if the given bindings
+   * are not all of one type.
+   */
+  static BindingType bindingTypeFor(Iterable<? extends ContributionBinding> bindings) {
+    checkNotNull(bindings);
+    switch (Iterables.size(bindings)) {
+      case 0:
+        throw new IllegalArgumentException("no bindings");
+      case 1:
+        return Iterables.getOnlyElement(bindings).bindingType();
+      default:
+        Set<BindingType> types = bindingTypesFor(bindings).keySet();
+        if (types.size() > 1) {
+          throw new IllegalArgumentException(
+              String.format(ErrorMessages.MULTIPLE_BINDING_TYPES_FORMAT, types));
+        }
+        return Iterables.getOnlyElement(types);
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
new file mode 100644
index 000000000..667e3bdc7
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -0,0 +1,112 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.Produces;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static javax.lang.model.element.ElementKind.METHOD;
+
+/**
+ * A value object representing the mechanism by which a {@link Key} can be produced. New instances
+ * should be created using an instance of the {@link Factory}.
+ *
+ * @author Jesse Beder
+ * @since 2.0
+ */
+@AutoValue
+abstract class ProductionBinding extends ContributionBinding {
+  @Override
+  ImmutableSet<DependencyRequest> implicitDependencies() {
+    return new ImmutableSet.Builder<DependencyRequest>()
+        .addAll(dependencies())
+        .build();
+  }
+
+  enum Kind {
+    /** Represents a binding configured by {@link Produces} that doesn't return a future. */
+    IMMEDIATE,
+    /** Represents a binding configured by {@link Produces} that returns a future. */
+    FUTURE_PRODUCTION,
+  }
+
+  /**
+   * The type of binding (whether the {@link Produces} method returns a future). For the particular
+   * type of production, use {@link #productionType}.
+   */
+  abstract Kind bindingKind();
+
+  /** Returns provision type that was used to bind the key. */
+  abstract Produces.Type productionType();
+
+  @Override
+  BindingType bindingType() {
+    switch (productionType()) {
+      case SET:
+      case SET_VALUES:
+        return BindingType.SET;
+      case MAP:
+        return BindingType.MAP;
+      case UNIQUE:
+        return BindingType.UNIQUE;
+      default:
+        throw new IllegalStateException("Unknown production type: " + productionType());
+    }
+  }
+
+  static final class Factory {
+    private final Elements elements;
+    private final Types types;
+    private final Key.Factory keyFactory;
+    private final DependencyRequest.Factory dependencyRequestFactory;
+
+    Factory(Elements elements, Types types, Key.Factory keyFactory,
+        DependencyRequest.Factory dependencyRequestFactory) {
+      this.elements = elements;
+      this.types = types;
+      this.keyFactory = keyFactory;
+      this.dependencyRequestFactory = dependencyRequestFactory;
+    }
+
+    ProductionBinding forProducesMethod(ExecutableElement producesMethod) {
+      checkNotNull(producesMethod);
+      checkArgument(producesMethod.getKind().equals(METHOD));
+      Produces producesAnnotation = producesMethod.getAnnotation(Produces.class);
+      checkArgument(producesAnnotation != null);
+      Key key = keyFactory.forProducesMethod(producesMethod);
+      ImmutableSet<DependencyRequest> dependencies =
+          dependencyRequestFactory.forRequiredVariables(producesMethod.getParameters());
+      Kind kind = MoreTypes.isTypeOf(ListenableFuture.class, producesMethod.getReturnType())
+          ? Kind.FUTURE_PRODUCTION
+          : Kind.IMMEDIATE;
+      return new AutoValue_ProductionBinding(
+          key,
+          producesMethod,
+          dependencies,
+          findBindingPackage(key),
+          kind,
+          producesAnnotation.type());
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 25cd5879b..114bfe6fc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -19,14 +19,10 @@
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Optional;
-import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Iterables;
-import com.google.common.collect.Ordering;
 import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.Provides;
-import java.util.Set;
 import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
@@ -55,7 +51,7 @@
  * @since 2.0
  */
 @AutoValue
-abstract class ProvisionBinding extends Binding {
+abstract class ProvisionBinding extends ContributionBinding {
   @Override
   ImmutableSet<DependencyRequest> implicitDependencies() {
     return new ImmutableSet.Builder<DependencyRequest>()
@@ -99,15 +95,7 @@
   /** If this provision requires members injeciton, this will be the corresonding request. */
   abstract Optional<DependencyRequest> memberInjectionRequest();
 
-  static enum BindingType {
-    /** Represents map bindings. */
-    MAP,
-    /** Represents set bindings. */
-    SET,
-    /** Represents a valid non-collection binding. */
-    UNIQUE;
-  }
-
+  @Override
   BindingType bindingType() {
     switch (provisionType()) {
       case SET:
@@ -122,43 +110,6 @@ BindingType bindingType() {
     }
   }
 
-  /**
-   * Returns the set of {@link BindingType} enum values implied by a given
-   * {@link ProvisionBinding} collection.
-   */
-  static ImmutableListMultimap<BindingType, ProvisionBinding> bindingTypesFor(
-      Iterable<ProvisionBinding> bindings) {
-    ImmutableListMultimap.Builder<BindingType, ProvisionBinding> builder =
-        ImmutableListMultimap.builder();
-    builder.orderKeysBy(Ordering.<BindingType>natural());
-    for (ProvisionBinding binding : bindings) {
-      builder.put(binding.bindingType(), binding);
-    }
-    return builder.build();
-  }
-
-  /**
-   * Returns a single {@code BindingsType} represented by a given collection of
-   * {@code ProvisionBindings} or throws an IllegalArgumentException if the given bindings
-   * are not all of one type.
-   */
-  static BindingType bindingTypeFor(Iterable<ProvisionBinding> bindings) {
-    checkNotNull(bindings);
-    switch (Iterables.size(bindings)) {
-      case 0:
-        throw new IllegalArgumentException("no bindings");
-      case 1:
-        return Iterables.getOnlyElement(bindings).bindingType();
-      default:
-        Set<BindingType> types = bindingTypesFor(bindings).keySet();
-        if (types.size() > 1) {
-          throw new IllegalArgumentException(
-              String.format(ErrorMessages.MULTIPLE_BINDING_TYPES_FORMAT, types));
-        }
-        return Iterables.getOnlyElement(types);
-    }
-  }
-
   enum FactoryCreationStrategy {
     ENUM_INSTANCE,
     CLASS_CONSTRUCTOR,
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 9f55f447a..176a5e06b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -145,6 +145,19 @@ static ClassName factoryNameForProvisionBinding(ProvisionBinding binding) {
     }
   }
 
+  static ClassName factoryNameForProductionBinding(ProductionBinding binding) {
+    TypeElement enclosingTypeElement = binding.bindingTypeElement();
+    ClassName enclosingClassName = ClassName.fromTypeElement(enclosingTypeElement);
+    switch (binding.bindingKind()) {
+      case IMMEDIATE:
+      case FUTURE_PRODUCTION:
+        return enclosingClassName.topLevelClassName().peerNamed(
+            enclosingClassName.classFileName() + "$$" + factoryPrefix(binding) + "Factory");
+      default:
+        throw new AssertionError();
+    }
+  }
+
   static ClassName membersInjectorNameForMembersInjectionBinding(MembersInjectionBinding binding) {
     ClassName injectedClassName = ClassName.fromTypeElement(binding.bindingElement());
     return injectedClassName.topLevelClassName().peerNamed(
@@ -163,5 +176,16 @@ private static String factoryPrefix(ProvisionBinding binding) {
     }
   }
 
+  private static String factoryPrefix(ProductionBinding binding) {
+    switch (binding.bindingKind()) {
+      case IMMEDIATE:
+      case FUTURE_PRODUCTION:
+        return CaseFormat.LOWER_CAMEL.to(UPPER_CAMEL,
+            ((ExecutableElement) binding.bindingElement()).getSimpleName().toString());
+      default:
+        throw new IllegalArgumentException();
+    }
+  }
+
   private SourceFiles() {}
 }
