diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index bf5c18465..6e24cf46c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -43,8 +43,8 @@
 import dagger.internal.codegen.writer.Snippet;
 import dagger.internal.codegen.writer.StringLiteral;
 import dagger.internal.codegen.writer.TypeName;
-import dagger.internal.codegen.writer.TypeReferences;
 import dagger.internal.codegen.writer.VoidName;
+import dagger.internal.codegen.writer.TypeNames;
 import java.util.List;
 import java.util.Map.Entry;
 import java.util.Set;
@@ -151,7 +151,7 @@ JavaWriter write(ClassName componentName, ComponentDescriptor input)  {
       // TODO(gak): provide more elaborate information about which requests relate
       TypeName providerTypeReferece = ParameterizedTypeName.create(
           ClassName.fromClass(Provider.class),
-          TypeReferences.forTypeMirror(key.type()));
+          TypeNames.forTypeMirror(key.type()));
       FieldWriter providerField =
           componentWriter.addField(providerTypeReferece, providerEntry.getValue());
       providerField.addModifiers(PRIVATE, FINAL);
@@ -161,7 +161,7 @@ JavaWriter write(ClassName componentName, ComponentDescriptor input)  {
       // TODO(gak): provide more elaborate information about which requests relate
       TypeName membersInjectorTypeReferece = ParameterizedTypeName.create(
           ClassName.fromClass(MembersInjector.class),
-          TypeReferences.forTypeMirror(key.type()));
+          TypeNames.forTypeMirror(key.type()));
       FieldWriter membersInjectorField =
           componentWriter.addField(membersInjectorTypeReferece, providerEntry.getValue());
       membersInjectorField.addModifiers(PRIVATE, FINAL);
@@ -212,7 +212,7 @@ JavaWriter write(ClassName componentName, ComponentDescriptor input)  {
         VariableElement parameter = Iterables.getOnlyElement(requestElement.getParameters());
         Name parameterName = parameter.getSimpleName();
         interfaceMethod.addParameter(
-            TypeReferences.forTypeMirror(parameter.asType()), parameterName.toString());
+            TypeNames.forTypeMirror(parameter.asType()), parameterName.toString());
         interfaceMethod.body()
             .addSnippet("%s.injectMembers(%s);", membersInjectorName, parameterName);
         if (!requestElement.getReturnType().getKind().equals(VOID)) {
@@ -238,7 +238,7 @@ private Snippet initializeFactoryForBinding(ProvisionBinding binding,
     if (binding.bindingKind().equals(COMPONENT)) {
       return Snippet.format("%s.<%s>create(this)",
           ClassName.fromClass(InstanceFactory.class),
-          TypeReferences.forTypeMirror(binding.providedKey().type()));
+          TypeNames.forTypeMirror(binding.providedKey().type()));
     } else {
       List<String> parameters = Lists.newArrayListWithCapacity(binding.dependencies().size() + 1);
       if (binding.bindingKind().equals(PROVISION)) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 29f763fd3..5c1f07e6a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -30,7 +30,7 @@
 import dagger.internal.codegen.writer.ParameterizedTypeName;
 import dagger.internal.codegen.writer.Snippet;
 import dagger.internal.codegen.writer.TypeName;
-import dagger.internal.codegen.writer.TypeReferences;
+import dagger.internal.codegen.writer.TypeNames;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map.Entry;
@@ -78,7 +78,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
 
   @Override
   JavaWriter write(ClassName generatedTypeName, ProvisionBinding binding) {
-    TypeName providedTypeName = TypeReferences.forTypeMirror(binding.providedKey().type());
+    TypeName providedTypeName = TypeNames.forTypeMirror(binding.providedKey().type());
     JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
 
     ClassWriter factoryWriter = writer.addClass(generatedTypeName.simpleName());
@@ -121,12 +121,12 @@ JavaWriter write(ClassName generatedTypeName, ProvisionBinding binding) {
       if (nameEntry.getKey().frameworkClass().equals(Provider.class)) {
         ParameterizedTypeName providerType = ParameterizedTypeName.create(
             ClassName.fromClass(Provider.class),
-            TypeReferences.forTypeMirror(nameEntry.getKey().key().type()));
+            TypeNames.forTypeMirror(nameEntry.getKey().key().type()));
         field = factoryWriter.addField(providerType, nameEntry.getValue());
       } else if (nameEntry.getKey().frameworkClass().equals(MembersInjector.class)) {
         ParameterizedTypeName membersInjectorType = ParameterizedTypeName.create(
             ClassName.fromClass(MembersInjector.class),
-            TypeReferences.forTypeMirror(nameEntry.getKey().key().type()));
+            TypeNames.forTypeMirror(nameEntry.getKey().key().type()));
         field = factoryWriter.addField(membersInjectorType, nameEntry.getValue());
       } else {
         throw new IllegalStateException();
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index ab000fc98..bc1f601a7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -35,7 +35,7 @@
 import dagger.internal.codegen.writer.MethodWriter;
 import dagger.internal.codegen.writer.ParameterizedTypeName;
 import dagger.internal.codegen.writer.Snippet;
-import dagger.internal.codegen.writer.TypeReferences;
+import dagger.internal.codegen.writer.TypeNames;
 import java.util.Map.Entry;
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
@@ -139,12 +139,12 @@ JavaWriter write(ClassName injectorClassName, MembersInjectionBinding binding) {
       if (nameEntry.getKey().frameworkClass().equals(Provider.class)) {
         ParameterizedTypeName providerType = ParameterizedTypeName.create(
             ClassName.fromClass(Provider.class),
-            TypeReferences.forTypeMirror(nameEntry.getKey().key().type()));
+            TypeNames.forTypeMirror(nameEntry.getKey().key().type()));
         field = injectorWriter.addField(providerType, nameEntry.getValue());
       } else if (nameEntry.getKey().frameworkClass().equals(MembersInjector.class)) {
         ParameterizedTypeName membersInjectorType = ParameterizedTypeName.create(
             ClassName.fromClass(MembersInjector.class),
-            TypeReferences.forTypeMirror(nameEntry.getKey().key().type()));
+            TypeNames.forTypeMirror(nameEntry.getKey().key().type()));
         field = injectorWriter.addField(membersInjectorType, nameEntry.getValue());
       } else {
         throw new IllegalStateException();
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/AnnotationWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/AnnotationWriter.java
index 82ee2034b..2da3420cc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/AnnotationWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/AnnotationWriter.java
@@ -3,7 +3,6 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
 import java.io.IOException;
 import java.util.Map.Entry;
 import java.util.Set;
@@ -32,8 +31,7 @@ public void setMember(String name, String value) {
   }
 
   @Override
-  public Appendable write(Appendable appendable, CompilationUnitContext context)
-      throws IOException {
+  public Appendable write(Appendable appendable, Context context) throws IOException {
     appendable.append('@');
     annotationName.write(appendable, context);
     if (!memberMap.isEmpty()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ArrayTypeName.java b/compiler/src/main/java/dagger/internal/codegen/writer/ArrayTypeName.java
new file mode 100644
index 000000000..537c7baed
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ArrayTypeName.java
@@ -0,0 +1,38 @@
+package dagger.internal.codegen.writer;
+
+import java.io.IOException;
+import java.util.Set;
+
+final class ArrayTypeName implements TypeName {
+  private final TypeName componentType;
+
+  ArrayTypeName(TypeName componentType) {
+    this.componentType = componentType;
+  }
+
+  @Override
+  public Set<ClassName> referencedClasses() {
+    return componentType.referencedClasses();
+  }
+
+  @Override
+  public Appendable write(Appendable appendable, Context context) throws IOException {
+    return componentType.write(appendable, context).append("[]");
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    return (obj instanceof ArrayTypeName)
+        & this.componentType.equals(((ArrayTypeName) obj).componentType);
+  }
+
+  @Override
+  public int hashCode() {
+    return componentType.hashCode();
+  }
+
+  @Override
+  public String toString() {
+    return Writables.writeToString(this);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/BlockWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/BlockWriter.java
index 50bfe2dfc..230a66c95 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/BlockWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/BlockWriter.java
@@ -3,7 +3,6 @@
 import com.google.common.base.Function;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.Lists;
-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
 import java.io.IOException;
 import java.util.List;
 import java.util.Set;
@@ -30,8 +29,7 @@ boolean isEmpty() {
   }
 
   @Override
-  public Appendable write(Appendable appendable, CompilationUnitContext context)
-      throws IOException {
+  public Appendable write(Appendable appendable, Context context) throws IOException {
     for (Snippet snippet : snippets) {
       appendable.append('\n');
       snippet.write(appendable, context);
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ClassName.java b/compiler/src/main/java/dagger/internal/codegen/writer/ClassName.java
index 8e89fe184..64ffc70e7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ClassName.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ClassName.java
@@ -23,7 +23,6 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -48,7 +47,7 @@
  *
  * @since 2.0
  */
-public final class ClassName implements Comparable<ClassName>, TypeName {
+public final class ClassName implements TypeName, Comparable<ClassName> {
   private String fullyQualifiedName = null;
   private final String packageName;
   /* From top to bottom.  E.g.: this field will contian ["A", "B"] for pgk.A.B.C */
@@ -226,8 +225,7 @@ public String toString() {
   }
 
   @Override
-  public Appendable write(Appendable appendable, CompilationUnitContext context)
-      throws IOException {
+  public Appendable write(Appendable appendable, Context context) throws IOException {
     appendable.append(context.sourceReferenceForClassName(this));
     return appendable;
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
index ffe8c8f18..4fffc757c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
@@ -6,7 +6,6 @@
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
 import java.io.IOException;
 import java.util.Iterator;
 import java.util.List;
@@ -81,7 +80,7 @@ public MethodWriter addMethod(TypeWriter returnType, String name) {
 
   public MethodWriter addMethod(TypeMirror returnType, String name) {
     MethodWriter methodWriter =
-        new MethodWriter(TypeReferences.forTypeMirror(returnType), name);
+        new MethodWriter(TypeNames.forTypeMirror(returnType), name);
     methodWriters.add(methodWriter);
     return methodWriter;
   }
@@ -100,8 +99,7 @@ public MethodWriter addMethod(Class<?> returnType, String name) {
   }
 
   @Override
-  public Appendable write(Appendable appendable, CompilationUnitContext context)
-      throws IOException {
+  public Appendable write(Appendable appendable, Context context) throws IOException {
     writeAnnotations(appendable, context);
     writeModifiers(appendable).append("class ").append(name.simpleName());
     if (!typeVariables.isEmpty()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ConstructorWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/ConstructorWriter.java
index cbdb6108b..08997ef23 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ConstructorWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ConstructorWriter.java
@@ -5,7 +5,6 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
 import java.io.IOException;
 import java.util.Iterator;
 import java.util.Map;
@@ -68,8 +67,7 @@ private VariableWriter addParameter(ClassName type, String name) {
   }
 
   @Override
-  public Appendable write(Appendable appendable, CompilationUnitContext context)
-      throws IOException {
+  public Appendable write(Appendable appendable, Context context) throws IOException {
     writeModifiers(appendable).append(name).append('(');
     Iterator<VariableWriter> parameterWritersIterator = parameterWriters.values().iterator();
     if (parameterWritersIterator.hasNext()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/FieldWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/FieldWriter.java
index 0d2565774..9d93b50c7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/FieldWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/FieldWriter.java
@@ -5,7 +5,6 @@
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
 import java.io.IOException;
 import java.util.Set;
 
@@ -22,8 +21,7 @@ public void setInitializer(Snippet initializer) {
   }
 
   @Override
-  public Appendable write(Appendable appendable, CompilationUnitContext context)
-      throws IOException {
+  public Appendable write(Appendable appendable, Context context) throws IOException {
     super.write(appendable, context);
     if (initializer.isPresent()) {
       appendable.append(" = ");
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java
index ce610f63d..33b1cd918 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java
@@ -4,7 +4,6 @@
 import com.google.common.base.Joiner;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.Lists;
-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
 import java.io.IOException;
 import java.util.List;
 import java.util.Set;
@@ -26,7 +25,7 @@ public void addTypeVariable(TypeVariableName typeVariable) {
   }
 
   @Override
-  public Appendable write(Appendable appendable, CompilationUnitContext context) throws IOException {
+  public Appendable write(Appendable appendable, Context context) throws IOException {
     writeModifiers(appendable).append("class ").append(name.simpleName());
     if (!typeVariables.isEmpty()) {
       appendable.append('<');
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
index ff5570cb5..7750f7e53 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
@@ -168,7 +168,9 @@ public String toString() {
     }
   }
 
-  final class CompilationUnitContext {
+
+
+  final class CompilationUnitContext implements Writable.Context {
     private final ImmutableSortedSet<ClassName> importedClasses;
 
     CompilationUnitContext(ImmutableSet<ClassName> importedClasses) {
@@ -176,7 +178,8 @@ public String toString() {
           ImmutableSortedSet.copyOf(Ordering.natural().reverse(), importedClasses);
     }
 
-    String sourceReferenceForClassName(ClassName className) {
+    @Override
+    public String sourceReferenceForClassName(ClassName className) {
       if (isImported(className)) {
         return className.simpleName();
       }
@@ -202,7 +205,8 @@ private boolean isImported(ClassName className) {
     private static final String JAVA_IDENTIFIER_REGEX =
         "\\p{javaJavaIdentifierStart}\\p{javaJavaIdentifierPart}*";
 
-    String compressTypesWithin(String snippet) {
+    @Override
+    public String compressTypesWithin(String snippet) {
 
       // TODO(gak): deal with string literals
       for (ClassName importedClass : importedClasses) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java
index 29d672768..3f6154360 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java
@@ -6,7 +6,6 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
 import java.io.IOException;
 import java.util.Iterator;
 import java.util.Map;
@@ -54,8 +53,7 @@ public BlockWriter body() {
   }
 
   @Override
-  public Appendable write(Appendable appendable, CompilationUnitContext context)
-      throws IOException {
+  public Appendable write(Appendable appendable, Context context) throws IOException {
     writeAnnotations(appendable, context);
     writeModifiers(appendable);
     returnType.write(appendable, context);
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Modifiable.java b/compiler/src/main/java/dagger/internal/codegen/writer/Modifiable.java
index 86ec45eda..9840ef830 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/Modifiable.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/Modifiable.java
@@ -1,7 +1,7 @@
 package dagger.internal.codegen.writer;
 
 import com.google.common.collect.Lists;
-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
+import dagger.internal.codegen.writer.Writable.Context;
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.util.EnumSet;
@@ -36,8 +36,7 @@ Appendable writeModifiers(Appendable appendable) throws IOException {
     return appendable;
   }
 
-  Appendable writeAnnotations(Appendable appendable, CompilationUnitContext context)
-      throws IOException {
+  Appendable writeAnnotations(Appendable appendable, Context context) throws IOException {
     for (AnnotationWriter annotationWriter : annotations) {
       annotationWriter.write(appendable, context).append('\n');
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/NullName.java b/compiler/src/main/java/dagger/internal/codegen/writer/NullName.java
new file mode 100644
index 000000000..4336f94e5
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/NullName.java
@@ -0,0 +1,24 @@
+package dagger.internal.codegen.writer;
+
+import com.google.common.collect.ImmutableSet;
+import java.io.IOException;
+import java.util.Set;
+
+enum NullName implements TypeName {
+  NULL;
+
+  @Override
+  public Set<ClassName> referencedClasses() {
+    return ImmutableSet.of();
+  }
+
+  @Override
+  public Appendable write(Appendable appendable, Context context) throws IOException {
+    return appendable.append("null");
+  }
+
+  @Override
+  public String toString() {
+    return "null";
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ParameterizedTypeName.java b/compiler/src/main/java/dagger/internal/codegen/writer/ParameterizedTypeName.java
index 6e620a7eb..ec7547b26 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ParameterizedTypeName.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ParameterizedTypeName.java
@@ -1,9 +1,8 @@
 package dagger.internal.codegen.writer;
 
-import com.google.common.base.Joiner;
+import com.google.common.base.Objects;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
 import java.io.IOException;
 import java.util.Iterator;
 import java.util.Set;
@@ -31,8 +30,7 @@
   }
 
   @Override
-  public Appendable write(Appendable appendable, CompilationUnitContext context)
-      throws IOException {
+  public Appendable write(Appendable appendable, Context context) throws IOException {
     appendable.append(context.sourceReferenceForClassName(type));
     Iterator<? extends TypeName> parameterIterator = parameters.iterator();
     verify(parameterIterator.hasNext(), type.toString());
@@ -46,11 +44,25 @@ public Appendable write(Appendable appendable, CompilationUnitContext context)
     return appendable;
   }
 
+  @Override
+  public boolean equals(Object obj) {
+    if (obj instanceof ParameterizedTypeName) {
+      ParameterizedTypeName that = (ParameterizedTypeName) obj;
+      return this.type.equals(that.type)
+          && this.parameters.equals(that.parameters);
+    } else {
+      return false;
+    }
+  }
+
+  @Override
+  public int hashCode() {
+    return Objects.hashCode(type, parameters);
+  }
+
   @Override
   public String toString() {
-    StringBuilder builder = new StringBuilder(type.toString()).append('<');
-    Joiner.on(", ").appendTo(builder, parameters);
-    return builder.append('>').toString();
+    return Writables.writeToString(this);
   }
 
   public static ParameterizedTypeName create(ClassName className,
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/PrimitiveName.java b/compiler/src/main/java/dagger/internal/codegen/writer/PrimitiveName.java
index d2d50b5aa..bc57c3904 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/PrimitiveName.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/PrimitiveName.java
@@ -2,7 +2,6 @@
 
 import com.google.common.base.Ascii;
 import com.google.common.collect.ImmutableSet;
-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
 import java.io.IOException;
 import java.util.Set;
 import javax.lang.model.type.PrimitiveType;
@@ -21,8 +20,7 @@ public String toString() {
   }
 
   @Override
-  public Appendable write(Appendable appendable, CompilationUnitContext context)
-      throws IOException {
+  public Appendable write(Appendable appendable, Context context) throws IOException {
     return appendable.append(toString());
   }
 
@@ -48,4 +46,32 @@ static PrimitiveName forTypeMirror(PrimitiveType mirror) {
         throw new AssertionError();
     }
   }
+
+  static PrimitiveName forClass(Class<?> primitiveClass) {
+    if (boolean.class.equals(primitiveClass)) {
+      return BOOLEAN;
+    }
+    if (byte.class.equals(primitiveClass)) {
+      return BYTE;
+    }
+    if (short.class.equals(primitiveClass)) {
+      return SHORT;
+    }
+    if (int.class.equals(primitiveClass)) {
+      return INT;
+    }
+    if (long.class.equals(primitiveClass)) {
+      return LONG;
+    }
+    if (char.class.equals(primitiveClass)) {
+      return CHAR;
+    }
+    if (float.class.equals(primitiveClass)) {
+      return FLOAT;
+    }
+    if (double.class.equals(primitiveClass)) {
+      return DOUBLE;
+    }
+    throw new IllegalArgumentException(primitiveClass + " is not a primitive type");
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java b/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java
index 9968a7383..db7780077 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java
@@ -3,7 +3,6 @@
 import com.google.common.base.Function;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
 import java.io.IOException;
 import java.util.Iterator;
 import java.util.List;
@@ -44,8 +43,7 @@ public String toString() {
   }
 
   @Override
-  public Appendable write(Appendable appendable, CompilationUnitContext context)
-      throws IOException {
+  public Appendable write(Appendable appendable, Context context) throws IOException {
     return appendable.append(context.compressTypesWithin(value));
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/TypeReferences.java b/compiler/src/main/java/dagger/internal/codegen/writer/TypeNames.java
similarity index 56%
rename from compiler/src/main/java/dagger/internal/codegen/writer/TypeReferences.java
rename to compiler/src/main/java/dagger/internal/codegen/writer/TypeNames.java
index 4960e356b..ba6a2ec71 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/TypeReferences.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/TypeNames.java
@@ -5,12 +5,14 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.NoType;
+import javax.lang.model.type.NullType;
 import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.type.WildcardType;
 import javax.lang.model.util.SimpleTypeVisitor6;
 
-public class TypeReferences {
+public class TypeNames {
   static Function<TypeMirror, TypeName> FOR_TYPE_MIRROR =
       new Function<TypeMirror, TypeName>() {
         @Override public TypeName apply(TypeMirror input) {
@@ -18,6 +20,18 @@
         }
       };
 
+  public static TypeName forClass(Class<?> clazz) {
+    if (clazz.isPrimitive()) {
+      return PrimitiveName.forClass(clazz);
+    } else if (void.class.equals(clazz)) {
+      return VoidName.VOID;
+    } else if (clazz.isArray()) {
+      return new ArrayTypeName(forClass(clazz.getComponentType()));
+    } else {
+      return ClassName.fromClass(clazz);
+    }
+  }
+
   public static TypeName forTypeMirror(TypeMirror mirror) {
     return mirror.accept(new SimpleTypeVisitor6<TypeName, Void>() {
       @Override
@@ -26,8 +40,8 @@ protected TypeName defaultAction(TypeMirror e, Void p) {
       }
 
       @Override
-      public TypeName visitArray(ArrayType t, Void p) {
-        return super.visitArray(t, p);
+      public ArrayTypeName visitArray(ArrayType t, Void p) {
+        return new ArrayTypeName(t.getComponentType().accept(this, null));
       }
 
       @Override
@@ -40,14 +54,31 @@ public TypeName visitDeclared(DeclaredType t, Void p) {
       }
 
       @Override
-      public TypeName visitPrimitive(PrimitiveType t, Void p) {
+      public PrimitiveName visitPrimitive(PrimitiveType t, Void p) {
         return PrimitiveName.forTypeMirror(t);
       }
 
       @Override
-      public TypeName visitWildcard(WildcardType t, Void p) {
+      public WildcardName visitWildcard(WildcardType t, Void p) {
         return WildcardName.forTypeMirror(t);
       }
+
+      @Override
+      public NullName visitNull(NullType t, Void p) {
+        return NullName.NULL;
+      }
+
+      @Override
+      public TypeName visitNoType(NoType t, Void p) {
+        switch (t.getKind()) {
+          case VOID:
+            return VoidName.VOID;
+          case PACKAGE:
+            throw new IllegalArgumentException();
+          default:
+            throw new IllegalStateException();
+        }
+      }
     }, null);
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/TypeVariableName.java b/compiler/src/main/java/dagger/internal/codegen/writer/TypeVariableName.java
index e47f42cc3..662bc2aeb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/TypeVariableName.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/TypeVariableName.java
@@ -2,7 +2,6 @@
 
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
 import java.io.IOException;
 import java.util.Set;
 
@@ -34,8 +33,7 @@ public String name() {
   }
 
   @Override
-  public Appendable write(Appendable appendable, CompilationUnitContext context)
-      throws IOException {
+  public Appendable write(Appendable appendable, Context context) throws IOException {
     appendable.append(name);
     if (extendsBound.isPresent()) {
       appendable.append(' ');
@@ -50,14 +48,7 @@ public Appendable write(Appendable appendable, CompilationUnitContext context)
 
   @Override
   public String toString() {
-    StringBuilder builder = new StringBuilder(name);
-    if (extendsBound.isPresent()) {
-      builder.append(' ').append(extendsBound.get());
-    }
-    if (superBound.isPresent()) {
-      builder.append(' ').append(superBound.get());
-    }
-    return builder.toString();
+    return Writables.writeToString(this);
   }
 
   static TypeVariableName named(String name) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java
index 5d2cf2a2f..53339127c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java
@@ -1,6 +1,5 @@
 package dagger.internal.codegen.writer;
 
-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
 import java.io.IOException;
 import java.util.Set;
 
@@ -23,8 +22,7 @@ public String name() {
   }
 
   @Override
-  public Appendable write(Appendable appendable, CompilationUnitContext context)
-      throws IOException {
+  public Appendable write(Appendable appendable, Context context) throws IOException {
     writeModifiers(appendable);
     type.write(appendable, context);
     return appendable.append(' ').append(name);
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/VoidName.java b/compiler/src/main/java/dagger/internal/codegen/writer/VoidName.java
index c6f36098c..3215d0581 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/VoidName.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/VoidName.java
@@ -1,7 +1,6 @@
 package dagger.internal.codegen.writer;
 
 import com.google.common.collect.ImmutableSet;
-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
 import java.io.IOException;
 import java.util.Set;
 
@@ -19,8 +18,7 @@ public String toString() {
   }
 
   @Override
-  public Appendable write(Appendable appendable, CompilationUnitContext context)
-      throws IOException {
+  public Appendable write(Appendable appendable, Context context) throws IOException {
     return appendable.append("void");
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/WildcardName.java b/compiler/src/main/java/dagger/internal/codegen/writer/WildcardName.java
index 9472223d9..c4fab1dd7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/WildcardName.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/WildcardName.java
@@ -2,12 +2,11 @@
 
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
 import java.io.IOException;
 import java.util.Set;
 import javax.lang.model.type.WildcardType;
 
-import static dagger.internal.codegen.writer.TypeReferences.FOR_TYPE_MIRROR;
+import static dagger.internal.codegen.writer.TypeNames.FOR_TYPE_MIRROR;
 
 public class WildcardName implements TypeName {
   private final Optional<TypeName> extendsBound;
@@ -38,8 +37,7 @@ static WildcardName forTypeMirror(WildcardType mirror) {
   }
 
   @Override
-  public Appendable write(Appendable appendable, CompilationUnitContext context)
-      throws IOException {
+  public Appendable write(Appendable appendable, Context context) throws IOException {
     appendable.append('?');
     if (extendsBound.isPresent()) {
       appendable.append(" extends ");
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Writable.java b/compiler/src/main/java/dagger/internal/codegen/writer/Writable.java
index 7d3808c7b..65e5c124b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/Writable.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/Writable.java
@@ -1,8 +1,12 @@
 package dagger.internal.codegen.writer;
 
-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
 import java.io.IOException;
 
 interface Writable {
-  Appendable write(Appendable appendable, CompilationUnitContext context) throws IOException;
+  interface Context {
+    String sourceReferenceForClassName(ClassName className);
+    String compressTypesWithin(String snippet);
+  }
+
+  Appendable write(Appendable appendable, Context context) throws IOException;
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Writables.java b/compiler/src/main/java/dagger/internal/codegen/writer/Writables.java
index 379540a91..ac0f41d87 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/Writables.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/Writables.java
@@ -1,18 +1,39 @@
 package dagger.internal.codegen.writer;
 
-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
+import dagger.internal.codegen.writer.Writable.Context;
 import java.io.IOException;
 
 final class Writables {
   static Writable toStringWritable(final Object object) {
     return new Writable() {
       @Override
-      public Appendable write(Appendable appendable, CompilationUnitContext ignored)
-          throws IOException {
+      public Appendable write(Appendable appendable, Context context) throws IOException {
         return appendable.append(object.toString());
       }
     };
   }
 
+  private static Context DEFAULT_CONTEXT = new Context() {
+    @Override
+    public String sourceReferenceForClassName(ClassName className) {
+      return className.canonicalName();
+    }
+
+    @Override
+    public String compressTypesWithin(String snippet) {
+      return snippet;
+    }
+  };
+
+  static String writeToString(Writable writable) {
+    StringBuilder builder = new StringBuilder();
+    try {
+      writable.write(builder, DEFAULT_CONTEXT);
+    } catch (IOException e) {
+      throw new AssertionError("StringBuilder doesn't throw IOException", e);
+    }
+    return builder.toString();
+  }
+
   private Writables() {}
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleProcessorTest.java
index 6a3b885d0..f9b33a102 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleProcessorTest.java
@@ -437,4 +437,45 @@
         .withErrorContaining(PROVIDES_METHOD_WITH_SAME_NAME).in(moduleFile).onLine(8)
         .and().withErrorContaining(PROVIDES_METHOD_WITH_SAME_NAME).in(moduleFile).onLine(12);
   }
+
+  @Test
+  public void providedTypes() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import java.io.Closeable;",
+        "import java.util.Set;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides String string() {",
+        "    return null;",
+        "  }",
+        "",
+        "  @Provides Set<String> strings() {",
+        "    return null;",
+        "  }",
+        "",
+        "  @Provides Set<? extends Closeable> closeables() {",
+        "    return null;",
+        "  }",
+        "",
+        "  @Provides String[] stringArray() {",
+        "    return null;",
+        "  }",
+        "",
+        "  @Provides int integer() {",
+        "    return 0;",
+        "  }",
+        "",
+        "  @Provides int[] integers() {",
+        "    return null;",
+        "  }",
+        "}");
+    ASSERT.about(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/writer/TypeNamesTest.java b/compiler/src/test/java/dagger/internal/codegen/writer/TypeNamesTest.java
new file mode 100644
index 000000000..08a114f84
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/writer/TypeNamesTest.java
@@ -0,0 +1,84 @@
+package dagger.internal.codegen.writer;
+
+import com.google.testing.compile.CompilationRule;
+import java.nio.charset.Charset;
+import java.util.Set;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static org.truth0.Truth.ASSERT;
+
+@RunWith(JUnit4.class)
+public class TypeNamesTest {
+  @Rule public final CompilationRule compilation = new CompilationRule();
+
+  private TypeElement getElement(Class<?> clazz) {
+    return compilation.getElements().getTypeElement(clazz.getCanonicalName());
+  }
+
+  private TypeMirror getType(Class<?> clazz) {
+    return getElement(clazz).asType();
+  }
+
+  @Test
+  public void forTypeMirror_basicTypes() {
+    ASSERT.that(TypeNames.forTypeMirror(getType(Object.class)))
+        .isEqualTo(ClassName.fromClass(Object.class));
+    ASSERT.that(TypeNames.forTypeMirror(getType(Charset.class)))
+        .isEqualTo(ClassName.fromClass(Charset.class));
+    ASSERT.that(TypeNames.forTypeMirror(getType(TypeNamesTest.class)))
+        .isEqualTo(ClassName.fromClass(TypeNamesTest.class));
+  }
+
+  @Test
+  public void forTypeMirror_parameterizedType() {
+    DeclaredType setType =
+        compilation.getTypes().getDeclaredType(getElement(Set.class), getType(Object.class));
+    ASSERT.that(TypeNames.forTypeMirror(setType))
+        .isEqualTo(ParameterizedTypeName.create(Set.class, ClassName.fromClass(Object.class)));
+  }
+
+  @Test
+  public void forTypeMirror_primitive() {
+    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.BOOLEAN)))
+        .isEqualTo(PrimitiveName.BOOLEAN);
+    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.BYTE)))
+        .isEqualTo(PrimitiveName.BYTE);
+    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.SHORT)))
+        .isEqualTo(PrimitiveName.SHORT);
+    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.INT)))
+        .isEqualTo(PrimitiveName.INT);
+    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.LONG)))
+        .isEqualTo(PrimitiveName.LONG);
+    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.CHAR)))
+        .isEqualTo(PrimitiveName.CHAR);
+    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.FLOAT)))
+        .isEqualTo(PrimitiveName.FLOAT);
+    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.DOUBLE)))
+        .isEqualTo(PrimitiveName.DOUBLE);
+  }
+
+  @Test
+  public void forTypeMirror_arrays() {
+    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getArrayType(getType(Object.class))))
+        .isEqualTo(new ArrayTypeName(ClassName.fromClass(Object.class)));
+  }
+
+  @Test
+  public void forTypeMirror_void() {
+    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getNoType(TypeKind.VOID)))
+        .isEqualTo(VoidName.VOID);
+  }
+
+  @Test
+  public void forTypeMirror_null() {
+    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getNullType()))
+        .isEqualTo(NullName.NULL);
+  }
+}
