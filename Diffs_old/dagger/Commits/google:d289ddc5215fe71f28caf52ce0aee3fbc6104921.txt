diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index fe7d31792..ebca7072f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -484,27 +484,25 @@ private void addField(ResolvedBindings resolvedBindings) {
 
     // TODO(gak): get rid of the field for unscoped delegated bindings
 
-    FieldSpec frameworkField = addFrameworkField(resolvedBindings, Optional.<BindingType>absent());
-    memberSelects.put(
-        bindingKey,
-        localField(name, frameworkField.name));
+    FieldSpec frameworkField = addFrameworkField(resolvedBindings, Optional.<ClassName>absent());
+    memberSelects.put(bindingKey, localField(name, frameworkField.name));
   }
 
   /**
    * Adds a field representing the resolved bindings, optionally forcing it to use a particular
-   * binding type (instead of the type the resolved bindings would typically use).
+   * framework class (instead of the class the resolved bindings would typically use).
    */
   private FieldSpec addFrameworkField(
-      ResolvedBindings resolvedBindings, Optional<BindingType> bindingType) {
+      ResolvedBindings resolvedBindings, Optional<ClassName> frameworkClass) {
     boolean useRawType = useRawType(resolvedBindings);
 
     FrameworkField contributionBindingField =
-        FrameworkField.createForResolvedBindings(resolvedBindings, bindingType);
+        FrameworkField.forResolvedBindings(resolvedBindings, frameworkClass);
     FieldSpec.Builder contributionField =
         componentField(
             useRawType
-                ? contributionBindingField.frameworkType().rawType
-                : contributionBindingField.frameworkType(),
+                ? contributionBindingField.type().rawType
+                : contributionBindingField.type(),
             contributionBindingField.name());
     contributionField.addModifiers(PRIVATE);
     if (useRawType) {
@@ -872,7 +870,7 @@ private CodeBlock initializeProducersFromProviderDependencies(Binding binding) {
           continue;
         }
         FieldSpec frameworkField =
-            addFrameworkField(resolvedBindings, Optional.of(BindingType.PRODUCTION));
+            addFrameworkField(resolvedBindings, Optional.of(PRODUCER));
         memberSelect = localField(name, frameworkField.name);
         producerFromProviderMemberSelects.put(frameworkDependency.bindingKey(), memberSelect);
         initializations.add(
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 5396285b9..cb2a5141e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -140,7 +140,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
         }
         for (FrameworkField bindingField : fields.values()) {
           addConstructorParameterAndTypeField(
-              bindingField.frameworkType(),
+              bindingField.type(),
               bindingField.name(),
               factoryBuilder,
               constructorBuilder.get());
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
index c1d4e1ac2..14e732c65 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
@@ -15,7 +15,6 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.CaseFormat;
 import com.google.common.base.Optional;
@@ -30,44 +29,47 @@
 import javax.lang.model.util.ElementKindVisitor6;
 
 /**
- * A value object that represents a field used by Dagger-generated code.
- *
- * @author Jesse Beder
- * @since 2.0
+ * A field that holds a {@link javax.inject.Provider}, {@link dagger.producers.Producer}, or other
+ * framework type.
  */
 @AutoValue
-// TODO(gak): Reexamine the this class and how consistently we're using it and its creation methods.
 abstract class FrameworkField {
-  static FrameworkField createWithTypeFromKey(Class<?> frameworkClass, Key key, String name) {
-    String suffix = frameworkClass.getSimpleName();
-    ParameterizedTypeName frameworkType =
-        ParameterizedTypeName.get(ClassName.get(frameworkClass), TypeName.get(key.type()));
+
+  /**
+   * Creates a framework field.
+   * 
+   * @param frameworkClassName the name of the framework class (e.g., {@link javax.inject.Provider})
+   * @param valueTypeName the name of the type parameter of the framework class (e.g., {@code Foo}
+   *     for {@code Provider<Foo>}
+   * @param fieldName the name of the field
+   */
+  static FrameworkField create(
+      ClassName frameworkClassName, TypeName valueTypeName, String fieldName) {
+    String suffix = frameworkClassName.simpleName();
     return new AutoValue_FrameworkField(
-        frameworkType, name.endsWith(suffix) ? name : name + suffix);
+        ParameterizedTypeName.get(frameworkClassName, valueTypeName),
+        fieldName.endsWith(suffix) ? fieldName : fieldName + suffix);
   }
 
-  private static FrameworkField createForMapBindingContribution(Key key, String name) {
-    TypeMirror type = MapType.from(key.type()).valueType();
-    String suffix = MoreTypes.asDeclared(type).asElement().getSimpleName().toString();
-    return new AutoValue_FrameworkField(
-        (ParameterizedTypeName) TypeName.get(type),
-        name.endsWith(suffix) ? name : name + suffix);
+  /**
+   * A framework field for a {@link ResolvedBindings}.
+   * 
+   * @param frameworkClass if present, the field will use this framework class instead of the normal
+   *     one for the bindings
+   */
+  static FrameworkField forResolvedBindings(
+      ResolvedBindings resolvedBindings, Optional<ClassName> frameworkClass) {
+    return create(frameworkClass.or(ClassName.get(resolvedBindings.frameworkClass())),
+        TypeName.get(fieldValueType(resolvedBindings)),
+        frameworkFieldName(resolvedBindings));
   }
 
-  static FrameworkField createForResolvedBindings(
-      ResolvedBindings resolvedBindings, Optional<BindingType> bindingType) {
-    if (resolvedBindings.isMultibindingContribution()
-        && resolvedBindings.contributionType().equals(ContributionType.MAP)) {
-      return createForMapBindingContribution(
-          resolvedBindings.key(), frameworkFieldName(resolvedBindings));
-    } else {
-      return createWithTypeFromKey(
-          bindingType.isPresent()
-              ? bindingType.get().frameworkClass()
-              : resolvedBindings.frameworkClass(),
-          resolvedBindings.key(),
-          frameworkFieldName(resolvedBindings));
-    }
+  private static TypeMirror fieldValueType(ResolvedBindings resolvedBindings) {
+    return resolvedBindings.isMultibindingContribution()
+            && resolvedBindings.contributionType().equals(ContributionType.MAP)
+        ? MapType.from(resolvedBindings.key().type())
+            .unwrappedValueType(resolvedBindings.frameworkClass())
+        : resolvedBindings.key().type();
   }
 
   private static String frameworkFieldName(ResolvedBindings resolvedBindings) {
@@ -104,6 +106,6 @@ public String visitType(TypeElement e, Binding p) {
         }
       };
 
-  abstract ParameterizedTypeName frameworkType();
+  abstract ParameterizedTypeName type();
   abstract String name();
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index ac1b505db..1e70eeddb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -155,8 +155,8 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
       String fieldName = fieldNames.getUniqueName(bindingField.name());
       TypeName fieldType =
           useRawFrameworkType
-              ? bindingField.frameworkType().rawType
-              : bindingField.frameworkType();
+              ? bindingField.type().rawType
+              : bindingField.type();
       FieldSpec.Builder fieldBuilder = FieldSpec.builder(fieldType, fieldName, PRIVATE, FINAL);
       ParameterSpec.Builder parameterBuilder = ParameterSpec.builder(fieldType, fieldName);
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 41fd0c0e7..8fbd1d0f1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -117,9 +117,8 @@ ClassName nameGeneratedType(ProductionBinding binding) {
     }
 
     for (FrameworkField bindingField : fields.values()) {
-      TypeName fieldType = bindingField.frameworkType();
       addFieldAndConstructorParameter(
-          factoryBuilder, constructorBuilder, bindingField.name(), fieldType);
+          factoryBuilder, constructorBuilder, bindingField.name(), bindingField.type());
     }
 
     MethodSpec.Builder computeMethodBuilder =
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index e7885d99b..2d9e2fb8c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -88,9 +88,9 @@ public int compare(DependencyRequest left, DependencyRequest right) {
     for (FrameworkDependency frameworkDependency : frameworkDependenciesForBinding(binding)) {
       bindingFields.put(
           frameworkDependency.bindingKey(),
-          FrameworkField.createWithTypeFromKey(
-              frameworkDependency.frameworkClass(),
-              frameworkDependency.bindingKey().key(),
+          FrameworkField.create(
+              ClassName.get(frameworkDependency.frameworkClass()),
+              TypeName.get(frameworkDependency.bindingKey().key().type()),
               fieldNameForDependency(frameworkDependency)));
     }
     return bindingFields.build();
diff --git a/compiler/src/test/java/dagger/internal/codegen/BindingFieldTest.java b/compiler/src/test/java/dagger/internal/codegen/BindingFieldTest.java
deleted file mode 100644
index 607b5cbc0..000000000
--- a/compiler/src/test/java/dagger/internal/codegen/BindingFieldTest.java
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.common.collect.Iterables;
-import com.google.testing.compile.CompilationRule;
-import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.ParameterizedTypeName;
-import com.squareup.javapoet.TypeName;
-import dagger.MembersInjector;
-import javax.inject.Inject;
-import javax.inject.Provider;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.util.ElementFilter;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static com.google.common.truth.Truth.assertThat;
-
-/**
- * Test case for {@link FrameworkField}.
- */
-@RunWith(JUnit4.class)
-public class BindingFieldTest {
-  @Rule public CompilationRule compilationRule = new CompilationRule();
-
-  private Elements elements;
-  private Types types;
-  private Key.Factory keyFactory;
-
-  @Before public void setUp() {
-    this.types = compilationRule.getTypes();
-    this.elements = compilationRule.getElements();
-    this.keyFactory = new Key.Factory(types, elements);
-  }
-
-  private ExecutableElement getXConstructor() {
-    TypeElement classElement = elements.getTypeElement(X.class.getCanonicalName());
-    return Iterables.getOnlyElement(
-        ElementFilter.constructorsIn(classElement.getEnclosedElements()));
-  }
-
-  @Test public void frameworkType() {
-    Key key = keyFactory.forInjectConstructorWithResolvedType(
-        getXConstructor().getEnclosingElement().asType());
-    TypeName xClass = TypeName.get(key.type());
-    assertThat(FrameworkField.createWithTypeFromKey(Provider.class, key, "test").frameworkType())
-        .isEqualTo(ParameterizedTypeName.get(ClassName.get(Provider.class), xClass));
-    assertThat(
-            FrameworkField.createWithTypeFromKey(MembersInjector.class, key, "test")
-                .frameworkType())
-        .isEqualTo(ParameterizedTypeName.get(ClassName.get(MembersInjector.class), xClass));
-  }
-
-  @Test public void nameSuffix() {
-    Key key = keyFactory.forInjectConstructorWithResolvedType(
-        getXConstructor().getEnclosingElement().asType());
-    assertThat(FrameworkField.createWithTypeFromKey(Provider.class, key, "foo").name())
-        .isEqualTo("fooProvider");
-    assertThat(FrameworkField.createWithTypeFromKey(Provider.class, key, "fooProvider").name())
-        .isEqualTo("fooProvider");
-
-  }
-
-  static final class X {
-    @Inject X() {}
-  }
-}
diff --git a/compiler/src/test/java/dagger/internal/codegen/FrameworkFieldTest.java b/compiler/src/test/java/dagger/internal/codegen/FrameworkFieldTest.java
new file mode 100644
index 000000000..118b8484b
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/FrameworkFieldTest.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.testing.compile.CompilationRule;
+import com.squareup.javapoet.ClassName;
+import javax.inject.Inject;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+import static dagger.internal.codegen.TypeNames.MEMBERS_INJECTOR;
+import static dagger.internal.codegen.TypeNames.PROVIDER;
+import static dagger.internal.codegen.TypeNames.membersInjectorOf;
+import static dagger.internal.codegen.TypeNames.providerOf;
+
+/**
+ * Test case for {@link FrameworkField}.
+ */
+@RunWith(JUnit4.class)
+public class FrameworkFieldTest {
+  @Rule public CompilationRule compilationRule = new CompilationRule();
+
+  private ClassName xTypeName;
+
+  @Before public void setUp() {
+    xTypeName =
+        ClassName.get(compilationRule.getElements().getTypeElement(X.class.getCanonicalName()));
+  }
+
+  @Test public void frameworkType() {
+    assertThat(FrameworkField.create(PROVIDER, xTypeName, "test").type())
+        .isEqualTo(providerOf(xTypeName));
+    assertThat(FrameworkField.create(MEMBERS_INJECTOR, xTypeName, "test").type())
+        .isEqualTo(membersInjectorOf(xTypeName));
+  }
+
+  @Test public void nameSuffix() {
+    assertThat(FrameworkField.create(PROVIDER, xTypeName, "foo").name())
+        .isEqualTo("fooProvider");
+    assertThat(FrameworkField.create(PROVIDER, xTypeName, "fooProvider").name())
+        .isEqualTo("fooProvider");
+  }
+
+  static final class X {
+    @Inject X() {}
+  }
+}
