diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 82fbcee2e..e1636eabc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -709,13 +709,22 @@ private void addSubcomponents() {
     }
   }
 
+  private static final int SNIPPETS_PER_INITIALIZATION_METHOD = 100;
+
   private void initializeFrameworkTypes() {
-    List<List<BindingKey>> partitions =
-        Lists.partition(graph.resolvedBindings().keySet().asList(), 100);
+    ImmutableList.Builder<Snippet> snippetsBuilder = ImmutableList.builder();
+    for (BindingKey bindingKey : graph.resolvedBindings().keySet()) {
+      snippetsBuilder.add(initializeFrameworkType(bindingKey));
+    }
+    ImmutableList<Snippet> snippets = snippetsBuilder.build();
+
+    List<List<Snippet>> partitions = Lists.partition(snippets, SNIPPETS_PER_INITIALIZATION_METHOD);
     for (int i = 0; i < partitions.size(); i++) {
       MethodWriter initializeMethod =
           componentWriter.addMethod(VoidName.VOID, "initialize" + ((i == 0) ? "" : i));
-      initializeMethod.body();
+      for (Snippet snippet : partitions.get(i)) {
+        initializeMethod.body().addSnippet(snippet);
+      }
       initializeMethod.addModifiers(PRIVATE);
       if (builderName.isPresent()) {
         initializeMethod.addParameter(builderName.get(), "builder").addModifiers(FINAL);
@@ -723,38 +732,43 @@ private void initializeFrameworkTypes() {
       } else {
         constructorWriter.body().addSnippet("%s();", initializeMethod.name());
       }
-      for (BindingKey bindingKey : partitions.get(i)) {
-        ResolvedBindings resolvedBindings = graph.resolvedBindings().get(bindingKey);
-        switch (bindingKey.kind()) {
-          case CONTRIBUTION:
-            switch (contributionTypeFor(resolvedBindings.contributionBindings())) {
-              case SET:
-                initializeSetMultibindings(initializeMethod, resolvedBindings);
-                break;
-              case MAP:
-                initializeMapMultibindings(initializeMethod, resolvedBindings);
-                break;
-              case UNIQUE:
-                initializeUniqueContributionBinding(initializeMethod, resolvedBindings);
-                break;
-              default:
-                throw new AssertionError();
-            }
-            break;
 
-          case MEMBERS_INJECTION:
-            initializeMembersInjectionBinding(initializeMethod, resolvedBindings);
-            break;
+    }
+  }
 
+  /**
+   * Returns a single snippet representing the initialization of the framework type.
+   *
+   * <p>Note that this must be a single snippet because initialization snippets can be invoked from
+   * any place in any order.  By requiring a single snippet (often of concatenated snippets) we
+   * ensure that things like local variables always behave as expected by the initialization logic.
+   */
+  private Snippet initializeFrameworkType(BindingKey bindingKey) {
+    ResolvedBindings resolvedBindings = graph.resolvedBindings().get(bindingKey);
+    switch (bindingKey.kind()) {
+      case CONTRIBUTION:
+        switch (contributionTypeFor(resolvedBindings.contributionBindings())) {
+          case SET:
+            return initializeSetMultibindings(resolvedBindings);
+          case MAP:
+            return initializeMapMultibindings(resolvedBindings);
+          case UNIQUE:
+            return initializeUniqueContributionBinding(resolvedBindings);
           default:
             throw new AssertionError();
         }
-      }
+
+      case MEMBERS_INJECTION:
+        return initializeMembersInjectionBinding(resolvedBindings);
+
+      default:
+        throw new AssertionError();
     }
   }
 
-  private void initializeSetMultibindings(
-      MethodWriter initializeMethod, ResolvedBindings resolvedBindings) {
+  private Snippet initializeSetMultibindings(ResolvedBindings resolvedBindings) {
+    ImmutableList.Builder<Snippet> initializationSnippets = ImmutableList.builder();
+
     ImmutableList.Builder<Snippet> parameterSnippets = ImmutableList.builder();
     for (ContributionBinding binding : resolvedBindings.contributionBindings()) {
       Optional<MemberSelect> multibindingContributionSnippet =
@@ -767,7 +781,7 @@ private void initializeSetMultibindings(
           && getContributionInitializationState(binding)
               .equals(InitializationState.UNINITIALIZED)) {
         Snippet initializeSnippet = initializeFactoryForContributionBinding(binding);
-        initializeMethod.body().addSnippet("this.%s = %s;", snippet, initializeSnippet);
+        initializationSnippets.add(Snippet.format("this.%s = %s;", snippet, initializeSnippet));
         setContributionInitializationState(binding, InitializationState.INITIALIZED);
       }
       parameterSnippets.add(snippet);
@@ -783,11 +797,15 @@ private void initializeSetMultibindings(
             "%s.create(%s)",
             ClassName.fromClass(factoryClass),
             makeParametersSnippet(parameterSnippets.build()));
-    initializeMember(initializeMethod, resolvedBindings.bindingKey(), initializeSetSnippet);
+    initializationSnippets.add(
+        initializeMember(resolvedBindings.bindingKey(), initializeSetSnippet));
+
+    return Snippet.concat(initializationSnippets.build());
   }
 
-  private void initializeMapMultibindings(
-      MethodWriter initializeMethod, ResolvedBindings resolvedBindings) {
+  private Snippet initializeMapMultibindings(ResolvedBindings resolvedBindings) {
+    ImmutableList.Builder<Snippet> initializationSnippets = ImmutableList.builder();
+
     if (any(resolvedBindings.contributionBindings(), Binding.Type.PRODUCTION)) {
       // TODO(beder): Implement producer map bindings.
       throw new IllegalStateException("producer map bindings not implemented yet");
@@ -798,47 +816,54 @@ private void initializeMapMultibindings(
       if (!isMapWithNonProvidedValues(binding.key().type())
           && multibindingContributionSnippet.isPresent()
           && multibindingContributionSnippet.get().owningClass().equals(name)) {
-        initializeMethod
-            .body()
-            .addSnippet(
+        initializationSnippets.add(
+            Snippet.format(
                 "this.%s = %s;",
                 multibindingContributionSnippet.get().getSnippetFor(name),
-                initializeFactoryForContributionBinding(binding));
+                initializeFactoryForContributionBinding(binding)));
       }
     }
-    initializeMember(
-        initializeMethod,
-        resolvedBindings.bindingKey(),
-        initializeMapBinding(resolvedBindings.contributionBindings()));
+    initializationSnippets.add(
+        initializeMember(
+            resolvedBindings.bindingKey(),
+            initializeMapBinding(resolvedBindings.contributionBindings())));
+
+    return Snippet.concat(initializationSnippets.build());
   }
 
-  private void initializeUniqueContributionBinding(
-      MethodWriter initializeMethod, ResolvedBindings resolvedBindings) {
+  private Snippet initializeUniqueContributionBinding(ResolvedBindings resolvedBindings) {
+    ImmutableList.Builder<Snippet> initializationSnippets = ImmutableList.builder();
+
     if (!resolvedBindings.ownedContributionBindings().isEmpty()) {
       ContributionBinding binding = getOnlyElement(resolvedBindings.ownedContributionBindings());
       if (!binding.factoryCreationStrategy().equals(ENUM_INSTANCE) || binding.scope().isPresent()) {
-        initializeDelegateFactories(binding, initializeMethod);
-        initializeMember(
-            initializeMethod,
-            resolvedBindings.bindingKey(),
-            initializeFactoryForContributionBinding(binding));
+        initializationSnippets.add(initializeDelegateFactories(binding));
+        initializationSnippets.add(
+            initializeMember(
+                resolvedBindings.bindingKey(), initializeFactoryForContributionBinding(binding)));
       }
     }
+
+    return Snippet.concat(initializationSnippets.build());
   }
 
-  private void initializeMembersInjectionBinding(
-      MethodWriter initializeMethod, ResolvedBindings resolvedBindings) {
+  private Snippet initializeMembersInjectionBinding(ResolvedBindings resolvedBindings) {
+    ImmutableList.Builder<Snippet> initializationSnippets = ImmutableList.builder();
+
     MembersInjectionBinding binding = getOnlyElement(resolvedBindings.membersInjectionBindings());
     if (!binding.injectionStrategy().equals(MembersInjectionBinding.Strategy.NO_OP)) {
-      initializeDelegateFactories(binding, initializeMethod);
-      initializeMember(
-          initializeMethod,
-          resolvedBindings.bindingKey(),
-          initializeMembersInjectorForBinding(binding));
+      initializationSnippets.add(initializeDelegateFactories(binding));
+      initializationSnippets.add(
+          initializeMember(
+              resolvedBindings.bindingKey(), initializeMembersInjectorForBinding(binding)));
     }
+
+    return Snippet.concat(initializationSnippets.build());
   }
 
-  private void initializeDelegateFactories(Binding binding, MethodWriter initializeMethod) {
+  private Snippet initializeDelegateFactories(Binding binding) {
+    ImmutableList.Builder<Snippet> initializationSnippets = ImmutableList.builder();
+
     for (Collection<DependencyRequest> requestsForKey :
         indexDependenciesByUnresolvedKey(types, binding.dependencies()).asMap().values()) {
       BindingKey dependencyKey =
@@ -848,37 +873,40 @@ private void initializeDelegateFactories(Binding binding, MethodWriter initializ
                   .toSet());
       if (!getMemberSelect(dependencyKey).staticMember()
           && getInitializationState(dependencyKey).equals(UNINITIALIZED)) {
-        initializeMethod
-            .body()
-            .addSnippet(
+        initializationSnippets.add(
+            Snippet.format(
                 "this.%s = new %s();",
                 getMemberSelectSnippet(dependencyKey),
-                ClassName.fromClass(DelegateFactory.class));
+                ClassName.fromClass(DelegateFactory.class)));
         setInitializationState(dependencyKey, DELEGATED);
       }
     }
+
+    return Snippet.concat(initializationSnippets.build());
   }
 
-  private void initializeMember(
-      MethodWriter initializeMethod, BindingKey bindingKey, Snippet initializationSnippet) {
+  private Snippet initializeMember(BindingKey bindingKey, Snippet initializationSnippet) {
+    ImmutableList.Builder<Snippet> initializationSnippets = ImmutableList.builder();
+
     Snippet memberSelect = getMemberSelectSnippet(bindingKey);
     Snippet delegateFactoryVariable = delegateFactoryVariableSnippet(bindingKey);
     if (getInitializationState(bindingKey).equals(DELEGATED)) {
-      initializeMethod
-          .body()
-          .addSnippet(
+      initializationSnippets.add(
+          Snippet.format(
               "%1$s %2$s = (%1$s) %3$s;",
               ClassName.fromClass(DelegateFactory.class),
               delegateFactoryVariable,
-              memberSelect);
+              memberSelect));
     }
-    initializeMethod.body().addSnippet("this.%s = %s;", memberSelect, initializationSnippet);
+    initializationSnippets.add(
+        Snippet.format("this.%s = %s;", memberSelect, initializationSnippet));
     if (getInitializationState(bindingKey).equals(DELEGATED)) {
-      initializeMethod
-          .body()
-          .addSnippet("%s.setDelegatedProvider(%s);", delegateFactoryVariable, memberSelect);
+      initializationSnippets.add(
+          Snippet.format("%s.setDelegatedProvider(%s);", delegateFactoryVariable, memberSelect));
     }
     setInitializationState(bindingKey, INITIALIZED);
+
+    return Snippet.concat(initializationSnippets.build());
   }
 
   private Snippet delegateFactoryVariableSnippet(BindingKey key) {
@@ -1130,7 +1158,7 @@ private Snippet initializeMapBinding(Set<? extends ContributionBinding> bindings
 
     snippets.add(Snippet.format("    .build()"));
 
-    return Snippet.join(Joiner.on('\n'), snippets.build());
+    return Snippet.concat(snippets.build());
   }
 
   private static String simpleVariableName(TypeElement typeElement) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java b/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java
index 2d11f60f7..80ab944f8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java
@@ -27,28 +27,9 @@
 import java.util.Iterator;
 import java.util.Set;
 
-public final class Snippet implements HasClassReferences, Writable {
-  private final String format;
-  private final ImmutableSet<TypeName> types;
-  private final ImmutableList<Object> args;
-
-  private Snippet(String format, ImmutableSet<TypeName> types, ImmutableList<Object> args) {
-    this.format = format;
-    this.types = types;
-    this.args = args;
-  }
-
-  public String format() {
-    return format;
-  }
+public abstract class Snippet implements HasClassReferences, Writable {
 
-  public ImmutableList<Object> args() {
-    return args;
-  }
-
-  public ImmutableSet<TypeName> types() {
-    return types;
-  }
+  abstract ImmutableSet<TypeName> types();
 
   @Override
   public String toString() {
@@ -56,40 +37,96 @@ public String toString() {
   }
 
   @Override
-  public Set<ClassName> referencedClasses() {
-    return FluentIterable.from(types)
-        .transformAndConcat(new Function<TypeName, Set<ClassName>>() {
-          @Override
-          public Set<ClassName> apply(TypeName input) {
-            return input.referencedClasses();
-          }
-        })
+  public final Set<ClassName> referencedClasses() {
+    return FluentIterable.from(types())
+        .transformAndConcat(
+            new Function<TypeName, Set<ClassName>>() {
+              @Override
+              public Set<ClassName> apply(TypeName input) {
+                return input.referencedClasses();
+              }
+            })
         .toSet();
   }
 
-  @Override
-  public Appendable write(Appendable appendable, Context context) throws IOException {
-    ImmutableList.Builder<Object> formattedArgsBuilder = ImmutableList.builder();
-    for (Object arg : args) {
-      if (arg instanceof Writable) {
-        formattedArgsBuilder.add(((Writable) arg).write(new StringBuilder(), context).toString());
-      } else {
-        formattedArgsBuilder.add(arg);
+  private static final class BasicSnippet extends Snippet {
+    final String format;
+    final ImmutableSet<TypeName> types;
+    final ImmutableList<Object> args;
+
+    BasicSnippet(String format, ImmutableSet<TypeName> types, ImmutableList<Object> args) {
+      this.format = format;
+      this.types = types;
+      this.args = args;
+    }
+
+    @Override
+    ImmutableSet<TypeName> types() {
+      return types;
+    }
+
+    @Override
+    public Appendable write(Appendable appendable, Context context) throws IOException {
+      ImmutableList.Builder<Object> formattedArgsBuilder = ImmutableList.builder();
+      for (Object arg : args) {
+        if (arg instanceof Writable) {
+          formattedArgsBuilder.add(((Writable) arg).write(new StringBuilder(), context).toString());
+        } else {
+          formattedArgsBuilder.add(arg);
+        }
       }
+
+      @SuppressWarnings("resource") // intentionally don't close the formatter
+      Formatter formatter = new Formatter(appendable);
+      formatter.format(format, Iterables.toArray(formattedArgsBuilder.build(), Object.class));
+
+      return appendable;
+    }
+  }
+
+  private static final class CompoundSnippet extends Snippet {
+    final String joinToken;
+    final ImmutableList<Snippet> snippets;
+
+    CompoundSnippet(String joinToken, ImmutableList<Snippet> snippets) {
+      this.joinToken = joinToken;
+      this.snippets = snippets;
     }
 
-    @SuppressWarnings("resource") // intentionally don't close the formatter
-    Formatter formatter = new Formatter(appendable);
-    formatter.format(format, formattedArgsBuilder.build().toArray(new Object[0]));
+    @Override
+    ImmutableSet<TypeName> types() {
+      return FluentIterable.from(snippets)
+          .transformAndConcat(
+              new Function<Snippet, Iterable<TypeName>>() {
+                @Override
+                public Iterable<TypeName> apply(Snippet input) {
+                  return input.types();
+                }
+              })
+          .toSet();
+    }
 
-    return appendable;
+    @Override
+    public Appendable write(Appendable appendable, Context context) throws IOException {
+      Iterator<Snippet> snippetIterator = snippets.iterator();
+      if (snippetIterator.hasNext()) {
+        Snippet firstSnippet = snippetIterator.next();
+        firstSnippet.write(appendable, context);
+        while (snippetIterator.hasNext()) {
+          Snippet nextSnippet = snippetIterator.next();
+          appendable.append(joinToken);
+          nextSnippet.write(appendable, context);
+        }
+      }
+      return appendable;
+    }
   }
 
   public static Snippet format(String format, Object... args) {
     ImmutableSet.Builder<TypeName> types = ImmutableSet.builder();
     for (Object arg : args) {
       if (arg instanceof Snippet) {
-        types.addAll(((Snippet) arg).types);
+        types.addAll(((Snippet) arg).types());
       }
       if (arg instanceof TypeName) {
         types.add((TypeName) arg);
@@ -98,7 +135,7 @@ public static Snippet format(String format, Object... args) {
         types.add(((HasTypeName) arg).name());
       }
     }
-    return new Snippet(format, types.build(), ImmutableList.copyOf(args));
+    return new BasicSnippet(format, types.build(), ImmutableList.copyOf(args));
   }
 
   public static Snippet format(String format, Iterable<? extends Object> args) {
@@ -121,66 +158,20 @@ public static Snippet nullCheck(Object thingToCheck, String message) {
   }
 
   public static Snippet makeParametersSnippet(Iterable<Snippet> parameterSnippets) {
-    Iterator<Snippet> iterator = parameterSnippets.iterator();
-    StringBuilder stringBuilder = new StringBuilder();
-    ImmutableSet.Builder<TypeName> typesBuilder = ImmutableSet.builder();
-    ImmutableList.Builder<Object> argsBuilder = ImmutableList.builder();
-    if (iterator.hasNext()) {
-      Snippet firstSnippet = iterator.next();
-      stringBuilder.append(firstSnippet.format());
-      typesBuilder.addAll(firstSnippet.types());
-      argsBuilder.addAll(firstSnippet.args());
-    }
-    while (iterator.hasNext()) {
-      Snippet nextSnippet = iterator.next();
-      stringBuilder.append(", ").append(nextSnippet.format());
-      typesBuilder.addAll(nextSnippet.types());
-      argsBuilder.addAll(nextSnippet.args());
-    }
-    return new Snippet(stringBuilder.toString(), typesBuilder.build(), argsBuilder.build());
+    return join(", ", parameterSnippets);
   }
 
   /**
-   * A snippet that concatenates its arguments.
+   * A snippet that concatenates its arguments with each snippet separated by a new line.
    */
   public static Snippet concat(Iterable<Snippet> snippets) {
-    return join(Joiner.on(""), snippets);
+    return join("\n", snippets);
   }
 
   /**
    * A snippet that joins its arguments with {@code joiner}.
    */
-  public static Snippet join(Joiner joiner, Iterable<Snippet> snippets) {
-    FluentIterable<Snippet> fluentSnippets = FluentIterable.from(snippets);
-    return new Snippet(
-        joiner
-            .appendTo(
-                new StringBuilder(),
-                fluentSnippets.transform(
-                    new Function<Snippet, String>() {
-                      @Override
-                      public String apply(Snippet snippet) {
-                        return snippet.format;
-                      }
-                    }))
-            .toString(),
-        fluentSnippets
-            .transformAndConcat(
-                new Function<Snippet, ImmutableSet<TypeName>>() {
-                  @Override
-                  public ImmutableSet<TypeName> apply(Snippet snippet) {
-                    return snippet.types;
-                  }
-                })
-            .toSet(),
-        fluentSnippets
-            .transformAndConcat(
-                new Function<Snippet, ImmutableList<Object>>() {
-                  @Override
-                  public ImmutableList<Object> apply(Snippet snippet) {
-                    return snippet.args;
-                  }
-                })
-            .toList());
+  public static Snippet join(String joinToken, Iterable<Snippet> snippets) {
+    return new CompoundSnippet(joinToken, ImmutableList.copyOf(snippets));
   }
 }
