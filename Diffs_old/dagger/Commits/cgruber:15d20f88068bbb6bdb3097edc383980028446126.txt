diff --git a/java/dagger/internal/codegen/BindingGraphConverter.java b/java/dagger/internal/codegen/BindingGraphConverter.java
index c51d66f7d..5b91edf2c 100644
--- a/java/dagger/internal/codegen/BindingGraphConverter.java
+++ b/java/dagger/internal/codegen/BindingGraphConverter.java
@@ -40,15 +40,11 @@
 
 /** Converts {@link dagger.internal.codegen.BindingGraph}s to {@link dagger.model.BindingGraph}s. */
 final class BindingGraphConverter {
-
   private final BindingDeclarationFormatter bindingDeclarationFormatter;
-  private final CompilerOptions compilerOptions;
 
   @Inject
-  BindingGraphConverter(
-      BindingDeclarationFormatter bindingDeclarationFormatter, CompilerOptions compilerOptions) {
+  BindingGraphConverter(BindingDeclarationFormatter bindingDeclarationFormatter) {
     this.bindingDeclarationFormatter = bindingDeclarationFormatter;
-    this.compilerOptions = compilerOptions;
   }
 
   /**
@@ -89,7 +85,7 @@ private ComponentNode rootComponentNode(Network<Node, Edge> network) {
     private ComponentNode currentComponent;
 
     Traverser(BindingGraph graph) {
-      super(graph, compilerOptions);
+      super(graph);
     }
 
     @Override
diff --git a/java/dagger/internal/codegen/ComponentProcessingStep.java b/java/dagger/internal/codegen/ComponentProcessingStep.java
index 32d7d9152..154401cb2 100644
--- a/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -23,6 +23,7 @@
 import static dagger.internal.codegen.ComponentCreatorAnnotation.allCreatorAnnotations;
 import static dagger.internal.codegen.ComponentCreatorAnnotation.rootComponentCreatorAnnotations;
 import static dagger.internal.codegen.ComponentCreatorAnnotation.subcomponentCreatorAnnotations;
+import static dagger.internal.codegen.ValidationType.NONE;
 import static java.util.Collections.disjoint;
 
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
@@ -134,6 +135,9 @@ private void processRootComponent(TypeElement component) {
     if (!isValid(componentDescriptor)) {
       return;
     }
+    if (!isFullBindingGraphValid(componentDescriptor)) {
+      return;
+    }
     BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor, false);
     if (isValid(bindingGraph)) {
       generateComponent(bindingGraph);
@@ -141,7 +145,8 @@ private void processRootComponent(TypeElement component) {
   }
 
   private void processSubcomponent(TypeElement subcomponent) {
-    if (!compilerOptions.aheadOfTimeSubcomponents()) {
+    if (!compilerOptions.aheadOfTimeSubcomponents()
+        && compilerOptions.moduleBindingValidationType(subcomponent).equals(NONE)) {
       return;
     }
     if (!isSubcomponentValid(subcomponent)) {
@@ -150,9 +155,14 @@ private void processSubcomponent(TypeElement subcomponent) {
     ComponentDescriptor subcomponentDescriptor =
         componentDescriptorFactory.subcomponentDescriptor(subcomponent);
     // TODO(dpb): ComponentDescriptorValidator for subcomponents, as we do for root components.
-    BindingGraph bindingGraph = bindingGraphFactory.create(subcomponentDescriptor, false);
-    if (isValid(bindingGraph)) {
-      generateComponent(bindingGraph);
+    if (!isFullBindingGraphValid(subcomponentDescriptor)) {
+      return;
+    }
+    if (compilerOptions.aheadOfTimeSubcomponents()) {
+      BindingGraph bindingGraph = bindingGraphFactory.create(subcomponentDescriptor, false);
+      if (isValid(bindingGraph)) {
+        generateComponent(bindingGraph);
+      }
     }
   }
 
@@ -220,10 +230,17 @@ private boolean isSubcomponentValid(Element subcomponentElement) {
       return false;
     }
     ValidationReport<?> subcomponentReport = reportsBySubcomponent.get(subcomponentElement);
-    if (subcomponentReport != null && !subcomponentReport.isClean()) {
-      return false;
+    return subcomponentReport == null || subcomponentReport.isClean();
+  }
+
+  private boolean isFullBindingGraphValid(ComponentDescriptor componentDescriptor) {
+    if (compilerOptions
+        .moduleBindingValidationType(componentDescriptor.typeElement())
+        .equals(NONE)) {
+      return true;
     }
-    return true;
+    BindingGraph fullBindingGraph = bindingGraphFactory.create(componentDescriptor, true);
+    return isValid(fullBindingGraph);
   }
 
   private boolean isValid(ComponentDescriptor componentDescriptor) {
diff --git a/java/dagger/internal/codegen/ComponentTreeTraverser.java b/java/dagger/internal/codegen/ComponentTreeTraverser.java
index 545ec9922..cc1efd29c 100644
--- a/java/dagger/internal/codegen/ComponentTreeTraverser.java
+++ b/java/dagger/internal/codegen/ComponentTreeTraverser.java
@@ -16,7 +16,6 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.base.Verify.verify;
 import static dagger.internal.codegen.DaggerStreams.toImmutableList;
@@ -47,12 +46,7 @@
   private final Deque<ComponentPath> componentPaths = new ArrayDeque<>();
 
   /** Constructs a traverser for a root (component, not subcomponent) binding graph. */
-  public ComponentTreeTraverser(BindingGraph rootGraph, CompilerOptions compilerOptions) {
-    checkArgument(
-        !rootGraph.componentDescriptor().isSubcomponent()
-            || compilerOptions.aheadOfTimeSubcomponents(),
-        "only root graphs can be traversed, not %s",
-        rootGraph.componentTypeElement().getQualifiedName());
+  public ComponentTreeTraverser(BindingGraph rootGraph) {
     bindingGraphPath.add(rootGraph);
     componentPaths.add(ComponentPath.create(ImmutableList.of(rootGraph.componentTypeElement())));
   }
diff --git a/java/dagger/internal/codegen/DiagnosticReporterFactory.java b/java/dagger/internal/codegen/DiagnosticReporterFactory.java
index e8839544b..30ec2779a 100644
--- a/java/dagger/internal/codegen/DiagnosticReporterFactory.java
+++ b/java/dagger/internal/codegen/DiagnosticReporterFactory.java
@@ -233,7 +233,7 @@ void printMessage(
         Diagnostic.Kind diagnosticKind,
         CharSequence message,
         @NullableDecl Element elementToReport) {
-      if (graph.isModuleBindingGraph()) {
+      if (graph.isFullBindingGraph()) {
         ValidationType validationType = compilerOptions.moduleBindingValidationType(rootComponent);
         if (validationType.equals(NONE)) {
           return;
@@ -297,12 +297,12 @@ private void appendBracketPrefix(StringBuilder message, String prefix) {
       @Override
       public String toString() {
         StringBuilder message =
-            graph.isModuleBindingGraph()
+            graph.isFullBindingGraph()
                 ? new StringBuilder()
                 : new StringBuilder(dependencyTrace.size() * 100 /* a guess heuristic */);
 
-        // Print the dependency trace unless it's a module binding graph
-        if (!graph.isModuleBindingGraph()) {
+        // Print the dependency trace unless it's a full binding graph
+        if (!graph.isFullBindingGraph()) {
           dependencyTrace.forEach(
               edge ->
                   dependencyRequestFormatter.appendFormatLine(message, edge.dependencyRequest()));
@@ -317,7 +317,7 @@ public String toString() {
                 // if printing entry points, skip entry points and the traced request
                 .filter(
                     request ->
-                        graph.isModuleBindingGraph()
+                        graph.isFullBindingGraph()
                             || (!request.isEntryPoint() && !isTracedRequest(request)))
                 .map(request -> request.dependencyRequest().requestElement())
                 .flatMap(presentValues())
@@ -325,14 +325,14 @@ public String toString() {
         if (!requestsToPrint.isEmpty()) {
           message
               .append("\nIt is")
-              .append(graph.isModuleBindingGraph() ? " " : " also ")
+              .append(graph.isFullBindingGraph() ? " " : " also ")
               .append("requested at:");
           elementFormatter().formatIndentedList(message, requestsToPrint, 1);
         }
 
-        // Print the remaining entry points, showing which component they're in, unless we're in a
-        // module binding graph
-        if (!graph.isModuleBindingGraph() && entryPoints.size() > 1) {
+        // Print the remaining entry points, showing which component they're in, unless it's a full
+        // binding graph
+        if (!graph.isFullBindingGraph() && entryPoints.size() > 1) {
           message.append("\nThe following other entry points also depend on it:");
           entryPointFormatter.formatIndentedList(
               message,
diff --git a/java/dagger/internal/codegen/IncompatiblyScopedBindingsValidator.java b/java/dagger/internal/codegen/IncompatiblyScopedBindingsValidator.java
index 7bbbd07ef..23d45d8f4 100644
--- a/java/dagger/internal/codegen/IncompatiblyScopedBindingsValidator.java
+++ b/java/dagger/internal/codegen/IncompatiblyScopedBindingsValidator.java
@@ -70,9 +70,11 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
                 ComponentNode componentNode =
                     bindingGraph.componentNode(binding.componentPath()).get();
                 if (!componentNode.scopes().contains(scope)) {
-                  // @Inject bindings in full binding graphs will appear at the properly scoped
-                  // ancestor component, so ignore them here.
-                  if (binding.kind().equals(INJECTION) && bindingGraph.isFullBindingGraph()) {
+                  // @Inject bindings in module or subcomponent binding graphs will appear at the
+                  // properly scoped ancestor component, so ignore them here.
+                  if (binding.kind().equals(INJECTION)
+                      && (bindingGraph.rootComponentNode().isSubcomponent()
+                          || !bindingGraph.rootComponentNode().isRealComponent())) {
                     return;
                   }
                   incompatibleBindings.put(componentNode, binding);
diff --git a/java/dagger/internal/codegen/MissingBindingValidator.java b/java/dagger/internal/codegen/MissingBindingValidator.java
index 642f7a4ad..3d5fec085 100644
--- a/java/dagger/internal/codegen/MissingBindingValidator.java
+++ b/java/dagger/internal/codegen/MissingBindingValidator.java
@@ -54,7 +54,7 @@ public String pluginName() {
 
   @Override
   public void visitGraph(BindingGraph graph, DiagnosticReporter diagnosticReporter) {
-    // Don't report missing bindings when validating a full graph or a graph built from a
+    // Don't report missing bindings when validating a full binding graph or a graph built from a
     // subcomponent.
     if (graph.isFullBindingGraph() || graph.rootComponentNode().isSubcomponent()) {
       return;
diff --git a/javatests/dagger/internal/codegen/DependencyCycleValidationTest.java b/javatests/dagger/internal/codegen/DependencyCycleValidationTest.java
index a24b7fe51..f43e34c31 100644
--- a/javatests/dagger/internal/codegen/DependencyCycleValidationTest.java
+++ b/javatests/dagger/internal/codegen/DependencyCycleValidationTest.java
@@ -18,10 +18,12 @@
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.TestUtils.endsWithMessage;
 import static dagger.internal.codegen.TestUtils.message;
 
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
+import java.util.regex.Pattern;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -29,45 +31,46 @@
 
 @RunWith(JUnit4.class)
 public class DependencyCycleValidationTest {
-  @Test public void cyclicDependency() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.Outer",
-            "package test;",
-            "",
-            "import dagger.Binds;",
-            "import dagger.Component;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import javax.inject.Inject;",
-            "",
-            "final class Outer {",
-            "  static class A {",
-            "    @Inject A(C cParam) {}",
-            "  }",
-            "",
-            "  static class B {",
-            "    @Inject B(A aParam) {}",
-            "  }",
-            "",
-            "  static class C {",
-            "    @Inject C(B bParam) {}",
-            "  }",
-            "",
-            "  @Module",
-            "  interface MModule {",
-            "    @Binds Object object(C c);",
-            "  }",
-            "",
-            "  @Component",
-            "  interface CComponent {",
-            "    C getC();",
-            "  }",
-            "}");
+  private static final JavaFileObject SIMPLE_CYCLIC_DEPENDENCY =
+      JavaFileObjects.forSourceLines(
+          "test.Outer",
+          "package test;",
+          "",
+          "import dagger.Binds;",
+          "import dagger.Component;",
+          "import dagger.Module;",
+          "import dagger.Provides;",
+          "import javax.inject.Inject;",
+          "",
+          "final class Outer {",
+          "  static class A {",
+          "    @Inject A(C cParam) {}",
+          "  }",
+          "",
+          "  static class B {",
+          "    @Inject B(A aParam) {}",
+          "  }",
+          "",
+          "  static class C {",
+          "    @Inject C(B bParam) {}",
+          "  }",
+          "",
+          "  @Module",
+          "  interface MModule {",
+          "    @Binds Object object(C c);",
+          "  }",
+          "",
+          "  @Component",
+          "  interface CComponent {",
+          "    C getC();",
+          "  }",
+          "}");
 
-    Compilation compilation =
-        daggerCompiler().withOptions("-Adagger.moduleBindingValidation=ERROR").compile(component);
+  @Test
+  public void cyclicDependency() {
+    Compilation compilation = daggerCompiler().compile(SIMPLE_CYCLIC_DEPENDENCY);
     assertThat(compilation).failed();
+
     assertThat(compilation)
         .hadErrorContaining(
             message(
@@ -80,21 +83,44 @@
                 "        test.Outer.C(bParam)",
                 "    test.Outer.C is provided at",
                 "        test.Outer.CComponent.getC()"))
-        .inFile(component)
+        .inFile(SIMPLE_CYCLIC_DEPENDENCY)
         .onLineContaining("interface CComponent");
 
+    assertThat(compilation).hadErrorCount(1);
+  }
+
+  @Test
+  public void cyclicDependencyWithModuleBindingValidation() {
+    // Cycle errors should not show a dependency trace to an entry point when doing full binding
+    // graph validation. So ensure that the message doesn't end with "test.Outer.C is provided at
+    // test.Outer.CComponent.getC()", as the previous test's message does.
+    Pattern moduleBindingValidationError =
+        endsWithMessage(
+            "Found a dependency cycle:",
+            "    test.Outer.C is injected at",
+            "        test.Outer.A(cParam)",
+            "    test.Outer.A is injected at",
+            "        test.Outer.B(aParam)",
+            "    test.Outer.B is injected at",
+            "        test.Outer.C(bParam)");
+
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions("-Adagger.moduleBindingValidation=ERROR")
+            .compile(SIMPLE_CYCLIC_DEPENDENCY);
+    assertThat(compilation).failed();
+
     assertThat(compilation)
-        .hadErrorContaining(
-            message(
-                "Found a dependency cycle:",
-                "    test.Outer.C is injected at",
-                "        test.Outer.A(cParam)",
-                "    test.Outer.A is injected at",
-                "        test.Outer.B(aParam)",
-                "    test.Outer.B is injected at",
-                "        test.Outer.C(bParam)"))
-        .inFile(component)
+        .hadErrorContainingMatch(moduleBindingValidationError)
+        .inFile(SIMPLE_CYCLIC_DEPENDENCY)
         .onLineContaining("interface MModule");
+
+    assertThat(compilation)
+        .hadErrorContainingMatch(moduleBindingValidationError)
+        .inFile(SIMPLE_CYCLIC_DEPENDENCY)
+        .onLineContaining("interface CComponent");
+
+    assertThat(compilation).hadErrorCount(2);
   }
 
   @Test public void cyclicDependencyNotIncludingEntryPoint() {
diff --git a/javatests/dagger/internal/codegen/ModuleBindingValidationTest.java b/javatests/dagger/internal/codegen/ModuleBindingValidationTest.java
index 79508c240..28338775c 100644
--- a/javatests/dagger/internal/codegen/ModuleBindingValidationTest.java
+++ b/javatests/dagger/internal/codegen/ModuleBindingValidationTest.java
@@ -254,6 +254,47 @@ public void moduleIncludingModuleWithCombinedErrors_validationTypeWarning() {
           "    @BindsInstance test.SubcomponentWithErrors.Builder"
               + " test.SubcomponentWithErrors.Builder.object(Object)");
 
+  @Test
+  public void subcomponentWithErrors_validationTypeNone() {
+    Compilation compilation = daggerCompiler().compile(SUBCOMPONENT_WITH_ERRORS, A_MODULE);
+
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void subcomponentWithErrors_validationTypeError() {
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions("-Adagger.moduleBindingValidation=ERROR")
+            .compile(SUBCOMPONENT_WITH_ERRORS, A_MODULE);
+
+    assertThat(compilation).failed();
+
+    assertThat(compilation)
+        .hadErrorContainingMatch(SUBCOMPONENT_WITH_ERRORS_MESSAGE)
+        .inFile(SUBCOMPONENT_WITH_ERRORS)
+        .onLineContaining("interface SubcomponentWithErrors");
+
+    assertThat(compilation).hadErrorCount(1);
+  }
+
+  @Test
+  public void subcomponentWithErrors_validationTypeWarning() {
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions("-Adagger.moduleBindingValidation=WARNING")
+            .compile(SUBCOMPONENT_WITH_ERRORS, A_MODULE);
+
+    assertThat(compilation).succeeded();
+
+    assertThat(compilation)
+        .hadWarningContainingMatch(SUBCOMPONENT_WITH_ERRORS_MESSAGE)
+        .inFile(SUBCOMPONENT_WITH_ERRORS)
+        .onLineContaining("interface SubcomponentWithErrors");
+
+    assertThat(compilation).hadWarningCount(1);
+  }
+
   private static final JavaFileObject MODULE_WITH_SUBCOMPONENT_WITH_ERRORS =
       JavaFileObjects.forSourceLines(
           "test.ModuleWithSubcomponentWithErrors",
@@ -288,7 +329,13 @@ public void moduleWithSubcomponentWithErrors_validationTypeError() {
         .inFile(MODULE_WITH_SUBCOMPONENT_WITH_ERRORS)
         .onLineContaining("interface ModuleWithSubcomponentWithErrors");
 
-    assertThat(compilation).hadErrorCount(1);
+    // TODO(b/130283677)
+    assertThat(compilation)
+        .hadErrorContainingMatch(SUBCOMPONENT_WITH_ERRORS_MESSAGE)
+        .inFile(SUBCOMPONENT_WITH_ERRORS)
+        .onLineContaining("interface SubcomponentWithErrors");
+
+    assertThat(compilation).hadErrorCount(2);
   }
 
   @Test
@@ -305,7 +352,13 @@ public void moduleWithSubcomponentWithErrors_validationTypeWarning() {
         .inFile(MODULE_WITH_SUBCOMPONENT_WITH_ERRORS)
         .onLineContaining("interface ModuleWithSubcomponentWithErrors");
 
-    assertThat(compilation).hadWarningCount(1);
+    // TODO(b/130283677)
+    assertThat(compilation)
+        .hadWarningContainingMatch(SUBCOMPONENT_WITH_ERRORS_MESSAGE)
+        .inFile(SUBCOMPONENT_WITH_ERRORS)
+        .onLineContaining("interface SubcomponentWithErrors");
+
+    assertThat(compilation).hadWarningCount(2);
   }
 
   private static final JavaFileObject A_SUBCOMPONENT =
