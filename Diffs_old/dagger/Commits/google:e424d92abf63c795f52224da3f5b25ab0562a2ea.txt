diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index c298b85dc..a61b7b459 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -461,12 +461,11 @@ private void addFields() {
   private void addField(ResolvedBindings resolvedBindings) {
     BindingKey bindingKey = resolvedBindings.bindingKey();
 
-    // No field needed for unique contributions inherited from the parent.
-    if (resolvedBindings.isUniqueContribution()
-        && resolvedBindings.ownedContributionBindings().isEmpty()) {
+    // No field needed if there are no owned bindings.
+    if (resolvedBindings.ownedBindings().isEmpty()) {
       return;
     }
-
+    
     // No field needed for bindings with no dependencies or state.
     Optional<MemberSelect> staticMemberSelect = staticMemberSelect(resolvedBindings);
     if (staticMemberSelect.isPresent()) {
@@ -702,7 +701,6 @@ private void initializeFrameworkTypes() {
       } else {
         constructorWriter.body().addSnippet("%s();", initializeMethod.name());
       }
-
     }
   }
 
@@ -715,6 +713,12 @@ private void initializeFrameworkTypes() {
    */
   private Snippet initializeFrameworkType(BindingKey bindingKey) {
     ResolvedBindings resolvedBindings = graph.resolvedBindings().get(bindingKey);
+    
+    // There's no field for inherited bindings.
+    if (resolvedBindings.ownedBindings().isEmpty()) {
+      return Snippet.format("");
+    }
+    
     switch (bindingKey.kind()) {
       case CONTRIBUTION:
         switch (contributionTypeFor(resolvedBindings.contributionBindings())) {
@@ -804,14 +808,12 @@ private Snippet initializeMapMultibindings(ResolvedBindings resolvedBindings) {
   private Snippet initializeUniqueContributionBinding(ResolvedBindings resolvedBindings) {
     ImmutableList.Builder<Snippet> initializationSnippets = ImmutableList.builder();
 
-    if (!resolvedBindings.ownedContributionBindings().isEmpty()) {
-      ContributionBinding binding = getOnlyElement(resolvedBindings.ownedContributionBindings());
-      if (!binding.factoryCreationStrategy().equals(ENUM_INSTANCE) || binding.scope().isPresent()) {
+    ContributionBinding binding = getOnlyElement(resolvedBindings.ownedContributionBindings());
+    if (!binding.factoryCreationStrategy().equals(ENUM_INSTANCE) || binding.scope().isPresent()) {
         initializationSnippets.add(initializeDelegateFactories(binding));
-        initializationSnippets.add(
-            initializeMember(
-                resolvedBindings.bindingKey(), initializeFactoryForContributionBinding(binding)));
-      }
+      initializationSnippets.add(
+          initializeMember(
+              resolvedBindings.bindingKey(), initializeFactoryForContributionBinding(binding)));
     }
 
     return Snippet.concat(initializationSnippets.build());
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index 39365e44a..28e3b4570 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -782,6 +782,160 @@ public void generatedModuleInSubcomponent() {
         .compilesWithoutError();
   }
 
+  @Test
+  public void subcomponentOmitsInheritedBindings() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = ParentModule.class)",
+            "interface Parent {",
+            "  Child child();",
+            "}");
+    JavaFileObject parentModule =
+        JavaFileObjects.forSourceLines(
+            "test.ParentModule",
+            "package test;",
+            "",
+            "import dagger.mapkeys.StringKey;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "import static dagger.Provides.Type.SET;",
+            "import static dagger.Provides.Type.MAP;",
+            "",
+            "@Module",
+            "class ParentModule {",
+            "  @Provides(type = SET) static Object parentObject() {",
+            "    return \"parent object\";",
+            "  }",
+            "",
+            "  @Provides(type = MAP) @StringKey(\"parent key\") Object parentKeyObject() {",
+            "    return \"parent value\";",
+            "  }",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "",
+            "@Subcomponent",
+            "interface Child {",
+            "  Set<Object> objectSet();",
+            "  Map<String, Object> objectMap();",
+            "}");
+    JavaFileObject expected =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerParent",
+            "package test;",
+            "",
+            "import dagger.internal.MapFactory;",
+            "import dagger.internal.MapProviderFactory;",
+            "import dagger.internal.SetFactory;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+            "public final class DaggerParent implements Parent {",
+            "  private Provider<Set<Object>> setOfObjectContribution1Provider;",
+            "  private Provider<Set<Object>> setOfObjectProvider;",
+            "  private Provider<Object> mapOfStringAndProviderOfObjectContribution1;",
+            "  private Provider<Map<String, Provider<Object>>>",
+            "      mapOfStringAndProviderOfObjectProvider;",
+            "",
+            "  private DaggerParent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static Parent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.setOfObjectContribution1Provider =",
+            "        ParentModule_ParentObjectFactory.create();",
+            "    this.setOfObjectProvider = SetFactory.create(setOfObjectContribution1Provider);",
+            "    this.mapOfStringAndProviderOfObjectContribution1 =",
+            "        ParentModule_ParentKeyObjectFactory.create(builder.parentModule);",
+            "    this.mapOfStringAndProviderOfObjectProvider =",
+            "        MapProviderFactory.<String, Object>builder(1)",
+            "            .put(\"parent key\", mapOfStringAndProviderOfObjectContribution1)",
+            "            .build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Child child() {",
+            "    return new ChildImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private ParentModule parentModule;",
+            "",
+            "    private Builder() {}",
+            "",
+            "    public Parent build() {",
+            "      if (parentModule == null) {",
+            "        this.parentModule = new ParentModule();",
+            "      }",
+            "      return new DaggerParent(this);",
+            "    }",
+            "",
+            "    public Builder parentModule(ParentModule parentModule) {",
+            "      if (parentModule == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.parentModule = parentModule;",
+            "      return this;",
+            "    }",
+            "  }",
+            "",
+            "  private final class ChildImpl implements Child {",
+            "    private Provider<Map<String, Object>> mapOfStringAndObjectProvider;",
+            "",
+            "    private ChildImpl() {",
+            "      initialize();",
+            "    }",
+            "",
+            "    @SuppressWarnings(\"unchecked\")",
+            "    private void initialize() {",
+            "      this.mapOfStringAndObjectProvider = MapFactory.create(",
+            "          DaggerParent.this.mapOfStringAndProviderOfObjectProvider);",
+            "    }",
+            "",
+            "    @Override",
+            "    public Set<Object> objectSet() {",
+            "      return DaggerParent.this.setOfObjectProvider.get();",
+            "    }",
+            "",
+            "    @Override",
+            "    public Map<String, Object> objectMap() {",
+            "      return mapOfStringAndObjectProvider.get();",
+            "    }",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(parent, parentModule, child))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(expected);
+  }
+
   @Test public void testDefaultPackage() {
     JavaFileObject aClass = JavaFileObjects.forSourceLines("AClass", "class AClass {}");
     JavaFileObject bClass = JavaFileObjects.forSourceLines("BClass",
diff --git a/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
index e8500d7de..51fb2c0e9 100644
--- a/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
@@ -245,7 +245,6 @@
         .withErrorContaining("@Singleton");
   }
 
-  @Ignore
   @Test
   public void delegateFactoryNotCreatedForSubcomponentWhenProviderExistsInParent() {
     JavaFileObject parentComponentFile =
@@ -395,8 +394,6 @@ public void delegateFactoryNotCreatedForSubcomponentWhenProviderExistsInParent()
             "    private Provider<NeedsDep1> needsDep1Provider;",
             "    private Provider<A> aProvider;",
             "    private Provider<Object> provideObjectProvider;",
-            "    private MembersInjector<Dep1> dep1MembersInjector;",
-            "    private MembersInjector<Dep2> dep2MembersInjector;",
             "  ",
             "    private ChildComponentImpl() {  ",
             "      this.childModule = new ChildModule();",
@@ -415,8 +412,6 @@ public void delegateFactoryNotCreatedForSubcomponentWhenProviderExistsInParent()
             "          DaggerParentComponent.this.dep2Provider);",
             "      this.provideObjectProvider = ChildModule_ProvideObjectFactory.create(",
             "          childModule, aProvider);",
-            "      this.dep1MembersInjector = Dep1_MembersInjector.create();",
-            "      this.dep2MembersInjector = Dep2_MembersInjector.create();",
             "    }",
             "  ",
             "    @Override",
