diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 39436072d..930941330 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -43,6 +43,7 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static dagger.internal.codegen.AnnotationMirrors.getAnnotationMirror;
 import static dagger.internal.codegen.DependencyRequest.Kind.MEMBERS_INJECTOR;
 import static javax.lang.model.element.Modifier.ABSTRACT;
@@ -176,7 +177,7 @@ ComponentDescriptor create(TypeElement componentDefinitionType) {
         List<ExecutableElement> moduleMethods =
             ElementFilter.methodsIn(elements.getAllMembers(module));
         for (ExecutableElement moduleMethod : moduleMethods) {
-          if (moduleMethod.getAnnotation(Provides.class) != null) {
+          if (isAnnotationPresent(moduleMethod, Provides.class)) {
             ProvisionBinding providesMethodBinding =
                 provisionBindingFactory.forProvidesMethod(moduleMethod);
             bindingIndexBuilder.put(providesMethodBinding.providedKey(), providesMethodBinding);
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisInjectBinding.java b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisInjectBinding.java
index 2d8350157..cbda5a496 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisInjectBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisInjectBinding.java
@@ -30,6 +30,7 @@
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.TypeMirror;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static dagger.internal.codegen.Util.getApplicationSupertype;
 
 /**
@@ -43,7 +44,7 @@
 
   private GraphAnalysisInjectBinding(String provideKey, String membersKey,
       TypeElement type, List<String> keys, String supertypeKey) {
-    super(provideKey, membersKey, type.getAnnotation(Singleton.class) != null,
+    super(provideKey, membersKey, isAnnotationPresent(type, Singleton.class),
         type.getQualifiedName().toString());
     this.type = type;
     this.keys = keys;
@@ -113,11 +114,11 @@ static GraphAnalysisInjectBinding create(TypeElement type, boolean mustHaveInjec
   }
 
   private static boolean hasAtInject(Element enclosed) {
-    return enclosed.getAnnotation(Inject.class) != null;
+    return isAnnotationPresent(enclosed, Inject.class);
   }
 
   private static boolean hasAtSingleton(Element enclosed) {
-    return enclosed.getAnnotation(Singleton.class) != null;
+    return isAnnotationPresent(enclosed, Singleton.class);
   }
 
   @Override public void attach(Linker linker) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
index c42fa09f9..ca305c7fa 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
@@ -58,6 +58,7 @@
 import javax.tools.JavaFileManager;
 import javax.tools.StandardLocation;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static dagger.Provides.Type.SET;
 import static dagger.Provides.Type.SET_VALUES;
 import static dagger.internal.codegen.Util.className;
@@ -337,8 +338,8 @@ void collectIncludesRecursively(
     private final Binding<?>[] parameters;
 
     protected ProviderMethodBinding(String provideKey, ExecutableElement method, boolean library) {
-      super(provideKey, method.getAnnotation(Singleton.class) != null,
-          className(method), method.getSimpleName().toString());
+      super(provideKey, isAnnotationPresent(method, Singleton.class), className(method),
+          method.getSimpleName().toString());
       this.method = method;
       this.parameters = new Binding[method.getParameters().size()];
       setLibrary(library);
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
index 85b105657..b222ff37b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
@@ -48,6 +48,7 @@
 import javax.tools.Diagnostic;
 import javax.tools.JavaFileObject;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static dagger.internal.Keys.isPlatformType;
 import static dagger.internal.codegen.AdapterJavadocs.bindingTypeDocs;
 import static dagger.internal.codegen.Util.adapterName;
@@ -66,8 +67,8 @@
 import static javax.lang.model.element.Modifier.STATIC;
 
 /**
- * Generates an implementation of {@link Binding} that injects the
- * {@literal @}{@code Inject}-annotated members of a class.
+ * Generates an implementation of {@link Binding} that injects the {@literal @}{@code Inject}
+ * -annotated members of a class.
  */
 @AutoService(Processor.class)
 @SupportedAnnotationTypes("javax.inject.Inject")
@@ -393,7 +394,7 @@ private void writeInjectAdapterConstructor(JavaWriter writer, ExecutableElement
         ? JavaWriter.stringLiteral(GeneratorKeys.get(type.asType()))
         : null;
     String membersKey = JavaWriter.stringLiteral(GeneratorKeys.rawMembersKey(type.asType()));
-    boolean singleton = type.getAnnotation(Singleton.class) != null;
+    boolean singleton = isAnnotationPresent(type, Singleton.class);
     writer.emitStatement("super(%s, %s, %s, %s.class)",
         key, membersKey, (singleton ? "IS_SINGLETON" : "NOT_SINGLETON"), strippedTypeName);
     writer.endMethod();
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java b/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java
index 1ce9f028e..c5b689a64 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java
@@ -28,6 +28,7 @@
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.util.ElementFilter;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS;
 import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_GENERIC_CLASS;
 import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_INNER_CLASS;
@@ -92,7 +93,7 @@
         ElementFilter.constructorsIn(enclosingElement.getEnclosedElements()))
             .filter(new Predicate<ExecutableElement>() {
               @Override public boolean apply(ExecutableElement input) {
-                return input.getAnnotation(Inject.class) != null;
+                return isAnnotationPresent(input, Inject.class);
               }
             });
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
index 04c017d78..c1769865e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
@@ -26,6 +26,7 @@
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkNotNull;
 
 /**
@@ -77,7 +78,7 @@
     return FluentIterable.from(annotations)
         .filter(new Predicate<AnnotationMirror>() {
           @Override public boolean apply(AnnotationMirror input) {
-            return input.getAnnotationType().asElement().getAnnotation(annotationType) != null;
+            return isAnnotationPresent(input.getAnnotationType().asElement(), annotationType);
           }
         })
         .toSet();
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index 97557f890..2beac8126 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -34,6 +34,7 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 
@@ -133,7 +134,7 @@ private int targetIndexInEnclosing(InjectionSite injectionSite)  {
       InjectionSite forInjectMethod(ExecutableElement methodElement) {
         checkNotNull(methodElement);
         checkArgument(methodElement.getKind().equals(ElementKind.METHOD));
-        checkArgument(methodElement.getAnnotation(Inject.class) != null);
+        checkArgument(isAnnotationPresent(methodElement, Inject.class));
         return new AutoValue_MembersInjectionBinding_InjectionSite(Kind.METHOD, methodElement,
             dependencyRequestFactory.forRequiredVariables(methodElement.getParameters()));
       }
@@ -141,7 +142,7 @@ InjectionSite forInjectMethod(ExecutableElement methodElement) {
       InjectionSite forInjectField(VariableElement fieldElement) {
         checkNotNull(fieldElement);
         checkArgument(fieldElement.getKind().equals(ElementKind.FIELD));
-        checkArgument(fieldElement.getAnnotation(Inject.class) != null);
+        checkArgument(isAnnotationPresent(fieldElement, Inject.class));
         return new AutoValue_MembersInjectionBinding_InjectionSite(Kind.FIELD, fieldElement,
             ImmutableList.of(dependencyRequestFactory.forRequiredVariable(fieldElement)));
       }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index bc1f601a7..05970210b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -15,8 +15,6 @@
  */
 package dagger.internal.codegen;
 
-import dagger.internal.codegen.writer.VoidName;
-
 import com.google.auto.common.MoreElements;
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;
@@ -36,6 +34,7 @@
 import dagger.internal.codegen.writer.ParameterizedTypeName;
 import dagger.internal.codegen.writer.Snippet;
 import dagger.internal.codegen.writer.TypeNames;
+import dagger.internal.codegen.writer.VoidName;
 import java.util.Map.Entry;
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
@@ -45,6 +44,7 @@
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
+
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static javax.lang.model.element.Modifier.FINAL;
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
index 593f8db81..ba3328a71 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
@@ -61,6 +61,7 @@
 import javax.tools.Diagnostic;
 import javax.tools.JavaFileObject;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static dagger.Provides.Type.SET;
 import static dagger.Provides.Type.SET_VALUES;
 import static dagger.internal.codegen.AdapterJavadocs.bindingTypeDocs;
@@ -80,8 +81,8 @@
 import static javax.lang.model.element.Modifier.STATIC;
 
 /**
- * Generates an implementation of {@link ModuleAdapter} that includes a binding
- * for each {@code @Provides} method of a target class.
+ * Generates an implementation of {@link ModuleAdapter} that includes a binding for each
+ * {@code @Provides} method of a target class.
  */
 @AutoService(Processor.class)
 @SupportedAnnotationTypes({ "*" })
@@ -466,7 +467,7 @@ private void generateProvidesAdapter(JavaWriter writer, ExecutableElement provid
 
     writer.emitEmptyLine();
     writer.beginMethod(null, className, EnumSet.of(PUBLIC), moduleType, "module");
-    boolean singleton = providerMethod.getAnnotation(Singleton.class) != null;
+    boolean singleton = isAnnotationPresent(providerMethod, Singleton.class);
     String key = JavaWriter.stringLiteral(GeneratorKeys.get(providerMethod));
     writer.emitStatement("super(%s, %s, %s, %s)",
         key, (singleton ? "IS_SINGLETON" : "NOT_SINGLETON"),
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleProcesssingStep.java b/compiler/src/main/java/dagger/internal/codegen/ModuleProcesssingStep.java
index bc49fc7eb..ec99b9550 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleProcesssingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleProcesssingStep.java
@@ -31,6 +31,7 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.ElementFilter;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static javax.lang.model.element.ElementKind.METHOD;
 
 /**
@@ -89,7 +90,7 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
         List<ExecutableElement> moduleMethods =
             ElementFilter.methodsIn(moduleElement.getEnclosedElements());
         for (ExecutableElement methodElement : moduleMethods) {
-          if (methodElement.getAnnotation(Provides.class) != null) {
+          if (isAnnotationPresent(methodElement, Provides.class)) {
             moduleProvidesMethodsBuilder.add(methodElement);
           }
         }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
index 8cf007e57..bbec9ccb9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
@@ -25,6 +25,7 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.ElementFilter;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_WITH_SAME_NAME;
 
 /**
@@ -41,7 +42,7 @@
     ImmutableListMultimap.Builder<String, ExecutableElement> providesMethodsByName =
         ImmutableListMultimap.builder();
     for (ExecutableElement moduleMethod : moduleMethods) {
-      if (moduleMethod.getAnnotation(Provides.class) != null) {
+      if (isAnnotationPresent(moduleMethod, Provides.class)) {
         providesMethodsByName.put(moduleMethod.getSimpleName().toString(), moduleMethod);
       }
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 9226c22c2..4405d0569 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -33,6 +33,7 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.Sets.immutableEnumSet;
@@ -119,7 +120,7 @@ static boolean isSetBindingCollection(Iterable<ProvisionBinding> bindings) {
     ProvisionBinding forInjectConstructor(ExecutableElement constructorElement) {
       checkNotNull(constructorElement);
       checkArgument(constructorElement.getKind().equals(CONSTRUCTOR));
-      checkArgument(constructorElement.getAnnotation(Inject.class) != null);
+      checkArgument(isAnnotationPresent(constructorElement, Inject.class));
       Key key = keyFactory.forInjectConstructor(constructorElement);
       checkArgument(!key.qualifier().isPresent());
       return new AutoValue_ProvisionBinding(
@@ -143,7 +144,7 @@ private boolean requiresMemeberInjection(TypeElement type) {
       }
       for (Element enclosedElement : type.getEnclosedElements()) {
         if (MEMBER_KINDS.contains(enclosedElement.getKind())
-            && (enclosedElement.getAnnotation(Inject.class) != null)) {
+            && (isAnnotationPresent(enclosedElement, Inject.class))) {
           return true;
         }
       }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ValidationProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ValidationProcessor.java
index 904761cd1..75cf77a40 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ValidationProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ValidationProcessor.java
@@ -40,20 +40,21 @@
 import javax.lang.model.element.TypeElement;
 import javax.tools.Diagnostic;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static dagger.internal.codegen.Util.elementToString;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.ElementKind.METHOD;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 
 /**
- * Checks for errors that are not directly related to modules and
- *  {@code @Inject} annotated elements.
+ * Checks for errors that are not directly related to modules and {@code @Inject} annotated
+ * elements.
  *
- *  <p> Warnings for invalid use of qualifier annotations can be suppressed
- *  with @SuppressWarnings("qualifiers")
+ * <p>Warnings for invalid use of qualifier annotations can be suppressed with
+ * @SuppressWarnings("qualifiers")
  *
- *  <p> Warnings for invalid use of scoping annotations can be suppressed
- *  with @SuppressWarnings("scoping")
+ * <p>Warnings for invalid use of scoping annotations can be suppressed with
+ * @SuppressWarnings("scoping")
  */
 @AutoService(Processor.class)
 @SupportedAnnotationTypes({ "*" })
@@ -80,16 +81,16 @@
   }
 
   private void validateProvides(Element element) {
-    if (element.getAnnotation(Provides.class) != null
+    if (isAnnotationPresent(element, Provides.class)
         && Util.getAnnotation(Module.class, element.getEnclosingElement()) == null) {
       error("@Provides methods must be declared in modules: " + elementToString(element), element);
     }
   }
 
   private void validateQualifiers(Element element, Map<Element, Element> parametersToTheirMethods) {
-    boolean suppressWarnings =
-        element.getAnnotation(SuppressWarnings.class) != null && Arrays.asList(
-            element.getAnnotation(SuppressWarnings.class).value()).contains("qualifiers");
+    boolean suppressWarnings = isAnnotationPresent(element, SuppressWarnings.class)
+       && Arrays.asList(element.getAnnotation(SuppressWarnings.class).value())
+           .contains("qualifiers");
     int numberOfQualifiersOnElement = 0;
     for (AnnotationMirror annotation : element.getAnnotationMirrors()) {
       if (annotation.getAnnotationType().asElement().getAnnotation(Qualifier.class) == null) {
@@ -132,9 +133,8 @@ private void validateQualifiers(Element element, Map<Element, Element> parameter
   }
 
   private void validateScoping(Element element) {
-    boolean suppressWarnings =
-        element.getAnnotation(SuppressWarnings.class) != null && Arrays.asList(
-            element.getAnnotation(SuppressWarnings.class).value()).contains("scoping");
+    boolean suppressWarnings = isAnnotationPresent(element, SuppressWarnings.class)
+        && Arrays.asList(element.getAnnotation(SuppressWarnings.class).value()).contains("scoping");
     int numberOfScopingAnnotationsOnElement = 0;
     for (AnnotationMirror annotation : element.getAnnotationMirrors()) {
       if (annotation.getAnnotationType().asElement().getAnnotation(Scope.class) == null) {
@@ -187,7 +187,7 @@ private void addAllEnclosed(
   }
 
   private boolean isProvidesMethod(Element element) {
-    return element.getKind() == METHOD && element.getAnnotation(Provides.class) != null;
+    return element.getKind() == METHOD && isAnnotationPresent(element, Provides.class);
   }
 
   /**
@@ -196,7 +196,7 @@ private boolean isProvidesMethod(Element element) {
    */
   private boolean isProvidesMethodParameter(
       Element parameter, Map<Element, Element> parametersToTheirMethods) {
-    return parametersToTheirMethods.get(parameter).getAnnotation(Provides.class) != null;
+    return isAnnotationPresent(parametersToTheirMethods.get(parameter), Provides.class);
   }
 
   /**
@@ -206,7 +206,7 @@ private boolean isProvidesMethodParameter(
   private boolean isInjectableConstructorParameter(
       Element parameter, Map<Element, Element> parametersToTheirMethods) {
     return parametersToTheirMethods.get(parameter).getKind() == CONSTRUCTOR
-        && parametersToTheirMethods.get(parameter).getAnnotation(Inject.class) != null;
+        && isAnnotationPresent(parametersToTheirMethods.get(parameter), Inject.class);
   }
 
   private void error(String msg, Element element) {
