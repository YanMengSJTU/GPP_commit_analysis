diff --git a/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java b/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
index 9a54dc238..7156cc4cd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
+++ b/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
@@ -16,48 +16,122 @@
 
 package dagger.internal.codegen;
 
-import com.google.common.collect.FluentIterable;
+import static java.util.stream.StreamSupport.stream;
+
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.CodeBlock.Builder;
 import com.squareup.javapoet.TypeName;
-import java.util.Iterator;
-import java.util.Spliterator;
+import java.util.stream.Collector;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.TypeMirror;
 
 final class CodeBlocks {
+  /**
+   * A {@link Collector} implementation that joins {@link CodeBlock} instances together into one
+   * separated by {@code delimiter}. For example, joining {@code String s}, {@code Object o} and
+   * {@code int i} using {@code ", "} would produce {@code String s, Object o, int i}.
+   */
+  static Collector<CodeBlock, ?, CodeBlock> joiningCodeBlocks(String delimiter) {
+    return Collector.of(
+        () -> new CodeBlockJoiner(delimiter, CodeBlock.builder()),
+        CodeBlockJoiner::add,
+        CodeBlockJoiner::merge,
+        CodeBlockJoiner::join);
+  }
 
-  /** Returns a comma-separated version of {@code codeBlocks} as one unified {@link CodeBlock}. */
-  static CodeBlock makeParametersCodeBlock(Iterable<CodeBlock> codeBlocks) {
-    return join(codeBlocks, ", ");
+  /**
+   * Joins {@link CodeBlock} instances in a manner suitable for use as method parameters (or
+   * arguments). This is equivalent to {@code joiningCodeBlocks(", ")}.
+   */
+  static Collector<CodeBlock, ?, CodeBlock> toParametersCodeBlock() {
+    return joiningCodeBlocks(", ");
   }
 
   /**
-   * Returns one unified {@link CodeBlock} which joins each item in {@code codeBlocks} with a
-   * newline.
+   * Joins {@link TypeName} instances into a {@link CodeBlock} that is a comma-separated list for
+   * use as type parameters or javadoc method arguments.
    */
-  static CodeBlock concat(Iterable<CodeBlock> codeBlocks) {
-    return join(codeBlocks, "\n");
+  static Collector<TypeName, ?, CodeBlock> toTypeNamesCodeBlock() {
+    return typeNamesIntoCodeBlock(CodeBlock.builder());
+  }
+
+  /**
+   * Adds {@link TypeName} instances to the given {@link CodeBlock.Builder} in a comma-separated
+   * list for use as type parameters or javadoc method arguments.
+   */
+  static Collector<TypeName, ?, CodeBlock> typeNamesIntoCodeBlock(CodeBlock.Builder builder) {
+    return Collector.of(
+        () -> new CodeBlockJoiner(", ", builder),
+        CodeBlockJoiner::addTypeName,
+        CodeBlockJoiner::merge,
+        CodeBlockJoiner::join);
+  }
+
+  /**
+   * Concatenates {@link CodeBlock} instances separated by newlines for readability. This is
+   * equivalent to {@code joiningCodeBlocks("\n")}.
+   */
+  static Collector<CodeBlock, ?, CodeBlock> toConcatenatedCodeBlock() {
+    return joiningCodeBlocks("\n");
+  }
+
+  /** Returns a comma-separated version of {@code codeBlocks} as one unified {@link CodeBlock}. */
+  static CodeBlock makeParametersCodeBlock(Iterable<CodeBlock> codeBlocks) {
+    return stream(codeBlocks.spliterator(), false).collect(toParametersCodeBlock());
   }
 
-  static CodeBlock.Builder join(
-      CodeBlock.Builder builder, Iterable<CodeBlock> codeBlocks, String delimiter) {
-    Iterator<CodeBlock> iterator = codeBlocks.iterator();
-    while (iterator.hasNext()) {
-      builder.add(iterator.next());
-      if (iterator.hasNext()) {
+  private static final class CodeBlockJoiner {
+    private final String delimiter;
+    private final CodeBlock.Builder builder;
+    private boolean first = true;
+
+    CodeBlockJoiner(String delimiter, Builder builder) {
+      this.delimiter = delimiter;
+      this.builder = builder;
+    }
+
+    @CanIgnoreReturnValue
+    CodeBlockJoiner add(CodeBlock codeBlock) {
+      maybeAddDelimiter();
+      builder.add(codeBlock);
+      return this;
+    }
+
+    @CanIgnoreReturnValue
+    CodeBlockJoiner addTypeName(TypeName typeName) {
+      maybeAddDelimiter();
+      builder.add("$T", typeName);
+      return this;
+    }
+
+    private void maybeAddDelimiter() {
+      if (!first) {
         builder.add(delimiter);
       }
+      first = false;
     }
-    return builder;
-  }
 
-  static CodeBlock join(Iterable<CodeBlock> codeBlocks, String delimiter) {
-    return join(CodeBlock.builder(), codeBlocks, delimiter).build();
+    @CanIgnoreReturnValue
+    CodeBlockJoiner merge(CodeBlockJoiner other) {
+      CodeBlock otherBlock = other.builder.build();
+      if (!otherBlock.isEmpty()) {
+        add(otherBlock);
+      }
+      return this;
+    }
+
+    CodeBlock join() {
+      return builder.build();
+    }
   }
 
-  static FluentIterable<CodeBlock> toCodeBlocks(Iterable<? extends TypeMirror> typeMirrors) {
-    return FluentIterable.from(typeMirrors).transform(typeMirror -> CodeBlock.of("$T", typeMirror));
+  /**
+   * Returns one unified {@link CodeBlock} which joins each item in {@code codeBlocks} with a
+   * newline.
+   */
+  static CodeBlock concat(Iterable<CodeBlock> codeBlocks) {
+    return stream(codeBlocks.spliterator(), false).collect(toConcatenatedCodeBlock());
   }
 
   static CodeBlock stringLiteral(String toWrap) {
@@ -83,16 +157,13 @@ static CodeBlock javadocLinkTo(ExecutableElement executableElement) {
         throw new AssertionError(executableElement.toString());
     }
     builder.add("(");
-    Spliterator<TypeName> rawTypesSpliterator =
-        executableElement
-            .getParameters()
-            .stream()
-            .map(VariableElement::asType)
-            .map(TypeName::get)
-            .map(TypeNames::rawTypeName)
-            .spliterator();
-    rawTypesSpliterator.tryAdvance(first -> builder.add("$T", first));
-    rawTypesSpliterator.forEachRemaining(remaining -> builder.add(", $T", remaining));
+    executableElement
+        .getParameters()
+        .stream()
+        .map(VariableElement::asType)
+        .map(TypeName::get)
+        .map(TypeNames::rawTypeName)
+        .collect(typeNamesIntoCodeBlock(builder));
     return builder.add(")}").build();
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java b/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
index 6643208e1..97ee9845a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
@@ -18,8 +18,7 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
-import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
-import static dagger.internal.codegen.CodeBlocks.toCodeBlocks;
+import static dagger.internal.codegen.CodeBlocks.toTypeNamesCodeBlock;
 import static dagger.internal.codegen.TypeNames.FACTORY;
 import static dagger.internal.codegen.TypeNames.MAP_OF_PRODUCER_PRODUCER;
 import static dagger.internal.codegen.TypeNames.MAP_PROVIDER_FACTORY;
@@ -29,6 +28,7 @@
 import com.google.common.collect.ImmutableList;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.TypeName;
 import dagger.MembersInjector;
 import java.util.List;
 import java.util.Set;
@@ -174,7 +174,7 @@ CodeBlock getExpressionFor(ClassName usingClass) {
         return CodeBlock.of(
             "$T.<$L>$L",
             owningClass(),
-            makeParametersCodeBlock(toCodeBlocks(typeParameters)),
+            typeParameters.stream().map(TypeName::get).collect(toTypeNamesCodeBlock()),
             methodCodeBlock);
       } else {
         return CodeBlock.of("(($T) $T.$L)", rawReturnType, owningClass(), methodCodeBlock);
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index 2e9b5df24..3cf636764 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -28,6 +28,7 @@
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
 import static dagger.internal.codegen.AnnotationSpecs.suppressWarnings;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
 import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.generateBindingFieldsForDependencies;
@@ -160,10 +161,7 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
           !isTypeAccessibleFrom(dependencyBindingKey.key().type(), generatedTypeName.packageName());
 
       String fieldName = fieldNames.getUniqueName(bindingField.name());
-      TypeName fieldType =
-          useRawFrameworkType
-              ? bindingField.type().rawType
-              : bindingField.type();
+      TypeName fieldType = useRawFrameworkType ? bindingField.type().rawType : bindingField.type();
       FieldSpec.Builder fieldBuilder = FieldSpec.builder(fieldType, fieldName, PRIVATE, FINAL);
       ParameterSpec.Builder parameterBuilder = ParameterSpec.builder(fieldType, fieldName);
 
@@ -185,7 +183,9 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
       dependencyFieldsBuilder.put(dependencyBindingKey, field);
       constructorInvocationParameters.add(CodeBlock.of("$N", field));
     }
-    createMethodBuilder.addCode(CodeBlocks.join(constructorInvocationParameters.build(), ", "));
+
+    createMethodBuilder.addCode(
+        constructorInvocationParameters.build().stream().collect(toParametersCodeBlock()));
     createMethodBuilder.addCode(");");
 
     injectorTypeBuilder.addMethod(constructorBuilder.build());
@@ -222,9 +222,7 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
     return Optional.of(injectorTypeBuilder);
   }
 
-  /**
-   * Returns a code block that directly injects the instance's field or method.
-   */
+  /** Returns a code block that directly injects the instance's field or method. */
   private CodeBlock directInjectMemberCodeBlock(
       MembersInjectionBinding binding,
       ImmutableMap<BindingKey, FieldSpec> dependencyFields,
diff --git a/compiler/src/test/java/dagger/internal/codegen/CodeBlocksTest.java b/compiler/src/test/java/dagger/internal/codegen/CodeBlocksTest.java
new file mode 100644
index 000000000..43507c9ea
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/CodeBlocksTest.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.truth.Truth.assertThat;
+import static dagger.internal.codegen.CodeBlocks.javadocLinkTo;
+import static dagger.internal.codegen.CodeBlocks.joiningCodeBlocks;
+import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
+import static javax.lang.model.element.ElementKind.METHOD;
+
+import com.google.testing.compile.CompilationRule;
+import com.squareup.javapoet.CodeBlock;
+import java.util.stream.Stream;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.util.Elements;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests for {@link CodeBlocks}. */
+@RunWith(JUnit4.class)
+public final class CodeBlocksTest {
+  private static final CodeBlock objectO = CodeBlock.of("$T o", Object.class);
+  private static final CodeBlock stringS = CodeBlock.of("$T s", String.class);
+  private static final CodeBlock intI = CodeBlock.of("$T i", int.class);
+
+  @Rule public CompilationRule compilationRule = new CompilationRule();
+  private Elements elements;
+
+  @Before
+  public void setUp() {
+    this.elements = compilationRule.getElements();
+  }
+
+  @Test
+  public void testToParametersCodeBlock() {
+    assertThat(Stream.of(objectO, stringS, intI).collect(toParametersCodeBlock()))
+        .isEqualTo(CodeBlock.of("$T o, $T s, $T i", Object.class, String.class, int.class));
+  }
+
+  @Test
+  public void testToParametersCodeBlock_empty() {
+    assertThat(Stream.<CodeBlock>of().collect(toParametersCodeBlock())).isEqualTo(CodeBlock.of(""));
+  }
+
+  @Test
+  public void testToParametersCodeBlock_oneElement() {
+    assertThat(Stream.of(objectO).collect(toParametersCodeBlock())).isEqualTo(objectO);
+  }
+
+  @Test
+  public void testJoiningCodeBlocks() {
+    assertThat(Stream.of(objectO, stringS, intI).collect(joiningCodeBlocks("!")))
+        .isEqualTo(CodeBlock.of("$T o!$T s!$T i", Object.class, String.class, int.class));
+  }
+
+  @Test
+  public void testJavadocLinkTo() {
+    ExecutableElement equals =
+        elements
+            .getTypeElement(Object.class.getCanonicalName())
+            .getEnclosedElements()
+            .stream()
+            .filter(element -> element.getKind().equals(METHOD))
+            .map(ExecutableElement.class::cast)
+            .filter(method -> method.getSimpleName().contentEquals("equals"))
+            .findFirst()
+            .get();
+    assertThat(javadocLinkTo(equals))
+        .isEqualTo(CodeBlock.of("{@link $T#equals($T)}", Object.class, Object.class));
+  }
+}
