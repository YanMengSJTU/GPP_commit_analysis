diff --git a/compiler/src/it/functional-tests/src/main/java/test/AbstractMembersInjectingBaseClass.java b/compiler/src/it/functional-tests/src/main/java/test/AbstractMembersInjectingBaseClass.java
new file mode 100644
index 000000000..4fb0f7832
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/AbstractMembersInjectingBaseClass.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Inject;
+
+abstract class AbstractMembersInjectingBaseClass {
+  @Inject Thing thing;
+}
+
diff --git a/compiler/src/it/functional-tests/src/main/java/test/AbstractMiddleClassWithoutMembers.java b/compiler/src/it/functional-tests/src/main/java/test/AbstractMiddleClassWithoutMembers.java
new file mode 100644
index 000000000..89e94bd2f
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/AbstractMiddleClassWithoutMembers.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+abstract class AbstractMiddleClassWithoutMembers extends AbstractMembersInjectingBaseClass {
+}
+
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ThingComponent.java b/compiler/src/it/functional-tests/src/main/java/test/ThingComponent.java
index bf33761ac..0b16afc04 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/ThingComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/ThingComponent.java
@@ -20,4 +20,5 @@
 @Component
 interface ThingComponent {
   Thing thing();
+  TypeWithInheritedMembersInjection typeWithInheritedMembersInjection();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TypeWithInheritedMembersInjection.java b/compiler/src/it/functional-tests/src/main/java/test/TypeWithInheritedMembersInjection.java
new file mode 100644
index 000000000..587baade1
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/TypeWithInheritedMembersInjection.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Inject;
+
+final class TypeWithInheritedMembersInjection extends AbstractMiddleClassWithoutMembers {
+  @Inject TypeWithInheritedMembersInjection() {}
+}
+
diff --git a/compiler/src/it/functional-tests/src/test/java/test/SimpleTest.java b/compiler/src/it/functional-tests/src/test/java/test/SimpleTest.java
index 82094e610..799b14993 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/SimpleTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/SimpleTest.java
@@ -28,4 +28,9 @@
     assertThat(thingComponent).isNotNull();
     assertThat(thingComponent.thing()).isNotNull();
   }
+
+  @Test public void inheritedMembersInjection() {
+    ThingComponent thingComponent = Dagger_ThingComponent.create();
+    assertThat(thingComponent.typeWithInheritedMembersInjection().thing).isNotNull();
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 707f96a64..94f72ec1e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -51,6 +51,8 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
 import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
+import static dagger.internal.codegen.MembersInjectionBinding.Strategy.DELEGATE;
+import static dagger.internal.codegen.MembersInjectionBinding.Strategy.NO_OP;
 import static javax.lang.model.util.ElementFilter.methodsIn;
 
 /**
@@ -345,11 +347,10 @@ private MembersInjectionBinding rollUpMembersInjectionBindings(Key key) {
         MembersInjectionBinding membersInjectionBinding =
             injectBindingRegistry.getOrFindMembersInjectionBinding(key);
 
-        if (membersInjectionBinding.injectionSites().isEmpty()
-            && membersInjectionBinding.parentInjectorRequest().isPresent()) {
+        if (membersInjectionBinding.injectionStrategy().equals(DELEGATE)) {
           MembersInjectionBinding parentBinding = rollUpMembersInjectionBindings(
               membersInjectionBinding.parentInjectorRequest().get().key());
-          if (parentBinding.injectionSites().isEmpty()) {
+          if (parentBinding.injectionStrategy().equals(NO_OP)) {
             return membersInjectionBinding.withoutParentInjectorRequest();
           }
         }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index d0410bb71..efe7e39eb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -91,6 +91,7 @@
 import static dagger.internal.codegen.Binding.bindingPackageFor;
 import static dagger.internal.codegen.ConfigurationAnnotations.getMapKeys;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
+import static dagger.internal.codegen.MembersInjectionBinding.Strategy.NO_OP;
 import static dagger.internal.codegen.ProvisionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
 import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.ProvisionBinding.Kind.SYNTHETIC_PROVISON;
@@ -477,8 +478,7 @@ private void writeFields(BindingGraph input,
         } else if (bindingKey.kind().equals(BindingKey.Kind.MEMBERS_INJECTION)) {
           MembersInjectionBinding membersInjectionBinding =
               Iterables.getOnlyElement(resolvedBindings.membersInjectionBindings());
-          if (membersInjectionBinding.injectionSites().isEmpty()
-              && !membersInjectionBinding.parentInjectorRequest().isPresent()) {
+          if (membersInjectionBinding.injectionStrategy().equals(NO_OP)) {
             // TODO(gak): refactory to use enumBindingKeys throughout the generator
             enumBindingKeysBuilder.add(bindingKey);
             memberSelectSnippetsBuilder.put(bindingKey,
@@ -1011,25 +1011,26 @@ private static Snippet initializeMembersInjectorForBinding(
       ClassName componentName,
       MembersInjectionBinding binding,
       ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets) {
-    if (binding.injectionSites().isEmpty()) {
-      if (binding.parentInjectorRequest().isPresent()) {
+    switch (binding.injectionStrategy()) {
+      case NO_OP:
+        return Snippet.format("%s.noOp()",
+            ClassName.fromClass(MembersInjectors.class));
+      case DELEGATE:
         DependencyRequest parentInjectorRequest = binding.parentInjectorRequest().get();
         return Snippet.format("%s.delegatingTo(%s)",
             ClassName.fromClass(MembersInjectors.class),
             memberSelectSnippets.get(BindingKey.forDependencyRequest(parentInjectorRequest))
                 .getSnippetFor(componentName));
-      } else {
-        return Snippet.format("%s.noOp()",
-            ClassName.fromClass(MembersInjectors.class));
-      }
-    } else {
-      List<Snippet> parameters = getDependencyParameters(
-          componentName,
-          Sets.union(binding.parentInjectorRequest().asSet(), binding.dependencies()),
-          memberSelectSnippets);
-      return Snippet.format("%s.create(%s)",
-          membersInjectorNameForMembersInjectionBinding(binding),
-          Snippet.makeParametersSnippet(parameters));
+      case INJECT_MEMBERS:
+        List<Snippet> parameters = getDependencyParameters(
+            componentName,
+            Sets.union(binding.parentInjectorRequest().asSet(), binding.dependencies()),
+            memberSelectSnippets);
+        return Snippet.format("%s.create(%s)",
+            membersInjectorNameForMembersInjectionBinding(binding),
+            Snippet.makeParametersSnippet(parameters));
+      default:
+        throw new AssertionError();
     }
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index 888c2aabe..ff432603c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -60,6 +60,22 @@
 
   abstract Optional<DependencyRequest> parentInjectorRequest();
 
+  enum Strategy {
+    NO_OP,
+    DELEGATE,
+    INJECT_MEMBERS,
+  }
+
+  Strategy injectionStrategy() {
+    if (injectionSites().isEmpty()) {
+      return parentInjectorRequest().isPresent()
+          ? Strategy.DELEGATE
+          : Strategy.NO_OP;
+    } else {
+      return Strategy.INJECT_MEMBERS;
+    }
+  }
+
   MembersInjectionBinding withoutParentInjectorRequest() {
     return new AutoValue_MembersInjectionBinding(
           key(),
