diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 25b7b720a..b73e8e97b 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -274,6 +274,7 @@ java_library(
         "ModifiableConcreteMethodBindingExpression.java",
         "MonitoringModuleGenerator.java",
         "MonitoringModuleProcessingStep.java",
+        "MultibindingExpression.java",
         "OptionalBindingExpression.java",
         "OptionalFactories.java",
         "OptionalFactoryInstanceCreationExpression.java",
diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index 24ad87e3f..f78a0e601 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -31,7 +31,6 @@
 import static dagger.model.BindingKind.DELEGATE;
 import static dagger.model.BindingKind.MULTIBOUND_MAP;
 import static dagger.model.BindingKind.MULTIBOUND_SET;
-import static java.util.function.Predicate.isEqual;
 import static javax.lang.model.element.Modifier.PUBLIC;
 
 import com.google.auto.common.MoreTypes;
@@ -72,7 +71,6 @@
   private final MembersInjectionMethods membersInjectionMethods;
   private final InnerSwitchingProviders innerSwitchingProviders;
   private final StaticSwitchingProviders staticSwitchingProviders;
-
   private final Map<BindingRequest, BindingExpression> expressions = new HashMap<>();
 
   ComponentBindingExpressions(
@@ -342,7 +340,9 @@ private boolean knownModifiableBindingWillBeFinalized(
       return true;
     }
     // All currently supported modifiable types are finalized upon modification.
-    return shouldModifyBinding(newModifiableBindingType, modifiableBindingMethod.request());
+    return modifiableBindingWillBeFinalized(
+        newModifiableBindingType,
+        shouldModifyBinding(newModifiableBindingType, modifiableBindingMethod.request()));
   }
 
   /**
@@ -353,8 +353,30 @@ private boolean knownModifiableBindingWillBeFinalized(
    */
   private boolean newModifiableBindingWillBeFinalized(
       ModifiableBindingType modifiableBindingType, BindingRequest request) {
-    // All currently supported modifiable types are finalized upon modification.
-    return shouldModifyBinding(modifiableBindingType, request);
+    return modifiableBindingWillBeFinalized(
+        modifiableBindingType, shouldModifyBinding(modifiableBindingType, request));
+  }
+
+  /**
+   * Returns true if we shouldn't attempt to further modify a modifiable binding once we complete
+   * the implementation for the current subcomponent.
+   */
+  private boolean modifiableBindingWillBeFinalized(
+      ModifiableBindingType modifiableBindingType, boolean modifyingBinding) {
+    switch (modifiableBindingType) {
+      case MISSING:
+      case GENERATED_INSTANCE:
+      case OPTIONAL:
+        // Once we modify any of the above a single time, then they are finalized.
+        return modifyingBinding;
+      case MULTIBINDING:
+        return false;
+      default:
+        throw new IllegalStateException(
+            String.format(
+                "Building binding expression for unsupported ModifiableBindingType [%s].",
+                modifiableBindingType));
+    }
   }
 
   private BindingExpression getBindingExpression(BindingRequest request) {
@@ -422,13 +444,9 @@ private BindingExpression createModifiableBindingExpression(
             matchingModifiableBindingMethod,
             matchingComponentMethod);
       case OPTIONAL:
-        BindingExpression expression = createBindingExpression(resolvedBindings, request);
-        // If the expression hasn't already been registered as a modifiable binding method then wrap
-        // the binding here.
-        if (!generatedComponentModel.getModifiableBindingMethod(request).isPresent()) {
-          return wrapInMethod(resolvedBindings, request, expression);
-        }
-        return expression;
+      case MULTIBINDING:
+        return wrapInMethod(
+            resolvedBindings, request, createBindingExpression(resolvedBindings, request));
       default:
         throw new IllegalStateException(
             String.format(
@@ -467,6 +485,11 @@ private ModifiableBindingType getModifiableBindingType(BindingRequest request) {
       if (binding.kind().equals(BindingKind.OPTIONAL)) {
         return ModifiableBindingType.OPTIONAL;
       }
+
+      if (resolvedBindings.bindingType().equals(BindingType.PROVISION)
+          && binding.isSyntheticMultibinding()) {
+        return ModifiableBindingType.MULTIBINDING;
+      }
     } else if (!resolvableBinding(request)) {
       return ModifiableBindingType.MISSING;
     }
@@ -496,6 +519,7 @@ private boolean shouldModifyKnownBinding(ModifiableBindingMethod modifiableBindi
    */
   private boolean shouldModifyBinding(
       ModifiableBindingType modifiableBindingType, BindingRequest request) {
+    ResolvedBindings resolvedBindings = graph.resolvedBindings(request);
     switch (modifiableBindingType) {
       case GENERATED_INSTANCE:
         return !generatedComponentModel.isAbstract();
@@ -507,8 +531,12 @@ private boolean shouldModifyBinding(
         return resolvableBinding(request);
       case OPTIONAL:
         // Only override optional binding methods if we have a non-empty binding.
-        ResolvedBindings resolvedBindings = graph.resolvedBindings(request);
         return !resolvedBindings.contributionBinding().dependencies().isEmpty();
+      case MULTIBINDING:
+        // Only modify a multibinding if there are new contributions.
+        return !generatedComponentModel
+            .superclassContributionsMade(request.key())
+            .containsAll(resolvedBindings.contributionBinding().dependencies());
       default:
         throw new IllegalStateException(
             String.format(
@@ -831,11 +859,13 @@ private BindingExpression instanceBindingExpression(ResolvedBindings resolvedBin
 
       case MULTIBOUND_SET:
         return Optional.of(
-            new SetBindingExpression(resolvedBindings, graph, this, types, elements));
+            new SetBindingExpression(
+                resolvedBindings, generatedComponentModel, graph, this, types, elements));
 
       case MULTIBOUND_MAP:
         return Optional.of(
-            new MapBindingExpression(resolvedBindings, graph, this, types, elements));
+            new MapBindingExpression(
+                resolvedBindings, generatedComponentModel, graph, this, types, elements));
 
       case OPTIONAL:
         return Optional.of(new OptionalBindingExpression(resolvedBindings, this, types));
@@ -912,13 +942,19 @@ private BindingExpression wrapInMethod(
       ResolvedBindings resolvedBindings,
       BindingRequest request,
       BindingExpression bindingExpression) {
+    // If we've already wrapped the expression, then use the delegate.
+    if (bindingExpression instanceof MethodBindingExpression) {
+      return bindingExpression;
+    }
+
     BindingMethodImplementation methodImplementation =
         methodImplementation(resolvedBindings, request, bindingExpression);
     Optional<ComponentMethodDescriptor> matchingComponentMethod =
         findMatchingComponentMethod(request);
 
     ModifiableBindingType modifiableBindingType = getModifiableBindingType(request);
-    if (modifiableBindingType.isModifiable() && !matchingComponentMethod.isPresent()) {
+    if (shouldUseAModifiableConcreteMethodBindingExpression(
+        modifiableBindingType, matchingComponentMethod)) {
       return new ModifiableConcreteMethodBindingExpression(
           resolvedBindings,
           request,
@@ -940,6 +976,23 @@ private BindingExpression wrapInMethod(
                     resolvedBindings, request, methodImplementation, generatedComponentModel));
   }
 
+  /**
+   * Returns true if we should wrap a binding expression using a {@link
+   * ModifiableConcreteMethodBindingExpression}. If we're generating the abstract base class of a
+   * subcomponent and the binding matches a component method, even if it is modifiable, then it
+   * should be "wrapped" by a {@link ComponentMethodBindingExpression}. If it isn't a base class
+   * then modifiable methods should be handled by a {@link
+   * ModifiableConcreteMethodBindingExpression}. When generating an inner subcomponent it doesn't
+   * matter whether the binding matches a component method: All modifiable bindings should be
+   * handled by a {@link ModifiableConcreteMethodBindingExpression}.
+   */
+  private boolean shouldUseAModifiableConcreteMethodBindingExpression(
+      ModifiableBindingType type, Optional<ComponentMethodDescriptor> matchingComponentMethod) {
+    return type.isModifiable()
+        && (generatedComponentModel.supermodel().isPresent()
+            || !matchingComponentMethod.isPresent());
+  }
+
   /** Returns the first component method associated with this request kind, if one exists. */
   private Optional<ComponentMethodDescriptor> findMatchingComponentMethod(BindingRequest request) {
     return graph.componentDescriptor().componentMethods().stream()
@@ -953,7 +1006,7 @@ private boolean doesComponentMethodMatch(
     return componentMethod
         .dependencyRequest()
         .map(BindingRequest::forDependencyRequest)
-        .filter(isEqual(request))
+        .filter(request::equals)
         .isPresent();
   }
 
diff --git a/java/dagger/internal/codegen/GeneratedComponentModel.java b/java/dagger/internal/codegen/GeneratedComponentModel.java
index 69299e8b3..424ca5307 100644
--- a/java/dagger/internal/codegen/GeneratedComponentModel.java
+++ b/java/dagger/internal/codegen/GeneratedComponentModel.java
@@ -19,6 +19,7 @@
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.CaseFormat.UPPER_UNDERSCORE;
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkState;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
@@ -30,9 +31,12 @@
 
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Supplier;
+import com.google.common.collect.HashMultimap;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ListMultimap;
 import com.google.common.collect.MultimapBuilder;
+import com.google.common.collect.SetMultimap;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.FieldSpec;
@@ -40,6 +44,8 @@
 import com.squareup.javapoet.TypeSpec;
 import dagger.internal.ReferenceReleasingProviderManager;
 import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
+import dagger.model.DependencyRequest;
+import dagger.model.Key;
 import dagger.model.RequestKind;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -145,6 +151,8 @@
       MultimapBuilder.enumKeys(TypeSpecKind.class).arrayListValues().build();
   private final List<Supplier<TypeSpec>> switchingProviderSupplier = new ArrayList<>();
   private final ModifiableBindingMethods modifiableBindingMethods = new ModifiableBindingMethods();
+  private final SetMultimap<Key, DependencyRequest> contributionsByMultibinding =
+      HashMultimap.create();
 
   private GeneratedComponentModel(
       ClassName name,
@@ -402,4 +410,43 @@ void claimMethodName(Name name) {
     switchingProviderSupplier.stream().map(Supplier::get).forEach(component::addType);
     return component;
   }
+
+  /**
+   * Registers a {@ProvisionBinding} representing a multibinding as having been implemented in this
+   * component. Multibindings are modifiable across subcomponent implementations and this allows us
+   * to know whether a contribution has been made by a superclass implementation. This is only
+   * relevant for ahead-of-time subcomponents.
+   */
+  void registerImplementedMultibinding(ContributionBinding multibinding) {
+    checkArgument(multibinding.isSyntheticMultibinding());
+    // We register a multibinding as implemented each time we request the multibinding expression,
+    // so only modify the set of contributions once.
+    if (!contributionsByMultibinding.containsKey(multibinding.key())) {
+      contributionsByMultibinding.putAll(multibinding.key(), multibinding.dependencies());
+    }
+  }
+
+  /**
+   * Returns the set of multibinding contributions associated with all superclass implementations of
+   * a multibinding.
+   */
+  ImmutableSet<DependencyRequest> superclassContributionsMade(Key key) {
+    ImmutableSet.Builder<DependencyRequest> contributionsBuilder = ImmutableSet.builder();
+    if (supermodel.isPresent()) {
+      contributionsBuilder.addAll(supermodel.get().getAllMultibindingContributions(key));
+    }
+    return contributionsBuilder.build();
+  }
+
+  /**
+   * Returns the set of multibinding contributions associated with all implementations of a
+   * multibinding.
+   */
+  private ImmutableSet<DependencyRequest> getAllMultibindingContributions(Key key) {
+    ImmutableSet.Builder<DependencyRequest> contributionsBuilder = ImmutableSet.builder();
+    if (contributionsByMultibinding.containsKey(key)) {
+      contributionsBuilder.addAll(contributionsByMultibinding.get(key));
+    }
+    return contributionsBuilder.addAll(superclassContributionsMade(key)).build();
+  }
 }
diff --git a/java/dagger/internal/codegen/MapBindingExpression.java b/java/dagger/internal/codegen/MapBindingExpression.java
index 25e2e001b..4884d2b49 100644
--- a/java/dagger/internal/codegen/MapBindingExpression.java
+++ b/java/dagger/internal/codegen/MapBindingExpression.java
@@ -32,11 +32,12 @@
 import dagger.model.BindingKind;
 import dagger.model.DependencyRequest;
 import java.util.Collections;
+import java.util.Optional;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 
 /** A {@link BindingExpression} for multibound maps. */
-final class MapBindingExpression extends SimpleInvocationBindingExpression {
+final class MapBindingExpression extends MultibindingExpression {
   /** Maximum number of key-value pairs that can be passed to ImmutableMap.of(K, V, K, V, ...). */
   private static final int MAX_IMMUTABLE_MAP_OF_KEY_VALUE_PAIRS = 5;
 
@@ -48,11 +49,12 @@
 
   MapBindingExpression(
       ResolvedBindings resolvedBindings,
+      GeneratedComponentModel generatedComponentModel,
       BindingGraph graph,
       ComponentBindingExpressions componentBindingExpressions,
       DaggerTypes types,
       DaggerElements elements) {
-    super(resolvedBindings);
+    super(resolvedBindings, generatedComponentModel);
     this.binding = (ProvisionBinding) resolvedBindings.contributionBinding();
     BindingKind bindingKind = this.binding.kind();
     checkArgument(bindingKind.equals(MULTIBOUND_MAP), bindingKind);
@@ -66,11 +68,14 @@
   }
 
   @Override
-  Expression getDependencyExpression(ClassName requestingClass) {
+  protected Expression buildDependencyExpression(ClassName requestingClass) {
+    Optional<CodeBlock> superMethodCall = superMethodCall();
     // TODO(ronshapiro): We should also make an ImmutableMap version of MapFactory
     boolean isImmutableMapAvailable = isImmutableMapAvailable();
     // TODO(ronshapiro, gak): Use Maps.immutableEnumMap() if it's available?
-    if (isImmutableMapAvailable && dependencies.size() <= MAX_IMMUTABLE_MAP_OF_KEY_VALUE_PAIRS) {
+    if (isImmutableMapAvailable
+        && dependencies.size() <= MAX_IMMUTABLE_MAP_OF_KEY_VALUE_PAIRS
+        && !superMethodCall.isPresent()) {
       return Expression.create(
           immutableMapType(),
           CodeBlock.builder()
@@ -106,9 +111,12 @@ Expression getDependencyExpression(ClassName requestingClass) {
         } else {
           instantiation.add("newMapBuilder($L)", dependencies.size());
         }
-        for (DependencyRequest dependency : dependencies.keySet()) {
+        for (DependencyRequest dependency : getNewContributions(dependencies.keySet())) {
           instantiation.add(".put($L)", keyAndValueExpression(dependency, requestingClass));
         }
+        if (superMethodCall.isPresent()) {
+          instantiation.add(CodeBlock.of(".putAll($L)", superMethodCall.get()));
+        }
         return Expression.create(
             isImmutableMapAvailable ? immutableMapType() : binding.key().type(),
             instantiation.add(".build()").build());
diff --git a/java/dagger/internal/codegen/ModifiableBindingMethods.java b/java/dagger/internal/codegen/ModifiableBindingMethods.java
index 6e7ddc6a9..d83a5fc9b 100644
--- a/java/dagger/internal/codegen/ModifiableBindingMethods.java
+++ b/java/dagger/internal/codegen/ModifiableBindingMethods.java
@@ -108,5 +108,10 @@ static ModifiableBindingMethod implement(
     abstract MethodSpec methodSpec();
 
     abstract boolean finalized();
+
+    /** Whether a {@link ModifiableBindingMethod} is for the same binding request. */
+    boolean fulfillsSameRequestAs(ModifiableBindingMethod other) {
+      return request().equals(other.request());
+    }
   }
 }
diff --git a/java/dagger/internal/codegen/ModifiableConcreteMethodBindingExpression.java b/java/dagger/internal/codegen/ModifiableConcreteMethodBindingExpression.java
index 975ed1a07..fb2c1fdc2 100644
--- a/java/dagger/internal/codegen/ModifiableConcreteMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/ModifiableConcreteMethodBindingExpression.java
@@ -22,6 +22,7 @@
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
 
+import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.TypeName;
 import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
 import java.util.Optional;
@@ -38,6 +39,7 @@
   private final BindingMethodImplementation methodImplementation;
   private final GeneratedComponentModel generatedComponentModel;
   private final boolean bindingFinalized;
+  private final Optional<ModifiableBindingMethod> matchingModifiableBindingMethod;
   private Optional<String> methodName;
 
   ModifiableConcreteMethodBindingExpression(
@@ -55,10 +57,25 @@
     this.methodImplementation = checkNotNull(methodImplementation);
     this.generatedComponentModel = checkNotNull(generatedComponentModel);
     this.bindingFinalized = bindingFinalized;
+    this.matchingModifiableBindingMethod = matchingModifiableBindingMethod;
     this.methodName =
         matchingModifiableBindingMethod.map(modifiableMethod -> modifiableMethod.methodSpec().name);
   }
 
+  @Override
+  CodeBlock getModifiableBindingMethodImplementation(
+      ModifiableBindingMethod modifiableBindingMethod, GeneratedComponentModel component) {
+    // Only emit the method implementation if the binding was known when the expression was created
+    // (and not registered when calling 'getDependencyExpression'), and we're generating a
+    // modifiable binding method for the original component (and not an ancestor component).
+    if (matchingModifiableBindingMethod.isPresent() && generatedComponentModel.equals(component)) {
+      checkState(
+          matchingModifiableBindingMethod.get().fulfillsSameRequestAs(modifiableBindingMethod));
+      return methodImplementation.body();
+    }
+    return super.getModifiableBindingMethodImplementation(modifiableBindingMethod, component);
+  }
+
   @Override
   protected void addMethod() {
     // Add the modifiable binding method to the component model if we haven't already.
diff --git a/java/dagger/internal/codegen/MultibindingExpression.java b/java/dagger/internal/codegen/MultibindingExpression.java
new file mode 100644
index 000000000..fdfd525cd
--- /dev/null
+++ b/java/dagger/internal/codegen/MultibindingExpression.java
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkState;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Sets;
+import com.google.common.collect.Sets.SetView;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
+import dagger.model.DependencyRequest;
+import dagger.model.RequestKind;
+import java.util.Optional;
+
+/** An abstract base class for multibinding {@link BindingExpression}s. */
+abstract class MultibindingExpression extends SimpleInvocationBindingExpression {
+  private final ProvisionBinding binding;
+  private final GeneratedComponentModel generatedComponentModel;
+
+  MultibindingExpression(
+      ResolvedBindings resolvedBindings, GeneratedComponentModel generatedComponentModel) {
+    super(resolvedBindings);
+    this.generatedComponentModel = generatedComponentModel;
+    this.binding = (ProvisionBinding) resolvedBindings.contributionBinding();
+  }
+
+  @Override
+  Expression getDependencyExpression(ClassName requestingClass) {
+    Expression expression = buildDependencyExpression(requestingClass);
+    generatedComponentModel.registerImplementedMultibinding(binding);
+    return expression;
+  }
+
+  /**
+   * Returns an expression that evaluates to the value of a multibinding request for the given
+   * requesting class.
+   */
+  protected abstract Expression buildDependencyExpression(ClassName requestingClass);
+
+  /**
+   * Returns the subset of {@code dependencies} that represent multibinding
+   * contributions that were not included in a superclass implementation of this multibinding
+   * method. This is relevant only for ahead-of-time subcomponents. When not generating
+   * ahead-of-time subcomponents there is only one implementation of a multibinding expression and
+   * all {@link DependencyRequest}s from the argment are returned.
+   */
+  protected SetView<DependencyRequest> getNewContributions(
+      ImmutableSet<DependencyRequest> dependencies) {
+    return Sets.difference(
+        dependencies, generatedComponentModel.superclassContributionsMade(binding.key()));
+  }
+
+  /**
+   * Returns the {@link CodeBlock} representing a call to a superclass implementation of the
+   * modifiable binding method that encapsulates this binding, if it exists. This is only possible
+   * when generating ahead-of-time subcomponents.
+   */
+  protected Optional<CodeBlock> superMethodCall() {
+    if (generatedComponentModel.supermodel().isPresent()) {
+      Optional<ModifiableBindingMethod> method =
+          generatedComponentModel.getModifiableBindingMethod(
+              BindingRequest.forDependencyRequest(binding.key(), RequestKind.INSTANCE));
+      checkState(
+          method.isPresent(),
+          "Generating a multibinding super method call when no method has been registered for the "
+              + "binding. Binding is for a %s in %s",
+          binding.key(),
+          generatedComponentModel.name());
+      ImmutableSet<DependencyRequest> superclassContributions =
+          generatedComponentModel.superclassContributionsMade(binding.key());
+      if (!superclassContributions.isEmpty()) {
+        return Optional.of(CodeBlock.of("super.$L()", method.get().methodSpec().name));
+      }
+    }
+    return Optional.empty();
+  }
+}
diff --git a/java/dagger/internal/codegen/SetBindingExpression.java b/java/dagger/internal/codegen/SetBindingExpression.java
index 2409541c0..d1f73dd29 100644
--- a/java/dagger/internal/codegen/SetBindingExpression.java
+++ b/java/dagger/internal/codegen/SetBindingExpression.java
@@ -27,11 +27,12 @@
 import dagger.internal.SetBuilder;
 import dagger.model.DependencyRequest;
 import java.util.Collections;
+import java.util.Optional;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 
 /** A binding expression for multibound sets. */
-final class SetBindingExpression extends SimpleInvocationBindingExpression {
+final class SetBindingExpression extends MultibindingExpression {
   private final ProvisionBinding binding;
   private final BindingGraph graph;
   private final ComponentBindingExpressions componentBindingExpressions;
@@ -40,11 +41,12 @@
 
   SetBindingExpression(
       ResolvedBindings resolvedBindings,
+      GeneratedComponentModel generatedComponentModel,
       BindingGraph graph,
       ComponentBindingExpressions componentBindingExpressions,
       DaggerTypes types,
       DaggerElements elements) {
-    super(resolvedBindings);
+    super(resolvedBindings, generatedComponentModel);
     this.binding = (ProvisionBinding) resolvedBindings.contributionBinding();
     this.graph = graph;
     this.componentBindingExpressions = componentBindingExpressions;
@@ -53,11 +55,14 @@
   }
 
   @Override
-  Expression getDependencyExpression(ClassName requestingClass) {
+  protected Expression buildDependencyExpression(ClassName requestingClass) {
+    Optional<CodeBlock> superMethodCall = superMethodCall();
     // TODO(ronshapiro): We should also make an ImmutableSet version of SetFactory
     boolean isImmutableSetAvailable = isImmutableSetAvailable();
     // TODO(ronshapiro, gak): Use Sets.immutableEnumSet() if it's available?
-    if (isImmutableSetAvailable && binding.dependencies().stream().allMatch(this::isSingleValue)) {
+    if (isImmutableSetAvailable
+        && binding.dependencies().stream().allMatch(this::isSingleValue)
+        && !superMethodCall.isPresent()) {
       return Expression.create(
           immutableSetType(),
           CodeBlock.builder()
@@ -105,11 +110,14 @@ Expression getDependencyExpression(ClassName requestingClass) {
         } else {
           instantiation.add("newSetBuilder($L)", binding.dependencies().size());
         }
-        for (DependencyRequest dependency : binding.dependencies()) {
+        for (DependencyRequest dependency : getNewContributions(binding.dependencies())) {
           String builderMethod = isSingleValue(dependency) ? "add" : "addAll";
           instantiation.add(
               ".$L($L)", builderMethod, getContributionExpression(dependency, requestingClass));
         }
+        if (superMethodCall.isPresent()) {
+          instantiation.add(CodeBlock.of(".addAll($L)", superMethodCall.get()));
+        }
         instantiation.add(".build()");
         return Expression.create(
             isImmutableSetAvailable ? immutableSetType() : binding.key().type(),
diff --git a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
index 8cbe47bf9..e3c40dd98 100644
--- a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
+++ b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
@@ -37,13 +37,12 @@ public void missingBindings() {
     ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
     createAncillaryClasses(
         filesToCompile,
-        "Foo",
-        "Bar",
-        "RequiresBar",
-        "Baz",
-        "Qux",
-        "RequiresQux",
-        "RequiresRequiresQux");
+        "InGrandChild",
+        "InChild",
+        "RequiresInChild",
+        "NonComponentMethodInChild",
+        "RequiresNonComponentMethodInChild",
+        "RequiresRequiresNonComponentMethodInChild");
 
     filesToCompile.add(
         JavaFileObjects.forSourceLines(
@@ -54,10 +53,11 @@ public void missingBindings() {
             "",
             "@Subcomponent(modules = GreatGrandchildModule.class)",
             "interface GreatGrandchild {",
-            "  RequiresBar requiresComponentMethodMissingBinding();",
-            "  RequiresRequiresQux requiresNonComponentMethodMissingBinding();",
-            "  Foo satisfiedByGrandchild();",
-            "  Bar satisfiedByChild();",
+            "  RequiresInChild requiresComponentMethodMissingBinding();",
+            "  RequiresRequiresNonComponentMethodInChild",
+            "      requiresNonComponentMethodMissingBinding();",
+            "  InGrandChild satisfiedByGrandchild();",
+            "  InChild satisfiedByChild();",
             "}"));
 
     filesToCompile.add(
@@ -70,12 +70,14 @@ public void missingBindings() {
             "",
             "@Module",
             "class GreatGrandchildModule {",
-            "  @Provides static RequiresBar provideRequiresBar(Bar bar) {",
-            "    return new RequiresBar();",
+            "  @Provides static RequiresInChild provideRequiresInChild(InChild inChild) {",
+            "    return new RequiresInChild();",
             "  }",
             "",
-            "  @Provides static RequiresRequiresQux provideRequiresRequiresQux(RequiresQux qux) {",
-            "    return new RequiresRequiresQux();",
+            "  @Provides static RequiresRequiresNonComponentMethodInChild",
+            "      provideRequiresRequiresNonComponentMethodInChild(",
+            "          RequiresNonComponentMethodInChild requiresNonComponentMethodInChild) {",
+            "    return new RequiresRequiresNonComponentMethodInChild();",
             "  }",
             "}"));
 
@@ -90,18 +92,22 @@ public void missingBindings() {
             "  protected DaggerGreatGrandchild() {}",
             "",
             "  @Override",
-            "  public RequiresBar requiresComponentMethodMissingBinding() {",
-            "    return GreatGrandchildModule_ProvideRequiresBarFactory.proxyProvideRequiresBar(",
-            "        satisfiedByChild());",
+            "  public RequiresInChild requiresComponentMethodMissingBinding() {",
+            "    return GreatGrandchildModule_ProvideRequiresInChildFactory",
+            "        .proxyProvideRequiresInChild(satisfiedByChild());",
             "  }",
             "",
             "  @Override",
-            "  public RequiresRequiresQux requiresNonComponentMethodMissingBinding() {",
-            "    return GreatGrandchildModule_ProvideRequiresRequiresQuxFactory",
-            "        .proxyProvideRequiresRequiresQux(getRequiresQux());",
+            "  public RequiresRequiresNonComponentMethodInChild",
+            "      requiresNonComponentMethodMissingBinding() {",
+            "    return",
+            "        GreatGrandchildModule_ProvideRequiresRequiresNonComponentMethodInChildFactory",
+            "        .proxyProvideRequiresRequiresNonComponentMethodInChild(",
+            "            getRequiresNonComponentMethodInChild());",
             "  }",
             "",
-            "  public abstract RequiresQux getRequiresQux();",
+            "  public abstract RequiresNonComponentMethodInChild",
+            "      getRequiresNonComponentMethodInChild();",
             "}");
 
     filesToCompile.add(
@@ -126,10 +132,12 @@ public void missingBindings() {
             "",
             "@Module",
             "class GrandchildModule {",
-            "  @Provides static Foo provideFoo() { return new Foo(); }",
+            "  @Provides static InGrandChild provideInGrandChild() { return new InGrandChild(); }",
             "",
-            "  @Provides static RequiresQux provideRequiresQux(Qux qux) {",
-            "    return new RequiresQux();",
+            "  @Provides static RequiresNonComponentMethodInChild",
+            "      provideRequiresNonComponentMethodInChild(",
+            "          NonComponentMethodInChild nonComponentMethodInChild) {",
+            "    return new RequiresNonComponentMethodInChild();",
             "  }",
             "}"));
 
@@ -143,12 +151,13 @@ public void missingBindings() {
             "public abstract class DaggerGrandchild implements Grandchild {",
             "  protected DaggerGrandchild() {}",
             "",
-            "  private RequiresQux getRequiresQux() {",
-            "    return GrandchildModule_ProvideRequiresQuxFactory.proxyProvideRequiresQux(",
-            "        getQux());",
+            "  private RequiresNonComponentMethodInChild getRequiresNonComponentMethodInChild() {",
+            "    return GrandchildModule_ProvideRequiresNonComponentMethodInChildFactory",
+            "        .proxyProvideRequiresNonComponentMethodInChild(",
+            "            getNonComponentMethodInChild());",
             "  }",
             "",
-            "  public abstract Qux getQux();",
+            "  public abstract NonComponentMethodInChild getNonComponentMethodInChild();",
             "",
             "  public abstract class GreatGrandchildImpl extends DaggerGreatGrandchild {",
             "    protected GreatGrandchildImpl() {",
@@ -156,13 +165,13 @@ public void missingBindings() {
             "    }",
             "",
             "    @Override",
-            "    public RequiresQux getRequiresQux() {",
-            "      return DaggerGrandchild.this.getRequiresQux();",
+            "    public RequiresNonComponentMethodInChild getRequiresNonComponentMethodInChild() {",
+            "      return DaggerGrandchild.this.getRequiresNonComponentMethodInChild();",
             "    }",
             "",
             "    @Override",
-            "    public Foo satisfiedByGrandchild() {",
-            "      return GrandchildModule_ProvideFooFactory.proxyProvideFoo();",
+            "    public InGrandChild satisfiedByGrandchild() {",
+            "      return GrandchildModule_ProvideInGrandChildFactory.proxyProvideInGrandChild();",
             "    }",
             "  }",
             "}");
@@ -189,8 +198,10 @@ public void missingBindings() {
             "",
             "@Module",
             "class ChildModule {",
-            "  @Provides static Bar provideBar() { return new Bar(); }",
-            "  @Provides static Qux provideQux() { return new Qux(); }",
+            "  @Provides static InChild provideInChild() { return new InChild(); }",
+            "  @Provides static NonComponentMethodInChild provideNonComponentMethodInChild() {",
+            "      return new NonComponentMethodInChild();",
+            "  }",
             "}"));
 
     JavaFileObject generatedChild =
@@ -209,8 +220,9 @@ public void missingBindings() {
             "    }",
             "",
             "    @Override",
-            "    public Qux getQux() {",
-            "      return ChildModule_ProvideQuxFactory.proxyProvideQux();",
+            "    public NonComponentMethodInChild getNonComponentMethodInChild() {",
+            "      return ChildModule_ProvideNonComponentMethodInChildFactory",
+            "          .proxyProvideNonComponentMethodInChild();",
             "    }",
             "",
             "    public abstract class GreatGrandchildImpl extends",
@@ -220,8 +232,8 @@ public void missingBindings() {
             "      }",
             "",
             "      @Override",
-            "      public Bar satisfiedByChild() {",
-            "        return ChildModule_ProvideBarFactory.proxyProvideBar();",
+            "      public InChild satisfiedByChild() {",
+            "        return ChildModule_ProvideInChildFactory.proxyProvideInChild();",
             "      }",
             "    }",
             "  }",
@@ -414,7 +426,8 @@ public void generatedInstanceBinding() {
   @Test
   public void optionalBindings_satisfiedByDifferentAncestors() {
     ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createAncillaryClasses(filesToCompile, "Baz", "Qux", "Flob", "Thud");
+    createAncillaryClasses(
+        filesToCompile, "Unsatisfied", "InGreatGrandchild", "InGrandchild", "InChild");
 
     filesToCompile.add(
         JavaFileObjects.forSourceLines(
@@ -426,10 +439,10 @@ public void optionalBindings_satisfiedByDifferentAncestors() {
             "",
             "@Subcomponent(modules = GreatGrandchildModule.class)",
             "interface GreatGrandchild {",
-            "  Optional<Baz> unsatisfied();",
-            "  Optional<Qux> satisfiedByGreatGrandchild();",
-            "  Optional<Flob> satisfiedByGrandchild();",
-            "  Optional<Thud> satisfiedByChild();",
+            "  Optional<Unsatisfied> unsatisfied();",
+            "  Optional<InGreatGrandchild> satisfiedByGreatGrandchild();",
+            "  Optional<InGrandchild> satisfiedByGrandchild();",
+            "  Optional<InChild> satisfiedByChild();",
             "",
             "  @Subcomponent.Builder",
             "  interface Builder {",
@@ -449,11 +462,13 @@ public void optionalBindings_satisfiedByDifferentAncestors() {
             "",
             "@Module",
             "abstract class GreatGrandchildModule {",
-            "  @BindsOptionalOf abstract Baz optionalBaz();",
-            "  @BindsOptionalOf abstract Qux optionalQux();",
-            "  @Provides static Qux provideQux() { return new Qux(); }",
-            "  @BindsOptionalOf abstract Flob optionalFlob();",
-            "  @BindsOptionalOf abstract Thud optionalThud();",
+            "  @BindsOptionalOf abstract Unsatisfied optionalUnsatisfied();",
+            "  @BindsOptionalOf abstract InGreatGrandchild optionalInGreatGrandchild();",
+            "  @Provides static InGreatGrandchild provideInGreatGrandchild() {",
+            "      return new InGreatGrandchild();",
+            "  }",
+            "  @BindsOptionalOf abstract InGrandchild optionalInGrandchild();",
+            "  @BindsOptionalOf abstract InChild optionalInChild();",
             "}"));
 
     JavaFileObject generatedGreatGrandchild =
@@ -469,23 +484,25 @@ public void optionalBindings_satisfiedByDifferentAncestors() {
             "  protected DaggerGreatGrandchild(Builder builder) {}",
             "",
             "  @Override",
-            "  public Optional<Baz> unsatisfied() {",
-            "    return Optional.<Baz>empty();",
+            "  public Optional<Unsatisfied> unsatisfied() {",
+            "    return Optional.<Unsatisfied>empty();",
             "  }",
             "",
             "  @Override",
-            "  public Optional<Qux> satisfiedByGreatGrandchild() {",
-            "    return Optional.of(GreatGrandchildModule_ProvideQuxFactory.proxyProvideQux());",
+            "  public Optional<InGreatGrandchild> satisfiedByGreatGrandchild() {",
+            "    return Optional.of(",
+            "        GreatGrandchildModule_ProvideInGreatGrandchildFactory",
+            "            .proxyProvideInGreatGrandchild());",
             "  }",
             "",
             "  @Override",
-            "  public Optional<Flob> satisfiedByGrandchild() {",
-            "    return Optional.<Flob>empty();",
+            "  public Optional<InGrandchild> satisfiedByGrandchild() {",
+            "    return Optional.<InGrandchild>empty();",
             "  }",
             "",
             "  @Override",
-            "  public Optional<Thud> satisfiedByChild() {",
-            "    return Optional.<Thud>empty();",
+            "  public Optional<InChild> satisfiedByChild() {",
+            "    return Optional.<InChild>empty();",
             "  }",
             "",
             "  protected abstract static class Builder implements GreatGrandchild.Builder {}",
@@ -513,7 +530,7 @@ public void optionalBindings_satisfiedByDifferentAncestors() {
             "",
             "@Module",
             "abstract class GrandchildModule {",
-            "  @Provides static Flob provideFlob() { return new Flob(); }",
+            "  @Provides static InGrandchild provideInGrandchild() { return new InGrandchild(); }",
             "}"));
 
     JavaFileObject generatedGrandchild =
@@ -537,9 +554,9 @@ public void optionalBindings_satisfiedByDifferentAncestors() {
             "    }",
             "",
             "    @Override",
-            "    public Optional<Flob> satisfiedByGrandchild() {",
+            "    public Optional<InGrandchild> satisfiedByGrandchild() {",
             "      return Optional.of(",
-            "          GrandchildModule_ProvideFlobFactory.proxyProvideFlob());",
+            "          GrandchildModule_ProvideInGrandchildFactory.proxyProvideInGrandchild());",
             "    }",
             "  }",
             "}");
@@ -566,7 +583,7 @@ public void optionalBindings_satisfiedByDifferentAncestors() {
             "",
             "@Module",
             "class ChildModule {",
-            "  @Provides static Thud provideThud() { return new Thud(); }",
+            "  @Provides static InChild provideInChild() { return new InChild(); }",
             "}"));
 
     JavaFileObject generatedChild =
@@ -596,8 +613,8 @@ public void optionalBindings_satisfiedByDifferentAncestors() {
             "      }",
             "",
             "      @Override",
-            "      public Optional<Thud> satisfiedByChild() {",
-            "        return Optional.of(ChildModule_ProvideThudFactory.proxyProvideThud());",
+            "      public Optional<InChild> satisfiedByChild() {",
+            "        return Optional.of(ChildModule_ProvideInChildFactory.proxyProvideInChild());",
             "      }",
             "    }",
             "  }",
@@ -623,12 +640,12 @@ public void optionalBindings_methodDependencies() {
     ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
     createAncillaryClasses(
         filesToCompile,
-        "Bar",
-        "NeedsOptionalBar",
-        "AlsoNeedsOptionalBar",
-        "Baz",
-        "NeedsOptionalBaz",
-        "AlsoNeedsOptionalBaz");
+        "NonComponentMethodInChild",
+        "NeedsOptionalNonComponentMethodInChild",
+        "AlsoNeedsOptionalNonComponentMethodInChild",
+        "ComponentMethodInGrandchild",
+        "NeedsOptionalComponentMethodInGrandchild",
+        "AlsoNeedsOptionalComponentMethodInGrandchild");
 
     filesToCompile.add(
         JavaFileObjects.forSourceLines(
@@ -640,11 +657,14 @@ public void optionalBindings_methodDependencies() {
             "",
             "@Subcomponent(modules = GreatGrandchildModule.class)",
             "interface GreatGrandchild {",
-            "  NeedsOptionalBaz needsOptionalBaz();",
-            "  Optional<Baz> componentMethod();",
-            "  NeedsOptionalBar needsOptionalBar();",
-            "  AlsoNeedsOptionalBar alsoNeedsOptionalBar();",
-            "  AlsoNeedsOptionalBaz alsoNeedsOptionalBaz();",
+            "  NeedsOptionalComponentMethodInGrandchild",
+            "      needsOptionalComponentMethodInGrandchild();",
+            "  Optional<ComponentMethodInGrandchild> componentMethod();",
+            "  NeedsOptionalNonComponentMethodInChild needsOptionalNonComponentMethodInChild();",
+            "  AlsoNeedsOptionalNonComponentMethodInChild",
+            "      alsoNeedsOptionalNonComponentMethodInChild();",
+            "  AlsoNeedsOptionalComponentMethodInGrandchild",
+            "      alsoNeedsOptionalComponentMethodInGrandchild();",
             "",
             "  @Subcomponent.Builder",
             "  interface Builder {",
@@ -664,23 +684,32 @@ public void optionalBindings_methodDependencies() {
             "",
             "@Module",
             "abstract class GreatGrandchildModule {",
-            "  @Provides static NeedsOptionalBar needsOptionalBar(Optional<Bar> optionalBar) {",
-            "    return new NeedsOptionalBar();",
+            "  @Provides static NeedsOptionalNonComponentMethodInChild",
+            "      needsOptionalNonComponentMethodInChild(",
+            "          Optional<NonComponentMethodInChild> optionalNonComponentMethodInChild) {",
+            "    return new NeedsOptionalNonComponentMethodInChild();",
             "  }",
-            "  @Provides static AlsoNeedsOptionalBar alsoNeedsOptionalBar(",
-            "      Optional<Bar> optionalBar) {",
-            "    return new AlsoNeedsOptionalBar();",
+            "  @Provides static AlsoNeedsOptionalNonComponentMethodInChild",
+            "      alsoNeedsOptionalNonComponentMethodInChild(",
+            "          Optional<NonComponentMethodInChild> optionalNonComponentMethodInChild) {",
+            "    return new AlsoNeedsOptionalNonComponentMethodInChild();",
             "  }",
-            "  @Provides static NeedsOptionalBaz needsOptionalBaz(",
-            "      Optional<Baz> optionalBaz) {",
-            "    return new NeedsOptionalBaz();",
+            "  @Provides static NeedsOptionalComponentMethodInGrandchild",
+            "      needsOptionalComponentMethodInGrandchild(",
+            "          Optional<ComponentMethodInGrandchild>",
+            "              optionalComponentMethodInGrandchild) {",
+            "    return new NeedsOptionalComponentMethodInGrandchild();",
             "  }",
-            "  @Provides static AlsoNeedsOptionalBaz alsoNeedsOptionalBaz(",
-            "      Optional<Baz> optionalBaz) {",
-            "    return new AlsoNeedsOptionalBaz();",
+            "  @Provides static AlsoNeedsOptionalComponentMethodInGrandchild",
+            "      alsoNeedsOptionalComponentMethodInGrandchild(",
+            "          Optional<ComponentMethodInGrandchild>",
+            "              optionalComponentMethodInGrandchild) {",
+            "    return new AlsoNeedsOptionalComponentMethodInGrandchild();",
             "  }",
-            "  @BindsOptionalOf abstract Baz optionalBaz();",
-            "  @BindsOptionalOf abstract Bar optionalBar();",
+            "  @BindsOptionalOf abstract ComponentMethodInGrandchild",
+            "      optionalComponentMethodInGrandchild();",
+            "  @BindsOptionalOf abstract NonComponentMethodInChild",
+            "      optionalNonComponentMethodInChild();",
             "}"));
 
     JavaFileObject generatedGreatGrandchild =
@@ -696,37 +725,44 @@ public void optionalBindings_methodDependencies() {
             "  protected DaggerGreatGrandchild(Builder builder) {}",
             "",
             "  @Override",
-            "  public NeedsOptionalBaz needsOptionalBaz() {",
-            "    return GreatGrandchildModule_NeedsOptionalBazFactory.proxyNeedsOptionalBaz(",
-            "        componentMethod());",
+            "  public NeedsOptionalComponentMethodInGrandchild",
+            "      needsOptionalComponentMethodInGrandchild() {",
+            "    return GreatGrandchildModule_NeedsOptionalComponentMethodInGrandchildFactory",
+            "        .proxyNeedsOptionalComponentMethodInGrandchild(componentMethod());",
             "  }",
             "",
             "  @Override",
-            "  public Optional<Baz> componentMethod() {",
-            "    return Optional.<Baz>empty();",
+            "  public Optional<ComponentMethodInGrandchild> componentMethod() {",
+            "    return Optional.<ComponentMethodInGrandchild>empty();",
             "  }",
             "",
             "  @Override",
-            "  public NeedsOptionalBar needsOptionalBar() {",
-            "    return GreatGrandchildModule_NeedsOptionalBarFactory.proxyNeedsOptionalBar(",
-            "        getOptionalOfBar());",
+            "  public NeedsOptionalNonComponentMethodInChild",
+            "      needsOptionalNonComponentMethodInChild() {",
+            "    return GreatGrandchildModule_NeedsOptionalNonComponentMethodInChildFactory",
+            "        .proxyNeedsOptionalNonComponentMethodInChild(",
+            "            getOptionalOfNonComponentMethodInChild());",
             "  }",
             "",
             "  @Override",
-            "  public AlsoNeedsOptionalBar alsoNeedsOptionalBar() {",
+            "  public AlsoNeedsOptionalNonComponentMethodInChild",
+            "      alsoNeedsOptionalNonComponentMethodInChild() {",
             "    return",
-            "        GreatGrandchildModule_AlsoNeedsOptionalBarFactory.proxyAlsoNeedsOptionalBar(",
-            "        getOptionalOfBar());",
+            "        GreatGrandchildModule_AlsoNeedsOptionalNonComponentMethodInChildFactory",
+            "            .proxyAlsoNeedsOptionalNonComponentMethodInChild(",
+            "                getOptionalOfNonComponentMethodInChild());",
             "  }",
             "",
             "  @Override",
-            "  public AlsoNeedsOptionalBaz alsoNeedsOptionalBaz() {",
-            "    return GreatGrandchildModule_AlsoNeedsOptionalBazFactory",
-            "        .proxyAlsoNeedsOptionalBaz(componentMethod());",
+            "  public AlsoNeedsOptionalComponentMethodInGrandchild",
+            "      alsoNeedsOptionalComponentMethodInGrandchild() {",
+            "    return GreatGrandchildModule_AlsoNeedsOptionalComponentMethodInGrandchildFactory",
+            "        .proxyAlsoNeedsOptionalComponentMethodInGrandchild(componentMethod());",
             "  }",
             "",
-            "  public Optional<Bar> getOptionalOfBar() {",
-            "    return Optional.<Bar>empty();",
+            "  public Optional<NonComponentMethodInChild>",
+            "      getOptionalOfNonComponentMethodInChild() {",
+            "    return Optional.<NonComponentMethodInChild>empty();",
             "  }",
             "",
             "  protected abstract static class Builder implements GreatGrandchild.Builder {}",
@@ -755,7 +791,9 @@ public void optionalBindings_methodDependencies() {
             "",
             "@Module",
             "abstract class GrandchildModule {",
-            "  @Provides static Baz provideBaz() { return new Baz(); }",
+            "  @Provides static ComponentMethodInGrandchild provideComponentMethodInGrandchild() {",
+            "    return new ComponentMethodInGrandchild();",
+            "  }",
             "}"));
 
     JavaFileObject generatedGrandchild =
@@ -779,8 +817,9 @@ public void optionalBindings_methodDependencies() {
             "    }",
             "",
             "    @Override",
-            "    public Optional<Baz> componentMethod() {",
-            "      return Optional.of(GrandchildModule_ProvideBazFactory.proxyProvideBaz());",
+            "    public Optional<ComponentMethodInGrandchild> componentMethod() {",
+            "      return Optional.of(GrandchildModule_ProvideComponentMethodInGrandchildFactory",
+            "          .proxyProvideComponentMethodInGrandchild());",
             "    }",
             "  }",
             "}");
@@ -807,7 +846,9 @@ public void optionalBindings_methodDependencies() {
             "",
             "@Module",
             "class ChildModule {",
-            "  @Provides static Bar provideBar() { return new Bar(); }",
+            "  @Provides static NonComponentMethodInChild provideNonComponentMethodInChild() {",
+            "    return new NonComponentMethodInChild();",
+            "  }",
             "}"));
 
     JavaFileObject generatedChild =
@@ -837,8 +878,10 @@ public void optionalBindings_methodDependencies() {
             "      }",
             "",
             "      @Override",
-            "      public Optional<Bar> getOptionalOfBar() {",
-            "        return Optional.of(ChildModule_ProvideBarFactory.proxyProvideBar());",
+            "      public Optional<NonComponentMethodInChild>",
+            "          getOptionalOfNonComponentMethodInChild() {",
+            "        return Optional.of(ChildModule_ProvideNonComponentMethodInChildFactory",
+            "            .proxyProvideNonComponentMethodInChild());",
             "      }",
             "    }",
             "  }",
@@ -862,7 +905,7 @@ public void optionalBindings_methodDependencies() {
   @Test
   public void optionalBindings_typeChanges() {
     ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
-    createAncillaryClasses(filesToCompile, "Wobble");
+    createAncillaryClasses(filesToCompile, "InChild");
 
     filesToCompile.add(
         JavaFileObjects.forSourceLines(
@@ -874,7 +917,7 @@ public void optionalBindings_typeChanges() {
             "",
             "@Subcomponent",
             "interface GreatGrandchild {",
-            "  Optional<Wobble> satisfiedByChildAndBoundInGrandchild();",
+            "  Optional<InChild> satisfiedByChildAndBoundInGrandchild();",
             "",
             "  @Subcomponent.Builder",
             "  interface Builder {",
@@ -920,7 +963,7 @@ public void optionalBindings_typeChanges() {
             "",
             "@Module",
             "abstract class GrandchildModule {",
-            "  @BindsOptionalOf abstract Wobble optionalWobble();",
+            "  @BindsOptionalOf abstract InChild optionalInChild();",
             "}"));
 
     JavaFileObject generatedGrandchild =
@@ -944,8 +987,8 @@ public void optionalBindings_typeChanges() {
             "    }",
             "",
             "    @Override",
-            "    public Optional<Wobble> satisfiedByChildAndBoundInGrandchild() {",
-            "      return Optional.<Wobble>empty();",
+            "    public Optional<InChild> satisfiedByChildAndBoundInGrandchild() {",
+            "      return Optional.<InChild>empty();",
             "    }",
             "  }",
             "}");
@@ -972,7 +1015,7 @@ public void optionalBindings_typeChanges() {
             "",
             "@Module",
             "class ChildModule {",
-            "  @Provides static Wobble provideWobble() { return new Wobble(); }",
+            "  @Provides static InChild provideInChild() { return new InChild(); }",
             "}"));
 
     JavaFileObject generatedChild =
@@ -1002,8 +1045,8 @@ public void optionalBindings_typeChanges() {
             "      }",
             "",
             "      @Override",
-            "      public Optional<Wobble> satisfiedByChildAndBoundInGrandchild() {",
-            "        return Optional.of(ChildModule_ProvideWobbleFactory.proxyProvideWobble());",
+            "      public Optional<InChild> satisfiedByChildAndBoundInGrandchild() {",
+            "        return Optional.of(ChildModule_ProvideInChildFactory.proxyProvideInChild());",
             "      }",
             "    }",
             "  }",
@@ -1024,6 +1067,1314 @@ public void optionalBindings_typeChanges() {
         .hasSourceEquivalentTo(generatedChild);
   }
 
+  @Test
+  public void setMultibindings_satisfiedByDifferentAncestors() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(
+        filesToCompile,
+        "InGreatGrandchild",
+        "InChild",
+        "InGreatGrandchildAndChild",
+        "InAllSubcomponents");
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.GreatGrandchild",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "",
+            "@Subcomponent(modules = GreatGrandchildModule.class)",
+            "interface GreatGrandchild {",
+            "  Set<InGreatGrandchild> contributionsInGreatGrandchildOnly();",
+            "  Set<InChild> contributionsInChildOnly();",
+            "  Set<InGreatGrandchildAndChild> contributionsInGreatGrandchildAndChild();",
+            "  Set<InAllSubcomponents> contributionsAtAllLevels();",
+            "}"));
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.GreatGrandchildModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "",
+            "@Module",
+            "class GreatGrandchildModule {",
+            "  @Provides",
+            "  @IntoSet",
+            "  static InGreatGrandchild provideInGreatGrandchild() {",
+            "    return new InGreatGrandchild();",
+            "  }",
+            "",
+            "  @Provides",
+            "  @IntoSet",
+            "  static InGreatGrandchildAndChild provideInGreatGrandchildAndChild() {",
+            "    return new InGreatGrandchildAndChild();",
+            "  }",
+            "",
+            "  @Provides",
+            "  @IntoSet",
+            "  static InAllSubcomponents provideInAllSubcomponents() {",
+            "    return new InAllSubcomponents();",
+            "  }",
+            "}"));
+
+    JavaFileObject generatedGreatGrandchild =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerGreatGrandchild",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerGreatGrandchild implements GreatGrandchild {",
+            "  protected DaggerGreatGrandchild() {}",
+            "",
+            "  @Override",
+            "  public Set<InGreatGrandchild> contributionsInGreatGrandchildOnly() {",
+            "    return ImmutableSet.<InGreatGrandchild>of(",
+            "        GreatGrandchildModule_ProvideInGreatGrandchildFactory",
+            "            .proxyProvideInGreatGrandchild());",
+            "  }",
+            "",
+            "  @Override",
+            "  public Set<InGreatGrandchildAndChild> contributionsInGreatGrandchildAndChild() {",
+            "    return ImmutableSet.<InGreatGrandchildAndChild>of(",
+            "        GreatGrandchildModule_ProvideInGreatGrandchildAndChildFactory",
+            "            .proxyProvideInGreatGrandchildAndChild());",
+            "  }",
+            "",
+            "  @Override",
+            "  public Set<InAllSubcomponents> contributionsAtAllLevels() {",
+            "    return ImmutableSet.<InAllSubcomponents>of(",
+            "        GreatGrandchildModule_ProvideInAllSubcomponentsFactory",
+            "            .proxyProvideInAllSubcomponents());",
+            "  }",
+            "}");
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Grandchild",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = GrandchildModule.class)",
+            "interface Grandchild {",
+            "  GreatGrandchild greatGrandchild();",
+            "}"));
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.GrandchildModule",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.ElementsIntoSet;",
+            "import java.util.Arrays;",
+            "import java.util.Set;",
+            "import java.util.HashSet;",
+            "",
+            "@Module",
+            "class GrandchildModule {",
+            "  @Provides",
+            "  @ElementsIntoSet",
+            "  static Set<InAllSubcomponents> provideInAllSubcomponents() {",
+            "      return ImmutableSet.of(new InAllSubcomponents(), new InAllSubcomponents());",
+            "  }",
+            "}"));
+
+    JavaFileObject generatedGrandchild =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerGrandchild",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerGrandchild implements Grandchild {",
+            "  protected DaggerGrandchild() {}",
+            "",
+            "  public abstract class GreatGrandchildImpl extends DaggerGreatGrandchild {",
+            "    protected GreatGrandchildImpl() {",
+            "      super();",
+            "    }",
+            "",
+            "    @Override",
+            "    public Set<InAllSubcomponents> contributionsAtAllLevels() {",
+            "      return ImmutableSet.<InAllSubcomponents>builderWithExpectedSize(2)",
+            "          .addAll(GrandchildModule_ProvideInAllSubcomponentsFactory",
+            "              .proxyProvideInAllSubcomponents())",
+            "          .addAll(super.contributionsAtAllLevels())",
+            "          .build();",
+            "    }",
+            "  }",
+            "}");
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = ChildModule.class)",
+            "interface Child {",
+            "  Grandchild grandchild();",
+            "}"));
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.ChildModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.ElementsIntoSet;",
+            "import dagger.multibindings.IntoSet;",
+            "import java.util.Arrays;",
+            "import java.util.HashSet;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "class ChildModule {",
+            "  @Provides",
+            "  @ElementsIntoSet",
+            "  static Set<InChild> provideInChilds() {",
+            "    return new HashSet<InChild>(Arrays.asList(new InChild(), new InChild()));",
+            "  }",
+            "",
+            "  @Provides",
+            "  @IntoSet",
+            "  static InGreatGrandchildAndChild provideInGreatGrandchildAndChild() {",
+            "    return new InGreatGrandchildAndChild();",
+            "  }",
+            "",
+            "  @Provides",
+            "  @IntoSet",
+            "  static InAllSubcomponents provideInAllSubcomponents() {",
+            "    return new InAllSubcomponents();",
+            "  }",
+            "}"));
+
+    JavaFileObject generatedChild =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerChild",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerChild implements Child {",
+            "  protected DaggerChild() {}",
+            "",
+            "  public abstract class GrandchildImpl extends DaggerGrandchild {",
+            "    protected GrandchildImpl() {",
+            "      super();",
+            "    }",
+            "",
+            "    public abstract class GreatGrandchildImpl extends",
+            "        DaggerGrandchild.GreatGrandchildImpl {",
+            "      protected GreatGrandchildImpl() {",
+            "        super();",
+            "      }",
+            "",
+            "      @Override",
+            "      public Set<InChild> contributionsInChildOnly() {",
+            "        return ImmutableSet.<InChild>copyOf(",
+            "            ChildModule_ProvideInChildsFactory.proxyProvideInChilds());",
+            "      }",
+            "",
+            "      @Override",
+            "      public Set<InGreatGrandchildAndChild>",
+            "          contributionsInGreatGrandchildAndChild() {",
+            "        return ImmutableSet.<InGreatGrandchildAndChild>builderWithExpectedSize(2)",
+            "            .add(ChildModule_ProvideInGreatGrandchildAndChildFactory",
+            "                .proxyProvideInGreatGrandchildAndChild())",
+            "            .addAll(super.contributionsInGreatGrandchildAndChild())",
+            "            .build();",
+            "      }",
+            "",
+            "      @Override",
+            "      public Set<InAllSubcomponents> contributionsAtAllLevels() {",
+            "        return ImmutableSet.<InAllSubcomponents>builderWithExpectedSize(3)",
+            "            .add(ChildModule_ProvideInAllSubcomponentsFactory",
+            "                .proxyProvideInAllSubcomponents())",
+            "            .addAll(super.contributionsAtAllLevels())",
+            "            .build();",
+            "      }",
+            "",
+            "    }",
+            "}");
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(AHEAD_OF_TIME_SUBCOMPONENTS_MODE.javacopts())
+            .compile(filesToCompile.build().toArray(new JavaFileObject[0]));
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerGreatGrandchild")
+        .hasSourceEquivalentTo(generatedGreatGrandchild);
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerGrandchild")
+        .hasSourceEquivalentTo(generatedGrandchild);
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerChild")
+        .hasSourceEquivalentTo(generatedChild);
+  }
+
+  @Test
+  public void setMultibindings_methodDependencies() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(
+        filesToCompile,
+        "InAllSubcomponents",
+        "RequiresInAllSubcomponents",
+        "NoContributions",
+        "RequiresNoContributions");
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.GreatGrandchild",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "",
+            "@Subcomponent(modules = GreatGrandchildModule.class)",
+            "interface GreatGrandchild {",
+            "  Set<InAllSubcomponents> contributionsAtAllLevels();",
+            "  RequiresNoContributions requiresNonComponentMethodSet();",
+            "  RequiresInAllSubcomponents requiresComponentMethodSet();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Builder module(GreatGrandchildModule module);",
+            "",
+            "    GreatGrandchild build();",
+            "  }",
+            "}"));
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.GreatGrandchildModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "class GreatGrandchildModule {",
+            "  @Provides",
+            "  @IntoSet",
+            "  static InAllSubcomponents provideInAllSubcomponents() {",
+            "    return new InAllSubcomponents();",
+            "  }",
+            "",
+            "  @Provides",
+            "  static RequiresNoContributions providesRequiresNonComponentMethodSet(",
+            "      Set<NoContributions> noContributions) {",
+            "    return new RequiresNoContributions();",
+            "  }",
+            "",
+            "  @Provides",
+            "  static RequiresInAllSubcomponents providesRequiresComponentMethodSet(",
+            "      Set<InAllSubcomponents> inAllSubcomponents) {",
+            "    return new RequiresInAllSubcomponents();",
+            "  }",
+            "}"));
+
+    JavaFileObject generatedGreatGrandchild =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerGreatGrandchild",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerGreatGrandchild implements GreatGrandchild {",
+            "  protected DaggerGreatGrandchild(Builder builder) {}",
+            "",
+            "  @Override",
+            "  public Set<InAllSubcomponents> contributionsAtAllLevels() {",
+            "    return ImmutableSet.<InAllSubcomponents>of(",
+            "        GreatGrandchildModule_ProvideInAllSubcomponentsFactory",
+            "            .proxyProvideInAllSubcomponents());",
+            "  }",
+            "",
+            "  @Override",
+            "  public RequiresNoContributions requiresNonComponentMethodSet() {",
+            "    return GreatGrandchildModule_ProvidesRequiresNonComponentMethodSetFactory",
+            "        .proxyProvidesRequiresNonComponentMethodSet(getSet());",
+            "  }",
+            "",
+            "  @Override",
+            "  public RequiresInAllSubcomponents requiresComponentMethodSet() {",
+            "    return GreatGrandchildModule_ProvidesRequiresComponentMethodSetFactory",
+            "        .proxyProvidesRequiresComponentMethodSet(contributionsAtAllLevels());",
+            "  }",
+            "",
+            "  public abstract Set<NoContributions> getSet();",
+            "",
+            "  protected abstract static class Builder implements GreatGrandchild.Builder {",
+            "",
+            "    @Override",
+            "    public Builder module(GreatGrandchildModule module) {",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Grandchild",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = GrandchildModule.class)",
+            "interface Grandchild {",
+            "  GreatGrandchild.Builder greatGrandchild();",
+            "}"));
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.GrandchildModule",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.ElementsIntoSet;",
+            "import java.util.Arrays;",
+            "import java.util.Set;",
+            "import java.util.HashSet;",
+            "",
+            "@Module",
+            "class GrandchildModule {",
+            "  @Provides",
+            "  @ElementsIntoSet",
+            "  static Set<InAllSubcomponents> provideInAllSubcomponents() {",
+            "      return ImmutableSet.of(new InAllSubcomponents(), new InAllSubcomponents());",
+            "  }",
+            "}"));
+
+    JavaFileObject generatedGrandchild =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerGrandchild",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerGrandchild implements Grandchild {",
+            "  protected DaggerGrandchild() {}",
+            "",
+            "  protected abstract class GreatGrandchildBuilder extends",
+            "      DaggerGreatGrandchild.Builder {",
+            "    @Override",
+            "    public GreatGrandchildBuilder module(GreatGrandchildModule module) {",
+            "      return this;",
+            "    }",
+            "  }",
+            "",
+            "  public abstract class GreatGrandchildImpl extends DaggerGreatGrandchild {",
+            "    protected GreatGrandchildImpl(GreatGrandchildBuilder builder) {",
+            "      super(builder);",
+            "    }",
+            "",
+            "    @Override",
+            "    public Set<InAllSubcomponents> contributionsAtAllLevels() {",
+            "      return ImmutableSet.<InAllSubcomponents>builderWithExpectedSize(2)",
+            "          .addAll(GrandchildModule_ProvideInAllSubcomponentsFactory",
+            "              .proxyProvideInAllSubcomponents())",
+            "          .addAll(super.contributionsAtAllLevels())",
+            "          .build();",
+            "    }",
+            "",
+            "  }",
+            "}");
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = ChildModule.class)",
+            "interface Child {",
+            "  Grandchild grandchild();",
+            "}"));
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.ChildModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "",
+            "@Module",
+            "class ChildModule {",
+            "",
+            "  @Provides",
+            "  @IntoSet",
+            "  static InAllSubcomponents provideInAllSubcomponents() {",
+            "    return new InAllSubcomponents();",
+            "  }",
+            "}"));
+
+    JavaFileObject generatedChild =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerChild",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerChild implements Child {",
+            "  protected DaggerChild() {}",
+            "",
+            "  public abstract class GrandchildImpl extends DaggerGrandchild {",
+            "    protected GrandchildImpl() {",
+            "      super();",
+            "    }",
+            "",
+            "    protected abstract class GreatGrandchildBuilder",
+            "        extends DaggerGrandchild.GreatGrandchildBuilder {",
+            "      @Override",
+            "      public GreatGrandchildBuilder module(GreatGrandchildModule module) {",
+            "        return this;",
+            "      }",
+            "    }",
+            "",
+            "    public abstract class GreatGrandchildImpl extends",
+            "        DaggerGrandchild.GreatGrandchildImpl {",
+            "      protected GreatGrandchildImpl(GreatGrandchildBuilder builder) {",
+            "        super(builder);",
+            "      }",
+            "",
+            "      @Override",
+            "      public Set<InAllSubcomponents> contributionsAtAllLevels() {",
+            "        return ImmutableSet.<InAllSubcomponents>builderWithExpectedSize(3)",
+            "            .add(ChildModule_ProvideInAllSubcomponentsFactory",
+            "                .proxyProvideInAllSubcomponents())",
+            "            .addAll(super.contributionsAtAllLevels())",
+            "            .build();",
+            "      }",
+            "",
+            "    }",
+            "}");
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(AHEAD_OF_TIME_SUBCOMPONENTS_MODE.javacopts())
+            .compile(filesToCompile.build().toArray(new JavaFileObject[0]));
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerGreatGrandchild")
+        .hasSourceEquivalentTo(generatedGreatGrandchild);
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerGrandchild")
+        .hasSourceEquivalentTo(generatedGrandchild);
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerChild")
+        .hasSourceEquivalentTo(generatedChild);
+  }
+
+  @Test
+  public void setMultibindings_typeChanges() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "InGrandchild");
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.GreatGrandchild",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface GreatGrandchild {",
+            "  InGrandchild missingWithSetDependency();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    GreatGrandchild build();",
+            "  }",
+            "}"));
+
+    JavaFileObject generatedGreatGrandchild =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerGreatGrandchild",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerGreatGrandchild implements GreatGrandchild {",
+            "  protected DaggerGreatGrandchild(Builder builder) {}",
+            "",
+            "  protected abstract static class Builder implements GreatGrandchild.Builder { }",
+            "}");
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Grandchild",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = GrandchildModule.class)",
+            "interface Grandchild {",
+            "  GreatGrandchild.Builder greatGrandchild();",
+            "}"));
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.GrandchildModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "class GrandchildModule {",
+            "",
+            "  @Provides",
+            "  static InGrandchild provideInGrandchild(Set<Long> longs) {",
+            "    return new InGrandchild();",
+            "  }",
+            "}"));
+
+    JavaFileObject generatedGrandchild =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerGrandchild",
+            "package test;",
+            "",
+            "import java.util.Set;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerGrandchild implements Grandchild {",
+            "  protected DaggerGrandchild() {}",
+            "",
+            "  private InGrandchild getInGrandchild() {",
+            "    return GrandchildModule_ProvideInGrandchildFactory",
+            "        .proxyProvideInGrandchild(getSet());",
+            "  }",
+            "",
+            "  public abstract Set<Long> getSet();",
+            "",
+            "  protected abstract class GreatGrandchildBuilder extends",
+            "      DaggerGreatGrandchild.Builder { }",
+            "",
+            "  public abstract class GreatGrandchildImpl extends DaggerGreatGrandchild {",
+            "    protected GreatGrandchildImpl(GreatGrandchildBuilder builder) {",
+            "      super(builder);",
+            "    }",
+            "",
+            "    @Override",
+            "    public InGrandchild missingWithSetDependency() {",
+            "      return DaggerGrandchild.this.getInGrandchild();",
+            "    }",
+            "",
+            "  }",
+            "}");
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = ChildModule.class)",
+            "interface Child {",
+            "  Grandchild grandchild();",
+            "}"));
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.ChildModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "",
+            "@Module",
+            "class ChildModule {",
+            "",
+            "  @Provides",
+            "  @IntoSet",
+            "  static Long provideLong() { return 0L; }",
+            "}"));
+
+    JavaFileObject generatedChild =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerChild",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerChild implements Child {",
+            "  protected DaggerChild() {}",
+            "",
+            "  public abstract class GrandchildImpl extends DaggerGrandchild {",
+            "    protected GrandchildImpl() {",
+            "      super();",
+            "    }",
+            "",
+            "    @Override",
+            "    public Set<Long> getSet() {",
+            "      return ImmutableSet.<Long>of(",
+            "          ChildModule_ProvideLongFactory.proxyProvideLong());",
+            "    }",
+            "",
+            "    protected abstract class GreatGrandchildBuilder",
+            "        extends DaggerGrandchild.GreatGrandchildBuilder { }",
+            "",
+            "    public abstract class GreatGrandchildImpl extends",
+            "        DaggerGrandchild.GreatGrandchildImpl {",
+            "      protected GreatGrandchildImpl(GreatGrandchildBuilder builder) {",
+            "        super(builder);",
+            "      }",
+            "    }",
+            "}");
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(AHEAD_OF_TIME_SUBCOMPONENTS_MODE.javacopts())
+            .compile(filesToCompile.build().toArray(new JavaFileObject[0]));
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerGreatGrandchild")
+        .hasSourceEquivalentTo(generatedGreatGrandchild);
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerGrandchild")
+        .hasSourceEquivalentTo(generatedGrandchild);
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerChild")
+        .hasSourceEquivalentTo(generatedChild);
+  }
+
+  @Test
+  public void mapMultibindings_satisfiedByDifferentAncestors() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(
+        filesToCompile,
+        "InGreatGrandchild",
+        "InChild",
+        "InGreatGrandchildAndChild",
+        "InAllSubcomponents");
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.GreatGrandchild",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "",
+            "@Subcomponent(modules = GreatGrandchildModule.class)",
+            "interface GreatGrandchild {",
+            "  Map<String, InGreatGrandchild> contributionsInGreatGrandchildOnly();",
+            "  Map<String, InChild> contributionsInChildOnly();",
+            "  Map<String, InGreatGrandchildAndChild> contributionsInGreatGrandchildAndChild();",
+            "  Map<String, InAllSubcomponents> contributionsAtAllLevels();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Builder module(GreatGrandchildModule module);",
+            "",
+            "    GreatGrandchild build();",
+            "  }",
+            "}"));
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.GreatGrandchildModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "class GreatGrandchildModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"great-grandchild\")",
+            "  static InGreatGrandchild provideInGreatGrandchild() {",
+            "    return new InGreatGrandchild();",
+            "  }",
+            "",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"great-grandchild\")",
+            "  static InGreatGrandchildAndChild provideInGreatGrandchildAndChild() {",
+            "    return new InGreatGrandchildAndChild();",
+            "  }",
+            "",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"great-grandchild\")",
+            "  static InAllSubcomponents provideInAllSubcomponents() {",
+            "    return new InAllSubcomponents();",
+            "  }",
+            "}"));
+
+    JavaFileObject generatedGreatGrandchild =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerGreatGrandchild",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import java.util.Map;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerGreatGrandchild implements GreatGrandchild {",
+            "  protected DaggerGreatGrandchild(Builder builder) {}",
+            "",
+            "  @Override",
+            "  public Map<String, InGreatGrandchild> contributionsInGreatGrandchildOnly() {",
+            "    return ImmutableMap.<String, InGreatGrandchild>of(",
+            "        \"great-grandchild\",",
+            "        GreatGrandchildModule_ProvideInGreatGrandchildFactory",
+            "            .proxyProvideInGreatGrandchild());",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<String, InGreatGrandchildAndChild>",
+            "      contributionsInGreatGrandchildAndChild() {",
+            "    return ImmutableMap.<String, InGreatGrandchildAndChild>of(",
+            "        \"great-grandchild\",",
+            "        GreatGrandchildModule_ProvideInGreatGrandchildAndChildFactory",
+            "            .proxyProvideInGreatGrandchildAndChild());",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<String, InAllSubcomponents> contributionsAtAllLevels() {",
+            "    return ImmutableMap.<String, InAllSubcomponents>of(",
+            "        \"great-grandchild\",",
+            "        GreatGrandchildModule_ProvideInAllSubcomponentsFactory",
+            "            .proxyProvideInAllSubcomponents());",
+            "  }",
+            "",
+            "  protected abstract static class Builder implements GreatGrandchild.Builder {",
+            "",
+            "    @Override",
+            "    public Builder module(GreatGrandchildModule module) {",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Grandchild",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = GrandchildModule.class)",
+            "interface Grandchild {",
+            "  GreatGrandchild.Builder greatGrandchild();",
+            "}"));
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.GrandchildModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "",
+            "@Module",
+            "class GrandchildModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"grandchild\")",
+            "  static InAllSubcomponents provideInAllSubcomponents() {",
+            "    return new InAllSubcomponents();",
+            "  }",
+            "}"));
+
+    JavaFileObject generatedGrandchild =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerGrandchild",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import java.util.Map;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerGrandchild implements Grandchild {",
+            "  protected DaggerGrandchild() {}",
+            "",
+            "  protected abstract class GreatGrandchildBuilder extends",
+            "      DaggerGreatGrandchild.Builder {",
+            "    @Override",
+            "    public GreatGrandchildBuilder module(GreatGrandchildModule module) {",
+            "      return this;",
+            "    }",
+            "  }",
+            "",
+            "  public abstract class GreatGrandchildImpl extends DaggerGreatGrandchild {",
+            "    protected GreatGrandchildImpl(GreatGrandchildBuilder builder) {",
+            "      super(builder);",
+            "    }",
+            "",
+            "    @Override",
+            "    public Map<String, InAllSubcomponents> contributionsAtAllLevels() {",
+            "      return ImmutableMap.<String, InAllSubcomponents>builderWithExpectedSize(2)",
+            "          .put(\"grandchild\", GrandchildModule_ProvideInAllSubcomponentsFactory",
+            "              .proxyProvideInAllSubcomponents())",
+            "          .putAll(super.contributionsAtAllLevels())",
+            "          .build();",
+            "    }",
+            "  }",
+            "}");
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = ChildModule.class)",
+            "interface Child {",
+            "  Grandchild grandchild();",
+            "}"));
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.ChildModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "",
+            "@Module",
+            "class ChildModule {",
+            "",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"child\")",
+            "  static InChild provideInChild() {",
+            "    return new InChild();",
+            "  }",
+            "",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"child\")",
+            "  static InGreatGrandchildAndChild provideInGreatGrandchildAndChild() {",
+            "    return new InGreatGrandchildAndChild();",
+            "  }",
+            "",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"child\")",
+            "  static InAllSubcomponents provideInAllSubcomponents() {",
+            "    return new InAllSubcomponents();",
+            "  }",
+            "}"));
+
+    JavaFileObject generatedChild =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerChild",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import java.util.Map;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerChild implements Child {",
+            "  protected DaggerChild() {}",
+            "",
+            "  public abstract class GrandchildImpl extends DaggerGrandchild {",
+            "    protected GrandchildImpl() {",
+            "      super();",
+            "    }",
+            "",
+            "    protected abstract class GreatGrandchildBuilder",
+            "        extends DaggerGrandchild.GreatGrandchildBuilder {",
+            "      @Override",
+            "      public GreatGrandchildBuilder module(GreatGrandchildModule module) {",
+            "        return this;",
+            "      }",
+            "    }",
+            "",
+            "    public abstract class GreatGrandchildImpl extends",
+            "        DaggerGrandchild.GreatGrandchildImpl {",
+            "      protected GreatGrandchildImpl(GreatGrandchildBuilder builder) {",
+            "        super(builder);",
+            "      }",
+            "",
+            "      @Override",
+            "      public Map<String, InChild> contributionsInChildOnly() {",
+            "        return ImmutableMap.<String, InChild>of(",
+            "            \"child\", ChildModule_ProvideInChildFactory.proxyProvideInChild());",
+            "      }",
+            "",
+            "      @Override",
+            "      public Map<String, InGreatGrandchildAndChild>",
+            "          contributionsInGreatGrandchildAndChild() {",
+            "        return",
+            "            ImmutableMap.<String, InGreatGrandchildAndChild>builderWithExpectedSize(",
+            "                2)",
+            "            .put(\"child\",",
+            "                ChildModule_ProvideInGreatGrandchildAndChildFactory",
+            "                    .proxyProvideInGreatGrandchildAndChild())",
+            "            .putAll(super.contributionsInGreatGrandchildAndChild())",
+            "            .build();",
+            "      }",
+            "",
+            "      @Override",
+            "      public Map<String, InAllSubcomponents> contributionsAtAllLevels() {",
+            "        return ImmutableMap.<String, InAllSubcomponents>builderWithExpectedSize(3)",
+            "            .put(\"child\",",
+            "                ChildModule_ProvideInAllSubcomponentsFactory",
+            "                    .proxyProvideInAllSubcomponents())",
+            "            .putAll(super.contributionsAtAllLevels())",
+            "            .build();",
+            "      }",
+            "    }",
+            "}");
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(AHEAD_OF_TIME_SUBCOMPONENTS_MODE.javacopts())
+            .compile(filesToCompile.build().toArray(new JavaFileObject[0]));
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerGreatGrandchild")
+        .hasSourceEquivalentTo(generatedGreatGrandchild);
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerGrandchild")
+        .hasSourceEquivalentTo(generatedGrandchild);
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerChild")
+        .hasSourceEquivalentTo(generatedChild);
+  }
+
+  @Test
+  public void mapMultibindings_methodDependencies() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(
+        filesToCompile,
+        "InAllSubcomponents",
+        "RequiresInAllSubcomponentsMap",
+        "Unsatisfied",
+        "RequiresUnsatisfiedMap");
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.GreatGrandchild",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "",
+            "@Subcomponent(modules = GreatGrandchildModule.class)",
+            "interface GreatGrandchild {",
+            "  Map<String, InAllSubcomponents> contributionsAtAllLevels();",
+            "  RequiresUnsatisfiedMap requiresNonComponentMethodMap();",
+            "  RequiresInAllSubcomponentsMap requiresComponentMethodMap();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Builder module(GreatGrandchildModule module);",
+            "",
+            "    GreatGrandchild build();",
+            "  }",
+            "}"));
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.GreatGrandchildModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "class GreatGrandchildModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"great-grandchild\")",
+            "  static InAllSubcomponents provideInAllSubcomponents() {",
+            "    return new InAllSubcomponents();",
+            "  }",
+            "",
+            "  @Provides",
+            "  static RequiresUnsatisfiedMap providesRequiresNonComponentMethodMap(",
+            "      Map<String, Unsatisfied> unsatisfiedMap) {",
+            "    return new RequiresUnsatisfiedMap();",
+            "  }",
+            "",
+            "  @Provides",
+            "  static RequiresInAllSubcomponentsMap providesRequiresComponentMethodMap(",
+            "      Map<String, InAllSubcomponents> inAllSubcomponentsMap) {",
+            "    return new RequiresInAllSubcomponentsMap();",
+            "  }",
+            "}"));
+
+    JavaFileObject generatedGreatGrandchild =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerGreatGrandchild",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import java.util.Map;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerGreatGrandchild implements GreatGrandchild {",
+            "  protected DaggerGreatGrandchild(Builder builder) {}",
+            "",
+            "  @Override",
+            "  public Map<String, InAllSubcomponents> contributionsAtAllLevels() {",
+            "    return ImmutableMap.<String, InAllSubcomponents>of(",
+            "        \"great-grandchild\",",
+            "        GreatGrandchildModule_ProvideInAllSubcomponentsFactory",
+            "            .proxyProvideInAllSubcomponents());",
+            "  }",
+            "",
+            "  @Override",
+            "  public RequiresUnsatisfiedMap requiresNonComponentMethodMap() {",
+            "    return GreatGrandchildModule_ProvidesRequiresNonComponentMethodMapFactory",
+            "        .proxyProvidesRequiresNonComponentMethodMap(getMap());",
+            "  }",
+            "",
+            "  @Override",
+            "  public RequiresInAllSubcomponentsMap requiresComponentMethodMap() {",
+            "    return GreatGrandchildModule_ProvidesRequiresComponentMethodMapFactory",
+            "        .proxyProvidesRequiresComponentMethodMap(contributionsAtAllLevels());",
+            "  }",
+            "",
+            "  public abstract Map<String, Unsatisfied> getMap();",
+            "",
+            "  protected abstract static class Builder implements GreatGrandchild.Builder {",
+            "",
+            "    @Override",
+            "    public Builder module(GreatGrandchildModule module) {",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Grandchild",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = GrandchildModule.class)",
+            "interface Grandchild {",
+            "  GreatGrandchild.Builder greatGrandchild();",
+            "}"));
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.GrandchildModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "",
+            "@Module",
+            "class GrandchildModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"grandchild\")",
+            "  static InAllSubcomponents provideInAllSubcomponents() {",
+            "    return new InAllSubcomponents();",
+            "  }",
+            "}"));
+
+    JavaFileObject generatedGrandchild =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerGrandchild",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import java.util.Map;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerGrandchild implements Grandchild {",
+            "  protected DaggerGrandchild() {}",
+            "",
+            "  protected abstract class GreatGrandchildBuilder extends",
+            "      DaggerGreatGrandchild.Builder {",
+            "    @Override",
+            "    public GreatGrandchildBuilder module(GreatGrandchildModule module) {",
+            "      return this;",
+            "    }",
+            "  }",
+            "",
+            "  public abstract class GreatGrandchildImpl extends DaggerGreatGrandchild {",
+            "    protected GreatGrandchildImpl(GreatGrandchildBuilder builder) {",
+            "      super(builder);",
+            "    }",
+            "",
+            "    @Override",
+            "    public Map<String, InAllSubcomponents> contributionsAtAllLevels() {",
+            "      return ImmutableMap.<String, InAllSubcomponents>builderWithExpectedSize(2)",
+            "          .put(\"grandchild\",",
+            "              GrandchildModule_ProvideInAllSubcomponentsFactory",
+            "                  .proxyProvideInAllSubcomponents())",
+            "          .putAll(super.contributionsAtAllLevels())",
+            "          .build();",
+            "    }",
+            "  }",
+            "}");
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = ChildModule.class)",
+            "interface Child {",
+            "  Grandchild grandchild();",
+            "}"));
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.ChildModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "",
+            "@Module",
+            "class ChildModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"child\")",
+            "  static InAllSubcomponents provideInAllSubcomponents() {",
+            "    return new InAllSubcomponents();",
+            "  }",
+            "}"));
+
+    JavaFileObject generatedChild =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerChild",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import java.util.Map;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerChild implements Child {",
+            "  protected DaggerChild() {}",
+            "",
+            "  public abstract class GrandchildImpl extends DaggerGrandchild {",
+            "    protected GrandchildImpl() {",
+            "      super();",
+            "    }",
+            "",
+            "    protected abstract class GreatGrandchildBuilder",
+            "        extends DaggerGrandchild.GreatGrandchildBuilder {",
+            "      @Override",
+            "      public GreatGrandchildBuilder module(GreatGrandchildModule module) {",
+            "        return this;",
+            "      }",
+            "    }",
+            "",
+            "    public abstract class GreatGrandchildImpl extends",
+            "        DaggerGrandchild.GreatGrandchildImpl {",
+            "      protected GreatGrandchildImpl(GreatGrandchildBuilder builder) {",
+            "        super(builder);",
+            "      }",
+            "",
+            "      @Override",
+            "      public Map<String, InAllSubcomponents> contributionsAtAllLevels() {",
+            "        return ImmutableMap.<String, InAllSubcomponents>builderWithExpectedSize(3)",
+            "            .put(\"child\",",
+            "                ChildModule_ProvideInAllSubcomponentsFactory",
+            "                    .proxyProvideInAllSubcomponents())",
+            "            .putAll(super.contributionsAtAllLevels())",
+            "            .build();",
+            "      }",
+            "    }",
+            "}");
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(AHEAD_OF_TIME_SUBCOMPONENTS_MODE.javacopts())
+            .compile(filesToCompile.build().toArray(new JavaFileObject[0]));
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerGreatGrandchild")
+        .hasSourceEquivalentTo(generatedGreatGrandchild);
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerGrandchild")
+        .hasSourceEquivalentTo(generatedGrandchild);
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerChild")
+        .hasSourceEquivalentTo(generatedChild);
+  }
+
   private void createAncillaryClasses(
       ImmutableList.Builder<JavaFileObject> filesBuilder, String... ancillaryClasses) {
     for (String className : ancillaryClasses) {
