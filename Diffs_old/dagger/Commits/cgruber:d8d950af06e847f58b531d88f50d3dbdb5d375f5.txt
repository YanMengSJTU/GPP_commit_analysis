diff --git a/compiler/src/it/guava-functional-tests/pom.xml b/compiler/src/it/guava-functional-tests/pom.xml
new file mode 100644
index 000000000..cb127fa0e
--- /dev/null
+++ b/compiler/src/it/guava-functional-tests/pom.xml
@@ -0,0 +1,78 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+Copyright (C) 2016 Google, Inc.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <parent>
+    <groupId>com.google.dagger</groupId>
+    <artifactId>dagger-parent</artifactId>
+    <version>HEAD-SNAPSHOT</version>
+  </parent>
+  <groupId>dagger.tests</groupId>
+  <artifactId>guava-functional-tests</artifactId>
+  <name>Guava Functional Tests</name>
+  <dependencies>
+    <dependency>
+      <groupId>com.google.dagger</groupId>
+      <artifactId>dagger</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.dagger</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>${project.version}</version>
+      <optional>true</optional>
+    </dependency>
+    <dependency>
+      <groupId>com.google.auto.value</groupId>
+      <artifactId>auto-value</artifactId>
+      <version>${auto.value.version}</version>
+      <scope>provided</scope> <!-- to leave out of the all-deps jar -->
+    </dependency>
+    <dependency>
+      <groupId>com.google.auto.factory</groupId>
+      <artifactId>auto-factory</artifactId>
+      <version>${auto.factory.version}</version>
+      <scope>provided</scope> <!-- to leave out of the all-deps jar -->
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.google.truth</groupId>
+      <artifactId>truth</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <version>3.1</version>
+        <configuration>
+          <source>1.7</source>
+          <target>1.7</target>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/compiler/src/it/guava-functional-tests/src/main/java/test/optional/OptionalBindingComponents.java b/compiler/src/it/guava-functional-tests/src/main/java/test/optional/OptionalBindingComponents.java
new file mode 100644
index 000000000..c57b0cab3
--- /dev/null
+++ b/compiler/src/it/guava-functional-tests/src/main/java/test/optional/OptionalBindingComponents.java
@@ -0,0 +1,155 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.optional;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Optional;
+import dagger.BindsOptionalOf;
+import dagger.Component;
+import dagger.Lazy;
+import dagger.Module;
+import dagger.Provides;
+import dagger.Subcomponent;
+import java.lang.annotation.Retention;
+import javax.inject.Inject;
+import javax.inject.Provider;
+import javax.inject.Qualifier;
+
+/**
+ * Classes to support {@link OptionalBindingComponentsTest} and
+ * {@link test.optional.a.OptionalBindingComponentsWithInaccessibleTypesTest}.
+ */
+public final class OptionalBindingComponents {
+
+  /** A qualifier. */
+  @Qualifier
+  @Retention(RUNTIME)
+  public @interface SomeQualifier {}
+
+  /** A value object that contains various optionally-bound objects. */
+  @AutoValue
+  public abstract static class Values {
+    abstract Optional<Value> optionalInstance();
+
+    abstract Optional<Provider<Value>> optionalProvider();
+
+    abstract Optional<Lazy<Value>> optionalLazy();
+
+    abstract Optional<Provider<Lazy<Value>>> optionalLazyProvider();
+  }
+
+  // Default access so that it's inaccessible to OptionalBindingComponentsWithInaccessibleTypes.
+  enum Value {
+    VALUE,
+    QUALIFIED_VALUE
+  }
+
+  static final class InjectedThing {
+    @Inject
+    InjectedThing() {}
+  }
+
+  /** Binds optionals and {@link Values}. */
+  @Module
+  public abstract static class OptionalBindingModule {
+    @BindsOptionalOf
+    abstract Value value();
+
+    @BindsOptionalOf
+    @SomeQualifier abstract Value qualifiedValue();
+
+    // Valid because it's qualified.
+    @BindsOptionalOf
+    @SomeQualifier abstract InjectedThing qualifiedInjectedThing();
+
+    @Provides
+    static Values values(
+        Optional<Value> optionalInstance,
+        Optional<Provider<Value>> optionalProvider,
+        Optional<Lazy<Value>> optionalLazy,
+        Optional<Provider<Lazy<Value>>> optionalLazyProvider) {
+      return new AutoValue_OptionalBindingComponents_Values(
+          optionalInstance, optionalProvider, optionalLazy, optionalLazyProvider);
+    }
+
+    @Provides
+    @SomeQualifier
+    static Values qualifiedValues(
+        @SomeQualifier Optional<Value> optionalInstance,
+        @SomeQualifier Optional<Provider<Value>> optionalProvider,
+        @SomeQualifier Optional<Lazy<Value>> optionalLazy,
+        @SomeQualifier Optional<Provider<Lazy<Value>>> optionalLazyProvider) {
+      return new AutoValue_OptionalBindingComponents_Values(
+          optionalInstance, optionalProvider, optionalLazy, optionalLazyProvider);
+    }
+  }
+
+  /** Binds {@link Value}. */
+  @Module
+  public abstract static class ConcreteBindingModule {
+    /** @param cycle to demonstrate that optional {@link Provider} injection can break cycles */
+    @Provides
+    static Value value(Optional<Provider<Value>> cycle) {
+      return Value.VALUE;
+    }
+
+    @Provides
+    @SomeQualifier static Value qualifiedValue() {
+      return Value.QUALIFIED_VALUE;
+    }
+  }
+
+  interface OptionalBindingComponent {
+    Values values();
+
+    Optional<Value> optionalInstance();
+
+    Optional<Provider<Value>> optionalProvider();
+
+    Optional<Lazy<Value>> optionalLazy();
+
+    Optional<Provider<Lazy<Value>>> optionalLazyProvider();
+
+    @SomeQualifier
+    Values qualifiedValues();
+
+    @SomeQualifier
+    Optional<Value> qualifiedOptionalInstance();
+
+    @SomeQualifier
+    Optional<Provider<Value>> qualifiedOptionalProvider();
+
+    @SomeQualifier
+    Optional<Lazy<Value>> qualifiedOptionalLazy();
+
+    @SomeQualifier
+    Optional<Provider<Lazy<Value>>> qualifiedOptionalLazyProvider();
+  }
+
+  @Component(modules = OptionalBindingModule.class)
+  interface AbsentOptionalBindingComponent extends OptionalBindingComponent {
+    PresentOptionalBindingSubcomponent presentChild();
+  }
+
+  @Component(modules = {OptionalBindingModule.class, ConcreteBindingModule.class})
+  interface PresentOptionalBindingComponent extends OptionalBindingComponent {}
+
+  @Subcomponent(modules = ConcreteBindingModule.class)
+  interface PresentOptionalBindingSubcomponent extends OptionalBindingComponent {}
+}
diff --git a/compiler/src/it/guava-functional-tests/src/main/java/test/optional/a/OptionalBindingComponentsWithInaccessibleTypes.java b/compiler/src/it/guava-functional-tests/src/main/java/test/optional/a/OptionalBindingComponentsWithInaccessibleTypes.java
new file mode 100644
index 000000000..f9a2f758c
--- /dev/null
+++ b/compiler/src/it/guava-functional-tests/src/main/java/test/optional/a/OptionalBindingComponentsWithInaccessibleTypes.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.optional.a;
+
+import dagger.Component;
+import test.optional.OptionalBindingComponents.ConcreteBindingModule;
+import test.optional.OptionalBindingComponents.OptionalBindingModule;
+import test.optional.OptionalBindingComponents.SomeQualifier;
+import test.optional.OptionalBindingComponents.Values;
+
+final class OptionalBindingComponentsWithInaccessibleTypes {
+
+  interface OptionalBindingComponent {
+    Values values();
+
+    @SomeQualifier
+    Values qualifiedValues();
+  }
+
+  @Component(modules = OptionalBindingModule.class)
+  interface AbsentOptionalBindingComponent extends OptionalBindingComponent {}
+
+  @Component(modules = {OptionalBindingModule.class, ConcreteBindingModule.class})
+  interface PresentOptionalBindingComponent extends OptionalBindingComponent {}
+}
diff --git a/compiler/src/it/guava-functional-tests/src/test/java/test/optional/OptionalBindingComponentsTest.java b/compiler/src/it/guava-functional-tests/src/test/java/test/optional/OptionalBindingComponentsTest.java
new file mode 100644
index 000000000..ef437cf84
--- /dev/null
+++ b/compiler/src/it/guava-functional-tests/src/test/java/test/optional/OptionalBindingComponentsTest.java
@@ -0,0 +1,166 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.optional;
+
+import static com.google.common.truth.Truth.assertThat;
+import static test.optional.OptionalBindingComponents.Value.QUALIFIED_VALUE;
+import static test.optional.OptionalBindingComponents.Value.VALUE;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import test.optional.OptionalBindingComponents.AbsentOptionalBindingComponent;
+import test.optional.OptionalBindingComponents.PresentOptionalBindingComponent;
+import test.optional.OptionalBindingComponents.PresentOptionalBindingSubcomponent;
+
+/** Tests for optional bindings. */
+@RunWith(JUnit4.class)
+public final class OptionalBindingComponentsTest {
+  private AbsentOptionalBindingComponent absent;
+  private PresentOptionalBindingComponent present;
+  private PresentOptionalBindingSubcomponent presentChild;
+
+  @Before
+  public void setUp() {
+    absent = DaggerOptionalBindingComponents_AbsentOptionalBindingComponent.create();
+    present = DaggerOptionalBindingComponents_PresentOptionalBindingComponent.create();
+    presentChild = absent.presentChild();
+  }
+
+  @Test
+  public void absentOptional() {
+    assertThat(absent.optionalInstance()).isAbsent();
+  }
+
+  @Test
+  public void absentOptionalProvider() {
+    assertThat(absent.optionalProvider()).isAbsent();
+  }
+
+  @Test
+  public void absentOptionalLazy() {
+    assertThat(absent.optionalLazy()).isAbsent();
+  }
+
+  @Test
+  public void absentOptionalLazyProvider() {
+    assertThat(absent.optionalLazyProvider()).isAbsent();
+  }
+
+  @Test
+  public void absentQualifiedOptional() {
+    assertThat(absent.qualifiedOptionalInstance()).isAbsent();
+  }
+
+  @Test
+  public void absentQualifiedOptionalProvider() {
+    assertThat(absent.qualifiedOptionalProvider()).isAbsent();
+  }
+
+  @Test
+  public void absentQualifiedOptionalLazy() {
+    assertThat(absent.qualifiedOptionalLazy()).isAbsent();
+  }
+
+  @Test
+  public void absentQualifiedOptionalLazyProvider() {
+    assertThat(absent.qualifiedOptionalLazyProvider()).isAbsent();
+  }
+
+  @Test
+  public void presentOptional() {
+    assertThat(present.optionalInstance()).hasValue(VALUE);
+  }
+
+  @Test
+  public void presentOptionalProvider() {
+    assertThat(present.optionalProvider().get().get()).isEqualTo(VALUE);
+  }
+
+  @Test
+  public void presentOptionalLazy() {
+    assertThat(present.optionalLazy().get().get()).isEqualTo(VALUE);
+  }
+
+  @Test
+  public void presentOptionalLazyProvider() {
+    assertThat(present.optionalLazyProvider().get().get().get()).isEqualTo(VALUE);
+  }
+
+  @Test
+  public void presentQualifiedOptional() {
+    assertThat(present.qualifiedOptionalInstance()).hasValue(QUALIFIED_VALUE);
+  }
+
+  @Test
+  public void presentQualifiedOptionalProvider() {
+    assertThat(present.qualifiedOptionalProvider().get().get()).isEqualTo(QUALIFIED_VALUE);
+  }
+
+  @Test
+  public void presentQualifiedOptionalLazy() {
+    assertThat(present.qualifiedOptionalLazy().get().get()).isEqualTo(QUALIFIED_VALUE);
+  }
+
+  @Test
+  public void presentQualifiedOptionalLazyProvider() {
+    assertThat(present.qualifiedOptionalLazyProvider().get().get().get())
+        .isEqualTo(QUALIFIED_VALUE);
+  }
+
+  @Test
+  public void presentChildOptional() {
+    assertThat(presentChild.optionalInstance()).hasValue(VALUE);
+  }
+
+  @Test
+  public void presentChildOptionalProvider() {
+    assertThat(presentChild.optionalProvider().get().get()).isEqualTo(VALUE);
+  }
+
+  @Test
+  public void presentChildOptionalLazy() {
+    assertThat(presentChild.optionalLazy().get().get()).isEqualTo(VALUE);
+  }
+
+  @Test
+  public void presentChildOptionalLazyProvider() {
+    assertThat(presentChild.optionalLazyProvider().get().get().get()).isEqualTo(VALUE);
+  }
+
+  @Test
+  public void presentChildQualifiedOptional() {
+    assertThat(presentChild.qualifiedOptionalInstance()).hasValue(QUALIFIED_VALUE);
+  }
+
+  @Test
+  public void presentChildQualifiedOptionalProvider() {
+    assertThat(presentChild.qualifiedOptionalProvider().get().get()).isEqualTo(QUALIFIED_VALUE);
+  }
+
+  @Test
+  public void presentChildQualifiedOptionalLazy() {
+    assertThat(presentChild.qualifiedOptionalLazy().get().get()).isEqualTo(QUALIFIED_VALUE);
+  }
+
+  @Test
+  public void presentChildQualifiedOptionalLazyProvider() {
+    assertThat(presentChild.qualifiedOptionalLazyProvider().get().get().get())
+        .isEqualTo(QUALIFIED_VALUE);
+  }
+}
diff --git a/compiler/src/it/guava-functional-tests/src/test/java/test/optional/a/OptionalBindingComponentsWithInaccessibleTypesTest.java b/compiler/src/it/guava-functional-tests/src/test/java/test/optional/a/OptionalBindingComponentsWithInaccessibleTypesTest.java
new file mode 100644
index 000000000..ed655022f
--- /dev/null
+++ b/compiler/src/it/guava-functional-tests/src/test/java/test/optional/a/OptionalBindingComponentsWithInaccessibleTypesTest.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.optional.a;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests for optional bindings that include types inaccessible to the component. */
+@RunWith(JUnit4.class)
+public class OptionalBindingComponentsWithInaccessibleTypesTest {
+  @Test
+  public void components() {
+    DaggerOptionalBindingComponentsWithInaccessibleTypes_AbsentOptionalBindingComponent.create();
+    DaggerOptionalBindingComponentsWithInaccessibleTypes_PresentOptionalBindingComponent.create();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 64b78268e..c0ea93968 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -162,6 +162,13 @@
    */
   protected final Map<TypeElement, MemberSelect> componentContributionFields = Maps.newHashMap();
 
+  /**
+   * The factory classes that implement {@code Provider<Optional<T>>} within the component. If the
+   * key is {@link Optional#absent()}, the class provides absent values.
+   */
+  private final Map<Optional<DependencyRequest.Kind>, TypeSpec> optionalFactoryClasses =
+      new HashMap<>();
+
   AbstractComponentWriter(
       Types types,
       Elements elements,
@@ -570,12 +577,12 @@ private boolean useRawType(Optional<String> bindingPackage) {
                       generatedClassNameForBinding(contributionBinding), typeArguments));
                 }
               }
+              // fall through
 
             default:
               return Optional.of(
                   staticMethod(
-                      generatedClassNameForBinding(contributionBinding),
-                      CodeBlock.of("create()")));
+                      generatedClassNameForBinding(contributionBinding), CodeBlock.of("create()")));
           }
         }
         break;
@@ -710,18 +717,16 @@ private void implementInterfaceMethods() {
           switch (interfaceRequest.kind()) {
             case MEMBERS_INJECTOR:
               List<? extends VariableElement> parameters = methodElement.getParameters();
-              if (parameters.isEmpty()) {
-                // we're returning the framework type
-                interfaceMethod.addStatement("return $L", codeBlock);
-              } else {
+              if (!parameters.isEmpty()) {
                 Name parameterName =
                     Iterables.getOnlyElement(methodElement.getParameters()).getSimpleName();
                 interfaceMethod.addStatement("$L.injectMembers($L)", codeBlock, parameterName);
                 if (!requestType.getReturnType().getKind().equals(VOID)) {
                   interfaceMethod.addStatement("return $L", parameterName);
                 }
+                break;
               }
-              break;
+              // fall through
             default:
               interfaceMethod.addStatement("return $L", codeBlock);
               break;
@@ -1104,8 +1109,11 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
       case SYNTHETIC_MULTIBOUND_MAP:
         return initializeFactoryForMapMultibinding(binding);
 
+      case SYNTHETIC_OPTIONAL_BINDING:
+        return initializeFactoryForSyntheticOptionalBinding(binding);
+
       default:
-        throw new AssertionError(binding.toString());
+        throw new AssertionError(binding);
     }
   }
 
@@ -1146,22 +1154,20 @@ private CodeBlock initializeMembersInjectorForBinding(MembersInjectionBinding bi
   private ImmutableList<CodeBlock> getDependencyArguments(Binding binding) {
     ImmutableList.Builder<CodeBlock> parameters = ImmutableList.builder();
     for (FrameworkDependency frameworkDependency : frameworkDependenciesForBinding(binding)) {
-      parameters.add(getDependencyArgument(frameworkDependency));
+      parameters.add(getDependencyArgument(frameworkDependency).getExpressionFor(name));
     }
     return parameters.build();
   }
 
-  /**
-   * The expression to use as an argument for a dependency.
-   */
-  private CodeBlock getDependencyArgument(FrameworkDependency frameworkDependency) {
+  /** Returns the member select to use as an argument for a dependency. */
+  private MemberSelect getDependencyArgument(FrameworkDependency frameworkDependency) {
     BindingKey requestedKey = frameworkDependency.bindingKey();
     ResolvedBindings resolvedBindings = graph.resolvedBindings().get(requestedKey);
     if (resolvedBindings.frameworkClass().equals(Provider.class)
         && frameworkDependency.frameworkClass().equals(Producer.class)) {
-      return producerFromProviderMemberSelects.get(requestedKey).getExpressionFor(name);
+      return producerFromProviderMemberSelects.get(requestedKey);
     } else {
-      return getMemberSelectExpression(requestedKey);
+      return getMemberSelect(requestedKey);
     }
   }
 
@@ -1204,7 +1210,7 @@ private CodeBlock initializeFactoryForSetMultibinding(ContributionBinding bindin
           potentiallyCast(
               useRawTypes,
               frameworkDependency.frameworkClass(),
-              getDependencyArgument(frameworkDependency)));
+              getDependencyArgument(frameworkDependency).getExpressionFor(name)));
     }
     builder.add("builder($L, $L)", individualProviders, setProviders);
     builder.add(builderMethodCalls.build());
@@ -1235,7 +1241,7 @@ private CodeBlock initializeFactoryForMapMultibinding(ContributionBinding bindin
           potentiallyCast(
               useRawTypes,
               frameworkDependency.frameworkClass(),
-              getDependencyArgument(frameworkDependency));
+              getDependencyArgument(frameworkDependency).getExpressionFor(name));
       if (binding.bindingType().frameworkClass().equals(Producer.class)
           && frameworkDependency.frameworkClass().equals(Provider.class)) {
         value = CodeBlock.of("$T.producerFromProvider($L)", PRODUCERS, value);
@@ -1256,6 +1262,50 @@ private CodeBlock potentiallyCast(boolean shouldCast, Class<?> classToCast, Code
     return CodeBlock.of("($T) $L", classToCast, notCasted);
   }
 
+  /** Returns an expression that initializes a {@link Provider} for an optional binding. */
+  private CodeBlock initializeFactoryForSyntheticOptionalBinding(ContributionBinding binding) {
+    if (binding.bindingType().equals(BindingType.PRODUCTION)) {
+      throw new UnsupportedOperationException("optional producers are not supported yet");
+    }
+
+    if (binding.dependencies().isEmpty()) {
+      return CodeBlock.of(
+          "$N.instance()", optionalFactoryClass(Optional.<DependencyRequest.Kind>absent()));
+    } else {
+      TypeMirror valueType = OptionalType.from(binding.key()).valueType();
+      DependencyRequest.Kind optionalValueKind =
+          DependencyRequest.extractKindAndType(valueType).kind();
+      FrameworkDependency frameworkDependency =
+          getOnlyElement(frameworkDependenciesForBinding(binding));
+      CodeBlock dependencyArgument =
+          getDependencyArgument(frameworkDependency).getExpressionFor(name);
+      return CodeBlock.of(
+          "$N.of($L)", optionalFactoryClass(Optional.of(optionalValueKind)), dependencyArgument);
+    }
+  }
+
+  /**
+   * Returns the nested class that implements {@code Provider<Optional<T>>} for optional bindings.
+   * Adds it to the root component if it hasn't already been added.
+   *
+   * <p>If {@code optionalValueKind} is absent, returns a {@link Provider} class that returns {@link
+   * Optional#absent()}.
+   *
+   * <p>If {@code optionalValueKind} is present, returns a {@link Provider} class where {@code T}
+   * represents dependency requests of that kind.
+   */
+  protected TypeSpec optionalFactoryClass(Optional<DependencyRequest.Kind> optionalValueKind) {
+    if (!optionalFactoryClasses.containsKey(optionalValueKind)) {
+      TypeSpec factory =
+          optionalValueKind.isPresent()
+              ? OptionalFactoryClasses.presentFactoryClass(optionalValueKind.get())
+              : OptionalFactoryClasses.ABSENT_FACTORY_CLASS;
+      component.addType(factory);
+      optionalFactoryClasses.put(optionalValueKind, factory);
+    }
+    return optionalFactoryClasses.get(optionalValueKind);
+  }
+
   private static String simpleVariableName(TypeElement typeElement) {
     return UPPER_CAMEL.to(LOWER_CAMEL, typeElement.getSimpleName().toString());
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index ab91f9db4..42774c387 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -23,6 +23,7 @@
 import static com.google.common.base.Predicates.in;
 import static com.google.common.base.Predicates.not;
 import static com.google.common.base.Verify.verify;
+import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.google.common.collect.Iterables.isEmpty;
 import static dagger.internal.codegen.BindingType.isOfType;
 import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor.isOfKind;
@@ -33,6 +34,7 @@
 import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ContributionBinding.Kind.IS_SYNTHETIC_MULTIBINDING_KIND;
+import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_OPTIONAL_BINDING;
 import static dagger.internal.codegen.Key.indexByKey;
 import static dagger.internal.codegen.Scope.reusableScope;
 import static javax.lang.model.element.Modifier.ABSTRACT;
@@ -41,6 +43,7 @@
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
+import com.google.common.base.Predicate;
 import com.google.common.base.VerifyException;
 import com.google.common.cache.Cache;
 import com.google.common.cache.CacheBuilder;
@@ -174,7 +177,8 @@ public ComponentDescriptor apply(BindingGraph graph) {
     private final ProvisionBinding.Factory provisionBindingFactory;
     private final ProductionBinding.Factory productionBindingFactory;
 
-    Factory(Elements elements,
+    Factory(
+        Elements elements,
         InjectBindingRegistry injectBindingRegistry,
         Key.Factory keyFactory,
         ProvisionBinding.Factory provisionBindingFactory,
@@ -194,6 +198,7 @@ private BindingGraph create(
         Optional<Resolver> parentResolver, ComponentDescriptor componentDescriptor) {
       ImmutableSet.Builder<ContributionBinding> explicitBindingsBuilder = ImmutableSet.builder();
       ImmutableSet.Builder<DelegateDeclaration> delegatesBuilder = ImmutableSet.builder();
+      ImmutableSet.Builder<OptionalBindingDeclaration> optionalsBuilder = ImmutableSet.builder();
 
       // binding for the component itself
       TypeElement componentDefinitionType = componentDescriptor.componentDefinitionType();
@@ -241,6 +246,7 @@ private BindingGraph create(
         explicitBindingsBuilder.addAll(moduleDescriptor.bindings());
         multibindingDeclarations.addAll(moduleDescriptor.multibindingDeclarations());
         delegatesBuilder.addAll(moduleDescriptor.delegateDeclarations());
+        optionalsBuilder.addAll(moduleDescriptor.optionalDeclarations());
       }
 
       Resolver requestResolver =
@@ -249,7 +255,8 @@ private BindingGraph create(
               componentDescriptor,
               indexByKey(explicitBindingsBuilder.build()),
               indexByKey(multibindingDeclarations.build()),
-              indexByKey(delegatesBuilder.build()));
+              indexByKey(delegatesBuilder.build()),
+              indexByKey(optionalsBuilder.build()));
       for (ComponentMethodDescriptor componentMethod : componentDescriptor.componentMethods()) {
         Optional<DependencyRequest> componentMethodRequest = componentMethod.dependencyRequest();
         if (componentMethodRequest.isPresent()) {
@@ -289,6 +296,7 @@ private BindingGraph create(
       final ImmutableSetMultimap<Key, ContributionBinding> explicitMultibindings;
       final ImmutableSetMultimap<Key, MultibindingDeclaration> multibindingDeclarations;
       final ImmutableSetMultimap<Key, DelegateDeclaration> delegateDeclarations;
+      final ImmutableSetMultimap<Key, OptionalBindingDeclaration> optionalBindingDeclarations;
       final ImmutableSetMultimap<Key, DelegateDeclaration> delegateMultibindingDeclarations;
       final Map<BindingKey, ResolvedBindings> resolvedBindings;
       final Deque<BindingKey> cycleStack = new ArrayDeque<>();
@@ -302,13 +310,15 @@ private BindingGraph create(
           ComponentDescriptor componentDescriptor,
           ImmutableSetMultimap<Key, ContributionBinding> explicitBindings,
           ImmutableSetMultimap<Key, MultibindingDeclaration> multibindingDeclarations,
-          ImmutableSetMultimap<Key, DelegateDeclaration> delegateDeclarations) {
+          ImmutableSetMultimap<Key, DelegateDeclaration> delegateDeclarations,
+          ImmutableSetMultimap<Key, OptionalBindingDeclaration> optionalBindingDeclarations) {
         this.parentResolver = checkNotNull(parentResolver);
         this.componentDescriptor = checkNotNull(componentDescriptor);
         this.explicitBindings = checkNotNull(explicitBindings);
         this.explicitBindingsSet = ImmutableSet.copyOf(explicitBindings.values());
         this.multibindingDeclarations = checkNotNull(multibindingDeclarations);
         this.delegateDeclarations = checkNotNull(delegateDeclarations);
+        this.optionalBindingDeclarations = checkNotNull(optionalBindingDeclarations);
         this.resolvedBindings = Maps.newLinkedHashMap();
         this.explicitMultibindings =
             multibindingContributionsByMultibindingKey(explicitBindingsSet);
@@ -352,23 +362,30 @@ ResolvedBindings lookUpBindings(BindingKey bindingKey) {
                 ImmutableSet.builder();
             ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarationsBuilder =
                 ImmutableSet.builder();
+            ImmutableSet.Builder<OptionalBindingDeclaration> optionalBindingDeclarationsBuilder =
+                ImmutableSet.builder();
 
             for (Key key : keysMatchingRequest(requestKey)) {
               contributionBindings.addAll(getExplicitBindings(key));
               multibindingContributionsBuilder.addAll(getExplicitMultibindings(key));
               multibindingDeclarationsBuilder.addAll(getMultibindingDeclarations(key));
+              optionalBindingDeclarationsBuilder.addAll(getOptionalBindingDeclarations(key));
             }
 
             ImmutableSet<ContributionBinding> multibindingContributions =
                 multibindingContributionsBuilder.build();
             ImmutableSet<MultibindingDeclaration> multibindingDeclarations =
                 multibindingDeclarationsBuilder.build();
+            ImmutableSet<OptionalBindingDeclaration> optionalBindingDeclarations =
+                optionalBindingDeclarationsBuilder.build();
 
-            contributionBindings.addAll(syntheticMapOfValuesBinding(bindingKey.key()).asSet());
+            contributionBindings.addAll(syntheticMapOfValuesBinding(requestKey).asSet());
             contributionBindings.addAll(
                 syntheticMultibinding(
-                        bindingKey.key(), multibindingContributions, multibindingDeclarations)
+                        requestKey, multibindingContributions, multibindingDeclarations)
                     .asSet());
+            contributionBindings.addAll(
+                syntheticOptionalBinding(requestKey, optionalBindingDeclarations).asSet());
 
             /* If there are no bindings, add the implicit @Inject-constructed binding if there is
              * one. */
@@ -382,7 +399,8 @@ ResolvedBindings lookUpBindings(BindingKey bindingKey) {
                 componentDescriptor,
                 indexBindingsByOwningComponent(
                     bindingKey, ImmutableSet.copyOf(contributionBindings)),
-                multibindingDeclarations);
+                multibindingDeclarations,
+                optionalBindingDeclarations);
 
           case MEMBERS_INJECTION:
             // no explicit deps for members injection, so just look it up
@@ -521,6 +539,26 @@ private boolean multibindingsRequireProduction(
         return Iterables.any(multibindingContributions, isOfType(BindingType.PRODUCTION));
       }
 
+      /**
+       * Returns a synthetic binding for {@code @Qualifier Optional<Type>} if there are any {@code
+       * optionalBindingDeclarations}.
+       */
+      private Optional<? extends ContributionBinding> syntheticOptionalBinding(
+          Key key, ImmutableSet<OptionalBindingDeclaration> optionalBindingDeclarations) {
+        if (optionalBindingDeclarations.isEmpty()) {
+          return Optional.absent();
+        }
+        ContributionBinding syntheticPresentBinding =
+            provisionBindingFactory.syntheticPresentBinding(key);
+        ResolvedBindings bindings =
+            lookUpBindings(getOnlyElement(syntheticPresentBinding.dependencies()).bindingKey());
+        if (bindings.isEmpty()) {
+          return Optional.of(provisionBindingFactory.syntheticAbsentBinding(key));
+        } else { // TODO(dpb): Support producers.
+          return Optional.of(syntheticPresentBinding);
+        }
+      }
+
       private ImmutableSet<ContributionBinding> createDelegateBindings(
           ImmutableSet<DelegateDeclaration> delegateDeclarations) {
         ImmutableSet.Builder<ContributionBinding> builder = ImmutableSet.builder();
@@ -667,17 +705,25 @@ private boolean isResolvedInParent(BindingKey bindingKey, ContributionBinding bi
        */
       private ImmutableSet<ContributionBinding> getExplicitBindings(Key requestKey) {
         ImmutableSet.Builder<ContributionBinding> bindings = ImmutableSet.builder();
-        Key delegateDeclarationKey = keyFactory.convertToDelegateKey(requestKey);
         for (Resolver resolver : getResolverLineage()) {
-          bindings
-              .addAll(resolver.explicitBindings.get(requestKey))
-              .addAll(
-                  createDelegateBindings(
-                      resolver.delegateDeclarations.get(delegateDeclarationKey)));
+          bindings.addAll(resolver.getLocalExplicitBindings(requestKey));
         }
         return bindings.build();
       }
 
+      /**
+       * Returns the explicit {@link ContributionBinding}s that match the {@code requestKey} from
+       * this resolver.
+       */
+      private ImmutableSet<ContributionBinding> getLocalExplicitBindings(Key requestKey) {
+        return new ImmutableSet.Builder<ContributionBinding>()
+            .addAll(explicitBindings.get(requestKey))
+            .addAll(
+                createDelegateBindings(
+                    delegateDeclarations.get(keyFactory.convertToDelegateKey(requestKey))))
+            .build();
+      }
+
       /**
        * Returns the explicit multibinding contributions that contribute to the map or set requested
        * by {@code requestKey} from this and all ancestor resolvers.
@@ -711,6 +757,22 @@ private boolean isResolvedInParent(BindingKey bindingKey, ContributionBinding bi
         return multibindingDeclarations.build();
       }
 
+      /**
+       * Returns the {@link OptionalBindingDeclaration}s that match the {@code key} from this and
+       * all ancestor resolvers.
+       */
+      private ImmutableSet<OptionalBindingDeclaration> getOptionalBindingDeclarations(Key key) {
+        Optional<Key> unwrapped = keyFactory.unwrapOptional(key);
+        if (!unwrapped.isPresent()) {
+          return ImmutableSet.of();
+        }
+        ImmutableSet.Builder<OptionalBindingDeclaration> declarations = ImmutableSet.builder();
+        for (Resolver resolver : getResolverLineage()) {
+          declarations.addAll(resolver.optionalBindingDeclarations.get(unwrapped.get()));
+        }
+        return declarations.build();
+      }
+
       private Optional<ResolvedBindings> getPreviouslyResolvedBindings(
           final BindingKey bindingKey) {
         Optional<ResolvedBindings> result = Optional.fromNullable(resolvedBindings.get(bindingKey));
@@ -743,13 +805,18 @@ void resolve(BindingKey bindingKey) {
          *
          * 2. If there are any explicit bindings in this component, they may conflict with those in
          *    the supercomponent, so resolve them here so that conflicts can be caught.
+         *
+         * 3. If the previously resolved binding is an optional binding, and there are any explicit
+         *    bindings for the underlying key in this component, resolve here so that absent
+         *    bindings in the parent can be overridden by present bindings here.
          */
         if (getPreviouslyResolvedBindings(bindingKey).isPresent()) {
           /* Resolve in the parent in case there are multibinding contributions or conflicts in some
            * component between this one and the previously-resolved one. */
           parentResolver.get().resolve(bindingKey);
           if (!new MultibindingDependencies().dependsOnLocalMultibindings(bindingKey)
-              && getExplicitBindings(bindingKey.key()).isEmpty()) {
+              && getLocalExplicitBindings(bindingKey.key()).isEmpty()
+              && !hasLocallyPresentOptionalBinding(bindingKey)) {
             /* Cache the inherited parent component's bindings in case resolving at the parent found
              * bindings in some component between this one and the previously-resolved one. */
             ResolvedBindings inheritedBindings =
@@ -805,6 +872,23 @@ void resolve(BindingKey bindingKey) {
             .immutableCopy();
       }
 
+      /**
+       * Returns {@code true} if {@code bindingKey} was previously resolved to an optional binding
+       * for which there is an explicit present binding in this component.
+       */
+      private boolean hasLocallyPresentOptionalBinding(BindingKey bindingKey) {
+        return Iterables.any(
+            getPreviouslyResolvedBindings(bindingKey).get().contributionBindings(),
+            new Predicate<ContributionBinding>() {
+              @Override
+              public boolean apply(ContributionBinding binding) {
+                return binding.bindingKind().equals(SYNTHETIC_OPTIONAL_BINDING)
+                    && !getLocalExplicitBindings(keyFactory.unwrapOptional(binding.key()).get())
+                        .isEmpty();
+              }
+            });
+      }
+
       private final class MultibindingDependencies {
         private final Set<Object> cycleChecker = new HashSet<>();
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index df91437de..501abccde 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -37,12 +37,14 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_MAP;
+import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_OPTIONAL_BINDING;
 import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByAnnotationType;
 import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByMapKey;
 import static dagger.internal.codegen.ContributionType.indexByContributionType;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_INJECT_WILDCARD_TYPE;
 import static dagger.internal.codegen.ErrorMessages.CONTAINS_DEPENDENCY_CYCLE_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.DEPENDS_ON_PRODUCTION_EXECUTOR_FORMAT;
+import static dagger.internal.codegen.ErrorMessages.DOUBLE_INDENT;
 import static dagger.internal.codegen.ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.DUPLICATE_SIZE_LIMIT;
 import static dagger.internal.codegen.ErrorMessages.INDENT;
@@ -197,25 +199,30 @@ boolean hasCycle() {
 
     /**
      * If there is a cycle, the segment of the path that represents the cycle. The first request's
-     * and the last request's binding keys are equal. The last request is the
-     * {@linkplain #currentDependencyRequest() current request}.
+     * and the last request's binding keys are equal. The last request is the {@linkplain
+     * #currentDependencyRequest() current request}.
      *
      * @throws IllegalStateException if {@link #hasCycle()} is {@code false}
      */
-    ImmutableList<ResolvedRequest> cycle() {
+    FluentIterable<ResolvedRequest> cycle() {
       checkState(hasCycle(), "no cycle");
-      return FluentIterable.from(path)
-          .skip(indexOf(keyPath, Predicates.equalTo(currentDependencyRequest().bindingKey())))
-          .toList();
+      return resolvedRequests()
+          .skip(indexOf(keyPath, Predicates.equalTo(currentDependencyRequest().bindingKey())));
     }
 
     /**
      * Makes {@code request} the current request. Be sure to call {@link #pop()} to back up to the
      * previous request in the path.
      */
-    void push(ResolvedRequest request) {
-      path.addLast(request);
-      keyPath.add(request.dependencyRequest().bindingKey());
+    void push(DependencyRequest request, ResolvedBindings resolvedBindings) {
+      path.add(
+          ResolvedRequest.create(
+              request,
+              resolvedBindings,
+              path.isEmpty()
+                  ? Optional.<ResolvedBindings>absent()
+                  : Optional.of(currentResolvedBindings())));
+      keyPath.add(request.bindingKey());
     }
 
     /** Makes the previous request the current request. */
@@ -235,9 +242,9 @@ int size() {
       return path.size();
     }
 
-    /** The dependency requests in this path, starting with the entry point. */
-    FluentIterable<DependencyRequest> dependencyRequests() {
-      return FluentIterable.from(path).transform(ResolvedRequest.DEPENDENCY_REQUEST);
+    /** Returns the resolved dependency requests in this path, starting with the entry point. */
+    FluentIterable<ResolvedRequest> resolvedRequests() {
+      return FluentIterable.from(path);
     }
   }
 
@@ -335,7 +342,7 @@ public boolean apply(TypeElement moduleType) {
      * @param request the current dependency request
      */
     private void traverseDependencyRequest(DependencyRequest request, DependencyPath path) {
-      path.push(ResolvedRequest.create(request, subject));
+      path.push(request, resolvedBindings(request));
       try {
         if (path.hasCycle()) {
           reportCycle(path);
@@ -360,6 +367,14 @@ private void traverseDependencyRequest(DependencyRequest request, DependencyPath
       }
     }
 
+    private ResolvedBindings resolvedBindings(DependencyRequest request) {
+      BindingKey bindingKey = request.bindingKey();
+      ResolvedBindings resolvedBindings = subject.resolvedBindings().get(bindingKey);
+      return resolvedBindings == null
+          ? ResolvedBindings.noBindings(bindingKey, subject.componentDescriptor())
+          : resolvedBindings;
+    }
+
     private Validation validationForComponent(ComponentDescriptor component) {
       if (component.equals(subject.componentDescriptor())) {
         return this;
@@ -481,12 +496,15 @@ private ResolvedBindings inlineContributionsWithoutBindingElements(
           ImmutableSetMultimap.builder();
       ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarations =
           ImmutableSet.builder();
+      ImmutableSet.Builder<OptionalBindingDeclaration> optionalBindingDeclarations =
+          ImmutableSet.builder();
 
       Queue<ResolvedBindings> queue = new ArrayDeque<>();
       queue.add(resolvedBinding);
 
       for (ResolvedBindings queued = queue.poll(); queued != null; queued = queue.poll()) {
         multibindingDeclarations.addAll(queued.multibindingDeclarations());
+        optionalBindingDeclarations.addAll(queued.optionalBindingDeclarations());
         for (Map.Entry<ComponentDescriptor, ContributionBinding> bindingEntry :
             queued.allContributionBindings().entries()) {
           BindingGraph owningGraph = validationForComponent(bindingEntry.getKey()).subject;
@@ -504,7 +522,8 @@ private ResolvedBindings inlineContributionsWithoutBindingElements(
           resolvedBinding.bindingKey(),
           resolvedBinding.owningComponent(),
           contributions.build(),
-          multibindingDeclarations.build());
+          multibindingDeclarations.build(),
+          optionalBindingDeclarations.build());
     }
 
     private ImmutableListMultimap<ContributionType, BindingDeclaration> declarationsByType(
@@ -964,14 +983,31 @@ private void reportProviderMayNotDependOnProducer(DependencyPath path) {
                 PROVIDER_ENTRY_POINT_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
                 formatCurrentDependencyRequestKey(path));
       } else {
-        ImmutableSet<? extends Binding> dependentProvisions =
+        FluentIterable<ContributionBinding> dependentProvisions =
             provisionsDependingOnLatestRequest(path);
-        // TODO(beder): Consider displaying all dependent provisions in the error message. If we do
-        // that, should we display all productions that depend on them also?
-        new Formatter(errorMessage)
-            .format(
-                PROVIDER_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
-                dependentProvisions.iterator().next().key());
+        if (dependentProvisions
+            .transform(ContributionBinding.KIND)
+            .contains(SYNTHETIC_OPTIONAL_BINDING)) {
+          // TODO(dpb): Implement @BindsOptionalOf for producers.
+          errorMessage
+              .append("Using optional bindings with @Produces bindings is not yet supported.\n")
+              .append(INDENT)
+              .append(formatCurrentDependencyRequestKey(path))
+              .append(" is produced at\n")
+              .append(DOUBLE_INDENT)
+              .append(
+                  bindingDeclarationFormatter.format(
+                      path.currentResolvedBindings().contributionBinding()))
+              .append('\n')
+              .append(dependencyRequestFormatter.toDependencyTrace(path));
+        } else {
+          // TODO(beder): Consider displaying all dependent provisions in the error message. If we
+          // do that, should we display all productions that depend on them also?
+          new Formatter(errorMessage)
+              .format(
+                  PROVIDER_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
+                  dependentProvisions.iterator().next().key());
+        }
       }
       reportBuilder.addError(errorMessage.toString(), path.entryPointElement());
     }
@@ -1149,7 +1185,7 @@ private void reportInconsistentMapKeyAnnotations(
     }
 
     private void reportCycle(DependencyPath path) {
-      if (!providersBreakingCycle(path.cycle()).isEmpty()) {
+      if (!providersBreakingCycle(path).isEmpty()) {
         return;
       }
       // TODO(cgruber): Provide a hint for the start and end of the cycle.
@@ -1166,40 +1202,62 @@ private void reportCycle(DependencyPath path) {
     }
 
     /**
-     * Returns any steps in a dependency cycle that "break" the cycle. These are any
-     * {@link Provider}, {@link Lazy}, or {@code Map<K, Provider<V>>} requests after the first
-     * request in the cycle.
+     * Returns any steps in a dependency cycle that "break" the cycle. These are any {@link
+     * Provider}, {@link Lazy}, or {@code Map<K, Provider<V>>} requests after the first request in
+     * the cycle.
      *
      * <p>If an implicit {@link Provider} dependency on {@code Map<K, Provider<V>>} is immediately
      * preceded by a dependency on {@code Map<K, V>}, which means that the map's {@link Provider}s'
      * {@link Provider#get() get()} methods are called during provision and so the cycle is not
      * really broken.
+     *
+     * <p>A request for an instance of {@code Optional} breaks the cycle if a request for the {@code
+     * Optional}'s type parameter would.
      */
-    private ImmutableSet<DependencyRequest> providersBreakingCycle(
-        ImmutableList<ResolvedRequest> cycle) {
-      return FluentIterable.from(cycle)
+    private ImmutableSet<DependencyRequest> providersBreakingCycle(DependencyPath path) {
+      return path.cycle()
           .skip(1)
-          .transform(ResolvedRequest.DEPENDENCY_REQUEST)
-          .filter(DependencyRequest.HAS_REQUEST_ELEMENT)
           .filter(
-              new Predicate<DependencyRequest>() {
+              new Predicate<ResolvedRequest>() {
                 @Override
-                public boolean apply(DependencyRequest dependencyRequest) {
-                  switch (dependencyRequest.kind()) {
+                public boolean apply(ResolvedRequest resolvedRequest) {
+                  DependencyRequest dependencyRequest = resolvedRequest.dependencyRequest();
+                  if (dependencyRequest.requestElement().isPresent()) {
+                    // Non-synthetic request
+                    return breaksCycle(dependencyRequest.key().type(), dependencyRequest.kind());
+                  } else if (!resolvedRequest.dependentOptionalBindingDeclarations().isEmpty()) {
+                    // Synthetic request from a @BindsOptionalOf: test the type inside the Optional.
+                    // Optional<Provider or Lazy or Provider of Lazy> breaks the cycle.
+                    TypeMirror requestedOptionalType =
+                        resolvedRequest.dependentBindings().get().key().type();
+                    DependencyRequest.KindAndType kindAndType =
+                        DependencyRequest.extractKindAndType(
+                            OptionalType.from(requestedOptionalType).valueType());
+                    return breaksCycle(kindAndType.type(), kindAndType.kind());
+                  } else {
+                    // Other synthetic requests.
+                    return false;
+                  }
+                }
+
+                private boolean breaksCycle(
+                    TypeMirror requestedType, DependencyRequest.Kind requestKind) {
+                  switch (requestKind) {
                     case PROVIDER:
                     case LAZY:
                     case PROVIDER_OF_LAZY:
                       return true;
 
                     case INSTANCE:
-                      return MapType.isMap(dependencyRequest.key())
-                          && MapType.from(dependencyRequest.key()).valuesAreTypeOf(Provider.class);
+                      return MapType.isMap(requestedType)
+                          && MapType.from(requestedType).valuesAreTypeOf(Provider.class);
 
                     default:
                       return false;
                   }
                 }
               })
+          .transform(ResolvedRequest.DEPENDENCY_REQUEST)
           .toSet();
     }
   }
@@ -1266,7 +1324,7 @@ private boolean doesPathRequireProvisionOnly(DependencyPath path) {
    * Returns any provision bindings resolved for the second-most-recent request in the given path;
    * that is, returns those provision bindings that depend on the latest request in the path.
    */
-  private ImmutableSet<? extends Binding> provisionsDependingOnLatestRequest(
+  private FluentIterable<ContributionBinding> provisionsDependingOnLatestRequest(
       final DependencyPath path) {
     return FluentIterable.from(path.previousResolvedBindings().bindings())
         .filter(BindingType.isOfType(BindingType.PROVISION))
@@ -1277,7 +1335,7 @@ public boolean apply(Binding binding) {
                 return binding.implicitDependencies().contains(path.currentDependencyRequest());
               }
             })
-        .toSet();
+        .filter(ContributionBinding.class);
   }
 
   private String formatContributionType(ContributionType type) {
@@ -1304,15 +1362,36 @@ private String formatCurrentDependencyRequestKey(DependencyPath path) {
     abstract DependencyRequest dependencyRequest();
 
     abstract ResolvedBindings resolvedBindings();
+    
+    /**
+     * The {@link #resolvedBindings()} of the previous entry in the {@link DependencyPath}. One of
+     * these bindings depends directly on {@link #dependencyRequest()}.
+     */
+    abstract Optional<ResolvedBindings> dependentBindings();
 
-    static ResolvedRequest create(DependencyRequest request, BindingGraph graph) {
-      BindingKey bindingKey = request.bindingKey();
-      ResolvedBindings resolvedBindings = graph.resolvedBindings().get(bindingKey);
+    /**
+     * If the binding that depends on {@link #dependencyRequest()} is a synthetic optional binding,
+     * returns its {@code @BindsOptionalOf} methods.
+     */
+    ImmutableSet<OptionalBindingDeclaration> dependentOptionalBindingDeclarations() {
+      if (dependentBindings().isPresent()) {
+        ResolvedBindings dependentBindings = dependentBindings().get();
+        for (ContributionBinding dependentBinding : dependentBindings.contributionBindings()) {
+          if (dependentBinding.bindingKind().equals(SYNTHETIC_OPTIONAL_BINDING)
+              && dependentBinding.dependencies().contains(dependencyRequest())) {
+            return dependentBindings.optionalBindingDeclarations();
+          }
+        }
+      }
+      return ImmutableSet.<OptionalBindingDeclaration>of();
+    }
+
+    private static ResolvedRequest create(
+        DependencyRequest request,
+        ResolvedBindings resolvedBindings,
+        Optional<ResolvedBindings> dependentBindings) {
       return new AutoValue_BindingGraphValidator_ResolvedRequest(
-          request,
-          resolvedBindings == null
-              ? ResolvedBindings.noBindings(bindingKey, graph.componentDescriptor())
-              : resolvedBindings);
+          request, resolvedBindings, dependentBindings);
     }
 
     static final Function<ResolvedRequest, DependencyRequest> DEPENDENCY_REQUEST =
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java
index 6026e6ed1..446262f68 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java
@@ -62,6 +62,7 @@
 import java.lang.annotation.Annotation;
 import javax.annotation.OverridingMethodsMustInvokeSuper;
 import javax.annotation.processing.Messager;
+import javax.inject.Qualifier;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.type.TypeKind;
@@ -75,7 +76,7 @@
   private final Elements elements;
   private final Types types;
   private final Class<? extends Annotation> methodAnnotation;
-  private final ImmutableSet<Class<? extends Annotation>> enclosingElementAnnotations;
+  private final ImmutableSet<? extends Class<? extends Annotation>> enclosingElementAnnotations;
   private final Abstractness abstractness;
   private final ExceptionSuperclass exceptionSuperclass;
   private final LoadingCache<ExecutableElement, ValidationReport<ExecutableElement>> cache =
@@ -90,6 +91,7 @@
                   return builder.build();
                 }
               });
+  private final AllowsMultibindings allowsMultibindings;
 
   /**
    * Creates a validator object.
@@ -104,14 +106,16 @@ protected BindingMethodValidator(
       Class<? extends Annotation> methodAnnotation,
       Class<? extends Annotation> enclosingElementAnnotation,
       Abstractness abstractness,
-      ExceptionSuperclass exceptionSuperclass) {
+      ExceptionSuperclass exceptionSuperclass,
+      AllowsMultibindings allowsMultibindings) {
     this(
         elements,
         types,
         methodAnnotation,
         ImmutableSet.of(enclosingElementAnnotation),
         abstractness,
-        exceptionSuperclass);
+        exceptionSuperclass,
+        allowsMultibindings);
   }
 
   /**
@@ -127,14 +131,15 @@ protected BindingMethodValidator(
       Class<? extends Annotation> methodAnnotation,
       Iterable<? extends Class<? extends Annotation>> enclosingElementAnnotations,
       Abstractness abstractness,
-      ExceptionSuperclass exceptionSuperclass) {
+      ExceptionSuperclass exceptionSuperclass,
+      AllowsMultibindings allowsMultibindings) {
     this.elements = elements;
     this.types = types;
     this.methodAnnotation = methodAnnotation;
-    this.enclosingElementAnnotations =
-        ImmutableSet.<Class<? extends Annotation>>copyOf(enclosingElementAnnotations);
+    this.enclosingElementAnnotations = ImmutableSet.copyOf(enclosingElementAnnotations);
     this.abstractness = abstractness;
     this.exceptionSuperclass = exceptionSuperclass;
+    this.allowsMultibindings = allowsMultibindings;
   }
   
   /** The annotation that identifies methods validated by this object. */
@@ -337,6 +342,9 @@ protected void checkQualifiers(ValidationReport.Builder<ExecutableElement> build
    * {@code MAP} has any.
    */
   protected void checkMapKeys(ValidationReport.Builder<ExecutableElement> builder) {
+    if (!allowsMultibindings.allowsMultibindings()) {
+      return;
+    }
     ImmutableSet<? extends AnnotationMirror> mapKeys = getMapKeys(builder.getSubject());
     if (ContributionType.fromBindingMethod(builder.getSubject()).equals(ContributionType.MAP)) {
       switch (mapKeys.size()) {
@@ -360,6 +368,9 @@ protected void checkMapKeys(ValidationReport.Builder<ExecutableElement> builder)
    * annotation has a {@code type} parameter.
    */
   protected void checkMultibindings(ValidationReport.Builder<ExecutableElement> builder) {
+    if (!allowsMultibindings.allowsMultibindings()) {
+      return;
+    }
     ImmutableSet<AnnotationMirror> multibindingAnnotations =
         MultibindingAnnotations.forMethod(builder.getSubject());
     if (multibindingAnnotations.size() > 1) {
@@ -473,4 +484,22 @@ protected void checkThrows(
       }
     }
   }
+
+  /** Whether to check multibinding annotations. */
+  protected enum AllowsMultibindings {
+    /**
+     * This method disallows multibinding annotations, so don't bother checking for their validity.
+     * {@link MultibindingAnnotationsProcessingStep} will add errors if the method has any
+     * multibinding annotations.
+     */
+    NO_MULTIBINDINGS,
+
+    /** This method allows multibinding annotations, so validate them. */
+    ALLOWS_MULTIBINDINGS,
+    ;
+
+    private boolean allowsMultibindings() {
+      return this == ALLOWS_MULTIBINDINGS;
+    }
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java
index 73e5d8f8e..3108e8a25 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java
@@ -18,6 +18,7 @@
 
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_ABSTRACT;
+import static dagger.internal.codegen.BindingMethodValidator.AllowsMultibindings.ALLOWS_MULTIBINDINGS;
 import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.RUNTIME_EXCEPTION;
 import static dagger.internal.codegen.ErrorMessages.BINDS_ELEMENTS_INTO_SET_METHOD_RETURN_SET;
 import static dagger.internal.codegen.ErrorMessages.BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER;
@@ -55,7 +56,8 @@
         Binds.class,
         ImmutableSet.of(Module.class, ProducerModule.class),
         MUST_BE_ABSTRACT,
-        RUNTIME_EXCEPTION);
+        RUNTIME_EXCEPTION,
+        ALLOWS_MULTIBINDINGS);
     this.types = types;
     this.elements = elements;
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java
new file mode 100644
index 000000000..e00ee9974
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_ABSTRACT;
+import static dagger.internal.codegen.BindingMethodValidator.AllowsMultibindings.NO_MULTIBINDINGS;
+import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.NO_EXCEPTIONS;
+import static dagger.internal.codegen.ErrorMessages.BINDS_OPTIONAL_OF_METHOD_HAS_PARAMETER;
+import static dagger.internal.codegen.ErrorMessages.BINDS_OPTIONAL_OF_METHOD_RETURNS_IMPLICITLY_PROVIDED_TYPE;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
+import static dagger.internal.codegen.InjectionAnnotations.injectedConstructors;
+import static dagger.internal.codegen.Key.isValidImplicitProvisionKey;
+
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableSet;
+import dagger.BindsOptionalOf;
+import dagger.Module;
+import dagger.producers.ProducerModule;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+/** A validator for {@link BindsOptionalOf} methods. */
+final class BindsOptionalOfMethodValidator extends BindingMethodValidator {
+
+  private final Types types;
+
+  BindsOptionalOfMethodValidator(Elements elements, Types types) {
+    super(
+        elements,
+        types,
+        BindsOptionalOf.class,
+        ImmutableSet.of(Module.class, ProducerModule.class),
+        MUST_BE_ABSTRACT,
+        NO_EXCEPTIONS,
+        NO_MULTIBINDINGS);
+    this.types = types;
+  }
+
+  @Override
+  protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder) {
+    super.checkMethod(builder);
+    checkParameters(builder);
+  }
+
+  @Override
+  protected void checkKeyType(
+      ValidationReport.Builder<ExecutableElement> builder, TypeMirror keyType) {
+    super.checkKeyType(builder, keyType);
+    if (isValidImplicitProvisionKey(
+            FluentIterable.from(getQualifiers(builder.getSubject())).first(), keyType, types)
+        && !injectedConstructors(MoreElements.asType(MoreTypes.asDeclared(keyType).asElement()))
+            .isEmpty()) {
+      builder.addError(BINDS_OPTIONAL_OF_METHOD_RETURNS_IMPLICITLY_PROVIDED_TYPE);
+    }
+  }
+
+  private void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
+    if (!builder.getSubject().getParameters().isEmpty()) {
+      builder.addError(BINDS_OPTIONAL_OF_METHOD_HAS_PARAMETER);
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index b61872b66..8d85797a4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -90,6 +90,8 @@ public SourceVersion getSupportedSourceVersion() {
         new MultibindsMethodValidator(elements, types);
     MultibindingsMethodValidator multibindingsMethodValidator =
         new MultibindingsMethodValidator(elements, types);
+    BindsOptionalOfMethodValidator bindsOptionalOfMethodValidator =
+        new BindsOptionalOfMethodValidator(elements, types);
 
     Key.Factory keyFactory = new Key.Factory(types, elements);
 
@@ -128,6 +130,8 @@ public SourceVersion getSupportedSourceVersion() {
 
     DelegateDeclaration.Factory bindingDelegateDeclarationFactory =
         new DelegateDeclaration.Factory(types, keyFactory, dependencyRequestFactory);
+    OptionalBindingDeclaration.Factory optionalBindingDeclarationFactory =
+        new OptionalBindingDeclaration.Factory(keyFactory);
 
     this.injectBindingRegistry =
         new InjectBindingRegistry(
@@ -145,7 +149,8 @@ public SourceVersion getSupportedSourceVersion() {
             provisionBindingFactory,
             productionBindingFactory,
             multibindingDeclarationFactory,
-            bindingDelegateDeclarationFactory);
+            bindingDelegateDeclarationFactory,
+            optionalBindingDeclarationFactory);
 
     ComponentDescriptor.Factory componentDescriptorFactory = new ComponentDescriptor.Factory(
         elements, types, dependencyRequestFactory, moduleDescriptorFactory);
@@ -191,7 +196,8 @@ public SourceVersion getSupportedSourceVersion() {
             factoryGenerator,
             providesMethodValidator,
             bindsMethodValidator,
-            multibindsMethodValidator),
+            multibindsMethodValidator,
+            bindsOptionalOfMethodValidator),
         new ComponentProcessingStep(
             ComponentDescriptor.Kind.COMPONENT,
             messager,
@@ -213,7 +219,8 @@ public SourceVersion getSupportedSourceVersion() {
             producerFactoryGenerator,
             producesMethodValidator,
             bindsMethodValidator,
-            multibindsMethodValidator),
+            multibindsMethodValidator,
+            bindsOptionalOfMethodValidator),
         new ComponentProcessingStep(
             ComponentDescriptor.Kind.PRODUCTION_COMPONENT,
             messager,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index 56bc049d7..88436bbc5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -109,6 +109,13 @@ public Kind apply(ContributionBinding binding) {
      */
     SYNTHETIC_DELEGATE_BINDING,
 
+    /**
+     * A synthetic binding for {@code Optional} of a type or a {@link javax.inject.Provider}, {@link
+     * dagger.Lazy}, or {@code Provider} of {@code Lazy} of a type. Generated by a {@link
+     * dagger.BindsOptionalOf} declaration.
+     */
+    SYNTHETIC_OPTIONAL_BINDING,
+
     // Provision kinds
 
     /** An {@link Inject}-annotated constructor. */
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index 9a50c3ccc..f4d1d9f91 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -23,12 +23,12 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.ConfigurationAnnotations.getNullableType;
 
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
-import com.google.common.base.Predicate;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.util.concurrent.ListenableFuture;
@@ -36,7 +36,6 @@
 import dagger.Lazy;
 import dagger.MembersInjector;
 import dagger.Provides;
-import dagger.internal.codegen.DependencyRequest.Factory.KindAndType;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import java.util.List;
@@ -125,11 +124,9 @@
       return Optional.<KindAndType>absent();
     }
 
-    /**
-     * Returns a {@link KindAndType} with this kind and {@code type} type.
-     */
+    /** Returns a {@link KindAndType} with this kind and {@code type} type. */
     KindAndType ofType(TypeMirror type) {
-      return new AutoValue_DependencyRequest_Factory_KindAndType(this, type);
+      return new AutoValue_DependencyRequest_KindAndType(this, type);
     }
   }
 
@@ -165,19 +162,75 @@ BindingKey bindingKey() {
    */
   abstract Optional<String> overriddenVariableName();
 
-  /** A predicate that passes for requests with elements. */
-  static final Predicate<DependencyRequest> HAS_REQUEST_ELEMENT =
-      new Predicate<DependencyRequest>() {
-        @Override
-        public boolean apply(DependencyRequest request) {
-          return request.requestElement().isPresent();
-        }
-      };
-
   private static DependencyRequest.Builder builder() {
     return new AutoValue_DependencyRequest.Builder().isNullable(false);
   }
 
+  /**
+   * Extracts the dependency request type and kind from the type of a dependency request element.
+   * For example, if a user requests {@code Provider<Foo>}, this will return ({@link Kind#PROVIDER},
+   * {@code Foo}).
+   *
+   * @throws TypeNotPresentException if {@code type}'s kind is {@link TypeKind#ERROR}, which may
+   *     mean that the type will be generated in a later round of processing
+   */
+  static KindAndType extractKindAndType(TypeMirror type) {
+    return type.accept(
+        new SimpleTypeVisitor7<KindAndType, Void>() {
+          @Override
+          public KindAndType visitError(ErrorType errorType, Void p) {
+            throw new TypeNotPresentException(errorType.toString(), null);
+          }
+
+          @Override
+          public KindAndType visitExecutable(ExecutableType executableType, Void p) {
+            return executableType.getReturnType().accept(this, null);
+          }
+
+          @Override
+          public KindAndType visitDeclared(DeclaredType declaredType, Void p) {
+            return KindAndType.from(declaredType).or(defaultAction(declaredType, p));
+          }
+
+          @Override
+          protected KindAndType defaultAction(TypeMirror otherType, Void p) {
+            return Kind.INSTANCE.ofType(otherType);
+          }
+        },
+        null);
+  }
+
+  @AutoValue
+  abstract static class KindAndType {
+    abstract Kind kind();
+
+    abstract TypeMirror type();
+
+    static Optional<KindAndType> from(TypeMirror type) {
+      for (Kind kind : Kind.values()) {
+        Optional<KindAndType> kindAndType = kind.from(type);
+        if (kindAndType.isPresent()) {
+          return kindAndType.get().maybeProviderOfLazy().or(kindAndType);
+        }
+      }
+      return Optional.absent();
+    }
+
+    /**
+     * If {@code kindAndType} represents a {@link Kind#PROVIDER} of a {@code Lazy<T>} for some type
+     * {@code T}, then this method returns ({@link Kind#PROVIDER_OF_LAZY}, {@code T}).
+     */
+    private Optional<KindAndType> maybeProviderOfLazy() {
+      if (kind().equals(Kind.PROVIDER)) {
+        Optional<KindAndType> providedKindAndType = from(type());
+        if (providedKindAndType.isPresent() && providedKindAndType.get().kind().equals(Kind.LAZY)) {
+          return Optional.of(Kind.PROVIDER_OF_LAZY.ofType(providedKindAndType.get().type()));
+        }
+      }
+      return Optional.absent();
+    }
+  }
+
   @CanIgnoreReturnValue
   @AutoValue.Builder
   abstract static class Builder {
@@ -380,6 +433,23 @@ DependencyRequest forProductionComponentMonitor() {
           .build();
     }
 
+    /**
+     * Returns a synthetic request for the present value of an optional binding generated from a
+     * {@link dagger.BindsOptionalOf} declaration.
+     */
+    DependencyRequest forSyntheticPresentOptionalBinding(Key requestKey, Kind kind) {
+      Optional<Key> key = keyFactory.unwrapOptional(requestKey);
+      checkArgument(key.isPresent(), "not a request for optional: %s", requestKey);
+      return builder()
+          .kind(kind)
+          .key(key.get())
+          .isNullable(
+              allowsNull(
+                  extractKindAndType(OptionalType.from(requestKey).valueType()).kind(),
+                  Optional.<DeclaredType>absent()))
+          .build();
+    }
+
     private DependencyRequest newDependencyRequest(
         Element requestElement,
         TypeMirror type,
@@ -389,83 +459,24 @@ private DependencyRequest newDependencyRequest(
       if (kindAndType.kind().equals(Kind.MEMBERS_INJECTOR)) {
         checkArgument(!qualifier.isPresent());
       }
-      // Only instance types can be non-null -- all other requests are wrapped
-      // inside something (e.g, Provider, Lazy, etc..).
-      // TODO(sameb): should Produced/Producer always require non-nullable?
-      boolean allowsNull = !kindAndType.kind().equals(Kind.INSTANCE)
-          || ConfigurationAnnotations.getNullableType(requestElement).isPresent();
       return DependencyRequest.builder()
           .kind(kindAndType.kind())
           .key(keyFactory.forQualifiedType(qualifier, kindAndType.type()))
           .requestElement(requestElement)
-          .isNullable(allowsNull)
+          .isNullable(allowsNull(kindAndType.kind(), getNullableType(requestElement)))
           .overriddenVariableName(name)
           .build();
     }
 
-    @AutoValue
-    abstract static class KindAndType {
-      abstract Kind kind();
-      abstract TypeMirror type();
-
-      static Optional<KindAndType> from(TypeMirror type) {
-        for (Kind kind : Kind.values()) {
-          Optional<KindAndType> kindAndType = kind.from(type);
-          if (kindAndType.isPresent()) {
-            return kindAndType.get().maybeProviderOfLazy().or(kindAndType);
-          }
-        }
-        return Optional.absent();
-      }
-
-      /**
-       * If {@code kindAndType} represents a {@link Kind#PROVIDER} of a {@code Lazy<T>} for some
-       * type {@code T}, then this method returns ({@link Kind#PROVIDER_OF_LAZY}, {@code T}).
-       */
-      private Optional<KindAndType> maybeProviderOfLazy() {
-        if (kind().equals(Kind.PROVIDER)) {
-          Optional<KindAndType> providedKindAndType = from(type());
-          if (providedKindAndType.isPresent()
-              && providedKindAndType.get().kind().equals(Kind.LAZY)) {
-            return Optional.of(Kind.PROVIDER_OF_LAZY.ofType(providedKindAndType.get().type()));
-          }
-        }
-        return Optional.absent();
-      }
-    }
-
     /**
-     * Extracts the dependency request type and kind from the type of a dependency request element.
-     * For example, if a user requests {@code Provider<Foo>}, this will return
-     * ({@link Kind#PROVIDER}, {@code Foo}).
-     *
-     * @throws TypeNotPresentException if {@code type}'s kind is {@link TypeKind#ERROR}, which may
-     *     mean that the type will be generated in a later round of processing
+     * Returns {@code true} if a given request element allows null values. {@link Kind#INSTANCE}
+     * requests must be annotated with {@code @Nullable} in order to allow null values. All other
+     * request kinds implicitly allow null values because they are are wrapped inside {@link
+     * Provider}, {@link Lazy}, etc.
      */
-    static KindAndType extractKindAndType(TypeMirror type) {
-      return type.accept(
-          new SimpleTypeVisitor7<KindAndType, Void>() {
-            @Override
-            public KindAndType visitError(ErrorType errorType, Void p) {
-              throw new TypeNotPresentException(errorType.toString(), null);
-            }
-
-            @Override
-            public KindAndType visitExecutable(ExecutableType executableType, Void p) {
-              return executableType.getReturnType().accept(this, null);
-            }
-
-            @Override
-            public KindAndType visitDeclared(DeclaredType declaredType, Void p) {
-              return KindAndType.from(declaredType).or(defaultAction(declaredType, p));
-            }
-
-            @Override
-            protected KindAndType defaultAction(TypeMirror otherType, Void p) {
-              return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.INSTANCE, otherType);
-            }
-          },
-          null);
+    // TODO(sameb): should Produced/Producer always require non-nullable?
+    private boolean allowsNull(Kind kind, Optional<DeclaredType> nullableType) {
+      return kind.equals(Kind.INSTANCE) ? nullableType.isPresent() : true;
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
index 5d5c6a544..990b52931 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
@@ -17,22 +17,30 @@
 package dagger.internal.codegen;
 
 import static com.google.auto.common.MoreElements.asExecutable;
+import static dagger.internal.codegen.ErrorMessages.DOUBLE_INDENT;
 import static dagger.internal.codegen.ErrorMessages.INDENT;
 
 import com.google.auto.common.MoreElements;
+import com.google.common.base.Function;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
 import com.google.common.base.Predicates;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.util.concurrent.ListenableFuture;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import dagger.Lazy;
 import dagger.Provides;
 import dagger.internal.codegen.BindingGraphValidator.DependencyPath;
+import dagger.internal.codegen.BindingGraphValidator.ResolvedRequest;
 import dagger.producers.Produces;
 import javax.inject.Inject;
+import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementKindVisitor7;
 import javax.lang.model.util.Elements;
@@ -79,9 +87,18 @@ String toDependencyTrace(DependencyPath dependencyPath) {
     return Joiner.on('\n')
         .join(
             dependencyPath
-                .dependencyRequests()
-                .filter(DependencyRequest.HAS_REQUEST_ELEMENT)
-                .transform(this)
+                .resolvedRequests()
+                .transform(
+                    new Function<ResolvedRequest, String>() {
+                      @Override
+                      public String apply(ResolvedRequest resolvedRequest) {
+                        ImmutableSet<OptionalBindingDeclaration> optionalBindingDeclarations =
+                            resolvedRequest.dependentOptionalBindingDeclarations();
+                        return optionalBindingDeclarations.isEmpty()
+                            ? format(resolvedRequest.dependencyRequest())
+                            : formatSyntheticOptionalBindingDependency(optionalBindingDeclarations);
+                      }
+                    })
                 .filter(Predicates.not(Predicates.equalTo("")))
                 .toList()
                 .reverse());
@@ -91,6 +108,9 @@ String toDependencyTrace(DependencyPath dependencyPath) {
   // TODO(cgruber): consider returning a small structure containing strings to be indented later.
   @Override
   public String format(DependencyRequest request) {
+    if (!request.requestElement().isPresent()) {
+      return "";
+    }
     return request
         .requestElement()
         .get()
@@ -101,12 +121,14 @@ public String format(DependencyRequest request) {
               @Override
               public String visitExecutableAsMethod(
                   ExecutableElement method, DependencyRequest request) {
-                StringBuilder builder = new StringBuilder(INDENT);
-                appendRequestedKeyAndVerb(
-                    builder,
-                    request.key().qualifier(),
-                    request.key().type(),
-                    componentMethodRequestVerb(request));
+                StringBuilder builder = new StringBuilder();
+                builder
+                    .append(INDENT)
+                    .append(formatKey(request.key()))
+                    .append(" is ")
+                    .append(componentMethodRequestVerb(request))
+                    .append(" at\n")
+                    .append(DOUBLE_INDENT);
                 appendEnclosingTypeAndMemberName(method, builder);
                 builder.append('(');
                 for (VariableElement parameter : method.getParameters()) {
@@ -123,9 +145,9 @@ public String visitExecutableAsMethod(
                */
               @Override
               public String visitVariableAsParameter(
-                  final VariableElement variable, DependencyRequest request) {
-                StringBuilder builder = new StringBuilder(INDENT);
-                appendRequestedKeyAndVerb(request, builder);
+                  VariableElement variable, DependencyRequest request) {
+                StringBuilder builder = new StringBuilder();
+                appendRequestedTypeIsInjectedAt(builder, request);
 
                 ExecutableElement methodOrConstructor =
                     asExecutable(variable.getEnclosingElement());
@@ -146,8 +168,8 @@ public String visitVariableAsParameter(
               @Override
               public String visitVariableAsField(
                   VariableElement variable, DependencyRequest request) {
-                StringBuilder builder = new StringBuilder(INDENT);
-                appendRequestedKeyAndVerb(request, builder);
+                StringBuilder builder = new StringBuilder();
+                appendRequestedTypeIsInjectedAt(builder, request);
                 appendEnclosingTypeAndMemberName(variable, builder);
                 return builder.toString();
               }
@@ -166,36 +188,50 @@ protected String defaultAction(Element element, DependencyRequest request) {
             request);
   }
 
-  private void appendRequestedKeyAndVerb(DependencyRequest request, StringBuilder builder) {
-    appendRequestedKeyAndVerb(
-        builder, request.key().qualifier(), requestedTypeWithFrameworkClass(request), "injected");
+  @CanIgnoreReturnValue
+  private StringBuilder appendRequestedTypeIsInjectedAt(
+      StringBuilder builder, DependencyRequest request) {
+    return builder
+        .append(INDENT)
+        .append(formatKey(request.key().qualifier(), requestedType(request)))
+        .append(" is injected at\n")
+        .append(DOUBLE_INDENT);
   }
 
-  private void appendRequestedKeyAndVerb(
-      StringBuilder builder,
-      Optional<AnnotationMirror> qualifier,
-      TypeMirror requestedType,
-      String verb) {
-    appendQualifiedType(builder, qualifier, requestedType);
-    builder.append(" is ").append(verb).append(" at\n    ").append(INDENT);
-  }
+  private TypeMirror requestedType(DependencyRequest request) {
+    TypeMirror keyType = request.key().type();
+    switch (request.kind()) {
+      case FUTURE:
+        return wrapType(ListenableFuture.class, keyType);
+
+      case PROVIDER_OF_LAZY:
+        return wrapType(Provider.class, wrapType(Lazy.class, keyType));
 
-  private TypeMirror requestedTypeWithFrameworkClass(DependencyRequest request) {
-    Optional<Class<?>> requestFrameworkClass = request.kind().frameworkClass;
-    if (requestFrameworkClass.isPresent()) {
-      return types.getDeclaredType(
-          elements.getTypeElement(requestFrameworkClass.get().getCanonicalName()),
-          request.key().type());
+      default:
+        if (request.kind().frameworkClass.isPresent()) {
+          return wrapType(request.kind().frameworkClass.get(), keyType);
+        } else {
+          return keyType;
+        }
     }
-    return request.key().type();
   }
 
-  private void appendQualifiedType(
-      StringBuilder builder, Optional<AnnotationMirror> qualifier, TypeMirror type) {
+  private DeclaredType wrapType(Class<?> wrapperType, TypeMirror wrappedType) {
+    return types.getDeclaredType(
+        elements.getTypeElement(wrapperType.getCanonicalName()), wrappedType);
+  }
+
+  private String formatKey(Key key) {
+    return formatKey(key.qualifier(), key.type());
+  }
+
+  private String formatKey(Optional<AnnotationMirror> qualifier, TypeMirror type) {
+    StringBuilder builder = new StringBuilder();
     if (qualifier.isPresent()) {
       builder.append(qualifier.get()).append(' ');
     }
     builder.append(type);
+    return builder.toString();
   }
 
   /**
@@ -231,4 +267,30 @@ private StringBuilder appendEnclosingTypeAndMemberName(Element member, StringBui
         .append('.')
         .append(member.getSimpleName());
   }
+
+  /**
+   * Returns a string of the form "{@code @BindsOptionalOf SomeKey is declared at Module.method()}",
+   * where {@code Module.method()} is the declaration. If there is more than one such declaration,
+   * one is chosen arbitrarily, and ", among others" is appended.
+   */
+  private String formatSyntheticOptionalBindingDependency(
+      ImmutableSet<OptionalBindingDeclaration> optionalBindingDeclarations) {
+    OptionalBindingDeclaration optionalBindingDeclaration =
+        optionalBindingDeclarations.iterator().next();
+    StringBuilder builder = new StringBuilder();
+    builder
+        .append(INDENT)
+        .append("@BindsOptionalOf ")
+        .append(formatKey(optionalBindingDeclaration.key()))
+        .append(" is declared at\n")
+        .append(DOUBLE_INDENT);
+
+    appendEnclosingTypeAndMemberName(optionalBindingDeclaration.bindingElement().get(), builder);
+    builder.append("()");
+    if (optionalBindingDeclarations.size() > 1) {
+      builder.append(", among others");
+    }
+
+    return builder.toString();
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 287409bee..73bb5d026 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -36,6 +36,7 @@
    * Common constants.
    */
   static final String INDENT = "    ";
+  static final String DOUBLE_INDENT = INDENT + INDENT;
   static final int DUPLICATE_SIZE_LIMIT = 10;
 
   /*
@@ -181,8 +182,15 @@ static String inconsistentMapKeyAnnotationsError(String key) {
   static final String BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER =
       "@Binds methods must have only one parameter whose type is assignable to the return type";
 
-  static final String BINDING_METHOD_NOT_IN_MODULE =
-      "@%s methods can only be present within a @%s";
+  static final String BINDS_OPTIONAL_OF_METHOD_HAS_PARAMETER =
+      "@BindsOptionalOf methods must not have parameters";
+
+  static final String BINDS_OPTIONAL_OF_METHOD_RETURNS_IMPLICITLY_PROVIDED_TYPE =
+      "@BindsOptionalOf methods cannot "
+          + "return unqualified types that have an @Inject-annotated constructor because those are "
+          + "always present";
+
+  static final String BINDING_METHOD_NOT_IN_MODULE = "@%s methods can only be present within a @%s";
 
   static final String BINDS_ELEMENTS_INTO_SET_METHOD_RETURN_SET =
       "@Binds @ElementsIntoSet methods must return a Set and take a Set parameter";
@@ -491,8 +499,6 @@ private MultibindingsMessages() {}
     static final String METHOD_MUST_RETURN_MAP_OR_SET =
         "@%s methods must return Map<K, V> or Set<T>";
 
-    static final String NO_MAP_KEY = "@%s methods must not have a @MapKey annotation";
-
     static final String PARAMETERS = "@%s methods cannot have parameters";
 
     private MultibindsMessages() {}
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkType.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkType.java
new file mode 100644
index 000000000..15cb4fccf
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkType.java
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_UNDERSCORE;
+import static dagger.internal.codegen.DependencyRequest.Kind.INSTANCE;
+
+import com.google.common.util.concurrent.Futures;
+import com.squareup.javapoet.CodeBlock;
+import dagger.MembersInjector;
+import dagger.internal.DoubleCheck;
+import dagger.internal.ProviderOfLazy;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import dagger.producers.internal.Producers;
+import javax.inject.Provider;
+
+/** One of the core types initialized as fields in a generated component. */
+enum FrameworkType {
+  /** A {@link Provider}. */
+  PROVIDER {
+    @Override
+    CodeBlock to(DependencyRequest.Kind requestKind, CodeBlock from) {
+      switch (requestKind) {
+        case INSTANCE:
+          return CodeBlock.of("$L.get()", from);
+
+        case LAZY:
+          return CodeBlock.of("$T.lazy($L)", DoubleCheck.class, from);
+
+        case PROVIDER:
+          return from;
+
+        case PROVIDER_OF_LAZY:
+          return CodeBlock.of("$T.create($L)", ProviderOfLazy.class, from);
+
+        case PRODUCER:
+          return CodeBlock.of("$T.producerFromProvider($L)", Producers.class, from);
+
+        case FUTURE:
+          return CodeBlock.of("$T.immediateFuture($L)", Futures.class, to(INSTANCE, from));
+
+        case PRODUCED:
+          return CodeBlock.of("$T.successful($L)", Produced.class, to(INSTANCE, from));
+
+        default:
+          throw new IllegalArgumentException(
+              String.format("Cannot request a %s from a %s", requestKind, this));
+      }
+    }
+  },
+
+  /** A {@link Producer}. */
+  PRODUCER {
+    @Override
+    CodeBlock to(DependencyRequest.Kind requestKind, CodeBlock from) {
+      switch (requestKind) {
+        case FUTURE:
+          return CodeBlock.of("$L.get()", from);
+
+        case PRODUCER:
+          return from;
+
+        default:
+          throw new IllegalArgumentException(
+              String.format("Cannot request a %s from a %s", requestKind, this));
+      }
+    }
+  },
+
+  /** A {@link MembersInjector}. */
+  MEMBERS_INJECTOR {
+    @Override
+    CodeBlock to(DependencyRequest.Kind requestKind, CodeBlock from) {
+      switch (requestKind) {
+        case MEMBERS_INJECTOR:
+          return from;
+
+        default:
+          throw new IllegalArgumentException(
+              String.format("Cannot request a %s from a %s", requestKind, this));
+      }
+    }
+  },
+  ;
+
+  /**
+   * Returns an expression that evaluates to a requested object given an expression that evaluates
+   * to an instance of this framework type.
+   *
+   * @param requestKind the kind of {@link DependencyRequest} that the returned expression can
+   *     satisfy
+   * @param from an expression that evaluates to an instance of this framework type
+   * @throws IllegalArgumentException if a valid expression cannot be generated for {@code
+   *     requestKind}
+   */
+  abstract CodeBlock to(DependencyRequest.Kind requestKind, CodeBlock from);
+
+  @Override
+  public String toString() {
+    return UPPER_UNDERSCORE.to(UPPER_CAMEL, super.toString());
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index b1b5bac4c..be4bcf922 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -16,19 +16,16 @@
 
 package dagger.internal.codegen;
 
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
+import static dagger.internal.codegen.InjectionAnnotations.injectedConstructors;
 import static dagger.internal.codegen.MembersInjectionBinding.Strategy.INJECT_MEMBERS;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
-import static javax.lang.model.util.ElementFilter.constructorsIn;
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Optional;
-import com.google.common.base.Predicate;
-import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
@@ -305,18 +302,6 @@ private void registerBinding(MembersInjectionBinding binding, boolean warnIfNotA
     }
   }
 
-  private ImmutableSet<ExecutableElement> injectedConstructors(TypeElement element) {
-    return FluentIterable.from(constructorsIn(element.getEnclosedElements()))
-        .filter(
-            new Predicate<ExecutableElement>() {
-              @Override
-              public boolean apply(ExecutableElement constructor) {
-                return isAnnotationPresent(constructor, Inject.class);
-              }
-            })
-        .toSet();
-  }
-
   /**
    * Returns a {@link MembersInjectionBinding} for {@code key}. If none has been registered yet,
    * registers one, along with all necessary members injection bindings for superclasses.
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
index bfc9773dc..403f2e7d5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
@@ -16,15 +16,22 @@
 
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkNotNull;
+import static javax.lang.model.util.ElementFilter.constructorsIn;
 
 import com.google.auto.common.AnnotationMirrors;
 import com.google.common.base.Optional;
+import com.google.common.base.Predicate;
+import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
+import javax.inject.Inject;
 import javax.inject.Qualifier;
 import javax.inject.Scope;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
 
 /**
  * Utilities relating to annotations defined in the {@code javax.inject} package.
@@ -55,5 +62,18 @@
     return AnnotationMirrors.getAnnotatedAnnotations(element, Scope.class);
   }
 
+  /** Returns the constructors in {@code type} that are annotated with {@link Inject}. */
+  static ImmutableSet<ExecutableElement> injectedConstructors(TypeElement type) {
+    return FluentIterable.from(constructorsIn(type.getEnclosedElements()))
+        .filter(
+            new Predicate<ExecutableElement>() {
+              @Override
+              public boolean apply(ExecutableElement constructor) {
+                return isAnnotationPresent(constructor, Inject.class);
+              }
+            })
+        .toSet();
+  }
+
   private InjectionAnnotations() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index fd3de007c..f5cbaf179 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -43,6 +43,7 @@
 import com.google.common.collect.Multimaps;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Binds;
+import dagger.BindsOptionalOf;
 import dagger.Multibindings;
 import dagger.multibindings.Multibinds;
 import dagger.producers.Produced;
@@ -54,6 +55,7 @@
 import java.util.Set;
 import java.util.concurrent.Executor;
 import javax.inject.Provider;
+import javax.inject.Qualifier;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
@@ -208,45 +210,54 @@ boolean isValidMembersInjectionKey() {
   }
 
   /**
-   * Returns true if the key is valid as an implicit key (that is, if it's valid for a just-in-time
-   * binding by discovering an {@code @Inject} constructor).
+   * Returns {@code true} if this is valid as an implicit key (that is, if it's valid for a
+   * just-in-time binding by discovering an {@code @Inject} constructor).
    */
-  boolean isValidImplicitProvisionKey(final Types types) {
+  boolean isValidImplicitProvisionKey(Types types) {
+    return isValidImplicitProvisionKey(qualifier(), type(), types);
+  }
+
+  /**
+   * Returns {@code true} if a key with {@code qualifier} and {@code type} is valid as an implicit
+   * key (that is, if it's valid for a just-in-time binding by discovering an {@code @Inject}
+   * constructor).
+   */
+  static boolean isValidImplicitProvisionKey(
+      Optional<? extends AnnotationMirror> qualifier, TypeMirror type, final Types types) {
     // Qualifiers disqualify implicit provisioning.
-    if (qualifier().isPresent()) {
+    if (qualifier.isPresent()) {
       return false;
     }
 
-    return type().accept(new SimpleTypeVisitor6<Boolean, Void>() {
-      @Override protected Boolean defaultAction(TypeMirror e, Void p) {
-        return false; // Only declared types are allowed.
-      }
-
-      @Override public Boolean visitDeclared(DeclaredType type, Void ignored) {
-        // Non-classes or abstract classes aren't allowed.
-        TypeElement element = MoreElements.asType(type.asElement());
-        if (!element.getKind().equals(ElementKind.CLASS)
-            || element.getModifiers().contains(Modifier.ABSTRACT)) {
-          return false;
-        }
-
-        // If the key has type arguments, validate that each type argument is declared.
-        // Otherwise the type argument may be a wildcard (or other type), and we can't
-        // resolve that to actual types.
-        for (TypeMirror arg : type.getTypeArguments()) {
-          if (arg.getKind() != TypeKind.DECLARED) {
-            return false;
+    return type.accept(
+        new SimpleTypeVisitor6<Boolean, Void>(false) {
+          @Override
+          public Boolean visitDeclared(DeclaredType type, Void ignored) {
+            // Non-classes or abstract classes aren't allowed.
+            TypeElement element = MoreElements.asType(type.asElement());
+            if (!element.getKind().equals(ElementKind.CLASS)
+                || element.getModifiers().contains(Modifier.ABSTRACT)) {
+              return false;
+            }
+
+            // If the key has type arguments, validate that each type argument is declared.
+            // Otherwise the type argument may be a wildcard (or other type), and we can't
+            // resolve that to actual types.
+            for (TypeMirror arg : type.getTypeArguments()) {
+              if (arg.getKind() != TypeKind.DECLARED) {
+                return false;
+              }
+            }
+
+            // Also validate that the key is not the erasure of a generic type.
+            // If it is, that means the user referred to Foo<T> as just 'Foo',
+            // which we don't allow.  (This is a judgement call -- we *could*
+            // allow it and instantiate the type bounds... but we don't.)
+            return MoreTypes.asDeclared(element.asType()).getTypeArguments().isEmpty()
+                || !types.isSameType(types.erasure(element.asType()), type);
           }
-        }
-
-        // Also validate that the key is not the erasure of a generic type.
-        // If it is, that means the user referred to Foo<T> as just 'Foo',
-        // which we don't allow.  (This is a judgement call -- we *could*
-        // allow it and instantiate the type bounds... but we don't.)
-        return MoreTypes.asDeclared(element.asType()).getTypeArguments().isEmpty()
-            || !types.isSameType(types.erasure(element.asType()), type());
-      }
-    }, null);
+        },
+        null);
   }
 
   /**
@@ -337,27 +348,42 @@ Key forSubcomponentBuilderMethod(
     }
 
     Key forProvidesMethod(ExecutableElement method, TypeElement contributingModule) {
-      return forProvidesOrProducesMethod(method, contributingModule, getProviderElement());
+      return forBindingMethod(method, contributingModule, Optional.of(getProviderElement()));
     }
 
     Key forProducesMethod(ExecutableElement method, TypeElement contributingModule) {
-      return forProvidesOrProducesMethod(method, contributingModule, getProducerElement());
+      return forBindingMethod(method, contributingModule, Optional.of(getProducerElement()));
+    }
+
+    /** Returns the key bound by a {@link Binds} method. */
+    Key forBindsMethod(ExecutableElement method, TypeElement contributingModule) {
+      checkArgument(isAnnotationPresent(method, Binds.class));
+      return forBindingMethod(method, contributingModule, Optional.<TypeElement>absent());
+    }
+
+    /** Returns the base key bound by a {@link BindsOptionalOf} method. */
+    Key forBindsOptionalOfMethod(ExecutableElement method, TypeElement contributingModule) {
+      checkArgument(isAnnotationPresent(method, BindsOptionalOf.class));
+      return forBindingMethod(method, contributingModule, Optional.<TypeElement>absent());
     }
 
-    private Key forProvidesOrProducesMethod(
-        ExecutableElement method, TypeElement contributingModule, TypeElement frameworkType) {
+    private Key forBindingMethod(
+        ExecutableElement method,
+        TypeElement contributingModule,
+        Optional<TypeElement> frameworkType) {
       checkArgument(method.getKind().equals(METHOD));
       ExecutableType methodType =
           MoreTypes.asExecutable(
               types.asMemberOf(MoreTypes.asDeclared(contributingModule.asType()), method));
       ContributionType contributionType = ContributionType.fromBindingMethod(method);
       TypeMirror returnType = normalize(types, methodType.getReturnType());
-      if (frameworkType.equals(getProducerElement())
+      if (frameworkType.isPresent()
+          && frameworkType.get().equals(getProducerElement())
           && MoreTypes.isTypeOf(ListenableFuture.class, returnType)) {
         returnType = Iterables.getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments());
       }
       TypeMirror keyType =
-          bindingMethodKeyType(returnType, method, contributionType, Optional.of(frameworkType));
+          bindingMethodKeyType(returnType, method, contributionType, frameworkType);
       Key key = forMethod(method, keyType);
       return contributionType.equals(ContributionType.UNIQUE)
           ? key
@@ -388,26 +414,6 @@ Key forMultibindsMethod(
       return forMethod(method, keyType);
     }
 
-    /** Returns the key bound by a {@link Binds} method. */
-    Key forBindsMethod(ExecutableElement method, TypeElement contributingModule) {
-      checkArgument(isAnnotationPresent(method, Binds.class));
-      ContributionType contributionType = ContributionType.fromBindingMethod(method);
-      TypeMirror returnType =
-          normalize(
-              types,
-              MoreTypes.asExecutable(
-                      types.asMemberOf(MoreTypes.asDeclared(contributingModule.asType()), method))
-                  .getReturnType());
-      TypeMirror keyType =
-          bindingMethodKeyType(
-              returnType, method, contributionType, Optional.<TypeElement>absent());
-      Key key = forMethod(method, keyType);
-      return contributionType.equals(ContributionType.UNIQUE)
-          ? key
-          : key.withMultibindingContributionIdentifier(
-              new MultibindingContributionIdentifier(method, contributingModule));
-    }
-
     private TypeMirror bindingMethodKeyType(
         TypeMirror returnType,
         ExecutableElement method,
@@ -653,5 +659,19 @@ private Key wrapMapValue(Key key, Class<?> newWrappingClass) {
       }
       return Optional.absent();
     }
+
+    /**
+     * If {@code key}'s type is {@code Optional<T>} for some {@code T}, returns a key with the same
+     * qualifier whose type is {@linkplain DependencyRequest#extractKindAndType(TypeMirror)
+     * extracted} from {@code T}.
+     */
+    Optional<Key> unwrapOptional(Key key) {
+      if (!OptionalType.isOptional(key)) {
+        return Optional.absent();
+      }
+      TypeMirror underlyingType =
+          DependencyRequest.extractKindAndType(OptionalType.from(key).valueType()).type();
+      return Optional.of(key.withType(types, underlyingType));
+    }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
index bda1fb584..ca6100794 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
@@ -36,6 +36,7 @@
 import com.google.common.collect.Iterables;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import dagger.Binds;
+import dagger.BindsOptionalOf;
 import dagger.Module;
 import dagger.Multibindings;
 import dagger.Provides;
@@ -68,16 +69,15 @@
 
   abstract ImmutableSet<ContributionBinding> bindings();
 
-  /**
-   * The multibinding declarations contained in this module.
-   */
+  /** The multibinding declarations contained in this module. */
   abstract ImmutableSet<MultibindingDeclaration> multibindingDeclarations();
 
-  /**
-   * The {@link Binds} method declarations that define delegate bindings.
-   */
+  /** The {@link Binds} method declarations that define delegate bindings. */
   abstract ImmutableSet<DelegateDeclaration> delegateDeclarations();
 
+  /** The {@link BindsOptionalOf} method declarations that define optional bindings. */
+  abstract ImmutableSet<OptionalBindingDeclaration> optionalDeclarations();
+
   enum Kind {
     MODULE(
         Module.class, Provides.class, ImmutableSet.of(Module.class)),
@@ -137,18 +137,21 @@
     private final ProductionBinding.Factory productionBindingFactory;
     private final MultibindingDeclaration.Factory multibindingDeclarationFactory;
     private final DelegateDeclaration.Factory bindingDelegateDeclarationFactory;
+    private final OptionalBindingDeclaration.Factory optionalBindingDeclarationFactory;
 
     Factory(
         Elements elements,
         ProvisionBinding.Factory provisionBindingFactory,
         ProductionBinding.Factory productionBindingFactory,
         MultibindingDeclaration.Factory multibindingDeclarationFactory,
-        DelegateDeclaration.Factory bindingDelegateDeclarationFactory) {
+        DelegateDeclaration.Factory bindingDelegateDeclarationFactory,
+        OptionalBindingDeclaration.Factory optionalBindingDeclarationFactory) {
       this.elements = elements;
       this.provisionBindingFactory = provisionBindingFactory;
       this.productionBindingFactory = productionBindingFactory;
       this.multibindingDeclarationFactory = multibindingDeclarationFactory;
       this.bindingDelegateDeclarationFactory = bindingDelegateDeclarationFactory;
+      this.optionalBindingDeclarationFactory = optionalBindingDeclarationFactory;
     }
 
     ModuleDescriptor create(TypeElement moduleElement) {
@@ -160,6 +163,9 @@ ModuleDescriptor create(TypeElement moduleElement) {
       ImmutableSet.Builder<DelegateDeclaration> delegates = ImmutableSet.builder();
       ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarations =
           ImmutableSet.builder();
+      ImmutableSet.Builder<OptionalBindingDeclaration> optionalDeclarations =
+          ImmutableSet.builder();
+
       for (ExecutableElement moduleMethod : methodsIn(elements.getAllMembers(moduleElement))) {
         if (isAnnotationPresent(moduleMethod, Provides.class)) {
           bindings.add(provisionBindingFactory.forProvidesMethod(moduleMethod, moduleElement));
@@ -174,6 +180,10 @@ ModuleDescriptor create(TypeElement moduleElement) {
           multibindingDeclarations.add(
               multibindingDeclarationFactory.forMultibindsMethod(moduleMethod, moduleElement));
         }
+        if (isAnnotationPresent(moduleMethod, BindsOptionalOf.class)) {
+          optionalDeclarations.add(
+              optionalBindingDeclarationFactory.forMethod(moduleMethod, moduleElement));
+        }
       }
 
       for (TypeElement memberType : typesIn(elements.getAllMembers(moduleElement))) {
@@ -189,7 +199,8 @@ ModuleDescriptor create(TypeElement moduleElement) {
               collectIncludedModules(new LinkedHashSet<ModuleDescriptor>(), moduleElement)),
           bindings.build(),
           multibindingDeclarations.build(),
-          delegates.build());
+          delegates.build(),
+          optionalDeclarations.build());
     }
 
     private static Optional<AnnotationMirror> getModuleAnnotation(TypeElement moduleElement) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
index b7b94d67d..818e5f510 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
@@ -44,8 +44,8 @@
 final class ModuleProcessingStep implements ProcessingStep {
 
   /**
-   * A {@link ProcessingStep} for {@code @Module} classes that generates factories for {@code
-   * @Provides} methods.
+   * A {@link ProcessingStep} for {@code @Module} classes that generates factories for
+   * {@code @Provides} methods.
    */
   static ModuleProcessingStep moduleProcessingStep(
       Messager messager,
@@ -54,14 +54,19 @@ static ModuleProcessingStep moduleProcessingStep(
       FactoryGenerator factoryGenerator,
       ProvidesMethodValidator providesMethodValidator,
       BindsMethodValidator bindsMethodValidator,
-      MultibindsMethodValidator multibindsMethodValidator) {
+      MultibindsMethodValidator multibindsMethodValidator,
+      BindsOptionalOfMethodValidator bindsOptionalOfMethodValidator) {
     return new ModuleProcessingStep(
         messager,
         Module.class,
         moduleValidator,
         ImmutableSet.<ModuleMethodFactoryGenerator>of(
             new ProvisionModuleMethodFactoryGenerator(provisionBindingFactory, factoryGenerator)),
-        ImmutableSet.of(providesMethodValidator, bindsMethodValidator, multibindsMethodValidator));
+        ImmutableSet.of(
+            providesMethodValidator,
+            bindsMethodValidator,
+            multibindsMethodValidator,
+            bindsOptionalOfMethodValidator));
   }
 
   /**
@@ -78,7 +83,8 @@ static ModuleProcessingStep producerModuleProcessingStep(
       ProducerFactoryGenerator producerFactoryGenerator,
       ProducesMethodValidator producesMethodValidator,
       BindsMethodValidator bindsMethodValidator,
-      MultibindsMethodValidator multibindsMethodValidator) {
+      MultibindsMethodValidator multibindsMethodValidator,
+      BindsOptionalOfMethodValidator bindsOptionalOfMethodValidator) {
     return new ModuleProcessingStep(
         messager,
         ProducerModule.class,
@@ -91,7 +97,8 @@ static ModuleProcessingStep producerModuleProcessingStep(
             providesMethodValidator,
             producesMethodValidator,
             bindsMethodValidator,
-            multibindsMethodValidator));
+            multibindsMethodValidator,
+            bindsOptionalOfMethodValidator));
   }
 
   private final Messager messager;
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindsMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/MultibindsMethodValidator.java
index 9dfb08a32..fc0ace9ff 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindsMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindsMethodValidator.java
@@ -17,25 +17,19 @@
 package dagger.internal.codegen;
 
 import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_ABSTRACT;
+import static dagger.internal.codegen.BindingMethodValidator.AllowsMultibindings.NO_MULTIBINDINGS;
 import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.NO_EXCEPTIONS;
 import static dagger.internal.codegen.ErrorMessages.MultibindsMessages.METHOD_MUST_RETURN_MAP_OR_SET;
-import static dagger.internal.codegen.ErrorMessages.MultibindsMessages.NO_MAP_KEY;
 import static dagger.internal.codegen.ErrorMessages.MultibindsMessages.PARAMETERS;
 import static dagger.internal.codegen.FrameworkTypes.isFrameworkType;
-import static dagger.internal.codegen.MapKeys.getMapKeys;
 
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableSet;
-import dagger.MapKey;
 import dagger.Module;
 import dagger.Multibindings;
-import dagger.multibindings.ElementsIntoSet;
-import dagger.multibindings.IntoMap;
-import dagger.multibindings.IntoSet;
 import dagger.multibindings.Multibinds;
 import dagger.producers.ProducerModule;
 import java.lang.annotation.Annotation;
-import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
@@ -63,7 +57,8 @@ protected MultibindsMethodValidator(
         methodAnnotation,
         enclosingElementAnnotations,
         MUST_BE_ABSTRACT,
-        NO_EXCEPTIONS);
+        NO_EXCEPTIONS,
+        NO_MULTIBINDINGS);
   }
   
   @Override
@@ -88,25 +83,6 @@ protected void checkReturnType(ValidationReport.Builder<ExecutableElement> build
     }
   }
 
-  /** Adds an error if the method has any {@link MapKey @MapKey} annotations. */
-  @Override
-  protected void checkMapKeys(ValidationReport.Builder<ExecutableElement> builder) {
-    ImmutableSet<? extends AnnotationMirror> mapKeys = getMapKeys(builder.getSubject());
-    if (!mapKeys.isEmpty()) {
-      builder.addError(formatErrorMessage(NO_MAP_KEY));
-    }
-  }
-
-  /**
-   * {@link MultibindingAnnotationsProcessingStep} reports an error if {@link IntoMap @IntoMap},
-   * {@link IntoSet @IntoSet}, or {@link ElementsIntoSet @ElementsIntoSet} are applied to the method
-   * at all, so no need to check again.
-   */
-  @Override
-  protected void checkMultibindings(ValidationReport.Builder<ExecutableElement> builder) {
-    // no-op
-  }
-
   private boolean isPlainMap(TypeMirror returnType) {
     if (!MapType.isMap(returnType)) {
       return false;
diff --git a/compiler/src/main/java/dagger/internal/codegen/OptionalBindingDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/OptionalBindingDeclaration.java
new file mode 100644
index 000000000..f5c14175f
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/OptionalBindingDeclaration.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Optional;
+import dagger.BindsOptionalOf;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+
+/** A {@link BindsOptionalOf} declaration. */
+@AutoValue
+abstract class OptionalBindingDeclaration extends BindingDeclaration {
+
+  /**
+   * {@inheritDoc}
+   *
+   * <p>The key's type is the method's return type, even though the synthetic bindings will be for
+   * {@code Optional} of derived types.
+   */
+  @Override
+  public abstract Key key();
+
+  static class Factory {
+    private final Key.Factory keyFactory;
+
+    Factory(Key.Factory keyFactory) {
+      this.keyFactory = keyFactory;
+    }
+
+    OptionalBindingDeclaration forMethod(ExecutableElement method, TypeElement contributingModule) {
+      checkArgument(isAnnotationPresent(method, BindsOptionalOf.class));
+      return new AutoValue_OptionalBindingDeclaration(
+          Optional.<Element>of(method),
+          Optional.of(contributingModule),
+          keyFactory.forBindsOptionalOfMethod(method, contributingModule));
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/OptionalFactoryClasses.java b/compiler/src/main/java/dagger/internal/codegen/OptionalFactoryClasses.java
new file mode 100644
index 000000000..c40a72560
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/OptionalFactoryClasses.java
@@ -0,0 +1,179 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_UNDERSCORE;
+import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_RAWTYPES;
+import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
+import static dagger.internal.codegen.TypeNames.lazyOf;
+import static dagger.internal.codegen.TypeNames.optionalOf;
+import static dagger.internal.codegen.TypeNames.providerOf;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
+
+import com.google.common.base.Optional;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import com.squareup.javapoet.TypeVariableName;
+import dagger.internal.Preconditions;
+import javax.inject.Provider;
+
+/** Factory class specifications for optional bindings. */
+// TODO(dpb): Name classes correctly if a component uses both Guava and JDK Optional.
+final class OptionalFactoryClasses {
+
+  /**
+   * The class specification for a {@link Provider<Optional<T>>} that always returns {@code
+   * Optional.absent()}.
+   */
+  static final TypeSpec ABSENT_FACTORY_CLASS = absentFactoryClass();
+
+  private static TypeSpec absentFactoryClass() {
+    String className = "AbsentOptionalFactory";
+    TypeVariableName typeVariable = TypeVariableName.get("T");
+    
+    return classBuilder(className)
+        .addTypeVariable(typeVariable)
+        .addModifiers(PRIVATE, STATIC, FINAL)
+        .addSuperinterface(providerOf(optionalOf(typeVariable)))
+        .addJavadoc("A {@link $T} that returns {$T.absent()}.", Provider.class, Optional.class)
+        .addField(FieldSpec.builder(Provider.class, "INSTANCE", PRIVATE, STATIC, FINAL)
+            .addAnnotation(SUPPRESS_WARNINGS_RAWTYPES)
+            .initializer("new $L()", className)
+            .build())
+        .addMethod(
+            methodBuilder("instance")
+                .addModifiers(PRIVATE, STATIC)
+                .addTypeVariable(typeVariable)
+                .returns(providerOf(optionalOf(typeVariable)))
+                .addCode("$L // safe covariant cast\n", SUPPRESS_WARNINGS_UNCHECKED)
+                .addCode("$1T provider = ($1T) INSTANCE;", providerOf(optionalOf(typeVariable)))
+                .addCode("return provider;")
+                .build())
+        .addMethod(
+            methodBuilder("get")
+                .addAnnotation(Override.class)
+                .addModifiers(PUBLIC)
+                .returns(optionalOf(typeVariable))
+                .addCode("return $T.absent();", Optional.class)
+                .build())
+        .build();
+  }
+
+  /**
+   * Returns the class specification for a {@link Provider} that returns a present value. The class
+   * is generic in {@code T}.
+   *
+   * <ul>
+   * <li>If {@code optionalRequestKind} is {@link DependencyRequest.Kind#INSTANCE}, the class
+   *     implements {@code Provider<Optional<T>>}.
+   * <li>If {@code optionalRequestKind} is {@link DependencyRequest.Kind#PROVIDER}, the class
+   *     implements {@code Provider<Optional<Provider<T>>>}.
+   * <li>If {@code optionalRequestKind} is {@link DependencyRequest.Kind#LAZY}, the class implements
+   *     {@code Provider<Optional<Lazy<T>>>}.
+   * <li>If {@code optionalRequestKind} is {@link DependencyRequest.Kind#PROVIDER_OF_LAZY}, the
+   *     class implements {@code Provider<Optional<Provider<Lazy<T>>>>}.
+   * </ul>
+   *
+   * <p>Production requests are not yet supported.
+   */
+  static TypeSpec presentFactoryClass(DependencyRequest.Kind optionalValueKind) {
+    String factoryClassName =
+        String.format(
+            "PresentOptional%sFactory",
+            UPPER_UNDERSCORE.to(UPPER_CAMEL, optionalValueKind.toString()));
+    
+    TypeVariableName typeVariable = TypeVariableName.get("T");
+    
+    FieldSpec providerField =
+        FieldSpec.builder(providerOf(typeVariable), "provider", PRIVATE, FINAL).build();
+    
+    ParameterSpec providerParameter =
+        ParameterSpec.builder(providerOf(typeVariable), "provider").build();
+    
+    ParameterizedTypeName optionalType = optionalType(optionalValueKind, typeVariable);
+    
+    return classBuilder(factoryClassName)
+        .addTypeVariable(typeVariable)
+        .addModifiers(PRIVATE, STATIC, FINAL)
+        .addSuperinterface(providerOf(optionalType))
+        .addJavadoc(
+            "A {@link $T} that returns an {@code $T} using a {@code Provider<T>}.",
+            Provider.class,
+            optionalType)
+        .addField(providerField)
+        .addMethod(
+            constructorBuilder()
+                .addModifiers(PRIVATE)
+                .addParameter(providerParameter)
+                .addCode(
+                    "this.$N = $T.checkNotNull($N);",
+                    FieldSpec.builder(providerOf(typeVariable), "provider", PRIVATE, FINAL).build(),
+                    Preconditions.class,
+                    providerParameter)
+                .build())
+        .addMethod(
+            methodBuilder("get")
+                .addAnnotation(Override.class)
+                .addModifiers(PUBLIC)
+                .returns(optionalType)
+                .addCode(
+                    "return $T.of($L);",
+                    Optional.class,
+                    FrameworkType.PROVIDER.to(optionalValueKind, CodeBlock.of("$N", providerField)))
+                .build())
+        .addMethod(
+            methodBuilder("of")
+                .addModifiers(PRIVATE, STATIC)
+                .addTypeVariable(typeVariable)
+                .returns(providerOf(optionalType))
+                .addParameter(providerParameter)
+                .addCode("return new $L<T>($N);", factoryClassName, providerParameter)
+                .build())
+        .build();
+  }
+
+  private static ParameterizedTypeName optionalType(
+      DependencyRequest.Kind optionalValueKind, TypeName valueType) {
+    switch (optionalValueKind) {
+      case INSTANCE:
+        return optionalOf(valueType);
+
+      case LAZY:
+        return optionalOf(lazyOf(valueType));
+
+      case PROVIDER:
+        return optionalOf(providerOf(valueType));
+
+      case PROVIDER_OF_LAZY:
+        return optionalOf(providerOf(lazyOf(valueType)));
+
+      default:
+        throw new AssertionError(optionalValueKind);
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/OptionalType.java b/compiler/src/main/java/dagger/internal/codegen/OptionalType.java
new file mode 100644
index 000000000..d7e23b17c
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/OptionalType.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkArgument;
+
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Equivalence;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.SimpleTypeVisitor7;
+
+/**
+ * Information about an {@code Optional} {@link TypeMirror}.
+ *
+ * <p>Only {@link com.google.common.base.Optional} is supported.
+ */
+// TODO(dpb): Support java.util.Optional.
+@AutoValue
+abstract class OptionalType {
+
+  private static final String OPTIONAL_TYPE = "com.google.common.base.Optional";
+
+  private static final SimpleTypeVisitor7<Boolean, Void> IS_OPTIONAL =
+      new SimpleTypeVisitor7<Boolean, Void>(false) {
+        @Override
+        public Boolean visitDeclared(DeclaredType t, Void p) {
+          return MoreElements.asType(t.asElement()).getQualifiedName().contentEquals(OPTIONAL_TYPE);
+        }
+      };
+
+  /**
+   * The optional type itself, wrapped using {@link MoreTypes#equivalence()}.
+   *
+   * @deprecated Use {@link #declaredOptionalType()} instead.
+   */
+  @Deprecated
+  protected abstract Equivalence.Wrapper<DeclaredType> wrappedDeclaredOptionalType();
+
+  /** The optional type itself. */
+  @SuppressWarnings("deprecation")
+  DeclaredType declaredOptionalType() {
+    return wrappedDeclaredOptionalType().get();
+  }
+
+  /** The value type. */
+  TypeMirror valueType() {
+    return declaredOptionalType().getTypeArguments().get(0);
+  }
+
+  /** Returns {@code true} if {@code type} is an {@code Optional} type. */
+  static boolean isOptional(TypeMirror type) {
+    return type.accept(IS_OPTIONAL, null);
+  }
+
+  /** Returns {@code true} if {@code key.type()} is an {@code Optional} type. */
+  static boolean isOptional(Key key) {
+    return isOptional(key.type());
+  }
+
+  /**
+   * Returns a {@link OptionalType} for {@code type}.
+   *
+   * @throws IllegalArgumentException if {@code type} is not an {@code Optional} type
+   */
+  static OptionalType from(TypeMirror type) {
+    checkArgument(isOptional(type), "%s must be an Optional", type);
+    return new AutoValue_OptionalType(MoreTypes.equivalence().wrap(MoreTypes.asDeclared(type)));
+  }
+
+  /**
+   * Returns a {@link OptionalType} for {@code key}'s {@link Key#type() type}.
+   *
+   * @throws IllegalArgumentException if {@code key.type()} is not an {@code Optional} type
+   */
+  static OptionalType from(Key key) {
+    return from(key.type());
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFieldRequestFulfillment.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFieldRequestFulfillment.java
index ea1d1d5cf..872110657 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFieldRequestFulfillment.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFieldRequestFulfillment.java
@@ -21,9 +21,6 @@
 
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
-import dagger.MembersInjector;
-import dagger.producers.Producer;
-import javax.inject.Provider;
 
 /** Fulfills requests for {@link ProductionBinding} instances. */
 final class ProducerFieldRequestFulfillment extends RequestFulfillment {
@@ -38,31 +35,7 @@
   @Override
   public CodeBlock getSnippetForDependencyRequest(
       DependencyRequest request, ClassName requestingClass) {
-    switch (request.kind()) {
-      case FUTURE:
-        return CodeBlock.of("$L.get()", producerFieldSelect.getExpressionFor(requestingClass));
-      case PRODUCER:
-        return CodeBlock.of("$L", producerFieldSelect.getExpressionFor(requestingClass));
-      case INSTANCE:
-      case LAZY:
-      case PRODUCED:
-      case PROVIDER_OF_LAZY:
-        throw new IllegalArgumentException(
-            String.format(
-                "The framework should never request a %s from a producer: %s",
-                request.kind(), request));
-      case MEMBERS_INJECTOR:
-        throw new IllegalArgumentException(
-            String.format(
-                "Cannot request a %s from a %s",
-                MembersInjector.class.getSimpleName(), Producer.class.getSimpleName()));
-      case PROVIDER:
-        throw new IllegalArgumentException(
-            String.format(
-                "Cannot request a %s from a %s",
-                Provider.class.getSimpleName(), Producer.class.getSimpleName()));
-      default:
-        throw new AssertionError(request.kind().toString());
-    }
+    return FrameworkType.PRODUCER.to(
+        request.kind(), producerFieldSelect.getExpressionFor(requestingClass));
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
index aca2f356f..c51f3a8c4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
@@ -18,6 +18,7 @@
 
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_CONCRETE;
+import static dagger.internal.codegen.BindingMethodValidator.AllowsMultibindings.ALLOWS_MULTIBINDINGS;
 import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.EXCEPTION;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_NULLABLE;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RAW_FUTURE;
@@ -49,7 +50,14 @@
 final class ProducesMethodValidator extends BindingMethodValidator {
 
   ProducesMethodValidator(Elements elements, Types types) {
-    super(elements, types, Produces.class, ProducerModule.class, MUST_BE_CONCRETE, EXCEPTION);
+    super(
+        elements,
+        types,
+        Produces.class,
+        ProducerModule.class,
+        MUST_BE_CONCRETE,
+        EXCEPTION,
+        ALLOWS_MULTIBINDINGS);
   }
   
   @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProviderFieldRequestFulfillment.java b/compiler/src/main/java/dagger/internal/codegen/ProviderFieldRequestFulfillment.java
index 0733192e1..642b9f74a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProviderFieldRequestFulfillment.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProviderFieldRequestFulfillment.java
@@ -18,16 +18,9 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static dagger.internal.codegen.BindingKey.Kind.CONTRIBUTION;
-import static dagger.internal.codegen.TypeNames.PROVIDER_OF_LAZY;
 
-import com.google.common.util.concurrent.Futures;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
-import dagger.MembersInjector;
-import dagger.internal.DoubleCheck;
-import dagger.producers.Produced;
-import dagger.producers.internal.Producers;
-import javax.inject.Provider;
 
 /** Fulfills requests for {@link ProvisionBinding} instances. */
 final class ProviderFieldRequestFulfillment extends RequestFulfillment {
@@ -42,43 +35,7 @@
   @Override
   public CodeBlock getSnippetForDependencyRequest(
       DependencyRequest request, ClassName requestingClass) {
-    switch (request.kind()) {
-      case FUTURE:
-        return CodeBlock.of(
-            "$T.immediateFuture($L.get())",
-            Futures.class,
-            providerFieldSelect.getExpressionFor(requestingClass));
-      case INSTANCE:
-        return CodeBlock.of("$L.get()", providerFieldSelect.getExpressionFor(requestingClass));
-      case LAZY:
-        return CodeBlock.of(
-            "$T.lazy($L)",
-            DoubleCheck.class,
-            providerFieldSelect.getExpressionFor(requestingClass));
-      case MEMBERS_INJECTOR:
-        throw new IllegalArgumentException(
-            String.format(
-                "Cannot request a %s from a %s",
-                MembersInjector.class.getSimpleName(), Provider.class.getSimpleName()));
-      case PRODUCED:
-        return CodeBlock.of(
-            "$T.successful($L.get())",
-            Produced.class,
-            providerFieldSelect.getExpressionFor(requestingClass));
-      case PRODUCER:
-        return CodeBlock.of(
-            "$T.producerFromProvider($L)",
-            Producers.class,
-            providerFieldSelect.getExpressionFor(requestingClass));
-      case PROVIDER:
-        return CodeBlock.of("$L", providerFieldSelect.getExpressionFor(requestingClass));
-      case PROVIDER_OF_LAZY:
-        return CodeBlock.of(
-            "$T.create($L)",
-            PROVIDER_OF_LAZY,
-            providerFieldSelect.getExpressionFor(requestingClass));
-      default:
-        throw new AssertionError();
-    }
+    return FrameworkType.PROVIDER.to(
+        request.kind(), providerFieldSelect.getExpressionFor(requestingClass));
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
index 3c2bd1555..9feadc7a3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
@@ -17,6 +17,7 @@
 package dagger.internal.codegen;
 
 import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_CONCRETE;
+import static dagger.internal.codegen.BindingMethodValidator.AllowsMultibindings.ALLOWS_MULTIBINDINGS;
 import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.RUNTIME_EXCEPTION;
 import static dagger.internal.codegen.ErrorMessages.provisionMayNotDependOnProducerType;
 
@@ -44,7 +45,8 @@
         Provides.class,
         ImmutableSet.of(Module.class, ProducerModule.class),
         MUST_BE_CONCRETE,
-        RUNTIME_EXCEPTION);
+        RUNTIME_EXCEPTION,
+        ALLOWS_MULTIBINDINGS);
   }
 
   @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 9dbeb02bd..2f4bdfba1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -83,6 +83,8 @@ private static Builder builder() {
         .dependencies(ImmutableSet.<DependencyRequest>of());
   }
 
+  abstract Builder toBuilder();
+
   @AutoValue.Builder
   @CanIgnoreReturnValue
   abstract static class Builder extends ContributionBinding.Builder<Builder> {
@@ -300,5 +302,30 @@ ProvisionBinding missingDelegate(DelegateDeclaration delegateDeclaration) {
           .bindingKind(Kind.SYNTHETIC_DELEGATE_BINDING)
           .scope(Scope.uniqueScopeOf(delegateDeclaration.bindingElement().get()));
     }
+
+    /**
+     * Returns a synthetic binding for an {@linkplain dagger.BindsOptionalOf optional binding} in a
+     * component with no binding for the underlying key.
+     */
+    ProvisionBinding syntheticAbsentBinding(Key key) {
+      return ProvisionBinding.builder()
+          .contributionType(ContributionType.UNIQUE)
+          .key(key)
+          .bindingKind(Kind.SYNTHETIC_OPTIONAL_BINDING)
+          .build();
+    }
+
+    /**
+     * Returns a synthetic binding for an {@linkplain dagger.BindsOptionalOf optional binding} in a
+     * component with a binding for the underlying key.
+     */
+    ProvisionBinding syntheticPresentBinding(Key key) {
+      return syntheticAbsentBinding(key)
+          .toBuilder()
+          .dependencies(
+              dependencyRequestFactory.forSyntheticPresentOptionalBinding(
+                  key, DependencyRequest.Kind.PROVIDER))
+          .build();
+    }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
index 95a8cc281..2182a0437 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
@@ -83,6 +83,12 @@ public Key key() {
    */
   abstract ImmutableSet<MultibindingDeclaration> multibindingDeclarations();
   
+  /**
+   * The optional binding declarations for {@link #bindingKey()}. If {@link #bindingKey()}'s kind is
+   * not {@link BindingKey.Kind#CONTRIBUTION}, this is empty.
+   */
+  abstract ImmutableSet<OptionalBindingDeclaration> optionalBindingDeclarations();
+
   /**
    * All bindings for {@link #bindingKey()}, regardless of in which component they were resolved.
    */
@@ -189,21 +195,21 @@ ComponentDescriptor owningComponent(ContributionBinding binding) {
     return Optional.fromNullable(allMembersInjectionBindings().get(owningComponent()));
   }
 
-  /**
-   * Creates a {@link ResolvedBindings} for contribution bindings.
-   */
+  /** Creates a {@link ResolvedBindings} for contribution bindings. */
   static ResolvedBindings forContributionBindings(
       BindingKey bindingKey,
       ComponentDescriptor owningComponent,
       Multimap<ComponentDescriptor, ? extends ContributionBinding> contributionBindings,
-      Iterable<MultibindingDeclaration> multibindings) {
+      Iterable<MultibindingDeclaration> multibindings,
+      Iterable<OptionalBindingDeclaration> optionalBindingDeclarations) {
     checkArgument(bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION));
     return new AutoValue_ResolvedBindings(
         bindingKey,
         owningComponent,
         ImmutableSetMultimap.<ComponentDescriptor, ContributionBinding>copyOf(contributionBindings),
         ImmutableMap.<ComponentDescriptor, MembersInjectionBinding>of(),
-        ImmutableSet.copyOf(multibindings));
+        ImmutableSet.copyOf(multibindings),
+        ImmutableSet.copyOf(optionalBindingDeclarations));
   }
   
   /**
@@ -219,7 +225,8 @@ static ResolvedBindings forMembersInjectionBinding(
         owningComponent,
         ImmutableSetMultimap.<ComponentDescriptor, ContributionBinding>of(),
         ImmutableMap.of(owningComponent, ownedMembersInjectionBinding),
-        ImmutableSet.<MultibindingDeclaration>of());
+        ImmutableSet.<MultibindingDeclaration>of(),
+        ImmutableSet.<OptionalBindingDeclaration>of());
   }
 
   /**
@@ -231,7 +238,8 @@ static ResolvedBindings noBindings(BindingKey bindingKey, ComponentDescriptor ow
         owningComponent,
         ImmutableSetMultimap.<ComponentDescriptor, ContributionBinding>of(),
         ImmutableMap.<ComponentDescriptor, MembersInjectionBinding>of(),
-        ImmutableSet.<MultibindingDeclaration>of());
+        ImmutableSet.<MultibindingDeclaration>of(),
+        ImmutableSet.<OptionalBindingDeclaration>of());
   }
 
   /**
@@ -244,7 +252,8 @@ ResolvedBindings asInheritedIn(ComponentDescriptor owningComponent) {
         owningComponent,
         allContributionBindings(),
         allMembersInjectionBindings(),
-        multibindingDeclarations());
+        multibindingDeclarations(),
+        optionalBindingDeclarations());
   }
 
   /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index c5a2e36c4..5683b38a0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -142,11 +142,11 @@ static CodeBlock frameworkTypeUsageStatement(
       case PROVIDER:
       case PRODUCER:
       case MEMBERS_INJECTOR:
-        return CodeBlock.of("$L", frameworkTypeMemberSelect);
+        return frameworkTypeMemberSelect;
       case PROVIDER_OF_LAZY:
         return CodeBlock.of("$T.create($L)", PROVIDER_OF_LAZY, frameworkTypeMemberSelect);
-      default:
-        throw new AssertionError();
+      default: // including PRODUCED
+        throw new AssertionError(dependencyKind);
     }
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
index 5aee50317..af5007271 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
@@ -41,6 +41,7 @@
 import com.squareup.javapoet.TypeSpec;
 import dagger.internal.Preconditions;
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
+import dagger.internal.codegen.DependencyRequest.Kind;
 import java.util.List;
 import java.util.Set;
 import javax.lang.model.element.ExecutableElement;
@@ -54,8 +55,8 @@
  */
 final class SubcomponentWriter extends AbstractComponentWriter {
 
-  private AbstractComponentWriter parent;
-  private ExecutableElement subcomponentFactoryMethod;
+  private final AbstractComponentWriter parent;
+  private final ExecutableElement subcomponentFactoryMethod;
 
   public SubcomponentWriter(
       AbstractComponentWriter parent,
@@ -163,6 +164,11 @@ protected void addFactoryMethods() {
     parent.component.addMethod(componentMethod.build());
   }
 
+  @Override
+  protected TypeSpec optionalFactoryClass(Optional<Kind> optionalValueKind) {
+    return parent.optionalFactoryClass(optionalValueKind);
+  }
+
   private void writeSubcomponentWithoutBuilder(
       MethodSpec.Builder componentMethod, ExecutableType resolvedMethod) {
     ImmutableList.Builder<CodeBlock> subcomponentConstructorParameters = ImmutableList.builder();
diff --git a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
index 939f15ff1..1e3cb30ba 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
@@ -16,12 +16,14 @@
 
 package dagger.internal.codegen;
 
+import com.google.common.base.Optional;
 import com.google.common.util.concurrent.AsyncFunction;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.ParameterizedTypeName;
 import com.squareup.javapoet.TypeName;
+import dagger.Lazy;
 import dagger.MembersInjector;
 import dagger.internal.DelegateFactory;
 import dagger.internal.DoubleCheck;
@@ -61,6 +63,7 @@
   static final ClassName FUTURES = ClassName.get(Futures.class);
   static final ClassName ILLEGAL_STATE_EXCEPTION = ClassName.get(IllegalStateException.class);
   static final ClassName INSTANCE_FACTORY = ClassName.get(InstanceFactory.class);
+  static final ClassName LAZY = ClassName.get(Lazy.class);
   static final ClassName LIST = ClassName.get(List.class);
   static final ClassName LISTENABLE_FUTURE = ClassName.get(ListenableFuture.class);
   static final ClassName MAP_FACTORY = ClassName.get(MapFactory.class);
@@ -70,6 +73,7 @@
   static final ClassName MAP_PROVIDER_FACTORY = ClassName.get(MapProviderFactory.class);
   static final ClassName MEMBERS_INJECTOR = ClassName.get(MembersInjector.class);
   static final ClassName MEMBERS_INJECTORS = ClassName.get(MembersInjectors.class);
+  static final ClassName OPTIONAL = ClassName.get(Optional.class);
   static final ClassName PRODUCER_TOKEN = ClassName.get(ProducerToken.class);
   static final ClassName PRODUCED = ClassName.get(Produced.class);
   static final ClassName PRODUCER = ClassName.get(Producer.class);
@@ -94,36 +98,48 @@
   static final TypeName SET_OF_FACTORIES =
       ParameterizedTypeName.get(Set.class, ProductionComponentMonitor.Factory.class);
 
+  static ParameterizedTypeName abstractProducerOf(TypeName typeName) {
+    return ParameterizedTypeName.get(ABSTRACT_PRODUCER, typeName);
+  }
+
+  static ParameterizedTypeName factoryOf(TypeName factoryType) {
+    return ParameterizedTypeName.get(FACTORY, factoryType);
+  }
+
+  static ParameterizedTypeName lazyOf(TypeName typeName) {
+    return ParameterizedTypeName.get(LAZY, typeName);
+  }
+
   static ParameterizedTypeName listOf(TypeName typeName) {
     return ParameterizedTypeName.get(LIST, typeName);
   }
 
-  static ParameterizedTypeName setOf(TypeName elementType) {
-    return ParameterizedTypeName.get(SET, elementType);
+  static ParameterizedTypeName listenableFutureOf(TypeName typeName) {
+    return ParameterizedTypeName.get(LISTENABLE_FUTURE, typeName);
   }
 
-  static ParameterizedTypeName abstractProducerOf(TypeName typeName) {
-    return ParameterizedTypeName.get(ABSTRACT_PRODUCER, typeName);
+  static ParameterizedTypeName membersInjectorOf(TypeName membersInjectorType) {
+    return ParameterizedTypeName.get(MEMBERS_INJECTOR, membersInjectorType);
+  }
+
+  static ParameterizedTypeName optionalOf(TypeName type) {
+    return ParameterizedTypeName.get(OPTIONAL, type);
   }
 
   static ParameterizedTypeName producedOf(TypeName typeName) {
     return ParameterizedTypeName.get(PRODUCED, typeName);
   }
 
-  static ParameterizedTypeName listenableFutureOf(TypeName typeName) {
-    return ParameterizedTypeName.get(LISTENABLE_FUTURE, typeName);
+  static ParameterizedTypeName producerOf(TypeName typeName) {
+    return ParameterizedTypeName.get(PRODUCER, typeName);
   }
 
   static ParameterizedTypeName providerOf(TypeName typeName) {
     return ParameterizedTypeName.get(PROVIDER, typeName);
   }
 
-  static ParameterizedTypeName membersInjectorOf(TypeName membersInjectorType) {
-    return ParameterizedTypeName.get(MEMBERS_INJECTOR, membersInjectorType);
-  }
-
-  static ParameterizedTypeName factoryOf(TypeName factoryType) {
-    return ParameterizedTypeName.get(FACTORY, factoryType);
+  static ParameterizedTypeName setOf(TypeName elementType) {
+    return ParameterizedTypeName.get(SET, elementType);
   }
 
   private TypeNames() {}
diff --git a/compiler/src/test/java/dagger/internal/codegen/BindsOptionalOfMethodValidatorTest.java b/compiler/src/test/java/dagger/internal/codegen/BindsOptionalOfMethodValidatorTest.java
new file mode 100644
index 000000000..9f48dd308
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/BindsOptionalOfMethodValidatorTest.java
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatMethodInUnannotatedClass;
+import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatModuleMethod;
+
+import com.google.common.collect.ImmutableList;
+import dagger.Module;
+import dagger.producers.ProducerModule;
+import java.lang.annotation.Annotation;
+import java.util.Collection;
+import javax.inject.Inject;
+import javax.inject.Qualifier;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
+/** Tests {@link BindsOptionalOfMethodValidator}. */
+@RunWith(Parameterized.class)
+public class BindsOptionalOfMethodValidatorTest {
+  @Parameters(name = "{0}")
+  public static Collection<Object[]> data() {
+    return ImmutableList.copyOf(new Object[][] {{Module.class}, {ProducerModule.class}});
+  }
+
+  private final String moduleDeclaration;
+
+  public BindsOptionalOfMethodValidatorTest(Class<? extends Annotation> moduleAnnotation) {
+    moduleDeclaration = "@" + moduleAnnotation.getCanonicalName() + " abstract class %s { %s }";
+  }
+
+  @Test
+  public void nonAbstract() {
+    assertThatMethod("@BindsOptionalOf Object concrete() { return null; }")
+        .hasError("must be abstract");
+  }
+
+  @Test
+  public void hasParameters() {
+    assertThatMethod("@BindsOptionalOf abstract Object hasParameters(String s1);")
+        .hasError("parameters");
+  }
+
+  @Test
+  public void typeParameters() {
+    assertThatMethod("@BindsOptionalOf abstract <S> S generic();").hasError("type parameters");
+  }
+
+  @Test
+  public void notInModule() {
+    assertThatMethodInUnannotatedClass("@BindsOptionalOf abstract Object notInModule();")
+        .hasError("within a @Module or @ProducerModule");
+  }
+
+  @Test
+  public void throwsException() {
+    assertThatMethod("@BindsOptionalOf abstract Object throwsException() throws RuntimeException;")
+        .hasError("may not throw");
+  }
+
+  @Test
+  public void returnsVoid() {
+    assertThatMethod("@BindsOptionalOf abstract void returnsVoid();").hasError("void");
+  }
+
+  @Test
+  public void returnsMembersInjector() {
+    assertThatMethod("@BindsOptionalOf abstract MembersInjector<Object> returnsMembersInjector();")
+        .hasError("framework");
+  }
+
+  @Test
+  public void tooManyQualifiers() {
+    assertThatMethod(
+            "@BindsOptionalOf @Qualifier1 @Qualifier2 abstract String tooManyQualifiers();")
+        .importing(Qualifier1.class, Qualifier2.class)
+        .hasError("more than one @Qualifier");
+  }
+
+  @Test
+  public void intoSet() {
+    assertThatMethod("@BindsOptionalOf @IntoSet abstract String intoSet();")
+        .hasError("Multibinding annotations");
+  }
+
+  @Test
+  public void elementsIntoSet() {
+    assertThatMethod("@BindsOptionalOf @ElementsIntoSet abstract Set<String> elementsIntoSet();")
+        .hasError("Multibinding annotations");
+  }
+
+  @Test
+  public void intoMap() {
+    assertThatMethod("@BindsOptionalOf @IntoMap abstract String intoMap();")
+        .hasError("Multibinding annotations");
+  }
+
+  /** An injectable value object. */
+  public static final class Thing {
+    @Inject
+    Thing() {}
+  }
+
+  @Test
+  public void implicitlyProvidedType() {
+    assertThatMethod("@BindsOptionalOf abstract Thing thing();")
+        .importing(Thing.class)
+        .hasError("return unqualified types that have an @Inject-annotated constructor");
+  }
+
+  private DaggerModuleMethodSubject assertThatMethod(String method) {
+    return assertThatModuleMethod(method).withDeclaration(moduleDeclaration);
+  }
+
+  /** A qualifier. */
+  @Qualifier
+  public @interface Qualifier1 {}
+
+  /** A qualifier. */
+  @Qualifier
+  public @interface Qualifier2 {}
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index 701f56d64..ba1e626f8 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -1424,6 +1424,190 @@ public void bindsMissingRightHandSide() {
         .compilesWithoutError();
   }
 
+  @Test
+  public void nullCheckForOptionalInstance() {
+    JavaFileObject a =
+        JavaFileObjects.forSourceLines(
+            "test.A",
+            "package test;",
+            "",
+            "import com.google.common.base.Optional;",
+            "import javax.inject.Inject;",
+            "",
+            "final class A {",
+            "  @Inject A(Optional<String> optional) {}",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.BindsOptionalOf;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "",
+            "@dagger.Module",
+            "abstract class TestModule {",
+            "  @Nullable @Provides static String provideString() { return null; }",
+            "  @BindsOptionalOf abstract String optionalString();",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  A a();",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(NULLABLE, a, module, component))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            nullableToNonNullable(
+                "java.lang.String",
+                "@test.Nullable @Provides String test.TestModule.provideString()"));
+  }
+
+  @Test
+  public void nullCheckForOptionalProvider() {
+    JavaFileObject a =
+        JavaFileObjects.forSourceLines(
+            "test.A",
+            "package test;",
+            "",
+            "import com.google.common.base.Optional;",
+            "import javax.inject.Inject;",
+            "import javax.inject.Provider;",
+            "",
+            "final class A {",
+            "  @Inject A(Optional<Provider<String>> optional) {}",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.BindsOptionalOf;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "",
+            "@dagger.Module",
+            "abstract class TestModule {",
+            "  @Nullable @Provides static String provideString() { return null; }",
+            "  @BindsOptionalOf abstract String optionalString();",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  A a();",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(NULLABLE, a, module, component))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+
+  @Test
+  public void nullCheckForOptionalLazy() {
+    JavaFileObject a =
+        JavaFileObjects.forSourceLines(
+            "test.A",
+            "package test;",
+            "",
+            "import com.google.common.base.Optional;",
+            "import dagger.Lazy;",
+            "import javax.inject.Inject;",
+            "",
+            "final class A {",
+            "  @Inject A(Optional<Lazy<String>> optional) {}",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.BindsOptionalOf;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "",
+            "@dagger.Module",
+            "abstract class TestModule {",
+            "  @Nullable @Provides static String provideString() { return null; }",
+            "  @BindsOptionalOf abstract String optionalString();",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  A a();",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(NULLABLE, a, module, component))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+
+  @Test
+  public void nullCheckForOptionalProviderOfLazy() {
+    JavaFileObject a =
+        JavaFileObjects.forSourceLines(
+            "test.A",
+            "package test;",
+            "",
+            "import com.google.common.base.Optional;",
+            "import dagger.Lazy;",
+            "import javax.inject.Inject;",
+            "import javax.inject.Provider;",
+            "",
+            "final class A {",
+            "  @Inject A(Optional<Provider<Lazy<String>>> optional) {}",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.BindsOptionalOf;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "",
+            "@dagger.Module",
+            "abstract class TestModule {",
+            "  @Nullable @Provides static String provideString() { return null; }",
+            "  @BindsOptionalOf abstract String optionalString();",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  A a();",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(NULLABLE, a, module, component))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+
   @Test public void componentDependencyMustNotCycle_Direct() {
     JavaFileObject shortLifetime = JavaFileObjects.forSourceLines("test.ComponentShort",
         "package test;",
diff --git a/core/src/main/java/dagger/BindsOptionalOf.java b/core/src/main/java/dagger/BindsOptionalOf.java
new file mode 100644
index 000000000..481453615
--- /dev/null
+++ b/core/src/main/java/dagger/BindsOptionalOf.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+import dagger.internal.Beta;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Target;
+import javax.inject.Inject;
+import javax.inject.Provider;
+import javax.inject.Qualifier;
+
+/**
+ * Annotates methods that declare bindings for {@code com.google.common.base.Optional} containers of
+ * values from bindings that may or may not be present in the component.
+ *
+ * <p>If a module contains a method declaration like this:
+ *
+ * <pre>
+ * {@literal @BindsOptionalOf} abstract Foo optionalFoo();</pre>
+ *
+ * then any binding in the component can depend on an {@code Optional} of {@code Foo}. If there is
+ * no binding for {@code Foo} in the component, the {@code Optional} will be absent. If there is a
+ * binding for {@code Foo} in the component, the {@code Optional} will be present, and its value
+ * will be the value given by the binding for {@code Foo}.
+ *
+ * <p>A {@code @BindsOptionalOf} method:
+ *
+ * <ul>
+ * <li>must be {@code abstract}
+ * <li>may have a {@linkplain Qualifier qualifier} annotation
+ * <li>must not return {@code void}
+ * <li>must not have parameters
+ * <li>must not throw exceptions
+ * <li>must not return an unqualified type with an {@link Inject @Inject}-annotated constructor,
+ *     since such a type is always present
+ * </ul>
+ *
+ * <p>Other bindings may inject any of:
+ *
+ * <ul>
+ * <li>{@code Optional<Foo>}
+ * <li>{@code Optional<Provider<Foo>>}
+ * <li>{@code Optional<Lazy<Foo>>}
+ * <li>{@code Optional<Provider<Lazy<Foo>>>}
+ * </ul>
+ *
+ * or a {@link Provider}, {@link Lazy}, or {@link Provider} of {@link Lazy} of any of the above.
+ *
+ * <p>Explicit bindings for any of the above will conflict with a {@code @BindsOptionalOf} binding.
+ */
+@Documented
+@Beta
+@Target(METHOD)
+public @interface BindsOptionalOf {}
