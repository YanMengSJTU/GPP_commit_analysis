diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 9ec404d94..de754ba2b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -44,6 +44,7 @@
 import javax.lang.model.util.Types;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentProvisionMethod;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
@@ -62,10 +63,10 @@
   abstract ComponentDescriptor componentDescriptor();
   abstract ImmutableSet<DependencyRequest> entryPoints();
   abstract ImmutableMap<TypeElement, ImmutableSet<TypeElement>> transitiveModules();
-  abstract ImmutableMap<Key, ResolvedBindings> resolvedBindings();
+  abstract ImmutableMap<FrameworkKey, ResolvedBindings> resolvedBindings();
 
   @AutoValue
-  static abstract class ResolvedBindings {
+  abstract static class ResolvedBindings {
     enum State {
       COMPLETE,
       INCOMPLETE,
@@ -76,8 +77,45 @@
       MISSING,
     }
 
+    abstract FrameworkKey.Kind kind();
     abstract State state();
-    abstract ImmutableSet<? extends Binding> bindings();
+    abstract ImmutableSet<ProvisionBinding> internalProvisionBindings();
+    abstract ImmutableSet<MembersInjectionBinding> internalMembersInjectionBindings();
+
+    static ResolvedBindings createForProvisionBindings(
+        State state, ImmutableSet<ProvisionBinding> provisionBindings) {
+      return new AutoValue_BindingGraph_ResolvedBindings(
+          FrameworkKey.Kind.PROVIDER, state, provisionBindings,
+          ImmutableSet.<MembersInjectionBinding>of());
+    }
+
+    static ResolvedBindings createForMembersInjectionBindings(
+        State state, ImmutableSet<MembersInjectionBinding> membersInjectionBindings) {
+      return new AutoValue_BindingGraph_ResolvedBindings(
+          FrameworkKey.Kind.MEMBERS_INJECTOR, state, ImmutableSet.<ProvisionBinding>of(),
+          membersInjectionBindings);
+    }
+
+    ImmutableSet<? extends Binding> bindings() {
+      switch (kind()) {
+        case PROVIDER:
+          return internalProvisionBindings();
+        case MEMBERS_INJECTOR:
+          return internalMembersInjectionBindings();
+        default:
+          throw new AssertionError();
+      }
+    }
+
+    ImmutableSet<ProvisionBinding> provisionBindings() {
+      checkState(kind() == FrameworkKey.Kind.PROVIDER);
+      return internalProvisionBindings();
+    }
+
+    ImmutableSet<MembersInjectionBinding> membersInjectionBindings() {
+      checkState(kind() == FrameworkKey.Kind.MEMBERS_INJECTOR);
+      return internalMembersInjectionBindings();
+    }
   }
 
   static final class Factory {
@@ -200,8 +238,8 @@ private boolean isComponentMembersInjectionMethod(ExecutableElement method) {
 
     private final class RequestResolver {
       final ImmutableSetMultimap<Key, ProvisionBinding> explicitBindings;
-      final Map<Key, ResolvedBindings> resolvedBindings;
-      final Deque<Key> cycleStack = Queues.newArrayDeque();
+      final Map<FrameworkKey, ResolvedBindings> resolvedBindings;
+      final Deque<FrameworkKey> cycleStack = Queues.newArrayDeque();
 
       RequestResolver(ImmutableSetMultimap<Key, ProvisionBinding> explicitBindings) {
         assert explicitBindings != null;
@@ -211,19 +249,20 @@ private boolean isComponentMembersInjectionMethod(ExecutableElement method) {
 
       State resolve(DependencyRequest request) {
         Key requestKey = request.key();
+        FrameworkKey frameworkKey = FrameworkKey.forDependencyRequest(request);
 
-        ResolvedBindings previouslyResolvedBinding = resolvedBindings.get(requestKey);
+        ResolvedBindings previouslyResolvedBinding = resolvedBindings.get(frameworkKey);
         if (previouslyResolvedBinding != null) {
           return previouslyResolvedBinding.state();
         }
 
-        if (cycleStack.contains(requestKey)) {
+        if (cycleStack.contains(frameworkKey)) {
           // return malformed, but don't add a resolved binding.
           // the original request will add it with all of the other resolved deps
           return State.CYCLE;
         }
 
-        cycleStack.push(requestKey);
+        cycleStack.push(frameworkKey);
         try {
           switch (request.kind()) {
             case INSTANCE:
@@ -242,8 +281,8 @@ State resolve(DependencyRequest request) {
                   ProvisionBinding implicitBinding =
                       provisionBindingFactory.forImplicitMapBinding(request, implicitRequest);
                   State implicitState = resolve(implicitRequest);
-                  resolvedBindings.put(requestKey,
-                      new AutoValue_BindingGraph_ResolvedBindings(
+                  resolvedBindings.put(frameworkKey,
+                      ResolvedBindings.createForProvisionBindings(
                           implicitState.equals(State.COMPLETE) ? State.COMPLETE : State.INCOMPLETE,
                           ImmutableSet.of(implicitBinding)));
                   return State.COMPLETE;
@@ -255,16 +294,16 @@ State resolve(DependencyRequest request) {
                     // found a binding, resolve its deps and then mark it resolved
                     State bindingState =
                         resolveDependencies(provisionBinding.get().implicitDependencies());
-                    resolvedBindings.put(requestKey,
-                        new AutoValue_BindingGraph_ResolvedBindings(
+                    resolvedBindings.put(frameworkKey,
+                        ResolvedBindings.createForProvisionBindings(
                             bindingState,
                             ImmutableSet.copyOf(provisionBinding.asSet())));
                     return bindingState;
                   } else {
                     // no explicit binding, no inject binding.  it's missing
-                    resolvedBindings.put(requestKey,
-                        new AutoValue_BindingGraph_ResolvedBindings(
-                            State.MISSING, ImmutableSet.<Binding>of()));
+                    resolvedBindings.put(frameworkKey,
+                        ResolvedBindings.createForProvisionBindings(
+                            State.MISSING, ImmutableSet.<ProvisionBinding>of()));
                     return State.MISSING;
                   }
                 }
@@ -295,21 +334,21 @@ State resolve(DependencyRequest request) {
                   ImmutableListMultimap<BindingType, ProvisionBinding> bindingsByType =
                       ProvisionBinding.bindingTypesFor(explicitBindingsForKey);
                   if (bindingsByType.keySet().size() > 1) {
-                    resolvedBindings.put(requestKey,
-                        new AutoValue_BindingGraph_ResolvedBindings(
+                    resolvedBindings.put(frameworkKey,
+                        ResolvedBindings.createForProvisionBindings(
                             State.MULTIPLE_BINDING_TYPES,
                             explicitBindingsForKey));
                     return State.MULTIPLE_BINDING_TYPES;
                   } else if (getOnlyElement(bindingsByType.keySet()).equals(BindingType.UNIQUE)) {
-                    resolvedBindings.put(requestKey,
-                        new AutoValue_BindingGraph_ResolvedBindings(
+                    resolvedBindings.put(frameworkKey,
+                        ResolvedBindings.createForProvisionBindings(
                             State.DUPLICATE_BINDINGS,
                             explicitBindingsForKey));
                     return State.DUPLICATE_BINDINGS;
                   }
                 }
-                resolvedBindings.put(requestKey,
-                    new AutoValue_BindingGraph_ResolvedBindings(
+                resolvedBindings.put(frameworkKey,
+                    ResolvedBindings.createForProvisionBindings(
                         bindingState, explicitBindingsForKey));
                 return bindingState;
               }
@@ -321,8 +360,8 @@ State resolve(DependencyRequest request) {
                 // found a binding, resolve its deps and then mark it resolved
                 State bindingState =
                     resolveDependencies(membersInjectionBinding.get().implicitDependencies());
-                resolvedBindings.put(requestKey,
-                    new AutoValue_BindingGraph_ResolvedBindings(
+                resolvedBindings.put(frameworkKey,
+                    ResolvedBindings.createForMembersInjectionBindings(
                         bindingState,
                         ImmutableSet.copyOf(membersInjectionBinding.asSet())));
                 return bindingState;
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index e0f025a23..d63c12989 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -49,12 +49,13 @@
   public ValidationReport<BindingGraph> validate(final BindingGraph subject) {
     final ValidationReport.Builder<BindingGraph> reportBuilder =
         ValidationReport.Builder.about(subject);
-    ImmutableMap<Key, ResolvedBindings> resolvedBindings = subject.resolvedBindings();
+    ImmutableMap<FrameworkKey, ResolvedBindings> resolvedBindings = subject.resolvedBindings();
 
     validateComponentScope(subject, reportBuilder, resolvedBindings);
 
     for (DependencyRequest entryPoint : subject.entryPoints()) {
-      ResolvedBindings resolvedBinding = resolvedBindings.get(entryPoint.key());
+      ResolvedBindings resolvedBinding = resolvedBindings.get(
+          FrameworkKey.forDependencyRequest(entryPoint));
       if (!resolvedBinding.state().equals(State.COMPLETE)) {
         LinkedList<DependencyRequest> requestPath = Lists.newLinkedList();
         requestPath.push(entryPoint);
@@ -97,14 +98,13 @@ boolean visitResolvedBinding(
    */
   void validateComponentScope(final BindingGraph subject,
       final ValidationReport.Builder<BindingGraph> reportBuilder,
-      ImmutableMap<Key, ResolvedBindings> resolvedBindings) {
+      ImmutableMap<FrameworkKey, ResolvedBindings> resolvedBindings) {
     Optional<Equivalence.Wrapper<AnnotationMirror>> componentScope =
         subject.componentDescriptor().wrappedScope();
     ImmutableSet.Builder<String> incompatiblyScopedMethodsBuilder = ImmutableSet.builder();
     for (ResolvedBindings bindings : resolvedBindings.values()) {
-      for (Binding binding : bindings.bindings()) {
-        if (binding instanceof ProvisionBinding) {
-          ProvisionBinding provisionBinding = (ProvisionBinding) binding;
+      if (bindings.kind().equals(FrameworkKey.Kind.PROVIDER)) {
+        for (ProvisionBinding provisionBinding : bindings.provisionBindings()) {
           if (provisionBinding.scope().isPresent()
               && !componentScope.equals(provisionBinding.wrappedScope())) {
             // Scoped components cannot reference bindings to @Provides methods or @Inject
@@ -285,7 +285,8 @@ boolean visitResolvedBinding(Deque<DependencyRequest> requestPath, ResolvedBindi
 
   private void traversalHelper(BindingGraph graph, Deque<DependencyRequest> requestPath,
       Traverser traverser) {
-    ResolvedBindings resolvedBinding = graph.resolvedBindings().get(requestPath.peek().key());
+    ResolvedBindings resolvedBinding = graph.resolvedBindings().get(
+        FrameworkKey.forDependencyRequest(requestPath.peek()));
     ImmutableSet<DependencyRequest> allDeps =
         FluentIterable.from(resolvedBinding.bindings())
             .transformAndConcat(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index d4c8fd100..62091e02b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -48,7 +48,6 @@
 import dagger.internal.codegen.writer.FieldWriter;
 import dagger.internal.codegen.writer.JavaWriter;
 import dagger.internal.codegen.writer.MethodWriter;
-import dagger.internal.codegen.writer.ParameterizedTypeName;
 import dagger.internal.codegen.writer.Snippet;
 import dagger.internal.codegen.writer.StringLiteral;
 import dagger.internal.codegen.writer.TypeName;
@@ -159,7 +158,8 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
     builderFactoryMethod.addModifiers(PUBLIC, STATIC);
     builderFactoryMethod.body().addSnippet("return new %s();", builderWriter.name());
 
-    ImmutableMap<Key, String> frameworkTypeNames = generateFrameworkTypeNames(input);
+    ImmutableMap<FrameworkKey, String> frameworkTypeNames =
+        generateFrameworkTypeNames(input);
 
     // the full set of types that calling code uses to construct a component instance
     ImmutableMap<TypeElement, String> componentContributionNames =
@@ -224,30 +224,31 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
       }
     }
 
-    ImmutableMap.Builder<Key, Snippet> memberSelectSnippetsBuilder =
+    ImmutableMap.Builder<FrameworkKey, Snippet> memberSelectSnippetsBuilder =
         ImmutableMap.builder();
 
     ImmutableSet.Builder<JavaWriter> proxyWriters = ImmutableSet.builder();
     Map<String, ProxyClassAndField> packageProxies = Maps.newHashMap();
 
-    for (Entry<Key, ResolvedBindings> resolvedBindingsEntry : input.resolvedBindings().entrySet()) {
-      Key key = resolvedBindingsEntry.getKey();
-
-      ImmutableSet<? extends Binding> bindings = resolvedBindingsEntry.getValue().bindings();
-      if (bindings.size() == 1) {
-        Binding onlyBinding = bindings.iterator().next();
-        if (onlyBinding instanceof ProvisionBinding) {
-          ProvisionBinding provisionBinding = ((ProvisionBinding) onlyBinding);
-          if (provisionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
-              && !provisionBinding.scope().isPresent()) {
-            // skip keys whose factories are enum instances and aren't scoped
-            memberSelectSnippetsBuilder.put(key, Snippet.format("%s.INSTANCE",
-                factoryNameForProvisionBinding(provisionBinding)));
-            continue;
-          }
+    for (Entry<FrameworkKey, ResolvedBindings> resolvedBindingsEntry :
+        input.resolvedBindings().entrySet()) {
+      FrameworkKey frameworkKey = resolvedBindingsEntry.getKey();
+      ResolvedBindings resolvedBindings = resolvedBindingsEntry.getValue();
+
+      if (resolvedBindings.bindings().size() == 1
+          && frameworkKey.kind().equals(FrameworkKey.Kind.PROVIDER)) {
+        ProvisionBinding provisionBinding =
+            Iterables.getOnlyElement(resolvedBindings.provisionBindings());
+        if (provisionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
+            && !provisionBinding.scope().isPresent()) {
+          // skip keys whose factories are enum instances and aren't scoped
+          memberSelectSnippetsBuilder.put(frameworkKey, Snippet.format("%s.INSTANCE",
+              factoryNameForProvisionBinding(provisionBinding)));
+          continue;
         }
       }
 
+      ImmutableSet<? extends Binding> bindings = resolvedBindings.bindings();
       ImmutableSet.Builder<String> bindingPackagesBuilder = ImmutableSet.builder();
       for (Binding binding : bindings) {
         bindingPackagesBuilder.addAll(binding.bindingPackage().asSet());
@@ -305,11 +306,8 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
         fieldModifiers = EnumSet.of(PUBLIC);
       }
 
-      TypeName frameworkTypeName = ParameterizedTypeName.create(
-          ClassName.fromClass(key.kind().frameworkClass()),
-          TypeNames.forTypeMirror(key.type()));
-
-      String fieldName = frameworkTypeNames.get(key);
+      String fieldName = frameworkTypeNames.get(frameworkKey);
+      TypeName frameworkTypeName = frameworkKey.frameworkType();
 
       FieldWriter frameworkField = classWithFields.addField(frameworkTypeName, fieldName);
       frameworkField.addModifiers(fieldModifiers);
@@ -318,7 +316,7 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
           .addAll(proxySelector.asSet())
           .add(frameworkField.name())
           .build();
-      memberSelectSnippetsBuilder.put(key,
+      memberSelectSnippetsBuilder.put(frameworkKey,
           Snippet.memberSelectSnippet(memberSelectTokens));
     }
 
@@ -331,9 +329,10 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
       factoryMethod.body().addSnippet("return builder().build();");
     }
 
-    ImmutableMap<Key, Snippet> memberSelectSnippets = memberSelectSnippetsBuilder.build();
+    ImmutableMap<FrameworkKey, Snippet> memberSelectSnippets = memberSelectSnippetsBuilder.build();
 
-    List<List<Key>> partitions = Lists.partition(input.resolvedBindings().keySet().asList(), 100);
+    List<List<FrameworkKey>> partitions = Lists.partition(
+        input.resolvedBindings().keySet().asList(), 100);
     for (int i = 0; i < partitions.size(); i++) {
       MethodWriter initializeMethod =
           componentWriter.addMethod(VoidName.VOID, "initialize" + ((i == 0) ? "" : i));
@@ -341,13 +340,12 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
       initializeMethod.addModifiers(PRIVATE);
       constructorWriter.body().addSnippet("%s();", initializeMethod.name());
 
-      for (Key key : partitions.get(i)) {
-        Snippet memberSelectSnippet = memberSelectSnippets.get(key);
-        switch (key.kind()) {
+      for (FrameworkKey frameworkKey : partitions.get(i)) {
+        Snippet memberSelectSnippet = memberSelectSnippets.get(frameworkKey);
+        switch (frameworkKey.kind()) {
           case PROVIDER:
-            @SuppressWarnings("unchecked")
             Set<ProvisionBinding> bindings =
-                (Set<ProvisionBinding>) input.resolvedBindings().get(key).bindings();
+                input.resolvedBindings().get(frameworkKey).provisionBindings();
             BindingType bindingsType = ProvisionBinding.bindingTypeFor(bindings);
             switch (bindingsType) {
               case SET:
@@ -390,8 +388,8 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
             }
             break;
           case MEMBERS_INJECTOR:
-            MembersInjectionBinding binding = (MembersInjectionBinding) Iterables.getOnlyElement(
-                input.resolvedBindings().get(key).bindings());
+            MembersInjectionBinding binding = Iterables.getOnlyElement(
+                input.resolvedBindings().get(frameworkKey).membersInjectionBindings());
             initializeMethod.body().addSnippet("this.%s = %s;",
                 memberSelectSnippet,
                 initializeMembersInjectorForBinding(binding, memberSelectSnippets));
@@ -416,9 +414,9 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
                     requestElement.getSimpleName().toString());
             interfaceMethod.annotate(Override.class);
             interfaceMethod.addModifiers(PUBLIC);
-            Key key = interfaceRequest.key();
+            FrameworkKey frameworkKey = FrameworkKey.forDependencyRequest(interfaceRequest);
             if (interfaceRequest.kind().equals(MEMBERS_INJECTOR)) {
-              Snippet membersInjectorName = memberSelectSnippets.get(key);
+              Snippet membersInjectorName = memberSelectSnippets.get(frameworkKey);
               VariableElement parameter = Iterables.getOnlyElement(requestElement.getParameters());
               Name parameterName = parameter.getSimpleName();
               interfaceMethod.addParameter(
@@ -430,7 +428,7 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
               }
             } else {
               interfaceMethod.body().addSnippet("return %s;",
-                  frameworkTypeUsageStatement(memberSelectSnippets.get(key),
+                  frameworkTypeUsageStatement(memberSelectSnippets.get(frameworkKey),
                       interfaceRequest.kind()));
             }
       }
@@ -442,28 +440,27 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
         .build();
   }
 
-  private ImmutableMap<Key, String> generateFrameworkTypeNames(BindingGraph graph) {
-    ImmutableMap.Builder<Key, String> names = ImmutableMap.builder();
-    for (Entry<Key, ResolvedBindings> entry : graph.resolvedBindings().entrySet()) {
-      Key key = entry.getKey();
-      switch (key.kind()) {
+  private ImmutableMap<FrameworkKey, String> generateFrameworkTypeNames(BindingGraph graph) {
+    ImmutableMap.Builder<FrameworkKey, String> names = ImmutableMap.builder();
+    for (Entry<FrameworkKey, ResolvedBindings> entry : graph.resolvedBindings().entrySet()) {
+      FrameworkKey frameworkKey = entry.getKey();
+      switch (frameworkKey.kind()) {
         case PROVIDER:
-          @SuppressWarnings("unchecked")
           ImmutableSet<ProvisionBinding> bindingsForKey =
-              (ImmutableSet<ProvisionBinding>) entry.getValue().bindings();
+              entry.getValue().provisionBindings();
           BindingType bindingsType = ProvisionBinding.bindingTypeFor(bindingsForKey);
           switch (bindingsType) {
             case SET:
-              names.put(key,
-                  new KeyVariableNamer().apply(key) + "Provider");
+              names.put(frameworkKey,
+                  new KeyVariableNamer().apply(frameworkKey.key()) + "Provider");
               break;
             case MAP:
-              names.put(key,
-                  new KeyVariableNamer().apply(key) + "Provider");
+              names.put(frameworkKey,
+                  new KeyVariableNamer().apply(frameworkKey.key()) + "Provider");
               break;
             case UNIQUE:
               ProvisionBinding binding = Iterables.getOnlyElement(bindingsForKey);
-              names.put(key,
+              names.put(frameworkKey,
                   binding.bindingElement().accept(new ElementKindVisitor6<String, Void>() {
                     @Override
                     public String visitExecutableAsConstructor(ExecutableElement e, Void p) {
@@ -487,7 +484,7 @@ public String visitType(TypeElement e, Void p) {
           }
           break;
         case MEMBERS_INJECTOR:
-          names.put(key, CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL,
+          names.put(frameworkKey, CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL,
               Iterables.getOnlyElement(entry.getValue().bindings())
                   .bindingElement().getSimpleName().toString()) + "MembersInjector");
           break;
@@ -501,7 +498,7 @@ public String visitType(TypeElement e, Void p) {
   private Snippet initializeFactoryForBinding(ProvisionBinding binding,
       ImmutableMap<ExecutableElement, TypeElement> dependencyMethodIndex,
       Map<TypeElement, FieldWriter> contributionFields,
-      ImmutableMap<Key, Snippet> memberSelectSnippets) {
+      ImmutableMap<FrameworkKey, Snippet> memberSelectSnippets) {
     if (binding.bindingKind().equals(COMPONENT)) {
       return Snippet.format("%s.<%s>create(this)",
           ClassName.fromClass(InstanceFactory.class),
@@ -531,7 +528,8 @@ private Snippet initializeFactoryForBinding(ProvisionBinding binding,
         parameters.add(Snippet.format(contributionFields.get(binding.bindingTypeElement()).name()));
       }
       if (binding.memberInjectionRequest().isPresent()) {
-        parameters.add(memberSelectSnippets.get(binding.memberInjectionRequest().get().key()));
+        parameters.add(memberSelectSnippets.get(FrameworkKey.forDependencyRequest(
+            binding.memberInjectionRequest().get())));
       }
       parameters.addAll(getDependencyParameters(binding.dependencies(), memberSelectSnippets));
 
@@ -548,14 +546,14 @@ private Snippet initializeFactoryForBinding(ProvisionBinding binding,
 
   private static Snippet initializeMembersInjectorForBinding(
       MembersInjectionBinding binding,
-      ImmutableMap<Key, Snippet> memberSelectSnippets) {
+      ImmutableMap<FrameworkKey, Snippet> memberSelectSnippets) {
     if (binding.injectionSites().isEmpty()) {
       if (binding.parentInjectorRequest().isPresent()) {
         DependencyRequest parentInjectorRequest = binding.parentInjectorRequest().get();
         return Snippet.format("%s.delegatingTo(%s)",
             ClassName.fromClass(MembersInjectors.class),
             memberSelectSnippets.get(
-                parentInjectorRequest.key()));
+                FrameworkKey.forDependencyRequest(parentInjectorRequest)));
       } else {
         return Snippet.format("%s.noOp()",
             ClassName.fromClass(MembersInjectors.class));
@@ -571,9 +569,9 @@ private static Snippet initializeMembersInjectorForBinding(
   }
 
   private static List<Snippet> getDependencyParameters(Iterable<DependencyRequest> dependencies,
-      ImmutableMap<Key, Snippet> memberSelectSnippets) {
+      ImmutableMap<FrameworkKey, Snippet> memberSelectSnippets) {
     ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
-    for (Key dependencyKey : SourceFiles.indexDependenciesByKey(dependencies).keySet()) {
+    for (FrameworkKey dependencyKey : SourceFiles.indexDependenciesByKey(dependencies).keySet()) {
       parameters.add(memberSelectSnippets.get(dependencyKey));
     }
     return parameters.build();
@@ -582,7 +580,7 @@ private static Snippet initializeMembersInjectorForBinding(
   private Snippet initializeMapBinding(
       Map<TypeElement, FieldWriter> contributionFields,
       ImmutableMap<ExecutableElement, TypeElement> dependencyMethodIndex,
-      ImmutableMap<Key, Snippet> memberSelectSnippets,
+      ImmutableMap<FrameworkKey, Snippet> memberSelectSnippets,
       Set<ProvisionBinding> bindings) {
     Iterator<ProvisionBinding> iterator = bindings.iterator();
     // get type information from first binding in iterator
@@ -590,7 +588,8 @@ private Snippet initializeMapBinding(
     if (isNonProviderMap(firstBinding)) {
       return Snippet.format("%s.create(%s)",
           ClassName.fromClass(MapFactory.class),
-          memberSelectSnippets.get(Iterables.getOnlyElement(firstBinding.dependencies()).key()));
+          memberSelectSnippets.get(FrameworkKey.forDependencyRequest(
+              Iterables.getOnlyElement(firstBinding.dependencies()))));
     } else {
       DeclaredType mapType = asDeclared(firstBinding.key().type());
       TypeMirror mapKeyType = Util.getKeyTypeOfMap(mapType);
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java b/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
index 668a2767e..aab819c32 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
@@ -45,6 +45,10 @@ public String apply(DependencyRequest dependency) {
         return variableName.endsWith("Provider") && !variableName.equals("Provider")
             ? variableName.substring(0, variableName.length() - 8)
             : variableName;
+      case MEMBERS_INJECTOR:
+        return variableName.endsWith("MembersInjector") && !variableName.equals("MembersInjector")
+            ? variableName.substring(0, variableName.length() - 15)
+            : variableName;
       default:
         throw new AssertionError();
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index d52a9c849..976ca1956 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -41,7 +41,6 @@
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
 import javax.inject.Inject;
-import javax.inject.Provider;
 import javax.lang.model.element.Element;
 import javax.lang.model.type.TypeMirror;
 
@@ -137,27 +136,12 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
           .addSnippet("this.membersInjector = membersInjector;");
     }
 
-    ImmutableMap<Key, String> names =
+    ImmutableMap<FrameworkKey, String> names =
         SourceFiles.generateFrameworkReferenceNamesForDependencies(binding.dependencies());
 
-    for (Entry<Key, String> nameEntry : names.entrySet()) {
-      final FieldWriter field;
-      switch (nameEntry.getKey().kind()) {
-        case PROVIDER:
-          ParameterizedTypeName providerType = ParameterizedTypeName.create(
-              ClassName.fromClass(Provider.class),
-              TypeNames.forTypeMirror(nameEntry.getKey().type()));
-          field = factoryWriter.addField(providerType, nameEntry.getValue());
-          break;
-        case MEMBERS_INJECTOR:
-          ParameterizedTypeName membersInjectorType = ParameterizedTypeName.create(
-              ClassName.fromClass(MembersInjector.class),
-              TypeNames.forTypeMirror(nameEntry.getKey().type()));
-          field = factoryWriter.addField(membersInjectorType, nameEntry.getValue());
-          break;
-        default:
-          throw new AssertionError();
-      }
+    for (Entry<FrameworkKey, String> nameEntry : names.entrySet()) {
+      ParameterizedTypeName fieldType = nameEntry.getKey().frameworkType();
+      FieldWriter field = factoryWriter.addField(fieldType, nameEntry.getValue());
       field.addModifiers(PRIVATE, FINAL);
       constructorWriter.get().addParameter(field.type(), field.name());
       constructorWriter.get().body()
@@ -168,7 +152,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     List<Snippet> parameters = Lists.newArrayList();
     for (DependencyRequest dependency : binding.dependencies()) {
       parameters.add(frameworkTypeUsageStatement(
-          Snippet.format(names.get(dependency.key())),
+          Snippet.format(names.get(FrameworkKey.forDependencyRequest(dependency))),
           dependency.kind()));
     }
     Snippet parametersSnippet = makeParametersSnippet(parameters);
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkKey.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkKey.java
new file mode 100644
index 000000000..aab67f59e
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkKey.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.value.AutoValue;
+import dagger.MembersInjector;
+import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.ParameterizedTypeName;
+import dagger.internal.codegen.writer.TypeNames;
+import javax.inject.Provider;
+
+/**
+ * A value object that pairs a {@link Key} with a framework class (e.g.: {@link Provider},
+ * {@link MembersInjector}) related to that key.
+ *
+ *  @author Gregory Kick
+ *  @since 2.0
+ */
+@AutoValue
+abstract class FrameworkKey {
+  /**
+   * The aspect of the framework for which a {@link Key} is an identifier. Particularly, whether a
+   * key is for a {@link Provider} or a {@link MembersInjector}.
+   */
+  enum Kind {
+    PROVIDER(Provider.class),
+    MEMBERS_INJECTOR(MembersInjector.class),
+    ;
+
+    private final Class<?> frameworkClass;
+
+    Kind(Class<?> frameworkClass) {
+      this.frameworkClass = frameworkClass;
+    }
+
+    Class<?> frameworkClass() {
+      return frameworkClass;
+    }
+  }
+
+  // TODO(user): Pass instructions for how to handle requests for instances, since producers will
+  // handle them differently.
+  static FrameworkKey forDependencyRequest(DependencyRequest request) {
+    switch (request.kind()) {
+      case INSTANCE:
+      case PROVIDER:
+      case LAZY:
+        return new AutoValue_FrameworkKey(Kind.PROVIDER, request.key());
+      case MEMBERS_INJECTOR:
+        return new AutoValue_FrameworkKey(Kind.MEMBERS_INJECTOR, request.key());
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  ParameterizedTypeName frameworkType() {
+    return ParameterizedTypeName.create(
+        ClassName.fromClass(kind().frameworkClass()), TypeNames.forTypeMirror(key().type()));
+  }
+
+  abstract Kind kind();
+  abstract Key key();
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index b05cfc62d..ed4d2b835 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -44,8 +44,6 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
-import static com.google.common.base.Verify.verify;
-import static dagger.internal.codegen.Key.Kind.PROVIDER;
 
 /**
  * Maintains the collection of provision bindings from {@link Inject} constructors and members
@@ -64,9 +62,58 @@
   private final MembersInjectionBinding.Factory membersInjectionBindingFactory;
   private final MembersInjectorGenerator membersInjectorGenerator;
 
-  private final Map<Key, Binding> bindingsByKey = Maps.newLinkedHashMap();
-  private final Deque<Binding> bindingsRequiringGeneration = Queues.newArrayDeque();
-  private final Set<Binding> materializedBindings = Sets.newLinkedHashSet();
+  final class BindingsCollection<B extends Binding> {
+    private final Map<Key, B> bindingsByKey = Maps.newLinkedHashMap();
+    private final Deque<B> bindingsRequiringGeneration = Queues.newArrayDeque();
+    private final Set<B> materializedBindings = Sets.newLinkedHashSet();
+
+    void generateBindings(SourceFileGenerator<B> generator) throws SourceFileGenerationException {
+      for (B binding = bindingsRequiringGeneration.poll();
+          binding != null;
+          binding = bindingsRequiringGeneration.poll()) {
+        generator.generate(binding);
+        materializedBindings.add(binding);
+      }
+    }
+
+    B getBinding(Key key) {
+      return bindingsByKey.get(key);
+    }
+
+    B tryMaterializeBinding(B binding) {
+      if (canRegisterBinding(binding)) {
+        materializedBindings.add(binding);
+      }
+      return binding;
+    }
+
+    B tryRegisterBinding(B binding, boolean explicit) {
+      if (canRegisterBinding(binding)) {
+        bindingsRequiringGeneration.offer(binding);
+        if (!explicit) {
+          messager.printMessage(Kind.NOTE, String.format(
+              "Generating a MembersInjector for %s. "
+                    + "Prefer to run the dagger processor over that class instead.",
+              binding.key().type()));
+        }
+      }
+      return binding;
+    }
+
+    private boolean canRegisterBinding(B binding) {
+      Key key = binding.key();
+      Binding previousValue = bindingsByKey.put(key, binding);
+      checkState(previousValue == null || binding.equals(previousValue),
+          "couldn't register %s. %s was already registered for %s",
+          binding, previousValue, key);
+      return !materializedBindings.contains(binding)
+          && !bindingsRequiringGeneration.contains(binding);
+    }
+  }
+
+  private final BindingsCollection<ProvisionBinding> provisionBindings = new BindingsCollection<>();
+  private final BindingsCollection<MembersInjectionBinding> membersInjectionBindings =
+      new BindingsCollection<>();
 
   InjectBindingRegistry(Elements elements,
       Types types,
@@ -90,68 +137,37 @@
    * {@link #getOrFindMembersInjectionBinding} or {@link #getOrFindProvisionBinding}) are generated.
    */
   void generateSourcesForRequiredBindings() throws SourceFileGenerationException {
-    for (Binding binding = bindingsRequiringGeneration.poll();
-        binding != null;
-        binding = bindingsRequiringGeneration.poll()) {
-      switch (binding.key().kind()) {
-        case PROVIDER:
-          factoryGenerator.generate((ProvisionBinding) binding);
-          break;
-        case MEMBERS_INJECTOR:
-          membersInjectorGenerator.generate((MembersInjectionBinding) binding);
-          break;
-        default:
-          throw new AssertionError();
-      }
-      materializedBindings.add(binding);
-    }
+    provisionBindings.generateBindings(factoryGenerator);
+    membersInjectionBindings.generateBindings(membersInjectorGenerator);
   }
 
-  <B extends Binding> B registerBinding(B binding) {
+  ProvisionBinding registerBinding(ProvisionBinding binding) {
     return registerBinding(binding, true);
   }
 
-  private <B extends Binding> B registerBinding(B binding, boolean explicit) {
-    Key key = binding.key();
-    Binding previousValue = bindingsByKey.put(key, binding);
-    checkState(previousValue == null || binding.equals(previousValue),
-        "couldn't register %s. %s was already registered for %s",
-        binding, previousValue, key);
-    if (!materializedBindings.contains(binding) && !bindingsRequiringGeneration.contains(binding)) {
-      switch (key.kind()) {
-        case PROVIDER:
-          ProvisionBinding provisionBinding =  (ProvisionBinding) binding;
-          ClassName factoryName = SourceFiles.factoryNameForProvisionBinding(provisionBinding);
-          if (elements.getTypeElement(factoryName.canonicalName()) == null) {
-            bindingsRequiringGeneration.offer(provisionBinding);
-            if (!explicit) {
-              messager.printMessage(Kind.NOTE, String.format("Generating a Factory for %s. "
-                  + "Prefer to run the dagger processor over that class instead.", key.type()));
-            }
-          }
-          break;
-        case MEMBERS_INJECTOR:
-          MembersInjectionBinding membersInjectionBinding = (MembersInjectionBinding) binding;
-          if (membersInjectionBinding.injectionSites().isEmpty()) {
-            // empty members injection bindings are special and don't need source files.
-            // so, we just pretend
-            materializedBindings.add(binding);
-          } else  {
-            ClassName membersInjectorName =
-                SourceFiles.membersInjectorNameForMembersInjectionBinding(membersInjectionBinding);
-            if (elements.getTypeElement(membersInjectorName.canonicalName()) == null) {
-              bindingsRequiringGeneration.offer(membersInjectionBinding);
-              if (!explicit) {
-                messager.printMessage(Kind.NOTE, String.format(
-                    "Generating a MembersInjector for %s. "
-                          + "Prefer to run the dagger processor over that class instead.",
-                    key.type()));
-              }
-            }
-          }
-          break;
-        default:
-          throw new AssertionError();
+  MembersInjectionBinding registerBinding(MembersInjectionBinding binding) {
+    return registerBinding(binding, true);
+  }
+
+  private ProvisionBinding registerBinding(ProvisionBinding binding, boolean explicit) {
+    ClassName factoryName = SourceFiles.factoryNameForProvisionBinding(binding);
+    if (elements.getTypeElement(factoryName.canonicalName()) == null) {
+      return provisionBindings.tryRegisterBinding(binding, explicit);
+    }
+    return binding;
+  }
+
+  private MembersInjectionBinding registerBinding(
+      MembersInjectionBinding binding, boolean explicit) {
+    if (binding.injectionSites().isEmpty()) {
+      // empty members injection bindings are special and don't need source files.
+      // so, we just pretend
+      return membersInjectionBindings.tryMaterializeBinding(binding);
+    } else  {
+      ClassName membersInjectorName =
+          SourceFiles.membersInjectorNameForMembersInjectionBinding(binding);
+      if (elements.getTypeElement(membersInjectorName.canonicalName()) == null) {
+        return membersInjectionBindings.tryRegisterBinding(binding, explicit);
       }
     }
     return binding;
@@ -159,14 +175,12 @@ void generateSourcesForRequiredBindings() throws SourceFileGenerationException {
 
   Optional<ProvisionBinding> getOrFindProvisionBinding(Key key) {
     checkNotNull(key);
-    checkArgument(key.kind().equals(PROVIDER));
     if (key.qualifier().isPresent()) {
       return Optional.absent();
     }
-    Binding binding = bindingsByKey.get(key);
+    ProvisionBinding binding = provisionBindings.getBinding(key);
     if (binding != null) {
-      verify(binding instanceof ProvisionBinding);
-      return Optional.of((ProvisionBinding) binding);
+      return Optional.of(binding);
     }
     // ok, let's see if we can find an @Inject constructor
     TypeElement element = MoreElements.asType(types.asElement(key.type()));
@@ -196,12 +210,11 @@ MembersInjectionBinding getOrFindMembersInjectionBinding(Key key) {
     checkNotNull(key);
     // TODO(gak): is checking the kind enough?
     checkArgument(key.isValidMembersInjectionKey());
-    Binding binding = bindingsByKey.get(key);
-    if (binding == null) {
-      TypeElement element = MoreElements.asType(types.asElement(key.type()));
-      binding = registerBinding(membersInjectionBindingFactory.forInjectedType(element), false);
+    MembersInjectionBinding binding = membersInjectionBindings.getBinding(key);
+    if (binding != null) {
+      return binding;
     }
-    verify(binding instanceof MembersInjectionBinding);
-    return (MembersInjectionBinding) binding;
+    TypeElement element = MoreElements.asType(types.asElement(key.type()));
+    return registerBinding(membersInjectionBindingFactory.forInjectedType(element), false);
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 430d66cf4..04576095b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -22,7 +22,6 @@
 import com.google.common.base.Optional;
 import com.google.common.collect.Iterables;
 import dagger.MapKey;
-import dagger.MembersInjector;
 import dagger.Provides;
 import java.util.Map;
 import java.util.Set;
@@ -57,29 +56,6 @@
  */
 @AutoValue
 abstract class Key {
-  /**
-   * The aspect of the framework for which a {@link Key} is an identifier. Particularly, whether a
-   * key is for a {@link Provider} or a {@link MembersInjector}.
-   */
-  enum Kind {
-    PROVIDER(Provider.class),
-    MEMBERS_INJECTOR(MembersInjector.class),
-    ;
-
-    private final Class<?> frameworkClass;
-
-    Kind(Class<?> frameworkClass) {
-      this.frameworkClass = frameworkClass;
-    }
-
-    Class<?> frameworkClass() {
-      return frameworkClass;
-    }
-  }
-
-  /** Returns the particular kind of this key. */
-  abstract Kind kind();
-
   /**
    * A {@link javax.inject.Qualifier} annotation that provides a unique namespace prefix
    * for the type of this key.
@@ -120,7 +96,6 @@ public Boolean visitDeclared(DeclaredType t, Void p) {
   public String toString() {
     return MoreObjects.toStringHelper(Key.class)
         .omitNullValues()
-        .addValue(kind())
         .add("qualifier", qualifier().orNull())
         .add("type", type())
         .toString();
@@ -156,7 +131,7 @@ Key forComponentMethod(ExecutableElement componentMethod) {
       checkNotNull(componentMethod);
       checkArgument(componentMethod.getKind().equals(METHOD));
       TypeMirror returnType = normalize(componentMethod.getReturnType());
-      return new AutoValue_Key(Kind.PROVIDER,
+      return new AutoValue_Key(
           wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(componentMethod)),
           MoreTypes.equivalence().wrap(returnType));
     }
@@ -169,12 +144,12 @@ Key forProvidesMethod(ExecutableElement e) {
       TypeMirror returnType = normalize(e.getReturnType());
       switch (providesAnnotation.type()) {
         case UNIQUE:
-          return new AutoValue_Key(Kind.PROVIDER,
+          return new AutoValue_Key(
               wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(e)),
               MoreTypes.equivalence().wrap(returnType));
         case SET:
           TypeMirror setType = types.getDeclaredType(getSetElement(), returnType);
-          return new AutoValue_Key(Kind.PROVIDER,
+          return new AutoValue_Key(
               wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(e)),
               MoreTypes.equivalence().wrap(setType));
         case MAP:
@@ -187,14 +162,14 @@ Key forProvidesMethod(ExecutableElement e) {
           TypeMirror valueType = types.getDeclaredType(getProviderElement(), returnType);
           TypeMirror mapType =
               types.getDeclaredType(getMapElement(), keyTypeElement.asType(), valueType);
-          return new AutoValue_Key(Kind.PROVIDER,
+          return new AutoValue_Key(
               wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(e)),
               MoreTypes.equivalence().wrap(mapType));
         case SET_VALUES:
           // TODO(gak): do we want to allow people to use "covariant return" here?
           checkArgument(returnType.getKind().equals(DECLARED));
           checkArgument(((DeclaredType) returnType).asElement().equals(getSetElement()));
-          return new AutoValue_Key(Kind.PROVIDER,
+          return new AutoValue_Key(
               wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(e)),
               MoreTypes.equivalence().wrap(returnType));
         default:
@@ -208,25 +183,25 @@ Key forInjectConstructor(ExecutableElement e) {
       checkArgument(!getQualifier(e).isPresent());
       // Must use the enclosing element.  The return type is void for constructors(?!)
       TypeMirror type = e.getEnclosingElement().asType();
-      return new AutoValue_Key(Kind.PROVIDER,
+      return new AutoValue_Key(
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           MoreTypes.equivalence().wrap(type));
     }
 
     Key forComponent(TypeMirror type) {
-      return new AutoValue_Key(Kind.PROVIDER,
+      return new AutoValue_Key(
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           MoreTypes.equivalence().wrap(normalize(type)));
     }
 
     Key forMembersInjectedType(TypeMirror type) {
-      return new AutoValue_Key(Kind.MEMBERS_INJECTOR,
+      return new AutoValue_Key(
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           MoreTypes.equivalence().wrap(normalize(type)));
     }
 
     Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
-      return new AutoValue_Key(Kind.PROVIDER,
+      return new AutoValue_Key(
           wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), qualifier),
           MoreTypes.equivalence().wrap(normalize(type)));
     }
@@ -244,7 +219,7 @@ Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
           DeclaredType keyType = Util.getKeyTypeOfMap(declaredMapType);
           DeclaredType providerType = types.getDeclaredType(getProviderElement(), mapValueType);
           TypeMirror mapType = types.getDeclaredType(getMapElement(), keyType, providerType);
-          return Optional.<Key>of(new AutoValue_Key(Kind.PROVIDER,
+          return Optional.<Key>of(new AutoValue_Key(
               possibleMapKey.wrappedQualifier(),
               MoreTypes.equivalence().wrap(mapType)));
         }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index bf3b9635a..206d483e4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -34,12 +34,10 @@
 import dagger.internal.codegen.writer.MethodWriter;
 import dagger.internal.codegen.writer.ParameterizedTypeName;
 import dagger.internal.codegen.writer.Snippet;
-import dagger.internal.codegen.writer.TypeNames;
 import dagger.internal.codegen.writer.VoidName;
 import java.util.Map.Entry;
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
-import javax.inject.Provider;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
@@ -128,44 +126,30 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
       injectMembersWriter.body().addSnippet("supertypeInjector.injectMembers(instance);");
     }
 
-    ImmutableMap<Key, String> names =
+    ImmutableMap<FrameworkKey, String> names =
         SourceFiles.generateFrameworkReferenceNamesForDependencies(
             ImmutableSet.copyOf(binding.dependencies()));
 
-    ImmutableMap.Builder<Key, FieldWriter> dependencyFieldsBuilder =
+    ImmutableMap.Builder<FrameworkKey, FieldWriter> dependencyFieldsBuilder =
         ImmutableMap.builder();
 
-    for (Entry<Key, String> nameEntry : names.entrySet()) {
-      final FieldWriter field;
-      switch (nameEntry.getKey().kind()) {
-        case PROVIDER:
-          ParameterizedTypeName providerType = ParameterizedTypeName.create(
-              ClassName.fromClass(Provider.class),
-              TypeNames.forTypeMirror(nameEntry.getKey().type()));
-          field = injectorWriter.addField(providerType, nameEntry.getValue());
-          break;
-        case MEMBERS_INJECTOR:
-          ParameterizedTypeName membersInjectorType = ParameterizedTypeName.create(
-              ClassName.fromClass(MembersInjector.class),
-              TypeNames.forTypeMirror(nameEntry.getKey().type()));
-          field = injectorWriter.addField(membersInjectorType, nameEntry.getValue());
-          break;
-        default:
-          throw new AssertionError();
-      }
+    for (Entry<FrameworkKey, String> nameEntry : names.entrySet()) {
+      ParameterizedTypeName fieldType = nameEntry.getKey().frameworkType();
+      FieldWriter field = injectorWriter.addField(fieldType, nameEntry.getValue());
       field.addModifiers(PRIVATE, FINAL);
       constructorWriter.addParameter(field.type(), field.name());
       constructorWriter.body().addSnippet("assert %s != null;", field.name());
       constructorWriter.body().addSnippet("this.%1$s = %1$s;", field.name());
       dependencyFieldsBuilder.put(nameEntry.getKey(), field);
     }
-    ImmutableMap<Key, FieldWriter> depedencyFields = dependencyFieldsBuilder.build();
+    ImmutableMap<FrameworkKey, FieldWriter> depedencyFields = dependencyFieldsBuilder.build();
     for (InjectionSite injectionSite : binding.injectionSites()) {
       switch (injectionSite.kind()) {
         case FIELD:
           DependencyRequest fieldDependency =
               Iterables.getOnlyElement(injectionSite.dependencies());
-          FieldWriter singleField = depedencyFields.get(fieldDependency.key());
+          FieldWriter singleField = depedencyFields.get(
+              FrameworkKey.forDependencyRequest(fieldDependency));
           injectMembersWriter.body().addSnippet("instance.%s = %s;",
               injectionSite.element().getSimpleName(),
               frameworkTypeUsageStatement(Snippet.format(singleField.name()),
@@ -174,8 +158,8 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
         case METHOD:
           ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
           for (DependencyRequest methodDependency : injectionSite.dependencies()) {
-            FieldWriter field =
-            depedencyFields.get(methodDependency.key());
+            FieldWriter field = depedencyFields.get(
+                FrameworkKey.forDependencyRequest(methodDependency));
             parameters.add(frameworkTypeUsageStatement(Snippet.format(field.name()),
                 methodDependency.kind()));
           }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index dfd68f090..9f55f447a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -59,13 +59,13 @@ public int compare(DependencyRequest left, DependencyRequest right) {
     }
   };
 
-  static ImmutableSetMultimap<Key, DependencyRequest> indexDependenciesByKey(
+  static ImmutableSetMultimap<FrameworkKey, DependencyRequest> indexDependenciesByKey(
       Iterable<? extends DependencyRequest> dependencies) {
-    ImmutableSetMultimap.Builder<Key, DependencyRequest> dependenciesByKeyBuilder =
-        new ImmutableSetMultimap.Builder<Key, DependencyRequest>().orderValuesBy(
+    ImmutableSetMultimap.Builder<FrameworkKey, DependencyRequest> dependenciesByKeyBuilder =
+        new ImmutableSetMultimap.Builder<FrameworkKey, DependencyRequest>().orderValuesBy(
             DEPENDENCY_ORDERING);
     for (DependencyRequest dependency : dependencies) {
-      dependenciesByKeyBuilder.put(dependency.key(), dependency);
+      dependenciesByKeyBuilder.put(FrameworkKey.forDependencyRequest(dependency), dependency);
     }
     return dependenciesByKeyBuilder.build();
   }
@@ -83,13 +83,15 @@ public int compare(DependencyRequest left, DependencyRequest right) {
    * @return Returns the mapping from {@link Key} to provider name sorted by the name of the
    *         provider.
    */
-  static ImmutableMap<Key, String> generateFrameworkReferenceNamesForDependencies(
+  static ImmutableMap<FrameworkKey, String> generateFrameworkReferenceNamesForDependencies(
       Iterable<? extends DependencyRequest> dependencies) {
-    ImmutableSetMultimap<Key, DependencyRequest> dependenciesByKey =
+    ImmutableSetMultimap<FrameworkKey, DependencyRequest> dependenciesByKey =
         indexDependenciesByKey(dependencies);
-    Map<Key, Collection<DependencyRequest>> dependenciesByKeyMap = dependenciesByKey.asMap();
-    ImmutableMap.Builder<Key, String> providerNames = ImmutableMap.builder();
-    for (Entry<Key, Collection<DependencyRequest>> entry : dependenciesByKeyMap.entrySet()) {
+    Map<FrameworkKey, Collection<DependencyRequest>> dependenciesByKeyMap =
+        dependenciesByKey.asMap();
+    ImmutableMap.Builder<FrameworkKey, String> providerNames = ImmutableMap.builder();
+    for (Entry<FrameworkKey, Collection<DependencyRequest>> entry
+        : dependenciesByKeyMap.entrySet()) {
       // collect together all of the names that we would want to call the provider
       ImmutableSet<String> dependencyNames =
           FluentIterable.from(entry.getValue()).transform(new DependencyVariableNamer()).toSet();
diff --git a/compiler/src/test/java/dagger/internal/codegen/FrameworkKeyTest.java b/compiler/src/test/java/dagger/internal/codegen/FrameworkKeyTest.java
new file mode 100644
index 000000000..472cdf0a2
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/FrameworkKeyTest.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.Iterables;
+import com.google.testing.compile.CompilationRule;
+import dagger.Lazy;
+import dagger.MembersInjector;
+import dagger.Module;
+import dagger.Provides;
+import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.ParameterizedTypeName;
+import java.util.List;
+import javax.inject.Provider;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+/**
+ * Test case for {@link FrameworkKey}.
+ */
+@RunWith(JUnit4.class)
+public class FrameworkKeyTest {
+  @Rule public CompilationRule compilationRule = new CompilationRule();
+
+  private Elements elements;
+  private Types types;
+  private Key.Factory keyFactory;
+  private DependencyRequest.Factory dependencyRequestFactory;
+
+  @Before public void setUp() {
+    this.types = compilationRule.getTypes();
+    this.elements = compilationRule.getElements();
+    this.keyFactory = new Key.Factory(types, elements);
+    this.dependencyRequestFactory = new DependencyRequest.Factory(elements, types, keyFactory);
+  }
+
+  private List<? extends VariableElement> sampleProviderParameters() {
+    TypeMirror stringType = elements.getTypeElement(String.class.getCanonicalName()).asType();
+    TypeElement moduleElement =
+        elements.getTypeElement(ProvidesMethodModule.class.getCanonicalName());
+    ExecutableElement providesMethod =
+        Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
+    return providesMethod.getParameters();
+  }
+
+  private DependencyRequest dependencyRequestForInstance() {
+    return dependencyRequestFactory.forRequiredVariable(sampleProviderParameters().get(0));
+  }
+
+  private DependencyRequest dependencyRequestForLazy() {
+    return dependencyRequestFactory.forRequiredVariable(sampleProviderParameters().get(1));
+  }
+
+  private DependencyRequest dependencyRequestForProvider() {
+    return dependencyRequestFactory.forRequiredVariable(sampleProviderParameters().get(2));
+  }
+
+  private DependencyRequest dependencyRequestForMembersInjector() {
+    return dependencyRequestFactory.forRequiredVariable(sampleProviderParameters().get(3));
+  }
+
+  @Test public void forDependencyRequest() {
+    assertThat(FrameworkKey.forDependencyRequest(dependencyRequestForInstance()).kind())
+        .isEqualTo(FrameworkKey.Kind.PROVIDER);
+    assertThat(FrameworkKey.forDependencyRequest(dependencyRequestForLazy()).kind())
+        .isEqualTo(FrameworkKey.Kind.PROVIDER);
+    assertThat(FrameworkKey.forDependencyRequest(dependencyRequestForProvider()).kind())
+        .isEqualTo(FrameworkKey.Kind.PROVIDER);
+    assertThat(FrameworkKey.forDependencyRequest(dependencyRequestForMembersInjector()).kind())
+        .isEqualTo(FrameworkKey.Kind.MEMBERS_INJECTOR);
+  }
+
+  @Test public void frameworkType() {
+    assertThat(FrameworkKey.forDependencyRequest(dependencyRequestForInstance()).frameworkType())
+        .isEqualTo(ParameterizedTypeName.create(
+            ClassName.fromClass(Provider.class), ClassName.fromClass(Integer.class)));
+    assertThat(FrameworkKey.forDependencyRequest(dependencyRequestForMembersInjector())
+        .frameworkType())
+        .isEqualTo(ParameterizedTypeName.create(
+            ClassName.fromClass(MembersInjector.class), ClassName.fromClass(Integer.class)));
+  }
+
+  @Module(library = true)
+  static final class ProvidesMethodModule {
+    @Provides String provideString(
+        Integer a, Lazy<Integer> b, Provider<Integer> c, MembersInjector<Integer> d) {
+      return null;
+    }
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
index 62ba6f402..41c3c60d1 100644
--- a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
@@ -22,7 +22,6 @@
 import com.google.testing.compile.CompilationRule;
 import dagger.Module;
 import dagger.Provides;
-import dagger.internal.codegen.Key.Kind;
 import java.util.Set;
 import javax.inject.Inject;
 import javax.inject.Qualifier;
@@ -67,7 +66,7 @@
     ExecutableElement constructor =
         Iterables.getOnlyElement(ElementFilter.constructorsIn(typeElement.getEnclosedElements()));
     assert_().that(keyFactory.forInjectConstructor(constructor))
-        .isEqualTo(new AutoValue_Key(Kind.PROVIDER,
+        .isEqualTo(new AutoValue_Key(
             Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
             MoreTypes.equivalence().wrap(typeElement.asType())));
   }
@@ -84,7 +83,7 @@
     ExecutableElement providesMethod =
         Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
     assert_().that(keyFactory.forProvidesMethod(providesMethod))
-        .isEqualTo(new AutoValue_Key(Kind.PROVIDER,
+        .isEqualTo(new AutoValue_Key(
             Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
             MoreTypes.equivalence().wrap(stringType)));
   }
@@ -157,7 +156,7 @@ String provideQualifiedString() {
     for (ExecutableElement providesMethod
         : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {
       assert_().that(keyFactory.forProvidesMethod(providesMethod))
-          .isEqualTo(new AutoValue_Key(Kind.PROVIDER,
+          .isEqualTo(new AutoValue_Key(
               Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
               MoreTypes.equivalence().wrap(setOfStringsType)));
     }
