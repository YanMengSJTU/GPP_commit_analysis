diff --git a/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
index 78cc5d102..73ec39e9d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
@@ -63,7 +63,6 @@ DelegateDeclaration create(
           MoreTypes.asExecutable(sourceElement.asMemberOfContributingType(types));
       DependencyRequest delegateRequest =
           dependencyRequestFactory.forRequiredResolvedVariable(
-              MoreTypes.asDeclared(contributingElement.asType()),
               Iterables.getOnlyElement(bindsMethod.getParameters()),
               Iterables.getOnlyElement(resolvedMethod.getParameterTypes()));
       return new AutoValue_DelegateDeclaration(
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index f25b941a8..33890d012 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -18,7 +18,6 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Equivalence;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
@@ -153,16 +152,6 @@ BindingKey bindingKey() {
 
   abstract Element requestElement();
 
-  /**
-   * Returns the possibly resolved type that contained the requesting element. For members injection
-   * requests, this is the type itself.
-   */
-  DeclaredType enclosingType() {
-    return wrappedEnclosingType().get();
-  }
-
-  abstract Equivalence.Wrapper<DeclaredType> wrappedEnclosingType();
-
   /** Returns true if this request allows null objects. */
   abstract boolean isNullable();
 
@@ -187,12 +176,12 @@ DeclaredType enclosingType() {
       this.keyFactory = keyFactory;
     }
 
-    ImmutableSet<DependencyRequest> forRequiredResolvedVariables(DeclaredType container,
+    ImmutableSet<DependencyRequest> forRequiredResolvedVariables(
         List<? extends VariableElement> variables, List<? extends TypeMirror> resolvedTypes) {
       checkState(resolvedTypes.size() == variables.size());
       ImmutableSet.Builder<DependencyRequest> builder = ImmutableSet.builder();
       for (int i = 0; i < variables.size(); i++) {
-        builder.add(forRequiredResolvedVariable(container, variables.get(i), resolvedTypes.get(i)));
+        builder.add(forRequiredResolvedVariable(variables.get(i), resolvedTypes.get(i)));
       }
       return builder.build();
     }
@@ -225,7 +214,6 @@ DependencyRequest forImplicitMapBinding(
           Kind.PROVIDER,
           mapOfFactoryKey,
           mapOfValueRequest.requestElement(),
-          mapOfValueRequest.wrappedEnclosingType(),
           false /* doesn't allow null */,
           Optional.<String>absent());
     }
@@ -244,7 +232,6 @@ DependencyRequest forMultibindingContribution(
           multibindingContributionRequestKind(multibindingContribution),
           multibindingContribution.key(),
           request.requestElement(),
-          request.wrappedEnclosingType(),
           false /* doesn't allow null */,
           Optional.<String>absent());
     }
@@ -287,18 +274,16 @@ DependencyRequest forRequiredVariable(VariableElement variableElement, Optional<
       checkNotNull(variableElement);
       TypeMirror type = variableElement.asType();
       Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(variableElement);
-      return newDependencyRequest(
-          variableElement, type, qualifier, getEnclosingType(variableElement), name);
+      return newDependencyRequest(variableElement, type, qualifier, name);
     }
 
-    DependencyRequest forRequiredResolvedVariable(DeclaredType container,
-        VariableElement variableElement,
-        TypeMirror resolvedType) {
+    DependencyRequest forRequiredResolvedVariable(
+        VariableElement variableElement, TypeMirror resolvedType) {
       checkNotNull(variableElement);
       checkNotNull(resolvedType);
       Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(variableElement);
       return newDependencyRequest(
-          variableElement, resolvedType, qualifier, container, Optional.<String>absent());
+          variableElement, resolvedType, qualifier, Optional.<String>absent());
     }
 
     DependencyRequest forComponentProvisionMethod(ExecutableElement provisionMethod,
@@ -314,7 +299,6 @@ DependencyRequest forComponentProvisionMethod(ExecutableElement provisionMethod,
           provisionMethod,
           provisionMethodType.getReturnType(),
           qualifier,
-          getEnclosingType(provisionMethod),
           Optional.<String>absent());
     }
 
@@ -326,7 +310,6 @@ DependencyRequest forComponentProductionMethod(ExecutableElement productionMetho
           "Component production methods must be empty: %s", productionMethod);
       TypeMirror type = productionMethodType.getReturnType();
       Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(productionMethod);
-      DeclaredType container = getEnclosingType(productionMethod);
       // Only a component production method can be a request for a ListenableFuture, so we
       // special-case it here.
       if (isTypeOf(ListenableFuture.class, type)) {
@@ -335,12 +318,10 @@ DependencyRequest forComponentProductionMethod(ExecutableElement productionMetho
             keyFactory.forQualifiedType(
                 qualifier, Iterables.getOnlyElement(((DeclaredType) type).getTypeArguments())),
             productionMethod,
-            MoreTypes.equivalence().wrap(container),
             false /* doesn't allow null */,
             Optional.<String>absent());
       } else {
-        return newDependencyRequest(
-            productionMethod, type, qualifier, container, Optional.<String>absent());
+        return newDependencyRequest(productionMethod, type, qualifier, Optional.<String>absent());
       }
     }
 
@@ -352,8 +333,6 @@ DependencyRequest forComponentMembersInjectionMethod(ExecutableElement membersIn
           InjectionAnnotations.getQualifier(membersInjectionMethod);
       checkArgument(!qualifier.isPresent());
       TypeMirror returnType = membersInjectionMethodType.getReturnType();
-      Equivalence.Wrapper<DeclaredType> container =
-          MoreTypes.equivalence().wrap(getEnclosingType(membersInjectionMethod));
       TypeMirror membersInjectedType =
           MoreTypes.isType(returnType) && MoreTypes.isTypeOf(MembersInjector.class, returnType)
               ? getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments())
@@ -362,7 +341,6 @@ DependencyRequest forComponentMembersInjectionMethod(ExecutableElement membersIn
           Kind.MEMBERS_INJECTOR,
           keyFactory.forMembersInjectedType(membersInjectedType),
           membersInjectionMethod,
-          container,
           false /* doesn't allow null */,
           Optional.<String>absent());
     }
@@ -372,7 +350,6 @@ DependencyRequest forMembersInjectedType(DeclaredType type) {
           Kind.MEMBERS_INJECTOR,
           keyFactory.forMembersInjectedType(type),
           type.asElement(),
-          MoreTypes.equivalence().wrap(type),
           false /* doesn't allow null */,
           Optional.<String>absent());
     }
@@ -383,7 +360,6 @@ DependencyRequest forProductionImplementationExecutor() {
           Kind.PROVIDER,
           key,
           MoreTypes.asElement(key.type()),
-          MoreTypes.equivalence().wrap(MoreTypes.asDeclared(key.type())),
           false /* doesn't allow null */,
           Optional.<String>absent());
     }
@@ -403,7 +379,6 @@ private DependencyRequest newDependencyRequest(
         Element requestElement,
         TypeMirror type,
         Optional<AnnotationMirror> qualifier,
-        DeclaredType container,
         Optional<String> name) {
       KindAndType kindAndType = extractKindAndType(type);
       if (kindAndType.kind().equals(Kind.MEMBERS_INJECTOR)) {
@@ -418,7 +393,6 @@ private DependencyRequest newDependencyRequest(
           kindAndType.kind(),
           keyFactory.forQualifiedType(qualifier, kindAndType.type()),
           requestElement,
-          MoreTypes.equivalence().wrap(container),
           allowsNull,
           name);
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index 53d15ee8d..0a8b80b84 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -157,7 +157,7 @@ private InjectionSite injectionSiteForInjectMethod(
           InjectionSite.Kind.METHOD,
           methodElement,
           dependencyRequestFactory.forRequiredResolvedVariables(
-              containingType, methodElement.getParameters(), resolved.getParameterTypes()));
+              methodElement.getParameters(), resolved.getParameterTypes()));
     }
 
     private InjectionSite injectionSiteForInjectField(
@@ -170,8 +170,7 @@ private InjectionSite injectionSiteForInjectField(
           InjectionSite.Kind.FIELD,
           fieldElement,
           ImmutableSet.of(
-              dependencyRequestFactory.forRequiredResolvedVariable(
-                  containingType, fieldElement, resolved)));
+              dependencyRequestFactory.forRequiredResolvedVariable(fieldElement, resolved)));
     }
 
     /** Returns true if the type has some injected members in itself or any of its super classes. */
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index 554abf1e5..c79f9c641 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -96,7 +96,6 @@ ProductionBinding forProducesMethod(
           MoreTypes.asExecutable(sourceElement.asMemberOfContributingType(types));
       ImmutableSet<DependencyRequest> dependencies =
           dependencyRequestFactory.forRequiredResolvedVariables(
-              MoreTypes.asDeclared(contributedBy.asType()),
               producesMethod.getParameters(),
               resolvedMethod.getParameterTypes());
       DependencyRequest executorRequest =
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 80b6d8230..dc0bd8417 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -106,9 +106,8 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
       Key key = keyFactory.forInjectConstructorWithResolvedType(enclosingCxtorType);
       checkArgument(!key.qualifier().isPresent());
       ImmutableSet<DependencyRequest> dependencies =
-          dependencyRequestFactory.forRequiredResolvedVariables(enclosingCxtorType,
-              constructorElement.getParameters(),
-              cxtorType.getParameterTypes());
+          dependencyRequestFactory.forRequiredResolvedVariables(
+              constructorElement.getParameters(), cxtorType.getParameterTypes());
       Optional<DependencyRequest> membersInjectionRequest =
           membersInjectionRequest(enclosingCxtorType);
       Optional<Scope> scope = Scope.uniqueScopeOf(constructorElement.getEnclosingElement());
@@ -158,7 +157,6 @@ ProvisionBinding forProvidesMethod(
       Key key = keyFactory.forProvidesMethod(sourceElement);
       ImmutableSet<DependencyRequest> dependencies =
           dependencyRequestFactory.forRequiredResolvedVariables(
-              MoreTypes.asDeclared(contributedBy.asType()),
               providesMethod.getParameters(),
               resolvedMethod.getParameterTypes());
       Optional<Scope> scope = Scope.uniqueScopeOf(providesMethod);
