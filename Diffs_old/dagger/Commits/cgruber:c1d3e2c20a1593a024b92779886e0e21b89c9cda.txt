diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 80a2bd6bd..785093357 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -42,7 +42,6 @@
 import static dagger.internal.codegen.MemberSelect.localField;
 import static dagger.internal.codegen.MemberSelect.noOpMembersInjector;
 import static dagger.internal.codegen.MemberSelect.staticMethod;
-import static dagger.internal.codegen.MembersInjectionBinding.Strategy.NO_OP;
 import static dagger.internal.codegen.Scope.reusableScope;
 import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
@@ -708,7 +707,7 @@ private boolean useRawType(Optional<String> bindingPackage) {
         Optional<MembersInjectionBinding> membersInjectionBinding =
             resolvedBindings.membersInjectionBinding();
         if (membersInjectionBinding.isPresent()
-            && membersInjectionBinding.get().injectionStrategy().equals(NO_OP)) {
+            && membersInjectionBinding.get().injectionSites().isEmpty()) {
           return Optional.of(noOpMembersInjector(membersInjectionBinding.get().key().type()));
         }
         break;
@@ -974,7 +973,7 @@ private void initializeFrameworkTypes() {
     MembersInjectionBinding binding =
         graph.resolvedBindings().get(bindingKey).membersInjectionBinding().get();
 
-    if (binding.injectionStrategy().equals(MembersInjectionBinding.Strategy.NO_OP)) {
+    if (binding.injectionSites().isEmpty()) {
       return Optional.absent();
     }
 
@@ -1249,17 +1248,12 @@ private CodeBlock nullableAnnotation(Optional<DeclaredType> nullableType) {
   }
 
   private CodeBlock initializeMembersInjectorForBinding(MembersInjectionBinding binding) {
-    switch (binding.injectionStrategy()) {
-      case NO_OP:
-        return CodeBlock.of("$T.noOp()", MEMBERS_INJECTORS);
-      case INJECT_MEMBERS:
-        return CodeBlock.of(
+    return binding.injectionSites().isEmpty()
+        ? CodeBlock.of("$T.noOp()", MEMBERS_INJECTORS)
+        : CodeBlock.of(
             "$T.create($L)",
             membersInjectorNameForType(binding.membersInjectedType()),
             makeParametersCodeBlock(getDependencyArguments(binding)));
-      default:
-        throw new AssertionError();
-    }
   }
 
   /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index be4bcf922..f646ff078 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -20,7 +20,6 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.InjectionAnnotations.injectedConstructors;
-import static dagger.internal.codegen.MembersInjectionBinding.Strategy.INJECT_MEMBERS;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
 
 import com.google.auto.common.MoreElements;
@@ -235,7 +234,7 @@ private void registerBinding(MembersInjectionBinding binding, boolean warnIfNotA
       ProvisionBinding binding =
           provisionBindingFactory.forInjectConstructor(constructorElement, resolvedType);
       registerBinding(binding, warnIfNotAlreadyGenerated);
-      if (membersInjectionBindingFactory.hasInjectedMembers(type)) {
+      if (membersInjectionBindingFactory.hasInjectedMembersIn(type)) {
         tryRegisterMembersInjectedType(typeElement, resolvedType, warnIfNotAlreadyGenerated);
       }
       return Optional.of(binding);
@@ -267,7 +266,7 @@ private void registerBinding(MembersInjectionBinding binding, boolean warnIfNotA
       MembersInjectionBinding binding =
           membersInjectionBindingFactory.forInjectedType(type, resolvedType);
       registerBinding(binding, warnIfNotAlreadyGenerated);
-      if (binding.parentKey().isPresent() && binding.injectionStrategy().equals(INJECT_MEMBERS)) {
+      if (binding.parentKey().isPresent() && !binding.injectionSites().isEmpty()) {
         getOrFindMembersInjectionBinding(binding.parentKey().get());
       }
       return Optional.of(binding);
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectValidator.java b/compiler/src/main/java/dagger/internal/codegen/InjectValidator.java
index ca489c1d4..549d3d95e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectValidator.java
@@ -270,7 +270,7 @@ InjectValidator whenGeneratingCode() {
         }
       }
     }
-    // We can't use MembersInjectionBinding.Factory#hasInjectedMembers because that assumes this
+    // We can't use MembersInjectionBinding.Factory#hasInjectedMembersIn because that assumes this
     // binding already validates, so we just check it again here.
     if (hasInjectedMembers && !isElementAccessibleFromOwnPackage(typeElement)) {
       builder.addItem(
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index d6c73f0c9..352cc36fd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -17,6 +17,7 @@
 package dagger.internal.codegen;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.auto.common.MoreTypes.nonObjectSuperclass;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
@@ -61,7 +62,7 @@
 abstract class MembersInjectionBinding extends Binding {
   @Override
   Optional<Element> bindingElement() {
-    return Optional.<Element>of(membersInjectedType());
+    return Optional.of(membersInjectedType());
   }
 
   abstract TypeElement membersInjectedType();
@@ -83,15 +84,6 @@
    */
   abstract Optional<Key> parentKey();
 
-  enum Strategy {
-    NO_OP,
-    INJECT_MEMBERS,
-  }
-
-  Strategy injectionStrategy() {
-    return injectionSites().isEmpty() ? Strategy.NO_OP : Strategy.INJECT_MEMBERS;
-  }
-
   @Override
   public BindingType bindingType() {
     return BindingType.MEMBERS_INJECTION;
@@ -101,7 +93,8 @@ public BindingType bindingType() {
    * Returns {@code true} if any of this binding's injection sites are directly on the bound type.
    */
   boolean hasLocalInjectionSites() {
-    return FluentIterable.from(injectionSites())
+    return injectionSites()
+        .stream()
         .anyMatch(
             injectionSite ->
                 injectionSite.element().getEnclosingElement().equals(membersInjectedType()));
@@ -170,7 +163,7 @@ private InjectionSite injectionSiteForInjectField(
     }
 
     /** Returns true if the type has some injected members in itself or any of its super classes. */
-    boolean hasInjectedMembers(DeclaredType declaredType) {
+    boolean hasInjectedMembersIn(DeclaredType declaredType) {
       return !getInjectionSites(declaredType).isEmpty();
     }
 
@@ -199,7 +192,7 @@ MembersInjectionBinding forInjectedType(
               .toSet();
 
       Optional<Key> parentKey =
-          MoreTypes.nonObjectSuperclass(types, elements, declaredType)
+          nonObjectSuperclass(types, elements, declaredType)
               .transform(keyFactory::forMembersInjectedType);
 
       Key key = keyFactory.forMembersInjectedType(declaredType);
@@ -210,9 +203,8 @@ MembersInjectionBinding forInjectedType(
           typeElement,
           hasNonDefaultTypeParameters(typeElement, key.type(), types)
               ? Optional.of(
-                  forInjectedType(
-                      MoreTypes.asDeclared(typeElement.asType()), Optional.<TypeMirror>absent()))
-              : Optional.<MembersInjectionBinding>absent(),
+                  forInjectedType(MoreTypes.asDeclared(typeElement.asType()), Optional.absent()))
+              : Optional.absent(),
           injectionSites,
           parentKey);
     }
@@ -223,7 +215,7 @@ MembersInjectionBinding forInjectedType(
       SetMultimap<String, ExecutableElement> overriddenMethodMap = LinkedHashMultimap.create();
       for (Optional<DeclaredType> currentType = Optional.of(declaredType);
           currentType.isPresent();
-          currentType = MoreTypes.nonObjectSuperclass(types, elements, currentType.get())) {
+          currentType = nonObjectSuperclass(types, elements, currentType.get())) {
         final DeclaredType type = currentType.get();
         ancestors.add(MoreElements.asType(type.asElement()));
         for (Element enclosedElement : type.asElement().getEnclosedElements()) {
@@ -234,7 +226,7 @@ MembersInjectionBinding forInjectedType(
             if (shouldBeInjected(injectionSite.element(), overriddenMethodMap)) {
               injectionSites.add(injectionSite);
             }
-            if (injectionSite.kind() == InjectionSite.Kind.METHOD) {
+            if (injectionSite.kind().equals(InjectionSite.Kind.METHOD)) {
               ExecutableElement injectionSiteMethod =
                   MoreElements.asExecutable(injectionSite.element());
               overriddenMethodMap.put(
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index 53278fb91..a8598e279 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -16,18 +16,21 @@
 
 package dagger.internal.codegen;
 
-import static com.google.auto.common.MoreElements.getPackage;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeName.VOID;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static dagger.internal.codegen.Accessibility.isElementAccessibleFrom;
+import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.RAWTYPES;
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
 import static dagger.internal.codegen.AnnotationSpecs.suppressWarnings;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
+import static dagger.internal.codegen.SourceFiles.generateBindingFieldsForDependencies;
 import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
 import static dagger.internal.codegen.SourceFiles.parameterizedGeneratedTypeNameForBinding;
 import static dagger.internal.codegen.TypeNames.membersInjectorOf;
@@ -62,12 +65,7 @@
 import javax.annotation.processing.Filer;
 import javax.inject.Provider;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.type.ArrayType;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.TypeVisitor;
 import javax.lang.model.util.Elements;
-import javax.lang.model.util.SimpleTypeVisitor7;
 
 /**
  * Generates {@link MembersInjector} implementations from {@link MembersInjectionBinding} instances.
@@ -103,7 +101,10 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
       return Optional.absent();
     }
     // We don't want to write out resolved bindings -- we want to write out the generic version.
-    checkState(!binding.unresolved().isPresent());
+    checkState(
+        !binding.unresolved().isPresent(),
+        "tried to generate a MembersInjector for a binding of a resolved generic type: %s",
+        binding);
 
     ImmutableList<TypeVariableName> typeParameters = bindingTypeElementTypeVariableNames(binding);
     TypeSpec.Builder injectorTypeBuilder =
@@ -117,7 +118,7 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
 
     MethodSpec.Builder injectMembersBuilder =
         methodBuilder("injectMembers")
-            .returns(TypeName.VOID)
+            .returns(VOID)
             .addModifiers(PUBLIC)
             .addAnnotation(Override.class)
             .addParameter(injectedTypeName, "instance")
@@ -128,8 +129,7 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
                 "Cannot inject members into a null reference")
             .addCode("}");
 
-    ImmutableMap<BindingKey, FrameworkField> fields =
-        SourceFiles.generateBindingFieldsForDependencies(binding);
+    ImmutableMap<BindingKey, FrameworkField> fields = generateBindingFieldsForDependencies(binding);
 
     ImmutableMap.Builder<BindingKey, FieldSpec> dependencyFieldsBuilder = ImmutableMap.builder();
 
@@ -141,7 +141,7 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
     MethodSpec.Builder createMethodBuilder =
         methodBuilder("create")
             .returns(implementedType)
-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
+            .addModifiers(PUBLIC, STATIC)
             .addTypeVariables(typeParameters);
 
     createMethodBuilder.addCode(
@@ -151,13 +151,13 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
     boolean usesRawFrameworkTypes = false;
     UniqueNameSet fieldNames = new UniqueNameSet();
     for (Entry<BindingKey, FrameworkField> fieldEntry : fields.entrySet()) {
-      BindingKey bindingKey = fieldEntry.getKey();
+      BindingKey dependencyBindingKey = fieldEntry.getKey();
       FrameworkField bindingField = fieldEntry.getValue();
 
       // If the dependency type is not visible to this members injector, then use the raw framework
       // type for the field.
       boolean useRawFrameworkType =
-          !VISIBLE_TO_MEMBERS_INJECTOR.visit(bindingKey.key().type(), binding);
+          !isTypeAccessibleFrom(dependencyBindingKey.key().type(), generatedTypeName.packageName());
 
       String fieldName = fieldNames.getUniqueName(bindingField.name());
       TypeName fieldType =
@@ -182,7 +182,7 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
       injectorTypeBuilder.addField(field);
       constructorBuilder.addStatement("assert $N != null", field);
       constructorBuilder.addStatement("this.$N = $N", field, field);
-      dependencyFieldsBuilder.put(bindingKey, field);
+      dependencyFieldsBuilder.put(dependencyBindingKey, field);
       constructorInvocationParameters.add(CodeBlock.of("$N", field));
     }
     createMethodBuilder.addCode(CodeBlocks.join(constructorInvocationParameters.build(), ", "));
@@ -196,7 +196,7 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
     List<MethodSpec> injectMethodsForSubclasses = new ArrayList<>();
     for (InjectionSite injectionSite : binding.injectionSites()) {
       injectMembersBuilder.addCode(
-          visibleToMembersInjector(binding, injectionSite.element())
+          isElementAccessibleFrom(injectionSite.element(), generatedTypeName.packageName())
               ? directInjectMemberCodeBlock(binding, dependencyFields, injectionSite)
               : delegateInjectMemberCodeBlock(dependencyFields, injectionSite));
       if (!injectionSite.element().getModifiers().contains(PUBLIC)
@@ -217,24 +217,11 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
     }
 
     injectorTypeBuilder.addMethod(injectMembersBuilder.build());
-    for (MethodSpec methodSpec : injectMethodsForSubclasses) {
-      injectorTypeBuilder.addMethod(methodSpec);
-    }
+    injectMethodsForSubclasses.forEach(injectorTypeBuilder::addMethod);
 
     return Optional.of(injectorTypeBuilder);
   }
 
-  /**
-   * Returns {@code true} if {@code element} is visible to the members injector for {@code binding}.
-   */
-  // TODO(dpb,gak): Make sure that all cases are covered here. E.g., what if element is public but
-  // enclosed in a package-private element?
-  private static boolean visibleToMembersInjector(
-      MembersInjectionBinding binding, Element element) {
-    return getPackage(element).equals(getPackage(binding.membersInjectedType()))
-        || element.getModifiers().contains(PUBLIC);
-  }
-
   /**
    * Returns a code block that directly injects the instance's field or method.
    */
@@ -304,7 +291,7 @@ private CodeBlock getInstanceCodeBlockWithPotentialCast(
     return CodeBlock.of("(($T) instance)", injectionSiteName);
   }
 
-  private String injectionSiteDelegateMethodName(Element injectionSiteElement) {
+  private static String injectionSiteDelegateMethodName(Element injectionSiteElement) {
     return "inject"
         + CaseFormat.LOWER_CAMEL.to(
             CaseFormat.UPPER_CAMEL, injectionSiteElement.getSimpleName().toString());
@@ -379,17 +366,4 @@ private String staticInjectMethodDependencyParameterName(
     }
     return parameterName.toString();
   }
-
-  private static final TypeVisitor<Boolean, MembersInjectionBinding> VISIBLE_TO_MEMBERS_INJECTOR =
-      new SimpleTypeVisitor7<Boolean, MembersInjectionBinding>(true) {
-        @Override
-        public Boolean visitArray(ArrayType t, MembersInjectionBinding p) {
-          return visit(t.getComponentType(), p);
-        }
-
-        @Override
-        public Boolean visitDeclared(DeclaredType t, MembersInjectionBinding p) {
-          return visibleToMembersInjector(p, t.asElement());
-        }
-      };
 }
