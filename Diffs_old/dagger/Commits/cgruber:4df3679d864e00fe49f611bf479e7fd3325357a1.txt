diff --git a/compiler/src/main/java/dagger/internal/codegen/ClassName.java b/compiler/src/main/java/dagger/internal/codegen/ClassName.java
new file mode 100644
index 000000000..a7c84025f
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ClassName.java
@@ -0,0 +1,206 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.Util.isValidJavaIdentifier;
+import static javax.lang.model.element.NestingKind.MEMBER;
+import static javax.lang.model.element.NestingKind.TOP_LEVEL;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Ascii;
+import com.google.common.base.CaseFormat;
+import com.google.common.base.CharMatcher;
+import com.google.common.base.Joiner;
+import com.google.common.base.Splitter;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Sets;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.NestingKind;
+import javax.lang.model.element.PackageElement;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * Represents a fully-qualified class name for {@link NestingKind#TOP_LEVEL} and
+ * {@link NestingKind#MEMBER} classes.
+ *
+ * @since 2.0
+ */
+@AutoValue
+abstract class ClassName implements Comparable<ClassName> {
+  private String fullyQualifiedName = null;
+
+  String fullyQualifiedName() {
+    if (fullyQualifiedName == null) {
+      StringBuilder builder = new StringBuilder(packageName());
+      if (builder.length() > 0) {
+        builder.append('.');
+      }
+      for (String enclosingSimpleName : enclosingSimpleNames()) {
+        builder.append(enclosingSimpleName).append('.');
+      }
+      fullyQualifiedName = builder.append(simpleName()).toString();
+    }
+    return fullyQualifiedName;
+  }
+
+  String classFileName() {
+    StringBuilder builder = new StringBuilder();
+    Joiner.on('$').appendTo(builder, enclosingSimpleNames());
+    if (!enclosingSimpleNames().isEmpty()) {
+      builder.append('$');
+    }
+    return builder.append(simpleName()).toString();
+  }
+
+  abstract String packageName();
+  /* From top to bottom.  E.g.: this field will contian ["A", "B"] for pgk.A.B.C */
+  abstract ImmutableList<String> enclosingSimpleNames();
+  abstract String simpleName();
+
+
+  String suggestedVariableName() {
+    return CharMatcher.is('$').removeFrom(
+        CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL, simpleName()));
+  }
+
+  ClassName nameOfTopLevelClass() {
+    Iterator<String> enclosingIterator = enclosingSimpleNames().iterator();
+    return enclosingIterator.hasNext()
+        ? new AutoValue_ClassName(packageName(), ImmutableList.<String>of(),
+            enclosingIterator.next())
+        : this;
+  }
+
+  ClassName memberClassNamed(String memberClassName) {
+    checkNotNull(memberClassName);
+    checkArgument(isValidJavaIdentifier(memberClassName));
+    checkArgument(Ascii.isUpperCase(memberClassName.charAt(0)));
+    return new AutoValue_ClassName(packageName(),
+        new ImmutableList.Builder<String>()
+            .addAll(enclosingSimpleNames())
+            .add(simpleName())
+            .build(),
+        memberClassName);
+  }
+
+  ClassName peerNamed(String peerClassName) {
+    checkNotNull(peerClassName);
+    checkArgument(isValidJavaIdentifier(peerClassName));
+    checkArgument(Ascii.isUpperCase(peerClassName.charAt(0)));
+    return new AutoValue_ClassName(packageName(), enclosingSimpleNames(), peerClassName);
+  }
+
+  private static final ImmutableSet<NestingKind> ACCEPTABLE_NESTING_KINDS =
+      Sets.immutableEnumSet(TOP_LEVEL, MEMBER);
+
+  static ClassName fromTypeElement(TypeElement element) {
+    checkNotNull(element);
+    checkArgument(ACCEPTABLE_NESTING_KINDS.contains(element.getNestingKind()));
+    String simpleName = element.getSimpleName().toString();
+    List<String> enclosingNames = new ArrayList<String>();
+    Element current = element.getEnclosingElement();
+    while (current.getKind().isClass() || current.getKind().isInterface()) {
+      checkArgument(ACCEPTABLE_NESTING_KINDS.contains(element.getNestingKind()));
+      enclosingNames.add(current.getSimpleName().toString());
+      current = element.getEnclosingElement();
+    }
+    PackageElement packageElement = Util.getPackage(current);
+    Collections.reverse(enclosingNames);
+    return new AutoValue_ClassName(packageElement.getQualifiedName().toString(),
+        ImmutableList.copyOf(enclosingNames), simpleName);
+  }
+
+  static ClassName fromClass(Class<?> clazz) {
+    checkNotNull(clazz);
+    List<String> enclosingNames = new ArrayList<String>();
+    Class<?> current = clazz.getEnclosingClass();
+    while (current != null) {
+      enclosingNames.add(current.getSimpleName());
+      current = clazz.getEnclosingClass();
+    }
+    Collections.reverse(enclosingNames);
+    return create(clazz.getPackage().getName(), enclosingNames, clazz.getSimpleName());
+  }
+
+  /**
+   * Returns a new {@link ClassName} instance for the given fully-qualified class name string. This
+   * method assumes that the input is ASCII and follows typical Java style (lower-case package
+   * names, upper-camel-case class names) and may produce incorrect results or throw
+   * {@link IllegalArgumentException} otherwise. For that reason, {@link #fromClass(Class)} and
+   * {@link #fromClass(Class)} should be preferred as they can correctly create {@link ClassName}
+   * instances without such restrictions.
+   */
+  static ClassName bestGuessFromString(String classNameString) {
+    checkNotNull(classNameString);
+    List<String> parts = Splitter.on('.').splitToList(classNameString);
+    int firstClassPartIndex = -1;
+    for (int i = 0; i < parts.size(); i++) {
+      String part = parts.get(i);
+      checkArgument(isValidJavaIdentifier(part));
+      char firstChar = part.charAt(0);
+      if (Ascii.isLowerCase(firstChar)) {
+        // looks like a package part
+        if (firstClassPartIndex >= 0) {
+          throw new IllegalArgumentException("couldn't make a guess for " + classNameString);
+        }
+      } else if (Ascii.isUpperCase(firstChar)) {
+        // looks like a class part
+        if (firstClassPartIndex < 0) {
+          firstClassPartIndex = i;
+        }
+      } else {
+        throw new IllegalArgumentException("couldn't make a guess for " + classNameString);
+      }
+    }
+    int lastIndex = parts.size() - 1;
+    return new AutoValue_ClassName(
+        Joiner.on('.').join(parts.subList(0, firstClassPartIndex)),
+        firstClassPartIndex == lastIndex
+            ? ImmutableList.<String>of()
+            : ImmutableList.copyOf(parts.subList(firstClassPartIndex, lastIndex)),
+        parts.get(lastIndex));
+  }
+
+  static ClassName create(String packageName,
+      List<String> enclosingSimpleNames, String simpleName) {
+    return new AutoValue_ClassName(packageName, ImmutableList.copyOf(enclosingSimpleNames),
+        simpleName);
+  }
+
+  static ClassName create(String packageName, String simpleName) {
+    return new AutoValue_ClassName(packageName, ImmutableList.<String>of(), simpleName);
+  }
+
+  @Override
+  public String toString() {
+    return fullyQualifiedName();
+  }
+
+  @Override
+  public int compareTo(ClassName o) {
+    return fullyQualifiedName().compareTo(o.fullyQualifiedName());
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
new file mode 100644
index 000000000..e44e6b03f
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Function;
+import com.google.common.base.Optional;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+
+import dagger.Lazy;
+import dagger.Provides;
+
+import java.util.List;
+
+import javax.inject.Inject;
+import javax.inject.Provider;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+
+/**
+ * Represents a request for a key at an injection point. Parameters to {@link Inject} constructors
+ * or {@link Provides} methods are examples of key requests.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+// TODO(gak): Set bindings and the permutations thereof need to be addressed
+@AutoValue
+abstract class DependencyRequest {
+  enum Kind {
+    /** A default request for an instance.  E.g.: {@code Blah} */
+    INSTANCE,
+    /** A request for a {@link Provider}.  E.g.: {@code Provider<Blah>} */
+    PROVIDER,
+    /** A request for a {@link Lazy}.  E.g.: {@code Lazy<Blah>} */
+    LAZY,
+  }
+
+  abstract Kind kind();
+  abstract Key key();
+  abstract VariableElement requestElement();
+
+  static final class Factory {
+    private final Elements elements;
+    private final Types types;
+
+    Factory(Elements elements, Types types) {
+      this.elements = elements;
+      this.types = types;
+    }
+
+    ImmutableSet<DependencyRequest> forVariables(List<? extends VariableElement> variables) {
+      return FluentIterable.from(variables)
+          .transform(new Function<VariableElement, DependencyRequest>() {
+            @Override public DependencyRequest apply(VariableElement input) {
+              return forVariable(input);
+            }
+          })
+          .toSet();
+    }
+
+    DependencyRequest forVariable(VariableElement variableElement) {
+      checkNotNull(variableElement);
+      TypeMirror type = variableElement.asType();
+      Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(variableElement);
+      if (elements.getTypeElement(Provider.class.getCanonicalName())
+          .equals(types.asElement(type))) {
+        DeclaredType providerType = (DeclaredType) type;
+        return new AutoValue_DependencyRequest(Kind.PROVIDER,
+            Key.create(qualifier, Iterables.getOnlyElement(providerType.getTypeArguments())),
+            variableElement);
+      } else if (elements.getTypeElement(Lazy.class.getCanonicalName())
+          .equals(types.asElement(type))) {
+        DeclaredType lazyType = (DeclaredType) type;
+        return new AutoValue_DependencyRequest(Kind.LAZY,
+            Key.create(qualifier, Iterables.getOnlyElement(lazyType.getTypeArguments())),
+            variableElement);
+      } else {
+        return new AutoValue_DependencyRequest(Kind.INSTANCE, Key.create(qualifier, type),
+            variableElement);
+      }
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
index 22ade7abb..bb53bd85d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
@@ -34,11 +34,16 @@
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
 
+import com.google.common.base.Function;
 import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Multimaps;
 
+import java.io.IOException;
 import java.lang.annotation.Annotation;
+import java.util.Collection;
 import java.util.List;
 import java.util.Set;
 
@@ -58,6 +63,8 @@
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.ElementKindVisitor6;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
 /**
  * An annotation processor for generating Dagger implementation code based on the {@link Inject}
@@ -69,11 +76,19 @@
 @SupportedSourceVersion(RELEASE_6)
 public final class InjectProcessor extends AbstractProcessor {
   private Messager messager;
+  private MembersInjectionBinding.Factory membersInjectionBindingFactory;
+  private MembersInjectorWriter membersInjectorWriter;
 
   @Override
   public synchronized void init(ProcessingEnvironment processingEnv) {
     super.init(processingEnv);
     this.messager = processingEnv.getMessager();
+    Elements elements = processingEnv.getElementUtils();
+    Types types = processingEnv.getTypeUtils();
+    this.membersInjectionBindingFactory = new MembersInjectionBinding.Factory(
+        new DependencyRequest.Factory(elements, types));
+    this.membersInjectorWriter = new MembersInjectorWriter(processingEnv.getFiler(),
+        new ProviderTypeRepository(elements, types));
   }
 
   @Override
@@ -84,6 +99,8 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
   @Override
   public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
     // TODO(gak): add some error handling for bad source files
+    final ImmutableSet.Builder<MembersInjectionBinding> membersInjections = ImmutableSet.builder();
+
     for (Element injectElement : roundEnv.getElementsAnnotatedWith(Inject.class)) {
       injectElement.accept(
           new ElementKindVisitor6<Void, Void>() {
@@ -108,7 +125,8 @@ public Void visitVariableAsField(VariableElement fieldElement, Void p) {
               report.printMessagesTo(messager);
 
               if (report.isClean()) {
-                // collect bindings for generating members injectors
+                membersInjections.add(
+                    membersInjectionBindingFactory.forInjectField(fieldElement));
               }
 
               return null;
@@ -121,7 +139,8 @@ public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
               report.printMessagesTo(messager);
 
               if (report.isClean()) {
-                // collect bindings for generating members injectors
+                membersInjections.add(
+                    membersInjectionBindingFactory.forInjectMethod(methodElement));
               }
 
               return null;
@@ -129,7 +148,22 @@ public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
           }, null);
     }
 
-    // TODO(gak): generate the factories and members injectors
+    ImmutableListMultimap<TypeElement, MembersInjectionBinding> membersInjectionsByType =
+        Multimaps.index(membersInjections.build(),
+            new Function<MembersInjectionBinding, TypeElement>() {
+              @Override public TypeElement apply(MembersInjectionBinding binding) {
+                return binding.targetEnclosingType();
+              }
+            });
+
+    for (Collection<MembersInjectionBinding> bindings : membersInjectionsByType.asMap().values()) {
+      try {
+        membersInjectorWriter.write(
+            MembersInjectionBinding.injectionOrdering().immutableSortedCopy(bindings));
+      } catch (IOException e) {
+        throw new RuntimeException(e);
+      }
+    }
 
     return false;
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
new file mode 100644
index 000000000..e0184bf7b
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
+
+import com.google.common.base.Optional;
+import com.google.common.base.Predicate;
+import com.google.common.collect.FluentIterable;
+
+import java.lang.annotation.Annotation;
+import java.util.Iterator;
+import java.util.List;
+
+import javax.inject.Qualifier;
+import javax.inject.Scope;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+
+/**
+ * Utilities relating to annotations defined in the {@code javax.inject} package.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+final class InjectionAnnotations {
+  static Optional<AnnotationMirror> getScopeAnnotation(Element e) {
+    checkNotNull(e);
+    return getAnnotatedAnnotation(e, Scope.class);
+  }
+
+  static Optional<AnnotationMirror> getQualifier(Element e) {
+    checkNotNull(e);
+    return getAnnotatedAnnotation(e, Qualifier.class);
+  }
+
+  private static Optional<AnnotationMirror> getAnnotatedAnnotation(Element e,
+      final Class<? extends Annotation> annotationType) {
+    List<? extends AnnotationMirror> annotations = e.getAnnotationMirrors();
+    Iterator<? extends AnnotationMirror> qualifiers = FluentIterable.from(annotations)
+        .filter(new Predicate<AnnotationMirror>() {
+          @Override
+          public boolean apply(AnnotationMirror input) {
+            return input.getAnnotationType().asElement().getAnnotation(annotationType) != null;
+          }
+        })
+        .iterator();
+    if (qualifiers.hasNext()) {
+      AnnotationMirror qualifier = qualifiers.next();
+      checkState(!qualifiers.hasNext(),
+          "More than one " + annotationType.getName() + " was present.");
+      return Optional.of(qualifier);
+    } else {
+      return Optional.absent();
+    }
+  }
+
+  private InjectionAnnotations() {}
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/JavaWriterUtil.java b/compiler/src/main/java/dagger/internal/codegen/JavaWriterUtil.java
new file mode 100644
index 000000000..9e45716b2
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/JavaWriterUtil.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableList;
+import com.squareup.javawriter.JavaWriter;
+
+import java.util.Map;
+import java.util.Map.Entry;
+
+/**
+ * Utilities for working with {@link JavaWriter} instances.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+// TODO(gak): push changes upstream to obviate the need for such utilities
+class JavaWriterUtil {
+  /**
+   * Given a mapping from variable name to type, returns a list of tokens suitable for methods such
+   * as {@link JavaWriter#beginMethod(String, String, java.util.Set, String...)}.
+   */
+  static ImmutableList<String> flattenVariableMap(Map<String, String> variableMap) {
+    ImmutableList.Builder<String> tokenList = ImmutableList.builder();
+    for (Entry<String, String> variableEntry : variableMap.entrySet()) {
+      tokenList.add(variableEntry.getValue(), variableEntry.getKey());
+    }
+    return tokenList.build();
+  }
+
+  private JavaWriterUtil() {}
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 51ba7ab7a..740ca59f3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -17,7 +17,7 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.base.Preconditions.checkState;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.ElementKind.METHOD;
 
@@ -25,17 +25,11 @@
 import com.google.common.base.Equivalence;
 import com.google.common.base.Objects;
 import com.google.common.base.Optional;
-import com.google.common.base.Predicate;
-import com.google.common.collect.FluentIterable;
 
 import dagger.Provides;
 
-import java.util.Iterator;
-import java.util.List;
-
 import javax.inject.Qualifier;
 import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.type.TypeMirror;
 
@@ -61,19 +55,21 @@ TypeMirror type() {
 
   @Override
   public String toString() {
-    return Objects.toStringHelper(this)
+    return Objects.toStringHelper(Key.class)
         .omitNullValues()
         .add("qualifier", qualifier().orNull())
         .add("type", type())
         .toString();
   }
 
+  // TODO(gak): normalize boxed types
+
   static Key create(TypeMirror type) {
     return new AutoValue_Key(Optional.<AnnotationMirror>absent(), Mirrors.equivalence().wrap(type));
   }
 
-  static Key create(AnnotationMirror qualifier, TypeMirror type) {
-    return new AutoValue_Key(Optional.of(qualifier), Mirrors.equivalence().wrap(type));
+  static Key create(Optional<AnnotationMirror> qualifier, TypeMirror type) {
+    return new AutoValue_Key(qualifier, Mirrors.equivalence().wrap(type));
   }
 
   // TODO(gak): decide whether to address set bindings here or someplace else
@@ -99,23 +95,4 @@ static Key forInjectConstructor(ExecutableElement e) {
     TypeMirror type = e.getEnclosingElement().asType();
     return new AutoValue_Key(Optional.<AnnotationMirror>absent(), Mirrors.equivalence().wrap(type));
   }
-
-  private static Optional<AnnotationMirror> getQualifier(Element e) {
-    List<? extends AnnotationMirror> annotations = e.getAnnotationMirrors();
-    Iterator<? extends AnnotationMirror> qualifiers = FluentIterable.from(annotations)
-        .filter(new Predicate<AnnotationMirror>() {
-          @Override
-          public boolean apply(AnnotationMirror input) {
-            return input.getAnnotationType().asElement().getAnnotation(Qualifier.class) != null;
-          }
-        })
-        .iterator();
-    if (qualifiers.hasNext()) {
-      AnnotationMirror qualifier = qualifiers.next();
-      checkState(!qualifiers.hasNext(), "More than one qualifier was present.");
-      return Optional.of(qualifier);
-    } else {
-      return Optional.absent();
-    }
-  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/KeyRequest.java b/compiler/src/main/java/dagger/internal/codegen/KeyRequest.java
deleted file mode 100644
index 71186804d..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/KeyRequest.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.auto.value.AutoValue;
-
-import dagger.Provides;
-
-import javax.inject.Inject;
-
-
-/**
- * Represents a request for a key at an injection point. Parameters to {@link Inject} constructors
- * or {@link Provides} methods are examples of key requests.
- *
- * @author Gregory Kick
- */
-// TODO(gak): Set bindings and the permutations thereof need to be addressed
-@AutoValue
-abstract class KeyRequest {
-  enum Kind {
-    INSTANCE,
-    PROVIDER,
-    LAZY,
-  }
-
-  abstract Kind type();
-  abstract Key key();
-
-  static KeyRequest instanceRequest(Key key) {
-    return new AutoValue_KeyRequest(Kind.INSTANCE, key);
-  }
-
-  static KeyRequest providerRequest(Key key) {
-    return new AutoValue_KeyRequest(Kind.PROVIDER, key);
-  }
-
-  static KeyRequest lazyRequest(Key key) {
-    return new AutoValue_KeyRequest(Kind.LAZY, key);
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
new file mode 100644
index 000000000..c05a2c3e7
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static javax.lang.model.element.ElementKind.FIELD;
+import static javax.lang.model.element.ElementKind.METHOD;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.ComparisonChain;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.Ordering;
+
+import javax.inject.Inject;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+
+/**
+ * A value object representing a binding for an {@link Inject} annotation on a member (as opposed to
+ * a constructor). New instances should be created using an instance of the {@link Factory}.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+@AutoValue
+abstract class MembersInjectionBinding {
+  /**
+   * Returns an {@link Ordering} suitable for sorting bindings into an ordering that abides by the
+   * injection ordering specified in {@link Inject}. This ordering should not be used with bindings
+   * from different {@link #targetEnclosingType() types}.
+   */
+  static Ordering<MembersInjectionBinding> injectionOrdering() {
+    return INJECTION_ORDERING;
+  }
+
+  private static final Ordering<MembersInjectionBinding> INJECTION_ORDERING =
+      new Ordering<MembersInjectionBinding>() {
+        @Override
+        public int compare(MembersInjectionBinding left, MembersInjectionBinding right) {
+          return ComparisonChain.start()
+              // fields before methods
+              .compare(left.target().getKind(), right.target().getKind())
+              // then sort by whichever element comes first in the parent
+              // this isn't necessary, but makes the processor nice and predictable
+              .compare(targetIndexInEnclosing(left), targetIndexInEnclosing(right))
+              .result();
+        }
+      };
+
+  private static int targetIndexInEnclosing(MembersInjectionBinding binding)  {
+    return binding.targetEnclosingType().getEnclosedElements().indexOf(binding.target());
+  }
+
+  /** The field or method annotated with {@link Inject}. */
+  abstract Element target();
+
+  /** The type enclosing the binding {@link #target()}. */
+  TypeElement targetEnclosingType() {
+    return ElementUtil.asTypeElement(target().getEnclosingElement());
+  }
+
+  /**
+   * The set of {@link DependencyRequest dependencies} required to satisfy this binding. For fields
+   * this will be a single element for the field and for methods this will be an element for each of
+   * the method parameters.
+   */
+  abstract ImmutableSet<DependencyRequest> dependencies();
+
+  /** Returns the {@link #dependencies()} indexed by {@link Key}. */
+  ImmutableSetMultimap<Key, DependencyRequest> dependenciesByKey() {
+    ImmutableSetMultimap.Builder<Key, DependencyRequest> builder = ImmutableSetMultimap.builder();
+    for (DependencyRequest dependency : dependencies()) {
+      builder.put(dependency.key(), dependency);
+    }
+    return builder.build();
+  }
+
+  /**
+   * A factory for creating {@link MembersInjectionBinding} instances.
+   */
+  static final class Factory {
+    private final DependencyRequest.Factory dependencyRequestFactory;
+
+    Factory(DependencyRequest.Factory dependencyRequestFactory) {
+      this.dependencyRequestFactory = checkNotNull(dependencyRequestFactory);
+    }
+
+    /** Returns the method injection binding for a method annotated with {@link Inject}. */
+    MembersInjectionBinding forInjectMethod(ExecutableElement methodElement) {
+      checkNotNull(methodElement);
+      checkArgument(methodElement.getKind().equals(METHOD));
+      checkArgument(methodElement.getAnnotation(Inject.class) != null);
+      return new AutoValue_MembersInjectionBinding(methodElement,
+          dependencyRequestFactory.forVariables(methodElement.getParameters()));
+    }
+
+    /** Returns the field injection binding for a field annotated with {@link Inject}. */
+    MembersInjectionBinding forInjectField(VariableElement fieldElement) {
+      checkNotNull(fieldElement);
+      checkArgument(fieldElement.getKind().equals(FIELD));
+      checkArgument(fieldElement.getAnnotation(Inject.class) != null);
+      return new AutoValue_MembersInjectionBinding(fieldElement,
+          ImmutableSet.of(dependencyRequestFactory.forVariable(fieldElement)));
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorWriter.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorWriter.java
new file mode 100644
index 000000000..afcf374a6
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorWriter.java
@@ -0,0 +1,415 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.squareup.javawriter.JavaWriter.stringLiteral;
+import static com.squareup.javawriter.JavaWriter.type;
+import static dagger.internal.codegen.JavaWriterUtil.flattenVariableMap;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+
+import com.google.common.base.Ascii;
+import com.google.common.base.CaseFormat;
+import com.google.common.base.Function;
+import com.google.common.base.Joiner;
+import com.google.common.collect.BiMap;
+import com.google.common.collect.ComparisonChain;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.HashBiMap;
+import com.google.common.collect.ImmutableBiMap;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.ImmutableSortedMap;
+import com.google.common.collect.ImmutableSortedSet;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Ordering;
+import com.google.common.collect.SetMultimap;
+import com.squareup.javawriter.JavaWriter;
+
+import dagger.Lazy;
+import dagger.MembersInjector;
+import dagger.internal.DoubleCheckLazy;
+
+import java.io.IOException;
+import java.util.Collection;
+import java.util.EnumSet;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Map.Entry;
+
+import javax.annotation.Generated;
+import javax.annotation.processing.Filer;
+import javax.inject.Inject;
+import javax.inject.Provider;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.Name;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.tools.JavaFileObject;
+
+/**
+ * Writes {@link MembersInjector} implementations from {@link MembersInjectionBinding} instances.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+final class MembersInjectorWriter {
+  private final Filer filer;
+  private final ProviderTypeRepository providerTypeRepository;
+
+  MembersInjectorWriter(Filer filer, ProviderTypeRepository providerTypeRepository) {
+    this.filer = checkNotNull(filer);
+    this.providerTypeRepository = providerTypeRepository;
+  }
+
+  /**
+   * Writes a new source file for the generated {@link MembersInjector}.
+   *
+   * @throws IllegalArgumentException if the given bindings are not all for the same
+   *     {@link MembersInjectionBinding#targetEnclosingType()}.
+   */
+  void write(ImmutableList<MembersInjectionBinding> bindings) throws IOException {
+    checkNotNull(bindings);
+    FluentIterable<MembersInjectionBinding> fluentBindings = FluentIterable.from(bindings);
+    checkArgument(!fluentBindings.isEmpty());
+    TypeElement injectedTypeElement = Iterables.getOnlyElement(fluentBindings
+        .transform(new Function<MembersInjectionBinding, TypeElement>() {
+          @Override public TypeElement apply(MembersInjectionBinding binding) {
+            return binding.targetEnclosingType();
+          }
+        })
+        .toSet());
+
+
+    ClassName injectedClassName = ClassName.fromTypeElement(injectedTypeElement);
+    ClassName injectorClassName =
+        injectedClassName.peerNamed(injectedClassName.simpleName() + "$$MembersInjector");
+
+    JavaFileObject sourceFile = filer.createSourceFile(injectorClassName.fullyQualifiedName(),
+        fluentBindings.transform(new Function<MembersInjectionBinding, Element>() {
+          @Override public Element apply(MembersInjectionBinding binding) {
+            return binding.target();
+          }
+        })
+        .toArray(Element.class));
+
+    JavaWriter writer = new JavaWriter(sourceFile.openWriter());
+    try {
+      writer.emitPackage(injectedClassName.packageName());
+
+
+      for (ClassName className : collectImports(injectorClassName, fluentBindings)) {
+        writer.emitImports(className.fullyQualifiedName());
+      }
+      writer.emitEmptyLine();
+
+      writer.emitJavadoc("A {@link MembersInjector} implementation for {@link %s}.",
+          injectedClassName.simpleName());
+
+      String membersInjectorType = type(MembersInjector.class, injectedClassName.simpleName());
+      // @Generated("dagger.internal.codegen.InjectProcessor")
+      // public final class Blah$$MembersInjector implements MembersInjector<Blah>
+      writer.emitAnnotation(Generated.class, stringLiteral(InjectProcessor.class.getName()))
+          .beginType(injectorClassName.simpleName(), "class", EnumSet.of(FINAL), null,
+              membersInjectorType);
+
+      // Require a Provider/MembersInjector for each request
+      ImmutableSetMultimap.Builder<Key, DependencyRequest> dependenciesByKeyBuilder =
+          new ImmutableSetMultimap.Builder<Key, DependencyRequest>()
+              .orderValuesBy(DEPENDENCY_ORDERING);
+      for (MembersInjectionBinding binding : bindings) {
+        for (DependencyRequest dependency : binding.dependencies()) {
+          dependenciesByKeyBuilder.put(dependency.key(), dependency);
+        }
+      }
+      ImmutableSetMultimap<Key, DependencyRequest> dependenciesByKey =
+          dependenciesByKeyBuilder.build();
+
+
+      final ImmutableBiMap<Key, String> providerNames = generateProviderNames(dependenciesByKey);
+
+      // Add the fields
+      writeProviderFields(writer, providerNames);
+
+      // Add the constructor
+      writeConstructor(writer, providerNames);
+
+      // @Override public void injectMembers(Blah instance)
+      writer.emitAnnotation(Override.class)
+          .beginMethod("void", "injectMembers", EnumSet.of(PUBLIC),
+              injectedClassName.simpleName(), "instance");
+      writer.beginControlFlow("if (instance == null)")
+          .emitStatement(
+              "throw new NullPointerException(\"Cannot inject members into a null reference\")")
+          .endControlFlow();
+
+      for (MembersInjectionBinding binding : bindings) {
+        Element target = binding.target();
+        switch (target.getKind()) {
+          case FIELD:
+            Name fieldName = ((VariableElement) target).getSimpleName();
+            DependencyRequest singleDependency = Iterables.getOnlyElement(binding.dependencies());
+            String providerName = providerNames.get(singleDependency.key());
+            switch (singleDependency.kind()) {
+              case LAZY:
+                writer.emitStatement("instance.%s = %s.create(%s)",
+                    fieldName, DoubleCheckLazy.class.getSimpleName(), providerName);
+                break;
+              case INSTANCE:
+                writer.emitStatement("instance.%s = %s.get()", fieldName, providerName);
+                break;
+              case PROVIDER:
+                writer.emitStatement("instance.%s = %s", fieldName, providerName);
+                break;
+              default:
+                throw new AssertionError();
+            }
+            break;
+          case METHOD:
+            Name methodName = ((ExecutableElement) target).getSimpleName();
+            String parameterString =
+                Joiner.on(", ").join(FluentIterable.from(binding.dependencies())
+                    .transform(new Function<DependencyRequest, String>() {
+                      @Override public String apply(DependencyRequest input) {
+                        String providerName = providerNames.get(input.key());
+                        switch (input.kind()) {
+                          case LAZY:
+                            return String.format("%s.create(%s)",
+                                DoubleCheckLazy.class.getSimpleName(), providerName);
+                          case INSTANCE:
+                            return String.format("%s.get()", providerName);
+                          case PROVIDER:
+                            return String.format("%s", providerName);
+                          default:
+                            throw new AssertionError();
+                        }
+                      }
+                    }));
+            writer.emitStatement("instance.%s(%s)", methodName, parameterString);
+            break;
+          default:
+            throw new IllegalStateException(target.getKind().toString());
+        }
+      }
+      writer.endMethod();
+
+      writeToString(writer, injectedClassName);
+
+      writer.endType();
+    } finally {
+      writer.close();
+      // TODO(gak): clean up malformed files caused by failures
+    }
+  }
+
+  private void writeProviderFields(JavaWriter writer, ImmutableBiMap<Key, String> providerNames)
+      throws IOException {
+    for (Entry<Key, String> providerEntry : providerNames.entrySet()) {
+      Key key = providerEntry.getKey();
+      // TODO(gak): provide more elaborate information about which requests relate
+      writer.emitJavadoc(key.toString())
+          .emitField(providerTypeString(key), providerEntry.getValue(),
+              EnumSet.of(PRIVATE, FINAL));
+    }
+    writer.emitEmptyLine();
+  }
+
+  private void writeConstructor(JavaWriter writer, ImmutableBiMap<Key, String> providerNames)
+      throws IOException {
+    writer.emitAnnotation(Inject.class);
+    writer.beginConstructor(EnumSet.noneOf(Modifier.class),
+        flattenVariableMap(providersAsVariableMap(providerNames)),
+        ImmutableList.<String>of());
+    for (String providerName : providerNames.values()) {
+      writer.emitStatement("assert %s != null", providerName);
+      writer.emitStatement("this.%1$s = %1$s", providerName);
+    }
+    writer.endConstructor().emitEmptyLine();
+  }
+
+  private void writeToString(JavaWriter writer, ClassName injectedClassName) throws IOException {
+    writer.emitAnnotation(Override.class)
+        .beginMethod("String", "toString", EnumSet.of(PUBLIC))
+        .emitStatement("return \"MembersInjector<%s>\"", injectedClassName.simpleName())
+        .endMethod();
+  }
+
+  private Map<String, String> providersAsVariableMap(ImmutableBiMap<Key, String> providerNames) {
+    return Maps.transformValues(providerNames.inverse(), new Function<Key, String>() {
+      @Override public String apply(Key key) {
+        return providerTypeString(key);
+      }
+    });
+  }
+
+  private String providerTypeString(Key key) {
+    return Util.typeToString(providerTypeRepository.getProviderType(key));
+  }
+
+  /**
+   * Returns the sorted set of all classes required by the {@link MembersInjector} implementation
+   * being generated.
+   */
+  private ImmutableSortedSet<ClassName> collectImports(ClassName topLevelClassName,
+      Iterable<MembersInjectionBinding> bindings) {
+    ImmutableSortedSet.Builder<ClassName> builder = ImmutableSortedSet.<ClassName>naturalOrder()
+        .add(ClassName.fromClass(Inject.class))
+        .add(ClassName.fromClass(MembersInjector.class))
+        .add(ClassName.fromClass(Generated.class));
+    ImmutableSet<String> packagesToSkip  =
+        ImmutableSet.of("java.lang", topLevelClassName.packageName());
+    for (MembersInjectionBinding binding : bindings) {
+      for (DependencyRequest dependency : binding.dependencies()) {
+        ImmutableSet<TypeElement> referencedTypes =
+            Mirrors.referencedTypes(dependency.key().type());
+        switch (dependency.kind()) {
+          case LAZY:
+            builder.add(ClassName.fromClass(Lazy.class), ClassName.fromClass(DoubleCheckLazy.class));
+            // fall through
+          case INSTANCE:
+          case PROVIDER:
+            builder.add(ClassName.fromClass(Provider.class));
+            break;
+          default:
+            throw new AssertionError();
+        }
+        for (TypeElement referencedType : referencedTypes) {
+          ClassName className = ClassName.fromTypeElement(referencedType);
+          // don't include classes in java.lang or the same package
+          if (!packagesToSkip.contains(className.packageName())
+              // or that are members of the same top-level class
+              && !className.nameOfTopLevelClass().equals(topLevelClassName)) {
+            builder.add(className);
+          }
+        }
+      }
+    }
+    return builder.build();
+  }
+
+
+  /**
+   * Sorts {@link DependencyRequest} instances in an order likely to reflect their logical
+   * importance.
+   */
+  private static final Ordering<DependencyRequest> DEPENDENCY_ORDERING =
+      new Ordering<DependencyRequest>() {
+        @Override
+        public int compare(DependencyRequest left, DependencyRequest right) {
+          return ComparisonChain.start()
+              // put fields before parameters
+              .compare(left.requestElement().getKind(), right.requestElement().getKind())
+              // order by dependency kind
+              .compare(left.kind(), right.kind())
+              // then sort by name
+              .compare(
+                  left.requestElement().getSimpleName().toString(),
+                  right.requestElement().getSimpleName().toString())
+              .result();
+        }
+      };
+
+  /**
+   * This method generates names for the {@link Provider} references necessary for all of the
+   * bindings. It is responsible for the following:
+   * <ul>
+   * <li>Choosing a name that associates the provider with all of the dependency requests for this
+   * type.
+   * <li>Choosing a name that is <i>probably</i> associated with the type being provided.
+   * <li>Ensuring that no two providers end up with the same name.
+   * </ul>
+   *
+   * @return Returns the mapping from {@link Key} to provider name sorted by the name of the
+   * provider.
+   */
+  private ImmutableBiMap<Key, String> generateProviderNames(
+      SetMultimap<Key, DependencyRequest> dependenciesByKey) {
+    Map<Key, Collection<DependencyRequest>> dependenciesByKeyMap = dependenciesByKey.asMap();
+    BiMap<Key, String> providerNames = HashBiMap.create(dependenciesByKeyMap.size());
+    for (Entry<Key, Collection<DependencyRequest>> entry : dependenciesByKeyMap.entrySet()) {
+      // collect together all of the names that we would want to call the provider
+      ImmutableSet<String> dependencyNames = FluentIterable.from(entry.getValue())
+          .transform(new Function<DependencyRequest, String>() {
+            @Override public String apply(DependencyRequest input) {
+              return nameForDependency(input);
+            }
+          })
+          .toSet();
+
+      final String baseProviderName;
+      if (dependencyNames.size() == 1) {
+        // if there's only one name, great!  use it!
+        String name = Iterables.getOnlyElement(dependencyNames);
+        baseProviderName = name.endsWith("Provider") ? name : name + "Provider";
+      } else {
+        // in the event that a provider is being used for a bunch of deps with different names,
+        // add all the names together with "And"s in the middle.  E.g.: stringAndS
+        Iterator<String> namesIterator = dependencyNames.iterator();
+        String first = namesIterator.next();
+        StringBuilder compositeNameBuilder = new StringBuilder(first);
+        while (namesIterator.hasNext()) {
+          compositeNameBuilder.append("And")
+              .append(CaseFormat.LOWER_CAMEL.to(UPPER_CAMEL, namesIterator.next()));
+        }
+        baseProviderName = compositeNameBuilder.append("Provider").toString();
+      }
+
+      // in the unlikely event that we have more that one provider with the exact same name,
+      // just add numbers at the end until there is no collision
+      String candidateName = baseProviderName;
+      for (int candidateNum = 2; providerNames.containsValue(candidateName); candidateNum++) {
+        candidateName = baseProviderName + candidateNum;
+      }
+
+      providerNames.put(entry.getKey(), candidateName);
+    }
+    // return the map so that it is sorted by name
+    return ImmutableBiMap.copyOf(ImmutableSortedMap.copyOf(providerNames.inverse())).inverse();
+  }
+
+  /**
+   * Picks a reasonable name for what we think is being provided from the variable name associated
+   * with the {@link DependencyRequest}.  I.e. strips out words like "lazy" and "Provider" if we
+   * believe that those refer to {@link Lazy} and {@link Provider} rather than the type being
+   * provided.
+   */
+  // TODO(gak): develop the heuristics to get better names
+  private String nameForDependency(DependencyRequest dependency) {
+    String variableName = dependency.requestElement().getSimpleName().toString();
+    switch (dependency.kind()) {
+      case INSTANCE:
+        return variableName;
+      case LAZY:
+        return variableName.startsWith("lazy") && !variableName.equals("lazy")
+            ? Ascii.toLowerCase(variableName.charAt(4)) + variableName.substring(5)
+            : variableName;
+      case PROVIDER:
+        return variableName.endsWith("Provider") && !variableName.equals("Provider")
+            ? variableName.substring(0, variableName.length() - 8)
+            : variableName;
+      default:
+        throw new AssertionError();
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Mirrors.java b/compiler/src/main/java/dagger/internal/codegen/Mirrors.java
index 4c317002b..ad110df49 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Mirrors.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Mirrors.java
@@ -44,6 +44,7 @@
  * Utilities related to {@link TypeMirror} instances.
  *
  * @author Gregory Kick
+ * @since 2.0
  */
 final class Mirrors {
   private static final Equivalence<TypeMirror> TYPE_EQUIVALENCE = new Equivalence<TypeMirror>() {
@@ -247,6 +248,10 @@ static int hash(TypeMirror mirror) {
     return mirror == null ? 0 : mirror.accept(HASH_VISITOR, null);
   }
 
+  /**
+   * Returns the set of {@linkplain TypeElement types} that are referenced by the given
+   * {@link TypeMirror}.
+   */
   static ImmutableSet<TypeElement> referencedTypes(TypeMirror type) {
     checkNotNull(type);
     ImmutableSet.Builder<TypeElement> elements = ImmutableSet.builder();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProviderTypeRepository.java b/compiler/src/main/java/dagger/internal/codegen/ProviderTypeRepository.java
new file mode 100644
index 000000000..67c7b8eda
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ProviderTypeRepository.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+import com.google.common.cache.CacheBuilder;
+import com.google.common.cache.CacheLoader;
+import com.google.common.cache.LoadingCache;
+
+import javax.inject.Provider;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+/**
+ * A simple repository for {@link Provider} {@link DeclaredType types} for a given {@link Key}. For
+ * example, a key for {@code @Named("foo") Set<String>} would return the type representing
+ * {@code Provider<Set<String>>}.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+final class ProviderTypeRepository {
+  private final LoadingCache<Key, DeclaredType> providerTypeCache;
+
+  ProviderTypeRepository(final Elements elements, final Types types) {
+    checkNotNull(elements);
+    checkNotNull(types);
+    this.providerTypeCache = CacheBuilder.newBuilder()
+        .concurrencyLevel(1)
+        .softValues() // just to make sure we don't OOME the compiler
+        .build(new CacheLoader<Key, DeclaredType>() {
+          TypeElement providerTypeElement =
+              elements.getTypeElement(Provider.class.getCanonicalName());
+
+          @Override public DeclaredType load(Key key) {
+            return types.getDeclaredType(providerTypeElement, key.type());
+          }
+        });
+  }
+
+  DeclaredType getProviderType(Key key) {
+    checkNotNull(key);
+    return providerTypeCache.getUnchecked(key);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
new file mode 100644
index 000000000..237035290
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
+import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableSet;
+
+import dagger.Provides;
+
+import javax.inject.Inject;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+
+/**
+ * A value object representing the mechanism by which a {@link Key} can be provided. New instances
+ * should be created using an instance of the {@link Factory}.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+@AutoValue
+abstract class ProvisionBinding {
+  /**
+   * The {@link Element} that actually implements the binding. This will the
+   * {@link ExecutableElement} for a {@link Provides} method or {@link Inject} constructor.
+   */
+  abstract ExecutableElement bindingElement();
+
+  /** The {@link Key} that is provided by this binding. */
+  abstract Key providedKey();
+
+  /**
+   * The set of {@linkplain DependencyRequest key requests} that satisfy the direct dependencies of
+   * this binding.
+   */
+  abstract ImmutableSet<DependencyRequest> dependencies();
+
+  /** The scope in which the binding declares the {@link #providedKey()}. */
+  abstract Optional<AnnotationMirror> scope();
+
+  static final class Factory {
+    private final DependencyRequest.Factory keyRequestFactory = null;
+
+    ProvisionBinding forInjectConstructor(ExecutableElement constructorElement) {
+      checkNotNull(constructorElement);
+      checkArgument(constructorElement.getKind().equals(CONSTRUCTOR));
+      checkArgument(constructorElement.getAnnotation(Inject.class) != null);
+      Key key = Key.forInjectConstructor(constructorElement);
+      checkArgument(!key.qualifier().isPresent());
+      return new AutoValue_ProvisionBinding(constructorElement, key,
+          keyRequestFactory.forVariables(constructorElement.getParameters()),
+          getScopeAnnotation(constructorElement.getEnclosingElement()));
+    }
+
+    ProvisionBinding forProvidesMethod(ExecutableElement providesMethod) {
+      checkNotNull(providesMethod);
+      checkArgument(providesMethod.getKind().equals(CONSTRUCTOR));
+      checkArgument(providesMethod.getAnnotation(Provides.class) != null);
+      return new AutoValue_ProvisionBinding(providesMethod, Key.forProvidesMethod(providesMethod),
+          keyRequestFactory.forVariables(providesMethod.getParameters()),
+          getScopeAnnotation(providesMethod));
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index db6e79641..0166e5535 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -16,12 +16,17 @@
  */
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+
 import dagger.internal.Keys;
+
 import java.lang.reflect.Method;
 import java.util.Arrays;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.AnnotationValueVisitor;
@@ -356,6 +361,20 @@ static boolean isStatic(Element element) {
     return false;
   }
 
+  static boolean isValidJavaIdentifier(String possibleIdentifier) {
+    checkNotNull(possibleIdentifier);
+    checkArgument(!possibleIdentifier.isEmpty());
+    if (!Character.isJavaIdentifierStart(possibleIdentifier.charAt(0))) {
+      return false;
+    }
+    for (int i = 1; i < possibleIdentifier.length(); i++) {
+      if (!Character.isJavaIdentifierPart(possibleIdentifier.charAt(i))) {
+        return false;
+      }
+    }
+    return true;
+  }
+
   /**
    * An exception thrown when a type is not extant (returns as an error type),
    * usually as a result of another processor not having yet generated its types upon
diff --git a/compiler/src/test/java/dagger/internal/codegen/ClassNameTest.java b/compiler/src/test/java/dagger/internal/codegen/ClassNameTest.java
new file mode 100644
index 000000000..60cd73410
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/ClassNameTest.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static org.junit.Assert.fail;
+import static org.truth0.Truth.ASSERT;
+
+import com.google.common.collect.ImmutableList;
+
+import java.util.Map;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class ClassNameTest {
+  @Test public void bestGuessForString_simpleClass() {
+    ASSERT.that(ClassName.bestGuessFromString(String.class.getName()))
+        .isEqualTo(ClassName.create("java.lang", "String"));
+  }
+
+  @Test public void bestGuessForString_nestedClass() {
+    ASSERT.that(ClassName.bestGuessFromString(Map.Entry.class.getCanonicalName()))
+        .isEqualTo(ClassName.create("java.util", ImmutableList.of("Map"), "Entry"));
+    ASSERT.that(ClassName.bestGuessFromString(ProcessBuilder.Redirect.Type.class.getCanonicalName()))
+        .isEqualTo(
+            ClassName.create("java.lang", ImmutableList.of("ProcessBuilder", "Redirect"), "Type"));
+  }
+
+  @Test public void bestGuessForString_defaultPackage() {
+    ASSERT.that(ClassName.bestGuessFromString("SomeClass"))
+        .isEqualTo(ClassName.create("", "SomeClass"));
+    ASSERT.that(ClassName.bestGuessFromString("SomeClass.Nested"))
+        .isEqualTo(ClassName.create("", ImmutableList.of("SomeClass"), "Nested"));
+    ASSERT.that(ClassName.bestGuessFromString("SomeClass.Nested.EvenMore"))
+        .isEqualTo(ClassName.create("", ImmutableList.of("SomeClass", "Nested"), "EvenMore"));
+  }
+
+  @Test public void bestGuessForString_confusingInput() {
+    try {
+      ClassName.bestGuessFromString("com.test.$");
+      fail();
+    } catch (IllegalArgumentException expected) {}
+    try {
+      ClassName.bestGuessFromString("com.test.LooksLikeAClass.pkg");
+      fail();
+    } catch (IllegalArgumentException expected) {}
+    try {
+      ClassName.bestGuessFromString("!@#$gibberish%^&*");
+      fail();
+    } catch (IllegalArgumentException expected) {}
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java
index a78f59fb2..358806c39 100644
--- a/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java
@@ -40,7 +40,6 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-
 @RunWith(JUnit4.class)
 public final class InjectProcessorTest {
   private static final JavaFileObject QUALIFIER_A =
@@ -269,4 +268,168 @@
         // for whatever reason, javac only reports the error once on the method
         .withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6);
   }
+
+  @Test public void fieldInjection() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.FieldInjection",
+        "package test;",
+        "",
+        "import dagger.Lazy;",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "class FieldInjection {",
+        "  @Inject String string;",
+        "  @Inject Lazy<String> lazyString;",
+        "  @Inject Provider<String> stringProvider;",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines("test.FieldInjection$$MembersInjector",
+        "package test;",
+        "",
+        "import dagger.Lazy;",
+        "import dagger.MembersInjector;",
+        "import dagger.internal.DoubleCheckLazy;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.InjectProcessor\")",
+        "final class FieldInjection$$MembersInjector ",
+        "    implements MembersInjector<FieldInjection> {",
+        "",
+        "  private final Provider<String> stringProvider;",
+        "",
+        "  @Inject FieldInjection$$MembersInjector(Provider<String> stringProvider) {",
+        "    assert stringProvider != null;",
+        "    this.stringProvider = stringProvider;",
+        "  }",
+        "",
+        "  @Override public void injectMembers(FieldInjection instance) {",
+        "    if (instance == null) {",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+        "    }",
+        "    instance.string = stringProvider.get();",
+        "    instance.lazyString = DoubleCheckLazy.create(stringProvider);",
+        "    instance.stringProvider = stringProvider;",
+        "  }",
+        "",
+        "  @Override public String toString() {",
+        "    return \"MembersInjector<FieldInjection>\";",
+        "  }",
+        "}");
+    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test public void methodInjection() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.MethodInjection",
+        "package test;",
+        "",
+        "import dagger.Lazy;",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "class MethodInjection {",
+        "  @Inject void noArgs() {}",
+        "  @Inject void oneArg(String string) {}",
+        "  @Inject void manyArgs(",
+        "      String string, Lazy<String> lazyString, Provider<String> stringProvider) {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines(
+        "test.MethodInjection$$MembersInjector",
+        "package test;",
+        "",
+        "import dagger.Lazy;",
+        "import dagger.MembersInjector;",
+        "import dagger.internal.DoubleCheckLazy;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.InjectProcessor\")",
+        "final class MethodInjection$$MembersInjector ",
+        "    implements MembersInjector<MethodInjection> {",
+        "",
+        "  private final Provider<String> stringProvider;",
+        "",
+        "  @Inject MethodInjection$$MembersInjector(Provider<String> stringProvider) {",
+        "    assert stringProvider != null;",
+        "    this.stringProvider = stringProvider;",
+        "  }",
+        "",
+        "  @Override public void injectMembers(MethodInjection instance) {",
+        "    if (instance == null) {",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+        "    }",
+        "    instance.noArgs();",
+        "    instance.oneArg(stringProvider.get());",
+        "    instance.manyArgs(stringProvider.get(), DoubleCheckLazy.create(stringProvider),",
+        "        stringProvider);",
+        "  }",
+        "",
+        "  @Override public String toString() {",
+        "    return \"MembersInjector<MethodInjection>\";",
+        "  }",
+        "}");
+    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test public void mixedMemberInjection() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.MixedMemberInjection",
+        "package test;",
+        "",
+        "import dagger.Lazy;",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "class MixedMemberInjection {",
+        "  @Inject String string;",
+        "  @Inject void setString(String s) {}",
+        "  @Inject Object object;",
+        "  @Inject void setObject(Object o) {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines(
+        "test.MixedMemberInjection$$MembersInjector",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.InjectProcessor\")",
+        "final class MixedMemberInjection$$MembersInjector ",
+        "    implements MembersInjector<MixedMemberInjection> {",
+        "",
+        "  private final Provider<Object> objectAndOProvider;",
+        "  private final Provider<String> stringAndSProvider;",
+        "",
+        "  @Inject MixedMemberInjection$$MembersInjector(Provider<Object> objectAndOProvider,",
+        "      Provider<String> stringAndSProvider) {",
+        "    assert objectAndOProvider != null;",
+        "    this.objectAndOProvider = objectAndOProvider;",
+        "    assert stringAndSProvider != null;",
+        "    this.stringAndSProvider = stringAndSProvider;",
+        "  }",
+        "",
+        "  @Override public void injectMembers(MixedMemberInjection instance) {",
+        "    if (instance == null) {",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+        "    }",
+        "    instance.string = stringAndSProvider.get();",
+        "    instance.object = objectAndOProvider.get();",
+        "    instance.setString(stringAndSProvider.get());",
+        "    instance.setObject(objectAndOProvider.get());",
+        "  }",
+        "",
+        "  @Override public String toString() {",
+        "    return \"MembersInjector<MixedMemberInjection>\";",
+        "  }",
+        "}");
+    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
 }
diff --git a/core/pom.xml b/core/pom.xml
index c9780ea86..401e02cb4 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -32,6 +32,11 @@
       <artifactId>javax.inject</artifactId>
     </dependency>
 
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+      <scope>test</scope>
+    </dependency>
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
diff --git a/core/src/main/java/dagger/Lazy.java b/core/src/main/java/dagger/Lazy.java
index 6b064661c..59419abd3 100644
--- a/core/src/main/java/dagger/Lazy.java
+++ b/core/src/main/java/dagger/Lazy.java
@@ -21,6 +21,10 @@
  * the first call to {@code get()} and remembers that same value for all
  * subsequent calls to {@code get()}.
  *
+ * <p>{@code null} is not a supported value.  Implementations of {@code Lazy}
+ * are expected to throw {@link NullPointerException} if the computed value is
+ * {@code null}.
+ *
  * <h2>Example</h2>
  * The differences between <strong>direct injection</strong>, <strong>provider
  * injection</strong> and <strong>lazy injection</strong> are best demonstrated
@@ -148,6 +152,8 @@
   /**
    * Return the underlying value, computing the value if necessary. All calls to
    * the same {@code Lazy} instance will return the same result.
+   *
+   * @throws NullPointerException if the computed value is {@code null}.
    */
   T get();
 }
diff --git a/core/src/main/java/dagger/MembersInjector.java b/core/src/main/java/dagger/MembersInjector.java
index 372c9f585..d0de7f396 100644
--- a/core/src/main/java/dagger/MembersInjector.java
+++ b/core/src/main/java/dagger/MembersInjector.java
@@ -17,26 +17,28 @@
 package dagger;
 
 /**
- * Injects dependencies into the fields and methods on instances of type
- * {@code T}. Ignores the presence or absence of an injectable constructor.
+ * Injects dependencies into the fields and methods on instances of type {@code T}. Ignores the
+ * presence or absence of an injectable constructor.
  *
  * @param <T> type to inject members of
  *
  * @author Bob Lee
  * @author Jesse Wilson
+ * @since 2.0 (since 1.0 without the provision that {@link #injectMembers} cannot accept
+ *      {@code null})
  */
 public interface MembersInjector<T> {
 
   /**
-   * Injects dependencies into the fields and methods of {@code instance}.
-   * Ignores the presence or absence of an injectable constructor.
+   * Injects dependencies into the fields and methods of {@code instance}. Ignores the presence or
+   * absence of an injectable constructor.
    *
-   * <p>Whenever the object graph creates an instance, it performs this
-   * injection automatically (after first performing constructor injection), so
-   * if you're able to let the object graph create all your objects for you,
-   * you'll never need to use this method.
+   * <p>Whenever the object graph creates an instance, it performs this injection automatically
+   * (after first performing constructor injection), so if you're able to let the object graph
+   * create all your objects for you, you'll never need to use this method.
    *
-   * @param instance to inject members on. May be {@code null}.
+   * @param instance into which members are to be injected
+   * @throws NullPointerException if {@code instance} is {@code null}
    */
   void injectMembers(T instance);
 }
diff --git a/core/src/main/java/dagger/internal/DoubleCheckLazy.java b/core/src/main/java/dagger/internal/DoubleCheckLazy.java
new file mode 100644
index 000000000..e18526ea1
--- /dev/null
+++ b/core/src/main/java/dagger/internal/DoubleCheckLazy.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import dagger.Lazy;
+
+import javax.inject.Provider;
+
+/**
+ * A basic {@link Lazy} implementation that memoizes the value returned from a {@link Provider}
+ * using the double-check idiom described in Effective Java 2: Item 71.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+public final class DoubleCheckLazy<T> implements Lazy<T> {
+  private final Provider<T> provider;
+  private volatile T instance = null;
+
+  private DoubleCheckLazy(Provider<T> provider) {
+    assert provider != null;
+    this.provider = provider;
+  }
+
+  @Override
+  public T get() {
+    T result = instance;
+    if (result == null) {
+      synchronized (this) {
+        result = instance;
+        if (result == null) {
+          instance = result = provider.get();
+          if (result == null) {
+            throw new NullPointerException(provider + " returned null");
+          }
+        }
+      }
+    }
+    return result;
+  }
+
+  public static <T> Lazy<T> create(Provider<T> provider) {
+    if (provider == null) {
+      throw new NullPointerException();
+    }
+    return new DoubleCheckLazy<T>(provider);
+  }
+}
diff --git a/core/src/main/java/dagger/internal/LazyBinding.java b/core/src/main/java/dagger/internal/LazyBinding.java
index c1e1c715c..ef6f11c98 100644
--- a/core/src/main/java/dagger/internal/LazyBinding.java
+++ b/core/src/main/java/dagger/internal/LazyBinding.java
@@ -47,6 +47,7 @@ public void attach(Linker linker) {
 
   @Override
   public Lazy<T> get() {
+    // TODO(gak): Use DoubleCheckLazy
     return new Lazy<T>() {
       private volatile Object cacheValue = NOT_PRESENT;
 
diff --git a/core/src/main/java/dagger/internal/NoOpMembersInjector.java b/core/src/main/java/dagger/internal/NoOpMembersInjector.java
new file mode 100644
index 000000000..dd15e86de
--- /dev/null
+++ b/core/src/main/java/dagger/internal/NoOpMembersInjector.java
@@ -0,0 +1,24 @@
+package dagger.internal;
+
+import dagger.MembersInjector;
+
+/**
+ * A {@link MembersInjector} implementation that injects no members; a valid null object for types
+ * that have no members (or inherited members) annotated with {@link javax.inject.Inject}.
+ *
+ * @since 2.0
+ */
+public final class NoOpMembersInjector<T> implements MembersInjector<T> {
+  @SuppressWarnings("unchecked")
+  public <T> MembersInjector<T> create() {
+    // this cast is safe because this members injector is a no-op
+    return (MembersInjector<T>) INSTANCE;
+  }
+
+  private static final NoOpMembersInjector<Object> INSTANCE = new NoOpMembersInjector<Object>() ;
+
+  @Override
+  public void injectMembers(T instance) {}
+
+  private NoOpMembersInjector () {}
+}
diff --git a/core/src/test/java/dagger/internal/DoubleCheckLazyTest.java b/core/src/test/java/dagger/internal/DoubleCheckLazyTest.java
new file mode 100644
index 000000000..6e64f6ec5
--- /dev/null
+++ b/core/src/test/java/dagger/internal/DoubleCheckLazyTest.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import static org.junit.Assert.fail;
+import static org.truth0.Truth.ASSERT;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Sets;
+import com.google.common.util.concurrent.Uninterruptibles;
+
+import dagger.Lazy;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.Callable;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import javax.inject.Provider;
+
+@RunWith(JUnit4.class)
+public class DoubleCheckLazyTest {
+  @Test public void get() throws Exception {
+    int numThreads = 10;
+    ExecutorService executor = Executors.newFixedThreadPool(numThreads);
+
+    final CountDownLatch latch = new CountDownLatch(numThreads);
+    LatchedProvider provider = new LatchedProvider(latch);
+    final Lazy<Object> lazy = DoubleCheckLazy.create(provider);
+
+    List<Callable<Object>> tasks = Lists.newArrayListWithCapacity(numThreads);
+    for (int i = 0; i < numThreads; i++) {
+      tasks.add(new Callable<Object>() {
+        @Override public Object call() throws Exception {
+          latch.countDown();
+          return lazy.get();
+        }
+      });
+    }
+
+    List<Future<Object>> futures = executor.invokeAll(tasks);
+
+    ASSERT.that(provider.provisions.get()).is(1);
+    Set<Object> results = Sets.newIdentityHashSet();
+    for (Future<Object> future : futures) {
+      results.add(future.get());
+    }
+    ASSERT.that(results.size()).is(1);
+  }
+
+  @Test public void get_null() {
+    Lazy<Object> lazy = DoubleCheckLazy.create(new Provider<Object> () {
+      @Override public Object get() {
+        return null;
+      }
+    });
+    try {
+      lazy.get();
+      fail();
+    } catch (NullPointerException expected) {}
+  }
+
+  private static class LatchedProvider implements Provider<Object> {
+    final AtomicInteger provisions;
+    final CountDownLatch latch;
+
+    LatchedProvider(CountDownLatch latch) {
+      this.latch = latch;
+      this.provisions = new AtomicInteger();
+    }
+
+    @Override
+    public Object get() {
+      if (latch != null) {
+        Uninterruptibles.awaitUninterruptibly(latch);
+      }
+      provisions.incrementAndGet();
+      return new Object();
+    }
+  }
+}
