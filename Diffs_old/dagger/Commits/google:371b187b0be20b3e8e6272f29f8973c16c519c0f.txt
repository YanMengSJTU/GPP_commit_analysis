diff --git a/compiler/src/it/functional-tests/src/main/java/test/ComponentSupertypeDependsOnGeneratedCode.java b/compiler/src/it/functional-tests/src/main/java/test/ComponentSupertypeDependsOnGeneratedCode.java
new file mode 100644
index 000000000..f7460c989
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/ComponentSupertypeDependsOnGeneratedCode.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Component;
+
+@Component
+interface ComponentSupertypeDependsOnGeneratedCode
+    extends ComponentSupertypeDependsOnGeneratedCodeInterface {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ComponentSupertypeDependsOnGeneratedCodeInterface.java b/compiler/src/it/functional-tests/src/main/java/test/ComponentSupertypeDependsOnGeneratedCodeInterface.java
new file mode 100644
index 000000000..fca90e0f3
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/ComponentSupertypeDependsOnGeneratedCodeInterface.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+interface ComponentSupertypeDependsOnGeneratedCodeInterface {
+  NeedsFactory_SomethingFactory somethingFactory();
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentProcessingStep.java
index 4c2e44d37..f78d1ac0d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentProcessingStep.java
@@ -32,16 +32,19 @@
 
   private final Messager messager;
   private final BindingGraphValidator bindingGraphValidator;
+  private final ComponentDescriptor.Factory componentDescriptorFactory;
   private final BindingGraph.Factory bindingGraphFactory;
   private final ComponentGenerator componentGenerator;
 
   AbstractComponentProcessingStep(
       Messager messager,
       BindingGraphValidator bindingGraphValidator,
+      ComponentDescriptor.Factory componentDescriptorFactory,
       BindingGraph.Factory bindingGraphFactory,
       ComponentGenerator componentGenerator) {
     this.messager = messager;
     this.bindingGraphValidator = bindingGraphValidator;
+    this.componentDescriptorFactory = componentDescriptorFactory;
     this.bindingGraphFactory = bindingGraphFactory;
     this.componentGenerator = componentGenerator;
   }
@@ -50,8 +53,10 @@
   public final ImmutableSet<Element> process(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
     ImmutableSet.Builder<Element> rejectedElements = ImmutableSet.builder();
-    for (ComponentDescriptor componentDescriptor : componentDescriptors(elementsByAnnotation)) {
+    for (TypeElement componentTypeElement : componentTypeElements(elementsByAnnotation)) {
       try {
+        ComponentDescriptor componentDescriptor =
+            componentDescriptorFactory.forComponent(componentTypeElement);
         BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
         ValidationReport<TypeElement> graphReport = bindingGraphValidator.validate(bindingGraph);
         graphReport.printMessagesTo(messager);
@@ -63,16 +68,15 @@
           }
         }
       } catch (TypeNotPresentException e) {
-        rejectedElements.add(componentDescriptor.componentDefinitionType());
+        rejectedElements.add(componentTypeElement);
       }
     }
     return rejectedElements.build();
   }
 
   /**
-   * Returns a {@link ComponentDescriptor} for each valid component element for which an
-   * implementation class should be generated.
+   * Returns the elements that represent valid components to process.
    */
-  protected abstract Set<ComponentDescriptor> componentDescriptors(
+  protected abstract Set<TypeElement> componentTypeElements(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation);
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 906be8a57..2f20482d5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -31,6 +31,7 @@
 import dagger.Subcomponent;
 import dagger.producers.ProductionComponent;
 import java.lang.annotation.Annotation;
+import java.util.EnumSet;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
@@ -49,6 +50,7 @@
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.ConfigurationAnnotations.enclosedBuilders;
@@ -72,16 +74,40 @@
   ComponentDescriptor() {}
 
   enum Kind {
-    COMPONENT(Component.class, Component.Builder.class),
-    SUBCOMPONENT(Subcomponent.class, Subcomponent.Builder.class),
-    PRODUCTION_COMPONENT(ProductionComponent.class, null);
+    COMPONENT(Component.class, Component.Builder.class, true),
+    SUBCOMPONENT(Subcomponent.class, Subcomponent.Builder.class, false),
+    PRODUCTION_COMPONENT(ProductionComponent.class, null, true);
 
     private final Class<? extends Annotation> annotationType;
     private final Class<? extends Annotation> builderType;
+    private final boolean isTopLevel;
+
+    /**
+     * Returns the kind of an annotated element if it is annotated with one of the
+     * {@linkplain #annotationType() annotation types}.
+     * 
+     * @throws IllegalArgumentException if the element is annotated with more than one of the
+     *     annotation types
+     */
+    static Optional<Kind> forAnnotatedElement(TypeElement element) {
+      Set<Kind> kinds = EnumSet.noneOf(Kind.class);
+      for (Kind kind : values()) {
+        if (MoreElements.isAnnotationPresent(element, kind.annotationType())) {
+          kinds.add(kind);
+        }
+      }
+      checkArgument(
+          kinds.size() <= 1, "%s cannot be annotated with more than one of %s", element, kinds);
+      return Optional.fromNullable(getOnlyElement(kinds, null));
+    }
 
-    Kind(Class<? extends Annotation> annotationType, Class<? extends Annotation> builderType) {
+    Kind(
+        Class<? extends Annotation> annotationType,
+        Class<? extends Annotation> builderType,
+        boolean isTopLevel) {
       this.annotationType = annotationType;
       this.builderType = builderType;
+      this.isTopLevel = isTopLevel;
     }
 
     Class<? extends Annotation> annotationType() {
@@ -91,6 +117,10 @@
     Class<? extends Annotation> builderAnnotationType() {
       return builderType;
     }
+
+    boolean isTopLevel() {
+      return isTopLevel;
+    }
   }
 
   abstract Kind kind();
@@ -202,12 +232,17 @@
       this.moduleDescriptorFactory = moduleDescriptorFactory;
     }
 
+    /**
+     * Returns a component descriptor for a type annotated with either {@link Component @Component}
+     * or {@link ProductionComponent @ProductionComponent}.
+     */
     ComponentDescriptor forComponent(TypeElement componentDefinitionType) {
-      return create(componentDefinitionType, Kind.COMPONENT);
-    }
-
-    ComponentDescriptor forProductionComponent(TypeElement componentDefinitionType) {
-      return create(componentDefinitionType, Kind.PRODUCTION_COMPONENT);
+      Optional<Kind> kind = Kind.forAnnotatedElement(componentDefinitionType);
+      checkArgument(
+          kind.isPresent() && kind.get().isTopLevel(),
+          "%s must be annotated with @Component or @ProductionComponent",
+          componentDefinitionType);
+      return create(componentDefinitionType, kind.get());
     }
 
     private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kind) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
index 18636fe18..c9c8d5514 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -43,7 +43,6 @@
   private final ComponentValidator subcomponentValidator;
   private final BuilderValidator componentBuilderValidator;
   private final BuilderValidator subcomponentBuilderValidator;
-  private final ComponentDescriptor.Factory componentDescriptorFactory;
 
   ComponentProcessingStep(
       Messager messager,
@@ -58,6 +57,7 @@
     super(
         messager,
         bindingGraphValidator,
+        componentDescriptorFactory,
         bindingGraphFactory,
         componentGenerator);
     this.messager = messager;
@@ -65,7 +65,6 @@
     this.subcomponentValidator = subcomponentValidator;
     this.componentBuilderValidator = componentBuilderValidator;
     this.subcomponentBuilderValidator = subcomponentBuilderValidator;
-    this.componentDescriptorFactory = componentDescriptorFactory;
   }
 
   @Override
@@ -75,7 +74,7 @@
   }
 
   @Override
-  protected ImmutableSet<ComponentDescriptor> componentDescriptors(
+  protected Set<TypeElement> componentTypeElements(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
     Map<Element, ValidationReport<TypeElement>> builderReportsByComponent =
         processComponentBuilders(elementsByAnnotation.get(Component.Builder.class));
@@ -87,7 +86,7 @@
         processSubcomponents(subcomponentElements, subcomponentBuilderElements);
     Set<Element> componentElements = elementsByAnnotation.get(Component.class);
 
-    ImmutableSet.Builder<ComponentDescriptor> builder = ImmutableSet.builder();
+    ImmutableSet.Builder<TypeElement> componentTypeElements = ImmutableSet.builder();
     for (Element element : componentElements) {
       TypeElement componentTypeElement = MoreElements.asType(element);
       ComponentValidationReport report = componentValidator.validate(
@@ -95,14 +94,10 @@
       report.report().printMessagesTo(messager);
       if (isClean(
           report, builderReportsByComponent, reportsBySubcomponent, builderReportsBySubcomponent)) {
-        try {
-          builder.add(componentDescriptorFactory.forComponent(componentTypeElement));
-        } catch (TypeNotPresentException e) {
-          // just skip it and get it later
-        }
+        componentTypeElements.add(componentTypeElement);
       }
     }
-    return builder.build();
+    return componentTypeElements.build();
   }
 
   private Map<Element, ValidationReport<TypeElement>> processComponentBuilders(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java
index a424d12b4..c7cd790b8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java
@@ -35,7 +35,6 @@
 final class ProductionComponentProcessingStep extends AbstractComponentProcessingStep {
   private final Messager messager;
   private final ProductionComponentValidator componentValidator;
-  private final ComponentDescriptor.Factory componentDescriptorFactory;
 
   ProductionComponentProcessingStep(
       Messager messager,
@@ -47,11 +46,11 @@
     super(
         messager,
         bindingGraphValidator,
+        componentDescriptorFactory,
         bindingGraphFactory,
         componentGenerator);
     this.messager = messager;
     this.componentValidator = componentValidator;
-    this.componentDescriptorFactory = componentDescriptorFactory;
   }
 
   @Override
@@ -60,9 +59,9 @@
   }
 
   @Override
-  protected ImmutableSet<ComponentDescriptor> componentDescriptors(
+  protected Set<TypeElement> componentTypeElements(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    ImmutableSet.Builder<ComponentDescriptor> componentDescriptors = ImmutableSet.builder();
+    ImmutableSet.Builder<TypeElement> componentTypeElements = ImmutableSet.builder();
     Set<Element> componentElements = elementsByAnnotation.get(ProductionComponent.class);
     for (Element element : componentElements) {
       TypeElement componentTypeElement = MoreElements.asType(element);
@@ -70,10 +69,9 @@
           componentValidator.validate(componentTypeElement);
       componentReport.printMessagesTo(messager);
       if (componentReport.isClean()) {
-        componentDescriptors.add(
-            componentDescriptorFactory.forProductionComponent(componentTypeElement));
+        componentTypeElements.add(componentTypeElement);
       }
     }
-    return componentDescriptors.build();
+    return componentTypeElements.build();
   }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index 444dd1086..189ed7fb3 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -37,6 +37,7 @@
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT;
+import static javax.tools.StandardLocation.SOURCE_OUTPUT;
 
 @RunWith(JUnit4.class)
 public class ComponentProcessorTest {
@@ -1798,7 +1799,6 @@ public void generatedTransitiveModule() {
         .withErrorContaining(
             "test.B<? extends test.A> cannot be provided without an @Provides-annotated method");
   }
-
   @Test
   public void componentImplicitlyDependsOnGeneratedType() {
     JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
@@ -1813,9 +1813,6 @@ public void componentImplicitlyDependsOnGeneratedType() {
         "package test;",
         "",
         "import dagger.Component;",
-        "import dagger.Lazy;",
-        "",
-        "import javax.inject.Provider;",
         "",
         "@Component",
         "interface SimpleComponent {",
@@ -1825,7 +1822,8 @@ public void componentImplicitlyDependsOnGeneratedType() {
         .that(ImmutableList.of(injectableTypeFile, componentFile))
         .processedWith(
             new ComponentProcessor(),
-            new GeneratingProcessor("test.GeneratedType",
+            new GeneratingProcessor(
+                "test.GeneratedType",
                 "package test;",
                 "",
                 "import javax.inject.Inject;",
@@ -1833,7 +1831,45 @@ public void componentImplicitlyDependsOnGeneratedType() {
                 "final class GeneratedType {",
                 "  @Inject GeneratedType() {}",
                 "}"))
-        .compilesWithoutError();
+        .compilesWithoutError()
+        .and()
+        .generatesFileNamed(SOURCE_OUTPUT, "test", "DaggerSimpleComponent.java");
+  }
+  @Test
+  public void componentSupertypeDependsOnGeneratedType() {
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface SimpleComponent extends SimpleComponentInterface {}");
+    JavaFileObject interfaceFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponentInterface",
+            "package test;",
+            "",
+            "interface SimpleComponentInterface {",
+            "  GeneratedType generatedType();",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(componentFile, interfaceFile))
+        .processedWith(
+            new ComponentProcessor(),
+            new GeneratingProcessor(
+                "test.GeneratedType",
+                "package test;",
+                "",
+                "import javax.inject.Inject;",
+                "",
+                "final class GeneratedType {",
+                "  @Inject GeneratedType() {}",
+                "}"))
+        .compilesWithoutError()
+        .and()
+        .generatesFileNamed(SOURCE_OUTPUT, "test", "DaggerSimpleComponent.java");
   }
 
   @Test
