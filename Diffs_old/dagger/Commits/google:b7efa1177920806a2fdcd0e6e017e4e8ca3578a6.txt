diff --git a/README.md b/README.md
index ed9db7ccb..b035cc66e 100644
--- a/README.md
+++ b/README.md
@@ -19,13 +19,13 @@ Square, Google, and other contributors.
 
 ## Status
 
-  - ***Release Version:* 2.1**
-  - ***Snapshot Version:* 2.2-SNAPSHOT**
+  - ***Release Version:* 2.2**
+  - ***Snapshot Version:* 2.3-SNAPSHOT**
 
 Dagger is currently in active development, primarily internally at Google,
 with regular pushes to the open-source community. Snapshot releases are
 auto-deployed to sonatype's central maven repository on a clean build with
-the version `2.2-SNAPSHOT`.
+the version `2.3-SNAPSHOT`.
 
 ## Documentation
 
@@ -53,12 +53,12 @@ of your `pom.xml` and the `dagger-compiler` artifact as either an `optional` or
   <dependency>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger</artifactId>
-    <version>2.1</version>
+    <version>2.2</version>
   </dependency>
   <dependency>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-compiler</artifactId>
-    <version>2.1</version>
+    <version>2.2</version>
     <optional>true</optional>
   </dependency>
 </dependencies>
@@ -72,7 +72,7 @@ parallelizable execution graphs), then add this to your maven configuration:
   <dependency>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-producers</artifactId>
-    <version>2.1</version>
+    <version>2.2</version>
   </dependency>
 </dependencies>
 ```
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ComponentWithReusableBindings.java b/compiler/src/it/functional-tests/src/main/java/test/ComponentWithReusableBindings.java
new file mode 100644
index 000000000..059794257
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/ComponentWithReusableBindings.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.Reusable;
+import dagger.Subcomponent;
+import javax.inject.Qualifier;
+
+@Component(modules = ComponentWithReusableBindings.ReusableBindingsModule.class)
+interface ComponentWithReusableBindings {
+
+  @Qualifier
+  @interface InParent {}
+
+  @Qualifier
+  @interface InChildren {}
+
+  @InParent
+  Object reusableInParent();
+
+  ChildOne childOne();
+
+  ChildTwo childTwo();
+
+  @Subcomponent
+  interface ChildOne {
+    @InParent
+    Object reusableInParent();
+
+    @InChildren
+    Object reusableInChild();
+  }
+
+  @Subcomponent
+  interface ChildTwo {
+    @InParent
+    Object reusableInParent();
+
+    @InChildren
+    Object reusableInChild();
+  }
+
+  @Module
+  static class ReusableBindingsModule {
+    @Provides
+    @Reusable
+    @InParent
+    static Object inParent() {
+      return new Object();
+    }
+
+    @Provides
+    @Reusable
+    @InChildren
+    static Object inChildren() {
+      return new Object();
+    }
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java b/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java
index 25b28542d..95d6508cf 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java
@@ -20,7 +20,7 @@
 import dagger.Module;
 import dagger.Provides;
 import dagger.Subcomponent;
-import dagger.mapkeys.StringKey;
+import dagger.multibindings.StringKey;
 import java.util.Map;
 import javax.inject.Inject;
 import javax.inject.Provider;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/MultibindingSubcomponents.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/MultibindingSubcomponents.java
index a9f0a1e0f..4ecf8caf3 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/MultibindingSubcomponents.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/MultibindingSubcomponents.java
@@ -19,7 +19,7 @@
 import dagger.Module;
 import dagger.Provides;
 import dagger.Subcomponent;
-import dagger.mapkeys.StringKey;
+import dagger.multibindings.StringKey;
 import java.util.Map;
 import java.util.Objects;
 import java.util.Set;
diff --git a/compiler/src/it/functional-tests/src/test/java/test/ReusableTest.java b/compiler/src/it/functional-tests/src/test/java/test/ReusableTest.java
new file mode 100644
index 000000000..acc212ddc
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/ReusableTest.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import test.ComponentWithReusableBindings.ChildOne;
+import test.ComponentWithReusableBindings.ChildTwo;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public class ReusableTest {
+  @Test
+  public void testReusable() {
+    ComponentWithReusableBindings parent = DaggerComponentWithReusableBindings.create();
+    ChildOne childOne = parent.childOne();
+    ChildTwo childTwo = parent.childTwo();
+
+    Object reusableInParent = parent.reusableInParent();
+    assertThat(parent.reusableInParent()).isSameAs(reusableInParent);
+    assertThat(childOne.reusableInParent()).isSameAs(reusableInParent);
+    assertThat(childTwo.reusableInParent()).isSameAs(reusableInParent);
+
+    Object reusableFromChildOne = childOne.reusableInChild();
+    assertThat(childOne.reusableInChild()).isSameAs(reusableFromChildOne);
+
+    Object reusableFromChildTwo = childTwo.reusableInChild();
+    assertThat(childTwo.reusableInChild()).isSameAs(reusableFromChildTwo);
+
+    assertThat(reusableFromChildTwo).isNotSameAs(reusableFromChildOne);
+  }
+}
diff --git a/compiler/src/it/tck/pom.xml b/compiler/src/it/tck/pom.xml
index cc4b196cc..ecbcb34f5 100644
--- a/compiler/src/it/tck/pom.xml
+++ b/compiler/src/it/tck/pom.xml
@@ -28,6 +28,11 @@ limitations under the License.
   <artifactId>tck</artifactId>
   <name>TCK</name>
   <dependencies>
+    <dependency>
+      <!-- Force the correct version of Guava to be on the classpath. -->
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+    </dependency>
     <dependency>
       <groupId>com.google.dagger</groupId>
       <artifactId>dagger</artifactId>
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 6b944466b..d7eb38720 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -85,10 +85,12 @@
 import static dagger.internal.codegen.MemberSelect.noOpMembersInjector;
 import static dagger.internal.codegen.MemberSelect.staticMethod;
 import static dagger.internal.codegen.MembersInjectionBinding.Strategy.NO_OP;
+import static dagger.internal.codegen.Scope.reusableScope;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
 import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
 import static dagger.internal.codegen.TypeNames.DELEGATE_FACTORY;
+import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
 import static dagger.internal.codegen.TypeNames.FACTORY;
 import static dagger.internal.codegen.TypeNames.ILLEGAL_STATE_EXCEPTION;
 import static dagger.internal.codegen.TypeNames.INSTANCE_FACTORY;
@@ -101,10 +103,10 @@
 import static dagger.internal.codegen.TypeNames.MEMBERS_INJECTORS;
 import static dagger.internal.codegen.TypeNames.PRODUCER;
 import static dagger.internal.codegen.TypeNames.PRODUCERS;
-import static dagger.internal.codegen.TypeNames.SCOPED_PROVIDER;
 import static dagger.internal.codegen.TypeNames.SET_FACTORY;
 import static dagger.internal.codegen.TypeNames.SET_OF_PRODUCED_PRODUCER;
 import static dagger.internal.codegen.TypeNames.SET_PRODUCER;
+import static dagger.internal.codegen.TypeNames.SIMPLE_LAZILY_INITIALIZED_PROVIDER;
 import static dagger.internal.codegen.TypeNames.STRING;
 import static dagger.internal.codegen.TypeNames.UNSUPPORTED_OPERATION_EXCEPTION;
 import static dagger.internal.codegen.TypeNames.providerOf;
@@ -927,7 +929,7 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
                   generatedClassNameForBinding(binding),
                   makeParametersCodeBlock(arguments));
           return binding.scope().isPresent()
-              ? CodeBlocks.format("$T.create($L)", SCOPED_PROVIDER, factoryCreate)
+              ? decorateForScope(factoryCreate, binding.scope().get())
               : factoryCreate;
         }
 
@@ -994,6 +996,12 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
     }
   }
 
+  private CodeBlock decorateForScope(CodeBlock factoryCreate, Scope scope) {
+    return scope.equals(reusableScope(elements))
+        ? CodeBlocks.format("$T.create($L)", SIMPLE_LAZILY_INITIALIZED_PROVIDER, factoryCreate)
+        : CodeBlocks.format("$T.provider($L)", DOUBLE_CHECK, factoryCreate);
+  }
+
   private CodeBlock nullableAnnotation(Optional<DeclaredType> nullableType) {
     return nullableType.isPresent()
         ? CodeBlocks.format("@$T ", TypeName.get(nullableType.get()))
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 5b06e828a..d9cd68f1b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -32,6 +32,7 @@
 import com.google.common.collect.Sets;
 import com.google.common.collect.TreeTraverser;
 import dagger.Component;
+import dagger.Reusable;
 import dagger.Subcomponent;
 import dagger.internal.codegen.BindingType.HasBindingType;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
@@ -59,6 +60,7 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Predicates.in;
 import static com.google.common.base.Verify.verify;
+import static dagger.internal.codegen.BindingKey.Kind.CONTRIBUTION;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
 import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor.isOfKind;
@@ -68,6 +70,7 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ContributionBinding.Kind.IS_SYNTHETIC_MULTIBINDING_KIND;
 import static dagger.internal.codegen.Key.indexByKey;
+import static dagger.internal.codegen.Scope.reusableScope;
 import static javax.lang.model.element.Modifier.STATIC;
 
 /**
@@ -491,6 +494,18 @@ private boolean isResolvedInParent(DependencyRequest request, ContributionBindin
       }
 
       private Optional<Resolver> getOwningResolver(ContributionBinding binding) {
+        if (binding.scope().isPresent() && binding.scope().get().equals(reusableScope(elements))) {
+          for (Resolver requestResolver : getResolverLineage().reverse()) {
+            // If a @Reusable binding was resolved in an ancestor, use that component.
+            if (requestResolver.resolvedBindings.containsKey(
+                BindingKey.create(CONTRIBUTION, binding.key()))) {
+              return Optional.of(requestResolver);
+            }
+          }
+          // If a @Reusable binding was not resolved in any ancestor, resolve it here.
+          return Optional.absent();
+        }
+
         for (Resolver requestResolver : getResolverLineage().reverse()) {
           if (requestResolver.explicitBindingsSet.contains(binding)) {
             return Optional.of(requestResolver);
@@ -724,11 +739,12 @@ public Boolean call() {
         }
 
         /**
-         * Returns {@code true} if {@code binding} is unscoped and depends on multibindings with
-         * contributions declared within this component's modules, or if any of its unscoped
-         * dependencies depend on such local multibindings.
+         * Returns {@code true} if {@code binding} is unscoped (or has {@link Reusable @Reusable}
+         * scope) and depends on multibindings with contributions declared within this component's
+         * modules, or if any of its unscoped or {@link Reusable @Reusable} scoped dependencies
+         * depend on such local multibindings.
          *
-         * <p>We don't care about scoped dependencies because they will never depend on
+         * <p>We don't care about non-reusable scoped dependencies because they will never depend on
          * multibindings with contributions from subcomponents.
          */
         boolean dependsOnLocalMultibindings(final Binding binding) {
@@ -741,7 +757,8 @@ boolean dependsOnLocalMultibindings(final Binding binding) {
                 new Callable<Boolean>() {
                   @Override
                   public Boolean call() {
-                    if (!binding.scope().isPresent()
+                    if ((!binding.scope().isPresent()
+                            || binding.scope().get().equals(reusableScope(elements)))
                         // TODO(beder): Figure out what happens with production subcomponents.
                         && !binding.bindingType().equals(BindingType.PRODUCTION)) {
                       for (DependencyRequest dependency : binding.implicitDependencies()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 2eb20921b..04647c97d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -101,6 +101,7 @@
 import static dagger.internal.codegen.ErrorMessages.inconsistentMapKeyAnnotationsError;
 import static dagger.internal.codegen.ErrorMessages.nullableToNonNullable;
 import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
+import static dagger.internal.codegen.Scope.reusableScope;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
 import static javax.tools.Diagnostic.Kind.ERROR;
 
@@ -175,7 +176,6 @@ void validateSubgraph() {
               entryPoint.get(),
               new ArrayDeque<ResolvedRequest>(),
               new LinkedHashSet<BindingKey>(),
-              subject,
               new HashSet<DependencyRequest>());
         }
       }
@@ -247,7 +247,6 @@ private void traverseRequest(
         DependencyRequest request,
         Deque<ResolvedRequest> bindingPath,
         LinkedHashSet<BindingKey> keysInPath,
-        BindingGraph graph,
         Set<DependencyRequest> resolvedRequests) {
       verify(bindingPath.size() == keysInPath.size(),
           "mismatched path vs keys -- (%s vs %s)", bindingPath, keysInPath);
@@ -263,14 +262,19 @@ private void traverseRequest(
 
       // If request has already been resolved, avoid re-traversing the binding path.
       if (resolvedRequests.add(request)) {
-        ResolvedRequest resolvedRequest = ResolvedRequest.create(request, graph);
+        ResolvedRequest resolvedRequest = ResolvedRequest.create(request, subject);
         bindingPath.push(resolvedRequest);
         keysInPath.add(requestKey);
         validateResolvedBinding(bindingPath, resolvedRequest.binding());
 
-        for (Binding binding : resolvedRequest.binding().bindings()) {
-          for (DependencyRequest nextRequest : binding.implicitDependencies()) {
-            traverseRequest(nextRequest, bindingPath, keysInPath, graph, resolvedRequests);
+        // Validate all dependencies within the component that owns the binding.
+        for (Map.Entry<ComponentDescriptor, Collection<Binding>> entry :
+            resolvedRequest.binding().bindingsByComponent().asMap().entrySet()) {
+          Validation validation = validationForComponent(entry.getKey());
+          for (Binding binding : entry.getValue()) {
+            for (DependencyRequest nextRequest : binding.implicitDependencies()) {
+              validation.traverseRequest(nextRequest, bindingPath, keysInPath, resolvedRequests);
+            }
           }
         }
         bindingPath.poll();
@@ -278,6 +282,20 @@ private void traverseRequest(
       }
     }
 
+    private Validation validationForComponent(ComponentDescriptor component) {
+      if (component.equals(subject.componentDescriptor())) {
+        return this;
+      } else if (parent.isPresent()) {
+        return parent.get().validationForComponent(component);
+      } else {
+        throw new IllegalArgumentException(
+            String.format(
+                "unknown component %s within %s",
+                component.componentDefinitionType(),
+                subject.componentDescriptor().componentDefinitionType()));
+      }
+    }
+
     /**
      * Reports errors if the set of bindings resolved is inconsistent with the type of the binding.
      */
@@ -796,10 +814,13 @@ void validateComponentScope() {
       ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings = subject.resolvedBindings();
       ImmutableSet<Scope> componentScopes = subject.componentDescriptor().scopes();
       ImmutableSet.Builder<String> incompatiblyScopedMethodsBuilder = ImmutableSet.builder();
+      Scope reusableScope = reusableScope(elements);
       for (ResolvedBindings bindings : resolvedBindings.values()) {
         for (ContributionBinding contributionBinding : bindings.ownedContributionBindings()) {
           Optional<Scope> bindingScope = contributionBinding.scope();
-          if (bindingScope.isPresent() && !componentScopes.contains(bindingScope.get())) {
+          if (bindingScope.isPresent()
+              && !bindingScope.get().equals(reusableScope)
+              && !componentScopes.contains(bindingScope.get())) {
             // Scoped components cannot reference bindings to @Provides methods or @Inject
             // types decorated by a different scope annotation. Unscoped components cannot
             // reference to scoped @Provides methods or @Inject types decorated by any
@@ -904,15 +925,13 @@ private StringBuilder requiresErrorMessageBase(Deque<ResolvedRequest> path) {
 
     private void reportMissingBinding(Deque<ResolvedRequest> path) {
       StringBuilder errorMessage = requiresErrorMessageBase(path);
-      ImmutableList<String> printableDependencyPath =
+      FluentIterable<String> printableDependencyPath =
           FluentIterable.from(path)
-              .filter(Predicates.not(SYNTHETIC_BINDING))
+              .filter(Predicates.not(PREVIOUS_REQUEST_WAS_SYNTHETIC))
               .transform(REQUEST_FROM_RESOLVED_REQUEST)
               .transform(dependencyRequestFormatter)
-              .filter(Predicates.not(Predicates.equalTo("")))
-              .toList()
-              .reverse();
-      for (String dependency : Iterables.skip(printableDependencyPath, 1)) {
+              .filter(Predicates.not(Predicates.equalTo("")));
+      for (String dependency : printableDependencyPath) {
         errorMessage.append('\n').append(dependency);
       }
       for (String suggestion : MissingBindingSuggestions.forKey(topLevelGraph(),
@@ -1075,7 +1094,7 @@ private void reportCycle(
               rootRequestElement.getSimpleName(),
               FluentIterable.from(bindingPath) // TODO(dpb): Resolve with similar code above.
                   .skip(1)
-                  .filter(Predicates.not(SYNTHETIC_BINDING))
+                  .filter(Predicates.not(PREVIOUS_REQUEST_WAS_SYNTHETIC))
                   .transform(REQUEST_FROM_RESOLVED_REQUEST)
                   .append(request)
                   .transform(dependencyRequestFormatter)
@@ -1102,7 +1121,7 @@ private void reportCycle(
         DependencyRequest dependencyRequest = cycle.get(i);
         switch (dependencyRequest.kind()) {
           case PROVIDER:
-            if (isImplicitProviderMapForValueMap(dependencyRequest, cycle.get(i - 1))) {
+            if (isDependencyOfSyntheticMap(dependencyRequest, cycle.get(i - 1))) {
               i++; // Skip the Provider requests in the Map<K, Provider<V>> too.
             } else {
               providers.add(dependencyRequest);
@@ -1128,16 +1147,19 @@ private void reportCycle(
     }
 
     /**
-     * Returns {@code true} if {@code maybeValueMapRequest}'s key type is {@code Map<K, V>} and
-     * {@code maybeProviderMapRequest}'s key type is {@code Map<K, Provider<V>>}, and both keys have
-     * the same qualifier.
+     * Returns {@code true} if {@code request} is a request for {@code Map<K, Provider<V>>} or
+     * {@code Map<K, Producer<V>>} from a synthetic binding for {@code Map<K, V>} or
+     * {@code Map<K, Produced<V>>}.
      */
-    private boolean isImplicitProviderMapForValueMap(
-        DependencyRequest maybeProviderMapRequest, DependencyRequest maybeValueMapRequest) {
-      Optional<Key> implicitProviderMapKey =
-          keyFactory.implicitMapProviderKeyFrom(maybeValueMapRequest.key());
-      return implicitProviderMapKey.isPresent()
-          && implicitProviderMapKey.get().equals(maybeProviderMapRequest.key());
+    // TODO(dpb): Make this check more explicit.
+    private boolean isDependencyOfSyntheticMap(
+        DependencyRequest request, DependencyRequest requestForPreviousBinding) {
+      // Synthetic map dependencies share the same request element as the previous request.
+      return request.requestElement().equals(requestForPreviousBinding.requestElement())
+          && Sets.union(
+                  keyFactory.implicitMapProviderKeyFrom(requestForPreviousBinding.key()).asSet(),
+                  keyFactory.implicitMapProducerKeyFrom(requestForPreviousBinding.key()).asSet())
+              .contains(request.key());
     }
   }
 
@@ -1261,11 +1283,16 @@ public DependencyRequest apply(ResolvedRequest resolvedRequest) {
         }
       };
 
-  private static final Predicate<ResolvedRequest> SYNTHETIC_BINDING =
+  private static final Predicate<ResolvedRequest> PREVIOUS_REQUEST_WAS_SYNTHETIC =
       new Predicate<ResolvedRequest>() {
+
+        boolean previousRequestWasSynthetic;
+
         @Override
-        public boolean apply(ResolvedRequest request) {
-          return request.binding().isSyntheticContribution();
+        public boolean apply(ResolvedRequest resolvedRequest) {
+          boolean returnValue = previousRequestWasSynthetic;
+          previousRequestWasSynthetic = resolvedRequest.binding().isSyntheticContribution();
+          return returnValue;
         }
       };
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index b1b530b09..146ddbce5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -31,7 +31,7 @@
  * @author Gregory Kick
  * @since 2.0
  */
-final class ComponentGenerator extends JavaPoetSourceFileGenerator<BindingGraph> {
+final class ComponentGenerator extends SourceFileGenerator<BindingGraph> {
   private final Types types;
   private final Elements elements;
   private final Key.Factory keyFactory;
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 3d439dd47..77a63cfd3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -63,7 +63,8 @@ public SourceVersion getSupportedSourceVersion() {
     MethodSignatureFormatter methodSignatureFormatter = new MethodSignatureFormatter(types);
     HasSourceElementFormatter hasSourceElementFormatter =
         new HasSourceElementFormatter(methodSignatureFormatter);
-    DependencyRequestFormatter dependencyRequestFormatter = new DependencyRequestFormatter(types);
+    DependencyRequestFormatter dependencyRequestFormatter =
+        new DependencyRequestFormatter(types, elements);
     KeyFormatter keyFormatter = new KeyFormatter(methodSignatureFormatter);
 
     InjectConstructorValidator injectConstructorValidator = new InjectConstructorValidator();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
index 0be4686a9..d47a3c68c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
@@ -27,6 +27,7 @@
 import com.google.common.collect.Multimap;
 import com.google.common.collect.Sets;
 import dagger.Component;
+import dagger.Reusable;
 import dagger.producers.ProductionComponent;
 import java.lang.annotation.Annotation;
 import java.util.Collection;
@@ -50,6 +51,7 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.enclosedBuilders;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
 import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
+import static dagger.internal.codegen.ErrorMessages.COMPONENT_ANNOTATED_REUSABLE;
 import static javax.lang.model.element.ElementKind.CLASS;
 import static javax.lang.model.element.ElementKind.INTERFACE;
 import static javax.lang.model.element.Modifier.ABSTRACT;
@@ -141,6 +143,11 @@ public ComponentValidationReport validate(final TypeElement subject,
           String.format(ErrorMessages.builderMsgsFor(componentKind).moreThanOne(), builders),
           subject);
     }
+    
+    Optional<AnnotationMirror> reusableAnnotation = getAnnotationMirror(subject, Reusable.class);
+    if (reusableAnnotation.isPresent()) {
+      builder.addError(COMPONENT_ANNOTATED_REUSABLE, subject, reusableAnnotation.get());
+    }
 
     DeclaredType subjectType = MoreTypes.asDeclared(subject.asType());
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index cbc579105..8866cb570 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -18,6 +18,7 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
+import com.google.common.base.Equivalence;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
@@ -50,7 +51,7 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
-import static javax.lang.model.type.TypeKind.DECLARED;
+import static com.google.common.collect.Iterables.getOnlyElement;
 import static javax.lang.model.util.ElementFilter.constructorsIn;
 
 /**
@@ -132,7 +133,11 @@ BindingKey bindingKey() {
    * Returns the possibly resolved type that contained the requesting element. For members injection
    * requests, this is the type itself.
    */
-  abstract DeclaredType enclosingType();
+  DeclaredType enclosingType() {
+    return wrappedEnclosingType().get();
+  }
+
+  abstract Equivalence.Wrapper<DeclaredType> wrappedEnclosingType();
 
   /** Returns true if this request allows null objects. */
   abstract boolean isNullable();
@@ -196,7 +201,7 @@ DependencyRequest forImplicitMapBinding(
           Kind.PROVIDER,
           mapOfFactoryKey,
           mapOfValueRequest.requestElement(),
-          mapOfValueRequest.enclosingType(),
+          mapOfValueRequest.wrappedEnclosingType(),
           false /* doesn't allow null */,
           Optional.<String>absent());
     }
@@ -207,23 +212,35 @@ DependencyRequest forImplicitMapBinding(
      */
     DependencyRequest forMultibindingContribution(
         DependencyRequest request, ContributionBinding multibindingContribution) {
-      checkArgument(
-          multibindingContribution.contributionType().isMultibinding(),
-          "multibindingContribution must be a multibinding: %s",
-          multibindingContribution);
       checkArgument(
           multibindingContribution.key().bindingMethod().isPresent(),
           "multibindingContribution's key must have a binding method identifier: %s",
           multibindingContribution);
       return new AutoValue_DependencyRequest(
-          Kind.PROVIDER,
+          multibindingContributionRequestKind(multibindingContribution),
           multibindingContribution.key(),
           request.requestElement(),
-          request.enclosingType(),
+          request.wrappedEnclosingType(),
           false /* doesn't allow null */,
           Optional.<String>absent());
     }
 
+    private Kind multibindingContributionRequestKind(ContributionBinding multibindingContribution) {
+      switch (multibindingContribution.contributionType()) {
+        case MAP:
+          return multibindingContribution.bindingType().equals(BindingType.PRODUCTION)
+              ? Kind.PRODUCER
+              : Kind.PROVIDER;
+        case SET:
+          return Kind.INSTANCE;
+        case UNIQUE:
+          throw new IllegalArgumentException(
+              "multibindingContribution must be a multibinding: " + multibindingContribution);
+        default:
+          throw new AssertionError(multibindingContribution.toString());
+      }
+    }
+
     /**
      * Creates dependency requests, with the same element as {@code request}, for each individual
      * multibinding contribution in {@code multibindingContributions}.
@@ -293,7 +310,7 @@ DependencyRequest forComponentProductionMethod(ExecutableElement productionMetho
             keyFactory.forQualifiedType(
                 qualifier, Iterables.getOnlyElement(((DeclaredType) type).getTypeArguments())),
             productionMethod,
-            container,
+            MoreTypes.equivalence().wrap(container),
             false /* doesn't allow null */,
             Optional.<String>absent());
       } else {
@@ -310,26 +327,19 @@ DependencyRequest forComponentMembersInjectionMethod(ExecutableElement membersIn
           InjectionAnnotations.getQualifier(membersInjectionMethod);
       checkArgument(!qualifier.isPresent());
       TypeMirror returnType = membersInjectionMethodType.getReturnType();
-      if (returnType.getKind().equals(DECLARED)
-          && MoreTypes.isTypeOf(MembersInjector.class, returnType)) {
-        return new AutoValue_DependencyRequest(
-            Kind.MEMBERS_INJECTOR,
-            keyFactory.forMembersInjectedType(
-                Iterables.getOnlyElement(((DeclaredType) returnType).getTypeArguments())),
-            membersInjectionMethod,
-            getEnclosingType(membersInjectionMethod),
-            false /* doesn't allow null */,
-            Optional.<String>absent());
-      } else {
-        return new AutoValue_DependencyRequest(
-            Kind.MEMBERS_INJECTOR,
-            keyFactory.forMembersInjectedType(
-                Iterables.getOnlyElement(membersInjectionMethodType.getParameterTypes())),
-            membersInjectionMethod,
-            getEnclosingType(membersInjectionMethod),
-            false /* doesn't allow null */,
-            Optional.<String>absent());
-      }
+      Equivalence.Wrapper<DeclaredType> container =
+          MoreTypes.equivalence().wrap(getEnclosingType(membersInjectionMethod));
+      TypeMirror membersInjectedType =
+          MoreTypes.isType(returnType) && MoreTypes.isTypeOf(MembersInjector.class, returnType)
+              ? getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments())
+              : getOnlyElement(membersInjectionMethodType.getParameterTypes());
+      return new AutoValue_DependencyRequest(
+          Kind.MEMBERS_INJECTOR,
+          keyFactory.forMembersInjectedType(membersInjectedType),
+          membersInjectionMethod,
+          container,
+          false /* doesn't allow null */,
+          Optional.<String>absent());
     }
 
     DependencyRequest forMembersInjectedType(DeclaredType type) {
@@ -337,7 +347,7 @@ DependencyRequest forMembersInjectedType(DeclaredType type) {
           Kind.MEMBERS_INJECTOR,
           keyFactory.forMembersInjectedType(type),
           type.asElement(),
-          type,
+          MoreTypes.equivalence().wrap(type),
           false /* doesn't allow null */,
           Optional.<String>absent());
     }
@@ -348,7 +358,7 @@ DependencyRequest forProductionImplementationExecutor() {
           Kind.PROVIDER,
           key,
           MoreTypes.asElement(key.type()),
-          MoreTypes.asDeclared(key.type()),
+          MoreTypes.equivalence().wrap(MoreTypes.asDeclared(key.type())),
           false /* doesn't allow null */,
           Optional.<String>absent());
     }
@@ -383,7 +393,7 @@ private DependencyRequest newDependencyRequest(
           kindAndType.kind(),
           keyFactory.forQualifiedType(qualifier, kindAndType.type()),
           requestElement,
-          container,
+          MoreTypes.equivalence().wrap(container),
           allowsNull,
           name);
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
index bbebdee3c..db8fc8aef 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
@@ -16,137 +16,192 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.MoreElements;
-import com.google.auto.common.MoreTypes;
 import com.google.common.base.Optional;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import java.util.List;
+import dagger.Provides;
+import dagger.producers.Produces;
+import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.SimpleElementVisitor6;
+import javax.lang.model.util.ElementKindVisitor7;
+import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
-import static com.google.common.base.Preconditions.checkState;
-import static com.google.common.collect.Iterables.getOnlyElement;
+import static com.google.auto.common.MoreElements.asExecutable;
 import static dagger.internal.codegen.ErrorMessages.INDENT;
 
 /**
  * Formats a {@link DependencyRequest} into a {@link String} suitable for an error message listing
  * a chain of dependencies.
- *
- * @author Christian Gruber
- * @since 2.0
+ * 
+ * <dl>
+ * <dt>For component provision methods
+ * <dd>{@code ComponentType.method() injects @Qualifier SomeType}
+ * 
+ * <dt>For component injection methods
+ * <dd>{@code ComponentType.method(foo) injects SomeType}
+ * 
+ * <dt>For parameters to {@link Provides @Provides}, {@link Produces @Produces}, or
+ * {@link Inject @Inject} methods:
+ * <dd>{@code EnclosingType.method([…, ]param[, …]) injects @Qualified ResolvedType}
+ * 
+ * <dt>For parameters to {@link Inject @Inject} constructors:
+ * <dd>{@code EnclosingType.<init>([…, ]param[, …]) injects @Qualified ResolvedType}
+ * 
+ * <dt>For {@link Inject @Inject} fields:
+ * <dd>{@code EnclosingType.field injects @Qualified ResolvedType}
+ * </dl>
  */
 final class DependencyRequestFormatter extends Formatter<DependencyRequest> {
+
   private final Types types;
+  private final Elements elements;
 
-  DependencyRequestFormatter(Types types) {
+  DependencyRequestFormatter(Types types, Elements elements) {
     this.types = types;
+    this.elements = elements;
   }
 
   // TODO(cgruber): Sweep this class for TypeMirror.toString() usage and do some preventive format.
   // TODO(cgruber): consider returning a small structure containing strings to be indented later.
-  @Override public String format(final DependencyRequest request) {
-    Element requestElement = request.requestElement();
-    Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(requestElement);
-    return requestElement.accept(new SimpleElementVisitor6<String, Optional<AnnotationMirror>>(){
-
-      /* Handle component methods */
-      @Override public String visitExecutable(
-          ExecutableElement method, Optional<AnnotationMirror> qualifier) {
-        StringBuilder builder = new StringBuilder(INDENT);
-        if (method.getParameters().isEmpty()) {
-          // some.package.name.MyComponent.myMethod()
-          //     [component method with return type: @other.package.Qualifier some.package.name.Foo]
-          appendEnclosingTypeAndMemberName(method, builder).append("()\n")
-              .append(INDENT).append(INDENT).append("[component method with return type: ");
-          if (qualifier.isPresent()) {
-            // TODO(cgruber) use chenying's annotation mirror stringifier
-            builder.append(qualifier.get()).append(' ');
-          }
-          builder.append(method.getReturnType()).append(']');
-        } else {
-          // some.package.name.MyComponent.myMethod(some.package.name.Foo foo)
-          //     [component injection method for type: some.package.name.Foo]
-          VariableElement componentMethodParameter = getOnlyElement(method.getParameters());
-          appendEnclosingTypeAndMemberName(method, builder).append("(");
-          appendParameter(componentMethodParameter, componentMethodParameter.asType(), builder);
-          builder.append(")\n");
-          builder.append(INDENT).append(INDENT).append("[component injection method for type: ")
-              .append(componentMethodParameter.asType())
-              .append(']');
-        }
-        return builder.toString();
-      }
-
-      /* Handle injected fields or method/constructor parameter injection. */
-      @Override public String visitVariable(
-          VariableElement variable, Optional<AnnotationMirror> qualifier) {
-        StringBuilder builder = new StringBuilder(INDENT);
-        TypeMirror resolvedVariableType =
-            MoreTypes.asMemberOf(types, request.enclosingType(), variable);
-        if (variable.getKind().equals(ElementKind.PARAMETER)) {
-          // some.package.name.MyClass.myMethod(some.package.name.Foo arg0, some.package.Bar arg1)
-          //     [parameter: @other.package.Qualifier some.package.name.Foo arg0]
-          ExecutableElement methodOrConstructor =
-              MoreElements.asExecutable(variable.getEnclosingElement());
-          ExecutableType resolvedMethodOrConstructor = MoreTypes.asExecutable(
-              types.asMemberOf(request.enclosingType(), methodOrConstructor));
-          appendEnclosingTypeAndMemberName(methodOrConstructor, builder).append('(');
-          List<? extends VariableElement> parameters = methodOrConstructor.getParameters();
-          List<? extends TypeMirror> parameterTypes =
-              resolvedMethodOrConstructor.getParameterTypes();
-          checkState(parameters.size() == parameterTypes.size());
-          for (int i = 0; i < parameters.size(); i++) {
-            appendParameter(parameters.get(i), parameterTypes.get(i), builder);
-            if (i != parameters.size() - 1) {
-              builder.append(", ");
-            }
-          }
-          builder.append(")\n").append(INDENT).append(INDENT).append("[parameter: ");
-        } else {
-          // some.package.name.MyClass.myField
-          //     [injected field of type: @other.package.Qualifier some.package.name.Foo myField]
-          appendEnclosingTypeAndMemberName(variable, builder).append("\n")
-              .append(INDENT).append(INDENT).append("[injected field of type: ");
-        }
-        if (qualifier.isPresent()) {
-          // TODO(cgruber) use chenying's annotation mirror stringifier
-          builder.append(qualifier.get()).append(' ');
-        }
-        builder.append(resolvedVariableType)
-            .append(' ')
-            .append(variable.getSimpleName())
-            .append(']');
-        return builder.toString();
-      }
-
-      @Override
-      public String visitType(TypeElement e, Optional<AnnotationMirror> p) {
-        return ""; // types by themselves provide no useful information.
-      }
-
-      @Override protected String defaultAction(Element element, Optional<AnnotationMirror> ignore) {
-        throw new IllegalStateException(
-            "Invalid request " + element.getKind() +  " element " + element);
-      }
-    }, qualifier);
+  @Override
+  public String format(DependencyRequest request) {
+    return request
+        .requestElement()
+        .accept(
+            new ElementKindVisitor7<String, DependencyRequest>() {
+
+              /** Returns the description for component methods. */
+              @Override
+              public String visitExecutableAsMethod(
+                  ExecutableElement method, DependencyRequest request) {
+                StringBuilder builder = new StringBuilder(INDENT);
+                appendEnclosingTypeAndMemberName(method, builder);
+                builder.append('(');
+                for (VariableElement parameter : method.getParameters()) {
+                  builder.append(parameter.getSimpleName());
+                }
+                builder.append(')');
+                appendRequest(
+                    builder,
+                    componentMethodRequestVerb(request),
+                    request.key().qualifier(),
+                    request.key().type());
+                return builder.toString();
+              }
+
+              /**
+               * Returns the description for {@link javax.inject.Inject @Inject} constructor and
+               * method parameters and for {@link dagger.Provides @Provides} and
+               * {@link dagger.producers.Produces @Produces} method parameters.
+               */
+              @Override
+              public String visitVariableAsParameter(
+                  final VariableElement variable, DependencyRequest request) {
+                StringBuilder builder = new StringBuilder(INDENT);
+                ExecutableElement methodOrConstructor =
+                    asExecutable(variable.getEnclosingElement());
+
+                appendEnclosingTypeAndMemberName(methodOrConstructor, builder).append('(');
+                int parameterIndex = methodOrConstructor.getParameters().indexOf(variable);
+                if (parameterIndex > 0) {
+                  builder.append("…, ");
+                }
+                builder.append(variable.getSimpleName());
+                if (parameterIndex < methodOrConstructor.getParameters().size() - 1) {
+                  builder.append(", …");
+                }
+                builder.append(')');
+                appendRequest(builder, request);
+                return builder.toString();
+              }
+
+              /** Returns the description for {@link javax.inject.Inject @Inject} fields. */
+              @Override
+              public String visitVariableAsField(
+                  VariableElement variable, DependencyRequest request) {
+                StringBuilder builder = new StringBuilder(INDENT);
+                appendEnclosingTypeAndMemberName(variable, builder);
+                appendRequest(builder, request);
+                return builder.toString();
+              }
+
+              @Override
+              public String visitType(TypeElement e, DependencyRequest request) {
+                return ""; // types by themselves provide no useful information.
+              }
+
+              @Override
+              protected String defaultAction(Element element, DependencyRequest request) {
+                throw new IllegalStateException(
+                    "Invalid request " + element.getKind() + " element " + element);
+              }
+            },
+            request);
   }
 
-  @CanIgnoreReturnValue
-  private StringBuilder appendParameter(
-      VariableElement parameter, TypeMirror type, StringBuilder builder) {
-    return builder.append(type).append(' ').append(parameter.getSimpleName());
+  private void appendRequest(StringBuilder builder, DependencyRequest request) {
+    appendRequest(
+        builder, "injects", request.key().qualifier(), requestedTypeWithFrameworkClass(request));
+  }
+
+  private void appendRequest(
+      StringBuilder builder, String verb, Optional<AnnotationMirror> qualifier, TypeMirror type) {
+    builder.append("\n    ").append(INDENT).append(verb).append(' ');
+    appendQualifiedType(builder, qualifier, type);
   }
 
+  private TypeMirror requestedTypeWithFrameworkClass(DependencyRequest request) {
+    Optional<Class<?>> requestFrameworkClass = request.kind().frameworkClass;
+    if (requestFrameworkClass.isPresent()) {
+      return types.getDeclaredType(
+          elements.getTypeElement(requestFrameworkClass.get().getCanonicalName()),
+          request.key().type());
+    }
+    return request.key().type();
+  }
+
+  private void appendQualifiedType(
+      StringBuilder builder, Optional<AnnotationMirror> qualifier, TypeMirror type) {
+    if (qualifier.isPresent()) {
+      builder.append(qualifier.get()).append(' ');
+    }
+    builder.append(type);
+  }
+
+  /**
+   * Returns the verb for a component method dependency request. Returns "produces", "provides", or
+   * "injects", depending on the kind of request.
+   */
+  private String componentMethodRequestVerb(DependencyRequest request) {
+    switch (request.kind()) {
+      case FUTURE:
+      case PRODUCER:
+        return "produces";
+
+      case INSTANCE:
+      case LAZY:
+      case PROVIDER:
+        return "provides";
+
+      case MEMBERS_INJECTOR:
+        return "injects";
+
+      case PRODUCED:
+      default:
+        throw new AssertionError("illegal request kind for method: " + request);
+    }
+  }
+
+  @CanIgnoreReturnValue
   private StringBuilder appendEnclosingTypeAndMemberName(Element member, StringBuilder builder) {
     TypeElement type = MoreElements.asType(member.getEnclosingElement());
-    return builder.append(type.getQualifiedName())
+    return builder
+        .append(type.getQualifiedName())
         .append('.')
         .append(member.getSimpleName());
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 17b57e416..ef091ee0f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -98,6 +98,7 @@
   static final String CANNOT_INJECT_WILDCARD_TYPE =
       "Dagger does not support injecting Provider<T>, Lazy<T> or Produced<T> when T is a wildcard "
           + "type such as <%s>.";
+  
   /*
    * Configuration errors
    *
@@ -115,6 +116,9 @@ static String inconsistentMapKeyAnnotationsError(String key) {
     return key + " uses more than one @MapKey annotation type";
   }
 
+  static final String COMPONENT_ANNOTATED_REUSABLE =
+      "@Reusable cannot be applied to components or subcomponents.";
+  
   static final String PROVIDES_METHOD_RETURN_TYPE =
       "@Provides methods must either return a primitive, an array, a type variable, or a declared"
           + " type.";
@@ -122,6 +126,9 @@ static String inconsistentMapKeyAnnotationsError(String key) {
   static final String PROVIDES_METHOD_THROWS =
       "@Provides methods may only throw unchecked exceptions";
 
+  static final String PRODUCES_METHOD_NULLABLE =
+      "@Nullable on @Produces methods does not do anything.";
+
   static final String PRODUCES_METHOD_RETURN_TYPE =
       "@Produces methods must either return a primitive, an array, a type variable, or a declared"
           + " type, or a ListenableFuture of one of those types.";
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index ce97a2ce3..2bbcb2414 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -73,7 +73,7 @@
  * @author Gregory Kick
  * @since 2.0
  */
-final class FactoryGenerator extends JavaPoetSourceFileGenerator<ProvisionBinding> {
+final class FactoryGenerator extends SourceFileGenerator<ProvisionBinding> {
 
   private final CompilerOptions compilerOptions;
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index 3342df9b5..212b08dba 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -78,8 +78,7 @@
       this.bindingType = bindingType;
     }
 
-    void generateBindings(JavaPoetSourceFileGenerator<B> generator)
-        throws SourceFileGenerationException {
+    void generateBindings(SourceFileGenerator<B> generator) throws SourceFileGenerationException {
       for (B binding = bindingsRequiringGeneration.poll();
           binding != null;
           binding = bindingsRequiringGeneration.poll()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
index d76099bfb..ac15287b8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
@@ -55,7 +55,7 @@
  *
  * @since 2.0
  */
-final class MapKeyGenerator extends JavaPoetSourceFileGenerator<MapKeyCreatorSpecification> {
+final class MapKeyGenerator extends SourceFileGenerator<MapKeyCreatorSpecification> {
 
   /**
    * Specification of the {@link MapKey} annotation and the annotation type to generate.
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index 293dc7466..1a0379c1f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -73,7 +73,7 @@
  * @author Gregory Kick
  * @since 2.0
  */
-final class MembersInjectorGenerator extends JavaPoetSourceFileGenerator<MembersInjectionBinding> {
+final class MembersInjectorGenerator extends SourceFileGenerator<MembersInjectionBinding> {
 
   MembersInjectorGenerator(Filer filer, Elements elements) {
     super(filer, elements);
diff --git a/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
index c72c616cd..76a3f6b9d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
@@ -41,7 +41,7 @@
 import static javax.lang.model.element.Modifier.STATIC;
 
 /** Generates a monitoring module for use with production components. */
-final class MonitoringModuleGenerator extends JavaPoetSourceFileGenerator<TypeElement> {
+final class MonitoringModuleGenerator extends SourceFileGenerator<TypeElement> {
 
   MonitoringModuleGenerator(Filer filer, Elements elements) {
     super(filer, elements);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index d1e5d3a8d..6c15b50fb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -69,7 +69,7 @@
  * @author Jesse Beder
  * @since 2.0
  */
-final class ProducerFactoryGenerator extends JavaPoetSourceFileGenerator<ProductionBinding> {
+final class ProducerFactoryGenerator extends SourceFileGenerator<ProductionBinding> {
   private final CompilerOptions compilerOptions;
 
   ProducerFactoryGenerator(Filer filer, Elements elements, CompilerOptions compilerOptions) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
index 62079a625..ce2479008 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
@@ -44,6 +44,7 @@
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_MULTIPLE_MAP_KEY;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_NO_MAP_KEY;
+import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_NULLABLE;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RAW_FUTURE;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RETURN_TYPE;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;
@@ -103,6 +104,11 @@ private TypeElement getSetElement() {
       builder.addError(formatErrorMessage(BINDING_METHOD_ABSTRACT), producesMethodElement);
     }
 
+    if (ConfigurationAnnotations.getNullableType(producesMethodElement).isPresent()) {
+      // TODO(beder): Make this an error.
+      builder.addWarning(PRODUCES_METHOD_NULLABLE, producesMethodElement);
+    }
+
     TypeMirror returnType = producesMethodElement.getReturnType();
     TypeKind returnTypeKind = returnType.getKind();
     if (returnTypeKind.equals(VOID)) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index 4630567f0..c21aec6db 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -123,7 +123,7 @@ ProductionBinding forProducesMethod(
           key,
           dependencies,
           findBindingPackage(key),
-          ConfigurationAnnotations.getNullableType(producesMethod),
+          Optional.<DeclaredType>absent(), // TODO(beder): Add nullability checking with Java 8.
           Optional.<DependencyRequest>absent(),
           kind,
           producesAnnotation.type(),
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleGenerator.java
index 1b8e5ab6d..d6a90a70d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleGenerator.java
@@ -40,7 +40,7 @@
 
 /** Generates a producer executor module for use with production components. */
 // TODO(beder): Replace this with a single class when the producers client library exists.
-final class ProductionExecutorModuleGenerator extends JavaPoetSourceFileGenerator<TypeElement> {
+final class ProductionExecutorModuleGenerator extends SourceFileGenerator<TypeElement> {
 
   ProductionExecutorModuleGenerator(Filer filer, Elements elements) {
     super(filer, elements);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
index 90e07ea7e..00ded026b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
@@ -97,6 +97,16 @@ public Key key() {
         throw new AssertionError(bindingKey());
     }
   }
+  
+  /**
+   * All bindings for {@link #bindingKey()}, indexed by the component in which they were resolved.
+   */
+  ImmutableSetMultimap<ComponentDescriptor, Binding> bindingsByComponent() {
+    return new ImmutableSetMultimap.Builder<ComponentDescriptor, Binding>()
+        .putAll(allContributionBindings())
+        .putAll(allMembersInjectionBindings().entrySet())
+        .build();
+  }
 
   /**
    * {@code true} if there are no {@link #bindings()} or {@link #multibindingDeclarations()}.
@@ -173,23 +183,7 @@ static ResolvedBindings forContributionBindings(
         ImmutableMap.<ComponentDescriptor, MembersInjectionBinding>of(),
         ImmutableSet.copyOf(multibindings));
   }
-
-  /**
-   * Creates a {@link ResolvedBindings} for contribution bindings.
-   */
-  static ResolvedBindings forContributionBindings(
-      BindingKey bindingKey,
-      ComponentDescriptor owningComponent,
-      ContributionBinding... ownedContributionBindings) {
-    return forContributionBindings(
-        bindingKey,
-        owningComponent,
-        ImmutableSetMultimap.<ComponentDescriptor, ContributionBinding>builder()
-            .putAll(owningComponent, ownedContributionBindings)
-            .build(),
-        ImmutableSet.<MultibindingDeclaration>of());
-  }
-
+  
   /**
    * Creates a {@link ResolvedBindings} for members injection bindings.
    */
diff --git a/compiler/src/main/java/dagger/internal/codegen/Scope.java b/compiler/src/main/java/dagger/internal/codegen/Scope.java
index 962440fd8..d8590efd8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Scope.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Scope.java
@@ -23,7 +23,9 @@
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
+import dagger.Reusable;
 import dagger.producers.ProductionScope;
+import java.lang.annotation.Annotation;
 import javax.inject.Singleton;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
@@ -71,21 +73,30 @@ private Scope(AnnotationMirror annotationMirror) {
   }
 
   /**
-   * Returns a representation for producer scope;
+   * Returns a representation for {@link ProductionScope @ProductionScope} scope.
    */
   static Scope productionScope(Elements elements) {
-    return new Scope(
-        SimpleAnnotationMirror.of(
-            elements.getTypeElement(ProductionScope.class.getCanonicalName())));
+    return scope(elements, ProductionScope.class);
   }
 
   /**
-   * Returns a representation for singleton scope.
+   * Returns a representation for {@link Singleton @Singleton} scope.
    */
   static Scope singletonScope(Elements elements) {
+    return scope(elements, Singleton.class);
+  }
+
+  /**
+   * Returns a representation for {@link Reusable @Reusable} scope.
+   */
+  static Scope reusableScope(Elements elements) {
+    return scope(elements, Reusable.class);
+  }
+
+  private static Scope scope(Elements elements, Class<? extends Annotation> scopeAnnotationClass) {
     return new Scope(
         SimpleAnnotationMirror.of(
-            elements.getTypeElement(Singleton.class.getCanonicalName())));
+            elements.getTypeElement(scopeAnnotationClass.getCanonicalName())));
   }
 
   /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/JavaPoetSourceFileGenerator.java b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
similarity index 97%
rename from compiler/src/main/java/dagger/internal/codegen/JavaPoetSourceFileGenerator.java
rename to compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
index 48bbb2816..928a794ba 100644
--- a/compiler/src/main/java/dagger/internal/codegen/JavaPoetSourceFileGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
@@ -43,7 +43,7 @@
  *
  * @param <T> The input type from which source is to be generated.
  */
-abstract class JavaPoetSourceFileGenerator<T> {
+abstract class SourceFileGenerator<T> {
   private static final String GENERATED_COMMENTS = "https://google.github.io/dagger";
 
   private static final AnnotationSpec GENERATED =
@@ -55,7 +55,7 @@
   private final Filer filer;
   private final boolean generatedAnnotationAvailable;
 
-  JavaPoetSourceFileGenerator(Filer filer, Elements elements) {
+  SourceFileGenerator(Filer filer, Elements elements) {
     this.filer = checkNotNull(filer);
     generatedAnnotationAvailable = elements.getTypeElement("javax.annotation.Generated") != null;
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index acd56f102..61edc72e7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -37,7 +37,7 @@
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.Preconditions.checkArgument;
 import static dagger.internal.codegen.FrameworkDependency.frameworkDependenciesForBinding;
-import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK_LAZY;
+import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
 
 /**
  * Utilities for generating files.
@@ -125,8 +125,7 @@ static CodeBlock frameworkTypeUsageStatement(
       CodeBlock frameworkTypeMemberSelect, DependencyRequest.Kind dependencyKind) {
     switch (dependencyKind) {
       case LAZY:
-        return CodeBlocks.format(
-            "$T.create($L)", DOUBLE_CHECK_LAZY, frameworkTypeMemberSelect);
+        return CodeBlocks.format("$T.lazy($L)", DOUBLE_CHECK, frameworkTypeMemberSelect);
       case INSTANCE:
       case FUTURE:
         return CodeBlocks.format("$L.get()", frameworkTypeMemberSelect);
diff --git a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
index e005761d7..b88c6caa0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
@@ -24,14 +24,14 @@
 import com.squareup.javapoet.TypeName;
 import dagger.MembersInjector;
 import dagger.internal.DelegateFactory;
-import dagger.internal.DoubleCheckLazy;
+import dagger.internal.DoubleCheck;
 import dagger.internal.Factory;
 import dagger.internal.InstanceFactory;
 import dagger.internal.MapFactory;
 import dagger.internal.MapProviderFactory;
 import dagger.internal.MembersInjectors;
-import dagger.internal.ScopedProvider;
 import dagger.internal.SetFactory;
+import dagger.internal.SimpleLazilyInitializedProvider;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import dagger.producers.internal.AbstractProducer;
@@ -55,8 +55,8 @@
 
   static final ClassName ABSTRACT_PRODUCER = ClassName.get(AbstractProducer.class);
   static final ClassName ASYNC_FUNCTION = ClassName.get(AsyncFunction.class);
-  static final ClassName DOUBLE_CHECK_LAZY = ClassName.get(DoubleCheckLazy.class);
   static final ClassName DELEGATE_FACTORY = ClassName.get(DelegateFactory.class);
+  static final ClassName DOUBLE_CHECK = ClassName.get(DoubleCheck.class);
   static final ClassName EXECUTOR = ClassName.get(Executor.class);
   static final ClassName FACTORY = ClassName.get(Factory.class);
   static final ClassName FUTURES = ClassName.get(Futures.class);
@@ -77,7 +77,8 @@
   static final ClassName PRODUCER = ClassName.get(Producer.class);
   static final ClassName PRODUCERS = ClassName.get(Producers.class);
   static final ClassName PROVIDER = ClassName.get(Provider.class);
-  static final ClassName SCOPED_PROVIDER = ClassName.get(ScopedProvider.class);
+  static final ClassName SIMPLE_LAZILY_INITIALIZED_PROVIDER =
+      ClassName.get(SimpleLazilyInitializedProvider.class);
   static final ClassName SET = ClassName.get(Set.class);
   static final ClassName SET_FACTORY = ClassName.get(SetFactory.class);
   static final ClassName SET_OF_PRODUCED_PRODUCER = ClassName.get(SetOfProducedProducer.class);
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index dbf7987c4..59b1b4a8c 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -219,53 +219,54 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "  Lazy<SomeInjectableType> lazySomeInjectableType();",
         "  Provider<SomeInjectableType> someInjectableTypeProvider();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerSimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Lazy;",
-        "import dagger.internal.DoubleCheckLazy;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerSimpleComponent implements SimpleComponent {",
-        "  private DaggerSimpleComponent(Builder builder) {",
-        "    assert builder != null;",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static SimpleComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @Override",
-        "  public SomeInjectableType someInjectableType() {",
-        "    return SomeInjectableType_Factory.create().get();",
-        "  }",
-        "",
-        "  @Override",
-        "  public Lazy<SomeInjectableType> lazySomeInjectableType() {",
-        "    return DoubleCheckLazy.create(SomeInjectableType_Factory.create());",
-        "  }",
-        "",
-        "  @Override",
-        "  public Provider<SomeInjectableType> someInjectableTypeProvider() {",
-        "    return SomeInjectableType_Factory.create();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public SimpleComponent build() {",
-        "      return new DaggerSimpleComponent(this);",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerSimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Lazy;",
+            "import dagger.internal.DoubleCheck;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerSimpleComponent implements SimpleComponent {",
+            "  private DaggerSimpleComponent(Builder builder) {",
+            "    assert builder != null;",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static SimpleComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public SomeInjectableType someInjectableType() {",
+            "    return SomeInjectableType_Factory.create().get();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Lazy<SomeInjectableType> lazySomeInjectableType() {",
+            "    return DoubleCheck.lazy(SomeInjectableType_Factory.create());",
+            "  }",
+            "",
+            "  @Override",
+            "  public Provider<SomeInjectableType> someInjectableTypeProvider() {",
+            "    return SomeInjectableType_Factory.create();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public SimpleComponent build() {",
+            "      return new DaggerSimpleComponent(this);",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -298,63 +299,63 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "  Lazy<SomeInjectableType> lazySomeInjectableType();",
         "  Provider<SomeInjectableType> someInjectableTypeProvider();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerSimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Lazy;",
-        "import dagger.internal.DoubleCheckLazy;",
-        "import dagger.internal.ScopedProvider;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerSimpleComponent implements SimpleComponent {",
-        "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
-        "",
-        "  private DaggerSimpleComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static SimpleComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.someInjectableTypeProvider =",
-        "        ScopedProvider.create(SomeInjectableType_Factory.create());",
-        "  }",
-        "",
-        "  @Override",
-        "  public SomeInjectableType someInjectableType() {",
-        "    return someInjectableTypeProvider.get();",
-        "  }",
-        "",
-        "  @Override",
-        "  public Lazy<SomeInjectableType> lazySomeInjectableType() {",
-        "    return DoubleCheckLazy.create(someInjectableTypeProvider);",
-        "  }",
-        "",
-        "  @Override",
-        "  public Provider<SomeInjectableType> someInjectableTypeProvider() {",
-        "    return someInjectableTypeProvider;",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public SimpleComponent build() {",
-        "      return new DaggerSimpleComponent(this);",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerSimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Lazy;",
+            "import dagger.internal.DoubleCheck;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerSimpleComponent implements SimpleComponent {",
+            "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
+            "",
+            "  private DaggerSimpleComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static SimpleComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.someInjectableTypeProvider =",
+            "        DoubleCheck.provider(SomeInjectableType_Factory.create());",
+            "  }",
+            "",
+            "  @Override",
+            "  public SomeInjectableType someInjectableType() {",
+            "    return someInjectableTypeProvider.get();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Lazy<SomeInjectableType> lazySomeInjectableType() {",
+            "    return DoubleCheck.lazy(someInjectableTypeProvider);",
+            "  }",
+            "",
+            "  @Override",
+            "  public Provider<SomeInjectableType> someInjectableTypeProvider() {",
+            "    return someInjectableTypeProvider;",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public SimpleComponent build() {",
+            "      return new DaggerSimpleComponent(this);",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -790,9 +791,9 @@ public void subcomponentOmitsInheritedBindings() {
             "test.ParentModule",
             "package test;",
             "",
-            "import dagger.mapkeys.StringKey;",
             "import dagger.Module;",
             "import dagger.Provides;",
+            "import dagger.multibindings.StringKey;",
             "",
             "import static dagger.Provides.Type.SET;",
             "import static dagger.Provides.Type.MAP;",
diff --git a/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java b/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java
index b47a43c1c..856bc0f2a 100644
--- a/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java
@@ -132,7 +132,7 @@ private DependencyRequest dependencyRequestForProduced() {
   static final class ProvidesMethodModule {
     @Provides String provideString(
         Integer a, Lazy<Integer> b, Provider<Integer> c, MembersInjector<Y> d) {
-      return null;
+      throw new UnsupportedOperationException();
     }
   }
 
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java
index e207fe0ee..8196d1afe 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java
@@ -21,7 +21,9 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+import static com.google.common.truth.Truth.assertAbout;
 import static com.google.common.truth.Truth.assert_;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static java.util.Arrays.asList;
 
@@ -345,4 +347,48 @@
         .failsToCompile()
         .withErrorContaining(errorMessage);
   }
+  
+  @Test
+  public void reusableNotAllowedOnComponent() {
+    JavaFileObject someComponent =
+        JavaFileObjects.forSourceLines(
+            "test.SomeComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Reusable;",
+            "",
+            "@Reusable",
+            "@Component",
+            "interface SomeComponent {}");
+    assertAbout(javaSource())
+        .that(someComponent)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("@Reusable cannot be applied to components or subcomponents.")
+        .in(someComponent)
+        .onLine(6);
+  }
+
+  @Test
+  public void reusableNotAllowedOnSubcomponent() {
+    JavaFileObject someSubcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.SomeComponent",
+            "package test;",
+            "",
+            "import dagger.Reusable;",
+            "import dagger.Subcomponent;",
+            "",
+            "@Reusable",
+            "@Subcomponent",
+            "interface SomeSubcomponent {}");
+    assertAbout(javaSource())
+        .that(someSubcomponent)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("@Reusable cannot be applied to components or subcomponents.")
+        .in(someSubcomponent)
+        .onLine(6);
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index 6fba4320c..ce284d511 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -188,13 +188,16 @@
         "  }",
         "}");
 
-    String expectedError = "test.Outer.CComponent.getC() contains a dependency cycle:\n"
-        + "      test.Outer.C.<init>(test.Outer.B bParam)\n"
-        + "          [parameter: test.Outer.B bParam]\n"
-        + "      test.Outer.B.<init>(test.Outer.A aParam)\n"
-        + "          [parameter: test.Outer.A aParam]\n"
-        + "      test.Outer.A.<init>(test.Outer.C cParam)\n"
-        + "          [parameter: test.Outer.C cParam]";
+    String expectedError =
+        Joiner.on('\n')
+            .join(
+                "test.Outer.CComponent.getC() contains a dependency cycle:",
+                "      test.Outer.C.<init>(bParam)",
+                "          injects test.Outer.B",
+                "      test.Outer.B.<init>(aParam)",
+                "          injects test.Outer.A",
+                "      test.Outer.A.<init>(cParam)",
+                "          injects test.Outer.C");
 
     assertAbout(javaSource()).that(component)
         .processedWith(new ComponentProcessor())
@@ -236,15 +239,18 @@
             "  }",
             "}");
 
-    String expectedError = "test.Outer.DComponent.getD() contains a dependency cycle:\n"
-        + "      test.Outer.D.<init>(test.Outer.C cParam)\n"
-        + "          [parameter: test.Outer.C cParam]\n"
-        + "      test.Outer.C.<init>(test.Outer.B bParam)\n"
-        + "          [parameter: test.Outer.B bParam]\n"
-        + "      test.Outer.B.<init>(test.Outer.A aParam)\n"
-        + "          [parameter: test.Outer.A aParam]\n"
-        + "      test.Outer.A.<init>(test.Outer.C cParam)\n"
-        + "          [parameter: test.Outer.C cParam]";
+    String expectedError =
+        Joiner.on('\n')
+            .join(
+                "test.Outer.DComponent.getD() contains a dependency cycle:",
+                "      test.Outer.D.<init>(cParam)",
+                "          injects test.Outer.C",
+                "      test.Outer.C.<init>(bParam)",
+                "          injects test.Outer.B",
+                "      test.Outer.B.<init>(aParam)",
+                "          injects test.Outer.A",
+                "      test.Outer.A.<init>(cParam)",
+                "          injects test.Outer.C");
 
     assertAbout(javaSource())
         .that(component)
@@ -306,14 +312,14 @@ public void cyclicDependencyNotBrokenByMapBinding() {
         Joiner.on('\n')
             .join(
                 "test.Outer.CComponent.getC() contains a dependency cycle:",
-                "      test.Outer.C.<init>(test.Outer.B bParam)",
-                "          [parameter: test.Outer.B bParam]",
-                "      test.Outer.B.<init>(test.Outer.A aParam)",
-                "          [parameter: test.Outer.A aParam]",
-                "      test.Outer.A.<init>(java.util.Map<java.lang.String,test.Outer.C> cMap)",
-                "          [parameter: java.util.Map<java.lang.String,test.Outer.C> cMap]",
-                "      test.Outer.CModule.c(test.Outer.C c)",
-                "          [parameter: test.Outer.C c]");
+                "      test.Outer.C.<init>(bParam)",
+                "          injects test.Outer.B",
+                "      test.Outer.B.<init>(aParam)",
+                "          injects test.Outer.A",
+                "      test.Outer.A.<init>(cMap)",
+                "          injects java.util.Map<java.lang.String,test.Outer.C>",
+                "      test.Outer.CModule.c(c)",
+                "          injects test.Outer.C");
 
     assertAbout(javaSource())
         .that(component)
@@ -324,6 +330,69 @@ public void cyclicDependencyNotBrokenByMapBinding() {
         .onLine(25);
   }
 
+  @Test
+  public void cyclicDependencyWithSetBinding() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import java.util.Set;",
+            "import javax.inject.Inject;",
+            "",
+            "final class Outer {",
+            "  static class A {",
+            "    @Inject A(Set<C> cSet) {}",
+            "  }",
+            "",
+            "  static class B {",
+            "    @Inject B(A aParam) {}",
+            "  }",
+            "",
+            "  static class C {",
+            "    @Inject C(B bParam) {}",
+            "  }",
+            "",
+            "  @Component(modules = CModule.class)",
+            "  interface CComponent {",
+            "    C getC();",
+            "  }",
+            "",
+            "  @Module",
+            "  static class CModule {",
+            "    @Provides(type = Provides.Type.SET)",
+            "    static C c(C c) {",
+            "      return c;",
+            "    }",
+            "  }",
+            "}");
+
+    String expectedError =
+        Joiner.on('\n')
+            .join(
+                "test.Outer.CComponent.getC() contains a dependency cycle:",
+                "      test.Outer.C.<init>(bParam)",
+                "          injects test.Outer.B",
+                "      test.Outer.B.<init>(aParam)",
+                "          injects test.Outer.A",
+                "      test.Outer.A.<init>(cSet)",
+                "          injects java.util.Set<test.Outer.C>",
+                "      test.Outer.CModule.c(c)",
+                "          injects test.Outer.C"
+                );
+
+    assertAbout(javaSource())
+        .that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError)
+        .in(component)
+        .onLine(24);
+  }
+
   @Test
   public void falsePositiveCyclicDependencyIndirectionDetected() {
     JavaFileObject component =
@@ -361,15 +430,17 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
             "}");
 
     String expectedError =
-        "test.Outer.DComponent.getD() contains a dependency cycle:\n"
-            + "      test.Outer.D.<init>(javax.inject.Provider<test.Outer.C> cParam)\n"
-            + "          [parameter: javax.inject.Provider<test.Outer.C> cParam]\n"
-            + "      test.Outer.C.<init>(test.Outer.B bParam)\n"
-            + "          [parameter: test.Outer.B bParam]\n"
-            + "      test.Outer.B.<init>(test.Outer.A aParam)\n"
-            + "          [parameter: test.Outer.A aParam]\n"
-            + "      test.Outer.A.<init>(test.Outer.C cParam)\n"
-            + "          [parameter: test.Outer.C cParam]";
+        Joiner.on('\n')
+            .join(
+                "test.Outer.DComponent.getD() contains a dependency cycle:",
+                "      test.Outer.D.<init>(cParam)",
+                "          injects javax.inject.Provider<test.Outer.C>",
+                "      test.Outer.C.<init>(bParam)",
+                "          injects test.Outer.B",
+                "      test.Outer.B.<init>(aParam)",
+                "          injects test.Outer.A",
+                "      test.Outer.A.<init>(cParam)",
+                "          injects test.Outer.C");
 
     assertAbout(javaSource())
         .that(component)
@@ -727,64 +798,86 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration()
   }
 
   @Test public void longChainOfDependencies() {
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "",
-        "final class TestClass {",
-        "  interface A {}",
-        "",
-        "  static class B {",
-        "    @Inject B(A a) {}",
-        "  }",
-        "",
-        "  static class C {",
-        "    @Inject B b;",
-        "    @Inject C(B b) {}",
-        "  }",
-        "",
-        "  interface D { }",
-        "",
-        "  static class DImpl implements D {",
-        "    @Inject DImpl(C c, B b) {}",
-        "  }",
-        "",
-        "  @Module",
-        "  static class DModule {",
-        "    @Provides D d(DImpl impl) { return impl; }",
-        "  }",
-        "",
-        "  @Component(modules = { DModule.class })",
-        "  interface AComponent {",
-        "    D getFoo();",
-        "    C injectC(C c);",
-        "  }",
-        "}");
-    String errorText =
-        "test.TestClass.A cannot be provided without an @Provides-annotated method.\n";
-    String firstError = errorText
-        + "      test.TestClass.DModule.d(test.TestClass.DImpl impl)\n"
-        + "          [parameter: test.TestClass.DImpl impl]\n"
-        + "      test.TestClass.DImpl.<init>(test.TestClass.C c, test.TestClass.B b)\n"
-        + "          [parameter: test.TestClass.C c]\n"
-        + "      test.TestClass.C.b\n"
-        + "          [injected field of type: test.TestClass.B b]\n"
-        + "      test.TestClass.B.<init>(test.TestClass.A a)\n"
-        + "          [parameter: test.TestClass.A a]";
-    String secondError = errorText
-        + "      test.TestClass.C.b\n"
-        + "          [injected field of type: test.TestClass.B b]\n"
-        + "      test.TestClass.B.<init>(test.TestClass.A a)\n"
-        + "          [parameter: test.TestClass.A a]";
-    assertAbout(javaSource()).that(component)
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestClass",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "import javax.inject.Named;",
+            "",
+            "final class TestClass {",
+            "  interface A {}",
+            "",
+            "  static class B {",
+            "    @Inject B(A a) {}",
+            "  }",
+            "",
+            "  static class C {",
+            "    @Inject B b;",
+            "    @Inject C(X x, B b) {}",
+            "  }",
+            "",
+            "  interface D { }",
+            "",
+            "  static class DImpl implements D {",
+            "    @Inject DImpl(C c, B b) {}",
+            "  }",
+            "",
+            "  static class X {",
+            "    @Inject X() {}",
+            "  }",
+            "",
+            "  @Module",
+            "  static class DModule {",
+            "    @Provides @Named(\"slim shady\") D d(X x1, DImpl impl, X x2) { return impl; }",
+            "  }",
+            "",
+            "  @Component(modules = { DModule.class })",
+            "  interface AComponent {",
+            "    @Named(\"slim shady\") D getFoo();",
+            "    C injectC(C c);",
+            "  }",
+            "}");
+    String errorText = "test.TestClass.A cannot be provided without an @Provides-annotated method.";
+    String firstError =
+        Joiner.on('\n')
+            .join(
+                errorText,
+                "      test.TestClass.B.<init>(a)",
+                "          injects test.TestClass.A",
+                "      test.TestClass.C.b",
+                "          injects test.TestClass.B",
+                "      test.TestClass.DImpl.<init>(c, …)",
+                "          injects test.TestClass.C",
+                "      test.TestClass.DModule.d(…, impl, …)",
+                "          injects test.TestClass.DImpl",
+                "      test.TestClass.AComponent.getFoo()",
+                "          provides @javax.inject.Named(\"slim shady\") test.TestClass.D");
+    String secondError =
+        Joiner.on('\n')
+            .join(
+                errorText,
+                "      test.TestClass.B.<init>(a)",
+                "          injects test.TestClass.A",
+                "      test.TestClass.C.b",
+                "          injects test.TestClass.B",
+                "      test.TestClass.AComponent.injectC(c)",
+                "          injects test.TestClass.C");
+    assertAbout(javaSource())
+        .that(component)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(firstError).in(component).onLine(33)
-        .and().withErrorContaining(secondError).in(component).onLine(34);
+        .withErrorContaining(firstError)
+        .in(component)
+        .onLine(38)
+        .and()
+        .withErrorContaining(secondError)
+        .in(component)
+        .onLine(39);
   }
 
   @Test public void resolvedParametersInDependencyTrace() {
@@ -823,14 +916,18 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration()
         "interface TestComponent {",
         "  UsesTest usesTest();",
         "}");
-    String expectedMsg = Joiner.on("\n").join(
-        "java.util.List cannot be provided without an @Provides-annotated method.",
-        "      test.UsesTest.<init>(test.Generic<test.TestClass> genericTestClass)",
-        "          [parameter: test.Generic<test.TestClass> genericTestClass]",
-        "      test.Generic.<init>(test.TestClass t)",
-        "          [parameter: test.TestClass t]",
-        "      test.TestClass.<init>(java.util.List list)",
-        "          [parameter: java.util.List list]");
+    String expectedMsg =
+        Joiner.on("\n")
+            .join(
+                "java.util.List cannot be provided without an @Provides-annotated method.",
+                "      test.TestClass.<init>(list)",
+                "          injects java.util.List",
+                "      test.Generic.<init>(t)",
+                "          injects test.TestClass",
+                "      test.UsesTest.<init>(genericTestClass)",
+                "          injects test.Generic<test.TestClass>",
+                "      test.TestComponent.usesTest()",
+                "          provides test.UsesTest");
     assertAbout(javaSources()).that(ImmutableList.of(generic, testClass, usesTest, component))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
@@ -874,14 +971,18 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration()
         "interface TestComponent {",
         "  UsesTest usesTest();",
         "}");
-    String expectedMsg = Joiner.on("\n").join(
-        "java.util.List cannot be provided without an @Provides-annotated method.",
-        "      test.UsesTest.<init>(test.Generic<test.TestClass> genericTestClass)",
-        "          [parameter: test.Generic<test.TestClass> genericTestClass]",
-        "      test.Generic.t",
-        "          [injected field of type: test.TestClass t]",
-        "      test.TestClass.<init>(java.util.List list)",
-        "          [parameter: java.util.List list]");
+    String expectedMsg =
+        Joiner.on("\n")
+            .join(
+                "java.util.List cannot be provided without an @Provides-annotated method.",
+                "      test.TestClass.<init>(list)",
+                "          injects java.util.List",
+                "      test.Generic.t",
+                "          injects test.TestClass",
+                "      test.UsesTest.<init>(genericTestClass)",
+                "          injects test.Generic<test.TestClass>",
+                "      test.TestComponent.usesTest()",
+                "          provides test.UsesTest");
     assertAbout(javaSources()).that(ImmutableList.of(generic, testClass, usesTest, component))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
@@ -1354,4 +1455,58 @@ public void subcomponentBindingConflictsWithParentWithNullableViolationAsWarning
         .in(parentConflictsWithChild)
         .onLine(9);
   }
+  
+  @Test
+  public void bindingUsedOnlyInSubcomponentDependsOnBindingOnlyInSubcomponent() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "Parent",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = ParentModule.class)",
+            "interface Parent {",
+            "  Child child();",
+            "}");
+    JavaFileObject parentModule =
+        JavaFileObjects.forSourceLines(
+            "ParentModule",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class ParentModule {",
+            "  @Provides static Object needsString(String string) {",
+            "    return \"needs string: \" + string;",
+            "  }",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "Child",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = ChildModule.class)",
+            "interface Child {",
+            "  String string();",
+            "  Object needsString();",
+            "}");
+    JavaFileObject childModule =
+        JavaFileObjects.forSourceLines(
+            "ChildModule",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class ChildModule {",
+            "  @Provides static String string() {",
+            "    return \"child string\";",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(parent, parentModule, child, childModule))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("[Child.needsString()] java.lang.String cannot be provided")
+        .in(parent)
+        .onLine(4);
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
index a4b796e76..2c4643ad5 100644
--- a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
@@ -363,79 +363,81 @@
         "                       @QualifierA String qs, Lazy<String> ls,",
         "                       B b, B b2, Provider<B> pb, @QualifierA B qb, Lazy<B> lb) {}",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass_Factory",
-        "package test;",
-        "",
-        "import dagger.internal.DoubleCheckLazy;",
-        "import dagger.internal.Factory;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class GenericClass_Factory<A, B> implements Factory<GenericClass<A, B>> {",
-        "  private final Provider<A> aAndA2AndPaAndLaProvider;",
-        "  private final Provider<A> qaProvider;",
-        "  private final Provider<String> sAndS2AndPsAndLsProvider;",
-        "  private final Provider<String> qsProvider;",
-        "  private final Provider<B> bAndB2AndPbAndLbProvider;",
-        "  private final Provider<B> qbProvider;",
-        "",
-        "  public GenericClass_Factory(Provider<A> aAndA2AndPaAndLaProvider,",
-        "      Provider<A> qaProvider,",
-        "      Provider<String> sAndS2AndPsAndLsProvider,",
-        "      Provider<String> qsProvider,",
-        "      Provider<B> bAndB2AndPbAndLbProvider,",
-        "      Provider<B> qbProvider) {",
-        "    assert aAndA2AndPaAndLaProvider != null;",
-        "    this.aAndA2AndPaAndLaProvider = aAndA2AndPaAndLaProvider;",
-        "    assert qaProvider != null;",
-        "    this.qaProvider = qaProvider;",
-        "    assert sAndS2AndPsAndLsProvider != null;",
-        "    this.sAndS2AndPsAndLsProvider = sAndS2AndPsAndLsProvider;",
-        "    assert qsProvider != null;",
-        "    this.qsProvider = qsProvider;",
-        "    assert bAndB2AndPbAndLbProvider != null;",
-        "    this.bAndB2AndPbAndLbProvider = bAndB2AndPbAndLbProvider;",
-        "    assert qbProvider != null;",
-        "    this.qbProvider = qbProvider;",
-        "  }",
-        "",
-        "  @Override",
-        "  public GenericClass<A, B> get() {",
-        "    return new GenericClass<A, B>(",
-        "      aAndA2AndPaAndLaProvider.get(),",
-        "      aAndA2AndPaAndLaProvider.get(),",
-        "      aAndA2AndPaAndLaProvider,",
-        "      qaProvider.get(),",
-        "      DoubleCheckLazy.create(aAndA2AndPaAndLaProvider),",
-        "      sAndS2AndPsAndLsProvider.get(),",
-        "      sAndS2AndPsAndLsProvider.get(),",
-        "      sAndS2AndPsAndLsProvider,",
-        "      qsProvider.get(),",
-        "      DoubleCheckLazy.create(sAndS2AndPsAndLsProvider),",
-        "      bAndB2AndPbAndLbProvider.get(),",
-        "      bAndB2AndPbAndLbProvider.get(),",
-        "      bAndB2AndPbAndLbProvider,",
-        "      qbProvider.get(),",
-        "      DoubleCheckLazy.create(bAndB2AndPbAndLbProvider));",
-        "  }",
-        "",
-        "  public static <A, B> Factory<GenericClass<A, B>> create(",
-        "      Provider<A> aAndA2AndPaAndLaProvider,",
-        "      Provider<A> qaProvider,",
-        "      Provider<String> sAndS2AndPsAndLsProvider,",
-        "      Provider<String> qsProvider,",
-        "      Provider<B> bAndB2AndPbAndLbProvider,",
-        "      Provider<B> qbProvider) {",
-        "    return new GenericClass_Factory<A, B>(",
-        "        aAndA2AndPaAndLaProvider,",
-        "        qaProvider,",
-        "        sAndS2AndPsAndLsProvider,",
-        "        qsProvider,",
-        "        bAndB2AndPbAndLbProvider,",
-        "        qbProvider);",
-        "  }",
-        "}");
+    JavaFileObject expected =
+        JavaFileObjects.forSourceLines(
+            "test.GenericClass_Factory",
+            "package test;",
+            "",
+            "import dagger.internal.DoubleCheck;",
+            "import dagger.internal.Factory;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class GenericClass_Factory<A, B> implements Factory<GenericClass<A, B>> {",
+            "  private final Provider<A> aAndA2AndPaAndLaProvider;",
+            "  private final Provider<A> qaProvider;",
+            "  private final Provider<String> sAndS2AndPsAndLsProvider;",
+            "  private final Provider<String> qsProvider;",
+            "  private final Provider<B> bAndB2AndPbAndLbProvider;",
+            "  private final Provider<B> qbProvider;",
+            "",
+            "  public GenericClass_Factory(Provider<A> aAndA2AndPaAndLaProvider,",
+            "      Provider<A> qaProvider,",
+            "      Provider<String> sAndS2AndPsAndLsProvider,",
+            "      Provider<String> qsProvider,",
+            "      Provider<B> bAndB2AndPbAndLbProvider,",
+            "      Provider<B> qbProvider) {",
+            "    assert aAndA2AndPaAndLaProvider != null;",
+            "    this.aAndA2AndPaAndLaProvider = aAndA2AndPaAndLaProvider;",
+            "    assert qaProvider != null;",
+            "    this.qaProvider = qaProvider;",
+            "    assert sAndS2AndPsAndLsProvider != null;",
+            "    this.sAndS2AndPsAndLsProvider = sAndS2AndPsAndLsProvider;",
+            "    assert qsProvider != null;",
+            "    this.qsProvider = qsProvider;",
+            "    assert bAndB2AndPbAndLbProvider != null;",
+            "    this.bAndB2AndPbAndLbProvider = bAndB2AndPbAndLbProvider;",
+            "    assert qbProvider != null;",
+            "    this.qbProvider = qbProvider;",
+            "  }",
+            "",
+            "  @Override",
+            "  public GenericClass<A, B> get() {",
+            "    return new GenericClass<A, B>(",
+            "      aAndA2AndPaAndLaProvider.get(),",
+            "      aAndA2AndPaAndLaProvider.get(),",
+            "      aAndA2AndPaAndLaProvider,",
+            "      qaProvider.get(),",
+            "      DoubleCheck.lazy(aAndA2AndPaAndLaProvider),",
+            "      sAndS2AndPsAndLsProvider.get(),",
+            "      sAndS2AndPsAndLsProvider.get(),",
+            "      sAndS2AndPsAndLsProvider,",
+            "      qsProvider.get(),",
+            "      DoubleCheck.lazy(sAndS2AndPsAndLsProvider),",
+            "      bAndB2AndPbAndLbProvider.get(),",
+            "      bAndB2AndPbAndLbProvider.get(),",
+            "      bAndB2AndPbAndLbProvider,",
+            "      qbProvider.get(),",
+            "      DoubleCheck.lazy(bAndB2AndPbAndLbProvider));",
+            "  }",
+            "",
+            "  public static <A, B> Factory<GenericClass<A, B>> create(",
+            "      Provider<A> aAndA2AndPaAndLaProvider,",
+            "      Provider<A> qaProvider,",
+            "      Provider<String> sAndS2AndPsAndLsProvider,",
+            "      Provider<String> qsProvider,",
+            "      Provider<B> bAndB2AndPbAndLbProvider,",
+            "      Provider<B> qbProvider) {",
+            "    return new GenericClass_Factory<A, B>(",
+            "        aAndA2AndPaAndLaProvider,",
+            "        qaProvider,",
+            "        sAndS2AndPsAndLsProvider,",
+            "        qsProvider,",
+            "        bAndB2AndPbAndLbProvider,",
+            "        qbProvider);",
+            "  }",
+            "}");
     assertAbout(javaSources()).that(ImmutableList.of(file, QUALIFIER_A))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
diff --git a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
index 3eef6ab97..0a5814765 100644
--- a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
@@ -101,7 +101,7 @@
   @Module
   static final class ProvidesMethodModule {
     @Provides String provideString() {
-      return null;
+      throw new UnsupportedOperationException();
     }
   }
 
@@ -143,7 +143,7 @@
     @Provides
     @TestQualifier(@InnerAnnotation)
     String provideQualifiedString() {
-      return null;
+      throw new UnsupportedOperationException();
     }
   }
 
@@ -179,11 +179,11 @@ String provideQualifiedString() {
   @Module
   static final class SetProvidesMethodsModule {
     @Provides(type = SET) String provideString() {
-      return null;
+      throw new UnsupportedOperationException();
     }
 
     @Provides(type = SET_VALUES) Set<String> provideStrings() {
-      return null;
+      throw new UnsupportedOperationException();
     }
   }
 
@@ -242,11 +242,11 @@ String provideQualifiedString() {
   @ProducerModule
   static final class ProducesMethodsModule {
     @Produces String produceString() {
-      return null;
+      throw new UnsupportedOperationException();
     }
 
     @Produces ListenableFuture<String> produceFutureString() {
-      return null;
+      throw new UnsupportedOperationException();
     }
   }
 
@@ -271,20 +271,20 @@ String provideQualifiedString() {
   @ProducerModule
   static final class SetProducesMethodsModule {
     @Produces(type = Produces.Type.SET) String produceString() {
-      return null;
+      throw new UnsupportedOperationException();
     }
 
     @Produces(type = Produces.Type.SET) ListenableFuture<String> produceFutureString() {
-      return null;
+      throw new UnsupportedOperationException();
     }
 
     @Produces(type = Produces.Type.SET_VALUES) Set<String> produceStrings() {
-      return null;
+      throw new UnsupportedOperationException();
     }
 
     @Produces(type = Produces.Type.SET_VALUES)
     ListenableFuture<Set<String>> produceFutureStrings() {
-      return null;
+      throw new UnsupportedOperationException();
     }
   }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
index 058c25bf2..a295f5098 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -213,7 +213,7 @@ public void mapBindingsWithStringKey() {
                 "",
                 "import dagger.Module;",
                 "import dagger.Provides;",
-                "import dagger.mapkeys.StringKey;",
+                "import dagger.multibindings.StringKey;",
                 "",
                 "@Module",
                 "final class MapModuleOne {",
@@ -230,7 +230,7 @@ public void mapBindingsWithStringKey() {
                 "",
                 "import dagger.Module;",
                 "import dagger.Provides;",
-                "import dagger.mapkeys.StringKey;",
+                "import dagger.multibindings.StringKey;",
                 "",
                 "@Module",
                 "final class MapModuleTwo {",
@@ -788,7 +788,7 @@ public void mapBindingsWithDuplicateKeys() {
             "",
             "import dagger.Module;",
             "import dagger.Provides;",
-            "import dagger.mapkeys.StringKey;",
+            "import dagger.multibindings.StringKey;",
             "",
             "import static dagger.Provides.Type.MAP;",
             "",
@@ -837,7 +837,7 @@ public void mapBindingsWithInconsistentKeyAnnotations() {
             "",
             "import dagger.Module;",
             "import dagger.Provides;",
-            "import dagger.mapkeys.StringKey;",
+            "import dagger.multibindings.StringKey;",
             "",
             "import static dagger.Provides.Type.MAP;",
             "",
diff --git a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
index 1b585f603..5443aac01 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
@@ -382,54 +382,55 @@ public void parentClass_injectedMembersInSupertype() {
         "  @Inject Lazy<String> lazyString;",
         "  @Inject Provider<String> stringProvider;",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines(
-        "test.FieldInjection_MembersInjector",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import dagger.internal.DoubleCheckLazy;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class FieldInjection_MembersInjector",
-        "    implements MembersInjector<FieldInjection> {",
-        "  private final Provider<String> stringProvider;",
-        "",
-        "  public FieldInjection_MembersInjector(Provider<String> stringProvider) {",
-        "    assert stringProvider != null;",
-        "    this.stringProvider = stringProvider;",
-        "  }",
-        "",
-        "  public static MembersInjector<FieldInjection> create(Provider<String> stringProvider) {",
-        "    return new FieldInjection_MembersInjector(stringProvider);",
-        "  }",
-        "",
-        "  @Override",
-        "  public void injectMembers(FieldInjection instance) {",
-        "    if (instance == null) {",
-        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
-        "    }",
-        "    instance.string = stringProvider.get();",
-        "    instance.lazyString = DoubleCheckLazy.create(stringProvider);",
-        "    instance.stringProvider = stringProvider;",
-        "  }",
-        "",
-        "  public static void injectString(",
-        "      FieldInjection instance, Provider<String> stringProvider) {",
-        "    instance.string = stringProvider.get();",
-        "  }",
-        "",
-        "  public static void injectLazyString(",
-        "      FieldInjection instance, Provider<String> lazyStringProvider) {",
-        "    instance.lazyString = DoubleCheckLazy.create(lazyStringProvider);",
-        "  }",
-        "",
-        "  public static void injectStringProvider(",
-        "      FieldInjection instance, Provider<String> stringProvider) {",
-        "    instance.stringProvider = stringProvider;",
-        "  }",
-        "}");
+    JavaFileObject expected =
+        JavaFileObjects.forSourceLines(
+            "test.FieldInjection_MembersInjector",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import dagger.internal.DoubleCheck;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class FieldInjection_MembersInjector",
+            "    implements MembersInjector<FieldInjection> {",
+            "  private final Provider<String> stringProvider;",
+            "",
+            "  public FieldInjection_MembersInjector(Provider<String> stringProvider) {",
+            "    assert stringProvider != null;",
+            "    this.stringProvider = stringProvider;",
+            "  }",
+            "",
+            "  public static MembersInjector<FieldInjection> create(Provider<String> stringProvider) {",
+            "    return new FieldInjection_MembersInjector(stringProvider);",
+            "  }",
+            "",
+            "  @Override",
+            "  public void injectMembers(FieldInjection instance) {",
+            "    if (instance == null) {",
+            "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+            "    }",
+            "    instance.string = stringProvider.get();",
+            "    instance.lazyString = DoubleCheck.lazy(stringProvider);",
+            "    instance.stringProvider = stringProvider;",
+            "  }",
+            "",
+            "  public static void injectString(",
+            "      FieldInjection instance, Provider<String> stringProvider) {",
+            "    instance.string = stringProvider.get();",
+            "  }",
+            "",
+            "  public static void injectLazyString(",
+            "      FieldInjection instance, Provider<String> lazyStringProvider) {",
+            "    instance.lazyString = DoubleCheck.lazy(lazyStringProvider);",
+            "  }",
+            "",
+            "  public static void injectStringProvider(",
+            "      FieldInjection instance, Provider<String> stringProvider) {",
+            "    instance.stringProvider = stringProvider;",
+            "  }",
+            "}");
     assertAbout(javaSource())
         .that(file)
         .processedWith(new ComponentProcessor())
@@ -452,62 +453,65 @@ public void parentClass_injectedMembersInSupertype() {
         "  @Inject void manyArgs(",
         "      String string, Lazy<String> lazyString, Provider<String> stringProvider) {}",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines(
-        "test.MethodInjection_MembersInjector",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import dagger.internal.DoubleCheckLazy;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class MethodInjection_MembersInjector",
-        "     implements MembersInjector<MethodInjection> {",
-        "",
-        "  private final Provider<String> stringProvider;",
-        "",
-        "  public MethodInjection_MembersInjector(Provider<String> stringProvider) {",
-        "    assert stringProvider != null;",
-        "    this.stringProvider = stringProvider;",
-        "  }",
-        "",
-        "  public static MembersInjector<MethodInjection> create(",
-        "      Provider<String> stringProvider) {",
-        "    return new MethodInjection_MembersInjector(stringProvider);",
-        "  }",
-        "",
-        "  @Override",
-        "  public void injectMembers(MethodInjection instance) {",
-        "    if (instance == null) {",
-        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
-        "    }",
-        "    instance.noArgs();",
-        "    instance.oneArg(stringProvider.get());",
-        "    instance.manyArgs(stringProvider.get(), DoubleCheckLazy.create(stringProvider),",
-        "        stringProvider);",
-        "  }",
-        "",
-        "  public static void injectNoArgs(MethodInjection instance) {",
-        "    instance.noArgs();",
-        "  }",
-        "",
-        "  public static void injectOneArg(",
-        "      MethodInjection instance, Provider<String> stringProvider) {",
-        "    instance.oneArg(stringProvider.get());",
-        "  }",
-        "",
-        "  public static void injectManyArgs(",
-        "      MethodInjection instance,",
-        "      Provider<String> stringProvider,",
-        "      Provider<String> lazyStringProvider,",
-        "      Provider<String> stringProvider2) {",
-        "    instance.manyArgs(",
-        "        stringProvider.get(),",
-        "        DoubleCheckLazy.create(lazyStringProvider),",
-        "        stringProvider2);",
-        "  }",
-        "}");
+    JavaFileObject expected =
+        JavaFileObjects.forSourceLines(
+            "test.MethodInjection_MembersInjector",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import dagger.internal.DoubleCheck;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class MethodInjection_MembersInjector",
+            "     implements MembersInjector<MethodInjection> {",
+            "",
+            "  private final Provider<String> stringProvider;",
+            "",
+            "  public MethodInjection_MembersInjector(Provider<String> stringProvider) {",
+            "    assert stringProvider != null;",
+            "    this.stringProvider = stringProvider;",
+            "  }",
+            "",
+            "  public static MembersInjector<MethodInjection> create(",
+            "      Provider<String> stringProvider) {",
+            "    return new MethodInjection_MembersInjector(stringProvider);",
+            "  }",
+            "",
+            "  @Override",
+            "  public void injectMembers(MethodInjection instance) {",
+            "    if (instance == null) {",
+            "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+            "    }",
+            "    instance.noArgs();",
+            "    instance.oneArg(stringProvider.get());",
+            "    instance.manyArgs(",
+            "        stringProvider.get(),",
+            "        DoubleCheck.lazy(stringProvider),",
+            "        stringProvider);",
+            "  }",
+            "",
+            "  public static void injectNoArgs(MethodInjection instance) {",
+            "    instance.noArgs();",
+            "  }",
+            "",
+            "  public static void injectOneArg(",
+            "      MethodInjection instance, Provider<String> stringProvider) {",
+            "    instance.oneArg(stringProvider.get());",
+            "  }",
+            "",
+            "  public static void injectManyArgs(",
+            "      MethodInjection instance,",
+            "      Provider<String> stringProvider,",
+            "      Provider<String> lazyStringProvider,",
+            "      Provider<String> stringProvider2) {",
+            "    instance.manyArgs(",
+            "        stringProvider.get(),",
+            "        DoubleCheck.lazy(lazyStringProvider),",
+            "        stringProvider2);",
+            "  }",
+            "}");
     assertAbout(javaSource())
         .that(file)
         .processedWith(new ComponentProcessor())
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index 39d439196..63c5821e5 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -929,7 +929,7 @@ public void genericSubclassedModule() {
             "",
             "import dagger.Module;",
             "import dagger.Provides;",
-            "import dagger.mapkeys.StringKey;",
+            "import dagger.multibindings.StringKey;",
             "import java.util.List;",
             "import java.util.ArrayList;",
             "",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
index ffda289a7..64cfba626 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -252,9 +252,9 @@ public void dependsOnProductionExecutor() {
             "package test;",
             "",
             "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.internal.DoubleCheck;",
             "import dagger.internal.InstanceFactory;",
             "import dagger.internal.Preconditions;",
-            "import dagger.internal.ScopedProvider;",
             "import dagger.internal.SetFactory;",
             "import dagger.producers.Producer;",
             "import dagger.producers.internal.Producers;",
@@ -286,14 +286,14 @@ public void dependsOnProductionExecutor() {
             "  private void initialize(final Builder builder) {",
             "    this.simpleComponentProvider =",
             "        InstanceFactory.<Executor>create(builder.executor);",
-            "     this.executorProvider =",
-            "         ScopedProvider.create(",
-            "             TestClass$SimpleComponent_ProductionExecutorModule_ExecutorFactory",
-            "                 .create(simpleComponentProvider));",
+            "    this.executorProvider =",
+            "        DoubleCheck.provider(",
+            "            TestClass$SimpleComponent_ProductionExecutorModule_ExecutorFactory",
+            "                .create(simpleComponentProvider));",
             "    this.simpleComponentProvider2 =",
             "        InstanceFactory.<TestClass.SimpleComponent>create(this);",
             "    this.monitorProvider =",
-            "        ScopedProvider.create(",
+            "        DoubleCheck.provider(",
             "            TestClass$SimpleComponent_MonitoringModule_MonitorFactory.create(",
             "                simpleComponentProvider2,",
             "                SetFactory.<ProductionComponentMonitor.Factory>create());",
@@ -370,4 +370,57 @@ public void dependsOnProductionExecutor() {
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
   }
+
+  @Test public void nullableProducersAreNotErrors() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "import dagger.producers.ProductionComponent;",
+        "import javax.annotation.Nullable;",
+        "import javax.inject.Inject;",
+        "",
+        "final class TestClass {",
+        "  interface A {}",
+        "  interface B {}",
+        "  interface C {}",
+        "",
+        "  @Module",
+        "  static final class CModule {",
+        "    @Provides @Nullable C c() {",
+        "      return null;",
+        "    }",
+        "  }",
+        "",
+        "  @ProducerModule",
+        "  static final class ABModule {",
+        "    @Produces @Nullable B b(@Nullable C c) {",
+        "      return null;",
+        "    }",
+
+        "    @Produces @Nullable ListenableFuture<A> a(B b) {",  // NOTE: B not injected as nullable
+        "      return null;",
+        "    }",
+        "  }",
+        "",
+        "  @ProductionComponent(modules = {ABModule.class, CModule.class})",
+        "  interface SimpleComponent {",
+        "    ListenableFuture<A> a();",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .withWarningContaining("@Nullable on @Produces methods does not do anything")
+        .in(component)
+        .onLine(26)
+        .and()
+        .withWarningContaining("@Nullable on @Produces methods does not do anything")
+        .in(component)
+        .onLine(29);
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
index 145e856f2..399fb758f 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
 import java.util.Arrays;
 import javax.tools.JavaFileObject;
@@ -268,4 +269,87 @@ public void monitoringDependsOnProduction() {
         .in(component)
         .onLine(36);
   }
+  
+  @Test
+  public void cycleNotBrokenByMap() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "TestComponent",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.producers.ProductionComponent;",
+            "",
+            "@ProductionComponent(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  ListenableFuture<String> string();",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "TestModule",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.Produces;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "import static dagger.producers.Produces.Type.MAP;",
+            "",
+            "@ProducerModule",
+            "final class TestModule {",
+            "  @Produces static String string(Map<String, String> map) {",
+            "    return \"string\";",
+            "  }",
+            "",
+            "  @Produces(type = MAP) @StringKey(\"key\")",
+            "  static String entry(String string) {",
+            "    return string;",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(component, module))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("cycle")
+        .in(component)
+        .onLine(6);
+  }
+
+  @Test
+  public void cycleNotBrokenByProducerMap() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "TestComponent",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.producers.ProductionComponent;",
+            "",
+            "@ProductionComponent(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  ListenableFuture<String> string();",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "TestModule",
+            "import dagger.producers.Producer;",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.Produces;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "import static dagger.producers.Produces.Type.MAP;",
+            "",
+            "@ProducerModule",
+            "final class TestModule {",
+            "  @Produces static String string(Map<String, Producer<String>> map) {",
+            "    return \"string\";",
+            "  }",
+            "",
+            "  @Produces(type = MAP) @StringKey(\"key\")",
+            "  static String entry(String string) {",
+            "    return string;",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(component, module))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("cycle")
+        .in(component)
+        .onLine(6);
+  }
 }
diff --git a/core/src/main/java/dagger/MapKey.java b/core/src/main/java/dagger/MapKey.java
index e65c99f62..dfcfc139e 100644
--- a/core/src/main/java/dagger/MapKey.java
+++ b/core/src/main/java/dagger/MapKey.java
@@ -63,8 +63,8 @@
  * <p>If {@code unwrapValue} is true, the annotation's single member can be any type except an
  * array.
  *
- * <p>See {@link dagger.mapkeys} for standard unwrapped map key annotations for keys that are boxed
- * primitives, strings, or classes.
+ * <p>See {@link dagger.multibindings} for standard unwrapped map key annotations for keys that are
+ * boxed primitives, strings, or classes.
  *
  * <h2>Annotations as keys</h2>
  *
diff --git a/core/src/main/java/dagger/mapkeys/StringKey.java b/core/src/main/java/dagger/Reusable.java
similarity index 50%
rename from core/src/main/java/dagger/mapkeys/StringKey.java
rename to core/src/main/java/dagger/Reusable.java
index e283f4782..01175e0ee 100644
--- a/core/src/main/java/dagger/mapkeys/StringKey.java
+++ b/core/src/main/java/dagger/Reusable.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2016 Google, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,26 +13,24 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.mapkeys;
+package dagger;
 
-import dagger.MapKey;
-import dagger.internal.Beta;
 import java.lang.annotation.Documented;
-import java.lang.annotation.Target;
+import java.lang.annotation.Retention;
+import javax.inject.Scope;
 
-import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
- * A {@link MapKey} annotation for maps with {@link String} keys.
+ * A scope that indicates that the object returned by a binding may be (but might not be) reused.
  *
- * @deprecated This annotation is being replaced by {@link dagger.multibindings.StringKey}. Prefer
- *     that annotation over this one.
+ * <p>{@code @Reusable} is useful when you want to limit the number of provisions of a type, but
+ * there is no specific lifetime over which there must be only one instance.
+ *
+ * @see <a href="http://google.github.io/dagger/users-guide.html#reusable-scope">Reusable Scope
+ * </a>
  */
-@Beta
 @Documented
-@Target(METHOD)
-@MapKey
-@Deprecated
-public @interface StringKey {
-  String value();
-}
+@Retention(RUNTIME)
+@Scope
+public @interface Reusable {}
diff --git a/core/src/main/java/dagger/internal/DoubleCheckLazy.java b/core/src/main/java/dagger/internal/DoubleCheck.java
similarity index 57%
rename from core/src/main/java/dagger/internal/DoubleCheckLazy.java
rename to core/src/main/java/dagger/internal/DoubleCheck.java
index 8257c3beb..6498eae31 100644
--- a/core/src/main/java/dagger/internal/DoubleCheckLazy.java
+++ b/core/src/main/java/dagger/internal/DoubleCheck.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2016 Google, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -18,26 +18,24 @@
 import dagger.Lazy;
 import javax.inject.Provider;
 
+import static dagger.internal.Preconditions.checkNotNull;
+
 /**
- * A basic {@link Lazy} implementation that memoizes the value returned from a {@link Provider}
- * using the double-check idiom described in Effective Java 2: Item 71.
- *
- * @author Gregory Kick
- * @since 2.0
+ * A {@link Lazy} and {@link Provider} implementation that memoizes the value returned from a
+ * delegate using the double-check idiom described in Item 71 of <i>Effective Java 2</i>.
  */
-// TODO(gak): Unify the duplicated code between this and ScopedProvider.
-public final class DoubleCheckLazy<T> implements Lazy<T> {
+public final class DoubleCheck<T> implements Provider<T>, Lazy<T> {
   private static final Object UNINITIALIZED = new Object();
 
-  private final Provider<T> provider;
+  private volatile Provider<T> provider;
   private volatile Object instance = UNINITIALIZED;
 
-  private DoubleCheckLazy(Provider<T> provider) {
+  private DoubleCheck(Provider<T> provider) {
     assert provider != null;
     this.provider = provider;
   }
 
-  @SuppressWarnings("unchecked") // cast only happens when result comes from the factory
+  @SuppressWarnings("unchecked") // cast only happens when result comes from the provider
   @Override
   public T get() {
     Object result = instance;
@@ -46,26 +44,32 @@ public T get() {
         result = instance;
         if (result == UNINITIALIZED) {
           instance = result = provider.get();
+          /* Null out the reference to the provider. We are never going to need it again, so we
+           * can make it eligible for GC. */
+          provider = null;
         }
       }
     }
     return (T) result;
   }
 
-  public static <T> Lazy<T> create(Provider<T> provider) {
-    if (provider == null) {
-      throw new NullPointerException();
-    }
+  /** Returns a new provider that caches the value from the given factory. */
+  public static <T> Provider<T> provider(Factory<T> factory) {
+    return new DoubleCheck<T>(checkNotNull(factory));
+  }
+
+  /** Returns a {@link Lazy} that caches the value from the given provider. */
+  public static <T> Lazy<T> lazy(Provider<T> provider) {
     if (provider instanceof Lazy) {
       @SuppressWarnings("unchecked")
       final Lazy<T> lazy = (Lazy<T>) provider;
       // Avoids memoizing a value that is already memoized.
       // NOTE: There is a pathological case where Provider<P> may implement Lazy<L>, but P and L
       // are different types using covariant return on get(). Right now this is used with
-      // ScopedProvider<T> exclusively, which is implemented such that P and L are always the same
-      // so it will be fine for that case.
+      // DoubleCheck<T> exclusively, which is implemented such that P and L are always
+      // the same, so it will be fine for that case.
       return lazy;
     }
-    return new DoubleCheckLazy<T>(provider);
+    return new DoubleCheck<T>(checkNotNull(provider));
   }
 }
diff --git a/core/src/main/java/dagger/internal/InstanceFactory.java b/core/src/main/java/dagger/internal/InstanceFactory.java
index 59b1fcb8b..400d26825 100644
--- a/core/src/main/java/dagger/internal/InstanceFactory.java
+++ b/core/src/main/java/dagger/internal/InstanceFactory.java
@@ -21,8 +21,8 @@
  *
  * <p>Note that while this is a {@link Factory} implementation, and thus unscoped, each call to
  * {@link #get} will always return the same instance.  As such, any scoping applied to this factory
- * is redundant and unnecessary.  However, using this with the {@link ScopedProvider} is valid and
- * may be desired for testing or contractual guarantees.
+ * is redundant and unnecessary.  However, using this with {@link DoubleCheck#provider(Factory)} is
+ * valid and may be desired for testing or contractual guarantees.
  *
  * @author Gregory Kick
  * @since 2.0
diff --git a/core/src/main/java/dagger/internal/ScopedProvider.java b/core/src/main/java/dagger/internal/SimpleLazilyInitializedProvider.java
similarity index 63%
rename from core/src/main/java/dagger/internal/ScopedProvider.java
rename to core/src/main/java/dagger/internal/SimpleLazilyInitializedProvider.java
index b25db380a..a87d3136f 100644
--- a/core/src/main/java/dagger/internal/ScopedProvider.java
+++ b/core/src/main/java/dagger/internal/SimpleLazilyInitializedProvider.java
@@ -18,19 +18,19 @@
 import dagger.Lazy;
 import javax.inject.Provider;
 
+import static dagger.internal.Preconditions.checkNotNull;
+
 /**
- * A {@link Provider} implementation that memoizes the result of a {@link Factory} instance.
- *
- * @author Gregory Kick
- * @since 2.0
+ * A {@link Provider} implementation that memoizes the result of a {@link Factory} instance using
+ * simple lazy initialization, not the double-checked lock pattern.
  */
-public final class ScopedProvider<T> implements Provider<T>, Lazy<T> {
+public final class SimpleLazilyInitializedProvider<T> implements Provider<T>, Lazy<T> {
   private static final Object UNINITIALIZED = new Object();
 
   private final Factory<T> factory;
   private volatile Object instance = UNINITIALIZED;
 
-  private ScopedProvider(Factory<T> factory) {
+  private SimpleLazilyInitializedProvider(Factory<T> factory) {
     assert factory != null;
     this.factory = factory;
   }
@@ -38,24 +38,14 @@ private ScopedProvider(Factory<T> factory) {
   @SuppressWarnings("unchecked") // cast only happens when result comes from the factory
   @Override
   public T get() {
-    // double-check idiom from EJ2: Item 71
-    Object result = instance;
-    if (result == UNINITIALIZED) {
-      synchronized (this) {
-        result = instance;
-        if (result == UNINITIALIZED) {
-          instance = result = factory.get();
-        }
-      }
+    if (instance == UNINITIALIZED) {
+      instance = factory.get();
     }
-    return (T) result;
+    return (T) instance;
   }
 
-  /** Returns a new scoped provider for the given factory. */
+  /** Returns a new provider for the given factory. */
   public static <T> Provider<T> create(Factory<T> factory) {
-    if (factory == null) {
-      throw new NullPointerException();
-    }
-    return new ScopedProvider<T>(factory);
+    return new SimpleLazilyInitializedProvider<T>(checkNotNull(factory));
   }
 }
diff --git a/core/src/test/java/dagger/internal/DoubleCheckLazyTest.java b/core/src/test/java/dagger/internal/DoubleCheckTest.java
similarity index 84%
rename from core/src/test/java/dagger/internal/DoubleCheckLazyTest.java
rename to core/src/test/java/dagger/internal/DoubleCheckTest.java
index 579e0405f..af110f49b 100644
--- a/core/src/test/java/dagger/internal/DoubleCheckLazyTest.java
+++ b/core/src/test/java/dagger/internal/DoubleCheckTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2016 Google, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -37,14 +37,32 @@
 import static org.junit.Assert.fail;
 
 @RunWith(JUnit4.class)
-public class DoubleCheckLazyTest {
+public class DoubleCheckTest {
+  @Test
+  public void provider_nullPointerException() {
+    try {
+      DoubleCheck.provider(null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+  }
+
+  @Test
+  public void lazy_nullPointerException() {
+    try {
+      DoubleCheck.lazy(null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+  }
+
   @Test public void get() throws Exception {
     int numThreads = 10;
     ExecutorService executor = Executors.newFixedThreadPool(numThreads);
 
     final CountDownLatch latch = new CountDownLatch(numThreads);
     LatchedProvider provider = new LatchedProvider(latch);
-    final Lazy<Object> lazy = DoubleCheckLazy.create(provider);
+    final Lazy<Object> lazy = DoubleCheck.lazy(provider);
 
     List<Callable<Object>> tasks = Lists.newArrayListWithCapacity(numThreads);
     for (int i = 0; i < numThreads; i++) {
@@ -66,19 +84,6 @@
     assert_().that(results.size()).isEqualTo(1);
   }
 
-  // TODO(gak): reenable this test once we can ensure that factories are no longer providing null
-  @Ignore @Test public void get_null() {
-    Lazy<Object> lazy = DoubleCheckLazy.create(new Provider<Object> () {
-      @Override public Object get() {
-        return null;
-      }
-    });
-    try {
-      lazy.get();
-      fail();
-    } catch (NullPointerException expected) {}
-  }
-
   private static class LatchedProvider implements Provider<Object> {
     final AtomicInteger provisions;
     final CountDownLatch latch;
diff --git a/core/src/test/java/dagger/internal/ScopedProviderTest.java b/core/src/test/java/dagger/internal/ScopedProviderTest.java
deleted file mode 100644
index 84b02c510..000000000
--- a/core/src/test/java/dagger/internal/ScopedProviderTest.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal;
-
-import javax.inject.Provider;
-import org.junit.Ignore;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static com.google.common.truth.Truth.assert_;
-import static org.junit.Assert.fail;
-
-/**
- * Tests {@link ScopedProvider}.
- */
-@RunWith(JUnit4.class)
-public class ScopedProviderTest {
-  @Test public void create_nullPointerException() {
-    try {
-      ScopedProvider.create(null);
-      fail();
-    } catch (NullPointerException expected) { }
-  }
-
-  // TODO(gak): reenable this test once we can ensure that factories are no longer providing null
-  @Ignore @Test public void get_nullPointerException() {
-    Provider<Object> scopedProvider = ScopedProvider.create(new Factory<Object>() {
-      @Override public Object get() {
-        return null;
-      }
-    });
-    try {
-      scopedProvider.get();
-      fail();
-    } catch (NullPointerException expected) {
-    }
-  }
-
-  @Test public void get() {
-    Provider<Integer> scopedProvider = ScopedProvider.create(new Factory<Integer>() {
-      int i = 0;
-
-      @Override public Integer get() {
-        return i++;
-      }
-    });
-    assert_().that(scopedProvider.get()).isEqualTo(0);
-    assert_().that(scopedProvider.get()).isEqualTo(0);
-    assert_().that(scopedProvider.get()).isEqualTo(0);
-  }
-}
diff --git a/core/src/test/java/dagger/internal/SimpleLazilyInitializedProviderTest.java b/core/src/test/java/dagger/internal/SimpleLazilyInitializedProviderTest.java
new file mode 100644
index 000000000..c1fd61c19
--- /dev/null
+++ b/core/src/test/java/dagger/internal/SimpleLazilyInitializedProviderTest.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import javax.inject.Provider;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+/**
+ * Tests {@link SimpleLazilyInitializedProvider}.
+ */
+@RunWith(JUnit4.class)
+public class SimpleLazilyInitializedProviderTest {
+  @Test(expected = NullPointerException.class)
+  public void create_nullPointerException() {
+    SimpleLazilyInitializedProvider.create(null);
+  }
+
+  @Test
+  public void get() {
+    Provider<Integer> provider =
+        SimpleLazilyInitializedProvider.create(
+            new Factory<Integer>() {
+              int i = 0;
+
+              @Override
+              public Integer get() {
+                return i++;
+              }
+            });
+    assertThat(provider.get()).isEqualTo(0);
+    assertThat(provider.get()).isEqualTo(0);
+    assertThat(provider.get()).isEqualTo(0);
+  }
+}
diff --git a/examples/android-activity-graphs/pom.xml b/examples/android-activity-graphs/pom.xml
index a51796a61..8e9afd4b1 100644
--- a/examples/android-activity-graphs/pom.xml
+++ b/examples/android-activity-graphs/pom.xml
@@ -28,6 +28,11 @@
   <packaging>apk</packaging>
 
   <dependencies>
+    <dependency>
+      <!-- Force the correct version of Guava to be on the classpath. -->
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+    </dependency>
     <dependency>
       <groupId>com.google.dagger</groupId>
       <artifactId>dagger</artifactId>
diff --git a/examples/android-simple/pom.xml b/examples/android-simple/pom.xml
index 19ce9932a..53f8dced3 100644
--- a/examples/android-simple/pom.xml
+++ b/examples/android-simple/pom.xml
@@ -28,6 +28,11 @@
   <packaging>apk</packaging>
 
   <dependencies>
+    <dependency>
+      <!-- Force the correct version of Guava to be on the classpath. -->
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+    </dependency>
     <dependency>
       <groupId>com.google.dagger</groupId>
       <artifactId>dagger</artifactId>
diff --git a/examples/simple/pom.xml b/examples/simple/pom.xml
index e3e260f35..e690d06d5 100644
--- a/examples/simple/pom.xml
+++ b/examples/simple/pom.xml
@@ -27,6 +27,11 @@
   <name>Examples: Simple</name>
 
   <dependencies>
+    <dependency>
+      <!-- Force the correct version of Guava to be on the classpath. -->
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+    </dependency>
     <dependency>
       <groupId>com.google.dagger</groupId>
       <artifactId>dagger</artifactId>
