diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 8628417f0..ac68c0afb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -52,6 +52,7 @@
 import dagger.internal.codegen.writer.StringLiteral;
 import dagger.internal.codegen.writer.TypeName;
 import dagger.internal.codegen.writer.TypeNames;
+import dagger.internal.codegen.writer.TypeWriter;
 import dagger.internal.codegen.writer.VoidName;
 import java.util.EnumSet;
 import java.util.Iterator;
@@ -81,6 +82,7 @@
 import static dagger.internal.codegen.DependencyRequest.Kind.MEMBERS_INJECTOR;
 import static dagger.internal.codegen.ProvisionBinding.Kind.COMPONENT;
 import static dagger.internal.codegen.ProvisionBinding.Kind.COMPONENT_PROVISION;
+import static dagger.internal.codegen.ProvisionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
@@ -226,7 +228,7 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
       String packageName = packageEntry.getKey();
 
       final Optional<String> proxySelector;
-      final ClassWriter classWithFields;
+      final TypeWriter classWithFields;
       final Set<Modifier> fieldModifiers;
 
       if (packageName.equals(componentName.packageName())) {
@@ -240,7 +242,7 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
         // create the proxy
         JavaWriter proxyWriter = JavaWriter.inPackage(packageName);
         packageProxies.add(proxyWriter);
-        ClassWriter proxyClassWriter =
+        TypeWriter proxyClassWriter =
             proxyWriter.addClass(componentName.simpleName() + "__PackageProxy");
         proxyClassWriter.addModifiers(PUBLIC, FINAL);
         // create the field for the proxy in the component
@@ -409,18 +411,20 @@ private Snippet initializeFactoryForBinding(ProvisionBinding binding,
           contributionFields.get(dependencyMethodIndex.get(binding.bindingElement())).name(),
           binding.bindingElement().getSimpleName().toString());
     } else {
+      if (binding.bindingKind().equals(INJECTION) && binding.implicitDependencies().isEmpty()) {
+        return binding.scope().isPresent()
+            ? Snippet.format("%s.create(%s.INSTANCE)",
+                ClassName.fromClass(ScopedProvider.class),
+                factoryNameForProvisionBinding(binding))
+            : Snippet.format("%s.INSTANCE",
+                factoryNameForProvisionBinding(binding));
+      }
       List<Snippet> parameters = Lists.newArrayListWithCapacity(binding.dependencies().size() + 1);
       if (binding.bindingKind().equals(PROVISION)) {
         parameters.add(Snippet.format(contributionFields.get(binding.bindingTypeElement()).name()));
       }
       if (binding.memberInjectionRequest().isPresent()) {
-        Snippet snippet = memberSelectSnippets.get(
-            binding.memberInjectionRequest().get().key());
-        if (snippet != null) {
-          parameters.add(snippet);
-        } else {
-          throw new UnsupportedOperationException("Non-generated MembersInjector");
-        }
+        parameters.add(memberSelectSnippets.get(binding.memberInjectionRequest().get().key()));
       }
       parameters.addAll(getDependencyParameters(binding.dependencies(), memberSelectSnippets));
       return binding.scope().isPresent()
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 4a9cb8868..9954c8c0f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -28,6 +28,7 @@
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.ClassWriter;
 import dagger.internal.codegen.writer.ConstructorWriter;
+import dagger.internal.codegen.writer.EnumWriter;
 import dagger.internal.codegen.writer.FieldWriter;
 import dagger.internal.codegen.writer.JavaWriter;
 import dagger.internal.codegen.writer.MethodWriter;
@@ -36,6 +37,7 @@
 import dagger.internal.codegen.writer.StringLiteral;
 import dagger.internal.codegen.writer.TypeName;
 import dagger.internal.codegen.writer.TypeNames;
+import dagger.internal.codegen.writer.TypeWriter;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map.Entry;
@@ -48,6 +50,7 @@
 import javax.lang.model.type.TypeMirror;
 
 import static dagger.Provides.Type.SET;
+import static dagger.internal.codegen.ProvisionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
@@ -93,43 +96,52 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     TypeName providedTypeName = TypeNames.forTypeMirror(keyType);
     JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
 
-    ClassWriter factoryWriter = writer.addClass(generatedTypeName.simpleName());
-    factoryWriter.annotate(Generated.class).setValue(ComponentProcessor.class.getName());
-    factoryWriter.addModifiers(PUBLIC, FINAL);
-    factoryWriter.addImplementedType(ParameterizedTypeName.create(
-        ClassName.fromClass(Factory.class),
-        providedTypeName));
-
+    final TypeWriter factoryWriter;
+    final Optional<ConstructorWriter> constructorWriter;
     // TODO(gak): stop doing this weird thing with the optional when javawriter lets me put fields
     // in arbitrary places
     Optional<FieldWriter> loggerField = Optional.absent();
-    if (binding.bindingKind().equals(PROVISION)) {
-      loggerField = Optional.of(factoryWriter.addField(Logger.class, "logger"));
-      loggerField.get().addModifiers(PRIVATE, STATIC, FINAL);
-      loggerField.get().setInitializer("%s.getLogger(%s.class.getCanonicalName())",
-          ClassName.fromClass(Logger.class), factoryWriter.name());
+    if (binding.bindingKind().equals(INJECTION) && binding.implicitDependencies().isEmpty()) {
+      EnumWriter enumWriter = writer.addEnum(generatedTypeName.simpleName());
+      enumWriter.addConstant("INSTANCE");
+      constructorWriter = Optional.absent();
+      factoryWriter = enumWriter;
+    } else {
+      ClassWriter classWriter = writer.addClass(generatedTypeName.simpleName());
+      classWriter.addModifiers(FINAL);
+      constructorWriter = Optional.of(classWriter.addConstructor());
+      constructorWriter.get().addModifiers(PUBLIC);
+      factoryWriter = classWriter;
+      if (binding.bindingKind().equals(PROVISION)) {
+        loggerField = Optional.of(factoryWriter.addField(Logger.class, "logger"));
+        loggerField.get().addModifiers(PRIVATE, STATIC, FINAL);
+        loggerField.get().setInitializer("%s.getLogger(%s.class.getCanonicalName())",
+            ClassName.fromClass(Logger.class), factoryWriter.name());
+
+        factoryWriter.addField(binding.bindingTypeElement(), "module").addModifiers(PRIVATE, FINAL);
+        constructorWriter.get().addParameter(binding.bindingTypeElement(), "module");
+        constructorWriter.get().body()
+            .addSnippet("assert module != null;")
+            .addSnippet("this.module = module;");
+      }
     }
 
+    factoryWriter.annotate(Generated.class).setValue(ComponentProcessor.class.getName());
+    factoryWriter.addModifiers(PUBLIC);
+    factoryWriter.addImplementedType(ParameterizedTypeName.create(
+        ClassName.fromClass(Factory.class),
+        providedTypeName));
+
     MethodWriter getMethodWriter = factoryWriter.addMethod(keyType, "get");
     getMethodWriter.annotate(Override.class);
     getMethodWriter.addModifiers(PUBLIC);
 
-    ConstructorWriter constructorWriter = factoryWriter.addConstructor();
-    constructorWriter.addModifiers(PUBLIC);
-    if (binding.bindingKind().equals(PROVISION)) {
-      factoryWriter.addField(binding.bindingTypeElement(), "module").addModifiers(PRIVATE, FINAL);
-      constructorWriter.addParameter(binding.bindingTypeElement(), "module");
-      constructorWriter.body()
-          .addSnippet("assert module != null;")
-          .addSnippet("this.module = module;");
-    }
-
     if (binding.memberInjectionRequest().isPresent()) {
       ParameterizedTypeName membersInjectorType = ParameterizedTypeName.create(
           MembersInjector.class, providedTypeName);
       factoryWriter.addField(membersInjectorType, "membersInjector").addModifiers(PRIVATE, FINAL);
-      constructorWriter.addParameter(membersInjectorType, "membersInjector");
-      constructorWriter.body()
+      constructorWriter.get().addParameter(membersInjectorType, "membersInjector");
+      constructorWriter.get().body()
           .addSnippet("assert membersInjector != null;")
           .addSnippet("this.membersInjector = membersInjector;");
     }
@@ -156,8 +168,8 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
           throw new AssertionError();
       }
       field.addModifiers(PRIVATE, FINAL);
-      constructorWriter.addParameter(field.type(), field.name());
-      constructorWriter.body()
+      constructorWriter.get().addParameter(field.type(), field.name());
+      constructorWriter.get().body()
           .addSnippet("assert %s != null;", field.name())
           .addSnippet("this.%1$s = %1$s;", field.name());
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
index 2fa5ff219..0715ca724 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
@@ -15,13 +15,14 @@
  */
 package dagger.internal.codegen;
 
+import dagger.internal.codegen.writer.TypeWriter;
+
 import com.google.auto.value.AutoAnnotation;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
 import dagger.MapKey;
 import dagger.internal.codegen.writer.ClassName;
-import dagger.internal.codegen.writer.ClassWriter;
 import dagger.internal.codegen.writer.JavaWriter;
 import dagger.internal.codegen.writer.MethodWriter;
 import java.util.ArrayList;
@@ -33,7 +34,6 @@
 import javax.lang.model.element.Name;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
-
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
 
@@ -68,7 +68,7 @@ ClassName nameGeneratedType(Element e) {
   @Override
   ImmutableSet<JavaWriter> write(ClassName generatedTypeName, Element e) {
     JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
-    ClassWriter mapKeyWriter = writer.addClass(generatedTypeName.simpleName());
+    TypeWriter mapKeyWriter = writer.addClass(generatedTypeName.simpleName());
     mapKeyWriter.annotate(Generated.class).setValue(ComponentProcessor.class.getName());
     mapKeyWriter.addModifiers(PUBLIC);
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
index 107062f22..dd51c179c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
@@ -5,60 +5,27 @@
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import java.io.IOException;
 import java.util.Iterator;
 import java.util.List;
-import java.util.Map;
 import java.util.Set;
 import javax.lang.model.element.Modifier;
-import javax.lang.model.element.TypeElement;
 
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PROTECTED;
 import static javax.lang.model.element.Modifier.PUBLIC;
 
 public final class ClassWriter extends TypeWriter {
-  private final Map<String, FieldWriter> fieldWriters;
   private final List<ConstructorWriter> constructorWriters;
   private final List<TypeVariableName> typeVariables;
 
   ClassWriter(ClassName className) {
     super(className);
-    this.fieldWriters = Maps.newLinkedHashMap();
     this.constructorWriters = Lists.newArrayList();
     this.typeVariables = Lists.newArrayList();
   }
 
-  public void addImplementedType(TypeName typeReference) {
-    implementedTypes.add(typeReference);
-  }
-
-  public void addImplementedType(TypeElement typeElement) {
-    implementedTypes.add(ClassName.fromTypeElement(typeElement));
-  }
-
-  public FieldWriter addField(Class<?> type, String name) {
-    return addField(ClassName.fromClass(type), name);
-  }
-
-  public FieldWriter addField(TypeElement type, String name) {
-    return addField(ClassName.fromTypeElement(type), name);
-  }
-
-  public FieldWriter addField(TypeName type, String name) {
-    String candidateName = name;
-    int differentiator = 1;
-    while (fieldWriters.containsKey(candidateName)) {
-      candidateName = name + differentiator;
-      differentiator++;
-    }
-    FieldWriter fieldWriter = new FieldWriter(type, candidateName);
-    fieldWriters.put(candidateName, fieldWriter);
-    return fieldWriter;
-  }
-
   public ConstructorWriter addConstructor() {
     ConstructorWriter constructorWriter = new ConstructorWriter(name.simpleName());
     constructorWriters.add(constructorWriter);
@@ -130,6 +97,7 @@ private boolean isDefaultConstructor(ConstructorWriter constructorWriter) {
 
   @Override
   public Set<ClassName> referencedClasses() {
+    @SuppressWarnings("unchecked")
     Iterable<? extends HasClassReferences> concat =
         Iterables.concat(nestedTypeWriters, fieldWriters.values(), constructorWriters,
             methodWriters, implementedTypes, supertype.asSet(), annotations);
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/EnumWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/EnumWriter.java
new file mode 100644
index 000000000..314380329
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/EnumWriter.java
@@ -0,0 +1,168 @@
+package dagger.internal.codegen.writer;
+
+import com.google.common.base.Function;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import javax.lang.model.element.Modifier;
+
+import static com.google.common.base.Preconditions.checkState;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PROTECTED;
+import static javax.lang.model.element.Modifier.PUBLIC;
+
+public class EnumWriter extends TypeWriter {
+  private final Map<String, ConstantWriter> constantWriters = Maps.newLinkedHashMap();
+  private final List<ConstructorWriter> constructorWriters = Lists.newArrayList();
+
+  EnumWriter(ClassName name) {
+    super(name);
+  }
+
+  public ConstantWriter addConstant(String name) {
+    ConstantWriter constantWriter = new ConstantWriter(name);
+    constantWriters.put(name, constantWriter);
+    return constantWriter;
+  }
+
+  public ConstructorWriter addConstructor() {
+    ConstructorWriter constructorWriter = new ConstructorWriter(name.simpleName());
+    constructorWriters.add(constructorWriter);
+    return constructorWriter;
+  }
+
+  @Override
+  public Appendable write(Appendable appendable, Context context) throws IOException {
+    context = context.createSubcontext(FluentIterable.from(nestedTypeWriters)
+        .transform(new Function<TypeWriter, ClassName>() {
+          @Override public ClassName apply(TypeWriter input) {
+            return input.name;
+          }
+        })
+        .toSet());
+    writeAnnotations(appendable, context);
+    writeModifiers(appendable).append("enum ").append(name.simpleName());
+    Iterator<TypeName> implementedTypesIterator = implementedTypes.iterator();
+    if (implementedTypesIterator.hasNext()) {
+      appendable.append(" implements ");
+      implementedTypesIterator.next().write(appendable, context);
+      while (implementedTypesIterator.hasNext()) {
+        appendable.append(", ");
+        implementedTypesIterator.next().write(appendable, context);
+      }
+    }
+    appendable.append(" {");
+
+    checkState(!constantWriters.isEmpty(), "Cannot write an enum with no constants.");
+    appendable.append('\n');
+    ImmutableList<ConstantWriter> constantWriterList =
+        ImmutableList.copyOf(constantWriters.values());
+    for (ConstantWriter constantWriter :
+        constantWriterList.subList(0, constantWriterList.size() - 1)) {
+      constantWriter.write(appendable, context);
+      appendable.append(",\n");
+    }
+    constantWriterList.get(constantWriterList.size() - 1).write(appendable, context);
+    appendable.append(";\n");
+
+    if (!fieldWriters.isEmpty()) {
+      appendable.append('\n');
+    }
+    for (VariableWriter fieldWriter : fieldWriters.values()) {
+      fieldWriter.write(new IndentingAppendable(appendable), context).append("\n");
+    }
+    for (ConstructorWriter constructorWriter : constructorWriters) {
+      appendable.append('\n');
+      if (!isDefaultConstructor(constructorWriter)) {
+        constructorWriter.write(new IndentingAppendable(appendable), context);
+      }
+    }
+    for (MethodWriter methodWriter : methodWriters) {
+      appendable.append('\n');
+      methodWriter.write(new IndentingAppendable(appendable), context);
+    }
+    for (TypeWriter nestedTypeWriter : nestedTypeWriters) {
+      appendable.append('\n');
+      nestedTypeWriter.write(new IndentingAppendable(appendable), context);
+    }
+    appendable.append("}\n");
+    return appendable;
+  }
+
+  private static final Set<Modifier> VISIBILIY_MODIFIERS =
+      Sets.immutableEnumSet(PUBLIC, PROTECTED, PRIVATE);
+
+  private boolean isDefaultConstructor(ConstructorWriter constructorWriter) {
+    return Sets.intersection(VISIBILIY_MODIFIERS, modifiers)
+        .equals(Sets.intersection(VISIBILIY_MODIFIERS, constructorWriter.modifiers))
+        && constructorWriter.body().isEmpty();
+  }
+
+  @Override
+  public Set<ClassName> referencedClasses() {
+    @SuppressWarnings("unchecked")
+    Iterable<? extends HasClassReferences> concat =
+        Iterables.concat(nestedTypeWriters, constantWriters.values(), fieldWriters.values(),
+            constructorWriters,
+            methodWriters, implementedTypes, supertype.asSet(), annotations);
+    return FluentIterable.from(concat)
+        .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
+          @Override
+          public Set<ClassName> apply(HasClassReferences input) {
+            return input.referencedClasses();
+          }
+        })
+        .toSet();
+  }
+
+  public static final class ConstantWriter implements Writable, HasClassReferences {
+    private final String name;
+    private final List<Snippet> constructorSnippets;
+
+    private ConstantWriter(String name) {
+      this.name = name;
+      this.constructorSnippets = Lists.newArrayList();
+    }
+
+    ConstantWriter addArgument(Snippet snippet) {
+      constructorSnippets.add(snippet);
+      return this;
+    }
+
+    @Override
+    public Appendable write(Appendable appendable, Context context) throws IOException {
+      appendable.append(name);
+      Iterator<Snippet> snippetIterator = constructorSnippets.iterator();
+      if (snippetIterator.hasNext()) {
+        appendable.append('(');
+        snippetIterator.next().write(appendable, context);
+        while (snippetIterator.hasNext()) {
+          appendable.append(", ");
+          snippetIterator.next().write(appendable, context);
+        }
+        appendable.append(')');
+      }
+      return appendable;
+    }
+
+    @Override
+    public Set<ClassName> referencedClasses() {
+      return FluentIterable.from(constructorSnippets)
+          .transformAndConcat(new Function<Snippet, Set<ClassName>>() {
+            @Override
+            public Set<ClassName> apply(Snippet input) {
+              return input.referencedClasses();
+            }
+          })
+          .toSet();
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
index 60ac493d1..4788a892e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
@@ -69,6 +69,13 @@ public ClassWriter addClass(String simpleName) {
     return classWriter;
   }
 
+  public EnumWriter addEnum(String simpleName) {
+    checkNotNull(simpleName);
+    EnumWriter writer = new EnumWriter(ClassName.create(simpleName, simpleName));
+    typeWriters.add(writer);
+    return writer;
+  }
+
   public InterfaceWriter addInterface(String simpleName) {
     InterfaceWriter writer = new InterfaceWriter(ClassName.create(packageName, simpleName));
     typeWriters.add(writer);
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java
index aa7ba02e5..40cd59e6e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java
@@ -2,7 +2,10 @@
 
 import com.google.common.base.Optional;
 import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
 import java.util.List;
+import java.util.Map;
+import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
 
 /**
@@ -15,13 +18,15 @@
   final List<TypeName> implementedTypes;
   final List<MethodWriter> methodWriters;
   final List<TypeWriter> nestedTypeWriters;
+  final Map<String, FieldWriter> fieldWriters;
 
   TypeWriter(ClassName name) {
     this.name = name;
     this.supertype = Optional.absent();
     this.implementedTypes = Lists.newArrayList();
     this.methodWriters = Lists.newArrayList();
-    nestedTypeWriters = Lists.newArrayList();
+    this.nestedTypeWriters = Lists.newArrayList();
+    this.fieldWriters = Maps.newLinkedHashMap();
   }
 
   @Override
@@ -60,4 +65,32 @@ public ClassWriter addNestedClass(String name) {
     nestedTypeWriters.add(innerClassWriter);
     return innerClassWriter;
   }
+
+  public void addImplementedType(TypeName typeReference) {
+    implementedTypes.add(typeReference);
+  }
+
+  public void addImplementedType(TypeElement typeElement) {
+    implementedTypes.add(ClassName.fromTypeElement(typeElement));
+  }
+
+  public FieldWriter addField(Class<?> type, String name) {
+    return addField(ClassName.fromClass(type), name);
+  }
+
+  public FieldWriter addField(TypeElement type, String name) {
+    return addField(ClassName.fromTypeElement(type), name);
+  }
+
+  public FieldWriter addField(TypeName type, String name) {
+    String candidateName = name;
+    int differentiator = 1;
+    while (fieldWriters.containsKey(candidateName)) {
+      candidateName = name + differentiator;
+      differentiator++;
+    }
+    FieldWriter fieldWriter = new FieldWriter(type, candidateName);
+    fieldWriters.put(candidateName, fieldWriter);
+    return fieldWriter;
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index 91a4fe954..d6cee23d3 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -136,7 +136,7 @@
         "  }",
         "",
         "  private void initialize() {",
-        "    this.someInjectableTypeProvider = new SomeInjectableType$$Factory();",
+        "    this.someInjectableTypeProvider = SomeInjectableType$$Factory.INSTANCE;",
         "  }",
         "",
         "  @Override",
@@ -224,7 +224,7 @@
         "",
         "  private void initialize() {",
         "    this.someInjectableTypeProvider =",
-        "        ScopedProvider.create(new SomeInjectableType$$Factory());",
+        "        ScopedProvider.create(SomeInjectableType$$Factory.INSTANCE);",
         "  }",
         "",
         "  @Override",
@@ -284,7 +284,8 @@
         "import javax.annotation.Generated;",
         "import test.OuterType.A;",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class OuterType$A$$Factory implements Factory<A> {",
+        "public enum OuterType$A$$Factory implements Factory<A> {",
+        "  INSTANCE;",
         "",
         "  @Override public A get() {",
         "    return new A();",
@@ -348,7 +349,7 @@
         "  }",
         "",
         "  private void initialize() {",
-        "    this.aProvider = new OuterType$A$$Factory();",
+        "    this.aProvider = OuterType$A$$Factory.INSTANCE;",
         "    this.bMembersInjector = new OuterType$B$$MembersInjector(aProvider);",
         "  }",
         "",
@@ -450,7 +451,7 @@
         "  }",
         "",
         "  private void initialize() {",
-        "    this.cProvider = new C$$Factory();",
+        "    this.cProvider = C$$Factory.INSTANCE;",
         "    this.bProvider = new TestModule$$BFactory(testModule, cProvider);",
         "    this.aProvider = new A$$Factory(bProvider);",
         "  }",
@@ -762,7 +763,7 @@
         "  }",
         "",
         "  private void initialize() {",
-        "    this.someInjectableTypeProvider = new SomeInjectableType$$Factory();",
+        "    this.someInjectableTypeProvider = SomeInjectableType$$Factory.INSTANCE;",
         "    this.someInjectedTypeMembersInjector =",
         "        new SomeInjectedType$$MembersInjector(someInjectableTypeProvider);",
         "  }",
@@ -922,7 +923,7 @@
         "  }",
         "",
         "  private void initialize() {",
-        "    this.someInjectableTypeProvider = new SomeInjectableType$$Factory();",
+        "    this.someInjectableTypeProvider = SomeInjectableType$$Factory.INSTANCE;",
         "    this.someInjectedTypeMembersInjector =",
         "        new SomeInjectedType$$MembersInjector(someInjectableTypeProvider);",
         "    this.someInjectedTypeProvider =",
@@ -1264,7 +1265,7 @@
         "  }",
         "",
         "  private void initialize() {",
-        "    this.cProvider = new C$$Factory();",
+        "    this.cProvider = C$$Factory.INSTANCE;",
         "    this.bProvider = new B$$Factory(cProvider);",
         "    this.aProvider = new A$$Factory(bProvider);",
         "    this.xProvider = new X$$Factory(cProvider);",
@@ -1370,7 +1371,7 @@
         "  }",
         "",
         "  private void initialize() {",
-        "    this.someInjectableTypeProvider = new SomeInjectableType$$Factory();",
+        "    this.someInjectableTypeProvider = SomeInjectableType$$Factory.INSTANCE;",
         "  }",
         "",
         "  @Override",
@@ -1463,7 +1464,7 @@
         "  }",
         "",
         "  private void initialize() {",
-        "    this.someInjectableTypeProvider = new SomeInjectableType$$Factory();",
+        "    this.someInjectableTypeProvider = SomeInjectableType$$Factory.INSTANCE;",
         "  }",
         "",
         "  @Override",
diff --git a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
index 29675bb16..8d6d1eb20 100644
--- a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
@@ -821,4 +821,35 @@ public void samePackageNameCollision() {
         .compilesWithoutError()
         .and().generatesSources(expected);
   }
+
+  @Test
+  public void noDeps() {
+    JavaFileObject simpleType = JavaFileObjects.forSourceLines("test.SimpleType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class SimpleType {",
+        "  @Inject SimpleType() {}",
+        "}");
+    JavaFileObject factory = JavaFileObjects.forSourceLines("test.SimpleType$$Factory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public enum SimpleType$$Factory implements Factory<SimpleType> {",
+        "  INSTANCE;",
+        "",
+        "  @Override public SimpleType get() {",
+        "    return new SimpleType();",
+        "  }",
+        "}");
+    assert_().about(javaSource())
+        .that(simpleType)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factory);
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
index e6c119e5b..d6a2c0ede 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
@@ -158,7 +158,7 @@ public void parentClass_injectedMembersInSupertype() {
         "  }",
         "",
         "  private void initialize() {",
-        "    this.depProvider = new Dep$$Factory();",
+        "    this.depProvider = Dep$$Factory.INSTANCE;",
         "    this.parentMembersInjector = new Parent$$MembersInjector(depProvider);",
         "    this.childMembersInjector = MembersInjectors.delegatingTo(parentMembersInjector);",
         "    this.childProvider = new Child$$Factory(childMembersInjector);",
diff --git a/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java b/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java
index c404cce56..4e370a0f4 100644
--- a/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java
@@ -73,7 +73,7 @@
         "  }",
         "",
         "  private void initialize() {",
-        "    this.foreign_Proxy.nonPublicClassProvider = new NonPublicClass$$Factory();",
+        "    this.foreign_Proxy.nonPublicClassProvider = NonPublicClass$$Factory.INSTANCE;",
         "    this.publicClassProvider =",
         "        new PublicClass$$Factory(foreign_Proxy.nonPublicClassProvider);",
         "  }",
