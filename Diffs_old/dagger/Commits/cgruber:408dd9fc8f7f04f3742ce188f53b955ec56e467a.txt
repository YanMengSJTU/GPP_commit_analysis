diff --git a/java/dagger/internal/codegen/BindingGraphValidator.java b/java/dagger/internal/codegen/BindingGraphValidator.java
index 8d18df36d..3aa26610c 100644
--- a/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -36,7 +36,6 @@
 import static dagger.internal.codegen.DaggerElements.isAnnotationPresent;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.DiagnosticFormatting.stripCommonTypePrefixes;
-import static dagger.internal.codegen.ErrorMessages.CANNOT_INJECT_WILDCARD_TYPE;
 import static dagger.internal.codegen.ErrorMessages.CONTAINS_DEPENDENCY_CYCLE_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.DEPENDS_ON_PRODUCTION_EXECUTOR_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT;
@@ -45,10 +44,6 @@
 import static dagger.internal.codegen.ErrorMessages.MEMBERS_INJECTION_WITH_RAW_TYPE;
 import static dagger.internal.codegen.ErrorMessages.MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE;
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_CONTRIBUTION_TYPES_FOR_KEY_FORMAT;
-import static dagger.internal.codegen.ErrorMessages.REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT;
-import static dagger.internal.codegen.ErrorMessages.REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_OR_PRODUCER_FORMAT;
-import static dagger.internal.codegen.ErrorMessages.REQUIRES_PROVIDER_FORMAT;
-import static dagger.internal.codegen.ErrorMessages.REQUIRES_PROVIDER_OR_PRODUCER_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.abstractModuleHasInstanceBindingMethods;
 import static dagger.internal.codegen.ErrorMessages.duplicateMapKeysError;
 import static dagger.internal.codegen.ErrorMessages.inconsistentMapKeyAnnotationsError;
@@ -851,25 +846,27 @@ public Boolean visitDeclared(DeclaredType t, Void p) {
        */
       private StringBuilder requiresErrorMessageBase() {
         Key key = dependencyRequest().key();
-        String requiresErrorMessageFormat;
+        StringBuilder errorMessage = new StringBuilder();
         // TODO(dpb): Check for wildcard injection somewhere else first?
         if (key.type().getKind().equals(TypeKind.WILDCARD)) {
-          requiresErrorMessageFormat = CANNOT_INJECT_WILDCARD_TYPE;
+          errorMessage
+              .append("Dagger does not support injecting Provider<T>, Lazy<T> or Produced<T> when ")
+              .append("T is a wildcard type such as ")
+              .append(formatCurrentDependencyRequestKey());
         } else {
-          boolean canUseProduction = dependencyRequestCanUseProduction();
-          if (!isValidImplicitProvisionKey(key, types)) {
-            requiresErrorMessageFormat =
-                canUseProduction ? REQUIRES_PROVIDER_OR_PRODUCER_FORMAT : REQUIRES_PROVIDER_FORMAT;
-          } else {
-            requiresErrorMessageFormat =
-                canUseProduction
-                    ? REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_OR_PRODUCER_FORMAT
-                    : REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT;
+          // TODO(ronshapiro): replace "provided" with "satisfied"?
+          errorMessage
+              .append(formatCurrentDependencyRequestKey())
+              .append(" cannot be provided without ");
+          if (isValidImplicitProvisionKey(key, types)) {
+            errorMessage.append("an @Inject constructor or ");
           }
+          errorMessage.append("an @Provides-");
+          if (dependencyRequestCanUseProduction()) {
+            errorMessage.append(" or @Produces-");
+          }
+          errorMessage.append("annotated method.");
         }
-        StringBuilder errorMessage =
-            new StringBuilder(
-                String.format(requiresErrorMessageFormat, formatCurrentDependencyRequestKey()));
         if (isValidMembersInjectionKey(key)
             && injectBindingRegistry.getOrFindMembersInjectionBinding(key)
                 .map(binding -> !binding.injectionSites().isEmpty())
diff --git a/java/dagger/internal/codegen/ErrorMessages.java b/java/dagger/internal/codegen/ErrorMessages.java
index 54604e34b..0176721bf 100644
--- a/java/dagger/internal/codegen/ErrorMessages.java
+++ b/java/dagger/internal/codegen/ErrorMessages.java
@@ -112,10 +112,6 @@
   static final String INJECT_INTO_PRIVATE_CLASS =
       "Dagger does not support injection into private classes";
 
-  static final String CANNOT_INJECT_WILDCARD_TYPE =
-      "Dagger does not support injecting Provider<T>, Lazy<T> or Produced<T> when T is a wildcard "
-          + "type such as <%s>.";
-
   /*
    * Configuration errors
    *
@@ -256,19 +252,6 @@ static String inconsistentMapKeyAnnotationsError(String key) {
   static final String DEPENDS_ON_PRODUCTION_EXECUTOR_FORMAT =
       "%s may not depend on the production executor.";
 
-  static final String REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT =
-      "%s cannot be provided without an @Inject constructor or from an @Provides-annotated method.";
-
-  static final String REQUIRES_PROVIDER_FORMAT =
-      "%s cannot be provided without an @Provides-annotated method.";
-
-  static final String REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_OR_PRODUCER_FORMAT =
-      "%s cannot be provided without an @Inject constructor or from an @Provides- or "
-      + "@Produces-annotated method.";
-
-  static final String REQUIRES_PROVIDER_OR_PRODUCER_FORMAT =
-      "%s cannot be provided without an @Provides- or @Produces-annotated method.";
-
   private static final String PROVISION_MAY_NOT_DEPEND_ON_PRODUCER_TYPE_FORMAT =
       "%s may only be injected in @Produces methods.";
 
diff --git a/javatests/dagger/internal/codegen/GraphValidationTest.java b/javatests/dagger/internal/codegen/GraphValidationTest.java
index 77e6f47d4..3e55833a5 100644
--- a/javatests/dagger/internal/codegen/GraphValidationTest.java
+++ b/javatests/dagger/internal/codegen/GraphValidationTest.java
@@ -128,8 +128,9 @@
         "    A getA();",
         "  }",
         "}");
-    String expectedError = "test.TestClass.A cannot be provided without an "
-        + "@Inject constructor or from an @Provides-annotated method.";
+    String expectedError =
+        "test.TestClass.A cannot be provided without an @Inject constructor or an "
+            + "@Provides-annotated method.";
     assertAbout(javaSource()).that(component)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
@@ -159,9 +160,10 @@
         "    B getB();",
         "  }",
         "}");
-    String expectedError = "test.TestClass.B cannot be provided without an "
-        + "@Inject constructor or from an @Provides-annotated method. "
-        + "This type supports members injection but cannot be implicitly provided.";
+    String expectedError =
+        "test.TestClass.B cannot be provided without an @Inject constructor or an "
+            + "@Provides-annotated method. This type supports members injection but cannot be "
+            + "implicitly provided.";
     assertAbout(javaSource()).that(component)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
@@ -1365,8 +1367,8 @@ public void bindsMethodAppearsInTrace() {
         .withErrorContaining(
             Joiner.on("\n      ")
                 .join(
-                    "java.lang.String cannot be provided without an @Inject constructor or from "
-                        + "an @Provides-annotated method.",
+                    "java.lang.String cannot be provided without an @Inject constructor or an "
+                        + "@Provides-annotated method.",
                     "java.lang.String is injected at",
                     "    TestImplementation.<init>(missingBinding)",
                     "TestImplementation is injected at",
diff --git a/javatests/dagger/internal/codegen/ProductionGraphValidationTest.java b/javatests/dagger/internal/codegen/ProductionGraphValidationTest.java
index 040000fbf..f3fe3bf45 100644
--- a/javatests/dagger/internal/codegen/ProductionGraphValidationTest.java
+++ b/javatests/dagger/internal/codegen/ProductionGraphValidationTest.java
@@ -78,12 +78,15 @@
         "    return null;",
         "  }",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(EXECUTOR_MODULE, module, component))
+    assertAbout(javaSources())
+        .that(ImmutableList.of(EXECUTOR_MODULE, module, component))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining("test.Bar cannot be provided without an @Inject constructor or from "
-            + "an @Provides- or @Produces-annotated method.")
-            .in(component).onLine(8);
+        .withErrorContaining(
+            "test.Bar cannot be provided without an @Inject constructor or an @Provides- or "
+                + "@Produces-annotated method.")
+        .in(component)
+        .onLine(8);
   }
 
   @Test public void componentProductionWithNoDependencyChain() {
diff --git a/javatests/dagger/internal/codegen/SubcomponentValidationTest.java b/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
index d3f91067c..b5207f46c 100644
--- a/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
+++ b/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
@@ -239,7 +239,7 @@ public SubcomponentValidationTest(CompilerMode compilerMode) {
         .failsToCompile()
         .withErrorContaining(
             "[test.ChildComponent.getString()] "
-                + "java.lang.Integer cannot be provided without an @Inject constructor or from an "
+                + "java.lang.Integer cannot be provided without an @Inject constructor or an "
                 + "@Provides-annotated method")
         .in(componentFile)
         .onLine(6);
