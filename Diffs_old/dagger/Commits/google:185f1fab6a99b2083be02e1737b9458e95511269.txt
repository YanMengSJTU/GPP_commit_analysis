diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 5404b8200..93a152997 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -1304,7 +1304,7 @@ private CodeBlock initializeFactoryForSyntheticOptionalBinding(ContributionBindi
           binding.bindingType().equals(BindingType.PROVISION),
           "Absent optional bindings should be provisions: %s",
           binding);
-      return optionalFactories.absentOptionalProvider();
+      return optionalFactories.absentOptionalProvider(binding);
     } else {
       return optionalFactories.presentOptionalFactory(
           binding, getOnlyElement(getDependencyArguments(binding)));
diff --git a/compiler/src/main/java/dagger/internal/codegen/OptionalFactories.java b/compiler/src/main/java/dagger/internal/codegen/OptionalFactories.java
index fea103f09..d0a268e12 100644
--- a/compiler/src/main/java/dagger/internal/codegen/OptionalFactories.java
+++ b/compiler/src/main/java/dagger/internal/codegen/OptionalFactories.java
@@ -26,17 +26,14 @@
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
 import static dagger.internal.codegen.TypeNames.PROVIDER;
 import static dagger.internal.codegen.TypeNames.listenableFutureOf;
-import static dagger.internal.codegen.TypeNames.optionalOf;
 import static dagger.internal.codegen.TypeNames.providerOf;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
 
+import com.google.auto.value.AutoValue;
 import com.google.common.base.Function;
-import com.google.common.base.Optional;
-import com.google.common.collect.HashBasedTable;
-import com.google.common.collect.Table;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.squareup.javapoet.ClassName;
@@ -50,76 +47,153 @@
 import com.squareup.javapoet.TypeVariableName;
 import dagger.internal.InstanceFactory;
 import dagger.internal.Preconditions;
+import dagger.internal.codegen.OptionalType.OptionalKind;
 import dagger.producers.Producer;
 import dagger.producers.internal.Producers;
+import java.util.Comparator;
+import java.util.Map;
+import java.util.TreeMap;
 import javax.inject.Provider;
-import javax.lang.model.type.TypeMirror;
 
 /** The nested class and static methods required by the component to implement optional bindings. */
-// TODO(dpb): Name classes correctly if a component uses both Guava and JDK Optional.
+// TODO(dpb): Name members simply if a component uses only one of Guava or JDK Optional.
 final class OptionalFactories {
 
-  /**
-   * A field specification for a {@link Provider<Optional<T>>} that always returns {@code
-   * Optional.absent()}.
-   */
-  private static final FieldSpec ABSENT_OPTIONAL_PROVIDER_FIELD =
-      FieldSpec.builder(PROVIDER, "ABSENT_OPTIONAL_PROVIDER", PRIVATE, STATIC, FINAL)
-          .addAnnotation(SUPPRESS_WARNINGS_RAWTYPES)
-          .initializer("$T.create($T.absent())", InstanceFactory.class, Optional.class)
-          .addJavadoc(
-              "A {@link $T} that returns {@code $T.absent()}.", Provider.class, Optional.class)
-          .build();
-
-  /**
-   * A method specification for a {@link Provider<Optional<T>>} that always returns {@code
-   * Optional.absent()}.
-   */
-  private static final MethodSpec ABSENT_OPTIONAL_PROVIDER_METHOD =
-      methodBuilder("absentOptionalProvider")
-          .addModifiers(PRIVATE, STATIC)
-          .addTypeVariable(TypeVariableName.get("T"))
-          .returns(providerOf(optionalOf(TypeVariableName.get("T"))))
-          .addJavadoc(
-              "Returns a {@link $T} that returns {@code $T.absent()}.",
-              Provider.class,
-              Optional.class)
-          .addCode("$L // safe covariant cast\n", SUPPRESS_WARNINGS_UNCHECKED)
-          .addCode(
-              "$1T provider = ($1T) $2N;",
-              providerOf(optionalOf(TypeVariableName.get("T"))),
-              ABSENT_OPTIONAL_PROVIDER_FIELD)
-          .addCode("return provider;")
-          .build();
-
   /**
    * The factory classes that implement {@code Provider<Optional<T>>} or {@code
    * Producer<Optional<T>>} for present optional bindings for a given kind of dependency request
    * within the component.
    *
-   * <p>The row key specifies whether the class implements {@link Provider} or {@link Producer}, and
-   * the column key specifies the kind of dependency request represented by {@code T}.
+   * <p>The key is the {@code Provider<Optional<T>>} type.
    */
-  private final Table<BindingType, DependencyRequest.Kind, TypeSpec> presentFactoryClasses =
-      HashBasedTable.create();
+  private final Map<PresentFactorySpec, TypeSpec> presentFactoryClasses =
+      new TreeMap<>(
+          Comparator.comparing(PresentFactorySpec::valueKind)
+              .thenComparing(PresentFactorySpec::bindingType)
+              .thenComparing(PresentFactorySpec::optionalKind));
 
   /**
-   * If the component contains any absent optional bindings, this will be the member select for a
-   * static method that returns a Provider<Optional<T>> that always returns {@link
-   * Optional#absent()}.
+   * The static methods that return a {@code Provider<Optional<T>>} that always returns an absent
+   * value.
    */
-  private Optional<CodeBlock> absentOptionalProviderMethod = Optional.absent();
+  private final Map<OptionalKind, MethodSpec> absentOptionalProviderMethods = new TreeMap<>();
+
+  /**
+   * The static fields for {@code Provider<Optional<T>>} objects that always return an absent value.
+   */
+  private final Map<OptionalKind, FieldSpec> absentOptionalProviderFields = new TreeMap<>();
 
   /**
    * Returns an expression that calls a static method that returns a {@code Provider<Optional<T>>}
    * for absent optional bindings.
    */
-  CodeBlock absentOptionalProvider() {
-    if (!absentOptionalProviderMethod.isPresent()) {
-      absentOptionalProviderMethod =
-          Optional.of(CodeBlock.of("$N()", ABSENT_OPTIONAL_PROVIDER_METHOD));
+  CodeBlock absentOptionalProvider(ContributionBinding binding) {
+    OptionalKind optionalKind = OptionalType.from(binding.key()).kind();
+    return CodeBlock.of(
+        "$N()",
+        absentOptionalProviderMethods.computeIfAbsent(
+            optionalKind, this::absentOptionalProviderMethod));
+  }
+
+  /**
+   * Creates a method specification for a {@link Provider<Optional<T>>} that always returns an
+   * absent value.
+   */
+  private MethodSpec absentOptionalProviderMethod(OptionalKind optionalKind) {
+    TypeVariableName typeVariable = TypeVariableName.get("T");
+    return methodBuilder(
+            String.format(
+                "absent%sProvider", UPPER_UNDERSCORE.to(UPPER_CAMEL, optionalKind.name())))
+        .addModifiers(PRIVATE, STATIC)
+        .addTypeVariable(typeVariable)
+        .returns(providerOf(optionalKind.of(typeVariable)))
+        .addJavadoc(
+            "Returns a {@link $T} that returns {@code $L}.",
+            Provider.class,
+            optionalKind.absentValueExpression())
+        .addCode("$L // safe covariant cast\n", SUPPRESS_WARNINGS_UNCHECKED)
+        .addCode(
+            "$1T provider = ($1T) $2N;",
+            providerOf(optionalKind.of(typeVariable)),
+            absentOptionalProviderFields.computeIfAbsent(
+                optionalKind, this::absentOptionalProviderField))
+        .addCode("return provider;")
+        .build();
+  }
+
+  /**
+   * Creates a field specification for a {@link Provider<Optional<T>>} that always returns an absent
+   * value.
+   */
+  private FieldSpec absentOptionalProviderField(OptionalKind optionalKind) {
+    return FieldSpec.builder(
+            PROVIDER,
+            String.format("ABSENT_%s_PROVIDER", optionalKind.name()),
+            PRIVATE,
+            STATIC,
+            FINAL)
+        .addAnnotation(SUPPRESS_WARNINGS_RAWTYPES)
+        .initializer("$T.create($L)", InstanceFactory.class, optionalKind.absentValueExpression())
+        .addJavadoc(
+            "A {@link $T} that returns {@code $L}.",
+            Provider.class,
+            optionalKind.absentValueExpression())
+        .build();
+  }
+
+  /** Information about the type of a factory for present bindings. */
+  @AutoValue
+  abstract static class PresentFactorySpec {
+    /** Whether the factory is a {@link Provider} or a {@link Producer}. */
+    abstract BindingType bindingType();
+
+    /** What kind of {@code Optional} is returned. */
+    abstract OptionalKind optionalKind();
+
+    /** The kind of request satisfied by the value of the {@code Optional}. */
+    abstract DependencyRequest.Kind valueKind();
+
+    /** The type variable for the factory class. */
+    TypeVariableName typeVariable() {
+      return TypeVariableName.get("T");
+    }
+
+    /** The type contained by the {@code Optional}. */
+    TypeName valueType() {
+      return valueKind().typeName(typeVariable());
+    }
+
+    /** The type provided or produced by the factory. */
+    ParameterizedTypeName optionalType() {
+      return optionalKind().of(valueType());
+    }
+
+    /** The type of the factory. */
+    ParameterizedTypeName factoryType() {
+      return bindingType().frameworkClassOf(optionalType());
+    }
+
+    /** The type of the delegate provider or producer. */
+    ParameterizedTypeName delegateType() {
+      return bindingType().frameworkClassOf(typeVariable());
+    }
+
+    /** The name of the factory class. */
+    String factoryClassName() {
+      return new StringBuilder("Present")
+          .append(UPPER_UNDERSCORE.to(UPPER_CAMEL, optionalKind().name()))
+          .append(UPPER_UNDERSCORE.to(UPPER_CAMEL, valueKind().toString()))
+          .append(bindingType().frameworkClass().getSimpleName())
+          .toString();
+    }
+
+    private static PresentFactorySpec of(ContributionBinding binding) {
+      OptionalKind optionalKind = OptionalType.from(binding.key()).kind();
+      DependencyRequest.Kind valueKind =
+          DependencyRequest.extractKindAndType(OptionalType.from(binding.key()).valueType()).kind();
+      return new AutoValue_OptionalFactories_PresentFactorySpec(
+          binding.bindingType(), optionalKind, valueKind);
     }
-    return absentOptionalProviderMethod.get();
   }
   
   /**
@@ -146,104 +220,82 @@ CodeBlock absentOptionalProvider() {
    *     underlying type
    */
   CodeBlock presentOptionalFactory(ContributionBinding binding, CodeBlock delegateFactory) {
-    TypeMirror valueType = OptionalType.from(binding.key()).valueType();
-    DependencyRequest.Kind valueKind = DependencyRequest.extractKindAndType(valueType).kind();
-    if (!presentFactoryClasses.contains(binding.bindingType(), valueKind)) {
-      presentFactoryClasses.put(
-          binding.bindingType(),
-          valueKind,
-          createPresentFactoryClass(binding.bindingType(), valueKind));
-    }
     return CodeBlock.of(
-        "$N.of($L)", presentFactoryClasses.get(binding.bindingType(), valueKind), delegateFactory);
-  }
-  /**
-   * Adds classes and methods required by previous calls to {@link #absentOptionalProvider()} and
-   * {@link #presentOptionalProvider(DependencyRequest.Kind, CodeBlock)} to the top-level {@code
-   * component}.
-   */
-  void addMembers(TypeSpec.Builder component) {
-    if (absentOptionalProviderMethod.isPresent()) {
-      component.addField(ABSENT_OPTIONAL_PROVIDER_FIELD).addMethod(ABSENT_OPTIONAL_PROVIDER_METHOD);
-    }
-    for (TypeSpec presentFactoryClass : presentFactoryClasses.values()) {
-      component.addType(presentFactoryClass);
-    }
+        "$N.of($L)",
+        presentFactoryClasses.computeIfAbsent(
+            PresentFactorySpec.of(binding), this::presentOptionalFactoryClass),
+        delegateFactory);
   }
 
-  private TypeSpec createPresentFactoryClass(
-      BindingType bindingType, DependencyRequest.Kind valueKind) {
-    TypeVariableName typeVariable = TypeVariableName.get("T");
-    TypeName valueType = valueKind.typeName(typeVariable);
-    ParameterizedTypeName factoryType = bindingType.frameworkClassOf(optionalOf(valueType));
-
+  private TypeSpec presentOptionalFactoryClass(PresentFactorySpec spec) {
     FieldSpec delegateField =
-        FieldSpec.builder(bindingType.frameworkClassOf(typeVariable), "delegate", PRIVATE, FINAL)
-            .build();
+        FieldSpec.builder(spec.delegateType(), "delegate", PRIVATE, FINAL).build();
     ParameterSpec delegateParameter = ParameterSpec.builder(delegateField.type, "delegate").build();
 
     MethodSpec.Builder getMethodBuilder =
         methodBuilder("get").addAnnotation(Override.class).addModifiers(PUBLIC);
-    switch (bindingType) {
+    switch (spec.bindingType()) {
       case PROVISION:
         getMethodBuilder
-            .returns(optionalOf(valueType))
+            .returns(spec.optionalType())
             .addCode(
-                "return $T.of($L);",
-                Optional.class,
-                FrameworkType.PROVIDER.to(valueKind, CodeBlock.of("$N", delegateField)));
+                "return $L;",
+                spec.optionalKind()
+                    .presentExpression(
+                        FrameworkType.PROVIDER.to(
+                            spec.valueKind(), CodeBlock.of("$N", delegateField))));
         break;
 
       case PRODUCTION:
-        getMethodBuilder.returns(listenableFutureOf(optionalOf(valueType)));
+        getMethodBuilder.returns(listenableFutureOf(spec.optionalType()));
 
-        switch (valueKind) {
+        switch (spec.valueKind()) {
           case FUTURE: // return a ListenableFuture<Optional<ListenableFuture<T>>>
           case PRODUCER: // return a ListenableFuture<Optional<Producer<T>>>
             getMethodBuilder.addCode(
-                "return $T.immediateFuture($T.of($L));",
+                "return $T.immediateFuture($L);",
                 Futures.class,
-                Optional.class,
-                FrameworkType.PRODUCER.to(valueKind, CodeBlock.of("$N", delegateField)));
+                spec.optionalKind()
+                    .presentExpression(
+                        FrameworkType.PRODUCER.to(
+                            spec.valueKind(), CodeBlock.of("$N", delegateField))));
             break;
 
           case INSTANCE: // return a ListenableFuture<Optional<T>>
             getMethodBuilder.addCode(
                 "return $L;",
-                transformFutureToOptional(typeVariable, CodeBlock.of("$N.get()", delegateField)));
+                transformFutureToOptional(
+                    spec.optionalKind(),
+                    spec.typeVariable(),
+                    CodeBlock.of("$N.get()", delegateField)));
             break;
 
           case PRODUCED: // return a ListenableFuture<Optional<Produced<T>>>
             getMethodBuilder.addCode(
                 "return $L;",
                 transformFutureToOptional(
-                    valueType,
+                    spec.optionalKind(),
+                    spec.valueType(),
                     CodeBlock.of(
                         "$T.createFutureProduced($N.get())", Producers.class, delegateField)));
             break;
 
           default:
-            throw new UnsupportedOperationException(factoryType + " objects are not supported");
+            throw new UnsupportedOperationException(
+                spec.factoryType() + " objects are not supported");
         }
         break;
 
       default:
-        throw new AssertionError(bindingType);
+        throw new AssertionError(spec.bindingType());
     }
-    MethodSpec getMethod = getMethodBuilder.build();
-
-    String factoryClassName =
-        String.format(
-            "PresentOptional%s%s",
-            UPPER_UNDERSCORE.to(UPPER_CAMEL, valueKind.toString()),
-            bindingType.frameworkClass().getSimpleName());
 
-    return classBuilder(factoryClassName)
-        .addTypeVariable(typeVariable)
+    return classBuilder(spec.factoryClassName())
+        .addTypeVariable(spec.typeVariable())
         .addModifiers(PRIVATE, STATIC, FINAL)
-        .addSuperinterface(factoryType)
+        .addSuperinterface(spec.factoryType())
         .addJavadoc(
-            "A {@link $T} that uses a delegate {@code $T}.", factoryType, delegateField.type)
+            "A {@link $T} that uses a delegate {@code $T}.", spec.factoryType(), delegateField.type)
         .addField(delegateField)
         .addMethod(
             constructorBuilder()
@@ -255,15 +307,18 @@ private TypeSpec createPresentFactoryClass(
                     Preconditions.class,
                     delegateParameter)
                 .build())
-        .addMethod(getMethod)
+        .addMethod(getMethodBuilder.build())
         .addMethod(
             methodBuilder("of")
                 .addModifiers(PRIVATE, STATIC)
-                .addTypeVariable(typeVariable)
-                .returns(factoryType)
+                .addTypeVariable(spec.typeVariable())
+                .returns(spec.factoryType())
                 .addParameter(delegateParameter)
                 .addCode(
-                    "return new $L<$T>($N);", factoryClassName, typeVariable, delegateParameter)
+                    "return new $L<$T>($N);",
+                    spec.factoryClassName(),
+                    spec.typeVariable(),
+                    delegateParameter)
                 .build())
         .build();
   }
@@ -274,7 +329,8 @@ private TypeSpec createPresentFactoryClass(
    *
    * @param inputFuture an expression of type {@code ListenableFuture<inputType>}
    */
-  private static CodeBlock transformFutureToOptional(TypeName inputType, CodeBlock inputFuture) {
+  private static CodeBlock transformFutureToOptional(
+      OptionalKind optionalKind, TypeName inputType, CodeBlock inputFuture) {
     return CodeBlock.of(
         "$T.transform($L, $L)",
         Futures.class,
@@ -282,15 +338,26 @@ private static CodeBlock transformFutureToOptional(TypeName inputType, CodeBlock
         anonymousClassBuilder("")
             .addSuperinterface(
                 ParameterizedTypeName.get(
-                    ClassName.get(Function.class), inputType, optionalOf(inputType)))
+                    ClassName.get(Function.class), inputType, optionalKind.of(inputType)))
             .addMethod(
                 methodBuilder("apply")
                     .addAnnotation(Override.class)
                     .addModifiers(PUBLIC)
-                    .returns(optionalOf(inputType))
+                    .returns(optionalKind.of(inputType))
                     .addParameter(inputType, "input")
-                    .addCode("return $T.of(input);", Optional.class)
+                    .addCode("return $L;", optionalKind.presentExpression(CodeBlock.of("input")))
                     .build())
             .build());
   }
+
+  /**
+   * Adds classes and methods required by previous calls to {@link
+   * #absentOptionalProvider(ContributionBinding)} and {@link
+   * #presentOptionalFactory(ContributionBinding, CodeBlock)} to the top-level {@code component}.
+   */
+  void addMembers(TypeSpec.Builder component) {
+    component.addTypes(presentFactoryClasses.values());
+    component.addMethods(absentOptionalProviderMethods.values());
+    component.addFields(absentOptionalProviderFields.values());
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/OptionalType.java b/compiler/src/main/java/dagger/internal/codegen/OptionalType.java
index d7e23b17c..2a76b05ee 100644
--- a/compiler/src/main/java/dagger/internal/codegen/OptionalType.java
+++ b/compiler/src/main/java/dagger/internal/codegen/OptionalType.java
@@ -22,26 +22,69 @@
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
+import com.google.common.base.Optional;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
+import javax.lang.model.element.Name;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.SimpleTypeVisitor7;
+import javax.lang.model.type.TypeVisitor;
+import javax.lang.model.util.SimpleTypeVisitor8;
 
 /**
  * Information about an {@code Optional} {@link TypeMirror}.
  *
- * <p>Only {@link com.google.common.base.Optional} is supported.
+ * <p>{@link com.google.common.base.Optional} and {@link java.util.Optional} are supported.
  */
-// TODO(dpb): Support java.util.Optional.
 @AutoValue
 abstract class OptionalType {
 
-  private static final String OPTIONAL_TYPE = "com.google.common.base.Optional";
+  /** A variant of {@code Optional}. */
+  enum OptionalKind {
+    /** {@link com.google.common.base.Optional}. */
+    GUAVA_OPTIONAL(com.google.common.base.Optional.class, "absent"),
 
-  private static final SimpleTypeVisitor7<Boolean, Void> IS_OPTIONAL =
-      new SimpleTypeVisitor7<Boolean, Void>(false) {
+    /** {@link java.util.Optional}. */
+    JDK_OPTIONAL(java.util.Optional.class, "empty"),
+    ;
+
+    private final Class<?> clazz;
+    private final String absentFactoryMethodName;
+
+    OptionalKind(Class<?> clazz, String absentFactoryMethodName) {
+      this.clazz = clazz;
+      this.absentFactoryMethodName = absentFactoryMethodName;
+    }
+
+    /** Returns {@code valueType} wrapped in the correct class. */
+    ParameterizedTypeName of(TypeName valueType) {
+      return ParameterizedTypeName.get(ClassName.get(clazz), valueType);
+    }
+
+    /** Returns an expression for the absent/empty value. */
+    CodeBlock absentValueExpression() {
+      return CodeBlock.of("$T.$L()", clazz, absentFactoryMethodName);
+    }
+
+    /** Returns an expression for the present {@code value}. */
+    CodeBlock presentExpression(CodeBlock value) {
+      return CodeBlock.of("$T.of($L)", clazz, value);
+    }
+  }
+
+  private static final TypeVisitor<Optional<OptionalKind>, Void> OPTIONAL_KIND =
+      new SimpleTypeVisitor8<Optional<OptionalKind>, Void>(Optional.absent()) {
         @Override
-        public Boolean visitDeclared(DeclaredType t, Void p) {
-          return MoreElements.asType(t.asElement()).getQualifiedName().contentEquals(OPTIONAL_TYPE);
+        public Optional<OptionalKind> visitDeclared(DeclaredType t, Void p) {
+          for (OptionalKind optionalKind : OptionalKind.values()) {
+            Name qualifiedName = MoreElements.asType(t.asElement()).getQualifiedName();
+            if (qualifiedName.contentEquals(optionalKind.clazz.getCanonicalName())) {
+              return Optional.of(optionalKind);
+            }
+          }
+          return Optional.absent();
         }
       };
 
@@ -58,6 +101,11 @@ public Boolean visitDeclared(DeclaredType t, Void p) {
   DeclaredType declaredOptionalType() {
     return wrappedDeclaredOptionalType().get();
   }
+  
+  /** Which {@code Optional} type is used. */
+  OptionalKind kind() {
+    return declaredOptionalType().accept(OPTIONAL_KIND, null).get();
+  }
 
   /** The value type. */
   TypeMirror valueType() {
@@ -66,7 +114,7 @@ TypeMirror valueType() {
 
   /** Returns {@code true} if {@code type} is an {@code Optional} type. */
   static boolean isOptional(TypeMirror type) {
-    return type.accept(IS_OPTIONAL, null);
+    return type.accept(OPTIONAL_KIND, null).isPresent();
   }
 
   /** Returns {@code true} if {@code key.type()} is an {@code Optional} type. */
diff --git a/core/src/main/java/dagger/BindsOptionalOf.java b/core/src/main/java/dagger/BindsOptionalOf.java
index a104cb916..887d9ae8f 100644
--- a/core/src/main/java/dagger/BindsOptionalOf.java
+++ b/core/src/main/java/dagger/BindsOptionalOf.java
@@ -25,8 +25,8 @@
 import javax.inject.Qualifier;
 
 /**
- * Annotates methods that declare bindings for {@code com.google.common.base.Optional} containers of
- * values from bindings that may or may not be present in the component.
+ * Annotates methods that declare bindings for {@code Optional} containers of values from bindings
+ * that may or may not be present in the component.
  *
  * <p>If a module contains a method declaration like this:
  *
@@ -69,6 +69,8 @@
  * <li>{@code Optional<Producer<Foo>>}
  * <li>{@code Optional<Produced<Foo>>}
  * </ul>
+ *
+ * <p>You can inject either {@code com.google.common.base.Optional} or {@code java.util.Optional}.
  */
 @Documented
 @Beta
