diff --git a/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java b/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java
index 8ce3c73d8..e87afb0e1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java
@@ -127,7 +127,11 @@ protected int doHash(AnnotationMirror annotation) {
     values.putAll(annotation.getElementValues());
     return values;
   }
-  
+
+  /**
+   * Returns all {@linkplain AnnotationMirror annotations} that are present on the given
+   * {@link Element} which are themselves annotated with {@code annotationType}.
+   */
   static ImmutableSet<? extends AnnotationMirror> getAnnotatedAnnotations(Element element,
       final Class<? extends Annotation> annotationType) {
     List<? extends AnnotationMirror> annotations = element.getAnnotationMirrors();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index df57561c2..b66d7e3c2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -33,16 +33,12 @@
 import dagger.Provides;
 import java.util.Deque;
 import java.util.List;
-import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
-import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
@@ -121,17 +117,21 @@
     private final Elements elements;
     private final Types types;
     private final InjectBindingRegistry injectBindingRegistry;
+    private final Key.Factory keyFactory;
     private final ProvisionBinding.Factory provisionBindingFactory;
     private final DependencyRequest.Factory dependencyRequestFactory;
 
-    Factory(Elements elements, Types types, InjectBindingRegistry injectBindingRegistry,
-        ProvisionBinding.Factory provisionBindingFactory,
-        DependencyRequest.Factory dependencyRequestFactory) {
+    Factory(Elements elements, Types types,
+        InjectBindingRegistry injectBindingRegistry,
+        DependencyRequest.Factory dependencyRequestFactory,
+        Key.Factory keyFactory,
+        ProvisionBinding.Factory provisionBindingFactory) {
       this.elements = elements;
       this.types = types;
       this.injectBindingRegistry = injectBindingRegistry;
-      this.provisionBindingFactory = provisionBindingFactory;
       this.dependencyRequestFactory = dependencyRequestFactory;
+      this.keyFactory = keyFactory;
+      this.provisionBindingFactory = provisionBindingFactory;
     }
 
     ComponentDescriptor create(TypeElement componentDefinitionType)
@@ -279,7 +279,7 @@ private void resolveRequest(DependencyRequest request,
               explicitBindings.get(requestKey);
           if (explicitBindingsForKey.isEmpty()) {
             // If the key is Map<K, V>, get its implicit binding key which is Map<K, Provider<V>>
-            Optional<Key> key = findMapKey(request);
+            Optional<Key> key = keyFactory.implicitMapProviderKeyFrom(request.key());
             if (key.isPresent()) {
               DependencyRequest implicitRequest =
                   dependencyRequestFactory.forImplicitMapBinding(request, key.get());
@@ -339,24 +339,6 @@ private void resolveRequest(DependencyRequest request,
 
     }
 
-    private Optional<Key> findMapKey(final DependencyRequest request) {
-      if (Util.isTypeOf(Map.class, request.key().type(), elements, types)) {
-        DeclaredType declaredMapType = Util.getDeclaredTypeOfMap(request.key().type());
-        TypeMirror mapValueType = Util.getValueTypeOfMap(declaredMapType);
-        if (!Util.isTypeOf(Provider.class, mapValueType, elements, types)) {
-          TypeMirror keyType =
-              Util.getKeyTypeOfMap((DeclaredType) (request.key().wrappedType().get()));
-          TypeMirror valueType = types.getDeclaredType(
-              elements.getTypeElement(Provider.class.getCanonicalName()), mapValueType);
-          TypeMirror mapType = types.getDeclaredType(
-              elements.getTypeElement(Map.class.getCanonicalName()), keyType, valueType);
-          return Optional.of((Key) new AutoValue_Key(request.key().wrappedQualifier(),
-              MoreTypes.equivalence().wrap(mapType)));
-        }
-      }
-      return Optional.absent();
-    }
-
     private static boolean isComponentProvisionMethod(ExecutableElement method) {
       return method.getParameters().isEmpty()
           && !method.getReturnType().getKind().equals(VOID);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 7e8f1b2c8..82f23237a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -40,7 +40,7 @@
 import dagger.internal.MembersInjectors;
 import dagger.internal.ScopedProvider;
 import dagger.internal.SetFactory;
-import dagger.internal.codegen.ProvisionBinding.BindingsType;
+import dagger.internal.codegen.ProvisionBinding.BindingType;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.ClassWriter;
 import dagger.internal.codegen.writer.ConstructorWriter;
@@ -307,9 +307,9 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
 
         if (frameworkKey.frameworkClass().equals(Provider.class)) {
           Set<ProvisionBinding> bindings = resolvedProvisionBindings.get(key);
-          BindingsType bindingsType = ProvisionBinding.getBindingsType(bindings);
+          BindingType bindingsType = ProvisionBinding.bindingTypeFor(bindings);
           switch (bindingsType) {
-            case SET_BINDING:
+            case SET:
               ImmutableList.Builder<Snippet> setFactoryParameters = ImmutableList.builder();
               for (ProvisionBinding binding : bindings) {
                 setFactoryParameters.add(initializeFactoryForBinding(binding,
@@ -322,7 +322,7 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
               initializeMethod.body().addSnippet("this.%s = %s;",
                   memberSelectSnippet, initializeSetSnippet);
               break;
-            case MAP_BINDING:
+            case MAP:
               if (!bindings.isEmpty()) {
                 Snippet initializeMapSnippet =
                     initializeMapBinding(componentContributionFields, input.dependencyMethodIndex(),
@@ -331,7 +331,7 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
                     memberSelectSnippet, initializeMapSnippet);
               }
               break;
-            case SINGULAR_BINDING:
+            case UNIQUE:
               ProvisionBinding binding = Iterables.getOnlyElement(bindings);
               initializeMethod.body().addSnippet("this.%s = %s;",
                   memberSelectSnippet,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 3a889ade7..8da069f9f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -98,11 +98,11 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
 
     ComponentDescriptor.Factory componentDescriptorFactory =
         new ComponentDescriptor.Factory(elements, types, injectBindingRegistry,
-            provisionBindingFactory, dependencyRequestFactory);
+            dependencyRequestFactory, keyFactory, provisionBindingFactory);
     MapKeyGenerator mapKeyGenerator = new MapKeyGenerator(filer);
 
-    GraphValidator graphValidator = new GraphValidator(elements, types, dependencyRequestFactory,
-        provisionBindingFactory, injectBindingRegistry);
+    GraphValidator graphValidator = new GraphValidator(elements, types, injectBindingRegistry,
+        dependencyRequestFactory, keyFactory, provisionBindingFactory);
 
     this.processingSteps = ImmutableList.<ProcessingStep>of(
         new MapKeyProcessingStep(
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
index d7150c8c9..170ee831e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
@@ -28,6 +28,7 @@
 import javax.lang.model.util.SimpleElementVisitor6;
 
 import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.ErrorMessages.INDENT;
 
 /**
  * Formats a {@link DependencyRequest} into a {@link String} suitable for an error message listing
@@ -38,7 +39,6 @@
  */
 final class DependencyRequestFormatter extends Formatter<DependencyRequest> {
   private static final DependencyRequestFormatter INSTANCE = new DependencyRequestFormatter();
-  private static final String INDENT = "    ";
 
   static DependencyRequestFormatter instance() {
     return INSTANCE;
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 484d6554a..0cd4df5fc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -22,6 +22,11 @@
  * @since 2.0
  */
 final class ErrorMessages {
+  /*
+   * Common constants.
+   */
+  static final String INDENT = "    ";
+
   /*
    * JSR-330 errors
    *
@@ -82,6 +87,9 @@
    * These are errors that relate specifically to the Dagger configuration API (@Module, @Provides,
    * etc.)
    */
+  static final String DUPLICATE_BINDINGS_FOR_KEY_FORMAT =
+      "%s is bound multiple times:";
+
   static final String PROVIDES_METHOD_RETURN_TYPE =
       "@Provides methods must either return a primitive, an array or a declared type.";
 
@@ -123,14 +131,11 @@
       "Map key annotation does not have fields";
 
   /* collection binding errors */
-  static final String NON_SETBINDING =
-      "More than one binding present including at least a set binding and a non-set binding";
-
-  static final String NON_MAPBINDING =
-      "More than one binding present including at least a map binding and a non-map binding";
+  static final String MULTIPLE_BINDING_TYPES_FORMAT =
+      "More than one binding present of different types %s";
 
-  static final String INVALID_COLLECTIONBINDING =
-      "More than one binding present, but found an invalid binding";
+  static final String MULTIPLE_BINDING_TYPES_FOR_KEY_FORMAT =
+      "%s has incompatible bindings:\n";
 
   static final String REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT =
       "%s cannot be provided without an @Inject constructor or from an @Provides-annotated method.";
diff --git a/compiler/src/main/java/dagger/internal/codegen/Formatter.java b/compiler/src/main/java/dagger/internal/codegen/Formatter.java
index 891349ea5..76a2facba 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Formatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Formatter.java
@@ -39,6 +39,7 @@
    *
    * @deprecated Override {@link #format(T)} instead.
    */
+  @SuppressWarnings("javadoc")
   @Deprecated
   @Override final public String apply(T object) {
     return format(object);
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/GraphValidator.java
index fde1298e1..03dee149f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphValidator.java
@@ -21,19 +21,22 @@
 import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Iterables;
+import com.google.common.collect.ListMultimap;
+import com.google.common.collect.Ordering;
 import com.google.common.collect.Queues;
 import dagger.Component;
 import dagger.Provides;
+import dagger.internal.codegen.ProvisionBinding.BindingType;
 import dagger.internal.codegen.ValidationReport.Builder;
 import java.util.Deque;
+import java.util.Formatter;
 import java.util.LinkedHashSet;
 import java.util.List;
-import java.util.Map;
 import java.util.Set;
-import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
@@ -50,8 +53,10 @@
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
 import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
+import static dagger.internal.codegen.ErrorMessages.INDENT;
 import static dagger.internal.codegen.ErrorMessages.REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.REQUIRES_PROVIDER_FORMAT;
 import static javax.lang.model.type.TypeKind.VOID;
@@ -66,21 +71,24 @@
 public class GraphValidator implements Validator<TypeElement> {
   private final Elements elements;
   private final Types types;
+  private final InjectBindingRegistry bindingRegistry;
   private final DependencyRequest.Factory dependencyRequestFactory;
+  private final Key.Factory keyFactory;
   private final ProvisionBinding.Factory provisionBindingFactory;
-  private final InjectBindingRegistry bindingRegistry;
 
   GraphValidator(
       Elements elements,
       Types types,
+      InjectBindingRegistry bindingRegistry,
       DependencyRequest.Factory dependencyRequestFactory,
-      ProvisionBinding.Factory provisionBindingFactory,
-      InjectBindingRegistry bindingRegistry) {
+      Key.Factory keyFactory,
+      ProvisionBinding.Factory provisionBindingFactory) {
     this.elements = elements;
     this.types = types;
-    this.provisionBindingFactory = provisionBindingFactory;
-    this.dependencyRequestFactory = dependencyRequestFactory;
     this.bindingRegistry = bindingRegistry;
+    this.dependencyRequestFactory = dependencyRequestFactory;
+    this.keyFactory = keyFactory;
+    this.provisionBindingFactory = provisionBindingFactory;
   }
 
   @Override
@@ -225,7 +233,7 @@ private void resolveRequest(DependencyRequest request,
           ImmutableSet<ProvisionBinding> explicitBindingsForKey = explicitBindings.get(requestKey);
           if (explicitBindingsForKey.isEmpty()) {
             // If the key is Map<K, V>, get its implicit binding key which is Map<K, Provider<V>>
-            Optional<Key> key = findMapKey(request);
+            Optional<Key> key = keyFactory.implicitMapProviderKeyFrom(request.key());
             if (key.isPresent()) {
               DependencyRequest implicitRequest =
                   dependencyRequestFactory.forImplicitMapBinding(request, key.get());
@@ -241,20 +249,33 @@ private void resolveRequest(DependencyRequest request,
                   findProvidableType(requestKey, reportBuilder, rootRequest, dependencyPath);
               if (provisionBinding.isPresent()) {
                 // found a binding, resolve its deps and then mark it resolved
-                for (DependencyRequest dependency : provisionBinding.get().dependencies()) {
+                for (DependencyRequest dependency : provisionBinding.get().implicitDependencies()) {
                   resolveRequest(dependency, rootRequest, reportBuilder, explicitBindings,
                       resolvedBindings, cycleStack, dependencyPath);
                 }
-                if (provisionBinding.get().memberInjectionRequest().isPresent()) {
-                  resolveRequest(provisionBinding.get().memberInjectionRequest().get(),
-                      rootRequest, reportBuilder, explicitBindings, resolvedBindings, cycleStack,
-                      dependencyPath);
-                }
                 resolvedBindings.add(frameworkKey);
               }
             }
           } else {
-            // we found explicit bindings. resolve the deps and them mark them resolved
+            // If this is an explicit Map<K, V> request then add in any map binding provision
+            // methods which are implied by and must collide with explicit Map<K, V> bindings.
+            Optional<Key> underlyingMapKey = keyFactory.implicitMapProviderKeyFrom(request.key());
+            if (underlyingMapKey.isPresent()) {
+              explicitBindingsForKey = ImmutableSet.<ProvisionBinding>builder()
+                  .addAll(explicitBindingsForKey)
+                  .addAll(explicitBindings.get(underlyingMapKey.get()))
+                  .build();
+            }
+            if (explicitBindingsForKey.size() > 1) {
+              // Multiple Explicit bindings. Validate that they are multi-bindings.
+              ImmutableListMultimap<BindingType, ProvisionBinding> bindingsByType =
+                  ProvisionBinding.bindingTypesFor(explicitBindingsForKey);
+              if (bindingsByType.keySet().size() > 1) {
+                reportMultipleBindingTypes(rootRequest, requestKey, bindingsByType, reportBuilder);
+              } else if (getOnlyElement(bindingsByType.keySet()).equals(BindingType.UNIQUE)) {
+                reportDuplicateBindings(rootRequest, requestKey, bindingsByType, reportBuilder);
+              }
+            }
             for (ProvisionBinding explicitBinding : explicitBindingsForKey) {
               for (DependencyRequest dependency : explicitBinding.dependencies()) {
                 resolveRequest(dependency, rootRequest, reportBuilder, explicitBindings,
@@ -286,23 +307,52 @@ private void resolveRequest(DependencyRequest request,
     }
   }
 
-  // TODO(user): Unify this with ComponentDescriptor.findMapKey() and put it somewhere in common.
-  private Optional<Key> findMapKey(final DependencyRequest request) {
-    if (Util.isTypeOf(Map.class, request.key().type(), elements, types)) {
-      DeclaredType declaredMapType = Util.getDeclaredTypeOfMap(request.key().type());
-      TypeMirror mapValueType = Util.getValueTypeOfMap(declaredMapType);
-      if (!Util.isTypeOf(Provider.class, mapValueType, elements, types)) {
-        TypeMirror keyType =
-            Util.getKeyTypeOfMap((DeclaredType) (request.key().wrappedType().get()));
-        TypeMirror valueType = types.getDeclaredType(
-            elements.getTypeElement(Provider.class.getCanonicalName()), mapValueType);
-        TypeMirror mapType = types.getDeclaredType(
-            elements.getTypeElement(Map.class.getCanonicalName()), keyType, valueType);
-        return Optional.of((Key) new AutoValue_Key(request.key().wrappedQualifier(),
-            MoreTypes.equivalence().wrap(mapType)));
+  @SuppressWarnings("resource") // Appendable is a StringBuilder.
+  private void reportDuplicateBindings(DependencyRequest rootRequest, Key requestKey,
+      ListMultimap<BindingType, ProvisionBinding> bindingsByType,
+      ValidationReport.Builder<TypeElement> reportBuilder) {
+    StringBuilder builder = new StringBuilder();
+    new Formatter(builder).format(ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT,
+        KeyFormatter.instance().format(requestKey));
+    for (ProvisionBinding binding : bindingsByType.values()) {
+      builder.append('\n').append(INDENT);
+      builder.append(ProvisionBindingFormatter.instance().format(binding));
+    }
+    reportBuilder.addItem(builder.toString(), rootRequest.requestElement());
+  }
+
+  @SuppressWarnings("resource") // Appendable is a StringBuilder.
+  private void reportMultipleBindingTypes(DependencyRequest rootRequest, Key requestKey,
+      ListMultimap<BindingType, ProvisionBinding> bindingsByType,
+      ValidationReport.Builder<TypeElement> reportBuilder) {
+    StringBuilder builder = new StringBuilder();
+    new Formatter(builder).format(ErrorMessages.MULTIPLE_BINDING_TYPES_FOR_KEY_FORMAT,
+        KeyFormatter.instance().format(requestKey));
+    for (BindingType type :
+        Ordering.natural().immutableSortedCopy(bindingsByType.keySet())) {
+      builder.append(INDENT);
+      builder.append(formatBindingType(type));
+      builder.append(" bindings:\n");
+      for (ProvisionBinding binding : bindingsByType.get(type)) {
+        builder.append(INDENT).append(INDENT);
+        builder.append(ProvisionBindingFormatter.instance().format(binding));
+        builder.append('\n');
       }
     }
-    return Optional.absent();
+    reportBuilder.addItem(builder.toString(), rootRequest.requestElement());
+  }
+
+  private String formatBindingType(BindingType type) {
+    switch(type) {
+      case MAP:
+        return "Map";
+      case SET:
+        return "Set";
+      case UNIQUE:
+        return "Unique";
+      default:
+        throw new IllegalStateException("Unknown binding type: " + type);
+    }
   }
 
   // TODO(user) determine what bits of InjectBindingRegistry's findOrCreate logic to factor out.
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 72fc6a3b0..fcdefa7f7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -60,7 +60,7 @@
    * for the type of this key.
    *
    * Despite documentation in {@link AnnotationMirror}, equals and hashCode aren't implemented
-   * to represent logical equality, so {@link MoreTypes#annotationMirrorEquivalence()}
+   * to represent logical equality, so {@link AnnotationMirrors#equivalence()}
    * provides this facility.
    */
   abstract Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedQualifier();
@@ -194,6 +194,29 @@ Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
       return new AutoValue_Key(rewrap(qualifier), MoreTypes.equivalence().wrap(normalize(type)));
     }
 
+    /**
+     * Optionally extract a {@link Key} for the underlying provision binding(s) if such a
+     * valid key can be inferred from the given key.  Specifically, if the key represents a 
+     * {@link Map}{@code <K, V>}, a key of {@code Map<K, Provider<V>>} will be returned.
+     */
+    Optional<Key> implicitMapProviderKeyFrom(Key possibleMapKey) {
+      if (Util.isTypeOf(Map.class, possibleMapKey.type(), elements, types)) {
+        DeclaredType declaredMapType = Util.getDeclaredTypeOfMap(possibleMapKey.type());
+        TypeMirror mapValueType = Util.getValueTypeOfMap(declaredMapType);
+        if (!Util.isTypeOf(Provider.class, mapValueType, elements, types)) {
+          TypeMirror keyType =
+              Util.getKeyTypeOfMap((DeclaredType) (possibleMapKey.wrappedType().get()));
+          TypeMirror valueType = types.getDeclaredType(
+              elements.getTypeElement(Provider.class.getCanonicalName()), mapValueType);
+          TypeMirror mapType = types.getDeclaredType(
+              elements.getTypeElement(Map.class.getCanonicalName()), keyType, valueType);
+          return Optional.<Key>of(new AutoValue_Key(possibleMapKey.wrappedQualifier(),
+              MoreTypes.equivalence().wrap(mapType)));
+        }
+      }
+      return Optional.absent();
+    }
+
     private Optional<Equivalence.Wrapper<AnnotationMirror>>
         rewrap(Optional<AnnotationMirror> qualifier) {
       return qualifier.isPresent()
diff --git a/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java b/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
new file mode 100644
index 000000000..146d03c04
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+/**
+ * Formats a {@link Key} into a {@link String} suitable for use in error messages
+ *
+ * @author Christian Gruber
+ * @since 2.0
+ */
+final class KeyFormatter extends Formatter<Key> {
+  private static final KeyFormatter INSTANCE = new KeyFormatter();
+
+  static KeyFormatter instance() {
+    return INSTANCE;
+  }
+
+  @Override public String format(Key request) {
+    StringBuilder builder = new StringBuilder();
+    if (request.qualifier().isPresent()) {
+      builder.append(request.qualifier()); // TODO(user): Use AnnotationMirrorFormatter.
+      builder.append(' ');
+    }
+    builder.append(request.type()); // TODO(user): Use TypeMirrorFormatter.
+    return builder.toString();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 0c07b9fee..abb8f945d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -18,12 +18,13 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
+import com.google.common.collect.Ordering;
 import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.Provides;
-import java.util.Iterator;
 import java.util.Set;
 import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
@@ -45,13 +46,6 @@
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.collect.Sets.immutableEnumSet;
-import static dagger.Provides.Type.MAP;
-import static dagger.Provides.Type.SET;
-import static dagger.Provides.Type.SET_VALUES;
-import static dagger.internal.codegen.ErrorMessages.INVALID_COLLECTIONBINDING;
-import static dagger.internal.codegen.ErrorMessages.NON_MAPBINDING;
-import static dagger.internal.codegen.ErrorMessages.NON_SETBINDING;
 import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.ElementKind.FIELD;
@@ -104,64 +98,63 @@
   /** If this provision requires members injeciton, this will be the corresonding request. */
   abstract Optional<DependencyRequest> memberInjectionRequest();
 
-  private static ImmutableSet<Provides.Type> SET_BINDING_TYPES = immutableEnumSet(SET, SET_VALUES);
-  private static ImmutableSet<Provides.Type> MAP_BINDING_TYPES = immutableEnumSet(MAP);
-
-  static enum BindingsType {
-    /** Represents set bindings. */
-    SET_BINDING,
+  static enum BindingType {
     /** Represents map bindings. */
-    MAP_BINDING,
+    MAP,
+    /** Represents set bindings. */
+    SET,
     /** Represents a valid non-collection binding. */
-    SINGULAR_BINDING,
+    UNIQUE;
+  }
+
+  BindingType bindingType() {
+    switch (provisionType()) {
+      case SET:
+      case SET_VALUES:
+        return BindingType.SET;
+      case MAP:
+        return BindingType.MAP;
+      case UNIQUE:
+        return BindingType.UNIQUE;
+      default:
+        throw new IllegalStateException("Unknown provision type: " + provisionType());
+    }
+  }
+
+  /**
+   * Returns the set of {@link BindingType} enum values implied by a given
+   * {@link ProvisionBinding} collection.
+   */
+  static ImmutableListMultimap<BindingType, ProvisionBinding> bindingTypesFor(
+      Iterable<ProvisionBinding> bindings) {
+    ImmutableListMultimap.Builder<BindingType, ProvisionBinding> builder =
+        ImmutableListMultimap.builder();
+    builder.orderKeysBy(Ordering.<BindingType>natural());
+    for (ProvisionBinding binding : bindings) {
+      builder.put(binding.bindingType(), binding);
+    }
+    return builder.build();
   }
 
   /**
-   * Returns {@code BindingsType} for bindings, which can be {@code SETBINDING} if the given
-   * bindings are all contributors to a set binding. Returns {@code MAPBINDING} if the given
-   * bindings are all contributors to a map binding. Returns {@code NONCOLLECTIONBINDING} if the
-   * given bindings is not a collection.
-   *
-   * @throws IllegalArgumentException if some of the bindings are map bindings or set bindings and
-   *         some are not.
-   * @throws IllegalArgumentException if the bindings in the collection are not supported in Dagger
-   *         (Not set bindings or map Bindings).
+   * Returns a single {@code BindingsType} represented by a given collection of
+   * {@code ProvisionBindings} or throws an IllegalArgumentException if the given bindings
+   * are not all of one type.
    */
-  static BindingsType getBindingsType(Iterable<ProvisionBinding> bindings) {
+  static BindingType bindingTypeFor(Iterable<ProvisionBinding> bindings) {
     checkNotNull(bindings);
     switch (Iterables.size(bindings)) {
       case 0:
         throw new IllegalArgumentException("no bindings");
       case 1:
-        if (SET_BINDING_TYPES.contains(Iterables.getOnlyElement(bindings).provisionType())) {
-          return BindingsType.SET_BINDING;
-        } else if (MAP_BINDING_TYPES.contains(Iterables.getOnlyElement(bindings).provisionType())) {
-          return BindingsType.MAP_BINDING;
-        }
-        return BindingsType.SINGULAR_BINDING;
+        return Iterables.getOnlyElement(bindings).bindingType();
       default:
-        Iterator<ProvisionBinding> iterator = bindings.iterator();
-        boolean setBinding = SET_BINDING_TYPES.contains(iterator.next().provisionType());
-        if (setBinding) {
-          while (iterator.hasNext()) {
-            checkArgument(setBinding, NON_SETBINDING);
-            checkArgument(SET_BINDING_TYPES.contains(iterator.next().provisionType()),
-                NON_SETBINDING);
-          }
-          return BindingsType.SET_BINDING;
-        }
-
-        iterator = bindings.iterator();
-        boolean mapBinding = MAP_BINDING_TYPES.contains(iterator.next().provisionType());
-        if (mapBinding) {
-          while (iterator.hasNext()) {
-            checkArgument(mapBinding, NON_MAPBINDING);
-            checkArgument(MAP_BINDING_TYPES.contains(iterator.next().provisionType()),
-                NON_MAPBINDING);
-          }
-          return BindingsType.MAP_BINDING;
+        Set<BindingType> types = bindingTypesFor(bindings).keySet();
+        if (types.size() > 1) {
+          throw new IllegalArgumentException(
+              String.format(ErrorMessages.MULTIPLE_BINDING_TYPES_FORMAT, types));
         }
-        throw new IllegalStateException(INVALID_COLLECTIONBINDING);
+        return Iterables.getOnlyElement(types);
     }
   }
 
@@ -291,7 +284,7 @@ ProvisionBinding forProvidesMethod(ExecutableElement providesMethod) {
           getScopeAnnotation(providesMethod),
           Optional.<DependencyRequest>absent());
     }
-    
+
     ProvisionBinding forImplicitMapBinding(DependencyRequest explicitRequest,
         DependencyRequest implicitRequest) {
       checkNotNull(explicitRequest);
@@ -299,12 +292,12 @@ ProvisionBinding forImplicitMapBinding(DependencyRequest explicitRequest,
       ImmutableSet<DependencyRequest> dependencies = ImmutableSet.of(implicitRequest);
       return new AutoValue_ProvisionBinding(
           implicitRequest.requestElement(),
-          dependencies, 
-          findBindingPackage(explicitRequest.key()), 
-          Kind.PROVISION, 
-          Provides.Type.MAP, 
-          explicitRequest.key(), 
-          getScopeAnnotation(implicitRequest.requestElement()), 
+          dependencies,
+          findBindingPackage(explicitRequest.key()),
+          Kind.PROVISION,
+          Provides.Type.MAP,
+          explicitRequest.key(),
+          getScopeAnnotation(implicitRequest.requestElement()),
           Optional.<DependencyRequest>absent());
     }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBindingFormatter.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBindingFormatter.java
new file mode 100644
index 000000000..61e915704
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBindingFormatter.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreElements;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+
+/**
+ * Formats a {@link Key} into a {@link String} suitable for use in error messages.
+ *
+ * @author Christian Gruber
+ * @since 2.0
+ */
+final class ProvisionBindingFormatter extends Formatter<ProvisionBinding> {
+  private static final ProvisionBindingFormatter INSTANCE = new ProvisionBindingFormatter();
+
+  static ProvisionBindingFormatter instance() {
+    return INSTANCE;
+  }
+
+  @Override public String format(ProvisionBinding binding) {
+    StringBuilder builder = new StringBuilder();
+    switch (binding.bindingKind()) {
+      case PROVISION:
+      case COMPONENT_PROVISION:
+        ExecutableElement method = MoreElements.asExecutable(binding.bindingElement());
+        TypeElement type = MoreElements.asType(method.getEnclosingElement());
+        builder.append(type.getQualifiedName());
+        builder.append('.');
+        builder.append(method.getSimpleName());
+        builder.append('(');
+        for (VariableElement parameter : method.getParameters()) {
+          builder.append(parameter.asType()); // TODO(user): Use TypeMirrorFormatter.
+        }
+        builder.append(')');
+        return builder.toString();
+      default:
+        throw new UnsupportedOperationException(
+            "Not yet supporting " + binding.bindingKind() + " binding types.");
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 2eb0e9b31..182948a2f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -32,7 +32,7 @@
 import dagger.Lazy;
 import dagger.MembersInjector;
 import dagger.internal.DoubleCheckLazy;
-import dagger.internal.codegen.ProvisionBinding.BindingsType;
+import dagger.internal.codegen.ProvisionBinding.BindingType;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.JavaWriter;
 import dagger.internal.codegen.writer.Snippet;
@@ -186,17 +186,17 @@
     ImmutableMap.Builder<Key, String> providerNames = ImmutableMap.builder();
     for (Entry<Key, Collection<ProvisionBinding>> entry : bindings.asMap().entrySet()) {
       Collection<ProvisionBinding> bindingsForKey = entry.getValue();
-      BindingsType bindingsType = ProvisionBinding.getBindingsType(bindingsForKey);
+      BindingType bindingsType = ProvisionBinding.bindingTypeFor(bindingsForKey);
       switch (bindingsType) {
-        case SET_BINDING:
+        case SET:
           providerNames.put(entry.getKey(),
               new KeyVariableNamer().apply(entry.getKey()) + "Provider");
           break;
-        case MAP_BINDING:
+        case MAP:
           providerNames.put(entry.getKey(),
               new KeyVariableNamer().apply(entry.getKey()) + "Provider");
           break;
-        case SINGULAR_BINDING:
+        case UNIQUE:
           ProvisionBinding binding = Iterables.getOnlyElement(bindingsForKey);
           providerNames.put(entry.getKey(),
               binding.bindingElement().accept(new ElementKindVisitor6<String, Void>() {
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index d25fa9d4f..71ddde94b 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -182,6 +182,160 @@
         .withErrorContaining(expectedError).in(component).onLine(23);
   }
 
+  @Test public void duplicateExplicitBindings_ProvidesAndComponentProvision() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "final class Outer {",
+        "  interface A {}",
+        "",
+        "  interface B {}",
+        "",
+        "  @Module",
+        "  static class AModule {",
+        "    @Provides String provideString() { return \"\"; }",
+        "    @Provides A provideA(String s) { return new A() {}; }",
+        "  }",
+        "",
+        "  @Component(modules = AModule.class)",
+        "  interface Parent {",
+        "    A getA();",
+        "  }",
+        "",
+        "  @Module",
+        "  static class BModule {",
+        "    @Provides B provideB(A a) { return new B() {}; }",
+        "  }",
+        "",
+        "  @Component(dependencies = Parent.class, modules = { BModule.class, AModule.class})",
+        "  interface Child {",
+        "    B getB();",
+        "  }",
+        "}");
+
+    String expectedError = "test.Outer.A is bound multiple times:\n"
+        + "      test.Outer.Parent.getA()\n"
+        + "      test.Outer.AModule.provideA(java.lang.String)";
+
+    assert_().about(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError).in(component).onLine(30);
+  }
+
+  @Test public void duplicateExplicitBindings_TwoProvidesMethods() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "final class Outer {",
+        "  interface A {}",
+        "",
+        "  @Module",
+        "  static class Module1 {",
+        "    @Provides A provideA1() { return new A() {}; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class Module2 {",
+        "    @Provides String provideString() { return \"\"; }",
+        "    @Provides A provideA2(String s) { return new A() {}; }",
+        "  }",
+        "",
+        "  @Component(modules = { Module1.class, Module2.class})",
+        "  interface TestComponent {",
+        "    A getA();",
+        "  }",
+        "}");
+
+    String expectedError = "test.Outer.A is bound multiple times:\n"
+        + "      test.Outer.Module1.provideA1()\n"
+        + "      test.Outer.Module2.provideA2(java.lang.String)";
+
+    assert_().about(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError).in(component).onLine(24);
+  }
+
+  @Test public void duplicateExplicitBindings_MultipleProvisionTypes() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.MapKey;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import dagger.MapKey;",
+        "import java.util.HashMap;",
+        "import java.util.HashSet;",
+        "import java.util.Map;",
+        "import java.util.Set;",
+        "",
+        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+        "import static dagger.Provides.Type.MAP;",
+        "import static dagger.Provides.Type.SET;",
+        "",
+        "final class Outer {",
+        "  @MapKey(unwrapValue = true)",
+        "  @interface StringKey {",
+        "    String value();",
+        "  }",
+        "",
+        "  @Module",
+        "  static class TestModule1 {",
+        "    @Provides(type = MAP)",
+        "    @StringKey(\"foo\")",
+        "    String provideStringMapEntry() { return \"\"; }",
+        "",
+        "    @Provides(type = SET) String provideStringSetElement() { return \"\"; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class TestModule2 {",
+        "    @Provides Set<String> provideStringSet() { return new HashSet<String>(); }",
+        "",
+        "    @Provides Map<String, String> provideStringMap() {",
+        "      return new HashMap<String, String>();",
+        "    }",
+        "  }",
+        "",
+        "  @Component(modules = { TestModule1.class, TestModule2.class })",
+        "  interface TestComponent {",
+        "    Set<String> getStringSet();",
+        "    Map<String, String> getStringMap();",
+        "  }",
+        "}");
+
+    String expectedSetError =
+        "java.util.Set<java.lang.String> has incompatible bindings:\n"
+            + "      Set bindings:\n"
+            + "          test.Outer.TestModule1.provideStringSetElement()\n"
+            + "      Unique bindings:\n"
+            + "          test.Outer.TestModule2.provideStringSet()";
+
+    String expectedMapError =
+        "java.util.Map<java.lang.String,java.lang.String> has incompatible bindings:\n"
+            + "      Map bindings:\n"
+            + "          test.Outer.TestModule1.provideStringMapEntry()\n"
+            + "      Unique bindings:\n"
+            + "          test.Outer.TestModule2.provideStringMap()";
+
+    assert_().about(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedSetError).in(component).onLine(43)
+        .and().withErrorContaining(expectedMapError).in(component).onLine(44);
+  }
+
   @Test public void longChainOfDependencies() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
         "package test;",
