diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
index 7fd73c139..05542a40d 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
@@ -35,5 +35,15 @@
   Set<String> mapKeys();
   Collection<String> mapValues();
   Set<Integer> set();
-  Map<TestKey.NestedWrappedKey, String> nestedKeyMap();
+  Map<TestStringKey.NestedWrappedKey, String> nestedKeyMap();
+  Map<Class<? extends Number>, String> numberClassKeyMap();
+  Map<Class<?>, String> classKeyMap();
+  Map<Long, String> longKeyMap();
+  Map<Integer, String> integerKeyMap();
+  Map<Short, String> shortKeyMap();
+  Map<Byte, String> byteKeyMap();
+  Map<Boolean, String> booleanKeyMap();
+  Map<Character, String> characterKeyMap();
+  Map<TestStringKey, String> unwrappedAnnotationKeyMap();
+  Map<TestWrappedAnnotationKey, String> wrappedAnnotationKeyMap();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
index 311ac1bd6..73d53fef3 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
@@ -17,6 +17,8 @@
 
 import dagger.Module;
 import dagger.Provides;
+import java.math.BigDecimal;
+import java.math.BigInteger;
 import java.util.Collection;
 import java.util.Map;
 import java.util.Set;
@@ -27,11 +29,15 @@
 
 @Module
 class MultibindingModule {
-  @Provides(type = MAP) @TestKey("foo") String provideFooKey(double doubleDependency) {
+  @Provides(type = MAP)
+  @TestStringKey("foo")
+  String provideFooKey(double doubleDependency) {
     return "foo value";
   }
 
-  @Provides(type = MAP) @TestKey("bar") String provideBarKey() {
+  @Provides(type = MAP)
+  @TestStringKey("bar")
+  String provideBarKey() {
     return "bar value";
   }
 
@@ -51,11 +57,98 @@
     return map.values();
   }
 
-  @Provides(type = MAP) @TestKey.NestedWrappedKey(Integer.class) String valueForInteger() {
+  @Provides(type = MAP)
+  @TestStringKey.NestedWrappedKey(Integer.class)
+  String valueForInteger() {
     return "integer";
   }
 
-  @Provides(type = MAP) @TestKey.NestedWrappedKey(Long.class) String valueForLong() {
+  @Provides(type = MAP)
+  @TestStringKey.NestedWrappedKey(Long.class)
+  String valueForLong() {
     return "long";
   }
+
+  @Provides(type = MAP)
+  @TestClassKey(Integer.class)
+  String valueForClassInteger() {
+    return "integer";
+  }
+
+  @Provides(type = MAP)
+  @TestClassKey(Long.class)
+  String valueForClassLong() {
+    return "long";
+  }
+
+  @Provides(type = MAP)
+  @TestNumberClassKey(BigDecimal.class)
+  String valueForNumberClassBigDecimal() {
+    return "bigdecimal";
+  }
+
+  @Provides(type = MAP)
+  @TestNumberClassKey(BigInteger.class)
+  String valueForNumberClassBigInteger() {
+    return "biginteger";
+  }
+
+  @Provides(type = MAP)
+  @TestLongKey(longValue = 100)
+  String valueFor100Long() {
+    return "100 long";
+  }
+
+  @Provides(type = MAP)
+  @TestIntKey(100)
+  String valueFor100Int() {
+    return "100 int";
+  }
+
+  @Provides(type = MAP)
+  @TestShortKey(100)
+  String valueFor100Short() {
+    return "100 short";
+  }
+
+  @Provides(type = MAP)
+  @TestByteKey(100)
+  String valueFor100Byte() {
+    return "100 byte";
+  }
+
+  @Provides(type = MAP)
+  @TestBooleanKey(true)
+  String valueForTrue() {
+    return "true";
+  }
+
+  @Provides(type = MAP)
+  @TestCharKey('a')
+  String valueForA() {
+    return "a char";
+  }
+
+  @Provides(type = MAP)
+  @TestCharKey('\n')
+  String valueForNewline() {
+    return "newline char";
+  }
+
+  @Provides(type = MAP)
+  @TestUnwrappedAnnotationKey(@TestStringKey("foo\n"))
+  String valueForUnwrappedAnnotationKeyFoo() {
+    return "foo annotation";
+  }
+
+  @Provides(type = MAP)
+  @TestWrappedAnnotationKey(
+    value = @TestStringKey("foo"),
+    integers = {1, 2, 3},
+    annotations = {},
+    classes = {Long.class, Integer.class}
+  )
+  String valueForWrappedAnnotationKeyFoo() {
+    return "wrapped foo annotation";
+  }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestBooleanKey.java b/compiler/src/it/functional-tests/src/main/java/test/TestBooleanKey.java
new file mode 100644
index 000000000..a4883459a
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/TestBooleanKey.java
@@ -0,0 +1,23 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import dagger.MapKey;
+
+@MapKey(unwrapValue = true)
+@interface TestBooleanKey {
+  boolean value();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestByteKey.java b/compiler/src/it/functional-tests/src/main/java/test/TestByteKey.java
new file mode 100644
index 000000000..7ad25c4a2
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/TestByteKey.java
@@ -0,0 +1,23 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import dagger.MapKey;
+
+@MapKey(unwrapValue = true)
+@interface TestByteKey {
+  byte value();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestCharKey.java b/compiler/src/it/functional-tests/src/main/java/test/TestCharKey.java
new file mode 100644
index 000000000..a727551de
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/TestCharKey.java
@@ -0,0 +1,23 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import dagger.MapKey;
+
+@MapKey(unwrapValue = true)
+@interface TestCharKey {
+  char value();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestClassKey.java b/compiler/src/it/functional-tests/src/main/java/test/TestClassKey.java
new file mode 100644
index 000000000..921259781
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/TestClassKey.java
@@ -0,0 +1,23 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import dagger.MapKey;
+
+@MapKey(unwrapValue = true)
+@interface TestClassKey {
+  Class<?> value();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestIntKey.java b/compiler/src/it/functional-tests/src/main/java/test/TestIntKey.java
new file mode 100644
index 000000000..14b25cf5d
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/TestIntKey.java
@@ -0,0 +1,23 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import dagger.MapKey;
+
+@MapKey(unwrapValue = true)
+@interface TestIntKey {
+  int value();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestLongKey.java b/compiler/src/it/functional-tests/src/main/java/test/TestLongKey.java
new file mode 100644
index 000000000..ba06ad0e1
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/TestLongKey.java
@@ -0,0 +1,23 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import dagger.MapKey;
+
+@MapKey(unwrapValue = true)
+@interface TestLongKey {
+  long longValue(); // Tests that the unwrapped member can have any name.
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestNumberClassKey.java b/compiler/src/it/functional-tests/src/main/java/test/TestNumberClassKey.java
new file mode 100644
index 000000000..884c75e19
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/TestNumberClassKey.java
@@ -0,0 +1,23 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import dagger.MapKey;
+
+@MapKey(unwrapValue = true)
+@interface TestNumberClassKey {
+  Class<? extends Number> value();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestShortKey.java b/compiler/src/it/functional-tests/src/main/java/test/TestShortKey.java
new file mode 100644
index 000000000..a74f21041
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/TestShortKey.java
@@ -0,0 +1,23 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import dagger.MapKey;
+
+@MapKey(unwrapValue = true)
+@interface TestShortKey {
+  short value();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestKey.java b/compiler/src/it/functional-tests/src/main/java/test/TestStringKey.java
similarity index 96%
rename from compiler/src/it/functional-tests/src/main/java/test/TestKey.java
rename to compiler/src/it/functional-tests/src/main/java/test/TestStringKey.java
index 645af788a..a0e89ed71 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/TestKey.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/TestStringKey.java
@@ -18,7 +18,7 @@
 import dagger.MapKey;
 
 @MapKey(unwrapValue = true)
-@interface TestKey {
+@interface TestStringKey {
   String value();
 
   @MapKey(unwrapValue = false)
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestUnwrappedAnnotationKey.java b/compiler/src/it/functional-tests/src/main/java/test/TestUnwrappedAnnotationKey.java
new file mode 100644
index 000000000..a00372890
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/TestUnwrappedAnnotationKey.java
@@ -0,0 +1,23 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import dagger.MapKey;
+
+@MapKey(unwrapValue = true)
+@interface TestUnwrappedAnnotationKey {
+  TestStringKey value();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestWrappedAnnotationKey.java b/compiler/src/it/functional-tests/src/main/java/test/TestWrappedAnnotationKey.java
new file mode 100644
index 000000000..13c059058
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/TestWrappedAnnotationKey.java
@@ -0,0 +1,26 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import dagger.MapKey;
+
+@MapKey(unwrapValue = false)
+@interface TestWrappedAnnotationKey {
+  TestStringKey value();
+  int[] integers();
+  TestClassKey[] annotations();
+  Class<? extends Number>[] classes();
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
index 8172ced27..66a429be1 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
@@ -15,6 +15,8 @@
 
 import com.google.auto.value.AutoAnnotation;
 import com.google.common.collect.ImmutableMap;
+import java.math.BigDecimal;
+import java.math.BigInteger;
 import java.util.Map;
 import javax.inject.Provider;
 import org.junit.Before;
@@ -64,12 +66,97 @@
             nestedWrappedKey(Long.class), "long"));
   }
 
+  @Test
+  public void unwrappedAnnotationKeyMap() {
+    assertThat(multibindingComponent.unwrappedAnnotationKeyMap())
+        .isEqualTo(ImmutableMap.of(testStringKey("foo\n"), "foo annotation"));
+  }
+
+  @Test
+  public void wrappedAnnotationKeyMap() {
+    @SuppressWarnings("unchecked")
+    Class<? extends Number>[] classes = new Class[] {Long.class, Integer.class};
+    assertThat(multibindingComponent.wrappedAnnotationKeyMap())
+        .isEqualTo(
+            ImmutableMap.of(
+                testWrappedAnnotationKey(
+                    testStringKey("foo"), new int[] {1, 2, 3}, new TestClassKey[] {}, classes),
+                "wrapped foo annotation"));
+  }
+
+  @Test
+  public void booleanKeyMap() {
+    assertThat(multibindingComponent.booleanKeyMap()).isEqualTo(ImmutableMap.of(true, "true"));
+  }
+
+  @Test
+  public void byteKeyMap() {
+    assertThat(multibindingComponent.byteKeyMap())
+        .isEqualTo(ImmutableMap.of((byte) 100, "100 byte"));
+  }
+
+  @Test
+  public void charKeyMap() {
+    assertThat(multibindingComponent.characterKeyMap())
+        .isEqualTo(ImmutableMap.of('a', "a char", '\n', "newline char"));
+  }
+
+  @Test
+  public void classKeyMap() {
+    assertThat(multibindingComponent.classKeyMap())
+        .isEqualTo(
+            ImmutableMap.of(
+                Integer.class, "integer",
+                Long.class, "long"));
+  }
+
+  @Test
+  public void numberClassKeyMap() {
+    assertThat(multibindingComponent.numberClassKeyMap())
+        .isEqualTo(
+            ImmutableMap.of(
+                BigDecimal.class, "bigdecimal",
+                BigInteger.class, "biginteger"));
+  }
+
+  @Test
+  public void intKeyMap() {
+    assertThat(multibindingComponent.integerKeyMap()).isEqualTo(ImmutableMap.of(100, "100 int"));
+  }
+
+  @Test
+  public void longKeyMap() {
+    assertThat(multibindingComponent.longKeyMap())
+        .isEqualTo(ImmutableMap.of((long) 100, "100 long"));
+  }
+
+  @Test
+  public void shortKeyMap() {
+    assertThat(multibindingComponent.shortKeyMap())
+        .isEqualTo(ImmutableMap.of((short) 100, "100 short"));
+  }
+
   @Test public void setBindings() {
     assertThat(multibindingComponent.set()).containsExactly(-90, -17, -1, 5, 6, 832, 1742);
   }
 
   @AutoAnnotation
-  static TestKey.NestedWrappedKey nestedWrappedKey(Class<?> value) {
+  static TestStringKey testStringKey(String value) {
+    return new AutoAnnotation_MultibindingTest_testStringKey(value);
+  }
+
+  @AutoAnnotation
+  static TestStringKey.NestedWrappedKey nestedWrappedKey(Class<?> value) {
     return new AutoAnnotation_MultibindingTest_nestedWrappedKey(value);
   }
+
+  @AutoAnnotation
+  static TestWrappedAnnotationKey testWrappedAnnotationKey(
+      TestStringKey value,
+      int[] integers,
+      TestClassKey[] annotations,
+      Class<? extends Number>[] classes) {
+    return new AutoAnnotation_MultibindingTest_testWrappedAnnotationKey(
+        value, integers, annotations, classes);
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 46ed0ad8c..95a5f7f98 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -15,7 +15,6 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
@@ -77,26 +76,30 @@
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
-import javax.lang.model.element.AnnotationValueVisitor;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.Name;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementKindVisitor6;
 import javax.lang.model.util.SimpleAnnotationValueVisitor6;
+import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
 
+import static com.google.auto.common.AnnotationMirrors.getAnnotationValuesWithDefaults;
 import static com.google.auto.common.MoreTypes.asDeclared;
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.base.Verify.verify;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static com.google.common.collect.Iterables.transform;
 import static dagger.internal.codegen.Binding.bindingPackageFor;
 import static dagger.internal.codegen.ConfigurationAnnotations.getMapKeys;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
@@ -108,6 +111,7 @@
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.membersInjectorNameForMembersInjectionBinding;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
+import static dagger.internal.codegen.writer.Snippet.makeParametersSnippet;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -1404,98 +1408,192 @@ private Snippet initializeMapBinding(
   // add one map entry for map Provider in Constructor
   private void writeEntry(List<Object> argsBuilder, Binding binding,
       Snippet factory) {
-    AnnotationMirror mapKeyAnnotationMirror =
+    AnnotationMirror mapKeyAnnotation =
         Iterables.getOnlyElement(getMapKeys(binding.bindingElement()));
-    Map<? extends ExecutableElement, ? extends AnnotationValue> map =
-        mapKeyAnnotationMirror.getElementValues();
-    MapKey mapKey =
-        mapKeyAnnotationMirror.getAnnotationType().asElement().getAnnotation(MapKey.class);
-    if (!mapKey.unwrapValue()) {// wrapped key case
-      FluentIterable<AnnotationValue> originIterable = FluentIterable.from(
-          AnnotationMirrors.getAnnotationValuesWithDefaults(mapKeyAnnotationMirror).values());
-      FluentIterable<Snippet> annotationValueNames =
-          originIterable.transform(new Function<AnnotationValue, Snippet>() {
-            @Override
-            public Snippet apply(AnnotationValue value) {
-              return getValueSnippet(value);
-            }
-          });
-      ImmutableList.Builder<Snippet> snippets = ImmutableList.builder();
-      for (Snippet snippet : annotationValueNames) {
-        snippets.add(snippet);
-      }
-      argsBuilder.add(Snippet.format("%s.create(%s)",
-          Util.getMapKeyCreatorClassName(
-              MoreTypes.asTypeElement(mapKeyAnnotationMirror.getAnnotationType())),
-          Snippet.makeParametersSnippet(snippets.build())));
-      argsBuilder.add(factory);
-    } else { // unwrapped key case
-      argsBuilder.add(Iterables.getOnlyElement(map.entrySet()).getValue());
-      argsBuilder.add(factory);
+    TypeElement mapKeyAnnotationElement =
+        MoreTypes.asTypeElement(mapKeyAnnotation.getAnnotationType());
+    ClassName mapKeyCreator = Util.getMapKeyCreatorClassName(mapKeyAnnotationElement);
+    if (mapKeyAnnotationElement.getAnnotation(MapKey.class).unwrapValue()) {
+      AnnotationValue unwrapMember = getOnlyElement(mapKeyAnnotation.getElementValues().values());
+      argsBuilder.add(
+          new UnwrappedMapKeyValueVisitor(mapKeyCreator).visit(unwrapMember, unwrapMember));
+    } else {
+      argsBuilder.add(annotationSnippet(mapKeyAnnotation, new MapKeyValueVisitor(mapKeyCreator)));
     }
+    argsBuilder.add(factory);
   }
 
-  // Get the Snippet representation of a Annotation Value
-  // TODO(user) write corresponding test to verify the AnnotationValueVisitor is right
-  private Snippet getValueSnippet(AnnotationValue value) {
-    AnnotationValueVisitor<Snippet, Void> mapKeyVisitor =
-        new SimpleAnnotationValueVisitor6<Snippet, Void>() {
-          @Override
-          public Snippet visitEnumConstant(VariableElement c, Void p) {
-            return Snippet.format("%s.%s",
-                TypeNames.forTypeMirror(c.getEnclosingElement().asType()), c.getSimpleName());
-          }
+  private boolean isNonProviderMap(Binding binding) {
+    TypeMirror bindingType = binding.key().type();
+    return MoreTypes.isTypeOf(Map.class, bindingType) // Implicitly guarantees a declared type.
+        && !MoreTypes.isTypeOf(Provider.class, asDeclared(bindingType).getTypeArguments().get(1));
+  }
 
-          @Override
-          public Snippet visitAnnotation(AnnotationMirror a, Void p) {
-            if (a.getElementValues().isEmpty()) {
-              return Snippet.format("@%s", TypeNames.forTypeMirror(a.getAnnotationType()));
-            } else {
-              Map<ExecutableElement, AnnotationValue> map =
-                  AnnotationMirrors.getAnnotationValuesWithDefaults(a);
-              // build "@Annotation(a = , b = , c = ))
-              ImmutableList.Builder<Snippet> snippets = ImmutableList.builder();
-              for (Entry<ExecutableElement, AnnotationValue> entry : map.entrySet()) {
-                snippets.add(Snippet.format("%s = %s",
-                    TypeNames.forTypeMirror(entry.getKey().asType()),
-                    getValueSnippet(entry.getValue())));
+  // TODO(dpb): Extract all this map-key support into a separate file.
 
-              }
-              return Snippet.format("@%s(%s)", TypeNames.forTypeMirror(a.getAnnotationType()),
-                  Snippet.makeParametersSnippet(snippets.build()));
-            }
-          }
+  /**
+   * Returns a snippet that calls a static method on {@code mapKeyCreator} to create an annotation
+   * from {@code annotationMirror}.
+   */
+  private static Snippet annotationSnippet(
+      AnnotationMirror annotationMirror, final MapKeyValueVisitor mapKeyValueVisitor) {
+    return Snippet.format(
+        "%s.create%s(%s)",
+        mapKeyValueVisitor.mapKeyCreator,
+        annotationMirror.getAnnotationType().asElement().getSimpleName(),
+        makeParametersSnippet(
+            transform(
+                getAnnotationValuesWithDefaults(annotationMirror).entrySet(),
+                new Function<Map.Entry<ExecutableElement, AnnotationValue>, Snippet>() {
+                  @Override
+                  public Snippet apply(Map.Entry<ExecutableElement, AnnotationValue> entry) {
+                    return ARRAY_LITERAL_PREFIX.visit(
+                        entry.getKey().getReturnType(),
+                        mapKeyValueVisitor.visit(entry.getValue(), entry.getValue()));
+                  }
+                })));
+  }
 
-          @Override
-          public Snippet visitType(TypeMirror t, Void p) {
-            return Snippet.format("%s.class", TypeNames.forTypeMirror(t));
-          }
+  /**
+   * Returns a snippet to create the visited value in code. Expects its parameter to be a class with
+   * static creation methods for all nested annotation types.
+   *
+   * <p>Note that {@link AnnotationValue#toString()} is the source-code representation of the value
+   * <em>when used in an annotation</em>, which is not always the same as the representation needed
+   * when creating the value in a method body.
+   *
+   * <p>For example, inside an annotation, a nested array of {@code int}s is simply
+   * <code>{1, 2, 3}</code>, but in code it would have to be <code> new int[] {1, 2, 3}</code>.
+   */
+  static class MapKeyValueVisitor extends SimpleAnnotationValueVisitor6<Snippet, AnnotationValue> {
 
-          @Override
-          public Snippet visitString(String s, Void p) {
-            return Snippet.format("\"%s\"", s);
-          }
+    final ClassName mapKeyCreator;
 
-          @Override
-          protected Snippet defaultAction(Object o, Void v) {
-            return Snippet.format("%s", o);
-          }
+    MapKeyValueVisitor(ClassName mapKeyCreator) {
+      this.mapKeyCreator = mapKeyCreator;
+    }
 
-          @Override
-          public Snippet visitArray(List<? extends AnnotationValue> values, Void v) {
-            ImmutableList.Builder<Snippet> snippets = ImmutableList.builder();
-            for (int i = 0; i < values.size(); i++) {
-              snippets.add(values.get(i).accept(this, null));
-            }
-            return Snippet.format("[%s]", Snippet.makeParametersSnippet(snippets.build()));
-          }
-        };
-    return value.accept(mapKeyVisitor, null);
+    @Override
+    public Snippet visitEnumConstant(VariableElement c, AnnotationValue p) {
+      return Snippet.format(
+          "%s.%s", TypeNames.forTypeMirror(c.getEnclosingElement().asType()), c.getSimpleName());
+    }
+
+    @Override
+    public Snippet visitAnnotation(AnnotationMirror a, AnnotationValue p) {
+      return annotationSnippet(a, this);
+    }
+
+    @Override
+    public Snippet visitType(TypeMirror t, AnnotationValue p) {
+      return Snippet.format("%s.class", TypeNames.forTypeMirror(t));
+    }
+
+    @Override
+    public Snippet visitString(String s, AnnotationValue p) {
+      return Snippet.format("%s", p);
+    }
+
+    @Override
+    public Snippet visitByte(byte b, AnnotationValue p) {
+      return Snippet.format("(byte) %s", b);
+    }
+
+    @Override
+    public Snippet visitChar(char c, AnnotationValue p) {
+      return Snippet.format("%s", p);
+    }
+
+    @Override
+    public Snippet visitDouble(double d, AnnotationValue p) {
+      return Snippet.format("%sD", d);
+    }
+
+    @Override
+    public Snippet visitFloat(float f, AnnotationValue p) {
+      return Snippet.format("%sF", f);
+    }
+
+    @Override
+    public Snippet visitInt(int i, AnnotationValue p) {
+      return Snippet.format("(int) %s", i);
+    }
+
+    @Override
+    public Snippet visitLong(long i, AnnotationValue p) {
+      return Snippet.format("%sL", i);
+    }
+
+    @Override
+    public Snippet visitShort(short s, AnnotationValue p) {
+      return Snippet.format("(short) %s", s);
+    }
+
+    @Override
+    protected Snippet defaultAction(Object o, AnnotationValue p) {
+      return Snippet.format("%s", o);
+    }
+
+    @Override
+    public Snippet visitArray(List<? extends AnnotationValue> values, AnnotationValue p) {
+      ImmutableList.Builder<Snippet> snippets = ImmutableList.builder();
+      for (int i = 0; i < values.size(); i++) {
+        snippets.add(this.visit(values.get(i), p));
+      }
+      return Snippet.format("{%s}", makeParametersSnippet(snippets.build()));
+    }
   }
 
-  private boolean isNonProviderMap(Binding binding) {
-    TypeMirror bindingType = binding.key().type();
-    return MoreTypes.isTypeOf(Map.class, bindingType) // Implicitly guarantees a declared type.
-        && !MoreTypes.isTypeOf(Provider.class, asDeclared(bindingType).getTypeArguments().get(1));
+  /**
+   * Returns a snippet for the visited value. Expects its parameter to be a class with static
+   * creation methods for all nested annotation types.
+   *
+   * <p>Throws {@link IllegalArgumentException} if the visited value is an array.
+   */
+  private static class UnwrappedMapKeyValueVisitor extends MapKeyValueVisitor {
+
+    UnwrappedMapKeyValueVisitor(ClassName mapKeyCreator) {
+      super(mapKeyCreator);
+    }
+
+    @Override
+    public Snippet visitArray(List<? extends AnnotationValue> values, AnnotationValue p) {
+      throw new IllegalArgumentException("Cannot unwrap arrays");
+    }
   }
+
+  /**
+   * If the visited type is an array, prefixes the parameter snippet with {@code new T[]}, where
+   * {@code T} is the raw array component type.
+   */
+  private static final SimpleTypeVisitor6<Snippet, Snippet> ARRAY_LITERAL_PREFIX =
+      new SimpleTypeVisitor6<Snippet, Snippet>() {
+
+        @Override
+        public Snippet visitArray(ArrayType t, Snippet p) {
+          return Snippet.format("new %s[] %s", RAW_TYPE_NAME.visit(t.getComponentType()), p);
+        }
+
+        @Override
+        protected Snippet defaultAction(TypeMirror e, Snippet p) {
+          return p;
+        }
+      };
+
+  /**
+   * If the visited type is an array, returns the name of its raw component type; otherwise returns
+   * the name of the type itself.
+   */
+  private static final SimpleTypeVisitor6<TypeName, Void> RAW_TYPE_NAME =
+      new SimpleTypeVisitor6<TypeName, Void>() {
+        @Override
+        public TypeName visitDeclared(DeclaredType t, Void p) {
+          return ClassName.fromTypeElement(MoreTypes.asTypeElement(t));
+        }
+
+        @Override
+        protected TypeName defaultAction(TypeMirror e, Void p) {
+          return TypeNames.forTypeMirror(e);
+        }
+      };
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 63c043478..35112668c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -148,6 +148,7 @@ public SourceVersion getSupportedSourceVersion() {
     return ImmutableList.<ProcessingStep>of(
         new MapKeyProcessingStep(
             messager,
+            types,
             mapKeyValidator,
             mapKeyGenerator),
         new InjectProcessingStep(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index e560706bb..12da8deae 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -160,8 +160,14 @@
       "Cannot use more than one @Qualifier on a @Provides or @Produces method";
 
   /* mapKey errors*/
-  static final String MAPKEY_WITHOUT_FIELDS =
-      "Map key annotation does not have fields";
+  static final String MAPKEY_WITHOUT_MEMBERS =
+      "Map key annotations must have members";
+
+  static final String UNWRAPPED_MAP_KEY_WITH_TOO_MANY_MEMBERS=
+      "Map key annotations with unwrapped values must have exactly one member";
+
+  static final String UNWRAPPED_MAP_KEY_WITH_ARRAY_MEMBER =
+      "Map key annotations with unwrapped values cannot use arrays";
 
   /* collection binding errors */
   static final String MULTIPLE_BINDING_TYPES_FORMAT =
@@ -211,7 +217,7 @@
 
   static final String CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD =
       "Cannot return null from a non-@Nullable @Provides method";
-  
+
   static ComponentBuilderMessages builderMsgsFor(ComponentDescriptor.Kind kind) {
     switch(kind) {
       case COMPONENT:
@@ -227,101 +233,101 @@ static ComponentBuilderMessages builderMsgsFor(ComponentDescriptor.Kind kind) {
     static final ComponentBuilderMessages INSTANCE = new ComponentBuilderMessages();
 
     protected String process(String s) { return s; }
-    
+
     /** Errors for component builders. */
     final String moreThanOne() {
       return process("@Component has more than one @Component.Builder: %s");
     }
-    
+
     final String cxtorOnlyOneAndNoArgs() {
       return process("@Component.Builder classes must have exactly one constructor,"
           + " and it must not have any parameters");
     }
-    
+
     final String generics() {
       return process("@Component.Builder types must not have any generic types");
     }
-    
+
     final String mustBeInComponent() {
       return process("@Component.Builder types must be nested within a @Component");
     }
-    
+
     final String mustBeClassOrInterface() {
       return process("@Component.Builder types must be abstract classes or interfaces");
     }
-    
+
     final String isPrivate() {
       return process("@Component.Builder types must not be private");
     }
-    
+
     final String mustBeStatic() {
       return process("@Component.Builder types must be static");
     }
-    
+
     final String mustBeAbstract() {
       return process("@Component.Builder types must be abstract");
     }
-    
+
     final String missingBuildMethod() {
       return process("@Component.Builder types must have exactly one no-args method that "
           + " returns the @Component type");
     }
-    
+
     final String manyMethodsForType() {
       return process("@Component.Builder types must not have more than one setter method per type,"
           + " but %s is set by %s");
     }
-    
+
     final String extraSetters() {
       return process(
           "@Component.Builder has setters for modules or components that aren't required: %s");
     }
-    
+
     final String missingSetters() {
       return process(
           "@Component.Builder is missing setters for required modules or components: %s");
     }
-    
+
     final String twoBuildMethods() {
       return process("@Component.Builder types must have exactly one zero-arg method, and that"
           + " method must return the @Component type. Already found: %s");
     }
-    
+
     final String inheritedTwoBuildMethods() {
       return process("@Component.Builder types must have exactly one zero-arg method, and that"
           + " method must return the @Component type. Found %s and %s");
     }
-    
+
     final String buildMustReturnComponentType() {
       return process(
           "@Component.Builder methods that have no arguments must return the @Component type");
     }
-    
+
     final String inheritedBuildMustReturnComponentType() {
       return process(
           "@Component.Builder methods that have no arguments must return the @Component type"
           + " Inherited method: %s");
     }
-    
+
     final String methodsMustTakeOneArg() {
       return process("@Component.Builder methods must not have more than one argument");
     }
-    
+
     final String inheritedMethodsMustTakeOneArg() {
       return process(
           "@Component.Builder methods must not have more than one argument. Inherited method: %s");
     }
-    
+
     final String methodsMustReturnVoidOrBuilder() {
       return process("@Component.Builder setter methods must return void, the builder,"
           + " or a supertype of the builder");
     }
-    
+
     final String inheritedMethodsMustReturnVoidOrBuilder() {
       return process("@Component.Builder setter methods must return void, the builder,"
           + "or a supertype of the builder. Inherited method: %s");
     }
-    
+
     final String methodsMayNotHaveTypeParameters() {
       return process("@Component.Builder methods must not have type parameters");
     }
@@ -335,7 +341,7 @@ final String inheritedMethodsMayNotHaveTypeParameters() {
   static final class SubcomponentBuilderMessages extends ComponentBuilderMessages {
     @SuppressWarnings("hiding")
     static final SubcomponentBuilderMessages INSTANCE = new SubcomponentBuilderMessages();
-    
+
     @Override protected String process(String s) {
       return s.replaceAll("component", "subcomponent").replaceAll("Component", "Subcomponent");
     }
@@ -343,7 +349,7 @@ final String inheritedMethodsMayNotHaveTypeParameters() {
     String builderMethodRequiresNoArgs() {
       return "Methods returning a @Subcomponent.Builder must have no arguments";
     }
-    
+
     String moreThanOneRefToSubcomponent() {
       return "Only one method can create a given subcomponent. %s is created by: %s";
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index ca01668b7..b9eb21560 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -50,10 +50,10 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.ConfigurationAnnotations.getMapKeys;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
+import static dagger.internal.codegen.Util.getUnwrappedMapKeyType;
 import static dagger.internal.codegen.Util.unwrapOptionalEquivalence;
 import static dagger.internal.codegen.Util.wrapOptionalInEquivalence;
 import static javax.lang.model.element.ElementKind.METHOD;
-import static javax.lang.model.type.TypeKind.DECLARED;
 
 /**
  * Represents a unique combination of {@linkplain TypeMirror type} and
@@ -187,9 +187,7 @@ Key forComponentMethod(ExecutableElement componentMethod) {
       checkNotNull(componentMethod);
       checkArgument(componentMethod.getKind().equals(METHOD));
       TypeMirror returnType = normalize(types, componentMethod.getReturnType());
-      return new AutoValue_Key(
-          wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(componentMethod)),
-          MoreTypes.equivalence().wrap(returnType));
+      return forMethod(componentMethod, returnType);
     }
 
     Key forProductionComponentMethod(ExecutableElement componentMethod) {
@@ -200,99 +198,93 @@ Key forProductionComponentMethod(ExecutableElement componentMethod) {
       if (MoreTypes.isTypeOf(ListenableFuture.class, returnType)) {
         keyType = Iterables.getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments());
       }
-      return new AutoValue_Key(
-          wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(componentMethod)),
-          MoreTypes.equivalence().wrap(keyType));
+      return forMethod(componentMethod, keyType);
     }
 
-    Key forProvidesMethod(ExecutableType executableType, ExecutableElement e) {
-      checkNotNull(e);
-      checkArgument(e.getKind().equals(METHOD));
-      Provides providesAnnotation = e.getAnnotation(Provides.class);
+    Key forProvidesMethod(ExecutableType executableType, ExecutableElement method) {
+      checkNotNull(method);
+      checkArgument(method.getKind().equals(METHOD));
+      Provides providesAnnotation = method.getAnnotation(Provides.class);
       checkArgument(providesAnnotation != null);
       TypeMirror returnType = normalize(types, executableType.getReturnType());
-      switch (providesAnnotation.type()) {
-        case UNIQUE:
-          return new AutoValue_Key(
-              wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(e)),
-              MoreTypes.equivalence().wrap(returnType));
-        case SET:
-          TypeMirror setType = types.getDeclaredType(getSetElement(), returnType);
-          return new AutoValue_Key(
-              wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(e)),
-              MoreTypes.equivalence().wrap(setType));
-        case MAP:
-          AnnotationMirror mapKeyAnnotation = Iterables.getOnlyElement(getMapKeys(e));
-          MapKey mapKey =
-              mapKeyAnnotation.getAnnotationType().asElement().getAnnotation(MapKey.class);
-          TypeElement keyTypeElement =
-              mapKey.unwrapValue() ? Util.getKeyTypeElement(mapKeyAnnotation, elements)
-                  : (TypeElement) mapKeyAnnotation.getAnnotationType().asElement();
-          TypeMirror valueType = types.getDeclaredType(getProviderElement(), returnType);
-          TypeMirror mapType =
-              types.getDeclaredType(getMapElement(), keyTypeElement.asType(), valueType);
-          return new AutoValue_Key(
-              wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(e)),
-              MoreTypes.equivalence().wrap(mapType));
-        case SET_VALUES:
-          // TODO(gak): do we want to allow people to use "covariant return" here?
-          checkArgument(returnType.getKind().equals(DECLARED));
-          checkArgument(((DeclaredType) returnType).asElement().equals(getSetElement()));
-          return new AutoValue_Key(
-              wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(e)),
-              MoreTypes.equivalence().wrap(returnType));
-        default:
-          throw new AssertionError();
-      }
+      TypeMirror keyType =
+          providesOrProducesKeyType(
+              returnType,
+              method,
+              Optional.of(providesAnnotation.type()),
+              Optional.<Produces.Type>absent());
+      return forMethod(method, keyType);
     }
 
     // TODO(user): Reconcile this method with forProvidesMethod when Provides.Type and
     // Produces.Type are no longer different.
-    Key forProducesMethod(ExecutableType executableType, ExecutableElement e) {
-      checkNotNull(e);
-      checkArgument(e.getKind().equals(METHOD));
-      Produces producesAnnotation = e.getAnnotation(Produces.class);
+    Key forProducesMethod(ExecutableType executableType, ExecutableElement method) {
+      checkNotNull(method);
+      checkArgument(method.getKind().equals(METHOD));
+      Produces producesAnnotation = method.getAnnotation(Produces.class);
       checkArgument(producesAnnotation != null);
       TypeMirror returnType = normalize(types, executableType.getReturnType());
-      TypeMirror keyType = returnType;
+      TypeMirror unfuturedType = returnType;
       if (MoreTypes.isTypeOf(ListenableFuture.class, returnType)) {
-        keyType = Iterables.getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments());
+        unfuturedType =
+            Iterables.getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments());
       }
-      switch (producesAnnotation.type()) {
+      TypeMirror keyType =
+          providesOrProducesKeyType(
+              unfuturedType,
+              method,
+              Optional.<Provides.Type>absent(),
+              Optional.of(producesAnnotation.type()));
+      return forMethod(method, keyType);
+    }
+
+    private TypeMirror providesOrProducesKeyType(
+        TypeMirror returnType,
+        ExecutableElement method,
+        Optional<Provides.Type> providesType,
+        Optional<Produces.Type> producesType) {
+      switch (providesType.isPresent()
+          ? providesType.get()
+          : Provides.Type.valueOf(producesType.get().name())) {
         case UNIQUE:
-          return new AutoValue_Key(
-              wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(e)),
-              MoreTypes.equivalence().wrap(keyType));
+          return returnType;
         case SET:
-          TypeMirror setType = types.getDeclaredType(getSetElement(), keyType);
-          return new AutoValue_Key(
-              wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(e)),
-              MoreTypes.equivalence().wrap(setType));
+          return types.getDeclaredType(getSetElement(), returnType);
         case MAP:
-          AnnotationMirror mapKeyAnnotation = Iterables.getOnlyElement(getMapKeys(e));
-          MapKey mapKey =
-              mapKeyAnnotation.getAnnotationType().asElement().getAnnotation(MapKey.class);
-          TypeElement keyTypeElement =
-              mapKey.unwrapValue() ? Util.getKeyTypeElement(mapKeyAnnotation, elements)
-                  : (TypeElement) mapKeyAnnotation.getAnnotationType().asElement();
-          TypeMirror valueType = types.getDeclaredType(getProducerElement(), keyType);
-          TypeMirror mapType =
-              types.getDeclaredType(getMapElement(), keyTypeElement.asType(), valueType);
-          return new AutoValue_Key(
-              wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(e)),
-              MoreTypes.equivalence().wrap(mapType));
+          return mapOfFactoryType(
+              method,
+              returnType,
+              providesType.isPresent() ? getProviderElement() : getProducerElement());
         case SET_VALUES:
           // TODO(gak): do we want to allow people to use "covariant return" here?
-          checkArgument(keyType.getKind().equals(DECLARED));
-          checkArgument(((DeclaredType) keyType).asElement().equals(getSetElement()));
-          return new AutoValue_Key(
-              wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(e)),
-              MoreTypes.equivalence().wrap(keyType));
+          checkArgument(MoreTypes.isType(returnType) && MoreTypes.isTypeOf(Set.class, returnType));
+          return returnType;
         default:
           throw new AssertionError();
       }
     }
 
+    private TypeMirror mapOfFactoryType(
+        ExecutableElement method, TypeMirror valueType, TypeElement factoryType) {
+      TypeMirror mapKeyType = mapKeyType(method);
+      TypeMirror mapValueFactoryType = types.getDeclaredType(factoryType, valueType);
+      return types.getDeclaredType(getMapElement(), mapKeyType, mapValueFactoryType);
+    }
+
+    private TypeMirror mapKeyType(ExecutableElement method) {
+      AnnotationMirror mapKeyAnnotation = Iterables.getOnlyElement(getMapKeys(method));
+      MapKey mapKey = mapKeyAnnotation.getAnnotationType().asElement().getAnnotation(MapKey.class);
+      return mapKey.unwrapValue()
+          ? getUnwrappedMapKeyType(mapKeyAnnotation.getAnnotationType(), types)
+          : mapKeyAnnotation.getAnnotationType();
+    }
+
+    private Key forMethod(ExecutableElement method, TypeMirror keyType) {
+      return new AutoValue_Key(
+          wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(method)),
+          MoreTypes.equivalence().wrap(keyType));
+    }
+
     Key forInjectConstructorWithResolvedType(TypeMirror type) {
       return new AutoValue_Key(
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
index e0be1493a..2c3c514ce 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
@@ -15,88 +15,161 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoAnnotation;
-import com.google.common.base.Joiner;
+import com.google.auto.value.AutoValue;
 import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import dagger.MapKey;
+import dagger.internal.codegen.MapKeyGenerator.MapKeyCreatorSpecification;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.JavaWriter;
 import dagger.internal.codegen.writer.MethodWriter;
+import dagger.internal.codegen.writer.Snippet;
+import dagger.internal.codegen.writer.TypeName;
+import dagger.internal.codegen.writer.TypeNames;
 import dagger.internal.codegen.writer.TypeWriter;
-import java.util.ArrayList;
-import java.util.List;
+import java.util.LinkedHashSet;
+import java.util.Set;
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Name;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.util.SimpleTypeVisitor6;
 
+import static dagger.internal.codegen.writer.Snippet.makeParametersSnippet;
+import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
+import static javax.lang.model.util.ElementFilter.methodsIn;
 
 /**
- * Generates implementations to create {@link MapKey} instances
+ * Generates classes that create annotations required to instantiate {@link MapKey}s.
  *
- * @author Chenying Hou
  * @since 2.0
  */
-final class MapKeyGenerator extends SourceFileGenerator<Element> {
+final class MapKeyGenerator extends SourceFileGenerator<MapKeyCreatorSpecification> {
+
+  /**
+   * Specification of the {@link MapKey} annotation and the annotation type to generate.
+   */
+  @AutoValue
+  abstract static class MapKeyCreatorSpecification {
+    /**
+     * The {@link MapKey}-annotated annotation.
+     */
+    abstract TypeElement mapKeyElement();
+
+    /**
+     * The annotation type to write create methods for. For wrapped {@link MapKey}s, this is
+     * {@link #mapKeyElement()}. For unwrapped {@code MapKey}s whose single element is an
+     * annotation, this is that annotation element.
+     */
+    abstract TypeElement annotationElement();
+
+    /**
+     * Returns a specification for a wrapped {@link MapKey}-annotated annotation.
+     */
+    static MapKeyCreatorSpecification wrappedMapKey(TypeElement mapKeyElement) {
+      return new AutoValue_MapKeyGenerator_MapKeyCreatorSpecification(mapKeyElement, mapKeyElement);
+    }
+
+    /**
+     * Returns a specification for an unwrapped {@link MapKey}-annotated annotation whose single
+     * element is a nested annotation.
+     */
+    static MapKeyCreatorSpecification unwrappedMapKeyWithAnnotationValue(
+        TypeElement mapKeyElement, TypeElement annotationElement) {
+      return new AutoValue_MapKeyGenerator_MapKeyCreatorSpecification(
+          mapKeyElement, annotationElement);
+    }
+  }
+
   MapKeyGenerator(Filer filer) {
     super(filer);
   }
 
   @Override
-  ClassName nameGeneratedType(Element e) {
-    return Util.getMapKeyCreatorClassName((TypeElement) e);
+  ClassName nameGeneratedType(MapKeyCreatorSpecification mapKeyCreatorType) {
+    return Util.getMapKeyCreatorClassName(mapKeyCreatorType.mapKeyElement());
   }
 
   @Override
-  Iterable<? extends Element> getOriginatingElements(Element e) {
-    return ImmutableSet.of(e);
+  Iterable<? extends Element> getOriginatingElements(MapKeyCreatorSpecification mapKeyCreatorType) {
+    return ImmutableSet.of(mapKeyCreatorType.mapKeyElement());
   }
 
   @Override
-  Optional<? extends Element> getElementForErrorReporting(Element e) {
-    return Optional.of(e);
+  Optional<? extends Element> getElementForErrorReporting(
+      MapKeyCreatorSpecification mapKeyCreatorType) {
+    return Optional.of(mapKeyCreatorType.mapKeyElement());
   }
 
   @Override
-  ImmutableSet<JavaWriter> write(ClassName generatedTypeName, Element e) {
+  ImmutableSet<JavaWriter> write(
+      ClassName generatedTypeName, MapKeyCreatorSpecification mapKeyCreatorType) {
     JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
-    TypeWriter mapKeyWriter = writer.addClass(generatedTypeName.simpleName());
-    mapKeyWriter.annotate(Generated.class).setValue(ComponentProcessor.class.getName());
-    mapKeyWriter.addModifiers(PUBLIC);
-
-    //create map key create method, which will return an instance of map key
-    MethodWriter getMethodWriter = mapKeyWriter.addMethod(e.asType(), "create");
-    //get parameter list of create method
-    List<? extends Element> enclosingElements = e.getEnclosedElements();
-    List<String> paraList = new ArrayList<String>();
-
-    //Using AutoAnnotation to generate mapkey creator files later
-    getMethodWriter.annotate(AutoAnnotation.class);
-    getMethodWriter.addModifiers(PUBLIC, STATIC);
-
-    for (Element element : enclosingElements) {
-      if (element instanceof ExecutableElement) {
-        ExecutableElement executableElement = (ExecutableElement) element;
-        Name parameterName = executableElement.getSimpleName();
-        getMethodWriter.addParameter(
-            (TypeElement) ((DeclaredType) (executableElement.getReturnType())).asElement(),
-            parameterName.toString());
-        paraList.add(parameterName.toString());
-      } else {
-        throw new IllegalStateException();
-      }
-    }
+    TypeWriter mapKeyCreatorWriter = writer.addClass(generatedTypeName.simpleName());
+    mapKeyCreatorWriter.annotate(Generated.class).setValue(ComponentProcessor.class.getName());
+    mapKeyCreatorWriter.addModifiers(PUBLIC, FINAL);
 
-    getMethodWriter.body().addSnippet(
-        "return new AutoAnnotation_" + generatedTypeName.simpleName() + "_create(%s);",
-        Joiner.on(", ").join(paraList));
+    for (TypeElement annotationElement :
+        nestedAnnotationElements(mapKeyCreatorType.annotationElement())) {
+      writeCreateMethod(mapKeyCreatorWriter, annotationElement);
+    }
 
     return ImmutableSet.of(writer);
   }
+
+  private void writeCreateMethod(TypeWriter mapKeyCreatorWriter, TypeElement annotationElement) {
+    MethodWriter createMethod =
+        mapKeyCreatorWriter.addMethod(
+            annotationElement.asType(), "create" + annotationElement.getSimpleName());
+
+    createMethod.annotate(AutoAnnotation.class);
+    createMethod.addModifiers(PUBLIC, STATIC);
+
+    ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
+    for (ExecutableElement annotationMember : methodsIn(annotationElement.getEnclosedElements())) {
+      String parameterName = annotationMember.getSimpleName().toString();
+      TypeName parameterType = TypeNames.forTypeMirror(annotationMember.getReturnType());
+      createMethod.addParameter(parameterType, parameterName);
+      parameters.add(Snippet.format("%s", parameterName));
+    }
+
+    ClassName autoAnnotationClass = mapKeyCreatorWriter.name().peerNamed(
+        "AutoAnnotation_" + mapKeyCreatorWriter.name().simpleName() + "_" + createMethod.name());
+    createMethod.body().addSnippet(
+        "return new %s(%s);", autoAnnotationClass, makeParametersSnippet(parameters.build()));
+  }
+
+  private static Set<TypeElement> nestedAnnotationElements(TypeElement annotationElement) {
+    return nestedAnnotationElements(annotationElement, new LinkedHashSet<TypeElement>());
+  }
+
+  private static Set<TypeElement> nestedAnnotationElements(
+      TypeElement annotationElement, Set<TypeElement> annotationElements) {
+    if (annotationElements.add(annotationElement)) {
+      for (ExecutableElement method : methodsIn(annotationElement.getEnclosedElements())) {
+        TRAVERSE_NESTED_ANNOTATIONS.visit(method.getReturnType(), annotationElements);
+      }
+    }
+    return annotationElements;
+  }
+
+  private static final SimpleTypeVisitor6<Void, Set<TypeElement>> TRAVERSE_NESTED_ANNOTATIONS =
+      new SimpleTypeVisitor6<Void, Set<TypeElement>>() {
+        @Override
+        public Void visitDeclared(DeclaredType t, Set<TypeElement> p) {
+          TypeElement typeElement = MoreTypes.asTypeElement(t);
+          if (typeElement.getKind() == ElementKind.ANNOTATION_TYPE) {
+            nestedAnnotationElements(typeElement, p);
+          }
+          return null;
+        }
+      };
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
index 488f031c1..7c7dc6624 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
@@ -16,13 +16,23 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.BasicAnnotationProcessor;
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
 import dagger.MapKey;
+import dagger.internal.codegen.MapKeyGenerator.MapKeyCreatorSpecification;
 import java.lang.annotation.Annotation;
 import java.util.Set;
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.util.Types;
+
+import static dagger.internal.codegen.MapKeyGenerator.MapKeyCreatorSpecification.unwrappedMapKeyWithAnnotationValue;
+import static dagger.internal.codegen.MapKeyGenerator.MapKeyCreatorSpecification.wrappedMapKey;
+import static dagger.internal.codegen.Util.getUnwrappedMapKeyType;
 
 /**
  * The annotation processor responsible for validating the mapKey annotation and auto-generate
@@ -33,12 +43,17 @@
  */
 public class MapKeyProcessingStep implements BasicAnnotationProcessor.ProcessingStep {
   private final Messager messager;
+  private final Types types;
   private final MapKeyValidator mapKeyValidator;
   private final MapKeyGenerator mapKeyGenerator;
 
-  MapKeyProcessingStep(Messager messager, MapKeyValidator mapKeyValidator,
+  MapKeyProcessingStep(
+      Messager messager,
+      Types types,
+      MapKeyValidator mapKeyValidator,
       MapKeyGenerator mapKeyGenerator) {
     this.messager = messager;
+    this.types = types;
     this.mapKeyValidator = mapKeyValidator;
     this.mapKeyGenerator = mapKeyGenerator;
   }
@@ -56,14 +71,26 @@ public void process(SetMultimap<Class<? extends Annotation>, Element> elementsBy
 
       if (mapKeyReport.isClean()) {
         MapKey mapkey = element.getAnnotation(MapKey.class);
-        if (!mapkey.unwrapValue()) {
-          try {
-            mapKeyGenerator.generate(element);
-          } catch (SourceFileGenerationException e) {
-            e.printMessageTo(messager);
+        if (mapkey.unwrapValue()) {
+          DeclaredType keyType =
+              getUnwrappedMapKeyType(MoreTypes.asDeclared(element.asType()), types);
+          if (keyType.asElement().getKind() == ElementKind.ANNOTATION_TYPE) {
+            writeCreatorClass(
+                unwrappedMapKeyWithAnnotationValue(
+                    MoreElements.asType(element), MoreTypes.asTypeElement(keyType)));
           }
+        } else {
+          writeCreatorClass(wrappedMapKey(MoreElements.asType(element)));
         }
       }
     }
   }
+
+  private void writeCreatorClass(MapKeyCreatorSpecification mapKeyCreatorType) {
+    try {
+      mapKeyGenerator.generate(mapKeyCreatorType);
+    } catch (SourceFileGenerationException e) {
+      e.printMessageTo(messager);
+    }
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyValidator.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyValidator.java
index 8411b20fb..01b0951a6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyValidator.java
@@ -16,23 +16,37 @@
 package dagger.internal.codegen;
 
 import dagger.MapKey;
+import java.util.List;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeKind;
 
-import static dagger.internal.codegen.ErrorMessages.MAPKEY_WITHOUT_FIELDS;
+import static dagger.internal.codegen.ErrorMessages.MAPKEY_WITHOUT_MEMBERS;
+import static dagger.internal.codegen.ErrorMessages.UNWRAPPED_MAP_KEY_WITH_ARRAY_MEMBER;
+import static dagger.internal.codegen.ErrorMessages.UNWRAPPED_MAP_KEY_WITH_TOO_MANY_MEMBERS;
+import static javax.lang.model.util.ElementFilter.methodsIn;
 
 /**
- * A {@link Validator} for {@link MapKey} Annotation.
+ * A {@link Validator} for {@link MapKey} annotations.
  *
  * @author Chenying Hou
  * @since 2.0
  */
+// TODO(dpb,gak): Should unwrapped MapKeys be required to have their single member be named "value"?
 final class MapKeyValidator implements Validator<Element> {
   @Override
   public ValidationReport<Element> validate(Element element) {
     ValidationReport.Builder<Element> builder = ValidationReport.Builder.about(element);
-    if (((TypeElement) element).getEnclosedElements().isEmpty()) {
-      builder.addItem(MAPKEY_WITHOUT_FIELDS, element);
+    List<ExecutableElement> members = methodsIn(((TypeElement) element).getEnclosedElements());
+    if (members.isEmpty()) {
+      builder.addItem(MAPKEY_WITHOUT_MEMBERS, element);
+    } else if (element.getAnnotation(MapKey.class).unwrapValue()) {
+      if (members.size() > 1) {
+        builder.addItem(UNWRAPPED_MAP_KEY_WITH_TOO_MANY_MEMBERS, element);
+      } else if (members.get(0).getReturnType().getKind() == TypeKind.ARRAY) {
+        builder.addItem(UNWRAPPED_MAP_KEY_WITH_ARRAY_MEMBER, element);
+      }
     }
     return builder.build();
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 3adf6f6bd..6aa0fb04b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -23,32 +23,35 @@
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.ImmutableSet.Builder;
-import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
+import dagger.MapKey;
 import dagger.internal.codegen.writer.ClassName;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.AnnotationValue;
-import javax.lang.model.element.AnnotationValueVisitor;
+import java.util.NoSuchElementException;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
-import javax.lang.model.util.SimpleAnnotationValueVisitor6;
+import javax.lang.model.util.SimpleTypeVisitor6;
+import javax.lang.model.util.Types;
 
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.collect.Iterables.getOnlyElement;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.STATIC;
+import static javax.lang.model.util.ElementFilter.methodsIn;
 
 /**
  * Utilities for handling types in annotation processors
@@ -83,38 +86,48 @@ public static DeclaredType getKeyTypeOfMap(DeclaredType mapType) {
   }
 
   /**
-   * Returns the unwrapped key's {@link TypeElement} for a {@link Map} given the
-   * {@link AnnotationMirror} of the key.
+   * Returns the map key type for an unwrapped {@link MapKey} annotation type. If the single member
+   * type is primitive, returns the boxed type.
+   *
+   * @throws IllegalArgumentException if {@code mapKeyAnnotationType} is not an annotation type or
+   *     has more than one member, or if its single member is an array
+   * @throws NoSuchElementException if the annotation has no members
    */
-  public static TypeElement getKeyTypeElement(AnnotationMirror mapKey, final Elements elements) {
-    Map<? extends ExecutableElement, ? extends AnnotationValue> map = mapKey.getElementValues();
-    // TODO(user) Support literals other than String and Enum
-    AnnotationValueVisitor<TypeElement, Void> mapKeyVisitor =
-        new SimpleAnnotationValueVisitor6<TypeElement, Void>() {
+  public static DeclaredType getUnwrappedMapKeyType(
+      final DeclaredType mapKeyAnnotationType, final Types types) {
+    checkArgument(
+        MoreTypes.asTypeElement(mapKeyAnnotationType).getKind() == ElementKind.ANNOTATION_TYPE,
+        "%s is not an annotation type",
+        mapKeyAnnotationType);
+
+    final ExecutableElement onlyElement =
+        getOnlyElement(methodsIn(mapKeyAnnotationType.asElement().getEnclosedElements()));
+
+    SimpleTypeVisitor6<DeclaredType, Void> keyTypeElementVisitor =
+        new SimpleTypeVisitor6<DeclaredType, Void>() {
+
           @Override
-          public TypeElement visitEnumConstant(VariableElement c, Void p) {
-            return MoreElements.asType(c.getEnclosingElement()) ;
+          public DeclaredType visitArray(ArrayType t, Void p) {
+            throw new IllegalArgumentException(
+                mapKeyAnnotationType + "." + onlyElement.getSimpleName() + " cannot be an array");
           }
 
           @Override
-          public TypeElement visitString(String s, Void p) {
-            return elements.getTypeElement(String.class.getCanonicalName());
+          public DeclaredType visitPrimitive(PrimitiveType t, Void p) {
+            return MoreTypes.asDeclared(types.boxedClass(t).asType());
           }
 
           @Override
-          protected TypeElement defaultAction(Object o, Void v) {
-            throw new IllegalStateException(
-                "Non-supported key type for map binding " + o.getClass().getCanonicalName());
+          public DeclaredType visitDeclared(DeclaredType t, Void p) {
+            return t;
           }
         };
-    TypeElement keyTypeElement =
-        Iterables.getOnlyElement(map.entrySet()).getValue().accept(mapKeyVisitor, null);
-    return keyTypeElement;
+    return keyTypeElementVisitor.visit(onlyElement.getReturnType());
   }
 
   /**
-   * Returns the name of the generated class that contains the static {@code create} method for a
-   * {@code @MapKey} annotation type.
+   * Returns the name of the generated class that contains the static {@code create} methods for a
+   * {@link MapKey} annotation type.
    */
   public static ClassName getMapKeyCreatorClassName(TypeElement mapKeyType) {
     ClassName enclosingClassName = ClassName.fromTypeElement(mapKeyType);
@@ -205,8 +218,11 @@ static boolean componentCanMakeNewInstances(TypeElement typeElement) {
     return ImmutableList.copyOf(methods);
   }
 
-  private static void findLocalAndInheritedMethodsRecursive(TypeElement objectType,
-      Elements elements, TypeElement type, List<ExecutableElement> methods) {
+  private static void findLocalAndInheritedMethodsRecursive(
+      TypeElement objectType,
+      Elements elements,
+      TypeElement type,
+      List<ExecutableElement> methods) {
     if (objectType.equals(type)) {
       return;
     }
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
index 74f33aeaa..cf5a94a2f 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -144,9 +144,9 @@ public void mapBindingsWithEnumKey() {
         "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
         "    this.mapOfPathEnumAndProviderOfHandlerProvider =",
         "        MapProviderFactory.<PathEnum, Handler>builder(2)",
-        "            .put(test.PathEnum.ADMIN,",
+        "            .put(PathEnum.ADMIN,",
         "                mapOfPathEnumAndProviderOfHandlerContribution1)",
-        "            .put(test.PathEnum.LOGIN,",
+        "            .put(PathEnum.LOGIN,",
         "                mapOfPathEnumAndProviderOfHandlerContribution2)",
         "            .build();",
         "  }",
@@ -477,8 +477,10 @@ public void mapBindingsWithWrappedKey() {
         "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
         "    this.mapOfClassKeyAndProviderOfHandlerProvider =",
         "        MapProviderFactory.<ClassKey, Handler>builder(2)",
-        "            .put(ClassKeyCreator.create(Integer.class), mapOfClassKeyAndProviderOfHandlerContribution1)",
-        "            .put(ClassKeyCreator.create(Long.class), mapOfClassKeyAndProviderOfHandlerContribution2)",
+        "            .put(ClassKeyCreator.createClassKey(Integer.class),",
+        "                mapOfClassKeyAndProviderOfHandlerContribution1)",
+        "            .put(ClassKeyCreator.createClassKey(Long.class),",
+        "                mapOfClassKeyAndProviderOfHandlerContribution2)",
         "            .build();",
         "  }",
         "",
@@ -647,9 +649,9 @@ public void mapBindingsWithNonProviderValue() {
         "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
         "    this.mapOfPathEnumAndProviderOfHandlerProvider =",
         "        MapProviderFactory.<PathEnum, Handler>builder(2)",
-        "            .put(test.PathEnum.ADMIN,",
+        "            .put(PathEnum.ADMIN,",
         "                mapOfPathEnumAndProviderOfHandlerContribution1)",
-        "            .put(test.PathEnum.LOGIN,",
+        "            .put(PathEnum.LOGIN,",
         "                mapOfPathEnumAndProviderOfHandlerContribution2)",
         "            .build();",
         "    this.mapOfPathEnumAndHandlerProvider =",
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
index b003a4fef..531ae722b 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
@@ -55,10 +55,10 @@ public void mapKeyCreatorFile() {
         "import javax.annotation.Generated;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public class PathKeyCreator {",
+        "public final class PathKeyCreator {",
         "  @com.google.auto.value.AutoAnnotation",
-        "  public static PathKey create(PathEnum value, String relativePath) {",
-        "    return new AutoAnnotation_PathKeyCreator_create(value, relativePath);",
+        "  public static PathKey createPathKey(PathEnum value, String relativePath) {",
+        "    return new AutoAnnotation_PathKeyCreator_createPathKey(value, relativePath);",
         "  }",
         "}");
     assert_().about(javaSources())
@@ -102,10 +102,11 @@ public void nestedMapKeyCreatorFile() {
             "import test.Container.PathKey",
             "",
             "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-            "public class Container$PathKeyCreator {",
+            "public final class Container$PathKeyCreator {",
             "  @com.google.auto.value.AutoAnnotation",
-            "  public static PathKey create(PathEnum value, String relativePath) {",
-            "    return new AutoAnnotation_Container$PathKeyCreator_create(value, relativePath);",
+            "  public static PathKey createPathKey(PathEnum value, String relativePath) {",
+            "    return new AutoAnnotation_Container$PathKeyCreator_createPathKey(",
+            "        value, relativePath);",
             "  }",
             "}");
     assert_().about(javaSources())
@@ -231,9 +232,9 @@ public void mapKeyComponentFileWithDisorderedKeyField() {
         "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
         "    this.mapOfPathKeyAndProviderOfHandlerProvider =",
         "        MapProviderFactory.<PathKey, Handler>builder(2)",
-        "            .put(PathKeyCreator.create(PathEnum.ADMIN, \"AdminPath\"),",
+        "            .put(PathKeyCreator.createPathKey(PathEnum.ADMIN, \"AdminPath\"),",
         "                mapOfPathKeyAndProviderOfHandlerContribution1)",
-        "            .put(PathKeyCreator.create(PathEnum.LOGIN, \"LoginPath\"),",
+        "            .put(PathKeyCreator.createPathKey(PathEnum.LOGIN, \"LoginPath\"),",
         "                mapOfPathKeyAndProviderOfHandlerContribution2)",
         "            .build();",
         "  }",
@@ -405,9 +406,9 @@ public void mapKeyComponentFileWithDefaultField() {
         "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
         "    this.mapOfPathKeyAndProviderOfHandlerProvider =",
         "        MapProviderFactory.<PathKey, Handler>builder(2)",
-        "            .put(PathKeyCreator.create(PathEnum.ADMIN, \"DefaultPath\"),",
+        "            .put(PathKeyCreator.createPathKey(PathEnum.ADMIN, \"DefaultPath\"),",
         "                mapOfPathKeyAndProviderOfHandlerContribution1)",
-        "            .put(PathKeyCreator.create(PathEnum.LOGIN, \"LoginPath\"),",
+        "            .put(PathKeyCreator.createPathKey(PathEnum.LOGIN, \"LoginPath\"),",
         "                mapOfPathKeyAndProviderOfHandlerContribution2)",
         "            .build();",
         "  }",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index 0ec5f8083..1eeda25e3 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -44,7 +44,7 @@
   private final JavaFileObject NULLABLE = JavaFileObjects.forSourceLines("test.Nullable",
       "package test;",
       "public @interface Nullable {}");
-  
+
   private static final StringLiteral NPE_LITERAL =
       StringLiteral.forValue(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
 
@@ -890,7 +890,7 @@ public void publicModuleNonPublicIncludes() {
             + "test.NonPublicModule1 and test.NonPublicModule2 public.")
         .in(publicModuleFile).onLine(8);
   }
-  
+
   @Test
   public void genericSubclassedModule() {
     JavaFileObject parent = JavaFileObjects.forSourceLines("test.ParentModule",
@@ -944,40 +944,40 @@ public void genericSubclassedModule() {
         "}");
     JavaFileObject listBFactory = JavaFileObjects.forSourceLines(
         "test.ParentModule_ProvidesListBFactory",
-        "package test;", 
-        "", 
+        "package test;",
+        "",
         "import dagger.internal.Factory;",
-        "import java.util.List;", 
-        "import javax.annotation.Generated;", 
-        "import javax.inject.Provider;", 
-        "", 
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")", 
+        "import java.util.List;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class ParentModule_ProvideListBFactory<A extends CharSequence,",
-        "    B, C extends Number & Comparable<C>> implements Factory<List<B>> {", 
-        "  private final ParentModule<A, B, C> module;", 
-        "  private final Provider<B> bProvider;", 
-        "", 
+        "    B, C extends Number & Comparable<C>> implements Factory<List<B>> {",
+        "  private final ParentModule<A, B, C> module;",
+        "  private final Provider<B> bProvider;",
+        "",
         "  public ParentModule_ProvideListBFactory(",
-        "        ParentModule<A, B, C> module, Provider<B> bProvider) {", 
-        "    assert module != null;", 
-        "    this.module = module;", 
-        "    assert bProvider != null;", 
-        "    this.bProvider = bProvider;", 
-        "  }", 
-        "", 
-        "  @Override", 
-        "  public List<B> get() {  ", 
+        "        ParentModule<A, B, C> module, Provider<B> bProvider) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "    assert bProvider != null;",
+        "    this.bProvider = bProvider;",
+        "  }",
+        "",
+        "  @Override",
+        "  public List<B> get() {  ",
         "    List<B> provided = module.provideListB(bProvider.get());",
         "    if (provided == null) {",
         "      throw new NullPointerException(" + NPE_LITERAL + ");",
         "    }",
-        "    return provided;", 
-        "  }", 
-        "", 
+        "    return provided;",
+        "  }",
+        "",
         "  public static <A extends CharSequence, B, C extends Number & Comparable<C>>",
         "      Factory<List<B>> create(ParentModule<A, B, C> module, Provider<B> bProvider) {",
-        "    return new ParentModule_ProvideListBFactory<A, B, C>(module, bProvider);", 
-        "  }", 
+        "    return new ParentModule_ProvideListBFactory<A, B, C>(module, bProvider);",
+        "  }",
         "}");
     JavaFileObject numberFactory = JavaFileObjects.forSourceLines(
         "test.ChildNumberModule_ProvideNumberFactory",
diff --git a/core/src/main/java/dagger/MapKey.java b/core/src/main/java/dagger/MapKey.java
index fcde154ce..3ebd13b31 100644
--- a/core/src/main/java/dagger/MapKey.java
+++ b/core/src/main/java/dagger/MapKey.java
@@ -19,19 +19,20 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
+import java.util.Map;
 
 import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
  * Identifies annotation types that are used to associate keys with values returned by
- * {@linkplain Provides provider methods} in order to compose a {@linkplain Provides#Type#MAP map}.
+ * {@linkplain Provides provider methods} in order to compose a {@linkplain Provides.Type#MAP map}.
  *
  * <p>Every provider method annotated with {@code @Provides(type = MAP)} must also have an
  * annotation that identifies the key for that map entry. That annotation's type must be annotated
  * with {@code @MapKey}.
  *
- * <p>Typically, the key annotation has a single member element, whose value is used as the map key.
+ * <p>Typically, the key annotation has a single member, whose value is used as the map key.
  *
  * <p>For example, to add an entry to a {@code Map<String, Integer>} with key "foo", you could use
  * an annotation called {@code @StringKey}:
@@ -59,9 +60,8 @@
  * }
  * </code></pre>
  *
- * <p><b>Note:</b> Until <a href=http://github.com/google/dagger/issues/144>issue 144</a> is fixed,
- * if {@code unwrapValue} is true, the annotation's single element must be a {@code String} or
- * enumerated type.
+ * <p>If {@code unwrapValue} is true, the annotation's single member can be any type except an
+ * array.
  *
  * <h2>Annotations as keys</h2>
  *
@@ -93,7 +93,7 @@
  * </code></pre>
  *
  * <p>(Note that there must be a class {@code MyMapKeyImpl} that implements {@code MyMapKey} in
- * order to call {@link Map#get()} on the provided map.)
+ * order to call {@link Map#get(Object)} on the provided map.)
  */
 @Documented
 @Target(ANNOTATION_TYPE)
@@ -101,11 +101,10 @@
 @Beta
 public @interface MapKey {
   /**
-   * True to use the value of the single element of the annotated annotation as the map key; false
+   * True to use the value of the single member of the annotated annotation as the map key; false
    * to use the annotation instance as the map key.
    *
-   * <p>Until <a href=http://github.com/google/dagger/issues/144>issue 144</a> is fixed, if true
-   * the single element must be a {@code String} or an enumerated type.
+   * <p>If true, the single member must not be an array.
    */
   boolean unwrapValue() default true;
 }
