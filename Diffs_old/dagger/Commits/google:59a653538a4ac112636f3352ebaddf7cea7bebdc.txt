diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index d0206a3e6..18b6af73b 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -337,6 +337,7 @@ java_library(
     srcs = [
         "BindingGraphValidationModule.java",
         "BindingMethodValidatorsModule.java",
+        "ComponentCreatorImplementationFactory.java",
         "ComponentGenerator.java",
         "ComponentHjarProcessingStep.java",
         "ComponentImplementationBuilder.java",
diff --git a/java/dagger/internal/codegen/ComponentCreatorImplementation.java b/java/dagger/internal/codegen/ComponentCreatorImplementation.java
index 89ea77562..45340ca89 100644
--- a/java/dagger/internal/codegen/ComponentCreatorImplementation.java
+++ b/java/dagger/internal/codegen/ComponentCreatorImplementation.java
@@ -16,379 +16,33 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.base.Preconditions.checkState;
-import static com.google.common.collect.Iterables.getOnlyElement;
-import static com.squareup.javapoet.MethodSpec.constructorBuilder;
-import static com.squareup.javapoet.MethodSpec.methodBuilder;
-import static com.squareup.javapoet.TypeSpec.classBuilder;
-import static dagger.internal.codegen.ModuleProxies.newModuleInstance;
-import static dagger.internal.codegen.SourceFiles.simpleVariableName;
-import static dagger.internal.codegen.TypeSpecs.addSupertype;
-import static javax.lang.model.element.Modifier.ABSTRACT;
-import static javax.lang.model.element.Modifier.FINAL;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.PROTECTED;
-import static javax.lang.model.element.Modifier.PUBLIC;
-import static javax.lang.model.element.Modifier.STATIC;
-import static javax.lang.model.type.TypeKind.VOID;
-
+import com.google.auto.value.AutoValue;
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Maps;
-import com.google.common.collect.Sets;
 import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.CodeBlock;
-import com.squareup.javapoet.FieldSpec;
-import com.squareup.javapoet.MethodSpec;
-import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
-import dagger.internal.Preconditions;
-import java.util.Optional;
-import javax.inject.Inject;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.TypeMirror;
 
 /** The implementation of a component creator type. */
-final class ComponentCreatorImplementation {
-  private final TypeSpec componentCreatorClass;
-  private final ClassName name;
-  private final ImmutableMap<ComponentRequirement, FieldSpec> builderFields;
+@AutoValue
+abstract class ComponentCreatorImplementation {
 
-  private ComponentCreatorImplementation(
+  /** Creates a new {@link ComponentCreatorImplementation}. */
+  static ComponentCreatorImplementation create(
       TypeSpec componentCreatorClass,
       ClassName name,
-      ImmutableMap<ComponentRequirement, FieldSpec> builderFields) {
-    this.componentCreatorClass = componentCreatorClass;
-    this.name = name;
-    this.builderFields = builderFields;
-  }
-
-  TypeSpec componentCreatorClass() {
-    return componentCreatorClass;
-  }
-
-  ClassName name() {
-    return name;
+      ImmutableMap<ComponentRequirement, String> requirementNames) {
+    return new AutoValue_ComponentCreatorImplementation(
+        componentCreatorClass, name, requirementNames);
   }
 
-  ImmutableMap<ComponentRequirement, FieldSpec> builderFields() {
-    return builderFields;
-  }
-
-  /** Factory for {@link ComponentCreatorImplementation} instances. */
-  static final class Factory {
-    // TODO(cgdecker): Possibly extract this to another top-level type,
-    // ComponentCreatorImplementationFactory, to match the separation between
-    // ComponentImplementation and ComponentImplementationFactory
-
-    static final String NOOP_BUILDER_METHOD_JAVADOC =
-        "This module is declared, but an instance is not used in the component. This method is a "
-            + "no-op. For more, see https://google.github.io/dagger/unused-modules.\n";
-
-    private final DaggerElements elements;
-    private final DaggerTypes types;
-
-    @Inject
-    Factory(DaggerElements elements, DaggerTypes types) {
-      this.elements = elements;
-      this.types = types;
-    }
-
-    Optional<ComponentCreatorImplementation> create(
-        ComponentImplementation componentImplementation, BindingGraph bindingGraph) {
-      if (!bindingGraph.componentDescriptor().hasCreator()) {
-        return Optional.empty();
-      }
-      if (componentImplementation.superclassImplementation().isPresent()
-          && componentImplementation.isAbstract()) {
-        // The component builder in ahead-of-time mode is generated with the base subcomponent
-        // implementation, with the exception of the build method since that requires invoking the
-        // constructor of a subclass component implementation. Intermediate component
-        // implementations, because they still can't invoke the eventual constructor and have no
-        // additional extensions to the builder, can ignore generating a builder implementation.
-        return Optional.empty();
-      }
-      return Optional.of(new Builder(componentImplementation, bindingGraph).build());
-    }
-
-    private final class Builder {
-      final BindingGraph graph;
-      final TypeSpec.Builder componentCreatorClass;
-      final ComponentImplementation componentImplementation;
-
-      Builder(ComponentImplementation componentImplementation, BindingGraph graph) {
-        this.componentImplementation = componentImplementation;
-        this.componentCreatorClass = classBuilder(componentImplementation.getCreatorName());
-        this.graph = graph;
-      }
-
-      ComponentCreatorImplementation build() {
-        if (!componentImplementation.isNested()) {
-          componentCreatorClass.addModifiers(STATIC);
-        }
-        if (creatorDescriptor().isPresent()) {
-          if (componentImplementation.isAbstract()) {
-            // The component creator class of a top-level component implementation in ahead-of-time
-            // subcomponents mode must be public, not protected, because the creator's subclass will
-            // be a sibling of the component subclass implementation, not nested.
-            componentCreatorClass.addModifiers(
-                componentImplementation.isNested() ? PROTECTED : PUBLIC);
-          } else {
-            componentCreatorClass.addModifiers(PRIVATE);
-          }
-          setSupertype();
-        } else {
-          componentCreatorClass
-              .addModifiers(PUBLIC)
-              .addMethod(constructorBuilder().addModifiers(PRIVATE).build());
-        }
-
-        ImmutableMap<ComponentRequirement, FieldSpec> builderFields = builderFields();
-
-        if (componentImplementation.isAbstract()) {
-          componentCreatorClass.addModifiers(ABSTRACT);
-        } else {
-          componentCreatorClass.addModifiers(FINAL);
-          componentCreatorClass.addMethod(factoryMethod(builderFields));
-        }
-
-        if (!componentImplementation.baseImplementation().isPresent()) {
-          componentCreatorClass.addFields(builderFields.values());
-        }
+  /** The type for the creator implementation. */
+  abstract TypeSpec componentCreatorClass();
 
-        // TODO(ronshapiro): this should be switched with factoryMethod(), but that currently breaks
-        // compile-testing tests that rely on the order of the methods
-        componentCreatorClass.addMethods(builderMethods(builderFields));
+  /** The name of the creator implementation class. */
+  abstract ClassName name();
 
-        return new ComponentCreatorImplementation(
-            componentCreatorClass.build(), componentImplementation.getCreatorName(), builderFields);
-      }
-
-      /** Set the superclass being extended or interface being implemented for this creator. */
-      void setSupertype() {
-        if (componentImplementation.baseImplementation().isPresent()) {
-          // If there's a superclass, extend the creator defined there.
-          componentCreatorClass.superclass(
-              componentImplementation.baseImplementation().get().getCreatorName());
-        } else {
-          addSupertype(componentCreatorClass, creatorDescriptor().get().typeElement());
-        }
-      }
-
-      /**
-       * Computes fields for each of the {@link ComponentRequirement}s}. Regardless of creator spec,
-       * there is always one field per requirement.
-       *
-       * <p>If the base implementation's creator is being generated in ahead-of-time-subcomponents
-       * mode, this uses {@link BindingGraph#possiblyNecessaryRequirements()} since Dagger doesn't
-       * know what modules may end up being unused. Otherwise, we use the {@link
-       * BindingGraph#componentRequirements() necessary component requirements}.
-       */
-      ImmutableMap<ComponentRequirement, FieldSpec> builderFields() {
-        if (componentImplementation.baseImplementation().isPresent()) {
-          // If there's a base implementation, retain the same names of the builder fields, but
-          // filter for currently used component requirements.
-          ComponentCreatorImplementation baseCreatorImplementation =
-              componentImplementation.baseImplementation().get().creatorImplementation().get();
-          return ImmutableMap.copyOf(
-              Maps.filterKeys(
-                  baseCreatorImplementation.builderFields(), componentRequirements()::contains));
-        }
-
-        UniqueNameSet fieldNames = new UniqueNameSet();
-        ImmutableMap.Builder<ComponentRequirement, FieldSpec> builderFields =
-            ImmutableMap.builder();
-        Modifier modifier = componentImplementation.isAbstract() ? PUBLIC : PRIVATE;
-        for (ComponentRequirement componentRequirement : componentRequirements()) {
-          String name = fieldNames.getUniqueName(componentRequirement.variableName());
-          builderFields.put(
-              componentRequirement,
-              FieldSpec.builder(TypeName.get(componentRequirement.type()), name, modifier).build());
-        }
-        return builderFields.build();
-      }
-
-      MethodSpec factoryMethod(ImmutableMap<ComponentRequirement, FieldSpec> builderFields) {
-        MethodSpec.Builder factoryMethod;
-        if (creatorDescriptor().isPresent()) {
-          ExecutableElement factoryMethodElement = creatorDescriptor().get().factoryMethod();
-          // Note: we don't use the factoryMethodElement.getReturnType() as the return type
-          // because it might be a type variable.  We make use of covariant returns to allow
-          // us to return the component type, which will always be valid.
-          factoryMethod =
-              methodBuilder(factoryMethodElement.getSimpleName().toString())
-                  .addAnnotation(Override.class);
-        } else {
-          factoryMethod = methodBuilder("build");
-        }
-        factoryMethod.returns(ClassName.get(graph.componentTypeElement())).addModifiers(PUBLIC);
-
-        builderFields.forEach(
-            (requirement, field) -> {
-              switch (requirement.nullPolicy(elements, types)) {
-                case NEW:
-                  checkState(requirement.kind().isModule());
-                  factoryMethod
-                      .beginControlFlow("if ($N == null)", field)
-                      .addStatement(
-                          "this.$N = $L",
-                          field,
-                          newModuleInstance(
-                              requirement.typeElement(), componentImplementation.name(), elements))
-                      .endControlFlow();
-                  break;
-                case THROW:
-                  // TODO(cgdecker,ronshapiro): ideally this should use the key instead of a class
-                  // for @BindsInstance requirements, but that's not easily proguardable.
-                  factoryMethod.addStatement(
-                      "$T.checkBuilderRequirement($N, $T.class)",
-                      Preconditions.class,
-                      field,
-                      TypeNames.rawTypeName(field.type));
-                  break;
-                case ALLOW:
-                  break;
-                default:
-                  throw new AssertionError(requirement);
-              }
-            });
-        factoryMethod.addStatement("return new $T(this)", componentImplementation.name());
-        return factoryMethod.build();
-      }
-
-      /**
-       * Computes the methods that set each of parameters on the builder. If the {@link
-       * ComponentCreatorDescriptor} is present, it will tailor the methods to match the descriptor.
-       */
-      ImmutableSet<MethodSpec> builderMethods(
-          ImmutableMap<ComponentRequirement, FieldSpec> builderFields) {
-        ImmutableSet<ComponentRequirement> componentRequirements = componentRequirements();
-        ImmutableSet.Builder<MethodSpec> methods = ImmutableSet.builder();
-        // TODO(ronshapiro): extract two separate methods: builderMethodsForBuilderSpec and
-        // builderMethodsForGeneratedTopLevelComponentBuilder()
-        if (creatorDescriptor().isPresent()) {
-          // In ahead-of-time subcomponents mode, all builder methods are defined at the base
-          // implementation. The only case where a method needs to be overridden is for a repeated
-          // module, which is unknown at the point when a base implementation is generated. We do
-          // this at the root for simplicity (and as an aside, repeated modules are never used in
-          // google as of 11/28/18, and thus the additional cost of including these methods at the
-          // root is negligible).
-          boolean hasBaseCreatorImplementation =
-              !componentImplementation.isAbstract()
-                  && componentImplementation.baseImplementation().isPresent();
-
-          UniqueNameSet parameterNames = new UniqueNameSet();
-          ComponentCreatorDescriptor creatorDescriptor = creatorDescriptor().get();
-          for (ComponentRequirement requirement : creatorDescriptor.requirements()) {
-            ExecutableElement method = creatorDescriptor.elementForRequirement(requirement);
-            MethodSpec.Builder builderMethod = addBuilderMethodFromSpec(method);
-            VariableElement parameterElement = getOnlyElement(method.getParameters());
-            String parameterName = parameterNames.getUniqueName(parameterElement.getSimpleName());
-
-            TypeName argType =
-                parameterElement.asType().getKind().isPrimitive()
-                    // Primitives need to use the original (unresolved) type to avoid boxing.
-                    ? TypeName.get(parameterElement.asType())
-                    // Otherwise we use the full resolved type.
-                    : TypeName.get(requirement.type());
-
-            builderMethod.addParameter(argType, parameterName);
-
-            if (componentRequirements.contains(requirement)) {
-              if (hasBaseCreatorImplementation) {
-                continue;
-              }
-              // required type
-              builderMethod.addStatement(
-                  "this.$N = $L",
-                  builderFields.get(requirement),
-                  requirement
-                          .nullPolicy(elements, types)
-                          .equals(ComponentRequirement.NullPolicy.ALLOW)
-                      ? parameterName
-                      : CodeBlock.of("$T.checkNotNull($L)", Preconditions.class, parameterName));
-              addBuilderMethodReturnStatementForSpec(method, builderMethod);
-            } else if (graph.ownedModuleTypes().contains(requirement.typeElement())) {
-              if (hasBaseCreatorImplementation) {
-                continue;
-              }
-              // owned, but not required
-              builderMethod.addJavadoc(NOOP_BUILDER_METHOD_JAVADOC);
-              addBuilderMethodReturnStatementForSpec(method, builderMethod);
-            } else {
-              // neither owned nor required, so it must be an inherited module
-              builderMethod.addStatement(
-                  "throw new $T($T.format($S, $T.class.getCanonicalName()))",
-                  UnsupportedOperationException.class,
-                  String.class,
-                  "%s cannot be set because it is inherited from the enclosing component",
-                  TypeNames.rawTypeName(TypeName.get(requirement.type())));
-            }
-
-            methods.add(builderMethod.build());
-          }
-        } else {
-          for (ComponentRequirement requirement :
-              graph.componentDescriptor().dependenciesAndConcreteModules()) {
-            String componentRequirementName = simpleVariableName(requirement.typeElement());
-            MethodSpec.Builder builderMethod =
-                methodBuilder(componentRequirementName)
-                    .returns(componentImplementation.getCreatorName())
-                    .addModifiers(PUBLIC)
-                    .addParameter(TypeName.get(requirement.type()), componentRequirementName);
-            if (componentRequirements.contains(requirement)) {
-              builderMethod.addStatement(
-                  "this.$N = $T.checkNotNull($L)",
-                  builderFields.get(requirement),
-                  Preconditions.class,
-                  componentRequirementName);
-            } else {
-              builderMethod.addStatement(
-                  "$T.checkNotNull($L)", Preconditions.class, componentRequirementName);
-              builderMethod.addJavadoc("@deprecated " + NOOP_BUILDER_METHOD_JAVADOC);
-              builderMethod.addAnnotation(Deprecated.class);
-            }
-            builderMethod.addStatement("return this");
-            methods.add(builderMethod.build());
-          }
-        }
-        return methods.build();
-      }
-
-      private ImmutableSet<ComponentRequirement> componentRequirements() {
-        return !componentImplementation.superclassImplementation().isPresent()
-                && componentImplementation.isAbstract()
-            ? graph.possiblyNecessaryRequirements()
-            : graph.componentRequirements();
-      }
-
-      MethodSpec.Builder addBuilderMethodFromSpec(ExecutableElement method) {
-        TypeMirror returnType = method.getReturnType();
-        MethodSpec.Builder builderMethod =
-            methodBuilder(method.getSimpleName().toString())
-                .addAnnotation(Override.class)
-                .addModifiers(Sets.difference(method.getModifiers(), ImmutableSet.of(ABSTRACT)));
-        // If the return type is void, we add a method with the void return type.
-        // Otherwise we use the generated builder name and take advantage of covariant returns
-        // (so that we don't have to worry about setter methods that return type variables).
-        if (!returnType.getKind().equals(VOID)) {
-          builderMethod.returns(componentImplementation.getCreatorName());
-        }
-        return builderMethod;
-      }
-
-      void addBuilderMethodReturnStatementForSpec(
-          ExecutableElement specMethod, MethodSpec.Builder builderMethod) {
-        if (!specMethod.getReturnType().getKind().equals(VOID)) {
-          builderMethod.addStatement("return this");
-        }
-      }
-
-      Optional<ComponentCreatorDescriptor> creatorDescriptor() {
-        return graph.componentDescriptor().creatorDescriptor();
-      }
-    }
-  }
+  /**
+   * The names to use for fields or parameters for the requirements this creator implementation
+   * provides.
+   */
+  abstract ImmutableMap<ComponentRequirement, String> requirementNames();
 }
diff --git a/java/dagger/internal/codegen/ComponentCreatorImplementationFactory.java b/java/dagger/internal/codegen/ComponentCreatorImplementationFactory.java
new file mode 100644
index 000000000..3d23f588d
--- /dev/null
+++ b/java/dagger/internal/codegen/ComponentCreatorImplementationFactory.java
@@ -0,0 +1,365 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
+import static dagger.internal.codegen.ModuleProxies.newModuleInstance;
+import static dagger.internal.codegen.SourceFiles.simpleVariableName;
+import static dagger.internal.codegen.TypeSpecs.addSupertype;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PROTECTED;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
+import static javax.lang.model.type.TypeKind.VOID;
+
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import dagger.internal.Preconditions;
+import java.util.Optional;
+import javax.inject.Inject;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+
+/** Factory for creating {@link ComponentCreatorImplementation} instances. */
+final class ComponentCreatorImplementationFactory {
+  private static final String NOOP_BUILDER_METHOD_JAVADOC =
+      "This module is declared, but an instance is not used in the component. This method is a "
+          + "no-op. For more, see https://google.github.io/dagger/unused-modules.\n";
+
+  private final DaggerElements elements;
+  private final DaggerTypes types;
+
+  @Inject
+  ComponentCreatorImplementationFactory(DaggerElements elements, DaggerTypes types) {
+    this.elements = elements;
+    this.types = types;
+  }
+
+  /** Returns a new creator implementation for the given component, if necessary. */
+  Optional<ComponentCreatorImplementation> create(ComponentImplementation componentImplementation) {
+    if (!componentImplementation.graph().componentDescriptor().hasCreator()) {
+      return Optional.empty();
+    }
+
+    if (componentImplementation.superclassImplementation().isPresent()
+        && componentImplementation.isAbstract()) {
+      // The component builder in ahead-of-time mode is generated with the base subcomponent
+      // implementation, with the exception of the build method since that requires invoking the
+      // constructor of a subclass component implementation. Intermediate component implementations,
+      // because they still can't invoke the eventual constructor and have no additional extensions
+      // to the builder, can ignore generating a builder implementation.
+      return Optional.empty();
+    }
+
+    return Optional.of(new Builder(componentImplementation).build());
+  }
+
+  private static ImmutableMap<ComponentRequirement, String> requirementNames(
+      ComponentImplementation componentImplementation) {
+    // If the base implementation's creator is being generated in ahead-of-time-subcomponents
+    // mode, this uses possiblyNecessaryRequirements() since Dagger doesn't know what modules may
+    // end up being unused. Otherwise, we use the necessary component requirements.
+    ImmutableSet<ComponentRequirement> requirements =
+        componentImplementation.isAbstract()
+                && !componentImplementation.superclassImplementation().isPresent()
+            ? componentImplementation.graph().possiblyNecessaryRequirements()
+            : componentImplementation.graph().componentRequirements();
+
+    if (componentImplementation.baseImplementation().isPresent()) {
+      // If there's a base implementation, retain the same names for the requirements, but filter
+      // for currently used component requirements.
+      ComponentCreatorImplementation baseCreatorImplementation =
+          componentImplementation.baseImplementation().get().creatorImplementation().get();
+      return ImmutableMap.copyOf(
+          Maps.filterKeys(baseCreatorImplementation.requirementNames(), requirements::contains));
+    }
+
+    UniqueNameSet names = new UniqueNameSet();
+    return Maps.toMap(requirements, requirement -> names.getUniqueName(requirement.variableName()));
+  }
+
+  private final class Builder {
+    final ComponentImplementation componentImplementation;
+    final BindingGraph graph;
+    final TypeSpec.Builder componentCreatorClass;
+    final ImmutableMap<ComponentRequirement, String> requirementNames;
+    final ImmutableSet<ComponentRequirement> requirements;
+
+    Builder(ComponentImplementation componentImplementation) {
+      this.componentImplementation = componentImplementation;
+      this.graph = componentImplementation.graph();
+      this.componentCreatorClass = classBuilder(componentImplementation.getCreatorName());
+      this.requirementNames = requirementNames(componentImplementation);
+      this.requirements = requirementNames.keySet();
+    }
+
+    ComponentCreatorImplementation build() {
+      if (!componentImplementation.isNested()) {
+        componentCreatorClass.addModifiers(STATIC);
+      }
+      if (creatorDescriptor().isPresent()) {
+        if (componentImplementation.isAbstract()) {
+          // The component creator class of a top-level component implementation in ahead-of-time
+          // subcomponents mode must be public, not protected, because the creator's subclass will
+          // be a sibling of the component subclass implementation, not nested.
+          componentCreatorClass.addModifiers(
+              componentImplementation.isNested() ? PROTECTED : PUBLIC);
+        } else {
+          componentCreatorClass.addModifiers(PRIVATE);
+        }
+        setSupertype();
+      } else {
+        componentCreatorClass
+            .addModifiers(PUBLIC)
+            .addMethod(constructorBuilder().addModifiers(PRIVATE).build());
+      }
+
+      if (componentImplementation.isAbstract()) {
+        componentCreatorClass.addModifiers(ABSTRACT);
+      } else {
+        componentCreatorClass.addModifiers(FINAL);
+        componentCreatorClass.addMethod(factoryMethod());
+      }
+
+      if (!componentImplementation.baseImplementation().isPresent()) {
+        requirements.stream().map(this::toFieldSpec).forEach(componentCreatorClass::addField);
+      }
+
+      // TODO(ronshapiro): this should be switched with factoryMethod(), but that currently breaks
+      // compile-testing tests that rely on the order of the methods
+      componentCreatorClass.addMethods(setterMethods());
+
+      return ComponentCreatorImplementation.create(
+          componentCreatorClass.build(),
+          componentImplementation.getCreatorName(),
+          requirementNames);
+    }
+
+    /** Set the superclass being extended or interface being implemented for this creator. */
+    void setSupertype() {
+      if (componentImplementation.baseImplementation().isPresent()) {
+        // If there's a superclass, extend the creator defined there.
+        componentCreatorClass.superclass(
+            componentImplementation.baseImplementation().get().getCreatorName());
+      } else {
+        addSupertype(componentCreatorClass, creatorDescriptor().get().typeElement());
+      }
+    }
+
+    FieldSpec toFieldSpec(ComponentRequirement requirement) {
+      Modifier modifier = componentImplementation.isAbstract() ? PUBLIC : PRIVATE;
+      return FieldSpec.builder(
+              TypeName.get(requirement.type()), requirementNames.get(requirement), modifier)
+          .build();
+    }
+
+    CodeBlock parametersCodeBlock() {
+      return requirements.stream()
+          .map(requirement -> CodeBlock.of("$L", requirementNames.get(requirement)))
+          .collect(toParametersCodeBlock());
+    }
+
+    MethodSpec factoryMethod() {
+      MethodSpec.Builder factoryMethod;
+      if (creatorDescriptor().isPresent()) {
+        ExecutableElement factoryMethodElement = creatorDescriptor().get().factoryMethod();
+        // Note: we don't use the factoryMethodElement.getReturnType() as the return type
+        // because it might be a type variable.  We make use of covariant returns to allow
+        // us to return the component type, which will always be valid.
+        factoryMethod =
+            methodBuilder(factoryMethodElement.getSimpleName().toString())
+                .addAnnotation(Override.class);
+      } else {
+        factoryMethod = methodBuilder("build");
+      }
+      factoryMethod.returns(ClassName.get(graph.componentTypeElement())).addModifiers(PUBLIC);
+
+      requirements.forEach(
+          requirement -> {
+            FieldSpec field = toFieldSpec(requirement);
+            switch (requirement.nullPolicy(elements, types)) {
+              case NEW:
+                checkState(requirement.kind().isModule());
+                factoryMethod
+                    .beginControlFlow("if ($N == null)", field)
+                    .addStatement(
+                        "this.$N = $L",
+                        field,
+                        newModuleInstance(
+                            requirement.typeElement(), componentImplementation.name(), elements))
+                    .endControlFlow();
+                break;
+              case THROW:
+                // TODO(cgdecker,ronshapiro): ideally this should use the key instead of a class for
+                // @BindsInstance requirements, but that's not easily proguardable.
+                factoryMethod.addStatement(
+                    "$T.checkBuilderRequirement($N, $T.class)",
+                    Preconditions.class,
+                    field,
+                    TypeNames.rawTypeName(field.type));
+                break;
+              case ALLOW:
+                break;
+            }
+          });
+      factoryMethod.addStatement(
+          "return new $T($L)", componentImplementation.name(), parametersCodeBlock());
+      return factoryMethod.build();
+    }
+
+    /**
+     * Computes the methods that set each field on the builder. If the {@link
+     * ComponentCreatorDescriptor} is present, it will tailor the methods to match the descriptor.
+     */
+    ImmutableSet<MethodSpec> setterMethods() {
+      ImmutableSet.Builder<MethodSpec> methods = ImmutableSet.builder();
+      // TODO(ronshapiro): extract two separate methods: setterMethodsForBuilderSpec and
+      // setterMethodsForGeneratedTopLevelComponentBuilder()
+      if (creatorDescriptor().isPresent()) {
+        ComponentCreatorDescriptor creatorDescriptor = creatorDescriptor().get();
+
+        // In ahead-of-time subcomponents mode, all builder methods are defined at the base
+        // implementation. The only case where a method needs to be overridden is for a repeated
+        // module, which is unknown at the point when a base implementation is generated. We do this
+        // at the root for simplicity (and as an aside, repeated modules are never used in google
+        // as of 11/28/18, and thus the additional cost of including these methods at the root is
+        // negligible).
+        boolean hasBaseCreatorImplementation =
+            !componentImplementation.isAbstract()
+                && componentImplementation.baseImplementation().isPresent();
+
+        UniqueNameSet parameterNames = new UniqueNameSet();
+        for (ComponentRequirement requirement : creatorDescriptor.requirements()) {
+          ExecutableElement method = creatorDescriptor.elementForRequirement(requirement);
+          MethodSpec.Builder setterMethod = setterMethod(method);
+          VariableElement parameterElement = getOnlyElement(method.getParameters());
+          String parameterName = parameterNames.getUniqueName(parameterElement.getSimpleName());
+
+          TypeName argType =
+              parameterElement.asType().getKind().isPrimitive()
+                  // Primitives need to use the original (unresolved) type to avoid boxing.
+                  ? TypeName.get(parameterElement.asType())
+                  // Otherwise we use the full resolved type.
+                  : TypeName.get(requirement.type());
+
+          setterMethod.addParameter(argType, parameterName);
+
+          if (requirements.contains(requirement)) {
+            if (hasBaseCreatorImplementation) {
+              continue;
+            }
+            // required type
+            setterMethod.addStatement(
+                "this.$N = $L",
+                requirementNames.get(requirement),
+                requirement
+                        .nullPolicy(elements, types)
+                        .equals(ComponentRequirement.NullPolicy.ALLOW)
+                    ? parameterName
+                    : CodeBlock.of("$T.checkNotNull($L)", Preconditions.class, parameterName));
+            addSetterMethodReturnStatementForSpec(method, setterMethod);
+          } else if (graph.ownedModuleTypes().contains(requirement.typeElement())) {
+            if (hasBaseCreatorImplementation) {
+              continue;
+            }
+            // owned, but not required
+            setterMethod.addJavadoc(NOOP_BUILDER_METHOD_JAVADOC);
+            addSetterMethodReturnStatementForSpec(method, setterMethod);
+          } else {
+            // neither owned nor required, so it must be an inherited module
+            setterMethod.addStatement(
+                "throw new $T($T.format($S, $T.class.getCanonicalName()))",
+                UnsupportedOperationException.class,
+                String.class,
+                "%s cannot be set because it is inherited from the enclosing component",
+                TypeNames.rawTypeName(TypeName.get(requirement.type())));
+          }
+
+          methods.add(setterMethod.build());
+        }
+      } else {
+        for (ComponentRequirement requirement :
+            graph.componentDescriptor().dependenciesAndConcreteModules()) {
+          String componentRequirementName = simpleVariableName(requirement.typeElement());
+          MethodSpec.Builder setterMethod =
+              methodBuilder(componentRequirementName)
+                  .returns(componentImplementation.getCreatorName())
+                  .addModifiers(PUBLIC)
+                  .addParameter(TypeName.get(requirement.type()), componentRequirementName);
+          if (requirements.contains(requirement)) {
+            setterMethod.addStatement(
+                "this.$N = $T.checkNotNull($L)",
+                requirementNames.get(requirement),
+                Preconditions.class,
+                componentRequirementName);
+          } else {
+            setterMethod.addStatement(
+                "$T.checkNotNull($L)", Preconditions.class, componentRequirementName);
+            setterMethod.addJavadoc("@deprecated " + NOOP_BUILDER_METHOD_JAVADOC);
+            setterMethod.addAnnotation(Deprecated.class);
+          }
+          setterMethod.addStatement("return this");
+          methods.add(setterMethod.build());
+        }
+      }
+      return methods.build();
+    }
+
+    MethodSpec.Builder setterMethod(ExecutableElement method) {
+      TypeMirror returnType = method.getReturnType();
+      MethodSpec.Builder setterMethod =
+          methodBuilder(method.getSimpleName().toString())
+              .addAnnotation(Override.class)
+              .addModifiers(Sets.difference(method.getModifiers(), ImmutableSet.of(ABSTRACT)));
+      // If the return type is void, we add a method with the void return type.
+      // Otherwise we use the generated builder name and take advantage of covariant returns
+      // (so that we don't have to worry about setter methods that return type variables).
+      if (!returnType.getKind().equals(VOID)) {
+        setterMethod.returns(componentImplementation.getCreatorName());
+      }
+      return setterMethod;
+    }
+
+    void addSetterMethodReturnStatementForSpec(
+        ExecutableElement specMethod, MethodSpec.Builder setterMethod) {
+      if (!specMethod.getReturnType().getKind().equals(VOID)) {
+        setterMethod.addStatement("return this");
+      }
+    }
+
+    Optional<ComponentCreatorDescriptor> creatorDescriptor() {
+      return graph.componentDescriptor().creatorDescriptor();
+    }
+  }
+}
diff --git a/java/dagger/internal/codegen/ComponentImplementation.java b/java/dagger/internal/codegen/ComponentImplementation.java
index e9ea026ca..ce0d4bfce 100644
--- a/java/dagger/internal/codegen/ComponentImplementation.java
+++ b/java/dagger/internal/codegen/ComponentImplementation.java
@@ -26,6 +26,7 @@
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 
+import com.google.auto.value.AutoValue;
 import com.google.common.base.Supplier;
 import com.google.common.collect.HashMultimap;
 import com.google.common.collect.ImmutableList;
@@ -144,7 +145,30 @@
     SUBCOMPONENT
   }
 
-  private final ComponentDescriptor componentDescriptor;
+  /**
+   * The method spec for a {@code configureInitialization} method plus details on the component
+   * requirements that its parameters are associated with.
+   */
+  @AutoValue
+  abstract static class ConfigureInitializationMethod {
+    /** Creates a new {@link ConfigureInitializationMethod}. */
+    static ConfigureInitializationMethod create(
+        MethodSpec spec, ImmutableSet<ComponentRequirement> parameters) {
+      return new AutoValue_ComponentImplementation_ConfigureInitializationMethod(
+          spec, parameters);
+    }
+
+    /** The spec for the method. */
+    abstract MethodSpec spec();
+
+    /**
+     * The component requirements associated with the method's parameters, in the same order as the
+     * parameters.
+     */
+    abstract ImmutableSet<ComponentRequirement> parameters();
+  }
+
+  private final BindingGraph graph;
   private final ClassName name;
   private final NestingKind nestingKind;
   private final boolean isAbstract;
@@ -156,7 +180,10 @@
   private final UniqueNameSet componentFieldNames = new UniqueNameSet();
   private final UniqueNameSet componentMethodNames = new UniqueNameSet();
   private final List<CodeBlock> initializations = new ArrayList<>();
-  private final List<CodeBlock> componentRequirementInitializations = new ArrayList<>();
+  private final Map<ComponentRequirement, CodeBlock> componentRequirementInitializations =
+      new LinkedHashMap<>();
+  private final Map<ComponentRequirement, String> componentRequirementParameterNames =
+      new HashMap<>();
   private final Set<Key> cancellableProducerKeys = new LinkedHashSet<>();
   private final ListMultimap<FieldSpecKind, FieldSpec> fieldSpecsMap =
       MultimapBuilder.enumKeys(FieldSpecKind.class).arrayListValues().build();
@@ -170,18 +197,18 @@
   // implicit
   private final SetMultimap<BindingRequest, DependencyRequest> multibindingContributionsMade =
       HashMultimap.create();
-  private Optional<MethodSpec> configureInitializationMethod = Optional.empty();
+  private Optional<ConfigureInitializationMethod> configureInitializationMethod = Optional.empty();
   private final Map<ComponentRequirement, String> modifiableModuleMethods = new LinkedHashMap<>();
 
   ComponentImplementation(
-      ComponentDescriptor componentDescriptor,
+      BindingGraph graph,
       ClassName name,
       NestingKind nestingKind,
       Optional<ComponentImplementation> superclassImplementation,
       SubcomponentNames subcomponentNames,
       Modifier... modifiers) {
     checkName(name, nestingKind);
-    this.componentDescriptor = componentDescriptor;
+    this.graph = graph;
     this.name = name;
     this.nestingKind = nestingKind;
     this.isAbstract = Arrays.asList(modifiers).contains(ABSTRACT);
@@ -192,12 +219,12 @@
 
   ComponentImplementation(
       ComponentImplementation parent,
-      ComponentDescriptor componentDescriptor,
+      BindingGraph graph,
       Optional<ComponentImplementation> superclassImplementation,
       Modifier... modifiers) {
     this(
-        componentDescriptor,
-        parent.getSubcomponentName(componentDescriptor),
+        graph,
+        parent.getSubcomponentName(graph.componentDescriptor()),
         NestingKind.MEMBER,
         superclassImplementation,
         parent.subcomponentNames,
@@ -222,9 +249,14 @@ private static void checkName(ClassName name, NestingKind nestingKind) {
     }
   }
 
+  /** Returns the binding graph for the component being generated. */
+  BindingGraph graph() {
+    return graph;
+  }
+
   /** Returns the descriptor for the component being generated. */
   ComponentDescriptor componentDescriptor() {
-    return componentDescriptor;
+    return graph.componentDescriptor();
   }
 
   /** Returns the name of the component. */
@@ -263,7 +295,7 @@ boolean isAbstract() {
    *
    * <p>Only returns a present value in {@link CompilerOptions#aheadOfTimeSubcomponents()}.
    */
-  Optional<MethodSpec> superConfigureInitializationMethod() {
+  Optional<ConfigureInitializationMethod> superConfigureInitializationMethod() {
     for (Optional<ComponentImplementation> currentSuper = superclassImplementation;
         currentSuper.isPresent();
         currentSuper = currentSuper.get().superclassImplementation) {
@@ -280,7 +312,7 @@ boolean isAbstract() {
    *
    * <p>Only returns a present value in {@link CompilerOptions#aheadOfTimeSubcomponents()}.
    */
-  Optional<MethodSpec> configureInitializationMethod() {
+  Optional<ConfigureInitializationMethod> configureInitializationMethod() {
     return configureInitializationMethod;
   }
 
@@ -288,9 +320,9 @@ boolean isAbstract() {
    * Set's this component implementation's {@code configureInitialization()} method and {@linkplain
    * #addMethod(MethodSpecKind, MethodSpec) adds the method}.
    */
-  void setConfigureInitializationMethod(MethodSpec method) {
+  void setConfigureInitializationMethod(ConfigureInitializationMethod method) {
     configureInitializationMethod = Optional.of(method);
-    addMethod(MethodSpecKind.CONFIGURE_INITIALIZATION_METHOD, method);
+    addMethod(MethodSpecKind.CONFIGURE_INITIALIZATION_METHOD, method.spec());
   }
 
   void setCreatorImplementation(Optional<ComponentCreatorImplementation> creatorImplementation) {
@@ -310,17 +342,17 @@ void setCreatorImplementation(Optional<ComponentCreatorImplementation> creatorIm
    */
   ClassName getCreatorName() {
     return isNested()
-        ? name.peerClass(subcomponentNames.get(componentDescriptor) + "Builder")
+        ? name.peerClass(subcomponentNames.get(componentDescriptor()) + "Builder")
         : name.nestedClass("Builder");
   }
 
   /** Returns the name of the nested implementation class for a child component. */
   ClassName getSubcomponentName(ComponentDescriptor childDescriptor) {
     checkArgument(
-        componentDescriptor.childComponents().contains(childDescriptor),
+        componentDescriptor().childComponents().contains(childDescriptor),
         "%s is not a child component of %s",
         childDescriptor.typeElement(),
-        componentDescriptor.typeElement());
+        componentDescriptor().typeElement());
     return name.nestedClass(subcomponentNames.get(childDescriptor) + "Impl");
   }
 
@@ -444,11 +476,12 @@ void addInitialization(CodeBlock codeBlock) {
   }
 
   /**
-   * Adds the given code block that initializes a {@link ComponentRequirement} to the component
-   * implementation.
+   * Adds the given code block that initializes the given {@link ComponentRequirement} to the
+   * component implementation.
    */
-  void addComponentRequirementInitialization(CodeBlock codeBlock) {
-    componentRequirementInitializations.add(codeBlock);
+  void addComponentRequirementInitialization(
+      ComponentRequirement requirement, CodeBlock codeBlock) {
+    componentRequirementInitializations.put(requirement, codeBlock);
   }
 
   /**
@@ -484,6 +517,20 @@ private String uniqueMethodName(BindingRequest request, String bindingName) {
     return getUniqueMethodName(baseMethodName);
   }
 
+  /** Gets the parameter name to use for the given requirement for this component. */
+  String getParameterName(ComponentRequirement requirement) {
+    return getParameterName(requirement, requirement.variableName());
+  }
+
+  /**
+   * Gets the parameter name to use for the given requirement for this component, starting with the
+   * given base name if no parameter name has already been selected for the requirement.
+   */
+  String getParameterName(ComponentRequirement requirement, String baseName) {
+    return componentRequirementParameterNames.computeIfAbsent(
+        requirement, r -> getUniqueFieldName(baseName));
+  }
+
   /** Claims a new method name for the component. Does nothing if method name already exists. */
   void claimMethodName(CharSequence name) {
     componentMethodNames.claim(name);
@@ -495,16 +542,26 @@ void claimMethodName(CharSequence name) {
   }
 
   /**
-   * Returns the list of {@link CodeBlock}s that initialize {@link ComponentRequirement}s. These
-   * initializations are kept separate from {@link #getInitializations()} because they must be
-   * executed before the initializations of any framework instance initializations in a superclass
-   * implementation that may depend on the instances. We cannot use the same strategy that we use
-   * for framework instances (i.e. wrap in a {@link dagger.internal.DelegateFactory} or {@link
-   * dagger.producers.internal.DelegateProducer} since the types of these initialized fields have no
-   * interface type that we can write a proxy for.
+   * Returns the map of {@link ComponentRequirement}s to {@link CodeBlock}s that initialize them.
+   *
+   * <p>These initializations are kept separate from {@link #getInitializations()} because they must
+   * be executed before the initializations of any framework instance initializations in a
+   * superclass implementation that may depend on the instances. We cannot use the same strategy
+   * that we use for framework instances (i.e. wrap in a {@link dagger.internal.DelegateFactory} or
+   * {@link dagger.producers.internal.DelegateProducer} since the types of these initialized fields
+   * have no interface type that we can write a proxy for.
+   */
+  ImmutableMap<ComponentRequirement, CodeBlock> getComponentRequirementInitializations() {
+    return ImmutableMap.copyOf(componentRequirementInitializations);
+  }
+
+  /**
+   * Returns whether or not this component has any {@linkplain #getInitializations() initilizations}
+   * or {@linkplain #getComponentRequirementInitializations() component requirement
+   * initializations}.
    */
-  ImmutableList<CodeBlock> getComponentRequirementInitializations() {
-    return ImmutableList.copyOf(componentRequirementInitializations);
+  boolean hasInitializations() {
+    return !initializations.isEmpty() || !componentRequirementInitializations.isEmpty();
   }
 
   /**
diff --git a/java/dagger/internal/codegen/ComponentImplementationBuilder.java b/java/dagger/internal/codegen/ComponentImplementationBuilder.java
index 906e32fa5..c40035b7f 100644
--- a/java/dagger/internal/codegen/ComponentImplementationBuilder.java
+++ b/java/dagger/internal/codegen/ComponentImplementationBuilder.java
@@ -20,6 +20,7 @@
 import static com.google.auto.common.MoreTypes.asDeclared;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.base.Predicates.in;
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
@@ -46,22 +47,31 @@
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableListMultimap;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
 import com.google.common.collect.Multimaps;
+import com.google.common.collect.Sets;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.ParameterSpec;
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
+import dagger.internal.Preconditions;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.ComponentImplementation.ConfigureInitializationMethod;
 import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
 import dagger.model.Key;
 import dagger.producers.internal.CancellationListener;
 import dagger.producers.internal.Producers;
+import java.util.Collection;
 import java.util.List;
+import java.util.Map;
 import java.util.Optional;
+import java.util.function.Function;
 import javax.inject.Inject;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.type.DeclaredType;
@@ -84,7 +94,7 @@
   @Inject ComponentBindingExpressions bindingExpressions;
   @Inject ComponentRequirementExpressions componentRequirementExpressions;
   @Inject ComponentImplementation componentImplementation;
-  @Inject ComponentCreatorImplementation.Factory componentCreatorImplementationFactory;
+  @Inject ComponentCreatorImplementationFactory componentCreatorImplementationFactory;
   @Inject DaggerTypes types;
   @Inject DaggerElements elements;
   @Inject CompilerOptions compilerOptions;
@@ -104,7 +114,7 @@ final ComponentImplementation build() {
         componentImplementation.name());
     setSupertype();
     componentImplementation.setCreatorImplementation(
-        componentCreatorImplementationFactory.create(componentImplementation, graph));
+        componentCreatorImplementationFactory.create(componentImplementation));
     componentImplementation
         .creatorImplementation()
         .map(ComponentCreatorImplementation::componentCreatorClass)
@@ -126,7 +136,7 @@ final ComponentImplementation build() {
     addChildComponents();
     implementModifiableModuleMethods();
 
-    addConstructor();
+    addConstructorAndInitializationMethods();
 
     if (graph.componentDescriptor().kind().isProducer()) {
       addCancellationListenerImplementation();
@@ -137,7 +147,7 @@ final ComponentImplementation build() {
   }
 
   /** Set the supertype for this generated class. */
-  final void setSupertype() {
+  private void setSupertype() {
     if (componentImplementation.superclassImplementation().isPresent()) {
       componentImplementation.addSuperclass(
           componentImplementation.superclassImplementation().get().name());
@@ -150,12 +160,12 @@ final void setSupertype() {
    * Adds {@code creator} as a nested creator class. Root components and subcomponents will nest
    * this in different classes.
    */
-  abstract void addCreatorClass(TypeSpec creator);
+  protected abstract void addCreatorClass(TypeSpec creator);
 
   /** Adds component factory methods. */
-  abstract void addFactoryMethods();
+  protected abstract void addFactoryMethods();
 
-  void addInterfaceMethods() {
+  protected void addInterfaceMethods() {
     // Each component method may have been declared by several supertypes. We want to implement
     // only one method for each distinct signature.
     ImmutableListMultimap<MethodSignature, ComponentMethodDescriptor> componentMethodsBySignature =
@@ -178,15 +188,18 @@ void addInterfaceMethods() {
     }
   }
 
-  final void addCancellationListenerImplementation() {
+  private void addCancellationListenerImplementation() {
     componentImplementation.addSupertype(elements.getTypeElement(CancellationListener.class));
     componentImplementation.claimMethodName(CANCELLATION_LISTENER_METHOD_NAME);
 
+    ImmutableList<ParameterSpec> parameters =
+        ImmutableList.of(ParameterSpec.builder(boolean.class, MAY_INTERRUPT_IF_RUNNING).build());
+
     MethodSpec.Builder methodBuilder =
         methodBuilder(CANCELLATION_LISTENER_METHOD_NAME)
             .addModifiers(PUBLIC)
             .addAnnotation(Override.class)
-            .addParameter(boolean.class, MAY_INTERRUPT_IF_RUNNING);
+            .addParameters(parameters);
     if (componentImplementation.superclassImplementation().isPresent()) {
       methodBuilder.addStatement(
           "super.$L($L)", CANCELLATION_LISTENER_METHOD_NAME, MAY_INTERRUPT_IF_RUNNING);
@@ -197,18 +210,15 @@ final void addCancellationListenerImplementation() {
     if (cancellationStatements.size() < STATEMENTS_PER_METHOD) {
       methodBuilder.addCode(CodeBlocks.concat(cancellationStatements)).build();
     } else {
-      List<List<CodeBlock>> partitions =
-          Lists.partition(cancellationStatements, STATEMENTS_PER_METHOD);
-      for (List<CodeBlock> partition : partitions) {
-        String methodName = componentImplementation.getUniqueMethodName("cancelProducers");
-        MethodSpec method =
-            methodBuilder(methodName)
-                .addModifiers(PRIVATE)
-                .addParameter(boolean.class, MAY_INTERRUPT_IF_RUNNING)
-                .addCode(CodeBlocks.concat(partition))
-                .build();
-        methodBuilder.addStatement("$N($L)", method, MAY_INTERRUPT_IF_RUNNING);
-        componentImplementation.addMethod(CANCELLATION_LISTENER_METHOD, method);
+      ImmutableList<MethodSpec> cancelProducersMethods =
+          createPartitionedMethods(
+              "cancelProducers",
+              parameters,
+              cancellationStatements,
+              methodName -> methodBuilder(methodName).addModifiers(PRIVATE));
+      for (MethodSpec cancelProducersMethod : cancelProducersMethods) {
+        methodBuilder.addStatement("$N($L)", cancelProducersMethod, MAY_INTERRUPT_IF_RUNNING);
+        componentImplementation.addMethod(CANCELLATION_LISTENER_METHOD, cancelProducersMethod);
       }
     }
 
@@ -255,7 +265,7 @@ final void addCancellationListenerImplementation() {
     return cancellationStatements.build();
   }
 
-  Optional<CodeBlock> cancelParentStatement() {
+  protected Optional<CodeBlock> cancelParentStatement() {
     // Returns empty by default. Overridden in subclass(es) to add a statement if and only if the
     // component being generated is a concrete subcomponent implementation with a parent that
     // allows cancellation to propagate to it from subcomponents.
@@ -290,12 +300,12 @@ private void implementModifiableModuleMethod(ComponentRequirement module, String
             .build());
   }
 
-  final MethodSignature getMethodSignature(ComponentMethodDescriptor method) {
+  private MethodSignature getMethodSignature(ComponentMethodDescriptor method) {
     return MethodSignature.forComponentMethod(
         method, MoreTypes.asDeclared(graph.componentTypeElement().asType()), types);
   }
 
-  final void addChildComponents() {
+  private void addChildComponents() {
     for (BindingGraph subgraph : graph.subgraphs()) {
       // TODO(b/117833324): Can an abstract inner subcomponent implementation be elided if it's
       // totally empty?
@@ -304,11 +314,11 @@ final void addChildComponents() {
     }
   }
 
-  final ComponentImplementation buildChildImplementation(BindingGraph childGraph) {
+  private ComponentImplementation buildChildImplementation(BindingGraph childGraph) {
     ComponentImplementation childImplementation =
         compilerOptions.aheadOfTimeSubcomponents()
-            ? abstractInnerSubcomponent(childGraph.componentDescriptor())
-            : concreteSubcomponent(childGraph.componentDescriptor());
+            ? abstractInnerSubcomponent(childGraph)
+            : concreteSubcomponent(childGraph);
     return topLevelImplementationComponent
         .currentImplementationSubcomponentBuilder()
         .componentImplementation(childImplementation)
@@ -322,161 +332,285 @@ final ComponentImplementation buildChildImplementation(BindingGraph childGraph)
   }
 
   /** Creates an inner abstract subcomponent implementation. */
-  final ComponentImplementation abstractInnerSubcomponent(ComponentDescriptor child) {
+  private ComponentImplementation abstractInnerSubcomponent(BindingGraph childGraph) {
     return new ComponentImplementation(
         componentImplementation,
-        child,
+        childGraph,
         Optional.of(
             componentImplementationFactory.findChildSuperclassImplementation(
-                child, componentImplementation)),
+                childGraph.componentDescriptor(), componentImplementation)),
         PROTECTED,
         componentImplementation.isAbstract() ? ABSTRACT : FINAL);
   }
 
   /** Creates a concrete inner subcomponent implementation. */
-  final ComponentImplementation concreteSubcomponent(ComponentDescriptor child) {
+  private ComponentImplementation concreteSubcomponent(BindingGraph childGraph) {
     return new ComponentImplementation(
         componentImplementation,
-        child,
+        childGraph,
         Optional.empty(), // superclassImplementation
         PRIVATE,
         FINAL);
   }
 
-  final void addConstructor() {
-    List<List<CodeBlock>> partitions =
-        Lists.partition(componentImplementation.getInitializations(), STATEMENTS_PER_METHOD);
-    ImmutableList<CodeBlock> componentRequirementInitializations =
-        componentImplementation.getComponentRequirementInitializations();
-
-    ImmutableList<ParameterSpec> constructorParameters = constructorParameters();
-    MethodSpec.Builder constructor =
-        constructorBuilder()
-            .addModifiers(componentImplementation.isAbstract() ? PROTECTED : PRIVATE);
-
+  /** Creates and adds the constructor and methods needed for initializing the component. */
+  private void addConstructorAndInitializationMethods() {
+    MethodSpec.Builder constructor = componentConstructorBuilder();
     if (!componentImplementation.isAbstract()) {
-      constructor.addParameters(constructorParameters);
+      implementInitializationMethod(constructor, initializationParameters());
+    } else if (componentImplementation.hasInitializations()) {
+      addConfigureInitializationMethod();
     }
+    componentImplementation.addMethod(CONSTRUCTOR, constructor.build());
+  }
 
-    Optional<MethodSpec.Builder> configureInitialization =
-        (partitions.isEmpty() && componentRequirementInitializations.isEmpty())
-                || !componentImplementation.isAbstract()
-            ? Optional.empty()
-            : Optional.of(configureInitializationMethodBuilder(constructorParameters));
+  /** Returns a builder for the component's constructor. */
+  private MethodSpec.Builder componentConstructorBuilder() {
+    return constructorBuilder()
+            .addModifiers(componentImplementation.isAbstract() ? PROTECTED : PRIVATE);
+  }
 
-    configureInitialization
-        .orElse(constructor)
-        .addCode(CodeBlocks.concat(componentRequirementInitializations));
+  /** Adds parameters and code to the given {@code initializationMethod}. */
+  private void implementInitializationMethod(
+      MethodSpec.Builder initializationMethod,
+      ImmutableMap<ComponentRequirement, ParameterSpec> initializationParameters) {
+    initializationMethod.addParameters(initializationParameters.values());
+    initializationMethod.addCode(
+        CodeBlocks.concat(
+            componentImplementation.getComponentRequirementInitializations().values()));
+    componentImplementation
+        .superConfigureInitializationMethod()
+        .ifPresent(
+            superConfigureInitializationMethod ->
+                addSuperConfigureInitializationCall(
+                    initializationMethod,
+                    initializationParameters,
+                    superConfigureInitializationMethod));
+    addInitializeMethods(initializationMethod, initializationParameters.values().asList());
+  }
 
-    if (componentImplementation.superConfigureInitializationMethod().isPresent()) {
-      MethodSpec superConfigureInitializationMethod =
-          componentImplementation.superConfigureInitializationMethod().get();
-      CodeBlock superInvocation =
-          CodeBlock.of(
-              "$N($L)",
-              superConfigureInitializationMethod,
-              parameterNames(superConfigureInitializationMethod.parameters));
-      if (configureInitialization.isPresent()) {
-        configureInitialization.get().addStatement("super.$L", superInvocation);
-      } else if (!componentImplementation.isAbstract()) {
-        constructor.addStatement(superInvocation);
-      }
-    }
+  /** Creates and adds a {@code configureInitializatoin} method to the component. */
+  private void addConfigureInitializationMethod() {
+    MethodSpec.Builder method = configureInitializationMethodBuilder();
+    ImmutableMap<ComponentRequirement, ParameterSpec> parameters = initializationParameters();
+    implementInitializationMethod(method, parameters);
+    componentImplementation.setConfigureInitializationMethod(
+        ConfigureInitializationMethod.create(method.build(), parameters.keySet()));
+  }
 
-    ImmutableList<ParameterSpec> initializeParameters = initializeParameters();
-    CodeBlock initializeParametersCodeBlock = parameterNames(constructorParameters);
-
-    for (List<CodeBlock> partition : partitions) {
-      String methodName = componentImplementation.getUniqueMethodName("initialize");
-      MethodSpec.Builder initializeMethod =
-          methodBuilder(methodName)
-              .addModifiers(PRIVATE)
-              /* TODO(gak): Strictly speaking, we only need the suppression here if we are also
-               * initializing a raw field in this method, but the structure of this code makes it
-               * awkward to pass that bit through.  This will be cleaned up when we no longer
-               * separate fields and initialization as we do now. */
-              .addAnnotation(AnnotationSpecs.suppressWarnings(UNCHECKED))
-              .addCode(CodeBlocks.concat(partition));
-      initializeMethod.addParameters(initializeParameters);
-      configureInitialization
-          .orElse(constructor)
-          .addStatement("$L($L)", methodName, initializeParametersCodeBlock);
-      componentImplementation.addMethod(INITIALIZE_METHOD, initializeMethod.build());
+  /** Returns a builder for the component's {@code configureInitialization} method. */
+  private MethodSpec.Builder configureInitializationMethodBuilder() {
+    String methodName = componentImplementation.getUniqueMethodName("configureInitialization");
+    MethodSpec.Builder configureInitialization = methodBuilder(methodName).addModifiers(PROTECTED);
+    if (overridesSuperclassConfigureInitialization(configureInitialization.build())) {
+      configureInitialization.addAnnotation(Override.class);
     }
-    componentImplementation.addMethod(CONSTRUCTOR, constructor.build());
-    configureInitialization.ifPresent(
-        method -> componentImplementation.setConfigureInitializationMethod(method.build()));
+    return configureInitialization;
   }
 
   /**
-   * Returns a {@link MethodSpec.Builder} for the {@link
-   * ComponentImplementation#configureInitializationMethod()}.
+   * Returns whether or not the given method overrides a configureInitialization method from a
+   * superclass.
    */
-  private MethodSpec.Builder configureInitializationMethodBuilder(
-      ImmutableList<ParameterSpec> initializationMethodParameters) {
-    String methodName = componentImplementation.getUniqueMethodName("configureInitialization");
-    MethodSpec.Builder configureInitialization =
-        methodBuilder(methodName)
-            .addModifiers(PROTECTED)
-            .addParameters(initializationMethodParameters);
-
-    // Checks all super configureInitialization() methods to see if they have the same signature
-    // as this one, and if so, adds as an @Override annotation
+  private boolean overridesSuperclassConfigureInitialization(MethodSpec method) {
     for (Optional<ComponentImplementation> currentSuperImplementation =
             componentImplementation.superclassImplementation();
         currentSuperImplementation.isPresent();
         currentSuperImplementation = currentSuperImplementation.get().superclassImplementation()) {
       Optional<MethodSpec> superConfigureInitializationMethod =
-          currentSuperImplementation.get().configureInitializationMethod();
+          currentSuperImplementation.get().configureInitializationMethod().map(m -> m.spec());
       if (superConfigureInitializationMethod
-          .filter(superMethod -> superMethod.name.equals(methodName))
-          .filter(superMethod -> superMethod.parameters.equals(initializationMethodParameters))
+          .filter(superMethod -> haveSameSignature(method, superMethod))
           .isPresent()) {
-        configureInitialization.addAnnotation(Override.class);
-        break;
+        return true;
       }
     }
 
-    return configureInitialization;
+    return false;
   }
 
-  /** Returns the list of {@link ParameterSpec}s for the initialize methods. */
-  final ImmutableList<ParameterSpec> initializeParameters() {
-    return constructorParameters().stream()
-        .map(param -> param.toBuilder().addModifiers(FINAL).build())
-        .collect(toImmutableList());
+  /** Returns whether or not methods {@code a} and {@code b} have the same signature. */
+  private boolean haveSameSignature(MethodSpec a, MethodSpec b) {
+    return a.name.equals(b.name) && types(a.parameters).equals(types(b.parameters));
   }
 
-  /** Returns the list of {@link ParameterSpec}s for the constructor. */
-  final ImmutableList<ParameterSpec> constructorParameters() {
-    Optional<ClassName> componentCreatorName;
-    if (componentImplementation.creatorImplementation().isPresent()) {
-      componentCreatorName =
-          componentImplementation.creatorImplementation().map(creator -> creator.name());
-    } else {
-      componentCreatorName =
-          componentImplementation
-              .baseImplementation()
-              .filter(component -> component.componentDescriptor().hasCreator())
-              .map(ComponentImplementation::getCreatorName);
+  private ImmutableList<TypeName> types(List<ParameterSpec> parameters) {
+    return parameters.stream().map(parameter -> parameter.type).collect(toImmutableList());
+  }
+
+  /**
+   * Adds a call to the superclass's {@code configureInitialization} method to the given {@code
+   * callingMethod}.
+   */
+  private void addSuperConfigureInitializationCall(
+      MethodSpec.Builder callingMethod,
+      ImmutableMap<ComponentRequirement, ParameterSpec> parameters,
+      ConfigureInitializationMethod superConfigureInitializationMethod) {
+    // This component's constructor may not have all of the parameters that the superclass's
+    // configureInitialization method takes, because the superclass configureInitialization method
+    // necessarily accepts things that it can't know whether will be needed or not. If they aren't
+    // needed (as is the case when the constructor doesn't have a parameter for the module), just
+    // pass null to super.configureInitialization for that parameter; it won't be used.
+    CodeBlock args =
+        superConfigureInitializationMethod.parameters().stream()
+            .map(
+                requirement ->
+                    parameters.containsKey(requirement)
+                        ? CodeBlock.of("$N", parameters.get(requirement))
+                        : CodeBlock.of("null"))
+            .collect(toParametersCodeBlock());
+
+    String qualifier =
+        haveSameSignature(callingMethod.build(), superConfigureInitializationMethod.spec())
+            ? "super."
+            : "";
+    callingMethod.addStatement(
+        qualifier + "$N($L)", superConfigureInitializationMethod.spec(), args);
+  }
+
+  /**
+   * Adds any necessary {@code initialize} methods to the component and adds calls to them to the
+   * given {@code callingMethod}.
+   */
+  private void addInitializeMethods(
+      MethodSpec.Builder callingMethod, ImmutableList<ParameterSpec> parameters) {
+    // TODO(cgdecker): It's not the case that each initialize() method has need for all of the
+    // given parameters. In some cases, those parameters may have already been assigned to fields
+    // which could be referenced instead. In other cases, an initialize method may just not need
+    // some of the parameters because the set of initializations in that partition does not
+    // include any reference to them. Right now, the Dagger code has no way of getting that
+    // information because, among other things, componentImplementation.getImplementations() just
+    // returns a bunch of CodeBlocks with no semantic information. Additionally, we may not know
+    // yet whether a field will end up needing to be created for a specific requirement, and we
+    // don't want to create a field that ends up only being used during initialization.
+    CodeBlock args = parameterNames(parameters);
+    ImmutableList<MethodSpec> methods =
+        createPartitionedMethods(
+            "initialize",
+            makeFinal(parameters),
+            componentImplementation.getInitializations(),
+            methodName ->
+                methodBuilder(methodName)
+                    .addModifiers(PRIVATE)
+                    /* TODO(gak): Strictly speaking, we only need the suppression here if we are
+                     * also initializing a raw field in this method, but the structure of this
+                     * code makes it awkward to pass that bit through.  This will be cleaned up
+                     * when we no longer separate fields and initialization as we do now. */
+                    .addAnnotation(AnnotationSpecs.suppressWarnings(UNCHECKED)));
+    for (MethodSpec method : methods) {
+      callingMethod.addStatement("$N($L)", method, args);
+      componentImplementation.addMethod(INITIALIZE_METHOD, method);
     }
+  }
+
+  /**
+   * Creates one or more methods, all taking the given {@code parameters}, which partition the given
+   * list of {@code statements} among themselves such that no method has more than {@code
+   * STATEMENTS_PER_METHOD} statements in it and such that the returned methods, if called in order,
+   * will execute the {@code statements} in the given order.
+   */
+  private ImmutableList<MethodSpec> createPartitionedMethods(
+      String methodName,
+      Iterable<ParameterSpec> parameters,
+      List<CodeBlock> statements,
+      Function<String, MethodSpec.Builder> methodBuilderCreator) {
+    return Lists.partition(statements, STATEMENTS_PER_METHOD).stream()
+        .map(
+            partition ->
+                methodBuilderCreator
+                    .apply(componentImplementation.getUniqueMethodName(methodName))
+                    .addParameters(parameters)
+                    .addCode(CodeBlocks.concat(partition))
+                    .build())
+        .collect(toImmutableList());
+  }
+
+  /** Returns the given parameters with a final modifier added. */
+  private final ImmutableList<ParameterSpec> makeFinal(Collection<ParameterSpec> parameters) {
+    return parameters.stream()
+        .map(param -> param.toBuilder().addModifiers(FINAL).build())
+        .collect(toImmutableList());
+  }
 
-    if (componentCreatorName.isPresent()) {
-      return ImmutableList.of(ParameterSpec.builder(componentCreatorName.get(), "builder").build());
+  /**
+   * Returns the parameters for the constructor or {@code configureInitilization} method as a map
+   * from the requirement the parameter fulfills to the spec for the parameter.
+   */
+  private final ImmutableMap<ComponentRequirement, ParameterSpec> initializationParameters() {
+    Optional<ComponentCreatorImplementation> creatorImplementation =
+        Optionals.firstPresent(
+            componentImplementation.creatorImplementation(),
+            componentImplementation.baseImplementation().flatMap(c -> c.creatorImplementation()));
+
+    Map<ComponentRequirement, ParameterSpec> parameters;
+    if (creatorImplementation.isPresent()) {
+      parameters =
+          Maps.transformEntries(
+              creatorImplementation.get().requirementNames(),
+              (requirement, name) -> requirement.toParameterSpec(name));
     } else if (componentImplementation.isAbstract() && componentImplementation.isNested()) {
       // If we're generating an abstract inner subcomponent, then we are not implementing module
       // instance bindings and have no need for factory method parameters.
-      return ImmutableList.of();
+      parameters = ImmutableMap.of();
     } else if (graph.factoryMethod().isPresent()) {
-      return getFactoryMethodParameterSpecs(graph);
+      parameters = getFactoryMethodParameters(graph);
     } else if (componentImplementation.isAbstract()) {
       // If we're generating an abstract base implementation of a subcomponent it's acceptable to
       // have neither a creator nor factory method.
-      return ImmutableList.of();
+      parameters = ImmutableMap.of();
     } else {
       throw new AssertionError(
           "Expected either a component creator or factory method but found neither.");
     }
+
+    if (componentImplementation.isAbstract()) {
+      parameters = Maps.filterKeys(parameters, in(configureInitializationRequirements()));
+    }
+    return renameParameters(parameters);
+  }
+
+  /**
+   * Returns the set of requirements for the configureInitialization method: the parameters that are
+   * needed either for initializing a component requirement field or for calling the superclass's
+   * {@code configureInitialization} method.
+   */
+  private ImmutableSet<ComponentRequirement> configureInitializationRequirements() {
+    ImmutableSet<ComponentRequirement> initializationRequirements =
+        componentImplementation.getComponentRequirementInitializations().keySet();
+    ImmutableSet<ComponentRequirement> superConfigureInitializationRequirements =
+        componentImplementation
+            .superConfigureInitializationMethod()
+            .map(ConfigureInitializationMethod::parameters)
+            .orElse(ImmutableSet.of());
+    return Sets.union(initializationRequirements, superConfigureInitializationRequirements)
+        .immutableCopy();
+  }
+
+  /**
+   * Renames the given parameters to guarantee their names do not conflict with fields in the
+   * component to ensure that a parameter is never referenced where a reference to a field was
+   * intended.
+   */
+  // TODO(cgdecker): This is a bit kludgy; it would be preferable to either qualify the field
+  // references with "this." or "super." when needed to disambiguate between field and parameter,
+  // but that would require more context than is currently available when the code referencing a
+  // field is generated.
+  private ImmutableMap<ComponentRequirement, ParameterSpec> renameParameters(
+      Map<ComponentRequirement, ParameterSpec> parameters) {
+    return ImmutableMap.copyOf(
+        Maps.transformEntries(
+            parameters,
+            (requirement, parameter) ->
+                renameParameter(
+                    parameter,
+                    componentImplementation.getParameterName(requirement, parameter.name))));
+  }
+
+  private ParameterSpec renameParameter(ParameterSpec parameter, String newName) {
+    return ParameterSpec.builder(parameter.type, newName)
+        .addAnnotations(parameter.annotations)
+        .addModifiers(parameter.modifiers)
+        .build();
   }
 
   /** Builds a root component implementation. */
@@ -487,12 +621,12 @@ final void addConstructor() {
     }
 
     @Override
-    void addCreatorClass(TypeSpec creator) {
+    protected void addCreatorClass(TypeSpec creator) {
       componentImplementation.addType(COMPONENT_CREATOR, creator);
     }
 
     @Override
-    void addFactoryMethods() {
+    protected void addFactoryMethods() {
       // Only top-level components have the factory builder() method.
       // Mirror the user's creator API type if they had one.
       MethodSpec creatorFactoryMethod =
@@ -525,13 +659,13 @@ void addFactoryMethods() {
     }
 
     /** {@code true} if all of the graph's required dependencies can be automatically constructed */
-    boolean canInstantiateAllRequirements() {
+    private boolean canInstantiateAllRequirements() {
       return !Iterables.any(
           graph.componentRequirements(),
           dependency -> dependency.requiresAPassedInstance(elements, types));
     }
 
-    ClassName componentCreatorName() {
+    private ClassName componentCreatorName() {
       return componentImplementation.creatorImplementation().get().name();
     }
   }
@@ -552,7 +686,7 @@ ClassName componentCreatorName() {
     }
 
     @Override
-    void addCreatorClass(TypeSpec creator) {
+    protected void addCreatorClass(TypeSpec creator) {
       if (parent.isPresent()) {
         // In an inner implementation of a subcomponent the creator is a peer class.
         parent.get().componentImplementation.addType(SUBCOMPONENT, creator);
@@ -562,7 +696,7 @@ void addCreatorClass(TypeSpec creator) {
     }
 
     @Override
-    void addFactoryMethods() {
+    protected void addFactoryMethods() {
       // Only construct instances of subcomponents that have concrete implementations.
       if (!componentImplementation.isAbstract()) {
         // Use the parent's factory method to create this subcomponent if the
@@ -571,29 +705,25 @@ void addFactoryMethods() {
       }
     }
 
-    void createSubcomponentFactoryMethod(ExecutableElement factoryMethod) {
+    private void createSubcomponentFactoryMethod(ExecutableElement factoryMethod) {
       checkState(parent.isPresent());
-      parent
-          .get()
-          .componentImplementation
-          .addMethod(
-              COMPONENT_METHOD,
-              MethodSpec.overriding(factoryMethod, parentType(), types)
-                  .addStatement(
-                      "return new $T($L)",
-                      componentImplementation.name(),
-                      getFactoryMethodParameterSpecs(graph).stream()
-                          .map(param -> CodeBlock.of("$N", param))
-                          .collect(toParametersCodeBlock()))
-                  .build());
+
+      Collection<ParameterSpec> params = getFactoryMethodParameters(graph).values();
+      MethodSpec.Builder method = MethodSpec.overriding(factoryMethod, parentType(), types);
+      params.forEach(
+          param -> method.addStatement("$T.checkNotNull($N)", Preconditions.class, param));
+      method.addStatement(
+          "return new $T($L)", componentImplementation.name(), parameterNames(params));
+
+      parent.get().componentImplementation.addMethod(COMPONENT_METHOD, method.build());
     }
 
-    DeclaredType parentType() {
+    private DeclaredType parentType() {
       return asDeclared(parent.get().graph.componentTypeElement().asType());
     }
 
     @Override
-    void addInterfaceMethods() {
+    protected void addInterfaceMethods() {
       if (componentImplementation.superclassImplementation().isPresent()) {
         // Since we're overriding a subcomponent implementation we add to its implementation given
         // an expanded binding graph.
@@ -613,7 +743,7 @@ void addInterfaceMethods() {
     }
 
     @Override
-    Optional<CodeBlock> cancelParentStatement() {
+    protected Optional<CodeBlock> cancelParentStatement() {
       if (!shouldPropagateCancellationToParent()) {
         return Optional.empty();
       }
@@ -627,7 +757,7 @@ void addInterfaceMethods() {
               .build());
     }
 
-    boolean shouldPropagateCancellationToParent() {
+    private boolean shouldPropagateCancellationToParent() {
       return parent.isPresent()
           && parent
               .get()
@@ -639,10 +769,12 @@ boolean shouldPropagateCancellationToParent() {
     }
   }
 
-  /** Returns the list of {@link ParameterSpec}s for the corresponding graph's factory method. */
-  private static ImmutableList<ParameterSpec> getFactoryMethodParameterSpecs(BindingGraph graph) {
-    return graph.factoryMethodParameters().values().stream()
-        .map(ParameterSpec::get)
-        .collect(toImmutableList());
+  /**
+   * Returns the map of {@link ComponentRequirement}s to {@link ParameterSpec}s for the
+   * given graph's factory method.
+   */
+  private static Map<ComponentRequirement, ParameterSpec> getFactoryMethodParameters(
+      BindingGraph graph) {
+    return Maps.transformValues(graph.factoryMethodParameters(), ParameterSpec::get);
   }
 }
diff --git a/java/dagger/internal/codegen/ComponentImplementationFactory.java b/java/dagger/internal/codegen/ComponentImplementationFactory.java
index 446e59d4e..3137e0f54 100644
--- a/java/dagger/internal/codegen/ComponentImplementationFactory.java
+++ b/java/dagger/internal/codegen/ComponentImplementationFactory.java
@@ -83,7 +83,7 @@ ComponentImplementation createComponentImplementation(BindingGraph bindingGraph)
   /** Creates a root component or top-level abstract subcomponent implementation. */
   ComponentImplementation topLevelImplementation(ClassName name, BindingGraph graph) {
     return new ComponentImplementation(
-        graph.componentDescriptor(),
+        graph,
         name,
         NestingKind.TOP_LEVEL,
         Optional.empty(), // superclassImplementation
diff --git a/java/dagger/internal/codegen/ComponentRequirement.java b/java/dagger/internal/codegen/ComponentRequirement.java
index 69c9ea9d4..12d5620cc 100644
--- a/java/dagger/internal/codegen/ComponentRequirement.java
+++ b/java/dagger/internal/codegen/ComponentRequirement.java
@@ -29,6 +29,8 @@
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
 import com.google.common.collect.ImmutableSet;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.TypeName;
 import dagger.Binds;
 import dagger.BindsOptionalOf;
 import dagger.Provides;
@@ -169,6 +171,11 @@ boolean requiresAPassedInstance(DaggerElements elements, DaggerTypes types) {
   /** Returns the name for this requirement that could be used as a variable. */
   abstract String variableName();
 
+  /** Returns a parameter spec for this requirement with the given parameter name. */
+  ParameterSpec toParameterSpec(String name) {
+    return ParameterSpec.builder(TypeName.get(type()), name).build();
+  }
+
   static ComponentRequirement forDependency(TypeMirror type) {
     return new AutoValue_ComponentRequirement(
         Kind.DEPENDENCY,
diff --git a/java/dagger/internal/codegen/ComponentRequirementExpression.java b/java/dagger/internal/codegen/ComponentRequirementExpression.java
index a4c1d3c05..b25c01b67 100644
--- a/java/dagger/internal/codegen/ComponentRequirementExpression.java
+++ b/java/dagger/internal/codegen/ComponentRequirementExpression.java
@@ -35,7 +35,7 @@
 
   /**
    * Returns an expression for the {@link ComponentRequirement} to be used only within {@code
-   * initialize()} methods, where the component builder is available.
+   * initialize()} methods, where the constructor parameters are available.
    *
    * <p>When accessing this expression from a subcomponent, this may cause a field to be initialized
    * or a method to be added in the component that owns this {@link ComponentRequirement}.
diff --git a/java/dagger/internal/codegen/ComponentRequirementExpressions.java b/java/dagger/internal/codegen/ComponentRequirementExpressions.java
index 8b56044a4..c06f1323d 100644
--- a/java/dagger/internal/codegen/ComponentRequirementExpressions.java
+++ b/java/dagger/internal/codegen/ComponentRequirementExpressions.java
@@ -36,7 +36,6 @@
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.ParameterSpec;
 import com.squareup.javapoet.TypeName;
-import dagger.internal.Preconditions;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Optional;
@@ -88,7 +87,7 @@ CodeBlock getExpression(ComponentRequirement componentRequirement, ClassName req
 
   /**
    * Returns an expression for the {@code componentRequirement} to be used only within {@code
-   * initialize()} methods, where the component builder is available.
+   * initialize()} methods, where the component constructor parameters are available.
    *
    * <p>When accessing this expression from a subcomponent, this may cause a field to be initialized
    * or a method to be added in the component that owns this {@link ComponentRequirement}.
@@ -133,13 +132,13 @@ private ComponentRequirementExpression createField(ComponentRequirement requirem
             componentImplementation.baseImplementation().flatMap(c -> c.creatorImplementation()),
             componentImplementation.creatorImplementation());
     if (creatorImplementation.isPresent()) {
-      FieldSpec builderField = creatorImplementation.get().builderFields().get(requirement);
-      return new BuilderField(requirement, componentImplementation, builderField);
+      String name =
+          creatorImplementation.get().requirementNames().get(requirement);
+      return new ComponentParameterField(requirement, componentImplementation, name);
     } else if (graph.factoryMethod().isPresent()
         && graph.factoryMethodParameters().containsKey(requirement)) {
-      ParameterSpec factoryParameter =
-          ParameterSpec.get(graph.factoryMethodParameters().get(requirement));
-      return new ComponentParameterField(requirement, componentImplementation, factoryParameter);
+      ParameterSpec parameter = ParameterSpec.get(graph.factoryMethodParameters().get(requirement));
+      return new ComponentParameterField(requirement, componentImplementation, parameter.name);
     } else if (requirement.kind().isModule()) {
       return new InstantiableModuleField(requirement, componentImplementation);
     } else {
@@ -150,7 +149,8 @@ private ComponentRequirementExpression createField(ComponentRequirement requirem
 
   private abstract static class AbstractField implements ComponentRequirementExpression {
     private final ComponentRequirement componentRequirement;
-    private final ComponentImplementation componentImplementation;
+    protected final ComponentImplementation componentImplementation;
+    protected final String fieldName;
     private final Supplier<MemberSelect> field = memoize(this::createField);
 
     private AbstractField(
@@ -158,6 +158,16 @@ private AbstractField(
         ComponentImplementation componentImplementation) {
       this.componentRequirement = checkNotNull(componentRequirement);
       this.componentImplementation = checkNotNull(componentImplementation);
+      // Note: The field name is being claimed eagerly here even though we don't know at this point
+      // whether or not the requirement will even need a field. This is done because:
+      // A) ComponentParameterField wants to ensure that it doesn't give the parameter the same name
+      //    as any field in the component, which requires that it claim a "field name" for itself
+      //    when naming the parameter.
+      // B) The parameter name may be needed before the field name is.
+      // C) We want to prefer giving the best name to the field rather than the parameter given its
+      //    wider scope.
+      this.fieldName =
+          componentImplementation.getUniqueFieldName(componentRequirement.variableName());
     }
 
     @Override
@@ -166,14 +176,11 @@ public CodeBlock getExpression(ClassName requestingClass) {
     }
 
     private MemberSelect createField() {
-      // TODO(dpb,ronshapiro): think about whether ComponentImplementation.addField
-      // should make a unique name for the field.
-      String fieldName =
-          componentImplementation.getUniqueFieldName(componentRequirement.variableName());
       FieldSpec field =
           FieldSpec.builder(TypeName.get(componentRequirement.type()), fieldName, PRIVATE).build();
       componentImplementation.addField(COMPONENT_REQUIREMENT_FIELD, field);
-      componentImplementation.addComponentRequirementInitialization(fieldInitialization(field));
+      componentImplementation.addComponentRequirementInitialization(
+          componentRequirement, fieldInitialization(field));
       return MemberSelect.localField(componentImplementation.name(), fieldName);
     }
 
@@ -181,52 +188,18 @@ private MemberSelect createField() {
     abstract CodeBlock fieldInitialization(FieldSpec componentField);
   }
 
-  /**
-   * A {@link ComponentRequirementExpression} for {@link ComponentRequirement}s that have a
-   * corresponding field on the component builder.
-   */
-  private static final class BuilderField extends AbstractField {
-    private final FieldSpec builderField;
-
-    private BuilderField(
-        ComponentRequirement componentRequirement,
-        ComponentImplementation componentImplementation,
-        FieldSpec builderField) {
-      super(componentRequirement, componentImplementation);
-      this.builderField = checkNotNull(builderField);
-    }
-
-    @Override
-    public CodeBlock getExpressionDuringInitialization(ClassName requestingClass) {
-      if (super.componentImplementation.name().equals(requestingClass)) {
-        return CodeBlock.of("builder.$N", builderField);
-      } else {
-        // requesting this component requirement during initialization of a child component requires
-        // the it to be access from a field and not the builder (since it is no longer available)
-        return getExpression(requestingClass);
-      }
-    }
-
-    @Override
-    CodeBlock fieldInitialization(FieldSpec componentField) {
-      return CodeBlock.of("this.$N = builder.$N;", componentField, builderField);
-    }
-  }
-
   /**
    * A {@link ComponentRequirementExpression} for {@link ComponentRequirement}s that can be
    * instantiated by the component (i.e. a static class with a no-arg constructor).
    */
   private final class InstantiableModuleField extends AbstractField {
     private final TypeElement moduleElement;
-    private final ComponentImplementation componentImplementation;
 
     private InstantiableModuleField(
         ComponentRequirement module, ComponentImplementation componentImplementation) {
       super(module, componentImplementation);
       checkArgument(module.kind().isModule());
       this.moduleElement = module.typeElement();
-      this.componentImplementation = componentImplementation;
     }
 
     @Override
@@ -240,23 +213,46 @@ CodeBlock fieldInitialization(FieldSpec componentField) {
 
   /**
    * A {@link ComponentRequirementExpression} for {@link ComponentRequirement}s that are passed in
-   * as parameters to a component factory method.
+   * as parameters to the component's constructor.
    */
   private static final class ComponentParameterField extends AbstractField {
-    private final ParameterSpec factoryParameter;
+    private final String name;
 
     private ComponentParameterField(
         ComponentRequirement componentRequirement,
         ComponentImplementation componentImplementation,
-        ParameterSpec factoryParameter) {
+        String name) {
       super(componentRequirement, componentImplementation);
-      this.factoryParameter = checkNotNull(factoryParameter);
+      // Get the name that the component implementation will use for its parameter for the
+      // requirement. If the given name is different than the name of the field created for the
+      // requirement (as may be the case when the parameter name is derived from a user-written
+      // factory method parameter), just use that as the base name for the parameter. Otherwise,
+      // append "Param" to the end of the name to differentiate.
+      // In either case, componentImplementation.getParameterName() will ensure that the final name
+      // that is used is not the same name as any field in the component even if there's something
+      // weird where the component actually has fields named, say, "foo" and "fooParam".
+      this.name =
+          componentImplementation.getParameterName(
+              componentRequirement,
+              name.equals(fieldName) ? name + "Param" : name);
+    }
+
+    @Override
+    public CodeBlock getExpressionDuringInitialization(ClassName requestingClass) {
+      if (componentImplementation.name().equals(requestingClass)) {
+        return CodeBlock.of("$L", name);
+      } else {
+        // requesting this component requirement during initialization of a child component requires
+        // it to be accessed from a field and not the parameter (since it is no longer available)
+        return getExpression(requestingClass);
+      }
     }
 
     @Override
     CodeBlock fieldInitialization(FieldSpec componentField) {
-      return CodeBlock.of(
-          "this.$N = $T.checkNotNull($N);", componentField, Preconditions.class, factoryParameter);
+      // Don't checkNotNull here because the parameter may be nullable; if it isn't, the caller
+      // should handle checking that before passing the parameter.
+      return CodeBlock.of("this.$N = $L;", componentField, name);
     }
   }
 
@@ -325,7 +321,7 @@ public CodeBlock getModifiableModuleMethodExpression(ClassName requestingClass)
           "throw new UnsupportedOperationException($T.class + $S)",
           module.typeElement(),
           " has been pruned from the final resolved binding graph. If this exception is thrown, "
-              + "it is a cause of a Dagger bug - please report it!");
+              + "it is a Dagger bug, so please report it!");
     }
   }
 }
diff --git a/java/dagger/internal/codegen/DependencyMethodProducerCreationExpression.java b/java/dagger/internal/codegen/DependencyMethodProducerCreationExpression.java
index 909d9921c..c934059a2 100644
--- a/java/dagger/internal/codegen/DependencyMethodProducerCreationExpression.java
+++ b/java/dagger/internal/codegen/DependencyMethodProducerCreationExpression.java
@@ -64,7 +64,16 @@ public CodeBlock creationExpression() {
                 ClassName.get(dependency.typeElement()), dependency.variableName(), PRIVATE, FINAL)
             .initializer(
                 componentRequirementExpressions.getExpressionDuringInitialization(
-                    dependency, componentImplementation.name()))
+                    dependency,
+                    // This isn't a real class name, but we want the requesting class for the
+                    // expression to *not* be the same class as the component implementation,
+                    // because it isn't... it's an anonymous inner class.
+                    // TODO(cgdecker): If we didn't use an anonymous inner class here but instead
+                    // generated a named nested class as with
+                    // DependencyMethodProviderCreationExpression, we wouldn't need to deal with
+                    // this and might be able to avoid potentially creating an extra field in the
+                    // component?
+                    componentImplementation.name().nestedClass("Anonymous")))
             .build();
     // TODO(b/70395982): Explore using a private static type instead of an anonymous class.
     TypeName keyType = TypeName.get(binding.key().type());
diff --git a/javatests/dagger/functional/cycle/LongCycleTest.java b/javatests/dagger/functional/cycle/LongCycleTest.java
index fa62a7dac..4c986b2ac 100644
--- a/javatests/dagger/functional/cycle/LongCycleTest.java
+++ b/javatests/dagger/functional/cycle/LongCycleTest.java
@@ -18,8 +18,10 @@
 
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.common.truth.TruthJUnit.assume;
+import static java.util.Arrays.stream;
 
 import dagger.functional.cycle.LongCycle.LongCycleComponent;
+import java.lang.reflect.Method;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -42,9 +44,12 @@ public void longCycle() {
    * factory is created in a separate method from the delegate factory.
    */
   @Test
-  public void longCycleHasMoreThanOneInitializeMethod() throws NoSuchMethodException {
+  public void longCycleHasMoreThanOneInitializeMethod() {
     assume().that(System.getProperty("dagger.mode")).doesNotContain("FastInit");
-    DaggerLongCycle_LongCycleComponent.class
-        .getDeclaredMethod("initialize2", DaggerLongCycle_LongCycleComponent.Builder.class);
+    boolean hasInitialize2 =
+        stream(DaggerLongCycle_LongCycleComponent.class.getDeclaredMethods())
+            .map(Method::getName)
+            .anyMatch(name -> name.equals("initialize2"));
+    assertThat(hasInitialize2).named("LongCycleComponent impl has an initialize2 method").isTrue();
   }
 }
diff --git a/javatests/dagger/functional/subcomponent/SubcomponentFactoryMethodTest.java b/javatests/dagger/functional/subcomponent/SubcomponentFactoryMethodTest.java
new file mode 100644
index 000000000..ca811af89
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/SubcomponentFactoryMethodTest.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent;
+
+import static org.junit.Assert.fail;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.Subcomponent;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests for subcomponent factory methods. */
+@RunWith(JUnit4.class)
+public final class SubcomponentFactoryMethodTest {
+
+  @Module
+  static class IntModule {
+    @Provides
+    int provideInt() {
+      return 42;
+    }
+  }
+
+  @Module
+  static class StringModule {
+    final String s;
+
+    StringModule(String s) {
+      this.s = s;
+    }
+
+    @Provides
+    String provideString(int i) {
+      return s + i;
+    }
+  }
+
+  @Component(modules = IntModule.class)
+  interface TestComponent {
+    TestSubcomponent newSubcomponent(StringModule stringModule);
+  }
+
+  @Subcomponent(modules = StringModule.class)
+  interface TestSubcomponent {
+    String string();
+  }
+
+  @Test
+  public void creatingSubcomponentViaFactoryMethod_failsForNullParameter() {
+    TestComponent component = DaggerSubcomponentFactoryMethodTest_TestComponent.create();
+    try {
+      component.newSubcomponent(null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+  }
+}
diff --git a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
index 18bf1a6c4..b7e955120 100644
--- a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
+++ b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
@@ -455,7 +455,7 @@ public void moduleInstanceDependency() {
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerRoot implements Root {",
-            "  private DaggerRoot(Builder builder) {}",
+            "  private DaggerRoot() {}",
             "",
             "  public static Builder builder() {",
             "    return new Builder();",
@@ -474,7 +474,7 @@ public void moduleInstanceDependency() {
             "    private Builder() {}",
             "",
             "    public Root build() {",
-            "      return new DaggerRoot(this);",
+            "      return new DaggerRoot();",
             "    }",
             "  }",
             "",
@@ -613,7 +613,7 @@ public void moduleInstanceDependency_withModuleParams() {
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerRoot implements Root {",
-            "  private DaggerRoot(Builder builder) {}",
+            "  private DaggerRoot() {}",
             "",
             "  public static Builder builder() {",
             "    return new Builder();",
@@ -632,7 +632,7 @@ public void moduleInstanceDependency_withModuleParams() {
             "    private Builder() {}",
             "",
             "    public Root build() {",
-            "      return new DaggerRoot(this);",
+            "      return new DaggerRoot();",
             "    }",
             "  }",
             "",
@@ -641,6 +641,7 @@ public void moduleInstanceDependency_withModuleParams() {
             "",
             "    @Override",
             "    public Leaf leaf(TestModule module) {",
+            "      Preconditions.checkNotNull(module);",
             "      return new LeafImpl(module);",
             "    }",
             "",
@@ -648,7 +649,7 @@ public void moduleInstanceDependency_withModuleParams() {
             "      private TestModule testModule;",
             "",
             "      private LeafImpl(TestModule module) {",
-            "        this.testModule = Preconditions.checkNotNull(module);",
+            "        this.testModule = module;",
             "      }",
             "",
             "      @Override",
@@ -751,7 +752,7 @@ public void generatedInstanceBinding() {
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerRoot implements Root {",
-            "  private DaggerRoot(Builder builder) {}",
+            "  private DaggerRoot() {}",
             "",
             "  public static Builder builder() {",
             "    return new Builder();",
@@ -770,7 +771,7 @@ public void generatedInstanceBinding() {
             "    private Builder() {}",
             "",
             "    public Root build() {",
-            "      return new DaggerRoot(this);",
+            "      return new DaggerRoot();",
             "    }",
             "  }",
             "",
@@ -785,12 +786,12 @@ public void generatedInstanceBinding() {
             "    private final class LeafBuilder extends DaggerLeaf.Builder {",
             "      @Override",
             "      public Leaf build() {",
-            "        return new LeafImpl(this);",
+            "        return new LeafImpl();",
             "      }",
             "    }",
             "",
             "    protected final class LeafImpl extends DaggerAncestor.LeafImpl {",
-            "      private LeafImpl(LeafBuilder builder) {}",
+            "      private LeafImpl() {}",
             "    }",
             "  }",
             "}");
@@ -908,7 +909,7 @@ public void prunedGeneratedInstanceBinding() {
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerRoot implements Root {",
-            "  private DaggerRoot(Builder builder) {}",
+            "  private DaggerRoot() {}",
             "",
             "  public static Builder builder() {",
             "    return new Builder();",
@@ -927,7 +928,7 @@ public void prunedGeneratedInstanceBinding() {
             "    private Builder() {}",
             "",
             "    public Root build() {",
-            "      return new DaggerRoot(this);",
+            "      return new DaggerRoot();",
             "    }",
             "  }",
             "",
@@ -4302,7 +4303,7 @@ public void provisionOverInjection_prunedIndirectDependency() {
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerRoot implements Root {",
-            "  private DaggerRoot(Builder builder) {}",
+            "  private DaggerRoot() {}",
             "",
             "  public static Builder builder() {",
             "    return new Builder();",
@@ -4321,7 +4322,7 @@ public void provisionOverInjection_prunedIndirectDependency() {
             "    private Builder() {}",
             "",
             "    public Root build() {",
-            "      return new DaggerRoot(this);",
+            "      return new DaggerRoot();",
             "    }",
             "",
             "    @Deprecated",
@@ -4455,7 +4456,7 @@ public void provisionOverInjection_prunedDirectDependency_prunedInConcreteImplem
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerRoot implements Root {",
-            "  private DaggerRoot(Builder builder) {}",
+            "  private DaggerRoot() {}",
             "",
             "  public static Builder builder() {",
             "    return new Builder();",
@@ -4474,7 +4475,7 @@ public void provisionOverInjection_prunedDirectDependency_prunedInConcreteImplem
             "    private Builder() {}",
             "",
             "    public Root build() {",
-            "      return new DaggerRoot(this);",
+            "      return new DaggerRoot();",
             "    }",
             "",
             "    @Deprecated",
@@ -4640,7 +4641,7 @@ public void provisionOverInjection_prunedDirectDependency_prunedInAbstractImplem
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerRoot implements Root {",
-            "  private DaggerRoot(Builder builder) {}",
+            "  private DaggerRoot() {}",
             "",
             "  public static Builder builder() {",
             "    return new Builder();",
@@ -4659,7 +4660,7 @@ public void provisionOverInjection_prunedDirectDependency_prunedInAbstractImplem
             "    private Builder() {}",
             "",
             "    public Root build() {",
-            "      return new DaggerRoot(this);",
+            "      return new DaggerRoot();",
             "    }",
             "  }",
             "",
@@ -4748,12 +4749,12 @@ public void productionSubcomponentAndModifiableFrameworkInstance() {
             "",
             "  protected DaggerLeaf() {}",
             "",
-            "  protected void configureInitialization(Builder builder) {",
-            "    initialize(builder);",
+            "  protected void configureInitialization() {",
+            "    initialize();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
+            "  private void initialize() {",
             "    this.responseProducer =",
             "        ResponseProducerModule_ResponseFactory.create(",
             "            getProductionImplementationExecutorProvider(),",
@@ -4900,8 +4901,8 @@ public void productionSubcomponentAndModifiableFrameworkInstance() {
             "  private Producer<ResponseDependency> responseDependencyProducer;",
             "  private Producer<Response> responseProducer;",
             "",
-            "  private DaggerRoot(Builder builder) {",
-            "    initialize(builder);",
+            "  private DaggerRoot() {",
+            "    initialize();",
             "  }",
             "",
             "  public static Root.Builder builder() {",
@@ -4913,7 +4914,7 @@ public void productionSubcomponentAndModifiableFrameworkInstance() {
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
+            "  private void initialize() {",
             "    this.productionImplementationExecutorProvider =",
             "        DoubleCheck.provider((Provider) ExecutorModule_ExecutorFactory.create());",
             "    this.rootProvider = InstanceFactory.create((Root) this);",
@@ -4944,27 +4945,27 @@ public void productionSubcomponentAndModifiableFrameworkInstance() {
             "  private static final class Builder implements Root.Builder {",
             "    @Override",
             "    public Root build() {",
-            "      return new DaggerRoot(this);",
+            "      return new DaggerRoot();",
             "    }",
             "  }",
             "",
             "  private final class LeafBuilder extends DaggerLeaf.Builder {",
             "    @Override",
             "    public Leaf build() {",
-            "      return new LeafImpl(this);",
+            "      return new LeafImpl();",
             "    }",
             "  }",
             "",
             "  protected final class LeafImpl extends DaggerLeaf implements CancellationListener {",
             "    private Producer<Set<Response>> setOfResponseProducer = new DelegateProducer<>();",
             "",
-            "    private LeafImpl(LeafBuilder builder) {",
-            "      configureInitialization(builder);",
-            "      initialize(builder);",
+            "    private LeafImpl() {",
+            "      configureInitialization();",
+            "      initialize();",
             "    }",
             "",
             "    @SuppressWarnings(\"unchecked\")",
-            "    private void initialize(final LeafBuilder builder) {",
+            "    private void initialize() {",
             "      DelegateProducer.setDelegate(",
             "          setOfResponseProducer,",
             "          SetProducer.<Response>builder(1, 1)",
@@ -5560,9 +5561,10 @@ public void subcomponentBuilders() {
             "",
             "  protected DaggerLeaf() {}",
             "",
-            "  protected void configureInitialization(Builder builder) {",
-            "    this.bindsInstance = builder.bindsInstance;",
-            "    this.leafModule = builder.leafModule;",
+            "  protected void configureInitialization(",
+            "      LeafModule leafModuleParam, Integer bindsInstanceParam) {",
+            "    this.bindsInstance = bindsInstanceParam;",
+            "    this.leafModule = leafModuleParam;",
             "  }",
             "",
             "  @Override",
@@ -5658,10 +5660,12 @@ public void subcomponentBuilders() {
             "",
             "    protected LeafImpl() {}",
             "",
-            "    @Override",
-            "    protected void configureInitialization(DaggerLeaf.Builder builder) {",
-            "      this.inducedInSubclass = builder.inducedInSubclass;",
-            "      super.configureInitialization(builder);",
+            "    protected void configureInitialization(",
+            "        LeafModule leafModule,",
+            "        Integer bindsInstance,",
+            "        String inducedInSubclassParam) {",
+            "      this.inducedInSubclass = inducedInSubclassParam;",
+            "      configureInitialization(leafModule, bindsInstance);",
             "    }",
             "",
             "    protected Set<String> getSetOfString() {",
@@ -5702,7 +5706,7 @@ public void subcomponentBuilders() {
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerRoot implements Root {",
-            "  private DaggerRoot(Builder builder) {}",
+            "  private DaggerRoot() {}",
             "",
             "  public static Builder builder() {",
             "    return new Builder();",
@@ -5721,7 +5725,7 @@ public void subcomponentBuilders() {
             "    private Builder() {}",
             "",
             "    public Root build() {",
-            "      return new DaggerRoot(this);",
+            "      return new DaggerRoot();",
             "    }",
             "  }",
             "",
@@ -5743,16 +5747,19 @@ public void subcomponentBuilders() {
             "        Preconditions.checkBuilderRequirement(leafModule, LeafModule.class);",
             "        Preconditions.checkBuilderRequirement(bindsInstance, Integer.class);",
             "        Preconditions.checkBuilderRequirement(inducedInSubclass, String.class);",
-            "        return new LeafImpl(this);",
+            "        return new LeafImpl(leafModule, bindsInstance, inducedInSubclass);",
             "      }",
             "    }",
             "",
             "    protected final class LeafImpl extends DaggerAncestor.LeafImpl {",
             "      private LeafModule leafModule;",
             "",
-            "      private LeafImpl(LeafBuilder builder) {",
-            "        this.leafModule = builder.leafModule;",
-            "        configureInitialization(builder);",
+            "      private LeafImpl(",
+            "          LeafModule leafModuleParam,",
+            "          Integer bindsInstance,",
+            "          String inducedInSubclass) {",
+            "        this.leafModule = leafModuleParam;",
+            "        configureInitialization(leafModuleParam, bindsInstance, inducedInSubclass);",
             "      }",
             "",
             "      @Override",
@@ -5830,8 +5837,9 @@ public void subcomponentBuilders_moduleWithUnusedInstanceBindings() {
             "",
             "  protected DaggerLeaf() {}",
             "",
-            "  protected void configureInitialization(Builder builder) {",
-            "    this.moduleWithUsedBinding = builder.moduleWithUsedBinding;",
+            "  protected void configureInitialization(",
+            "      ModuleWithUsedBinding moduleWithUsedBindingParam) {",
+            "    this.moduleWithUsedBinding = moduleWithUsedBindingParam;",
             "  }",
             "",
             "  @Override",
@@ -5875,7 +5883,7 @@ public void subcomponentBuilders_moduleWithUnusedInstanceBindings() {
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerRoot implements Root {",
-            "  private DaggerRoot(Builder builder) {}",
+            "  private DaggerRoot() {}",
             "",
             "  public static Builder builder() {",
             "    return new Builder();",
@@ -5894,7 +5902,7 @@ public void subcomponentBuilders_moduleWithUnusedInstanceBindings() {
             "    private Builder() {}",
             "",
             "    public Root build() {",
-            "      return new DaggerRoot(this);",
+            "      return new DaggerRoot();",
             "    }",
             "  }",
             "",
@@ -5905,16 +5913,16 @@ public void subcomponentBuilders_moduleWithUnusedInstanceBindings() {
             "        this.moduleWithUsedBinding = new ModuleWithUsedBinding();",
             "      }",
             // ModuleWithUnusedBinding is not verified since it's not used
-            "      return new LeafImpl(this);",
+            "      return new LeafImpl(moduleWithUsedBinding);",
             "    }",
             "  }",
             "",
             "  protected final class LeafImpl extends DaggerLeaf {",
             "    private ModuleWithUsedBinding moduleWithUsedBinding;",
             "",
-            "    private LeafImpl(LeafBuilder builder) {",
-            "      this.moduleWithUsedBinding = builder.moduleWithUsedBinding;",
-            "      configureInitialization(builder);",
+            "    private LeafImpl(ModuleWithUsedBinding moduleWithUsedBindingParam) {",
+            "      this.moduleWithUsedBinding = moduleWithUsedBindingParam;",
+            "      configureInitialization(moduleWithUsedBindingParam);",
             "    }",
             "",
             "    @Override",
@@ -5978,8 +5986,8 @@ public void subcomponentBuilders_repeatedModule() {
             "",
             "  protected DaggerLeaf() {}",
             "",
-            "  protected void configureInitialization(Builder builder) {",
-            "    this.repeatedModule = builder.repeatedModule;",
+            "  protected void configureInitialization(RepeatedModule repeatedModuleParam) {",
+            "    this.repeatedModule = repeatedModuleParam;",
             "  }",
             "",
             "  @Override",
@@ -6030,8 +6038,8 @@ public void subcomponentBuilders_repeatedModule() {
             "public final class DaggerRoot implements Root {",
             "  private RepeatedModule repeatedModule;",
             "",
-            "  private DaggerRoot(Builder builder) {",
-            "    this.repeatedModule = builder.repeatedModule;",
+            "  private DaggerRoot(RepeatedModule repeatedModuleParam) {",
+            "    this.repeatedModule = repeatedModuleParam;",
             "  }",
             "",
             "  public static Builder builder() {",
@@ -6056,7 +6064,7 @@ public void subcomponentBuilders_repeatedModule() {
             "      if (repeatedModule == null) {",
             "        this.repeatedModule = new RepeatedModule();",
             "      }",
-            "      return new DaggerRoot(this);",
+            "      return new DaggerRoot(repeatedModule);",
             "    }",
             "",
             "    public Builder repeatedModule(RepeatedModule repeatedModule) {",
@@ -6068,7 +6076,7 @@ public void subcomponentBuilders_repeatedModule() {
             "  private final class LeafBuilder extends DaggerLeaf.Builder {",
             "    @Override",
             "    public Leaf build() {",
-            "      return new LeafImpl(this);",
+            "      return new LeafImpl();",
             "    }",
             "",
             "    @Override",
@@ -6081,8 +6089,8 @@ public void subcomponentBuilders_repeatedModule() {
             "  }",
             "",
             "  protected final class LeafImpl extends DaggerLeaf {",
-            "    private LeafImpl(LeafBuilder builder) {",
-            "      configureInitialization(builder);",
+            "    private LeafImpl() {",
+            "      configureInitialization(null);",
             "    }",
             "",
             "    @Override",
@@ -6175,7 +6183,7 @@ public void bindsWithMissingDependency() {
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerRoot implements Root {",
-            "  private DaggerRoot(Builder builder) {}",
+            "  private DaggerRoot() {}",
             "",
             "  public static Builder builder() {",
             "    return new Builder();",
@@ -6194,7 +6202,7 @@ public void bindsWithMissingDependency() {
             "    private Builder() {}",
             "",
             "    public Root build() {",
-            "      return new DaggerRoot(this);",
+            "      return new DaggerRoot();",
             "    }",
             "  }",
             "",
@@ -6307,7 +6315,7 @@ public void bindsWithMissingDependency_pruned() {
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerRoot implements Root {",
-            "  private DaggerRoot(Builder builder) {}",
+            "  private DaggerRoot() {}",
             "",
             "  public static Builder builder() {",
             "    return new Builder();",
@@ -6326,7 +6334,7 @@ public void bindsWithMissingDependency_pruned() {
             "    private Builder() {}",
             "",
             "    public Root build() {",
-            "      return new DaggerRoot(this);",
+            "      return new DaggerRoot();",
             "    }",
             "  }",
             "",
@@ -6513,7 +6521,7 @@ public void modifiedProducerFromProvider() {
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerRoot implements Root {",
-            "  private DaggerRoot(Builder builder) {}",
+            "  private DaggerRoot() {}",
             "",
             "  public static Builder builder() {",
             "    return new Builder();",
@@ -6532,7 +6540,7 @@ public void modifiedProducerFromProvider() {
             "    private Builder() {}",
             "",
             "    public Root build() {",
-            "      return new DaggerRoot(this);",
+            "      return new DaggerRoot();",
             "    }",
             "  }",
             "",
@@ -7145,7 +7153,7 @@ public void prunedModuleWithInstanceState() {
 
     String exceptionText =
         " has been pruned from the final resolved binding graph. If this exception is thrown, it "
-            + "is a cause of a Dagger bug - please report it!";
+            + "is a Dagger bug, so please report it!";
     JavaFileObject generatedRoot =
         JavaFileObjects.forSourceLines(
             "test.DaggerRoot",
@@ -7383,7 +7391,7 @@ public void componentBuilderFields_consistencyAcrossImplementations() {
             "      if (mod3 == null) {",
             "        this.mod3 = new c.Mod();",
             "      }",
-            "      return new HasUnusedModuleLeafImpl(this);",
+            "      return new HasUnusedModuleLeafImpl(mod, mod3);",
             "    }",
             "  }",
             "}");
diff --git a/javatests/dagger/internal/codegen/ComponentBuilderTest.java b/javatests/dagger/internal/codegen/ComponentBuilderTest.java
index cc385249d..58001f61a 100644
--- a/javatests/dagger/internal/codegen/ComponentBuilderTest.java
+++ b/javatests/dagger/internal/codegen/ComponentBuilderTest.java
@@ -86,7 +86,7 @@ public void testEmptyBuilder() {
             "  private static final class Builder implements SimpleComponent.Builder {",
             "    @Override",
             "    public SimpleComponent build() {",
-            "      return new DaggerSimpleComponent(this);",
+            "      return new DaggerSimpleComponent();",
             "    }",
             "  }",
             "}");
@@ -149,7 +149,7 @@ public void testUsesBuildAndSetterNames() {
             "      if (testModule == null) {",
             "        this.testModule = new TestModule();",
             "      }",
-            "      return new DaggerTestComponent(this);",
+            "      return new DaggerTestComponent(testModule);",
             "    }",
             "",
             "    @Override",
@@ -225,9 +225,11 @@ public void testIgnoresModulesNotInApi() {
             "  private TestModule1 testModule1;",
             "  private TestModule2 testModule2;",
             "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    this.testModule1 = builder.testModule1;",
-            "    this.testModule2 = builder.testModule2;",
+            "  private DaggerTestComponent(",
+            "      TestModule1 testModule1Param,",
+            "      TestModule2 testModule2Param) {",
+            "    this.testModule1 = testModule1Param;",
+            "    this.testModule2 = testModule2Param;",
             "  }",
             "",
             "  public static TestComponent.Builder builder() {",
@@ -260,7 +262,7 @@ public void testIgnoresModulesNotInApi() {
             "      if (testModule2 == null) {",
             "        this.testModule2 = new TestModule2();",
             "      }",
-            "      return new DaggerTestComponent(this);",
+            "      return new DaggerTestComponent(testModule1, testModule2);",
             "    }",
             "",
             "    @Override",
@@ -408,8 +410,8 @@ public void testBuilderBindsInstanceNoCreateGenerated() {
             "public final class DaggerSimpleComponent implements SimpleComponent {",
             "  private Object object;",
             "",
-            "  private DaggerSimpleComponent(Builder builder) {",
-            "    this.object = builder.object;",
+            "  private DaggerSimpleComponent(Object objectParam) {",
+            "    this.object = objectParam;",
             "  }",
             "",
             "  public static SimpleComponent.Builder builder() {",
@@ -427,7 +429,7 @@ public void testBuilderBindsInstanceNoCreateGenerated() {
             "    @Override",
             "    public SimpleComponent build() {",
             "      Preconditions.checkBuilderRequirement(object, Object.class);",
-            "      return new DaggerSimpleComponent(this);",
+            "      return new DaggerSimpleComponent(object);",
             "    }",
             "",
             "    @Override",
diff --git a/javatests/dagger/internal/codegen/ComponentProcessorTest.java b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
index b91d6b750..51f24ea56 100644
--- a/javatests/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
@@ -191,7 +191,7 @@ public ComponentProcessorTest(CompilerMode compilerMode) {
                 FAST_INIT_MODE,
                 "  private volatile Provider<SomeInjectableType> someInjectableTypeProvider;")
             .addLines(
-                "  private DaggerSimpleComponent(Builder builder) {}",
+                "  private DaggerSimpleComponent() {}",
                 "",
                 "  public static Builder builder() {",
                 "    return new Builder();",
@@ -237,7 +237,7 @@ public ComponentProcessorTest(CompilerMode compilerMode) {
                 "    private Builder() {}",
                 "",
                 "    public SimpleComponent build() {",
-                "      return new DaggerSimpleComponent(this);",
+                "      return new DaggerSimpleComponent();",
                 "    }",
                 "  }")
             .addLinesIn(
@@ -313,7 +313,7 @@ public ComponentProcessorTest(CompilerMode compilerMode) {
                 "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
                 "",
                 "  @SuppressWarnings(\"unchecked\")",
-                "  private void initialize(final Builder builder) {",
+                "  private void initialize() {",
                 "    this.someInjectableTypeProvider =",
                 "        DoubleCheck.provider(SomeInjectableType_Factory.create());",
                 "  }",
@@ -425,7 +425,7 @@ public ComponentProcessorTest(CompilerMode compilerMode) {
                 GENERATED_ANNOTATION,
                 "public final class DaggerOuterType_SimpleComponent",
                 "    implements OuterType.SimpleComponent {",
-                "  private DaggerOuterType_SimpleComponent(Builder builder) {}",
+                "  private DaggerOuterType_SimpleComponent() {}",
                 "",
                 "  @Override",
                 "  public OuterType.A a() {",
@@ -510,8 +510,8 @@ public ComponentProcessorTest(CompilerMode compilerMode) {
                 "public final class DaggerTestComponent implements TestComponent {",
                 "  private TestModule testModule;",
                 "",
-                "  private DaggerTestComponent(Builder builder) {",
-                "    this.testModule = builder.testModule;",
+                "  private DaggerTestComponent(TestModule testModuleParam) {",
+                "    this.testModule = testModuleParam;",
                 "  }",
                 "",
                 "  private B getB() {",
@@ -530,7 +530,7 @@ public ComponentProcessorTest(CompilerMode compilerMode) {
                 "      if (testModule == null) {",
                 "        this.testModule = new TestModule();",
                 "      }",
-                "      return new DaggerTestComponent(this);",
+                "      return new DaggerTestComponent(testModule);",
                 "    }",
                 "",
                 "    public Builder testModule(TestModule testModule) {",
@@ -712,7 +712,7 @@ public void componentWithAbstractModule() {
         "public final class DaggerTestComponent implements TestComponent {",
         "  public static final class Builder {",
         "    public TestComponent build() {",
-        "      return new DaggerTestComponent(this);",
+        "      return new DaggerTestComponent();",
         "    }",
         "",
         "    @Deprecated",
@@ -895,7 +895,7 @@ public void subcomponentNotGeneratedIfNotUsedInGraph() {
             GENERATED_ANNOTATION,
             "public final class DaggerParent implements Parent {",
             "",
-            "  private DaggerParent(Builder builder) {}",
+            "  private DaggerParent() {}",
             "",
             "  public static Builder builder() {",
             "    return new Builder();",
@@ -915,7 +915,7 @@ public void subcomponentNotGeneratedIfNotUsedInGraph() {
             "    private Builder() {}",
             "",
             "    public Parent build() {",
-            "      return new DaggerParent(this);",
+            "      return new DaggerParent();",
             "    }",
             "",
             "    @Deprecated",
@@ -1068,7 +1068,7 @@ public void testDefaultPackage() {
             "  private Provider<SimpleComponent> simpleComponentProvider;",
             "",
             "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
+            "  private void initialize() {",
             "    this.simpleComponentProvider = InstanceFactory.create((SimpleComponent) this);",
             "  }",
             "",
@@ -1207,8 +1207,8 @@ public void testDefaultPackage() {
                 "  private volatile Provider<A> aProvider;",
                 "  private AComponent aComponent;",
                 "",
-                "  private DaggerBComponent(Builder builder) {",
-                "    this.aComponent = builder.aComponent;",
+                "  private DaggerBComponent(AComponent aComponentParam) {",
+                "    this.aComponent = aComponentParam;",
                 "  }",
                 "",
                 "  private Provider<A> getAProvider() {",
@@ -1222,8 +1222,8 @@ public void testDefaultPackage() {
             .addLinesIn(
                 DEFAULT_MODE,
                 "  @SuppressWarnings(\"unchecked\")",
-                "  private void initialize(final Builder builder) {",
-                "    this.aProvider = new test_AComponent_a(builder.aComponent);",
+                "  private void initialize(final AComponent aComponentParam) {",
+                "    this.aProvider = new test_AComponent_a(aComponentParam);",
                 "  }")
             .addLines(
                 "",
@@ -1243,7 +1243,7 @@ public void testDefaultPackage() {
                 "",
                 "    public BComponent build() {",
                 "      Preconditions.checkBuilderRequirement(aComponent, AComponent.class);",
-                "      return new DaggerBComponent(this);",
+                "      return new DaggerBComponent(aComponent);",
                 "    }",
                 "",
                 "    public Builder aComponent(AComponent aComponent) {",
@@ -1347,9 +1347,11 @@ public void testDefaultPackage() {
             "  private TestModule testModule;",
             "  private other.test.TestModule testModule2;",
             "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    this.testModule = builder.testModule;",
-            "    this.testModule2 = builder.testModule2;",
+            "  private DaggerTestComponent(",
+            "      TestModule testModuleParam,",
+            "      other.test.TestModule testModule2Param) {",
+            "    this.testModule = testModuleParam;",
+            "    this.testModule2 = testModule2Param;",
             "  }",
             "",
             "  @Override",
@@ -1373,7 +1375,7 @@ public void testDefaultPackage() {
             "      if (testModule2 == null) {",
             "        this.testModule2 = new other.test.TestModule();",
             "      }",
-            "      return new DaggerTestComponent(this);",
+            "      return new DaggerTestComponent(testModule, testModule2);",
             "    }",
             "",
             "    public Builder testModule(TestModule testModule) {",
@@ -1470,8 +1472,8 @@ public void testDefaultPackage() {
             "public final class DaggerBComponent implements BComponent {",
             "  private AComponent aComponent;",
             "",
-            "  private DaggerBComponent(Builder builder) {",
-            "    this.aComponent = builder.aComponent;",
+            "  private DaggerBComponent(AComponent aComponentParam) {",
+            "    this.aComponent = aComponentParam;",
             "  }",
             "",
             "  @Override",
@@ -1636,7 +1638,7 @@ public void testDefaultPackage() {
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerSimpleComponent implements SimpleComponent {",
-            "  private DaggerSimpleComponent(Builder builder) {}",
+            "  private DaggerSimpleComponent() {}",
             "",
             "  public static Builder builder() {",
             "    return new Builder();",
@@ -1655,7 +1657,7 @@ public void testDefaultPackage() {
             "    private Builder() {}",
             "",
             "    public SimpleComponent build() {",
-            "      return new DaggerSimpleComponent(this);",
+            "      return new DaggerSimpleComponent();",
             "    }",
             "  }",
             "}");
@@ -2081,7 +2083,7 @@ public void unusedSubcomponents_dontResolveExtraBindingsInParentComponents() {
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerParent implements Parent {",
-            "  private DaggerParent(Builder builder) {",
+            "  private DaggerParent() {",
             "  }",
             "",
             "  public static Builder builder() {",
@@ -2096,7 +2098,7 @@ public void unusedSubcomponents_dontResolveExtraBindingsInParentComponents() {
             "    private Builder() {}",
             "",
             "    public Parent build() {",
-            "      return new DaggerParent(this);",
+            "      return new DaggerParent();",
             "    }",
             "",
             "    @Deprecated",
diff --git a/javatests/dagger/internal/codegen/ComponentRequirementFieldTest.java b/javatests/dagger/internal/codegen/ComponentRequirementFieldTest.java
index f44c5dc56..6f36cb62b 100644
--- a/javatests/dagger/internal/codegen/ComponentRequirementFieldTest.java
+++ b/javatests/dagger/internal/codegen/ComponentRequirementFieldTest.java
@@ -81,9 +81,9 @@ public void bindsInstance() {
                 "  private Integer i;",
                 "  private List<String> list;",
                 "",
-                "  private DaggerTestComponent(Builder builder) {",
-                "    this.i = builder.i;",
-                "    this.list = builder.list;",
+                "  private DaggerTestComponent(Integer iParam, List<String> listParam) {",
+                "    this.i = iParam;",
+                "    this.list = listParam;",
                 "  }",
                 "",
                 "  @Override",
@@ -104,7 +104,7 @@ public void bindsInstance() {
                 "    public TestComponent build() {",
                 "      Preconditions.checkBuilderRequirement(i, Integer.class);",
                 "      Preconditions.checkBuilderRequirement(list, List.class);",
-                "      return new DaggerTestComponent(this);",
+                "      return new DaggerTestComponent(i, list);",
                 "    }",
                 "",
                 "    @Override",
@@ -251,8 +251,8 @@ public void componentInstances() {
                 "public final class DaggerTestComponent implements TestComponent {",
                 "  private Dep dep;",
                 "",
-                "  private DaggerTestComponent(Builder builder) {",
-                "    this.dep = builder.dep;",
+                "  private DaggerTestComponent(Dep depParam) {",
+                "    this.dep = depParam;",
                 "  }",
                 "",
                 "  @Override",
@@ -365,8 +365,8 @@ public void componentRequirementNeededInFactoryCreationOfSubcomponent() {
                 "public final class DaggerTestComponent implements TestComponent {",
                 "  private ParentModule parentModule;",
                 "",
-                "  private DaggerTestComponent(Builder builder) {",
-                "    this.parentModule = builder.parentModule;",
+                "  private DaggerTestComponent(ParentModule parentModuleParam) {",
+                "    this.parentModule = parentModuleParam;",
                 "  }",
                 "",
                 "  private final class TestSubcomponentImpl implements TestSubcomponent {",
@@ -393,20 +393,20 @@ public void componentRequirementNeededInFactoryCreationOfSubcomponent() {
                 "public final class DaggerTestComponent implements TestComponent {",
                 "  private ParentModule parentModule;",
                 "",
-                "  private DaggerTestComponent(Builder builder) {",
-                "    this.parentModule = builder.parentModule;",
-                "    initialize(builder);",
+                "  private DaggerTestComponent(ParentModule parentModuleParam) {",
+                "    this.parentModule = parentModuleParam;",
+                "    initialize(parentModuleParam);",
                 "  }",
                 "",
                 "  @SuppressWarnings(\"unchecked\")",
-                "  private void initialize(final Builder builder) {",
+                "  private void initialize(final ParentModule parentModuleParam) {",
                 "    this.setOfObjectProvider =",
                 "        SetFactory.<Object>builder(1, 0)",
                 "            .addProvider(ParentModule_ContributionFactory.create())",
                 "            .build();",
                 "    this.reliesOnMultibindingProvider =",
                 "        ParentModule_ReliesOnMultibindingFactory.create(",
-                "            builder.parentModule, setOfObjectProvider);",
+                "            parentModuleParam, setOfObjectProvider);",
                 "  }",
                 "",
                 "  private final class TestSubcomponentImpl implements TestSubcomponent {",
diff --git a/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java b/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java
index 4f0154d91..998eb1ac0 100644
--- a/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java
+++ b/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java
@@ -177,7 +177,7 @@ public void toDoubleCheck() {
                 .addLinesIn(
                     DEFAULT_MODE,
                     "  @SuppressWarnings(\"unchecked\")",
-                    "  private void initialize(final Builder builder) {",
+                    "  private void initialize() {",
                     "    this.regularScopedProvider = ",
                     "        DoubleCheck.provider(RegularScoped_Factory.create());",
                     "    this.reusableScopedProvider = ",
@@ -256,7 +256,7 @@ public void toSingleCheck() {
                 .addLinesIn(
                     DEFAULT_MODE,
                     "  @SuppressWarnings(\"unchecked\")",
-                    "  private void initialize(final Builder builder) {",
+                    "  private void initialize() {",
                     "    this.regularScopedProvider = ",
                     "        DoubleCheck.provider(RegularScoped_Factory.create());",
                     "    this.reusableScopedProvider = ",
@@ -332,7 +332,7 @@ public void toUnscoped() {
                 .addLinesIn(
                     DEFAULT_MODE,
                     "  @SuppressWarnings(\"unchecked\")",
-                    "  private void initialize(final Builder builder) {",
+                    "  private void initialize() {",
                     "    this.regularScopedProvider = ",
                     "        DoubleCheck.provider(RegularScoped_Factory.create());",
                     "    this.reusableScopedProvider = ",
@@ -410,7 +410,7 @@ public void castNeeded_rawTypes_Provider_get() {
                     "  private Provider subtypeProvider;",
                     "",
                     "  @SuppressWarnings(\"unchecked\")",
-                    "  private void initialize(final Builder builder) {",
+                    "  private void initialize() {",
                     "    this.subtypeProvider = DoubleCheck.provider(Subtype_Factory.create());",
                     "  }",
                     "",
@@ -911,7 +911,7 @@ public void providerWhenBindsScopeGreaterThanDependencyScope() {
                     "  private Provider<Object> bindStringProvider;",
                     "",
                     "  @SuppressWarnings(\"unchecked\")",
-                    "  private void initialize(final Builder builder) {",
+                    "  private void initialize() {",
                     "    this.provideStringProvider =",
                     "        SingleCheck.provider(TestModule_ProvideStringFactory.create());",
                     "    this.bindStringProvider =",
diff --git a/javatests/dagger/internal/codegen/ElidedFactoriesTest.java b/javatests/dagger/internal/codegen/ElidedFactoriesTest.java
index 07f29f56b..f8a9ab554 100644
--- a/javatests/dagger/internal/codegen/ElidedFactoriesTest.java
+++ b/javatests/dagger/internal/codegen/ElidedFactoriesTest.java
@@ -86,7 +86,7 @@ public void simpleComponent() {
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerSimpleComponent implements SimpleComponent {",
-            "  private DaggerSimpleComponent(Builder builder) {}",
+            "  private DaggerSimpleComponent() {}",
             "",
             "  public static Builder builder() {",
             "    return new Builder();",
@@ -106,7 +106,7 @@ public void simpleComponent() {
             "    }",
             "",
             "    public SimpleComponent build() {",
-            "      return new DaggerSimpleComponent(this);",
+            "      return new DaggerSimpleComponent();",
             "    }",
             "  }",
             "}");
@@ -190,7 +190,7 @@ public void simpleComponent_injectsProviderOf_dependsOnScoped() {
                 "  private volatile Object scopedType = new MemoizedSentinel();",
                 "  private volatile Provider<DependsOnScoped> dependsOnScopedProvider;",
                 "",
-                "  private DaggerSimpleComponent(Builder builder) {}",
+                "  private DaggerSimpleComponent() {}",
                 "",
                 "  public static Builder builder() {",
                 "    return new Builder();",
@@ -236,7 +236,7 @@ public void simpleComponent_injectsProviderOf_dependsOnScoped() {
                 "    private Builder() {}",
                 "",
                 "    public SimpleComponent build() {",
-                "      return new DaggerSimpleComponent(this);",
+                "      return new DaggerSimpleComponent();",
                 "    }",
                 "  }",
                 "  private final class SwitchingProvider<T> implements Provider<T> {",
@@ -272,8 +272,8 @@ public void simpleComponent_injectsProviderOf_dependsOnScoped() {
                 "  private Provider<ScopedType> scopedTypeProvider;",
                 "  private Provider<DependsOnScoped> dependsOnScopedProvider;",
                 "",
-                "  private DaggerSimpleComponent(Builder builder) {",
-                "    initialize(builder);",
+                "  private DaggerSimpleComponent() {",
+                "    initialize();",
                 "  }",
                 "",
                 "  public static Builder builder() {",
@@ -285,7 +285,7 @@ public void simpleComponent_injectsProviderOf_dependsOnScoped() {
                 "  }",
                 "",
                 "  @SuppressWarnings(\"unchecked\")",
-                "  private void initialize(final Builder builder) {",
+                "  private void initialize() {",
                 "    this.scopedTypeProvider = DoubleCheck.provider(ScopedType_Factory.create());",
                 "    this.dependsOnScopedProvider = ",
                 "        DependsOnScoped_Factory.create(scopedTypeProvider);",
@@ -301,7 +301,7 @@ public void simpleComponent_injectsProviderOf_dependsOnScoped() {
                 "    }",
                 "",
                 "    public SimpleComponent build() {",
-                "      return new DaggerSimpleComponent(this);",
+                "      return new DaggerSimpleComponent();",
                 "    }",
                 "  }",
                 "}");
@@ -383,7 +383,7 @@ public void scopedBinding_onlyUsedInSubcomponent() {
                 "public final class DaggerSimpleComponent implements SimpleComponent {",
                 "  private volatile Object scopedType = new MemoizedSentinel();",
                 "",
-                "  private DaggerSimpleComponent(Builder builder) {}",
+                "  private DaggerSimpleComponent() {}",
                 "",
                 "  public static Builder builder() {",
                 "    return new Builder();",
@@ -416,7 +416,7 @@ public void scopedBinding_onlyUsedInSubcomponent() {
                 "    private Builder() {}",
                 "",
                 "    public SimpleComponent build() {",
-                "      return new DaggerSimpleComponent(this);",
+                "      return new DaggerSimpleComponent();",
                 "    }",
                 "  }",
                 "",
@@ -444,8 +444,8 @@ public void scopedBinding_onlyUsedInSubcomponent() {
                 "public final class DaggerSimpleComponent implements SimpleComponent {",
                 "  private Provider<ScopedType> scopedTypeProvider;",
                 "",
-                "  private DaggerSimpleComponent(Builder builder) {",
-                "    initialize(builder);",
+                "  private DaggerSimpleComponent() {",
+                "    initialize();",
                 "  }",
                 "",
                 "  public static Builder builder() {",
@@ -457,7 +457,7 @@ public void scopedBinding_onlyUsedInSubcomponent() {
                 "  }",
                 "",
                 "  @SuppressWarnings(\"unchecked\")",
-                "  private void initialize(final Builder builder) {",
+                "  private void initialize() {",
                 "    this.scopedTypeProvider = DoubleCheck.provider(ScopedType_Factory.create());",
                 "  }",
                 "",
@@ -470,7 +470,7 @@ public void scopedBinding_onlyUsedInSubcomponent() {
                 "    private Builder() {}",
                 "",
                 "    public SimpleComponent build() {",
-                "      return new DaggerSimpleComponent(this);",
+                "      return new DaggerSimpleComponent();",
                 "    }",
                 "  }",
                 "",
diff --git a/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
index e32b46042..84aa60ddf 100644
--- a/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -213,11 +213,13 @@ public void mapBindingsWithEnumKey() {
                 "      mapOfPathEnumAndProviderOfHandlerProvider;",
                 "",
                 "  @SuppressWarnings(\"unchecked\")",
-                "  private void initialize(final Builder builder) {",
+                "  private void initialize(",
+                "      final MapModuleOne mapModuleOneParam,",
+                "      final MapModuleTwo mapModuleTwoParam) {",
                 "    this.provideAdminHandlerProvider =",
-                "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
+                "        MapModuleOne_ProvideAdminHandlerFactory.create(mapModuleOneParam);",
                 "    this.provideLoginHandlerProvider =",
-                "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
+                "        MapModuleTwo_ProvideLoginHandlerFactory.create(mapModuleTwoParam);",
                 "    this.mapOfPathEnumAndProviderOfHandlerProvider =",
                 "        MapProviderFactory.<PathEnum, Handler>builder(2)",
                 "            .put(PathEnum.ADMIN, provideAdminHandlerProvider)",
@@ -371,7 +373,7 @@ public void mapBindingsWithInaccessibleKeys() {
                 "  }",
                 "",
                 "  @SuppressWarnings(\"unchecked\")",
-                "  private void initialize(final Builder builder) {",
+                "  private void initialize() {",
                 "    this.mapOfClassOfAndIntegerProvider =",
                 "        MapFactory.<Class<?>, Integer>builder(1)",
                 "            .put(MapModule_ClassKeyMapKey.create(),",
@@ -619,11 +621,13 @@ public void mapBindingsWithStringKey() {
                 "      mapOfStringAndProviderOfHandlerProvider;",
                 "",
                 "  @SuppressWarnings(\"unchecked\")",
-                "  private void initialize(final Builder builder) {",
+                "  private void initialize(",
+                "      final MapModuleOne mapModuleOneParam,",
+                "      final MapModuleTwo mapModuleTwoParam) {",
                 "    this.provideAdminHandlerProvider =",
-                "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
+                "        MapModuleOne_ProvideAdminHandlerFactory.create(mapModuleOneParam);",
                 "    this.provideLoginHandlerProvider =",
-                "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
+                "        MapModuleTwo_ProvideLoginHandlerFactory.create(mapModuleTwoParam);",
                 "    this.mapOfStringAndProviderOfHandlerProvider =",
                 "        MapProviderFactory.<String, Handler>builder(2)",
                 "            .put(\"Admin\", provideAdminHandlerProvider)",
@@ -742,9 +746,11 @@ public void mapBindingsWithWrappedKey() {
                 "  private MapModuleOne mapModuleOne;",
                 "  private MapModuleTwo mapModuleTwo;",
                 "",
-                "  private DaggerTestComponent(Builder builder) {",
-                "    this.mapModuleOne = builder.mapModuleOne;",
-                "    this.mapModuleTwo = builder.mapModuleTwo;",
+                "  private DaggerTestComponent(",
+                "      MapModuleOne mapModuleOneParam,",
+                "      MapModuleTwo mapModuleTwoParam) {",
+                "    this.mapModuleOne = mapModuleOneParam;",
+                "    this.mapModuleTwo = mapModuleTwoParam;",
                 "  }",
                 "",
                 "  private Provider<Handler> getProvideAdminHandlerProvider() {",
@@ -825,11 +831,13 @@ public void mapBindingsWithWrappedKey() {
                 "      mapOfWrappedClassKeyAndProviderOfHandlerProvider;",
                 "",
                 "  @SuppressWarnings(\"unchecked\")",
-                "  private void initialize(final Builder builder) {",
+                "  private void initialize(",
+                "      final MapModuleOne mapModuleOneParam,",
+                "      final MapModuleTwo mapModuleTwoParam) {",
                 "    this.provideAdminHandlerProvider =",
-                "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
+                "        MapModuleOne_ProvideAdminHandlerFactory.create(mapModuleOneParam);",
                 "    this.provideLoginHandlerProvider =",
-                "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
+                "        MapModuleTwo_ProvideLoginHandlerFactory.create(mapModuleTwoParam);",
                 "    this.mapOfWrappedClassKeyAndProviderOfHandlerProvider =",
                 "        MapProviderFactory.<WrappedClassKey, Handler>builder(2)",
                 "            .put(WrappedClassKeyCreator.createWrappedClassKey(Integer.class),",
@@ -1001,11 +1009,13 @@ public void mapBindingsWithNonProviderValue() {
                 "  private Provider<Map<PathEnum, Handler>> mapOfPathEnumAndHandlerProvider;",
                 "",
                 "  @SuppressWarnings(\"unchecked\")",
-                "  private void initialize(final Builder builder) {",
+                "  private void initialize(",
+                "        final MapModuleOne mapModuleOneParam,",
+                "        final MapModuleTwo mapModuleTwoParam) {",
                 "    this.provideAdminHandlerProvider =",
-                "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
+                "        MapModuleOne_ProvideAdminHandlerFactory.create(mapModuleOneParam);",
                 "    this.provideLoginHandlerProvider =",
-                "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
+                "        MapModuleTwo_ProvideLoginHandlerFactory.create(mapModuleTwoParam);",
                 "    this.mapOfPathEnumAndHandlerProvider =",
                 "        MapFactory.<PathEnum, Handler>builder(2)",
                 "            .put(PathEnum.ADMIN, provideAdminHandlerProvider)",
diff --git a/javatests/dagger/internal/codegen/MembersInjectionTest.java b/javatests/dagger/internal/codegen/MembersInjectionTest.java
index 824f4a46e..9dd924bb0 100644
--- a/javatests/dagger/internal/codegen/MembersInjectionTest.java
+++ b/javatests/dagger/internal/codegen/MembersInjectionTest.java
@@ -1401,7 +1401,7 @@ public void accessibleRawType_ofInaccessibleType() {
                 "  private Provider inaccessiblesProvider;",
                 "",
                 "  @SuppressWarnings(\"unchecked\")",
-                "  private void initialize(final Builder builder) {",
+                "  private void initialize() {",
                 "    this.inaccessiblesProvider =",
                 "        DoubleCheck.provider(InaccessiblesModule_InaccessiblesFactory.create());",
                 "  }")
diff --git a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
index 37983fe60..2a685f1c3 100644
--- a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -263,9 +263,11 @@ public void simpleComponent() {
                 "  private Producer<TestClass.B> bProducer;",
                 "  private Producer<TestClass.A> aProducer;",
                 "",
-                "  private DaggerTestClass_SimpleComponent(Builder builder) {",
-                "    this.bModule = builder.bModule;",
-                "    initialize(builder);",
+                "  private DaggerTestClass_SimpleComponent(",
+                "      TestClass.AModule aModuleParam,",
+                "      TestClass.BModule bModuleParam) {",
+                "    this.bModule = bModuleParam;",
+                "    initialize(aModuleParam, bModuleParam);",
                 "  }",
                 "",
                 "  public static Builder builder() {",
@@ -346,13 +348,15 @@ public void simpleComponent() {
                 "  }",
                 "",
                 "  @SuppressWarnings(\"unchecked\")",
-                "  private void initialize(final Builder builder) {",
+                "  private void initialize(",
+                "      final TestClass.AModule aModuleParam,",
+                "      final TestClass.BModule bModuleParam) {",
                 "    this.simpleComponentProvider =",
                 "        InstanceFactory.create((TestClass.SimpleComponent) this);",
                 "    this.bProducer = Producers.producerFromProvider(getBProvider());",
                 "    this.aProducer =",
                 "        TestClass_AModule_AFactory.create(",
-                "            builder.aModule,",
+                "            aModuleParam,",
                 "            getProductionImplementationExecutorProvider(),",
                 "            getProductionComponentMonitorProvider(),",
                 "            bProducer);",
@@ -383,7 +387,7 @@ public void simpleComponent() {
                 "      if (bModule == null) {",
                 "        this.bModule = new TestClass.BModule();",
                 "      }",
-                "      return new DaggerTestClass_SimpleComponent(this);",
+                "      return new DaggerTestClass_SimpleComponent(aModule, bModule);",
                 "    }",
                 "",
                 "    public Builder aModule(TestClass.AModule aModule) {",
@@ -451,8 +455,10 @@ public void simpleComponent() {
                 "  private Producer<TestClass.B> bProducer;",
                 "  private Producer<TestClass.A> aProducer;",
                 "",
-                "  private DaggerTestClass_SimpleComponent(Builder builder) {",
-                "    initialize(builder);",
+                "  private DaggerTestClass_SimpleComponent(",
+                "      TestClass.AModule aModuleParam,",
+                "      TestClass.BModule bModuleParam) {",
+                "    initialize(aModuleParam, bModuleParam);",
                 "  }",
                 "",
                 "  public static Builder builder() {",
@@ -464,9 +470,11 @@ public void simpleComponent() {
                 "  }",
                 "",
                 "  @SuppressWarnings(\"unchecked\")",
-                "  private void initialize(final Builder builder) {",
+                "  private void initialize(",
+                "      final TestClass.AModule aModuleParam,",
+                "      final TestClass.BModule bModuleParam) {",
                 "    this.executorProvider =",
-                "        TestClass_BModule_ExecutorFactory.create(builder.bModule);",
+                "        TestClass_BModule_ExecutorFactory.create(bModuleParam);",
                 "    this.productionImplementationExecutorProvider =",
                 "        DoubleCheck.provider((Provider) executorProvider);",
                 "    this.simpleComponentProvider = ",
@@ -477,10 +485,10 @@ public void simpleComponent() {
                 "                simpleComponentProvider,",
                 "                SetFactory.<ProductionComponentMonitor.Factory>empty()));",
                 "    this.bProvider = TestClass_BModule_BFactory.create(",
-                "        builder.bModule, TestClass_C_Factory.create());",
+                "        bModuleParam, TestClass_C_Factory.create());",
                 "    this.bProducer = Producers.producerFromProvider(bProvider);",
                 "    this.aProducer = TestClass_AModule_AFactory.create(",
-                "        builder.aModule,",
+                "        aModuleParam,",
                 "        productionImplementationExecutorProvider,",
                 "        monitorProvider,",
                 "        bProducer);",
@@ -511,7 +519,7 @@ public void simpleComponent() {
                 "      if (bModule == null) {",
                 "        this.bModule = new TestClass.BModule();",
                 "      }",
-                "      return new DaggerTestClass_SimpleComponent(this);",
+                "      return new DaggerTestClass_SimpleComponent(aModule, bModule);",
                 "    }",
                 "",
                 "    public Builder aModule(TestClass.AModule aModule) {",
diff --git a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentTest.java b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentTest.java
index 046061689..d3eb767b2 100644
--- a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentTest.java
+++ b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentTest.java
@@ -268,7 +268,7 @@ public void subcomponentOmitsInheritedBindings() {
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerParent implements Parent {",
-            "  private DaggerParent(Builder builder) {}",
+            "  private DaggerParent() {}",
             "",
             "  public static Builder builder() {",
             "    return new Builder();",
@@ -287,7 +287,7 @@ public void subcomponentOmitsInheritedBindings() {
             "    private Builder() {}",
             "",
             "    public Parent build() {",
-            "      return new DaggerParent(this);",
+            "      return new DaggerParent();",
             "    }",
             "",
             "    @Deprecated",
diff --git a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
index 20ef6a2b6..f49e89b44 100644
--- a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
+++ b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
@@ -336,7 +336,7 @@ public void productionComponents() {
             GENERATED_ANNOTATION,
             "public final class DaggerTestComponent implements TestComponent, "
                 + "CancellationListener {",
-            "  private DaggerTestComponent(Builder builder) {}",
+            "  private DaggerTestComponent() {}",
             "",
             "  public static Builder builder() {",
             "    return new Builder();",
@@ -363,7 +363,7 @@ public void productionComponents() {
             "    private Builder() {}",
             "",
             "    public TestComponent build() {",
-            "      return new DaggerTestComponent(this);",
+            "      return new DaggerTestComponent();",
             "    }",
             "  }",
             "}");
diff --git a/javatests/dagger/internal/codegen/SubcomponentBuilderRequestFulfillmentTest.java b/javatests/dagger/internal/codegen/SubcomponentBuilderRequestFulfillmentTest.java
index d391622b8..27a6844fb 100644
--- a/javatests/dagger/internal/codegen/SubcomponentBuilderRequestFulfillmentTest.java
+++ b/javatests/dagger/internal/codegen/SubcomponentBuilderRequestFulfillmentTest.java
@@ -91,7 +91,7 @@ public void testInlinedSubcomponentBuilders_componentMethod() {
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerC implements C {",
-            "  private DaggerC(Builder builder) {}",
+            "  private DaggerC() {}",
             "",
             "  public static Builder builder() {",
             "    return new Builder();",
@@ -115,19 +115,19 @@ public void testInlinedSubcomponentBuilders_componentMethod() {
             "    private Builder() {}",
             "",
             "    public C build() {",
-            "      return new DaggerC(this);",
+            "      return new DaggerC();",
             "    }",
             "  }",
             "",
             "  private final class SubBuilder implements Sub.Builder {",
             "    @Override",
             "    public Sub build() {",
-            "      return new SubImpl(this);",
+            "      return new SubImpl();",
             "    }",
             "  }",
             "",
             "  private final class SubImpl implements Sub {",
-            "    private SubImpl(SubBuilder builder) {}",
+            "    private SubImpl() {}",
             "  }",
             "}");
 
diff --git a/javatests/dagger/internal/codegen/SubcomponentValidationTest.java b/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
index ca3fd35ae..9b0bcfa88 100644
--- a/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
+++ b/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
@@ -468,7 +468,7 @@ public void delegateFactoryNotCreatedForSubcomponentWhenProviderExistsInParent()
             .addLinesIn(
                 DEFAULT_MODE,
                 "  @SuppressWarnings(\"unchecked\")",
-                "  private void initialize(final Builder builder) {",
+                "  private void initialize() {",
                 "    this.dep1Provider = DoubleCheck.provider(Dep1_Factory.create());",
                 "    this.dep2Provider = DoubleCheck.provider(Dep2_Factory.create());",
                 "  }",
@@ -677,7 +677,7 @@ public void multipleSubcomponentsWithSameSimpleNamesCanExistInSameComponent() {
             "",
             "  public static final class Builder {",
             "    public ParentComponent build() {",
-            "      return new DaggerParentComponent(this);",
+            "      return new DaggerParentComponent();",
             "    }",
             "  }",
             "",
@@ -755,7 +755,7 @@ public void subcomponentSimpleNamesDisambiguated() {
             "",
             "  public static final class Builder {",
             "    public ParentComponent build() {",
-            "      return new DaggerParentComponent(this);",
+            "      return new DaggerParentComponent();",
             "    }",
             "  }",
             "",
@@ -1024,23 +1024,23 @@ public void subcomponentBuilderNamesShouldNotConflict() {
             "  private final class F_SubBuilder implements C.Foo.Sub.Builder {",
             "    @Override",
             "    public C.Foo.Sub build() {",
-            "      return new F_SubImpl(this);",
+            "      return new F_SubImpl();",
             "    }",
             "  }",
             "",
             "  private final class F_SubImpl implements C.Foo.Sub {",
-            "    private F_SubImpl(F_SubBuilder builder) {}",
+            "    private F_SubImpl() {}",
             "  }",
             "",
             "  private final class B_SubBuilder implements C.Bar.Sub.Builder {",
             "    @Override",
             "    public C.Bar.Sub build() {",
-            "      return new B_SubImpl(this);",
+            "      return new B_SubImpl();",
             "    }",
             "  }",
             "",
             "  private final class B_SubImpl implements C.Bar.Sub {",
-            "    private B_SubImpl(B_SubBuilder builder) {}",
+            "    private B_SubImpl() {}",
             "  }",
             "}");
     Compilation compilation =
diff --git a/javatests/dagger/internal/codegen/SwitchingProviderTest.java b/javatests/dagger/internal/codegen/SwitchingProviderTest.java
index cfd4706ee..887c75091 100644
--- a/javatests/dagger/internal/codegen/SwitchingProviderTest.java
+++ b/javatests/dagger/internal/codegen/SwitchingProviderTest.java
@@ -474,7 +474,7 @@ public void memberInjectors() {
                 "  private Provider<MembersInjector<Foo>> fooMembersInjectorProvider;",
                 "",
                 "  @SuppressWarnings(\"unchecked\")",
-                "  private void initialize(final Builder builder) {",
+                "  private void initialize() {",
                 "    this.fooMembersInjectorProvider = ",
                 "        InstanceFactory.create(MembersInjectors.<Foo>noOp());",
                 "  }",
@@ -542,7 +542,6 @@ public void optionals() {
                 "",
                 GENERATED_ANNOTATION,
                 "public final class DaggerTestComponent implements TestComponent {",
-
                 "  @SuppressWarnings(\"rawtypes\")",
                 "  private static final Provider ABSENT_JDK_OPTIONAL_PROVIDER =",
                 "      InstanceFactory.create(Optional.empty());",
@@ -552,7 +551,7 @@ public void optionals() {
                 "  private Provider<Optional<Absent>> optionalOfAbsentProvider;",
                 "",
                 "  @SuppressWarnings(\"unchecked\")",
-                "  private void initialize(final Builder builder) {",
+                "  private void initialize() {",
                 "    this.optionalOfAbsentProvider = absentJdkOptionalProvider();",
                 "  }",
                 "",
