diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ResponseProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ResponseProducerModule.java
index 0ef2ae886..02fa7e91f 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ResponseProducerModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ResponseProducerModule.java
@@ -17,18 +17,40 @@
 
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
+import dagger.Lazy;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
+import javax.inject.Provider;
+import javax.inject.Qualifier;
 
 @ProducerModule(includes = ResponseModule.class)
 final class ResponseProducerModule {
+  @Qualifier
+  @interface RequestsProducerAndProduced {}
+
   @Produces
   static ListenableFuture<String> greeting() {
     return Futures.immediateFuture("Hello");
   }
 
   @Produces
-  static Response response(String greeting, Request request, int requestNumber) {
+  @RequestsProducerAndProduced
+  static ListenableFuture<String> intermediateGreeting(
+      // TODO(beder): Allow Producer and Provider of the same type (which would force the binding
+      // to be a provision binding), and add validation for that.
+      String greeting,
+      Producer<String> greetingProducer,
+      Produced<String> greetingProduced,
+      Provider<Integer> requestNumberProvider,
+      Lazy<Integer> requestNumberLazy) {
+    return greetingProducer.get();
+  }
+
+  @Produces
+  static Response response(
+      @RequestsProducerAndProduced String greeting, Request request, int requestNumber) {
     return new Response(String.format("%s, %s #%d!", greeting, request.name(), requestNumber));
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 5b791b674..4d5926aff 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -965,7 +965,7 @@ private Snippet initializeFactoryForContributionBinding(ContributionBinding bind
               && !binding.bindingElement().getModifiers().contains(STATIC)) {
             parameters.add(getComponentContributionSnippet(binding.contributedBy().get()));
           }
-          parameters.addAll(getDependencyParameters(binding));
+          parameters.addAll(getDependencyParameters(binding, DependencyRequestMapper.FOR_PROVIDER));
 
           Snippet factorySnippet =
               Snippet.format(
@@ -1011,7 +1011,7 @@ private Snippet initializeFactoryForContributionBinding(ContributionBinding bind
           parameters.add(
               getComponentContributionSnippet(
                   graph.componentDescriptor().executorDependency().get()));
-          parameters.addAll(getProducerDependencyParameters(binding));
+          parameters.addAll(getDependencyParameters(binding, DependencyRequestMapper.FOR_PRODUCER));
 
           return Snippet.format(
               "new %s(%s)",
@@ -1035,7 +1035,8 @@ private Snippet initializeMembersInjectorForBinding(MembersInjectionBinding bind
       case NO_OP:
         return Snippet.format("%s.noOp()", ClassName.fromClass(MembersInjectors.class));
       case INJECT_MEMBERS:
-        List<Snippet> parameters = getDependencyParameters(binding);
+        List<Snippet> parameters =
+            getDependencyParameters(binding, DependencyRequestMapper.FOR_PROVIDER);
         return Snippet.format(
             "%s.create(%s)",
             membersInjectorNameForType(binding.bindingElement()),
@@ -1045,7 +1046,8 @@ private Snippet initializeMembersInjectorForBinding(MembersInjectionBinding bind
     }
   }
 
-  private List<Snippet> getDependencyParameters(Binding binding) {
+  private List<Snippet> getDependencyParameters(
+      Binding binding, DependencyRequestMapper dependencyRequestMapper) {
     ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
     Set<Key> keysSeen = new HashSet<>();
     for (Collection<DependencyRequest> requestsForKey :
@@ -1060,8 +1062,21 @@ private Snippet initializeMembersInjectorForBinding(MembersInjectionBinding bind
         }
       }
       if (!requestedBindingKeys.isEmpty()) {
+        Class<?> frameworkClass = dependencyRequestMapper.getFrameworkClass(requestsForKey);
         BindingKey key = Iterables.getOnlyElement(requestedBindingKeys);
-        parameters.add(getMemberSelect(key).getSnippetWithRawTypeCastFor(name));
+        ResolvedBindings resolvedBindings = graph.resolvedBindings().get(key);
+        Snippet frameworkSnippet = getMemberSelect(key).getSnippetWithRawTypeCastFor(name);
+        if (FrameworkField.frameworkClassForResolvedBindings(resolvedBindings)
+                .equals(Provider.class)
+            && frameworkClass.equals(Producer.class)) {
+          parameters.add(
+              Snippet.format(
+                  "%s.producerFromProvider(%s)",
+                  ClassName.fromClass(Producers.class),
+                  frameworkSnippet));
+        } else {
+          parameters.add(frameworkSnippet);
+        }
       }
     }
     return parameters.build();
@@ -1082,31 +1097,6 @@ private TypeMirror typeMirrorAsMemberOf(TypeElement bindingTypeElement, Element
     }
   }
 
-  private List<Snippet> getProducerDependencyParameters(Binding binding) {
-    ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
-    for (Collection<DependencyRequest> requestsForKey :
-        SourceFiles.indexDependenciesByUnresolvedKey(types, binding.implicitDependencies())
-            .asMap()
-            .values()) {
-      BindingKey key = Iterables.getOnlyElement(FluentIterable.from(requestsForKey)
-          .transform(DependencyRequest.BINDING_KEY_FUNCTION));
-      ResolvedBindings resolvedBindings = graph.resolvedBindings().get(key);
-      Class<?> frameworkClass =
-          DependencyRequestMapper.FOR_PRODUCER.getFrameworkClass(requestsForKey);
-      if (FrameworkField.frameworkClassForResolvedBindings(resolvedBindings).equals(Provider.class)
-          && frameworkClass.equals(Producer.class)) {
-        parameters.add(
-            Snippet.format(
-                "%s.producerFromProvider(%s)",
-                ClassName.fromClass(Producers.class),
-                getMemberSelectSnippet(key)));
-      } else {
-        parameters.add(getMemberSelectSnippet(key));
-      }
-    }
-    return parameters.build();
-  }
-
   private Snippet initializeMapBinding(Set<ContributionBinding> bindings) {
     // Get type information from the first binding.
     ContributionBinding firstBinding = bindings.iterator().next();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 90a0337bd..dcf7e4874 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -176,9 +176,9 @@ public boolean apply(DependencyRequest dependency) {
       computeMethodWriter
           .body()
           .addSnippet(
-              "%s %sFuture = %s;",
+              "%s %s = %s;",
               futureType,
-              name,
+              dependencyFutureName(dependency),
               dependency.kind().equals(DependencyRequest.Kind.PRODUCED)
                   ? Snippet.format(
                       "%s.createFutureProduced(%s)",
@@ -220,6 +220,11 @@ public boolean apply(DependencyRequest dependency) {
     return ImmutableSet.of(writer);
   }
 
+  /** Returns a name of the variable representing this dependency's future. */
+  private static String dependencyFutureName(DependencyRequest dependency) {
+    return dependency.requestElement().getSimpleName() + "Future";
+  }
+
   /** Represents the transformation of an input future by a producer method. */
   abstract static class FutureTransform {
     protected final ImmutableMap<BindingKey, FrameworkField> fields;
@@ -312,7 +317,7 @@ String applyArgName() {
 
     @Override
     Snippet futureSnippet() {
-      return Snippet.format("%s", fields.get(asyncDependency.bindingKey()).name() + "Future");
+      return Snippet.format("%s", dependencyFutureName(asyncDependency));
     }
 
     @Override
@@ -363,12 +368,11 @@ Snippet futureSnippet() {
           ClassName.fromClass(Object.class),
           makeParametersSnippet(
               FluentIterable.from(asyncDependencies)
-                  .transform(DependencyRequest.BINDING_KEY_FUNCTION)
                   .transform(
-                      new Function<BindingKey, Snippet>() {
+                      new Function<DependencyRequest, Snippet>() {
                         @Override
-                        public Snippet apply(BindingKey bindingKey) {
-                          return Snippet.format("%s", fields.get(bindingKey).name() + "Future");
+                        public Snippet apply(DependencyRequest dependency) {
+                          return Snippet.format("%s", dependencyFutureName(dependency));
                         }
                       })));
     }
