diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeys.java b/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
index b0cb00db0..00ae1d337 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
@@ -20,8 +20,8 @@
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
-import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.TypeName;
 import dagger.MapKey;
 import java.util.List;
@@ -66,7 +66,7 @@
     ImmutableSet<? extends AnnotationMirror> mapKeys = getMapKeys(bindingElement);
     return mapKeys.isEmpty()
         ? Optional.<AnnotationMirror>absent()
-        : Optional.of(getOnlyElement(mapKeys));
+        : Optional.<AnnotationMirror>of(getOnlyElement(mapKeys));
   }
 
   /**
diff --git a/compiler/src/test/java/dagger/internal/codegen/BindsMethodValidatorTest.java b/compiler/src/test/java/dagger/internal/codegen/BindsMethodValidatorTest.java
index 13aafff1f..05071f493 100644
--- a/compiler/src/test/java/dagger/internal/codegen/BindsMethodValidatorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/BindsMethodValidatorTest.java
@@ -16,19 +16,20 @@
 package dagger.internal.codegen;
 
 import com.google.common.collect.ImmutableList;
-import com.google.testing.compile.JavaFileObjects;
 import dagger.Module;
 import dagger.producers.ProducerModule;
+import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.util.Collection;
-import javax.tools.JavaFileObject;
+import javax.inject.Qualifier;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
 
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatMethodInUnannotatedClass;
+import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatModuleMethod;
 
 @RunWith(Parameterized.class)
 public class BindsMethodValidatorTest {
@@ -37,141 +38,74 @@
     return ImmutableList.copyOf(new Object[][] {{Module.class}, {ProducerModule.class}});
   }
 
-  private final Class<? extends Annotation> moduleAnnotation;
+  private final String moduleDeclaration;
 
   public BindsMethodValidatorTest(Class<? extends Annotation> moduleAnnotation) {
-    this.moduleAnnotation = moduleAnnotation;
+    moduleDeclaration = "@" + moduleAnnotation.getCanonicalName() + " abstract class %s { %s }";
   }
 
   @Test
   public void nonAbstract() {
-    JavaFileObject moduleFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Binds;",
-            "",
-            "@" + moduleAnnotation.getCanonicalName(),
-            "abstract class TestModule {",
-            "  @Binds Object bindObject(String impl) { return null; }",
-            "}");
-    assertAbout(javaSource())
-        .that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("must be abstract")
-        .in(moduleFile)
-        .onLine(7);
+    assertThatMethod("@Binds Object concrete(String impl) { return null; }")
+        .hasError("must be abstract");
   }
 
   @Test
   public void notAssignable() {
-    JavaFileObject moduleFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Binds;",
-            "",
-            "@" + moduleAnnotation.getCanonicalName(),
-            "abstract class TestModule {",
-            "  @Binds abstract String bindString(Object impl);",
-            "}");
-    assertAbout(javaSource())
-        .that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("assignable")
-        .in(moduleFile)
-        .onLine(7);
+    assertThatMethod("@Binds abstract String notAssignable(Object impl);").hasError("assignable");
   }
-
+  
   @Test
-  public void moreThanOneParamter() {
-    JavaFileObject moduleFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Binds;",
-            "",
-            "@" + moduleAnnotation.getCanonicalName(),
-            "abstract class TestModule {",
-            "  @Binds abstract Object bindObject(String s1, String s2);",
-            "}");
-    assertAbout(javaSource())
-        .that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("one parameter")
-        .in(moduleFile)
-        .onLine(7);
+  public void moreThanOneParameter() {
+    assertThatMethod("@Binds abstract Object tooManyParameters(String s1, String s2);")
+        .hasError("one parameter");
   }
 
   @Test
   public void typeParameters() {
-    JavaFileObject moduleFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Binds;",
-            "",
-            "@" + moduleAnnotation.getCanonicalName(),
-            "abstract class TestModule {",
-            "  @Binds abstract <S, T extends S> S bindS(T t);",
-            "}");
-    assertAbout(javaSource())
-        .that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("type parameters")
-        .in(moduleFile)
-        .onLine(7);
+    assertThatMethod("@Binds abstract <S, T extends S> S generic(T t);")
+        .hasError("type parameters");
   }
 
   @Test
   public void notInModule() {
-    JavaFileObject moduleFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Binds;",
-            "",
-            "abstract class TestModule {",
-            "  @Binds abstract Object bindObject(String s);",
-            "}");
-    assertAbout(javaSource())
-        .that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("within a @Module or @ProducerModule")
-        .in(moduleFile)
-        .onLine(6);
+    assertThatMethodInUnannotatedClass("@Binds abstract Object bindObject(String s);")
+        .hasError("within a @Module or @ProducerModule");
   }
 
   @Test
   public void throwsException() {
-    JavaFileObject moduleFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Binds;",
-            "import java.io.IOException;",
-            "",
-            "@" + moduleAnnotation.getCanonicalName(),
-            "abstract class TestModule {",
-            "  @Binds abstract Object bindObject(String s1) throws IOException;",
-            "}");
-    assertAbout(javaSource())
-        .that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("only throw unchecked")
-        .in(moduleFile)
-        .onLine(8);
+    assertThatMethod("@Binds abstract Object throwsException(String s1) throws IOException;")
+        .importing(IOException.class)
+        .hasError("only throw unchecked");
+  }
+
+  @Test
+  @Ignore("TODO: @Binds methods do not check explicitly for void")
+  public void returnsVoid() {
+    assertThatMethod("@Binds abstract void returnsVoid(Object impl);").hasError("void");
+  }
+
+  @Test
+  public void tooManyQualifiers() {
+    assertThatMethod(
+            "@Binds @Qualifier1 @Qualifier2 abstract String tooManyQualifiers(String impl);")
+        .importing(Qualifier1.class, Qualifier2.class)
+        .hasError("more than one @Qualifier");
   }
+
+  @Test
+  public void noParameters() {
+    assertThatMethod("@Binds abstract Object noParameters();").hasError("one parameter");
+  }
+
+  private DaggerModuleMethodSubject assertThatMethod(String method) {
+    return assertThatModuleMethod(method).withDeclaration(moduleDeclaration);
+  }
+
+  @Qualifier
+  public @interface Qualifier1 {}
+
+  @Qualifier
+  public @interface Qualifier2 {}
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index 6f9e7e2e0..f535d430e 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -47,6 +47,7 @@
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+import static java.util.Arrays.asList;
 import static javax.tools.StandardLocation.SOURCE_OUTPUT;
 
 @RunWith(JUnit4.class)
@@ -2373,6 +2374,35 @@ public void scopeAnnotationOnInjectConstructorNotValid() {
         .onLine(6);
   }
 
+  @Test
+  public void attemptToInjectWildcardGenerics() {
+    JavaFileObject testComponent =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Lazy;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  Lazy<? extends Number> wildcardNumberLazy();",
+            "  Provider<? super Number> wildcardNumberProvider();",
+            "}");
+    assertAbout(javaSources())
+        .that(asList(testComponent))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("wildcard type")
+        .in(testComponent)
+        .onLine(9)
+        .and()
+        .withErrorContaining("wildcard type")
+        .in(testComponent)
+        .onLine(10);
+  }
+
   /**
    * A {@link ComponentProcessor} that excludes elements using a {@link Predicate}.
    */
diff --git a/compiler/src/test/java/dagger/internal/codegen/DaggerModuleMethodSubject.java b/compiler/src/test/java/dagger/internal/codegen/DaggerModuleMethodSubject.java
new file mode 100644
index 000000000..3581057bc
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/DaggerModuleMethodSubject.java
@@ -0,0 +1,192 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Function;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Iterables;
+import com.google.common.truth.FailureStrategy;
+import com.google.common.truth.Subject;
+import com.google.common.truth.SubjectFactory;
+import com.google.common.truth.Truth;
+import com.google.testing.compile.JavaFileObjects;
+import dagger.Module;
+import dagger.Multibindings;
+import dagger.producers.ProducerModule;
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.util.Arrays;
+import javax.tools.JavaFileObject;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+
+/** A {@link Truth} subject for testing Dagger module methods. */
+final class DaggerModuleMethodSubject extends Subject<DaggerModuleMethodSubject, String> {
+
+  /** A {@link Truth} subject factory for testing Dagger module methods. */
+  static final class Factory extends SubjectFactory<DaggerModuleMethodSubject, String> {
+
+    /** Starts a clause testing a Dagger {@link Module @Module} method. */
+    static DaggerModuleMethodSubject assertThatModuleMethod(String method) {
+      return assertAbout(daggerModuleMethod())
+          .that(method)
+          .withDeclaration("@Module abstract class %s { %s }");
+    }
+
+    /** Starts a clause testing a Dagger {@link ProducerModule @ProducerModule} method. */
+    static DaggerModuleMethodSubject assertThatProductionModuleMethod(String method) {
+      return assertAbout(daggerModuleMethod())
+          .that(method)
+          .withDeclaration("@ProducerModule abstract class %s { %s }");
+    }
+
+    /** Starts a clause testing a Dagger {@link Multibindings @Multibindings} interface method. */
+    static DaggerModuleMethodSubject assertThatMultibindingsMethod(String method) {
+      return assertAbout(daggerModuleMethod())
+          .that(method)
+          .withDeclaration("@Module abstract class %s { @Multibindings interface Empties { %s }}");
+    }
+
+    /** Starts a clause testing a method in an unannotated class. */
+    static DaggerModuleMethodSubject assertThatMethodInUnannotatedClass(String method) {
+      return assertAbout(daggerModuleMethod())
+          .that(method)
+          .withDeclaration("abstract class %s { %s }");
+    }
+
+    static Factory daggerModuleMethod() {
+      return new Factory();
+    }
+
+    private Factory() {}
+
+    @Override
+    public DaggerModuleMethodSubject getSubject(FailureStrategy fs, String that) {
+      return new DaggerModuleMethodSubject(fs, that);
+    }
+  }
+
+  private ImmutableList.Builder<String> imports =
+      new ImmutableList.Builder<String>()
+          .add(
+              "import dagger.*;",
+              "import dagger.multibindings.*;",
+              "import dagger.producers.*;",
+              "import java.util.*;",
+              "import javax.inject.*;");
+  private String declaration;
+  private ImmutableList<JavaFileObject> additionalSources = ImmutableList.of();
+
+  private DaggerModuleMethodSubject(FailureStrategy failureStrategy, String subject) {
+    super(failureStrategy, subject);
+  }
+
+  /**
+   * Imports classes and interfaces. Note that all types in the following packages are already
+   * imported:<ul>
+   * <li>{@code dagger.*}
+   * <li>{@code dagger.multibindings.*}
+   * <li>(@code dagger.producers.*}
+   * <li>{@code java.util.*}
+   * <li>{@code javax.inject.*}
+   * </ul>
+   */
+  DaggerModuleMethodSubject importing(Class<?>... imports) {
+    return importing(FluentIterable.from(Arrays.asList(imports)));
+  }
+
+  /**
+   * Imports classes and interfaces. Note that all types in the following packages are already
+   * imported:<ul>
+   * <li>{@code dagger.*}
+   * <li>{@code dagger.multibindings.*}
+   * <li>(@code dagger.producers.*}
+   * <li>{@code java.util.*}
+   * <li>{@code javax.inject.*}
+   * </ul>
+   */
+  DaggerModuleMethodSubject importing(Iterable<? extends Class<?>> imports) {
+    this.imports.addAll(Iterables.transform(imports, IMPORT));
+    return this;
+  }
+
+  /**
+   * Sets the declaration of the module. Must be a string with two {@code %s} parameters. The first
+   * will be replaced with the name of the type, and the second with the method declaration, which
+   * must be within paired braces.
+   */
+  DaggerModuleMethodSubject withDeclaration(String declaration) {
+    this.declaration = declaration;
+    return this;
+  }
+
+  /** Additional source files that must be compiled with the module. */
+  DaggerModuleMethodSubject withAdditionalSources(JavaFileObject... sources) {
+    this.additionalSources = ImmutableList.copyOf(sources);
+    return this;
+  }
+
+  /**
+   * Fails if compiling the module with the method doesn't report an error at the method
+   * declaration whose message contains {@code errorSubstring}.
+   */
+  void hasError(String errorSubstring) {
+    String source = moduleSource();
+    JavaFileObject module = JavaFileObjects.forSourceLines("test.TestModule", source);
+    assertAbout(javaSources())
+        .that(FluentIterable.from(additionalSources).append(module))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(errorSubstring)
+        .in(module)
+        .onLine(methodLine(source));
+  }
+
+  private int methodLine(String source) {
+    String beforeMethod = source.substring(0, source.indexOf(getSubject()));
+    int methodLine = 1;
+    for (int nextNewlineIndex = beforeMethod.indexOf('\n');
+        nextNewlineIndex >= 0;
+        nextNewlineIndex = beforeMethod.indexOf('\n', nextNewlineIndex + 1)) {
+      methodLine++;
+    }
+    return methodLine;
+  }
+
+  private String moduleSource() {
+    StringWriter stringWriter = new StringWriter();
+    PrintWriter writer = new PrintWriter(stringWriter);
+    writer.println("package test;");
+    writer.println();
+    for (String importLine : imports.build()) {
+      writer.println(importLine);
+    }
+    writer.println();
+    writer.printf(declaration, "TestModule", "\n" + getSubject() + "\n");
+    writer.println();
+    return stringWriter.toString();
+  }
+
+  private static final Function<Class<?>, String> IMPORT =
+      new Function<Class<?>, String>() {
+        @Override
+        public String apply(Class<?> clazz) {
+          return String.format("import %s;", clazz.getCanonicalName());
+        }
+      };
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index 82dd4236f..52ce9d51d 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -28,6 +28,8 @@
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubject.assertThat;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatMethodInUnannotatedClass;
+import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatModuleMethod;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MULTIPLE_QUALIFIERS;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES;
@@ -46,9 +48,9 @@
 @RunWith(JUnit4.class)
 public class ModuleFactoryGeneratorTest {
 
-  private final JavaFileObject NULLABLE = JavaFileObjects.forSourceLines("test.Nullable",
-      "package test;",
-      "public @interface Nullable {}");
+  private static final JavaFileObject NULLABLE =
+      JavaFileObjects.forSourceLines(
+          "test.Nullable", "package test;", "public @interface Nullable {}");
 
   private static final CodeBlock NPE_LITERAL =
       CodeBlocks.stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
@@ -65,198 +67,74 @@ private String formatModuleErrorMessage(String msg) {
   }
 
   @Test public void providesMethodNotInModule() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Provides;",
-        "",
-        "final class TestModule {",
-        "  @Provides String provideString() {",
-        "    return \"\";",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE));
+    assertThatMethodInUnannotatedClass("@Provides String provideString() { return null; }")
+        .hasError(formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE));
   }
 
   @Test public void providesMethodAbstract() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "abstract class TestModule {",
-        "  @Provides abstract String provideString();",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(formatErrorMessage(BINDING_METHOD_ABSTRACT));
+    assertThatModuleMethod("@Provides abstract String abstractMethod();")
+        .hasError(formatErrorMessage(BINDING_METHOD_ABSTRACT));
   }
 
   @Test public void providesMethodPrivate() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class TestModule {",
-        "  @Provides private String provideString() {",
-        "    return \"\";",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(formatErrorMessage(BINDING_METHOD_PRIVATE));
+    assertThatModuleMethod("@Provides private String privateMethod() { return null; }")
+        .hasError(formatErrorMessage(BINDING_METHOD_PRIVATE));
   }
 
   @Test public void providesMethodReturnVoid() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class TestModule {",
-        "  @Provides void provideNothing() {}",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE));
+    assertThatModuleMethod("@Provides void voidMethod() {}")
+        .hasError(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE));
   }
 
-  @Test public void providesMethodFrameworkType() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Lazy;",
-        "import dagger.MembersInjector;",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import dagger.producers.Producer;",
-        "import dagger.producers.Produced;",
-        "import javax.inject.Provider;",
-        "",
-        "@Module",
-        "final class TestModule {",
-        "  @Provides Provider<String> provideProvider() {}",
-        "  @Provides Lazy<String> provideLazy() {}",
-        "  @Provides MembersInjector<String> provideMembersInjector() {}",
-        "  @Provides Producer<String> provideProducer() {}",
-        "  @Provides Produced<String> provideProduced() {}",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES))
-        .in(moduleFile).onLine(13)
-        .and()
-        .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES))
-        .in(moduleFile).onLine(14)
-        .and()
-        .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES))
-        .in(moduleFile).onLine(15)
-        .and()
-        .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES))
-        .in(moduleFile).onLine(16)
-        .and()
-        .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES))
-        .in(moduleFile).onLine(17);
+  @Test
+  public void providesMethodReturnsProvider() {
+    assertThatModuleMethod("@Provides Provider<String> provideProvider() {}")
+        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+  }
+
+  @Test
+  public void providesMethodReturnsLazy() {
+    assertThatModuleMethod("@Provides Lazy<String> provideLazy() {}")
+        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+  }
+
+  @Test
+  public void providesMethodReturnsMembersInjector() {
+    assertThatModuleMethod("@Provides MembersInjector<String> provideMembersInjector() {}")
+        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+  }
+
+  @Test
+  public void providesMethodReturnsProducer() {
+    assertThatModuleMethod("@Provides Producer<String> provideProducer() {}")
+        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+  }
+
+  @Test
+  public void providesMethodReturnsProduced() {
+    assertThatModuleMethod("@Provides Produced<String> provideProduced() {}")
+        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
   }
 
   @Test public void providesMethodWithTypeParameter() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class TestModule {",
-        "  @Provides <T> String provideString() {",
-        "    return \"\";",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER));
+    assertThatModuleMethod("@Provides <T> String typeParameter() { return null; }")
+        .hasError(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER));
   }
 
   @Test public void providesMethodSetValuesWildcard() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import dagger.multibindings.ElementsIntoSet;",
-        "",
-        "import java.util.Set;",
-        "",
-        "@Module",
-        "final class TestModule {",
-        "  @Provides @ElementsIntoSet Set<?> provideWildcard() {",
-        "    return null;",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(String.format(BINDING_METHOD_RETURN_TYPE, "Provides"));
+    assertThatModuleMethod("@Provides @ElementsIntoSet Set<?> provideWildcard() { return null; }")
+        .hasError(formatErrorMessage(BINDING_METHOD_RETURN_TYPE));
   }
 
   @Test public void providesMethodSetValuesRawSet() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import dagger.multibindings.ElementsIntoSet;",
-        "",
-        "import java.util.Set;",
-        "",
-        "@Module",
-        "final class TestModule {",
-        "  @Provides @ElementsIntoSet Set provideSomething() {",
-        "    return null;",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET));
+    assertThatModuleMethod("@Provides @ElementsIntoSet Set provideSomething() { return null; }")
+        .hasError(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET));
   }
 
   @Test public void providesMethodSetValuesNotASet() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import dagger.multibindings.ElementsIntoSet;",
-        "",
-        "import java.util.List;",
-        "",
-        "@Module",
-        "final class TestModule {",
-        "  @Provides @ElementsIntoSet List<String> provideStrings() {",
-        "    return null;",
-        "  }",
-        "}");
-    assertAbout(javaSource())
-        .that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(formatErrorMessage(BINDING_METHOD_SET_VALUES_RETURN_SET));
+    assertThatModuleMethod(
+            "@Provides @ElementsIntoSet List<String> provideStrings() { return null; }")
+        .hasError(formatErrorMessage(BINDING_METHOD_SET_VALUES_RETURN_SET));
   }
 
   @Test public void modulesWithTypeParamsMustBeAbstract() {
@@ -264,14 +142,16 @@ private String formatModuleErrorMessage(String msg) {
         "package test;",
         "",
         "import dagger.Module;",
-        "import dagger.Provides;",
         "",
         "@Module",
         "final class TestModule<A> {}");
-    assertAbout(javaSource()).that(moduleFile)
+    assertAbout(javaSource())
+        .that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT);
+        .withErrorContaining(MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT)
+        .in(moduleFile)
+        .onLine(6);
   }
 
   @Test public void provideOverriddenByNoProvide() {
@@ -285,20 +165,14 @@ private String formatModuleErrorMessage(String msg) {
         "class Parent {",
         "  @Provides String foo() { return null; }",
         "}");
-    JavaFileObject child = JavaFileObjects.forSourceLines("test.Child",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "",
-        "@Module",
-        "class Child extends Parent{",
-        "  String foo() { return null; }",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(parent, child))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(String.format(ErrorMessages.METHOD_OVERRIDES_PROVIDES_METHOD,
-            "Provides", "@Provides String test.Parent.foo()"));
+    assertThatModuleMethod("String foo() { return null; }")
+        .withDeclaration("@Module class %s extends Parent { %s }")
+        .withAdditionalSources(parent)
+        .hasError(
+            String.format(
+                ErrorMessages.METHOD_OVERRIDES_PROVIDES_METHOD,
+                "Provides",
+                "@Provides String test.Parent.foo()"));
   }
 
   @Test public void provideOverriddenByProvide() {
@@ -312,21 +186,14 @@ private String formatModuleErrorMessage(String msg) {
         "class Parent {",
         "  @Provides String foo() { return null; }",
         "}");
-    JavaFileObject child = JavaFileObjects.forSourceLines("test.Child",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "class Child extends Parent{",
-        "  @Provides String foo() { return null; }",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(parent, child))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(String.format(ErrorMessages.PROVIDES_METHOD_OVERRIDES_ANOTHER,
-            "Provides", "@Provides String test.Parent.foo()"));
+    assertThatModuleMethod("@Provides String foo() { return null; }")
+        .withDeclaration("@Module class %s extends Parent { %s }")
+        .withAdditionalSources(parent)
+        .hasError(
+            String.format(
+                ErrorMessages.PROVIDES_METHOD_OVERRIDES_ANOTHER,
+                "Provides",
+                "@Provides String test.Parent.foo()"));
   }
 
   @Test public void providesOverridesNonProvides() {
@@ -339,21 +206,14 @@ private String formatModuleErrorMessage(String msg) {
         "class Parent {",
         "  String foo() { return null; }",
         "}");
-    JavaFileObject child = JavaFileObjects.forSourceLines("test.Child",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "class Child extends Parent{",
-        "  @Provides String foo() { return null; }",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(parent, child))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(String.format(ErrorMessages.PROVIDES_METHOD_OVERRIDES_ANOTHER,
-            "Provides", "String test.Parent.foo()"));
+    assertThatModuleMethod("@Provides String foo() { return null; }")
+        .withDeclaration("@Module class %s extends Parent { %s }")
+        .withAdditionalSources(parent)
+        .hasError(
+            String.format(
+                ErrorMessages.PROVIDES_METHOD_OVERRIDES_ANOTHER,
+                "Provides",
+                "String test.Parent.foo()"));
   }
 
   @Test public void validatesIncludedModules() {
diff --git a/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java b/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java
index 30f30055f..74a49472c 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java
@@ -16,6 +16,7 @@
 package dagger.internal.codegen;
 
 import com.google.testing.compile.JavaFileObjects;
+import javax.inject.Qualifier;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -23,6 +24,7 @@
 
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatMultibindingsMethod;
 import static java.util.Arrays.asList;
 
 @RunWith(JUnit4.class)
@@ -47,7 +49,7 @@
           "",
           "@Qualifier",
           "@interface OtherQualifier {}");
-
+  
   @Test
   public void abstractClass() {
     JavaFileObject testModule =
@@ -198,101 +200,93 @@ public void notWithinModule() {
         .in(testModule)
         .onLine(9);
   }
+  
+  @Test
+  public void voidMethod() {
+    assertThatMultibindingsMethod("void voidMethod();")
+        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
+  }
 
   @Test
-  public void badMethods() {
-    JavaFileObject testModule =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Multibindings;",
-            "import dagger.producers.Produced;",
-            "import dagger.producers.Producer;",
-            "import java.util.Map;",
-            "import java.util.Set;",
-            "import javax.inject.Provider;",
-            "",
-            "@Module",
-            "class TestModule {",
-            "  @Multibindings",
-            "  interface Empties {",
-            "    void voidMethod();",
-            "    int primitive();",
-            "    Map rawMap();",
-            "    Map<?, ?> wildcardMap();",
-            "    Map<String, Provider<Object>> providerMap();",
-            "    Map<String, Producer<Object>> producerMap();",
-            "    Map<String, Produced<Object>> producedMap();",
-            "    Set rawSet();",
-            "    Set<?> wildcardSet();",
-            "    Set<Provider<Object>> providerSet();",
-            "    Set<Producer<Object>> producerSet();",
-            "    Set<Produced<Object>> producedSet();",
-            "    @SomeQualifier @OtherQualifier Set<Object> tooManyQualifiersSet();",
-            "    @SomeQualifier @OtherQualifier Map<String, Object> tooManyQualifiersMap();",
-            "  }",
-            "}");
-    assertAbout(javaSources())
-        .that(asList(testModule, SOME_QUALIFIER, OTHER_QUALIFIER))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
-        .in(testModule)
-        .onLine(15)
-        .and()
-        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
-        .in(testModule)
-        .onLine(16)
-        .and()
-        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
-        .in(testModule)
-        .onLine(17)
-        .and()
-        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
-        .in(testModule)
-        .onLine(18)
-        .and()
-        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
-        .in(testModule)
-        .onLine(19)
-        .and()
-        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
-        .in(testModule)
-        .onLine(20)
-        .and()
-        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
-        .in(testModule)
-        .onLine(21)
-        .and()
-        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
-        .in(testModule)
-        .onLine(22)
-        .and()
-        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
-        .in(testModule)
-        .onLine(23)
-        .and()
-        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
-        .in(testModule)
-        .onLine(24)
-        .and()
-        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
-        .in(testModule)
-        .onLine(25)
-        .and()
-        .withErrorContaining("@Multibindings methods must return Map<K, V> or Set<T>")
-        .in(testModule)
-        .onLine(26)
-        .and()
-        .withErrorContaining("Cannot use more than one @Qualifier")
-        .in(testModule)
-        .onLine(27)
-        .and()
-        .withErrorContaining("Cannot use more than one @Qualifier")
-        .in(testModule)
-        .onLine(28);
+  public void primitiveMethod() {
+    assertThatMultibindingsMethod("int primitive();")
+        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void rawMap() {
+    assertThatMultibindingsMethod("Map rawMap();")
+        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void wildcardMap() {
+    assertThatMultibindingsMethod("Map<?, ?> wildcardMap();")
+        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void providerMap() {
+    assertThatMultibindingsMethod("Map<String, Provider<Object>> providerMap();")
+        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void producerMap() {
+    assertThatMultibindingsMethod("Map<String, Producer<Object>> producerMap();")
+        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void producedMap() {
+    assertThatMultibindingsMethod("Map<String, Produced<Object>> producedMap();")
+        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void rawSet() {
+    assertThatMultibindingsMethod("Set rawSet();")
+        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void wildcardSet() {
+    assertThatMultibindingsMethod("Set<?> wildcardSet();")
+        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void providerSet() {
+    assertThatMultibindingsMethod("Set<Provider<Object>> providerSet();")
+        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void producerSet() {
+    assertThatMultibindingsMethod("Set<Producer<Object>> producerSet();")
+        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void producedSet() {
+    assertThatMultibindingsMethod("Set<Produced<Object>> producedSet();")
+        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void overqualifiedSet() {
+    assertThatMultibindingsMethod(
+            "@SomeQualifier @OtherQualifier Set<Object> tooManyQualifiersSet();")
+        .importing(SomeQualifier.class, OtherQualifier.class)
+        .hasError("Cannot use more than one @Qualifier");
+  }
+
+  @Test
+  public void overqualifiedMap() {
+    assertThatMultibindingsMethod(
+            "@SomeQualifier @OtherQualifier Map<String, Object> tooManyQualifiersMap();")
+        .importing(SomeQualifier.class, OtherQualifier.class)
+        .hasError("Cannot use more than one @Qualifier");
   }
 
   @Test
@@ -390,33 +384,9 @@ public void duplicateKeys() {
         .onLine(29);
   }
 
-  @Test
-  public void attemptToInjectWildcardGenerics() {
-    JavaFileObject testComponent =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.Lazy;",
-            "import javax.inject.Provider;",
-            "",
-            "@Component",
-            "interface TestComponent {",
-            "  Lazy<? extends Number> qualifiedNumberLazy();",
-            "  Provider<? super Number> qualifiedNumberProvider();",
-            "}");
-    assertAbout(javaSources())
-        .that(asList(testComponent))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("wildcard type")
-        .in(testComponent)
-        .onLine(9)
-        .and()
-        .withErrorContaining("wildcard type")
-        .in(testComponent)
-        .onLine(10);
-  }
+  @Qualifier
+  public @interface SomeQualifier {}
 
+  @Qualifier
+  public @interface OtherQualifier {}
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index 3caf3f6e3..2c783ef2f 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -17,7 +17,9 @@
 package dagger.internal.codegen;
 
 import com.google.common.collect.ImmutableList;
+import com.google.common.util.concurrent.ListenableFuture;
 import com.google.testing.compile.JavaFileObjects;
+import javax.inject.Qualifier;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -26,6 +28,8 @@
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatMethodInUnannotatedClass;
+import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatProductionModuleMethod;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MULTIPLE_QUALIFIERS;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES;
@@ -33,7 +37,6 @@
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_THROWS;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RAW_FUTURE;
@@ -43,6 +46,7 @@
 
 @RunWith(JUnit4.class)
 public class ProducerModuleFactoryGeneratorTest {
+  
   private String formatErrorMessage(String msg) {
     return String.format(msg, "Produces");
   }
@@ -52,302 +56,112 @@ private String formatModuleErrorMessage(String msg) {
   }
 
   @Test public void producesMethodNotInModule() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.producers.Produces;",
-        "",
-        "final class TestModule {",
-        "  @Produces String produceString() {",
-        "    return \"\";",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE));
+    assertThatMethodInUnannotatedClass("@Produces String produceString() { return null; }")
+        .hasError(formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE));
   }
 
   @Test public void producesMethodAbstract() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "@ProducerModule",
-        "abstract class TestModule {",
-        "  @Produces abstract String produceString();",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(formatErrorMessage(BINDING_METHOD_ABSTRACT));
+    assertThatProductionModuleMethod("@Produces abstract String produceString();")
+        .hasError(formatErrorMessage(BINDING_METHOD_ABSTRACT));
   }
 
   @Test public void producesMethodPrivate() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces private String produceString() {",
-        "    return \"\";",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(formatErrorMessage(BINDING_METHOD_PRIVATE));
+    assertThatProductionModuleMethod("@Produces private String produceString() { return null; }")
+        .hasError(formatErrorMessage(BINDING_METHOD_PRIVATE));
   }
 
   @Test public void producesMethodReturnVoid() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces void produceNothing() {}",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE));
+    assertThatProductionModuleMethod("@Produces void produceNothing() {}")
+        .hasError(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE));
   }
 
-  @Test public void producesMethodFrameworkType() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Lazy;",
-        "import dagger.MembersInjector;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produced;",
-        "import dagger.producers.Producer;",
-        "import dagger.producers.Produces;",
-        "import javax.inject.Provider;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces Provider<String> produceProvider() {}",
-        "  @Produces Lazy<String> produceLazy() {}",
-        "  @Produces MembersInjector<String> produceMembersInjector() {}",
-        "  @Produces Producer<String> produceProducer() {}",
-        "  @Produces Produced<String> produceProduced() {}",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-    .processedWith(new ComponentProcessor())
-    .failsToCompile()
-    .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES))
-    .in(moduleFile).onLine(13)
-    .and()
-    .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES))
-    .in(moduleFile).onLine(14)
-    .and()
-    .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES))
-    .in(moduleFile).onLine(15)
-    .and()
-    .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES))
-    .in(moduleFile).onLine(16)
-    .and()
-    .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES))
-    .in(moduleFile).onLine(17);
+  @Test
+  public void producesProvider() {
+    assertThatProductionModuleMethod("@Produces Provider<String> produceProvider() {}")
+        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+  }
+
+  @Test
+  public void producesLazy() {
+    assertThatProductionModuleMethod("@Produces Lazy<String> produceLazy() {}")
+        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+  }
+
+  @Test
+  public void producesMembersInjector() {
+    assertThatProductionModuleMethod(
+            "@Produces MembersInjector<String> produceMembersInjector() {}")
+        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+  }
+
+  @Test
+  public void producesProducer() {
+    assertThatProductionModuleMethod("@Produces Producer<String> produceProducer() {}")
+        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+  }
+
+  @Test
+  public void producesProduced() {
+    assertThatProductionModuleMethod("@Produces Produced<String> produceProduced() {}")
+        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
   }
 
   @Test public void producesMethodReturnRawFuture() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces ListenableFuture produceRaw() {}",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(PRODUCES_METHOD_RAW_FUTURE);
+    assertThatProductionModuleMethod("@Produces ListenableFuture produceRaw() {}")
+        .importing(ListenableFuture.class)
+        .hasError(PRODUCES_METHOD_RAW_FUTURE);
   }
 
   @Test public void producesMethodReturnWildcardFuture() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces ListenableFuture<?> produceRaw() {}",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(PRODUCES_METHOD_RETURN_TYPE);
+    assertThatProductionModuleMethod("@Produces ListenableFuture<?> produceRaw() {}")
+        .importing(ListenableFuture.class)
+        .hasError(PRODUCES_METHOD_RETURN_TYPE);
   }
 
   @Test public void producesMethodWithTypeParameter() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces <T> String produceString() {",
-        "    return \"\";",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER));
+    assertThatProductionModuleMethod("@Produces <T> String produceString() { return null; }")
+        .hasError(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER));
   }
 
   @Test public void producesMethodSetValuesWildcard() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.multibindings.ElementsIntoSet;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "import java.util.Set;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces @ElementsIntoSet Set<?> produceWildcard() {",
-        "    return null;",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(PRODUCES_METHOD_RETURN_TYPE);
+    assertThatProductionModuleMethod(
+            "@Produces @ElementsIntoSet Set<?> produceWildcard() { return null; }")
+        .hasError(PRODUCES_METHOD_RETURN_TYPE);
   }
 
   @Test public void producesMethodSetValuesRawSet() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.multibindings.ElementsIntoSet;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "import java.util.Set;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces @ElementsIntoSet Set produceSomething() {",
-        "    return null;",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET));
+    assertThatProductionModuleMethod(
+            "@Produces @ElementsIntoSet Set produceSomething() { return null; }")
+        .hasError(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET));
   }
 
   @Test public void producesMethodSetValuesNotASet() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.multibindings.ElementsIntoSet;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "import java.util.List;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces @ElementsIntoSet List<String> produceStrings() {",
-        "    return null;",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(PRODUCES_METHOD_SET_VALUES_RETURN_SET);
+    assertThatProductionModuleMethod(
+            "@Produces @ElementsIntoSet List<String> produceStrings() { return null; }")
+        .hasError(PRODUCES_METHOD_SET_VALUES_RETURN_SET);
   }
 
   @Test public void producesMethodSetValuesWildcardInFuture() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.multibindings.ElementsIntoSet;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "import java.util.Set;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces @ElementsIntoSet ListenableFuture<Set<?>> produceWildcard() {",
-        "    return null;",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(PRODUCES_METHOD_RETURN_TYPE);
+    assertThatProductionModuleMethod(
+            "@Produces @ElementsIntoSet "
+                + "ListenableFuture<Set<?>> produceWildcard() { return null; }")
+        .importing(ListenableFuture.class)
+        .hasError(PRODUCES_METHOD_RETURN_TYPE);
   }
 
   @Test public void producesMethodSetValuesFutureRawSet() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.multibindings.ElementsIntoSet;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "import java.util.Set;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces @ElementsIntoSet ListenableFuture<Set> produceSomething() {",
-        "    return null;",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET));
+    assertThatProductionModuleMethod(
+            "@Produces @ElementsIntoSet ListenableFuture<Set> produceSomething() { return null; }")
+        .importing(ListenableFuture.class)
+        .hasError(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET));
   }
 
   @Test public void producesMethodSetValuesFutureNotASet() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.multibindings.ElementsIntoSet;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "import java.util.List;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces @ElementsIntoSet ListenableFuture<List<String>> produceStrings() {",
-        "    return null;",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(PRODUCES_METHOD_SET_VALUES_RETURN_SET);
+    assertThatProductionModuleMethod(
+            "@Produces @ElementsIntoSet "
+                + "ListenableFuture<List<String>> produceStrings() { return null; }")
+        .importing(ListenableFuture.class)
+        .hasError(PRODUCES_METHOD_SET_VALUES_RETURN_SET);
   }
 
   @Test public void multipleProducesMethodsWithSameName() {
@@ -377,28 +191,10 @@ private String formatModuleErrorMessage(String msg) {
 
   @Test
   public void producesMethodThrowsThrowable() {
-    JavaFileObject moduleFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.producers.ProducerModule;",
-            "import dagger.producers.Produces;",
-            "",
-            "@ProducerModule",
-            "final class TestModule {",
-            "  @Produces int produceInt() throws Throwable {",
-            "    return 0;",
-            "  }",
-            "",
-            "}");
-    assertAbout(javaSource())
-        .that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(formatErrorMessage(BINDING_METHOD_THROWS))
-        .in(moduleFile)
-        .onLine(8);
+    assertThatProductionModuleMethod("@Produces int produceInt() throws Throwable { return 0; }")
+        .hasError(
+            "@Produces methods may only throw unchecked exceptions or exceptions subclassing "
+                + "Exception");
   }
 
   @Test
@@ -688,37 +484,16 @@ public void singleProducesMethodNoArgsFutureWithProducerName() {
         .generatesSources(factoryFile);
   }
 
-  private static final JavaFileObject QUALIFIER_A =
-      JavaFileObjects.forSourceLines("test.QualifierA",
-          "package test;",
-          "",
-          "import javax.inject.Qualifier;",
-          "",
-          "@Qualifier @interface QualifierA {}");
-  private static final JavaFileObject QUALIFIER_B =
-      JavaFileObjects.forSourceLines("test.QualifierB",
-          "package test;",
-          "",
-          "import javax.inject.Qualifier;",
-          "",
-          "@Qualifier @interface QualifierB {}");
-
   @Test public void producesMethodMultipleQualifiers() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces @QualifierA @QualifierB abstract String produceString() {",
-        "    return \"\";",
-        "  }",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, QUALIFIER_A, QUALIFIER_B))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(BINDING_METHOD_MULTIPLE_QUALIFIERS);
+    assertThatProductionModuleMethod(
+            "@Produces @QualifierA @QualifierB abstract String produceString() { return null; }")
+        .importing(ListenableFuture.class, QualifierA.class, QualifierB.class)
+        .hasError(BINDING_METHOD_MULTIPLE_QUALIFIERS);
   }
+  
+  @Qualifier
+  public @interface QualifierA {}
+
+  @Qualifier
+  public @interface QualifierB {}
 }
