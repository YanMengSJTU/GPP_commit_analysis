diff --git a/java/dagger/internal/codegen/BindingElementValidator.java b/java/dagger/internal/codegen/BindingElementValidator.java
index 57bac052b..00519123d 100644
--- a/java/dagger/internal/codegen/BindingElementValidator.java
+++ b/java/dagger/internal/codegen/BindingElementValidator.java
@@ -29,10 +29,8 @@
 
 import com.google.common.collect.ImmutableSet;
 import com.google.errorprone.annotations.FormatMethod;
-import com.google.errorprone.annotations.OverridingMethodsMustInvokeSuper;
 import dagger.MapKey;
 import dagger.Provides;
-import dagger.internal.codegen.ValidationReport.Builder;
 import dagger.model.Key;
 import dagger.model.Scope;
 import dagger.multibindings.ElementsIntoSet;
@@ -71,6 +69,15 @@ protected BindingElementValidator(
     this.allowsScoping = allowsScoping;
   }
 
+  /** Returns a {@link ValidationReport} for {@code element}. */
+  final ValidationReport<E> validate(E element) {
+    return reentrantComputeIfAbsent(cache, element, this::validateUncached);
+  }
+
+  private ValidationReport<E> validateUncached(E element) {
+    return elementValidator(element).validate();
+  }
+
   /**
    * Returns an error message of the form "&lt;{@link #bindingElements()}&gt; <i>rule</i>", where
    * <i>rule</i> comes from calling {@link String#format(String, Object...)} on {@code ruleFormat}
@@ -86,86 +93,10 @@ protected final String bindingElements(String ruleFormat, Object... args) {
    */
   protected abstract String bindingElements();
 
-  /** The verb describing the {@link #bindingElementType(Builder)} in error messages. */
+  /** The verb describing the {@link ElementValidator#bindingElementType()} in error messages. */
   // TODO(ronshapiro,dpb): improve the name of this method and it's documentation.
   protected abstract String bindingElementTypeVerb();
 
-  /** Returns a {@link ValidationReport} for {@code element}. */
-  final ValidationReport<E> validate(E element) {
-    return reentrantComputeIfAbsent(cache, element, this::validateUncached);
-  }
-
-  private ValidationReport<E> validateUncached(E element) {
-    ValidationReport.Builder<E> report = ValidationReport.about(element);
-    checkElement(report);
-    return report.build();
-  }
-
-  /** Checks the element for validity. Adds errors to {@code builder}. */
-  @OverridingMethodsMustInvokeSuper
-  protected void checkElement(ValidationReport.Builder<E> builder) {
-    checkType(builder);
-    checkQualifiers(builder);
-    checkMapKeys(builder);
-    checkMultibindings(builder);
-    checkScopes(builder);
-  }
-
-  /**
-   * The type declared by this binding element. This may differ from a binding's {@link Key#type()},
-   * for example in multibindings. An {@link Optional#empty()} return value indicates that the
-   * contributed type is ambiguous or missing, i.e. a {@code @BindsInstance} method with zero or
-   * many parameters.
-   */
-  // TODO(dpb): should this be an ImmutableList<TypeMirror>, with this class checking the size?
-  protected abstract Optional<TypeMirror> bindingElementType(ValidationReport.Builder<E> report);
-
-  /**
-   * Adds an error if the {@link #bindingElementType(ValidationReport.Builder) binding element type}
-   * is not appropriate.
-   *
-   * <p>Adds an error if the type is not a primitive, array, declared type, or type variable.
-   *
-   * <p>If the binding is not a multibinding contribution, adds an error if the type is a framework
-   * type.
-   *
-   * <p>If the element has {@link ElementsIntoSet @ElementsIntoSet} or {@code SET_VALUES}, adds an
-   * error if the type is not a {@code Set<T>} for some {@code T}
-   */
-  protected void checkType(ValidationReport.Builder<E> builder) {
-    switch (ContributionType.fromBindingElement(builder.getSubject())) {
-      case UNIQUE:
-        /* Validate that a unique binding is not attempting to bind a framework type. This
-         * validation is only appropriate for unique bindings because multibindings may collect
-         * framework types.  E.g. Set<Provider<Foo>> is perfectly reasonable. */
-        checkFrameworkType(builder);
-        // fall through
-
-      case SET:
-      case MAP:
-        bindingElementType(builder).ifPresent(type -> checkKeyType(builder, type));
-        break;
-
-      case SET_VALUES:
-        checkSetValuesType(builder);
-    }
-  }
-
-  /**
-   * Adds an error if {@code keyType} is not a primitive, declared type, array, or type variable.
-   */
-  protected void checkKeyType(ValidationReport.Builder<E> builder, TypeMirror keyType) {
-    TypeKind kind = keyType.getKind();
-    if (kind.equals(VOID)) {
-      builder.addError(bindingElements("must %s a value (not void)", bindingElementTypeVerb()));
-    } else if (!(kind.isPrimitive()
-        || kind.equals(DECLARED)
-        || kind.equals(ARRAY)
-        || kind.equals(TYPEVAR))) {
-      builder.addError(badTypeMessage());
-    }
-  }
-
   /** The error message when a binding element has a bad type. */
   protected String badTypeMessage() {
     return bindingElements(
@@ -173,29 +104,6 @@ protected String badTypeMessage() {
         bindingElementTypeVerb());
   }
 
-  /**
-   * Adds an error if the type for an element with {@link ElementsIntoSet @ElementsIntoSet} or
-   * {@code SET_VALUES} is not a a {@code Set<T>} for a reasonable {@code T}.
-   */
-  // TODO(gak): should we allow "covariant return" for set values?
-  protected void checkSetValuesType(ValidationReport.Builder<E> builder) {
-    bindingElementType(builder).ifPresent(keyType -> checkSetValuesType(builder, keyType));
-  }
-
-  /** Adds an error if {@code type} is not a {@code Set<T>} for a reasonable {@code T}. */
-  protected final void checkSetValuesType(ValidationReport.Builder<E> builder, TypeMirror type) {
-    if (!SetType.isSet(type)) {
-      builder.addError(elementsIntoSetNotASetMessage());
-    } else {
-      SetType setType = SetType.from(type);
-      if (setType.isRawType()) {
-        builder.addError(elementsIntoSetRawSetMessage());
-      } else {
-        checkKeyType(builder, setType.elementType());
-      }
-    }
-  }
-
   /**
    * The error message when a the type for a binding element with {@link
    * ElementsIntoSet @ElementsIntoSet} or {@code SET_VALUES} is a not set type.
@@ -214,127 +122,234 @@ protected String elementsIntoSetRawSetMessage() {
         "annotated with @ElementsIntoSet cannot %s a raw Set", bindingElementTypeVerb());
   }
 
-  /** Adds an error if the element has more than one {@linkplain Qualifier qualifier} annotation. */
-  private void checkQualifiers(ValidationReport.Builder<E> builder) {
-    ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(builder.getSubject());
-    if (qualifiers.size() > 1) {
-      for (AnnotationMirror qualifier : qualifiers) {
-        builder.addError(
-            bindingElements("may not use more than one @Qualifier"),
-            builder.getSubject(),
-            qualifier);
-      }
+  /*** Returns an {@link ElementValidator} for validating the given {@code element}. */
+  protected abstract ElementValidator elementValidator(E element);
+
+  /** Validator for a single binding element. */
+  protected abstract class ElementValidator {
+    protected final E element;
+    protected final ValidationReport.Builder<E> report;
+
+    protected ElementValidator(E element) {
+      this.element = element;
+      this.report = ValidationReport.about(element);
     }
-  }
 
-  /**
-   * Adds an error if an {@link IntoMap @IntoMap} element doesn't have exactly one {@link
-   * MapKey @MapKey} annotation, or if an element that is {@link IntoMap @IntoMap} has any.
-   */
-  private void checkMapKeys(ValidationReport.Builder<E> builder) {
-    if (!allowsMultibindings.allowsMultibindings()) {
-      return;
+    /** Checks the element for validity. */
+    private ValidationReport<E> validate() {
+      checkType();
+      checkQualifiers();
+      checkMapKeys();
+      checkMultibindings();
+      checkScopes();
+      checkAdditionalProperties();
+      return report.build();
     }
-    ImmutableSet<? extends AnnotationMirror> mapKeys = getMapKeys(builder.getSubject());
-    if (ContributionType.fromBindingElement(builder.getSubject()).equals(ContributionType.MAP)) {
-      switch (mapKeys.size()) {
-        case 0:
-          builder.addError(bindingElements("of type map must declare a map key"));
-          break;
-        case 1:
-          break;
-        default:
-          builder.addError(bindingElements("may not have more than one map key"));
+
+    /** Check any additional properties of the element. Does nothing by default. */
+    protected void checkAdditionalProperties() {}
+
+    /**
+     * The type declared by this binding element. This may differ from a binding's {@link
+     * Key#type()}, for example in multibindings. An {@link Optional#empty()} return value indicates
+     * that the contributed type is ambiguous or missing, i.e. a {@code @BindsInstance} method with
+     * zero or many parameters.
+     */
+    // TODO(dpb): should this be an ImmutableList<TypeMirror>, with this class checking the size?
+    protected abstract Optional<TypeMirror> bindingElementType();
+
+    /**
+     * Adds an error if the {@link #bindingElementType() binding element type} is not appropriate.
+     *
+     * <p>Adds an error if the type is not a primitive, array, declared type, or type variable.
+     *
+     * <p>If the binding is not a multibinding contribution, adds an error if the type is a
+     * framework type.
+     *
+     * <p>If the element has {@link ElementsIntoSet @ElementsIntoSet} or {@code SET_VALUES}, adds an
+     * error if the type is not a {@code Set<T>} for some {@code T}
+     */
+    protected void checkType() {
+      switch (ContributionType.fromBindingElement(element)) {
+        case UNIQUE:
+          /* Validate that a unique binding is not attempting to bind a framework type. This
+           * validation is only appropriate for unique bindings because multibindings may collect
+           * framework types.  E.g. Set<Provider<Foo>> is perfectly reasonable. */
+          checkFrameworkType();
+          // fall through
+
+        case SET:
+        case MAP:
+          bindingElementType().ifPresent(type -> checkKeyType(type));
           break;
+
+        case SET_VALUES:
+          checkSetValuesType();
       }
-    } else if (!mapKeys.isEmpty()) {
-      builder.addError(bindingElements("of non map type cannot declare a map key"));
     }
-  }
 
-  /**
-   * Adds errors if:
-   *
-   * <ul>
-   *   <li>the element doesn't allow {@linkplain MultibindingAnnotations multibinding annotations}
-   *       and has any
-   *   <li>the element does allow them but has more than one
-   *   <li>the element has a multibinding annotation and its {@link Provides} or {@link Produces}
-   *       annotation has a {@code type} parameter.
-   * </ul>
-   */
-  private void checkMultibindings(ValidationReport.Builder<E> builder) {
-    ImmutableSet<AnnotationMirror> multibindingAnnotations =
-        MultibindingAnnotations.forElement(builder.getSubject());
-
-    switch (allowsMultibindings) {
-      case NO_MULTIBINDINGS:
-        for (AnnotationMirror annotation : multibindingAnnotations) {
-          builder.addError(
-              bindingElements("cannot have multibinding annotations"),
-              builder.getSubject(),
-              annotation);
+    /**
+     * Adds an error if {@code keyType} is not a primitive, declared type, array, or type variable.
+     */
+    protected void checkKeyType(TypeMirror keyType) {
+      TypeKind kind = keyType.getKind();
+      if (kind.equals(VOID)) {
+        report.addError(bindingElements("must %s a value (not void)", bindingElementTypeVerb()));
+      } else if (!(kind.isPrimitive()
+          || kind.equals(DECLARED)
+          || kind.equals(ARRAY)
+          || kind.equals(TYPEVAR))) {
+        report.addError(badTypeMessage());
+      }
+    }
+
+    /**
+     * Adds an error if the type for an element with {@link ElementsIntoSet @ElementsIntoSet} or
+     * {@code SET_VALUES} is not a a {@code Set<T>} for a reasonable {@code T}.
+     */
+    // TODO(gak): should we allow "covariant return" for set values?
+    protected void checkSetValuesType() {
+      bindingElementType().ifPresent(keyType -> checkSetValuesType(keyType));
+    }
+
+    /** Adds an error if {@code type} is not a {@code Set<T>} for a reasonable {@code T}. */
+    protected final void checkSetValuesType(TypeMirror type) {
+      if (!SetType.isSet(type)) {
+        report.addError(elementsIntoSetNotASetMessage());
+      } else {
+        SetType setType = SetType.from(type);
+        if (setType.isRawType()) {
+          report.addError(elementsIntoSetRawSetMessage());
+        } else {
+          checkKeyType(setType.elementType());
         }
-        break;
+      }
+    }
 
-      case ALLOWS_MULTIBINDINGS:
-        if (multibindingAnnotations.size() > 1) {
-          for (AnnotationMirror annotation : multibindingAnnotations) {
-            builder.addError(
-                bindingElements("cannot have more than one multibinding annotation"),
-                builder.getSubject(),
-                annotation);
-          }
+    /**
+     * Adds an error if the element has more than one {@linkplain Qualifier qualifier} annotation.
+     */
+    private void checkQualifiers() {
+      ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(element);
+      if (qualifiers.size() > 1) {
+        for (AnnotationMirror qualifier : qualifiers) {
+          report.addError(
+              bindingElements("may not use more than one @Qualifier"),
+              element,
+              qualifier);
         }
-        break;
+      }
     }
 
-    // TODO(ronshapiro): move this into ProvidesMethodValidator
-    if (bindingAnnotation.equals(Provides.class)) {
-      AnnotationMirror bindingAnnotationMirror =
-          getAnnotationMirror(builder.getSubject(), bindingAnnotation).get();
-      boolean usesProvidesType = false;
-      for (ExecutableElement member : bindingAnnotationMirror.getElementValues().keySet()) {
-        usesProvidesType |= member.getSimpleName().contentEquals("type");
+    /**
+     * Adds an error if an {@link IntoMap @IntoMap} element doesn't have exactly one {@link
+     * MapKey @MapKey} annotation, or if an element that is {@link IntoMap @IntoMap} has any.
+     */
+    private void checkMapKeys() {
+      if (!allowsMultibindings.allowsMultibindings()) {
+        return;
       }
-      if (usesProvidesType && !multibindingAnnotations.isEmpty()) {
-        builder.addError(
-            "@Provides.type cannot be used with multibinding annotations", builder.getSubject());
+      ImmutableSet<? extends AnnotationMirror> mapKeys = getMapKeys(element);
+      if (ContributionType.fromBindingElement(element).equals(ContributionType.MAP)) {
+        switch (mapKeys.size()) {
+          case 0:
+            report.addError(bindingElements("of type map must declare a map key"));
+            break;
+          case 1:
+            break;
+          default:
+            report.addError(bindingElements("may not have more than one map key"));
+            break;
+        }
+      } else if (!mapKeys.isEmpty()) {
+        report.addError(bindingElements("of non map type cannot declare a map key"));
       }
     }
-  }
 
-  /**
-   * Adds an error if the element has a scope but doesn't allow scoping, or if it has more than one
-   * {@linkplain Scope scope} annotation.
-   */
-  private void checkScopes(ValidationReport.Builder<E> builder) {
-    ImmutableSet<Scope> scopes = scopesOf(builder.getSubject());
-    String error = null;
-    switch (allowsScoping) {
-      case ALLOWS_SCOPING:
-        if (scopes.size() <= 1) {
-          return;
+    /**
+     * Adds errors if:
+     *
+     * <ul>
+     *   <li>the element doesn't allow {@linkplain MultibindingAnnotations multibinding annotations}
+     *       and has any
+     *   <li>the element does allow them but has more than one
+     *   <li>the element has a multibinding annotation and its {@link Provides} or {@link Produces}
+     *       annotation has a {@code type} parameter.
+     * </ul>
+     */
+    private void checkMultibindings() {
+      ImmutableSet<AnnotationMirror> multibindingAnnotations =
+          MultibindingAnnotations.forElement(element);
+
+      switch (allowsMultibindings) {
+        case NO_MULTIBINDINGS:
+          for (AnnotationMirror annotation : multibindingAnnotations) {
+            report.addError(
+                bindingElements("cannot have multibinding annotations"),
+                element,
+                annotation);
+          }
+          break;
+
+        case ALLOWS_MULTIBINDINGS:
+          if (multibindingAnnotations.size() > 1) {
+            for (AnnotationMirror annotation : multibindingAnnotations) {
+              report.addError(
+                  bindingElements("cannot have more than one multibinding annotation"),
+                  element,
+                  annotation);
+            }
+          }
+          break;
+      }
+
+      // TODO(ronshapiro): move this into ProvidesMethodValidator
+      if (bindingAnnotation.equals(Provides.class)) {
+        AnnotationMirror bindingAnnotationMirror =
+            getAnnotationMirror(element, bindingAnnotation).get();
+        boolean usesProvidesType = false;
+        for (ExecutableElement member : bindingAnnotationMirror.getElementValues().keySet()) {
+          usesProvidesType |= member.getSimpleName().contentEquals("type");
+        }
+        if (usesProvidesType && !multibindingAnnotations.isEmpty()) {
+          report.addError(
+              "@Provides.type cannot be used with multibinding annotations", element);
         }
-        error = bindingElements("cannot use more than one @Scope");
-        break;
-      case NO_SCOPING:
-        error = bindingElements("cannot be scoped");
-        break;
+      }
     }
-    verifyNotNull(error);
-    for (Scope scope : scopes) {
-      builder.addError(error, builder.getSubject(), scope.scopeAnnotation());
+
+    /**
+     * Adds an error if the element has a scope but doesn't allow scoping, or if it has more than
+     * one {@linkplain Scope scope} annotation.
+     */
+    private void checkScopes() {
+      ImmutableSet<Scope> scopes = scopesOf(element);
+      String error = null;
+      switch (allowsScoping) {
+        case ALLOWS_SCOPING:
+          if (scopes.size() <= 1) {
+            return;
+          }
+          error = bindingElements("cannot use more than one @Scope");
+          break;
+        case NO_SCOPING:
+          error = bindingElements("cannot be scoped");
+          break;
+      }
+      verifyNotNull(error);
+      for (Scope scope : scopes) {
+        report.addError(error, element, scope.scopeAnnotation());
+      }
     }
-  }
 
-  /**
-   * Adds an error if the {@link #bindingElementType(Builder) type} is a {@linkplain FrameworkTypes
-   * framework type}.
-   */
-  private void checkFrameworkType(ValidationReport.Builder<E> builder) {
-    if (bindingElementType(builder).filter(FrameworkTypes::isFrameworkType).isPresent()) {
-      builder.addError(bindingElements("must not %s framework types", bindingElementTypeVerb()));
+    /**
+     * Adds an error if the {@link #bindingElementType() type} is a {@linkplain FrameworkTypes
+     * framework type}.
+     */
+    private void checkFrameworkType() {
+      if (bindingElementType().filter(FrameworkTypes::isFrameworkType).isPresent()) {
+        report.addError(bindingElements("must not %s framework types", bindingElementTypeVerb()));
+      }
     }
   }
 
diff --git a/java/dagger/internal/codegen/BindingMethodValidator.java b/java/dagger/internal/codegen/BindingMethodValidator.java
index a3a9249bb..21c05ccd2 100644
--- a/java/dagger/internal/codegen/BindingMethodValidator.java
+++ b/java/dagger/internal/codegen/BindingMethodValidator.java
@@ -123,92 +123,100 @@ protected final String bindingElementTypeVerb() {
     return "return";
   }
 
-  @Override
-  protected final Optional<TypeMirror> bindingElementType(
-      ValidationReport.Builder<ExecutableElement> report) {
-    return Optional.of(report.getSubject().getReturnType());
-  }
+  /** Abstract validator for individual binding method elements. */
+  protected abstract class MethodValidator extends ElementValidator {
+    protected MethodValidator(ExecutableElement element) {
+      super(element);
+    }
 
-  @Override
-  protected void checkElement(ValidationReport.Builder<ExecutableElement> builder) {
-    super.checkElement(builder);
-    checkEnclosingElement(builder);
-    checkTypeParameters(builder);
-    checkNotPrivate(builder);
-    checkAbstractness(builder);
-    checkThrows(builder);
-    checkParameters(builder);
-  }
+    @Override
+    protected final Optional<TypeMirror> bindingElementType() {
+      return Optional.of(element.getReturnType());
+    }
 
-  /**
-   * Adds an error if the method is not declared in a class or interface annotated with one of the
-   * {@link #enclosingElementAnnotations}.
-   */
-  private void checkEnclosingElement(ValidationReport.Builder<ExecutableElement> builder) {
-    if (!isAnyAnnotationPresent(
-        builder.getSubject().getEnclosingElement(), enclosingElementAnnotations)) {
-      builder.addError(
-          bindingMethods(
-              "can only be present within a @%s",
-              enclosingElementAnnotations.stream()
-                  .map(Class::getSimpleName)
-                  .collect(joining(" or @"))));
+    @Override
+    protected final void checkAdditionalProperties() {
+      checkEnclosingElement();
+      checkTypeParameters();
+      checkNotPrivate();
+      checkAbstractness();
+      checkThrows();
+      checkParameters();
+      checkAdditionalMethodProperties();
     }
-  }
 
-  /** Adds an error if the method is generic. */
-  private void checkTypeParameters(ValidationReport.Builder<ExecutableElement> builder) {
-    if (!builder.getSubject().getTypeParameters().isEmpty()) {
-      builder.addError(bindingMethods("may not have type parameters"));
+    /** Checks additional properties of the binding method. */
+    protected void checkAdditionalMethodProperties() {}
+
+    /**
+     * Adds an error if the method is not declared in a class or interface annotated with one of the
+     * {@link #enclosingElementAnnotations}.
+     */
+    private void checkEnclosingElement() {
+      if (!isAnyAnnotationPresent(
+          element.getEnclosingElement(), enclosingElementAnnotations)) {
+        report.addError(
+            bindingMethods(
+                "can only be present within a @%s",
+                enclosingElementAnnotations.stream()
+                    .map(Class::getSimpleName)
+                    .collect(joining(" or @"))));
+      }
     }
-  }
 
-  /** Adds an error if the method is private. */
-  private void checkNotPrivate(ValidationReport.Builder<ExecutableElement> builder) {
-    if (builder.getSubject().getModifiers().contains(PRIVATE)) {
-      builder.addError(bindingMethods("cannot be private"));
+    /** Adds an error if the method is generic. */
+    private void checkTypeParameters() {
+      if (!element.getTypeParameters().isEmpty()) {
+        report.addError(bindingMethods("may not have type parameters"));
+      }
     }
-  }
 
-  /** Adds an error if the method is abstract but must not be, or is not and must be. */
-  private void checkAbstractness(ValidationReport.Builder<ExecutableElement> builder) {
-    boolean isAbstract = builder.getSubject().getModifiers().contains(ABSTRACT);
-    switch (abstractness) {
-      case MUST_BE_ABSTRACT:
-        if (!isAbstract) {
-          builder.addError(bindingMethods("must be abstract"));
-        }
-        break;
+    /** Adds an error if the method is private. */
+    private void checkNotPrivate() {
+      if (element.getModifiers().contains(PRIVATE)) {
+        report.addError(bindingMethods("cannot be private"));
+      }
+    }
 
-      case MUST_BE_CONCRETE:
-        if (isAbstract) {
-          builder.addError(bindingMethods("cannot be abstract"));
-        }
+    /** Adds an error if the method is abstract but must not be, or is not and must be. */
+    private void checkAbstractness() {
+      boolean isAbstract = element.getModifiers().contains(ABSTRACT);
+      switch (abstractness) {
+        case MUST_BE_ABSTRACT:
+          if (!isAbstract) {
+            report.addError(bindingMethods("must be abstract"));
+          }
+          break;
+
+        case MUST_BE_CONCRETE:
+          if (isAbstract) {
+            report.addError(bindingMethods("cannot be abstract"));
+          }
+      }
     }
-  }
 
-  /**
-   * Adds an error if the method declares throws anything but an {@link Error} or an appropriate
-   * subtype of {@link Exception}.
-   */
-  private void checkThrows(ValidationReport.Builder<ExecutableElement> builder) {
-    exceptionSuperclass.checkThrows(this, builder);
-  }
+    /**
+     * Adds an error if the method declares throws anything but an {@link Error} or an appropriate
+     * subtype of {@link Exception}.
+     */
+    private void checkThrows() {
+      exceptionSuperclass.checkThrows(BindingMethodValidator.this, element, report);
+    }
 
-  /** Adds errors for the method parameters. */
-  protected void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
-    for (VariableElement parameter : builder.getSubject().getParameters()) {
-      checkParameter(builder, parameter);
+    /** Adds errors for the method parameters. */
+    protected void checkParameters() {
+      for (VariableElement parameter : element.getParameters()) {
+        checkParameter(parameter);
+      }
     }
-  }
 
-  /**
-   * Adds errors for a method parameter. This implementation reports an error if the parameter has
-   * more than one qualifier.
-   */
-  protected void checkParameter(
-      ValidationReport.Builder<ExecutableElement> builder, VariableElement parameter) {
-    dependencyRequestValidator.validateDependencyRequest(builder, parameter, parameter.asType());
+    /**
+     * Adds errors for a method parameter. This implementation reports an error if the parameter has
+     * more than one qualifier.
+     */
+    protected void checkParameter(VariableElement parameter) {
+      dependencyRequestValidator.validateDependencyRequest(report, parameter, parameter.asType());
+    }
   }
 
   /** An abstract/concrete restriction on methods. */
@@ -231,9 +239,11 @@ protected String errorMessage(BindingMethodValidator validator) {
 
       @Override
       protected void checkThrows(
-          BindingMethodValidator validator, ValidationReport.Builder<ExecutableElement> builder) {
-        if (!builder.getSubject().getThrownTypes().isEmpty()) {
-          builder.addError(validator.bindingMethods("may not throw"));
+          BindingMethodValidator validator,
+          ExecutableElement element,
+          ValidationReport.Builder<ExecutableElement> report) {
+        if (!element.getThrownTypes().isEmpty()) {
+          report.addError(validator.bindingMethods("may not throw"));
           return;
         }
       }
@@ -274,13 +284,15 @@ protected String errorMessage(BindingMethodValidator validator) {
      * <p>This method is overridden in {@link #NO_EXCEPTIONS}.
      */
     protected void checkThrows(
-        BindingMethodValidator validator, ValidationReport.Builder<ExecutableElement> builder) {
+        BindingMethodValidator validator,
+        ExecutableElement element,
+        ValidationReport.Builder<ExecutableElement> report) {
       TypeMirror exceptionSupertype = validator.elements.getTypeElement(superclass).asType();
       TypeMirror errorType = validator.elements.getTypeElement(Error.class).asType();
-      for (TypeMirror thrownType : builder.getSubject().getThrownTypes()) {
+      for (TypeMirror thrownType : element.getThrownTypes()) {
         if (!validator.types.isSubtype(thrownType, exceptionSupertype)
             && !validator.types.isSubtype(thrownType, errorType)) {
-          builder.addError(errorMessage(validator));
+          report.addError(errorMessage(validator));
           break;
         }
       }
diff --git a/java/dagger/internal/codegen/BindsInstanceMethodValidator.java b/java/dagger/internal/codegen/BindsInstanceMethodValidator.java
index 653c698da..1a491c76e 100644
--- a/java/dagger/internal/codegen/BindsInstanceMethodValidator.java
+++ b/java/dagger/internal/codegen/BindsInstanceMethodValidator.java
@@ -35,28 +35,45 @@
   BindsInstanceMethodValidator() {}
 
   @Override
-  protected void checkElement(ValidationReport.Builder<ExecutableElement> report) {
-    super.checkElement(report);
+  protected ElementValidator elementValidator(ExecutableElement element) {
+    return new Validator(element);
+  }
+
+  private class Validator extends ElementValidator {
+    Validator(ExecutableElement element) {
+      super(element);
+    }
 
-    ExecutableElement method = report.getSubject();
-    if (!method.getModifiers().contains(ABSTRACT)) {
-      report.addError("@BindsInstance methods must be abstract");
+    @Override
+    protected void checkAdditionalProperties() {
+      if (!element.getModifiers().contains(ABSTRACT)) {
+        report.addError("@BindsInstance methods must be abstract");
+      }
+      if (element.getParameters().size() != 1) {
+        report.addError(
+            "@BindsInstance methods should have exactly one parameter for the bound type");
+      }
+      TypeElement enclosingType = MoreElements.asType(element.getEnclosingElement());
+      moduleAnnotation(enclosingType)
+          .ifPresent(moduleAnnotation -> report.addError(didYouMeanBinds(moduleAnnotation)));
+      anyComponentAnnotation(enclosingType)
+          .ifPresent(
+              componentAnnotation ->
+                  report.addError(
+                      String.format(
+                          "@BindsInstance methods should not be included in @%1$ss. "
+                              + "Did you mean to put it in a @%1$s.Builder?",
+                          componentAnnotation.simpleName())));
     }
-    if (method.getParameters().size() != 1) {
-      report.addError(
-          "@BindsInstance methods should have exactly one parameter for the bound type");
+
+    @Override
+    protected Optional<TypeMirror> bindingElementType() {
+      List<? extends VariableElement> parameters =
+          MoreElements.asExecutable(element).getParameters();
+      return parameters.size() == 1
+          ? Optional.of(getOnlyElement(parameters).asType())
+          : Optional.empty();
     }
-    TypeElement enclosingType = MoreElements.asType(method.getEnclosingElement());
-    moduleAnnotation(enclosingType)
-        .ifPresent(moduleAnnotation -> report.addError(didYouMeanBinds(moduleAnnotation)));
-    anyComponentAnnotation(enclosingType)
-        .ifPresent(
-            componentAnnotation ->
-                report.addError(
-                    String.format(
-                        "@BindsInstance methods should not be included in @%1$ss. "
-                            + "Did you mean to put it in a @%1$s.Builder?",
-                        componentAnnotation.simpleName())));
   }
 
   private static String didYouMeanBinds(ModuleAnnotation moduleAnnotation) {
@@ -64,14 +81,4 @@ private static String didYouMeanBinds(ModuleAnnotation moduleAnnotation) {
         "@BindsInstance methods should not be included in @%ss. Did you mean @Binds?",
         moduleAnnotation.annotationClass().getSimpleName());
   }
-
-  @Override
-  protected Optional<TypeMirror> bindingElementType(
-      ValidationReport.Builder<ExecutableElement> report) {
-    List<? extends VariableElement> parameters =
-        MoreElements.asExecutable(report.getSubject()).getParameters();
-    return parameters.size() == 1
-        ? Optional.of(getOnlyElement(parameters).asType())
-        : Optional.empty();
-  }
 }
diff --git a/java/dagger/internal/codegen/BindsInstanceParameterValidator.java b/java/dagger/internal/codegen/BindsInstanceParameterValidator.java
index be14d4405..b2dc8d878 100644
--- a/java/dagger/internal/codegen/BindsInstanceParameterValidator.java
+++ b/java/dagger/internal/codegen/BindsInstanceParameterValidator.java
@@ -35,32 +35,40 @@
   BindsInstanceParameterValidator() {}
 
   @Override
-  protected void checkElement(ValidationReport.Builder<VariableElement> report) {
-    super.checkElement(report);
+  protected ElementValidator elementValidator(VariableElement element) {
+    return new Validator(element);
+  }
 
-    VariableElement parameter = report.getSubject();
-    Element enclosing = parameter.getEnclosingElement();
-    if (!enclosing.getKind().equals(METHOD)) {
-      report.addError("@BindsInstance should only be applied to methods or parameters of methods");
-      return;
+  private class Validator extends ElementValidator {
+    Validator(VariableElement element) {
+      super(element);
     }
 
-    ExecutableElement method = MoreElements.asExecutable(enclosing);
-    if (!method.getModifiers().contains(ABSTRACT)) {
-      report.addError("@BindsInstance parameters may only be used in abstract methods");
-    }
+    @Override
+    protected void checkAdditionalProperties() {
+      Element enclosing = element.getEnclosingElement();
+      if (!enclosing.getKind().equals(METHOD)) {
+        report.addError(
+            "@BindsInstance should only be applied to methods or parameters of methods");
+        return;
+      }
+
+      ExecutableElement method = MoreElements.asExecutable(enclosing);
+      if (!method.getModifiers().contains(ABSTRACT)) {
+        report.addError("@BindsInstance parameters may only be used in abstract methods");
+      }
 
-    TypeKind returnKind = method.getReturnType().getKind();
-    if (!(returnKind.equals(DECLARED) || returnKind.equals(TYPEVAR))) {
-      report.addError(
-          "@BindsInstance parameters may not be used in methods with a void, array or primitive "
-              + "return type");
+      TypeKind returnKind = method.getReturnType().getKind();
+      if (!(returnKind.equals(DECLARED) || returnKind.equals(TYPEVAR))) {
+        report.addError(
+            "@BindsInstance parameters may not be used in methods with a void, array or primitive "
+                + "return type");
+      }
     }
-  }
 
-  @Override
-  protected Optional<TypeMirror> bindingElementType(
-      ValidationReport.Builder<VariableElement> report) {
-    return Optional.of(report.getSubject().asType());
+    @Override
+    protected Optional<TypeMirror> bindingElementType() {
+      return Optional.of(element.asType());
+    }
   }
 }
diff --git a/java/dagger/internal/codegen/BindsMethodValidator.java b/java/dagger/internal/codegen/BindsMethodValidator.java
index 1850a3228..e198c3af3 100644
--- a/java/dagger/internal/codegen/BindsMethodValidator.java
+++ b/java/dagger/internal/codegen/BindsMethodValidator.java
@@ -58,48 +58,50 @@
   }
 
   @Override
-  protected void checkElement(ValidationReport.Builder<ExecutableElement> builder) {
-    super.checkElement(builder);
-    checkParameters(builder);
+  protected ElementValidator elementValidator(ExecutableElement element) {
+    return new Validator(element);
   }
 
-  @Override
-  protected void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
-    ExecutableElement method = builder.getSubject();
-    if (method.getParameters().size() != 1) {
-      builder.addError(
-          bindingMethods(
-              "must have exactly one parameter, whose type is assignable to the return type"));
-    } else {
-      super.checkParameters(builder);
+  private class Validator extends MethodValidator {
+    Validator(ExecutableElement element) {
+      super(element);
     }
-  }
 
-  @Override
-  protected void checkParameter(
-      ValidationReport.Builder<ExecutableElement> builder, VariableElement parameter) {
-    super.checkParameter(builder, parameter);
-    ExecutableElement method = builder.getSubject();
-    TypeMirror leftHandSide = boxIfNecessary(method.getReturnType());
-    TypeMirror rightHandSide = parameter.asType();
-    ContributionType contributionType = ContributionType.fromBindingElement(method);
-    if (contributionType.equals(ContributionType.SET_VALUES) && !SetType.isSet(leftHandSide)) {
-      builder.addError(
-          "@Binds @ElementsIntoSet methods must return a Set and take a Set parameter");
+    @Override
+    protected void checkParameters() {
+      if (element.getParameters().size() != 1) {
+        report.addError(
+            bindingMethods(
+                "must have exactly one parameter, whose type is assignable to the return type"));
+      } else {
+        super.checkParameters();
+      }
     }
 
-    if (!bindsTypeChecker.isAssignable(rightHandSide, leftHandSide, contributionType)) {
-      // TODO(ronshapiro): clarify this error message for @ElementsIntoSet cases, where the
-      // right-hand-side might not be assignable to the left-hand-side, but still compatible with
-      // Set.addAll(Collection<? extends E>)
-      builder.addError("@Binds methods' parameter type must be assignable to the return type");
+    @Override
+    protected void checkParameter(VariableElement parameter) {
+      super.checkParameter(parameter);
+      TypeMirror leftHandSide = boxIfNecessary(element.getReturnType());
+      TypeMirror rightHandSide = parameter.asType();
+      ContributionType contributionType = ContributionType.fromBindingElement(element);
+      if (contributionType.equals(ContributionType.SET_VALUES) && !SetType.isSet(leftHandSide)) {
+        report.addError(
+            "@Binds @ElementsIntoSet methods must return a Set and take a Set parameter");
+      }
+
+      if (!bindsTypeChecker.isAssignable(rightHandSide, leftHandSide, contributionType)) {
+        // TODO(ronshapiro): clarify this error message for @ElementsIntoSet cases, where the
+        // right-hand-side might not be assignable to the left-hand-side, but still compatible with
+        // Set.addAll(Collection<? extends E>)
+        report.addError("@Binds methods' parameter type must be assignable to the return type");
+      }
     }
-  }
 
-  private TypeMirror boxIfNecessary(TypeMirror maybePrimitive) {
-    if (maybePrimitive.getKind().isPrimitive()) {
-      return types.boxedClass(MoreTypes.asPrimitiveType(maybePrimitive)).asType();
+    private TypeMirror boxIfNecessary(TypeMirror maybePrimitive) {
+      if (maybePrimitive.getKind().isPrimitive()) {
+        return types.boxedClass(MoreTypes.asPrimitiveType(maybePrimitive)).asType();
+      }
+      return maybePrimitive;
     }
-    return maybePrimitive;
   }
 }
diff --git a/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java b/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java
index b1d440cd6..e1c9d735f 100644
--- a/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java
+++ b/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java
@@ -60,29 +60,33 @@
   }
 
   @Override
-  protected void checkElement(ValidationReport.Builder<ExecutableElement> builder) {
-    super.checkElement(builder);
-    checkParameters(builder);
+  protected ElementValidator elementValidator(ExecutableElement element) {
+    return new Validator(element);
   }
 
-  @Override
-  protected void checkKeyType(
-      ValidationReport.Builder<ExecutableElement> builder, TypeMirror keyType) {
-    super.checkKeyType(builder, keyType);
-    if (isValidImplicitProvisionKey(
-            getQualifiers(builder.getSubject()).stream().findFirst(), keyType, types)
-        && !injectedConstructors(MoreElements.asType(MoreTypes.asDeclared(keyType).asElement()))
-            .isEmpty()) {
-      builder.addError(
-          "@BindsOptionalOf methods cannot return unqualified types that have an @Inject-"
-              + "annotated constructor because those are always present");
+  private class Validator extends MethodValidator {
+    Validator(ExecutableElement element) {
+      super(element);
     }
-  }
 
-  @Override
-  protected void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
-    if (!builder.getSubject().getParameters().isEmpty()) {
-      builder.addError("@BindsOptionalOf methods cannot have parameters");
+    @Override
+    protected void checkKeyType(TypeMirror keyType) {
+      super.checkKeyType(keyType);
+      if (isValidImplicitProvisionKey(
+              getQualifiers(element).stream().findFirst(), keyType, types)
+          && !injectedConstructors(MoreElements.asType(MoreTypes.asDeclared(keyType).asElement()))
+              .isEmpty()) {
+        report.addError(
+            "@BindsOptionalOf methods cannot return unqualified types that have an @Inject-"
+                + "annotated constructor because those are always present");
+      }
+    }
+
+    @Override
+    protected void checkParameters() {
+      if (!element.getParameters().isEmpty()) {
+        report.addError("@BindsOptionalOf methods cannot have parameters");
+      }
     }
   }
 }
diff --git a/java/dagger/internal/codegen/MultibindsMethodValidator.java b/java/dagger/internal/codegen/MultibindsMethodValidator.java
index 4bd4603fa..bc97d3060 100644
--- a/java/dagger/internal/codegen/MultibindsMethodValidator.java
+++ b/java/dagger/internal/codegen/MultibindsMethodValidator.java
@@ -55,45 +55,49 @@
   }
 
   @Override
-  protected void checkElement(ValidationReport.Builder<ExecutableElement> builder) {
-    super.checkElement(builder);
-
-    checkParameters(builder);
+  protected ElementValidator elementValidator(ExecutableElement element) {
+    return new Validator(element);
   }
 
-  @Override
-  protected void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
-    if (!builder.getSubject().getParameters().isEmpty()) {
-      builder.addError(bindingMethods("cannot have parameters"));
+  private class Validator extends MethodValidator {
+    Validator(ExecutableElement element) {
+      super(element);
     }
-  }
 
-  /** Adds an error unless the method returns a {@code Map<K, V>} or {@code Set<T>}. */
-  @Override
-  protected void checkType(ValidationReport.Builder<ExecutableElement> builder) {
-    if (!isPlainMap(builder.getSubject().getReturnType())
-        && !isPlainSet(builder.getSubject().getReturnType())) {
-      builder.addError(bindingMethods("must return Map<K, V> or Set<T>"));
+    @Override
+    protected void checkParameters() {
+      if (!element.getParameters().isEmpty()) {
+        report.addError(bindingMethods("cannot have parameters"));
+      }
     }
-  }
 
-  private boolean isPlainMap(TypeMirror returnType) {
-    if (!MapType.isMap(returnType)) {
-      return false;
+    /** Adds an error unless the method returns a {@code Map<K, V>} or {@code Set<T>}. */
+    @Override
+    protected void checkType() {
+      if (!isPlainMap(element.getReturnType())
+          && !isPlainSet(element.getReturnType())) {
+        report.addError(bindingMethods("must return Map<K, V> or Set<T>"));
+      }
+    }
+
+    private boolean isPlainMap(TypeMirror returnType) {
+      if (!MapType.isMap(returnType)) {
+        return false;
+      }
+      MapType mapType = MapType.from(returnType);
+      return !mapType.isRawType()
+          && MoreTypes.isType(mapType.valueType()) // No wildcards.
+          && !isFrameworkType(mapType.valueType());
     }
-    MapType mapType = MapType.from(returnType);
-    return !mapType.isRawType()
-        && MoreTypes.isType(mapType.valueType()) // No wildcards.
-        && !isFrameworkType(mapType.valueType());
-  }
 
-  private boolean isPlainSet(TypeMirror returnType) {
-    if (!SetType.isSet(returnType)) {
-      return false;
+    private boolean isPlainSet(TypeMirror returnType) {
+      if (!SetType.isSet(returnType)) {
+        return false;
+      }
+      SetType setType = SetType.from(returnType);
+      return !setType.isRawType()
+          && MoreTypes.isType(setType.elementType()) // No wildcards.
+          && !isFrameworkType(setType.elementType());
     }
-    SetType setType = SetType.from(returnType);
-    return !setType.isRawType()
-        && MoreTypes.isType(setType.elementType()) // No wildcards.
-        && !isFrameworkType(setType.elementType());
   }
 }
diff --git a/java/dagger/internal/codegen/ProducesMethodValidator.java b/java/dagger/internal/codegen/ProducesMethodValidator.java
index 09e5ce4d1..bf4594856 100644
--- a/java/dagger/internal/codegen/ProducesMethodValidator.java
+++ b/java/dagger/internal/codegen/ProducesMethodValidator.java
@@ -57,17 +57,8 @@
   }
 
   @Override
-  protected void checkElement(ValidationReport.Builder<ExecutableElement> builder) {
-    super.checkElement(builder);
-    checkNullable(builder);
-  }
-
-  /** Adds a warning if a {@link Produces @Produces} method is declared nullable. */
-  // TODO(beder): Properly handle nullable with producer methods.
-  private void checkNullable(ValidationReport.Builder<ExecutableElement> builder) {
-    if (ConfigurationAnnotations.getNullableType(builder.getSubject()).isPresent()) {
-      builder.addWarning("@Nullable on @Produces methods does not do anything");
-    }
+  protected String elementsIntoSetNotASetMessage() {
+    return "@Produces methods of type set values must return a Set or ListenableFuture of Set";
   }
 
   @Override
@@ -76,51 +67,67 @@ protected String badTypeMessage() {
         + "a declared type, or a ListenableFuture of one of those types";
   }
 
-  /**
-   * {@inheritDoc}
-   *
-   * <p>Allows {@code keyType} to be a {@link ListenableFuture} of an otherwise-valid key type.
-   */
   @Override
-  protected void checkKeyType(
-      ValidationReport.Builder<ExecutableElement> reportBuilder, TypeMirror keyType) {
-    Optional<TypeMirror> typeToCheck = unwrapListenableFuture(reportBuilder, keyType);
-    if (typeToCheck.isPresent()) {
-      super.checkKeyType(reportBuilder, typeToCheck.get());
-    }
+  protected ElementValidator elementValidator(ExecutableElement element) {
+    return new Validator(element);
   }
 
-  /**
-   * {@inheritDoc}
-   *
-   * <p>Allows an {@link ElementsIntoSet @ElementsIntoSet} or {@code SET_VALUES} method to return a
-   * {@link ListenableFuture} of a {@link Set} as well.
-   */
-  @Override
-  protected void checkSetValuesType(ValidationReport.Builder<ExecutableElement> builder) {
-    Optional<TypeMirror> typeToCheck =
-        unwrapListenableFuture(builder, builder.getSubject().getReturnType());
-    if (typeToCheck.isPresent()) {
-      checkSetValuesType(builder, typeToCheck.get());
+  private class Validator extends MethodValidator {
+    Validator(ExecutableElement element) {
+      super(element);
     }
-  }
 
-  @Override
-  protected String elementsIntoSetNotASetMessage() {
-    return "@Produces methods of type set values must return a Set or ListenableFuture of Set";
-  }
+    @Override
+    protected void checkAdditionalMethodProperties() {
+      checkNullable();
+    }
+
+    /** Adds a warning if a {@link Produces @Produces} method is declared nullable. */
+    // TODO(beder): Properly handle nullable with producer methods.
+    private void checkNullable() {
+      if (ConfigurationAnnotations.getNullableType(element).isPresent()) {
+        report.addWarning("@Nullable on @Produces methods does not do anything");
+      }
+    }
+
+    /**
+     * {@inheritDoc}
+     *
+     * <p>Allows {@code keyType} to be a {@link ListenableFuture} of an otherwise-valid key type.
+     */
+    @Override
+    protected void checkKeyType(TypeMirror keyType) {
+      Optional<TypeMirror> typeToCheck = unwrapListenableFuture(keyType);
+      if (typeToCheck.isPresent()) {
+        super.checkKeyType(typeToCheck.get());
+      }
+    }
+
+    /**
+     * {@inheritDoc}
+     *
+     * <p>Allows an {@link ElementsIntoSet @ElementsIntoSet} or {@code SET_VALUES} method to return
+     * a {@link ListenableFuture} of a {@link Set} as well.
+     */
+    @Override
+    protected void checkSetValuesType() {
+      Optional<TypeMirror> typeToCheck = unwrapListenableFuture(element.getReturnType());
+      if (typeToCheck.isPresent()) {
+        checkSetValuesType(typeToCheck.get());
+      }
+    }
 
-  private static Optional<TypeMirror> unwrapListenableFuture(
-      ValidationReport.Builder<ExecutableElement> reportBuilder, TypeMirror type) {
-    if (MoreTypes.isType(type) && MoreTypes.isTypeOf(ListenableFuture.class, type)) {
-      DeclaredType declaredType = MoreTypes.asDeclared(type);
-      if (declaredType.getTypeArguments().isEmpty()) {
-        reportBuilder.addError("@Produces methods cannot return a raw ListenableFuture");
-        return Optional.empty();
-      } else {
-        return Optional.of((TypeMirror) getOnlyElement(declaredType.getTypeArguments()));
+    private Optional<TypeMirror> unwrapListenableFuture(TypeMirror type) {
+      if (MoreTypes.isType(type) && MoreTypes.isTypeOf(ListenableFuture.class, type)) {
+        DeclaredType declaredType = MoreTypes.asDeclared(type);
+        if (declaredType.getTypeArguments().isEmpty()) {
+          report.addError("@Produces methods cannot return a raw ListenableFuture");
+          return Optional.empty();
+        } else {
+          return Optional.of((TypeMirror) getOnlyElement(declaredType.getTypeArguments()));
+        }
       }
+      return Optional.of(type);
     }
-    return Optional.of(type);
   }
 }
diff --git a/java/dagger/internal/codegen/ProvidesMethodValidator.java b/java/dagger/internal/codegen/ProvidesMethodValidator.java
index 771edf1dd..01e71ae09 100644
--- a/java/dagger/internal/codegen/ProvidesMethodValidator.java
+++ b/java/dagger/internal/codegen/ProvidesMethodValidator.java
@@ -55,15 +55,24 @@
   }
 
   @Override
-  protected void checkElement(ValidationReport.Builder<ExecutableElement> builder) {
-    super.checkElement(builder);
+  protected ElementValidator elementValidator(ExecutableElement element) {
+    return new Validator(element);
   }
 
-  /** Adds an error if a {@link Provides @Provides} method depends on a producer type. */
-  @Override
-  protected void checkParameter(
-      ValidationReport.Builder<ExecutableElement> builder, VariableElement parameter) {
-    super.checkParameter(builder, parameter);
-    dependencyRequestValidator.checkNotProducer(builder, parameter);
+  private class Validator extends MethodValidator {
+    Validator(ExecutableElement element) {
+      super(element);
+    }
+
+    @Override
+    protected void checkAdditionalMethodProperties() {
+    }
+
+    /** Adds an error if a {@link Provides @Provides} method depends on a producer type. */
+    @Override
+    protected void checkParameter(VariableElement parameter) {
+      super.checkParameter(parameter);
+      dependencyRequestValidator.checkNotProducer(report, parameter);
+    }
   }
 }
