diff --git a/core/src/main/java/dagger/Component.java b/core/src/main/java/dagger/Component.java
new file mode 100644
index 000000000..08880e845
--- /dev/null
+++ b/core/src/main/java/dagger/Component.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Target;
+import javax.inject.Inject;
+import javax.inject.Provider;
+import javax.inject.Qualifier;
+
+import static java.lang.annotation.ElementType.TYPE;
+
+/**
+ * Annotates an interface or abstract class for which a fully-formed, dependency-injected
+ * implementation is to be generated from a set of {@linkplain #modules}. The generated class will
+ * have the name of the type annotated with {@code @Component} prepended with
+ * {@code Dagger_}.  For example, {@code @Component interface MyComponent {...}} will
+ * produce an implementation named {@code Dagger_MyComponent}.
+ *
+ * <h2>Component methods</h2>
+ *
+ * <p>Every type annotated with {@code @Component} must contain at least one abstract component
+ * method. Component methods must either represent {@linkplain Provider provision} or
+ * {@linkplain MembersInjector member injection}.
+ *
+ * Provision methods have no arguments and return an {@link Inject injected} or
+ * {@link Provides provided} type.  Each may have a {@link Qualifier} annotation as well. The
+ * following are all valid provision method declarations: <pre>   {@code
+ *   SomeType getSomeType();
+ *   Set<SomeType> getSomeTypes();
+ *   @PortNumber int getPortNumber();
+ *   }</pre>
+ *
+ * Member injection methods take a single parameter and optionally return that same type. The
+ * following are all valid member injection method declarations: <pre>   {@code
+ *   void injectSomeType(SomeType someType);
+ *   SomeType injectAndReturnSomeType(SomeType someType);
+ *   }</pre>
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+// TODO(gak): add missing spec for @Scope
+// TODO(gak): add missing spec for component dependencies
+@Target(TYPE)
+@Documented
+public @interface Component {
+  /**
+   * A list of classes annotated with {@link Module} whose bindings are used to generate the
+   * component implementation.
+   */
+  Class<?>[] modules() default {};
+
+  /**
+   * A list of types that are to be used as component dependencies.
+   */
+  Class<?>[] dependencies() default {};
+}
diff --git a/core/src/main/java/dagger/Factory.java b/core/src/main/java/dagger/Factory.java
new file mode 100644
index 000000000..74e2d0d12
--- /dev/null
+++ b/core/src/main/java/dagger/Factory.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger;
+
+import javax.inject.Inject;
+import javax.inject.Provider;
+import javax.inject.Scope;
+
+/**
+ * An {@linkplain Scope unscoped} {@link Provider}. While a {@link Provider} <i>may<i> apply
+ * scoping semantics while providing an instance, a factory implementation is guaranteed to exercise
+ * the binding logic ({@link Inject} constructors, {@link Provides} methods) upon each call to
+ * {@link #get}.
+ *
+ * <p>Note that while subsequent calls to {@link #get} will create new instances for bindings such
+ * as those created by {@link Inject} constructors, a new instance is not guaranteed by all
+ * bindings. For example, {@link Provides} methods may be implemented in ways that return the same
+ * instance for each call.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+public interface Factory<T> extends Provider<T> {
+}
diff --git a/core/src/main/java/dagger/Lazy.java b/core/src/main/java/dagger/Lazy.java
new file mode 100644
index 000000000..59419abd3
--- /dev/null
+++ b/core/src/main/java/dagger/Lazy.java
@@ -0,0 +1,159 @@
+/*
+ * Copyright (C) 2012 Google, Inc.
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger;
+
+/**
+ * A handle to a lazily-computed value. Each {@code Lazy} computes its value on
+ * the first call to {@code get()} and remembers that same value for all
+ * subsequent calls to {@code get()}.
+ *
+ * <p>{@code null} is not a supported value.  Implementations of {@code Lazy}
+ * are expected to throw {@link NullPointerException} if the computed value is
+ * {@code null}.
+ *
+ * <h2>Example</h2>
+ * The differences between <strong>direct injection</strong>, <strong>provider
+ * injection</strong> and <strong>lazy injection</strong> are best demonstrated
+ * with an example. Start with a module that computes a different integer for
+ * each use:<pre><code>
+ *   &#64;Module
+ *   public class CounterModule {
+ *
+ *     int next = 100;
+ *
+ *     &#64;Provides Integer provideInteger() {
+ *       System.out.println("computing...");
+ *       return next++;
+ *     }
+ *   }
+ * </code></pre>
+ *
+ * <h3>Direct Injection</h3>
+ * This class injects that integer and prints it 3 times:<pre><code>
+ *   public class DirectCounter {
+ *
+ *     &#64Inject Integer value;
+ *
+ *     public void print() {
+ *       System.out.println("printing...");
+ *       System.out.println(value);
+ *       System.out.println(value);
+ *       System.out.println(value);
+ *     }
+ *   }
+ * </code></pre>
+ * Injecting a {@code DirectCounter} and invoking {@code print()} reveals that
+ * the value is computed <i>before</i> it is required:<pre><code>
+ *   computing...
+ *   printing...
+ *   100
+ *   100
+ *   100
+ * </code></pre>
+ *
+ * <h3>Provider Injection</h3>
+ * This class injects a {@linkplain javax.inject.Provider provider} for the
+ * integer. It calls {@code Provider.get()} 3 times and prints each result:
+ * <pre><code>
+ *   public class ProviderCounter {
+ *
+ *     &#64;Inject Provider<Integer> provider;
+ *
+ *     public void print() {
+ *       System.out.println("printing...");
+ *       System.out.println(provider.get());
+ *       System.out.println(provider.get());
+ *       System.out.println(provider.get());
+ *     }
+ *   }
+ * </code></pre>
+ * Injecting a {@code ProviderCounter} and invoking {@code print()} shows that
+ * a new value is computed each time {@code Provider.get()} is used:<pre><code>
+ *   printing...
+ *   computing...
+ *   100
+ *   computing...
+ *   101
+ *   computing...
+ *   102
+ * </code></pre>
+ *
+ * <h3>Lazy Injection</h3>
+ * This class injects a {@code Lazy} for the integer. Like the provider above,
+ * it calls {@code Lazy.get()} 3 times and prints each result:<pre><code>
+ *   public static class LazyCounter {
+ *
+ *     &#64;Inject Lazy<Integer> lazy;
+ *
+ *     public void print() {
+ *       System.out.println("printing...");
+ *       System.out.println(lazy.get());
+ *       System.out.println(lazy.get());
+ *       System.out.println(lazy.get());
+ *     }
+ *   }
+ * </code></pre>
+ * Injecting a {@code LazyCounter} and invoking {@code print()} shows that a new
+ * value is computed immediately before it is needed. The same value is returned
+ * for all subsequent uses:<pre><code>
+ *   printing...
+ *   computing...
+ *   100
+ *   100
+ *   100
+ * </code></pre>
+ *
+ * <h3>Lazy != Singleton</h3>
+ * Note that each injected {@code Lazy} is independent, and remembers its value
+ * in isolation of other {@code Lazy} instances. In this example, two {@code
+ * LazyCounter} objects are created and {@code print()} is called on each:
+ * <pre><code>
+ *     public void run() {
+ *       ObjectGraph graph = ObjectGraph.create(new CounterModule());
+ *
+ *       LazyCounter counter1 = graph.get(LazyCounter.class);
+ *       counter1.print();
+ *
+ *       LazyCounter counter2 = graph.get(LazyCounter.class);
+ *       counter2.print();
+ *     }
+ * </code></pre>
+ * The program's output demonstrates that each {@code Lazy} works independently:
+ * <pre><code>
+ *   printing...
+ *   computing...
+ *   100
+ *   100
+ *   100
+ *   printing...
+ *   computing...
+ *   101
+ *   101
+ *   101
+ * </code></pre>
+ * Use {@linkplain javax.inject.Singleton @Singleton} to share one instance
+ * among all clients, and {@code Lazy} for lazy computation in a single client.
+ */
+public interface Lazy<T> {
+  /**
+   * Return the underlying value, computing the value if necessary. All calls to
+   * the same {@code Lazy} instance will return the same result.
+   *
+   * @throws NullPointerException if the computed value is {@code null}.
+   */
+  T get();
+}
diff --git a/core/src/main/java/dagger/MapKey.java b/core/src/main/java/dagger/MapKey.java
new file mode 100644
index 000000000..06c3b65d9
--- /dev/null
+++ b/core/src/main/java/dagger/MapKey.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger;
+
+import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+/**
+ * It enables to define customized key type annotation for map binding by
+ * annotating an annotation of a {@code Map}'s key type. The defined key type
+ * annotation can be later applied to the key of the {@code Map}. Currently
+ * {@code String} and {@code enum} key types are supported for map binding.
+ *
+ * <h2>Example</h2> For example, if you want to define a key type annotation
+ * called StringKey, you can define it the following way:
+ *
+ * <pre><code>
+ *&#64;MapKey(unwrapValue = true)
+ *&#64;Retention(RUNTIME)
+ *public &#64;interface StringKey {
+ *String value();
+ *}
+ *</code></pre>
+ *
+ * if {@code unwrapValue} is false, then the whole annotation will be the key
+ * type for the map and annotation instances will be the keys. If
+ * {@code unwrapValue} is true, the value() type of key type annotation will be
+ * the key type for injected map and the value instances will be the keys.
+ */
+@Documented
+@Target(ANNOTATION_TYPE)
+@Retention(RUNTIME)
+public @interface MapKey {
+  /**
+   * if {@code unwrapValue} is false, then the whole annotation will be the type and annotation
+   * instances will be the keys. If {@code unwrapValue} is true, the value() type of key type
+   * annotation will be the key type for injected map and the value instances will be the keys.
+   * Currently only support {@code unwrapValue} to be true.
+   */
+  boolean unwrapValue();
+}
diff --git a/core/src/main/java/dagger/MembersInjector.java b/core/src/main/java/dagger/MembersInjector.java
new file mode 100644
index 000000000..d0de7f396
--- /dev/null
+++ b/core/src/main/java/dagger/MembersInjector.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2009 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger;
+
+/**
+ * Injects dependencies into the fields and methods on instances of type {@code T}. Ignores the
+ * presence or absence of an injectable constructor.
+ *
+ * @param <T> type to inject members of
+ *
+ * @author Bob Lee
+ * @author Jesse Wilson
+ * @since 2.0 (since 1.0 without the provision that {@link #injectMembers} cannot accept
+ *      {@code null})
+ */
+public interface MembersInjector<T> {
+
+  /**
+   * Injects dependencies into the fields and methods of {@code instance}. Ignores the presence or
+   * absence of an injectable constructor.
+   *
+   * <p>Whenever the object graph creates an instance, it performs this injection automatically
+   * (after first performing constructor injection), so if you're able to let the object graph
+   * create all your objects for you, you'll never need to use this method.
+   *
+   * @param instance into which members are to be injected
+   * @throws NullPointerException if {@code instance} is {@code null}
+   */
+  void injectMembers(T instance);
+}
diff --git a/core/src/main/java/dagger/Module.java b/core/src/main/java/dagger/Module.java
new file mode 100644
index 000000000..1e28f4fd6
--- /dev/null
+++ b/core/src/main/java/dagger/Module.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Annotates a class that contributes to the object graph.
+ */
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.TYPE)
+public @interface Module {
+  /**
+   * Returns classes that object graphs created with this module must be able to
+   * inject. This includes both classes passed to {@link ObjectGraph#get} and
+   * the types of instances passed {@link ObjectGraph#inject}.
+   *
+   * <p>It is an error to call {@link ObjectGraph#get} or {@link
+   * ObjectGraph#inject} with a type that isn't listed in the {@code injects}
+   * set for any of the object graph's modules. Making such a call will trigger
+   * an {@code IllegalArgumentException} at runtime.
+   *
+   * <p>Maintaining this set is onerous, but doing so provides benefits to the
+   * application. This set enables dagger to perform more aggressive static
+   * analysis than would be otherwise possible:
+   * <ul>
+   *   <li><strong>Detect missing bindings.</strong> Dagger can check that all
+   *       injected dependencies can be satisfied. Set {@code complete=false} to
+   *       disable this check for the current module.
+   *   <li><strong>Detect unused bindings.</strong> Dagger can check that all
+   *       provides methods are used to satisfy injected dependencies. Set
+   *       {@code library=true} to disable this check for the current module.
+   * </ul>
+   */
+  Class<?>[] injects() default { };
+  Class<?>[] staticInjections() default { };
+
+  /**
+   * True if {@code @Provides} methods from this module are permitted to
+   * override those of other modules. This is a dangerous feature as it permits
+   * binding conflicts to go unnoticed. It should only be used in test and
+   * development modules.
+   */
+  boolean overrides() default false;
+
+  /**
+   * Additional {@code @Module}-annotated classes from which this module is
+   * composed. The de-duplicated contributions of the modules in
+   * {@code includes}, and of their inclusions recursively, are all contributed
+   * to the object graph.
+   */
+  Class<?>[] includes() default { };
+
+  /**
+   * An optional {@code @Module}-annotated class upon which this module can be
+   * {@link ObjectGraph#plus added} to form a complete graph.
+   */
+  Class<?> addsTo() default Void.class;
+
+  /**
+   * True if all of the bindings required by this module can also be satisfied
+   * by this module, its {@link #includes} and its {@link #addsTo}. If a module
+   * is complete it is eligible for additional static checking: tools can detect
+   * if required bindings are not available. Modules that have external
+   * dependencies must use {@code complete = false}.
+   */
+  boolean complete() default true;
+
+  /**
+   * False if all the included bindings in this module are necessary to satisfy
+   * all of its {@link #injects injectable types}. If a module is not a library
+   * module, it is eligible for additional static checking: tools can detect if
+   * included bindings are not necessary. If you provide bindings that are not
+   * used by this module's graph, then you must declare {@code library = true}.
+   *
+   * <p>This is intended to help you detect dead code.
+   */
+  boolean library() default false;
+}
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
new file mode 100644
index 000000000..f9c84ae7b
--- /dev/null
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -0,0 +1,367 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2012 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger;
+
+import dagger.internal.Binding;
+import dagger.internal.BindingsGroup;
+import dagger.internal.FailoverLoader;
+import dagger.internal.Keys;
+import dagger.internal.Linker;
+import dagger.internal.Loader;
+import dagger.internal.ModuleAdapter;
+import dagger.internal.Modules;
+import dagger.internal.Modules.ModuleWithAdapter;
+import dagger.internal.ProblemDetector;
+import dagger.internal.SetBinding;
+import dagger.internal.StaticInjection;
+import dagger.internal.ThrowingErrorHandler;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * A graph of objects linked by their dependencies.
+ *
+ * <p>The following injection features are supported:
+ * <ul>
+ *   <li>Field injection. A class may have any number of field injections, and
+ *       fields may be of any visibility. Static fields will be injected each
+ *       time an instance is injected.
+ *   <li>Constructor injection. A class may have a single
+ *       {@code @Inject}-annotated constructor. Classes that have fields
+ *       injected may omit the {@code @Inject} annotation if they have a public
+ *       no-arguments constructor.
+ *   <li>Injection of {@code @Provides} method parameters.
+ *   <li>{@code @Provides} methods annotated {@code @Singleton}.
+ *   <li>Constructor-injected classes annotated {@code @Singleton}.
+ *   <li>Injection of {@code Provider}s.
+ *   <li>Injection of {@code MembersInjector}s.
+ *   <li>Qualifier annotations on injected parameters and fields.
+ *   <li>JSR 330 annotations.
+ * </ul>
+ *
+ * <p>The following injection features are not currently supported:
+ * <ul>
+ *   <li>Method injection.</li>
+ *   <li>Circular dependencies.</li>
+ * </ul>
+ */
+public abstract class ObjectGraph {
+  ObjectGraph() {
+  }
+
+  /**
+   * Returns an instance of {@code type}.
+   *
+   * @throws IllegalArgumentException if {@code type} is not one of this object
+   *     graph's {@link Module#injects injectable types}.
+   */
+  public abstract <T> T get(Class<T> type);
+
+  /**
+   * Injects the members of {@code instance}, including injectable members
+   * inherited from its supertypes.
+   *
+   * @throws IllegalArgumentException if the runtime type of {@code instance} is
+   *     not one of this object graph's {@link Module#injects injectable types}.
+   */
+  public abstract <T> T inject(T instance);
+
+  /**
+   * Returns a new object graph that includes all of the objects in this graph,
+   * plus additional objects in the {@literal @}{@link Module}-annotated
+   * modules. This graph is a subgraph of the returned graph.
+   *
+   * <p>The current graph is not modified by this operation: its objects and the
+   * dependency links between them are unchanged. But this graph's objects may
+   * be shared by both graphs. For example, the singletons of this graph may be
+   * injected and used by the returned graph.
+   *
+   * <p>This <strong>does not</strong> inject any members or validate the graph.
+   * See {@link #create} for guidance on injection and validation.
+   */
+  public abstract ObjectGraph plus(Object... modules);
+
+  /**
+   * Do runtime graph problem detection. For fastest graph creation, rely on
+   * build time tools for graph validation.
+   *
+   * @throws IllegalStateException if this graph has problems.
+   */
+  public abstract void validate();
+
+  /**
+   * Injects the static fields of the classes listed in the object graph's
+   * {@code staticInjections} property.
+   */
+  public abstract void injectStatics();
+
+  /**
+   * Returns a new dependency graph using the {@literal @}{@link
+   * Module}-annotated modules.
+   *
+   * <p>This <strong>does not</strong> inject any members. Most applications
+   * should call {@link #injectStatics} to inject static members and {@link
+   * #inject} or get {@link #get(Class)} to inject instance members when this
+   * method has returned.
+   *
+   * <p>This <strong>does not</strong> validate the graph. Rely on build time
+   * tools for graph validation, or call {@link #validate} to find problems in
+   * the graph at runtime.
+   */
+  public static ObjectGraph create(Object... modules) {
+    return DaggerObjectGraph.makeGraph(null, new FailoverLoader(), modules);
+  }
+
+  /**
+   * Load the graph with a custom loading strategy.  If you're not using this to work around
+   * proguard obfuscation, then use {@link #create(Object...)}
+   *
+   * @deprecated Recreated for reflective use of Dagger in the obfuscation case, and will be
+   *     entirely obsolete in Dagger 2.0.
+   */
+  @Deprecated
+  public static ObjectGraph createWith(Loader loader, Object... modules) {
+    return DaggerObjectGraph.makeGraph(null, loader, modules);
+  }
+
+  // TODO(user): Move this internal implementation of ObjectGraph into the internal package.
+  static class DaggerObjectGraph extends ObjectGraph {
+    private final DaggerObjectGraph base;
+    private final Linker linker;
+    private final Loader plugin;
+    private final Map<Class<?>, StaticInjection> staticInjections;
+    private final Map<String, Class<?>> injectableTypes;
+    private final List<SetBinding<?>> setBindings;
+
+    DaggerObjectGraph(DaggerObjectGraph base,
+        Linker linker,
+        Loader plugin,
+        Map<Class<?>, StaticInjection> staticInjections,
+        Map<String, Class<?>> injectableTypes,
+        List<SetBinding<?>> setBindings) {
+
+      this.base = base;
+      this.linker = checkNotNull(linker, "linker");
+      this.plugin = checkNotNull(plugin, "plugin");
+      this.staticInjections = checkNotNull(staticInjections, "staticInjections");
+      this.injectableTypes = checkNotNull(injectableTypes, "injectableTypes");
+      this.setBindings = checkNotNull(setBindings, "setBindings");
+    }
+
+    private static <T> T checkNotNull(T object, String label) {
+      if (object == null) throw new NullPointerException(label);
+      return object;
+    }
+
+    private static ObjectGraph makeGraph(DaggerObjectGraph base, Loader plugin, Object... modules) {
+      Map<String, Class<?>> injectableTypes = new LinkedHashMap<String, Class<?>>();
+      Map<Class<?>, StaticInjection> staticInjections
+          = new LinkedHashMap<Class<?>, StaticInjection>();
+      StandardBindings baseBindings =
+          (base == null) ? new StandardBindings() : new StandardBindings(base.setBindings);
+      BindingsGroup overrideBindings = new OverridesBindings();
+
+      ArrayList<ModuleWithAdapter> loadedModules = Modules.loadModules(plugin, modules);
+      int loadedModulesCount = loadedModules.size();
+      for (int moduleIndex = 0; moduleIndex < loadedModulesCount; moduleIndex++) {
+        ModuleWithAdapter loadedModule = loadedModules.get(moduleIndex);
+        @SuppressWarnings("unchecked")
+        ModuleAdapter<Object> moduleAdapter =
+            (ModuleAdapter<Object>) loadedModule.getModuleAdapter();
+        for (int i = 0; i < moduleAdapter.injectableTypes.length; i++) {
+          injectableTypes.put(moduleAdapter.injectableTypes[i], moduleAdapter.moduleClass);
+        }
+        for (int i = 0; i < moduleAdapter.staticInjections.length; i++) {
+          staticInjections.put(moduleAdapter.staticInjections[i], null);
+        }
+        try {
+          BindingsGroup addTo = moduleAdapter.overrides ? overrideBindings : baseBindings;
+          moduleAdapter.getBindings(addTo, loadedModule.getModule());
+        } catch (IllegalArgumentException e) {
+          throw new IllegalArgumentException(
+              moduleAdapter.moduleClass.getSimpleName() + ": " + e.getMessage(), e);
+        }
+      }
+
+      // Create a linker and install all of the user's bindings
+      Linker linker =
+          new Linker((base != null) ? base.linker : null, plugin, new ThrowingErrorHandler());
+      linker.installBindings(baseBindings);
+      linker.installBindings(overrideBindings);
+
+      return new DaggerObjectGraph(
+          base, linker, plugin, staticInjections, injectableTypes, baseBindings.setBindings);
+    }
+
+    @Override public ObjectGraph plus(Object... modules) {
+      linkEverything();
+      return makeGraph(this, plugin, modules);
+    }
+
+    private void linkStaticInjections() {
+      for (Map.Entry<Class<?>, StaticInjection> entry : staticInjections.entrySet()) {
+        StaticInjection staticInjection = entry.getValue();
+        if (staticInjection == null) {
+          staticInjection = plugin.getStaticInjection(entry.getKey());
+          entry.setValue(staticInjection);
+        }
+        staticInjection.attach(linker);
+      }
+    }
+
+    private void linkInjectableTypes() {
+      for (Map.Entry<String, Class<?>> entry : injectableTypes.entrySet()) {
+        linker.requestBinding(entry.getKey(), entry.getValue(), entry.getValue().getClassLoader(),
+            false, true);
+      }
+    }
+
+    @Override public void validate() {
+      Map<String, Binding<?>> allBindings = linkEverything();
+      new ProblemDetector().detectProblems(allBindings.values());
+    }
+
+    /**
+     * Links all bindings, injectable types and static injections.
+     */
+    private Map<String, Binding<?>> linkEverything() {
+      Map<String, Binding<?>> bindings = linker.fullyLinkedBindings();
+      if (bindings != null) {
+        return bindings;
+      }
+      synchronized (linker) {
+        if ((bindings = linker.fullyLinkedBindings()) != null) {
+          return bindings;
+        }
+        linkStaticInjections();
+        linkInjectableTypes();
+        return linker.linkAll(); // Linker.linkAll() implicitly does Linker.linkRequested().
+      }
+    }
+
+    @Override public void injectStatics() {
+      // We call linkStaticInjections() twice on purpose. The first time through
+      // we request all of the bindings we need. The linker returns null for
+      // bindings it doesn't have. Then we ask the linker to link all of those
+      // requested bindings. Finally we call linkStaticInjections() again: this
+      // time the linker won't return null because everything has been linked.
+      synchronized (linker) {
+        linkStaticInjections();
+        linker.linkRequested();
+        linkStaticInjections();
+      }
+
+      for (Map.Entry<Class<?>, StaticInjection> entry : staticInjections.entrySet()) {
+        entry.getValue().inject();
+      }
+    }
+
+    @Override public <T> T get(Class<T> type) {
+      String key = Keys.get(type);
+      String injectableTypeKey = type.isInterface() ? key : Keys.getMembersKey(type);
+      ClassLoader classLoader = type.getClassLoader();
+      @SuppressWarnings("unchecked") // The linker matches keys to bindings by their type.
+      Binding<T> binding =
+          (Binding<T>) getInjectableTypeBinding(classLoader, injectableTypeKey, key);
+      return binding.get();
+    }
+
+    @Override public <T> T inject(T instance) {
+      String membersKey = Keys.getMembersKey(instance.getClass());
+      ClassLoader classLoader = instance.getClass().getClassLoader();
+      @SuppressWarnings("unchecked") // The linker matches keys to bindings by their type.
+      Binding<T> binding =
+          (Binding<T>) getInjectableTypeBinding(classLoader, membersKey, membersKey);
+      binding.injectMembers(instance);
+      return instance;
+    }
+
+    /**
+     * @param classLoader the {@code ClassLoader} used to load dependent bindings.
+     * @param injectableKey the key used to store the injectable type. This
+     *     is a provides key for interfaces and a members injection key for
+     *     other types. That way keys can always be created, even if the type
+     *     has no injectable constructor.
+     * @param key the key to use when retrieving the binding. This may be a
+     *     regular (provider) key or a members key.
+     */
+    private Binding<?> getInjectableTypeBinding(
+        ClassLoader classLoader, String injectableKey, String key) {
+      Class<?> moduleClass = null;
+      for (DaggerObjectGraph graph = this; graph != null; graph = graph.base) {
+        moduleClass = graph.injectableTypes.get(injectableKey);
+        if (moduleClass != null) break;
+      }
+      if (moduleClass == null) {
+        throw new IllegalArgumentException("No inject registered for " + injectableKey
+            + ". You must explicitly add it to the 'injects' option in one of your modules.");
+      }
+
+      synchronized (linker) {
+        Binding<?> binding = linker.requestBinding(key, moduleClass, classLoader, false, true);
+        if (binding == null || !binding.isLinked()) {
+          linker.linkRequested();
+          binding = linker.requestBinding(key, moduleClass, classLoader, false, true);
+        }
+        return binding;
+      }
+    }
+  }
+
+  /**
+   * A BindingsGroup which fails when existing values are clobbered and sets aside
+   * {@link SetBinding}.
+   */
+  private static final class StandardBindings extends BindingsGroup {
+    private final List<SetBinding<?>> setBindings;
+
+    public StandardBindings() {
+      setBindings = new ArrayList<SetBinding<?>>();
+    }
+
+    public StandardBindings(List<SetBinding<?>> baseSetBindings) {
+      setBindings = new ArrayList<SetBinding<?>>(baseSetBindings.size());
+      for (SetBinding<?> sb : baseSetBindings) {
+        @SuppressWarnings({ "rawtypes", "unchecked" })
+        SetBinding<?> child = new SetBinding(sb);
+        setBindings.add(child);
+        put(child.provideKey, child);
+      }
+    }
+
+    @Override public Binding<?> contributeSetBinding(String key, SetBinding<?> value) {
+      setBindings.add(value);
+      return super.put(key, value);
+    }
+  }
+
+  /**
+   * A BindingsGroup which throws an {@link IllegalArgumentException} when a
+   * {@link SetBinding} is contributed, since overrides modules cannot contribute such
+   * bindings.
+   */
+  private static final class OverridesBindings extends BindingsGroup {
+    OverridesBindings() { }
+
+    @Override public Binding<?> contributeSetBinding(String key, SetBinding<?> value) {
+      throw new IllegalArgumentException("Module overrides cannot contribute set bindings.");
+    }
+  }
+}
diff --git a/core/src/main/java/dagger/Provides.java b/core/src/main/java/dagger/Provides.java
new file mode 100644
index 000000000..df4ad904d
--- /dev/null
+++ b/core/src/main/java/dagger/Provides.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2007 Google Inc.
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Annotates methods of a module to create a provider method binding. The
+ * method's return type is bound to its returned value. The object graph will
+ * pass dependencies to the method as parameters.
+ *
+ * @author Bob Lee
+ */
+@Documented @Target(METHOD) @Retention(RUNTIME)
+public @interface Provides {
+  /** The type of binding into which the return type of the annotated method contributes. */
+  enum Type {
+    /**
+     * The method is the only one which can produce the value for the specified return type. This
+     * is the default behavior.
+     */
+    UNIQUE,
+
+    /**
+     * The method's return type forms the generic type argument of a {@code Set<T>}, and the
+     * returned value is contributed to the set. The object graph will pass dependencies to the
+     * method as parameters. The {@code Set<T>} produced from the accumulation of values will be
+     * immutable.
+     */
+    SET,
+
+    /**
+     * Like {@link #SET}, except the method's return type is {@code Set<T>}, where any values are
+     * contributed to the set. An example use is to provide a default empty set binding, which is
+     * otherwise not possible using {@link #SET}.
+     */
+    SET_VALUES,
+
+    /**
+     * The method's return type forms the type argument for the value of a
+     * {@code Map<K, Provider<V>>}, and the combination of the annotated key and the returned value
+     * is contributed to the map as a key/value pair. The {@code Map<K, Provider<V>>} produced from
+     * the accumulation of values will be immutable.
+     */
+    MAP;
+  }
+
+  Type type() default Type.UNIQUE;
+}
diff --git a/core/src/main/java/dagger/internal/ArrayQueue.java b/core/src/main/java/dagger/internal/ArrayQueue.java
new file mode 100644
index 000000000..fbcc27e66
--- /dev/null
+++ b/core/src/main/java/dagger/internal/ArrayQueue.java
@@ -0,0 +1,606 @@
+/*
+ * Written by Josh Bloch of Google Inc. and released to the public domain,
+ * as explained at http://creativecommons.org/publicdomain/zero/1.0/.
+ *
+ * Adapted from https://android.googlesource.com/platform/libcore/+
+ *     android-4.2.2_r1/luni/src/main/java/java/util/ArrayDeque.java
+ */
+package dagger.internal;
+
+import java.lang.reflect.Array;
+import java.util.AbstractCollection;
+import java.util.Collection;
+import java.util.ConcurrentModificationException;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.NoSuchElementException;
+import java.util.Queue;
+
+/**
+ * Resizable-array implementation of the {@link Queue} interface.  Array
+ * queues have no capacity restrictions; they grow as necessary to support
+ * usage.  They are not thread-safe; in the absence of external
+ * synchronization, they do not support concurrent access by multiple threads.
+ * Null elements are prohibited.  This class is likely to be faster than
+ * {@link LinkedList} when used as a queue.
+ *
+ * <p>Most <tt>ArrayBackedQueue</tt> operations run in amortized constant time.
+ * Exceptions include {@link #remove(Object) remove}, {@link
+ * #removeFirstOccurrence removeFirstOccurrence}, {@link #contains contains},
+ * {@link #iterator iterator.remove()}, and the bulk operations, all of which
+ * run in linear time.
+ *
+ * <p>The iterators returned by this class's <tt>iterator</tt> method are
+ * <i>fail-fast</i>: If the queue is modified at any time after the iterator
+ * is created, in any way except through the iterator's own <tt>remove</tt>
+ * method, the iterator will generally throw a {@link
+ * ConcurrentModificationException}.  Thus, in the face of concurrent
+ * modification, the iterator fails quickly and cleanly, rather than risking
+ * arbitrary, non-deterministic behavior at an undetermined time in the
+ * future.
+ *
+ * <p>Note that the fail-fast behavior of an iterator cannot be guaranteed
+ * as it is, generally speaking, impossible to make any hard guarantees in the
+ * presence of unsynchronized concurrent modification.  Fail-fast iterators
+ * throw <tt>ConcurrentModificationException</tt> on a best-effort basis.
+ * Therefore, it would be wrong to write a program that depended on this
+ * exception for its correctness: <i>the fail-fast behavior of iterators
+ * should be used only to detect bugs.</i>
+ *
+ * <p>This class and its iterator implement all of the
+ * <em>optional</em> methods of the {@link Collection} and {@link
+ * Iterator} interfaces.
+ *
+ * @author  Josh Bloch and Doug Lea
+ * @param <E> the type of elements held in this collection
+ */
+public class ArrayQueue<E> extends AbstractCollection<E>
+                           implements Queue<E>, Cloneable, java.io.Serializable {
+    /**
+     * The array in which the elements of the queue are stored.
+     * The capacity of the queue is the length of this array, which is
+     * always a power of two. The array is never allowed to become
+     * full, except transiently within an addX method where it is
+     * resized (see doubleCapacity) immediately upon becoming full,
+     * thus avoiding head and tail wrapping around to equal each
+     * other.  We also guarantee that all array cells not holding
+     * queue elements are always null.
+     */
+    private transient Object[] elements;
+
+    /**
+     * The index of the element at the head of the queue (which is the
+     * element that would be removed by remove() or pop()); or an
+     * arbitrary number equal to tail if the queue is empty.
+     */
+    private transient int head;
+
+    /**
+     * The index at which the next element would be added to the tail
+     * of the queue (via addLast(E), add(E), or push(E)).
+     */
+    private transient int tail;
+
+    /**
+     * The minimum capacity that we'll use for a newly created queue.
+     * Must be a power of 2.
+     */
+    private static final int MIN_INITIAL_CAPACITY = 8;
+
+    // ******  Array allocation and resizing utilities ******
+
+    /**
+     * Allocate empty array to hold the given number of elements.
+     *
+     * @param numElements  the number of elements to hold
+     */
+    private void allocateElements(int numElements) {
+        int initialCapacity = MIN_INITIAL_CAPACITY;
+        // Find the best power of two to hold elements.
+        // Tests "<=" because arrays aren't kept full.
+        if (numElements >= initialCapacity) {
+            initialCapacity = numElements;
+            initialCapacity |= (initialCapacity >>>  1);
+            initialCapacity |= (initialCapacity >>>  2);
+            initialCapacity |= (initialCapacity >>>  4);
+            initialCapacity |= (initialCapacity >>>  8);
+            initialCapacity |= (initialCapacity >>> 16);
+            initialCapacity++;
+
+            if (initialCapacity < 0)   // Too many elements, must back off
+                initialCapacity >>>= 1; // Good luck allocating 2 ^ 30 elements
+        }
+        elements = new Object[initialCapacity];
+    }
+
+    /**
+     * Double the capacity of this queue.  Call only when full, i.e.,
+     * when head and tail have wrapped around to become equal.
+     */
+    private void doubleCapacity() {
+        // assert head == tail;
+        int p = head;
+        int n = elements.length;
+        int r = n - p; // number of elements to the right of p
+        int newCapacity = n << 1;
+        if (newCapacity < 0)
+            throw new IllegalStateException("Sorry, queue too big");
+        Object[] a = new Object[newCapacity];
+        System.arraycopy(elements, p, a, 0, r);
+        System.arraycopy(elements, 0, a, r, p);
+        elements = a;
+        head = 0;
+        tail = n;
+    }
+
+    /**
+     * Constructs an empty array queue with an initial capacity
+     * sufficient to hold 16 elements.
+     */
+    public ArrayQueue() {
+        elements = new Object[16];
+    }
+
+    /**
+     * Constructs an empty array queue with an initial capacity
+     * sufficient to hold the specified number of elements.
+     *
+     * @param numElements  lower bound on initial capacity of the queue
+     */
+    public ArrayQueue(int numElements) {
+        allocateElements(numElements);
+    }
+
+    /**
+     * Constructs a queue containing the elements of the specified
+     * collection, in the order they are returned by the collection's
+     * iterator.  (The first element returned by the collection's
+     * iterator becomes the first element, or <i>front</i> of the
+     * queue.)
+     *
+     * @param c the collection whose elements are to be placed into the queue
+     * @throws NullPointerException if the specified collection is null
+     */
+    public ArrayQueue(Collection<? extends E> c) {
+        allocateElements(c.size());
+        addAll(c);
+    }
+
+    /**
+     * Inserts the specified element at the end of this queue.
+     *
+     * <p>This method is equivalent to {@link #offer}.
+     *
+     * @param e the element to add
+     * @return <tt>true</tt> (as specified by {@link Collection#add})
+     * @throws NullPointerException if the specified element is null
+     */
+    @Override
+    public boolean add(E e) {
+        if (e == null)
+            throw new NullPointerException("e == null");
+        elements[tail] = e;
+        if ((tail = (tail + 1) & (elements.length - 1)) == head)
+            doubleCapacity();
+        return true;
+    }
+
+    /**
+     * Inserts the specified element at the end of this queue.
+     *
+     * @param e the element to add
+     * @return <tt>true</tt> (as specified by {@link Queue#offer})
+     * @throws NullPointerException if the specified element is null
+     */
+    @Override
+    public boolean offer(E e) {
+        return add(e);
+    }
+
+    /**
+     * Retrieves and removes the head of the queue represented by this queue.
+     *
+     * This method differs from {@link #poll poll} only in that it throws an
+     * exception if this queue is empty.
+     *
+     * @return the head of the queue represented by this queue
+     * @throws NoSuchElementException {@inheritDoc}
+     */
+    @Override
+    public E remove() {
+        E x = poll();
+        if (x == null)
+            throw new NoSuchElementException();
+        return x;
+    }
+
+    /**
+     * Retrieves and removes the head of the queue represented by this queue
+     * (in other words, the first element of this queue), or returns
+     * <tt>null</tt> if this queue is empty.
+     *
+     * @return the head of the queue represented by this queue, or
+     *         <tt>null</tt> if this queue is empty
+     */
+    @Override
+    public E poll() {
+        int h = head;
+        @SuppressWarnings("unchecked") E result = (E) elements[h];
+        // Element is null if queue empty
+        if (result == null)
+            return null;
+        elements[h] = null;     // Must null out slot
+        head = (h + 1) & (elements.length - 1);
+        return result;
+    }
+
+    /**
+     * Retrieves, but does not remove, the head of the queue represented by
+     * this queue.  This method differs from {@link #peek peek} only in
+     * that it throws an exception if this queue is empty.
+     *
+     * @return the head of the queue represented by this queue
+     * @throws NoSuchElementException {@inheritDoc}
+     */
+    @Override
+    public E element() {
+        @SuppressWarnings("unchecked") E result = (E) elements[head];
+        if (result == null)
+            throw new NoSuchElementException();
+        return result;
+    }
+
+    /**
+     * Retrieves, but does not remove, the head of the queue represented by
+     * this queue, or returns <tt>null</tt> if this queue is empty.
+     *
+     * @return the head of the queue represented by this queue, or
+     *         <tt>null</tt> if this queue is empty
+     */
+    @Override
+    public E peek() {
+        @SuppressWarnings("unchecked") E result = (E) elements[head];
+        // elements[head] is null if queue empty
+        return result;
+    }
+
+    /**
+     * Removes the element at the specified position in the elements array,
+     * adjusting head and tail as necessary.  This can result in motion of
+     * elements backwards or forwards in the array.
+     *
+     * <p>This method is called delete rather than remove to emphasize
+     * that its semantics differ from those of {@link List#remove(int)}.
+     *
+     * @return true if elements moved backwards
+     */
+    private boolean delete(int i) {
+        //checkInvariants();
+        final Object[] elements = this.elements;
+        final int mask = elements.length - 1;
+        final int h = head;
+        final int t = tail;
+        final int front = (i - h) & mask;
+        final int back  = (t - i) & mask;
+
+        // Invariant: head <= i < tail mod circularity
+        if (front >= ((t - h) & mask))
+            throw new ConcurrentModificationException();
+
+        // Optimize for least element motion
+        if (front < back) {
+            if (h <= i) {
+                System.arraycopy(elements, h, elements, h + 1, front);
+            } else { // Wrap around
+                System.arraycopy(elements, 0, elements, 1, i);
+                elements[0] = elements[mask];
+                System.arraycopy(elements, h, elements, h + 1, mask - h);
+            }
+            elements[h] = null;
+            head = (h + 1) & mask;
+            return false;
+        } else {
+            if (i < t) { // Copy the null tail as well
+                System.arraycopy(elements, i + 1, elements, i, back);
+                tail = t - 1;
+            } else { // Wrap around
+                System.arraycopy(elements, i + 1, elements, i, mask - i);
+                elements[mask] = elements[0];
+                System.arraycopy(elements, 1, elements, 0, t);
+                tail = (t - 1) & mask;
+            }
+            return true;
+        }
+    }
+
+    // *** Collection Methods ***
+
+    /**
+     * Returns the number of elements in this queue.
+     *
+     * @return the number of elements in this queue
+     */
+    @Override
+    public int size() {
+        return (tail - head) & (elements.length - 1);
+    }
+
+    /**
+     * Returns <tt>true</tt> if this queue contains no elements.
+     *
+     * @return <tt>true</tt> if this queue contains no elements
+     */
+    @Override
+    public boolean isEmpty() {
+        return head == tail;
+    }
+
+    /**
+     * Returns an iterator over the elements in this queue.  The elements
+     * will be ordered from first (head) to last (tail).  This is the same
+     * order that elements would be queueued (via successive calls to
+     * {@link #remove} or popped (via successive calls to {@link #pop}).
+     *
+     * @return an iterator over the elements in this queue
+     */
+    @Override
+    public Iterator<E> iterator() {
+        return new QueueIterator();
+    }
+
+    private class QueueIterator implements Iterator<E> {
+        /**
+         * Index of element to be returned by subsequent call to next.
+         */
+        private int cursor = head;
+
+        /**
+         * Tail recorded at construction (also in remove), to stop
+         * iterator and also to check for comodification.
+         */
+        private int fence = tail;
+
+        /**
+         * Index of element returned by most recent call to next.
+         * Reset to -1 if element is deleted by a call to remove.
+         */
+        private int lastRet = -1;
+
+        @Override
+        public boolean hasNext() {
+            return cursor != fence;
+        }
+
+        @Override
+        public E next() {
+            if (cursor == fence)
+                throw new NoSuchElementException();
+            @SuppressWarnings("unchecked") E result = (E) elements[cursor];
+            // This check doesn't catch all possible comodifications,
+            // but does catch the ones that corrupt traversal
+            if (tail != fence || result == null)
+                throw new ConcurrentModificationException();
+            lastRet = cursor;
+            cursor = (cursor + 1) & (elements.length - 1);
+            return result;
+        }
+
+        @Override
+        public void remove() {
+            if (lastRet < 0)
+                throw new IllegalStateException();
+            if (delete(lastRet)) { // if left-shifted, undo increment in next()
+                cursor = (cursor - 1) & (elements.length - 1);
+                fence = tail;
+            }
+            lastRet = -1;
+        }
+    }
+
+    /**
+     * Returns <tt>true</tt> if this queue contains the specified element.
+     * More formally, returns <tt>true</tt> if and only if this queue contains
+     * at least one element <tt>e</tt> such that <tt>o.equals(e)</tt>.
+     *
+     * @param o object to be checked for containment in this queue
+     * @return <tt>true</tt> if this queue contains the specified element
+     */
+    @Override
+    public boolean contains(Object o) {
+        if (o == null)
+            return false;
+        int mask = elements.length - 1;
+        int i = head;
+        Object x;
+        while ((x = elements[i]) != null) {
+            if (o.equals(x))
+                return true;
+            i = (i + 1) & mask;
+        }
+        return false;
+    }
+
+    /**
+     * Removes a single instance of the specified element from this queue.
+     * If the queue does not contain the element, it is unchanged.
+     * More formally, removes the first element <tt>e</tt> such that
+     * <tt>o.equals(e)</tt> (if such an element exists).
+     * Returns <tt>true</tt> if this queue contained the specified element
+     * (or equivalently, if this queue changed as a result of the call).
+     *
+     * @param o element to be removed from this queue, if present
+     * @return <tt>true</tt> if this queue contained the specified element
+     */
+    @Override
+    public boolean remove(Object o) {
+        if (o == null)
+            return false;
+        int mask = elements.length - 1;
+        int i = head;
+        Object x;
+        while ((x = elements[i]) != null) {
+            if (o.equals(x)) {
+                delete(i);
+                return true;
+            }
+            i = (i + 1) & mask;
+        }
+        return false;
+    }
+
+    /**
+     * Removes all of the elements from this queue.
+     * The queue will be empty after this call returns.
+     */
+    @Override
+    public void clear() {
+        int h = head;
+        int t = tail;
+        if (h != t) { // clear all cells
+            head = tail = 0;
+            int i = h;
+            int mask = elements.length - 1;
+            do {
+                elements[i] = null;
+                i = (i + 1) & mask;
+            } while (i != t);
+        }
+    }
+
+    /**
+     * Returns an array containing all of the elements in this queue
+     * in proper sequence (from first to last element).
+     *
+     * <p>The returned array will be "safe" in that no references to it are
+     * maintained by this queue.  (In other words, this method must allocate
+     * a new array).  The caller is thus free to modify the returned array.
+     *
+     * <p>This method acts as bridge between array-based and collection-based
+     * APIs.
+     *
+     * @return an array containing all of the elements in this queue
+     */
+    @Override
+    public Object[] toArray() {
+        return toArray(new Object[size()]);
+    }
+
+    /**
+     * Returns an array containing all of the elements in this queue in
+     * proper sequence (from first to last element); the runtime type of the
+     * returned array is that of the specified array.  If the queue fits in
+     * the specified array, it is returned therein.  Otherwise, a new array
+     * is allocated with the runtime type of the specified array and the
+     * size of this queue.
+     *
+     * <p>If this queue fits in the specified array with room to spare
+     * (i.e., the array has more elements than this queue), the element in
+     * the array immediately following the end of the queue is set to
+     * <tt>null</tt>.
+     *
+     * <p>Like the {@link #toArray()} method, this method acts as bridge between
+     * array-based and collection-based APIs.  Further, this method allows
+     * precise control over the runtime type of the output array, and may,
+     * under certain circumstances, be used to save allocation costs.
+     *
+     * <p>Suppose <tt>x</tt> is a queue known to contain only strings.
+     * The following code can be used to dump the queue into a newly
+     * allocated array of <tt>String</tt>:
+     *
+     *  <pre> {@code String[] y = x.toArray(new String[0]);}</pre>
+     *
+     * Note that <tt>toArray(new Object[0])</tt> is identical in function to
+     * <tt>toArray()</tt>.
+     *
+     * @param a the array into which the elements of the queue are to
+     *          be stored, if it is big enough; otherwise, a new array of the
+     *          same runtime type is allocated for this purpose
+     * @return an array containing all of the elements in this queue
+     * @throws ArrayStoreException if the runtime type of the specified array
+     *         is not a supertype of the runtime type of every element in
+     *         this queue
+     * @throws NullPointerException if the specified array is null
+     */
+    @Override
+    public <T> T[] toArray(T[] a) {
+        int size = size();
+        if (a.length < size)
+            a = (T[]) java.lang.reflect.Array.newInstance(
+                    a.getClass().getComponentType(), size);
+        if (head < tail) {
+            System.arraycopy(elements, head, a, 0, size());
+        } else if (head > tail) {
+            int headPortionLen = elements.length - head;
+            System.arraycopy(elements, head, a, 0, headPortionLen);
+            System.arraycopy(elements, 0, a, headPortionLen, tail);
+        }
+        if (a.length > size)
+            a[size] = null;
+        return a;
+    }
+
+    // *** Object methods ***
+
+    /**
+     * Returns a copy of this queue.
+     *
+     * @return a copy of this queue
+     */
+    @Override
+    public ArrayQueue<E> clone() {
+        try {
+            ArrayQueue<E> result = (ArrayQueue<E>) super.clone();
+            E[] newElements = (E[]) Array.newInstance(elements.getClass().getComponentType(),
+                elements.length);
+            System.arraycopy(elements, 0, newElements, 0, elements.length);
+            result.elements = newElements;
+            return result;
+        } catch (CloneNotSupportedException e) {
+            throw new AssertionError();
+        }
+    }
+
+    /**
+     * Appease the serialization gods.
+     */
+    private static final long serialVersionUID = 2340985798034038923L;
+
+    /**
+     * Serialize this queue.
+     *
+     * @serialData The current size (<tt>int</tt>) of the queue,
+     * followed by all of its elements (each an object reference) in
+     * first-to-last order.
+     */
+    private void writeObject(java.io.ObjectOutputStream s)
+            throws java.io.IOException {
+        s.defaultWriteObject();
+
+        // Write out size
+        s.writeInt(size());
+
+        // Write out elements in order.
+        int mask = elements.length - 1;
+        for (int i = head; i != tail; i = (i + 1) & mask)
+            s.writeObject(elements[i]);
+    }
+
+    /**
+     * Deserialize this queue.
+     */
+    private void readObject(java.io.ObjectInputStream s)
+            throws java.io.IOException, ClassNotFoundException {
+        s.defaultReadObject();
+
+        // Read in size and allocate array
+        int size = s.readInt();
+        allocateElements(size);
+        head = 0;
+        tail = size;
+
+        // Read in all elements in the proper order.
+        for (int i = 0; i < size; i++)
+            elements[i] = s.readObject();
+    }
+}
diff --git a/core/src/main/java/dagger/internal/Binding.java b/core/src/main/java/dagger/internal/Binding.java
new file mode 100644
index 000000000..893dd9515
--- /dev/null
+++ b/core/src/main/java/dagger/internal/Binding.java
@@ -0,0 +1,168 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import dagger.MembersInjector;
+import java.util.Set;
+import javax.inject.Provider;
+
+/**
+ * Injects a value of a specific type.
+ */
+public abstract class Binding<T> implements Provider<T>, MembersInjector<T> {
+  public static final Binding<Object> UNRESOLVED = new Binding<Object>(null, null, false, null) {
+    @Override public Object get() {
+      throw new AssertionError("Unresolved binding should never be called to inject.");
+    }
+    @Override public void injectMembers(Object t) {
+      throw new AssertionError("Unresolved binding should never be called to inject.");
+    }
+  };
+  protected static final boolean IS_SINGLETON = true;
+  protected static final boolean NOT_SINGLETON = false;
+
+  /** Set if the provided instance is always the same object. */
+  private static final int SINGLETON = 1 << 0;
+
+  /** Set if this binding's {@link #attach} completed without any missing dependencies. */
+  private static final int LINKED = 1 << 1;
+
+  /** Set if {@link ProblemDetector} is actively visiting this binding. */
+  private static final int VISITING = 1 << 2;
+
+  /** Set if {@link ProblemDetector} has confirmed this binding has no circular dependencies. */
+  private static final int CYCLE_FREE = 1 << 3;
+
+  private static final int DEPENDED_ON = 1 << 4;
+
+  private static final int LIBRARY = 1 << 5;
+
+  /** The key used to provide instances of 'T', or null if this binding cannot provide instances. */
+  public final String provideKey;
+
+  /** The key used to inject members of 'T', or null if this binding cannot inject members. */
+  public final String membersKey;
+
+  /** Bitfield of states like SINGLETON and LINKED. */
+  private int bits;
+
+  public final Object requiredBy;
+
+  protected Binding(String provideKey, String membersKey, boolean singleton, Object requiredBy) {
+    if (singleton && provideKey == null) {
+      throw new InvalidBindingException(Keys.getClassName(membersKey),
+          "is exclusively members injected and therefore cannot be scoped");
+    }
+    this.provideKey = provideKey;
+    this.membersKey = membersKey;
+    this.requiredBy = requiredBy;
+    this.bits = (singleton ? SINGLETON : 0);
+  }
+
+  /**
+   * Links this binding to its dependencies.
+   */
+  public void attach(Linker linker) {
+  }
+
+  @Override public void injectMembers(T t) {
+    // If no members to inject, no-op.  Some classes will have no injectable members even
+    // if their supertypes do.
+  }
+
+  @Override public T get() {
+    throw new UnsupportedOperationException("No injectable constructor on " + getClass().getName());
+  }
+
+  /**
+   * Populates {@code getBindings} and {@code injectMembersBindings} with the
+   * bindings used by this binding to satisfy {@link #get} and {@link
+   * #injectMembers} calls, respectively.
+   *
+   * @param getBindings the bindings required by this binding's {@code get}
+   *     method. Although {@code get} usually calls into {@code injectMembers},
+   *     this <i>does not</i> contain the injectMembers bindings.
+   * @param injectMembersBindings the bindings required by this binding's {@code
+   *     injectMembers} method.
+   */
+  public void getDependencies(Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {
+    // Do nothing.  No override == no dependencies to contribute.
+  }
+
+  void setLinked() {
+    bits |= LINKED;
+  }
+
+  public boolean isLinked() {
+    return (bits & LINKED) != 0;
+  }
+
+  boolean isSingleton() {
+    return (bits & SINGLETON) != 0;
+  }
+
+  public boolean isVisiting() {
+    return (bits & VISITING) != 0;
+  }
+
+  public void setVisiting(boolean visiting) {
+    this.bits = visiting ? (bits | VISITING) : (bits & ~VISITING);
+  }
+
+  public boolean isCycleFree() {
+    return (bits & CYCLE_FREE) != 0;
+  }
+
+  public void setCycleFree(boolean cycleFree) {
+    this.bits = cycleFree ? (bits | CYCLE_FREE) : (bits & ~CYCLE_FREE);
+  }
+
+  public void setLibrary(boolean library) {
+    this.bits = library ? (bits | LIBRARY) : (bits & ~LIBRARY);
+  }
+
+  public boolean library() {
+    return (bits & LIBRARY) != 0;
+  }
+
+  public void setDependedOn(boolean dependedOn) {
+    this.bits = dependedOn ? (bits | DEPENDED_ON) : (bits & ~DEPENDED_ON);
+  }
+
+  public boolean dependedOn() {
+    return (bits & DEPENDED_ON) != 0;
+  }
+
+  @Override public String toString() {
+    return getClass().getSimpleName()
+            + "[provideKey=\"" + provideKey + "\", memberskey=\"" + membersKey + "\"]";
+  }
+
+  /** An exception thrown by anything attempting to construct a binding which is invalid. */
+  public static class InvalidBindingException extends RuntimeException {
+    public final String type;
+
+    public InvalidBindingException(String type, String error) {
+      super(error);
+      this.type = type;
+    }
+
+    public InvalidBindingException(String type, String error, Throwable cause) {
+      super("Binding for " + type + " was invalid: " + error, cause);
+      this.type = type;
+    }
+  }
+}
diff --git a/core/src/main/java/dagger/internal/BindingsGroup.java b/core/src/main/java/dagger/internal/BindingsGroup.java
new file mode 100644
index 000000000..861f7de86
--- /dev/null
+++ b/core/src/main/java/dagger/internal/BindingsGroup.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2013 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+
+/**
+ * A grouping of bindings that fails when existing values are clobbered, to be used in collecting
+ * the initial set of bindings for a graph (from provides methods).
+ */
+public abstract class BindingsGroup {
+  private final Map<String, Binding<?>> bindings = new LinkedHashMap<String, Binding<?>>();
+
+  public abstract Binding<?> contributeSetBinding(String key, SetBinding<?> value);
+
+  public Binding<?> contributeProvidesBinding(String key, ProvidesBinding<?> value) {
+    return put(key, value);
+  }
+
+  protected Binding<?> put(String key, Binding<?> value) {
+    Binding<?> clobbered = bindings.put(key, value);
+    if (clobbered != null) {
+      bindings.put(key, clobbered); // Put things back as they were.
+      throw new IllegalArgumentException("Duplicate:\n    " + clobbered + "\n    " + value);
+    }
+    return null;
+  }
+
+  public Binding<?> get(String key) {
+    return bindings.get(key);
+  }
+
+  public final Set<Entry<String, Binding<?>>> entrySet() {
+    return bindings.entrySet();
+  }
+
+  @Override public String toString() {
+    return getClass().getSimpleName() + bindings.toString();
+  }
+}
diff --git a/core/src/main/java/dagger/internal/BuiltInBinding.java b/core/src/main/java/dagger/internal/BuiltInBinding.java
new file mode 100644
index 000000000..425c4ff94
--- /dev/null
+++ b/core/src/main/java/dagger/internal/BuiltInBinding.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+/**
+ * Injects a Provider or a MembersInjector.
+ */
+final class BuiltInBinding<T> extends Binding<T> {
+  private final String delegateKey;
+  private final ClassLoader classLoader;
+  private Binding<?> delegate;
+
+  public BuiltInBinding(
+      String key, Object requiredBy, ClassLoader classLoader, String delegateKey) {
+    super(key, null, false, requiredBy);
+    this.classLoader = classLoader;
+    this.delegateKey = delegateKey;
+  }
+
+  @Override public void attach(Linker linker) {
+    delegate = linker.requestBinding(delegateKey, requiredBy, classLoader);
+  }
+
+  @Override public void injectMembers(T t) {
+    throw new UnsupportedOperationException();
+  }
+
+  @SuppressWarnings("unchecked") // At runtime we know 'T' is a Provider or MembersInjector.
+  @Override public T get() {
+    return (T) delegate;
+  }
+
+  public Binding<?> getDelegate() {
+    return delegate;
+  }
+
+  // public void getDependencies() not overridden.
+  // We don't add 'delegate' because it isn't actually used by get() or injectMembers().
+}
diff --git a/core/src/main/java/dagger/internal/DoubleCheckLazy.java b/core/src/main/java/dagger/internal/DoubleCheckLazy.java
new file mode 100644
index 000000000..29315d3af
--- /dev/null
+++ b/core/src/main/java/dagger/internal/DoubleCheckLazy.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import dagger.Lazy;
+import javax.inject.Provider;
+
+/**
+ * A basic {@link Lazy} implementation that memoizes the value returned from a {@link Provider}
+ * using the double-check idiom described in Effective Java 2: Item 71.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+public final class DoubleCheckLazy<T> implements Lazy<T> {
+  private final Provider<T> provider;
+  private volatile T instance = null;
+
+  private DoubleCheckLazy(Provider<T> provider) {
+    assert provider != null;
+    this.provider = provider;
+  }
+
+  @Override
+  public T get() {
+    T result = instance;
+    if (result == null) {
+      synchronized (this) {
+        result = instance;
+        if (result == null) {
+          instance = result = provider.get();
+          if (result == null) {
+            throw new NullPointerException(provider + " returned null");
+          }
+        }
+      }
+    }
+    return result;
+  }
+
+  public static <T> Lazy<T> create(Provider<T> provider) {
+    if (provider == null) {
+      throw new NullPointerException();
+    }
+    return new DoubleCheckLazy<T>(provider);
+  }
+}
diff --git a/core/src/main/java/dagger/internal/FailoverLoader.java b/core/src/main/java/dagger/internal/FailoverLoader.java
new file mode 100644
index 000000000..e55daf06a
--- /dev/null
+++ b/core/src/main/java/dagger/internal/FailoverLoader.java
@@ -0,0 +1,173 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2013 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import dagger.internal.loaders.ReflectiveAtInjectBinding;
+import dagger.internal.loaders.ReflectiveStaticInjection;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+
+import static dagger.internal.loaders.GeneratedAdapters.INJECT_ADAPTER_SUFFIX;
+import static dagger.internal.loaders.GeneratedAdapters.MODULE_ADAPTER_SUFFIX;
+import static dagger.internal.loaders.GeneratedAdapters.STATIC_INJECTION_SUFFIX;
+
+/**
+ * Handles loading/finding of modules, injection bindings, and static injections by use of a
+ * strategy of "load the appropriate generated code" or, if no such code is found, create a
+ * reflective equivalent.
+ */
+public final class FailoverLoader extends Loader {
+  /*
+   * Note that String.concat is used throughout this code because it is the most efficient way to
+   * concatenate _two_ strings.  javac uses StringBuilder for the + operator and it has proven to
+   * be wasteful in terms of both CPU and memory allocated.
+   */
+
+  private final Memoizer<Class<?>, ModuleAdapter<?>> loadedAdapters =
+      new Memoizer<Class<?>, ModuleAdapter<?>>() {
+        @Override protected ModuleAdapter<?> create(Class<?> type) {
+          ModuleAdapter<?> result =
+              instantiate(type.getName().concat(MODULE_ADAPTER_SUFFIX), type.getClassLoader());
+          if (result == null) {
+            throw new IllegalStateException("Module adapter for " + type + " could not be loaded. "
+                + "Please ensure that code generation was run for this module.");
+          }
+          return result;
+        }
+      };
+
+  /**
+   * Obtains a module adapter for {@code module} from the first responding resolver.
+   */
+  @SuppressWarnings("unchecked") // cache ensures types match
+  @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<T> type) {
+    return (ModuleAdapter<T>) loadedAdapters.get(type);
+  }
+
+  private final Memoizer<AtInjectBindingKey, AtInjectBindingInfo> atInjectBindings =
+      new Memoizer<AtInjectBindingKey, AtInjectBindingInfo>() {
+        @Override protected AtInjectBindingInfo create(AtInjectBindingKey key) {
+          return getAtInjectBindingInfo(key.classLoader, key.className);
+        }
+      };
+
+  private static final class AtInjectBindingKey {
+    // classLoader can be null
+    private final ClassLoader classLoader;
+    private final String className;
+
+    AtInjectBindingKey(ClassLoader classLoader, String className) {
+      this.classLoader = classLoader;
+      this.className = className;
+    }
+
+    @Override
+    public int hashCode() {
+      // It is highly unlikely for the same class name to be present in multiple class loaders. If
+      // this does happen, we'll just let those keys collide.
+      return className.hashCode();
+    }
+
+    @Override
+    public boolean equals(Object object) {
+      if (object == this) {
+        return true;
+      }
+      if (object instanceof AtInjectBindingKey) {
+        AtInjectBindingKey other = (AtInjectBindingKey) object;
+        return (classLoader == other.classLoader) && className.equals(other.className);
+      }
+      return false;
+
+    }
+  }
+
+  private static final class AtInjectBindingInfo {
+    private final Constructor<Binding<?>> adapterConstructor;
+    private final ReflectiveAtInjectBinding.Factory<?> reflectiveBindingFactory;
+
+    AtInjectBindingInfo(Constructor<Binding<?>> adapterConstructor,
+        ReflectiveAtInjectBinding.Factory<?> reflectiveBindingFactory) {
+      this.adapterConstructor = adapterConstructor;
+      this.reflectiveBindingFactory = reflectiveBindingFactory;
+    }
+  }
+
+  @Override public Binding<?> getAtInjectBinding(
+      String key, String className, ClassLoader classLoader, boolean mustHaveInjections) {
+    AtInjectBindingInfo info = atInjectBindings.get(new AtInjectBindingKey(classLoader, className));
+    if (info.adapterConstructor != null) {
+      try {
+        return info.adapterConstructor.newInstance();
+        // Duplicated catch statements becase: android.
+      } catch (InstantiationException e) {
+        throw new IllegalStateException(
+            "Could not create an instance of the inject adapter for class " + className, e);
+      } catch (IllegalAccessException e) {
+        throw new IllegalStateException(
+            "Could not create an instance of the inject adapter for class " + className, e);
+      } catch (IllegalArgumentException e) {
+        throw new IllegalStateException(
+            "Could not create an instance of the inject adapter for class " + className, e);
+      } catch (InvocationTargetException e) {
+        throw new IllegalStateException(
+            "Could not create an instance of the inject adapter for class " + className, e);
+      }
+    } else if (info.reflectiveBindingFactory != null) {
+      return info.reflectiveBindingFactory.create(mustHaveInjections);
+    } else {
+      return null;
+    }
+  }
+
+  private AtInjectBindingInfo getAtInjectBindingInfo(ClassLoader classLoader, String className) {
+    Class<?> adapterClass = loadClass(classLoader, className.concat(INJECT_ADAPTER_SUFFIX));
+    if (!adapterClass.equals(Void.class)) {
+      // Found loadable adapter, using it.
+      try {
+        @SuppressWarnings("unchecked")
+        Constructor<Binding<?>> constructor
+            = (Constructor<Binding<?>>) adapterClass.getConstructor();
+        return new AtInjectBindingInfo(constructor, null);
+      } catch (NoSuchMethodException e) {
+        throw new IllegalStateException(
+            "Couldn't find default constructor in the generated inject adapter for class "
+            + className);
+      }
+    }
+    Class<?> type = loadClass(classLoader, className);
+    if (type.equals(Void.class)) {
+      throw new IllegalStateException("Could not load class " + className);
+    }
+    if (type.isInterface()) {
+      // Short-circuit since we can't build reflective bindings for interfaces.
+      return new AtInjectBindingInfo(null, null);
+    }
+    ReflectiveAtInjectBinding.Factory<?> reflectiveBindingFactory
+        = ReflectiveAtInjectBinding.createFactory(type);
+    return new AtInjectBindingInfo(null, reflectiveBindingFactory);
+  }
+
+  @Override public StaticInjection getStaticInjection(Class<?> injectedClass) {
+    StaticInjection result = instantiate(
+          injectedClass.getName().concat(STATIC_INJECTION_SUFFIX), injectedClass.getClassLoader());
+    if (result != null) {
+      return result;
+    }
+    return ReflectiveStaticInjection.create(injectedClass);
+  }
+}
diff --git a/core/src/main/java/dagger/internal/InstanceFactory.java b/core/src/main/java/dagger/internal/InstanceFactory.java
new file mode 100644
index 000000000..7c4990b16
--- /dev/null
+++ b/core/src/main/java/dagger/internal/InstanceFactory.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import dagger.Factory;
+
+/**
+ * A {@link Factory} implementation that returns a single instance for all invocations of
+ * {@link #get}.
+ *
+ * <p>Note that while this is a {@link Factory} implementation, and thus unscoped, each call to
+ * {@link #get} will always return the same instance.  As such, any scoping applied to this factory
+ * is redundant and unnecessary.  However, using this with the {@link ScopedProvider} is valid and
+ * may be desired for testing or contractual guarantees.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+public final class InstanceFactory<T> implements Factory<T> {
+  public static <T> Factory<T> create(T instance) {
+    if (instance == null) {
+      throw new NullPointerException();
+    }
+    return new InstanceFactory<T>(instance);
+  }
+
+  private final T instance;
+
+  private InstanceFactory(T instance) {
+    this.instance = instance;
+  }
+
+  @Override
+  public T get() {
+    return instance;
+  }
+}
diff --git a/core/src/main/java/dagger/internal/Keys.java b/core/src/main/java/dagger/internal/Keys.java
new file mode 100644
index 000000000..2a5fe120f
--- /dev/null
+++ b/core/src/main/java/dagger/internal/Keys.java
@@ -0,0 +1,274 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2012 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import dagger.Lazy;
+import dagger.MembersInjector;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.GenericArrayType;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.Set;
+import javax.inject.Provider;
+import javax.inject.Qualifier;
+
+/**
+ * Formats strings that identify the value to be injected. Keys are of one of
+ * three forms:
+ * <ol>
+ *   <li>{@code com.square.Foo}: provides instances of Foo.
+ *   <li>{@code @com.square.Bar/com.square.Foo}: provides instances of Foo
+ *       qualified by the annotation.
+ *   <li>{@code members/com.square.Foo}: injects members of Foo.
+ * </ol>
+ * Bindings from {@code @Provides} methods are of the first two types. BindingsGroup
+ * created from {@code @Inject}-annotated members of a class are of the first
+ * and last types.
+ */
+public final class Keys {
+  private static final String PROVIDER_PREFIX = Provider.class.getCanonicalName() + "<";
+  private static final String MEMBERS_INJECTOR_PREFIX =
+      MembersInjector.class.getCanonicalName() + "<";
+  private static final String LAZY_PREFIX = Lazy.class.getCanonicalName() + "<";
+  private static final String SET_PREFIX = Set.class.getCanonicalName() + "<";
+
+  private static final Memoizer<Class<? extends Annotation>, Boolean> IS_QUALIFIER_ANNOTATION =
+      new Memoizer<Class<? extends Annotation>, Boolean>() {
+        @Override protected Boolean create(Class<? extends Annotation> annotationType) {
+          return annotationType.isAnnotationPresent(Qualifier.class);
+        }
+      };
+
+  Keys() {
+  }
+
+  /** Returns a key for {@code type} with no annotation. */
+  public static String get(Type type) {
+    return get(type, null);
+  }
+
+  /** Returns a key for the members of {@code type}. */
+  public static String getMembersKey(Class<?> key) {
+    // for classes key.getName() is equivalent to get(key)
+    return "members/".concat(key.getName());
+  }
+
+  /** Returns a key for {@code type} annotated by {@code annotation}. */
+  private static String get(Type type, Annotation annotation) {
+    type = boxIfPrimitive(type);
+    if (annotation == null && type instanceof Class && !((Class<?>) type).isArray()) {
+      return ((Class<?>) type).getName();
+    }
+    StringBuilder result = new StringBuilder();
+    if (annotation != null) {
+      result.append(annotation).append("/");
+    }
+    typeToString(type, result, true);
+    return result.toString();
+  }
+
+  /**
+   * Returns a key for {@code type} annotated with {@code annotations},
+   * wrapped by {@code Set}, reporting failures against {@code subject}.
+   *
+   * @param annotations the annotations on a single method, field or parameter.
+   *     This array may contain at most one qualifier annotation.
+   */
+  public static String getSetKey(Type type, Annotation[] annotations, Object subject) {
+    Annotation qualifier = extractQualifier(annotations, subject);
+    type = boxIfPrimitive(type);
+    StringBuilder result = new StringBuilder();
+    if (qualifier != null) {
+      result.append(qualifier).append("/");
+    }
+    result.append(SET_PREFIX);
+    typeToString(type, result, true);
+    result.append(">");
+    return result.toString();
+  }
+
+  /**
+   * Returns a key for {@code type} annotated with {@code annotations},
+   * reporting failures against {@code subject}.
+   *
+   * @param annotations the annotations on a single method, field or parameter.
+   *     This array may contain at most one qualifier annotation.
+   */
+  public static String get(Type type, Annotation[] annotations, Object subject) {
+    return get(type, extractQualifier(annotations, subject));
+  }
+
+  /**
+   * Validates that among {@code annotations} there exists only one annotation which is, itself
+   * qualified by {@code \@Qualifier}
+   */
+  private static Annotation extractQualifier(Annotation[] annotations,
+      Object subject) {
+    Annotation qualifier = null;
+    for (Annotation a : annotations) {
+      if (!IS_QUALIFIER_ANNOTATION.get(a.annotationType())) {
+        continue;
+      }
+      if (qualifier != null) {
+        throw new IllegalArgumentException("Too many qualifier annotations on " + subject);
+      }
+      qualifier = a;
+    }
+    return qualifier;
+  }
+
+  /**
+   * @param topLevel true if this is a top-level type where primitive types
+   *     like 'int' are forbidden. Recursive calls pass 'false' to support
+   *     arrays like {@code int[]}.
+   */
+  private static void typeToString(Type type, StringBuilder result, boolean topLevel) {
+    if (type instanceof Class) {
+      Class<?> c = (Class<?>) type;
+      if (c.isArray()) {
+        typeToString(c.getComponentType(), result, false);
+        result.append("[]");
+      } else if (c.isPrimitive()) {
+        if (topLevel) {
+          throw new UnsupportedOperationException("Uninjectable type " + c.getName());
+        }
+        result.append(c.getName());
+      } else {
+        result.append(c.getName());
+      }
+    } else if (type instanceof ParameterizedType) {
+      ParameterizedType parameterizedType = (ParameterizedType) type;
+      typeToString(parameterizedType.getRawType(), result, true);
+      Type[] arguments = parameterizedType.getActualTypeArguments();
+      result.append("<");
+      for (int i = 0; i < arguments.length; i++) {
+        if (i != 0) {
+          result.append(", ");
+        }
+        typeToString(arguments[i], result, true);
+      }
+      result.append(">");
+    } else if (type instanceof GenericArrayType) {
+      GenericArrayType genericArrayType = (GenericArrayType) type;
+      typeToString(genericArrayType.getGenericComponentType(), result, false);
+      result.append("[]");
+    } else {
+      throw new UnsupportedOperationException("Uninjectable type " + type);
+    }
+  }
+
+  /**
+   * Returns a key for the type provided by, or injected by this key. For
+   * example, if this is a key for a {@code Provider<Foo>}, this returns the
+   * key for {@code Foo}. This retains annotations and supports both Provider
+   * keys and MembersInjector keys.
+   */
+  static String getBuiltInBindingsKey(String key) {
+    int start = startOfType(key);
+    if (substringStartsWith(key, start, PROVIDER_PREFIX)) {
+      return extractKey(key, start, key.substring(0, start), PROVIDER_PREFIX);
+    } else if (substringStartsWith(key, start, MEMBERS_INJECTOR_PREFIX)) {
+      return extractKey(key, start, "members/", MEMBERS_INJECTOR_PREFIX);
+    } else {
+      return null;
+    }
+  }
+
+  /**
+   * Returns a key for the underlying binding of a {@code Lazy<T>} value. For example,
+   * if this is a key for a {@code Lazy<Foo>}, this returns the key for
+   * {@code Foo}. This retains annotations.
+   */
+  static String getLazyKey(String key) {
+    int start = startOfType(key);
+    if (substringStartsWith(key, start, LAZY_PREFIX)) {
+      return extractKey(key, start, key.substring(0, start), LAZY_PREFIX);
+    } else {
+      return null;
+    }
+  }
+
+  /**
+   * Returns the start of a key if it is a plain key, and the start of the
+   * underlying key if it is an annotated key
+   */
+  private static int startOfType(String key) {
+    return (key.startsWith("@")) ? key.lastIndexOf('/') + 1 : 0;
+  }
+
+  /**
+   * Returns an unwrapped key (the key for {@code T} from a {@code Provider<T>} for example),
+   * removing all wrapping key information, but preserving annotations or known
+   * prefixes.
+   *
+   * @param key the key from which the delegate key should be extracted.
+   * @param start
+   *          an index into the key representing the key's "real" start after
+   *          any annotations.
+   * @param delegatePrefix
+   *          key prefix elements extracted from the underlying delegate
+   *          (annotations, "members/", etc.)
+   * @param prefix the prefix to strip.
+   */
+  private static String extractKey(String key, int start, String delegatePrefix, String prefix) {
+    return delegatePrefix + key.substring(start + prefix.length(), key.length() - 1);
+  }
+
+  /** Returns true if {@code string.substring(offset).startsWith(substring)}. */
+  private static boolean substringStartsWith(String string, int offset, String substring) {
+    return string.regionMatches(offset, substring, 0, substring.length());
+  }
+
+  /** Returns true if {@code key} has a qualifier annotation. */
+  public static boolean isAnnotated(String key) {
+    return key.startsWith("@");
+  }
+
+  /**
+   * Returns the class name for {@code key}, if {@code key} was created with a
+   * class instance. Returns null if {@code key} represents a parameterized type
+   * or an array type.
+   */
+  public static String getClassName(String key) {
+    int start = 0;
+    if (key.startsWith("@") || key.startsWith("members/")) {
+      start = key.lastIndexOf('/') + 1;
+    }
+    return (key.indexOf('<', start) == -1 && key.indexOf('[', start) == -1)
+        ? key.substring(start)
+        : null;
+  }
+
+  /** Returns true if {@code name} is the name of a platform-provided class. */
+  public static boolean isPlatformType(String name) {
+    return name.startsWith("java.") || name.startsWith("javax.") || name.startsWith("android.");
+  }
+
+  private static Type boxIfPrimitive(Type type) {
+    if (type == byte.class) return Byte.class;
+    if (type == short.class) return Short.class;
+    if (type == int.class) return Integer.class;
+    if (type == long.class) return Long.class;
+    if (type == char.class) return Character.class;
+    if (type == boolean.class) return Boolean.class;
+    if (type == float.class) return Float.class;
+    if (type == double.class) return Double.class;
+    if (type == void.class) return Void.class;
+    return type;
+  }
+
+}
diff --git a/core/src/main/java/dagger/internal/LazyBinding.java b/core/src/main/java/dagger/internal/LazyBinding.java
new file mode 100644
index 000000000..ef6f11c98
--- /dev/null
+++ b/core/src/main/java/dagger/internal/LazyBinding.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2012 Google, Inc.
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import dagger.Lazy;
+
+/**
+ * Injects a Lazy wrapper for a type T
+ */
+final class LazyBinding<T> extends Binding<Lazy<T>> {
+
+  private final static Object NOT_PRESENT = new Object();
+
+  private final String lazyKey;
+  private final ClassLoader loader;
+  private Binding<T> delegate;
+
+  public LazyBinding(String key, Object requiredBy, ClassLoader loader, String lazyKey) {
+    super(key, null, false, requiredBy);
+    this.loader = loader;
+    this.lazyKey = lazyKey;
+  }
+
+  @SuppressWarnings("unchecked") // At runtime we know it's a Binding<Lazy<T>>.
+  @Override
+  public void attach(Linker linker) {
+    delegate = (Binding<T>) linker.requestBinding(lazyKey, requiredBy, loader);
+  }
+
+  @Override public void injectMembers(Lazy<T> t) {
+    throw new UnsupportedOperationException(); // Injecting into a custom Lazy not supported.
+  }
+
+  @Override
+  public Lazy<T> get() {
+    // TODO(gak): Use DoubleCheckLazy
+    return new Lazy<T>() {
+      private volatile Object cacheValue = NOT_PRESENT;
+
+      @SuppressWarnings("unchecked") // Delegate is of type T
+      @Override
+      public T get() {
+        if (cacheValue == NOT_PRESENT) {
+          synchronized (this) {
+            if (cacheValue == NOT_PRESENT) {
+              cacheValue = delegate.get();
+            }
+          }
+        }
+        return (T) cacheValue;
+      }
+    };
+  }
+
+  // public void getDependencies() not overridden.
+  // We don't add 'delegate' because it isn't actually used by get() or injectMembers().
+}
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
new file mode 100644
index 000000000..e9cf9f4b6
--- /dev/null
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -0,0 +1,472 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import dagger.internal.Binding.InvalidBindingException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Queue;
+import java.util.Set;
+
+/**
+ * Links bindings to their dependencies.
+ */
+public final class Linker {
+  private static final Object UNINITIALIZED = new Object();
+
+  /**
+   * The base {@code Linker} which will be consulted to satisfy bindings not
+   * otherwise satisfiable from this {@code Linker}. The top-most {@code Linker}
+   * in a chain will have a null base linker.
+   */
+  private final Linker base;
+
+  /** Bindings requiring a call to attach(). May contain deferred bindings. */
+  private final Queue<Binding<?>> toLink = new ArrayQueue<Binding<?>>();
+
+  /** True unless calls to requestBinding() were unable to satisfy the binding. */
+  private boolean attachSuccess = true;
+
+  /** All errors encountered during injection. */
+  private final List<String> errors = new ArrayList<String>();
+
+  /** All of the object graph's bindings. This may contain unlinked bindings. */
+  private final Map<String, Binding<?>> bindings = new HashMap<String, Binding<?>>();
+
+  /**
+   * An unmodifiable map containing all of the bindings available in this linker, fully linked.
+   * This will be null if the bindings are not yet fully linked. It provides both a signal
+   * of completion of the {@link #linkAll()} method, as well as a place to reference the final,
+   * fully linked map of bindings.
+   */
+  private volatile Map<String, Binding<?>> linkedBindings = null;
+
+  private final Loader plugin;
+
+  private final ErrorHandler errorHandler;
+
+  public Linker(Linker base, Loader plugin, ErrorHandler errorHandler) {
+    if (plugin == null) throw new NullPointerException("plugin");
+    if (errorHandler == null) throw new NullPointerException("errorHandler");
+
+    this.base = base;
+    this.plugin = plugin;
+    this.errorHandler = errorHandler;
+  }
+
+  /**
+   * Adds all bindings in {@code toInstall}. The caller must call either {@link
+   * #linkAll} or {@link #requestBinding} and {@link #linkRequested} before the
+   * bindings can be used.
+   *
+   * This method may only be called before {@link #linkAll()}. Subsequent calls to
+   * {@link #installBindings(BindingsGroup)} will throw an {@link IllegalStateException}.
+   */
+  public void installBindings(BindingsGroup toInstall) {
+    if (linkedBindings != null) {
+      throw new IllegalStateException("Cannot install further bindings after calling linkAll().");
+    }
+    for (Map.Entry<String, ? extends Binding<?>> entry : toInstall.entrySet()) {
+      bindings.put(entry.getKey(), scope(entry.getValue()));
+    }
+  }
+
+  /**
+   * Links all known bindings (whether requested or installed), plus all of their
+   * transitive dependencies. This loads injectable types' bindings as necessary to fill in
+   * the gaps.  If this method has returned successfully at least once, all further
+   * work is short-circuited.
+   *
+   * @throws AssertionError if this method is not called within a synchronized block which
+   *     holds this {@link Linker} as the lock object.
+   */
+  public Map<String, Binding<?>> linkAll() {
+    assertLockHeld();
+    if (linkedBindings != null) {
+      return linkedBindings;
+    }
+    for (Binding<?> binding : bindings.values()) {
+      if (!binding.isLinked()) {
+        toLink.add(binding);
+      }
+    }
+    linkRequested(); // This method throws if bindings are not resolvable/linkable.
+    linkedBindings = Collections.unmodifiableMap(bindings);
+    return linkedBindings;
+  }
+
+  /**
+   * Returns the map of all bindings available to this {@link Linker}, if and only if
+   * {@link #linkAll()} has successfully returned at least once, otherwise it returns null;
+   */
+  public Map<String, Binding<?>> fullyLinkedBindings() {
+    return linkedBindings;
+  }
+
+  /**
+   * Links all requested bindings plus their transitive dependencies. This
+   * creates JIT bindings as necessary to fill in the gaps.
+   *
+   * @throws AssertionError if this method is not called within a synchronized block which
+   *     holds this {@link Linker} as the lock object.
+   */
+  public void linkRequested() {
+    assertLockHeld();
+    Binding<?> binding;
+    while ((binding = toLink.poll()) != null) {
+      if (binding instanceof DeferredBinding) {
+        DeferredBinding deferred = (DeferredBinding) binding;
+        String key = deferred.deferredKey;
+        boolean mustHaveInjections = deferred.mustHaveInjections;
+        if (bindings.containsKey(key)) {
+          continue; // A binding for this key has since been linked.
+        }
+        try {
+          Binding<?> resolvedBinding =
+              createBinding(key, binding.requiredBy, deferred.classLoader, mustHaveInjections);
+          resolvedBinding.setLibrary(binding.library());
+          resolvedBinding.setDependedOn(binding.dependedOn());
+          // Fail if the type of binding we got wasn't capable of what was requested.
+          if (!key.equals(resolvedBinding.provideKey) && !key.equals(resolvedBinding.membersKey)) {
+            throw new IllegalStateException("Unable to create binding for " + key);
+          }
+          // Enqueue the JIT binding so its own dependencies can be linked.
+          Binding<?> scopedBinding = scope(resolvedBinding);
+          toLink.add(scopedBinding);
+          putBinding(scopedBinding);
+        } catch (InvalidBindingException e) {
+          addError(e.type + " " + e.getMessage() + " required by " + binding.requiredBy);
+          bindings.put(key, Binding.UNRESOLVED);
+        } catch (UnsupportedOperationException e) {
+          addError("Unsupported: " + e.getMessage() + " required by " + binding.requiredBy);
+          bindings.put(key, Binding.UNRESOLVED);
+        } catch (IllegalArgumentException e) {
+          addError(e.getMessage() + " required by " + binding.requiredBy);
+          bindings.put(key, Binding.UNRESOLVED);
+        } catch (RuntimeException e) {
+          throw e;
+        } catch (Exception e) {
+          throw new RuntimeException(e);
+        }
+      } else {
+        // Attempt to attach the binding to its dependencies. If any dependency
+        // is not available, the attach will fail. We'll enqueue creation of
+        // that dependency and retry the attachment later.
+        attachSuccess = true;
+        binding.attach(this);
+        if (attachSuccess) {
+          binding.setLinked();
+        } else {
+          toLink.add(binding);
+        }
+      }
+    }
+
+    try {
+      errorHandler.handleErrors(errors);
+    } finally {
+      errors.clear();
+    }
+  }
+
+  /**
+   * Don't permit bindings to be linked without a lock. Callers should lock
+   * before requesting any bindings, link the requested bindings, retrieve
+   * the linked bindings, and then release the lock.
+   */
+  private void assertLockHeld() {
+    if (!Thread.holdsLock(this)) throw new AssertionError();
+  }
+
+  /**
+   * Returns a binding for the key in {@code deferred}. The type of binding
+   * to be created depends on the key's type:
+   * <ul>
+   *   <li>Injections of {@code Provider<Foo>}, {@code MembersInjector<Bar>}, and
+   *       {@code Lazy<Blah>} will delegate to the bindings of {@code Foo}, {@code Bar}, and
+   *       {@code Blah} respectively.
+   *   <li>Injections of raw types will use the injectable constructors of those classes.
+   *   <li>Any other injection types require @Provides bindings and will error out.
+   * </ul>
+   */
+  private Binding<?> createBinding(String key, Object requiredBy, ClassLoader classLoader,
+      boolean mustHaveInjections) {
+    String builtInBindingsKey = Keys.getBuiltInBindingsKey(key);
+    if (builtInBindingsKey != null) {
+      return new BuiltInBinding<Object>(key, requiredBy, classLoader, builtInBindingsKey);
+    }
+    String lazyKey = Keys.getLazyKey(key);
+    if (lazyKey != null) {
+      return new LazyBinding<Object>(key, requiredBy, classLoader, lazyKey);
+    }
+
+    String className = Keys.getClassName(key);
+    if (className == null) {
+      throw new InvalidBindingException(key,
+          "is a generic class or an array and can only be bound with concrete type parameter(s) "
+          + "in a @Provides method.");
+    }
+    if (Keys.isAnnotated(key)) {
+      throw new InvalidBindingException(key,
+          "is a @Qualifier-annotated type and must be bound by a @Provides method.");
+    }
+    Binding<?> binding =
+        plugin.getAtInjectBinding(key, className, classLoader, mustHaveInjections);
+    if (binding != null) {
+      return binding;
+    }
+    throw new InvalidBindingException(className, "could not be bound with key " + key);
+  }
+
+  /** @deprecated Older, generated code still using this should be re-generated. */
+  @Deprecated
+  public Binding<?> requestBinding(String key, Object requiredBy) {
+    return requestBinding(
+        key, requiredBy, getClass().getClassLoader(), true, true);
+  }
+
+  /**
+   * Returns the binding if it exists immediately. Otherwise this returns
+   * null. If the returned binding didn't exist or was unlinked, it will be
+   * enqueued to be linked.
+   */
+  public Binding<?> requestBinding(String key, Object requiredBy, ClassLoader classLoader) {
+    return requestBinding(key, requiredBy, classLoader, true, true);
+  }
+
+  /** @deprecated Older, generated code still using this should be re-generated. */
+  @Deprecated
+  public Binding<?> requestBinding(String key, Object requiredBy,
+      boolean mustHaveInjections, boolean library) {
+    return requestBinding(key, requiredBy, getClass().getClassLoader(),
+        mustHaveInjections, library);
+  }
+
+  /**
+   * Returns the binding if it exists immediately. Otherwise this returns
+   * null. If the returned binding didn't exist or was unlinked, it will be
+   * enqueued to be linked.
+   *
+   * @param mustHaveInjections true if the the referenced key requires either an
+   *     {@code @Inject} annotation is produced by a {@code @Provides} method.
+   *     This isn't necessary for Module.injects types because frameworks need
+   *     to inject arbitrary classes like JUnit test cases and Android
+   *     activities. It also isn't necessary for supertypes.
+   */
+  public Binding<?> requestBinding(String key, Object requiredBy, ClassLoader classLoader,
+      boolean mustHaveInjections, boolean library) {
+    assertLockHeld();
+
+    Binding<?> binding = null;
+    for (Linker linker = this; linker != null; linker = linker.base) {
+      binding = linker.bindings.get(key);
+      if (binding != null) {
+        if (linker != this && !binding.isLinked()) throw new AssertionError();
+        break;
+      }
+    }
+
+    if (binding == null) {
+      // We can't satisfy this binding. Make sure it'll work next time!
+      Binding<?> deferredBinding =
+          new DeferredBinding(key, classLoader, requiredBy, mustHaveInjections);
+      deferredBinding.setLibrary(library);
+      deferredBinding.setDependedOn(true);
+      toLink.add(deferredBinding);
+      attachSuccess = false;
+      return null;
+    }
+
+    if (!binding.isLinked()) {
+      toLink.add(binding); // This binding was never linked; link it now!
+    }
+
+    binding.setLibrary(library);
+    binding.setDependedOn(true);
+    return binding;
+  }
+
+  private <T> void putBinding(final Binding<T> binding) {
+
+    // At binding insertion time it's possible that another binding for the same
+    // key to already exist. This occurs when an @Provides method returns a type T
+    // and we also inject the members of that type.
+    if (binding.provideKey != null) {
+      putIfAbsent(bindings, binding.provideKey, binding);
+    }
+    if (binding.membersKey != null) {
+      putIfAbsent(bindings, binding.membersKey, binding);
+    }
+  }
+
+  /**
+   * Returns a scoped binding for {@code binding}.
+   */
+  static <T> Binding<T> scope(final Binding<T> binding) {
+    if (!binding.isSingleton() || binding instanceof SingletonBinding) {
+      return binding; // Default scoped binding or already a scoped binding.
+    }
+    return new SingletonBinding<T>(binding);
+  }
+
+  /**
+   * Puts the mapping {@code key, value} in {@code map} if no mapping for {@code
+   * key} already exists.
+   */
+  private <K, V> void putIfAbsent(Map<K, V> map, K key, V value) {
+    V replaced = map.put(key, value); // Optimistic: prefer only one hash operation lookup.
+    if (replaced != null) {
+      map.put(key, replaced);
+    }
+  }
+
+  /** Enqueue {@code message} as a fatal error to be reported to the user. */
+  private void addError(String message) {
+    errors.add(message);
+  }
+
+  /**
+   * A Binding that implements singleton behaviour around an existing binding.
+   */
+  private static class SingletonBinding<T> extends Binding<T> {
+    private final Binding<T> binding;
+    private volatile Object onlyInstance = UNINITIALIZED;
+
+    private SingletonBinding(Binding<T> binding) {
+      super(binding.provideKey, binding.membersKey, true, binding.requiredBy);
+      this.binding = binding;
+    }
+
+    @Override public void attach(Linker linker) {
+      binding.attach(linker);
+    }
+
+    @Override public void injectMembers(T t) {
+      binding.injectMembers(t);
+    }
+
+    @SuppressWarnings("unchecked") // onlyInstance is either 'UNINITIALIZED' or a 'T'.
+    @Override public T get() {
+      if (onlyInstance == UNINITIALIZED) {
+        synchronized (this) {
+          if (onlyInstance == UNINITIALIZED) {
+            onlyInstance = binding.get();
+          }
+        }
+      }
+      return (T) onlyInstance;
+    }
+
+    @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
+      binding.getDependencies(get, injectMembers);
+    }
+
+    @Override public boolean isCycleFree() {
+      return binding.isCycleFree();
+    }
+
+    @Override public boolean isLinked() {
+      return binding.isLinked();
+    }
+
+    @Override public boolean isVisiting() {
+      return binding.isVisiting();
+    }
+
+    @Override public boolean library() {
+      return binding.library();
+    }
+
+    @Override public boolean dependedOn() {
+      return binding.dependedOn();
+    }
+
+    @Override public void setCycleFree(final boolean cycleFree) {
+      binding.setCycleFree(cycleFree);
+    }
+
+    @Override public void setVisiting(final boolean visiting) {
+      binding.setVisiting(visiting);
+    }
+
+    @Override public void setLibrary(boolean library) {
+      binding.setLibrary(true);
+    }
+
+    @Override public void setDependedOn(boolean dependedOn) {
+      binding.setDependedOn(dependedOn);
+    }
+
+    @Override protected boolean isSingleton() {
+      return true;
+    }
+
+    @Override protected void setLinked() {
+      binding.setLinked();
+    }
+
+    @Override public String toString() {
+      return "@Singleton/" + binding.toString();
+    }
+  }
+
+  /** Handles linker errors appropriately. */
+  public interface ErrorHandler {
+    ErrorHandler NULL = new ErrorHandler() {
+      @Override public void handleErrors(List<String> errors) {
+      }
+    };
+
+    /**
+     * Fail if any errors have been enqueued.
+     * Implementations may throw exceptions or report the errors through another
+     * channel.  Callers are responsible for clearing enqueued errors.
+     *
+     * @param errors a potentially empty list of error messages.
+     */
+    void handleErrors(List<String> errors);
+  }
+
+  private static class DeferredBinding extends Binding<Object> {
+    /** Loader originally intended to load this binding, to be used in loading the actual one */
+    final ClassLoader classLoader;
+    final String deferredKey;
+    final boolean mustHaveInjections;
+
+    private DeferredBinding(String deferredKey, ClassLoader classLoader, Object requiredBy,
+        boolean mustHaveInjections) {
+      super(null, null, false, requiredBy);
+      this.deferredKey = deferredKey;
+      this.classLoader = classLoader;
+      this.mustHaveInjections = mustHaveInjections;
+    }
+
+    @Override public void injectMembers(Object t) {
+      throw new UnsupportedOperationException("Deferred bindings must resolve first.");
+    }
+
+    @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
+      throw new UnsupportedOperationException("Deferred bindings must resolve first.");
+    }
+
+    @Override public String toString() {
+      return "DeferredBinding[deferredKey=" + deferredKey + "]";
+    }
+  }
+}
diff --git a/core/src/main/java/dagger/internal/Loader.java b/core/src/main/java/dagger/internal/Loader.java
new file mode 100644
index 000000000..16e0e2322
--- /dev/null
+++ b/core/src/main/java/dagger/internal/Loader.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2013 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import java.lang.reflect.AccessibleObject;
+
+/**
+ * Provides a point of configuration of the basic resolving functions within Dagger, namely
+ * that of Module handling, injection binding creation, and static injection.  A plugin must
+ * provide all resolution methods
+ */
+public abstract class Loader {
+  private final Memoizer<ClassLoader, Memoizer<String, Class<?>>> caches =
+      new Memoizer<ClassLoader, Memoizer<String, Class<?>>>() {
+        @Override protected Memoizer<String, Class<?>> create(final ClassLoader classLoader) {
+          return new Memoizer<String, Class<?>>() {
+            @Override protected Class<?> create(String className) {
+              try {
+                return classLoader.loadClass(className);
+              } catch (ClassNotFoundException e) {
+                return Void.class; // Cache the failure (negative case).
+              }
+            }
+          };
+        }
+      };
+
+  /**
+   * Returns a binding that uses {@code @Inject} annotations, or null if no valid binding can
+   * be found or created.
+   */
+  public abstract Binding<?> getAtInjectBinding(
+      String key, String className, ClassLoader classLoader, boolean mustHaveInjections);
+
+  /**
+   * Returns a module adapter for {@code moduleClass} or throws a {@code TypeNotPresentException} if
+   * none can be found.
+   */
+  public abstract <T> ModuleAdapter<T> getModuleAdapter(Class<T> moduleClass);
+
+  /**
+   * Returns the static injection for {@code injectedClass}.
+   */
+  public abstract StaticInjection getStaticInjection(Class<?> injectedClass);
+
+  /**
+   * Loads a class from a {@code ClassLoader}-specific cache if it's already there, or
+   * loads it from the given {@code ClassLoader} and caching it for future requests.  Failures
+   * to load are also cached using the Void.class type.  A null {@code ClassLoader} is assumed
+   * to be the system classloader.
+   */
+  protected Class<?> loadClass(ClassLoader classLoader, String name) {
+    // A null classloader is the system classloader.
+    classLoader = (classLoader != null) ? classLoader : ClassLoader.getSystemClassLoader();
+    return caches.get(classLoader).get(name);
+  }
+
+  /**
+   * Instantiates a class using its default constructor and the given {@link ClassLoader}. This
+   * method does not attempt to {@linkplain AccessibleObject#setAccessible set accessibility}.
+   */
+  protected <T> T instantiate(String name, ClassLoader classLoader) {
+    try {
+      Class<?> generatedClass = loadClass(classLoader, name);
+      if (generatedClass == Void.class) {
+        return null;
+      }
+      @SuppressWarnings("unchecked")
+      T instance = (T) generatedClass.newInstance();
+      return instance;
+    } catch (InstantiationException e) {
+      throw new RuntimeException("Failed to initialize " + name, e);
+    } catch (IllegalAccessException e) {
+      throw new RuntimeException("Failed to initialize " + name, e);
+    }
+  }
+
+}
\ No newline at end of file
diff --git a/core/src/main/java/dagger/internal/MapFactory.java b/core/src/main/java/dagger/internal/MapFactory.java
new file mode 100644
index 000000000..10fd6169f
--- /dev/null
+++ b/core/src/main/java/dagger/internal/MapFactory.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import dagger.Factory;
+
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+
+import javax.inject.Provider;
+
+/**
+ * A {@link Factory} implementation used to implement {@link Map} bindings. This factory returns a
+ * {@code Map<K, V>} when calling {@link #get} (as specified by {@link Factory}).
+ *
+ * @author Chenying Hou
+ * @since 2.0
+ *
+ */
+public class MapFactory<K, V> implements Factory<Map<K, V>> {
+  private final Map<K, Provider<V>> contributingMap;
+  
+  private MapFactory(Map<K, Provider<V>> map) {
+    this.contributingMap = Collections.unmodifiableMap(map);
+  }
+
+  /**
+   * Returns a new MapFactory.
+   */
+  public static <K, V> MapFactory<K, V> create(Provider<Map<K, Provider<V>>> mapProviderFactory) {
+    Map<K, Provider<V>> map = mapProviderFactory.get();
+    return new MapFactory<K, V>(map);
+  }
+
+  /**
+   * Returns a {@code Map<K, V>} whose iteration order is that of the elements
+   * given by each of the providers, which are invoked in the order given at creation.
+   *
+   */
+  @Override
+  public Map<K, V> get() {
+    LinkedHashMap<K, V> result = new LinkedHashMap<K, V>();
+    for (Entry<K, Provider<V>> entry: contributingMap.entrySet()) {
+      result.put(entry.getKey(), entry.getValue().get());
+    }
+    return result;
+  }
+}
diff --git a/core/src/main/java/dagger/internal/MapProviderFactory.java b/core/src/main/java/dagger/internal/MapProviderFactory.java
new file mode 100644
index 000000000..5cc62c312
--- /dev/null
+++ b/core/src/main/java/dagger/internal/MapProviderFactory.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import dagger.Factory;
+
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+import javax.inject.Provider;
+
+/**
+ * A {@link Factory} implementation used to implement {@link Map} bindings. This factory returns a
+ * {@code Map<K, Provider<V>>} when calling {@link #get} (as specified by {@link Factory}).
+ *
+ * @author Chenying Hou
+ * @since 2.0
+ *
+ */
+public class MapProviderFactory<K, V> implements Factory<Map<K, Provider<V>>> {
+  private final Map<K, Provider<V>> contributingMap;
+
+  /**
+   * Returns a new {@link Builder}
+   */
+  public static <K, V> Builder<K, V> builder(int size) {
+    return new Builder<K, V>(size);
+  }
+
+  private MapProviderFactory(LinkedHashMap<K, Provider<V>> contributingMap) {
+    this.contributingMap = Collections.unmodifiableMap(contributingMap);
+  }
+
+  /**
+   * Returns a {@code Map<K, Provider<V>>} whose iteration order is that of the elements
+   * given by each of the providers, which are invoked in the order given at creation.
+   *
+   */
+  @Override
+  public Map<K, Provider<V>> get() {
+    return this.contributingMap;
+  }
+
+  /**
+   * A builder to help build the {@link MapProviderFactory}
+   */
+  public static class Builder<K, V> {
+    private final LinkedHashMap<K, Provider<V>> mapBuilder;
+
+    private Builder(int size) {
+      // TODO(user): consider which way to initialize mapBuilder is better
+      this.mapBuilder = newLinkedHashMapWithExpectedSize(size);
+    }
+
+    /**
+     * Returns a new {@link MapProviderFactory}
+     */
+    public MapProviderFactory<K, V> build() {
+      return new MapProviderFactory<K, V>(this.mapBuilder);
+    }
+
+    /**
+     * Associate k with providerOfValue in {@code Builder}
+     */
+    public Builder<K, V> put(K key, Provider<V> providerOfValue) {
+      if (key == null) {
+        throw new NullPointerException("The key is null");
+      }
+      if (providerOfValue == null) {
+        throw new NullPointerException("The provider of the value is null");
+      }
+
+      this.mapBuilder.put(key, providerOfValue);
+      return this;
+    }
+
+    private static <K, V> LinkedHashMap<K, Provider<V>> newLinkedHashMapWithExpectedSize(
+        int expectedSize) {
+      if (expectedSize < 0) {
+        throw new IllegalArgumentException("The expected size of map cannot be negative.");
+      }
+      int initialCapacity = (expectedSize < 3) ? expectedSize + 1
+          : (expectedSize < (1 << (Integer.SIZE - 2))) ? expectedSize + expectedSize / 3
+              : Integer.MAX_VALUE;
+      return new LinkedHashMap<K, Provider<V>>(initialCapacity);
+    }
+  }
+}
diff --git a/core/src/main/java/dagger/internal/MembersInjectors.java b/core/src/main/java/dagger/internal/MembersInjectors.java
new file mode 100644
index 000000000..1b9bc105f
--- /dev/null
+++ b/core/src/main/java/dagger/internal/MembersInjectors.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2014 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import dagger.MembersInjector;
+
+import javax.inject.Inject;
+
+/**
+ * Basic {@link MembersInjector} implementations used by the framework.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+public final class MembersInjectors {
+  /**
+   * Returns a {@link MembersInjector} implementation that injects no members
+   *
+   * <p>Note that there is no verification that the type being injected does not have {@link Inject}
+   * members, so care should be taken to ensure appropriate use.
+   */
+  @SuppressWarnings("unchecked")
+  public static <T> MembersInjector<T> noOp() {
+    return (MembersInjector<T>) NoOpMembersInjector.INSTANCE;
+  }
+
+  private static enum NoOpMembersInjector implements MembersInjector<Object> {
+    INSTANCE;
+
+    @Override public void injectMembers(Object instance) {
+      if (instance == null) {
+        throw new NullPointerException();
+      }
+    }
+  }
+
+  /**
+   * Returns a {@link MembersInjector} that delegates to the {@link MembersInjector} of its
+   * supertype.  This is useful for cases where a type is known not to have its own {@link Inject}
+   * members, but must still inject members on its supertype(s).
+   *
+   * <p>Note that there is no verification that the type being injected does not have {@link Inject}
+   * members, so care should be taken to ensure appropriate use.
+   */
+  @SuppressWarnings("unchecked")
+  public static <T> MembersInjector<T> delegatingTo(MembersInjector<? super T> delegate) {
+    return (MembersInjector<T>) delegate;
+  }
+
+  private MembersInjectors() {}
+}
diff --git a/core/src/main/java/dagger/internal/Memoizer.java b/core/src/main/java/dagger/internal/Memoizer.java
new file mode 100644
index 000000000..5b36208d8
--- /dev/null
+++ b/core/src/main/java/dagger/internal/Memoizer.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+/**
+ * An abstract supertype that provides
+ * <a href="http://en.wikipedia.org/wiki/Memoize">memoization</a> for idempotent operations that
+ * <i>may</i> be computed more than once, but for which performance is prohibitive. Subclasses
+ * implement the {@link #create} method with the operation to be memoized, while callers invoke the
+ * {@link #get} method to utilize the memoization.
+ *
+ * <p>Synchronization on this class is implemented using a {@link ReadWriteLock}. Multiple threads
+ * may accessed previously memoized results without contention.
+ *
+ * <p>This class is implemented such that concurrent requests for the same key may result in
+ * simultaneous computation in multiple threads - the instance of the result that is persisted for
+ * subsequent invocations in not guaranteed.
+ *
+ * <p><b>Warning:</b> there is no eviction. Large input sets will result in growth without bound.
+ */
+abstract class Memoizer<K, V> {
+  private final Map<K, V> map;
+  private final Lock readLock;
+  private final Lock writeLock;
+
+  Memoizer() {
+    // Don't use LinkedHashMap. This is a performance-oriented class and we don't want overhead
+    this.map = new HashMap<K, V>();
+    ReadWriteLock lock = new ReentrantReadWriteLock();
+    this.readLock = lock.readLock();
+    this.writeLock = lock.writeLock();
+  }
+
+  final V get(K key) {
+    if (key == null) {
+      throw new NullPointerException("key == null");
+    }
+
+    // check to see if we already have a value
+    readLock.lock();
+    try {
+      V value = map.get(key);
+      if (value != null) {
+        return value;
+      }
+    } finally {
+      readLock.unlock();
+    }
+
+    // create a new value.  this may race and we might create more than one instance, but that's ok
+    V newValue = create(key);
+    if (newValue == null) {
+      throw new NullPointerException("create returned null");
+    }
+
+    // write the new value and return it
+    writeLock.lock();
+    try {
+      map.put(key, newValue);
+      return newValue;
+    } finally {
+      writeLock.unlock();
+    }
+  }
+
+  abstract V create(K key);
+
+  @Override public final String toString() {
+    readLock.lock();
+    try {
+      return map.toString();
+    } finally {
+      readLock.unlock();
+    }
+  }
+}
diff --git a/core/src/main/java/dagger/internal/ModuleAdapter.java b/core/src/main/java/dagger/internal/ModuleAdapter.java
new file mode 100644
index 000000000..ba7bc7062
--- /dev/null
+++ b/core/src/main/java/dagger/internal/ModuleAdapter.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2012 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+/**
+ * Extracts bindings from an {@code @Module}-annotated class.
+ */
+public abstract class ModuleAdapter<T> {
+  public final Class<T> moduleClass;
+  public final String[] injectableTypes;
+  public final Class<?>[] staticInjections;
+  public final boolean overrides;
+  public final Class<?>[] includes;
+  public final boolean complete;
+  public final boolean library;
+
+  protected ModuleAdapter(Class<T> moduleClass, String[] injectableTypes,
+      Class<?>[] staticInjections, boolean overrides, Class<?>[] includes, boolean complete,
+      boolean library) {
+    this.moduleClass = moduleClass;
+    this.injectableTypes = injectableTypes;
+    this.staticInjections = staticInjections;
+    this.overrides = overrides;
+    this.includes = includes;
+    this.complete = complete;
+    this.library = library;
+  }
+
+  /**
+   * Returns bindings for the {@code @Provides} methods of {@code module}. The
+   * returned bindings must be linked before they can be used to inject values.
+   */
+  @SuppressWarnings("unused")
+  public void getBindings(BindingsGroup map, T module) {
+    // no-op;
+  }
+
+  /**
+   * Returns a new instance of the module class created using a no-args
+   * constructor. Only used when a manually-constructed module is not supplied.
+   */
+  protected T newModule() {
+    throw new UnsupportedOperationException("No no-args constructor on " + getClass().getName());
+  }
+
+  @Override
+  public final boolean equals(Object obj) {
+    if (obj == this) {
+      return true;
+    } else if (obj instanceof ModuleAdapter<?>) {
+      ModuleAdapter<?> that = (ModuleAdapter<?>) obj;
+      return this.moduleClass.equals(that.moduleClass);
+    } else {
+      return false;
+    }
+  }
+
+  @Override
+  public final int hashCode() {
+    return moduleClass.hashCode();
+  }
+}
diff --git a/core/src/main/java/dagger/internal/Modules.java b/core/src/main/java/dagger/internal/Modules.java
new file mode 100644
index 000000000..4f8d3cf7d
--- /dev/null
+++ b/core/src/main/java/dagger/internal/Modules.java
@@ -0,0 +1,103 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2012 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+
+/**
+ * Static helper for organizing modules.
+ */
+public final class Modules {
+
+  private Modules() { }
+
+  /**
+   * Returns a full set of module adapters, including module adapters for included
+   * modules.
+   */
+  public static ArrayList<ModuleWithAdapter> loadModules(Loader loader,
+      Object[] seedModulesOrClasses) {
+    int seedModuleCount = seedModulesOrClasses.length;
+    ArrayList<ModuleWithAdapter> result = new ArrayList<ModuleWithAdapter>(seedModuleCount);
+    HashSet<Class<?>> visitedClasses = new HashSet<Class<?>>(seedModuleCount);
+    // Add all seed classes to visited classes right away, so that we won't instantiate modules for
+    // them in collectIncludedModulesRecursively
+    // Iterate over seedModulesOrClasses in reverse, so that if multiple instances/classes of the
+    // same module are provided, the later one is used (this matches previous behavior which some
+    // code came to depend on.)
+    for (int i = seedModuleCount-1; i >= 0; i--) {
+      Object moduleOrClass = seedModulesOrClasses[i];
+      if (moduleOrClass instanceof Class<?>) {
+        if (visitedClasses.add((Class<?>) moduleOrClass)) {
+          ModuleAdapter<?> moduleAdapter = loader.getModuleAdapter((Class<?>) moduleOrClass);
+          result.add(new ModuleWithAdapter(moduleAdapter, moduleAdapter.newModule()));
+        }
+      } else {
+        if (visitedClasses.add(moduleOrClass.getClass())) {
+          ModuleAdapter<?> moduleAdapter = loader.getModuleAdapter(moduleOrClass.getClass());
+          result.add(new ModuleWithAdapter(moduleAdapter, moduleOrClass));
+        }
+      }
+    }
+    int dedupedSeedModuleCount = result.size();
+    for (int i = 0; i < dedupedSeedModuleCount; i++) {
+      ModuleAdapter<?> seedAdapter = result.get(i).getModuleAdapter();
+      collectIncludedModulesRecursively(loader, seedAdapter, result, visitedClasses);
+    }
+    return result;
+  }
+
+  /**
+   * Wrapper around a module adapter and an instance of the corresponding module.
+   */
+  public static class ModuleWithAdapter {
+    private final ModuleAdapter<?> moduleAdapter;
+    private final Object module;
+
+    ModuleWithAdapter(ModuleAdapter<?> moduleAdapter, Object module) {
+      this.moduleAdapter = moduleAdapter;
+      this.module = module;
+    }
+
+    public ModuleAdapter<?> getModuleAdapter() {
+      return moduleAdapter;
+    }
+
+    public Object getModule() {
+      return module;
+    }
+  }
+
+  /**
+   * Fills {@code result} with the module adapters for the includes of {@code
+   * adapter}, and their includes recursively.
+   */
+  private static void collectIncludedModulesRecursively(Loader plugin, ModuleAdapter<?> adapter,
+      List<ModuleWithAdapter> result, HashSet<Class<?>> visitedClasses) {
+    for (Class<?> include : adapter.includes) {
+      if (!visitedClasses.contains(include)) {
+        ModuleAdapter<?> includedModuleAdapter = plugin.getModuleAdapter(include);
+        result.add(new ModuleWithAdapter(includedModuleAdapter, includedModuleAdapter.newModule()));
+        visitedClasses.add(include);
+        collectIncludedModulesRecursively(plugin, includedModuleAdapter, result, visitedClasses);
+      }
+    }
+  }
+
+}
diff --git a/core/src/main/java/dagger/internal/ProblemDetector.java b/core/src/main/java/dagger/internal/ProblemDetector.java
new file mode 100644
index 000000000..8df091558
--- /dev/null
+++ b/core/src/main/java/dagger/internal/ProblemDetector.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import java.util.AbstractSet;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+
+/**
+ * Detects problems like cyclic dependencies.
+ */
+public final class ProblemDetector {
+  public void detectCircularDependencies(Collection<Binding<?>> bindings) {
+    detectCircularDependencies(bindings, new ArrayList<Binding<?>>());
+  }
+
+  public void detectUnusedBinding(Collection<Binding<?>> bindings) {
+    List<Binding> unusedBindings = new ArrayList<Binding>();
+    for (Binding<?> binding : bindings) {
+      if (!binding.library() && !binding.dependedOn()) {
+        unusedBindings.add(binding);
+      }
+    }
+    if (!unusedBindings.isEmpty()) {
+      StringBuilder builder = new StringBuilder();
+      builder.append("You have these unused @Provider methods:");
+      for (int i = 0; i < unusedBindings.size(); i++) {
+        builder.append("\n    ").append(i + 1).append(". ")
+            .append(unusedBindings.get(i).requiredBy);
+      }
+      builder.append("\n    Set library=true in your module to disable this check.");
+      throw new IllegalStateException(builder.toString());
+    }
+  }
+
+  private static void detectCircularDependencies(Collection<Binding<?>> bindings,
+      List<Binding<?>> path) {
+    for (Binding<?> binding : bindings) {
+      if (binding.isCycleFree()) {
+        continue;
+      }
+
+      if (binding.isVisiting()) {
+        int index = path.indexOf(binding);
+        StringBuilder message = new StringBuilder()
+            .append("Dependency cycle:");
+        for (int i = index; i < path.size(); i++) {
+          message.append("\n    ").append(i - index).append(". ")
+              .append(path.get(i).provideKey).append(" bound by ").append(path.get(i));
+        }
+        message.append("\n    ").append(0).append(". ").append(binding.provideKey);
+        throw new IllegalStateException(message.toString());
+      }
+
+      binding.setVisiting(true);
+      path.add(binding);
+      try {
+        ArraySet<Binding<?>> dependencies = new ArraySet<Binding<?>>();
+        binding.getDependencies(dependencies, dependencies);
+        detectCircularDependencies(dependencies, path);
+        binding.setCycleFree(true);
+      } finally {
+        path.remove(path.size() - 1);
+        binding.setVisiting(false);
+      }
+    }
+  }
+
+  public void detectProblems(Collection<Binding<?>> values) {
+    detectCircularDependencies(values);
+    detectUnusedBinding(values);
+  }
+
+  static class ArraySet<T> extends AbstractSet<T> {
+    private final ArrayList<T> list = new ArrayList<T>();
+
+    @Override public boolean add(T t) {
+      list.add(t);
+      return true;
+    }
+
+    @Override public Iterator<T> iterator() {
+      return list.iterator();
+    }
+
+    @Override public int size() {
+      throw new UnsupportedOperationException();
+    }
+  }
+}
diff --git a/core/src/main/java/dagger/internal/ProvidesBinding.java b/core/src/main/java/dagger/internal/ProvidesBinding.java
new file mode 100644
index 000000000..43b3ac2c6
--- /dev/null
+++ b/core/src/main/java/dagger/internal/ProvidesBinding.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2013 Google, Inc.
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+/**
+ * A {@code Binding<T>} which delegates to a module method.
+ */
+public abstract class ProvidesBinding<T> extends Binding<T> {
+  protected final String moduleClass;
+
+  protected final String methodName;
+
+  /**
+   * Creates a new {@code ProvidesBinding} with the given "provides" key, a flag as to whether
+   * this binding should be scoped, and the requiredBy object for traceability.
+   */
+  public ProvidesBinding(String key, boolean singleton, String moduleClass, String methodName) {
+    // Set requiredBy as fullMethodName to preserve older debugging meaning.
+    // Use an explicitly sized StringBuilder as this code is invoked often
+    super(key, null, singleton,
+        new StringBuilder(moduleClass.length() + methodName.length() + 3)
+            .append(moduleClass).append('.').append(methodName).append("()").toString());
+    this.moduleClass = moduleClass;
+    this.methodName = methodName;
+  }
+
+  /**
+   * A provides binding is responsible for implementing storage of the module instance, and
+   * delegation to that module instance's method.
+   */
+  @Override
+  public abstract T get();
+
+  @Override public String toString() {
+    return getClass().getName() + "[key=" + provideKey
+        + " method=" + moduleClass + "." + methodName + "()" + "]";
+  }
+}
diff --git a/core/src/main/java/dagger/internal/ReflectiveLoader.java b/core/src/main/java/dagger/internal/ReflectiveLoader.java
new file mode 100644
index 000000000..4d20522a0
--- /dev/null
+++ b/core/src/main/java/dagger/internal/ReflectiveLoader.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2013 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import dagger.internal.loaders.ReflectiveAtInjectBinding;
+import dagger.internal.loaders.ReflectiveModuleAdapter;
+import dagger.internal.loaders.ReflectiveStaticInjection;
+
+/**
+ * Handles loading/finding of modules, injection bindings, and static injections by use of a
+ * reflective bindings.
+ *
+ * @deprecated Provided only to work around proguard obfuscation - obsolete in 2.0.
+ */
+@Deprecated
+public final class ReflectiveLoader extends Loader {
+  /**
+   * Obtains a {@link ReflectiveModuleAdapter} for {@code module}.
+   */
+  @SuppressWarnings("unchecked") // cache ensures types match
+  @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<T> type) {
+    return ReflectiveModuleAdapter.create(type);
+  }
+
+  /**
+   * Obtains a {@link ReflectiveAtInjectBinding} for a given key.
+   */
+  @Override public Binding<?> getAtInjectBinding(
+      String key, String className, ClassLoader classLoader, boolean mustHaveInjections) {
+    Class<?> type = loadClass(classLoader, className);
+    if (type.equals(Void.class)) {
+      throw new IllegalStateException(
+          String.format("Could not load class %s needed for binding %s", className, key));
+    }
+    if (type.isInterface()) {
+      return null; // Short-circuit since we can't build reflective bindings for interfaces.
+    }
+    return ReflectiveAtInjectBinding.createFactory(type).create(mustHaveInjections);
+  }
+
+  @Override public StaticInjection getStaticInjection(Class<?> injectedClass) {
+    return ReflectiveStaticInjection.create(injectedClass);
+  }
+}
diff --git a/core/src/main/java/dagger/internal/ScopedProvider.java b/core/src/main/java/dagger/internal/ScopedProvider.java
new file mode 100644
index 000000000..90a679a90
--- /dev/null
+++ b/core/src/main/java/dagger/internal/ScopedProvider.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import dagger.Factory;
+import javax.inject.Provider;
+
+/**
+ * A {@link Provider} implementation that memoizes the result of a {@link Factory} instance.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+public final class ScopedProvider<T> implements Provider<T> {
+  private static final Object UNINITIALIZED = new Object();
+
+  private final Factory<T> factory;
+  private volatile Object instance = UNINITIALIZED;
+
+  private ScopedProvider(Factory<T> factory) {
+    assert factory != null;
+    this.factory = factory;
+  }
+
+  @SuppressWarnings("unchecked") // cast only happens when result comes from the factory
+  @Override
+  public T get() {
+    // double-check idiom from EJ2: Item 71
+    Object result = instance;
+    if (result == UNINITIALIZED) {
+      synchronized (this) {
+        result = instance;
+        if (result == UNINITIALIZED) {
+          instance = result = factory.get();
+        }
+      }
+    }
+    return (T) result;
+  }
+
+  /** Returns a new scoped provider for the given factory. */
+  public static <T> Provider<T> create(Factory<T> factory) {
+    if (factory == null) {
+      throw new NullPointerException();
+    }
+    return new ScopedProvider<T>(factory);
+  }
+}
diff --git a/core/src/main/java/dagger/internal/SetBinding.java b/core/src/main/java/dagger/internal/SetBinding.java
new file mode 100644
index 000000000..af3729061
--- /dev/null
+++ b/core/src/main/java/dagger/internal/SetBinding.java
@@ -0,0 +1,145 @@
+/*
+ * Copyright (C) 2012 Google, Inc.
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Set;
+
+/**
+ * A {@code Binding<T>} which contains contributors (other bindings marked with
+ * {@code @Provides} {@code @OneOf}), to which it delegates provision
+ * requests on an as-needed basis.
+ */
+public final class SetBinding<T> extends Binding<Set<T>> {
+
+  public static <T> void add(BindingsGroup bindings, String setKey, Binding<?> binding) {
+    prepareSetBinding(bindings, setKey, binding).contributors.add(Linker.scope(binding));
+  }
+
+  @SuppressWarnings("unchecked")
+  private static <T> SetBinding<T> prepareSetBinding(
+      BindingsGroup bindings, String setKey, Binding<?> binding) {
+    Binding<?> previous = bindings.get(setKey);
+    SetBinding<T> setBinding;
+    if (previous instanceof SetBinding) {
+      setBinding = (SetBinding<T>) previous;
+      setBinding.setLibrary(setBinding.library() && binding.library());
+      return setBinding;
+    } else if (previous != null) {
+      throw new IllegalArgumentException("Duplicate:\n    " + previous + "\n    " + binding);
+    } else {
+      setBinding = new SetBinding<T>(setKey, binding.requiredBy);
+      setBinding.setLibrary(binding.library());
+      bindings.contributeSetBinding(setKey, setBinding);
+      return (SetBinding<T>) bindings.get(setKey); // BindingMap.put() copies SetBindings.
+    }
+  }
+
+  /**
+   * A {@link SetBinding} with whose contributing bindings this set-binding provides a union
+   * view.
+   */
+  private final SetBinding<T> parent;
+
+  /**
+   * A {@link Set} of {@link Binding} instances which contribute values to the injected set.
+   */
+  private final List<Binding<?>> contributors;
+
+  /**
+   * Creates a new {@code SetBinding} with the given "provides" key, and the requiredBy object
+   * for traceability.
+   */
+  public SetBinding(String key, Object requiredBy) {
+    super(key, null, false, requiredBy);
+    parent = null;
+    contributors = new ArrayList<Binding<?>>();
+  }
+
+  /**
+   * Creates a new {@code SetBinding} with all of the contributing bindings of the provided
+   * original {@code SetBinding}.
+   */
+  public SetBinding(SetBinding<T> original) {
+    super(original.provideKey, null, false, original.requiredBy);
+    parent = original;
+    this.setLibrary(original.library());
+    this.setDependedOn(original.dependedOn());
+    contributors = new ArrayList<Binding<?>>();
+  }
+
+  @Override public void attach(Linker linker) {
+    for (Binding<?> contributor : contributors) {
+      contributor.attach(linker);
+    }
+  }
+
+  public int size() {
+    int size = 0;
+    for (SetBinding<T> binding = this; binding != null; binding = binding.parent) {
+      size += binding.contributors.size();
+    }
+    return size;
+  }
+
+  @SuppressWarnings("unchecked") // Only Binding<T> and Set<T> are added to contributors.
+  @Override public Set<T> get() {
+    List<T> result = new ArrayList<T>();
+    for (SetBinding<T> setBinding = this; setBinding != null; setBinding = setBinding.parent) {
+      for (int i = 0, size = setBinding.contributors.size(); i < size; i++) {
+        Binding<?> contributor = setBinding.contributors.get(i);
+        Object contribution = contributor.get(); // Let runtime exceptions through.
+        if (contributor.provideKey.equals(provideKey)) {
+          result.addAll((Set<T>) contribution);
+        } else {
+          result.add((T) contribution);
+        }
+      }
+    }
+    return Collections.unmodifiableSet(new LinkedHashSet<T>(result));
+  }
+
+  @Override public void getDependencies(
+      Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {
+    for (SetBinding<T> binding = this; binding != null; binding = binding.parent) {
+      getBindings.addAll(binding.contributors);
+    }
+  }
+
+  @Override public void injectMembers(Set<T> t) {
+    throw new UnsupportedOperationException("Cannot inject members on a contributed Set<T>.");
+  }
+
+  @Override public String toString() {
+    boolean first = true;
+    StringBuilder builder = new StringBuilder("SetBinding[");
+    for (SetBinding<T> setBinding = this; setBinding != null; setBinding = setBinding.parent) {
+      for (int i = 0, size = setBinding.contributors.size(); i < size; i++) {
+        if (!first) {
+          builder.append(",");
+        }
+        builder.append(setBinding.contributors.get(i));
+        first = false;
+      }
+    }
+    builder.append("]");
+    return builder.toString();
+  }
+}
diff --git a/core/src/main/java/dagger/internal/SetFactory.java b/core/src/main/java/dagger/internal/SetFactory.java
new file mode 100644
index 000000000..42c2bd6a4
--- /dev/null
+++ b/core/src/main/java/dagger/internal/SetFactory.java
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import dagger.Factory;
+import java.util.ArrayList;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Set;
+import javax.inject.Provider;
+
+import static java.util.Collections.unmodifiableSet;
+
+/**
+ * A {@link Factory} implementation used to implement {@link Set} bindings. This factory always
+ * returns a new {@link Set} instance for each call to {@link #get} (as required by {@link Factory})
+ * whose elements are populated by subsequent calls to their {@link Provider#get} methods.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+public final class SetFactory<T> implements Factory<Set<T>> {
+  /**
+   * Returns a new factory that creates {@link Set} instances that from the union of the given
+   * {@link Provider} instances.
+   */
+  public static <T> Factory<Set<T>> create(Provider<Set<T>> first,
+      @SuppressWarnings("unchecked") Provider<Set<T>>... rest) {
+    if (first == null) {
+      throw new NullPointerException();
+    }
+    if (rest == null) {
+      throw new NullPointerException();
+    }
+    Set<Provider<Set<T>>> contributingProviders = newLinkedHashSetWithExpectedSize(1 + rest.length);
+    contributingProviders.add(first);
+    for (Provider<Set<T>> provider : rest) {
+      if (provider == null) {
+        throw new NullPointerException();
+      }
+      contributingProviders.add(provider);
+    }
+    return new SetFactory<T>(contributingProviders);
+  }
+
+  private final Set<Provider<Set<T>>> contributingProviders;
+
+  private SetFactory(Set<Provider<Set<T>>> contributingProviders) {
+    this.contributingProviders = contributingProviders;
+  }
+
+  /**
+   * Returns a {@link Set} whose iteration order is that of the elements given by each of the
+   * providers, which are invoked in the order given at creation.
+   *
+   * @throws NullPointerException if any of the delegate {@link Set} instances or elements therein
+   *     are {@code null}
+   */
+  @Override
+  public Set<T> get() {
+    List<Set<T>> providedSets = new ArrayList<Set<T>>(contributingProviders.size());
+    for (Provider<Set<T>> provider : contributingProviders) {
+      Set<T> providedSet = provider.get();
+      if (providedSet == null) {
+        throw new NullPointerException(provider + " returned null");
+      }
+      providedSets.add(providedSet);
+    }
+    int size = 0;
+    for (Set<T> providedSet : providedSets) {
+      size += providedSet.size();
+    }
+    Set<T> result = newLinkedHashSetWithExpectedSize(size);
+    for (Set<T> s : providedSets) {
+      for (T element : s) {
+        if (element == null) {
+          throw new NullPointerException("a null element was provided");
+        }
+        result.add(element);
+      }
+    }
+    return unmodifiableSet(result);
+  }
+
+  // TODO(gak): consider whether (expectedSize, 1.0f) is better for this use case since callers are
+  // typically only going to iterate
+  private static <E> LinkedHashSet<E> newLinkedHashSetWithExpectedSize(int expectedSize) {
+    int initialCapacity = (expectedSize < 3)
+        ? expectedSize + 1
+        : (expectedSize < (1 << (Integer.SIZE - 2)))
+            ? expectedSize + expectedSize / 3
+            : Integer.MAX_VALUE;
+    return new LinkedHashSet<E>(initialCapacity);
+  }
+}
diff --git a/core/src/main/java/dagger/internal/StaticInjection.java b/core/src/main/java/dagger/internal/StaticInjection.java
new file mode 100644
index 000000000..d9399a37a
--- /dev/null
+++ b/core/src/main/java/dagger/internal/StaticInjection.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2012 Square Inc.
+ * Copyright (C) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+/**
+ * Injects the static fields of a class.
+ */
+public abstract class StaticInjection {
+
+  public abstract void attach(Linker linker);
+
+  public abstract void inject();
+
+}
diff --git a/core/src/main/java/dagger/internal/ThrowingErrorHandler.java b/core/src/main/java/dagger/internal/ThrowingErrorHandler.java
new file mode 100644
index 000000000..d17ae7a92
--- /dev/null
+++ b/core/src/main/java/dagger/internal/ThrowingErrorHandler.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import java.util.List;
+
+/**
+ * Handles errors by throwing an exception containing all the available errors.
+ */
+public final class ThrowingErrorHandler implements Linker.ErrorHandler {
+
+  @Override public void handleErrors(List<String> errors) {
+    if (errors.isEmpty()) {
+      return;
+    }
+    StringBuilder message = new StringBuilder();
+    message.append("Errors creating object graph:");
+    for (String error : errors) {
+      message.append("\n  ").append(error);
+    }
+    throw new IllegalStateException(message.toString());
+  }
+}
diff --git a/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java b/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java
new file mode 100644
index 000000000..3c126898b
--- /dev/null
+++ b/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2013 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.loaders;
+
+/**
+ * A single point for API used in common by Adapters and Adapter generators
+ */
+public final class GeneratedAdapters {
+  private static final String SEPARATOR = "$$";
+  public static final String INJECT_ADAPTER_SUFFIX = SEPARATOR + "InjectAdapter";
+  public static final String MODULE_ADAPTER_SUFFIX = SEPARATOR + "ModuleAdapter";
+  public static final String STATIC_INJECTION_SUFFIX = SEPARATOR + "StaticInjection";
+
+  private GeneratedAdapters() { }
+}
diff --git a/core/src/main/java/dagger/internal/loaders/ReflectiveAtInjectBinding.java b/core/src/main/java/dagger/internal/loaders/ReflectiveAtInjectBinding.java
new file mode 100644
index 000000000..d464ec50e
--- /dev/null
+++ b/core/src/main/java/dagger/internal/loaders/ReflectiveAtInjectBinding.java
@@ -0,0 +1,270 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.loaders;
+
+import dagger.internal.Binding;
+import dagger.internal.Keys;
+import dagger.internal.Linker;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Modifier;
+import java.lang.reflect.Type;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
+import javax.inject.Inject;
+import javax.inject.Singleton;
+
+/**
+ * Injects the {@code @Inject}-annotated fields and constructors of a class
+ * using reflection.
+ */
+public final class ReflectiveAtInjectBinding<T> extends Binding<T> {
+  private final Field[] fields;
+  private final ClassLoader loader;
+  private final Constructor<T> constructor;
+  private final Class<?> supertype;
+  private final String[] keys;
+  private final Binding<?>[] fieldBindings;
+  private final Binding<?>[] parameterBindings;
+  private Binding<? super T> supertypeBinding;
+
+  /**
+   * @param keys keys for the fields, constructor parameters and supertype in
+   *     that order. These are precomputed to minimize reflection when {@code
+   *     attach} is called multiple times.
+   * @param constructor the injectable constructor, or null if this binding
+   *     supports members injection only.
+   * @param supertype the injectable supertype, or null if the supertype is a
+   */
+  private ReflectiveAtInjectBinding(String provideKey, String membersKey, boolean singleton,
+      Class<?> type, Field[] fields, Constructor<T> constructor, int parameterCount,
+      Class<?> supertype, String[] keys) {
+    super(provideKey, membersKey, singleton, type);
+    this.constructor = constructor;
+    this.fields = fields;
+    this.supertype = supertype;
+    this.keys = keys;
+    this.parameterBindings = new Binding<?>[parameterCount];
+    this.fieldBindings = new Binding<?>[fields.length];
+    this.loader = type.getClassLoader();
+  }
+
+  @SuppressWarnings("unchecked") // We're careful to make keys and bindings match up.
+  @Override public void attach(Linker linker) {
+    int k = 0;
+    for (int i = 0; i < fields.length; i++) {
+      if (fieldBindings[i] == null) {
+        fieldBindings[i] = linker.requestBinding(keys[k], fields[i], loader);
+      }
+      k++;
+    }
+    if (constructor != null) {
+      for (int i = 0; i < parameterBindings.length; i++) {
+        if (parameterBindings[i] == null) {
+          parameterBindings[i] = linker.requestBinding(keys[k], constructor, loader);
+        }
+        k++;
+      }
+    }
+    if (supertype != null && supertypeBinding == null) {
+      supertypeBinding =
+          (Binding<? super T>) linker.requestBinding(keys[k], membersKey, loader, false, true);
+    }
+  }
+
+  @Override public T get() {
+    if (constructor == null) {
+      throw new UnsupportedOperationException();
+    }
+    Object[] args = new Object[parameterBindings.length];
+    for (int i = 0; i < parameterBindings.length; i++) {
+      args[i] = parameterBindings[i].get();
+    }
+    T result;
+    try {
+      result = constructor.newInstance(args);
+    } catch (InvocationTargetException e) {
+      Throwable cause = e.getCause();
+      throw cause instanceof RuntimeException
+          ? (RuntimeException) cause
+          : new RuntimeException(cause);
+    } catch (IllegalAccessException e) {
+      throw new AssertionError(e);
+    } catch (InstantiationException e) {
+      throw new RuntimeException(e);
+    }
+    injectMembers(result);
+    return result;
+  }
+
+  @Override public void injectMembers(T t) {
+    try {
+      for (int i = 0; i < fields.length; i++) {
+        fields[i].set(t, fieldBindings[i].get());
+      }
+      if (supertypeBinding != null) {
+        supertypeBinding.injectMembers(t);
+      }
+    } catch (IllegalAccessException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
+    if (parameterBindings != null) {
+      Collections.addAll(get, parameterBindings);
+    }
+    Collections.addAll(injectMembers, fieldBindings);
+    if (supertypeBinding != null) {
+      injectMembers.add(supertypeBinding);
+    }
+  }
+
+  @Override public String toString() {
+    return provideKey != null ? provideKey : membersKey;
+  }
+
+  /**
+   * A factory for creating {@code ReflectiveAtInjectBinding<T>}.
+   */
+  public static class Factory<T> {
+    private final String provideKey;
+    private final String membersKey;
+    private final boolean singleton;
+    private final Class<?> type;
+    private final Field[] fields;
+    private final Constructor<T> constructor;
+    private final int parameterCount;
+    private final Class<?> supertype;
+    private final String[] keys;
+
+    private Factory(String provideKey, String membersKey, boolean singleton,
+        Class<?> type, Field[] fields, Constructor<T> constructor, int parameterCount,
+        Class<?> supertype, String[] keys) {
+      this.provideKey = provideKey;
+      this.membersKey = membersKey;
+      this.singleton = singleton;
+      this.type = type;
+      this.fields = fields;
+      this.constructor = constructor;
+      this.parameterCount = parameterCount;
+      this.supertype = supertype;
+      this.keys = keys;
+    }
+
+    public ReflectiveAtInjectBinding<T> create(boolean mustHaveInjections) {
+      if (mustHaveInjections && constructor == null && fields.length == 0) {
+        throw new InvalidBindingException(type.getName(),
+            "has no injectable members. Do you want to add an injectable constructor?");
+      }
+      return new ReflectiveAtInjectBinding<T>(provideKey, membersKey, singleton,
+          type, fields, constructor, parameterCount,
+          supertype, keys);
+    }
+  }
+
+  public static <T> Factory<T> createFactory(Class<T> type) {
+    boolean singleton = type.isAnnotationPresent(Singleton.class);
+    List<String> keys = new ArrayList<String>();
+
+    // Lookup the injectable fields and their corresponding keys.
+    List<Field> injectedFields = new ArrayList<Field>();
+    for (Class<?> c = type; c != Object.class; c = c.getSuperclass()) {
+      for (Field field : c.getDeclaredFields()) {
+        if (!field.isAnnotationPresent(Inject.class) || Modifier.isStatic(field.getModifiers())) {
+          continue;
+        }
+        if ((field.getModifiers() & Modifier.PRIVATE) != 0) {
+          throw new IllegalStateException("Can't inject private field: " + field);
+        }
+        field.setAccessible(true);
+        injectedFields.add(field);
+        keys.add(Keys.get(field.getGenericType(), field.getAnnotations(), field));
+      }
+    }
+
+    // Look up @Inject-annotated constructors. If there's no @Inject-annotated
+    // constructor, use a default public constructor if the class has other
+    // injections. Otherwise treat the class as non-injectable.
+    Constructor<T> injectedConstructor = null;
+    for (Constructor<T> constructor : getConstructorsForType(type)) {
+      if (!constructor.isAnnotationPresent(Inject.class)) {
+        continue;
+      }
+      if (injectedConstructor != null) {
+        throw new InvalidBindingException(type.getName(), "has too many injectable constructors");
+      }
+      injectedConstructor = constructor;
+    }
+    if (injectedConstructor == null) {
+      if (!injectedFields.isEmpty()) {
+        try {
+          injectedConstructor = type.getDeclaredConstructor();
+        } catch (NoSuchMethodException ignored) {
+        }
+      }
+    }
+
+    int parameterCount;
+    String provideKey;
+    if (injectedConstructor != null) {
+      if ((injectedConstructor.getModifiers() & Modifier.PRIVATE) != 0) {
+        throw new IllegalStateException("Can't inject private constructor: " + injectedConstructor);
+      }
+
+      provideKey = Keys.get(type);
+      injectedConstructor.setAccessible(true);
+      Type[] types = injectedConstructor.getGenericParameterTypes();
+      parameterCount = types.length;
+      if (parameterCount != 0) {
+        Annotation[][] annotations = injectedConstructor.getParameterAnnotations();
+        for (int p = 0; p < types.length; p++) {
+          keys.add(Keys.get(types[p], annotations[p], injectedConstructor));
+        }
+      }
+    } else {
+      provideKey = null;
+      parameterCount = 0;
+      if (singleton) {
+        throw new IllegalArgumentException(
+            "No injectable constructor on @Singleton " + type.getName());
+      }
+    }
+
+    Class<? super T> supertype = type.getSuperclass();
+    if (supertype != null) {
+      if (Keys.isPlatformType(supertype.getName())) {
+        supertype = null;
+      } else {
+        keys.add(Keys.getMembersKey(supertype));
+      }
+    }
+
+    String membersKey = Keys.getMembersKey(type);
+    return new Factory<T>(provideKey, membersKey, singleton, type,
+        injectedFields.toArray(new Field[injectedFields.size()]), injectedConstructor,
+        parameterCount, supertype, keys.toArray(new String[keys.size()]));
+  }
+
+  @SuppressWarnings("unchecked") // Class.getDeclaredConstructors is an unsafe API.
+  private static <T> Constructor<T>[] getConstructorsForType(Class<T> type) {
+    return (Constructor<T>[]) type.getDeclaredConstructors();
+  }
+}
diff --git a/core/src/main/java/dagger/internal/loaders/ReflectiveModuleAdapter.java b/core/src/main/java/dagger/internal/loaders/ReflectiveModuleAdapter.java
new file mode 100644
index 000000000..a37ebb791
--- /dev/null
+++ b/core/src/main/java/dagger/internal/loaders/ReflectiveModuleAdapter.java
@@ -0,0 +1,216 @@
+package dagger.internal.loaders;
+
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import dagger.Lazy;
+import dagger.Module;
+import dagger.Provides;
+import dagger.internal.Binding;
+import dagger.internal.BindingsGroup;
+import dagger.internal.Keys;
+import dagger.internal.Linker;
+import dagger.internal.ModuleAdapter;
+import dagger.internal.ProvidesBinding;
+import dagger.internal.SetBinding;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.Set;
+import javax.inject.Provider;
+import javax.inject.Singleton;
+
+/**
+ * @deprecated this is in place to temporarily support obfuscation needs and
+ *     will not exist as of Dagger 2.0
+ */
+@Deprecated
+public class ReflectiveModuleAdapter<M> extends ModuleAdapter<M> {
+  public ReflectiveModuleAdapter(Class<M> moduleClass, Module annotation) {
+    super(
+        moduleClass,
+        injectableTypesToKeys(annotation.injects()),
+        annotation.staticInjections(),
+        annotation.overrides(),
+        annotation.includes(),
+        annotation.complete(),
+        annotation.library());
+  }
+
+  private static String[] injectableTypesToKeys(Class<?>[] injectableTypes) {
+    String[] result = new String[injectableTypes.length];
+    for (int i = 0; i < injectableTypes.length; i++) {
+      Class<?> injectableType = injectableTypes[i];
+      result[i] = injectableType.isInterface()
+          ? Keys.get(injectableType)
+          : Keys.getMembersKey(injectableType);
+    }
+    return result;
+  }
+
+  @Override public void getBindings(BindingsGroup bindings, M module) {
+    for (Class<?> c = moduleClass; !c.equals(Object.class); c = c.getSuperclass()) {
+      for (Method method : c.getDeclaredMethods()) {
+        Provides provides = method.getAnnotation(Provides.class);
+        if (provides != null) {
+          Type genericReturnType = method.getGenericReturnType();
+
+          Type typeToCheck = genericReturnType;
+          if (genericReturnType instanceof ParameterizedType) {
+            typeToCheck = ((ParameterizedType) genericReturnType).getRawType();
+          }
+          if (Provider.class.equals(typeToCheck)) {
+            throw new IllegalStateException("@Provides method must not return Provider directly: "
+                + c.getName()
+                + "."
+                + method.getName());
+          }
+          if (Lazy.class.equals(typeToCheck)) {
+            throw new IllegalStateException("@Provides method must not return Lazy directly: "
+                + c.getName()
+                + "."
+                + method.getName());
+          }
+
+          String key = Keys.get(genericReturnType, method.getAnnotations(), method);
+          switch (provides.type()) {
+            case UNIQUE:
+              handleBindings(bindings, module, method, key, library);
+              break;
+            case SET:
+              String setKey = Keys.getSetKey(method.getGenericReturnType(),
+                  method.getAnnotations(), method);
+              handleSetBindings(bindings, module, method, setKey, key, library);
+              break;
+            case SET_VALUES:
+              handleSetBindings(bindings, module, method, key, key, library);
+              break;
+            default:
+              throw new AssertionError("Unknown @Provides type " + provides.type());
+          }
+        }
+      }
+    }
+  }
+
+  private void handleBindings(BindingsGroup bindings, M module, Method method, String key,
+      boolean library) {
+    bindings.contributeProvidesBinding(key,
+        new ReflectiveProvidesBinding<M>(method, key, moduleClass.getName(), module, library));
+  }
+
+  private void handleSetBindings(BindingsGroup bindings, M module, Method method,
+      String setKey, String providerKey, boolean library) {
+    SetBinding.<M>add(bindings, setKey,
+        new ReflectiveProvidesBinding<M>(
+            method, providerKey, moduleClass.getName(), module, library));
+  }
+
+  @Override public M newModule() {
+    try {
+      Constructor<?> constructor = moduleClass.getDeclaredConstructor();
+      constructor.setAccessible(true);
+      return (M)constructor.newInstance();
+    } catch (InvocationTargetException e) {
+      throw new IllegalArgumentException(e.getCause());
+    } catch (NoSuchMethodException e) {
+      throw new IllegalArgumentException("Could not construct " + moduleClass.getName()
+          + " as it lacks an accessible no-args constructor. This module must be passed"
+          + " in as an instance, or an accessible no-args constructor must be added.", e);
+    } catch (InstantiationException e) {
+      throw new IllegalArgumentException("Failed to construct " + moduleClass.getName(), e);
+    } catch (IllegalAccessException e) {
+      throw new AssertionError();
+    }
+  }
+
+  @Override public String toString() {
+    return "ReflectiveModuleAdapter[" + this.moduleClass.getName() + "]";
+  }
+
+  /**
+   * Creates a ReflectiveModuleAdapter or throws an {@code IllegalArgumentException}.
+   */
+  public static <M> ModuleAdapter<M> create(Class<M> moduleClass) {
+    Module annotation = moduleClass.getAnnotation(Module.class);
+    if (annotation == null) {
+      throw new IllegalArgumentException("No @Module on " + moduleClass.getName());
+    }
+    if (!moduleClass.getSuperclass().equals(Object.class)) {
+      throw new IllegalArgumentException(
+          "Modules must not extend from other classes: " + moduleClass.getName());
+    }
+    return new ReflectiveModuleAdapter<M>(moduleClass, annotation);
+  }
+
+  /**
+   * Invokes a method to provide a value. The method's parameters are injected.
+   */
+  private static final class ReflectiveProvidesBinding<T> extends ProvidesBinding<T> {
+    private Binding<?>[] parameters;
+    private final Method method;
+    private final Object instance;
+
+    public ReflectiveProvidesBinding(Method method, String key, String moduleClass,
+        Object instance, boolean library) {
+      super(key, method.isAnnotationPresent(Singleton.class), moduleClass, method.getName());
+      this.method = method;
+      this.instance = instance;
+      method.setAccessible(true);
+      setLibrary(library);
+    }
+
+    @Override public void attach(Linker linker) {
+      Type[] types = method.getGenericParameterTypes();
+      Annotation[][] annotations = method.getParameterAnnotations();
+      parameters = new Binding[types.length];
+      for (int i = 0; i < parameters.length; i++) {
+        String key = Keys.get(types[i], annotations[i], method + " parameter " + i);
+        parameters[i] = linker.requestBinding(key, method, instance.getClass().getClassLoader());
+      }
+    }
+
+    @Override public T get() {
+      Object[] args = new Object[parameters.length];
+      for (int i = 0; i < parameters.length; i++) {
+        args[i] = parameters[i].get();
+      }
+      try {
+        return (T) method.invoke(instance, args);
+      } catch (InvocationTargetException e) {
+        Throwable cause = e.getCause();
+        throw cause instanceof RuntimeException
+            ? (RuntimeException) cause
+            : new RuntimeException(cause);
+      } catch (IllegalAccessException e) {
+        throw new RuntimeException(e);
+      }
+    }
+
+    @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
+      for (Binding<?> binding : parameters) {
+        get.add(binding);
+      }
+    }
+
+    @Override public void injectMembers(T t) {
+      throw new AssertionError("Provides method bindings are not MembersInjectors");
+    }
+  }
+}
diff --git a/core/src/main/java/dagger/internal/loaders/ReflectiveStaticInjection.java b/core/src/main/java/dagger/internal/loaders/ReflectiveStaticInjection.java
new file mode 100644
index 000000000..1150eed5d
--- /dev/null
+++ b/core/src/main/java/dagger/internal/loaders/ReflectiveStaticInjection.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.loaders;
+
+import dagger.internal.Binding;
+import dagger.internal.Keys;
+import dagger.internal.Linker;
+import dagger.internal.StaticInjection;
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+import java.util.ArrayList;
+import java.util.List;
+import javax.inject.Inject;
+
+/**
+ * Uses reflection to inject the static fields of a class.
+ */
+public final class ReflectiveStaticInjection extends StaticInjection {
+  private final ClassLoader loader;
+  private final Field[] fields;
+  private Binding<?>[] bindings;
+
+  private ReflectiveStaticInjection(ClassLoader loader, Field[] fields) {
+    this.fields = fields;
+    this.loader = loader;
+  }
+
+  @Override public void attach(Linker linker) {
+    bindings = new Binding<?>[fields.length];
+    for (int i = 0; i < fields.length; i++) {
+      Field field = fields[i];
+      String key = Keys.get(field.getGenericType(), field.getAnnotations(), field);
+      bindings[i] = linker.requestBinding(key, field, loader);
+    }
+  }
+
+  @Override public void inject() {
+    try {
+      for (int f = 0; f < fields.length; f++) {
+        fields[f].set(null, bindings[f].get());
+      }
+    } catch (IllegalAccessException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  public static StaticInjection create(Class<?> injectedClass) {
+    List<Field> fields = new ArrayList<Field>();
+    for (Field field : injectedClass.getDeclaredFields()) {
+      if (Modifier.isStatic(field.getModifiers()) && field.isAnnotationPresent(Inject.class)) {
+        field.setAccessible(true);
+        fields.add(field);
+      }
+    }
+    if (fields.isEmpty()) {
+      throw new IllegalArgumentException("No static injections: " + injectedClass.getName());
+    }
+    return new ReflectiveStaticInjection(injectedClass.getClassLoader(),
+        fields.toArray(new Field[fields.size()]));
+  }
+}
\ No newline at end of file
