diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedProductionComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedProductionComponent.java
index ba98e3698..50b466da5 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedProductionComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedProductionComponent.java
@@ -18,7 +18,7 @@
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.ProductionComponent;
 
-@ProductionComponent(modules = DependedProducerModule.class)
+@ProductionComponent(modules = {ExecutorModule.class, DependedProducerModule.class})
 interface DependedProductionComponent {
   ListenableFuture<Integer> numGreetings();
 }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependentComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependentComponent.java
index 85709f0f3..f467178c6 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependentComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependentComponent.java
@@ -21,8 +21,9 @@
 import java.util.List;
 
 @ProductionComponent(
-    modules = DependentProducerModule.class,
-    dependencies = {DependedComponent.class, DependedProductionComponent.class})
+  modules = {ExecutorModule.class, DependentProducerModule.class},
+  dependencies = {DependedComponent.class, DependedProductionComponent.class}
+)
 interface DependentComponent {
   ListenableFuture<List<String>> greetings();
 }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ExecutorModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ExecutorModule.java
new file mode 100644
index 000000000..f37eac5c4
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ExecutorModule.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest;
+
+import com.google.common.util.concurrent.MoreExecutors;
+import dagger.Module;
+import dagger.Provides;
+import dagger.producers.Production;
+import java.util.concurrent.Executor;
+
+/**
+ * A module that provides an optionally user-defined executor for a production component, defaulting
+ * to the direct executor.
+ */
+@Module
+public final class ExecutorModule {
+  private final Executor executor;
+
+  public ExecutorModule() {
+    this(MoreExecutors.directExecutor());
+  }
+
+  public ExecutorModule(Executor executor) {
+    this.executor = executor;
+  }
+
+  @Provides
+  @Production
+  Executor executor() {
+    return executor;
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleComponent.java
index 1d1e49233..ea793fd4d 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleComponent.java
@@ -18,7 +18,7 @@
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.ProductionComponent;
 
-@ProductionComponent(modules = ResponseProducerModule.class)
+@ProductionComponent(modules = {ExecutorModule.class, ResponseProducerModule.class})
 interface SimpleComponent {
   ListenableFuture<Response> response();
 }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/SimpleComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/SimpleComponent.java
index 6b3536eae..efeb1d003 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/SimpleComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/SimpleComponent.java
@@ -17,12 +17,16 @@
 
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.ProductionComponent;
+import producerstest.ExecutorModule;
 
 /**
  * A component that contains entry points that exercise different execution paths, for verifying the
  * behavior when the executor throws a {@link java.util.concurrent.RejectedExecutionException}.
  */
-@ProductionComponent(dependencies = ComponentDependency.class, modules = SimpleProducerModule.class)
+@ProductionComponent(
+  dependencies = ComponentDependency.class,
+  modules = {ExecutorModule.class, SimpleProducerModule.class}
+)
 interface SimpleComponent {
   /** An entry point exposing a producer method with no args. */
   ListenableFuture<String> noArgStr();
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/TestComponentWithBuilder.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/TestComponentWithBuilder.java
index 16dc9bad7..1e4973fc1 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/TestComponentWithBuilder.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/TestComponentWithBuilder.java
@@ -17,10 +17,10 @@
 
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.ProductionComponent;
-import java.util.concurrent.Executor;
+import producerstest.ExecutorModule;
 
 @ProductionComponent(
-  modules = {StringModule.class, IntModule.class},
+  modules = {ExecutorModule.class, StringModule.class, IntModule.class},
   dependencies = DepComponent.class
 )
 interface TestComponentWithBuilder {
@@ -31,7 +31,6 @@
   interface Builder {
     Builder depComponent(DepComponent depComponent);
     Builder strModule(StringModule strModule);
-    Builder executor(Executor executor);
     TestComponentWithBuilder build();
   }
 }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoredComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoredComponent.java
index 48acbabac..d46c88fa9 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoredComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoredComponent.java
@@ -17,8 +17,11 @@
 
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.ProductionComponent;
+import producerstest.ExecutorModule;
 
-@ProductionComponent(modules = {MonitoringModule.class, StubModule.class, ServingModule.class})
+@ProductionComponent(
+  modules = {ExecutorModule.class, MonitoringModule.class, StubModule.class, ServingModule.class}
+)
 interface MonitoredComponent {
   ListenableFuture<String> output();
 }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java
index 845e52426..8decb55fb 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java
@@ -21,11 +21,12 @@
 import dagger.producers.ProductionComponent;
 import java.util.Map;
 import java.util.Set;
+import producerstest.ExecutorModule;
 import producerstest.multibindings.Qualifiers.ObjCount;
 import producerstest.multibindings.Qualifiers.PossiblyThrowingMap;
 import producerstest.multibindings.Qualifiers.PossiblyThrowingSet;
 
-@ProductionComponent(modules = MultibindingProducerModule.class)
+@ProductionComponent(modules = {ExecutorModule.class, MultibindingProducerModule.class})
 interface MultibindingComponent {
   ListenableFuture<Set<String>> strs();
   ListenableFuture<Integer> strCount();
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/SetComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/SetComponent.java
index c7801c06a..75a05fa3f 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/SetComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/SetComponent.java
@@ -18,8 +18,9 @@
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.ProductionComponent;
 import java.util.Set;
+import producerstest.ExecutorModule;
 
-@ProductionComponent(modules = {ScopedModule.class, SetProducerModule.class})
+@ProductionComponent(modules = {ExecutorModule.class, ScopedModule.class, SetProducerModule.class})
 interface SetComponent {
   ScopedObject scopedObject();
 
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/Subcomponents.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/Subcomponents.java
deleted file mode 100644
index b998c5a3d..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/Subcomponents.java
+++ /dev/null
@@ -1,142 +0,0 @@
-/*
- * Copyright (C) 2016 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package producerstest.subcomponent;
-
-import com.google.common.util.concurrent.ListenableFuture;
-import dagger.Component;
-import dagger.Module;
-import dagger.Provides;
-import dagger.producers.ProducerModule;
-import dagger.producers.Produces;
-import dagger.producers.ProductionComponent;
-import dagger.producers.ProductionSubcomponent;
-import java.util.concurrent.Executor;
-import javax.inject.Inject;
-import javax.inject.Provider;
-import javax.inject.Qualifier;
-
-final class Subcomponents {
-  @Qualifier
-  @interface FromParent {}
-
-  @Qualifier
-  @interface FromChild {}
-
-  @Qualifier
-  @interface FromGrandchild {}
-
-  @Module
-  static final class ParentModule {
-    @Provides
-    @FromParent
-    static String fromParent() {
-      return "parent";
-    }
-  }
-
-  @Component(modules = ParentModule.class)
-  interface ParentComponent {
-    InjectsChildBuilder injectsChildBuilder();
-
-    ChildComponentWithExecutor.Builder newChildComponentBuilder();
-  }
-
-  @ProducerModule
-  static final class ParentProducerModule {
-    @Produces
-    @FromParent
-    static String fromParent() {
-      return "parentproduction";
-    }
-  }
-
-  @ProductionComponent(modules = ParentProducerModule.class)
-  interface ParentProductionComponent {
-    ChildComponent.Builder newChildComponentBuilder();
-  }
-
-  @ProducerModule
-  static final class ChildProducerModule {
-    @Produces
-    @FromChild
-    static String fromChild(@FromParent String fromParent) {
-      return "child:" + fromParent;
-    }
-  }
-
-  @ProductionSubcomponent(modules = ChildProducerModule.class)
-  interface ChildComponent {
-    @FromChild
-    ListenableFuture<String> fromChild();
-
-    GrandchildComponent.Builder newGrandchildComponentBuilder();
-
-    @ProductionSubcomponent.Builder
-    interface Builder {
-      ChildComponent build();
-    }
-  }
-
-  @ProductionSubcomponent(modules = ChildProducerModule.class)
-  interface ChildComponentWithExecutor {
-    @FromChild
-    ListenableFuture<String> fromChild();
-
-    GrandchildComponent.Builder newGrandchildComponentBuilder();
-
-    @ProductionSubcomponent.Builder
-    interface Builder {
-      Builder executor(Executor executor);
-
-      ChildComponentWithExecutor build();
-    }
-  }
-
-  static final class InjectsChildBuilder {
-    private final Provider<ChildComponentWithExecutor.Builder> childBuilder;
-
-    @Inject
-    InjectsChildBuilder(Provider<ChildComponentWithExecutor.Builder> childBuilder) {
-      this.childBuilder = childBuilder;
-    }
-
-    ChildComponentWithExecutor.Builder childBuilder() {
-      return childBuilder.get();
-    }
-  }
-
-  @ProducerModule
-  static final class GrandchildProducerModule {
-    @Produces
-    @FromGrandchild
-    static String fromGranchild(@FromChild String fromChild) {
-      return "grandchild:" + fromChild;
-    }
-  }
-
-  @ProductionSubcomponent(modules = GrandchildProducerModule.class)
-  interface GrandchildComponent {
-    @FromGrandchild
-    ListenableFuture<String> fromGrandchild();
-
-    @ProductionSubcomponent.Builder
-    interface Builder {
-      GrandchildComponent build();
-    }
-  }
-
-  private Subcomponents() {}
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/sub/ChildComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/sub/ChildComponent.java
index a53bb3564..0059631b8 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/sub/ChildComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/sub/ChildComponent.java
@@ -17,15 +17,14 @@
 
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.ProductionSubcomponent;
-import java.util.concurrent.Executor;
+import producerstest.ExecutorModule;
 
-@ProductionSubcomponent(modules = ChildModule.class)
+@ProductionSubcomponent(modules = {ExecutorModule.class, ChildModule.class})
 public interface ChildComponent {
   ListenableFuture<String> str();
 
   @ProductionSubcomponent.Builder
   interface Builder {
-    Builder executor(Executor executor);
     ChildComponent build();
   }
 }
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/DependentTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/DependentTest.java
index b2533d735..e4812b823 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/DependentTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/DependentTest.java
@@ -17,7 +17,6 @@
 
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
-import com.google.common.util.concurrent.MoreExecutors;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -27,30 +26,24 @@
 @RunWith(JUnit4.class)
 public class DependentTest {
   @Test public void dependentComponent() throws Exception {
-    DependentComponent dependentComponent = DaggerDependentComponent
-        .builder()
-        .dependedProductionComponent(DaggerDependedProductionComponent.builder()
-            .executor(MoreExecutors.directExecutor())
-            .build())
-        .dependedComponent(DaggerDependedComponent.create())
-        .executor(MoreExecutors.directExecutor())
-        .build();
+    DependentComponent dependentComponent =
+        DaggerDependentComponent.builder()
+            .dependedProductionComponent(DaggerDependedProductionComponent.create())
+            .dependedComponent(DaggerDependedComponent.create())
+            .build();
     assertThat(dependentComponent).isNotNull();
     assertThat(dependentComponent.greetings().get()).containsExactly(
         "2", "Hello world!", "HELLO WORLD!");
   }
 
   @Test public void reuseBuilderWithDependentComponent() throws Exception {
-    DaggerDependentComponent.Builder dependentComponentBuilder = DaggerDependentComponent
-        .builder()
-        .executor(MoreExecutors.directExecutor());
+    DaggerDependentComponent.Builder dependentComponentBuilder = DaggerDependentComponent.builder();
 
-    DependentComponent componentUsingComponents = dependentComponentBuilder
-        .dependedProductionComponent(DaggerDependedProductionComponent.builder()
-            .executor(MoreExecutors.directExecutor())
-            .build())
-        .dependedComponent(DaggerDependedComponent.create())
-        .build();
+    DependentComponent componentUsingComponents =
+        dependentComponentBuilder
+            .dependedProductionComponent(DaggerDependedProductionComponent.create())
+            .dependedComponent(DaggerDependedComponent.create())
+            .build();
 
     DependentComponent componentUsingJavaImpls = dependentComponentBuilder
         .dependedProductionComponent(new DependedProductionComponent() {
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/SimpleTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/SimpleTest.java
index cacc0f11d..e4812ab9a 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/SimpleTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/SimpleTest.java
@@ -15,7 +15,6 @@
 */
 package producerstest;
 
-import com.google.common.util.concurrent.MoreExecutors;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -25,10 +24,7 @@
 @RunWith(JUnit4.class)
 public class SimpleTest {
   @Test public void testSimpleComponent() throws Exception {
-    SimpleComponent simpleComponent = DaggerSimpleComponent
-        .builder()
-        .executor(MoreExecutors.directExecutor())
-        .build();
+    SimpleComponent simpleComponent = DaggerSimpleComponent.create();
     assertThat(simpleComponent).isNotNull();
     assertThat(simpleComponent.response().get().data()).isEqualTo("Hello, Request #5!");
   }
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/badexecutor/BadExecutorTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/badexecutor/BadExecutorTest.java
index 8a49797f5..0e4d44d39 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/badexecutor/BadExecutorTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/badexecutor/BadExecutorTest.java
@@ -10,6 +10,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
+import producerstest.ExecutorModule;
 
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
@@ -31,7 +32,7 @@ public void setUpComponent() {
     ListeningExecutorService executorService = MoreExecutors.newDirectExecutorService();
     component =
         DaggerSimpleComponent.builder()
-            .executor(executorService)
+            .executorModule(new ExecutorModule(executorService))
             .componentDependency(dependency)
             .build();
     executorService.shutdown();
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/builder/ProductionComponentBuilderTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/builder/ProductionComponentBuilderTest.java
index 715761df4..10e5f4fac 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/builder/ProductionComponentBuilderTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/builder/ProductionComponentBuilderTest.java
@@ -17,7 +17,6 @@
 
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
-import com.google.common.util.concurrent.MoreExecutors;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -32,7 +31,6 @@
   public void successfulBuild() throws Exception {
     TestComponentWithBuilder component =
         DaggerTestComponentWithBuilder.builder()
-            .executor(MoreExecutors.directExecutor())
             .depComponent(depComponent(15.3))
             .strModule(new StringModule())
             .build();
@@ -44,25 +42,15 @@ public void successfulBuild() throws Exception {
   public void successfulBuild_withMissingZeroArgModule() throws Exception {
     TestComponentWithBuilder component =
         DaggerTestComponentWithBuilder.builder()
-            .executor(MoreExecutors.directExecutor())
             .depComponent(depComponent(15.3))
             .build();
     assertThat(component.s().get()).isEqualTo("arg: 42");
     assertThat(component.d().get()).isEqualTo(15.3);
   }
 
-  @Test(expected = IllegalStateException.class)
-  public void missingExecutor() {
-    DaggerTestComponentWithBuilder.builder()
-        .depComponent(depComponent(15.3))
-        .strModule(new StringModule())
-        .build();
-  }
-
   @Test(expected = IllegalStateException.class)
   public void missingDepComponent() {
     DaggerTestComponentWithBuilder.builder()
-        .executor(MoreExecutors.directExecutor())
         .strModule(new StringModule())
         .build();
   }
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/monitoring/MonitoringTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/monitoring/MonitoringTest.java
index 6572215ff..e36f35886 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/monitoring/MonitoringTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/monitoring/MonitoringTest.java
@@ -18,7 +18,6 @@
 import com.google.common.base.Throwables;
 import com.google.common.collect.ImmutableList;
 import com.google.common.util.concurrent.ListenableFuture;
-import com.google.common.util.concurrent.MoreExecutors;
 import com.google.common.util.concurrent.SettableFuture;
 import dagger.producers.monitoring.ProducerMonitor;
 import dagger.producers.monitoring.ProducerToken;
@@ -67,7 +66,6 @@ public void setUp() {
   public void basicMonitoring() throws Exception {
     MonitoredComponent component =
         DaggerMonitoredComponent.builder()
-            .executor(MoreExecutors.directExecutor())
             .monitoringModule(new MonitoringModule(componentMonitorFactory))
             .stubModule(new StubModule(server1, server2))
             .build();
@@ -110,7 +108,6 @@ public void basicMonitoring() throws Exception {
   public void basicMonitoringWithFailure() throws Exception {
     MonitoredComponent component =
         DaggerMonitoredComponent.builder()
-            .executor(MoreExecutors.directExecutor())
             .monitoringModule(new MonitoringModule(componentMonitorFactory))
             .stubModule(new StubModule(server1, server2))
             .build();
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/multibindings/MultibindingTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/multibindings/MultibindingTest.java
index 0919fded2..03aae67bb 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/multibindings/MultibindingTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/multibindings/MultibindingTest.java
@@ -17,7 +17,6 @@
 
 import com.google.common.collect.Iterables;
 import com.google.common.util.concurrent.ListenableFuture;
-import com.google.common.util.concurrent.MoreExecutors;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import java.util.HashSet;
@@ -35,8 +34,7 @@
 public class MultibindingTest {
   @Test
   public void setBinding() throws Exception {
-    MultibindingComponent multibindingComponent =
-        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
     assertThat(multibindingComponent.strs().get())
         .containsExactly("foo", "foo1", "foo2", "bar", "bar1", "bar2");
     assertThat(multibindingComponent.strCount().get()).isEqualTo(6);
@@ -44,8 +42,7 @@ public void setBinding() throws Exception {
 
   @Test
   public void setBindingOfProduced() throws Exception {
-    MultibindingComponent multibindingComponent =
-        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
     assertThat(multibindingComponent.successfulSet().get())
         .containsExactly(
             Produced.successful("foo"),
@@ -58,8 +55,7 @@ public void setBindingOfProduced() throws Exception {
 
   @Test
   public void setBindingOfProducedWithFailures() throws Exception {
-    MultibindingComponent multibindingComponent =
-        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
     Set<Produced<String>> possiblyThrowingSet = multibindingComponent.possiblyThrowingSet().get();
     Set<String> successes = new HashSet<>();
     Set<ExecutionException> failures = new HashSet<>();
@@ -77,8 +73,7 @@ public void setBindingOfProducedWithFailures() throws Exception {
 
   @Test
   public void mapBinding() throws Exception {
-    MultibindingComponent multibindingComponent =
-        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
     Map<Integer, String> map = multibindingComponent.map().get();
     assertThat(map).hasSize(2);
     assertThat(map).containsEntry(15, "fifteen");
@@ -87,8 +82,7 @@ public void mapBinding() throws Exception {
 
   @Test
   public void mapOfProducerBinding() throws Exception {
-    MultibindingComponent multibindingComponent =
-        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
     Map<Integer, Producer<String>> map = multibindingComponent.mapOfProducer().get();
     assertThat(map).hasSize(2);
     assertThat(map).containsKey(15);
@@ -99,8 +93,7 @@ public void mapOfProducerBinding() throws Exception {
 
   @Test
   public void mapOfProducedBinding() throws Exception {
-    MultibindingComponent multibindingComponent =
-        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
     Map<Integer, Produced<String>> map = multibindingComponent.mapOfProduced().get();
     assertThat(map).hasSize(2);
     assertThat(map).containsKey(15);
@@ -111,8 +104,7 @@ public void mapOfProducedBinding() throws Exception {
 
   @Test
   public void mapBindingWithFailures() throws Exception {
-    MultibindingComponent multibindingComponent =
-        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
     try {
       multibindingComponent.possiblyThrowingMap().get();
       fail();
@@ -123,8 +115,7 @@ public void mapBindingWithFailures() throws Exception {
 
   @Test
   public void mapOfProducerBindingWithFailures() throws Exception {
-    MultibindingComponent multibindingComponent =
-        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
     Map<Integer, Producer<String>> map =
         multibindingComponent.possiblyThrowingMapOfProducer().get();
     assertThat(map).hasSize(2);
@@ -142,8 +133,7 @@ public void mapOfProducerBindingWithFailures() throws Exception {
 
   @Test
   public void mapOfProducedBindingWithFailures() throws Exception {
-    MultibindingComponent multibindingComponent =
-        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
     Map<Integer, Produced<String>> map =
         multibindingComponent.possiblyThrowingMapOfProduced().get();
     assertThat(map).hasSize(2);
@@ -161,8 +151,7 @@ public void mapOfProducedBindingWithFailures() throws Exception {
 
   @Test
   public void emptySet() throws Exception {
-    MultibindingComponent multibindingComponent =
-        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
     assertThat(multibindingComponent.objs().get()).isEmpty();
     assertThat(multibindingComponent.producedObjs().get()).isEmpty();
     assertThat(multibindingComponent.objCount().get()).isEqualTo(0);
@@ -170,8 +159,7 @@ public void emptySet() throws Exception {
 
   @Test
   public void emptyMap() throws Exception {
-    MultibindingComponent multibindingComponent =
-        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
     assertThat(multibindingComponent.objMap().get()).isEmpty();
     assertThat(multibindingComponent.objMapOfProduced().get()).isEmpty();
     assertThat(multibindingComponent.objMapOfProducer().get()).isEmpty();
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/scope/ScopeTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/scope/ScopeTest.java
index 36ce255e5..6af6d8af6 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/scope/ScopeTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/scope/ScopeTest.java
@@ -15,7 +15,6 @@
  */
 package producerstest.scope;
 
-import com.google.common.util.concurrent.MoreExecutors;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -27,8 +26,7 @@
 
   @Test
   public void scope() throws Exception {
-    SetComponent component =
-        DaggerSetComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    SetComponent component = DaggerSetComponent.create();
     assertThat(component.set().get()).hasSize(1);
     assertThat(component.scopedObject()).isSameAs(component.scopedObject());
   }
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/MultiPackageSubcomponentTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/MultiPackageSubcomponentTest.java
index ad5c86d22..313202172 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/MultiPackageSubcomponentTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/MultiPackageSubcomponentTest.java
@@ -17,8 +17,6 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
-import com.google.common.util.concurrent.MoreExecutors;
-import java.util.concurrent.Executor;
 import producerstest.subcomponent.MultiPackageSubcomponents.ParentComponent;
 import producerstest.subcomponent.sub.ChildComponent;
 import org.junit.Test;
@@ -30,9 +28,8 @@
 
   @Test
   public void childComponent() throws Exception {
-    Executor executor = MoreExecutors.directExecutor();
     ParentComponent parent = DaggerMultiPackageSubcomponents_ParentComponent.create();
-    ChildComponent child = parent.childComponentBuilder().executor(executor).build();
+    ChildComponent child = parent.childComponentBuilder().build();
     assertThat(child.str().get()).isEqualTo("Hello, World 42");
   }
 }
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/SubcomponentTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/SubcomponentTest.java
deleted file mode 100644
index ddd43403e..000000000
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/SubcomponentTest.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Copyright (C) 2016 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package producerstest.subcomponent;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import com.google.common.util.concurrent.MoreExecutors;
-import java.util.concurrent.Executor;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import producerstest.subcomponent.Subcomponents.ChildComponent;
-import producerstest.subcomponent.Subcomponents.ChildComponentWithExecutor;
-import producerstest.subcomponent.Subcomponents.GrandchildComponent;
-import producerstest.subcomponent.Subcomponents.ParentComponent;
-import producerstest.subcomponent.Subcomponents.ParentProductionComponent;
-
-@RunWith(JUnit4.class)
-public final class SubcomponentTest {
-  @Test
-  public void topLevelComponent_child() throws Exception {
-    Executor executor = MoreExecutors.directExecutor();
-    ParentComponent parent = DaggerSubcomponents_ParentComponent.create();
-    ChildComponentWithExecutor child = parent.newChildComponentBuilder().executor(executor).build();
-    assertThat(child.fromChild().get()).isEqualTo("child:parent");
-  }
-
-  @Test
-  public void topLevelComponent_injectsChildBuilder() throws Exception {
-    Executor executor = MoreExecutors.directExecutor();
-    ParentComponent parent = DaggerSubcomponents_ParentComponent.create();
-    ChildComponentWithExecutor child =
-        parent.injectsChildBuilder().childBuilder().executor(executor).build();
-    assertThat(child.fromChild().get()).isEqualTo("child:parent");
-  }
-
-  @Test
-  public void topLevelComponent_grandchild() throws Exception {
-    Executor executor = MoreExecutors.directExecutor();
-    ParentComponent parent = DaggerSubcomponents_ParentComponent.create();
-    ChildComponentWithExecutor child = parent.newChildComponentBuilder().executor(executor).build();
-    GrandchildComponent grandchild = child.newGrandchildComponentBuilder().build();
-    assertThat(grandchild.fromGrandchild().get()).isEqualTo("grandchild:child:parent");
-  }
-
-  @Test
-  public void topLevelProductionComponent_child() throws Exception {
-    Executor executor = MoreExecutors.directExecutor();
-    ParentProductionComponent parent =
-        DaggerSubcomponents_ParentProductionComponent.builder().executor(executor).build();
-    ChildComponent child = parent.newChildComponentBuilder().build();
-    assertThat(child.fromChild().get()).isEqualTo("child:parentproduction");
-  }
-
-  @Test
-  public void topLevelProductionComponent_grandchild() throws Exception {
-    Executor executor = MoreExecutors.directExecutor();
-    ParentProductionComponent parent =
-        DaggerSubcomponents_ParentProductionComponent.builder().executor(executor).build();
-    ChildComponent child = parent.newChildComponentBuilder().build();
-    GrandchildComponent grandchild = child.newGrandchildComponentBuilder().build();
-    assertThat(grandchild.fromGrandchild().get()).isEqualTo("grandchild:child:parentproduction");
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index d7eb38720..dafe78a5e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -933,14 +933,6 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
               : factoryCreate;
         }
 
-      case EXECUTOR_DEPENDENCY:
-        return CodeBlocks.format(
-            "$T.<$T>create($L)",
-            INSTANCE_FACTORY,
-            bindingKeyTypeName,
-            getComponentContributionExpression(
-                graph.componentDescriptor().executorDependency().get()));
-
       case COMPONENT_PRODUCTION:
         {
           TypeElement bindingTypeElement =
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 67dbe1304..9f9e1ed7d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -48,7 +48,6 @@
 import java.util.Set;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Executor;
 import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
@@ -110,8 +109,7 @@
 
   /**
    * Returns the set of types necessary to implement the component, but are not part of the injected
-   * graph.  This includes modules, component dependencies and an {@link Executor} in the case of
-   * {@link ProductionComponent}.
+   * graph.  This includes modules and component dependencies.
    */
   ImmutableSet<TypeElement> componentRequirements() {
     return SUBGRAPH_TRAVERSER
@@ -141,7 +139,6 @@
             })
         .filter(in(ownedModuleTypes()))
         .append(componentDescriptor().dependencies())
-        .append(componentDescriptor().executorDependency().asSet())
         .toSet();
   }
 
@@ -165,7 +162,6 @@ public ComponentDescriptor apply(BindingGraph graph) {
     return new ImmutableSet.Builder<TypeElement>()
         .addAll(componentDescriptor().transitiveModuleTypes())
         .addAll(componentDescriptor().dependencies())
-        .addAll(componentDescriptor().executorDependency().asSet())
         .build();
   }
 
@@ -200,12 +196,6 @@ private BindingGraph create(
       TypeElement componentDefinitionType = componentDescriptor.componentDefinitionType();
       explicitBindingsBuilder.add(provisionBindingFactory.forComponent(componentDefinitionType));
 
-      // immediate binding for the executor, if it's provided to the builder
-      if (componentDescriptor.executorDependency().isPresent()) {
-        explicitBindingsBuilder.add(
-            provisionBindingFactory.forExecutorDependency(componentDefinitionType));
-      }
-
       // Collect Component dependencies.
       Optional<AnnotationMirror> componentMirror =
           getAnnotationMirror(componentDefinitionType, Component.class)
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 2060f199b..fa3e8e30e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -42,7 +42,6 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import java.util.concurrent.Executor;
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
@@ -272,11 +271,6 @@ boolean isProducer() {
    */
   abstract ImmutableMap<ExecutableElement, TypeElement> dependencyMethodIndex();
 
-  /**
-   * The element representing {@link Executor}, if it should be a dependency of this component.
-   */
-  abstract Optional<TypeElement> executorDependency();
-
   /**
    * The scopes of the component.
    */
@@ -486,7 +480,6 @@ private ComponentDescriptor create(
         scopes = FluentIterable.from(scopes).append(Scope.productionScope(elements)).toSet();
       }
 
-      Optional<TypeElement> executorDependency = createExecutorDependency(kind, builderSpec);
       return new AutoValue_ComponentDescriptor(
           kind,
           componentMirror,
@@ -494,7 +487,6 @@ private ComponentDescriptor create(
           componentDependencyTypes,
           modules.build(),
           dependencyMethodIndex.build(),
-          executorDependency,
           scopes,
           subcomponentDescriptors.build(),
           componentMethodsBuilder.build(),
@@ -595,25 +587,6 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(
           map.build(), buildMethod, element.getEnclosingElement().asType()));
     }
 
-    // TODO(beder): Remove the executor dependency when all clients have been updated.
-    private Optional<TypeElement> createExecutorDependency(
-        Kind componentKind, Optional<BuilderSpec> builderSpec) {
-      if (!componentKind.isProducer()) {
-        return Optional.absent();
-      }
-      TypeElement executorTypeElement = elements.getTypeElement(Executor.class.getCanonicalName());
-      if (!builderSpec.isPresent()) {
-        // if there's no builder on a component (not a subcomponent!), we'll add an executor()
-        // method to the generated builder so it must be specified
-        return componentKind.equals(Kind.PRODUCTION_COMPONENT)
-            ? Optional.of(executorTypeElement)
-            : Optional.<TypeElement>absent();
-      }
-      return builderSpec.get().methodMap().containsKey(executorTypeElement)
-          ? Optional.of(executorTypeElement)
-          : Optional.<TypeElement>absent();
-    }
-
     /**
      * Returns a descriptor for a generated module that handles monitoring for production
      * components. This module is generated in the {@link MonitoringModuleProcessingStep}.
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index 6aec6a795..71cb38afd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -142,13 +142,6 @@ public Kind apply(ContributionBinding binding) {
      */
     SUBCOMPONENT_BUILDER,
 
-    /**
-     * The executor provided in a builder for a production component. This executor is used to
-     * schedule producer methods, and its specification on the component builder is to provide an
-     * implicit provision for it.
-     */
-    EXECUTOR_DEPENDENCY,
-
     // Production kinds
 
     /** A {@link Produces}-annotated method that doesn't return a {@link ListenableFuture}. */
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 2fb6c2bfe..ee3f692c6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -22,7 +22,6 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import dagger.Provides;
-import java.util.concurrent.Executor;
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
@@ -278,21 +277,5 @@ ProvisionBinding forSubcomponentBuilderMethod(
           Optional.<ProvisionBinding>absent(),
           Optional.<Scope>absent());
     }
-
-    ProvisionBinding forExecutorDependency(TypeElement componentElement) {
-      TypeElement executorElement = elements.getTypeElement(Executor.class.getCanonicalName());
-      checkNotNull(executorElement);
-      return new AutoValue_ProvisionBinding(
-          SourceElement.forElement(componentElement),
-          keyFactory.forProductionExecutor(),
-          ImmutableSet.<DependencyRequest>of(),
-          Optional.<String>absent(),
-          Optional.<DeclaredType>absent(),
-          Optional.<DependencyRequest>absent(),
-          Kind.EXECUTOR_DEPENDENCY,
-          Provides.Type.UNIQUE,
-          Optional.<ProvisionBinding>absent(),
-          Optional.<Scope>absent());
-    }
   }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
index 64cfba626..00ebc99b6 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -89,7 +89,7 @@
   }
 
   @Test
-  public void builderWithExecutorAndProvidedExecutor() {
+  public void dependsOnProductionExecutor() {
     JavaFileObject moduleFile =
         JavaFileObjects.forSourceLines(
             "test.ExecutorModule",
@@ -114,10 +114,12 @@ public void builderWithExecutorAndProvidedExecutor() {
             "",
             "import dagger.producers.ProducerModule;",
             "import dagger.producers.Produces;",
+            "import dagger.producers.Production;",
+            "import java.util.concurrent.Executor;",
             "",
             "@ProducerModule",
             "final class SimpleModule {",
-            "  @Produces String str() {",
+            "  @Produces String str(@Production Executor executor) {",
             "    return \"\";",
             "  }",
             "}");
@@ -136,7 +138,6 @@ public void builderWithExecutorAndProvidedExecutor() {
             "",
             "  @ProductionComponent.Builder",
             "  interface Builder {",
-            "    Builder executor(Executor executor);",
             "    SimpleComponent build();",
             "  }",
             "}");
@@ -144,108 +145,58 @@ public void builderWithExecutorAndProvidedExecutor() {
         .that(ImmutableList.of(moduleFile, producerModuleFile, componentFile))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining("is bound multiple times");
+        .withErrorContaining("may not depend on the production executor");
   }
 
   @Test
-  public void dependsOnProductionExecutor() {
-    JavaFileObject moduleFile =
+  public void simpleComponent() {
+    JavaFileObject component =
         JavaFileObjects.forSourceLines(
-            "test.ExecutorModule",
+            "test.TestClass",
             "package test;",
             "",
+            "import com.google.common.util.concurrent.ListenableFuture;",
             "import com.google.common.util.concurrent.MoreExecutors;",
             "import dagger.Module;",
             "import dagger.Provides;",
-            "import dagger.producers.Production;",
-            "import java.util.concurrent.Executor;",
-            "",
-            "@Module",
-            "final class ExecutorModule {",
-            "  @Provides @Production Executor executor() {",
-            "    return MoreExecutors.directExecutor();",
-            "  }",
-            "}");
-    JavaFileObject producerModuleFile =
-        JavaFileObjects.forSourceLines(
-            "test.SimpleModule",
-            "package test;",
-            "",
             "import dagger.producers.ProducerModule;",
             "import dagger.producers.Produces;",
             "import dagger.producers.Production;",
+            "import dagger.producers.ProductionComponent;",
             "import java.util.concurrent.Executor;",
+            "import javax.inject.Inject;",
             "",
-            "@ProducerModule",
-            "final class SimpleModule {",
-            "  @Produces String str(@Production Executor executor) {",
-            "    return \"\";",
+            "final class TestClass {",
+            "  static final class C {",
+            "    @Inject C() {}",
             "  }",
-            "}");
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.SimpleComponent",
-            "package test;",
             "",
-            "import com.google.common.util.concurrent.ListenableFuture;",
-            "import dagger.producers.ProductionComponent;",
-            "import java.util.concurrent.Executor;",
+            "  interface A {}",
+            "  interface B {}",
             "",
-            "@ProductionComponent(modules = {ExecutorModule.class, SimpleModule.class})",
-            "interface SimpleComponent {",
-            "  ListenableFuture<String> str();",
+            "  @Module",
+            "  static final class BModule {",
+            "    @Provides B b(C c) {",
+            "      return null;",
+            "    }",
             "",
-            "  @ProductionComponent.Builder",
-            "  interface Builder {",
-            "    SimpleComponent build();",
+            "    @Provides @Production Executor executor() {",
+            "      return MoreExecutors.directExecutor();",
+            "    }",
+            "  }",
+            "",
+            "  @ProducerModule",
+            "  static final class AModule {",
+            "    @Produces ListenableFuture<A> a(B b) {",
+            "      return null;",
+            "    }",
+            "  }",
+            "",
+            "  @ProductionComponent(modules = {AModule.class, BModule.class})",
+            "  interface SimpleComponent {",
+            "    ListenableFuture<A> a();",
             "  }",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(moduleFile, producerModuleFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("may not depend on the production executor");
-  }
-
-  @Test public void simpleComponent() {
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "import dagger.producers.ProductionComponent;",
-        "import javax.inject.Inject;",
-        "",
-        "final class TestClass {",
-        "  static final class C {",
-        "    @Inject C() {}",
-        "  }",
-        "",
-        "  interface A {}",
-        "  interface B {}",
-        "",
-        "  @Module",
-        "  static final class BModule {",
-        "    @Provides B b(C c) {",
-        "      return null;",
-        "    }",
-        "  }",
-        "",
-        "  @ProducerModule",
-        "  static final class AModule {",
-        "    @Produces ListenableFuture<A> a(B b) {",
-        "      return null;",
-        "    }",
-        "  }",
-        "",
-        "  @ProductionComponent(modules = {AModule.class, BModule.class})",
-        "  interface SimpleComponent {",
-        "    ListenableFuture<A> a();",
-        "  }",
-        "}");
     JavaFileObject generatedComponent =
         JavaFileObjects.forSourceLines(
             "test.DaggerTestClass_SimpleComponent",
@@ -266,9 +217,9 @@ public void dependsOnProductionExecutor() {
             GENERATED_ANNOTATION,
             "public final class DaggerTestClass_SimpleComponent",
             "    implements TestClass.SimpleComponent {",
-            "  private Provider<Executor> simpleComponentProvider;",
             "  private Provider<Executor> executorProvider;",
-            "  private Provider<TestClass.SimpleComponent> simpleComponentProvider2;",
+            "  private Provider<Executor> executorProvider2;",
+            "  private Provider<TestClass.SimpleComponent> simpleComponentProvider;",
             "  private Provider<ProductionComponentMonitor> monitorProvider;",
             "  private Provider<TestClass.B> bProvider;",
             "  private Producer<TestClass.A> aProducer;",
@@ -282,26 +233,30 @@ public void dependsOnProductionExecutor() {
             "    return new Builder();",
             "  }",
             "",
+            "  public static TestClass.SimpleComponent create() {",
+            "    return builder().build()",
+            "  }",
+            "",
             "  @SuppressWarnings(\"unchecked\")",
             "  private void initialize(final Builder builder) {",
-            "    this.simpleComponentProvider =",
-            "        InstanceFactory.<Executor>create(builder.executor);",
             "    this.executorProvider =",
-            "        DoubleCheck.provider(",
-            "            TestClass$SimpleComponent_ProductionExecutorModule_ExecutorFactory",
-            "                .create(simpleComponentProvider));",
-            "    this.simpleComponentProvider2 =",
+            "        TestClass$BModule_ExecutorFactory.create(builder.bModule);",
+            "     this.executorProvider2 =",
+            "         DoubleCheck.provider(",
+            "             TestClass$SimpleComponent_ProductionExecutorModule_ExecutorFactory.create(",
+            "                 executorProvider));",
+            "    this.simpleComponentProvider =",
             "        InstanceFactory.<TestClass.SimpleComponent>create(this);",
             "    this.monitorProvider =",
             "        DoubleCheck.provider(",
             "            TestClass$SimpleComponent_MonitoringModule_MonitorFactory.create(",
-            "                simpleComponentProvider2,",
+            "                simpleComponentProvider,",
             "                SetFactory.<ProductionComponentMonitor.Factory>create());",
             "    this.bProvider = TestClass$BModule_BFactory.create(",
             "        builder.bModule, TestClass$C_Factory.create());",
             "    this.aProducer = new TestClass$AModule_AFactory(",
             "        builder.aModule,",
-            "        executorProvider,",
+            "        executorProvider2,",
             "        monitorProvider,",
             "        Producers.producerFromProvider(bProvider));",
             "  }",
@@ -314,7 +269,6 @@ public void dependsOnProductionExecutor() {
             "  public static final class Builder {",
             "    private TestClass.BModule bModule;",
             "    private TestClass.AModule aModule;",
-            "    private Executor executor;",
             "",
             "    private Builder() {",
             "    }",
@@ -326,10 +280,6 @@ public void dependsOnProductionExecutor() {
             "      if (aModule == null) {",
             "        this.aModule = new TestClass.AModule();",
             "      }",
-            "      if (executor == null) {",
-            "        throw new IllegalStateException(Executor.class.getCanonicalName()",
-            "            + \" must be set\");",
-            "      }",
             "      return new DaggerTestClass_SimpleComponent(this);",
             "    }",
             "",
@@ -358,12 +308,6 @@ public void dependsOnProductionExecutor() {
             "      Preconditions.checkNotNull(testClass$SimpleComponent_ProductionExecutorModule);",
             "      return this;",
             "    }",
-            "",
-            "    public Builder executor(Executor executor) {",
-            "      this.executor = Preconditions.checkNotNull(executor);",
-            "      return this;",
-            "    }",
-            "  }",
             "}");
     assertAbout(javaSource()).that(component)
         .processedWith(new ComponentProcessor())
@@ -376,11 +320,14 @@ public void dependsOnProductionExecutor() {
         "package test;",
         "",
         "import com.google.common.util.concurrent.ListenableFuture;",
+        "import com.google.common.util.concurrent.MoreExecutors;",
         "import dagger.Module;",
         "import dagger.Provides;",
         "import dagger.producers.ProducerModule;",
         "import dagger.producers.Produces;",
+        "import dagger.producers.Production;",
         "import dagger.producers.ProductionComponent;",
+        "import java.util.concurrent.Executor;",
         "import javax.annotation.Nullable;",
         "import javax.inject.Inject;",
         "",
@@ -394,6 +341,10 @@ public void dependsOnProductionExecutor() {
         "    @Provides @Nullable C c() {",
         "      return null;",
         "    }",
+        "",
+        "    @Provides @Production Executor executor() {",
+        "      return MoreExecutors.directExecutor();",
+        "    }",
         "  }",
         "",
         "  @ProducerModule",
@@ -417,10 +368,10 @@ public void dependsOnProductionExecutor() {
         .compilesWithoutError()
         .withWarningContaining("@Nullable on @Produces methods does not do anything")
         .in(component)
-        .onLine(26)
+        .onLine(33)
         .and()
         .withWarningContaining("@Nullable on @Produces methods does not do anything")
         .in(component)
-        .onLine(29);
+        .onLine(36);
   }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
index 399fb758f..0d38a6103 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
@@ -17,14 +17,12 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
-import java.util.Arrays;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
 import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 
 /**
@@ -32,6 +30,24 @@
  */
 @RunWith(JUnit4.class)
 public class ProductionGraphValidationTest {
+  private static final JavaFileObject EXECUTOR_MODULE =
+      JavaFileObjects.forSourceLines(
+          "test.ExecutorModule",
+          "package test;",
+          "",
+          "import com.google.common.util.concurrent.MoreExecutors;",
+          "import dagger.Module;",
+          "import dagger.Provides;",
+          "import dagger.producers.Production;",
+          "import java.util.concurrent.Executor;",
+          "",
+          "@Module",
+          "class ExecutorModule {",
+          "  @Provides @Production Executor executor() {",
+          "    return MoreExecutors.directExecutor();",
+          "  }",
+          "}");
+
   @Test public void componentWithUnprovidedInput() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.MyComponent",
         "package test;",
@@ -39,7 +55,7 @@
         "import com.google.common.util.concurrent.ListenableFuture;",
         "import dagger.producers.ProductionComponent;",
         "",
-        "@ProductionComponent(modules = FooModule.class)",
+        "@ProductionComponent(modules = {ExecutorModule.class, FooModule.class})",
         "interface MyComponent {",
         "  ListenableFuture<Foo> getFoo();",
         "}");
@@ -58,7 +74,7 @@
         "    return null;",
         "  }",
         "}");
-    assertAbout(javaSources()).that(Arrays.asList(module, component))
+    assertAbout(javaSources()).that(ImmutableList.of(EXECUTOR_MODULE, module, component))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining("test.Bar cannot be provided without an @Inject constructor or from "
@@ -76,14 +92,14 @@
         "final class TestClass {",
         "  interface A {}",
         "",
-        "  @ProductionComponent()",
+        "  @ProductionComponent(modules = ExecutorModule.class)",
         "  interface AComponent {",
         "    ListenableFuture<A> getA();",
         "  }",
         "}");
     String expectedError =
         "test.TestClass.A cannot be provided without an @Provides- or @Produces-annotated method.";
-    assertAbout(javaSource()).that(component)
+    assertAbout(javaSources()).that(ImmutableList.of(EXECUTOR_MODULE, component))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(expectedError).in(component).onLine(11);
@@ -118,14 +134,14 @@
         "    }",
         "  }",
         "",
-        "  @ProductionComponent(modules = {AModule.class, BModule.class})",
+        "  @ProductionComponent(modules = {ExecutorModule.class, AModule.class, BModule.class})",
         "  interface AComponent {",
         "    ListenableFuture<A> getA();",
         "  }",
         "}");
     String expectedError =
         "test.TestClass.A is a provision, which cannot depend on a production.";
-    assertAbout(javaSource()).that(component)
+    assertAbout(javaSources()).that(ImmutableList.of(EXECUTOR_MODULE, component))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(expectedError).in(component).onLine(30);
@@ -150,14 +166,14 @@
         "    }",
         "  }",
         "",
-        "  @ProductionComponent(modules = AModule.class)",
+        "  @ProductionComponent(modules = {ExecutorModule.class, AModule.class})",
         "  interface AComponent {",
         "    A getA();",
         "  }",
         "}");
     String expectedError =
         "test.TestClass.A is a provision entry-point, which cannot depend on a production.";
-    assertAbout(javaSource()).that(component)
+    assertAbout(javaSources()).that(ImmutableList.of(EXECUTOR_MODULE, component))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(expectedError).in(component).onLine(20);
@@ -198,20 +214,21 @@ public void monitoringDependsOnUnboundType() {
             "    }",
             "  }",
             "",
-            "  @ProductionComponent(modules = {MonitoringModule.class, StringModule.class})",
+            "  @ProductionComponent(",
+            "    modules = {ExecutorModule.class, MonitoringModule.class, StringModule.class}",
+            "  )",
             "  interface StringComponent {",
             "    ListenableFuture<String> getString();",
             "  }",
             "}");
     String expectedError =
         "test.TestClass.A cannot be provided without an @Provides-annotated method.";
-    assertAbout(javaSource())
-        .that(component)
+    assertAbout(javaSources()).that(ImmutableList.of(EXECUTOR_MODULE, component))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(expectedError)
         .in(component)
-        .onLine(33);
+        .onLine(35);
   }
 
   @Test
@@ -252,7 +269,9 @@ public void monitoringDependsOnProduction() {
             "    }",
             "  }",
             "",
-            "  @ProductionComponent(modules = {MonitoringModule.class, StringModule.class})",
+            "  @ProductionComponent(",
+            "    modules = {ExecutorModule.class, MonitoringModule.class, StringModule.class}",
+            "  )",
             "  interface StringComponent {",
             "    ListenableFuture<String> getString();",
             "  }",
@@ -261,30 +280,33 @@ public void monitoringDependsOnProduction() {
         "@Provides(type=SET) dagger.producers.monitoring.ProductionComponentMonitor.Factory"
             + " test.TestClass.MonitoringModule.monitorFactory(test.TestClass.A) is a provision,"
             + " which cannot depend on a production.";
-    assertAbout(javaSource())
-        .that(component)
+    assertAbout(javaSources()).that(ImmutableList.of(EXECUTOR_MODULE, component))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(expectedError)
         .in(component)
-        .onLine(36);
+        .onLine(38);
   }
   
   @Test
   public void cycleNotBrokenByMap() {
     JavaFileObject component =
         JavaFileObjects.forSourceLines(
-            "TestComponent",
+            "test.TestComponent",
+            "package test;",
+            "",
             "import com.google.common.util.concurrent.ListenableFuture;",
             "import dagger.producers.ProductionComponent;",
             "",
-            "@ProductionComponent(modules = TestModule.class)",
+            "@ProductionComponent(modules = {ExecutorModule.class, TestModule.class})",
             "interface TestComponent {",
             "  ListenableFuture<String> string();",
             "}");
     JavaFileObject module =
         JavaFileObjects.forSourceLines(
-            "TestModule",
+            "test.TestModule",
+            "package test;",
+            "",
             "import dagger.producers.ProducerModule;",
             "import dagger.producers.Produces;",
             "import dagger.multibindings.StringKey;",
@@ -303,29 +325,33 @@ public void cycleNotBrokenByMap() {
             "  }",
             "}");
     assertAbout(javaSources())
-        .that(ImmutableList.of(component, module))
+        .that(ImmutableList.of(EXECUTOR_MODULE, component, module))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining("cycle")
         .in(component)
-        .onLine(6);
+        .onLine(8);
   }
 
   @Test
   public void cycleNotBrokenByProducerMap() {
     JavaFileObject component =
         JavaFileObjects.forSourceLines(
-            "TestComponent",
+            "test.TestComponent",
+            "package test;",
+            "",
             "import com.google.common.util.concurrent.ListenableFuture;",
             "import dagger.producers.ProductionComponent;",
             "",
-            "@ProductionComponent(modules = TestModule.class)",
+            "@ProductionComponent(modules = {ExecutorModule.class, TestModule.class})",
             "interface TestComponent {",
             "  ListenableFuture<String> string();",
             "}");
     JavaFileObject module =
         JavaFileObjects.forSourceLines(
-            "TestModule",
+            "test.TestModule",
+            "package test;",
+            "",
             "import dagger.producers.Producer;",
             "import dagger.producers.ProducerModule;",
             "import dagger.producers.Produces;",
@@ -345,11 +371,11 @@ public void cycleNotBrokenByProducerMap() {
             "  }",
             "}");
     assertAbout(javaSources())
-        .that(ImmutableList.of(component, module))
+        .that(ImmutableList.of(EXECUTOR_MODULE, component, module))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining("cycle")
         .in(component)
-        .onLine(6);
+        .onLine(8);
   }
 }
