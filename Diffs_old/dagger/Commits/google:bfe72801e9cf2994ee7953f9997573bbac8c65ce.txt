diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/FooComponent.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/FooComponent.java
index f3021bd1a..afbc3f05f 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/FooComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/FooComponent.java
@@ -20,6 +20,7 @@
 import java.util.Set;
 import test.multipackage.a.AModule;
 import test.multipackage.a.UsesInaccessible;
+import test.multipackage.a.UsesInaccessibleInGenericsOnly;
 import test.multipackage.sub.FooChildComponent;
 
 /**
@@ -42,4 +43,6 @@
   FooChildComponent fooChildComponent();
 
   UsesInaccessible usesInaccessible();
+
+  UsesInaccessibleInGenericsOnly accessibleConstructorUsesInaccessibleInGenericsOnly();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/UsesInaccessible.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/UsesInaccessible.java
index 762492913..3ee3a5e06 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/UsesInaccessible.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/UsesInaccessible.java
@@ -23,7 +23,7 @@
 @SuppressWarnings("unused")
 public class UsesInaccessible {
   @Inject
-  UsesInaccessible(
+  public UsesInaccessible(
       Inaccessible inaccessible,
       Set<Inaccessible> inaccessibleSet,
       Map<String, Inaccessible> inaccessibleMap) {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/UsesInaccessibleInGenericsOnly.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/UsesInaccessibleInGenericsOnly.java
new file mode 100644
index 000000000..f212a0c66
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/UsesInaccessibleInGenericsOnly.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.multipackage.a;
+
+import java.util.Map;
+import java.util.Set;
+import javax.inject.Inject;
+
+@SuppressWarnings("unused")
+public class UsesInaccessibleInGenericsOnly {
+  @Inject
+  public UsesInaccessibleInGenericsOnly(
+      Set<Inaccessible> inaccessibleSet, Map<String, Inaccessible> inaccessibleMap) {}
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 3e92d661a..0b939a327 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -27,13 +27,10 @@
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.DELEGATED;
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.INITIALIZED;
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.UNINITIALIZED;
-import static dagger.internal.codegen.Accessibility.isElementAccessibleFrom;
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
 import static dagger.internal.codegen.BindingKey.contribution;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
-import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
-import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
 import static dagger.internal.codegen.FrameworkDependency.frameworkDependenciesForBinding;
 import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
@@ -128,10 +125,8 @@
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
 
-/**
- * Creates the implementation class for a component or subcomponent.
- */
-abstract class AbstractComponentWriter {
+/** Creates the implementation class for a component or subcomponent. */
+abstract class AbstractComponentWriter implements HasBindingMembers {
   private static final String NOOP_BUILDER_METHOD_JAVADOC =
       "This module is declared, but an instance is not used in the component. This method is a "
           + "no-op. For more, see https://google.github.io/dagger/unused-modules.\n";
@@ -149,7 +144,7 @@
   private final UniqueNameSet componentFieldNames = new UniqueNameSet();
   private final Map<BindingKey, MemberSelect> memberSelects = new HashMap<>();
   private final Map<BindingKey, MemberSelect> producerFromProviderMemberSelects = new HashMap<>();
-  private final Map<BindingKey, RequestFulfillment> requestFulfillments = Maps.newLinkedHashMap();
+  private final RequestFulfillmentRegistry requestFulfillmentRegistry;
   protected final MethodSpec.Builder constructor = constructorBuilder().addModifiers(PRIVATE);
   protected Optional<ClassName> builderName = Optional.absent();
   private final OptionalFactories optionalFactories;
@@ -187,6 +182,8 @@
     this.graph = graph;
     this.subcomponentNames = subcomponentNames;
     this.optionalFactories = optionalFactories;
+    this.requestFulfillmentRegistry =
+        new RequestFulfillmentRegistry(graph.resolvedBindings(), this);
   }
 
   protected AbstractComponentWriter(
@@ -260,7 +257,8 @@ private CodeBlock getMemberSelectExpression(BindingKey key) {
     return getMemberSelect(key).getExpressionFor(name);
   }
 
-  protected MemberSelect getMemberSelect(BindingKey key) {
+  @Override
+  public MemberSelect getMemberSelect(BindingKey key) {
     return memberSelects.get(key);
   }
 
@@ -688,41 +686,6 @@ private static ClassName frameworkMapFactoryClassName(BindingType bindingType) {
         ? MAP_OF_PRODUCER_PRODUCER : MAP_PROVIDER_FACTORY;
   }
 
-  // TODO(gak): extract this into a proper factory class
-  private RequestFulfillment createRequestFulfillment(BindingKey bindingKey) {
-    /* TODO(gak): it is super convoluted that we create the member selects separately and then
-     * look them up again this way. Now that we have RequestFulfillment, the next step is to
-     * create it and the MemberSelect and the field on demand rather than in a first pass. */
-    MemberSelect memberSelect = getMemberSelect(bindingKey);
-    ResolvedBindings resolvedBindings = graph.resolvedBindings().get(bindingKey);
-    switch (resolvedBindings.bindingType()) {
-      case MEMBERS_INJECTION:
-        return new MembersInjectorRequestFulfillment(bindingKey, memberSelect);
-      case PRODUCTION:
-        return new ProducerFieldRequestFulfillment(bindingKey, memberSelect);
-      case PROVISION:
-        ProvisionBinding provisionBinding =
-            (ProvisionBinding) resolvedBindings.contributionBinding();
-        ProviderFieldRequestFulfillment providerFieldRequestFulfillment =
-            new ProviderFieldRequestFulfillment(bindingKey, memberSelect);
-        if (provisionBinding.implicitDependencies().isEmpty()
-            && !provisionBinding.scope().isPresent()
-            && !provisionBinding.requiresModuleInstance()
-            && provisionBinding.bindingElement().isPresent()
-            && (provisionBinding.bindingKind().equals(INJECTION)
-                || provisionBinding.bindingKind().equals(PROVISION))
-            // TODO(gak): the accessibility limitation here needs to be addressed
-            && isElementAccessibleFrom(
-                provisionBinding.bindingElement().get(), name.packageName())) {
-          return new SimpleMethodRequestFulfillment(
-              bindingKey, provisionBinding, providerFieldRequestFulfillment);
-        }
-        return providerFieldRequestFulfillment;
-      default:
-        throw new AssertionError();
-    }
-  }
-
   private void implementInterfaceMethods() {
     Set<MethodSignature> interfaceMethods = Sets.newHashSet();
     for (ComponentMethodDescriptor componentMethod :
@@ -743,8 +706,7 @@ private void implementInterfaceMethods() {
           MethodSpec.Builder interfaceMethod =
               methodSpecForComponentMethod(methodElement, requestType);
           RequestFulfillment fulfillment =
-              requestFulfillments.computeIfAbsent(
-                  interfaceRequest.bindingKey(), this::createRequestFulfillment);
+              requestFulfillmentRegistry.getRequestFulfillment(interfaceRequest.bindingKey());
           CodeBlock codeBlock = fulfillment.getSnippetForDependencyRequest(interfaceRequest, name);
           switch (interfaceRequest.kind()) {
             case MEMBERS_INJECTOR:
diff --git a/compiler/src/main/java/dagger/internal/codegen/HasBindingMembers.java b/compiler/src/main/java/dagger/internal/codegen/HasBindingMembers.java
new file mode 100644
index 000000000..bc260d65d
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/HasBindingMembers.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import javax.annotation.Nullable;
+
+/** An object which associates a {@link MemberSelect} instance with a {@link BindingKey}. */
+// TODO(gak): this isn't a particularly good abstraction. This should go away when MS is reworked.
+interface HasBindingMembers {
+
+  /**
+   * Returns the {@link MemberSelect} associated with the given {@link BindingKey} or {@code null}
+   * if no association exists.
+   */
+  @Nullable
+  MemberSelect getMemberSelect(BindingKey bindingKey);
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/RequestFulfillmentRegistry.java b/compiler/src/main/java/dagger/internal/codegen/RequestFulfillmentRegistry.java
new file mode 100644
index 000000000..943ac5e4a
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/RequestFulfillmentRegistry.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.collect.Maps.newLinkedHashMapWithExpectedSize;
+import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
+import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
+
+import com.google.common.collect.ImmutableMap;
+import java.util.Map;
+
+/**
+ * A registry that associates a {@link BindingKey} with a {@link RequestFulfillment}. The registry
+ * is responsible for choosing the most appropriate {@link RequestFulfillment} implementation based
+ * on the properties of the binding and how it is used throughout the component.
+ */
+final class RequestFulfillmentRegistry {
+  private final ImmutableMap<BindingKey, ResolvedBindings> resolvedBindingsMap;
+  private final HasBindingMembers hasBindingMembers;
+  /** This map is mutated as {@link #getRequestFulfillment} is invoked. */
+  private final Map<BindingKey, RequestFulfillment> requestFulfillments;
+
+  RequestFulfillmentRegistry(
+      ImmutableMap<BindingKey, ResolvedBindings> resolvedBindingsMap,
+      HasBindingMembers hasBindingMembers) {
+    this.resolvedBindingsMap = resolvedBindingsMap;
+    this.hasBindingMembers = hasBindingMembers;
+    this.requestFulfillments = newLinkedHashMapWithExpectedSize(resolvedBindingsMap.size());
+  }
+
+  /** Returns a {@link RequestFulfillment} implementation for the given {@link BindingKey} */
+  RequestFulfillment getRequestFulfillment(BindingKey bindingKey) {
+    return requestFulfillments.computeIfAbsent(bindingKey, this::createRequestFulfillment);
+  }
+
+  private RequestFulfillment createRequestFulfillment(BindingKey bindingKey) {
+    /* TODO(gak): it is super convoluted that we create the member selects separately and then
+     * look them up again this way. Now that we have RequestFulfillment, the next step is to
+     * create it and the MemberSelect and the field on demand rather than in a first pass. */
+    MemberSelect memberSelect = hasBindingMembers.getMemberSelect(bindingKey);
+    ResolvedBindings resolvedBindings = resolvedBindingsMap.get(bindingKey);
+    switch (resolvedBindings.bindingType()) {
+      case MEMBERS_INJECTION:
+        return new MembersInjectorRequestFulfillment(bindingKey, memberSelect);
+      case PRODUCTION:
+        return new ProducerFieldRequestFulfillment(bindingKey, memberSelect);
+      case PROVISION:
+        ProvisionBinding provisionBinding =
+            (ProvisionBinding) resolvedBindings.contributionBinding();
+
+        ProviderFieldRequestFulfillment providerFieldRequestFulfillment =
+            new ProviderFieldRequestFulfillment(bindingKey, memberSelect);
+        if (provisionBinding.frameworkDependencies().isEmpty()
+            && !provisionBinding.scope().isPresent()
+            && !provisionBinding.requiresModuleInstance()
+            && provisionBinding.bindingElement().isPresent()
+            && (provisionBinding.bindingKind().equals(INJECTION)
+                || provisionBinding.bindingKind().equals(PROVISION))) {
+          return new SimpleMethodRequestFulfillment(
+              bindingKey, provisionBinding, providerFieldRequestFulfillment, this);
+        }
+        return providerFieldRequestFulfillment;
+      default:
+        throw new AssertionError();
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java b/compiler/src/main/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java
index 9eb91f534..987320a6c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java
@@ -19,12 +19,20 @@
 import static com.google.auto.common.MoreElements.asExecutable;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkState;
+import static dagger.internal.codegen.Accessibility.isElementAccessibleFrom;
+import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+import static java.util.stream.Collectors.toList;
 import static javax.lang.model.element.Modifier.STATIC;
 
 import com.google.common.util.concurrent.Futures;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.SimpleTypeVisitor8;
 
 /**
  * A request fulfillment implementation that invokes methods or constructors directly to fulfill
@@ -32,47 +40,116 @@
  * delegates to one that uses a {@link javax.inject.Provider}.
  */
 final class SimpleMethodRequestFulfillment extends RequestFulfillment {
+
   private final ProvisionBinding provisionBinding;
   private final RequestFulfillment providerDelegate;
+  private final RequestFulfillmentRegistry registry;
 
   SimpleMethodRequestFulfillment(
       BindingKey bindingKey,
       ProvisionBinding provisionBinding,
-      RequestFulfillment providerDelegate) {
+      RequestFulfillment providerDelegate,
+      RequestFulfillmentRegistry registry) {
     super(bindingKey);
-    checkArgument(provisionBinding.implicitDependencies().isEmpty());
+    checkArgument(
+        provisionBinding.frameworkDependencies().isEmpty(),
+        "framework deps are not currently supported");
     checkArgument(!provisionBinding.scope().isPresent());
     checkArgument(!provisionBinding.requiresModuleInstance());
     checkArgument(provisionBinding.bindingElement().isPresent());
     this.provisionBinding = provisionBinding;
     this.providerDelegate = providerDelegate;
+    this.registry = registry;
   }
 
   @Override
   CodeBlock getSnippetForDependencyRequest(DependencyRequest request, ClassName requestingClass) {
+    String requestingPackage = requestingClass.packageName();
+    /* This is where we do some checking to make sure we honor and/or dodge accessibility
+     * restrictions:
+     *
+     * 1. Check to make sure that the method/constructor that we're trying to invoke is accessible.
+     * 2. Check that the *raw type* of each parameter is accessible.  If something is only
+     *    inaccessible due to a type variable, we do a raw type cast just like we do for framework
+     *    types.
+     */
+    // TODO(gak): the accessibility limitation here needs to be addressed
+    if (!isElementAccessibleFrom(provisionBinding.bindingElement().get(), requestingPackage)
+        || provisionBinding
+            .dependencies()
+            .stream()
+            .anyMatch(
+                dependencyRequest ->
+                    !isRawTypeAccessible(dependencyRequest.key().type(), requestingPackage))) {
+      return providerDelegate.getSnippetForDependencyRequest(request, requestingClass);
+    }
     switch (request.kind()) {
       case INSTANCE:
-        return invokeMethod();
+        return invokeMethod(requestingClass);
       case FUTURE:
-        return CodeBlock.of("$T.immediateFuture($L)", Futures.class, invokeMethod());
+        return CodeBlock.of("$T.immediateFuture($L)", Futures.class, invokeMethod(requestingClass));
       default:
         return providerDelegate.getSnippetForDependencyRequest(request, requestingClass);
     }
   }
 
-  private CodeBlock invokeMethod() {
+  public static final SimpleTypeVisitor8<Boolean, String> RAW_TYPE_ACCESSIBILITY_VISITOR =
+      new SimpleTypeVisitor8<Boolean, String>() {
+        @Override
+        protected Boolean defaultAction(TypeMirror e, String requestingPackage) {
+          return isTypeAccessibleFrom(e, requestingPackage);
+        }
+
+        @Override
+        public Boolean visitDeclared(DeclaredType t, String requestingPackage) {
+          return isElementAccessibleFrom(t.asElement(), requestingPackage);
+        }
+      };
+
+  private static boolean isRawTypeAccessible(TypeMirror type, String requestingPackage) {
+    return type.accept(RAW_TYPE_ACCESSIBILITY_VISITOR, requestingPackage);
+  }
+
+  private CodeBlock invokeMethod(ClassName requestingClass) {
+    CodeBlock parametersCodeBlock =
+        CodeBlocks.makeParametersCodeBlock(
+            provisionBinding
+                .dependencies()
+                .stream()
+                .map(
+                    request -> {
+                      CodeBlock snippet =
+                          registry
+                              .getRequestFulfillment(request.bindingKey())
+                              .getSnippetForDependencyRequest(request, requestingClass);
+                      return isTypeAccessibleFrom(
+                              request.key().type(), requestingClass.packageName())
+                          ? snippet
+                          : CodeBlock.of(
+                              "($T) $L", rawTypeName(TypeName.get(request.key().type())), snippet);
+                    })
+                .collect(toList()));
     // we use the type from the key to ensure we get the right generics
     // TODO(gak): use <>?
     ExecutableElement method = asExecutable(provisionBinding.bindingElement().get());
     switch (method.getKind()) {
       case CONSTRUCTOR:
-        return CodeBlock.of("new $T()", provisionBinding.key().type());
+        return CodeBlock.of("new $T($L)", provisionBinding.key().type(), parametersCodeBlock);
       case METHOD:
         checkState(method.getModifiers().contains(STATIC));
         return CodeBlock.of(
-            "$T.$L()", provisionBinding.bindingTypeElement().get(), method.getSimpleName());
+            "$T.$L($L)",
+            provisionBinding.bindingTypeElement().get(),
+            method.getSimpleName(),
+            parametersCodeBlock);
       default:
         throw new IllegalStateException();
     }
   }
+
+  private static TypeName rawTypeName(TypeName typeName) {
+    return (typeName instanceof ParameterizedTypeName)
+        ? ((ParameterizedTypeName) typeName).rawType
+        : typeName;
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
index 7a4b7155f..9555ba055 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
@@ -92,7 +92,7 @@ protected InitializationState getInitializationState(BindingKey bindingKey) {
   }
 
   @Override
-  protected MemberSelect getMemberSelect(BindingKey key) {
+  public MemberSelect getMemberSelect(BindingKey key) {
     MemberSelect memberSelect = super.getMemberSelect(key);
     return memberSelect == null ? parent.getMemberSelect(key) : memberSelect;
   }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index 0c79fb47f..9a4ab1c2d 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -482,63 +482,64 @@
         "interface TestComponent {",
         "  A a();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import dagger.internal.Preconditions;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private Provider<B> bProvider;",
-        "  private Provider<A> aProvider;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.bProvider = TestModule_BFactory.create(builder.testModule,",
-        "        C_Factory.create());",
-        "    this.aProvider = A_Factory.create(bProvider);",
-        "  }",
-        "",
-        "  @Override",
-        "  public A a() {",
-        "    return aProvider.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private TestModule testModule;",
-        "",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public TestComponent build() {",
-        "      if (testModule == null) {",
-        "        this.testModule = new TestModule();",
-        "      }",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "",
-        "    public Builder testModule(TestModule testModule) {",
-        "      this.testModule = Preconditions.checkNotNull(testModule);",
-        "      return this;",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.internal.Preconditions;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private Provider<B> bProvider;",
+            "  private Provider<A> aProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.bProvider = TestModule_BFactory.create(builder.testModule,",
+            "        C_Factory.create());",
+            "    this.aProvider = A_Factory.create(bProvider);",
+            "  }",
+            "",
+            "  @Override",
+            "  public A a() {",
+            "    return new A(bProvider.get());",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private TestModule testModule;",
+            "",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      if (testModule == null) {",
+            "        this.testModule = new TestModule();",
+            "      }",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "",
+            "    public Builder testModule(TestModule testModule) {",
+            "      this.testModule = Preconditions.checkNotNull(testModule);",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(aFile, bFile, cFile, moduleFile, componentFile))
         .processedWith(new ComponentProcessor())
@@ -633,7 +634,7 @@ public void componentWithAbstractModule() {
             "",
             "  @Override",
             "  public A a() {",
-            "    return aProvider.get();",
+            "    return new A(TestModule.b(new C()));",
             "  }",
             "",
             "  public static final class Builder {",
@@ -1382,53 +1383,54 @@ public void testDefaultPackage() {
         "interface SimpleComponent {",
         "  SomeInjectableType someInjectableType();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerSimpleComponent",
-        "package test;",
-        "",
-        "import dagger.internal.InstanceFactory;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerSimpleComponent implements SimpleComponent {",
-        "  private Provider<SimpleComponent> simpleComponentProvider;",
-        "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
-        "",
-        "  private DaggerSimpleComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static SimpleComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.simpleComponentProvider = InstanceFactory.<SimpleComponent>create(this);",
-        "    this.someInjectableTypeProvider =",
-        "        SomeInjectableType_Factory.create(simpleComponentProvider);",
-        "  }",
-        "",
-        "  @Override",
-        "  public SomeInjectableType someInjectableType() {",
-        "    return someInjectableTypeProvider.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public SimpleComponent build() {",
-        "      return new DaggerSimpleComponent(this);",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerSimpleComponent",
+            "package test;",
+            "",
+            "import dagger.internal.InstanceFactory;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerSimpleComponent implements SimpleComponent {",
+            "  private Provider<SimpleComponent> simpleComponentProvider;",
+            "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
+            "",
+            "  private DaggerSimpleComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static SimpleComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.simpleComponentProvider = InstanceFactory.<SimpleComponent>create(this);",
+            "    this.someInjectableTypeProvider =",
+            "        SomeInjectableType_Factory.create(simpleComponentProvider);",
+            "  }",
+            "",
+            "  @Override",
+            "  public SomeInjectableType someInjectableType() {",
+            "    return new SomeInjectableType(simpleComponentProvider.get())",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public SimpleComponent build() {",
+            "      return new DaggerSimpleComponent(this);",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -1631,65 +1633,66 @@ public void testDefaultPackage() {
         "interface BComponent {",
         "  B b();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerBComponent",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import dagger.internal.Preconditions;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerBComponent implements BComponent {",
-        "  private Provider<A> aProvider;",
-        "  private Provider<B> bProvider;",
-        "",
-        "  private DaggerBComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.aProvider = new Factory<A>() {",
-        "      private final AComponent aComponent = builder.aComponent;",
-        "      @Override public A get() {",
-        "        return Preconditions.checkNotNull(aComponent.a(), " + NPE_LITERAL + ");",
-        "      }",
-        "    };",
-        "    this.bProvider = B_Factory.create(aProvider);",
-        "  }",
-        "",
-        "  @Override",
-        "  public B b() {",
-        "    return bProvider.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private AComponent aComponent;",
-        "",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public BComponent build() {",
-        "      if (aComponent == null) {",
-        "        throw new IllegalStateException(AComponent.class.getCanonicalName()",
-        "            + \" must be set\");",
-        "      }",
-        "      return new DaggerBComponent(this);",
-        "    }",
-        "",
-        "    public Builder aComponent(AComponent aComponent) {",
-        "      this.aComponent = Preconditions.checkNotNull(aComponent);",
-        "      return this;",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerBComponent",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import dagger.internal.Preconditions;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerBComponent implements BComponent {",
+            "  private Provider<A> aProvider;",
+            "  private Provider<B> bProvider;",
+            "",
+            "  private DaggerBComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.aProvider = new Factory<A>() {",
+            "      private final AComponent aComponent = builder.aComponent;",
+            "      @Override public A get() {",
+            "        return Preconditions.checkNotNull(aComponent.a(), " + NPE_LITERAL + ");",
+            "      }",
+            "    };",
+            "    this.bProvider = B_Factory.create(aProvider);",
+            "  }",
+            "",
+            "  @Override",
+            "  public B b() {",
+            "    return new B(aProvider.get());",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private AComponent aComponent;",
+            "",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public BComponent build() {",
+            "      if (aComponent == null) {",
+            "        throw new IllegalStateException(AComponent.class.getCanonicalName()",
+            "            + \" must be set\");",
+            "      }",
+            "      return new DaggerBComponent(this);",
+            "    }",
+            "",
+            "    public Builder aComponent(AComponent aComponent) {",
+            "      this.aComponent = Preconditions.checkNotNull(aComponent);",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(aFile, bFile, aComponentFile, bComponentFile))
         .processedWith(new ComponentProcessor())
@@ -1898,7 +1901,7 @@ public void testDefaultPackage() {
             "",
             "  @Override",
             "  public A a() {",
-            "    return aProvider.get();",
+            "    return new A(new B(new C()));",
             "  }",
             "",
             "  @Override",
@@ -1908,7 +1911,7 @@ public void testDefaultPackage() {
             "",
             "  @Override",
             "  public X x() {",
-            "    return xProvider.get();",
+            "    return new X(new C());",
             "  }",
             "",
             "  public static final class Builder {",
diff --git a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
index 4cf5a9122..da1eca604 100644
--- a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
@@ -49,14 +49,16 @@
       "  @Inject PrimitiveInjectable(int ignored) {}",
       "}");
 
-  JavaFileObject primitiveModule = JavaFileObjects.forSourceLines("test.PrimitiveModule",
-      "package test;",
-      "import dagger.Module;",
-      "import dagger.Provides;",
-      "@Module",
-      "class PrimitiveModule {",
-      "  @Provides int primitiveInt() { return Integer.MAX_VALUE; }",
-      "}");
+  JavaFileObject primitiveModule =
+      JavaFileObjects.forSourceLines(
+          "test.PrimitiveModule",
+          "package test;",
+          "import dagger.Module;",
+          "import dagger.Provides;",
+          "@Module",
+          "class PrimitiveModule {",
+          "  @Provides static int primitiveInt() { return Integer.MAX_VALUE; }",
+          "}");
 
   JavaFileObject component = JavaFileObjects.forSourceLines("test.PrimitiveComponent",
       "package test;",
@@ -68,69 +70,63 @@
       "  PrimitiveInjectable primitiveInjectable();",
       "}");
 
-  JavaFileObject expectedComponent = JavaFileObjects.forSourceLines(
-      "test.DaggerPrimitiveComponent",
-      "package test;",
-      "",
-      "import dagger.internal.Preconditions;",
-      "import javax.annotation.Generated;",
-      "import javax.inject.Provider;",
-      "",
-      GENERATED_ANNOTATION,
-      "public final class DaggerPrimitiveComponent implements PrimitiveComponent {",
-      "  private Provider<Integer> primitiveIntProvider;",
-      "  private Provider<PrimitiveInjectable> primitiveInjectableProvider;",
-      "",
-      "  private DaggerPrimitiveComponent(Builder builder) {",
-      "    assert builder != null;",
-      "    initialize(builder);",
-      "  }",
-      "",
-      "  public static Builder builder() {",
-      "    return new Builder();",
-      "  }",
-      "",
-      "  public static PrimitiveComponent create() {",
-      "    return builder().build();",
-      "  }",
-      "",
-      "  @SuppressWarnings(\"unchecked\")",
-      "  private void initialize(final Builder builder) {",
-      "    this.primitiveIntProvider =",
-      "        PrimitiveModule_PrimitiveIntFactory.create(builder.primitiveModule);",
-      "    this.primitiveInjectableProvider =",
-      "        PrimitiveInjectable_Factory.create(primitiveIntProvider);",
-      "  }",
-      "",
-      "  @Override",
-      "  public int primitiveInt() {",
-      "    return primitiveIntProvider.get();",
-      "  }",
-      "",
-      "  @Override",
-      "  public PrimitiveInjectable primitiveInjectable() {",
-      "    return primitiveInjectableProvider.get();",
-      "  }",
-      "",
-      "  public static final class Builder {",
-      "    private PrimitiveModule primitiveModule;",
-      "",
-      "    private Builder() {",
-      "    }",
-      "",
-      "    public PrimitiveComponent build() {",
-      "      if (primitiveModule == null) {",
-      "        this.primitiveModule = new PrimitiveModule();",
-      "      }",
-      "      return new DaggerPrimitiveComponent(this);",
-      "    }",
-      "",
-      "    public Builder primitiveModule(PrimitiveModule primitiveModule) {",
-      "      this.primitiveModule = Preconditions.checkNotNull(primitiveModule);",
-      "      return this;",
-      "    }",
-      "  }",
-      "}");
+  JavaFileObject expectedComponent =
+      JavaFileObjects.forSourceLines(
+          "test.DaggerPrimitiveComponent",
+          "package test;",
+          "",
+          "import dagger.internal.Preconditions;",
+          "import javax.annotation.Generated;",
+          "import javax.inject.Provider;",
+          "",
+          GENERATED_ANNOTATION,
+          "public final class DaggerPrimitiveComponent implements PrimitiveComponent {",
+          "  private Provider<PrimitiveInjectable> primitiveInjectableProvider;",
+          "",
+          "  private DaggerPrimitiveComponent(Builder builder) {",
+          "    assert builder != null;",
+          "    initialize(builder);",
+          "  }",
+          "",
+          "  public static Builder builder() {",
+          "    return new Builder();",
+          "  }",
+          "",
+          "  public static PrimitiveComponent create() {",
+          "    return builder().build();",
+          "  }",
+          "",
+          "  @SuppressWarnings(\"unchecked\")",
+          "  private void initialize(final Builder builder) {",
+          "    this.primitiveInjectableProvider = PrimitiveInjectable_Factory.create(",
+          "        PrimitiveModule_PrimitiveIntFactory.create());",
+          "  }",
+          "",
+          "  @Override",
+          "  public int primitiveInt() {",
+          "    return PrimitiveModule.primitiveInt();",
+          "  }",
+          "",
+          "  @Override",
+          "  public PrimitiveInjectable primitiveInjectable() {",
+          "    return new PrimitiveInjectable(PrimitiveModule.primitiveInt());",
+          "  }",
+          "",
+          "  public static final class Builder {",
+          "",
+          "    private Builder() {}",
+          "",
+          "    public PrimitiveComponent build() {",
+          "      return new DaggerPrimitiveComponent(this);",
+          "    }",
+          "",
+          "    @Deprecated",
+          "    public Builder primitiveModule(PrimitiveModule primitiveModule) {",
+          "      Preconditions.checkNotNull(primitiveModule);",
+          "      return this;",
+          "    }",
+          "  }",
+          "}");
 
   @Test public void primitiveArrayTypesAllInjected() {
     assertAbout(javaSources())
