diff --git a/doc/Dagger & Android.md b/doc/Dagger & Android.md
new file mode 100644
index 000000000..5d495c712
--- /dev/null
+++ b/doc/Dagger & Android.md	
@@ -0,0 +1,218 @@
+One of the primary advantages of Dagger 2 over most other dependency injection frameworks is that its strictly generated implementation (no reflection) means that it can be used in Android applications. However, there are still some considerations to be made when using Dagger within Android applications.
+
+## Philosophy
+
+While code written for Android is Java source, it is often quite different in terms of style. Typically, such differences exist to accomodate the unique performance considerations of a mobile platform.
+
+But many of the patterns commonly applied to code intended for Android are contrary to those applied to other Java code. Even much of the advice in Effective Java is considered inappropriate for Android.
+
+In order to achieve the goals of both idiomatic and portable code, Dagger relies on ProGuard to post-process the compiled bytecode. This allows Dagger to emit source that looks and feels natural on both the server and Android, while using the different toolchains to produce bytecode that executes efficiently in both environements. Moreover, Dagger has an explicit goal to ensure that the Java source that it generates is consistently compatible with ProGuard optimizations.
+
+Of course, not all issues can be addressed in that manner, but it is the primary mechanism by which Android-specific compatbility will be provided.
+
+tl;dr
+Dagger assumes that users on Android will use ProGuard.
+
+## Recommended ProGuard Settings
+
+Watch this space for ProGuard settings that are relevant to applications using Dagger.
+
+### dagger.android
+
+One of the central difficulties of writing an Android application using Dagger is that many Android framework classes are instantiated by the OS itself, like Activity and Fragment, but Dagger works best if it can create all the injected objects. Instead, you have to perform members injection in a lifecycle method. This means many classes end up looking like:
+
+```
+public class FrombulationActivity extends Activity {
+  @Inject Frombulator frombulator;
+
+  @Override
+  public void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    // DO THIS FIRST. Otherwise frombulator might be null!
+    ((SomeApplicationBaseType) getContext().getApplicationContext())
+        .getApplicationComponent()
+        .newActivityComponentBuilder()
+        .activity(this)
+        .build()
+        .inject(this);
+    // ... now you can write the exciting code
+  }
+}
+```
+This has a few problems:
+
+- Copy-pasting code makes it hard to refactor later on. As more and more developers copy-paste that block, fewer will know what it actually does.
+
+- More fundamentally, it requires the type requesting injection (FrombulationActivity) to know about its injector. Even if this is done through interfaces instead of concrete types, it breaks a core principle of dependency injection: a class shouldn’t know anything about how it is injected.
+
+The classes in dagger.android offer one approach to simplify this pattern.
+
+### Injecting Activity objects
+
+- Install AndroidInjectionModule in your application component to ensure that all bindings necessary for these base types are available.
+
+- Start off by writing a @Subcomponent that implements AndroidInjector<YourActivity>, with a @Subcomponent.Builder that extends AndroidInjector.Builder<YourActivity>:
+
+```
+@Subcomponent(modules = ...)
+public interface YourActivitySubcomponent extends AndroidInjector<YourActivity> {
+  @Subcomponent.Builder
+  public abstract class Builder extends AndroidInjector.Builder<YourActivity> {}
+}
+```
+
+- After defining the subcomponent, add it to your component hierarchy by defining a module that binds the subcomponent builder and adding it to the component that injects your Application:
+
+```
+@Module(subcomponents = YourActivitySubcomponent.class)
+abstract class YourActivityModule {
+  @Binds
+  @IntoMap
+  @ClassKey(YourActivity.class)
+  abstract AndroidInjector.Factory<?>
+      bindYourActivityInjectorFactory(YourActivitySubcomponent.Builder builder);
+}
+
+@Component(modules = {..., YourActivityModule.class})
+interface YourApplicationComponent {}
+```
+
+Pro-tip: If your subcomponent and its builder have no other methods or supertypes than the ones mentioned in step #2, you can use @ContributesAndroidInjector to generate them for you. Instead of steps 2 and 3, add an abstract module method that returns your activity, annotate it with @ContributesAndroidInjector, and specify the modules you want to install into the subcomponent. If the subcomponent needs scopes, apply the scope annotations to the method as well.
+
+```
+@ActivityScope
+@ContributesAndroidInjector(modules = { /* modules to install into the subcomponent */ })
+abstract YourActivity contributeYourActivityInjector();
+```
+- Next, make your Application implement HasActivityInjector and @Inject a DispatchingAndroidInjector<Activity> to return from the activityInjector() method:
+
+```
+public class YourApplication extends Application implements HasActivityInjector {
+  @Inject DispatchingAndroidInjector<Activity> dispatchingActivityInjector;
+
+  @Override
+  public void onCreate() {
+    super.onCreate();
+    DaggerYourApplicationComponent.create()
+        .inject(this);
+  }
+
+  @Override
+  public AndroidInjector<Activity> activityInjector() {
+    return dispatchingActivityInjector;
+  }
+}
+```
+- Finally, in your Activity.onCreate() method, call AndroidInjection.inject(this) before calling super.onCreate();:
+
+```
+public class YourActivity extends Activity {
+  public void onCreate(Bundle savedInstanceState) {
+    AndroidInjection.inject(this);
+    super.onCreate(savedInstanceState);
+  }
+}
+```
+- Congratulations!
+
+### How did that work?
+
+AndroidInjection.inject() gets a DispatchingAndroidInjector<Activity> from the Application and passes your activity to inject(Activity). The DispatchingAndroidInjector looks up the AndroidInjector.Factory for your activity’s class (which is YourActivitySubcomponent.Builder), creates the AndroidInjector (which is YourActivitySubcomponent), and passes your activity to inject(YourActivity).
+
+### Injecting Fragment objects
+
+Injecting a Fragment is just as simple as injecting an Activity. Define your subcomponent in the same way and replace HasActivityInjector with HasFragmentInjector.
+
+Instead of injecting in onCreate() as is done for Activity types, inject Fragments to in onAttach().
+
+Unlike the modules defined for Activitys, you have a choice of where to install modules for Fragments. You can make your Fragment component a subcomponent of another Fragment component, an Activity component, or the Application component — it all depends on which other bindings your Fragment requires. After deciding on the component location, make the corresponding type implement HasFragmentInjector. For example, if your Fragment needs bindings from YourActivitySubcomponent, your code will look something like this:
+
+```
+public class YourActivity extends Activity
+    implements HasFragmentInjector {
+  @Inject DispatchingAndroidInjector<Fragment> fragmentInjector;
+
+  @Override
+  public void onCreate(Bundle savedInstanceState) {
+    AndroidInjection.inject(this);
+    super.onCreate(savedInstanceState);
+    // ...
+  }
+
+  @Override
+  public AndroidInjector<Fragment> fragmentInjector() {
+    return fragmentInjector;
+  }
+}
+
+public class YourFragment extends Fragment {
+  @Inject SomeDependency someDep;
+
+  @Override
+  public void onAttach(Activity activity) {
+    AndroidInjection.inject(this);
+    super.onAttach(activity);
+    // ...
+  }
+}
+
+@Subcomponent(modules = ...)
+public interface YourFragmentSubcomponent extends AndroidInjector<YourFragment> {
+  @Subcomponent.Builder
+  public abstract class Builder extends AndroidInjector.Builder<YourFragment> {}
+}
+
+@Module(subcomponents = YourFragmentSubcomponent.class)
+abstract class YourFragmentModule {
+  @Binds
+  @IntoMap
+  @ClassKey(YourFragment.class)
+  abstract AndroidInjector.Factory<?>
+      bindYourFragmentInjectorFactory(YourFragmentSubcomponent.Builder builder);
+}
+
+@Subcomponent(modules = { YourFragmentModule.class, ... }
+public interface YourActivityOrYourApplicationComponent { ... }
+```
+
+### Base Framework Types
+
+Because DispatchingAndroidInjector looks up the appropriate AndroidInjector.Factory by the class at runtime, a base class can implement HasActivityInjector/HasFragmentInjector/etc as well as call AndroidInjection.inject(). All each subclass needs to do is bind a corresponding @Subcomponent. Dagger provides a few base types that do this, such as DaggerActivity and DaggerFragment, if you don’t have a complicated class hierarchy. Dagger also provides a DaggerApplication for the same purpose — all you need to do is to extend it and override the applicationInjector() method to return the component that should inject the Application.
+
+The following types are also included:
+
+- DaggerService and DaggerIntentService
+- DaggerBroadcastReceiver
+- DaggerContentProvider
+
+Note: DaggerBroadcastReceiver should only be used when the BroadcastReceiver is registered in the AndroidManifest.xml. When the BroadcastReceiver is created in your own code, prefer constructor injection instead.
+
+###Support libraries
+
+For users of the Android support library, parallel types exist in the dagger.android.support package.
+
+> TODO(ronshapiro): we should begin to split this up by androidx packages
+
+### How do I get it?
+
+Add the following to your build.gradle:
+
+```
+dependencies {
+  compile 'com.google.dagger:dagger-android:2.x'
+  compile 'com.google.dagger:dagger-android-support:2.x' // if you use the support libraries
+  annotationProcessor 'com.google.dagger:dagger-android-processor:2.x'
+}
+```
+
+## When to inject
+
+Constructor injection is preferred whenever possible because javac will ensure that no field is referenced before it has been set, which helps avoid NullPointerExceptions. When members injection is required (as discussed above), prefer to inject as early as possible. For this reason, DaggerActivity calls AndroidInjection.inject() immediately in onCreate(), before calling super.onCreate(), and DaggerFragment does the same in onAttach(), which also prevents inconsistencies if the Fragment is reattached.
+
+It is crucial to call AndroidInjection.inject() before super.onCreate() in an Activity, since the call to super attaches Fragments from the previous activity instance during configuration change, which in turn injects the Fragments. In order for the Fragment injection to succeed, the Activity must already be injected. For users of ErrorProne, it is a compiler error to call AndroidInjection.inject() after super.onCreate().
+
+## FAQ
+
+### Scoping AndroidInjector.Factory
+
+AndroidInjector.Factory is intended to be a stateless interface so that implementors don’t have to worry about managing state related to the object which will be injected. When DispatchingAndroidInjector requests a AndroidInjector.Factory, it does so through a Provider so that it doesn’t explicitly retain any instances of the factory. Because the AndroidInjector.Builder implementation that is generated by Dagger does retain an instance of the Activity/Fragment/etc that is being injected, it is a compile-time error to apply a scope to the methods which provide them. If you are positive that your AndroidInjector.Factory does not retain an instance to the injected object, you may suppress this error by applying @SuppressWarnings("dagger.android.ScopedInjectoryFactory") to your module method.
\ No newline at end of file
diff --git a/doc/Multibindings.md b/doc/Multibindings.md
new file mode 100644
index 000000000..521765f41
--- /dev/null
+++ b/doc/Multibindings.md
@@ -0,0 +1,379 @@
+Dagger allows you to bind several objects into a collection even when the objects are bound in different modules using multibindings. Dagger assembles the collection so that application code can inject it without depending directly on the individual bindings.
+
+You could use multibindings to implement a plugin architecture, for example, where several modules can contribute individual plugin interface implementations so that a central class can use the entire set of plugins. Or you could have several modules contribute individual service providers to a map, keyed by name.
+
+### Set multibindings
+
+In order to contribute one element to an injectable multibound set, add an @IntoSet annotation to your module method:
+
+```
+@Module
+class MyModuleA {
+  @Provides @IntoSet
+  static String provideOneString(DepA depA, DepB depB) {
+    return "ABC";
+  }
+}
+```
+You can also contribute several elements at one time by adding a module method that returns a subset and is annotated with @ElementsIntoSet:
+
+```
+@Module
+class MyModuleB {
+  @Provides @ElementsIntoSet
+  static Set<String> provideSomeStrings(DepA depA, DepB depB) {
+    return new HashSet<String>(Arrays.asList("DEF", "GHI"));
+  }
+}
+```
+Now a binding in that component can depend on the set:
+
+```
+class Bar {
+  @Inject Bar(Set<String> strings) {
+    assert strings.contains("ABC");
+    assert strings.contains("DEF");
+    assert strings.contains("GHI");
+  }
+}
+```
+Or the component can provide the set:
+
+```
+@Component(modules = {MyModuleA.class, MyModuleB.class})
+interface MyComponent {
+  Set<String> strings();
+}
+
+@Test void testMyComponent() {
+  MyComponent myComponent = DaggerMyComponent.create();
+  assertThat(myComponent.strings()).containsExactly("ABC", "DEF", "GHI");
+}
+```
+As with any other binding, in addition to depending on a multibound Set<Foo>, you can also depend on Provider<Set<Foo>> or Lazy<Set<Foo>>. You cannot, however, depend on Set<Provider<Foo>>.
+
+To contribute to a qualified multibound set, annotate each @Provides method with the qualifier:
+
+```
+@Module
+class MyModuleC {
+  @Provides @IntoSet
+  @MyQualifier
+  static Foo provideOneFoo(DepA depA, DepB depB) {
+    return new Foo(depA, depB);
+  }
+}
+
+@Module
+class MyModuleD {
+  @Provides
+  static FooSetUser provideFooSetUser(@MyQualifier Set<Foo> foos) { ... }
+}
+```
+
+## Map multibindings
+
+Dagger lets you use multibindings to contribute entries to an injectable map as long as the map keys are known at compile time.
+
+To contribute an entry to a multibound map, add a method to a module that returns the value and is annotated with @IntoMap and with another custom annotation that specifies the map key for that entry. To contribute an entry to a qualified multibound map, annotate each @IntoMap method with the qualifier.
+
+Then you can inject either the map itself (Map<K, V>) or a map containing value providers (Map<K, Provider<V>>). The latter is useful when you don’t want all of the values to be instantiated because you’re going to extract one value at a time, or because you want to get a potentially new instance of each value each time you query the map.
+
+### Simple map keys
+
+For maps with keys that are strings, Class<?>, or boxed primitives, use one of the standard annotations in dagger.multibindings:
+
+```
+@Module
+class MyModule {
+  @Provides @IntoMap
+  @StringKey("foo")
+  static Long provideFooValue() {
+    return 100L;
+  }
+
+  @Provides @IntoMap
+  @ClassKey(Thing.class)
+  static String provideThingValue() {
+    return "value for Thing";
+  }
+}
+
+@Component(modules = MyModule.class)
+interface MyComponent {
+  Map<String, Long> longsByString();
+  Map<Class<?>, String> stringsByClass();
+}
+
+@Test void testMyComponent() {
+  MyComponent myComponent = DaggerMyComponent.create();
+  assertThat(myComponent.longsByString().get("foo")).isEqualTo(100L);
+  assertThat(myComponent.stringsByClass().get(Thing.class))
+      .isEqualTo("value for Thing");
+}
+```
+For maps with keys that are enums or a more specifically parameterized class, write an annotation type with one member whose type is the map key type, and annotate it with @MapKey:
+
+```
+enum MyEnum {
+  ABC, DEF;
+}
+
+@MapKey
+@interface MyEnumKey {
+  MyEnum value();
+}
+
+@MapKey
+@interface MyNumberClassKey {
+  Class<? extends Number> value();
+}
+
+@Module
+class MyModule {
+  @Provides @IntoMap
+  @MyEnumKey(MyEnum.ABC)
+  static String provideABCValue() {
+    return "value for ABC";
+  }
+
+  @Provides @IntoMap
+  @MyNumberClassKey(BigDecimal.class)
+  static String provideBigDecimalValue() {
+    return "value for BigDecimal";
+  }
+}
+
+@Component(modules = MyModule.class)
+interface MyComponent {
+  Map<MyEnum, String> myEnumStringMap();
+  Map<Class<? extends Number>, String> stringsByNumberClass();
+}
+
+@Test void testMyComponent() {
+  MyComponent myComponent = DaggerMyComponent.create();
+  assertThat(myComponent.myEnumStringMap().get(MyEnum.ABC)).isEqualTo("value for ABC");
+  assertThat(myComponent.stringsByNumberClass.get(BigDecimal.class))
+      .isEqualTo("value for BigDecimal");
+}
+```
+Your annotation’s single member can be any valid annotation member type except for arrays, and can have any name.
+
+### Complex map keys
+
+If your map’s key is more than can be expressed by a single annotation member, you can use the entire annotation as the map key by setting @MapKey’s unwrapValue to false. In that case, the annotation can have array members as well.
+
+```
+@MapKey(unwrapValue = false)
+@interface MyKey {
+  String name();
+  Class<?> implementingClass();
+  int[] thresholds();
+}
+
+@Module
+class MyModule {
+  @Provides @IntoMap
+  @MyKey(name = "abc", implementingClass = Abc.class, thresholds = {1, 5, 10})
+  static String provideAbc1510Value() {
+    return "foo";
+  }
+}
+
+@Component(modules = MyModule.class)
+interface MyComponent {
+  Map<MyKey, String> myKeyStringMap();
+}
+```
+
+### Using @AutoAnnotation to create annotation instances
+
+If your map uses complex keys, then you may need to create an instance of your @MapKey annotation at run-time to pass to the map’s get(Object) method. The easiest way to do that is to use the @AutoAnnotation annotation to create a static method that instantiates your annotation. See @AutoAnnotation’s documentation for more details.
+
+```
+class MyComponentTest {
+  @Test void testMyComponent() {
+    MyComponent myComponent = DaggerMyComponent.create();
+    assertThat(myComponent.myKeyStringMap()
+        .get(createMyKey("abc", Abc.class, new int[] {1, 5, 10}))
+        .isEqualTo("foo");
+  }
+
+  @AutoAnnotation
+  static MyKey createMyKey(String name, Class<?> implementingClass, int[] thresholds) {
+    return new AutoAnnotation_MyComponentTest_createMyKey(name, implementingClass, thresholds);
+  }
+}
+```
+
+### Maps whose keys are not known at compile time
+
+Map multibindings work only if your map’s keys are known at compile time and can be expressed in an annotation. If your map’s keys don’t fit in those constraints, then you cannot create a multibound map, but you can work around that by using set multibindings to bind a set of objects that you can then transform into a non-multibound map.
+
+```
+@Module
+class MyModule {
+  @Provides @IntoSet
+  static Map.Entry<Foo, Bar> entryOne(...) {
+    Foo key = ...;
+    Bar value = ...;
+    return new SimpleImmutableEntry(key, value);
+  }
+
+  @Provides @IntoSet
+  static Map.Entry<Foo, Bar> entryTwo(...) {
+    Foo key = ...;
+    Bar value = ...;
+    return new SimpleImmutableEntry(key, value);
+  }
+}
+
+@Module
+class MyMapModule {
+  @Provides
+  static Map<Foo, Bar> fooBarMap(Set<Map.Entry<Foo, Bar>> entries) {
+    Map<Foo, Bar> fooBarMap = new LinkedHashMap<>(entries.size());
+    for (Map.Entry<Foo, Bar> entry : entries) {
+      fooBarMap.put(entry.getKey(), entry.getValue());
+    }
+    return fooBarMap;
+  }
+}
+```
+Note that this technique does not give you the automatic binding of Map<Foo, Provider<Bar>> as well. If you want a map of providers, the Map.Entry objects in your multibound set should include the providers. Then your non-multibound map can have Provider values.
+
+```
+@Module
+class MyModule {
+  @Provides @IntoSet
+  static Map.Entry<Foo, Provider<Bar>> entry(
+      Provider<BarSubclass> barSubclassProvider) {
+    Foo key = ...;
+    return new SimpleImmutableEntry(key, barSubclassProvider);
+  }
+}
+
+@Module
+class MyProviderMapModule {
+  @Provides
+  static Map<Foo, Provider<Bar>> fooBarProviderMap(
+      Set<Map.Entry<Foo, Provider<Bar>>> entries) {
+    return ...;
+  }
+}
+```
+
+## Declaring multibindings
+
+You can declare that a multibound set or map is bound by adding an abstract @Multibinds-annotated method to a module that returns the set or map you want to declare.
+
+You do not have to use @Multibinds for sets or maps that have at least one @IntoSet, @ElementsIntoSet, or @IntoMap binding, but you do have to declare them if they may be empty.
+
+```
+@Module
+abstract class MyModule {
+  @Multibinds abstract Set<Foo> aSet();
+  @Multibinds @MyQualifier abstract Set<Foo> aQualifiedSet();
+  @Multibinds abstract Map<String, Foo> aMap();
+  @Multibinds @MyQualifier abstract Map<String, Foo> aQualifiedMap();
+}
+```
+A given set or map multibinding can be declared any number of times without error. Dagger never implements or calls any @Multibinds methods.
+
+Alternative: @ElementsIntoSet returning an empty set
+For empty sets only, as an alternative, you can add a @ElementsIntoSet method that returns an empty set:
+
+```
+@Module
+class MyEmptySetModule {
+  @Provides @ElementsIntoSet
+  static Set<Foo> primeEmptyFooSet() {
+    return Collections.emptySet();
+  }
+}
+```
+
+### Inherited subcomponent multibindings
+
+A binding in a subcomponent can depend on a multibound set or map from its parent, just as it can depend on any other binding from its parent. But a subcomponent can add elements to multibound sets or maps that are bound in its parent as well, by simply including the appropriate @Provides methods in its modules.
+
+When that happens, the set or map is different depending on where it is injected. When it is injected into a binding defined on the subcomponent, then it has the values or entries defined by the subcomponent’s multibindings as well as those defined by the parent component’s multibindings. When it is injected into a binding defined on the parent component, it has only the values or entries defined there.
+
+```java
+@Component(modules = ParentModule.class)
+interface ParentComponent {
+  Set<String> strings();
+  Map<String, String> stringMap();
+  ChildComponent childComponent();
+}
+
+@Module
+class ParentModule {
+  @Provides @IntoSet
+  static String string1() {
+    "parent string 1";
+  }
+
+  @Provides @IntoSet
+  static String string2() {
+    "parent string 2";
+  }
+
+  @Provides @IntoMap
+  @StringKey("a")
+  static String stringA() {
+    "parent string A";
+  }
+
+  @Provides @IntoMap
+  @StringKey("b")
+  static String stringB() {
+    "parent string B";
+  }
+}
+
+@Subcomponent(modules = ChildModule.class)
+interface ChildComponent {
+  Set<String> strings();
+  Map<String, String> stringMap();
+}
+
+@Module
+class ChildModule {
+  @Provides @IntoSet
+  static String string3() {
+    "child string 3";
+  }
+
+  @Provides @IntoSet
+  static String string4() {
+    "child string 4";
+  }
+
+  @Provides @IntoMap
+  @StringKey("c")
+  static String stringC() {
+    "child string C";
+  }
+
+  @Provides @IntoMap
+  @StringKey("d")
+  static String stringD() {
+    "child string D";
+  }
+}
+
+@Test void testMultibindings() {
+  ParentComponent parentComponent = DaggerParentComponent.create();
+  assertThat(parentComponent.strings()).containsExactly(
+      "parent string 1", "parent string 2");
+  assertThat(parentComponent.stringMap().keySet()).containsExactly("a", "b");
+
+  ChildComponent childComponent = parentComponent.childComponent();
+  assertThat(childComponent.strings()).containsExactly(
+      "parent string 1", "parent string 2", "child string 3", "child string 4");
+  assertThat(childComponent.stringMap().keySet()).containsExactly(
+      "a", "b", "c", "d");
+}
+```
+
diff --git a/doc/User's Guide.md b/doc/User's Guide.md
new file mode 100644
index 000000000..a4fc7973b
--- /dev/null
+++ b/doc/User's Guide.md	
@@ -0,0 +1,404 @@
+任何应用程序中最好的类是那些做的东西：BarcodeDecoder，KoopaPhysicsEngine和AudioStreamer。 这些类有依赖关系; 也许是BarcodeCameraFinder，DefaultPhysicsEngine和HttpStreamer。
+
+相比之下，任何应用程序中最差的类都是占用空间而没有做太多的类：BarcodeDecoderFactory，CameraServiceLoader和MutableContextWrapper。 这些类是笨拙的胶带，将有趣的东西连接在一起。
+
+Dagger是这些FactoryFactory类的替代品，它们实现了依赖注入设计模式，而没有编写样板文件的负担。 它允许您专注于有趣的类。声明依赖项，指定如何满足它们，并发送您的应用程序。
+
+通过构建标准的javax.inject注释（JSR 330），每个类都很容易测试。 您不需要一堆样板来将RpcCreditCardService换成FakeCreditCardService。
+
+依赖注入不仅仅用于测试。它还可以轻松创建可重复使用的可互换模块。您可以在所有应用中共享相同的AuthenticationModule。您可以在开发期间运行DevLoggingModule，在生产中运行ProdLoggingModule以在每种情况下获得正确的行为。
+
+### 为什么Dagger2不同
+
+依赖注入框架已存在多年，其中包含各种用于配置和注入的API。那么，为什么重新发明轮子呢？Dagger2是第一个用生成的代码实现完整堆栈的人。指导原则是生成代码，该代码模仿用户可能手写的代码，以确保依赖注入尽可能简单，可追踪和高效。 有关设计的更多背景，请观看+ Gregory Kick的演讲（幻灯片）。
+
+## 使用Dagger
+
+我们将通过建立咖啡机来展示依赖注入和Dagger。有关可以编译和运行的完整示例代码，请参阅Dagger的咖啡示例。
+
+### 声明依赖关系
+
+Dagger构造应用程序类的实例并满足它们的依赖关系。它使用javax.inject.Inject批注来标识它感兴趣的构造函数和字段。
+
+使用@Inject注释Dagger应该用来创建类实例的构造函数。 当请求新实例时，Dagger将获取所需的参数值并调用此构造函数。
+
+```
+class Thermosiphon implements Pump {
+  private final Heater heater;
+
+  @Inject
+  Thermosiphon(Heater heater) {
+    this.heater = heater;
+  }
+  ...
+}
+```
+
+Dagger可以直接注入字段。 在此示例中，它获取heater字段的Heater实例和pump字段的Pump实例。
+
+```
+class CoffeeMaker {
+  @Inject Heater heater;
+  @Inject Pump pump;
+
+  ...
+}
+```
+
+如果您的类具有@Inject-annotated字段但没有@Inject-annotated构造函数，则Dagger将在请求时注入这些字段，但不会创建新实例。 添加带有@Inject批注的无参数构造函数，以指示Dagger也可以创建实例。
+
+Dagger也支持方法注入，但通常首选构造函数或字段注入。
+
+缺少@Inject注释的类不能由Dagger构造。
+
+### 满足依赖性
+
+默认情况下，Dagger通过构造所请求类型的实例来满足每个依赖关系，如上所述。 当您请求CoffeeMaker时，它将通过调用新的CoffeeMaker()并设置其可注入字段来获取一个。
+
+但@Inject无处不在：
+
+- 无法构造接口。
+- 无法注释第三方类。
+- 必须配置可配置对象！
+
+对于@Inject不足或笨拙的情况，请使用@Provide-annotated方法来满足依赖关系。方法的返回类型定义了它满足的依赖关系。
+
+For example, provideHeater() is invoked whenever a Heater is required:
+
+```
+@Provides static Heater provideHeater() {
+  return new ElectricHeater();
+}
+```
+It’s possible for @Provides methods to have dependencies of their own. This one returns a Thermosiphon whenever a Pump is required:
+
+```
+@Provides static Pump providePump(Thermosiphon pump) {
+  return pump;
+}
+```
+All @Provides methods must belong to a module. These are just classes that have an @Module annotation.
+
+```
+@Module
+class DripCoffeeModule {
+  @Provides static Heater provideHeater() {
+    return new ElectricHeater();
+  }
+
+  @Provides static Pump providePump(Thermosiphon pump) {
+    return pump;
+  }
+}
+```
+
+By convention, @Provides methods are named with a provide prefix and module classes are named with a Module suffix.
+
+### 构建图表
+
+The @Inject and @Provides-annotated classes form a graph of objects, linked by their dependencies. Calling code like an application’s main method or an Android Application accesses that graph via a well-defined set of roots. In Dagger 2, that set is defined by an interface with methods that have no arguments and return the desired type. By applying the @Component annotation to such an interface and passing the module types to the modules parameter, Dagger 2 then fully generates an implementation of that contract.
+
+```
+@Component(modules = DripCoffeeModule.class)
+interface CoffeeShop {
+  CoffeeMaker maker();
+}
+```
+
+The implementation has the same name as the interface prefixed with Dagger. Obtain an instance by invoking the builder() method on that implementation and use the returned builder to set dependencies and build() a new instance.
+
+```
+CoffeeShop coffeeShop = DaggerCoffeeShop.builder()
+    .dripCoffeeModule(new DripCoffeeModule())
+    .build();
+```
+Note: If your @Component is not a top-level type, the generated component’s name will include its enclosing types’ names, joined with an underscore. For example, this code:
+
+```
+class Foo {
+  static class Bar {
+    @Component
+    interface BazComponent {}
+  }
+}
+```
+would generate a component named DaggerFoo_Bar_BazComponent.
+
+Any module with an accessible default constructor can be elided as the builder will construct an instance automatically if none is set. And for any module whose @Provides methods are all static, the implementation doesn’t need an instance at all. If all dependencies can be constructed without the user creating a dependency instance, then the generated implementation will also have a create() method that can be used to get a new instance without having to deal with the builder.
+
+```
+CoffeeShop coffeeShop = DaggerCoffeeShop.create();
+```
+Now, our CoffeeApp can simply use the Dagger-generated implementation of CoffeeShop to get a fully-injected CoffeeMaker.
+
+```
+public class CoffeeApp {
+  public static void main(String[] args) {
+    CoffeeShop coffeeShop = DaggerCoffeeShop.create();
+    coffeeShop.maker().brew();
+  }
+}
+```
+Now that the graph is constructed and the entry point is injected, we run our coffee maker app. Fun.
+
+```
+$ java -cp ... coffee.CoffeeApp
+~ ~ ~ heating ~ ~ ~
+=> => pumping => =>
+ [_]P coffee! [_]P
+```
+
+### Bindings in the graph
+
+The example above shows how to construct a component with some of the more typical bindings, but there are a variety of mechanisms for contributing bindings to the graph. The following are available as dependencies and may be used to generate a well-formed component:
+
+- Those declared by @Provides methods within a @Module referenced directly by @Component.modules or transitively via @Module.includes
+- Any type with an @Inject constructor that is unscoped or has a @Scope annotation that matches one of the component’s scopes
+- The component provision methods of the component dependencies
+- The component itself
+- Unqualified builders for any included subcomponent
+- Provider or Lazy wrappers for any of the above bindings
+- A Provider of a Lazy of any of the above bindings (e.g., Provider<Lazy<CoffeeMaker>>)
+- A MembersInjector for any type
+
+## Singletons and Scoped Bindings
+
+Annotate an @Provides method or injectable class with @Singleton. The graph will use a single instance of the value for all of its clients.
+
+```
+@Provides @Singleton static Heater provideHeater() {
+  return new ElectricHeater();
+}
+```
+The @Singleton annotation on an injectable class also serves as documentation. It reminds potential maintainers that this class may be shared by multiple threads.
+
+```
+@Singleton
+class CoffeeMaker {
+  ...
+}
+```
+Since Dagger 2 associates scoped instances in the graph with instances of component implementations, the components themselves need to declare which scope they intend to represent. For example, it wouldn’t make any sense to have a @Singleton binding and a @RequestScoped binding in the same component because those scopes have different lifecycles and thus must live in components with different lifecycles. To declare that a component is associated with a given scope, simply apply the scope annotation to the component interface.
+
+```
+@Component(modules = DripCoffeeModule.class)
+@Singleton
+interface CoffeeShop {
+  CoffeeMaker maker();
+}
+```
+Components may have multiple scope annotations applied. This declares that they are all aliases to the same scope, and so that component may include scoped bindings with any of the scopes it declares.
+
+## Reusable scope
+
+Sometimes you want to limit the number of times an @Inject-constructed class is instantiated or a @Provides method is called, but you don’t need to guarantee that the exact same instance is used during the lifetime of any particular component or subcomponent. This can be useful in environments such as Android, where allocations can be expensive.
+
+For these bindings, you can apply @Reusable scope. @Reusable-scoped bindings, unlike other scopes, are not associated with any single component; instead, each component that actually uses the binding will cache the returned or instantiated object.
+
+That means that if you install a module with a @Reusable binding in a component, but only a subcomponent actually uses the binding, then only that subcomponent will cache the binding’s object. If two subcomponents that do not share an ancestor each use the binding, each of them will cache its own object. If a component’s ancestor has already cached the object, the subcomponent will reuse it.
+
+There is no guarantee that the component will call the binding only once, so applying @Reusable to bindings that return mutable objects, or objects where it’s important to refer to the same instance, is dangerous. It’s safe to use @Reusable for immutable objects that you would leave unscoped if you didn’t care how many times they were allocated.
+
+```
+@Reusable // It doesn't matter how many scoopers we use, but don't waste them.
+class CoffeeScooper {
+  @Inject CoffeeScooper() {}
+}
+
+@Module
+class CashRegisterModule {
+  @Provides
+  @Reusable // DON'T DO THIS! You do care which register you put your cash in.
+            // Use a specific scope instead.
+  static CashRegister badIdeaCashRegister() {
+    return new CashRegister();
+  }
+}
+
+@Reusable // DON'T DO THIS! You really do want a new filter each time, so this
+          // should be unscoped.
+class CoffeeFilter {
+  @Inject CoffeeFilter() {}
+}
+```
+
+### Lazy injections 懒惰注射
+
+Sometimes you need an object to be instantiated lazily. For any binding T, you can create a Lazy<T> which defers instantiation until the first call to Lazy<T>’s get() method. If T is a singleton, then Lazy<T> will be the same instance for all injections within the ObjectGraph. Otherwise, each injection site will get its own Lazy<T> instance. Regardless, subsequent calls to any given instance of Lazy<T> will return the same underlying instance of T.
+
+```
+class GrindingCoffeeMaker {
+  @Inject Lazy<Grinder> lazyGrinder;
+
+  public void brew() {
+    while (needsGrinding()) {
+      // Grinder created once on first call to .get() and cached.
+      lazyGrinder.get().grind();
+    }
+  }
+}
+```
+
+### Provider injections 提供者注射
+
+Sometimes you need multiple instances to be returned instead of just injecting a single value. While you have several options (Factories, Builders, etc.), one option is to inject a Provider<T> instead of just T. A Provider<T> invokes the binding logic for T each time .get() is called. If that binding logic is an @Inject constructor, a new instance will be created, but a @Provides method has no such guarantee.
+
+```
+class BigCoffeeMaker {
+  @Inject Provider<Filter> filterProvider;
+
+  public void brew(int numberOfPots) {
+  ...
+    for (int p = 0; p < numberOfPots; p++) {
+      maker.addFilter(filterProvider.get()); //new filter every time.
+      maker.addCoffee(...);
+      maker.percolate();
+      ...
+    }
+  }
+}
+```
+Note: Injecting Provider<T> has the possibility of creating confusing code, and may be a design smell of mis-scoped or mis-structured objects in your graph. Often you will want to use a factory or a Lazy<T> or re-organize the lifetimes and structure of your code to be able to just inject a T. Injecting Provider<T> can, however, be a life saver in some cases. A common use is when you must use a legacy architecture that doesn’t line up with your object’s natural lifetimes (e.g. servlets are singletons by design, but only are valid in the context of request-specfic data).
+
+### Qualifiers 限定符
+
+Sometimes the type alone is insufficient to identify a dependency. For example, a sophisticated coffee maker app may want separate heaters for the water and the hot plate.
+
+In this case, we add a qualifier annotation. This is any annotation that itself has a @Qualifier annotation. Here’s the declaration of @Named, a qualifier annotation included in javax.inject:
+
+```
+@Qualifier
+@Documented
+@Retention(RUNTIME)
+public @interface Named {
+  String value() default "";
+}
+```
+You can create your own qualifier annotations, or just use @Named. Apply qualifiers by annotating the field or parameter of interest. The type and qualifier annotation will both be used to identify the dependency.
+
+```
+class ExpensiveCoffeeMaker {
+  @Inject @Named("water") Heater waterHeater;
+  @Inject @Named("hot plate") Heater hotPlateHeater;
+  ...
+}
+```
+Supply qualified values by annotating the corresponding @Provides method.
+
+```
+@Provides @Named("hot plate") static Heater provideHotPlateHeater() {
+  return new ElectricHeater(70);
+}
+
+@Provides @Named("water") static Heater provideWaterHeater() {
+  return new ElectricHeater(93);
+}
+```
+Dependencies may not have multiple qualifier annotations.
+
+### 可选绑定
+
+If you want a binding to work even if some dependency is not bound in the component, you can add a @BindsOptionalOf method to a module:
+
+```
+@BindsOptionalOf abstract CoffeeCozy optionalCozy();
+```
+That means that @Inject constructors and members and @Provides methods can depend on an Optional<CoffeeCozy> object. If there is a binding for CoffeeCozy in the component, the Optional will be present; if there is no binding for CoffeeCozy, the Optional will be absent.
+
+Specifically, you can inject any of the following:
+
+- Optional< CoffeeCozy> (unless there is a @Nullable binding for CoffeeCozy; see below)
+- Optional< Provider < CoffeeCozy >>
+- Optional< Lazy < CoffeeCozy >>
+- Optional< Provider < Lazy < CoffeeCozy >>>
+
+(You could also inject a Provider or Lazy or Provider of Lazy of any of those, but that isn’t very useful.)
+
+If there is a binding for CoffeeCozy, and that binding is @Nullable, then it is a compile-time error to inject Optional<CoffeeCozy>, because Optional cannot contain null. You can always inject the other forms, because Provider and Lazy can always return null from their get() methods.
+
+An optional binding that is absent in one component can be present in a subcomponent if the subcomponent includes a binding for the underlying type.
+
+You can use either Guava’s Optional or Java 8’s Optional.
+
+### 绑定实例
+
+通常，在构建组件时，您可以获得数据。 例如，假设您有一个使用命令行参数的应用程序; 您可能希望在组件中绑定这些args。
+
+也许你的应用程序只需要一个参数来表示你想要注入的用户名@UserName String。 您可以将注释@BindsInstance的方法添加到组件构建器，以允许将该实例注入组件中。
+
+```
+@Component(modules = AppModule.class)
+interface AppComponent {
+  App app();
+
+  @Component.Builder
+  interface Builder {
+    @BindsInstance Builder userName(@UserName String userName);
+    AppComponent build();
+  }
+}
+```
+Your app then might look like
+
+```
+public static void main(String[] args) {
+  if (args.length > 1) { exit(1); }
+  App app = DaggerAppComponent
+      .builder()
+      .userName(args[0])
+      .build()
+      .app();
+  app.run();
+}
+```
+In the above example, injecting @UserName String in the component will use the instance provided to the Builder when calling this method. Before building the component, all @BindsInstance methods must be called, passing a non-null value (with the exception of @Nullable bindings below).
+
+If the parameter to a @BindsInstance method is marked @Nullable, then the binding will be considered “nullable” in the same way as a @Provides method is nullable: injection sites must also mark it @Nullable, and null is an acceptable value for the binding. Moreover, users of the Builder may omit calling the method, and the component will treat the instance as null.
+
+@BindsInstance methods should be preferred to writing a @Module with constructor arguments and immediately providing those values.
+
+### 编译时验证
+
+The Dagger annotation processor is strict and will cause a compiler error if any bindings are invalid or incomplete. For example, this module is installed in a component, which is missing a binding for Executor:
+
+```
+@Module
+class DripCoffeeModule {
+  @Provides static Heater provideHeater(Executor executor) {
+    return new CpuHeater(executor);
+  }
+}
+```
+When compiling it, javac rejects the missing binding:
+
+```
+[ERROR] COMPILATION ERROR :
+[ERROR] error: java.util.concurrent.Executor cannot be provided without an @Provides-annotated method.
+```
+Fix the problem by adding an @Provides-annotated method for Executor to any of the modules in the component. While @Inject, @Module and @Provides annotations are validated individually, all validation of the relationship between bindings happens at the @Component level. Dagger 1 relied strictly on @Module-level validation (which may or may not have reflected runtime behavior), but Dagger 2 elides such validation (and the accompanying configuration parameters on @Module) in favor of full graph validation.
+
+### 编译时代码生成
+
+Dagger’s annotation processor may also generate source files with names like CoffeeMaker_Factory.java or CoffeeMaker_MembersInjector.java. These files are Dagger implementation details. You shouldn’t need to use them directly, though they can be handy when step-debugging through an injection. The only generated types you should refer to in your code are the ones Prefixed with Dagger for your component.
+
+### 在你的构建中使用Dagger
+
+您需要在应用程序的运行时导入dagger-2.X.jar。为了激活代码生成，您需要在编译时在构建中包含dagger-compiler-2.X.jar。有关更多信息，请参阅 README 文件。
+
+### License 许可
+
+```
+Copyright 2012 The Dagger Authors
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+```
\ No newline at end of file
