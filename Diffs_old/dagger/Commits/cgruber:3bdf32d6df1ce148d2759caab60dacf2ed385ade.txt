diff --git a/compiler/src/it/functional-tests/src/main/java/test/scope/BlueModule.java b/compiler/src/it/functional-tests/src/main/java/test/scope/BlueModule.java
new file mode 100644
index 000000000..c5fa3fa68
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/scope/BlueModule.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.scope;
+
+import dagger.Module;
+import dagger.Provides;
+
+import static dagger.Provides.Type.SET;
+
+@Module
+final class BlueModule {
+  @Provides(type = SET)
+  @BlueScope
+  static Object blue() {
+    return new Object();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/scope/BlueScope.java b/compiler/src/it/functional-tests/src/main/java/test/scope/BlueScope.java
new file mode 100644
index 000000000..1bf133794
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/scope/BlueScope.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.scope;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import javax.inject.Scope;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+@Documented
+@Retention(RUNTIME)
+@Scope
+@interface BlueScope {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/scope/GreenModule.java b/compiler/src/it/functional-tests/src/main/java/test/scope/GreenModule.java
new file mode 100644
index 000000000..9a160ff4b
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/scope/GreenModule.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.scope;
+
+import dagger.Module;
+import dagger.Provides;
+
+import static dagger.Provides.Type.SET;
+
+@Module
+final class GreenModule  {
+  @Provides(type = SET)
+  @GreenScope
+  static Object green() {
+    return new Object();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/scope/GreenScope.java b/compiler/src/it/functional-tests/src/main/java/test/scope/GreenScope.java
new file mode 100644
index 000000000..57bb5ae7c
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/scope/GreenScope.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.scope;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import javax.inject.Scope;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+@Documented
+@Retention(RUNTIME)
+@Scope
+@interface GreenScope {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/scope/ScopedComponent.java b/compiler/src/it/functional-tests/src/main/java/test/scope/ScopedComponent.java
new file mode 100644
index 000000000..8e5e03ee3
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/scope/ScopedComponent.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.scope;
+
+import dagger.Component;
+import java.util.Set;
+
+@BlueScope
+@GreenScope
+@Component(modules = {BlueModule.class, GreenModule.class, TurquoiseModule.class})
+interface ScopedComponent {
+  Set<Object> set();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/scope/TurquoiseModule.java b/compiler/src/it/functional-tests/src/main/java/test/scope/TurquoiseModule.java
new file mode 100644
index 000000000..7947ccfbd
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/scope/TurquoiseModule.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.scope;
+
+import dagger.Module;
+import dagger.Provides;
+
+import static dagger.Provides.Type.SET;
+
+@Module
+final class TurquoiseModule {
+  @Provides(type = SET)
+  @BlueScope
+  static Object blue() {
+    return new Object();
+  }
+
+  @Provides(type = SET)
+  @GreenScope
+  static Object green() {
+    return new Object();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/scope/ScopeTest.java b/compiler/src/it/functional-tests/src/test/java/test/scope/ScopeTest.java
new file mode 100644
index 000000000..aa289b12c
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/scope/ScopeTest.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.scope;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class ScopeTest {
+
+  @Test
+  public void testScope() {
+    ScopedComponent component = DaggerScopedComponent.create();
+    assertThat(component.set()).hasSize(4);
+    assertThat(component.set()).isEqualTo(component.set());
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Binding.java b/compiler/src/main/java/dagger/internal/codegen/Binding.java
index 26d3b61d4..71e1361ea 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Binding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Binding.java
@@ -151,8 +151,8 @@ public Void visitWildcard(WildcardType t, ImmutableSet.Builder<String> p) {
   /**
    * The scope of this binding.
    */
-  Scope scope() {
-    return Scope.unscoped();
+  Optional<Scope> scope() {
+    return Optional.absent();
   }
 
   // TODO(sameb): Remove the TypeElement parameter and pull it from the TypeMirror.
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index a85b8f6a4..1a627649c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -493,10 +493,10 @@ private boolean isResolvedInParent(DependencyRequest request, ContributionBindin
 
         // look for scope separately.  we do this for the case where @Singleton can appear twice
         // in the â€  compatibility mode
-        Scope bindingScope = binding.scope();
+        Optional<Scope> bindingScope = binding.scope();
         if (bindingScope.isPresent()) {
           for (Resolver requestResolver : getResolverLineage().reverse()) {
-            if (bindingScope.equals(requestResolver.componentDescriptor.scope())) {
+            if (requestResolver.componentDescriptor.scopes().contains(bindingScope.get())) {
               return Optional.of(requestResolver);
             }
           }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 15c540ede..1aac416ca 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -42,6 +42,7 @@
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.SourceElement.HasSourceElement;
+import dagger.producers.ProductionComponent;
 import java.util.ArrayDeque;
 import java.util.Arrays;
 import java.util.Collection;
@@ -63,6 +64,7 @@
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
@@ -104,6 +106,7 @@
 
 public class BindingGraphValidator {
 
+  private final Elements elements;
   private final Types types;
   private final InjectBindingRegistry injectBindingRegistry;
   private final ValidationType scopeCycleValidationType;
@@ -115,6 +118,7 @@
   private final Key.Factory keyFactory;
 
   BindingGraphValidator(
+      Elements elements,
       Types types,
       InjectBindingRegistry injectBindingRegistry,
       ValidationType scopeCycleValidationType,
@@ -124,6 +128,7 @@
       DependencyRequestFormatter dependencyRequestFormatter,
       KeyFormatter keyFormatter,
       Key.Factory keyFactory) {
+    this.elements = elements;
     this.types = types;
     this.injectBindingRegistry = injectBindingRegistry;
     this.scopeCycleValidationType = scopeCycleValidationType;
@@ -173,7 +178,7 @@ void validateSubgraph() {
               new HashSet<DependencyRequest>());
         }
       }
-      
+
       for (Map.Entry<ComponentMethodDescriptor, ComponentDescriptor> entry :
           filterKeys(
                   subject.componentDescriptor().subcomponents(),
@@ -358,7 +363,7 @@ private ResolvedBindings inlineSyntheticContributions(ResolvedBindings resolvedB
           .anyMatch(IS_SYNTHETIC_KIND)) {
         return resolvedBinding;
       }
-      
+
       ImmutableSetMultimap.Builder<ComponentDescriptor, ContributionBinding> contributions =
           ImmutableSetMultimap.builder();
       ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarations =
@@ -624,12 +629,13 @@ private void validateComponentHierarchy(
      */
     private void validateDependencyScopes() {
       ComponentDescriptor descriptor = subject.componentDescriptor();
-      Scope scope = descriptor.scope();
+      ImmutableSet<Scope> scopes = descriptor.scopes();
       ImmutableSet<TypeElement> scopedDependencies = scopedTypesIn(descriptor.dependencies());
-      if (scope.isPresent()) {
+      if (!scopes.isEmpty()) {
+        Scope singletonScope = Scope.singletonScope(elements);
         // Dagger 1.x scope compatibility requires this be suppress-able.
         if (scopeCycleValidationType.diagnosticKind().isPresent()
-            && scope.isSingleton()) {
+            && scopes.contains(singletonScope)) {
           // Singleton is a special-case representing the longest lifetime, and therefore
           // @Singleton components may not depend on scoped components
           if (!scopedDependencies.isEmpty()) {
@@ -643,8 +649,11 @@ private void validateDependencyScopes() {
           }
         } else if (scopedDependencies.size() > 1) {
           // Scoped components may depend on at most one scoped component.
-          StringBuilder message = new StringBuilder(scope.getReadableSource())
-              .append(' ')
+          StringBuilder message = new StringBuilder();
+          for (Scope scope : scopes) {
+            message.append(scope.getReadableSource()).append(' ');
+          }
+          message
               .append(descriptor.componentDefinitionType().getQualifiedName())
               .append(" depends on more than one scoped component:\n");
           appendIndentedComponentsList(message, scopedDependencies);
@@ -657,7 +666,7 @@ private void validateDependencyScopes() {
           if (!scopeCycleValidationType.equals(ValidationType.NONE)) {
             validateScopeHierarchy(descriptor.componentDefinitionType(),
                 descriptor.componentDefinitionType(),
-                new ArrayDeque<Scope>(),
+                new ArrayDeque<ImmutableSet<Scope>>(),
                 new ArrayDeque<TypeElement>());
           }
         }
@@ -730,41 +739,53 @@ public boolean apply(TypeElement input) {
      */
     private void validateScopeHierarchy(TypeElement rootComponent,
         TypeElement componentType,
-        Deque<Scope> scopeStack,
+        Deque<ImmutableSet<Scope>> scopeStack,
         Deque<TypeElement> scopedDependencyStack) {
-      Scope scope = Scope.scopeOf(componentType);
-      if (scope.isPresent()) {
-        if (scopeStack.contains(scope)) {
-          scopedDependencyStack.push(componentType);
-          // Current scope has already appeared in the component chain.
-          StringBuilder message = new StringBuilder();
-          message.append(rootComponent.getQualifiedName());
-          message.append(" depends on scoped components in a non-hierarchical scope ordering:\n");
-          appendIndentedComponentsList(message, scopedDependencyStack);
-          if (scopeCycleValidationType.diagnosticKind().isPresent()) {
-            reportBuilder.addItem(message.toString(),
-                scopeCycleValidationType.diagnosticKind().get(),
-                rootComponent, getAnnotationMirror(rootComponent, Component.class).get());
+      ImmutableSet<Scope> scopes = Scope.scopesOf(componentType);
+      if (stackOverlaps(scopeStack, scopes)) {
+        scopedDependencyStack.push(componentType);
+        // Current scope has already appeared in the component chain.
+        StringBuilder message = new StringBuilder();
+        message.append(rootComponent.getQualifiedName());
+        message.append(" depends on scoped components in a non-hierarchical scope ordering:\n");
+        appendIndentedComponentsList(message, scopedDependencyStack);
+        if (scopeCycleValidationType.diagnosticKind().isPresent()) {
+          reportBuilder.addItem(
+              message.toString(),
+              scopeCycleValidationType.diagnosticKind().get(),
+              rootComponent,
+              getAnnotationMirror(rootComponent, Component.class)
+                  .or(getAnnotationMirror(rootComponent, ProductionComponent.class))
+                  .get());
+        }
+        scopedDependencyStack.pop();
+      } else {
+        // TODO(beder): transitively check scopes of production components too.
+        Optional<AnnotationMirror> componentAnnotation =
+            getAnnotationMirror(componentType, Component.class);
+        if (componentAnnotation.isPresent()) {
+          ImmutableSet<TypeElement> scopedDependencies = scopedTypesIn(
+              MoreTypes.asTypeElements(getComponentDependencies(componentAnnotation.get())));
+          if (scopedDependencies.size() == 1) {
+            // empty can be ignored (base-case), and > 1 is a different error reported separately.
+            scopeStack.push(scopes);
+            scopedDependencyStack.push(componentType);
+            validateScopeHierarchy(rootComponent, getOnlyElement(scopedDependencies),
+                scopeStack, scopedDependencyStack);
+            scopedDependencyStack.pop();
+            scopeStack.pop();
           }
-          scopedDependencyStack.pop();
-        } else {
-          Optional<AnnotationMirror> componentAnnotation =
-              getAnnotationMirror(componentType, Component.class);
-          if (componentAnnotation.isPresent()) {
-            ImmutableSet<TypeElement> scopedDependencies = scopedTypesIn(
-                MoreTypes.asTypeElements(getComponentDependencies(componentAnnotation.get())));
-            if (scopedDependencies.size() == 1) {
-              // empty can be ignored (base-case), and > 1 is a different error reported separately.
-              scopeStack.push(scope);
-              scopedDependencyStack.push(componentType);
-              validateScopeHierarchy(rootComponent, getOnlyElement(scopedDependencies),
-                  scopeStack, scopedDependencyStack);
-              scopedDependencyStack.pop();
-              scopeStack.pop();
-            }
-          } // else: we skip component dependencies which are not components
+        } // else: we skip component dependencies which are not components
+      }
+    }
+
+    private <T> boolean stackOverlaps(Deque<ImmutableSet<T>> stack, ImmutableSet<T> set) {
+      for (ImmutableSet<T> entry : stack) {
+        if (!Sets.intersection(entry, set).isEmpty()) {
+          return true;
         }
       }
+      return false;
     }
 
     /**
@@ -773,12 +794,12 @@ private void validateScopeHierarchy(TypeElement rootComponent,
      */
     void validateComponentScope() {
       ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings = subject.resolvedBindings();
-      Scope componentScope = subject.componentDescriptor().scope();
+      ImmutableSet<Scope> componentScopes = subject.componentDescriptor().scopes();
       ImmutableSet.Builder<String> incompatiblyScopedMethodsBuilder = ImmutableSet.builder();
       for (ResolvedBindings bindings : resolvedBindings.values()) {
         for (ContributionBinding contributionBinding : bindings.ownedContributionBindings()) {
-          Scope bindingScope = contributionBinding.scope();
-          if (bindingScope.isPresent() && !bindingScope.equals(componentScope)) {
+          Optional<Scope> bindingScope = contributionBinding.scope();
+          if (bindingScope.isPresent() && !componentScopes.contains(bindingScope.get())) {
             // Scoped components cannot reference bindings to @Provides methods or @Inject
             // types decorated by a different scope annotation. Unscoped components cannot
             // reference to scoped @Provides methods or @Inject types decorated by any
@@ -792,7 +813,7 @@ void validateComponentScope() {
                 break;
               case INJECTION:
                 incompatiblyScopedMethodsBuilder.add(
-                    bindingScope.getReadableSource()
+                    bindingScope.get().getReadableSource()
                         + " class "
                         + contributionBinding.bindingTypeElement().getQualifiedName());
                 break;
@@ -807,10 +828,12 @@ void validateComponentScope() {
       if (!incompatiblyScopedMethods.isEmpty()) {
         TypeElement componentType = subject.componentDescriptor().componentDefinitionType();
         StringBuilder message = new StringBuilder(componentType.getQualifiedName());
-        if (componentScope.isPresent()) {
+        if (!componentScopes.isEmpty()) {
           message.append(" scoped with ");
-          message.append(componentScope.getReadableSource());
-          message.append(" may not reference bindings with different scopes:\n");
+          for (Scope scope : componentScopes) {
+            message.append(scope.getReadableSource()).append(' ');
+          }
+          message.append("may not reference bindings with different scopes:\n");
         } else {
           message.append(" (unscoped) may not reference scoped bindings:\n");
         }
@@ -1079,8 +1102,7 @@ private boolean suppressCycleWarnings(ImmutableList<DependencyRequest> pathEleme
   private void appendIndentedComponentsList(StringBuilder message, Iterable<TypeElement> types) {
     for (TypeElement scopedComponent : types) {
       message.append(INDENT);
-      Scope scope = Scope.scopeOf(scopedComponent);
-      if (scope.isPresent()) {
+      for (Scope scope : Scope.scopesOf(scopedComponent)) {
         message.append(scope.getReadableSource()).append(' ');
       }
       message.append(stripCommonTypePrefixes(scopedComponent.getQualifiedName().toString()))
@@ -1095,7 +1117,7 @@ private void appendIndentedComponentsList(StringBuilder message, Iterable<TypeEl
   private ImmutableSet<TypeElement> scopedTypesIn(Set<TypeElement> types) {
     return FluentIterable.from(types).filter(new Predicate<TypeElement>() {
       @Override public boolean apply(TypeElement input) {
-        return Scope.scopeOf(input).isPresent();
+        return !Scope.scopesOf(input).isEmpty();
       }
     }).toSet();
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index fe41e7ed5..df6be5233 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -276,9 +276,9 @@ boolean isProducer() {
   abstract Optional<TypeElement> executorDependency();
 
   /**
-   * The scope of the component.
+   * The scopes of the component.
    */
-  abstract Scope scope();
+  abstract ImmutableSet<Scope> scopes();
 
   abstract ImmutableMap<ComponentMethodDescriptor, ComponentDescriptor> subcomponents();
 
@@ -482,10 +482,9 @@ private ComponentDescriptor create(
       Optional<DeclaredType> builderType =
           Optional.fromNullable(getOnlyElement(enclosedBuilders, null));
 
-      Scope scope = Scope.scopeOf(componentDefinitionType);
-      if (kind.isProducer() && !scope.isPresent()) {
-        // TODO(beder): Override scope for production components when clients don't use them.
-        scope = Scope.productionScope(elements);
+      ImmutableSet<Scope> scopes = Scope.scopesOf(componentDefinitionType);
+      if (kind.isProducer()) {
+        scopes = FluentIterable.from(scopes).append(Scope.productionScope(elements)).toSet();
       }
 
       return new AutoValue_ComponentDescriptor(
@@ -496,7 +495,7 @@ private ComponentDescriptor create(
           modules.build(),
           dependencyMethodIndex.build(),
           executorDependency,
-          scope,
+          scopes,
           subcomponentDescriptors.build(),
           componentMethodsBuilder.build(),
           createBuilderSpec(builderType));
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index e66907977..9574883f4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -161,6 +161,7 @@ public SourceVersion getSupportedSourceVersion() {
     ComponentHierarchyValidator componentHierarchyValidator = new ComponentHierarchyValidator();
     BindingGraphValidator bindingGraphValidator =
         new BindingGraphValidator(
+            elements,
             types,
             injectBindingRegistry,
             scopeValidationType(processingEnv),
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
index 15b900677..0be4686a9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
@@ -19,7 +19,6 @@
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Optional;
-import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
@@ -29,7 +28,6 @@
 import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.producers.ProductionComponent;
-import dagger.producers.ProductionScope;
 import java.lang.annotation.Annotation;
 import java.util.Collection;
 import java.util.List;
@@ -231,23 +229,6 @@ public ComponentValidationReport validate(final TypeElement subject,
       }
     }
 
-    if (componentKind.isProducer()) {
-      ImmutableSet<? extends AnnotationMirror> nonProductionScopes =
-          FluentIterable.from(InjectionAnnotations.getScopes(subject))
-              .filter(
-                  new Predicate<AnnotationMirror>() {
-                    @Override
-                    public boolean apply(AnnotationMirror scope) {
-                      return !MoreTypes.isTypeOf(ProductionScope.class, scope.getAnnotationType());
-                    }
-                  })
-              .toSet();
-      if (!nonProductionScopes.isEmpty()) {
-        // TODO(beder): Make this an error after all clients are updated.
-        builder.addWarning(ErrorMessages.PRODUCTION_COMPONENT_SCOPE, subject);
-      }
-    }
-
     AnnotationMirror componentMirror =
         getAnnotationMirror(subject, componentKind.annotationType()).get();
     ImmutableList<TypeMirror> moduleTypes = getComponentModules(componentMirror);
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
index b3b245dfb..c911fda7e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
@@ -32,20 +32,6 @@
  * @since 2.0
  */
 final class InjectionAnnotations {
-  static Optional<AnnotationMirror> getScopeAnnotation(Element e) {
-    checkNotNull(e);
-    ImmutableSet<? extends AnnotationMirror> scopeAnnotations = getScopes(e);
-    switch (scopeAnnotations.size()) {
-      case 0:
-        return Optional.absent();
-      case 1:
-        return Optional.<AnnotationMirror>of(scopeAnnotations.iterator().next());
-      default:
-        throw new IllegalArgumentException(
-            e + " was annotated with more than one @Scope annotation");
-    }
-  }
-
   static Optional<AnnotationMirror> getQualifier(Element e) {
     checkNotNull(e);
     ImmutableSet<? extends AnnotationMirror> qualifierAnnotations = getQualifiers(e);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 346fdc4b3..3e23fd74a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -39,7 +39,6 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
-import static dagger.internal.codegen.Scope.scopeOf;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.ElementKind.FIELD;
 import static javax.lang.model.element.ElementKind.METHOD;
@@ -63,7 +62,7 @@ public BindingType bindingType() {
   abstract Optional<ProvisionBinding> unresolved();
 
   @Override
-  abstract Scope scope();
+  abstract Optional<Scope> scope();
   
   static final class Factory {
     private final Elements elements;
@@ -113,7 +112,7 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
               cxtorType.getParameterTypes());
       Optional<DependencyRequest> membersInjectionRequest =
           membersInjectionRequest(enclosingCxtorType);
-      Scope scope = Scope.scopeOf(constructorElement.getEnclosingElement());
+      Optional<Scope> scope = Scope.uniqueScopeOf(constructorElement.getEnclosingElement());
 
       TypeElement bindingTypeElement =
           MoreElements.asType(constructorElement.getEnclosingElement());
@@ -165,7 +164,7 @@ ProvisionBinding forProvidesMethod(
               MoreTypes.asDeclared(contributedBy.asType()),
               providesMethod.getParameters(),
               resolvedMethod.getParameterTypes());
-      Scope scope = Scope.scopeOf(providesMethod);
+      Optional<Scope> scope = Scope.uniqueScopeOf(providesMethod);
       return new AutoValue_ProvisionBinding(
           sourceElement,
           key,
@@ -200,7 +199,7 @@ ProvisionBinding implicitMapOfProviderBinding(DependencyRequest mapOfValueReques
           Kind.SYNTHETIC_MAP,
           Provides.Type.UNIQUE,
           Optional.<ProvisionBinding>absent(),
-          scopeOf(implicitMapOfProviderRequest.requestElement()));
+          Scope.uniqueScopeOf(implicitMapOfProviderRequest.requestElement()));
     }
 
     /**
@@ -219,7 +218,7 @@ ProvisionBinding syntheticMultibinding(
           Kind.forMultibindingRequest(request),
           Provides.Type.UNIQUE,
           Optional.<ProvisionBinding>absent(),
-          scopeOf(request.requestElement()));
+          Scope.uniqueScopeOf(request.requestElement()));
     }
 
     ProvisionBinding forComponent(TypeElement componentDefinitionType) {
@@ -234,14 +233,14 @@ ProvisionBinding forComponent(TypeElement componentDefinitionType) {
           Kind.COMPONENT,
           Provides.Type.UNIQUE,
           Optional.<ProvisionBinding>absent(),
-          Scope.unscoped());
+          Optional.<Scope>absent());
     }
 
     ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
       checkNotNull(componentMethod);
       checkArgument(componentMethod.getKind().equals(METHOD));
       checkArgument(componentMethod.getParameters().isEmpty());
-      Scope scope = Scope.scopeOf(componentMethod);
+      Optional<Scope> scope = Scope.uniqueScopeOf(componentMethod);
       return new AutoValue_ProvisionBinding(
           SourceElement.forElement(componentMethod),
           keyFactory.forComponentMethod(componentMethod),
@@ -271,7 +270,7 @@ ProvisionBinding forSubcomponentBuilderMethod(
           Kind.SUBCOMPONENT_BUILDER,
           Provides.Type.UNIQUE,
           Optional.<ProvisionBinding>absent(),
-          Scope.unscoped());
+          Optional.<Scope>absent());
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Scope.java b/compiler/src/main/java/dagger/internal/codegen/Scope.java
index c64ff64c9..962440fd8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Scope.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Scope.java
@@ -17,59 +17,57 @@
 
 import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.common.MoreTypes;
+import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.base.Preconditions;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
 import dagger.producers.ProductionScope;
-import javax.annotation.Nullable;
 import javax.inject.Singleton;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.Elements;
 
-import static com.google.auto.common.MoreTypes.isTypeOf;
+import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
-import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
+import static dagger.internal.codegen.InjectionAnnotations.getScopes;
 
 /**
  * A representation of the scope (or lack of it) associated with a component, providing method
  * or injection location.
  */
 final class Scope {
-
-  /**
-   * An internal representation for an unscoped binding.
-   */
-  private static final Scope UNSCOPED = new Scope();
-
   /**
    * The underlying {@link AnnotationMirror} that represents the scope annotation.
    */
-  @Nullable
   private final AnnotationMirror annotationMirror;
 
-  private Scope(@Nullable AnnotationMirror annotationMirror) {
-    this.annotationMirror = annotationMirror;
+  private Scope(AnnotationMirror annotationMirror) {
+    this.annotationMirror = checkNotNull(annotationMirror);
   }
 
-  private Scope() {
-    this(null);
-  }
-
-  /**
-   * Returns representation for an unscoped binding.
-   */
-  static Scope unscoped() {
-    return UNSCOPED;
+  /** Returns all of the associated scoped annotations from the source code element. */
+  static ImmutableSet<Scope> scopesOf(Element element) {
+    return FluentIterable.from(getScopes(element)).
+        transform(new Function<AnnotationMirror, Scope>() {
+          @Override public Scope apply(AnnotationMirror annotationMirror) {
+            return new Scope(annotationMirror);
+          }
+        }).toSet();
   }
 
   /**
-   * If the source code element has an associated scoped annotation then returns a representation
-   * of that scope, otherwise returns a representation for an unscoped binding.
+   * Returns at most one associated scoped annotation from the source code element, throwing an
+   * exception if there are more than one.
    */
-  static Scope scopeOf(Element element) {
-    Optional<AnnotationMirror> scopeAnnotation = getScopeAnnotation(element);
-    return scopeAnnotation.isPresent() ? new Scope(scopeAnnotation.get()) : UNSCOPED;
+  static Optional<Scope> uniqueScopeOf(Element element) {
+    ImmutableSet<? extends AnnotationMirror> scopeAnnotations = getScopes(element);
+    if (scopeAnnotations.isEmpty()) {
+      return Optional.absent();
+    }
+    return Optional.of(new Scope(Iterables.getOnlyElement(scopeAnnotations)));
   }
 
   /**
@@ -82,18 +80,12 @@ static Scope productionScope(Elements elements) {
   }
 
   /**
-   * Returns true if the scope is present, i.e. it's not unscoped binding.
+   * Returns a representation for singleton scope.
    */
-  public boolean isPresent() {
-    return annotationMirror != null;
-  }
-
-  /**
-   * Returns true if the scope represents the {@link Singleton @Singleton} annotation.
-   */
-  public boolean isSingleton() {
-    return annotationMirror != null
-        && isTypeOf(Singleton.class, annotationMirror.getAnnotationType());
+  static Scope singletonScope(Elements elements) {
+    return new Scope(
+        SimpleAnnotationMirror.of(
+            elements.getTypeElement(Singleton.class.getCanonicalName())));
   }
 
   /**
@@ -151,6 +143,6 @@ public int hashCode() {
    */
   @Override
   public String toString() {
-    return annotationMirror == null ? "UNSCOPED" : annotationMirror.toString();
+    return annotationMirror.toString();
   }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
index 8d8da6783..c645056a5 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -86,24 +86,6 @@
         .withErrorContaining("is not annotated with one of @Module, @ProducerModule");
   }
 
-  // TODO(beder): Expose this when CompileTester is updated externally.
-
-  @Test public void productionScopedProductionComponent() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ScopedComponent",
-        "package test;",
-        "",
-        "import dagger.producers.ProductionComponent;",
-        "import dagger.producers.ProductionScope;",
-        "",
-        "@ProductionScope",
-        "@ProductionComponent",
-        "interface ScopedComponent {}");
-    assertAbout(javaSource())
-        .that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
-  }
-
   @Test public void simpleComponent() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
         "package test;",
