diff --git a/compiler/pom.xml b/compiler/pom.xml
index af4eaa067..6b2990d91 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -79,6 +79,11 @@
       <artifactId>guava-testlib</artifactId>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>org.mockito</groupId>
+      <artifactId>mockito-core</artifactId>
+      <scope>test</scope>
+    </dependency>
     <dependency>
       <groupId>org.truth0</groupId>
       <artifactId>truth</artifactId>
diff --git a/compiler/src/main/java/dagger/internal/codegen/Binding.java b/compiler/src/main/java/dagger/internal/codegen/Binding.java
new file mode 100644
index 000000000..44faf5f3b
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/Binding.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
+
+import javax.inject.Inject;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * An abstract type for classes representing a Dagger binding.  Particularly, contains the
+ * {@link Element} that generated the binding and the {@link DependencyRequest} instances that are
+ * required to satisfy the binding, but leaves the specifics of the <i>mechanism</i> of the binding
+ * to the subtypes.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+abstract class Binding {
+  /** The field or method annotated with {@link Inject}. */
+  abstract Element bindingElement();
+
+  /** The type enclosing the binding {@link #bindingElement()}. */
+  TypeElement enclosingType() {
+    return ElementUtil.asTypeElement(bindingElement().getEnclosingElement());
+  }
+
+  /**
+   * The set of {@link DependencyRequest dependencies} required to satisfy this binding. For fields
+   * this will be a single element for the field and for methods this will be an element for each of
+   * the method parameters.
+   */
+  abstract ImmutableSet<DependencyRequest> dependencies();
+
+  /** Returns the {@link #dependencies()} indexed by {@link Key}. */
+  ImmutableSetMultimap<Key, DependencyRequest> dependenciesByKey() {
+    ImmutableSetMultimap.Builder<Key, DependencyRequest> builder = ImmutableSetMultimap.builder();
+    for (DependencyRequest dependency : dependencies()) {
+      builder.put(dependency.key(), dependency);
+    }
+    return builder.build();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ClassName.java b/compiler/src/main/java/dagger/internal/codegen/ClassName.java
new file mode 100644
index 000000000..c3a58c110
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ClassName.java
@@ -0,0 +1,205 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.Util.isValidJavaIdentifier;
+import static javax.lang.model.element.NestingKind.MEMBER;
+import static javax.lang.model.element.NestingKind.TOP_LEVEL;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Ascii;
+import com.google.common.base.CaseFormat;
+import com.google.common.base.CharMatcher;
+import com.google.common.base.Joiner;
+import com.google.common.base.Splitter;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Sets;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+
+import javax.lang.model.element.Element;
+import javax.lang.model.element.NestingKind;
+import javax.lang.model.element.PackageElement;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * Represents a fully-qualified class name for {@link NestingKind#TOP_LEVEL} and
+ * {@link NestingKind#MEMBER} classes.
+ *
+ * @since 2.0
+ */
+@AutoValue
+abstract class ClassName implements Comparable<ClassName> {
+  private String fullyQualifiedName = null;
+
+  String fullyQualifiedName() {
+    if (fullyQualifiedName == null) {
+      StringBuilder builder = new StringBuilder(packageName());
+      if (builder.length() > 0) {
+        builder.append('.');
+      }
+      for (String enclosingSimpleName : enclosingSimpleNames()) {
+        builder.append(enclosingSimpleName).append('.');
+      }
+      fullyQualifiedName = builder.append(simpleName()).toString();
+    }
+    return fullyQualifiedName;
+  }
+
+  String classFileName() {
+    StringBuilder builder = new StringBuilder();
+    Joiner.on('$').appendTo(builder, enclosingSimpleNames());
+    if (!enclosingSimpleNames().isEmpty()) {
+      builder.append('$');
+    }
+    return builder.append(simpleName()).toString();
+  }
+
+  abstract String packageName();
+  /* From top to bottom.  E.g.: this field will contian ["A", "B"] for pgk.A.B.C */
+  abstract ImmutableList<String> enclosingSimpleNames();
+  abstract String simpleName();
+
+
+  String suggestedVariableName() {
+    return CharMatcher.is('$').removeFrom(
+        CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL, simpleName()));
+  }
+
+  ClassName nameOfTopLevelClass() {
+    Iterator<String> enclosingIterator = enclosingSimpleNames().iterator();
+    return enclosingIterator.hasNext()
+        ? new AutoValue_ClassName(packageName(), ImmutableList.<String>of(),
+            enclosingIterator.next())
+        : this;
+  }
+
+  ClassName memberClassNamed(String memberClassName) {
+    checkNotNull(memberClassName);
+    checkArgument(isValidJavaIdentifier(memberClassName));
+    checkArgument(Ascii.isUpperCase(memberClassName.charAt(0)));
+    return new AutoValue_ClassName(packageName(),
+        new ImmutableList.Builder<String>()
+            .addAll(enclosingSimpleNames())
+            .add(simpleName())
+            .build(),
+        memberClassName);
+  }
+
+  ClassName peerNamed(String peerClassName) {
+    checkNotNull(peerClassName);
+    checkArgument(isValidJavaIdentifier(peerClassName));
+    checkArgument(Ascii.isUpperCase(peerClassName.charAt(0)));
+    return new AutoValue_ClassName(packageName(), enclosingSimpleNames(), peerClassName);
+  }
+
+  private static final ImmutableSet<NestingKind> ACCEPTABLE_NESTING_KINDS =
+      Sets.immutableEnumSet(TOP_LEVEL, MEMBER);
+
+  static ClassName fromTypeElement(TypeElement element) {
+    checkNotNull(element);
+    checkArgument(ACCEPTABLE_NESTING_KINDS.contains(element.getNestingKind()));
+    String simpleName = element.getSimpleName().toString();
+    List<String> enclosingNames = new ArrayList<String>();
+    Element current = element.getEnclosingElement();
+    while (current.getKind().isClass() || current.getKind().isInterface()) {
+      checkArgument(ACCEPTABLE_NESTING_KINDS.contains(element.getNestingKind()));
+      enclosingNames.add(current.getSimpleName().toString());
+      current = element.getEnclosingElement();
+    }
+    PackageElement packageElement = Util.getPackage(current);
+    Collections.reverse(enclosingNames);
+    return new AutoValue_ClassName(packageElement.getQualifiedName().toString(),
+        ImmutableList.copyOf(enclosingNames), simpleName);
+  }
+
+  static ClassName fromClass(Class<?> clazz) {
+    checkNotNull(clazz);
+    List<String> enclosingNames = new ArrayList<String>();
+    Class<?> current = clazz.getEnclosingClass();
+    while (current != null) {
+      enclosingNames.add(current.getSimpleName());
+      current = clazz.getEnclosingClass();
+    }
+    Collections.reverse(enclosingNames);
+    return create(clazz.getPackage().getName(), enclosingNames, clazz.getSimpleName());
+  }
+
+  /**
+   * Returns a new {@link ClassName} instance for the given fully-qualified class name string. This
+   * method assumes that the input is ASCII and follows typical Java style (lower-case package
+   * names, upper-camel-case class names) and may produce incorrect results or throw
+   * {@link IllegalArgumentException} otherwise. For that reason, {@link #fromClass(Class)} and
+   * {@link #fromClass(Class)} should be preferred as they can correctly create {@link ClassName}
+   * instances without such restrictions.
+   */
+  static ClassName bestGuessFromString(String classNameString) {
+    checkNotNull(classNameString);
+    List<String> parts = Splitter.on('.').splitToList(classNameString);
+    int firstClassPartIndex = -1;
+    for (int i = 0; i < parts.size(); i++) {
+      String part = parts.get(i);
+      checkArgument(isValidJavaIdentifier(part));
+      char firstChar = part.charAt(0);
+      if (Ascii.isLowerCase(firstChar)) {
+        // looks like a package part
+        if (firstClassPartIndex >= 0) {
+          throw new IllegalArgumentException("couldn't make a guess for " + classNameString);
+        }
+      } else if (Ascii.isUpperCase(firstChar)) {
+        // looks like a class part
+        if (firstClassPartIndex < 0) {
+          firstClassPartIndex = i;
+        }
+      } else {
+        throw new IllegalArgumentException("couldn't make a guess for " + classNameString);
+      }
+    }
+    int lastIndex = parts.size() - 1;
+    return new AutoValue_ClassName(
+        Joiner.on('.').join(parts.subList(0, firstClassPartIndex)),
+        firstClassPartIndex == lastIndex
+            ? ImmutableList.<String>of()
+            : ImmutableList.copyOf(parts.subList(firstClassPartIndex, lastIndex)),
+        parts.get(lastIndex));
+  }
+
+  static ClassName create(String packageName,
+      List<String> enclosingSimpleNames, String simpleName) {
+    return new AutoValue_ClassName(packageName, ImmutableList.copyOf(enclosingSimpleNames),
+        simpleName);
+  }
+
+  static ClassName create(String packageName, String simpleName) {
+    return new AutoValue_ClassName(packageName, ImmutableList.<String>of(), simpleName);
+  }
+
+  @Override
+  public String toString() {
+    return fullyQualifiedName();
+  }
+
+  @Override
+  public int compareTo(ClassName o) {
+    return fullyQualifiedName().compareTo(o.fullyQualifiedName());
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
new file mode 100644
index 000000000..e44e6b03f
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Function;
+import com.google.common.base.Optional;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+
+import dagger.Lazy;
+import dagger.Provides;
+
+import java.util.List;
+
+import javax.inject.Inject;
+import javax.inject.Provider;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+
+/**
+ * Represents a request for a key at an injection point. Parameters to {@link Inject} constructors
+ * or {@link Provides} methods are examples of key requests.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+// TODO(gak): Set bindings and the permutations thereof need to be addressed
+@AutoValue
+abstract class DependencyRequest {
+  enum Kind {
+    /** A default request for an instance.  E.g.: {@code Blah} */
+    INSTANCE,
+    /** A request for a {@link Provider}.  E.g.: {@code Provider<Blah>} */
+    PROVIDER,
+    /** A request for a {@link Lazy}.  E.g.: {@code Lazy<Blah>} */
+    LAZY,
+  }
+
+  abstract Kind kind();
+  abstract Key key();
+  abstract VariableElement requestElement();
+
+  static final class Factory {
+    private final Elements elements;
+    private final Types types;
+
+    Factory(Elements elements, Types types) {
+      this.elements = elements;
+      this.types = types;
+    }
+
+    ImmutableSet<DependencyRequest> forVariables(List<? extends VariableElement> variables) {
+      return FluentIterable.from(variables)
+          .transform(new Function<VariableElement, DependencyRequest>() {
+            @Override public DependencyRequest apply(VariableElement input) {
+              return forVariable(input);
+            }
+          })
+          .toSet();
+    }
+
+    DependencyRequest forVariable(VariableElement variableElement) {
+      checkNotNull(variableElement);
+      TypeMirror type = variableElement.asType();
+      Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(variableElement);
+      if (elements.getTypeElement(Provider.class.getCanonicalName())
+          .equals(types.asElement(type))) {
+        DeclaredType providerType = (DeclaredType) type;
+        return new AutoValue_DependencyRequest(Kind.PROVIDER,
+            Key.create(qualifier, Iterables.getOnlyElement(providerType.getTypeArguments())),
+            variableElement);
+      } else if (elements.getTypeElement(Lazy.class.getCanonicalName())
+          .equals(types.asElement(type))) {
+        DeclaredType lazyType = (DeclaredType) type;
+        return new AutoValue_DependencyRequest(Kind.LAZY,
+            Key.create(qualifier, Iterables.getOnlyElement(lazyType.getTypeArguments())),
+            variableElement);
+      } else {
+        return new AutoValue_DependencyRequest(Kind.INSTANCE, Key.create(qualifier, type),
+            variableElement);
+      }
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java b/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
new file mode 100644
index 000000000..b762831aa
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Ascii;
+import com.google.common.base.Function;
+
+import dagger.Lazy;
+
+import javax.inject.Provider;
+
+/**
+ * Picks a reasonable name for what we think is being provided from the variable name associated
+ * with the {@link DependencyRequest}.  I.e. strips out words like "lazy" and "provider" if we
+ * believe that those refer to {@link Lazy} and {@link Provider} rather than the type being
+ * provided.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+//TODO(gak): develop the heuristics to get better names
+final class DependencyVariableNamer implements Function<DependencyRequest, String> {
+  @Override
+  public String apply(DependencyRequest dependency) {
+    String variableName = dependency.requestElement().getSimpleName().toString();
+    switch (dependency.kind()) {
+      case INSTANCE:
+        return variableName;
+      case LAZY:
+        return variableName.startsWith("lazy") && !variableName.equals("lazy")
+            ? Ascii.toLowerCase(variableName.charAt(4)) + variableName.substring(5)
+            : variableName;
+      case PROVIDER:
+        return variableName.endsWith("Provider") && !variableName.equals("Provider")
+            ? variableName.substring(0, variableName.length() - 8)
+            : variableName;
+      default:
+        throw new AssertionError();
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectConstructorFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/InjectConstructorFactoryGenerator.java
new file mode 100644
index 000000000..f5aa2baa5
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectConstructorFactoryGenerator.java
@@ -0,0 +1,203 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Function;
+import com.google.common.base.Functions;
+import com.google.common.base.Joiner;
+import com.google.common.base.Optional;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableBiMap;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSortedSet;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Ordering;
+import com.squareup.javawriter.JavaWriter;
+import dagger.Factory;
+import dagger.MembersInjector;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.EnumSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import javax.annotation.Generated;
+import javax.annotation.processing.Filer;
+import javax.inject.Inject;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+
+import static com.squareup.javawriter.JavaWriter.stringLiteral;
+import static com.squareup.javawriter.JavaWriter.type;
+import static dagger.internal.codegen.SourceFiles.collectImportsFromDependencies;
+import static dagger.internal.codegen.SourceFiles.flattenVariableMap;
+import static dagger.internal.codegen.SourceFiles.generateProviderNames;
+import static dagger.internal.codegen.SourceFiles.providerUsageStatement;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+
+/**
+ * Generates {@link Factory} implementations from {@link ProvisionBinding} instances for
+ * {@link Inject} constructors.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+final class InjectConstructorFactoryGenerator extends SourceFileGenerator<ProvisionBinding> {
+  private final ProviderTypeRepository providerTypeRepository;
+
+  InjectConstructorFactoryGenerator(Filer filer, ProviderTypeRepository providerTypeRepository) {
+    super(filer);
+    this.providerTypeRepository = providerTypeRepository;
+  }
+
+  @Override
+  ClassName nameGeneratedType(ProvisionBinding binding) {
+    TypeElement providedElement = binding.enclosingType();
+    ClassName providedClassName = ClassName.fromTypeElement(providedElement);
+    return providedClassName.peerNamed(providedClassName.simpleName() + "$$Factory");
+  }
+
+  @Override
+  Iterable<? extends Element> getOriginatingElements(ProvisionBinding binding) {
+    return ImmutableSet.of(binding.bindingElement());
+  }
+
+  @Override
+  Optional<? extends Element> getElementForErrorReporting(ProvisionBinding binding) {
+    return Optional.of(binding.bindingElement());
+  }
+
+  @Override
+  void write(ClassName factoryClassName, JavaWriter writer, ProvisionBinding binding)
+      throws IOException {
+    ClassName providedClassName = ClassName.fromTypeElement(binding.enclosingType());
+
+    writer.emitPackage(factoryClassName.packageName());
+
+    List<ClassName> importsBuilder = new ArrayList<ClassName>();
+    importsBuilder.addAll(collectImportsFromDependencies(factoryClassName, binding.dependencies()));
+    importsBuilder.add(ClassName.fromClass(Factory.class));
+    importsBuilder.add(ClassName.fromClass(Generated.class));
+    if (binding.requiresMemberInjection()) {
+      importsBuilder.add(ClassName.fromClass(MembersInjector.class));
+    }
+    ImmutableSortedSet<String> imports = FluentIterable.from(importsBuilder)
+        .transform(Functions.toStringFunction())
+        .toSortedSet(Ordering.natural());
+    writer.emitImports(imports).emitEmptyLine();
+
+    writer.emitAnnotation(Generated.class, stringLiteral(InjectProcessor.class.getName()))
+        .beginType(factoryClassName.simpleName(), "class", EnumSet.of(PUBLIC, FINAL), null,
+            type(Factory.class, Util.typeToString(binding.providedKey().type())));
+
+    final ImmutableBiMap<Key, String> providerNames =
+        generateProviderNames(ImmutableList.of(binding));
+
+    ImmutableMap.Builder<String, String> variableMapBuilder =
+        new ImmutableMap.Builder<String, String>();
+    if (binding.requiresMemberInjection()) {
+      variableMapBuilder.put("membersInjector",
+          type(MembersInjector.class, providedClassName.simpleName()));
+    }
+    ImmutableMap<String, String> variableMap = variableMapBuilder
+        .putAll(providersAsVariableMap(providerNames))
+        .build();
+
+    if (binding.requiresMemberInjection()) {
+      writeMembersInjectorField(writer, providedClassName);
+    }
+    writeProviderFields(writer, providerNames);
+
+    writeConstructor(writer, variableMap);
+
+    writer.emitAnnotation(Override.class)
+        .beginMethod(providedClassName.simpleName(), "get", EnumSet.of(PUBLIC));
+    String parameterString =
+        Joiner.on(", ").join(FluentIterable.from(binding.dependencies())
+            .transform(new Function<DependencyRequest, String>() {
+              @Override public String apply(DependencyRequest input) {
+                return providerUsageStatement(providerNames.get(input.key()), input.kind());
+              }
+            }));
+    if (binding.requiresMemberInjection()) {
+      writer.emitStatement("%1$s instance = new %1$s(%2$s)",
+          providedClassName.simpleName(), parameterString);
+      writer.emitStatement("membersInjector.injectMembers(instance)");
+      writer.emitStatement("return instance");
+    } else {
+      writer.emitStatement("return new %s(%s)", providedClassName.simpleName(), parameterString);
+    }
+    writer.endMethod().emitEmptyLine();
+
+    writeToString(writer, providedClassName);
+
+    writer.endType();
+  }
+
+  private void writeMembersInjectorField(JavaWriter writer, ClassName providedClassName)
+      throws IOException {
+    writer.emitField(type(MembersInjector.class, providedClassName.fullyQualifiedName()),
+        "membersInjector", EnumSet.of(PRIVATE, FINAL));
+  }
+
+  private void writeProviderFields(JavaWriter writer, ImmutableBiMap<Key, String> providerNames)
+      throws IOException {
+    for (Entry<Key, String> providerEntry : providerNames.entrySet()) {
+      Key key = providerEntry.getKey();
+      // TODO(gak): provide more elaborate information about which requests relate
+      writer.emitJavadoc(key.toString())
+          .emitField(providerTypeString(key), providerEntry.getValue(),
+              EnumSet.of(PRIVATE, FINAL));
+    }
+    writer.emitEmptyLine();
+  }
+
+  private void writeConstructor(JavaWriter writer, Map<String, String> variableMap)
+      throws IOException {
+    writer.beginConstructor(EnumSet.of(PUBLIC),
+        flattenVariableMap(variableMap),
+        ImmutableList.<String>of());
+    for (String variableName : variableMap.keySet()) {
+      writer.emitStatement("assert %s != null", variableName);
+      writer.emitStatement("this.%1$s = %1$s", variableName);
+    }
+    writer.endConstructor().emitEmptyLine();
+  }
+
+  private void writeToString(JavaWriter writer, ClassName providedClassName) throws IOException {
+    writer.emitAnnotation(Override.class)
+        .beginMethod("String", "toString", EnumSet.of(PUBLIC))
+        .emitStatement("return \"%s<%s>\"",
+            Factory.class.getSimpleName(), providedClassName.simpleName())
+        .endMethod();
+  }
+
+  private Map<String, String> providersAsVariableMap(ImmutableBiMap<Key, String> providerNames) {
+    return Maps.transformValues(providerNames.inverse(), new Function<Key, String>() {
+      @Override public String apply(Key key) {
+        return providerTypeString(key);
+      }
+    });
+  }
+
+  private String providerTypeString(Key key) {
+    return Util.typeToString(providerTypeRepository.getProviderType(key));
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
index 22ade7abb..4edbc6c2b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
@@ -34,15 +34,20 @@
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
 
+import com.google.common.base.Function;
 import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Multimaps;
 
 import java.lang.annotation.Annotation;
+import java.util.Collection;
 import java.util.List;
 import java.util.Set;
 
 import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.Filer;
 import javax.annotation.processing.Messager;
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.annotation.processing.RoundEnvironment;
@@ -58,6 +63,8 @@
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.ElementKindVisitor6;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
 /**
  * An annotation processor for generating Dagger implementation code based on the {@link Inject}
@@ -69,11 +76,26 @@
 @SupportedSourceVersion(RELEASE_6)
 public final class InjectProcessor extends AbstractProcessor {
   private Messager messager;
+  private ProvisionBinding.Factory provisionBindingFactory;
+  private InjectConstructorFactoryGenerator factoryWriter;
+  private MembersInjectionBinding.Factory membersInjectionBindingFactory;
+  private MembersInjectorGenerator membersInjectorWriter;
 
   @Override
   public synchronized void init(ProcessingEnvironment processingEnv) {
     super.init(processingEnv);
     this.messager = processingEnv.getMessager();
+    Filer filer = processingEnv.getFiler();
+    Elements elements = processingEnv.getElementUtils();
+    Types types = processingEnv.getTypeUtils();
+    DependencyRequest.Factory dependencyRequestFactory =
+        new DependencyRequest.Factory(elements, types);
+    ProviderTypeRepository providerTypeRepository = new ProviderTypeRepository(elements, types);
+    this.provisionBindingFactory = new ProvisionBinding.Factory(dependencyRequestFactory);
+    this.factoryWriter = new InjectConstructorFactoryGenerator(filer, providerTypeRepository);
+    this.membersInjectionBindingFactory =
+        new MembersInjectionBinding.Factory(dependencyRequestFactory);
+    this.membersInjectorWriter = new MembersInjectorGenerator(filer, providerTypeRepository);
   }
 
   @Override
@@ -84,6 +106,9 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
   @Override
   public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
     // TODO(gak): add some error handling for bad source files
+    final ImmutableSet.Builder<ProvisionBinding> provisions = ImmutableSet.builder();
+    final ImmutableSet.Builder<MembersInjectionBinding> membersInjections = ImmutableSet.builder();
+
     for (Element injectElement : roundEnv.getElementsAnnotatedWith(Inject.class)) {
       injectElement.accept(
           new ElementKindVisitor6<Void, Void>() {
@@ -95,7 +120,7 @@ public Void visitExecutableAsConstructor(ExecutableElement constructorElement, V
               report.printMessagesTo(messager);
 
               if (report.isClean()) {
-                // collect bindings for generating factories
+                provisions.add(provisionBindingFactory.forInjectConstructor(constructorElement));
               }
 
               return null;
@@ -108,7 +133,8 @@ public Void visitVariableAsField(VariableElement fieldElement, Void p) {
               report.printMessagesTo(messager);
 
               if (report.isClean()) {
-                // collect bindings for generating members injectors
+                membersInjections.add(
+                    membersInjectionBindingFactory.forInjectField(fieldElement));
               }
 
               return null;
@@ -121,7 +147,8 @@ public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
               report.printMessagesTo(messager);
 
               if (report.isClean()) {
-                // collect bindings for generating members injectors
+                membersInjections.add(
+                    membersInjectionBindingFactory.forInjectMethod(methodElement));
               }
 
               return null;
@@ -129,7 +156,29 @@ public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
           }, null);
     }
 
-    // TODO(gak): generate the factories and members injectors
+    ImmutableListMultimap<TypeElement, MembersInjectionBinding> membersInjectionsByType =
+        Multimaps.index(membersInjections.build(),
+            new Function<MembersInjectionBinding, TypeElement>() {
+              @Override public TypeElement apply(MembersInjectionBinding binding) {
+                return binding.enclosingType();
+              }
+            });
+
+    for (Collection<MembersInjectionBinding> bindings : membersInjectionsByType.asMap().values()) {
+      try {
+        membersInjectorWriter.generate(MembersInjectorDescriptor.create(bindings));
+      } catch (SourceFileGenerationException e) {
+        e.printMessageTo(messager);
+      }
+    }
+
+    for (ProvisionBinding binding : provisions.build()) {
+      try {
+        factoryWriter.generate(binding);
+      } catch (SourceFileGenerationException e) {
+        e.printMessageTo(messager);
+      }
+    }
 
     return false;
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
new file mode 100644
index 000000000..e0184bf7b
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
+
+import com.google.common.base.Optional;
+import com.google.common.base.Predicate;
+import com.google.common.collect.FluentIterable;
+
+import java.lang.annotation.Annotation;
+import java.util.Iterator;
+import java.util.List;
+
+import javax.inject.Qualifier;
+import javax.inject.Scope;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+
+/**
+ * Utilities relating to annotations defined in the {@code javax.inject} package.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+final class InjectionAnnotations {
+  static Optional<AnnotationMirror> getScopeAnnotation(Element e) {
+    checkNotNull(e);
+    return getAnnotatedAnnotation(e, Scope.class);
+  }
+
+  static Optional<AnnotationMirror> getQualifier(Element e) {
+    checkNotNull(e);
+    return getAnnotatedAnnotation(e, Qualifier.class);
+  }
+
+  private static Optional<AnnotationMirror> getAnnotatedAnnotation(Element e,
+      final Class<? extends Annotation> annotationType) {
+    List<? extends AnnotationMirror> annotations = e.getAnnotationMirrors();
+    Iterator<? extends AnnotationMirror> qualifiers = FluentIterable.from(annotations)
+        .filter(new Predicate<AnnotationMirror>() {
+          @Override
+          public boolean apply(AnnotationMirror input) {
+            return input.getAnnotationType().asElement().getAnnotation(annotationType) != null;
+          }
+        })
+        .iterator();
+    if (qualifiers.hasNext()) {
+      AnnotationMirror qualifier = qualifiers.next();
+      checkState(!qualifiers.hasNext(),
+          "More than one " + annotationType.getName() + " was present.");
+      return Optional.of(qualifier);
+    } else {
+      return Optional.absent();
+    }
+  }
+
+  private InjectionAnnotations() {}
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 51ba7ab7a..740ca59f3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -17,7 +17,7 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.base.Preconditions.checkState;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.ElementKind.METHOD;
 
@@ -25,17 +25,11 @@
 import com.google.common.base.Equivalence;
 import com.google.common.base.Objects;
 import com.google.common.base.Optional;
-import com.google.common.base.Predicate;
-import com.google.common.collect.FluentIterable;
 
 import dagger.Provides;
 
-import java.util.Iterator;
-import java.util.List;
-
 import javax.inject.Qualifier;
 import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.type.TypeMirror;
 
@@ -61,19 +55,21 @@ TypeMirror type() {
 
   @Override
   public String toString() {
-    return Objects.toStringHelper(this)
+    return Objects.toStringHelper(Key.class)
         .omitNullValues()
         .add("qualifier", qualifier().orNull())
         .add("type", type())
         .toString();
   }
 
+  // TODO(gak): normalize boxed types
+
   static Key create(TypeMirror type) {
     return new AutoValue_Key(Optional.<AnnotationMirror>absent(), Mirrors.equivalence().wrap(type));
   }
 
-  static Key create(AnnotationMirror qualifier, TypeMirror type) {
-    return new AutoValue_Key(Optional.of(qualifier), Mirrors.equivalence().wrap(type));
+  static Key create(Optional<AnnotationMirror> qualifier, TypeMirror type) {
+    return new AutoValue_Key(qualifier, Mirrors.equivalence().wrap(type));
   }
 
   // TODO(gak): decide whether to address set bindings here or someplace else
@@ -99,23 +95,4 @@ static Key forInjectConstructor(ExecutableElement e) {
     TypeMirror type = e.getEnclosingElement().asType();
     return new AutoValue_Key(Optional.<AnnotationMirror>absent(), Mirrors.equivalence().wrap(type));
   }
-
-  private static Optional<AnnotationMirror> getQualifier(Element e) {
-    List<? extends AnnotationMirror> annotations = e.getAnnotationMirrors();
-    Iterator<? extends AnnotationMirror> qualifiers = FluentIterable.from(annotations)
-        .filter(new Predicate<AnnotationMirror>() {
-          @Override
-          public boolean apply(AnnotationMirror input) {
-            return input.getAnnotationType().asElement().getAnnotation(Qualifier.class) != null;
-          }
-        })
-        .iterator();
-    if (qualifiers.hasNext()) {
-      AnnotationMirror qualifier = qualifiers.next();
-      checkState(!qualifiers.hasNext(), "More than one qualifier was present.");
-      return Optional.of(qualifier);
-    } else {
-      return Optional.absent();
-    }
-  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/KeyRequest.java b/compiler/src/main/java/dagger/internal/codegen/KeyRequest.java
deleted file mode 100644
index 71186804d..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/KeyRequest.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.auto.value.AutoValue;
-
-import dagger.Provides;
-
-import javax.inject.Inject;
-
-
-/**
- * Represents a request for a key at an injection point. Parameters to {@link Inject} constructors
- * or {@link Provides} methods are examples of key requests.
- *
- * @author Gregory Kick
- */
-// TODO(gak): Set bindings and the permutations thereof need to be addressed
-@AutoValue
-abstract class KeyRequest {
-  enum Kind {
-    INSTANCE,
-    PROVIDER,
-    LAZY,
-  }
-
-  abstract Kind type();
-  abstract Key key();
-
-  static KeyRequest instanceRequest(Key key) {
-    return new AutoValue_KeyRequest(Kind.INSTANCE, key);
-  }
-
-  static KeyRequest providerRequest(Key key) {
-    return new AutoValue_KeyRequest(Kind.PROVIDER, key);
-  }
-
-  static KeyRequest lazyRequest(Key key) {
-    return new AutoValue_KeyRequest(Kind.LAZY, key);
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
new file mode 100644
index 000000000..c92a133cc
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static javax.lang.model.element.ElementKind.FIELD;
+import static javax.lang.model.element.ElementKind.METHOD;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.ComparisonChain;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Ordering;
+
+import javax.inject.Inject;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.VariableElement;
+
+/**
+ * A value object representing a binding for an {@link Inject} annotation on a member (as opposed to
+ * a constructor). New instances should be created using an instance of the {@link Factory}.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+@AutoValue
+abstract class MembersInjectionBinding extends Binding {
+  /**
+   * Returns an {@link Ordering} suitable for sorting bindings into an ordering that abides by the
+   * injection ordering specified in {@link Inject}. This ordering should not be used with bindings
+   * from different {@link #enclosingType() types}.
+   */
+  static Ordering<MembersInjectionBinding> injectionOrdering() {
+    return INJECTION_ORDERING;
+  }
+
+  private static final Ordering<MembersInjectionBinding> INJECTION_ORDERING =
+      new Ordering<MembersInjectionBinding>() {
+        @Override
+        public int compare(MembersInjectionBinding left, MembersInjectionBinding right) {
+          return ComparisonChain.start()
+              // fields before methods
+              .compare(left.bindingElement().getKind(), right.bindingElement().getKind())
+              // then sort by whichever element comes first in the parent
+              // this isn't necessary, but makes the processor nice and predictable
+              .compare(targetIndexInEnclosing(left), targetIndexInEnclosing(right))
+              .result();
+        }
+      };
+
+  private static int targetIndexInEnclosing(MembersInjectionBinding binding)  {
+    return binding.enclosingType().getEnclosedElements().indexOf(binding.bindingElement());
+  }
+
+  /**
+   * A factory for creating {@link MembersInjectionBinding} instances.
+   */
+  static final class Factory {
+    private final DependencyRequest.Factory dependencyRequestFactory;
+
+    Factory(DependencyRequest.Factory dependencyRequestFactory) {
+      this.dependencyRequestFactory = checkNotNull(dependencyRequestFactory);
+    }
+
+    /** Returns the method injection binding for a method annotated with {@link Inject}. */
+    MembersInjectionBinding forInjectMethod(ExecutableElement methodElement) {
+      checkNotNull(methodElement);
+      checkArgument(methodElement.getKind().equals(METHOD));
+      checkArgument(methodElement.getAnnotation(Inject.class) != null);
+      return new AutoValue_MembersInjectionBinding(methodElement,
+          dependencyRequestFactory.forVariables(methodElement.getParameters()));
+    }
+
+    /** Returns the field injection binding for a field annotated with {@link Inject}. */
+    MembersInjectionBinding forInjectField(VariableElement fieldElement) {
+      checkNotNull(fieldElement);
+      checkArgument(fieldElement.getKind().equals(FIELD));
+      checkArgument(fieldElement.getAnnotation(Inject.class) != null);
+      return new AutoValue_MembersInjectionBinding(fieldElement,
+          ImmutableSet.of(dependencyRequestFactory.forVariable(fieldElement)));
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorDescriptor.java
new file mode 100644
index 000000000..ce8845bfd
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorDescriptor.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Function;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableSortedSet;
+import com.google.common.collect.Iterables;
+
+import javax.lang.model.element.TypeElement;
+
+/**
+ * Represents the collection of {@link MembersInjectionBinding} instances that represent the total
+ * set of bindings for a single class.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+@AutoValue
+abstract class MembersInjectorDescriptor {
+  abstract ImmutableSortedSet<MembersInjectionBinding> bindings();
+  abstract TypeElement injectedClass();
+
+  ClassName injectedClassName() {
+    return ClassName.fromTypeElement(injectedClass());
+  }
+
+  /**
+   * Creates a {@link MembersInjectorDescriptor} for the given bindings.
+   *
+   * @throws IllegalArgumentException if the bindings are not all associated with the same type.
+   */
+  static MembersInjectorDescriptor create(Iterable<MembersInjectionBinding> bindings) {
+    ImmutableSortedSet<MembersInjectionBinding> bindingSet =
+        ImmutableSortedSet.copyOf(MembersInjectionBinding.injectionOrdering(), bindings);
+    TypeElement injectedTypeElement = Iterables.getOnlyElement(FluentIterable.from(bindings)
+        .transform(new Function<MembersInjectionBinding, TypeElement>() {
+          @Override public TypeElement apply(MembersInjectionBinding binding) {
+            return binding.enclosingType();
+          }
+        })
+        .toSet());
+    return new AutoValue_MembersInjectorDescriptor(bindingSet, injectedTypeElement);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
new file mode 100644
index 000000000..c4555454c
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -0,0 +1,224 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Function;
+import com.google.common.base.Functions;
+import com.google.common.base.Joiner;
+import com.google.common.base.Optional;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableBiMap;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSortedSet;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Ordering;
+import com.squareup.javawriter.JavaWriter;
+import dagger.MembersInjector;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.EnumSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+import javax.annotation.Generated;
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.Name;
+import javax.lang.model.element.VariableElement;
+
+import static com.squareup.javawriter.JavaWriter.stringLiteral;
+import static com.squareup.javawriter.JavaWriter.type;
+import static dagger.internal.codegen.SourceFiles.DEPENDENCY_ORDERING;
+import static dagger.internal.codegen.SourceFiles.collectImportsFromDependencies;
+import static dagger.internal.codegen.SourceFiles.flattenVariableMap;
+import static dagger.internal.codegen.SourceFiles.generateProviderNames;
+import static dagger.internal.codegen.SourceFiles.providerUsageStatement;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+
+/**
+ * Generates {@link MembersInjector} implementations from {@link MembersInjectionBinding} instances.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+final class MembersInjectorGenerator extends SourceFileGenerator<MembersInjectorDescriptor> {
+  private final ProviderTypeRepository providerTypeRepository;
+
+  MembersInjectorGenerator(Filer filer, ProviderTypeRepository providerTypeRepository) {
+    super(filer);
+    this.providerTypeRepository = providerTypeRepository;
+  }
+
+  @Override
+  ClassName nameGeneratedType(MembersInjectorDescriptor descriptor) {
+    ClassName injectedClassName = descriptor.injectedClassName();
+    return injectedClassName.peerNamed(injectedClassName.simpleName() + "$$MembersInjector");
+  }
+
+  @Override
+  Iterable<? extends Element> getOriginatingElements(
+      MembersInjectorDescriptor descriptor) {
+    return FluentIterable.from(descriptor.bindings())
+        .transform(new Function<MembersInjectionBinding, Element>() {
+          @Override public Element apply(MembersInjectionBinding binding) {
+            return binding.bindingElement();
+          }
+        })
+        .toSet();
+  }
+
+  @Override
+  Optional<? extends Element> getElementForErrorReporting(MembersInjectorDescriptor input) {
+    return Optional.of(input.injectedClass());
+  }
+
+  @Override
+  void write(ClassName injectorClassName, JavaWriter writer, MembersInjectorDescriptor descriptor)
+      throws IOException {
+    ClassName injectedClassName = descriptor.injectedClassName();
+    ImmutableSortedSet<MembersInjectionBinding> bindings = descriptor.bindings();
+
+    writer.emitPackage(injectedClassName.packageName());
+
+    ImmutableSortedSet<DependencyRequest> dependencies = FluentIterable.from(descriptor.bindings())
+        .transformAndConcat(new Function<MembersInjectionBinding, Set<DependencyRequest>>() {
+          @Override public Set<DependencyRequest> apply(MembersInjectionBinding input) {
+            return input.dependencies();
+          }
+        })
+        .toSortedSet(DEPENDENCY_ORDERING);
+
+    List<ClassName> importsBuilder = new ArrayList<ClassName>();
+    importsBuilder.addAll(collectImportsFromDependencies(injectorClassName, dependencies));
+    importsBuilder.add(ClassName.fromClass(MembersInjector.class));
+    importsBuilder.add(ClassName.fromClass(Generated.class));
+    ImmutableSortedSet<String> imports = FluentIterable.from(importsBuilder)
+        .transform(Functions.toStringFunction())
+        .toSortedSet(Ordering.natural());
+    writer.emitImports(imports).emitEmptyLine();
+
+    writer.emitJavadoc("A {@link MembersInjector} implementation for {@link %s}.",
+        injectedClassName.simpleName());
+
+    String membersInjectorType = type(MembersInjector.class, injectedClassName.simpleName());
+    // @Generated("dagger.internal.codegen.InjectProcessor")
+    // public final class Blah$$MembersInjector implements MembersInjector<Blah>
+    writer.emitAnnotation(Generated.class, stringLiteral(InjectProcessor.class.getName()))
+        .beginType(injectorClassName.simpleName(), "class", EnumSet.of(FINAL), null,
+            membersInjectorType);
+
+
+    final ImmutableBiMap<Key, String> providerNames = generateProviderNames(descriptor.bindings());
+
+    // Add the fields
+    writeProviderFields(writer, providerNames);
+
+    // Add the constructor
+    writeConstructor(writer, providerNames);
+
+    // @Override public void injectMembers(Blah instance)
+    writer.emitAnnotation(Override.class)
+        .beginMethod("void", "injectMembers", EnumSet.of(PUBLIC),
+            injectedClassName.simpleName(), "instance");
+    // TODO(gak): figure out what (if anything) to do about being passed a subtype of the class
+    // specified as the type parameter for the MembersInjector.
+    writer.beginControlFlow("if (instance == null)")
+        .emitStatement(
+            "throw new NullPointerException(\"Cannot inject members into a null reference\")")
+        .endControlFlow();
+
+    for (MembersInjectionBinding binding : bindings) {
+      Element target = binding.bindingElement();
+      switch (target.getKind()) {
+        case FIELD:
+          Name fieldName = ((VariableElement) target).getSimpleName();
+          DependencyRequest singleDependency = Iterables.getOnlyElement(binding.dependencies());
+          String providerName = providerNames.get(singleDependency.key());
+          writer.emitStatement("instance.%s = %s",
+              fieldName, providerUsageStatement(providerName, singleDependency.kind()));
+          break;
+        case METHOD:
+          Name methodName = ((ExecutableElement) target).getSimpleName();
+          String parameterString =
+              Joiner.on(", ").join(FluentIterable.from(binding.dependencies())
+                  .transform(new Function<DependencyRequest, String>() {
+                    @Override public String apply(DependencyRequest input) {
+                      return providerUsageStatement(providerNames.get(input.key()), input.kind());
+                    }
+                  }));
+          writer.emitStatement("instance.%s(%s)", methodName, parameterString);
+          break;
+        default:
+          throw new IllegalStateException(target.getKind().toString());
+      }
+    }
+    writer.endMethod();
+
+    writeToString(writer, injectedClassName);
+
+    writer.endType();
+  }
+
+  private void writeProviderFields(JavaWriter writer, ImmutableBiMap<Key, String> providerNames)
+      throws IOException {
+    for (Entry<Key, String> providerEntry : providerNames.entrySet()) {
+      Key key = providerEntry.getKey();
+      // TODO(gak): provide more elaborate information about which requests relate
+      writer.emitJavadoc(key.toString())
+          .emitField(providerTypeString(key), providerEntry.getValue(),
+              EnumSet.of(PRIVATE, FINAL));
+    }
+    writer.emitEmptyLine();
+  }
+
+  private void writeConstructor(JavaWriter writer, ImmutableBiMap<Key, String> providerNames)
+      throws IOException {
+    writer.beginConstructor(EnumSet.noneOf(Modifier.class),
+        flattenVariableMap(providersAsVariableMap(providerNames)),
+        ImmutableList.<String>of());
+    for (String providerName : providerNames.values()) {
+      writer.emitStatement("assert %s != null", providerName);
+      writer.emitStatement("this.%1$s = %1$s", providerName);
+    }
+    writer.endConstructor().emitEmptyLine();
+  }
+
+  private void writeToString(JavaWriter writer, ClassName injectedClassName) throws IOException {
+    writer.emitAnnotation(Override.class)
+        .beginMethod("String", "toString", EnumSet.of(PUBLIC))
+        .emitStatement("return \"%s<%s>\"",
+            MembersInjector.class.getSimpleName(), injectedClassName.simpleName())
+        .endMethod();
+  }
+
+  private Map<String, String> providersAsVariableMap(ImmutableBiMap<Key, String> providerNames) {
+    return Maps.transformValues(providerNames.inverse(), new Function<Key, String>() {
+      @Override public String apply(Key key) {
+        return providerTypeString(key);
+      }
+    });
+  }
+
+  private String providerTypeString(Key key) {
+    return Util.typeToString(providerTypeRepository.getProviderType(key));
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Mirrors.java b/compiler/src/main/java/dagger/internal/codegen/Mirrors.java
index 4c317002b..ad110df49 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Mirrors.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Mirrors.java
@@ -44,6 +44,7 @@
  * Utilities related to {@link TypeMirror} instances.
  *
  * @author Gregory Kick
+ * @since 2.0
  */
 final class Mirrors {
   private static final Equivalence<TypeMirror> TYPE_EQUIVALENCE = new Equivalence<TypeMirror>() {
@@ -247,6 +248,10 @@ static int hash(TypeMirror mirror) {
     return mirror == null ? 0 : mirror.accept(HASH_VISITOR, null);
   }
 
+  /**
+   * Returns the set of {@linkplain TypeElement types} that are referenced by the given
+   * {@link TypeMirror}.
+   */
   static ImmutableSet<TypeElement> referencedTypes(TypeMirror type) {
     checkNotNull(type);
     ImmutableSet.Builder<TypeElement> elements = ImmutableSet.builder();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
index f10efa31d..870fb87d6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
@@ -99,6 +99,8 @@
       remainingTypes.putAll(providerMethodsByClass(env));
     } catch (ClassCastException e) {
       return false; // upstream compiler issues - bail cleanly.
+    } catch (CodeGenerationIncompleteException e) {
+      return false; // upstream compiler issues - bail cleanly.
     }
     for (Iterator<String> i = remainingTypes.keySet().iterator(); i.hasNext();) {
       String typeName = i.next();
@@ -147,6 +149,10 @@ private void error(String msg, Element element) {
 
     provides:
     for (Element providerMethod : findProvidesMethods(env)) {
+      if (providerMethod.getAnnotation(Provides.class) == null) {
+        throw new CodeGenerationIncompleteException("Missing import of dagger.Provides.");
+      }
+
       switch (providerMethod.getEnclosingElement().getKind()) {
         case CLASS:
           break; // valid, move along
diff --git a/compiler/src/main/java/dagger/internal/codegen/PrintableErrorMessage.java b/compiler/src/main/java/dagger/internal/codegen/PrintableErrorMessage.java
new file mode 100644
index 000000000..bb9ba982c
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/PrintableErrorMessage.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import javax.annotation.processing.Messager;
+
+/**
+ * An interface for types that represent a compilation
+ * {@linkplain javax.tools.Diagnostic.Kind#ERROR error} (though, not necessarily a
+ * {@link Throwable}) that can be printed using a {@link Messager}.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+interface PrintableErrorMessage {
+  /**
+   * Prints the information represented by this object to the given {@link Messager} as an
+   * {@link javax.tools.Diagnostic.Kind#ERROR}.
+   */
+  void printMessageTo(Messager messager);
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProviderTypeRepository.java b/compiler/src/main/java/dagger/internal/codegen/ProviderTypeRepository.java
new file mode 100644
index 000000000..67c7b8eda
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ProviderTypeRepository.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+import com.google.common.cache.CacheBuilder;
+import com.google.common.cache.CacheLoader;
+import com.google.common.cache.LoadingCache;
+
+import javax.inject.Provider;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+/**
+ * A simple repository for {@link Provider} {@link DeclaredType types} for a given {@link Key}. For
+ * example, a key for {@code @Named("foo") Set<String>} would return the type representing
+ * {@code Provider<Set<String>>}.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+final class ProviderTypeRepository {
+  private final LoadingCache<Key, DeclaredType> providerTypeCache;
+
+  ProviderTypeRepository(final Elements elements, final Types types) {
+    checkNotNull(elements);
+    checkNotNull(types);
+    this.providerTypeCache = CacheBuilder.newBuilder()
+        .concurrencyLevel(1)
+        .softValues() // just to make sure we don't OOME the compiler
+        .build(new CacheLoader<Key, DeclaredType>() {
+          TypeElement providerTypeElement =
+              elements.getTypeElement(Provider.class.getCanonicalName());
+
+          @Override public DeclaredType load(Key key) {
+            return types.getDeclaredType(providerTypeElement, key.type());
+          }
+        });
+  }
+
+  DeclaredType getProviderType(Key key) {
+    checkNotNull(key);
+    return providerTypeCache.getUnchecked(key);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
new file mode 100644
index 000000000..ba2760043
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
+import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
+import static javax.lang.model.element.ElementKind.FIELD;
+import static javax.lang.model.element.ElementKind.METHOD;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Sets;
+
+import dagger.Provides;
+
+import javax.inject.Inject;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * A value object representing the mechanism by which a {@link Key} can be provided. New instances
+ * should be created using an instance of the {@link Factory}.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+@AutoValue
+abstract class ProvisionBinding extends Binding {
+  /** The {@link Key} that is provided by this binding. */
+  abstract Key providedKey();
+
+  /** The scope in which the binding declares the {@link #providedKey()}. */
+  abstract Optional<AnnotationMirror> scope();
+
+  /** Returns {@code true} if this provision binding requires members to be injected implicitly. */
+  abstract boolean requiresMemberInjection();
+
+  static final class Factory {
+    private final DependencyRequest.Factory keyRequestFactory;
+
+    Factory(DependencyRequest.Factory keyRequestFactory) {
+      this.keyRequestFactory = keyRequestFactory;
+    }
+
+    ProvisionBinding forInjectConstructor(ExecutableElement constructorElement) {
+      checkNotNull(constructorElement);
+      checkArgument(constructorElement.getKind().equals(CONSTRUCTOR));
+      checkArgument(constructorElement.getAnnotation(Inject.class) != null);
+      Key key = Key.forInjectConstructor(constructorElement);
+      checkArgument(!key.qualifier().isPresent());
+      return new AutoValue_ProvisionBinding(constructorElement,
+          keyRequestFactory.forVariables(constructorElement.getParameters()),
+          key,
+          getScopeAnnotation(constructorElement.getEnclosingElement()),
+          requiresMemeberInjection(
+              ElementUtil.asTypeElement(constructorElement.getEnclosingElement())));
+    }
+
+    private static final ImmutableSet<ElementKind> MEMBER_KINDS =
+        Sets.immutableEnumSet(METHOD, FIELD);
+
+    private static boolean requiresMemeberInjection(TypeElement type) {
+      for (Element enclosedElement : type.getEnclosedElements()) {
+        if (MEMBER_KINDS.contains(enclosedElement.getKind())
+            && (enclosedElement.getAnnotation(Inject.class) != null)) {
+          return true;
+        }
+      }
+      return false;
+    }
+
+    ProvisionBinding forProvidesMethod(ExecutableElement providesMethod) {
+      checkNotNull(providesMethod);
+      checkArgument(providesMethod.getKind().equals(CONSTRUCTOR));
+      checkArgument(providesMethod.getAnnotation(Provides.class) != null);
+      return new AutoValue_ProvisionBinding(providesMethod,
+          keyRequestFactory.forVariables(providesMethod.getParameters()),
+          Key.forProvidesMethod(providesMethod),
+          getScopeAnnotation(providesMethod),
+          false);
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java
new file mode 100644
index 000000000..b1c40eafb
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static javax.tools.Diagnostic.Kind.ERROR;
+
+import com.google.common.base.Optional;
+
+import javax.annotation.processing.Messager;
+import javax.lang.model.element.Element;
+
+/**
+ * An exception thrown to indicate that a source file could not be generated.
+ *
+ * <p>This exception <b>should not</b> be used to report detectable, logical errors as it may mask
+ * other errors that might have been caught upon further processing.  Use a {@link ValidationReport}
+ * for that.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+final class SourceFileGenerationException extends Exception implements PrintableErrorMessage {
+  private final ClassName generatedClassName;
+  private final Optional<? extends Element> associatedElement;
+
+  SourceFileGenerationException(ClassName generatedClassName, Throwable cause,
+      Optional<? extends Element> associatedElement) {
+    super(createMessage(generatedClassName, cause.getMessage()), cause);
+    this.generatedClassName = checkNotNull(generatedClassName);
+    this.associatedElement = checkNotNull(associatedElement);
+  }
+
+  SourceFileGenerationException(ClassName generatedClassName, Throwable cause) {
+    this(generatedClassName, cause, Optional.<Element>absent());
+  }
+
+  SourceFileGenerationException(ClassName generatedClassName, Throwable cause,
+      Element associatedElement) {
+    this(generatedClassName, cause, Optional.of(associatedElement));
+  }
+
+  public ClassName generatedClassName() {
+    return generatedClassName;
+  }
+
+  public Optional<? extends Element> associatedElement() {
+    return associatedElement;
+  }
+
+  private static String createMessage(ClassName generatedClassName, String message) {
+    return String.format("Could not generate %s: %s.", generatedClassName, message);
+  }
+
+  @Override
+  public void printMessageTo(Messager messager) {
+    if (associatedElement.isPresent()) {
+      messager.printMessage(ERROR, getMessage(), associatedElement.get());
+    } else {
+      messager.printMessage(ERROR, getMessage());
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
new file mode 100644
index 000000000..164499fc8
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+import com.google.common.base.Optional;
+import com.google.common.base.Throwables;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import com.squareup.javawriter.JavaWriter;
+
+import java.io.IOException;
+
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.Element;
+import javax.tools.JavaFileObject;
+
+/**
+ * A template class that provides a framework for properly handling IO while generating source files
+ * from an annotation processor.  Particularly, it makes a best effort to ensure that files that
+ * fail to write successfully are deleted.
+ *
+ * @param <T> The input type from which source is to be generated.
+ * @author Gregory Kick
+ * @since 2.0
+ */
+abstract class SourceFileGenerator<T> {
+  private final Filer filer;
+
+  SourceFileGenerator(Filer filer) {
+    this.filer = checkNotNull(filer);
+  }
+
+  final void generate(T input) throws SourceFileGenerationException {
+    ClassName generatedTypeName = nameGeneratedType(input);
+    ImmutableSet<Element> originatingElements = ImmutableSet.copyOf(getOriginatingElements(input));
+    JavaFileObject file = null;
+    try {
+      // first, try to create the file
+      file = filer.createSourceFile(generatedTypeName.fullyQualifiedName(),
+          Iterables.toArray(originatingElements, Element.class));
+      // try to create the writer
+      JavaWriter writer = new JavaWriter(file.openWriter());
+      boolean thrownWriting = false;
+      try {
+        write(generatedTypeName, writer, input);
+      } catch (Exception e) {
+        thrownWriting = true;
+        throw new SourceFileGenerationException(generatedTypeName, e,
+            getElementForErrorReporting(input));
+      } finally {
+        // good or bad, we have to close the stream
+        try {
+          writer.close();
+        } catch (IOException e) {
+          // only throw this exception if nothing was thrown during writing as that one is much
+          // more likely to be interesting
+          if (!thrownWriting) {
+            throw new SourceFileGenerationException(generatedTypeName, e,
+                getElementForErrorReporting(input));
+          }
+        }
+      }
+    } catch (Exception e) {
+      // deletes the file if any exception occurred creating the file, opening the writer or writing
+      // the contents
+      if (file != null) {
+        file.delete();
+      }
+      // if the code above threw a SFGE, use that
+      Throwables.propagateIfPossible(e, SourceFileGenerationException.class);
+      // otherwise, throw a new one
+      throw new SourceFileGenerationException(generatedTypeName, e,
+          getElementForErrorReporting(input));
+    }
+  }
+
+  /**
+   * Implementations should return the {@link ClassName} for the top-level type to be generated.
+   */
+  abstract ClassName nameGeneratedType(T input);
+
+  /**
+   * Implementations should return {@link Element} instances from which the source is to be
+   * generated.
+   */
+  abstract Iterable<? extends Element> getOriginatingElements(T input);
+
+  /**
+   * Returns an optional element to be used for reporting errors. This returns a single element
+   * rather than a collection to reduce output noise.
+   */
+  abstract Optional<? extends Element> getElementForErrorReporting(T input);
+
+  /**
+   * Implementations should emit source using the given {@link JavaWriter} instance. It is not
+   * necessary to close the writer.
+   */
+  abstract void write(ClassName generatedTypeName, JavaWriter writer, T input) throws IOException;
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
new file mode 100644
index 000000000..55d4ece15
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -0,0 +1,202 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+
+import com.google.common.base.CaseFormat;
+import com.google.common.collect.BiMap;
+import com.google.common.collect.ComparisonChain;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.HashBiMap;
+import com.google.common.collect.ImmutableBiMap;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.ImmutableSortedMap;
+import com.google.common.collect.ImmutableSortedSet;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Ordering;
+import com.squareup.javawriter.JavaWriter;
+
+import dagger.Lazy;
+import dagger.MembersInjector;
+import dagger.internal.DoubleCheckLazy;
+
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Map.Entry;
+
+import javax.inject.Provider;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * Utilities for generating files.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+class SourceFiles {
+  /**
+   * Given a mapping from variable name to type, returns a list of tokens suitable for methods such
+   * as {@link JavaWriter#beginMethod(String, String, java.util.Set, String...)}.
+   */
+  // TODO(gak): push this change upstream to obviate the need for this utility
+  static ImmutableList<String> flattenVariableMap(Map<String, String> variableMap) {
+    ImmutableList.Builder<String> tokenList = ImmutableList.builder();
+    for (Entry<String, String> variableEntry : variableMap.entrySet()) {
+      tokenList.add(variableEntry.getValue(), variableEntry.getKey());
+    }
+    return tokenList.build();
+  }
+
+  /**
+   * Returns the sorted set of all classes required by the {@link MembersInjector} implementation
+   * being generated.
+   */
+  static ImmutableSortedSet<ClassName> collectImportsFromDependencies(ClassName topLevelClassName,
+      Iterable<? extends DependencyRequest> dependencies) {
+    ImmutableSortedSet.Builder<ClassName> builder = ImmutableSortedSet.<ClassName>naturalOrder();
+    ImmutableSet<String> packagesToSkip  =
+        ImmutableSet.of("java.lang", topLevelClassName.packageName());
+    for (DependencyRequest dependency : dependencies) {
+      ImmutableSet<TypeElement> referencedTypes = Mirrors.referencedTypes(dependency.key().type());
+      switch (dependency.kind()) {
+        case LAZY:
+          builder.add(ClassName.fromClass(Lazy.class), ClassName.fromClass(DoubleCheckLazy.class));
+          // fall through
+        case INSTANCE:
+        case PROVIDER:
+          builder.add(ClassName.fromClass(Provider.class));
+          break;
+        default:
+          throw new AssertionError();
+      }
+      for (TypeElement referencedType : referencedTypes) {
+        ClassName className = ClassName.fromTypeElement(referencedType);
+        // don't include classes in java.lang or the same package
+        if (!packagesToSkip.contains(className.packageName())
+            // or that are members of the same top-level class
+            && !className.nameOfTopLevelClass().equals(topLevelClassName)) {
+          builder.add(className);
+        }
+      }
+    }
+    return builder.build();
+  }
+
+  /**
+   * Sorts {@link DependencyRequest} instances in an order likely to reflect their logical
+   * importance.
+   */
+  static final Ordering<DependencyRequest> DEPENDENCY_ORDERING =
+      new Ordering<DependencyRequest>() {
+        @Override public int compare(DependencyRequest left, DependencyRequest right) {
+          return ComparisonChain.start()
+              // put fields before parameters
+              .compare(left.requestElement().getKind(), right.requestElement().getKind())
+              // order by dependency kind
+              .compare(left.kind(), right.kind())
+              // then sort by name
+              .compare(
+                  left.requestElement().getSimpleName().toString(),
+                  right.requestElement().getSimpleName().toString())
+              .result();
+        }
+      };
+
+  /**
+   * This method generates names for the {@link Provider} references necessary for all of the
+   * bindings. It is responsible for the following:
+   * <ul>
+   * <li>Choosing a name that associates the provider with all of the dependency requests for this
+   * type.
+   * <li>Choosing a name that is <i>probably</i> associated with the type being provided.
+   * <li>Ensuring that no two providers end up with the same name.
+   * </ul>
+   *
+   * @return Returns the mapping from {@link Key} to provider name sorted by the name of the
+   * provider.
+   */
+  static ImmutableBiMap<Key, String> generateProviderNames(
+      Iterable<? extends Binding> bindings) {
+    ImmutableSetMultimap.Builder<Key, DependencyRequest> dependenciesByKeyBuilder =
+        new ImmutableSetMultimap.Builder<Key, DependencyRequest>()
+            .orderValuesBy(DEPENDENCY_ORDERING);
+    for (Binding binding : bindings) {
+      for (DependencyRequest dependency : binding.dependencies()) {
+        dependenciesByKeyBuilder.put(dependency.key(), dependency);
+      }
+    }
+    ImmutableSetMultimap<Key, DependencyRequest> dependenciesByKey =
+        dependenciesByKeyBuilder.build();
+    Map<Key, Collection<DependencyRequest>> dependenciesByKeyMap = dependenciesByKey.asMap();
+    BiMap<Key, String> providerNames = HashBiMap.create(dependenciesByKeyMap.size());
+    for (Entry<Key, Collection<DependencyRequest>> entry : dependenciesByKeyMap.entrySet()) {
+      // collect together all of the names that we would want to call the provider
+      ImmutableSet<String> dependencyNames = FluentIterable.from(entry.getValue())
+          .transform(new DependencyVariableNamer())
+          .toSet();
+
+      final String baseProviderName;
+      if (dependencyNames.size() == 1) {
+        // if there's only one name, great!  use it!
+        String name = Iterables.getOnlyElement(dependencyNames);
+        baseProviderName = name.endsWith("Provider") ? name : name + "Provider";
+      } else {
+        // in the event that a provider is being used for a bunch of deps with different names,
+        // add all the names together with "And"s in the middle.  E.g.: stringAndS
+        Iterator<String> namesIterator = dependencyNames.iterator();
+        String first = namesIterator.next();
+        StringBuilder compositeNameBuilder = new StringBuilder(first);
+        while (namesIterator.hasNext()) {
+          compositeNameBuilder.append("And")
+              .append(CaseFormat.LOWER_CAMEL.to(UPPER_CAMEL, namesIterator.next()));
+        }
+        baseProviderName = compositeNameBuilder.append("Provider").toString();
+      }
+
+      // in the unlikely event that we have more that one provider with the exact same name,
+      // just add numbers at the end until there is no collision
+      String candidateName = baseProviderName;
+      for (int candidateNum = 2; providerNames.containsValue(candidateName); candidateNum++) {
+        candidateName = baseProviderName + candidateNum;
+      }
+
+      providerNames.put(entry.getKey(), candidateName);
+    }
+    // return the map so that it is sorted by name
+    return ImmutableBiMap.copyOf(ImmutableSortedMap.copyOf(providerNames.inverse())).inverse();
+  }
+
+  static String providerUsageStatement(String providerName,
+      DependencyRequest.Kind dependencyKind) {
+    switch (dependencyKind) {
+      case LAZY:
+        return String.format("%s.create(%s)",
+            DoubleCheckLazy.class.getSimpleName(), providerName);
+      case INSTANCE:
+        return String.format("%s.get()", providerName);
+      case PROVIDER:
+        return String.format("%s", providerName);
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  private SourceFiles() {}
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index db6e79641..0166e5535 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -16,12 +16,17 @@
  */
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+
 import dagger.internal.Keys;
+
 import java.lang.reflect.Method;
 import java.util.Arrays;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.AnnotationValueVisitor;
@@ -356,6 +361,20 @@ static boolean isStatic(Element element) {
     return false;
   }
 
+  static boolean isValidJavaIdentifier(String possibleIdentifier) {
+    checkNotNull(possibleIdentifier);
+    checkArgument(!possibleIdentifier.isEmpty());
+    if (!Character.isJavaIdentifierStart(possibleIdentifier.charAt(0))) {
+      return false;
+    }
+    for (int i = 1; i < possibleIdentifier.length(); i++) {
+      if (!Character.isJavaIdentifierPart(possibleIdentifier.charAt(i))) {
+        return false;
+      }
+    }
+    return true;
+  }
+
   /**
    * An exception thrown when a type is not extant (returns as an error type),
    * usually as a result of another processor not having yet generated its types upon
diff --git a/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java b/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
index a5b7aa4e3..a337fc83c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
@@ -50,12 +50,13 @@ void printMessagesTo(Messager messager) {
   }
 
   @AutoValue
-  static abstract class Item {
+  static abstract class Item implements PrintableErrorMessage {
     abstract String message();
     abstract Element element();
     abstract Optional<AnnotationMirror> annotation();
 
-    void printMessageTo(Messager messager) {
+    @Override
+    public void printMessageTo(Messager messager) {
       if (annotation().isPresent()) {
         messager.printMessage(ERROR, message(), element(), annotation().get());
       } else {
diff --git a/compiler/src/test/java/dagger/internal/codegen/ClassNameTest.java b/compiler/src/test/java/dagger/internal/codegen/ClassNameTest.java
new file mode 100644
index 000000000..8895aff5e
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/ClassNameTest.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableList;
+import java.util.Map;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static org.junit.Assert.fail;
+import static org.truth0.Truth.ASSERT;
+
+@RunWith(JUnit4.class)
+public class ClassNameTest {
+  @Test public void bestGuessForString_simpleClass() {
+    ASSERT.that(ClassName.bestGuessFromString(String.class.getName()))
+        .isEqualTo(ClassName.create("java.lang", "String"));
+  }
+
+  static class OuterClass {
+    static class InnerClass {}
+  }
+
+  @Test public void bestGuessForString_nestedClass() {
+    ASSERT.that(ClassName.bestGuessFromString(Map.Entry.class.getCanonicalName()))
+        .isEqualTo(ClassName.create("java.util", ImmutableList.of("Map"), "Entry"));
+    ASSERT.that(ClassName.bestGuessFromString(OuterClass.InnerClass.class.getCanonicalName()))
+        .isEqualTo(
+            ClassName.create("dagger.internal.codegen",
+                ImmutableList.of("ClassNameTest", "OuterClass"), "InnerClass"));
+  }
+
+  @Test public void bestGuessForString_defaultPackage() {
+    ASSERT.that(ClassName.bestGuessFromString("SomeClass"))
+        .isEqualTo(ClassName.create("", "SomeClass"));
+    ASSERT.that(ClassName.bestGuessFromString("SomeClass.Nested"))
+        .isEqualTo(ClassName.create("", ImmutableList.of("SomeClass"), "Nested"));
+    ASSERT.that(ClassName.bestGuessFromString("SomeClass.Nested.EvenMore"))
+        .isEqualTo(ClassName.create("", ImmutableList.of("SomeClass", "Nested"), "EvenMore"));
+  }
+
+  @Test public void bestGuessForString_confusingInput() {
+    try {
+      ClassName.bestGuessFromString("com.test.$");
+      fail();
+    } catch (IllegalArgumentException expected) {}
+    try {
+      ClassName.bestGuessFromString("com.test.LooksLikeAClass.pkg");
+      fail();
+    } catch (IllegalArgumentException expected) {}
+    try {
+      ClassName.bestGuessFromString("!@#$gibberish%^&*");
+      fail();
+    } catch (IllegalArgumentException expected) {}
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java
index a78f59fb2..dc23b0bfd 100644
--- a/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java
@@ -40,8 +40,8 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-
 @RunWith(JUnit4.class)
+// TODO(gak): add tests for generation in the default package.
 public final class InjectProcessorTest {
   private static final JavaFileObject QUALIFIER_A =
       JavaFileObjects.forSourceLines("test.QualifierA",
@@ -269,4 +269,288 @@
         // for whatever reason, javac only reports the error once on the method
         .withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6);
   }
+
+  @Test public void fieldInjection() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.FieldInjection",
+        "package test;",
+        "",
+        "import dagger.Lazy;",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "class FieldInjection {",
+        "  @Inject String string;",
+        "  @Inject Lazy<String> lazyString;",
+        "  @Inject Provider<String> stringProvider;",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines("test.FieldInjection$$MembersInjector",
+        "package test;",
+        "",
+        "import dagger.Lazy;",
+        "import dagger.MembersInjector;",
+        "import dagger.internal.DoubleCheckLazy;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.InjectProcessor\")",
+        "final class FieldInjection$$MembersInjector ",
+        "    implements MembersInjector<FieldInjection> {",
+        "",
+        "  private final Provider<String> stringProvider;",
+        "",
+        "  FieldInjection$$MembersInjector(Provider<String> stringProvider) {",
+        "    assert stringProvider != null;",
+        "    this.stringProvider = stringProvider;",
+        "  }",
+        "",
+        "  @Override public void injectMembers(FieldInjection instance) {",
+        "    if (instance == null) {",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+        "    }",
+        "    instance.string = stringProvider.get();",
+        "    instance.lazyString = DoubleCheckLazy.create(stringProvider);",
+        "    instance.stringProvider = stringProvider;",
+        "  }",
+        "",
+        "  @Override public String toString() {",
+        "    return \"MembersInjector<FieldInjection>\";",
+        "  }",
+        "}");
+    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test public void methodInjection() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.MethodInjection",
+        "package test;",
+        "",
+        "import dagger.Lazy;",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "class MethodInjection {",
+        "  @Inject void noArgs() {}",
+        "  @Inject void oneArg(String string) {}",
+        "  @Inject void manyArgs(",
+        "      String string, Lazy<String> lazyString, Provider<String> stringProvider) {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines(
+        "test.MethodInjection$$MembersInjector",
+        "package test;",
+        "",
+        "import dagger.Lazy;",
+        "import dagger.MembersInjector;",
+        "import dagger.internal.DoubleCheckLazy;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.InjectProcessor\")",
+        "final class MethodInjection$$MembersInjector ",
+        "    implements MembersInjector<MethodInjection> {",
+        "",
+        "  private final Provider<String> stringProvider;",
+        "",
+        "  MethodInjection$$MembersInjector(Provider<String> stringProvider) {",
+        "    assert stringProvider != null;",
+        "    this.stringProvider = stringProvider;",
+        "  }",
+        "",
+        "  @Override public void injectMembers(MethodInjection instance) {",
+        "    if (instance == null) {",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+        "    }",
+        "    instance.noArgs();",
+        "    instance.oneArg(stringProvider.get());",
+        "    instance.manyArgs(stringProvider.get(), DoubleCheckLazy.create(stringProvider),",
+        "        stringProvider);",
+        "  }",
+        "",
+        "  @Override public String toString() {",
+        "    return \"MembersInjector<MethodInjection>\";",
+        "  }",
+        "}");
+    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test public void mixedMemberInjection() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.MixedMemberInjection",
+        "package test;",
+        "",
+        "import dagger.Lazy;",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "class MixedMemberInjection {",
+        "  @Inject String string;",
+        "  @Inject void setString(String s) {}",
+        "  @Inject Object object;",
+        "  @Inject void setObject(Object o) {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines(
+        "test.MixedMemberInjection$$MembersInjector",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.InjectProcessor\")",
+        "final class MixedMemberInjection$$MembersInjector ",
+        "    implements MembersInjector<MixedMemberInjection> {",
+        "",
+        "  private final Provider<Object> objectAndOProvider;",
+        "  private final Provider<String> stringAndSProvider;",
+        "",
+        "  MixedMemberInjection$$MembersInjector(Provider<Object> objectAndOProvider,",
+        "      Provider<String> stringAndSProvider) {",
+        "    assert objectAndOProvider != null;",
+        "    this.objectAndOProvider = objectAndOProvider;",
+        "    assert stringAndSProvider != null;",
+        "    this.stringAndSProvider = stringAndSProvider;",
+        "  }",
+        "",
+        "  @Override public void injectMembers(MixedMemberInjection instance) {",
+        "    if (instance == null) {",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+        "    }",
+        "    instance.string = stringAndSProvider.get();",
+        "    instance.object = objectAndOProvider.get();",
+        "    instance.setString(stringAndSProvider.get());",
+        "    instance.setObject(objectAndOProvider.get());",
+        "  }",
+        "",
+        "  @Override public String toString() {",
+        "    return \"MembersInjector<MixedMemberInjection>\";",
+        "  }",
+        "}");
+    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test public void injectConstructor() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.InjectConstructor",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class InjectConstructor {",
+        "  @Inject InjectConstructor(String s) {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines(
+        "test.InjectConstructor$$Factory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.InjectProcessor\")",
+        "public final class InjectConstructor$$Factory ",
+        "    implements Factory<InjectConstructor> {",
+        "",
+        "  private final Provider<String> sProvider;",
+        "",
+        "  public InjectConstructor$$Factory(Provider<String> sProvider) {",
+        "    assert sProvider != null;",
+        "    this.sProvider = sProvider;",
+        "  }",
+        "",
+        "  @Override public InjectConstructor get() {",
+        "    return new InjectConstructor(sProvider.get());",
+        "  }",
+        "",
+        "  @Override public String toString() {",
+        "    return \"Factory<InjectConstructor>\";",
+        "  }",
+        "}");
+    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test public void injectConstructorAndMembersInjection() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.AllInjections",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class AllInjections {",
+        "  @Inject String s;",
+        "  @Inject AllInjections(String s) {}",
+        "  @Inject void s(String s) {}",
+        "}");
+    JavaFileObject expectedFactory = JavaFileObjects.forSourceLines(
+        "test.AllInjections$$Factory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.InjectProcessor\")",
+        "public final class AllInjections$$Factory ",
+        "    implements Factory<AllInjections> {",
+        "",
+        "  private final MembersInjector<AllInjections> membersInjector;",
+        "  private final Provider<String> sProvider;",
+        "",
+        "  public AllInjections$$Factory(MembersInjector<AllInjections> membersInjector, ",
+        "      Provider<String> sProvider) {",
+        "    assert membersInjector != null;",
+        "    this.membersInjector = membersInjector;",
+        "    assert sProvider != null;",
+        "    this.sProvider = sProvider;",
+        "  }",
+        "",
+        "  @Override public AllInjections get() {",
+        "    AllInjections instance = new AllInjections(sProvider.get());",
+        "    membersInjector.injectMembers(instance);",
+        "    return instance;",
+        "  }",
+        "",
+        "  @Override public String toString() {",
+        "    return \"Factory<AllInjections>\";",
+        "  }",
+        "}");
+    JavaFileObject expectedMembersInjector = JavaFileObjects.forSourceLines(
+        "test.AllInjections$$MembersInjector",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.InjectProcessor\")",
+        "final class AllInjections$$MembersInjector ",
+        "    implements MembersInjector<AllInjections> {",
+        "",
+        "  private final Provider<String> sProvider;",
+        "",
+        "  AllInjections$$MembersInjector(Provider<String> sProvider) {",
+        "    assert sProvider != null;",
+        "    this.sProvider = sProvider;",
+        "  }",
+        "",
+        "  @Override public void injectMembers(AllInjections instance) {",
+        "    if (instance == null) {",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+        "    }",
+        "    instance.s = sProvider.get();",
+        "    instance.s(sProvider.get());",
+        "  }",
+        "",
+        "  @Override public String toString() {",
+        "    return \"MembersInjector<AllInjections>\";",
+        "  }",
+        "}");
+    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(expectedFactory, expectedMembersInjector);
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/SourceFileGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/SourceFileGeneratorTest.java
new file mode 100644
index 000000000..7e5df19ad
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/SourceFileGeneratorTest.java
@@ -0,0 +1,159 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.anyString;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+import static org.truth0.Truth.ASSERT;
+
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableSet;
+import com.squareup.javawriter.JavaWriter;
+
+import java.io.IOException;
+import java.io.Writer;
+
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.Element;
+import javax.tools.JavaFileObject;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.runners.MockitoJUnitRunner;
+
+@RunWith(MockitoJUnitRunner.class)
+public class SourceFileGeneratorTest {
+  private static final ClassName FAKE_CLASS_NAME = ClassName.create("test", "FakeClass");
+
+  @Mock public Filer filer;
+  @Mock public JavaFileObject file;
+  @Mock public Writer writer;
+
+  private SourceFileGenerator<Void> generator;
+
+  @Before public void createGenerator() {
+    this.generator = new FailingSourceFileGenerator(filer);
+  }
+
+  @Test public void generate_failToCreateFile() throws Exception {
+    when(filer.createSourceFile(FAKE_CLASS_NAME.fullyQualifiedName()))
+      .thenThrow(new IOException("file creation"));
+    try {
+      generator.generate(null);
+      fail();
+    } catch (SourceFileGenerationException e) {
+      String message = e.getMessage();
+      ASSERT.that(message).contains(FAKE_CLASS_NAME.fullyQualifiedName());
+      ASSERT.that(message).contains("file creation");
+    }
+  }
+
+  @Test public void generate_failToOpenWriter() throws Exception {
+    when(filer.createSourceFile(FAKE_CLASS_NAME.fullyQualifiedName())).thenReturn(file);
+    when(file.openWriter()).thenThrow(new IOException("opening writer"));
+    try {
+      generator.generate(null);
+      fail();
+    } catch (SourceFileGenerationException e) {
+      String message = e.getMessage();
+      ASSERT.that(message).contains(FAKE_CLASS_NAME.fullyQualifiedName());
+      ASSERT.that(message).contains("opening writer");
+    }
+    verify(file).delete();
+  }
+
+  @Test public void generate_failToWrite() throws Exception {
+    when(filer.createSourceFile(FAKE_CLASS_NAME.fullyQualifiedName())).thenReturn(file);
+    when(file.openWriter()).thenReturn(writer);
+    doThrow(new IOException("writing")).when(writer).write(anyString());
+    try {
+      generator.generate(null);
+      fail();
+    } catch (SourceFileGenerationException e) {
+      String message = e.getMessage();
+      ASSERT.that(message).contains(FAKE_CLASS_NAME.fullyQualifiedName());
+      ASSERT.that(message).contains("writing");
+    }
+    verify(writer).close();
+    verify(file).delete();
+  }
+
+  @Test public void generate_failToWriteFailToClose() throws Exception {
+    when(filer.createSourceFile(FAKE_CLASS_NAME.fullyQualifiedName())).thenReturn(file);
+    when(file.openWriter()).thenReturn(writer);
+    doThrow(new IOException("writing")).when(writer).write(anyString());
+    doThrow(new IOException("closing writer")).when(writer).close();
+    try {
+      generator.generate(null);
+      fail();
+    } catch (SourceFileGenerationException e) {
+      String message = e.getMessage();
+      ASSERT.that(message).contains(FAKE_CLASS_NAME.fullyQualifiedName());
+      ASSERT.that(message).contains("writing");
+    }
+    verify(writer).close();
+    verify(file).delete();
+  }
+
+  @Test public void generate_failToClose() throws Exception {
+    when(filer.createSourceFile(FAKE_CLASS_NAME.fullyQualifiedName())).thenReturn(file);
+    when(file.openWriter()).thenReturn(writer);
+    doThrow(new IOException("closing writer")).when(writer).close();
+    try {
+      generator.generate(null);
+      fail();
+    } catch (SourceFileGenerationException e) {
+      String message = e.getMessage();
+      ASSERT.that(message).contains(FAKE_CLASS_NAME.fullyQualifiedName());
+      ASSERT.that(message).contains("closing writer");
+    }
+    verify(writer).close();
+    verify(file).delete();
+  }
+
+  private static final class FailingSourceFileGenerator extends SourceFileGenerator<Void> {
+    FailingSourceFileGenerator(Filer filer) {
+      super(filer);
+    }
+
+    @Override
+    ClassName nameGeneratedType(Void input) {
+      return FAKE_CLASS_NAME;
+    }
+
+    @Override
+    Iterable<? extends Element> getOriginatingElements(Void input) {
+      return ImmutableSet.of();
+    }
+
+    @Override
+    Optional<? extends Element> getElementForErrorReporting(Void input) {
+      return Optional.absent();
+    }
+
+    @Override
+    void write(ClassName generatedTypeName, JavaWriter writer, Void input) throws IOException {
+      writer.emitPackage(FAKE_CLASS_NAME.packageName())
+          .beginType("class", FAKE_CLASS_NAME.simpleName())
+          .endType();
+    }
+  }
+}
diff --git a/core/pom.xml b/core/pom.xml
index c9780ea86..401e02cb4 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -32,6 +32,11 @@
       <artifactId>javax.inject</artifactId>
     </dependency>
 
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+      <scope>test</scope>
+    </dependency>
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
diff --git a/core/src/main/java/dagger/Lazy.java b/core/src/main/java/dagger/Lazy.java
index 6b064661c..59419abd3 100644
--- a/core/src/main/java/dagger/Lazy.java
+++ b/core/src/main/java/dagger/Lazy.java
@@ -21,6 +21,10 @@
  * the first call to {@code get()} and remembers that same value for all
  * subsequent calls to {@code get()}.
  *
+ * <p>{@code null} is not a supported value.  Implementations of {@code Lazy}
+ * are expected to throw {@link NullPointerException} if the computed value is
+ * {@code null}.
+ *
  * <h2>Example</h2>
  * The differences between <strong>direct injection</strong>, <strong>provider
  * injection</strong> and <strong>lazy injection</strong> are best demonstrated
@@ -148,6 +152,8 @@
   /**
    * Return the underlying value, computing the value if necessary. All calls to
    * the same {@code Lazy} instance will return the same result.
+   *
+   * @throws NullPointerException if the computed value is {@code null}.
    */
   T get();
 }
diff --git a/core/src/main/java/dagger/MembersInjector.java b/core/src/main/java/dagger/MembersInjector.java
index 372c9f585..d0de7f396 100644
--- a/core/src/main/java/dagger/MembersInjector.java
+++ b/core/src/main/java/dagger/MembersInjector.java
@@ -17,26 +17,28 @@
 package dagger;
 
 /**
- * Injects dependencies into the fields and methods on instances of type
- * {@code T}. Ignores the presence or absence of an injectable constructor.
+ * Injects dependencies into the fields and methods on instances of type {@code T}. Ignores the
+ * presence or absence of an injectable constructor.
  *
  * @param <T> type to inject members of
  *
  * @author Bob Lee
  * @author Jesse Wilson
+ * @since 2.0 (since 1.0 without the provision that {@link #injectMembers} cannot accept
+ *      {@code null})
  */
 public interface MembersInjector<T> {
 
   /**
-   * Injects dependencies into the fields and methods of {@code instance}.
-   * Ignores the presence or absence of an injectable constructor.
+   * Injects dependencies into the fields and methods of {@code instance}. Ignores the presence or
+   * absence of an injectable constructor.
    *
-   * <p>Whenever the object graph creates an instance, it performs this
-   * injection automatically (after first performing constructor injection), so
-   * if you're able to let the object graph create all your objects for you,
-   * you'll never need to use this method.
+   * <p>Whenever the object graph creates an instance, it performs this injection automatically
+   * (after first performing constructor injection), so if you're able to let the object graph
+   * create all your objects for you, you'll never need to use this method.
    *
-   * @param instance to inject members on. May be {@code null}.
+   * @param instance into which members are to be injected
+   * @throws NullPointerException if {@code instance} is {@code null}
    */
   void injectMembers(T instance);
 }
diff --git a/core/src/main/java/dagger/internal/DoubleCheckLazy.java b/core/src/main/java/dagger/internal/DoubleCheckLazy.java
new file mode 100644
index 000000000..e18526ea1
--- /dev/null
+++ b/core/src/main/java/dagger/internal/DoubleCheckLazy.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import dagger.Lazy;
+
+import javax.inject.Provider;
+
+/**
+ * A basic {@link Lazy} implementation that memoizes the value returned from a {@link Provider}
+ * using the double-check idiom described in Effective Java 2: Item 71.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+public final class DoubleCheckLazy<T> implements Lazy<T> {
+  private final Provider<T> provider;
+  private volatile T instance = null;
+
+  private DoubleCheckLazy(Provider<T> provider) {
+    assert provider != null;
+    this.provider = provider;
+  }
+
+  @Override
+  public T get() {
+    T result = instance;
+    if (result == null) {
+      synchronized (this) {
+        result = instance;
+        if (result == null) {
+          instance = result = provider.get();
+          if (result == null) {
+            throw new NullPointerException(provider + " returned null");
+          }
+        }
+      }
+    }
+    return result;
+  }
+
+  public static <T> Lazy<T> create(Provider<T> provider) {
+    if (provider == null) {
+      throw new NullPointerException();
+    }
+    return new DoubleCheckLazy<T>(provider);
+  }
+}
diff --git a/core/src/main/java/dagger/internal/LazyBinding.java b/core/src/main/java/dagger/internal/LazyBinding.java
index c1e1c715c..ef6f11c98 100644
--- a/core/src/main/java/dagger/internal/LazyBinding.java
+++ b/core/src/main/java/dagger/internal/LazyBinding.java
@@ -47,6 +47,7 @@ public void attach(Linker linker) {
 
   @Override
   public Lazy<T> get() {
+    // TODO(gak): Use DoubleCheckLazy
     return new Lazy<T>() {
       private volatile Object cacheValue = NOT_PRESENT;
 
diff --git a/core/src/test/java/dagger/internal/DoubleCheckLazyTest.java b/core/src/test/java/dagger/internal/DoubleCheckLazyTest.java
new file mode 100644
index 000000000..6e64f6ec5
--- /dev/null
+++ b/core/src/test/java/dagger/internal/DoubleCheckLazyTest.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import static org.junit.Assert.fail;
+import static org.truth0.Truth.ASSERT;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Sets;
+import com.google.common.util.concurrent.Uninterruptibles;
+
+import dagger.Lazy;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.Callable;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import javax.inject.Provider;
+
+@RunWith(JUnit4.class)
+public class DoubleCheckLazyTest {
+  @Test public void get() throws Exception {
+    int numThreads = 10;
+    ExecutorService executor = Executors.newFixedThreadPool(numThreads);
+
+    final CountDownLatch latch = new CountDownLatch(numThreads);
+    LatchedProvider provider = new LatchedProvider(latch);
+    final Lazy<Object> lazy = DoubleCheckLazy.create(provider);
+
+    List<Callable<Object>> tasks = Lists.newArrayListWithCapacity(numThreads);
+    for (int i = 0; i < numThreads; i++) {
+      tasks.add(new Callable<Object>() {
+        @Override public Object call() throws Exception {
+          latch.countDown();
+          return lazy.get();
+        }
+      });
+    }
+
+    List<Future<Object>> futures = executor.invokeAll(tasks);
+
+    ASSERT.that(provider.provisions.get()).is(1);
+    Set<Object> results = Sets.newIdentityHashSet();
+    for (Future<Object> future : futures) {
+      results.add(future.get());
+    }
+    ASSERT.that(results.size()).is(1);
+  }
+
+  @Test public void get_null() {
+    Lazy<Object> lazy = DoubleCheckLazy.create(new Provider<Object> () {
+      @Override public Object get() {
+        return null;
+      }
+    });
+    try {
+      lazy.get();
+      fail();
+    } catch (NullPointerException expected) {}
+  }
+
+  private static class LatchedProvider implements Provider<Object> {
+    final AtomicInteger provisions;
+    final CountDownLatch latch;
+
+    LatchedProvider(CountDownLatch latch) {
+      this.latch = latch;
+      this.provisions = new AtomicInteger();
+    }
+
+    @Override
+    public Object get() {
+      if (latch != null) {
+        Uninterruptibles.awaitUninterruptibly(latch);
+      }
+      provisions.incrementAndGet();
+      return new Object();
+    }
+  }
+}
diff --git a/pom.xml b/pom.xml
index 1d8d53a1f..9873ee301 100644
--- a/pom.xml
+++ b/pom.xml
@@ -47,10 +47,11 @@
     <guava.version>16.0.1</guava.version>
 
     <!-- Test Dependencies -->
-    <junit.version>4.10</junit.version>
+    <compile-testing.version>0.5</compile-testing.version>
     <fest.version>1.4</fest.version>
+    <junit.version>4.10</junit.version>
+    <mockito.version>1.9.5</mockito.version>
     <truth.version>0.13</truth.version>
-    <compile-testing.version>0.5</compile-testing.version>
   </properties>
 
   <scm>
@@ -114,6 +115,11 @@
         <artifactId>compile-testing</artifactId>
         <version>${compile-testing.version}</version>
       </dependency>
+      <dependency>
+        <groupId>org.mockito</groupId>
+        <artifactId>mockito-core</artifactId>
+        <version>${mockito.version}</version>
+      </dependency>
       <dependency>
         <groupId>org.truth0</groupId>
         <artifactId>truth</artifactId>
