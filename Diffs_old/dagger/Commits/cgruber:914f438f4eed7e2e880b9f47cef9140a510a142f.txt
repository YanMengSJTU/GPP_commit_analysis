diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java
index efbd5a593..845e52426 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java
@@ -21,6 +21,7 @@
 import dagger.producers.ProductionComponent;
 import java.util.Map;
 import java.util.Set;
+import producerstest.multibindings.Qualifiers.ObjCount;
 import producerstest.multibindings.Qualifiers.PossiblyThrowingMap;
 import producerstest.multibindings.Qualifiers.PossiblyThrowingSet;
 
@@ -48,4 +49,17 @@
 
   @PossiblyThrowingMap
   ListenableFuture<Map<Integer, Produced<String>>> possiblyThrowingMapOfProduced();
+
+  ListenableFuture<Set<Object>> objs();
+
+  ListenableFuture<Set<Produced<Object>>> producedObjs();
+
+  ListenableFuture<Map<Object, Object>> objMap();
+
+  ListenableFuture<Map<Object, Produced<Object>>> objMapOfProduced();
+
+  ListenableFuture<Map<Object, Producer<Object>>> objMapOfProducer();
+
+  @ObjCount
+  ListenableFuture<Integer> objCount();
 }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java
index dbeefeede..d63da4d50 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java
@@ -18,12 +18,16 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
+import dagger.Multibindings;
 import dagger.mapkeys.IntKey;
+import dagger.producers.Produced;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
+import java.util.Map;
+import java.util.Set;
+import producerstest.multibindings.Qualifiers.ObjCount;
 import producerstest.multibindings.Qualifiers.PossiblyThrowingMap;
 import producerstest.multibindings.Qualifiers.PossiblyThrowingSet;
-import java.util.Set;
 
 import static dagger.producers.Produces.Type.MAP;
 import static dagger.producers.Produces.Type.SET;
@@ -99,4 +103,17 @@ static String valueFor15() {
   static String throwingValueFor15() {
     throw new RuntimeException("monkey");
   }
+
+  @Multibindings
+  interface MultiBindings {
+    Set<Object> objs();
+
+    Map<Object, Object> objMap();
+  }
+
+  @Produces
+  @ObjCount
+  static int objCount(Set<Produced<Object>> objs, Map<Object, Produced<Object>> objMap) {
+    return objs.size() + objMap.size();
+  }
 }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/Qualifiers.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/Qualifiers.java
index 1a41b4330..c638270ed 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/Qualifiers.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/Qualifiers.java
@@ -32,5 +32,10 @@
   @Qualifier
   @interface PossiblyThrowingMap {}
 
+  @Documented
+  @Retention(RUNTIME)
+  @Qualifier
+  @interface ObjCount {}
+
   private Qualifiers() {}
 }
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/multibindings/MultibindingTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/multibindings/MultibindingTest.java
index 15ce7592c..0919fded2 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/multibindings/MultibindingTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/multibindings/MultibindingTest.java
@@ -158,4 +158,22 @@ public void mapOfProducedBindingWithFailures() throws Exception {
       assertThat(e.getCause()).hasMessage("monkey");
     }
   }
+
+  @Test
+  public void emptySet() throws Exception {
+    MultibindingComponent multibindingComponent =
+        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    assertThat(multibindingComponent.objs().get()).isEmpty();
+    assertThat(multibindingComponent.producedObjs().get()).isEmpty();
+    assertThat(multibindingComponent.objCount().get()).isEqualTo(0);
+  }
+
+  @Test
+  public void emptyMap() throws Exception {
+    MultibindingComponent multibindingComponent =
+        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    assertThat(multibindingComponent.objMap().get()).isEmpty();
+    assertThat(multibindingComponent.objMapOfProduced().get()).isEmpty();
+    assertThat(multibindingComponent.objMapOfProducer().get()).isEmpty();
+  }
 }
diff --git a/core/src/main/java/dagger/internal/SetFactory.java b/core/src/main/java/dagger/internal/SetFactory.java
index 9b73e79db..90dbb23eb 100644
--- a/core/src/main/java/dagger/internal/SetFactory.java
+++ b/core/src/main/java/dagger/internal/SetFactory.java
@@ -23,6 +23,7 @@
 import javax.inject.Provider;
 
 import static dagger.internal.Collections.newLinkedHashSetWithExpectedSize;
+import static java.util.Collections.emptySet;
 import static java.util.Collections.unmodifiableSet;
 
 /**
@@ -40,6 +41,19 @@
   private static final String ARGUMENTS_MUST_BE_NON_NULL =
       "SetFactory.create() requires its arguments to be non-null";
 
+  private static final Factory<Set<Object>> EMPTY_FACTORY =
+      new Factory<Set<Object>>() {
+        @Override
+        public Set<Object> get() {
+          return emptySet();
+        }
+      };
+
+  @SuppressWarnings({"unchecked", "rawtypes"}) // safe covariant cast
+  public static <T> Factory<Set<T>> create() {
+    return (Factory<Set<T>>) (Factory) EMPTY_FACTORY;
+  }
+
   /**
    * Returns the supplied factory.  If there's just one factory, there's no need to wrap it or its
    * result.
@@ -48,7 +62,7 @@
     assert factory != null : ARGUMENTS_MUST_BE_NON_NULL;
     return factory;
   }
-  
+
   /**
    * Returns a new factory that creates {@link Set} instances that form the union of the given
    * {@link Provider} instances.  Callers must not modify the providers array after invoking this
@@ -94,7 +108,7 @@ private SetFactory(List<Provider<Set<T>>> contributingProviders) {
     int size = 0;
 
     // Profiling revealed that this method was a CPU-consuming hotspot in some applications, so
-    // these loops were changed to use c-style for.  Versus enhanced for-each loops, C-style for is 
+    // these loops were changed to use c-style for.  Versus enhanced for-each loops, C-style for is
     // faster for ArrayLists, at least through Java 8.
 
     List<Set<T>> providedSets = new ArrayList<Set<T>>(contributingProviders.size());
diff --git a/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java b/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java
index e51bcad42..2862f6c3c 100644
--- a/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java
@@ -36,6 +36,10 @@
  * @since 2.0
  */
 public final class SetOfProducedProducer<T> extends AbstractProducer<Set<Produced<T>>> {
+  public static <T> Producer<Set<T>> create() {
+    return SetProducer.create();
+  }
+
   /**
    * Returns a new producer that creates {@link Set} futures from the union of the given
    * {@link Producer} instances.
diff --git a/producers/src/main/java/dagger/producers/internal/SetProducer.java b/producers/src/main/java/dagger/producers/internal/SetProducer.java
index 5b3c0902d..271d31b4d 100644
--- a/producers/src/main/java/dagger/producers/internal/SetProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/SetProducer.java
@@ -34,6 +34,27 @@
  * @since 2.0
  */
 public final class SetProducer<T> extends AbstractProducer<Set<T>> {
+  private static final Producer<Set<Object>> EMPTY_PRODUCER =
+      new Producer<Set<Object>>() {
+        @Override
+        public ListenableFuture<Set<Object>> get() {
+          return Futures.<Set<Object>>immediateFuture(ImmutableSet.<Object>of());
+        }
+      };
+
+  @SuppressWarnings({"unchecked", "rawtypes"}) // safe covariant cast
+  public static <T> Producer<Set<T>> create() {
+    return (Producer<Set<T>>) (Producer) EMPTY_PRODUCER;
+  }
+
+  /**
+   * Returns the supplied producer.  If there's just one producer, there's no need to wrap it or its
+   * result.
+   */
+  public static <T> Producer<Set<T>> create(Producer<Set<T>> producer) {
+    return producer;
+  }
+
   /**
    * Returns a new producer that creates {@link Set} futures from the union of the given
    * {@link Producer} instances.
