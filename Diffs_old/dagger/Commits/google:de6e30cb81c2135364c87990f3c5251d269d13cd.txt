diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 17aa0d36a..22f2960d2 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -21,7 +21,12 @@ load("//:build_defs.bzl", "DOCLINT_HTML_AND_SYNTAX", "DOCLINT_REFERENCES")
 
 EXPERIMENTAL_VISUALIZER_SRCS = ["BindingNetworkVisualizer.java"]
 
-KYTHE_SRCS = ["KytheBindingGraphFactory.java"]
+KYTHE_SRCS = [
+    "KytheBindingGraphFactory.java",
+    "DaggerKythePlugin.java",
+    "KytheFormatting.java",
+    "KeyVNameFactory.java",
+]
 
 CODEGEN_SRCS = glob(
     ["*.java"],
@@ -266,6 +271,11 @@ java_library(
         "//java/dagger:core",
         "//java/dagger/producers",
         "//third_party:auto_common",
+        "//third_party:auto_service",
+        "//third_party:guava",
+        "//third_party:javapoet",
+        "//third_party:kythe_plugin",
+        "@bazel_tools//third_party/java/jdk/langtools:javac",
     ],
 )
 
diff --git a/java/dagger/internal/codegen/DaggerKythePlugin.java b/java/dagger/internal/codegen/DaggerKythePlugin.java
new file mode 100644
index 000000000..574119996
--- /dev/null
+++ b/java/dagger/internal/codegen/DaggerKythePlugin.java
@@ -0,0 +1,192 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// This must be in the dagger.internal.codegen package since Dagger doesn't expose its APIs publicly
+// https://github.com/google/dagger/issues/773 could present an opportunity to put this somewhere in
+// the regular kythe/java tree.
+package dagger.internal.codegen;
+
+import static com.google.devtools.kythe.analyzers.base.EdgeKind.DEFINES_BINDING;
+import static com.google.devtools.kythe.analyzers.base.EdgeKind.REF;
+import static dagger.internal.codegen.KytheFormatting.formatAnnotation;
+import static dagger.internal.codegen.KytheFormatting.formatKey;
+
+import com.google.auto.common.MoreElements;
+import com.google.auto.service.AutoService;
+import com.google.devtools.kythe.analyzers.base.CorpusPath;
+import com.google.devtools.kythe.analyzers.base.EdgeKind;
+import com.google.devtools.kythe.analyzers.base.EntrySet;
+import com.google.devtools.kythe.analyzers.base.FactEmitter;
+import com.google.devtools.kythe.analyzers.base.KytheEntrySets;
+import com.google.devtools.kythe.analyzers.java.Plugin;
+import com.google.devtools.kythe.proto.Storage.VName;
+import com.google.devtools.kythe.util.Span;
+import com.sun.tools.javac.api.JavacTrees;
+import com.sun.tools.javac.model.JavacElements;
+import com.sun.tools.javac.model.JavacTypes;
+import com.sun.tools.javac.tree.JCTree;
+import com.sun.tools.javac.tree.JCTree.JCClassDecl;
+import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;
+import com.sun.tools.javac.util.Context;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.Name;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * A plugin which emits nodes and edges for <a href="https://github.com/google/dagger">Dagger</a>
+ * specific code.
+ */
+@AutoService(Plugin.class)
+public class DaggerKythePlugin extends Plugin.Scanner<Void, Void> {
+  private JavacTrees trees;
+  private FactEmitter emitter;
+  private JCCompilationUnit compilationUnit;
+  private VName fileVName;
+  private KytheBindingGraphFactory bindingGraphFactory;
+  private CorpusPath corpusPath;
+  private KeyVNameFactory keys;
+
+  @Override
+  public Void visitClassDef(JCClassDecl tree, Void p) {
+    TypeElement type = MoreElements.asType(trees.getElement(trees.getPath(compilationUnit, tree)));
+    bindingGraphFactory.create(type).ifPresent(this::addNodesForGraph);
+    return super.visitClassDef(tree, p);
+  }
+
+  private void addNodesForGraph(BindingGraph graph) {
+    for (ResolvedBindings resolvedBindings : graph.resolvedBindings().values()) {
+      for (Binding binding : resolvedBindings.bindings()) {
+        addBindingDeclarationNode(binding);
+
+        binding.dependencies().forEach(this::addDependencyNode);
+      }
+
+      resolvedBindings.multibindingDeclarations().forEach(this::addBindingDeclarationNode);
+      resolvedBindings.subcomponentDeclarations().forEach(this::addBindingDeclarationNode);
+      resolvedBindings
+          .optionalBindingDeclarations()
+          .forEach(
+              declaration ->
+                  addBindingDeclarationNode(declaration, resolvedBindings.bindingKey().key()));
+    }
+
+    for (ComponentDescriptor.ComponentMethodDescriptor componentMethod :
+        graph.componentDescriptor().componentMethods()) {
+      componentMethod.dependencyRequest().ifPresent(this::addDependencyNode);
+    }
+  }
+
+  private void addBindingDeclarationNode(BindingDeclaration declaration) {
+    addBindingDeclarationNode(declaration, declaration.key());
+  }
+
+  /**
+   * Adds a {@code defines/binding} edge between {@code declaration}'s {@link
+   * BindingDeclaration#bindingElement()} and the node for {@code key}.
+   *
+   * <p>{@link BindingDeclaration#key()} is not used directly, since {@link
+   * OptionalBindingDeclaration}s' keys are the unwrapped {@code Optional} types and can apply to
+   * either {@code java.util.Optional} or {@code com.google.common.base.Optional}.
+   */
+  private void addBindingDeclarationNode(BindingDeclaration declaration, Key key) {
+    if (!declaration.bindingElement().isPresent()) {
+      return;
+    }
+    EntrySet bindingAnchor =
+        entrySets.newAnchorAndEmit(fileVName, bindingElementSpan(declaration), null);
+
+    entrySets.emitEdge(bindingAnchor, DEFINES_BINDING, keyNode(key));
+  }
+
+  private Span bindingElementSpan(BindingDeclaration declaration) {
+    Element bindingElement = declaration.bindingElement().get();
+    Name name =
+        bindingElement.getKind().equals(ElementKind.METHOD)
+            ? bindingElement.getSimpleName()
+            : declaration.bindingTypeElement().get().getSimpleName();
+    return span(name, trees.getTree(bindingElement));
+  }
+
+  /**
+   * Adds a {@code ref} edge between {@code dependencyRequest} and it's {@link
+   * DependencyRequest#key() key's} node.
+   */
+  private void addDependencyNode(DependencyRequest dependencyRequest) {
+    if (!dependencyRequest.requestElement().isPresent()) {
+      return;
+    }
+    EntrySet dependencyRequestAnchor =
+        entrySets.newAnchorAndEmit(fileVName, dependencyRequestSpan(dependencyRequest), null);
+    entrySets.emitEdge(dependencyRequestAnchor, REF, keyNode(dependencyRequest.key()));
+  }
+
+  private Span dependencyRequestSpan(DependencyRequest dependency) {
+    Element requestElement = dependency.requestElement().get();
+    return span(requestElement.getSimpleName(), trees.getTree(requestElement));
+  }
+
+  private Span span(Name name, JCTree tree) {
+    return kytheGraph.findIdentifier(name, tree.getPreferredPosition()).get();
+  }
+
+  private EntrySet keyNode(Key key) {
+    EntrySet keyNode = newNode("key", formatKey(key));
+
+    entrySets.emitEdge(keyNode.getVName(), EdgeKind.PARAM, keys.vname(key), 0);
+    key.qualifier()
+        .ifPresent(
+            qualifier -> {
+              entrySets.emitEdge(
+                  keyNode.getVName(), EdgeKind.PARAM, qualifierNode(qualifier).getVName(), 1);
+            });
+
+    return keyNode;
+  }
+
+  private EntrySet qualifierNode(AnnotationMirror qualifier) {
+    return newNode("qualifier", formatAnnotation(qualifier));
+  }
+
+  private EntrySet newNode(String nodeKind, String format) {
+    EntrySet node = entrySets
+        .newNode("inject/" + nodeKind)
+        .setCorpusPath(corpusPath)
+        .setSignature(String.format("inject_%s:%s", nodeKind, format))
+        .build();
+    node.emit(emitter);
+    return node;
+  }
+
+  @Override
+  public void run(
+      JCCompilationUnit compilationUnit, KytheEntrySets entrySets, KytheGraph kytheGraph) {
+    if (bindingGraphFactory == null) {
+      Context javaContext = kytheGraph.getJavaContext();
+      trees = JavacTrees.instance(javaContext);
+      emitter = entrySets.getEmitter();
+      bindingGraphFactory =
+          new KytheBindingGraphFactory(
+              JavacTypes.instance(javaContext), JavacElements.instance(javaContext));
+      keys = new KeyVNameFactory(kytheGraph, entrySets, emitter);
+    }
+    this.compilationUnit = compilationUnit;
+    fileVName = kytheGraph.getNode(compilationUnit).get().getVName();
+    corpusPath = new CorpusPath(fileVName.getCorpus(), "", "");
+    super.run(compilationUnit, entrySets, kytheGraph);
+  }
+}
diff --git a/java/dagger/internal/codegen/KeyVNameFactory.java b/java/dagger/internal/codegen/KeyVNameFactory.java
new file mode 100644
index 000000000..6f48d47dd
--- /dev/null
+++ b/java/dagger/internal/codegen/KeyVNameFactory.java
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static dagger.internal.codegen.KytheFormatting.formatKey;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableList;
+import com.google.devtools.kythe.analyzers.base.EntrySet;
+import com.google.devtools.kythe.analyzers.base.FactEmitter;
+import com.google.devtools.kythe.analyzers.base.KytheEntrySets;
+import com.google.devtools.kythe.analyzers.base.NodeKind;
+import com.google.devtools.kythe.analyzers.java.Plugin.KytheGraph;
+import com.google.devtools.kythe.proto.Storage.VName;
+import com.sun.tools.javac.code.Symbol.ClassSymbol;
+import java.util.EnumMap;
+import javax.lang.model.type.ArrayType;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.PrimitiveType;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.TypeVariable;
+import javax.lang.model.type.WildcardType;
+import javax.lang.model.util.SimpleTypeVisitor8;
+
+// TODO(ronshapiro): move this to a dagger.kythe package once Key is a public API
+/** Factory for {@link VName}s of Dagger {@link Key}s. */
+final class KeyVNameFactory {
+  private final KytheGraph kytheGraph;
+  private final KytheEntrySets entrySets;
+  private final FactEmitter emitter;
+  private final EnumMap<TypeKind, VName> typeKindVNames = new EnumMap<>(TypeKind.class);
+
+  // TODO(ronshapiro): use @Inject
+  KeyVNameFactory(KytheGraph kytheGraph, KytheEntrySets entrySets, FactEmitter emitter) {
+    this.kytheGraph = kytheGraph;
+    this.entrySets = entrySets;
+    this.emitter = emitter;
+  }
+
+  VName vname(Key key) {
+    return key.type().accept(new TypeExtractor(), key);
+  }
+
+  private VName forTypeKind(TypeKind typeKind) {
+    return typeKindVNames.computeIfAbsent(
+        typeKind, kind -> entrySets.getBuiltinVName(kind.toString().toLowerCase()));
+  }
+
+  private class TypeExtractor extends SimpleTypeVisitor8<VName, Key> {
+    @Override
+    public VName visitPrimitive(PrimitiveType primitiveType, Key key) {
+      return forTypeKind(primitiveType.getKind());
+    }
+
+    @Override
+    public VName visitArray(ArrayType arrayType, Key key) {
+      return entrySets
+          .newTApplyAndEmit(
+              forTypeKind(TypeKind.ARRAY),
+              ImmutableList.of(arrayType.getComponentType().accept(this, key)))
+          .getVName();
+    }
+
+    @Override
+    public VName visitDeclared(DeclaredType declaredType, Key key) {
+      ClassSymbol classSymbol = (ClassSymbol) MoreTypes.asTypeElement(declaredType);
+      // TODO(user,ronshapiro): is this correct? Will this be the VName for the Symbol but not
+      // the *type*? Also, this seems to return null for all boxed primitive types if boxed
+      // primitive is not mentioned in the compilation (i.e. if you @Provides int and then request
+      // int from a binding, but never java.lang.Integer) - we have to synthesize those
+      VName rawType = kytheGraph.getNode(classSymbol).get().getVName();
+      if (classSymbol.getTypeParameters().isEmpty()) {
+        return rawType;
+      }
+      ImmutableList.Builder<VName> typeArguments = ImmutableList.builder();
+      for (TypeMirror typeArgument : declaredType.getTypeArguments()) {
+        typeArguments.add(typeArgument.accept(this, key));
+      }
+      return entrySets.newTApplyAndEmit(rawType, typeArguments.build()).getVName();
+    }
+
+    private int wildcardCounter = 0;
+
+    @Override
+    public VName visitWildcard(WildcardType wildcardType, Key key) {
+      EntrySet wildcardNode =
+          entrySets
+              .newNode(NodeKind.ABS_VAR)
+              // wildcards should be unique among other keys with similar wildcards, but similar
+              // against equal keys
+              .addSignatureSalt(formatKey(key) + wildcardCounter++)
+              .build();
+      wildcardNode.emit(emitter);
+      return wildcardNode.getVName();
+    }
+
+    @Override
+    public VName visitTypeVariable(TypeVariable typeVariable, Key key) {
+      throw new IllegalArgumentException(
+          "Type Variables are not allowed in resolved bindings, found in key: " + key);
+    }
+  }
+}
diff --git a/java/dagger/internal/codegen/KytheFormatting.java b/java/dagger/internal/codegen/KytheFormatting.java
new file mode 100644
index 000000000..187df4935
--- /dev/null
+++ b/java/dagger/internal/codegen/KytheFormatting.java
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.auto.common.AnnotationMirrors.getAnnotationValuesWithDefaults;
+
+import com.google.auto.common.MoreTypes;
+import com.squareup.javapoet.CodeBlock;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.function.Consumer;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.AnnotationValueVisitor;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.SimpleAnnotationValueVisitor8;
+
+final class KytheFormatting {
+  /**
+   * Produces a {@link String} representation of a {@link Key} in a deterministic fashion. The
+   * result is a combination of the key's {@link Key#type() type} and an optional {@link
+   * Key#qualifier() qualifier}.
+   */
+  static String formatKey(Key key) {
+    StringBuilder builder = new StringBuilder();
+    if (key.qualifier().isPresent()) {
+      formatAnnotation(key.qualifier().get(), builder);
+      builder.append(' ');
+    }
+    return builder.append(key.type().toString()).toString();
+  }
+
+  /**
+   * Produces a string version of {@code annotation} with its attributes and values, including any
+   * defaults. Attributes are presented in the order in which they are defined in the {@link
+   * AnnotationMirror#getAnnotationType() annotation type}.
+   */
+  static String formatAnnotation(AnnotationMirror annotation) {
+    StringBuilder builder = new StringBuilder();
+    formatAnnotation(annotation, builder);
+    return builder.toString();
+  }
+
+  private static void formatAnnotation(AnnotationMirror annotation, StringBuilder stringBuilder) {
+    stringBuilder.append('@').append(MoreTypes.asTypeElement(annotation.getAnnotationType()));
+    Map<ExecutableElement, AnnotationValue> annotationValues =
+        getAnnotationValuesWithDefaults(annotation);
+    if (!annotationValues.isEmpty()) {
+      stringBuilder.append('(');
+      appendList(
+          stringBuilder,
+          annotationValues.entrySet(),
+          entry -> {
+            stringBuilder.append(entry.getKey().getSimpleName()).append('=');
+            entry.getValue().accept(ANNOTATION_VALUE_FORMATTER, stringBuilder);
+          });
+      stringBuilder.append(')');
+    }
+  }
+
+  private static final AnnotationValueVisitor<Void, StringBuilder> ANNOTATION_VALUE_FORMATTER =
+      new SimpleAnnotationValueVisitor8<Void, StringBuilder>() {
+        @Override
+        public Void visitAnnotation(AnnotationMirror innerAnnotation, StringBuilder stringBuilder) {
+          formatAnnotation(innerAnnotation, stringBuilder);
+          return null;
+        }
+
+        @Override
+        public Void visitArray(List<? extends AnnotationValue> list, StringBuilder stringBuilder) {
+          stringBuilder.append('{');
+          appendList(stringBuilder, list, value -> value.accept(this, stringBuilder));
+          stringBuilder.append('}');
+          return null;
+        }
+
+        @Override
+        public Void visitEnumConstant(VariableElement enumConstant, StringBuilder stringBuilder) {
+          stringBuilder.append(enumConstant.getSimpleName());
+          return null;
+        }
+
+        @Override
+        public Void visitType(TypeMirror typeMirror, StringBuilder stringBuilder) {
+          stringBuilder.append(typeMirror).append(".class");
+          return null;
+        }
+
+        @Override
+        protected Void defaultAction(Object value, StringBuilder stringBuilder) {
+          stringBuilder.append(value);
+          return null;
+        }
+
+        @Override
+        public Void visitString(String value, StringBuilder stringBuilder) {
+          stringBuilder.append(CodeBlock.of("$S", value));
+          return null;
+        }
+      };
+
+  private static <T> void appendList(
+      StringBuilder stringBuilder, Iterable<T> iterable, Consumer<T> consumer) {
+    Iterator<T> iterator = iterable.iterator();
+    while (iterator.hasNext()) {
+      consumer.accept(iterator.next());
+      if (iterator.hasNext()) {
+        stringBuilder.append(", ");
+      }
+    }
+  }
+}
diff --git a/third_party/BUILD b/third_party/BUILD
index 34c925add..db03f7f2e 100644
--- a/third_party/BUILD
+++ b/third_party/BUILD
@@ -233,3 +233,13 @@ java_library(
         "@local_jdk//:lib/tools.jar",
     ],
 )
+
+# A _deploy.jar consisting of the java_librarys in https://github.com/google/kythe needed to build a
+# Kythe plugin
+# TODO(ronshapiro): replace this with a http_archive of the next release in
+# https://github.com/google/kythe/releases
+java_import(
+    name = "kythe_plugin",
+    jars = ["kythe_plugin_deploy.jar"],
+    neverlink = 1,
+)
diff --git a/third_party/kythe_plugin_deploy.jar b/third_party/kythe_plugin_deploy.jar
new file mode 100644
index 000000000..f6a5988c6
Binary files /dev/null and b/third_party/kythe_plugin_deploy.jar differ
