diff --git a/core/src/main/java/dagger/internal/FailoverLoader.java b/core/src/main/java/dagger/internal/FailoverLoader.java
index a9fb26031..ccfdd3bcf 100644
--- a/core/src/main/java/dagger/internal/FailoverLoader.java
+++ b/core/src/main/java/dagger/internal/FailoverLoader.java
@@ -16,9 +16,9 @@
  */
 package dagger.internal;
 
-
 import dagger.internal.loaders.ReflectiveAtInjectBinding;
 import dagger.internal.loaders.ReflectiveStaticInjection;
+import java.lang.reflect.Constructor;
 
 import static dagger.internal.loaders.GeneratedAdapters.INJECT_ADAPTER_SUFFIX;
 import static dagger.internal.loaders.GeneratedAdapters.MODULE_ADAPTER_SUFFIX;
@@ -57,21 +57,98 @@
     return (ModuleAdapter<T>) loadedAdapters.get(type);
   }
 
+  private final Memoizer<AtInjectBindingKey, AtInjectBindingInfo> atInjectBindings =
+      new Memoizer<AtInjectBindingKey, AtInjectBindingInfo>() {
+        @Override protected AtInjectBindingInfo create(AtInjectBindingKey key) {
+          return getAtInjectBindingInfo(key.classLoader, key.className);
+        }
+      };
+
+  private static final class AtInjectBindingKey {
+    // classLoader can be null
+    private final ClassLoader classLoader;
+    private final String className;
+
+    AtInjectBindingKey(ClassLoader classLoader, String className) {
+      this.classLoader = classLoader;
+      this.className = className;
+    }
+
+    @Override
+    public int hashCode() {
+      // It is highly unlikely for the same class name to be present in multiple class loaders. If
+      // this does happen, we'll just let those keys collide.
+      return className.hashCode();
+    }
+
+    @Override
+    public boolean equals(Object object) {
+      if (object == this) {
+        return true;
+      }
+      if (object instanceof AtInjectBindingKey) {
+        AtInjectBindingKey other = (AtInjectBindingKey) object;
+        return (classLoader == other.classLoader) && className.equals(other.className);
+      }
+      return false;
+
+    }
+  }
+
+  private static final class AtInjectBindingInfo {
+    private final Constructor<Binding<?>> adapterConstructor;
+    private final ReflectiveAtInjectBinding.Factory<?> reflectiveBindingFactory;
+
+    AtInjectBindingInfo(Constructor<Binding<?>> adapterConstructor,
+        ReflectiveAtInjectBinding.Factory<?> reflectiveBindingFactory) {
+      this.adapterConstructor = adapterConstructor;
+      this.reflectiveBindingFactory = reflectiveBindingFactory;
+    }
+  }
+
   @Override public Binding<?> getAtInjectBinding(
       String key, String className, ClassLoader classLoader, boolean mustHaveInjections) {
-    Binding<?> result = instantiate(className.concat(INJECT_ADAPTER_SUFFIX), classLoader);
-    if (result != null) {
-      return result; // Found loadable adapter, returning it.
+    AtInjectBindingInfo info = atInjectBindings.get(new AtInjectBindingKey(classLoader, className));
+    if (info.adapterConstructor != null) {
+      try {
+        return info.adapterConstructor.newInstance();
+      } catch (ReflectiveOperationException e) {
+        throw new IllegalStateException(
+            "Could not create an instance of the inject adapter for class " + className, e);
+      }
+    } else if (info.reflectiveBindingFactory != null) {
+      return info.reflectiveBindingFactory.create(mustHaveInjections);
+    } else {
+      return null;
+    }
+  }
+
+  private AtInjectBindingInfo getAtInjectBindingInfo(ClassLoader classLoader, String className) {
+    Class<?> adapterClass = loadClass(classLoader, className.concat(INJECT_ADAPTER_SUFFIX));
+    if (!adapterClass.equals(Void.class)) {
+      // Found loadable adapter, using it.
+      try {
+        @SuppressWarnings("unchecked")
+        Constructor<Binding<?>> constructor
+            = (Constructor<Binding<?>>) adapterClass.getConstructor();
+        return new AtInjectBindingInfo(constructor, null);
+      } catch (NoSuchMethodException e) {
+        throw new IllegalStateException(
+            "Couldn't find default constructor in the generated inject adapter for class "
+            + className);
+      }
     }
     Class<?> type = loadClass(classLoader, className);
     if (type.equals(Void.class)) {
-      throw new IllegalStateException(
-          String.format("Could not load class %s needed for binding %s", className, key));
+      throw new IllegalStateException("Could not load class " + className);
     }
     if (type.isInterface()) {
-      return null; // Short-circuit since we can't build reflective bindings for interfaces.
+      // Short-circuit since we can't build reflective bindings for interfaces.
+      return new AtInjectBindingInfo(null, null);
     }
-    return ReflectiveAtInjectBinding.create(type, mustHaveInjections);
+    ReflectiveAtInjectBinding.Factory<?> reflectiveBindingFactory
+        = ReflectiveAtInjectBinding.createFactory(type);
+    return new AtInjectBindingInfo(null, reflectiveBindingFactory);
   }
 
   @Override public StaticInjection getStaticInjection(Class<?> injectedClass) {
diff --git a/core/src/main/java/dagger/internal/loaders/ReflectiveAtInjectBinding.java b/core/src/main/java/dagger/internal/loaders/ReflectiveAtInjectBinding.java
index 08f0264c3..d464ec50e 100644
--- a/core/src/main/java/dagger/internal/loaders/ReflectiveAtInjectBinding.java
+++ b/core/src/main/java/dagger/internal/loaders/ReflectiveAtInjectBinding.java
@@ -141,7 +141,46 @@ private ReflectiveAtInjectBinding(String provideKey, String membersKey, boolean
     return provideKey != null ? provideKey : membersKey;
   }
 
-  public static <T> Binding<T> create(Class<T> type, boolean mustHaveInjections) {
+  /**
+   * A factory for creating {@code ReflectiveAtInjectBinding<T>}.
+   */
+  public static class Factory<T> {
+    private final String provideKey;
+    private final String membersKey;
+    private final boolean singleton;
+    private final Class<?> type;
+    private final Field[] fields;
+    private final Constructor<T> constructor;
+    private final int parameterCount;
+    private final Class<?> supertype;
+    private final String[] keys;
+
+    private Factory(String provideKey, String membersKey, boolean singleton,
+        Class<?> type, Field[] fields, Constructor<T> constructor, int parameterCount,
+        Class<?> supertype, String[] keys) {
+      this.provideKey = provideKey;
+      this.membersKey = membersKey;
+      this.singleton = singleton;
+      this.type = type;
+      this.fields = fields;
+      this.constructor = constructor;
+      this.parameterCount = parameterCount;
+      this.supertype = supertype;
+      this.keys = keys;
+    }
+
+    public ReflectiveAtInjectBinding<T> create(boolean mustHaveInjections) {
+      if (mustHaveInjections && constructor == null && fields.length == 0) {
+        throw new InvalidBindingException(type.getName(),
+            "has no injectable members. Do you want to add an injectable constructor?");
+      }
+      return new ReflectiveAtInjectBinding<T>(provideKey, membersKey, singleton,
+          type, fields, constructor, parameterCount,
+          supertype, keys);
+    }
+  }
+
+  public static <T> Factory<T> createFactory(Class<T> type) {
     boolean singleton = type.isAnnotationPresent(Singleton.class);
     List<String> keys = new ArrayList<String>();
 
@@ -180,9 +219,6 @@ private ReflectiveAtInjectBinding(String provideKey, String membersKey, boolean
           injectedConstructor = type.getDeclaredConstructor();
         } catch (NoSuchMethodException ignored) {
         }
-      } else if (mustHaveInjections) {
-        throw new InvalidBindingException(type.getName(),
-            "has no injectable members. Do you want to add an injectable constructor?");
       }
     }
 
@@ -222,7 +258,7 @@ private ReflectiveAtInjectBinding(String provideKey, String membersKey, boolean
     }
 
     String membersKey = Keys.getMembersKey(type);
-    return new ReflectiveAtInjectBinding<T>(provideKey, membersKey, singleton, type,
+    return new Factory<T>(provideKey, membersKey, singleton, type,
         injectedFields.toArray(new Field[injectedFields.size()]), injectedConstructor,
         parameterCount, supertype, keys.toArray(new String[keys.size()]));
   }
diff --git a/core/src/test/java/dagger/internal/TestingLoader.java b/core/src/test/java/dagger/internal/TestingLoader.java
index b364cde05..0767446a6 100644
--- a/core/src/test/java/dagger/internal/TestingLoader.java
+++ b/core/src/test/java/dagger/internal/TestingLoader.java
@@ -37,7 +37,7 @@
       if (type.isInterface()) {
         return null; // Short-circuit since we can't build reflective bindings for interfaces.
       }
-      return ReflectiveAtInjectBinding.create(type, mustHaveInjections);
+      return ReflectiveAtInjectBinding.createFactory(type).create(mustHaveInjections);
     } catch (ClassNotFoundException e) {
       throw new TypeNotPresentException(
           String.format("Could not find %s needed for binding %s", className, key), e);
