diff --git a/javatests/dagger/android/processor/AndroidMapKeyValidatorTest.java b/javatests/dagger/android/processor/AndroidMapKeyValidatorTest.java
index 8f1a5290b..d08bf0b78 100644
--- a/javatests/dagger/android/processor/AndroidMapKeyValidatorTest.java
+++ b/javatests/dagger/android/processor/AndroidMapKeyValidatorTest.java
@@ -171,7 +171,7 @@ public void mapKeyDoesntMatchCoreType() {
                 + "dagger.android.AndroidInjector.Factory<? extends android.app.Activity>");
     assertThat(compilation)
         .hadErrorContaining(
-            "test.FooActivity.Builder does not implement " + "AndroidInjector<test.BazFragment>")
+            "test.FooActivity.Builder does not implement AndroidInjector<test.BazFragment>")
         .inFile(module)
         .onLine(LINES_BEFORE_METHOD + 3);
   }
diff --git a/javatests/dagger/internal/codegen/ConflictingEntryPointsTest.java b/javatests/dagger/internal/codegen/ConflictingEntryPointsTest.java
index ea904474b..7ffd922a3 100644
--- a/javatests/dagger/internal/codegen/ConflictingEntryPointsTest.java
+++ b/javatests/dagger/internal/codegen/ConflictingEntryPointsTest.java
@@ -72,8 +72,8 @@ public void covariantType() {
         .hadErrorContaining(
             message(
                 "conflicting entry point declarations:",
-                "Long test.Base1.foo()",
-                "Number test.Base2.foo()"))
+                "    Long test.Base1.foo()",
+                "    Number test.Base2.foo()"))
         .inFile(component)
         .onLineContaining("interface TestComponent ");
   }
@@ -120,8 +120,8 @@ public void covariantTypeFromGenericSupertypes() {
         .hadErrorContaining(
             message(
                 "conflicting entry point declarations:",
-                "Long test.Base1.foo()",
-                "Number test.Base2.foo()"))
+                "    Long test.Base1.foo()",
+                "    Number test.Base2.foo()"))
         .inFile(component)
         .onLineContaining("interface TestComponent ");
   }
@@ -171,8 +171,8 @@ public void differentQualifier() {
         .hadErrorContaining(
             message(
                 "conflicting entry point declarations:",
-                "Object test.Base1.foo()",
-                "@Named(\"foo\") Object test.Base2.foo()"))
+                "    Object test.Base1.foo()",
+                "    @Named(\"foo\") Object test.Base2.foo()"))
         .inFile(component)
         .onLineContaining("interface TestComponent ");
   }
diff --git a/javatests/dagger/internal/codegen/GraphValidationScopingTest.java b/javatests/dagger/internal/codegen/GraphValidationScopingTest.java
index bd7ccb744..2e7aa7d2a 100644
--- a/javatests/dagger/internal/codegen/GraphValidationScopingTest.java
+++ b/javatests/dagger/internal/codegen/GraphValidationScopingTest.java
@@ -18,6 +18,7 @@
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.TestUtils.message;
 
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
@@ -62,13 +63,15 @@
         "  @Provides long integer() { return 0L; }",
         "  @Provides float floatingPoint() { return 0.0f; }",
         "}");
-    String errorMessage =
-        "test.MyComponent (unscoped) may not reference scoped bindings:\n"
-            + "      @Singleton class test.ScopedType\n"
-            + "      @Provides @Singleton String test.ScopedModule.string()";
+
     Compilation compilation = daggerCompiler().compile(componentFile, typeFile, moduleFile);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(errorMessage);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.MyComponent (unscoped) may not reference scoped bindings:",
+                "    @Singleton class test.ScopedType",
+                "    @Provides @Singleton String test.ScopedModule.string()"));
   }
 
   @Test // b/79859714
@@ -146,8 +149,10 @@ public void bindsWithChildScope_inParentModule_notAllowed() {
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            "test.Parent scoped with @Singleton may not reference bindings with different scopes:\n"
-                + "      @Binds @test.ChildScope test.Foo test.ParentModule.bind(test.FooImpl)");
+            message(
+                "test.Parent scoped with @Singleton may not reference bindings with different "
+                    + "scopes:",
+                "    @Binds @test.ChildScope test.Foo test.ParentModule.bind(test.FooImpl)"));
   }
 
   @Test public void componentWithScopeIncludesIncompatiblyScopedBindings_Fail() {
@@ -203,17 +208,20 @@ public void bindsWithChildScope_inParentModule_notAllowed() {
         "  @Provides @Singleton float floatingPoint() { return 0.0f; }", // same scope - valid
         "  @Provides @Per(MyComponent.class) boolean bool() { return false; }", // incompatible
         "}");
-    String errorMessage =
-        "test.MyComponent scoped with @Singleton "
-            + "may not reference bindings with different scopes:\n"
-            + "      @test.PerTest class test.ScopedType\n"
-            + "      @Provides @test.PerTest String test.ScopedModule.string()\n"
-            + "      @Provides @test.Per(test.MyComponent.class) boolean test.ScopedModule.bool()";
+
     Compilation compilation =
         daggerCompiler()
             .compile(componentFile, scopeFile, scopeWithAttribute, typeFile, moduleFile);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(errorMessage);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.MyComponent scoped with @Singleton "
+                    + "may not reference bindings with different scopes:",
+                "    @test.PerTest class test.ScopedType",
+                "    @Provides @test.PerTest String test.ScopedModule.string()",
+                "    @Provides @test.Per(test.MyComponent.class) boolean "
+                    + "test.ScopedModule.bool()"));
   }
 
   @Test public void componentWithScopeMayDependOnOnlyOneScopedComponent() {
@@ -276,16 +284,19 @@ public void bindsWithChildScope_inParentModule_notAllowed() {
         "interface SimpleScopedComponent {",
         "  SimpleType.A type();",
         "}");
-    String errorMessage =
-        "@test.SimpleScope test.SimpleScopedComponent depends on more than one scoped component:\n"
-        + "      @Singleton test.SingletonComponentA\n"
-        + "      @Singleton test.SingletonComponentB";
+
     Compilation compilation =
         daggerCompiler()
             .compile(
                 type, simpleScope, simpleScoped, singletonScopedA, singletonScopedB, scopeless);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(errorMessage);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "@test.SimpleScope test.SimpleScopedComponent depends on more than one scoped "
+                    + "component:",
+                "    @Singleton test.SingletonComponentA",
+                "    @Singleton test.SingletonComponentB"));
   }
 
   @Test public void componentWithoutScopeCannotDependOnScopedComponent() {
@@ -318,12 +329,14 @@ public void bindsWithChildScope_inParentModule_notAllowed() {
         "interface UnscopedComponent {",
         "  SimpleType type();",
         "}");
-    String errorMessage =
-        "test.UnscopedComponent (unscoped) cannot depend on scoped components:\n"
-        + "      @Singleton test.ScopedComponent";
+
     Compilation compilation = daggerCompiler().compile(type, scopedComponent, unscopedComponent);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(errorMessage);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.UnscopedComponent (unscoped) cannot depend on scoped components:",
+                "    @Singleton test.ScopedComponent"));
   }
 
   @Test public void componentWithSingletonScopeMayNotDependOnOtherScope() {
@@ -363,13 +376,15 @@ public void bindsWithChildScope_inParentModule_notAllowed() {
         "interface SingletonComponent {",
         "  SimpleType type();",
         "}");
-    String errorMessage =
-        "This @Singleton component cannot depend on scoped components:\n"
-        + "      @test.SimpleScope test.SimpleScopedComponent";
+
     Compilation compilation =
         daggerCompiler().compile(type, simpleScope, simpleScoped, singletonScoped);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(errorMessage);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "This @Singleton component cannot depend on scoped components:",
+                "    @test.SimpleScope test.SimpleScopedComponent"));
   }
 
   @Test public void componentScopeAncestryMustNotCycle() {
@@ -426,15 +441,18 @@ public void bindsWithChildScope_inParentModule_notAllowed() {
         "interface ComponentShort {",
         "  SimpleType type();",
         "}");
-    String errorMessage =
-        "test.ComponentShort depends on scoped components in a non-hierarchical scope ordering:\n"
-        + "      @test.ScopeA test.ComponentLong\n"
-        + "      @test.ScopeB test.ComponentMedium\n"
-        + "      @test.ScopeA test.ComponentShort";
+
     Compilation compilation =
         daggerCompiler().compile(type, scopeA, scopeB, longLifetime, mediumLifetime, shortLifetime);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(errorMessage);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.ComponentShort depends on scoped components in a non-hierarchical scope "
+                    + "ordering:",
+                "    @test.ScopeA test.ComponentLong",
+                "    @test.ScopeB test.ComponentMedium",
+                "    @test.ScopeA test.ComponentShort"));
   }
 
   @Test
diff --git a/javatests/dagger/internal/codegen/GraphValidationTest.java b/javatests/dagger/internal/codegen/GraphValidationTest.java
index 2abceae51..7b0d7f6e5 100644
--- a/javatests/dagger/internal/codegen/GraphValidationTest.java
+++ b/javatests/dagger/internal/codegen/GraphValidationTest.java
@@ -22,7 +22,6 @@
 import static dagger.internal.codegen.NonNullableRequestForNullableBindingValidation.nullableToNonNullable;
 import static dagger.internal.codegen.TestUtils.message;
 
-import com.google.common.base.Joiner;
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
@@ -125,12 +124,15 @@
         "    A getA();",
         "  }",
         "}");
-    String expectedError =
-        "test.TestClass.A cannot be provided without an @Inject constructor or an "
-            + "@Provides-annotated method.";
+
     Compilation compilation = daggerCompiler().compile(component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(15);
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.TestClass.A cannot be provided without an @Inject constructor or an "
+                + "@Provides-annotated method.")
+        .inFile(component)
+        .onLine(15);
   }
 
   @Test public void membersInjectWithoutProvision() {
@@ -156,13 +158,16 @@
         "    B getB();",
         "  }",
         "}");
-    String expectedError =
-        "test.TestClass.B cannot be provided without an @Inject constructor or an "
-            + "@Provides-annotated method. This type supports members injection but cannot be "
-            + "implicitly provided.";
+
     Compilation compilation = daggerCompiler().compile(component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(19);
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.TestClass.B cannot be provided without an @Inject constructor or an "
+                + "@Provides-annotated method. This type supports members injection but cannot be "
+                + "implicitly provided.")
+        .inFile(component)
+        .onLine(19);
   }
 
   @Test
@@ -190,18 +195,18 @@ public void membersInjectDependsOnUnboundedType() {
             "interface TestComponent {",
             "  void injectsUnboundedType(InjectsUnboundedType injects);",
             "}");
+
     Compilation compilation = daggerCompiler().compile(injectsUnboundedType, component);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            Joiner.on('\n')
-                .join(
-                    "Cannot inject members into types with unbounded type arguments: "
-                        + "java.util.ArrayList<?>",
-                    "      dagger.MembersInjector<java.util.ArrayList<?>> is injected at",
-                    "          test.InjectsUnboundedType.listInjector",
-                    "      test.InjectsUnboundedType is injected at",
-                    "          test.TestComponent.injectsUnboundedType(test.InjectsUnboundedType)"))
+            message(
+                "Cannot inject members into types with unbounded type arguments: "
+                    + "java.util.ArrayList<?>",
+                "    dagger.MembersInjector<java.util.ArrayList<?>> is injected at",
+                "        test.InjectsUnboundedType.listInjector",
+                "    test.InjectsUnboundedType is injected at",
+                "        test.TestComponent.injectsUnboundedType(test.InjectsUnboundedType)"))
         .inFile(component)
         .onLine(7);
   }
@@ -348,22 +353,22 @@ public void staticFieldInjection() {
         "  }",
         "}");
 
-    String expectedError =
-        Joiner.on('\n')
-            .join(
-                "Found a dependency cycle:",
-                "      test.Outer.C is injected at",
-                "          test.Outer.A.<init>(cParam)",
-                "      test.Outer.A is injected at",
-                "          test.Outer.B.<init>(aParam)",
-                "      test.Outer.B is injected at",
-                "          test.Outer.C.<init>(bParam)",
-                "      test.Outer.C is provided at",
-                "          test.Outer.CComponent.getC()");
-
     Compilation compilation = daggerCompiler().compile(component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(23);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "Found a dependency cycle:",
+                "    test.Outer.C is injected at",
+                "        test.Outer.A.<init>(cParam)",
+                "    test.Outer.A is injected at",
+                "        test.Outer.B.<init>(aParam)",
+                "    test.Outer.B is injected at",
+                "        test.Outer.C.<init>(bParam)",
+                "    test.Outer.C is provided at",
+                "        test.Outer.CComponent.getC()"))
+        .inFile(component)
+        .onLine(23);
   }
 
   @Test public void cyclicDependencyNotIncludingEntryPoint() {
@@ -400,24 +405,24 @@ public void staticFieldInjection() {
             "  }",
             "}");
 
-    String expectedError =
-        Joiner.on('\n')
-            .join(
-                "Found a dependency cycle:",
-                "      test.Outer.C is injected at",
-                "          test.Outer.A.<init>(cParam)",
-                "      test.Outer.A is injected at",
-                "          test.Outer.B.<init>(aParam)",
-                "      test.Outer.B is injected at",
-                "          test.Outer.C.<init>(bParam)",
-                "      test.Outer.C is injected at",
-                "          test.Outer.D.<init>(cParam)",
-                "      test.Outer.D is provided at",
-                "          test.Outer.DComponent.getD()");
-
     Compilation compilation = daggerCompiler().compile(component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(27);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "Found a dependency cycle:",
+                "    test.Outer.C is injected at",
+                "        test.Outer.A.<init>(cParam)",
+                "    test.Outer.A is injected at",
+                "        test.Outer.B.<init>(aParam)",
+                "    test.Outer.B is injected at",
+                "        test.Outer.C.<init>(bParam)",
+                "    test.Outer.C is injected at",
+                "        test.Outer.D.<init>(cParam)",
+                "    test.Outer.D is provided at",
+                "        test.Outer.DComponent.getD()"))
+        .inFile(component)
+        .onLine(27);
   }
 
   @Test
@@ -474,16 +479,16 @@ public void cyclicDependencyNotBrokenByMapBinding() {
         .hadErrorContaining(
             message(
                 "Found a dependency cycle:",
-                "test.Outer.C is injected at",
-                "    test.Outer.CModule.c(c)",
-                "java.util.Map<java.lang.String,test.Outer.C> is injected at",
-                "    test.Outer.A.<init>(cMap)",
-                "test.Outer.A is injected at",
-                "    test.Outer.B.<init>(aParam)",
-                "test.Outer.B is injected at",
-                "    test.Outer.C.<init>(bParam)",
-                "test.Outer.C is provided at",
-                "    test.Outer.CComponent.getC()"))
+                "    test.Outer.C is injected at",
+                "        test.Outer.CModule.c(c)",
+                "    java.util.Map<java.lang.String,test.Outer.C> is injected at",
+                "        test.Outer.A.<init>(cMap)",
+                "    test.Outer.A is injected at",
+                "        test.Outer.B.<init>(aParam)",
+                "    test.Outer.B is injected at",
+                "        test.Outer.C.<init>(bParam)",
+                "    test.Outer.C is provided at",
+                "        test.Outer.CComponent.getC()"))
         .inFile(component)
         .onLineContaining("C getC();");
   }
@@ -529,24 +534,24 @@ public void cyclicDependencyWithSetBinding() {
             "  }",
             "}");
 
-    String expectedError =
-        Joiner.on('\n')
-            .join(
-                "Found a dependency cycle:",
-                "      test.Outer.C is injected at",
-                "          test.Outer.CModule.c(c)",
-                "      java.util.Set<test.Outer.C> is injected at",
-                "          test.Outer.A.<init>(cSet)",
-                "      test.Outer.A is injected at",
-                "          test.Outer.B.<init>(aParam)",
-                "      test.Outer.B is injected at",
-                "          test.Outer.C.<init>(bParam)",
-                "      test.Outer.C is provided at",
-                "          test.Outer.CComponent.getC()");
-
     Compilation compilation = daggerCompiler().compile(component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(25);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "Found a dependency cycle:",
+                "    test.Outer.C is injected at",
+                "        test.Outer.CModule.c(c)",
+                "    java.util.Set<test.Outer.C> is injected at",
+                "        test.Outer.A.<init>(cSet)",
+                "    test.Outer.A is injected at",
+                "        test.Outer.B.<init>(aParam)",
+                "    test.Outer.B is injected at",
+                "        test.Outer.C.<init>(bParam)",
+                "    test.Outer.C is provided at",
+                "        test.Outer.CComponent.getC()"))
+        .inFile(component)
+        .onLine(25);
   }
 
   @Test
@@ -585,24 +590,24 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
             "  }",
             "}");
 
-    String expectedError =
-        Joiner.on('\n')
-            .join(
-                "Found a dependency cycle:",
-                "      test.Outer.C is injected at",
-                "          test.Outer.A.<init>(cParam)",
-                "      test.Outer.A is injected at",
-                "          test.Outer.B.<init>(aParam)",
-                "      test.Outer.B is injected at",
-                "          test.Outer.C.<init>(bParam)",
-                "      javax.inject.Provider<test.Outer.C> is injected at",
-                "          test.Outer.D.<init>(cParam)",
-                "      test.Outer.D is provided at",
-                "          test.Outer.DComponent.getD()");
-
     Compilation compilation = daggerCompiler().compile(component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(28);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "Found a dependency cycle:",
+                "    test.Outer.C is injected at",
+                "        test.Outer.A.<init>(cParam)",
+                "    test.Outer.A is injected at",
+                "        test.Outer.B.<init>(aParam)",
+                "    test.Outer.B is injected at",
+                "        test.Outer.C.<init>(bParam)",
+                "    javax.inject.Provider<test.Outer.C> is injected at",
+                "        test.Outer.D.<init>(cParam)",
+                "    test.Outer.D is provided at",
+                "        test.Outer.DComponent.getD()"))
+        .inFile(component)
+        .onLine(28);
   }
 
   @Test
@@ -674,13 +679,13 @@ public void cyclicDependencyInSubcomponents() {
     assertThat(compilation)
         .hadErrorContaining(
             message(
-                "[test.Grandchild.entry()] Found a dependency cycle:",
-                "java.lang.String is injected at",
-                "    test.CycleModule.object(string)",
-                "java.lang.Object is injected at",
-                "    test.CycleModule.string(object)",
-                "java.lang.String is provided at",
-                "    test.Grandchild.entry()"))
+                "Found a dependency cycle:",
+                "    java.lang.String is injected at",
+                "        test.CycleModule.object(string)",
+                "    java.lang.Object is injected at",
+                "        test.CycleModule.string(object)",
+                "    java.lang.String is provided at",
+                "        test.Grandchild.entry()"))
         .inFile(parent)
         .onLineContaining("interface Parent");
   }
@@ -757,12 +762,12 @@ public void cyclicDependencyInSubcomponentsWithChildren() {
         .hadErrorContaining(
             message(
                 "[test.Child.entry()] Found a dependency cycle:",
-                "java.lang.String is injected at",
-                "    test.CycleModule.object(string)",
-                "java.lang.Object is injected at",
-                "    test.CycleModule.string(object)",
-                "java.lang.String is provided at",
-                "    test.Child.entry()"))
+                "    java.lang.String is injected at",
+                "        test.CycleModule.object(string)",
+                "    java.lang.Object is injected at",
+                "        test.CycleModule.string(object)",
+                "    java.lang.String is provided at",
+                "        test.Child.entry()"))
         .inFile(parent)
         .onLineContaining("interface Parent");
   }
@@ -808,12 +813,12 @@ public void circularBindsMethods() {
         .hadErrorContaining(
             message(
                 "Found a dependency cycle:",
-                "java.lang.Object is injected at",
-                "    test.TestModule.bindQualified(unqualified)",
-                "@test.SomeQualifier java.lang.Object is injected at",
-                "    test.TestModule.bindUnqualified(qualified)",
-                "java.lang.Object is provided at",
-                "    test.TestComponent.unqualified()"))
+                "    java.lang.Object is injected at",
+                "        test.TestModule.bindQualified(unqualified)",
+                "    @test.SomeQualifier java.lang.Object is injected at",
+                "        test.TestModule.bindUnqualified(qualified)",
+                "    java.lang.Object is provided at",
+                "        test.TestComponent.unqualified()"))
         .inFile(component)
         .onLineContaining("unqualified();");
   }
@@ -848,11 +853,12 @@ public void selfReferentialBinds() {
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            "Found a dependency cycle:\n"
-                + "      java.lang.Object is injected at\n"
-                + "          test.TestModule.bindToSelf(sameKey)\n"
-                + "      java.lang.Object is provided at\n"
-                + "          test.TestComponent.selfReferential()")
+            message(
+                "Found a dependency cycle:",
+                "    java.lang.Object is injected at",
+                "        test.TestModule.bindToSelf(sameKey)",
+                "    java.lang.Object is provided at",
+                "        test.TestComponent.selfReferential()"))
         .inFile(component)
         .onLine(7);
   }
@@ -897,17 +903,16 @@ public void cycleFromMembersInjectionMethod_WithSameKeyAsMembersInjectionMethod(
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            Joiner.on('\n')
-                .join(
-                    "Found a dependency cycle:",
-                    "      test.B is injected at",
-                    "          test.A.b",
-                    "      test.A is injected at",
-                    "          test.B.a",
-                    "      test.B is injected at",
-                    "          test.A.b",
-                    "      test.A is injected at",
-                    "          test.CycleComponent.inject(test.A)"))
+            message(
+                "Found a dependency cycle:",
+                "    test.B is injected at",
+                "        test.A.b",
+                "    test.A is injected at",
+                "        test.B.a",
+                "    test.B is injected at",
+                "        test.A.b",
+                "    test.A is injected at",
+                "        test.CycleComponent.inject(test.A)"))
         .inFile(component)
         .onLineContaining("void inject(A a);");
   }
@@ -1013,15 +1018,16 @@ public void missingBindingWithSameKeyAsMembersInjectionMethod() {
         "  }",
         "}");
 
-    String expectedError =
-        message(
-            "test.Outer.A is bound multiple times:",
-            "@Provides test.Outer.A test.Outer.AModule.provideA(String)",
-            "test.Outer.A test.Outer.Parent.getA()");
-
     Compilation compilation = daggerCompiler().compile(component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(30);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.Outer.A is bound multiple times:",
+                "    @Provides test.Outer.A test.Outer.AModule.provideA(String)",
+                "    test.Outer.A test.Outer.Parent.getA()"))
+        .inFile(component)
+        .onLine(30);
   }
 
   @Test public void duplicateExplicitBindings_TwoProvidesMethods() {
@@ -1053,13 +1059,16 @@ public void missingBindingWithSameKeyAsMembersInjectionMethod() {
         "  }",
         "}");
 
-    String expectedError = "test.Outer.A is bound multiple times:\n"
-        + "      @Provides test.Outer.A test.Outer.Module1.provideA1()\n"
-        + "      @Provides test.Outer.A test.Outer.Module2.provideA2(String)";
-
     Compilation compilation = daggerCompiler().compile(component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(24);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.Outer.A is bound multiple times:",
+                "    @Provides test.Outer.A test.Outer.Module1.provideA1()",
+                "    @Provides test.Outer.A test.Outer.Module2.provideA2(String)"))
+        .inFile(component)
+        .onLine(24);
   }
 
   @Test
@@ -1102,11 +1111,10 @@ public void duplicateExplicitBindings_ProvidesVsBinds() {
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            Joiner.on("\n      ")
-                .join(
-                    "test.Outer.A is bound multiple times:",
-                    "@Provides test.Outer.A test.Outer.Module1.provideA1()",
-                    "@Binds test.Outer.A test.Outer.Module2.bindA2(test.Outer.B)"))
+            message(
+                "test.Outer.A is bound multiple times:",
+                "    @Provides test.Outer.A test.Outer.Module1.provideA1()",
+                "    @Binds test.Outer.A test.Outer.Module2.bindA2(test.Outer.B)"))
         .inFile(component)
         .onLine(28);
   }
@@ -1169,35 +1177,39 @@ public void duplicateExplicitBindings_ProvidesVsBinds() {
         "  }",
         "}");
 
-    String expectedSetError =
-        message(
-            "java.util.Set<java.lang.String> has incompatible bindings or declarations:",
-            "Set bindings and declarations:",
-            "    @Binds @dagger.multibindings.IntoSet String "
-                + "test.Outer.TestModule1.bindStringSetElement(@test.Outer.SomeQualifier String)",
-            "    @Provides @dagger.multibindings.IntoSet String "
-                + "test.Outer.TestModule1.stringSetElement()",
-            "Unique bindings and declarations:",
-            "    @Provides Set<String> test.Outer.TestModule2.stringSet()");
-
-    String expectedMapError =
-        message(
-            "java.util.Map<java.lang.String,java.lang.String> has incompatible bindings "
-                + "or declarations:",
-            "Map bindings and declarations:",
-            "    @Binds @dagger.multibindings.IntoMap "
-                + "@test.Outer.StringKey(\"bar\") String"
-                + " test.Outer.TestModule1.bindStringMapEntry(@test.Outer.SomeQualifier String)",
-            "    @Provides @dagger.multibindings.IntoMap "
-                + "@test.Outer.StringKey(\"foo\") String"
-                + " test.Outer.TestModule1.stringMapEntry()",
-            "Unique bindings and declarations:",
-            "    @Provides Map<String,String> test.Outer.TestModule2.stringMap()");
-
     Compilation compilation = daggerCompiler().compile(component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedSetError).inFile(component).onLine(52);
-    assertThat(compilation).hadErrorContaining(expectedMapError).inFile(component).onLine(53);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "java.util.Set<java.lang.String> has incompatible bindings or declarations:",
+                "    Set bindings and declarations:",
+                "        @Binds @dagger.multibindings.IntoSet String "
+                    + "test.Outer.TestModule1.bindStringSetElement(@test.Outer.SomeQualifier "
+                    + "String)",
+                "        @Provides @dagger.multibindings.IntoSet String "
+                    + "test.Outer.TestModule1.stringSetElement()",
+                "    Unique bindings and declarations:",
+                "        @Provides Set<String> test.Outer.TestModule2.stringSet()"))
+        .inFile(component)
+        .onLine(52);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "java.util.Map<java.lang.String,java.lang.String> has incompatible bindings "
+                    + "or declarations:",
+                "    Map bindings and declarations:",
+                "        @Binds @dagger.multibindings.IntoMap "
+                    + "@test.Outer.StringKey(\"bar\") String"
+                    + " test.Outer.TestModule1.bindStringMapEntry(@test.Outer.SomeQualifier "
+                    + "String)",
+                "        @Provides @dagger.multibindings.IntoMap "
+                    + "@test.Outer.StringKey(\"foo\") String"
+                    + " test.Outer.TestModule1.stringMapEntry()",
+                "    Unique bindings and declarations:",
+                "        @Provides Map<String,String> test.Outer.TestModule2.stringMap()"))
+        .inFile(component)
+        .onLine(53);
   }
 
   @Test
@@ -1241,27 +1253,31 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration()
             "  }",
             "}");
 
-    String expectedSetError =
-        "java.util.Set<java.lang.String> has incompatible bindings or declarations:\n"
-            + "      Set bindings and declarations:\n"
-            + "          @dagger.multibindings.Multibinds Set<String> "
-            + "test.Outer.TestModule1.stringSet()\n"
-            + "      Unique bindings and declarations:\n"
-            + "          @Provides Set<String> test.Outer.TestModule2.stringSet()";
-
-    String expectedMapError =
-        "java.util.Map<java.lang.String,java.lang.String> has incompatible bindings "
-            + "or declarations:\n"
-            + "      Map bindings and declarations:\n"
-            + "          @dagger.multibindings.Multibinds Map<String,String> "
-            + "test.Outer.TestModule1.stringMap()\n"
-            + "      Unique bindings and declarations:\n"
-            + "          @Provides Map<String,String> test.Outer.TestModule2.stringMap()";
-
     Compilation compilation = daggerCompiler().compile(component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedSetError).inFile(component).onLine(32);
-    assertThat(compilation).hadErrorContaining(expectedMapError).inFile(component).onLine(33);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "java.util.Set<java.lang.String> has incompatible bindings or declarations:",
+                "    Set bindings and declarations:",
+                "        @dagger.multibindings.Multibinds Set<String> "
+                    + "test.Outer.TestModule1.stringSet()",
+                "    Unique bindings and declarations:",
+                "        @Provides Set<String> test.Outer.TestModule2.stringSet()"))
+        .inFile(component)
+        .onLine(32);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "java.util.Map<java.lang.String,java.lang.String> has incompatible bindings "
+                    + "or declarations:",
+                "    Map bindings and declarations:",
+                "        @dagger.multibindings.Multibinds Map<String,String> "
+                    + "test.Outer.TestModule1.stringMap()",
+                "    Unique bindings and declarations:",
+                "        @Provides Map<String,String> test.Outer.TestModule2.stringMap()"))
+        .inFile(component)
+        .onLine(33);
   }
 
   @Test public void duplicateBindings_TruncateAfterLimit() {
@@ -1363,17 +1379,17 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration()
         .hadErrorContaining(
             message(
                 "test.Outer.A is bound multiple times:",
-                "@Provides test.Outer.A test.Outer.Module01.provideA()",
-                "@Provides test.Outer.A test.Outer.Module02.provideA()",
-                "@Provides test.Outer.A test.Outer.Module03.provideA()",
-                "@Provides test.Outer.A test.Outer.Module04.provideA()",
-                "@Provides test.Outer.A test.Outer.Module05.provideA()",
-                "@Provides test.Outer.A test.Outer.Module06.provideA()",
-                "@Provides test.Outer.A test.Outer.Module07.provideA()",
-                "@Provides test.Outer.A test.Outer.Module08.provideA()",
-                "@Provides test.Outer.A test.Outer.Module09.provideA()",
-                "@Provides test.Outer.A test.Outer.Module10.provideA()",
-                "and 2 others"))
+                "    @Provides test.Outer.A test.Outer.Module01.provideA()",
+                "    @Provides test.Outer.A test.Outer.Module02.provideA()",
+                "    @Provides test.Outer.A test.Outer.Module03.provideA()",
+                "    @Provides test.Outer.A test.Outer.Module04.provideA()",
+                "    @Provides test.Outer.A test.Outer.Module05.provideA()",
+                "    @Provides test.Outer.A test.Outer.Module06.provideA()",
+                "    @Provides test.Outer.A test.Outer.Module07.provideA()",
+                "    @Provides test.Outer.A test.Outer.Module08.provideA()",
+                "    @Provides test.Outer.A test.Outer.Module09.provideA()",
+                "    @Provides test.Outer.A test.Outer.Module10.provideA()",
+                "    and 2 others"))
         .inFile(component)
         .onLineContaining("getA();");
   }
@@ -1429,30 +1445,30 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration()
             "  }",
             "}");
     String errorText = "test.TestClass.A cannot be provided without an @Provides-annotated method.";
-    String firstError =
-        message(
-            errorText,
-            "test.TestClass.A is injected at",
-            "    test.TestClass.B.<init>(a)",
-            "test.TestClass.B is injected at",
-            "    test.TestClass.DImpl.<init>(…, b)",
-            "test.TestClass.DImpl is injected at",
-            "    test.TestClass.DModule.d(…, impl, …)",
-            "@javax.inject.Named(\"slim shady\") test.TestClass.D is provided at",
-            "    test.TestClass.AComponent.getFoo()");
     String otherErrorFormat =
         message(
             errorText,
-            "test.TestClass.A is injected at",
-            "    test.TestClass.B.<init>(a)",
-            "test.TestClass.B is injected at",
-            "    test.TestClass.C.b",
-            "test.TestClass.C is %s at",
-            "    test.TestClass.AComponent.%s");
+            "    test.TestClass.A is injected at",
+            "        test.TestClass.B.<init>(a)",
+            "    test.TestClass.B is injected at",
+            "        test.TestClass.C.b",
+            "    test.TestClass.C is %s at",
+            "        test.TestClass.AComponent.%s");
+
     Compilation compilation = daggerCompiler().compile(component);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining(firstError)
+        .hadErrorContaining(
+            message(
+                errorText,
+                "    test.TestClass.A is injected at",
+                "        test.TestClass.B.<init>(a)",
+                "    test.TestClass.B is injected at",
+                "        test.TestClass.DImpl.<init>(…, b)",
+                "    test.TestClass.DImpl is injected at",
+                "        test.TestClass.DModule.d(…, impl, …)",
+                "    @javax.inject.Named(\"slim shady\") test.TestClass.D is provided at",
+                "        test.TestClass.AComponent.getFoo()"))
         .inFile(component)
         .onLineContaining("getFoo();");
     assertThat(compilation)
@@ -1505,21 +1521,21 @@ public void bindsMethodAppearsInTrace() {
             "interface TestModule {",
             "  @Binds abstract TestInterface bindTestInterface(TestImplementation implementation);",
             "}");
+
     Compilation compilation =
         daggerCompiler().compile(component, module, interfaceFile, implementationFile);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            Joiner.on("\n      ")
-                .join(
-                    "java.lang.String cannot be provided without an @Inject constructor or an "
-                        + "@Provides-annotated method.",
-                    "java.lang.String is injected at",
-                    "    TestImplementation.<init>(missingBinding)",
-                    "TestImplementation is injected at",
-                    "    TestModule.bindTestInterface(implementation)",
-                    "TestInterface is provided at",
-                    "    TestComponent.testInterface()"))
+            message(
+                "java.lang.String cannot be provided without an @Inject constructor or an "
+                    + "@Provides-annotated method.",
+                "    java.lang.String is injected at",
+                "        TestImplementation.<init>(missingBinding)",
+                "    TestImplementation is injected at",
+                "        TestModule.bindTestInterface(implementation)",
+                "    TestInterface is provided at",
+                "        TestComponent.testInterface()"))
         .inFile(component)
         .onLine(5);
   }
@@ -1599,12 +1615,12 @@ public void bindsMissingRightHandSide() {
             "\\Qtest.Duplicates.NotBound cannot be provided\\E|"
                 + message(
                     "\\Qtest.Duplicates.BoundTwice is bound multiple times:",
-                    "@Binds test.Duplicates.BoundTwice "
+                    "    @Binds test.Duplicates.BoundTwice "
                         + "test.Duplicates.DuplicatesModule"
                         + ".bindWithResolvedKey(test.Duplicates.BoundImpl)",
-                    "@Binds test.Duplicates.BoundTwice "
+                    "    @Binds test.Duplicates.BoundTwice "
                         + "test.Duplicates.DuplicatesModule"
-                        + ".bindWithUnresolvedKey(test.Duplicates.NotBound)"))
+                        + ".bindWithUnresolvedKey(test.Duplicates.NotBound"))
         .inFile(component)
         .onLineContaining("boundTwice();");
     assertThat(compilation)
@@ -1664,21 +1680,21 @@ public void bindsMissingRightHandSide() {
         "interface TestComponent {",
         "  UsesTest usesTest();",
         "}");
-    String expectedMsg =
-        Joiner.on("\n")
-            .join(
-                "java.util.List cannot be provided without an @Provides-annotated method.",
-                "      java.util.List is injected at",
-                "          test.TestClass.<init>(list)",
-                "      test.TestClass is injected at",
-                "          test.Generic.<init>(t)",
-                "      test.Generic<test.TestClass> is injected at",
-                "          test.UsesTest.<init>(genericTestClass)",
-                "      test.UsesTest is provided at",
-                "          test.TestComponent.usesTest()");
+
     Compilation compilation = daggerCompiler().compile(generic, testClass, usesTest, component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedMsg);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "java.util.List cannot be provided without an @Provides-annotated method.",
+                "    java.util.List is injected at",
+                "        test.TestClass.<init>(list)",
+                "    test.TestClass is injected at",
+                "        test.Generic.<init>(t)",
+                "    test.Generic<test.TestClass> is injected at",
+                "        test.UsesTest.<init>(genericTestClass)",
+                "    test.UsesTest is provided at",
+                "        test.TestComponent.usesTest()"));
   }
 
   @Test public void resolvedVariablesInDependencyTrace() {
@@ -1718,21 +1734,21 @@ public void bindsMissingRightHandSide() {
         "interface TestComponent {",
         "  UsesTest usesTest();",
         "}");
-    String expectedMsg =
-        Joiner.on("\n")
-            .join(
-                "java.util.List cannot be provided without an @Provides-annotated method.",
-                "      java.util.List is injected at",
-                "          test.TestClass.<init>(list)",
-                "      test.TestClass is injected at",
-                "          test.Generic.t",
-                "      test.Generic<test.TestClass> is injected at",
-                "          test.UsesTest.<init>(genericTestClass)",
-                "      test.UsesTest is provided at",
-                "          test.TestComponent.usesTest()");
+
     Compilation compilation = daggerCompiler().compile(generic, testClass, usesTest, component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedMsg);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "java.util.List cannot be provided without an @Provides-annotated method.",
+                "    java.util.List is injected at",
+                "        test.TestClass.<init>(list)",
+                "    test.TestClass is injected at",
+                "        test.Generic.t",
+                "    test.Generic<test.TestClass> is injected at",
+                "        test.UsesTest.<init>(genericTestClass)",
+                "    test.UsesTest is provided at",
+                "        test.TestComponent.usesTest()"));
   }
 
   @Test public void nullCheckForConstructorParameters() {
@@ -2095,12 +2111,14 @@ public void nullCheckForOptionalProviderOfLazy() {
         "@Component(dependencies = ComponentShort.class)",
         "interface ComponentShort {",
         "}");
-    String errorMessage =
-        "test.ComponentShort contains a cycle in its component dependencies:\n"
-            + "      test.ComponentShort";
+
     Compilation compilation = daggerCompiler().compile(shortLifetime);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(errorMessage);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.ComponentShort contains a cycle in its component dependencies:",
+                "    test.ComponentShort"));
   }
 
   @Test public void componentDependencyMustNotCycle_Indirect() {
@@ -2128,27 +2146,34 @@ public void nullCheckForOptionalProviderOfLazy() {
         "@Component(dependencies = ComponentMedium.class)",
         "interface ComponentShort {",
         "}");
-    String longErrorMessage =
-        "test.ComponentLong contains a cycle in its component dependencies:\n"
-            + "      test.ComponentLong\n"
-            + "      test.ComponentMedium\n"
-            + "      test.ComponentLong";
-    String mediumErrorMessage =
-        "test.ComponentMedium contains a cycle in its component dependencies:\n"
-            + "      test.ComponentMedium\n"
-            + "      test.ComponentLong\n"
-            + "      test.ComponentMedium";
-    String shortErrorMessage =
-        "test.ComponentShort contains a cycle in its component dependencies:\n"
-            + "      test.ComponentMedium\n"
-            + "      test.ComponentLong\n"
-            + "      test.ComponentMedium\n"
-            + "      test.ComponentShort";
+
     Compilation compilation = daggerCompiler().compile(longLifetime, mediumLifetime, shortLifetime);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(longErrorMessage).inFile(longLifetime);
-    assertThat(compilation).hadErrorContaining(mediumErrorMessage).inFile(mediumLifetime);
-    assertThat(compilation).hadErrorContaining(shortErrorMessage).inFile(shortLifetime);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.ComponentLong contains a cycle in its component dependencies:",
+                "    test.ComponentLong",
+                "    test.ComponentMedium",
+                "    test.ComponentLong"))
+        .inFile(longLifetime);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.ComponentMedium contains a cycle in its component dependencies:",
+                "    test.ComponentMedium",
+                "    test.ComponentLong",
+                "    test.ComponentMedium"))
+        .inFile(mediumLifetime);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.ComponentShort contains a cycle in its component dependencies:",
+                "    test.ComponentMedium",
+                "    test.ComponentLong",
+                "    test.ComponentMedium",
+                "    test.ComponentShort"))
+        .inFile(shortLifetime);
   }
 
   @Test
@@ -2195,14 +2220,15 @@ public void childBindingConflictsWithParent() {
             "    }",
             "  }",
             "}");
+
     Compilation compilation = daggerCompiler().compile(aComponent, bComponent);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
             message(
-                "[test.B.conflict()] java.lang.Object is bound multiple times:",
-                "@Provides Object test.A.AModule.abConflict()",
-                "@Provides Object test.B.BModule.abConflict()"))
+                "java.lang.Object is bound multiple times:",
+                "    @Provides Object test.A.AModule.abConflict()",
+                "    @Provides Object test.B.BModule.abConflict()"))
         .inFile(aComponent)
         .onLineContaining("interface A {");
   }
@@ -2262,14 +2288,15 @@ public void grandchildBindingConflictsWithGrandparent() {
             "    }",
             "  }",
             "}");
+
     Compilation compilation = daggerCompiler().compile(aComponent, bComponent, cComponent);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
             message(
-                "[test.C.conflict()] java.lang.Object is bound multiple times:",
-                "@Provides Object test.A.AModule.acConflict()",
-                "@Provides Object test.C.CModule.acConflict()"))
+                "java.lang.Object is bound multiple times:",
+                "    @Provides Object test.A.AModule.acConflict()",
+                "    @Provides Object test.C.CModule.acConflict()"))
         .inFile(aComponent)
         .onLineContaining("interface A {");
   }
@@ -2329,14 +2356,15 @@ public void grandchildBindingConflictsWithChild() {
             "    }",
             "  }",
             "}");
+
     Compilation compilation = daggerCompiler().compile(aComponent, bComponent, cComponent);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
             message(
-                "[test.C.conflict()] java.lang.Object is bound multiple times:",
-                "@Provides Object test.B.BModule.bcConflict()",
-                "@Provides Object test.C.CModule.bcConflict()"))
+                "java.lang.Object is bound multiple times:",
+                "    @Provides Object test.B.BModule.bcConflict()",
+                "    @Provides Object test.C.CModule.bcConflict()"))
         .inFile(aComponent)
         .onLineContaining("interface A {");
   }
@@ -2384,6 +2412,7 @@ public void grandchildBindingConflictsWithParentWithNullableViolationAsWarning()
             "    }",
             "  }",
             "}");
+
     Compilation compilation =
         javac()
             .withOptions("-Adagger.nullableValidation=WARNING")
@@ -2393,10 +2422,9 @@ public void grandchildBindingConflictsWithParentWithNullableViolationAsWarning()
     assertThat(compilation)
         .hadErrorContaining(
             message(
-                "[test.Child.parentChildConflictThatViolatesNullability()] "
-                    + "java.lang.Object is bound multiple times:",
-                "@Provides Object test.Child.ChildModule.nonNullableParentChildConflict()",
-                "@Provides @javax.annotation.Nullable Object"
+                "java.lang.Object is bound multiple times:",
+                "    @Provides Object test.Child.ChildModule.nonNullableParentChildConflict()",
+                "    @Provides @javax.annotation.Nullable Object"
                     + " test.ParentConflictsWithChild.ParentModule.nullableParentChildConflict()"))
         .inFile(parentConflictsWithChild)
         .onLine(9);
@@ -2447,6 +2475,7 @@ public void bindingUsedOnlyInSubcomponentDependsOnBindingOnlyInSubcomponent() {
             "    return \"child string\";",
             "  }",
             "}");
+
     Compilation compilation = daggerCompiler().compile(parent, parentModule, child, childModule);
     assertThat(compilation).failed();
     assertThat(compilation)
@@ -2735,6 +2764,7 @@ public void releasableReferenceManagerConflict() {
             "  Set<ReleasableReferenceManager> managers();",
             "  Set<TypedReleasableReferenceManager<TestMetadata>> typedManagers();",
             "}");
+
     Compilation compilation =
         daggerCompiler().compile(testScope, testMetadata, testModule, component);
     assertThat(compilation).failed();
@@ -2744,9 +2774,9 @@ public void releasableReferenceManagerConflict() {
                 message(
                     "@%1$s.ForReleasableReferences(test.TestScope.class) "
                         + "%1$s.ReleasableReferenceManager is bound multiple times:",
-                    "@Provides @%1$s.ForReleasableReferences(test.TestScope.class) "
+                    "    @Provides @%1$s.ForReleasableReferences(test.TestScope.class) "
                         + "%1$s.ReleasableReferenceManager test.TestModule.rrm()",
-                    "binding for "
+                    "    binding for "
                         + "@%1$s.ForReleasableReferences(value = test.TestScope.class) "
                         + "%1$s.ReleasableReferenceManager from the scope declaration"),
                 "dagger.releasablereferences"))
@@ -2759,10 +2789,10 @@ public void releasableReferenceManagerConflict() {
                     "@%1$s.ForReleasableReferences(test.TestScope.class) "
                         + "%1$s.TypedReleasableReferenceManager<test.TestMetadata> "
                         + "is bound multiple times:",
-                    "@Provides @%1$s.ForReleasableReferences(test.TestScope.class) "
+                    "    @Provides @%1$s.ForReleasableReferences(test.TestScope.class) "
                         + "%1$s.TypedReleasableReferenceManager<test.TestMetadata> "
                         + "test.TestModule.typedRrm()",
-                    "binding for "
+                    "    binding for "
                         + "@%1$s.ForReleasableReferences(value = test.TestScope.class) "
                         + "%1$s.TypedReleasableReferenceManager<test.TestMetadata> "
                         + "from the scope declaration"),
@@ -2774,10 +2804,10 @@ public void releasableReferenceManagerConflict() {
             message(
                 "java.util.Set<dagger.releasablereferences.ReleasableReferenceManager> "
                     + "is bound multiple times:",
-                "@Provides "
+                "    @Provides "
                     + "Set<dagger.releasablereferences.ReleasableReferenceManager> "
                     + "test.TestModule.rrmSet()",
-                "Dagger-generated binding for "
+                "    Dagger-generated binding for "
                     + "Set<dagger.releasablereferences.ReleasableReferenceManager>"))
         .inFile(component)
         .onLine(18);
@@ -2787,10 +2817,10 @@ public void releasableReferenceManagerConflict() {
                 message(
                     "java.util.Set<%1$s.TypedReleasableReferenceManager<test.TestMetadata>> "
                         + "is bound multiple times:",
-                    "@Provides "
+                    "    @Provides "
                         + "Set<%1$s.TypedReleasableReferenceManager<test.TestMetadata>> "
                         + "test.TestModule.typedRrmSet()",
-                    "Dagger-generated binding for "
+                    "    Dagger-generated binding for "
                         + "Set<%1$s.TypedReleasableReferenceManager<test.TestMetadata>>"),
                 "dagger.releasablereferences"))
         .inFile(component)
diff --git a/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index c030266b2..c10e2a266 100644
--- a/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -213,13 +213,12 @@ public void providesMethodReturnsProduced() {
         "",
         "@Module(includes = Void.class)",
         "class TestModule {}");
+
     Compilation compilation = daggerCompiler().compile(module);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            String.format(
-                "%s is listed as a module, but is not annotated with %s",
-                "java.lang.Void", "@Module"));
+            "java.lang.Void is listed as a module, but is not annotated with @Module");
   }
 
   @Test public void singleProvidesMethodNoArgs() {
diff --git a/javatests/dagger/internal/codegen/ProductionGraphValidationTest.java b/javatests/dagger/internal/codegen/ProductionGraphValidationTest.java
index 1ea56dbe1..905f94453 100644
--- a/javatests/dagger/internal/codegen/ProductionGraphValidationTest.java
+++ b/javatests/dagger/internal/codegen/ProductionGraphValidationTest.java
@@ -98,11 +98,15 @@
         "    ListenableFuture<A> getA();",
         "  }",
         "}");
-    String expectedError =
-        "test.TestClass.A cannot be provided without an @Provides- or @Produces-annotated method.";
+
     Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(11);
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.TestClass.A cannot be provided without an @Provides- or @Produces-annotated "
+                + "method.")
+        .inFile(component)
+        .onLine(11);
   }
 
   @Test public void provisionDependsOnProduction() {
@@ -139,11 +143,13 @@
         "    ListenableFuture<A> getA();",
         "  }",
         "}");
-    String expectedError =
-        "test.TestClass.A is a provision, which cannot depend on a production.";
+
     Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(30);
+    assertThat(compilation)
+        .hadErrorContaining("test.TestClass.A is a provision, which cannot depend on a production.")
+        .inFile(component)
+        .onLine(30);
   }
 
   @Test public void provisionEntryPointDependsOnProduction() {
@@ -172,11 +178,14 @@
             "    A getA();",
             "  }",
             "}");
-    String expectedError =
-        "test.TestClass.A is a provision entry-point, which cannot depend on a production.";
+
     Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(20);
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.TestClass.A is a provision entry-point, which cannot depend on a production.")
+        .inFile(component)
+        .onLine(20);
   }
 
   @Test
@@ -278,11 +287,14 @@ public void monitoringDependsOnUnboundType() {
             "    ListenableFuture<String> getString();",
             "  }",
             "}");
-    String expectedError =
-        "test.TestClass.A cannot be provided without an @Provides-annotated method.";
+
     Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(34);
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.TestClass.A cannot be provided without an @Provides-annotated method.")
+        .inFile(component)
+        .onLine(34);
   }
 
   @Test
@@ -329,13 +341,16 @@ public void monitoringDependsOnProduction() {
             "    ListenableFuture<String> getString();",
             "  }",
             "}");
-    String expectedError =
-        "java.util.Set<dagger.producers.monitoring.ProductionComponentMonitor.Factory>"
-            + " test.TestClass.MonitoringModule#monitorFactory is a provision,"
-            + " which cannot depend on a production.";
+
     Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(37);
+    assertThat(compilation)
+        .hadErrorContaining(
+            "java.util.Set<dagger.producers.monitoring.ProductionComponentMonitor.Factory>"
+                + " test.TestClass.MonitoringModule#monitorFactory is a provision,"
+                + " which cannot depend on a production.")
+        .inFile(component)
+        .onLine(37);
   }
 
   @Test
diff --git a/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java b/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
index a829ec3d5..ce0c7d43c 100644
--- a/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
+++ b/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
@@ -18,8 +18,8 @@
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.TestUtils.message;
 
-import com.google.common.base.Joiner;
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
@@ -719,15 +719,15 @@ public void testMultipleSettersPerBoundInstanceTypeFails() {
             "    @BindsInstance void set2(String s);",
             "  }",
             "}");
+
     Compilation compilation = daggerCompiler().compile(componentFile, childComponentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            Joiner.on("\n      ")
-                .join(
-                    "[test.ChildComponent.s()] java.lang.String is bound multiple times:",
-                    "@BindsInstance void test.ChildComponent.Builder.set1(String)",
-                    "@BindsInstance void test.ChildComponent.Builder.set2(String)"))
+            message(
+                "[test.ChildComponent.s()] java.lang.String is bound multiple times:",
+                "    @BindsInstance void test.ChildComponent.Builder.set1(String)",
+                "    @BindsInstance void test.ChildComponent.Builder.set2(String)"))
         .inFile(componentFile)
         .onLineContaining("interface ParentComponent {");
   }
diff --git a/javatests/dagger/internal/codegen/TestUtils.java b/javatests/dagger/internal/codegen/TestUtils.java
index c7191d3ea..c02a5f934 100644
--- a/javatests/dagger/internal/codegen/TestUtils.java
+++ b/javatests/dagger/internal/codegen/TestUtils.java
@@ -21,10 +21,10 @@
 /** Utility methods useful for codegen tests. */
 final class TestUtils {
 
-  private static final Joiner MESSAGE_JOINER = Joiner.on("\n      ");
+  private static final Joiner MESSAGE_JOINER = Joiner.on("\n  ");
 
   /**
-   * Returns the lines joined by newline plus the standard indent. Useful for passing to {@link
+   * Returns the lines joined by newline plus two spaces. Useful for passing to {@link
    * com.google.testing.compile.CompilationSubject#hadErrorContaining(String)}, etc.
    */
   static String message(String... lines) {
diff --git a/javatests/dagger/spi/SpiPluginTest.java b/javatests/dagger/spi/SpiPluginTest.java
index d9d479b38..51ddf283e 100644
--- a/javatests/dagger/spi/SpiPluginTest.java
+++ b/javatests/dagger/spi/SpiPluginTest.java
@@ -63,10 +63,10 @@ public void dependencyTraceAtBinding() {
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            lines(
+            message(
                 "[FailingPlugin] Bad Binding!",
-                "      test.Foo is provided at",
-                "          test.TestComponent.foo()"))
+                "    test.Foo is provided at",
+                "        test.TestComponent.foo()"))
         .inFile(component)
         .onLineContaining("Foo foo();");
   }
@@ -151,30 +151,30 @@ public void dependencyTraceAtDependencyRequest() {
 
     assertThat(compilationFactory.compilationWithErrorOnDependency("entryPoint"))
         .hadErrorContaining(
-            lines(
+            message(
                 "[FailingPlugin] Bad Dependency!",
-                "      test.EntryPoint is provided at",
-                "          test.TestComponent.entryPoint()"))
+                "    test.EntryPoint is provided at",
+                "        test.TestComponent.entryPoint()"))
         .inFile(component)
         .onLineContaining("EntryPoint entryPoint();");
     assertThat(compilationFactory.compilationWithErrorOnDependency("dup1"))
         .hadErrorContaining(
-            lines(
+            message(
                 "[FailingPlugin] Bad Dependency!",
-                "      test.Duplicated is injected at",
-                "          test.EntryPoint.<init>(…, dup1, …)",
-                "      test.EntryPoint is provided at",
-                "          test.TestComponent.entryPoint()"))
+                "    test.Duplicated is injected at",
+                "        test.EntryPoint.<init>(…, dup1, …)",
+                "    test.EntryPoint is provided at",
+                "        test.TestComponent.entryPoint()"))
         .inFile(component)
         .onLineContaining("EntryPoint entryPoint();");
     assertThat(compilationFactory.compilationWithErrorOnDependency("dup2"))
         .hadErrorContaining(
-            lines(
+            message(
                 "[FailingPlugin] Bad Dependency!",
-                "      test.Duplicated is injected at",
-                "          test.EntryPoint.<init>(…, dup2)",
-                "      test.EntryPoint is provided at",
-                "          test.TestComponent.entryPoint()"))
+                "    test.Duplicated is injected at",
+                "        test.EntryPoint.<init>(…, dup2)",
+                "    test.EntryPoint is provided at",
+                "        test.TestComponent.entryPoint()"))
         .inFile(component)
         .onLineContaining("EntryPoint entryPoint();");
     // Note that this compilation results in one error being reported twice since there are
@@ -183,30 +183,30 @@ public void dependencyTraceAtDependencyRequest() {
         compilationFactory.compilationWithErrorOnDependency("inFooDep");
     assertThat(inFooDepCompilation)
         .hadErrorContaining(
-            lines(
+            message(
                 "[FailingPlugin] Bad Dependency!",
-                "      test.Duplicated is injected at",
-                "          test.Foo.<init>(inFooDep)",
-                "      test.Foo is injected at",
-                "          test.EntryPoint.<init>(foo, …)",
-                "      test.EntryPoint is provided at",
-                "          test.TestComponent.entryPoint()"))
+                "    test.Duplicated is injected at",
+                "        test.Foo.<init>(inFooDep)",
+                "    test.Foo is injected at",
+                "        test.EntryPoint.<init>(foo, …)",
+                "    test.EntryPoint is provided at",
+                "        test.TestComponent.entryPoint()"))
         .inFile(component)
         .onLineContaining("EntryPoint entryPoint();");
     assertThat(inFooDepCompilation)
         .hadErrorContaining(
-            lines(
+            message(
                 "[FailingPlugin] Bad Dependency!",
-                "      test.Duplicated is injected at",
-                "          test.Foo.<init>(inFooDep)",
-                "      test.Foo is injected at",
-                "          test.Chain3.<init>(foo)",
-                "      test.Chain3 is injected at",
-                "          test.Chain2.<init>(chain)",
-                "      test.Chain2 is injected at",
-                "          test.Chain1.<init>(chain)",
-                "      test.Chain1 is provided at",
-                "          test.TestComponent.chain()"))
+                "    test.Duplicated is injected at",
+                "        test.Foo.<init>(inFooDep)",
+                "    test.Foo is injected at",
+                "        test.Chain3.<init>(foo)",
+                "    test.Chain3 is injected at",
+                "        test.Chain2.<init>(chain)",
+                "    test.Chain2 is injected at",
+                "        test.Chain1.<init>(chain)",
+                "    test.Chain1 is provided at",
+                "        test.TestComponent.chain()"))
         .inFile(component)
         .onLineContaining("Chain1 chain();");
   }
@@ -260,25 +260,25 @@ public void dependencyTraceAtDependencyRequest_subcomponents() {
         new CompilationFactory(component, subcomponent, foo, entryPoint);
     assertThat(compilationFactory.compilationWithErrorOnDependency("childEntryPoint"))
         .hadErrorContaining(
-            lines(
+            message(
                 "[FailingPlugin] [test.TestSubcomponent.childEntryPoint()] Bad Dependency!",
-                "      test.EntryPoint is provided at",
-                "          test.TestSubcomponent.childEntryPoint()",
-                "  component path: test.TestComponent → test.TestSubcomponent"))
+                "    test.EntryPoint is provided at",
+                "        test.TestSubcomponent.childEntryPoint()",
+                "component path: test.TestComponent → test.TestSubcomponent"))
         .inFile(component)
         .onLineContaining("interface TestComponent");
     assertThat(compilationFactory.compilationWithErrorOnDependency("foo"))
         .hadErrorContaining(
-            lines(
+            message(
                 "[FailingPlugin] [test.TestSubcomponent.childEntryPoint()] Bad Dependency!",
-                "      test.Foo is injected at",
-                "          test.EntryPoint.<init>(foo)",
-                "      test.EntryPoint is provided at",
-                "          test.TestSubcomponent.childEntryPoint()",
+                "    test.Foo is injected at",
+                "        test.EntryPoint.<init>(foo)",
+                "    test.EntryPoint is provided at",
+                "        test.TestSubcomponent.childEntryPoint()",
                 // TODO(ronshapiro): Maybe make the component path resemble a stack trace:
                 //     test.TestSubcomponent is a child of
                 //         test.TestComponent
-                "  component path: test.TestComponent → test.TestSubcomponent"))
+                "component path: test.TestComponent → test.TestSubcomponent"))
         .inFile(component)
         .onLineContaining("interface TestComponent");
   }
@@ -338,9 +338,9 @@ public void errorOnSubcomponent() {
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            lines(
+            message(
                 "[FailingPlugin] Bad Subcomponent!",
-                "  component path: test.TestComponent → test.TestSubcomponent"))
+                "component path: test.TestComponent → test.TestSubcomponent"))
         .inFile(component)
         .onLineContaining("interface TestComponent");
   }
@@ -446,27 +446,27 @@ public void shortestPathToBindingExistsThroughSubcomponentBuilder() {
                 subcomponentModule);
     assertThat(compilation)
         .hadErrorContaining(
-            lines(
+            message(
                 "[FailingPlugin] Bad Binding!",
-                "      test.ExposedOnSubcomponent is injected at",
-                "          test.Chain3.<init>(exposedOnSubcomponent)",
-                "      test.Chain3 is injected at",
-                "          test.Chain2.<init>(chain)",
-                "      test.Chain2 is injected at",
-                "          test.Chain1.<init>(chain)",
-                "      test.Chain1 is provided at",
-                "          test.TestComponent.chain()"))
+                "    test.ExposedOnSubcomponent is injected at",
+                "        test.Chain3.<init>(exposedOnSubcomponent)",
+                "    test.Chain3 is injected at",
+                "        test.Chain2.<init>(chain)",
+                "    test.Chain2 is injected at",
+                "        test.Chain1.<init>(chain)",
+                "    test.Chain1 is provided at",
+                "        test.TestComponent.chain()"))
         .inFile(component)
         .onLineContaining("Chain1 chain();");
     assertThat(compilation)
         .hadErrorContaining(
-            lines(
+            message(
                 // TODO(ronshapiro): should this error be reported if it's already been reported at
                 // an ancestor component?
                 "[FailingPlugin] [test.TestSubcomponent.exposedOnSubcomponent()] Bad Binding!",
-                "      test.ExposedOnSubcomponent is provided at",
-                "          test.TestSubcomponent.exposedOnSubcomponent()",
-                "  component path: test.TestComponent → test.TestSubcomponent"))
+                "    test.ExposedOnSubcomponent is provided at",
+                "        test.TestSubcomponent.exposedOnSubcomponent()",
+                "component path: test.TestComponent → test.TestSubcomponent"))
         .inFile(component)
         .onLineContaining("interface TestComponent");
   }
@@ -490,7 +490,7 @@ private Compilation compilationWithErrorOnDependency(String dependencySimpleName
     }
   }
 
-  private static String lines(String... lines) {
-    return Joiner.on('\n').join(lines);
+  private static String message(String... lines) {
+    return Joiner.on("\n  ").join(lines);
   }
 }
