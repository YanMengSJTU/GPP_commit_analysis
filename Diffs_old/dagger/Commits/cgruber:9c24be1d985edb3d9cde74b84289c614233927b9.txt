diff --git a/compiler/src/it/functional-tests/src/main/java/test/ComponentDependsOnGeneratedCode.java b/compiler/src/it/functional-tests/src/main/java/test/ComponentDependsOnGeneratedCode.java
new file mode 100644
index 000000000..6ffe1e07d
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/ComponentDependsOnGeneratedCode.java
@@ -0,0 +1,23 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import dagger.Component;
+
+@Component
+interface ComponentDependsOnGeneratedCode {
+  NeedsFactory needsFactory();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/NeedsFactory.java b/compiler/src/it/functional-tests/src/main/java/test/NeedsFactory.java
new file mode 100644
index 000000000..b78907382
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/NeedsFactory.java
@@ -0,0 +1,27 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import com.google.auto.factory.AutoFactory;
+import javax.inject.Inject;
+
+class NeedsFactory {
+  @Inject NeedsFactory(NeedsFactory_SomethingFactory somethingFactory) {}
+
+  @AutoFactory
+  static class Something {}
+}
+
diff --git a/compiler/src/it/functional-tests/src/test/java/test/DependsOnGeneratedCodeTest.java b/compiler/src/it/functional-tests/src/test/java/test/DependsOnGeneratedCodeTest.java
new file mode 100644
index 000000000..0310df6ef
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/DependsOnGeneratedCodeTest.java
@@ -0,0 +1,29 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public class DependsOnGeneratedCodeTest {
+  @Test public void testComponentDependsOnGeneratedCode() {
+    assertThat(DaggerComponentDependsOnGeneratedCode.create().needsFactory()).isNotNull();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentProcessingStep.java
index 05a064a16..fd670f266 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentProcessingStep.java
@@ -46,21 +46,26 @@
   }
 
   @Override
-  public final Set<Element> process(
+  public final ImmutableSet<Element> process(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    ImmutableSet.Builder<Element> rejectedElements = ImmutableSet.builder();
     for (ComponentDescriptor componentDescriptor : componentDescriptors(elementsByAnnotation)) {
-      BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
-      ValidationReport<BindingGraph> graphReport = bindingGraphValidator.validate(bindingGraph);
-      graphReport.printMessagesTo(messager);
-      if (graphReport.isClean()) {
-        try {
-          componentGenerator.generate(bindingGraph);
-        } catch (SourceFileGenerationException e) {
-          e.printMessageTo(messager);
+      try {
+        BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
+        ValidationReport<BindingGraph> graphReport = bindingGraphValidator.validate(bindingGraph);
+        graphReport.printMessagesTo(messager);
+        if (graphReport.isClean()) {
+          try {
+            componentGenerator.generate(bindingGraph);
+          } catch (SourceFileGenerationException e) {
+            e.printMessageTo(messager);
+          }
         }
+      } catch (TypeNotPresentException e) {
+        rejectedElements.add(componentDescriptor.componentDefinitionType());
       }
     }
-    return ImmutableSet.of();
+    return rejectedElements.build();
   }
 
   /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
index 1cab2b9d1..63425665b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -38,6 +38,7 @@
 import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.AnnotationValueVisitor;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
@@ -45,6 +46,7 @@
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
+import javax.lang.model.util.SimpleAnnotationValueVisitor6;
 import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 
@@ -108,18 +110,54 @@ static boolean isComponent(TypeElement componentDefinitionType) {
     return Optional.absent();
   }
 
+  /**
+   * Extracts the list of types that is the value of the annotation member {@code elementName} of
+   * {@code annotationMirror}.
+   *
+   * @throws IllegalArgumentException if no such member exists on {@code annotationMirror}, or it
+   *     exists but is not an array
+   * @throws TypeNotPresentException if any of the values cannot be converted to a type
+   */
   static ImmutableList<TypeMirror> convertClassArrayToListOfTypes(
-      AnnotationMirror annotationMirror, final String elementName) {
-    @SuppressWarnings("unchecked") // that's the whole point of this method
-    List<? extends AnnotationValue> listValue = (List<? extends AnnotationValue>)
-        getAnnotationValue(annotationMirror, elementName).getValue();
-    return FluentIterable.from(listValue).transform(new Function<AnnotationValue, TypeMirror>() {
-      @Override public TypeMirror apply(AnnotationValue typeValue) {
-        return (TypeMirror) typeValue.getValue();
-      }
-    }).toList();
+      AnnotationMirror annotationMirror, String elementName) {
+    return TO_LIST_OF_TYPES.visit(getAnnotationValue(annotationMirror, elementName), elementName);
   }
 
+  private static final AnnotationValueVisitor<ImmutableList<TypeMirror>, String> TO_LIST_OF_TYPES =
+      new SimpleAnnotationValueVisitor6<ImmutableList<TypeMirror>, String>() {
+        @Override
+        public ImmutableList<TypeMirror> visitArray(
+            List<? extends AnnotationValue> vals, String elementName) {
+          return FluentIterable.from(vals)
+              .transform(
+                  new Function<AnnotationValue, TypeMirror>() {
+                    @Override
+                    public TypeMirror apply(AnnotationValue typeValue) {
+                      return TO_TYPE.visit(typeValue);
+                    }
+                  })
+              .toList();
+        }
+
+        @Override
+        protected ImmutableList<TypeMirror> defaultAction(Object o, String elementName) {
+          throw new IllegalArgumentException(elementName + " is not an array: " + o);
+        }
+      };
+
+  private static final AnnotationValueVisitor<TypeMirror, Void> TO_TYPE =
+      new SimpleAnnotationValueVisitor6<TypeMirror, Void>() {
+        @Override
+        public TypeMirror visitType(TypeMirror t, Void p) {
+          return t;
+        }
+
+        @Override
+        protected TypeMirror defaultAction(Object o, Void p) {
+          throw new TypeNotPresentException(o.toString(), null);
+        }
+      };
+
   /**
    * Returns the full set of modules transitively {@linkplain Module#includes included} from the
    * given seed modules.  If a module is malformed and a type listed in {@link Module#includes}
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index 2fbb507c2..7097b9991 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -107,6 +107,12 @@ BindingKey bindingKey() {
   /** Returns true if this request allows null objects. */
   abstract boolean isNullable();
 
+  /**
+   * Factory for {@link DependencyRequest}s.
+   *
+   * <p>Any factory method may throw {@link TypeNotPresentException} if a type is not available,
+   * which may mean that the type will be generated in a later round of processing.
+   */
   static final class Factory {
     private final Key.Factory keyFactory;
 
@@ -260,9 +266,16 @@ private DependencyRequest newDependencyRequest(Element requestElement,
 
     /**
      * Extracts the correct requesting type & kind out a request type. For example, if a user
-     * requests Provider<Foo>, this will return Kind.PROVIDER with "Foo".
+     * requests {@code Provider<Foo>}, this will return ({@link Kind#PROVIDER}, {@code Foo}).
+     *
+     * @throws TypeNotPresentException if {@code type}'s kind is {@link TypeKind#ERROR}, which may
+     *     mean that the type will be generated in a later round of processing
      */
     static KindAndType extractKindAndType(TypeMirror type) {
+      if (type.getKind().equals(TypeKind.ERROR)) {
+        throw new TypeNotPresentException(type.toString(), null);
+      }
+
       // We must check TYPEVAR explicitly before the below checks because calling
       // isTypeOf(..) on a TYPEVAR throws an exception (because it can't be
       // represented as a Class).
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index 81cf0a2d1..f204258b1 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -15,9 +15,18 @@
  */
 package dagger.internal.codegen;
 
+import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 import com.google.testing.compile.JavaFileObjects;
 import dagger.internal.codegen.writer.StringLiteral;
+import java.io.IOException;
+import java.io.Writer;
+import java.util.Set;
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.Processor;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.element.TypeElement;
 import javax.tools.JavaFileObject;
 import org.junit.Ignore;
 import org.junit.Test;
@@ -717,6 +726,41 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         .and().generatesSources(generatedComponent);
   }
 
+  @Test
+  public void generatedTransitiveModule() {
+    JavaFileObject rootModule = JavaFileObjects.forSourceLines("test.RootModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module(includes = GeneratedModule.class)",
+        "final class RootModule {}");
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = RootModule.class)",
+        "interface TestComponent {}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(rootModule, component))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile();
+    assertAbout(javaSources())
+        .that(ImmutableList.of(rootModule, component))
+        .processedWith(
+            new ComponentProcessor(),
+            new GeneratingProcessor(
+                "test.GeneratedModule",
+                "package test;",
+                "",
+                "import dagger.Module;",
+                "",
+                "@Module",
+                "final class GeneratedModule {}"))
+        .compilesWithoutError();
+  }
+
   @Test public void testDefaultPackage() {
     JavaFileObject aClass = JavaFileObjects.forSourceLines("AClass", "class AClass {}");
     JavaFileObject bClass = JavaFileObjects.forSourceLines("BClass",
@@ -1755,6 +1799,43 @@ private void checkCannotReferToModuleOfType(String moduleType) {
             "test.B<? extends test.A> cannot be provided without an @Provides-annotated method");
   }
 
+  @Test
+  public void componentImplicitlyDependsOnGeneratedType() {
+    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class SomeInjectableType {",
+        "  @Inject SomeInjectableType(GeneratedType generatedType) {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SimpleComponent {",
+        "  SomeInjectableType someInjectableType();",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(injectableTypeFile, componentFile))
+        .processedWith(
+            new ComponentProcessor(),
+            new GeneratingProcessor("test.GeneratedType",
+                "package test;",
+                "",
+                "import javax.inject.Inject;",
+                "",
+                "final class GeneratedType {",
+                "  @Inject GeneratedType() {}",
+                "}"))
+        .compilesWithoutError();
+  }
+
   @Test
   @Ignore // modify this test as necessary while debugging for your situation.
   @SuppressWarnings("unused")
@@ -1846,4 +1927,37 @@ public void genericTestToLetMeDebugInEclipse() {
          .compilesWithoutError()
          .and().generatesSources(generatedComponent);
    }
+
+  /**
+   * A simple {@link Processor} that generates one source file.
+   */
+  private static final class GeneratingProcessor extends AbstractProcessor {
+    private final String generatedClassName;
+    private final String generatedSource;
+    private boolean processed;
+
+    GeneratingProcessor(String generatedClassName, String... source) {
+      this.generatedClassName = generatedClassName;
+      this.generatedSource = Joiner.on("\n").join(source);
+    }
+
+    @Override
+    public Set<String> getSupportedAnnotationTypes() {
+      return ImmutableSet.of("*");
+    }
+
+    @Override
+    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
+      if (!processed) {
+        processed = true;
+        try (Writer writer =
+                processingEnv.getFiler().createSourceFile(generatedClassName).openWriter()) {
+          writer.append(generatedSource);
+        } catch (IOException e) {
+          throw new RuntimeException(e);
+        }
+      }
+      return false;
+    }
+  }
 }
