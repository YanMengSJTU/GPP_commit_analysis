diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 43d9ebf8c..15d0e9dc1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -46,6 +46,7 @@
 import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
 import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
+import static dagger.internal.codegen.SourceFiles.simpleVariableName;
 import static dagger.internal.codegen.TypeNames.DELEGATE_FACTORY;
 import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
 import static dagger.internal.codegen.TypeNames.FACTORY;
@@ -1531,10 +1532,6 @@ private CodeBlock initializeFactoryForSyntheticOptionalBinding(ContributionBindi
     }
   }
 
-  private static String simpleVariableName(TypeElement typeElement) {
-    return UPPER_CAMEL.to(LOWER_CAMEL, typeElement.getSimpleName().toString());
-  }
-
   /**
    * Initialization state for a factory field.
    */
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 6a33e8a72..3a8906faf 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -14,13 +14,16 @@
 
 package dagger.internal.codegen;
 
+import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Verify.verify;
 import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.Optionals.optionalComparator;
 import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
 import static dagger.internal.codegen.TypeNames.PROVIDER_OF_LAZY;
 import static java.util.Comparator.comparing;
+import static javax.lang.model.SourceVersion.isName;
 
 import com.google.common.base.CaseFormat;
 import com.google.common.base.Joiner;
@@ -36,6 +39,7 @@
 import com.squareup.javapoet.TypeVariableName;
 import java.util.Comparator;
 import java.util.Iterator;
+import javax.lang.model.SourceVersion;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.TypeParameterElement;
@@ -236,5 +240,47 @@ private static String factoryPrefix(ContributionBinding binding) {
     return builder.build();
   }
 
+  /**
+   * Returns a name to be used for variables of the given {@linkplain TypeElement type}. Prefer
+   * semantically meaningful variable names, but if none can be derived, this will produce something
+   * readable.
+   */
+  // TODO(gak): maybe this should be a function of TypeMirrors instead of Elements?
+  static String simpleVariableName(TypeElement typeElement) {
+    String candidateName = UPPER_CAMEL.to(LOWER_CAMEL, typeElement.getSimpleName().toString());
+    String variableName = protectAgainstKeywords(candidateName);
+    verify(isName(variableName), "'%s' was expected to be a valid variable name");
+    return variableName;
+  }
+
+  private static String protectAgainstKeywords(String candidateName) {
+    switch (candidateName) {
+      case "package":
+        return "pkg";
+      case "boolean":
+        return "b";
+      case "double":
+        return "d";
+      case "byte":
+        return "b";
+      case "int":
+        return "i";
+      case "short":
+        return "s";
+      case "char":
+        return "c";
+      case "void":
+        return "v";
+      case "class":
+        return "clazz";
+      case "float":
+        return "f";
+      case "long":
+        return "l";
+      default:
+        return SourceVersion.isKeyword(candidateName) ? candidateName + '_' : candidateName;
+    }
+  }
+
   private SourceFiles() {}
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/SourceFilesTest.java b/compiler/src/test/java/dagger/internal/codegen/SourceFilesTest.java
new file mode 100644
index 000000000..c7fe99876
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/SourceFilesTest.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.truth.Truth.assertThat;
+import static dagger.internal.codegen.SourceFiles.simpleVariableName;
+
+import com.google.testing.compile.CompilationRule;
+import java.util.List;
+import javax.lang.model.element.TypeElement;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests for {@link SourceFiles}. */
+@RunWith(JUnit4.class)
+public final class SourceFilesTest {
+  @Rule public CompilationRule compilation = new CompilationRule();
+
+  private TypeElement typeElementFor(Class<?> clazz) {
+    return compilation.getElements().getTypeElement(clazz.getCanonicalName());
+  }
+
+  private static final class Int {}
+
+  @Test
+  public void testSimpleVariableName_typeCollisions() {
+    // a handful of boxed types
+    assertThat(simpleVariableName(typeElementFor(Long.class))).isEqualTo("l");
+    assertThat(simpleVariableName(typeElementFor(Double.class))).isEqualTo("d");
+    // not a boxed type type, but a custom type might collide
+    assertThat(simpleVariableName(typeElementFor(Int.class))).isEqualTo("i");
+    // void is the weird pseudo-boxed type
+    assertThat(simpleVariableName(typeElementFor(Void.class))).isEqualTo("v");
+    // reflective types
+    assertThat(simpleVariableName(typeElementFor(Class.class))).isEqualTo("clazz");
+    assertThat(simpleVariableName(typeElementFor(Package.class))).isEqualTo("pkg");
+  }
+
+  private static final class For {}
+
+  private static final class Goto {}
+
+  @Test
+  public void testSimpleVariableName_randomKeywords() {
+    assertThat(simpleVariableName(typeElementFor(For.class))).isEqualTo("for_");
+    assertThat(simpleVariableName(typeElementFor(Goto.class))).isEqualTo("goto_");
+  }
+
+  @Test
+  public void testSimpleVariableName() {
+    assertThat(simpleVariableName(typeElementFor(Object.class))).isEqualTo("object");
+    assertThat(simpleVariableName(typeElementFor(List.class))).isEqualTo("list");
+  }
+}
