diff --git a/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java b/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java
index eeb31af73..8ce3c73d8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java
@@ -78,15 +78,14 @@
   }
 
   private static final Equivalence<AnnotationMirror> ANNOTATION_MIRROR_EQUIVALENCE =
-    new Equivalence<AnnotationMirror>() {
-      @Override protected boolean doEquivalent(AnnotationMirror left, AnnotationMirror right) {
-        return MoreTypes.equivalence()
-            .equivalent(left.getAnnotationType(), right.getAnnotationType())
-                && AnnotationValues.equivalence().pairwise().equivalent(
-                    getAnnotationValuesWithDefaults(left).values(),
-                    getAnnotationValuesWithDefaults(right).values());
-      }
-
+      new Equivalence<AnnotationMirror>() {
+        @Override
+        protected boolean doEquivalent(AnnotationMirror left, AnnotationMirror right) {
+          return MoreTypes.equivalence().equivalent(left.getAnnotationType(),
+              right.getAnnotationType()) && AnnotationValues.equivalence().pairwise().equivalent(
+              getAnnotationValuesWithDefaults(left).values(),
+              getAnnotationValuesWithDefaults(right).values());
+        }
         @Override
         protected int doHash(AnnotationMirror annotation) {
           DeclaredType type = annotation.getAnnotationType();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 8d6fcad95..fae6ac65c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -35,13 +35,17 @@
 import java.util.Deque;
 import java.util.LinkedHashSet;
 import java.util.List;
+import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Queue;
+import javax.inject.Provider;
 import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
@@ -280,21 +284,35 @@ private void resolveRequest(DependencyRequest request,
           ImmutableSet<ProvisionBinding> explicitBindingsForKey =
               explicitBindings.get(requestKey);
           if (explicitBindingsForKey.isEmpty()) {
-            // no explicit binding, look it up
-            Optional<ProvisionBinding> provisionBinding =
-                injectBindingRegistry.getOrFindOrCreateProvisionBindingForKey(requestKey);
-            checkState(provisionBinding.isPresent(),
-                "could not find a provision binding for %s. this should not have passed validation",
-                requestKey);
-            // found a binding, resolve its deps and then mark it resolved
-            for (DependencyRequest dependency : Iterables.concat(
-                provisionBinding.get().dependencies(),
-                provisionBinding.get().memberInjectionRequest().asSet())) {
-              resolveRequest(dependency, explicitBindings, resolvedBindings,
-                  resolvedProvisionsBindingBuilder, resolvedMembersIjectionBindingsBuilder);
-            }
-            resolvedBindings.put(frameworkKey, provisionBinding.get());
-            resolvedProvisionsBindingBuilder.put(requestKey, provisionBinding.get());
+            // If the key is Map<K, V>, get its implicit binding key which is Map<K, Provider<V>>
+            Optional<Key> key = findMapKey(request);
+            if (key.isPresent()) {
+              DependencyRequest implicitRequest =
+                  dependencyRequestFactory.forImplicitMapBinding(request, key.get());
+              ProvisionBinding implicitBinding =
+                  provisionBindingFactory.forImplicitMapBinding(request, implicitRequest);
+              resolveRequest(Iterables.getOnlyElement(implicitBinding.dependencies()),
+                  explicitBindings, resolvedBindings, resolvedProvisionsBindingBuilder,
+                  resolvedMembersIjectionBindingsBuilder);
+              resolvedBindings.put(frameworkKey, implicitBinding);
+              resolvedProvisionsBindingBuilder.put(request.key(), implicitBinding);
+            } else {
+              // no explicit binding, look it up
+              Optional<ProvisionBinding> provisionBinding =
+                  injectBindingRegistry.getOrFindOrCreateProvisionBindingForKey(requestKey);
+              checkState(provisionBinding.isPresent(),
+                  "Can not find a provision binding for %s. this should not have passed validation",
+                  requestKey);
+              // found a binding, resolve its deps and then mark it resolved
+              for (DependencyRequest dependency : Iterables.concat(
+                  provisionBinding.get().dependencies(),
+                  provisionBinding.get().memberInjectionRequest().asSet())) {
+                resolveRequest(dependency, explicitBindings, resolvedBindings,
+                    resolvedProvisionsBindingBuilder, resolvedMembersIjectionBindingsBuilder);
+              }
+              resolvedBindings.put(frameworkKey, provisionBinding.get());
+              resolvedProvisionsBindingBuilder.put(requestKey, provisionBinding.get());
+              } 
           } else {
             // we found explicit bindings. resolve the deps and them mark them resolved
             for (ProvisionBinding explicitBinding : explicitBindingsForKey) {
@@ -324,6 +342,25 @@ private void resolveRequest(DependencyRequest request,
         default:
           throw new AssertionError();
       }
+
+    }
+
+    private Optional<Key> findMapKey(final DependencyRequest request) {
+      if (Util.isTypeOf(Map.class, request.key().type(), elements, types)) {
+        DeclaredType declaredMapType = Util.getDeclaredTypeOfMap(request.key().type());
+        TypeMirror mapValueType = Util.getValueTypeOfMap(declaredMapType);
+        if (!Util.isTypeOf(Provider.class, mapValueType, elements, types)) {
+          TypeMirror keyType =
+              Util.getKeyTypeOfMap((DeclaredType) (request.key().wrappedType().get()));
+          TypeMirror valueType = types.getDeclaredType(
+              elements.getTypeElement(Provider.class.getCanonicalName()), mapValueType);
+          TypeMirror mapType = types.getDeclaredType(
+              elements.getTypeElement(Map.class.getCanonicalName()), keyType, valueType);
+          return Optional.of((Key) new AutoValue_Key(request.key().wrappedQualifier(),
+              MoreTypes.equivalence().wrap(mapType)));
+        }
+      }
+      return Optional.absent();
     }
 
     private static boolean isComponentProvisionMethod(ExecutableElement method) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 20ccdcc23..7ea9b04e5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -35,6 +35,7 @@
 import dagger.MapKey;
 import dagger.MembersInjector;
 import dagger.internal.InstanceFactory;
+import dagger.internal.MapFactory;
 import dagger.internal.MapProviderFactory;
 import dagger.internal.MembersInjectors;
 import dagger.internal.ScopedProvider;
@@ -286,9 +287,9 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
     }
 
     ImmutableMap<FrameworkKey, Snippet> memberSelectSnippets = memberSelectSnippetsBuilder.build();
-
     for (FrameworkKey frameworkKey : input.initializationOrdering()) {
       Key key = frameworkKey.key();
+
       if (frameworkKey.frameworkClass().equals(Provider.class)) {
         Set<ProvisionBinding> bindings = resolvedProvisionBindings.get(key);
         BindingsType bindingsType = ProvisionBinding.getBindingsType(bindings);
@@ -308,24 +309,30 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
               Iterator<ProvisionBinding> iterator = bindings.iterator();
               // get type information from first binding in iterator
               ProvisionBinding firstBinding = iterator.next();
-              DeclaredType declaredMapType =
-                  Util.getDeclaredTypeOfMap(firstBinding.providedKey().type());
-              TypeMirror mapKeyType = Util.getKeyTypeOfMap(declaredMapType);
-              TypeMirror mapValueType = Util.getValueTypeOfMap(declaredMapType);
-              constructorWriter.body().addSnippet("this.%s = %s.<%s, %s>builder(%d)",
-                  providerNames.get(key),
-                  ClassName.fromClass(MapProviderFactory.class),
-                  TypeNames.forTypeMirror(mapKeyType),
-                  TypeNames.forTypeMirror(mapValueType),
-                  bindings.size());
-              writeEntry(constructorWriter, firstBinding, initializeFactoryForBinding(
-                  firstBinding, componentContributionFields, memberSelectSnippets));
-              while (iterator.hasNext()) {
-                ProvisionBinding binding = iterator.next();
-                writeEntry(constructorWriter, binding, initializeFactoryForBinding(
-                    binding, componentContributionFields, memberSelectSnippets));
+              if (isNonProviderMap(firstBinding)) {
+                constructorWriter.body().addSnippet("this.%s = %s.create(%s);",
+                    providerNames.get(key), ClassName.fromClass(MapFactory.class),
+                    providerNames.get(Iterables.getOnlyElement(firstBinding.dependencies()).key()));
+              } else {
+                DeclaredType declaredMapType =
+                    Util.getDeclaredTypeOfMap(firstBinding.providedKey().type());
+                TypeMirror mapKeyType = Util.getKeyTypeOfMap(declaredMapType);
+                TypeMirror mapValueType = Util.getProvideValueTypeOfMap(declaredMapType);
+                constructorWriter.body().addSnippet("this.%s = %s.<%s, %s>builder(%d)",
+                    providerNames.get(key),
+                    ClassName.fromClass(MapProviderFactory.class),
+                    TypeNames.forTypeMirror(mapKeyType),
+                    TypeNames.forTypeMirror(mapValueType),
+                    bindings.size());
+                writeEntry(constructorWriter, firstBinding, initializeFactoryForBinding(
+                    firstBinding, componentContributionFields, memberSelectSnippets));
+                while (iterator.hasNext()) {
+                  ProvisionBinding binding = iterator.next();
+                  writeEntry(constructorWriter, binding, initializeFactoryForBinding(binding,
+                      componentContributionFields, memberSelectSnippets));
+                }
+                constructorWriter.body().addSnippet("    .build();");
               }
-              constructorWriter.body().addSnippet("    .build();");
             }
             break;
           case SINGULAR_BINDING:
@@ -491,7 +498,7 @@ public Snippet apply(AnnotationValue value) {
     }
   }
 
-  // Get the string representation of a Annotation Value
+  // Get the Snippet representation of a Annotation Value
   // TODO(user) write corresponding test to verify the AnnotationValueVisitor is right
   private Snippet getValueSnippet(AnnotationValue value) {
     AnnotationValueVisitor<Snippet, Void> mapKeyVisitor =
@@ -549,4 +556,12 @@ public Snippet visitArray(List<? extends AnnotationValue> values, Void v) {
     return value.accept(mapKeyVisitor, null);
   }
 
+  private boolean isNonProviderMap(ProvisionBinding binding) {
+    DeclaredType declaredMapType = Util.getDeclaredTypeOfMap(binding.providedKey().type());
+    TypeMirror mapValueType = Util.getProvideValueTypeOfMap(declaredMapType);
+    if (mapValueType == null) {
+      return true;
+    }
+    return false;
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index 41aefbf1d..527f5d1f1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -86,6 +86,17 @@
           })
           .toSet();
     }
+    
+    /**
+     * Creates a DependencyRequest for implictMapBinding, this request's key will be
+     * {@code Map<K, Provider<V>>}, this DependencyRequest is depended by the DependencyRequest
+     * whose key is {@code Map<K, V>}
+     */
+    DependencyRequest forImplicitMapBinding(DependencyRequest delegatingRequest, Key delegateKey) {
+      checkNotNull(delegatingRequest);
+      return new AutoValue_DependencyRequest(Kind.PROVIDER, delegateKey,
+          delegatingRequest.requestElement());
+    }
 
     DependencyRequest forRequiredVariable(VariableElement variableElement) {
       checkNotNull(variableElement);
@@ -151,4 +162,4 @@ private boolean isTypeOf(Class<?> type, TypeMirror mirror) {
       return elements.getTypeElement(type.getCanonicalName()).equals(types.asElement(mirror));
     }
   }
-}
+}
\ No newline at end of file
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index ee81a84a4..58801b6d4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -85,7 +85,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
 
   @Override
   ImmutableSet<JavaWriter> write(ClassName generatedTypeName, ProvisionBinding binding) {
-    TypeMirror keyType = binding.provisionType().equals(Type.MAP) ? Util.getValueTypeOfMap(
+    TypeMirror keyType = binding.provisionType().equals(Type.MAP) ? Util.getProvideValueTypeOfMap(
         Util.getDeclaredTypeOfMap(binding.providedKey().type()))
         : binding.providedKey().type();
     TypeName providedTypeName = TypeNames.forTypeMirror(keyType);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index c8837740b..0c07b9fee 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -291,6 +291,22 @@ ProvisionBinding forProvidesMethod(ExecutableElement providesMethod) {
           getScopeAnnotation(providesMethod),
           Optional.<DependencyRequest>absent());
     }
+    
+    ProvisionBinding forImplicitMapBinding(DependencyRequest explicitRequest,
+        DependencyRequest implicitRequest) {
+      checkNotNull(explicitRequest);
+      checkNotNull(implicitRequest);
+      ImmutableSet<DependencyRequest> dependencies = ImmutableSet.of(implicitRequest);
+      return new AutoValue_ProvisionBinding(
+          implicitRequest.requestElement(),
+          dependencies, 
+          findBindingPackage(explicitRequest.key()), 
+          Kind.PROVISION, 
+          Provides.Type.MAP, 
+          explicitRequest.key(), 
+          getScopeAnnotation(implicitRequest.requestElement()), 
+          Optional.<DependencyRequest>absent());
+    }
 
     ProvisionBinding forComponent(TypeElement componentDefinitionType) {
       checkNotNull(componentDefinitionType);
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 2eeb7e799..4104893eb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -16,6 +16,7 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreElements;
 import com.google.common.collect.Iterables;
 import dagger.internal.Keys;
 import java.lang.reflect.Method;
@@ -43,6 +44,8 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleAnnotationValueVisitor6;
 import javax.lang.model.util.SimpleTypeVisitor6;
+import javax.lang.model.util.Types;
+
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 
@@ -388,17 +391,35 @@ public CodeGenerationIncompleteException(String s) {
   /**
    * Returns the value type for a {@link Map} type like Map<K, Provider<V>>}.
    */
-  public static TypeMirror getValueTypeOfMap(DeclaredType declaredMapType) {
+  public static TypeMirror getProvideValueTypeOfMap(DeclaredType declaredMapType) {
+    if (!isMapType(declaredMapType)) {
+      throw new IllegalStateException();
+    }
     List<? extends TypeMirror> mapArgs = declaredMapType.getTypeArguments();
     DeclaredType declaredValueType = (DeclaredType) mapArgs.get(1);
     List<? extends TypeMirror> mapValueArgs = declaredValueType.getTypeArguments();
-    return mapValueArgs.get(0);
+    return mapValueArgs.isEmpty() ? null : mapValueArgs.get(0);
+  }
+
+  /**
+   * returns the value type for a {@link Map} type like Map<K, V>}.
+   */
+  public static TypeMirror getValueTypeOfMap(DeclaredType declaredMapType) {
+    if (!isMapType(declaredMapType)) {
+      throw new IllegalStateException();
+    }
+    List<? extends TypeMirror> mapArgs = declaredMapType.getTypeArguments();
+    DeclaredType declaredValueType = (DeclaredType) mapArgs.get(1);
+    return declaredValueType;
   }
 
   /**
    * Returns the key type for a {@link Map} type like Map<K, Provider<V>>}
    */
   public static TypeMirror getKeyTypeOfMap(DeclaredType declaredMapType) {
+    if (!isMapType(declaredMapType)) {
+      throw new IllegalStateException();
+    }
     List<? extends TypeMirror> mapArgs = declaredMapType.getTypeArguments();
     return mapArgs.get(0);
   }
@@ -414,7 +435,7 @@ public static TypeElement getKeyTypeElement(AnnotationMirror mapKey, final Eleme
         new SimpleAnnotationValueVisitor6<TypeElement, Void>() {
           @Override
           public TypeElement visitEnumConstant(VariableElement c, Void p) {
-            return (TypeElement) c.getEnclosingElement();
+            return MoreElements.asType(c.getEnclosingElement()) ;
           }
 
           @Override
@@ -444,10 +465,20 @@ public static DeclaredType getDeclaredTypeOfMap(TypeMirror map) {
     }
     // check whether the element associate with this DeclaredType is a map
     DeclaredType declaredMapType = (DeclaredType) map;
-    if (!((TypeElement) declaredMapType.asElement()).getQualifiedName().contentEquals(
-        "java.util.Map")) {
+    if (!isMapType(declaredMapType)) {
       throw new IllegalStateException();
     }
     return declaredMapType;
   }
+
+  public static boolean isMapType(DeclaredType type) {
+    if (MoreElements.asType(type.asElement()).getQualifiedName().contentEquals("java.util.Map")) {
+      return true;
+    } else {
+      return false;
+    }
+  }
+  public static boolean isTypeOf(Class<?> type, TypeMirror mirror, Elements elements, Types types) {
+    return elements.getTypeElement(type.getCanonicalName()).equals(types.asElement(mirror));
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
index 096cb3ada..ac3250aae 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -30,38 +30,34 @@
 
   @Test
   public void mapBindingsWithEnumKey() {
-    JavaFileObject mapModuleOneFile =
-        JavaFileObjects
-            .forSourceLines("test.MapModuleOne",
-                "package test;",
-                "",
-                "import static dagger.Provides.Type.MAP;",
-                "",
-                "import dagger.Module;",
-                "import dagger.Provides;",
-                "",
-                "@Module",
-                "final class MapModuleOne {",
-                "  @Provides(type = MAP) @PathKey(PathEnum.ADMIN) Handler provideAdminHandler() {",
-                "    return new AdminHandler(); ",
-                "  }",
-                "}");
-    JavaFileObject mapModuleTwoFile =
-        JavaFileObjects
-            .forSourceLines("test.MapModuleTwo",
-                "package test;",
-                "",
-                "import static dagger.Provides.Type.MAP;",
-                "",
-                "import dagger.Module;",
-                "import dagger.Provides;",
-                "",
-                "@Module",
-                "final class MapModuleTwo {",
-                "  @Provides(type = MAP) @PathKey(PathEnum.LOGIN) Handler provideLoginHandler() {",
-                "    return new LoginHandler(); ",
-                "  }",
-                "}");
+    JavaFileObject mapModuleOneFile = JavaFileObjects.forSourceLines("test.MapModuleOne",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.MAP;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class MapModuleOne {",
+        "  @Provides(type = MAP) @PathKey(PathEnum.ADMIN) Handler provideAdminHandler() {",
+        "    return new AdminHandler(); ",
+        "  }",
+        "}");
+    JavaFileObject mapModuleTwoFile = JavaFileObjects.forSourceLines("test.MapModuleTwo",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.MAP;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class MapModuleTwo {",
+        "  @Provides(type = MAP) @PathKey(PathEnum.LOGIN) Handler provideLoginHandler() {",
+        "    return new LoginHandler(); ",
+        "  }",
+        "}");
     JavaFileObject enumKeyFile = JavaFileObjects.forSourceLines("test.PathKey",
         "package test;",
         "import dagger.MapKey;",
@@ -80,7 +76,6 @@ public void mapBindingsWithEnumKey() {
         "    ADMIN,",
         "    LOGIN;",
         "}");
-
     JavaFileObject HandlerFile = JavaFileObjects.forSourceLines("test.Handler",
         "package test;",
         "",
@@ -108,84 +103,82 @@ public void mapBindingsWithEnumKey() {
         "interface TestComponent {",
         "  Map<PathEnum, Provider<Handler>> dispatcher();",
         "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects
-            .forSourceLines("test.Dagger_TestComponent",
-                "package test;",
-                "",
-                "import dagger.internal.MapProviderFactory;",
-                "import java.util.Map;",
-                "import javax.annotation.Generated;",
-                "import javax.inject.Provider;",
-                "",
-                "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-                "public final class Dagger_TestComponent implements TestComponent {",
-                "  private final MapModuleOne mapModuleOne;",
-                "  private final MapModuleTwo mapModuleTwo;",
-                "  private final Provider<Map<PathEnum, Provider<Handler>>> ",
-                "      mapOfPathEnumAndProviderOfHandlerProvider;",
-                "",
-                "  private Dagger_TestComponent(Builder builder) {",
-                "    assert builder != null;",
-                "    this.mapModuleOne = builder.mapModuleOne;",
-                "    this.mapModuleTwo = builder.mapModuleTwo;",
-                "    this.mapOfPathEnumAndProviderOfHandlerProvider = ",
-                "        MapProviderFactory.<PathEnum, Handler>builder(2)",
-                "            .put(PathEnum.ADMIN, ",
-                "                new MapModuleOne$$ProvideAdminHandlerFactory(mapModuleOne))",
-                "            .put(PathEnum.LOGIN, ",
-                "                new MapModuleTwo$$ProvideLoginHandlerFactory(mapModuleTwo))",
-                "            .build();",
-                "  }",
-                "",
-                "  public static Builder builder() {",
-                "    return new Builder();",
-                "  }",
-                "",
-                "  public static TestComponent create() {",
-                "    return builder().build();",
-                "  }",
-                "",
-                "  @Override",
-                "  public Map<PathEnum, Provider<Handler>> dispatcher() {",
-                "    return mapOfPathEnumAndProviderOfHandlerProvider.get();",
-                "  }",
-                "",
-                "  public static final class Builder {",
-                "    private MapModuleOne mapModuleOne;",
-                "    private MapModuleTwo mapModuleTwo;",
-                "",
-                "    private Builder() {",
-                "    }",
-                "",
-                "    public TestComponent build() {",
-                "      if (mapModuleOne == null) {",
-                "        this.mapModuleOne = new MapModuleOne();",
-                "      }",
-                "      if (mapModuleTwo == null) {",
-                "        this.mapModuleTwo = new MapModuleTwo();",
-                "      }",
-                "      return new Dagger_TestComponent(this);",
-                "    }",
-                "",
-                "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
-                "      if (mapModuleOne == null) {",
-                "        throw new NullPointerException(\"mapModuleOne\");",
-                "      }",
-                "      this.mapModuleOne = mapModuleOne;",
-                "      return this;",
-                "    }",
-                "",
-                "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
-                "      if (mapModuleTwo == null) {",
-                "        throw new NullPointerException(\"mapModuleTwo\");",
-                "      }",
-                "      this.mapModuleTwo = mapModuleTwo;",
-                "      return this;",
-                "    }",
-                "  }",
-                "}",
-                "");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.Dagger_TestComponent",
+        "package test;",
+        "",
+        "import dagger.internal.MapProviderFactory;",
+        "import java.util.Map;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_TestComponent implements TestComponent {",
+        "  private final MapModuleOne mapModuleOne;",
+        "  private final MapModuleTwo mapModuleTwo;",
+        "  private final Provider<Map<PathEnum, Provider<Handler>>> ",
+        "      mapOfPathEnumAndProviderOfHandlerProvider;",
+        "",
+        "  private Dagger_TestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    this.mapModuleOne = builder.mapModuleOne;",
+        "    this.mapModuleTwo = builder.mapModuleTwo;",
+        "    this.mapOfPathEnumAndProviderOfHandlerProvider = ",
+        "        MapProviderFactory.<PathEnum, Handler>builder(2)",
+        "            .put(PathEnum.ADMIN, ",
+        "                new MapModuleOne$$ProvideAdminHandlerFactory(mapModuleOne))",
+        "            .put(PathEnum.LOGIN, ",
+        "                new MapModuleTwo$$ProvideLoginHandlerFactory(mapModuleTwo))",
+        "            .build();",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  @Override",
+        "  public Map<PathEnum, Provider<Handler>> dispatcher() {",
+        "    return mapOfPathEnumAndProviderOfHandlerProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private MapModuleOne mapModuleOne;",
+        "    private MapModuleTwo mapModuleTwo;",
+        "",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public TestComponent build() {",
+        "      if (mapModuleOne == null) {",
+        "        this.mapModuleOne = new MapModuleOne();",
+        "      }",
+        "      if (mapModuleTwo == null) {",
+        "        this.mapModuleTwo = new MapModuleTwo();",
+        "      }",
+        "      return new Dagger_TestComponent(this);",
+        "    }",
+        "",
+        "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+        "      if (mapModuleOne == null) {",
+        "        throw new NullPointerException(\"mapModuleOne\");",
+        "      }",
+        "      this.mapModuleOne = mapModuleOne;",
+        "      return this;",
+        "    }",
+        "",
+        "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+        "      if (mapModuleTwo == null) {",
+        "        throw new NullPointerException(\"mapModuleTwo\");",
+        "      }",
+        "      this.mapModuleTwo = mapModuleTwo;",
+        "      return this;",
+        "    }",
+        "  }",
+        "}",
+        "");
     assert_().about(javaSources())
         .that(ImmutableList.of(mapModuleOneFile,
             mapModuleTwoFile,
@@ -197,44 +190,39 @@ public void mapBindingsWithEnumKey() {
             componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and()
-        .generatesSources(generatedComponent);
+        .and().generatesSources(generatedComponent);
   }
 
-  @Test
-  public void mapBindingsWithStringKey() {
-    JavaFileObject mapModuleOneFile =
-        JavaFileObjects
-            .forSourceLines("test.MapModuleOne",
-                "package test;",
-                "",
-                "import static dagger.Provides.Type.MAP;",
-                "",
-                "import dagger.Module;",
-                "import dagger.Provides;",
-                "",
-                "@Module",
-                "final class MapModuleOne {",
-                "  @Provides(type = MAP) @StringKey(\"Admin\") Handler provideAdminHandler() {",
-                "    return new AdminHandler();",
-                "  }",
-                "}");
-    JavaFileObject mapModuleTwoFile =
-        JavaFileObjects
-            .forSourceLines("test.MapModuleTwo",
-                "package test;",
-                "",
-                "import static dagger.Provides.Type.MAP;",
-                "",
-                "import dagger.Module;",
-                "import dagger.Provides;",
-                "",
-                "@Module",
-                "final class MapModuleTwo {",
-                "  @Provides(type = MAP) @StringKey(\"Login\") Handler provideLoginHandler() {",
-                "    return new LoginHandler();",
-                "  }",
-                "}");
+ @Test
+ public void mapBindingsWithStringKey() {
+    JavaFileObject mapModuleOneFile = JavaFileObjects.forSourceLines("test.MapModuleOne",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.MAP;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class MapModuleOne {",
+        "  @Provides(type = MAP) @StringKey(\"Admin\") Handler provideAdminHandler() {",
+        "    return new AdminHandler();",
+        "  }",
+        "}");
+    JavaFileObject mapModuleTwoFile = JavaFileObjects.forSourceLines("test.MapModuleTwo",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.MAP;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class MapModuleTwo {",
+        "  @Provides(type = MAP) @StringKey(\"Login\") Handler provideLoginHandler() {",
+        "    return new LoginHandler();",
+        "  }",
+        "}");
     JavaFileObject stringKeyFile = JavaFileObjects.forSourceLines("test.StringKey",
         "package test;",
         "import dagger.MapKey;",
@@ -273,85 +261,82 @@ public void mapBindingsWithStringKey() {
         "interface TestComponent {",
         "  Map<String, Provider<Handler>> dispatcher();",
         "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects
-            .forSourceLines("test.Dagger_TestComponent",
-                "package test;",
-                "",
-                "import dagger.internal.MapProviderFactory;",
-                "import java.util.Map;",
-                "import javax.annotation.Generated;",
-                "import javax.inject.Provider;",
-                "",
-                "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-                "public final class Dagger_TestComponent implements TestComponent {",
-                "  private final MapModuleOne mapModuleOne;",
-                "  private final MapModuleTwo mapModuleTwo;",
-                "  private final Provider<Map<String, Provider<Handler>>> ",
-                "      mapOfStringAndProviderOfHandlerProvider;",
-                "",
-                "",
-                "  private Dagger_TestComponent(Builder builder) {",
-                "    assert builder != null;",
-                "    this.mapModuleOne = builder.mapModuleOne;",
-                "    this.mapModuleTwo = builder.mapModuleTwo;",
-                "    this.mapOfStringAndProviderOfHandlerProvider =",
-                "        MapProviderFactory.<String, Handler>builder(2)",
-                "            .put(\"Admin\", ",
-                "                new MapModuleOne$$ProvideAdminHandlerFactory(mapModuleOne))",
-                "            .put(\"Login\", ",
-                "                new MapModuleTwo$$ProvideLoginHandlerFactory(mapModuleTwo))",
-                "            .build();",
-                "  }",
-                "",
-                "  public static Builder builder() {",
-                "    return new Builder();",
-                "  }",
-                "",
-                "  public static TestComponent create() {",
-                "    return builder().build();",
-                "  }",
-                "",
-                "  @Override",
-                "  public Map<String, Provider<Handler>> dispatcher() {",
-                "    return mapOfStringAndProviderOfHandlerProvider.get();",
-                "  }",
-                "",
-                "  public static final class Builder {",
-                "    private MapModuleOne mapModuleOne;",
-                "    private MapModuleTwo mapModuleTwo;",
-                "",
-                "    private Builder() {",
-                "    }",
-                "",
-                "    public TestComponent build() {",
-                "      if (mapModuleOne == null) {",
-                "        this.mapModuleOne = new MapModuleOne();",
-                "      }",
-                "      if (mapModuleTwo == null) {",
-                "        this.mapModuleTwo = new MapModuleTwo();",
-                "      }",
-                "      return new Dagger_TestComponent(this);",
-                "    }",
-                "",
-                "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
-                "      if (mapModuleOne == null) {",
-                "        throw new NullPointerException(\"mapModuleOne\");",
-                "      }",
-                "      this.mapModuleOne = mapModuleOne;",
-                "      return this;",
-                "    }",
-                "",
-                "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
-                "      if (mapModuleTwo == null) {",
-                "        throw new NullPointerException(\"mapModuleTwo\");",
-                "      }",
-                "      this.mapModuleTwo = mapModuleTwo;",
-                "      return this;",
-                "    }",
-                "  }",
-                "}");
-
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.Dagger_TestComponent",
+        "package test;",
+        "",
+        "import dagger.internal.MapProviderFactory;",
+        "import java.util.Map;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_TestComponent implements TestComponent {",
+        "  private final MapModuleOne mapModuleOne;",
+        "  private final MapModuleTwo mapModuleTwo;",
+        "  private final Provider<Map<String, Provider<Handler>>> ",
+        "      mapOfStringAndProviderOfHandlerProvider;",
+        "",
+        "",
+        "  private Dagger_TestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    this.mapModuleOne = builder.mapModuleOne;",
+        "    this.mapModuleTwo = builder.mapModuleTwo;",
+        "    this.mapOfStringAndProviderOfHandlerProvider =",
+        "        MapProviderFactory.<String, Handler>builder(2)",
+        "            .put(\"Admin\",",
+        "                new MapModuleOne$$ProvideAdminHandlerFactory(mapModuleOne))",
+        "            .put(\"Login\",",
+        "                new MapModuleTwo$$ProvideLoginHandlerFactory(mapModuleTwo))",
+        "            .build();",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  @Override",
+        "  public Map<String, Provider<Handler>> dispatcher() {",
+        "    return mapOfStringAndProviderOfHandlerProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private MapModuleOne mapModuleOne;",
+        "    private MapModuleTwo mapModuleTwo;",
+        "",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public TestComponent build() {",
+        "      if (mapModuleOne == null) {",
+        "        this.mapModuleOne = new MapModuleOne();",
+        "      }",
+        "      if (mapModuleTwo == null) {",
+        "        this.mapModuleTwo = new MapModuleTwo();",
+        "      }",
+        "      return new Dagger_TestComponent(this);",
+        "    }",
+        "",
+        "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+        "      if (mapModuleOne == null) {",
+        "        throw new NullPointerException(\"mapModuleOne\");",
+        "      }",
+        "      this.mapModuleOne = mapModuleOne;",
+        "      return this;",
+        "    }",
+        "",
+        "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+        "      if (mapModuleTwo == null) {",
+        "        throw new NullPointerException(\"mapModuleTwo\");",
+        "      }",
+        "      this.mapModuleTwo = mapModuleTwo;",
+        "      return this;",
+        "    }",
+        "  }",
+        "}");
     assert_().about(javaSources())
         .that(ImmutableList.of(mapModuleOneFile,
             mapModuleTwoFile,
@@ -362,7 +347,264 @@ public void mapBindingsWithStringKey() {
             componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and()
-        .generatesSources(generatedComponent);
+        .and().generatesSources(generatedComponent);
+  }
+
+  @Test
+  public void mapBindingsWithNonProviderValue() {
+    JavaFileObject mapModuleOneFile = JavaFileObjects.forSourceLines("test.MapModuleOne",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.MAP;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class MapModuleOne {",
+        "  @Provides(type = MAP) @PathKey(PathEnum.ADMIN) Handler provideAdminHandler() {",
+        "    return new AdminHandler(); ",
+        "  }",
+        "}");
+    JavaFileObject mapModuleTwoFile = JavaFileObjects.forSourceLines("test.MapModuleTwo",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.MAP;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class MapModuleTwo {",
+        "  @Provides(type = MAP) @PathKey(PathEnum.LOGIN) Handler provideLoginHandler() {",
+        "    return new LoginHandler(); ",
+        "  }",
+        "}");
+    JavaFileObject enumKeyFile = JavaFileObjects.forSourceLines("test.PathKey",
+        "package test;",
+        "import dagger.MapKey;",
+        "import java.lang.annotation.Retention;",
+        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+        "",
+        "@MapKey(unwrapValue = true)",
+        "@Retention(RUNTIME)",
+        "public @interface PathKey {",
+        "  PathEnum value();",
+        "}");
+    JavaFileObject pathEnumFile = JavaFileObjects.forSourceLines("test.PathEnum",
+        "package test;",
+        "",
+        "public enum PathEnum {",
+        "    ADMIN,",
+        "    LOGIN;",
+        "}");
+    JavaFileObject HandlerFile = JavaFileObjects.forSourceLines("test.Handler", 
+        "package test;", 
+        "", 
+        "interface Handler {}");
+    JavaFileObject LoginHandlerFile = JavaFileObjects.forSourceLines("test.LoginHandler",
+        "package test;",
+        "",
+        "class LoginHandler implements Handler {",
+        "  public LoginHandler() {}",
+        "}");
+    JavaFileObject AdminHandlerFile = JavaFileObjects.forSourceLines("test.AdminHandler",
+        "package test;",
+        "",
+        "class AdminHandler implements Handler {",
+        "  public AdminHandler() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.Map;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
+        "interface TestComponent {",
+        "  Map<PathEnum, Handler> dispatcher();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.Dagger_TestComponent",
+        "package test;",
+        "",
+        "import dagger.internal.MapFactory;",
+        "import dagger.internal.MapProviderFactory;",
+        "import java.util.Map;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_TestComponent implements TestComponent {",
+        "  private final MapModuleOne mapModuleOne;",
+        "  private final MapModuleTwo mapModuleTwo;",
+        "  private final Provider<Map<PathEnum, Provider<Handler>>> ",
+        "      mapOfPathEnumAndProviderOfHandlerProvider;",
+        "  private final Provider<Map<PathEnum, Handler>> mapOfPathEnumAndHandlerProvider;",
+        "",
+        "  private Dagger_TestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    this.mapModuleOne = builder.mapModuleOne;",
+        "    this.mapModuleTwo = builder.mapModuleTwo;",
+        "    this.mapOfPathEnumAndProviderOfHandlerProvider = ",
+        "        MapProviderFactory.<PathEnum, Handler>builder(2)",
+        "            .put(PathEnum.ADMIN, ",
+        "                new MapModuleOne$$ProvideAdminHandlerFactory(mapModuleOne))",
+        "            .put(PathEnum.LOGIN, ",
+        "                new MapModuleTwo$$ProvideLoginHandlerFactory(mapModuleTwo))",
+        "            .build();",
+        "    this.mapOfPathEnumAndHandlerProvider = ",
+        "        MapFactory.create(mapOfPathEnumAndProviderOfHandlerProvider);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  @Override",
+        "  public Map<PathEnum, Handler> dispatcher() {",
+        "    return mapOfPathEnumAndHandlerProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private MapModuleOne mapModuleOne;",
+        "    private MapModuleTwo mapModuleTwo;",
+        "",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public TestComponent build() {",
+        "      if (mapModuleOne == null) {",
+        "        this.mapModuleOne = new MapModuleOne();",
+        "      }",
+        "      if (mapModuleTwo == null) {",
+        "        this.mapModuleTwo = new MapModuleTwo();",
+        "      }",
+        "      return new Dagger_TestComponent(this);",
+        "    }",
+        "",
+        "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+        "      if (mapModuleOne == null) {",
+        "        throw new NullPointerException(\"mapModuleOne\");",
+        "      }",
+        "      this.mapModuleOne = mapModuleOne;",
+        "      return this;",
+        "    }",
+        "",
+        "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+        "      if (mapModuleTwo == null) {",
+        "        throw new NullPointerException(\"mapModuleTwo\");",
+        "      }",
+        "      this.mapModuleTwo = mapModuleTwo;",
+        "      return this;",
+        "    }",
+        "  }",
+        "}",
+        "");
+    assert_().about(javaSources())
+        .that(ImmutableList.of(mapModuleOneFile,
+            mapModuleTwoFile,
+            enumKeyFile,
+            pathEnumFile,
+            HandlerFile,
+            LoginHandlerFile,
+            AdminHandlerFile,
+            componentFile)).
+        processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+
+  @Test
+  public void injectMapWithoutMapBinding() {
+    JavaFileObject mapModuleFile = JavaFileObjects.forSourceLines("test.MapModule",
+        "package test;",
+        "",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import java.util.HashMap;",
+        "import java.util.Map;",
+        "",
+        "@Module",
+        "final class MapModule {",
+        "  @Provides Map<String, String> provideAMap() {",
+        "    Map<String, String> map = new HashMap<String, String>();",
+        "    map.put(\"Hello\", \"World\");",
+        "    return map;",
+        "  }",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.Map;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = {MapModule.class})",
+        "interface TestComponent {",
+        "  Map<String, String> dispatcher();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.Dagger_TestComponent",
+        "package test;",
+        "",
+        "import java.util.Map;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_TestComponent implements TestComponent {",
+        "  private final MapModule mapModule;",
+        "  private final Provider<Map<String, String>> provideAMapProvider;",
+        "",
+        "",
+        "  private Dagger_TestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    this.mapModule = builder.mapModule;",
+        "    this.provideAMapProvider = new MapModule$$ProvideAMapFactory(mapModule);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  @Override",
+        "  public Map<String, String> dispatcher() {",
+        "    return provideAMapProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private MapModule mapModule;",
+        "",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public TestComponent build() { ",
+        "      if (mapModule == null) {",
+        "        this.mapModule = new MapModule();",
+        "      }",
+        "      return new Dagger_TestComponent(this);",
+        "    }",
+        "",
+        "    public Builder mapModule(MapModule mapModule) {",
+        "      if (mapModule == null) {",
+        "        throw new NullPointerException(\"mapModule\");",
+        "      }",
+        "      this.mapModule = mapModule;",
+        "      return this;",
+        "    }",
+        "  }",
+        "}");
+    assert_().about(javaSources()).that(ImmutableList.of(mapModuleFile,componentFile))
+        .processedWith(new ComponentProcessor()).compilesWithoutError()
+        .and().generatesSources(generatedComponent);
   }
-}
+}
\ No newline at end of file
diff --git a/core/src/main/java/dagger/internal/MapFactory.java b/core/src/main/java/dagger/internal/MapFactory.java
new file mode 100644
index 000000000..10fd6169f
--- /dev/null
+++ b/core/src/main/java/dagger/internal/MapFactory.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import dagger.Factory;
+
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+
+import javax.inject.Provider;
+
+/**
+ * A {@link Factory} implementation used to implement {@link Map} bindings. This factory returns a
+ * {@code Map<K, V>} when calling {@link #get} (as specified by {@link Factory}).
+ *
+ * @author Chenying Hou
+ * @since 2.0
+ *
+ */
+public class MapFactory<K, V> implements Factory<Map<K, V>> {
+  private final Map<K, Provider<V>> contributingMap;
+  
+  private MapFactory(Map<K, Provider<V>> map) {
+    this.contributingMap = Collections.unmodifiableMap(map);
+  }
+
+  /**
+   * Returns a new MapFactory.
+   */
+  public static <K, V> MapFactory<K, V> create(Provider<Map<K, Provider<V>>> mapProviderFactory) {
+    Map<K, Provider<V>> map = mapProviderFactory.get();
+    return new MapFactory<K, V>(map);
+  }
+
+  /**
+   * Returns a {@code Map<K, V>} whose iteration order is that of the elements
+   * given by each of the providers, which are invoked in the order given at creation.
+   *
+   */
+  @Override
+  public Map<K, V> get() {
+    LinkedHashMap<K, V> result = new LinkedHashMap<K, V>();
+    for (Entry<K, Provider<V>> entry: contributingMap.entrySet()) {
+      result.put(entry.getKey(), entry.getValue().get());
+    }
+    return result;
+  }
+}
