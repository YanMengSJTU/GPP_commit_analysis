diff --git a/compiler/pom.xml b/compiler/pom.xml
index 577481e9b..343c89ec9 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -50,10 +50,12 @@
       <artifactId>auto-service</artifactId>
       <optional>true</optional>
     </dependency>
+    <!-- TODO(gak): Restore this presumably as javapoet when appropriate.
     <dependency>
       <groupId>com.squareup</groupId>
       <artifactId>javawriter</artifactId>
     </dependency>
+    -->
     <dependency>
       <groupId>com.google.guava</groupId>
       <artifactId>guava</artifactId>
@@ -63,6 +65,7 @@
       <groupId>com.google.auto.value</groupId>
       <artifactId>auto-value</artifactId>
       <optional>true</optional>
+      <version>1.0</version>
     </dependency>
 
     <dependency>
diff --git a/compiler/src/it/functional-tests/pom.xml b/compiler/src/it/functional-tests/pom.xml
index a7dbbc8b1..688cd7291 100644
--- a/compiler/src/it/functional-tests/pom.xml
+++ b/compiler/src/it/functional-tests/pom.xml
@@ -33,12 +33,12 @@ limitations under the License.
       <artifactId>dagger</artifactId>
       <version>${project.version}</version>
     </dependency>
-      <dependency>
-        <groupId>com.google.dagger</groupId>
-        <artifactId>dagger-compiler</artifactId>
-        <version>${project.version}</version>
-        <optional>true</optional>
-      </dependency>
+    <dependency>
+      <groupId>com.google.dagger</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>${project.version}</version>
+      <optional>true</optional>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
@@ -50,10 +50,6 @@ limitations under the License.
       <artifactId>truth</artifactId>
       <scope>test</scope>
     </dependency>
-    <dependency>
-      <groupId>com.google.guava</groupId>
-      <artifactId>guava</artifactId>
-    </dependency>
   </dependencies>
   <build>
     <plugins>
@@ -61,8 +57,8 @@ limitations under the License.
         <artifactId>maven-compiler-plugin</artifactId>
         <version>3.1</version>
         <configuration>
-          <source>1.6</source>
-          <target>1.6</target>
+          <source>1.7</source>
+          <target>1.7</target>
           <annotationProcessors>
             <annotationProcessor>dagger.internal.codegen.ComponentProcessor</annotationProcessor>
           </annotationProcessors>
diff --git a/compiler/src/it/functional-tests/src/main/java/test/BoundedGenericModule.java b/compiler/src/it/functional-tests/src/main/java/test/BoundedGenericModule.java
index 963e0325c..6bd7be4fb 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/BoundedGenericModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/BoundedGenericModule.java
@@ -15,12 +15,10 @@
  */
 package test;
 
-import com.google.common.collect.Lists;
-import com.google.common.collect.Sets;
 import dagger.Module;
 import dagger.Provides;
 import java.util.ArrayList;
-import java.util.Collections;
+import java.util.HashSet;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Set;
@@ -40,38 +38,44 @@ Double provideDouble() {
 
   @Provides
   ArrayList<String> provideArrayListString() {
-    return Lists.newArrayList("arrayListOfString");
+    ArrayList<String> list = new ArrayList<>();
+    list.add("arrayListOfString");
+    return list;
   }
 
   @Provides
   LinkedList<String> provideLinkedListString() {
-    return BoundedGenericModule.newLinkedList("linkedListOfString");
+    LinkedList<String> list = new LinkedList<>();
+    list.add("linkedListOfString");
+    return list;
   }
 
   @Provides
   LinkedList<CharSequence> provideLinkedListCharSeq() {
-    return BoundedGenericModule.<CharSequence>newLinkedList("linkedListOfCharSeq");
+    LinkedList<CharSequence> list = new LinkedList<>();
+    list.add("linkedListOfCharSeq");
+    return list;
   }
 
   @Provides
   @SuppressWarnings("unchecked")
   LinkedList<Comparable<String>> provideArrayListOfComparableString() {
-    return BoundedGenericModule.<Comparable<String>>newLinkedList("arrayListOfComparableOfString");
+    LinkedList<Comparable<String>> list = new LinkedList<>();
+    list.add("arrayListOfComparableOfString");
+    return list;
   }
 
   @Provides
   List<Integer> provideListOfInteger() {
-    return Lists.newArrayList(3);
+    LinkedList<Integer> list = new LinkedList<>();
+    list.add(3);
+    return list;
   }
 
   @Provides
   Set<Double> provideSetOfDouble() {
-    return Sets.newHashSet(4d);
-  }
-
-  private static <E> LinkedList<E> newLinkedList(E... elements) {
-    LinkedList<E> list = Lists.newLinkedList();
-    Collections.addAll(list, elements);
-    return list;
+    Set<Double> set = new HashSet<>();
+    set.add(4d);
+    return set;
   }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ChildDoubleModule.java b/compiler/src/it/functional-tests/src/main/java/test/ChildDoubleModule.java
new file mode 100644
index 000000000..09a1e6b72
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/ChildDoubleModule.java
@@ -0,0 +1,21 @@
+package test;
+
+import dagger.Module;
+import dagger.Provides;
+import java.util.ArrayList;
+import java.util.List;
+
+@Module
+class ChildDoubleModule extends ParentModule<Double, String, List<Double>> {
+
+  @Provides Double provideDouble() {
+    return 3d;
+  }
+
+  @Provides List<Double> provideListOfDouble() {
+    List<Double> list = new ArrayList<>();
+    list.add(4d);
+    return list;
+  }
+
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ChildIntegerModule.java b/compiler/src/it/functional-tests/src/main/java/test/ChildIntegerModule.java
new file mode 100644
index 000000000..ac9c61207
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/ChildIntegerModule.java
@@ -0,0 +1,21 @@
+package test;
+
+import dagger.Module;
+import dagger.Provides;
+import java.util.ArrayList;
+import java.util.List;
+
+@Module
+class ChildIntegerModule extends ParentModule<Integer, String, List<Integer>> {
+
+  @Provides Integer provideInteger() {
+    return 1;
+  }
+
+  @Provides List<Integer> provideListOfInteger() {
+    List<Integer> list = new ArrayList<>();
+    list.add(2);
+    return list;
+  }
+
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/GenericComponent.java b/compiler/src/it/functional-tests/src/main/java/test/GenericComponent.java
index 37b8881c6..da5b9b530 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/GenericComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/GenericComponent.java
@@ -19,7 +19,7 @@
 import test.sub.Exposed;
 import test.sub.PublicSubclass;
 
-@Component
+@Component(modules = {ChildDoubleModule.class, ChildIntegerModule.class})
 interface GenericComponent {
   ReferencesGeneric referencesGeneric();
   GenericDoubleReferences<A> doubleGenericA();
@@ -27,10 +27,13 @@
   ComplexGenerics complexGenerics();
   GenericNoDeps<A> noDepsA();
   GenericNoDeps<B> noDepsB();
-  
+
   void injectA(GenericChild<A> childA);
   void injectB(GenericChild<B> childB);
 
   Exposed exposed();
   PublicSubclass publicSubclass();
+  
+  Iterable<Integer> iterableInt();
+  Iterable<Double> iterableDouble();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
new file mode 100644
index 000000000..3b76fc642
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
@@ -0,0 +1,24 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import dagger.Component;
+import java.util.Map;
+
+@Component(modules = MultibindingModule.class)
+interface MultibindingComponent {
+  Map<String, String> map();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
new file mode 100644
index 000000000..0e83ed519
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
@@ -0,0 +1,32 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import dagger.Module;
+import dagger.Provides;
+
+import static dagger.Provides.Type.MAP;
+
+@Module
+class MultibindingModule {
+  @Provides(type = MAP) @TestKey("foo") String provideFooKey() {
+    return "foo value";
+  }
+
+  @Provides(type = MAP) @TestKey("bar") String provideBarKey() {
+    return "bar value";
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/NonComponentDependencyComponent.java b/compiler/src/it/functional-tests/src/main/java/test/NonComponentDependencyComponent.java
new file mode 100644
index 000000000..5521dd7dd
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/NonComponentDependencyComponent.java
@@ -0,0 +1,42 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import dagger.Component;
+import javax.inject.Inject;
+
+@Component(dependencies = {NonComponentDependencyComponent.ThingComponent.class})
+interface NonComponentDependencyComponent {
+  ThingTwo thingTwo();
+
+  static class ThingTwo {
+    @Inject
+    ThingTwo(Thing thing) {}
+  }
+
+  // A non-component interface which this interface depends upon.
+  interface ThingComponent {
+    Thing thing();
+  }
+
+  // The implementation for that interface.
+  static class ThingComponentImpl implements ThingComponent {
+    @Override
+    public Thing thing() {
+      return new Thing();
+    }
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ParentModule.java b/compiler/src/it/functional-tests/src/main/java/test/ParentModule.java
new file mode 100644
index 000000000..a161abaa8
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/ParentModule.java
@@ -0,0 +1,18 @@
+package test;
+
+import dagger.Module;
+import dagger.Provides;
+import java.util.ArrayList;
+import java.util.List;
+
+@Module
+abstract class ParentModule<A extends Number & Comparable<A>, B, C extends Iterable<A>> {
+  @Provides Iterable<A> provideIterableOfAWithC(A a, C c) {
+    List<A> list = new ArrayList<>();
+    list.add(a);
+    for (A elt : c) {
+      list.add(elt);
+    }
+    return list;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestKey.java b/compiler/src/it/functional-tests/src/main/java/test/TestKey.java
new file mode 100644
index 000000000..549eb3fa7
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/TestKey.java
@@ -0,0 +1,23 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import dagger.MapKey;
+
+@MapKey(unwrapValue = true)
+@interface TestKey {
+  String value();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/nullables/NullComponent.java b/compiler/src/it/functional-tests/src/main/java/test/nullables/NullComponent.java
new file mode 100644
index 000000000..a8a572473
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/nullables/NullComponent.java
@@ -0,0 +1,29 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test.nullables;
+
+import javax.inject.Provider;
+
+import dagger.Component;
+
+@Component(modules = NullModule.class)
+interface NullComponent {
+  NullFoo nullFoo();
+  @Nullable String string();
+  Provider<String> stringProvider();
+  Number number();
+  Provider<Number> numberProvider();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/nullables/NullComponentWithDependency.java b/compiler/src/it/functional-tests/src/main/java/test/nullables/NullComponentWithDependency.java
new file mode 100644
index 000000000..05093ed60
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/nullables/NullComponentWithDependency.java
@@ -0,0 +1,28 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test.nullables;
+
+import javax.inject.Provider;
+
+import dagger.Component;
+
+@Component(dependencies = NullComponent.class)
+interface NullComponentWithDependency {
+  @Nullable String string();
+  Provider<String> stringProvider();
+  Number number();
+  Provider<Number> numberProvider();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/nullables/NullFoo.java b/compiler/src/it/functional-tests/src/main/java/test/nullables/NullFoo.java
new file mode 100644
index 000000000..9ed4b5dea
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/nullables/NullFoo.java
@@ -0,0 +1,56 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test.nullables;
+
+import javax.inject.Inject;
+import javax.inject.Provider;
+
+class NullFoo {
+  final String string;
+  final Provider<String> stringProvider;
+  final Number number;
+  final Provider<Number> numberProvider;
+
+  @Inject
+  NullFoo(@Nullable String string,
+      Provider<String> stringProvider,
+      Number number,
+      Provider<Number> numberProvider) {
+    this.string = string;
+    this.stringProvider = stringProvider;
+    this.number = number;
+    this.numberProvider = numberProvider;
+  }
+
+  String methodInjectedString;
+  Provider<String> methodInjectedStringProvider;
+  Number methodInjectedNumber;
+  Provider<Number> methodInjectedNumberProvider;
+  @Inject void inject(@Nullable String string,
+      Provider<String> stringProvider,
+      Number number,
+      Provider<Number> numberProvider) {
+    this.methodInjectedString = string;
+    this.methodInjectedStringProvider = stringProvider;
+    this.methodInjectedNumber = number;
+    this.methodInjectedNumberProvider = numberProvider;
+  }
+
+  @Nullable @Inject String fieldInjectedString;
+  @Inject Provider<String> fieldInjectedStringProvider;
+  @Inject Number fieldInjectedNumber;
+  @Inject Provider<Number> fieldInjectedNumberProvider;
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/nullables/NullModule.java b/compiler/src/it/functional-tests/src/main/java/test/nullables/NullModule.java
new file mode 100644
index 000000000..652d5ebbb
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/nullables/NullModule.java
@@ -0,0 +1,35 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test.nullables;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+class NullModule {
+  Number numberValue = null;
+
+  @Nullable
+  @Provides
+  String provideNullableString() {
+    return null;
+  }
+
+  @Provides
+  Number provideNumber() {
+    return numberValue;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/nullables/Nullable.java b/compiler/src/it/functional-tests/src/main/java/test/nullables/Nullable.java
new file mode 100644
index 000000000..86776406a
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/nullables/Nullable.java
@@ -0,0 +1,3 @@
+package test.nullables;
+
+@interface Nullable {}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ResolvableBinding.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponent.java
similarity index 56%
rename from compiler/src/main/java/dagger/internal/codegen/ResolvableBinding.java
rename to compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponent.java
index 7dc52f78b..e5247c4a1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ResolvableBinding.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponent.java
@@ -13,17 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package test.subcomponent;
 
-/**
- * A Binding that can be resolved at request time. For example, a ProvisionBinding for
- * {@code List<T>} might be resolved to {@code List<Foo>} or {@code List<Bar>}
- * depending on how it's requested.
- */
-interface ResolvableBinding {  
-  /**
-   * True if this represents a binding that refers to a type with parameters, and the
-   * parameters have been resolved based on a requesting key.
-   */
-  boolean isResolved();
+import dagger.Subcomponent;
+import java.util.Set;
+
+@Subcomponent(modules = ChildModule.class)
+interface ChildComponent {
+  RequiresSingleton requiresSingleton();
+
+  Set<Object> objectSet();
+
+  GrandchildComponent newGrandchildComponent();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModule.java
new file mode 100644
index 000000000..ef28bd47a
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModule.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import dagger.Module;
+import dagger.Provides;
+
+import static dagger.Provides.Type.SET;
+
+@Module
+final class ChildModule {
+  @Provides(type = SET) Object provideUnscopedObject() {
+    return new Object() {
+      @Override public String toString() {
+        return "unscoped in child";
+      }
+    };
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildComponent.java
new file mode 100644
index 000000000..d1332a27c
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildComponent.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import dagger.Subcomponent;
+import java.util.Set;
+
+@Subcomponent(modules = GrandchildModule.class)
+interface GrandchildComponent {
+  RequiresSingleton requiresSingleton();
+  Set<Object> objectSet();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildModule.java
new file mode 100644
index 000000000..b426f6386
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildModule.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import dagger.Module;
+import dagger.Provides;
+
+import static dagger.Provides.Type.SET;
+
+@Module
+final class GrandchildModule {
+  @Provides(type = SET) Object provideUnscopedObject() {
+    return new Object() {
+      @Override public String toString() {
+        return "unscoped in grandchild";
+      }
+    };
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java
new file mode 100644
index 000000000..6bf9bd15a
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import dagger.Component;
+import java.util.Set;
+import javax.inject.Singleton;
+
+@Component(modules = ParentModule.class)
+@Singleton
+interface ParentComponent {
+  SingletonType getSingletonType();
+
+  Set<Object> objectSet();
+
+  ChildComponent newChildComponent();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentModule.java
new file mode 100644
index 000000000..3ac07b086
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentModule.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import dagger.Module;
+import dagger.Provides;
+import javax.inject.Singleton;
+
+import static dagger.Provides.Type.SET;
+
+@Module
+final class ParentModule {
+  @Provides(type = SET) Object provideUnscopedObject() {
+    return new Object() {
+      @Override public String toString() {
+        return "unscoped in parent";
+      }
+    };
+  }
+
+  @Provides(type = SET) @Singleton Object provideSingletonObject() {
+    return new Object() {
+      @Override public String toString() {
+        return "singleton";
+      }
+    };
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresSingleton.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresSingleton.java
new file mode 100644
index 000000000..d7813f1cd
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresSingleton.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import javax.inject.Inject;
+
+final class RequiresSingleton {
+  private final SingletonType singletonType;
+
+  @Inject RequiresSingleton(SingletonType singletonType) {
+    this.singletonType = singletonType;
+  }
+
+  SingletonType singletonType() {
+    return singletonType;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/SingletonType.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/SingletonType.java
new file mode 100644
index 000000000..663e858a9
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/SingletonType.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import javax.inject.Inject;
+import javax.inject.Singleton;
+
+@Singleton
+final class SingletonType {
+  @Inject SingletonType() {}
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/GenericTest.java b/compiler/src/it/functional-tests/src/test/java/test/GenericTest.java
index 844f3e4a8..88be63f0e 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/GenericTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/GenericTest.java
@@ -138,4 +138,11 @@
     
     assertThat(a).isNotSameAs(b);
   }
+  
+  @Test public void genericModules() {
+    GenericComponent component = Dagger_GenericComponent.create();
+    assertThat(component.iterableInt()).containsExactly(1, 2).inOrder();
+    assertThat(component.iterableDouble()).containsExactly(3d, 4d).inOrder();
+    
+  }
 }
diff --git a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
new file mode 100644
index 000000000..dfcf34189
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
@@ -0,0 +1,34 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import java.util.Map;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public class MultibindingTest {
+  @Test public void testMultibindings() {
+    MultibindingComponent multibindingComponent = Dagger_MultibindingComponent.create();
+    Map<String, String> map = multibindingComponent.map();
+    assertThat(map).hasSize(2);
+    assertThat(map).containsEntry("foo", "foo value");
+    assertThat(map).containsEntry("bar", "bar value");
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/NonComponentDependencyTest.java b/compiler/src/it/functional-tests/src/test/java/test/NonComponentDependencyTest.java
new file mode 100644
index 000000000..157acf999
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/NonComponentDependencyTest.java
@@ -0,0 +1,34 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public class NonComponentDependencyTest {
+  @Test public void testThing() {
+    NonComponentDependencyComponent component =
+        Dagger_NonComponentDependencyComponent.builder()
+            .thingComponent(new NonComponentDependencyComponent.ThingComponentImpl())
+            .build();
+    assertThat(component).isNotNull();
+    assertThat(component.thingTwo()).isNotNull();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/nullables/NullabilityTest.java b/compiler/src/it/functional-tests/src/test/java/test/nullables/NullabilityTest.java
new file mode 100644
index 000000000..5ad9efb7c
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/nullables/NullabilityTest.java
@@ -0,0 +1,110 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test.nullables;
+
+import javax.inject.Provider;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+@RunWith(JUnit4.class)
+public class NullabilityTest {
+  @Test public void testNullability_provides() {
+    NullModule module = new NullModule();
+    NullComponent component = Dagger_NullComponent.builder().nullModule(module).build();
+
+    // Can't construct NullFoo because it depends on Number, and Number was null.
+    try {
+      component.nullFoo();
+      fail();
+    } catch (NullPointerException npe) {
+      assertThat(npe).hasMessage("Cannot return null from a non-@Nullable @Provides method");
+    }
+
+    // set number to non-null so we can create
+    module.numberValue = 1;
+    NullFoo nullFoo = component.nullFoo();
+
+    // Then set it back to null so we can test its providers.
+    module.numberValue = null;
+    validate(true, nullFoo.string, nullFoo.stringProvider, nullFoo.numberProvider);
+    validate(true, nullFoo.methodInjectedString, nullFoo.methodInjectedStringProvider,
+        nullFoo.methodInjectedNumberProvider);
+    validate(true, nullFoo.fieldInjectedString, nullFoo.fieldInjectedStringProvider,
+        nullFoo.fieldInjectedNumberProvider);
+  }
+  
+  @Test public void testNullability_components() {
+    NullComponent nullComponent = new NullComponent() {      
+      @Override public Provider<String> stringProvider() {
+        return new Provider<String>() {
+          @Override public String get() {
+            return null;
+          }
+        };
+      }
+      
+      @Override public String string() {
+        return null;
+      }
+      
+      @Override public Provider<Number> numberProvider() {
+        return new Provider<Number>() {
+          @Override public Number get() {
+            return null;
+          }
+        };
+      }
+      
+      @Override public Number number() {
+        return null;
+      }
+      
+      @Override public NullFoo nullFoo() {
+        return null;
+      }
+    };
+    NullComponentWithDependency component =
+        Dagger_NullComponentWithDependency.builder().nullComponent(nullComponent).build();
+    validate(false, component.string(), component.stringProvider(), component.numberProvider());
+    
+    // Also validate that the component's number() method fails
+    try {
+      component.number();
+      fail();
+    } catch (NullPointerException npe) {
+      assertThat(npe).hasMessage("Cannot return null from a non-@Nullable component method");
+    }
+  }
+
+  private void validate(boolean fromProvides,
+      String string,
+      Provider<String> stringProvider,
+      Provider<Number> numberProvider) {
+    assertThat(string).isNull();
+    assertThat(numberProvider).isNotNull();
+    try {
+      numberProvider.get();
+      fail();
+    } catch(NullPointerException npe) {
+      assertThat(npe).hasMessage("Cannot return null from a non-@Nullable "
+          + (fromProvides ? "@Provides" : "component") + " method");
+    }
+    assertThat(stringProvider.get()).isNull();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentScopeTest.java b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentScopeTest.java
new file mode 100644
index 000000000..3d6079b22
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentScopeTest.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import java.util.Set;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.collect.Sets.intersection;
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public class SubcomponentScopeTest {
+  @Test
+  public void testSingletonPropagatesUpward() {
+    ParentComponent parentComponent = Dagger_ParentComponent.create();
+    SingletonType singletonType = parentComponent.getSingletonType();
+    assertThat(parentComponent.newChildComponent().requiresSingleton().singletonType())
+        .isSameAs(singletonType);
+    assertThat(parentComponent.newChildComponent()
+        .newGrandchildComponent()
+        .requiresSingleton().singletonType())
+            .isSameAs(singletonType);
+  }
+
+  @Test
+  public void testMultibindingContributions() {
+    ParentComponent parentComponent = Dagger_ParentComponent.create();
+    Set<Object> parentObjectSet = parentComponent.objectSet();
+    assertThat(parentObjectSet).hasSize(2);
+    Set<Object> childObjectSet = parentComponent.newChildComponent().objectSet();
+    assertThat(childObjectSet).hasSize(3);
+    Set<Object> grandchildObjectSet =
+        parentComponent.newChildComponent().newGrandchildComponent().objectSet();
+    assertThat(grandchildObjectSet).hasSize(4);
+    assertThat(intersection(parentObjectSet, childObjectSet)).hasSize(1);
+    assertThat(intersection(parentObjectSet, grandchildObjectSet)).hasSize(1);
+    assertThat(intersection(childObjectSet, grandchildObjectSet)).hasSize(1);
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/pom.xml b/compiler/src/it/producers-functional-tests/pom.xml
new file mode 100644
index 000000000..b8e8972e8
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/pom.xml
@@ -0,0 +1,96 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+Copyright (C) 2014 Google, Inc.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <parent>
+    <groupId>com.google.dagger</groupId>
+    <artifactId>dagger-parent</artifactId>
+    <version>2.0-SNAPSHOT</version>
+  </parent>
+  <groupId>dagger.tests</groupId>
+  <artifactId>producers-functional-tests</artifactId>
+  <name>Producers Functional Tests</name>
+  <dependencies>
+    <dependency>
+      <groupId>com.google.dagger</groupId>
+      <artifactId>dagger</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.dagger</groupId>
+      <artifactId>dagger-producers</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.dagger</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>${project.version}</version>
+      <optional>true</optional>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.google.truth</groupId>
+      <artifactId>truth</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <version>3.1</version>
+        <configuration>
+          <source>1.7</source>
+          <target>1.7</target>
+          <annotationProcessors>
+            <annotationProcessor>dagger.internal.codegen.ComponentProcessor</annotationProcessor>
+          </annotationProcessors>
+        </configuration>
+      </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-checkstyle-plugin</artifactId>
+        <version>2.10</version>
+        <configuration>
+          <failsOnError>false</failsOnError>
+          <consoleOutput>true</consoleOutput>
+          <configLocation>../../../../checkstyle.xml</configLocation>
+        </configuration>
+        <executions>
+          <execution>
+            <phase>compile</phase>
+            <goals>
+              <goal>checkstyle</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/DependedComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/test/DependedComponent.java
new file mode 100644
index 000000000..fa392dd8e
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/test/DependedComponent.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.Component;
+
+@Component(modules = DependedModule.class)
+interface DependedComponent {
+  String getGreeting();
+}
+
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/DependedModule.java b/compiler/src/it/producers-functional-tests/src/main/java/test/DependedModule.java
new file mode 100644
index 000000000..604107025
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/test/DependedModule.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+final class DependedModule {
+  @Provides
+  String provideGreeting() {
+    return "Hello world!";
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/DependedProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/test/DependedProducerModule.java
new file mode 100644
index 000000000..ad0c792a9
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/test/DependedProducerModule.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import com.google.common.base.Ascii;
+import com.google.common.collect.ImmutableList;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+
+import java.util.List;
+
+@ProducerModule
+final class DependedProducerModule {
+
+  @Produces
+  int produceNumberOfGreetings() {
+    return 2;
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/DependedProductionComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/test/DependedProductionComponent.java
new file mode 100644
index 000000000..57f175812
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/test/DependedProductionComponent.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProductionComponent;
+
+@ProductionComponent(modules = DependedProducerModule.class)
+interface DependedProductionComponent {
+  ListenableFuture<Integer> numGreetings();
+}
+
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/DependentComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/test/DependentComponent.java
new file mode 100644
index 000000000..4b14f99b5
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/test/DependentComponent.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProductionComponent;
+
+import java.util.List;
+
+@ProductionComponent(
+    modules = DependentProducerModule.class,
+    dependencies = {DependedComponent.class, DependedProductionComponent.class})
+interface DependentComponent {
+  ListenableFuture<List<String>> greetings();
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/DependentProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/test/DependentProducerModule.java
new file mode 100644
index 000000000..234c088d3
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/test/DependentProducerModule.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import com.google.common.base.Ascii;
+import com.google.common.collect.ImmutableList;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+
+import java.util.List;
+
+@ProducerModule
+final class DependentProducerModule {
+  @Produces
+  ListenableFuture<List<String>> greetings(Integer numGreetings, String greeting) {
+    List<String> greetings = ImmutableList.of(
+        String.valueOf(numGreetings), greeting, Ascii.toUpperCase(greeting));
+    return Futures.immediateFuture(greetings);
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/Request.java b/compiler/src/it/producers-functional-tests/src/main/java/test/Request.java
new file mode 100644
index 000000000..039d0fe55
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/test/Request.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Inject;
+
+final class Request {
+  private final String name;
+
+  @Inject
+  Request() {
+    this.name = "Request";
+  }
+
+  String name() {
+    return this.name;
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/Response.java b/compiler/src/it/producers-functional-tests/src/main/java/test/Response.java
new file mode 100644
index 000000000..7a46e5b0e
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/test/Response.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+final class Response {
+  private final String data;
+
+  Response(String data) {
+    this.data = data;
+  }
+
+  String data() {
+    return this.data;
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/ResponseProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/test/ResponseProducerModule.java
new file mode 100644
index 000000000..bda53eb56
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/test/ResponseProducerModule.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+
+@ProducerModule
+final class ResponseProducerModule {
+  @Produces ListenableFuture<String> greeting() {
+    return Futures.immediateFuture("Hello");
+  }
+
+  @Produces Response response(String greeting, Request request) {
+    return new Response(greeting + ", " + request.name() + "!");
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/SimpleComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/test/SimpleComponent.java
new file mode 100644
index 000000000..583cd50f0
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/test/SimpleComponent.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProductionComponent;
+
+@ProductionComponent(modules = ResponseProducerModule.class)
+interface SimpleComponent {
+  ListenableFuture<Response> response();
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/SimpleProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/test/SimpleProducerModule.java
new file mode 100644
index 000000000..fa63d4822
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/test/SimpleProducerModule.java
@@ -0,0 +1,32 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+
+@ProducerModule
+final class SimpleProducerModule {
+  @Produces ListenableFuture<String> str() {
+    return Futures.immediateFuture("Hello, World!");
+  }
+
+  @Produces int len(String str) {
+    return str.length();
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/test/DependentTest.java b/compiler/src/it/producers-functional-tests/src/test/java/test/DependentTest.java
new file mode 100644
index 000000000..70413ae94
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/test/DependentTest.java
@@ -0,0 +1,40 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import com.google.common.util.concurrent.MoreExecutors;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public class DependentTest {
+  @Test public void testDependentComponent() throws Exception {
+    DependentComponent dependentComponent = Dagger_DependentComponent
+        .builder()
+        .dependedProductionComponent(Dagger_DependedProductionComponent.builder()
+            .executor(MoreExecutors.directExecutor())
+            .build())
+        .dependedComponent(Dagger_DependedComponent.create())
+        .executor(MoreExecutors.directExecutor())
+        .build();
+    assertThat(dependentComponent).isNotNull();
+    assertThat(dependentComponent.greetings().get()).containsExactly(
+        "2", "Hello world!", "HELLO WORLD!");
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/test/ProducerFactoryTest.java b/compiler/src/it/producers-functional-tests/src/test/java/test/ProducerFactoryTest.java
new file mode 100644
index 000000000..3342ec9f5
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/test/ProducerFactoryTest.java
@@ -0,0 +1,55 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.MoreExecutors;
+import com.google.common.util.concurrent.SettableFuture;
+import dagger.producers.Producer;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public class ProducerFactoryTest {
+  @Test public void noArgMethod() throws Exception {
+    SimpleProducerModule module = new SimpleProducerModule();
+    Producer<String> producer =
+        new SimpleProducerModule$$StrFactory(module, MoreExecutors.directExecutor());
+    assertThat(producer.get().get()).isEqualTo("Hello, World!");
+  }
+
+  @Test public void singleArgMethod() throws Exception {
+    SimpleProducerModule module = new SimpleProducerModule();
+    SettableFuture<String> strFuture = SettableFuture.create();
+    Producer<String> strProducer = producerOfFuture(strFuture);
+    Producer<Integer> producer =
+        new SimpleProducerModule$$LenFactory(module, MoreExecutors.directExecutor(), strProducer);
+    assertThat(producer.get().isDone()).isFalse();
+    strFuture.set("abcdef");
+    assertThat(producer.get().get()).isEqualTo(6);
+  }
+
+  private static <T> Producer<T> producerOfFuture(final ListenableFuture<T> future) {
+    return new Producer<T>() {
+      @Override public ListenableFuture<T> get() {
+        return future;
+      }
+    };
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/test/SimpleTest.java b/compiler/src/it/producers-functional-tests/src/test/java/test/SimpleTest.java
new file mode 100644
index 000000000..de0ea89bd
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/test/SimpleTest.java
@@ -0,0 +1,35 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import com.google.common.util.concurrent.MoreExecutors;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public class SimpleTest {
+  @Test public void testSimpleComponent() throws Exception {
+    SimpleComponent simpleComponent = Dagger_SimpleComponent
+        .builder()
+        .executor(MoreExecutors.directExecutor())
+        .build();
+    assertThat(simpleComponent).isNotNull();
+    assertThat(simpleComponent.response().get().data()).isEqualTo("Hello, Request!");
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Binding.java b/compiler/src/main/java/dagger/internal/codegen/Binding.java
index 22cae1c9f..4b05e88aa 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Binding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Binding.java
@@ -17,18 +17,23 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Lists;
+import java.util.List;
 import java.util.Set;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.Name;
 import javax.lang.model.element.PackageElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.TypeParameterElement;
 import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.type.WildcardType;
 import javax.lang.model.util.SimpleElementVisitor6;
 import javax.lang.model.util.SimpleTypeVisitor6;
+import javax.lang.model.util.Types;
 
 import static javax.lang.model.element.Modifier.PUBLIC;
 
@@ -149,4 +154,47 @@ public Void visitWildcard(WildcardType t, ImmutableSet.Builder<String> p) {
     return packages.build();
   }
 
+  /**
+   * Returns true if this is a binding for a key that has a different type parameter list than the
+   * element it's providing.
+   */
+  abstract boolean hasNonDefaultTypeParameters();
+
+  // TODO(sameb): Remove the TypeElement parameter and pull it from the TypeMirror.
+  static boolean hasNonDefaultTypeParameters(TypeElement element, TypeMirror type, Types types) {
+    // If the element has no type parameters, nothing can be wrong.
+    if (element.getTypeParameters().isEmpty()) {
+      return false;
+    }
+    
+    List<TypeMirror> defaultTypes = Lists.newArrayList();
+    for (TypeParameterElement parameter : element.getTypeParameters()) {
+      defaultTypes.add(parameter.asType());
+    }
+    
+    List<TypeMirror> actualTypes =
+        type.accept(new SimpleTypeVisitor6<List<TypeMirror>, Void>() {
+          @Override
+          protected List<TypeMirror> defaultAction(TypeMirror e, Void p) {
+            return ImmutableList.of();
+          }
+
+          @Override
+          public List<TypeMirror> visitDeclared(DeclaredType t, Void p) {
+            return ImmutableList.copyOf(t.getTypeArguments());
+          }
+        }, null);
+    
+    // The actual type parameter size can be different if the user is using a raw type.
+    if (defaultTypes.size() != actualTypes.size()) {
+      return true;
+    }
+
+    for (int i = 0; i < defaultTypes.size(); i++) {
+      if (!types.isSameType(defaultTypes.get(i), actualTypes.get(i))) {
+        return true;
+      }
+    }
+    return false;
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index d0c1888c0..362a21dfc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -17,33 +17,40 @@
 
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
+import com.google.common.base.Equivalence;
 import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Queues;
+import dagger.Component;
 import dagger.Provides;
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodType;
+import dagger.producers.Produces;
+import dagger.producers.ProductionComponent;
 import java.util.Deque;
 import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkState;
-import static dagger.internal.codegen.ComponentDescriptor.isComponentProvisionMethod;
+import static dagger.internal.codegen.ComponentDescriptor.Kind.PRODUCTION_COMPONENT;
+import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
+import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
 import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
-import static javax.lang.model.type.TypeKind.VOID;
 import static javax.lang.model.util.ElementFilter.methodsIn;
 
 /**
@@ -57,6 +64,7 @@
   abstract ImmutableSet<DependencyRequest> entryPoints();
   abstract ImmutableMap<TypeElement, ImmutableSet<TypeElement>> transitiveModules();
   abstract ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings();
+  abstract ImmutableMap<ExecutableElement, BindingGraph> subgraphs();
 
   @AutoValue
   abstract static class ResolvedBindings {
@@ -88,174 +96,293 @@ static ResolvedBindings create(
     private final Key.Factory keyFactory;
     private final DependencyRequest.Factory dependencyRequestFactory;
     private final ProvisionBinding.Factory provisionBindingFactory;
+    private final ProductionBinding.Factory productionBindingFactory;
 
     Factory(Elements elements,
         Types types,
         InjectBindingRegistry injectBindingRegistry,
         Key.Factory keyFactory,
         DependencyRequest.Factory dependencyRequestFactory,
-        ProvisionBinding.Factory provisionBindingFactory) {
+        ProvisionBinding.Factory provisionBindingFactory,
+        ProductionBinding.Factory productionBindingFactory) {
       this.elements = elements;
       this.types = types;
       this.injectBindingRegistry = injectBindingRegistry;
       this.keyFactory = keyFactory;
       this.dependencyRequestFactory = dependencyRequestFactory;
       this.provisionBindingFactory = provisionBindingFactory;
+      this.productionBindingFactory = productionBindingFactory;
     }
 
     BindingGraph create(ComponentDescriptor componentDescriptor) {
-      ImmutableSet.Builder<ProvisionBinding> explicitBindingsBuilder = ImmutableSet.builder();
+      return create(Optional.<RequestResolver>absent(), componentDescriptor);
+    }
+
+    private BindingGraph create(Optional<RequestResolver> parentResolver,
+        ComponentDescriptor componentDescriptor) {
+      ImmutableSet.Builder<ProvisionBinding> explicitProvisionBindingsBuilder =
+          ImmutableSet.builder();
+      ImmutableSet.Builder<ProductionBinding> explicitProductionBindingsBuilder =
+          ImmutableSet.builder();
       AnnotationMirror componentAnnotation = componentDescriptor.componentAnnotation();
 
       // binding for the component itself
+      TypeElement componentDefinitionType = componentDescriptor.componentDefinitionType();
       ProvisionBinding componentBinding =
-          provisionBindingFactory.forComponent(componentDescriptor.componentDefinitionType());
-      explicitBindingsBuilder.add(componentBinding);
+          provisionBindingFactory.forComponent(componentDefinitionType);
+      explicitProvisionBindingsBuilder.add(componentBinding);
 
       // Collect Component dependencies.
-      ImmutableSet<TypeElement> componentDependencyTypes =
-          MoreTypes.asTypeElements(types, getComponentDependencies(componentAnnotation));
+      Optional<AnnotationMirror> componentMirror =
+          getAnnotationMirror(componentDefinitionType, Component.class)
+              .or(getAnnotationMirror(componentDefinitionType, ProductionComponent.class));
+      ImmutableSet<TypeElement> componentDependencyTypes = componentMirror.isPresent()
+          ? MoreTypes.asTypeElements(getComponentDependencies(componentMirror.get()))
+          : ImmutableSet.<TypeElement>of();
       for (TypeElement componentDependency : componentDependencyTypes) {
-        explicitBindingsBuilder.add(provisionBindingFactory.forComponent(componentDependency));
+        explicitProvisionBindingsBuilder.add(
+            provisionBindingFactory.forComponent(componentDependency));
         List<ExecutableElement> dependencyMethods =
             ElementFilter.methodsIn(elements.getAllMembers(componentDependency));
         for (ExecutableElement method : dependencyMethods) {
-          if (isComponentProvisionMethod(elements, method)) {
-            // MembersInjection methods aren't "provided" explicitly, so ignore them.
-            explicitBindingsBuilder.add(provisionBindingFactory.forComponentMethod(method));
+          // MembersInjection methods aren't "provided" explicitly, so ignore them.
+          if (isComponentContributionMethod(elements, method)) {
+            if (componentDescriptor.kind().equals(PRODUCTION_COMPONENT)
+                && isComponentProductionMethod(elements, method)) {
+              explicitProductionBindingsBuilder.add(
+                  productionBindingFactory.forComponentMethod(method));
+            } else {
+              explicitProvisionBindingsBuilder.add(
+                  provisionBindingFactory.forComponentMethod(method));
+            }
           }
         }
       }
 
       // Collect transitive modules provisions.
       ImmutableSet<TypeElement> moduleTypes =
-          MoreTypes.asTypeElements(types, getComponentModules(componentAnnotation));
+          MoreTypes.asTypeElements(getComponentModules(componentAnnotation));
 
       ImmutableMap<TypeElement, ImmutableSet<TypeElement>> transitiveModules =
-          getTransitiveModules(types, moduleTypes);
+          getTransitiveModules(types, elements, moduleTypes);
       for (TypeElement module : transitiveModules.keySet()) {
         // traverse the modules, collect the bindings
         List<ExecutableElement> moduleMethods = methodsIn(elements.getAllMembers(module));
         for (ExecutableElement moduleMethod : moduleMethods) {
           if (isAnnotationPresent(moduleMethod, Provides.class)) {
-            try {
-              explicitBindingsBuilder.add(provisionBindingFactory.forProvidesMethod(moduleMethod));
-            } catch (IllegalArgumentException e) {
-              // just ignore it
-            }
+            explicitProvisionBindingsBuilder.add(
+                provisionBindingFactory.forProvidesMethod(moduleMethod, module.asType()));
           }
+          if (isAnnotationPresent(moduleMethod, Produces.class)) {
+            explicitProductionBindingsBuilder.add(
+                productionBindingFactory.forProducesMethod(moduleMethod, module.asType()));
+           }
         }
       }
 
-      RequestResolver requestResolver =
-          new RequestResolver(explicitBindingsByKey(explicitBindingsBuilder.build()));
+      RequestResolver requestResolver = new RequestResolver(
+          parentResolver,
+          componentDescriptor.wrappedScope(),
+          explicitBindingsByKey(explicitProvisionBindingsBuilder.build()),
+          explicitBindingsByKey(explicitProductionBindingsBuilder.build()));
+      ImmutableSetMultimap<ComponentMethodType, ExecutableElement> componentMethods =
+          componentDescriptor.componentMethods();
+
       ImmutableSet<DependencyRequest> componentMethodRequests =
-          componentMethodRequests(componentDescriptor.componentDefinitionType());
+          componentMethodRequests(componentMethods);
       for (DependencyRequest componentMethodRequest :
           componentMethodRequests) {
         requestResolver.resolve(componentMethodRequest);
       }
 
+      ImmutableMap.Builder<ExecutableElement, BindingGraph> subgraphsBuilder =
+          ImmutableMap.builder();
+      for (Entry<ExecutableElement, ComponentDescriptor> subcomponentEntry :
+          componentDescriptor.subcomponents().entrySet()) {
+        subgraphsBuilder.put(subcomponentEntry.getKey(),
+            create(Optional.of(requestResolver), subcomponentEntry.getValue()));
+      }
+
       return new AutoValue_BindingGraph(
           componentDescriptor,
           componentMethodRequests,
           transitiveModules,
-          ImmutableMap.copyOf(requestResolver.resolvedBindings));
+          ImmutableMap.copyOf(requestResolver.resolvedBindings),
+          subgraphsBuilder.build());
     }
 
-    private ImmutableSetMultimap<Key, ProvisionBinding> explicitBindingsByKey(
-        Iterable<ProvisionBinding> bindings) {
+    private <B extends ContributionBinding> ImmutableSetMultimap<Key, B> explicitBindingsByKey(
+        Iterable<? extends B> bindings) {
       // Multimaps.index() doesn't do ImmutableSetMultimaps.
-      ImmutableSetMultimap.Builder<Key, ProvisionBinding> builder = ImmutableSetMultimap.builder();
-      for (ProvisionBinding binding : bindings) {
+      ImmutableSetMultimap.Builder<Key, B> builder = ImmutableSetMultimap.builder();
+      for (B binding : bindings) {
         builder.put(binding.key(), binding);
       }
       return builder.build();
     }
 
-    private ImmutableSet<DependencyRequest> componentMethodRequests(TypeElement componentType) {
+    private ImmutableSet<DependencyRequest> componentMethodRequests(
+        ImmutableSetMultimap<ComponentMethodType, ExecutableElement> componentMethods) {
       ImmutableSet.Builder<DependencyRequest> interfaceRequestsBuilder = ImmutableSet.builder();
-      for (ExecutableElement componentMethod : methodsIn(elements.getAllMembers(componentType))) {
-        if (componentMethod.getModifiers().contains(Modifier.ABSTRACT)) { // Elide Object.*;
-          if (ComponentDescriptor.isComponentProvisionMethod(elements, componentMethod)) {
-            interfaceRequestsBuilder.add(
-                dependencyRequestFactory.forComponentProvisionMethod(componentMethod));
-          } else if (isComponentMembersInjectionMethod(componentMethod)) {
-            interfaceRequestsBuilder.add(
-                dependencyRequestFactory.forComponentMembersInjectionMethod(componentMethod));
-          }
-        }
+      for (ExecutableElement provisionMethod : componentMethods.get(ComponentMethodType.PROVISON)) {
+        interfaceRequestsBuilder.add(
+            dependencyRequestFactory.forComponentProvisionMethod(provisionMethod));
+      }
+      for (ExecutableElement productionMethod :
+          componentMethods.get(ComponentMethodType.PRODUCTION)) {
+        interfaceRequestsBuilder.add(
+            dependencyRequestFactory.forComponentProductionMethod(productionMethod));
+      }
+      for (ExecutableElement membersInjectionMethod :
+          componentMethods.get(ComponentMethodType.MEMBERS_INJECTION)) {
+        interfaceRequestsBuilder.add(
+            dependencyRequestFactory.forComponentMembersInjectionMethod(membersInjectionMethod));
       }
       return interfaceRequestsBuilder.build();
     }
 
-    private boolean isComponentMembersInjectionMethod(ExecutableElement method) {
-      List<? extends VariableElement> parameters = method.getParameters();
-      TypeMirror returnType = method.getReturnType();
-      return parameters.size() == 1
-          && (returnType.getKind().equals(VOID)
-              || MoreTypes.equivalence().equivalent(returnType, parameters.get(0).asType()))
-          && !elements.getTypeElement(Object.class.getCanonicalName())
-              .equals(method.getEnclosingElement());
-    }
-
     private final class RequestResolver {
-      final ImmutableSetMultimap<Key, ProvisionBinding> explicitBindings;
+      final Optional<RequestResolver> parentResolver;
+      final Optional<Equivalence.Wrapper<AnnotationMirror>> targetScope;
+      final ImmutableSetMultimap<Key, ProvisionBinding> explicitProvisionBindings;
+      final ImmutableSetMultimap<Key, ProductionBinding> explicitProductionBindings;
       final Map<BindingKey, ResolvedBindings> resolvedBindings;
       final Deque<BindingKey> cycleStack = Queues.newArrayDeque();
 
-      RequestResolver(ImmutableSetMultimap<Key, ProvisionBinding> explicitBindings) {
-        assert explicitBindings != null;
-        this.explicitBindings = explicitBindings;
+      RequestResolver(Optional<RequestResolver> parentResolver,
+          Optional<Equivalence.Wrapper<AnnotationMirror>> targetScope,
+          ImmutableSetMultimap<Key, ProvisionBinding> explicitProvisionBindings,
+          ImmutableSetMultimap<Key, ProductionBinding> explicitProductionBindings) {
+        assert parentResolver != null;
+        this.parentResolver = parentResolver;
+        assert targetScope != null;
+        this.targetScope = targetScope;
+        assert explicitProvisionBindings != null;
+        this.explicitProvisionBindings = explicitProvisionBindings;
+        assert explicitProductionBindings != null;
+        this.explicitProductionBindings = explicitProductionBindings;
         this.resolvedBindings = Maps.newLinkedHashMap();
       }
 
-      ImmutableSet<? extends Binding> lookUpBindings(DependencyRequest request) {
+      /**
+       *  Looks up the bindings associated with a given dependency request and returns them.  In the
+       *  event that the binding is owned by a parent component it will trigger resolution in that
+       *  component's resolver but will return an {@link Optional#absent} value.
+       */
+      Optional<? extends ImmutableSet<? extends Binding>> lookUpBindings(
+          DependencyRequest request) {
         BindingKey bindingKey = BindingKey.forDependencyRequest(request);
         switch (bindingKey.kind()) {
           case CONTRIBUTION:
             // First, check for explicit keys (those from modules and components)
-            ImmutableSet<ProvisionBinding> explicitBindingsForKey =
-                explicitBindings.get(bindingKey.key());
-            if (explicitBindingsForKey.isEmpty()) {
-              // If the key is Map<K, V>, get its implicit binding key which is
-              // Map<K, Provider<V>>
-              Optional<Key> mapProviderKey =
-                  keyFactory.implicitMapProviderKeyFrom(bindingKey.key());
-              if (mapProviderKey.isPresent()) {
+            ImmutableSet<ProvisionBinding> explicitProvisionBindingsForKey =
+                getExplicitProvisionBindings(bindingKey.key());
+            ImmutableSet<ProductionBinding> explicitProductionBindingsForKey =
+                getExplicitProductionBindings(bindingKey.key());
+
+            // If the key is Map<K, V>, get its implicit binding keys, which are either
+            // Map<K, Provider<V>> or Map<K, Producer<V>>, and grab their explicit bindings.
+            Optional<Key> mapProviderKey = keyFactory.implicitMapProviderKeyFrom(bindingKey.key());
+            ImmutableSet<ProvisionBinding> explicitMapProvisionBindings = ImmutableSet.of();
+            if (mapProviderKey.isPresent()) {
+              explicitMapProvisionBindings = getExplicitProvisionBindings(mapProviderKey.get());
+            }
+
+            Optional<Key> mapProducerKey = keyFactory.implicitMapProducerKeyFrom(bindingKey.key());
+            ImmutableSet<ProductionBinding> explicitMapProductionBindings = ImmutableSet.of();
+            if (mapProducerKey.isPresent()) {
+              explicitMapProductionBindings = getExplicitProductionBindings(mapProducerKey.get());
+            }
+
+            if (!explicitProvisionBindingsForKey.isEmpty()
+                || !explicitProductionBindingsForKey.isEmpty()) {
+              // we have some explicit binding for this key, so we collect all explicit implicit map
+              // bindings that might conflict with this and let the validator sort it out
+              return Optional.of(ImmutableSet.<ContributionBinding>builder()
+                  .addAll(explicitProvisionBindingsForKey)
+                  .addAll(explicitMapProvisionBindings)
+                  .addAll(explicitProductionBindingsForKey)
+                  .addAll(explicitMapProductionBindings)
+                  .build());
+            } else {
+              if (!explicitMapProductionBindings.isEmpty()) {
+                // if we have any explicit Map<K, Producer<V>> bindings, then this Map<K, V> binding
+                // must be considered an implicit ProductionBinding
+                DependencyRequest implicitRequest =
+                    dependencyRequestFactory.forImplicitMapBinding(request, mapProducerKey.get());
+                return Optional.of(ImmutableSet.of(productionBindingFactory.forImplicitMapBinding(
+                    request, implicitRequest)));
+              } else if (!explicitMapProvisionBindings.isEmpty()) {
+                // if there are Map<K, Provider<V>> bindings, then it'll be an implicit
+                // ProvisionBinding
                 DependencyRequest implicitRequest =
                     dependencyRequestFactory.forImplicitMapBinding(request, mapProviderKey.get());
-                return ImmutableSet.of(provisionBindingFactory.forImplicitMapBinding(
-                    request, implicitRequest));
+                return Optional.of(ImmutableSet.of(provisionBindingFactory.forImplicitMapBinding(
+                    request, implicitRequest)));
               } else {
                 // no explicit binding, look it up.
                 Optional<ProvisionBinding> provisionBinding =
                     injectBindingRegistry.getOrFindProvisionBinding(bindingKey.key());
-                return ImmutableSet.copyOf(provisionBinding.asSet());
+                if (provisionBinding.isPresent()) {
+                  Optional<RequestResolver> owningResolver =
+                      getOwningResolver(provisionBinding.get());
+                  if (owningResolver.isPresent() && !owningResolver.get().equals(this)) {
+                    owningResolver.get().resolve(request);
+                    return Optional.absent();
+                  }
+                }
+                return Optional.of(ImmutableSet.copyOf(provisionBinding.asSet()));
               }
-            } else {
-              // If this is an explicit Map<K, V> request then add in any map binding provision
-              // methods which are implied by and must collide with explicit Map<K, V> bindings.
-              Optional<Key> underlyingMapKey =
-                  keyFactory.implicitMapProviderKeyFrom(bindingKey.key());
-              if (underlyingMapKey.isPresent()) {
-                explicitBindingsForKey = ImmutableSet.<ProvisionBinding>builder()
-                    .addAll(explicitBindingsForKey)
-                    .addAll(explicitBindings.get(underlyingMapKey.get()))
-                    .build();
-              }
-              return explicitBindingsForKey;
             }
           case MEMBERS_INJECTION:
             // no explicit deps for members injection, so just look it up
             MembersInjectionBinding membersInjectionBinding =
                 injectBindingRegistry.getOrFindMembersInjectionBinding(bindingKey.key());
-            return ImmutableSet.of(membersInjectionBinding);
+            return Optional.of(ImmutableSet.of(membersInjectionBinding));
           default:
             throw new AssertionError();
         }
       }
 
+      private Optional<RequestResolver> getOwningResolver(ProvisionBinding provisionBinding) {
+        Optional<Equivalence.Wrapper<AnnotationMirror>> bindingScope =
+            provisionBinding.wrappedScope();
+        for (RequestResolver requestResolver : getResolverLineage()) {
+          if (bindingScope.equals(requestResolver.targetScope)) {
+            return Optional.of(requestResolver);
+          }
+        }
+        return Optional.absent();
+      }
+
+      private ImmutableList<RequestResolver> getResolverLineage() {
+        List<RequestResolver> resolverList = Lists.newArrayList();
+        for (Optional<RequestResolver> currentResolver = Optional.of(this);
+            currentResolver.isPresent();
+            currentResolver = currentResolver.get().parentResolver) {
+          resolverList.add(currentResolver.get());
+        }
+        return ImmutableList.copyOf(Lists.reverse(resolverList));
+      }
+
+      private ImmutableSet<ProvisionBinding> getExplicitProvisionBindings(Key requestKey) {
+        ImmutableSet.Builder<ProvisionBinding> explicitBindingsForKey = ImmutableSet.builder();
+        for (RequestResolver resolver : getResolverLineage()) {
+          explicitBindingsForKey.addAll(
+              resolver.explicitProvisionBindings.get(requestKey));
+        }
+        return explicitBindingsForKey.build();
+      }
+
+      private ImmutableSet<ProductionBinding> getExplicitProductionBindings(Key requestKey) {
+        ImmutableSet.Builder<ProductionBinding> explicitBindingsForKey = ImmutableSet.builder();
+        for (RequestResolver resolver : getResolverLineage()) {
+          explicitBindingsForKey.addAll(
+              resolver.explicitProductionBindings.get(requestKey));
+        }
+        return explicitBindingsForKey.build();
+      }
+
       void resolve(DependencyRequest request) {
         BindingKey bindingKey = BindingKey.forDependencyRequest(request);
 
@@ -272,11 +399,13 @@ void resolve(DependencyRequest request) {
 
         cycleStack.push(bindingKey);
         try {
-          ImmutableSet<? extends Binding> bindings = lookUpBindings(request);
-          for (Binding binding : bindings) {
-            resolveDependencies(binding.implicitDependencies());
+          Optional<? extends ImmutableSet<? extends Binding>> bindings = lookUpBindings(request);
+          if (bindings.isPresent()) {
+            for (Binding binding : bindings.get()) {
+              resolveDependencies(binding.implicitDependencies());
+            }
+            resolvedBindings.put(bindingKey, ResolvedBindings.create(bindingKey, bindings.get()));
           }
-          resolvedBindings.put(bindingKey, ResolvedBindings.create(bindingKey, bindings));
         } finally {
           cycleStack.pop();
         }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 947a753a7..213811749 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -15,22 +15,26 @@
  */
 package dagger.internal.codegen;
 
+import javax.tools.Diagnostic;
+
 import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
 import com.google.common.base.Predicate;
+import com.google.common.base.Predicates;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
-import com.google.common.collect.Lists;
 import com.google.common.collect.Ordering;
+import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.internal.codegen.BindingGraph.ResolvedBindings;
 import dagger.internal.codegen.ContributionBinding.BindingType;
@@ -40,23 +44,28 @@
 import java.util.Deque;
 import java.util.Formatter;
 import java.util.HashSet;
-import java.util.LinkedList;
+import java.util.Iterator;
 import java.util.Set;
 import javax.inject.Singleton;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
-import javax.tools.Diagnostic;
-
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreTypes.isTypeOf;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ErrorMessages.INDENT;
+import static dagger.internal.codegen.ErrorMessages.MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE;
+import static dagger.internal.codegen.ErrorMessages.NULLABLE_TO_NON_NULLABLE;
 import static dagger.internal.codegen.ErrorMessages.REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT;
+import static dagger.internal.codegen.ErrorMessages.REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_OR_PRODUCER_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.REQUIRES_PROVIDER_FORMAT;
+import static dagger.internal.codegen.ErrorMessages.REQUIRES_PROVIDER_OR_PRODUCER_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
 import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
 
@@ -64,15 +73,33 @@
 
   private final Types types;
   private final InjectBindingRegistry injectBindingRegistry;
-  private final ScopeCycleValidation disableInterComponentScopeCycles;
+  private final ValidationType scopeCycleValidationType;
+  private final Diagnostic.Kind nullableValidationType;
+  private final ProvisionBindingFormatter provisionBindingFormatter;
+  private final ProductionBindingFormatter productionBindingFormatter;
+  private final MethodSignatureFormatter methodSignatureFormatter;
+  private final DependencyRequestFormatter dependencyRequestFormatter;
+  private final KeyFormatter keyFormatter;
 
   BindingGraphValidator(
       Types types,
       InjectBindingRegistry injectBindingRegistry,
-      ScopeCycleValidation disableInterComponentScopeCycles) {
+      ValidationType scopeCycleValidationType,
+      Diagnostic.Kind nullableValidationType,
+      ProvisionBindingFormatter provisionBindingFormatter,
+      ProductionBindingFormatter productionBindingFormatter,
+      MethodSignatureFormatter methodSignatureFormatter,
+      DependencyRequestFormatter dependencyRequestFormatter,
+      KeyFormatter keyFormatter) {
     this.types = types;
     this.injectBindingRegistry = injectBindingRegistry;
-    this.disableInterComponentScopeCycles = disableInterComponentScopeCycles;
+    this.scopeCycleValidationType = scopeCycleValidationType;
+    this.nullableValidationType = nullableValidationType;
+    this.provisionBindingFormatter = provisionBindingFormatter;
+    this.productionBindingFormatter = productionBindingFormatter;
+    this.methodSignatureFormatter = methodSignatureFormatter;
+    this.dependencyRequestFormatter = dependencyRequestFormatter;
+    this.keyFormatter = keyFormatter;
   }
 
   @Override
@@ -85,17 +112,18 @@
     validateDependencyScopes(subject, reportBuilder);
 
     for (DependencyRequest entryPoint : subject.entryPoints()) {
-      LinkedList<DependencyRequest> requestPath = Lists.newLinkedList();
-      requestPath.push(entryPoint);
-      traversalHelper(subject, requestPath, new Traverser() {
+      Deque<ResolvedRequest> path = new ArrayDeque<>();
+      path.push(ResolvedRequest.create(entryPoint, subject));
+      traversalHelper(subject, path, new Traverser() {
         final Set<BindingKey> visitedBindings = new HashSet<>();
 
         @Override
-        boolean visitResolvedBinding(
-            Deque<DependencyRequest> requestPath, ResolvedBindings binding) {
-          for (DependencyRequest request : Iterables.skip(requestPath, 1)) {
-            if (BindingKey.forDependencyRequest(request).equals(binding.bindingKey())) {
-              reportCycle(requestPath, subject, reportBuilder);
+        boolean visitResolvedRequest(Deque<ResolvedRequest> path) {
+          ResolvedBindings binding = path.peek().binding();
+          for (ResolvedRequest resolvedRequest : Iterables.skip(path, 1)) {
+            if (BindingKey.forDependencyRequest(resolvedRequest.request())
+                .equals(binding.bindingKey())) {
+              reportCycle(path, reportBuilder);
               return false;
             }
           }
@@ -104,7 +132,7 @@ boolean visitResolvedBinding(
             return false;
           }
 
-          return validateResolvedBinding(requestPath, binding, reportBuilder);
+          return validateResolvedBinding(path, binding, reportBuilder);
         }
       });
     }
@@ -117,28 +145,33 @@ boolean visitResolvedBinding(
    * returns true if the bindings are valid.
    */
   private boolean validateResolvedBinding(
-      Deque<DependencyRequest> requestPath,
+      Deque<ResolvedRequest> path,
       ResolvedBindings resolvedBinding,
       Builder<BindingGraph> reportBuilder) {
     if (resolvedBinding.bindings().isEmpty()) {
-      reportMissingBinding(requestPath, reportBuilder);
+      reportMissingBinding(path, reportBuilder);
       return false;
     }
 
-    ImmutableSet.Builder<ContributionBinding> contributionBindingsBuilder =
+    ImmutableSet.Builder<ProvisionBinding> provisionBindingsBuilder =
+        ImmutableSet.builder();
+    ImmutableSet.Builder<ProductionBinding> productionBindingsBuilder =
         ImmutableSet.builder();
     ImmutableSet.Builder<MembersInjectionBinding> membersInjectionBindingsBuilder =
         ImmutableSet.builder();
     for (Binding binding : resolvedBinding.bindings()) {
-      if (binding instanceof ContributionBinding) {
-        contributionBindingsBuilder.add((ContributionBinding) binding);
+      if (binding instanceof ProvisionBinding) {
+        provisionBindingsBuilder.add((ProvisionBinding) binding);
+      }
+      if (binding instanceof ProductionBinding) {
+        productionBindingsBuilder.add((ProductionBinding) binding);
       }
       if (binding instanceof MembersInjectionBinding) {
         membersInjectionBindingsBuilder.add((MembersInjectionBinding) binding);
       }
     }
-    ImmutableSet<ContributionBinding> contributionBindings =
-        contributionBindingsBuilder.build();
+    ImmutableSet<ProvisionBinding> provisionBindings = provisionBindingsBuilder.build();
+    ImmutableSet<ProductionBinding> productionBindings = productionBindingsBuilder.build();
     ImmutableSet<MembersInjectionBinding> membersInjectionBindings =
         membersInjectionBindingsBuilder.build();
 
@@ -148,28 +181,43 @@ private boolean validateResolvedBinding(
           throw new IllegalArgumentException(
               "contribution binding keys should never have members injection bindings");
         }
-        if (contributionBindings.size() <= 1) {
+        Set<ContributionBinding> combined = Sets.union(provisionBindings, productionBindings);
+        if (!validateNullability(path, combined, reportBuilder)) {
+          return false;
+        }
+        if (!productionBindings.isEmpty() && doesPathRequireProvisionOnly(path)) {
+          reportProviderMayNotDependOnProducer(path, reportBuilder);
+          return false;
+        }
+        if ((provisionBindings.size() + productionBindings.size()) <= 1) {
           return true;
         }
         ImmutableListMultimap<BindingType, ContributionBinding> bindingsByType =
-            ContributionBinding.bindingTypesFor(contributionBindings);
+            ContributionBinding.bindingTypesFor(
+                Iterables.<ContributionBinding>concat(provisionBindings, productionBindings));
         if (bindingsByType.keySet().size() > 1) {
-          reportMultipleBindingTypes(requestPath, resolvedBinding, reportBuilder);
+          reportMultipleBindingTypes(path, reportBuilder);
           return false;
         } else if (getOnlyElement(bindingsByType.keySet()).equals(BindingType.UNIQUE)) {
-          reportDuplicateBindings(requestPath, resolvedBinding, reportBuilder);
+          reportDuplicateBindings(path, reportBuilder);
           return false;
         }
         break;
       case MEMBERS_INJECTION:
-        if (!contributionBindings.isEmpty()) {
+        if (!provisionBindings.isEmpty() || !productionBindings.isEmpty()) {
           throw new IllegalArgumentException(
               "members injection binding keys should never have contribution bindings");
         }
         if (membersInjectionBindings.size() > 1) {
-          reportDuplicateBindings(requestPath, resolvedBinding, reportBuilder);
+          reportDuplicateBindings(path, reportBuilder);
           return false;
         }
+        if (membersInjectionBindings.size() == 1) {
+          MembersInjectionBinding binding = getOnlyElement(membersInjectionBindings);
+          if (!validateMembersInjectionBinding(binding, path, reportBuilder)) {
+            return false;
+          }
+        }
         break;
       default:
         throw new AssertionError();
@@ -177,6 +225,83 @@ private boolean validateResolvedBinding(
     return true;
   }
 
+  /** Ensures that if the request isn't nullable, then each contribution is also not nullable. */
+  private boolean validateNullability(Deque<ResolvedRequest> requestPath,
+      Set<ContributionBinding> bindings, Builder<BindingGraph> reportBuilder) {
+    boolean valid = true;
+    DependencyRequest request = requestPath.peek().request();
+    String typeName = TypeNames.forTypeMirror(request.key().type()).toString();
+    if (!request.isNullable()) {
+      for (ContributionBinding binding : bindings) {
+        if (binding.nullableType().isPresent()) {
+          String methodSignature;
+          if (binding instanceof ProvisionBinding) {
+            ProvisionBinding provisionBinding = (ProvisionBinding) binding;
+            methodSignature = provisionBindingFormatter.format(provisionBinding);
+          } else {
+            ProductionBinding productionBinding = (ProductionBinding) binding;
+            methodSignature = productionBindingFormatter.format(productionBinding);
+          }
+          // Note: the method signature will include the @Nullable in it!
+          // TODO(sameb): Sometimes javac doesn't include the Element in its output.
+          // (Maybe this happens if the code was already compiled before this point?)
+          // ... we manually print ouf the request in that case, otherwise the error
+          // message is kind of useless.
+          reportBuilder.addItem(
+              String.format(NULLABLE_TO_NON_NULLABLE, typeName, methodSignature)
+              + "\n at: " + dependencyRequestFormatter.format(request),
+              nullableValidationType,
+              request.requestElement());
+          valid = false;
+        }
+      }
+    }
+    return valid;
+  }
+
+  /**
+   * Validates a members injection binding, returning false (and reporting the error) if it wasn't
+   * valid.
+   */
+  private boolean validateMembersInjectionBinding(MembersInjectionBinding binding,
+      final Deque<ResolvedRequest> path, final Builder<BindingGraph> reportBuilder) {
+    return binding.key().type().accept(new SimpleTypeVisitor6<Boolean, Void>() {
+      @Override protected Boolean defaultAction(TypeMirror e, Void p) {
+        reportBuilder.addItem("Invalid members injection request.",
+            path.peek().request().requestElement());
+        return false;
+      }
+
+      @Override public Boolean visitDeclared(DeclaredType type, Void ignored) {
+        // If the key has type arguments, validate that each type argument is declared.
+        // Otherwise the type argument may be a wildcard (or other type), and we can't
+        // resolve that to actual types.
+        for (TypeMirror arg : type.getTypeArguments()) {
+          if (arg.getKind() != TypeKind.DECLARED) {
+            reportBuilder.addItem(MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE,
+                path.peek().request().requestElement());
+            return false;
+          }
+        }
+
+        TypeElement element = MoreElements.asType(type.asElement());
+        // Also validate that the key is not the erasure of a generic type.
+        // If it is, that means the user referred to Foo<T> as just 'Foo',
+        // which we don't allow.  (This is a judgement call -- we *could*
+        // allow it and instantiate the type bounds... but we don't.)
+        if (!MoreTypes.asDeclared(element.asType()).getTypeArguments().isEmpty()
+            && types.isSameType(types.erasure(element.asType()), type)) {
+          reportBuilder.addItem(
+              String.format(ErrorMessages.MEMBERS_INJECTION_WITH_RAW_TYPE, type.toString()),
+              path.peek().request().requestElement());
+          return false;
+        }
+
+        return true; // valid
+      }
+    }, null);
+  }
+
   /**
    * Validates that among the dependencies are at most one scoped dependency,
    * that there are no cycles within the scoping chain, and that singleton
@@ -189,7 +314,7 @@ private void validateDependencyScopes(BindingGraph subject,
     ImmutableSet<TypeElement> scopedDependencies = scopedTypesIn(descriptor.dependencies());
     if (scope.isPresent()) {
       // Dagger 1.x scope compatibility requires this be suppress-able.
-      if (disableInterComponentScopeCycles.diagnosticKind().isPresent()
+      if (scopeCycleValidationType.diagnosticKind().isPresent()
           && isTypeOf(Singleton.class, scope.get().getAnnotationType())) {
         // Singleton is a special-case representing the longest lifetime, and therefore
         // @Singleton components may not depend on scoped components
@@ -198,7 +323,7 @@ private void validateDependencyScopes(BindingGraph subject,
               "This @Singleton component cannot depend on scoped components:\n");
           appendIndentedComponentsList(message, scopedDependencies);
           reportBuilder.addItem(message.toString(),
-              disableInterComponentScopeCycles.diagnosticKind().get(),
+              scopeCycleValidationType.diagnosticKind().get(),
               descriptor.componentDefinitionType(),
               descriptor.componentAnnotation());
         }
@@ -214,7 +339,7 @@ private void validateDependencyScopes(BindingGraph subject,
             descriptor.componentAnnotation());
       } else {
         // Dagger 1.x scope compatibility requires this be suppress-able.
-        if (!disableInterComponentScopeCycles.equals(ScopeCycleValidation.NONE)) {
+        if (!scopeCycleValidationType.equals(ValidationType.NONE)) {
           validateScopeHierarchy(descriptor.componentDefinitionType(),
               descriptor.componentDefinitionType(),
               reportBuilder,
@@ -287,9 +412,9 @@ private void validateScopeHierarchy(TypeElement rootComponent,
         message.append(rootComponent.getQualifiedName());
         message.append(" depends on scoped components in a non-hierarchical scope ordering:\n");
         appendIndentedComponentsList(message, scopedDependencyStack);
-        if (disableInterComponentScopeCycles.diagnosticKind().isPresent()) {
+        if (scopeCycleValidationType.diagnosticKind().isPresent()) {
           reportBuilder.addItem(message.toString(),
-              disableInterComponentScopeCycles.diagnosticKind().get(),
+              scopeCycleValidationType.diagnosticKind().get(),
               rootComponent, getAnnotationMirror(rootComponent, Component.class).get());
         }
         scopedDependencyStack.pop();
@@ -298,7 +423,7 @@ private void validateScopeHierarchy(TypeElement rootComponent,
             getAnnotationMirror(componentType, Component.class);
         if (componentAnnotation.isPresent()) {
           ImmutableSet<TypeElement> scopedDependencies = scopedTypesIn(
-              MoreTypes.asTypeElements(types, getComponentDependencies(componentAnnotation.get())));
+              MoreTypes.asTypeElements(getComponentDependencies(componentAnnotation.get())));
           if (scopedDependencies.size() == 1) {
             // empty can be ignored (base-case), and > 1 is a different error reported separately.
             scopeStack.push(wrappedScope);
@@ -339,7 +464,7 @@ void validateComponentScope(final BindingGraph subject,
                   ExecutableElement provisionMethod =
                       MoreElements.asExecutable(provisionBinding.bindingElement());
                   incompatiblyScopedMethodsBuilder.add(
-                      MethodSignatureFormatter.instance().format(provisionMethod));
+                      methodSignatureFormatter.format(provisionMethod));
                   break;
                 case INJECTION:
                   incompatiblyScopedMethodsBuilder.add(stripCommonTypePrefixes(
@@ -373,47 +498,127 @@ void validateComponentScope(final BindingGraph subject,
     }
   }
 
+  @SuppressWarnings("resource") // Appendable is a StringBuilder.
+  private void reportProviderMayNotDependOnProducer(
+      Deque<ResolvedRequest> path, ValidationReport.Builder<BindingGraph> reportBuilder) {
+    StringBuilder errorMessage = new StringBuilder();
+    if (path.size() == 1) {
+      new Formatter(errorMessage).format(
+          ErrorMessages.PROVIDER_ENTRY_POINT_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
+          keyFormatter.format(path.peek().request().key()));
+    } else {
+      ImmutableSet<ProvisionBinding> dependentProvisions = provisionsDependingOnLatestRequest(path);
+      // TODO(user): Consider displaying all dependent provisions in the error message. If we do
+      // that, should we display all productions that depend on them also?
+      new Formatter(errorMessage).format(ErrorMessages.PROVIDER_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
+          keyFormatter.format(dependentProvisions.iterator().next().key()));
+    }
+    reportBuilder.addItem(errorMessage.toString(), path.getLast().request().requestElement());
+  }
+
   private void reportMissingBinding(
-      Deque<DependencyRequest> requestPath, ValidationReport.Builder<BindingGraph> reportBuilder) {
-    Key key = requestPath.peek().key();
+      Deque<ResolvedRequest> path, ValidationReport.Builder<BindingGraph> reportBuilder) {
+    Key key = path.peek().request().key();
     TypeMirror type = key.type();
     String typeName = TypeNames.forTypeMirror(type).toString();
-    boolean requiresProvidesMethod = !key.isValidImplicitProvisionKey(types);
+    boolean requiresContributionMethod = !key.isValidImplicitProvisionKey(types);
+    boolean requiresProvision = doesPathRequireProvisionOnly(path);
     StringBuilder errorMessage = new StringBuilder();
-    if (requiresProvidesMethod) {
-      errorMessage.append(String.format(REQUIRES_PROVIDER_FORMAT, typeName));
+    final String requiresErrorMessageFormat;
+    if (requiresContributionMethod) {
+      requiresErrorMessageFormat = requiresProvision
+          ? REQUIRES_PROVIDER_FORMAT
+          : REQUIRES_PROVIDER_OR_PRODUCER_FORMAT;
     } else {
-      errorMessage.append(
-          String.format(REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT, typeName));
+      requiresErrorMessageFormat = requiresProvision
+          ? REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT
+          : REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_OR_PRODUCER_FORMAT;
     }
+    errorMessage.append(String.format(requiresErrorMessageFormat, typeName));
     if (key.isValidMembersInjectionKey()
         && !injectBindingRegistry.getOrFindMembersInjectionBinding(key).injectionSites()
             .isEmpty()) {
       errorMessage.append(" ").append(ErrorMessages.MEMBERS_INJECTION_DOES_NOT_IMPLY_PROVISION);
     }
     ImmutableList<String> printableDependencyPath =
-        FluentIterable.from(requestPath)
-            .transform(DependencyRequestFormatter.instance())
+        FluentIterable.from(path)
+            .transform(REQUEST_FROM_RESOLVED_REQUEST)
+            .transform(dependencyRequestFormatter)
+            .filter(Predicates.not(Predicates.equalTo("")))
             .toList()
             .reverse();
     for (String dependency :
         printableDependencyPath.subList(1, printableDependencyPath.size())) {
       errorMessage.append("\n").append(dependency);
     }
-    reportBuilder.addItem(errorMessage.toString(), requestPath.getLast().requestElement());
+    reportBuilder.addItem(errorMessage.toString(), path.getLast().request().requestElement());
+  }
+
+  /**
+   * Returns whether the given dependency path would require the most recent request to be resolved
+   * by only provision bindings.
+   */
+  private boolean doesPathRequireProvisionOnly(Deque<ResolvedRequest> path) {
+    if (path.size() == 1) {
+      // if this is an entry-point, then we check the request
+      switch (path.peek().request().kind()) {
+        case INSTANCE:
+        case PROVIDER:
+        case LAZY:
+        case MEMBERS_INJECTOR:
+          return true;
+        case PRODUCER:
+        case PRODUCED:
+        case FUTURE:
+          return false;
+        default:
+          throw new AssertionError();
+      }
+    }
+    // otherwise, the second-most-recent bindings determine whether the most recent one must be a
+    // provision
+    ImmutableSet<ProvisionBinding> dependentProvisions = provisionsDependingOnLatestRequest(path);
+    return !dependentProvisions.isEmpty();
+  }
+
+  /**
+   * Returns any provision bindings resolved for the second-most-recent request in the given path;
+   * that is, returns those provision bindings that depend on the latest request in the path.
+   */
+  private ImmutableSet<ProvisionBinding> provisionsDependingOnLatestRequest(
+      Deque<ResolvedRequest> path) {
+    Iterator<ResolvedRequest> iterator = path.iterator();
+    final DependencyRequest request = iterator.next().request();
+    ResolvedRequest previousResolvedRequest = iterator.next();
+    @SuppressWarnings("unchecked")  // validated by instanceof below
+    ImmutableSet<ProvisionBinding> bindings = (ImmutableSet<ProvisionBinding>) FluentIterable
+        .from(previousResolvedRequest.binding().bindings())
+        .filter(new Predicate<Binding>() {
+            @Override public boolean apply(Binding binding) {
+              return binding instanceof ProvisionBinding
+                  && binding.implicitDependencies().contains(request);
+            }
+        }).toSet();
+    return bindings;
   }
 
   private static final int DUPLICATE_SIZE_LIMIT = 10;
 
   @SuppressWarnings("resource") // Appendable is a StringBuilder.
-  private void reportDuplicateBindings(Deque<DependencyRequest> requestPath,
-      ResolvedBindings resolvedBinding, ValidationReport.Builder<BindingGraph> reportBuilder) {
+  private void reportDuplicateBindings(
+      Deque<ResolvedRequest> path, ValidationReport.Builder<BindingGraph> reportBuilder) {
+    ResolvedBindings resolvedBinding = path.peek().binding();
     StringBuilder builder = new StringBuilder();
     new Formatter(builder).format(ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT,
-        KeyFormatter.instance().format(requestPath.peek().key()));
+        keyFormatter.format(path.peek().request().key()));
     for (Binding binding : Iterables.limit(resolvedBinding.bindings(), DUPLICATE_SIZE_LIMIT)) {
       builder.append('\n').append(INDENT);
-      builder.append(ProvisionBindingFormatter.instance().format((ProvisionBinding) binding));
+      // TODO(user): Refactor the formatters so we don't need these instanceof checks.
+      if (binding instanceof ProvisionBinding) {
+        builder.append(provisionBindingFormatter.format((ProvisionBinding) binding));
+      } else if (binding instanceof ProductionBinding) {
+        builder.append(productionBindingFormatter.format((ProductionBinding) binding));
+      }
     }
     int numberOfOtherBindings = resolvedBinding.bindings().size() - DUPLICATE_SIZE_LIMIT;
     if (numberOfOtherBindings > 0) {
@@ -423,30 +628,34 @@ private void reportDuplicateBindings(Deque<DependencyRequest> requestPath,
     if (numberOfOtherBindings > 1) {
       builder.append('s');
     }
-    reportBuilder.addItem(builder.toString(), requestPath.getLast().requestElement());
+    reportBuilder.addItem(builder.toString(), path.getLast().request().requestElement());
   }
 
   @SuppressWarnings("resource") // Appendable is a StringBuilder.
-  private void reportMultipleBindingTypes(Deque<DependencyRequest> requestPath,
-      ResolvedBindings resolvedBinding, ValidationReport.Builder<BindingGraph> reportBuilder) {
+  private void reportMultipleBindingTypes(
+      Deque<ResolvedRequest> path, ValidationReport.Builder<BindingGraph> reportBuilder) {
+    ResolvedBindings resolvedBinding = path.peek().binding();
     StringBuilder builder = new StringBuilder();
     new Formatter(builder).format(ErrorMessages.MULTIPLE_BINDING_TYPES_FOR_KEY_FORMAT,
-        KeyFormatter.instance().format(requestPath.peek().key()));
-    @SuppressWarnings("unchecked")
-    ImmutableListMultimap<BindingType, ProvisionBinding> bindingsByType =
-        ProvisionBinding.bindingTypesFor((Iterable<ProvisionBinding>) resolvedBinding.bindings());
+        keyFormatter.format(path.peek().request().key()));
+    ImmutableListMultimap<BindingType, ContributionBinding> bindingsByType =
+        ContributionBinding.bindingTypesFor(resolvedBinding.contributionBindings());
     for (BindingType type :
         Ordering.natural().immutableSortedCopy(bindingsByType.keySet())) {
       builder.append(INDENT);
       builder.append(formatBindingType(type));
       builder.append(" bindings:\n");
-      for (ProvisionBinding binding : bindingsByType.get(type)) {
+      for (ContributionBinding binding : bindingsByType.get(type)) {
         builder.append(INDENT).append(INDENT);
-        builder.append(ProvisionBindingFormatter.instance().format(binding));
+        if (binding instanceof ProvisionBinding) {
+          builder.append(provisionBindingFormatter.format((ProvisionBinding) binding));
+        } else if (binding instanceof ProductionBinding) {
+          builder.append(productionBindingFormatter.format((ProductionBinding) binding));
+        }
         builder.append('\n');
       }
     }
-    reportBuilder.addItem(builder.toString(), requestPath.getLast().requestElement());
+    reportBuilder.addItem(builder.toString(), path.getLast().request().requestElement());
   }
 
   private String formatBindingType(BindingType type) {
@@ -462,11 +671,15 @@ private String formatBindingType(BindingType type) {
     }
   }
 
-  private void reportCycle(Deque<DependencyRequest> requestPath,
-      BindingGraph graph, final ValidationReport.Builder<BindingGraph> reportBuilder) {
-    ImmutableList<String> printableDependencyPath = FluentIterable.from(requestPath)
-        .transform(DependencyRequestFormatter.instance()).toList().reverse();
-    DependencyRequest rootRequest = requestPath.getLast();
+  private void reportCycle(Deque<ResolvedRequest> path,
+      final ValidationReport.Builder<BindingGraph> reportBuilder) {
+    ImmutableList<String> printableDependencyPath = FluentIterable.from(path)
+        .transform(REQUEST_FROM_RESOLVED_REQUEST)
+        .transform(dependencyRequestFormatter)
+        .filter(Predicates.not(Predicates.equalTo("")))
+        .toList()
+        .reverse();
+    DependencyRequest rootRequest = path.getLast().request();
     TypeElement componentType =
         MoreElements.asType(rootRequest.requestElement().getEnclosingElement());
     // TODO(user): Restructure to provide a hint for the start and end of the cycle.
@@ -479,12 +692,28 @@ private void reportCycle(Deque<DependencyRequest> requestPath,
         rootRequest.requestElement());
   }
 
-  private void traversalHelper(BindingGraph graph, Deque<DependencyRequest> requestPath,
+  @AutoValue
+  abstract static class ResolvedRequest {
+    abstract DependencyRequest request();
+    abstract ResolvedBindings binding();
+
+    static ResolvedRequest create(DependencyRequest request, BindingGraph graph) {
+      return new AutoValue_BindingGraphValidator_ResolvedRequest(
+          request, graph.resolvedBindings().get(BindingKey.forDependencyRequest(request)));
+    }
+  }
+
+  private static final Function<ResolvedRequest, DependencyRequest> REQUEST_FROM_RESOLVED_REQUEST =
+      new Function<ResolvedRequest, DependencyRequest>() {
+        @Override public DependencyRequest apply(ResolvedRequest resolvedRequest) {
+          return resolvedRequest.request();
+        }
+      };
+
+  private void traversalHelper(BindingGraph graph, Deque<ResolvedRequest> path,
       Traverser traverser) {
-    ResolvedBindings resolvedBinding = graph.resolvedBindings().get(
-        BindingKey.forDependencyRequest(requestPath.peek()));
     ImmutableSet<DependencyRequest> allDeps =
-        FluentIterable.from(resolvedBinding.bindings())
+        FluentIterable.from(path.peek().binding().bindings())
             .transformAndConcat(
                 new Function<Binding, Set<DependencyRequest>>() {
                   @Override
@@ -493,44 +722,17 @@ private void traversalHelper(BindingGraph graph, Deque<DependencyRequest> reques
                   }
                 })
             .toSet();
-    boolean descend = traverser.visitResolvedBinding(requestPath, resolvedBinding);
+    boolean descend = traverser.visitResolvedRequest(path);
     if (descend) {
       for (DependencyRequest dependency : allDeps) {
-        requestPath.push(dependency);
-        traversalHelper(graph, requestPath, traverser);
-        requestPath.pop();
+        path.push(ResolvedRequest.create(dependency, graph));
+        traversalHelper(graph, path, traverser);
+        path.pop();
       }
     }
   }
 
   abstract static class Traverser {
-    abstract boolean visitResolvedBinding(
-        Deque<DependencyRequest> requestPath, ResolvedBindings binding);
-  }
-
-  /**
-   * {@code -Adagger.disableInterComponentScopeValidation=none} will suppress validation of
-   * scoping relationships between dagger {@code @Component} interfaces. This is a migration
-   * tool to permit easier migration from Dagger 1.x which used {@code @Singleton} for scoped
-   * graphs in any lifetime.
-   *
-   * <p>The value can be (case-insensitively) set to any of {@code ERROR}, {@code WARNING},
-   * or {@code NONE} and defaults to {@code ERROR}.
-   */
-  enum ScopeCycleValidation {
-    ERROR,
-    WARNING,
-    NONE;
-
-    Optional<Diagnostic.Kind> diagnosticKind() {
-      switch (this) {
-        case ERROR:
-          return Optional.of(Diagnostic.Kind.ERROR);
-        case WARNING:
-          return Optional.of(Diagnostic.Kind.WARNING);
-        default:
-          return Optional.absent();
-      }
-    }
+    abstract boolean visitResolvedRequest(Deque<ResolvedRequest> path);
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingKey.java b/compiler/src/main/java/dagger/internal/codegen/BindingKey.java
index ed599e267..473deba64 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingKey.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingKey.java
@@ -38,6 +38,7 @@ static BindingKey forDependencyRequest(DependencyRequest request) {
       case PROVIDER:
       case PRODUCER:
       case PRODUCED:
+      case FUTURE:
         return BindingKey.create(Kind.CONTRIBUTION, request.key());
       case MEMBERS_INJECTOR:
         return BindingKey.create(Kind.MEMBERS_INJECTION, request.key());
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index adb25639e..e2a2eb605 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -16,28 +16,40 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.AnnotationMirrors;
+import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.Lists;
+import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Component;
+import dagger.Subcomponent;
 import dagger.producers.ProductionComponent;
 import java.lang.annotation.Annotation;
+import java.util.Iterator;
 import java.util.List;
+import java.util.concurrent.Executor;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
+import static dagger.internal.codegen.ConfigurationAnnotations.isComponent;
 import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
 import static dagger.internal.codegen.Util.unwrapOptionalEquivalence;
 import static dagger.internal.codegen.Util.wrapOptionalInEquivalence;
+import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.VOID;
 
 /**
@@ -87,6 +99,11 @@
    */
   abstract ImmutableMap<ExecutableElement, TypeElement> dependencyMethodIndex();
 
+  /**
+   * The element representing {@link Executor}, if it should be a dependency of this component.
+   */
+  abstract Optional<TypeElement> executorDependency();
+
   /**
    * An optional annotation constraining the scope of this component.
    */
@@ -101,13 +118,22 @@
    */
   abstract Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedScope();
 
+  abstract ImmutableMap<ExecutableElement, ComponentDescriptor> subcomponents();
+
+  abstract ImmutableSetMultimap<ComponentMethodType, ExecutableElement> componentMethods();
+
+  enum ComponentMethodType {
+    PROVISON,
+    PRODUCTION,
+    MEMBERS_INJECTION,
+    SUBCOMPONENT,
+  }
+
   static final class Factory {
     private final Elements elements;
-    private final Types types;
 
-    Factory(Elements elements, Types types) {
+    Factory(Elements elements) {
       this.elements = elements;
-      this.types = types;
     }
 
     ComponentDescriptor forComponent(TypeElement componentDefinitionType) {
@@ -120,9 +146,13 @@ ComponentDescriptor forProductionComponent(TypeElement componentDefinitionType)
 
     private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kind) {
       AnnotationMirror componentMirror =
-          getAnnotationMirror(componentDefinitionType, kind.annotationType()).get();
+          getAnnotationMirror(componentDefinitionType, kind.annotationType())
+              .or(getAnnotationMirror(componentDefinitionType, Subcomponent.class))
+              .get();
       ImmutableSet<TypeElement> componentDependencyTypes =
-          MoreTypes.asTypeElements(types, getComponentDependencies(componentMirror));
+          isComponent(componentDefinitionType)
+              ? MoreTypes.asTypeElements(getComponentDependencies(componentMirror))
+              : ImmutableSet.<TypeElement>of();
 
       ImmutableMap.Builder<ExecutableElement, TypeElement> dependencyMethodIndex =
           ImmutableMap.builder();
@@ -131,12 +161,36 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
         List<ExecutableElement> dependencyMethods =
             ElementFilter.methodsIn(elements.getAllMembers(componentDependency));
         for (ExecutableElement dependencyMethod : dependencyMethods) {
-          if (isComponentProvisionMethod(elements, dependencyMethod)) {
+          if (isComponentContributionMethod(elements, dependencyMethod)) {
             dependencyMethodIndex.put(dependencyMethod, componentDependency);
           }
         }
       }
 
+      Optional<TypeElement> executorDependency =
+          kind.equals(Kind.PRODUCTION_COMPONENT)
+              ? Optional.of(elements.getTypeElement(Executor.class.getCanonicalName()))
+              : Optional.<TypeElement>absent();
+
+      ImmutableSet<ExecutableElement> unimplementedMethods =
+          getUnimplementedMethods(elements, componentDefinitionType);
+
+      ImmutableSetMultimap.Builder<ComponentMethodType, ExecutableElement> componentMethodsBuilder =
+          ImmutableSetMultimap.builder();
+
+      ImmutableMap.Builder<ExecutableElement, ComponentDescriptor> subcomponentDescriptors =
+          ImmutableMap.builder();
+      for (ExecutableElement componentMethod : unimplementedMethods) {
+        ComponentMethodType componentMethodType =
+            getComponentMethodType(kind, componentMethod);
+        componentMethodsBuilder.put(componentMethodType, componentMethod);
+        if (componentMethodType.equals(ComponentMethodType.SUBCOMPONENT)) {
+          subcomponentDescriptors.put(componentMethod,
+              create(MoreElements.asType(MoreTypes.asElement(componentMethod.getReturnType())),
+                  Kind.COMPONENT));
+        }
+      }
+
       Optional<AnnotationMirror> scope = getScopeAnnotation(componentDefinitionType);
       return new AutoValue_ComponentDescriptor(
           kind,
@@ -144,14 +198,105 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
           componentDefinitionType,
           componentDependencyTypes,
           dependencyMethodIndex.build(),
-          wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), scope));
+          executorDependency,
+          wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), scope),
+          subcomponentDescriptors.build(),
+          componentMethodsBuilder.build());
     }
   }
 
-  static boolean isComponentProvisionMethod(Elements elements, ExecutableElement method) {
+  private static ComponentMethodType getComponentMethodType(Kind componentKind,
+      ExecutableElement method) {
+    TypeMirror returnType = method.getReturnType();
+    if (returnType.getKind().equals(DECLARED) &&
+        getAnnotationMirror(MoreTypes.asElement(returnType), Subcomponent.class).isPresent()) {
+      return ComponentMethodType.SUBCOMPONENT;
+    }
+
+    if (method.getParameters().isEmpty()
+        && !method.getReturnType().getKind().equals(VOID)) {
+      switch (componentKind) {
+        case COMPONENT:
+          return ComponentMethodType.PROVISON;
+        case PRODUCTION_COMPONENT:
+          return ComponentMethodType.PRODUCTION;
+        default:
+          throw new AssertionError();
+      }
+    }
+
+    List<? extends VariableElement> parameters = method.getParameters();
+    if (parameters.size() == 1
+        && (returnType.getKind().equals(VOID)
+            || MoreTypes.equivalence().equivalent(returnType, parameters.get(0).asType()))) {
+      return ComponentMethodType.MEMBERS_INJECTION;
+    }
+
+    throw new IllegalArgumentException();
+  }
+
+  static boolean isComponentContributionMethod(Elements elements, ExecutableElement method) {
     return method.getParameters().isEmpty()
         && !method.getReturnType().getKind().equals(VOID)
         && !elements.getTypeElement(Object.class.getCanonicalName())
             .equals(method.getEnclosingElement());
   }
+
+  static boolean isComponentProductionMethod(Elements elements, ExecutableElement method) {
+    return isComponentContributionMethod(elements, method)
+        && MoreTypes.isTypeOf(ListenableFuture.class, method.getReturnType());
+  }
+
+  /*
+   * These two methods were borrowed from AutoValue and slightly modified.  TODO(gak): reconcile
+   * the two and put them in auto common
+   */
+  private static void findLocalAndInheritedMethods(Elements elements, TypeElement type,
+      List<ExecutableElement> methods) {
+    for (TypeMirror superInterface : type.getInterfaces()) {
+      findLocalAndInheritedMethods(
+          elements, MoreElements.asType(MoreTypes.asElement(superInterface)), methods);
+    }
+    if (type.getSuperclass().getKind() != TypeKind.NONE) {
+      // Visit the superclass after superinterfaces so we will always see the implementation of a
+      // method after any interfaces that declared it.
+      findLocalAndInheritedMethods(
+          elements, MoreElements.asType(MoreTypes.asElement(type.getSuperclass())), methods);
+    }
+    // Add each method of this class, and in so doing remove any inherited method it overrides.
+    // This algorithm is quadratic in the number of methods but it's hard to see how to improve
+    // that while still using Elements.overrides.
+    List<ExecutableElement> theseMethods = ElementFilter.methodsIn(type.getEnclosedElements());
+    for (ExecutableElement method : theseMethods) {
+      if (!method.getModifiers().contains(Modifier.PRIVATE)) {
+        boolean alreadySeen = false;
+        for (Iterator<ExecutableElement> methodIter = methods.iterator(); methodIter.hasNext();) {
+          ExecutableElement otherMethod = methodIter.next();
+          if (elements.overrides(method, otherMethod, type)) {
+            methodIter.remove();
+          } else if (method.getSimpleName().equals(otherMethod.getSimpleName())
+              && method.getParameters().equals(otherMethod.getParameters())) {
+            // If we inherit this method on more than one path, we don't want to add it twice.
+            alreadySeen = true;
+          }
+        }
+        if (!alreadySeen) {
+          methods.add(method);
+        }
+      }
+    }
+  }
+
+  private static ImmutableSet<ExecutableElement> getUnimplementedMethods(
+      Elements elements, TypeElement type) {
+    ImmutableSet.Builder<ExecutableElement> unimplementedMethods = ImmutableSet.builder();
+    List<ExecutableElement> methods = Lists.newArrayList();
+    findLocalAndInheritedMethods(elements, type, methods);
+    for (ExecutableElement method : methods) {
+      if (method.getModifiers().contains(Modifier.ABSTRACT)) {
+        unimplementedMethods.add(method);
+      }
+    }
+    return unimplementedMethods.build();
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 8e75f5393..d1d1633e7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -24,6 +24,7 @@
 import com.google.common.base.Functions;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
+import com.google.common.base.Predicates;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
@@ -32,6 +33,7 @@
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
+import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Component;
 import dagger.Factory;
 import dagger.MapKey;
@@ -57,6 +59,9 @@
 import dagger.internal.codegen.writer.TypeNames;
 import dagger.internal.codegen.writer.TypeWriter;
 import dagger.internal.codegen.writer.VoidName;
+import dagger.producers.Producer;
+import dagger.producers.internal.Producers;
+import java.util.Collection;
 import java.util.EnumSet;
 import java.util.Iterator;
 import java.util.List;
@@ -79,14 +84,22 @@
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementKindVisitor6;
 import javax.lang.model.util.SimpleAnnotationValueVisitor6;
+import javax.tools.Diagnostic;
 
 import static com.google.auto.common.MoreTypes.asDeclared;
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static dagger.internal.codegen.Binding.bindingPackageFor;
 import static dagger.internal.codegen.ConfigurationAnnotations.getMapKeys;
+import static dagger.internal.codegen.DependencyRequest.Kind.MEMBERS_INJECTOR;
+import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
+import static dagger.internal.codegen.ProductionBinding.Kind.COMPONENT_PRODUCTION;
 import static dagger.internal.codegen.ProvisionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
+import static dagger.internal.codegen.ProvisionBinding.Kind.COMPONENT;
+import static dagger.internal.codegen.ProvisionBinding.Kind.COMPONENT_PROVISION;
+import static dagger.internal.codegen.ProvisionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.ProvisionBinding.Kind.SYNTHETIC_PROVISON;
+import static dagger.internal.codegen.SourceFiles.factoryNameForProductionBinding;
 import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.membersInjectorNameForMembersInjectionBinding;
@@ -106,8 +119,11 @@
  * @since 2.0
  */
 final class ComponentGenerator extends SourceFileGenerator<BindingGraph> {
-  ComponentGenerator(Filer filer) {
+  private final Diagnostic.Kind nullableValidationType;
+
+  ComponentGenerator(Filer filer, Diagnostic.Kind nullableValidationType) {
     super(filer);
+    this.nullableValidationType = nullableValidationType;
   }
 
   @Override
@@ -145,14 +161,24 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
         ClassName.fromTypeElement(input.componentDescriptor().componentDefinitionType());
 
     JavaWriter writer = JavaWriter.inPackage(componentName.packageName());
+
     ClassWriter componentWriter = writer.addClass(componentName.simpleName());
     componentWriter.annotate(Generated.class).setValue(ComponentProcessor.class.getCanonicalName());
     componentWriter.addModifiers(PUBLIC, FINAL);
     componentWriter.addImplementedType(componentDefinitionTypeName);
 
+    Set<JavaWriter> javaWriters = Sets.newHashSet();
+    javaWriters.add(writer);
+    writeComponent(input, componentDefinitionTypeName, componentWriter, javaWriters);
+
+    return ImmutableSet.copyOf(javaWriters);
+  }
+
+  private ImmutableMap<BindingKey, Snippet> writeComponent(
+      BindingGraph input, ClassName componentDefinitionTypeName, ClassWriter componentWriter,
+      Set<JavaWriter> proxyWriters) {
     ClassWriter builderWriter = componentWriter.addNestedClass("Builder");
     builderWriter.addModifiers(PUBLIC, STATIC, FINAL);
-
     builderWriter.addConstructor().addModifiers(PRIVATE);
 
     MethodWriter builderFactoryMethod = componentWriter.addMethod(builderWriter, "builder");
@@ -163,8 +189,10 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
     ImmutableMap<TypeElement, String> componentContributionNames =
         ImmutableMap.copyOf(Maps.asMap(
             Sets.union(
-                input.transitiveModules().keySet(),
-                input.componentDescriptor().dependencies()),
+                Sets.union(
+                    input.transitiveModules().keySet(),
+                    input.componentDescriptor().dependencies()),
+                input.componentDescriptor().executorDependency().asSet()),
             Functions.compose(
                 CaseFormat.UPPER_CAMEL.converterTo(LOWER_CAMEL),
                 new Function<TypeElement, String>() {
@@ -222,15 +250,186 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
       }
     }
 
-    ImmutableMap.Builder<BindingKey, Snippet> memberSelectSnippetsBuilder =
-        ImmutableMap.builder();
-    ImmutableMap.Builder<ContributionBinding, Snippet> multibindingContributionSnippetsBuilder =
-        ImmutableMap.builder();
+    if (!requiresBuilder) {
+      MethodWriter factoryMethod = componentWriter.addMethod(componentDefinitionTypeName, "create");
+      factoryMethod.addModifiers(PUBLIC, STATIC);
+      // TODO(gak): replace this with something that doesn't allocate a builder
+      factoryMethod.body().addSnippet("return builder().build();");
+    }
+
+    Map<BindingKey, Snippet> memberSelectSnippetsBuilder = Maps.newHashMap();
+    Map<ContributionBinding, Snippet> multibindingContributionSnippetsBuilder = Maps.newHashMap();
     ImmutableSet.Builder<BindingKey> enumBindingKeysBuilder = ImmutableSet.builder();
 
-    ImmutableSet.Builder<JavaWriter> proxyWriters = ImmutableSet.builder();
     Map<String, ProxyClassAndField> packageProxies = Maps.newHashMap();
 
+    writeFields(input,
+        componentWriter,
+        proxyWriters,
+        memberSelectSnippetsBuilder,
+        ImmutableMap.<ContributionBinding, Snippet>of(),
+        multibindingContributionSnippetsBuilder,
+        enumBindingKeysBuilder,
+        packageProxies);
+
+    buildMethod.body().addSnippet("return new %s(this);", componentWriter.name());
+
+    ImmutableMap<BindingKey, Snippet> memberSelectSnippets =
+        ImmutableMap.copyOf(memberSelectSnippetsBuilder);
+    ImmutableMap<ContributionBinding, Snippet> multibindingContributionSnippets =
+        ImmutableMap.copyOf(multibindingContributionSnippetsBuilder);
+    ImmutableSet<BindingKey> enumBindingKeys = enumBindingKeysBuilder.build();
+
+    initializeFrameworkTypes(input,
+        componentWriter,
+        constructorWriter,
+        componentContributionFields,
+        memberSelectSnippets,
+        ImmutableMap.<ContributionBinding, Snippet>of(),
+        multibindingContributionSnippets);
+
+    writeInterfaceMethods(input, componentWriter, memberSelectSnippets, enumBindingKeys);
+
+    writeSubcomponents(input,
+        componentWriter,
+        proxyWriters,
+        componentContributionFields,
+        memberSelectSnippets,
+        multibindingContributionSnippets);
+
+    return memberSelectSnippets;
+  }
+
+  private void writeSubcomponents(BindingGraph input,
+      ClassWriter componentWriter,
+      Set<JavaWriter> proxyWriters,
+      Map<TypeElement, FieldWriter> componentContributionFields,
+      ImmutableMap<BindingKey, Snippet> memberSelectSnippets,
+      ImmutableMap<ContributionBinding, Snippet> multibindingContributionSnippets) {
+    for (Entry<ExecutableElement, BindingGraph> subgraphEntry : input.subgraphs().entrySet()) {
+      TypeName componentType =
+          TypeNames.forTypeMirror(subgraphEntry.getKey().getReturnType());
+
+      ClassWriter subcomponentWriter = componentWriter.addNestedClass(
+          subgraphEntry.getValue().componentDescriptor().componentDefinitionType().getSimpleName()
+              + "Impl");
+
+      subcomponentWriter.addModifiers(PRIVATE, FINAL);
+      subcomponentWriter.addImplementedType(componentType);
+
+      writeSubcomponent(subgraphEntry.getValue(),
+          subcomponentWriter,
+          proxyWriters,
+          ImmutableMap.copyOf(componentContributionFields),
+          ImmutableMap.copyOf(multibindingContributionSnippets),
+          memberSelectSnippets);
+
+      MethodWriter componentMethod = componentWriter.addMethod(componentType,
+          subgraphEntry.getKey().getSimpleName().toString());
+      componentMethod.addModifiers(PUBLIC);
+      componentMethod.annotate(Override.class);
+      // TODO(gak): need to pipe through the method params
+      componentMethod.body().addSnippet("return new %s();",
+          subcomponentWriter.name());
+    }
+  }
+
+  private ImmutableMap<BindingKey, Snippet> writeSubcomponent(
+      BindingGraph input, ClassWriter componentWriter,
+      Set<JavaWriter> proxyWriters,
+      ImmutableMap<TypeElement, FieldWriter> parentContributionFields,
+      ImmutableMap<ContributionBinding, Snippet> parentMultibindingContributionSnippets,
+      ImmutableMap<BindingKey, Snippet> parentMemberSelectSnippets) {
+    // the full set of types that calling code uses to construct a component instance
+    ImmutableMap<TypeElement, String> componentContributionNames =
+        ImmutableMap.copyOf(Maps.asMap(
+            Sets.union(
+                input.transitiveModules().keySet(),
+                input.componentDescriptor().dependencies()),
+            new Function<TypeElement, String>() {
+              @Override public String apply(TypeElement input) {
+                return CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL, input.getSimpleName().toString());
+              }
+            }));
+
+    ConstructorWriter constructorWriter = componentWriter.addConstructor();
+    constructorWriter.addModifiers(PRIVATE);
+
+    Map<TypeElement, FieldWriter> componentContributionFields =
+        Maps.newHashMap(parentContributionFields);
+
+    for (Entry<TypeElement, String> entry : componentContributionNames.entrySet()) {
+      TypeElement contributionElement = entry.getKey();
+      String contributionName = entry.getValue();
+      FieldWriter contributionField =
+          componentWriter.addField(contributionElement, contributionName);
+      if (hasNoArgsConstructor(entry.getKey())) {
+        contributionField.setInitializer(Snippet.format("new %s()",
+            ClassName.fromTypeElement(entry.getKey())));
+      }
+      contributionField.addModifiers(PRIVATE, FINAL);
+      componentContributionFields.put(contributionElement, contributionField);
+    }
+
+    Map<BindingKey, Snippet> memberSelectSnippetsBuilder = Maps.newHashMap();
+
+    Map<ContributionBinding, Snippet> multibindingContributionSnippetsBuilder = Maps.newHashMap();
+    ImmutableSet.Builder<BindingKey> enumBindingKeysBuilder = ImmutableSet.builder();
+
+    Map<String, ProxyClassAndField> packageProxies = Maps.newHashMap();
+
+    writeFields(input,
+        componentWriter,
+        proxyWriters,
+        memberSelectSnippetsBuilder,
+        parentMultibindingContributionSnippets,
+        multibindingContributionSnippetsBuilder,
+        enumBindingKeysBuilder,
+        packageProxies);
+
+    for (Entry<BindingKey, Snippet> parentBindingEntry : parentMemberSelectSnippets.entrySet()) {
+      if (!memberSelectSnippetsBuilder.containsKey(parentBindingEntry.getKey())) {
+        memberSelectSnippetsBuilder.put(parentBindingEntry.getKey(), parentBindingEntry.getValue());
+      }
+    }
+
+    ImmutableMap<BindingKey, Snippet> memberSelectSnippets =
+        ImmutableMap.copyOf(memberSelectSnippetsBuilder);
+    ImmutableMap<ContributionBinding, Snippet> multibindingContributionSnippets =
+        ImmutableMap.copyOf(multibindingContributionSnippetsBuilder);
+    ImmutableSet<BindingKey> enumBindingKeys = enumBindingKeysBuilder.build();
+
+    initializeFrameworkTypes(input,
+        componentWriter,
+        constructorWriter,
+        componentContributionFields,
+        memberSelectSnippets,
+        parentMultibindingContributionSnippets,
+        multibindingContributionSnippets);
+
+    writeInterfaceMethods(input, componentWriter, memberSelectSnippets, enumBindingKeys);
+
+    writeSubcomponents(input,
+        componentWriter,
+        proxyWriters,
+        componentContributionFields,
+        memberSelectSnippets,
+        new ImmutableMap.Builder<ContributionBinding, Snippet>()
+            .putAll(parentMultibindingContributionSnippets)
+            .putAll(multibindingContributionSnippets)
+            .build());
+
+    return memberSelectSnippets;
+  }
+
+  private void writeFields(BindingGraph input,
+      ClassWriter componentWriter,
+      Set<JavaWriter> proxyWriters,
+      Map<BindingKey, Snippet> memberSelectSnippetsBuilder,
+      Map<ContributionBinding, Snippet> parentMultibindingContributionSnippetsBuilder,
+      Map<ContributionBinding, Snippet> multibindingContributionSnippetsBuilder,
+      ImmutableSet.Builder<BindingKey> enumBindingKeysBuilder,
+      Map<String, ProxyClassAndField> packageProxies) throws AssertionError {
     for (ResolvedBindings resolvedBindings : input.resolvedBindings().values()) {
       BindingKey bindingKey = resolvedBindings.bindingKey();
 
@@ -252,13 +451,13 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
       }
 
       String bindingPackage = bindingPackageFor(resolvedBindings.bindings())
-          .or(componentName.packageName());
+          .or(componentWriter.name().packageName());
 
       final Optional<String> proxySelector;
       final TypeWriter classWithFields;
       final Set<Modifier> fieldModifiers;
 
-      if (bindingPackage.equals(componentName.packageName())) {
+      if (bindingPackage.equals(componentWriter.name().packageName())) {
         // no proxy
         proxySelector = Optional.absent();
         // component gets the fields
@@ -272,7 +471,7 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
           JavaWriter proxyJavaWriter = JavaWriter.inPackage(bindingPackage);
           proxyWriters.add(proxyJavaWriter);
           ClassWriter proxyWriter =
-              proxyJavaWriter.addClass(componentName.simpleName() + "__PackageProxy");
+              proxyJavaWriter.addClass(componentWriter.name().simpleName() + "__PackageProxy");
           proxyWriter.annotate(Generated.class)
               .setValue(ComponentProcessor.class.getCanonicalName());
           proxyWriter.addModifiers(PUBLIC, FINAL);
@@ -297,22 +496,27 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
         ImmutableSet<? extends ContributionBinding> contributionBindings =
             resolvedBindings.contributionBindings();
         if (ContributionBinding.bindingTypeFor(contributionBindings).isMultibinding()) {
+          // note that here we rely on the order of the resolved bindings being from parent to child
+          // otherwise, the nubmering wouldn't work
           int contributionNumber = 0;
           for (ContributionBinding contributionBinding : contributionBindings) {
             if (isSytheticProvisionBinding(contributionBinding)) {
               contributionNumber++;
-              FrameworkField contributionBindingField = frameworkFieldForSyntheticProvisionBinding(
-                  bindingKey, contributionNumber, contributionBinding);
-              FieldWriter contributionField = classWithFields.addField(
-                  contributionBindingField.frameworkType(), contributionBindingField.name());
-              contributionField.addModifiers(fieldModifiers);
-
-              ImmutableList<String> contirubtionSelectTokens = new ImmutableList.Builder<String>()
-                  .addAll(proxySelector.asSet())
-                  .add(contributionField.name())
-                  .build();
-              multibindingContributionSnippetsBuilder.put(contributionBinding,
-                  Snippet.memberSelectSnippet(contirubtionSelectTokens));
+              if (!parentMultibindingContributionSnippetsBuilder.containsKey(contributionBinding)) {
+                FrameworkField contributionBindingField =
+                    frameworkFieldForSyntheticProvisionBinding(
+                          bindingKey, contributionNumber, contributionBinding);
+                FieldWriter contributionField = classWithFields.addField(
+                    contributionBindingField.frameworkType(), contributionBindingField.name());
+                contributionField.addModifiers(fieldModifiers);
+
+                ImmutableList<String> contirubtionSelectTokens = new ImmutableList.Builder<String>()
+                    .addAll(proxySelector.asSet())
+                    .add(contributionField.name())
+                    .build();
+                multibindingContributionSnippetsBuilder.put(contributionBinding,
+                    Snippet.memberSelectSnippet(contirubtionSelectTokens));
+              }
             }
           }
         }
@@ -327,25 +531,80 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
           .addAll(proxySelector.asSet())
           .add(frameworkField.name())
           .build();
-      memberSelectSnippetsBuilder.put(bindingKey,
-          Snippet.memberSelectSnippet(memberSelectTokens));
-
+      memberSelectSnippetsBuilder.put(bindingKey, Snippet.memberSelectSnippet(memberSelectTokens));
     }
+  }
 
-    buildMethod.body().addSnippet("return new %s(this);", componentWriter.name());
+  private void writeInterfaceMethods(BindingGraph input, ClassWriter componentWriter,
+      ImmutableMap<BindingKey, Snippet> memberSelectSnippets,
+      ImmutableSet<BindingKey> enumBindingKeys) throws AssertionError {
+    Set<MethodSignature> interfaceMethods = Sets.newHashSet();
 
-    if (!requiresBuilder) {
-      MethodWriter factoryMethod = componentWriter.addMethod(componentDefinitionTypeName, "create");
-      factoryMethod.addModifiers(PUBLIC, STATIC);
-      // TODO(gak): replace this with something that doesn't allocate a builder
-      factoryMethod.body().addSnippet("return builder().build();");
+    for (DependencyRequest interfaceRequest : input.entryPoints()) {
+      ExecutableElement requestElement =
+          MoreElements.asExecutable(interfaceRequest.requestElement());
+      MethodSignature signature = MethodSignature.fromExecutableElement(requestElement);
+      if (!interfaceMethods.contains(signature)) {
+        interfaceMethods.add(signature);
+        MethodWriter interfaceMethod = requestElement.getReturnType().getKind().equals(VOID)
+            ? componentWriter.addMethod(VoidName.VOID, requestElement.getSimpleName().toString())
+                : componentWriter.addMethod(requestElement.getReturnType(),
+                    requestElement.getSimpleName().toString());
+        interfaceMethod.annotate(Override.class);
+        interfaceMethod.addModifiers(PUBLIC);
+        BindingKey bindingKey = BindingKey.forDependencyRequest(interfaceRequest);
+        switch(interfaceRequest.kind()) {
+          case MEMBERS_INJECTOR:
+            Snippet membersInjectorName = memberSelectSnippets.get(bindingKey);
+            VariableElement parameter = Iterables.getOnlyElement(requestElement.getParameters());
+            Name parameterName = parameter.getSimpleName();
+            interfaceMethod.addParameter(
+                TypeNames.forTypeMirror(parameter.asType()), parameterName.toString());
+            interfaceMethod.body()
+                .addSnippet("%s.injectMembers(%s);", membersInjectorName, parameterName);
+            if (!requestElement.getReturnType().getKind().equals(VOID)) {
+              interfaceMethod.body().addSnippet("return %s;", parameterName);
+            }
+            break;
+          case INSTANCE:
+            if (enumBindingKeys.contains(bindingKey)
+                && !MoreTypes.asDeclared(bindingKey.key().type())
+                        .getTypeArguments().isEmpty()) {
+              // If using a parameterized enum type, then we need to store the factory
+              // in a temporary variable, in order to help javac be able to infer
+              // the generics of the Factory.create methods.
+              TypeName factoryType = ParameterizedTypeName.create(Provider.class,
+                  TypeNames.forTypeMirror(requestElement.getReturnType()));
+              interfaceMethod.body().addSnippet("%s factory = %s;", factoryType,
+                  memberSelectSnippets.get(bindingKey));
+              interfaceMethod.body().addSnippet("return factory.get();");
+              break;
+            }
+            // fall through in the else case.
+          case LAZY:
+          case PRODUCED:
+          case PRODUCER:
+          case PROVIDER:
+          case FUTURE:
+            interfaceMethod.body().addSnippet("return %s;",
+                frameworkTypeUsageStatement(memberSelectSnippets.get(bindingKey),
+                    interfaceRequest.kind()));
+            break;
+          default:
+            throw new AssertionError();
+        }
+      }
     }
+  }
 
-    ImmutableMap<BindingKey, Snippet> memberSelectSnippets = memberSelectSnippetsBuilder.build();
-    ImmutableMap<ContributionBinding, Snippet> multibindingContributionSnippets =
-        multibindingContributionSnippetsBuilder.build();
-    ImmutableSet<BindingKey> enumBindingKeys = enumBindingKeysBuilder.build();
-
+  private void initializeFrameworkTypes(BindingGraph input,
+      ClassWriter componentWriter,
+      ConstructorWriter constructorWriter,
+      Map<TypeElement, FieldWriter> componentContributionFields,
+      ImmutableMap<BindingKey, Snippet> memberSelectSnippets,
+      ImmutableMap<ContributionBinding, Snippet> parentMultibindingContributionSnippets,
+      ImmutableMap<ContributionBinding, Snippet> multibindingContributionSnippets)
+      throws AssertionError {
     List<List<BindingKey>> partitions = Lists.partition(
         input.resolvedBindings().keySet().asList(), 100);
     for (int i = 0; i < partitions.size(); i++) {
@@ -359,56 +618,94 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
         Snippet memberSelectSnippet = memberSelectSnippets.get(bindingKey);
         switch (bindingKey.kind()) {
           case CONTRIBUTION:
-            @SuppressWarnings("unchecked")  // checked during validation
-            ImmutableSet<ProvisionBinding> bindings =
-                (ImmutableSet<ProvisionBinding>) input.resolvedBindings()
-                .get(bindingKey)
-                .contributionBindings();
+            ImmutableSet<? extends ContributionBinding> bindings =
+                input.resolvedBindings().get(bindingKey).contributionBindings();
 
             switch (ContributionBinding.bindingTypeFor(bindings)) {
               case SET:
-                for (ProvisionBinding provisionBinding : bindings) {
+                if (Sets.filter(bindings, Predicates.instanceOf(ProductionBinding.class))
+                    .isEmpty()) {
+                  @SuppressWarnings("unchecked")  // checked by the instanceof filter above
+                  ImmutableSet<ProvisionBinding> provisionBindings =
+                      (ImmutableSet<ProvisionBinding>) bindings;
+                  ImmutableList.Builder<Snippet> parameterSnippets = ImmutableList.builder();
+                  for (ProvisionBinding provisionBinding : provisionBindings) {
+                    if (multibindingContributionSnippets.containsKey(provisionBinding)) {
+                      Snippet snippet = multibindingContributionSnippets.get(provisionBinding);
+                      initializeMethod.body().addSnippet("this.%s = %s;",
+                          snippet,
+                          initializeFactoryForProvisionBinding(provisionBinding,
+                              input.componentDescriptor().dependencyMethodIndex(),
+                              componentContributionFields,
+                              memberSelectSnippets));
+                      parameterSnippets.add(snippet);
+                    } else if (parentMultibindingContributionSnippets
+                        .containsKey(provisionBinding)) {
+                      parameterSnippets.add(
+                          parentMultibindingContributionSnippets.get(provisionBinding));
+                    } else {
+                      throw new IllegalStateException();
+                    }
+                  }
+                  Snippet initializeSetSnippet = Snippet.format("%s.create(%s)",
+                      ClassName.fromClass(SetFactory.class),
+                      Snippet.makeParametersSnippet(parameterSnippets.build()));
                   initializeMethod.body().addSnippet("this.%s = %s;",
-                      multibindingContributionSnippets.get(provisionBinding),
-                      initializeFactoryForBinding(provisionBinding,
-                          input.componentDescriptor().dependencyMethodIndex(),
-                          componentContributionFields,
-                          memberSelectSnippets));
+                      memberSelectSnippet, initializeSetSnippet);
+                } else {
+                  // TODO(user): Implement producer set bindings.
+                  throw new IllegalStateException("producer set bindings not implemented yet");
                 }
-                Snippet initializeSetSnippet = Snippet.format("%s.create(%s)",
-                    ClassName.fromClass(SetFactory.class),
-                    Snippet.makeParametersSnippet(Iterables.transform(bindings,
-                        Functions.forMap(multibindingContributionSnippets))));
-                initializeMethod.body().addSnippet("this.%s = %s;",
-                    memberSelectSnippet, initializeSetSnippet);
                 break;
               case MAP:
-                for (ProvisionBinding provisionBinding : bindings) {
-                  if (!isNonProviderMap(provisionBinding)) {
-                    initializeMethod.body().addSnippet("this.%s = %s;",
+                if (Sets.filter(bindings, Predicates.instanceOf(ProductionBinding.class))
+                    .isEmpty()) {
+                  @SuppressWarnings("unchecked")  // checked by the instanceof filter above
+                  ImmutableSet<ProvisionBinding> provisionBindings =
+                      (ImmutableSet<ProvisionBinding>) bindings;
+                  for (ProvisionBinding provisionBinding : provisionBindings) {
+                    if (!isNonProviderMap(provisionBinding)) {
+                      initializeMethod.body().addSnippet("this.%s = %s;",
                         multibindingContributionSnippets.get(provisionBinding),
-                        initializeFactoryForBinding(provisionBinding,
-                            input.componentDescriptor().dependencyMethodIndex(),
-                            componentContributionFields,
-                            memberSelectSnippets));
+                          initializeFactoryForProvisionBinding(provisionBinding,
+                              input.componentDescriptor().dependencyMethodIndex(),
+                              componentContributionFields,
+                              memberSelectSnippets));
+                    }
                   }
-                }
-                if (!bindings.isEmpty()) {
-                  Snippet initializeMapSnippet = initializeMapBinding(
-                      memberSelectSnippets, multibindingContributionSnippets, bindings);
-                  initializeMethod.body().addSnippet("this.%s = %s;",
-                      memberSelectSnippet, initializeMapSnippet);
+                  if (!provisionBindings.isEmpty()) {
+                    Snippet initializeMapSnippet = initializeMapBinding(
+                        memberSelectSnippets, multibindingContributionSnippets, provisionBindings);
+                    initializeMethod.body().addSnippet("this.%s = %s;",
+                        memberSelectSnippet, initializeMapSnippet);
+                  }
+                } else {
+                  // TODO(user): Implement producer map bindings.
+                  throw new IllegalStateException("producer map bindings not implemented yet");
                 }
                 break;
               case UNIQUE:
-                ProvisionBinding binding = Iterables.getOnlyElement(bindings);
-                if (!binding.factoryCreationStrategy().equals(ENUM_INSTANCE)
-                    || binding.scope().isPresent()) {
+                ContributionBinding binding = Iterables.getOnlyElement(bindings);
+                if (binding instanceof ProvisionBinding) {
+                  ProvisionBinding provisionBinding = (ProvisionBinding) binding;
+                  if (!provisionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
+                      || provisionBinding.scope().isPresent()) {
+                    initializeMethod.body().addSnippet("this.%s = %s;",
+                        memberSelectSnippet,
+                        initializeFactoryForProvisionBinding(provisionBinding,
+                            input.componentDescriptor().dependencyMethodIndex(),
+                            componentContributionFields, memberSelectSnippets));
+                  }
+                } else if (binding instanceof ProductionBinding) {
+                  ProductionBinding productionBinding = (ProductionBinding) binding;
                   initializeMethod.body().addSnippet("this.%s = %s;",
                       memberSelectSnippet,
-                      initializeFactoryForBinding(binding,
+                      initializeFactoryForProductionBinding(productionBinding,
+                          input,
                           input.componentDescriptor().dependencyMethodIndex(),
                           componentContributionFields, memberSelectSnippets));
+                } else {
+                  throw new IllegalStateException();
                 }
                 break;
               default:
@@ -427,68 +724,6 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
         }
       }
     }
-
-    Set<MethodSignature> interfaceMethods = Sets.newHashSet();
-
-    for (DependencyRequest interfaceRequest : input.entryPoints()) {
-      ExecutableElement requestElement =
-          MoreElements.asExecutable(interfaceRequest.requestElement());
-      MethodSignature signature = MethodSignature.fromExecutableElement(requestElement);
-      if (!interfaceMethods.contains(signature)) {
-        interfaceMethods.add(signature);
-        MethodWriter interfaceMethod = requestElement.getReturnType().getKind().equals(VOID)
-            ? componentWriter.addMethod(VoidName.VOID, requestElement.getSimpleName().toString())
-                : componentWriter.addMethod(requestElement.getReturnType(),
-                    requestElement.getSimpleName().toString());
-            interfaceMethod.annotate(Override.class);
-            interfaceMethod.addModifiers(PUBLIC);
-            BindingKey bindingKey = BindingKey.forDependencyRequest(interfaceRequest);
-            switch(interfaceRequest.kind()) {
-              case MEMBERS_INJECTOR:
-                Snippet membersInjectorName = memberSelectSnippets.get(bindingKey);
-                VariableElement parameter = Iterables.getOnlyElement(requestElement.getParameters());
-                Name parameterName = parameter.getSimpleName();
-                interfaceMethod.addParameter(
-                    TypeNames.forTypeMirror(parameter.asType()), parameterName.toString());
-                interfaceMethod.body()
-                    .addSnippet("%s.injectMembers(%s);", membersInjectorName, parameterName);
-                if (!requestElement.getReturnType().getKind().equals(VOID)) {
-                  interfaceMethod.body().addSnippet("return %s;", parameterName);
-                }
-                break;
-              case INSTANCE:
-                if (enumBindingKeys.contains(bindingKey)
-                    && !MoreTypes.asDeclared(bindingKey.key().type())
-                            .getTypeArguments().isEmpty()) {
-                  // If using a parameterized enum type, then we need to store the factory
-                  // in a temporary variable, in order to help javac be able to infer
-                  // the generics of the Factory.create methods.
-                  TypeName factoryType = ParameterizedTypeName.create(Provider.class,
-                      TypeNames.forTypeMirror(requestElement.getReturnType()));
-                  interfaceMethod.body().addSnippet("%s factory = %s;", factoryType,
-                      memberSelectSnippets.get(bindingKey));
-                  interfaceMethod.body().addSnippet("return factory.get();");
-                  break;
-                }
-                // fall through in the else case.
-              case LAZY:
-              case PRODUCED:
-              case PRODUCER:
-              case PROVIDER:
-                interfaceMethod.body().addSnippet("return %s;",
-                    frameworkTypeUsageStatement(memberSelectSnippets.get(bindingKey),
-                        interfaceRequest.kind()));
-                break;
-              default:
-                throw new AssertionError();
-            }
-      }
-    }
-
-    return new ImmutableSet.Builder<JavaWriter>()
-        .addAll(proxyWriters.build())
-        .add(writer)
-        .build();
   }
 
   private static FrameworkField frameworkFieldForSyntheticProvisionBinding(BindingKey bindingKey,
@@ -528,6 +763,22 @@ private static boolean isSytheticProvisionBinding(ContributionBinding contributi
             .bindingKind().equals(SYNTHETIC_PROVISON));
   }
 
+  private static Class<?> frameworkClassForResolvedBindings(ResolvedBindings resolvedBindings) {
+    switch (resolvedBindings.bindingKey().kind()) {
+      case CONTRIBUTION:
+        for (ContributionBinding binding : resolvedBindings.contributionBindings()) {
+          if (binding instanceof ProductionBinding) {
+            return Producer.class;
+          }
+        }
+        return Provider.class;
+      case MEMBERS_INJECTION:
+        return MembersInjector.class;
+      default:
+        throw new AssertionError();
+    }
+  }
+
   private FrameworkField frameworkFieldForResolvedBindings(ResolvedBindings resolvedBindings) {
     BindingKey bindingKey = resolvedBindings.bindingKey();
     switch (bindingKey.kind()) {
@@ -539,13 +790,13 @@ private FrameworkField frameworkFieldForResolvedBindings(ResolvedBindings resolv
           case SET:
           case MAP:
             return FrameworkField.createWithTypeFromKey(
-                Provider.class,
+                frameworkClassForResolvedBindings(resolvedBindings),
                 bindingKey,
                 KeyVariableNamer.INSTANCE.apply(bindingKey.key()));
           case UNIQUE:
             ContributionBinding binding = Iterables.getOnlyElement(contributionBindings);
             return FrameworkField.createWithTypeFromKey(
-                Provider.class,
+                frameworkClassForResolvedBindings(resolvedBindings),
                 bindingKey,
                 binding.bindingElement().accept(new ElementKindVisitor6<String, Void>() {
                   @Override
@@ -579,7 +830,7 @@ public String visitType(TypeElement e, Void p) {
     }
   }
 
-  private Snippet initializeFactoryForBinding(ProvisionBinding binding,
+  private Snippet initializeFactoryForProvisionBinding(ProvisionBinding binding,
       ImmutableMap<ExecutableElement, TypeElement> dependencyMethodIndex,
       Map<TypeElement, FieldWriter> contributionFields,
       ImmutableMap<BindingKey, Snippet> memberSelectSnippets) {
@@ -589,23 +840,54 @@ private Snippet initializeFactoryForBinding(ProvisionBinding binding,
             ClassName.fromClass(InstanceFactory.class),
             TypeNames.forTypeMirror(binding.key().type()));
       case COMPONENT_PROVISION:
-        return Snippet.format(Joiner.on('\n').join(
-          "new %s<%2$s>() {",
-          "  @Override public %2$s get() {",
-          "    return %3$s.%4$s();",
-          "  }",
-          "}"),
-          ClassName.fromClass(Factory.class),
-          TypeNames.forTypeMirror(binding.key().type()),
-          contributionFields.get(dependencyMethodIndex.get(binding.bindingElement())).name(),
-          binding.bindingElement().getSimpleName().toString());
+        if (binding.nullableType().isPresent()
+            || nullableValidationType.equals(Diagnostic.Kind.WARNING)) {
+          Snippet nullableSnippet = binding.nullableType().isPresent()
+              ? Snippet.format("@%s ", TypeNames.forTypeMirror(binding.nullableType().get()))
+              : Snippet.format("");
+          return Snippet.format(Joiner.on('\n').join(
+            "new %s<%2$s>() {",
+            "  %5$s@Override public %2$s get() {",
+            "    return %3$s.%4$s();",
+            "  }",
+            "}"),
+            ClassName.fromClass(Factory.class),
+            TypeNames.forTypeMirror(binding.key().type()),
+            contributionFields.get(dependencyMethodIndex.get(binding.bindingElement())).name(),
+            binding.bindingElement().getSimpleName().toString(),
+            nullableSnippet);
+        } else {
+          // TODO(sameb): This throws a very vague NPE right now.  The stack trace doesn't
+          // help to figure out what the method or return type is.  If we include a string
+          // of the return type or method name in the error message, that can defeat obfuscation.
+          // We can easily include the raw type (no generics) + annotation type (no values),
+          // using .class & String.format -- but that wouldn't be the whole story.
+          // What should we do?
+          StringLiteral failMsg =
+              StringLiteral.forValue(CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
+          return Snippet.format(Joiner.on('\n').join(
+            "new %s<%2$s>() {",
+            "  @Override public %2$s get() {",
+            "    %2$s provided = %3$s.%4$s();",
+            "    if (provided == null) {",
+            "      throw new NullPointerException(%5$s);",
+            "    }",
+            "    return provided;",
+            "  }",
+            "}"),
+            ClassName.fromClass(Factory.class),
+            TypeNames.forTypeMirror(binding.key().type()),
+            contributionFields.get(dependencyMethodIndex.get(binding.bindingElement())).name(),
+            binding.bindingElement().getSimpleName().toString(),
+            failMsg);
+        }
       case INJECTION:
       case PROVISION:
         List<Snippet> parameters =
             Lists.newArrayListWithCapacity(binding.dependencies().size() + 1);
         if (binding.bindingKind().equals(PROVISION)) {
           parameters.add(
-              Snippet.format(contributionFields.get(binding.bindingTypeElement()).name()));
+              Snippet.format(contributionFields.get(binding.contributedBy().get()).name()));
         }
         if (binding.memberInjectionRequest().isPresent()) {
           parameters.add(memberSelectSnippets.get(
@@ -613,28 +895,50 @@ private Snippet initializeFactoryForBinding(ProvisionBinding binding,
         }
         parameters.addAll(getDependencyParameters(binding.dependencies(), memberSelectSnippets));
 
-        if (binding.bindingKind().equals(PROVISION)) {
-          // Factories from @Provides methods don't have .create() methods.
-          return binding.scope().isPresent()
-              ? Snippet.format("%s.create(new %s(%s))",
-                  ClassName.fromClass(ScopedProvider.class),
-                  factoryNameForProvisionBinding(binding),
-                  Snippet.makeParametersSnippet(parameters))
-              : Snippet.format("new %s(%s)",
-                  factoryNameForProvisionBinding(binding),
-                  Snippet.makeParametersSnippet(parameters));
-        } else {
-          // Factories from @Inject classes have .create() methods.
-          return binding.scope().isPresent()
-              ? Snippet.format("%s.create(%s.create(%s))",
-                  ClassName.fromClass(ScopedProvider.class),
-                  factoryNameForProvisionBinding(binding),
-                  Snippet.makeParametersSnippet(parameters))
-              : Snippet.format("%s.create(%s)",
-                  factoryNameForProvisionBinding(binding),
-                  Snippet.makeParametersSnippet(parameters));
-        }
+        return binding.scope().isPresent()
+            ? Snippet.format("%s.create(%s.create(%s))",
+                ClassName.fromClass(ScopedProvider.class),
+                factoryNameForProvisionBinding(binding),
+                Snippet.makeParametersSnippet(parameters))
+            : Snippet.format("%s.create(%s)",
+                factoryNameForProvisionBinding(binding),
+                Snippet.makeParametersSnippet(parameters));
+      default:
+        throw new AssertionError();
+    }
+  }
 
+  private Snippet initializeFactoryForProductionBinding(ProductionBinding binding,
+      BindingGraph bindingGraph,
+      ImmutableMap<ExecutableElement, TypeElement> dependencyMethodIndex,
+      Map<TypeElement, FieldWriter> contributionFields,
+      ImmutableMap<BindingKey, Snippet> memberSelectSnippets) {
+    switch (binding.bindingKind()) {
+      case COMPONENT_PRODUCTION:
+        return Snippet.format(Joiner.on('\n').join(
+            "new %s<%2$s>() {",
+            "  @Override public %3$s<%2$s> get() {",
+            "    return %4$s.%5$s();",
+            "  }",
+            "}"),
+            ClassName.fromClass(Producer.class),
+            TypeNames.forTypeMirror(binding.key().type()),
+            ClassName.fromClass(ListenableFuture.class),
+            contributionFields.get(dependencyMethodIndex.get(binding.bindingElement())).name(),
+            binding.bindingElement().getSimpleName().toString());
+      case IMMEDIATE:
+      case FUTURE_PRODUCTION:
+        List<Snippet> parameters =
+            Lists.newArrayListWithCapacity(binding.dependencies().size() + 2);
+        parameters.add(Snippet.format(contributionFields.get(binding.bindingTypeElement()).name()));
+        parameters.add(Snippet.format(contributionFields.get(
+            bindingGraph.componentDescriptor().executorDependency().get()).name()));
+        parameters.addAll(getProducerDependencyParameters(
+            bindingGraph, binding.dependencies(), memberSelectSnippets));
+
+        return Snippet.format("new %s(%s)",
+            factoryNameForProductionBinding(binding),
+            Snippet.makeParametersSnippet(parameters));
       default:
         throw new AssertionError();
     }
@@ -667,8 +971,45 @@ private static Snippet initializeMembersInjectorForBinding(
       Iterable<DependencyRequest> dependencies,
       ImmutableMap<BindingKey, Snippet> memberSelectSnippets) {
     ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
-    for (BindingKey keys : SourceFiles.indexDependenciesByUnresolvedKey(dependencies).values()) {
-      parameters.add(memberSelectSnippets.get(keys));
+    for (Collection<DependencyRequest> requestsForKey :
+         SourceFiles.indexDependenciesByUnresolvedKey(dependencies).asMap().values()) {
+      BindingKey key = Iterables.getOnlyElement(FluentIterable.from(requestsForKey)
+          .transform(new Function<DependencyRequest, BindingKey>() {
+            @Override public BindingKey apply(DependencyRequest request) {
+              return BindingKey.forDependencyRequest(request);
+            }
+          })
+          .toSet());
+      parameters.add(memberSelectSnippets.get(key));
+    }
+    return parameters.build();
+  }
+
+  private static List<Snippet> getProducerDependencyParameters(
+      BindingGraph bindingGraph,
+      Iterable<DependencyRequest> dependencies,
+      ImmutableMap<BindingKey, Snippet> memberSelectSnippets) {
+    ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
+    for (Collection<DependencyRequest> requestsForKey :
+         SourceFiles.indexDependenciesByUnresolvedKey(dependencies).asMap().values()) {
+      BindingKey key = Iterables.getOnlyElement(FluentIterable.from(requestsForKey)
+          .transform(new Function<DependencyRequest, BindingKey>() {
+            @Override public BindingKey apply(DependencyRequest request) {
+              return BindingKey.forDependencyRequest(request);
+            }
+          }));
+      ResolvedBindings resolvedBindings = bindingGraph.resolvedBindings().get(key);
+      Class<?> frameworkClass =
+          DependencyRequestMapper.FOR_PRODUCER.getFrameworkClass(requestsForKey);
+      if (frameworkClassForResolvedBindings(resolvedBindings).equals(Provider.class)
+          && frameworkClass.equals(Producer.class)) {
+        parameters.add(Snippet.format(
+            "%s.producerFromProvider(%s)",
+            ClassName.fromClass(Producers.class),
+            memberSelectSnippets.get(key)));
+      } else {
+        parameters.add(memberSelectSnippets.get(key));
+      }
     }
     return parameters.build();
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 3e449e4fe..a298e8aff 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -15,13 +15,16 @@
  */
 package dagger.internal.codegen;
 
+import java.util.EnumSet;
+
+import javax.tools.Diagnostic;
+import java.util.Arrays;
 import com.google.auto.common.BasicAnnotationProcessor;
 import com.google.auto.service.AutoService;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import dagger.Module;
 import dagger.Provides;
-import dagger.internal.codegen.BindingGraphValidator.ScopeCycleValidation;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
 import java.util.Map;
@@ -33,7 +36,6 @@
 import javax.lang.model.SourceVersion;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
-
 import static javax.tools.Diagnostic.Kind.ERROR;
 
 /**
@@ -56,7 +58,7 @@ public SourceVersion getSupportedSourceVersion() {
 
   @Override
   public Set<String> getSupportedOptions() {
-    return ImmutableSet.of(DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY);
+    return ImmutableSet.of(DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY, NULLABLE_VALIDATION_KEY);
   }
 
   @Override
@@ -66,25 +68,37 @@ public SourceVersion getSupportedSourceVersion() {
     Elements elements = processingEnv.getElementUtils();
     Filer filer = processingEnv.getFiler();
 
+    Diagnostic.Kind nullableDiagnosticType =
+        nullableValidationType(processingEnv).diagnosticKind().get();
+
+    MethodSignatureFormatter methodSignatureFormatter = new MethodSignatureFormatter(types);
+    ProvisionBindingFormatter provisionBindingFormatter =
+        new ProvisionBindingFormatter(methodSignatureFormatter);
+    ProductionBindingFormatter productionBindingFormatter =
+        new ProductionBindingFormatter(methodSignatureFormatter);
+    DependencyRequestFormatter dependencyRequestFormatter = new DependencyRequestFormatter(types);
+    KeyFormatter keyFormatter = new KeyFormatter();
+
     InjectConstructorValidator injectConstructorValidator = new InjectConstructorValidator();
     InjectFieldValidator injectFieldValidator = new InjectFieldValidator();
     InjectMethodValidator injectMethodValidator = new InjectMethodValidator();
-    ModuleValidator moduleValidator = new ModuleValidator(types, Module.class, Provides.class);
+    ModuleValidator moduleValidator = new ModuleValidator(types, elements, methodSignatureFormatter,
+        Module.class, Provides.class);
     ProvidesMethodValidator providesMethodValidator = new ProvidesMethodValidator(elements);
-    ComponentValidator componentValidator = new ComponentValidator();
+    ComponentValidator componentValidator = new ComponentValidator(moduleValidator);
     MapKeyValidator mapKeyValidator = new MapKeyValidator();
-    ModuleValidator producerModuleValidator = new ModuleValidator(
-        types, ProducerModule.class, Produces.class);
+    ModuleValidator producerModuleValidator = new ModuleValidator(types, elements,
+        methodSignatureFormatter, ProducerModule.class, Produces.class);
     ProducesMethodValidator producesMethodValidator = new ProducesMethodValidator(elements);
     ProductionComponentValidator productionComponentValidator = new ProductionComponentValidator();
 
     Key.Factory keyFactory = new Key.Factory(types, elements);
 
     FactoryGenerator factoryGenerator =
-        new FactoryGenerator(filer, DependencyRequestMapper.FOR_PROVIDER);
+        new FactoryGenerator(filer, DependencyRequestMapper.FOR_PROVIDER, nullableDiagnosticType);
     MembersInjectorGenerator membersInjectorGenerator =
         new MembersInjectorGenerator(filer, elements, types, DependencyRequestMapper.FOR_PROVIDER);
-    ComponentGenerator componentGenerator = new ComponentGenerator(filer);
+    ComponentGenerator componentGenerator = new ComponentGenerator(filer, nullableDiagnosticType);
     ProducerFactoryGenerator producerFactoryGenerator =
         new ProducerFactoryGenerator(filer, DependencyRequestMapper.FOR_PRODUCER);
 
@@ -92,7 +106,7 @@ public SourceVersion getSupportedSourceVersion() {
     ProvisionBinding.Factory provisionBindingFactory =
         new ProvisionBinding.Factory(elements, types, keyFactory, dependencyRequestFactory);
     ProductionBinding.Factory productionBindingFactory =
-        new ProductionBinding.Factory(keyFactory, dependencyRequestFactory);
+        new ProductionBinding.Factory(types, keyFactory, dependencyRequestFactory);
 
     MembersInjectionBinding.Factory membersInjectionBindingFactory =
         new MembersInjectionBinding.Factory(elements, types, keyFactory, dependencyRequestFactory);
@@ -102,17 +116,23 @@ public SourceVersion getSupportedSourceVersion() {
         membersInjectionBindingFactory, membersInjectorGenerator);
 
     ComponentDescriptor.Factory componentDescriptorFactory =
-        new ComponentDescriptor.Factory(elements, types);
+        new ComponentDescriptor.Factory(elements);
 
     BindingGraph.Factory bindingGraphFactory = new BindingGraph.Factory(
         elements, types, injectBindingRegistry, keyFactory,
-        dependencyRequestFactory, provisionBindingFactory);
+        dependencyRequestFactory, provisionBindingFactory, productionBindingFactory);
 
     MapKeyGenerator mapKeyGenerator = new MapKeyGenerator(filer);
     BindingGraphValidator bindingGraphValidator = new BindingGraphValidator(
         types,
         injectBindingRegistry,
-        disableInterComponentScopeValidation(processingEnv));
+        scopeValidationType(processingEnv),
+        nullableDiagnosticType,
+        provisionBindingFormatter,
+        productionBindingFormatter,
+        methodSignatureFormatter,
+        dependencyRequestFormatter,
+        keyFormatter);
 
     return ImmutableList.<ProcessingStep>of(
         new MapKeyProcessingStep(
@@ -149,7 +169,10 @@ public SourceVersion getSupportedSourceVersion() {
         new ProductionComponentProcessingStep(
             messager,
             productionComponentValidator,
-            componentDescriptorFactory));
+            bindingGraphValidator,
+            componentDescriptorFactory,
+            bindingGraphFactory,
+            componentGenerator));
   }
 
   @Override
@@ -164,20 +187,39 @@ protected void postProcess() {
   private static final String DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY =
       "dagger.disableInterComponentScopeValidation";
 
-  private static ScopeCycleValidation disableInterComponentScopeValidation(
-      ProcessingEnvironment processingEnv) {
+  private static final String NULLABLE_VALIDATION_KEY =
+      "dagger.nullableValidation";
+
+  private static ValidationType scopeValidationType(ProcessingEnvironment processingEnv) {
+    return validationTypeFor(processingEnv,
+        DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY,
+        ValidationType.ERROR,
+        EnumSet.allOf(ValidationType.class));
+  }
+
+  private static ValidationType nullableValidationType(ProcessingEnvironment processingEnv) {
+    return validationTypeFor(processingEnv,
+        NULLABLE_VALIDATION_KEY,
+        ValidationType.ERROR,
+        EnumSet.of(ValidationType.ERROR, ValidationType.WARNING));
+  }
+
+  private static ValidationType validationTypeFor(ProcessingEnvironment processingEnv, String key,
+      ValidationType defaultValue, Set<ValidationType> validValues) {
     Map<String, String> options = processingEnv.getOptions();
-    if (options.containsKey(DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY)) {
+    if (options.containsKey(key)) {
       try {
-        return ScopeCycleValidation.valueOf(
-            options.get(DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY).toUpperCase());
+        ValidationType type = ValidationType.valueOf(options.get(key).toUpperCase());
+        if (!validValues.contains(type)) {
+          throw new IllegalArgumentException(); // let handler below print out good msg.
+        }
+        return type;
       } catch (IllegalArgumentException e) {
         processingEnv.getMessager().printMessage(ERROR, "Processor option -A"
-            + DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY
-            + " may only have the values ERROR, WARNING, or NONE (case insensitive) "
-            + " found: " + options.get(DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY));
+            + key + " may only have the values " + validValues
+            + " (case insensitive), found: " + options.get(key));
       }
     }
-    return ScopeCycleValidation.ERROR;
+    return defaultValue;
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
index 5e15022ed..ed99925e9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
@@ -15,18 +15,13 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreElements;
 import com.google.common.collect.ImmutableList;
 import dagger.Component;
-import dagger.Module;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.SimpleTypeVisitor6;
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
-import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
 import static javax.lang.model.element.ElementKind.CLASS;
 import static javax.lang.model.element.ElementKind.INTERFACE;
@@ -38,6 +33,12 @@
  * @author Gregory Kick
  */
 final class ComponentValidator implements Validator<TypeElement> {
+  private final ModuleValidator moduleValidator;
+  
+  ComponentValidator(ModuleValidator moduleValidator) {
+    this.moduleValidator = moduleValidator;
+  }
+  
   @Override public ValidationReport<TypeElement> validate(final TypeElement subject) {
     final ValidationReport.Builder<TypeElement> builder = ValidationReport.Builder.about(subject);
 
@@ -48,29 +49,7 @@
 
     AnnotationMirror componentMirror = getAnnotationMirror(subject, Component.class).get();
     ImmutableList<TypeMirror> moduleTypes = getComponentModules(componentMirror);
-
-    // TODO(gak): make unused modules an error
-    for (TypeMirror moduleType : moduleTypes) {
-      moduleType.accept(new SimpleTypeVisitor6<Void, Void>() {
-        @Override
-        protected Void defaultAction(TypeMirror mirror, Void p) {
-          builder.addItem(mirror + " is not a valid module type.", subject);
-          return null;
-        }
-
-        @Override
-        public Void visitDeclared(DeclaredType t, Void p) {
-          checkState(t.getTypeArguments().isEmpty());
-          TypeElement moduleElement = MoreElements.asType(t.asElement());
-          if (!getAnnotationMirror(moduleElement, Module.class).isPresent()) {
-            builder.addItem(moduleElement.getQualifiedName()
-                + " is listed as a module, but is not annotated with @Module", subject);
-          }
-          return null;
-        }
-      }, null);
-    }
-
+    moduleValidator.validateReferencedModules(subject, builder, moduleTypes);
     return builder.build();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
index f60e07f35..3a91a1e34 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -15,7 +15,10 @@
  */
 package dagger.internal.codegen;
 
+import javax.lang.model.type.DeclaredType;
+
 import com.google.auto.common.AnnotationMirrors;
+import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
@@ -28,6 +31,9 @@
 import dagger.Component;
 import dagger.MapKey;
 import dagger.Module;
+import dagger.Subcomponent;
+import dagger.producers.ProducerModule;
+import dagger.producers.ProductionComponent;
 import java.util.List;
 import java.util.Map;
 import java.util.Queue;
@@ -35,12 +41,16 @@
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
-
 import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.common.base.Preconditions.checkNotNull;
+
 /**
  * Utility methods related to dagger configuration annotations (e.g.: {@link Component}
  * and {@link Module}).
@@ -48,6 +58,12 @@
  * @author Gregory Kick
  */
 final class ConfigurationAnnotations {
+
+  static boolean isComponent(TypeElement componentDefinitionType) {
+    return MoreElements.isAnnotationPresent(componentDefinitionType, Component.class)
+        || MoreElements.isAnnotationPresent(componentDefinitionType, ProductionComponent.class);
+  }
+
   private static final String MODULES_ATTRIBUTE = "modules";
 
   static ImmutableList<TypeMirror> getComponentModules(AnnotationMirror componentAnnotation) {
@@ -79,6 +95,17 @@
   static ImmutableSet<? extends AnnotationMirror> getMapKeys(Element element) {
     return AnnotationMirrors.getAnnotatedAnnotations(element, MapKey.class);
   }
+  
+  /** Returns the first type that specifies this' nullability, or absent if none. */
+  static Optional<DeclaredType> getNullableType(Element element) {
+    List<? extends AnnotationMirror> mirrors = element.getAnnotationMirrors();
+    for (AnnotationMirror mirror : mirrors) {
+      if (mirror.getAnnotationType().asElement().getSimpleName().toString().equals("Nullable")) {
+        return Optional.of(mirror.getAnnotationType());
+      }
+    }
+    return Optional.absent();
+  }
 
   static ImmutableList<TypeMirror> convertClassArrayToListOfTypes(
       AnnotationMirror annotationMirror, final String elementName) {
@@ -98,16 +125,24 @@
    * is not annotated with {@link Module}, it is ignored.
    */
   static ImmutableMap<TypeElement, ImmutableSet<TypeElement>> getTransitiveModules(
-      Types types, ImmutableSet<TypeElement> seedModules) {
+      Types types, Elements elements, ImmutableSet<TypeElement> seedModules) {
+    TypeMirror objectType = elements.getTypeElement(Object.class.getCanonicalName()).asType();
     Queue<TypeElement> moduleQueue = Queues.newArrayDeque(seedModules);
     Map<TypeElement, ImmutableSet<TypeElement>> moduleElements = Maps.newLinkedHashMap();
     for (TypeElement moduleElement = moduleQueue.poll();
         moduleElement != null;
         moduleElement = moduleQueue.poll()) {
-      Optional<AnnotationMirror> moduleMirror = getAnnotationMirror(moduleElement, Module.class);
+      Optional<AnnotationMirror> moduleMirror = getAnnotationMirror(moduleElement, Module.class)
+          .or(getAnnotationMirror(moduleElement, ProducerModule.class));
       if (moduleMirror.isPresent()) {
-        ImmutableSet<TypeElement> moduleDependencies =
-            MoreTypes.asTypeElements(types, getModuleIncludes(moduleMirror.get()));
+        ImmutableSet.Builder<TypeElement> moduleDependenciesBuilder = ImmutableSet.builder();
+        moduleDependenciesBuilder.addAll(
+            MoreTypes.asTypeElements(getModuleIncludes(moduleMirror.get())));
+        // (note: we don't recurse on the parent class because we don't want the parent class as a
+        // root that the component depends on, and also because we want the dependencies rooted
+        // against this element, not the parent.)
+        addIncludesFromSuperclasses(types, moduleElement, moduleDependenciesBuilder, objectType);
+        ImmutableSet<TypeElement> moduleDependencies = moduleDependenciesBuilder.build();
         moduleElements.put(moduleElement, moduleDependencies);
         for (TypeElement dependencyType : moduleDependencies) {
           if (!moduleElements.containsKey(dependencyType)) {
@@ -119,5 +154,39 @@
     return ImmutableMap.copyOf(moduleElements);
   }
 
+  static boolean isSubcomponentType(TypeMirror type) {
+    return type.accept(new SubcomponentDetector(), null).isPresent();
+  }
+
+  private static final class SubcomponentDetector
+      extends SimpleTypeVisitor6<Optional<AnnotationMirror>, Void> {
+    @Override
+    protected Optional<AnnotationMirror> defaultAction(TypeMirror e, Void p) {
+      return Optional.absent();
+    }
+
+    @Override
+    public Optional<AnnotationMirror> visitDeclared(DeclaredType t, Void p) {
+      return MoreElements.getAnnotationMirror(t.asElement(), Subcomponent.class);
+    }
+  }
+
+  /** Traverses includes from superclasses and adds them into the builder. */
+  private static void addIncludesFromSuperclasses(Types types, TypeElement element,
+      ImmutableSet.Builder<TypeElement> builder, TypeMirror objectType) {
+    // Also add the superclass to the queue, in case any @Module definitions were on that.
+    TypeMirror superclass = element.getSuperclass();
+    while (!types.isSameType(objectType, superclass)
+        && superclass.getKind().equals(TypeKind.DECLARED)) {
+      element = MoreElements.asType(types.asElement(superclass));
+      Optional<AnnotationMirror> moduleMirror = getAnnotationMirror(element, Module.class)
+          .or(getAnnotationMirror(element, ProducerModule.class));
+      if (moduleMirror.isPresent()) {
+        builder.addAll(MoreTypes.asTypeElements(getModuleIncludes(moduleMirror.get())));
+      }
+      superclass = element.getSuperclass();
+    }
+  }
+
   private ConfigurationAnnotations() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index 688018fac..2a7c617d9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -15,11 +15,14 @@
  */
 package dagger.internal.codegen;
 
+import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Ordering;
 import java.util.EnumSet;
 import java.util.Set;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
@@ -46,13 +49,24 @@ boolean isMultibinding() {
   }
 
   abstract BindingType bindingType();
+  
+  /** Returns the type that specifies this' nullability, absent if not nullable. */
+  abstract Optional<DeclaredType> nullableType();
+
+  /**
+   * If this is a provision request from an {@code @Provides} or {@code @Produces} method, this will
+   * be the element that contributed it. In the case of subclassed modules, this may differ than the
+   * binding's enclosed element, as this will return the subclass whereas the enclosed element will
+   * be the superclass.
+   */
+  abstract Optional<TypeElement> contributedBy();
 
   /**
    * Returns the set of {@link BindingType} enum values implied by a given
    * {@link ContributionBinding} collection.
    */
   static <B extends ContributionBinding> ImmutableListMultimap<BindingType, B> bindingTypesFor(
-      Iterable<B> bindings) {
+      Iterable<? extends B> bindings) {
     ImmutableListMultimap.Builder<BindingType, B> builder =
         ImmutableListMultimap.builder();
     builder.orderKeysBy(Ordering.<BindingType>natural());
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index 68c2a6a18..bce63acc0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -15,12 +15,15 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreTypes;
+
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
+import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Lazy;
 import dagger.MembersInjector;
 import dagger.Provides;
@@ -36,7 +39,6 @@
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
-
 import static com.google.auto.common.MoreTypes.isTypeOf;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
@@ -65,11 +67,25 @@
     PRODUCER,
     /** A request for a {@link Produced}.  E.g.: {@code Produced<Blah>} */
     PRODUCED,
+    /**
+     * A request for a {@link ListenableFuture}.  E.g.: {@code ListenableFuture<Blah>}.
+     * These can only be requested by component interfaces.
+     */
+    FUTURE,
   }
 
   abstract Kind kind();
   abstract Key key();
   abstract Element requestElement();
+  
+  /**
+   * Returns the possibly resolved type that contained the requesting element. For members injection
+   * requests, this is the type itself.
+   */
+  abstract DeclaredType enclosingType();
+  
+  /** Returns true if this request allows null objects. */
+  abstract boolean isNullable();
 
   static final class Factory {
     private final Key.Factory keyFactory;
@@ -78,12 +94,12 @@
       this.keyFactory = keyFactory;
     }
 
-    ImmutableSet<DependencyRequest> forRequiredResolvedVariables(
+    ImmutableSet<DependencyRequest> forRequiredResolvedVariables(DeclaredType container,
         List<? extends VariableElement> variables, List<? extends TypeMirror> resolvedTypes) {
       checkState(resolvedTypes.size() == variables.size());
       ImmutableSet.Builder<DependencyRequest> builder = ImmutableSet.builder();
       for (int i = 0; i < variables.size(); i++) {
-         builder.add(forRequiredResolvedVariable(variables.get(i), resolvedTypes.get(i)));
+        builder.add(forRequiredResolvedVariable(container, variables.get(i), resolvedTypes.get(i)));
       }
       return builder.build();
     }
@@ -107,22 +123,26 @@
     DependencyRequest forImplicitMapBinding(DependencyRequest delegatingRequest, Key delegateKey) {
       checkNotNull(delegatingRequest);
       return new AutoValue_DependencyRequest(Kind.PROVIDER, delegateKey,
-          delegatingRequest.requestElement());
+          delegatingRequest.requestElement(),
+          MoreTypes.asDeclared(delegatingRequest.requestElement().getEnclosingElement().asType()),
+          false /* doesn't allow null */);
     }
 
     DependencyRequest forRequiredVariable(VariableElement variableElement) {
       checkNotNull(variableElement);
       TypeMirror type = variableElement.asType();
       Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(variableElement);
-      return newDependencyRequest(variableElement, type, qualifier);
+      return newDependencyRequest(variableElement, type, qualifier, MoreTypes.asDeclared(
+          variableElement.getEnclosingElement().getEnclosingElement().asType()));
     }
 
-    DependencyRequest forRequiredResolvedVariable(VariableElement variableElement,
+    DependencyRequest forRequiredResolvedVariable(DeclaredType container,
+        VariableElement variableElement,
         TypeMirror resolvedType) {
       checkNotNull(variableElement);
       checkNotNull(resolvedType);
       Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(variableElement);
-      return newDependencyRequest(variableElement, resolvedType, qualifier);
+      return newDependencyRequest(variableElement, resolvedType, qualifier, container);
     }
 
     DependencyRequest forComponentProvisionMethod(ExecutableElement provisionMethod) {
@@ -131,7 +151,31 @@ DependencyRequest forComponentProvisionMethod(ExecutableElement provisionMethod)
           "Component provision methods must be empty: " + provisionMethod);
       TypeMirror type = provisionMethod.getReturnType();
       Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(provisionMethod);
-      return newDependencyRequest(provisionMethod, type, qualifier);
+      return newDependencyRequest(provisionMethod, type, qualifier,
+          MoreTypes.asDeclared(provisionMethod.getEnclosingElement().asType()));
+    }
+
+    DependencyRequest forComponentProductionMethod(ExecutableElement productionMethod) {
+      checkNotNull(productionMethod);
+      checkArgument(productionMethod.getParameters().isEmpty(),
+          "Component production methods must be empty: %s", productionMethod);
+      TypeMirror type = productionMethod.getReturnType();
+      Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(productionMethod);
+      DeclaredType container =
+          MoreTypes.asDeclared(productionMethod.getEnclosingElement().asType());
+      // Only a component production method can be a request for a ListenableFuture, so we
+      // special-case it here.
+      if (isTypeOf(ListenableFuture.class, type)) {
+        return new AutoValue_DependencyRequest(
+            Kind.FUTURE,
+            keyFactory.forQualifiedType(qualifier,
+                Iterables.getOnlyElement(((DeclaredType) type).getTypeArguments())),
+            productionMethod,
+            container,
+            false /* doesn't allow null */);
+      } else {
+        return newDependencyRequest(productionMethod, type, qualifier, container);
+      }
     }
 
     DependencyRequest forComponentMembersInjectionMethod(ExecutableElement membersInjectionMethod) {
@@ -142,32 +186,43 @@ DependencyRequest forComponentMembersInjectionMethod(ExecutableElement membersIn
       return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR,
           keyFactory.forMembersInjectedType(
               Iterables.getOnlyElement(membersInjectionMethod.getParameters()).asType()),
-          membersInjectionMethod);
+          membersInjectionMethod,
+          MoreTypes.asDeclared(membersInjectionMethod.getEnclosingElement().asType()),
+          false /* doesn't allow null */);
     }
 
     DependencyRequest forMembersInjectedType(DeclaredType type) {
       return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR,
           keyFactory.forMembersInjectedType(type),
-          type.asElement());
+          type.asElement(),
+          type,
+          false /* doesn't allow null */);
     }
 
-    private DependencyRequest newDependencyRequest(Element requestElement, TypeMirror type,
-        Optional<AnnotationMirror> qualifier) {
+    private DependencyRequest newDependencyRequest(Element requestElement,
+        TypeMirror type, Optional<AnnotationMirror> qualifier, DeclaredType container) {
       KindAndType kindAndType = extractKindAndType(type);
-      if (kindAndType.kind() == Kind.MEMBERS_INJECTOR) {
+      if (kindAndType.kind().equals(Kind.MEMBERS_INJECTOR)) {
         checkArgument(!qualifier.isPresent());
       }
+      // Only instance types can be non-null -- all other requests are wrapped
+      // inside something (e.g, Provider, Lazy, etc..).
+      // TODO(sameb): should Produced/Producer always require non-nullable?
+      boolean allowsNull = !kindAndType.kind().equals(Kind.INSTANCE)
+          || ConfigurationAnnotations.getNullableType(requestElement).isPresent();
       return new AutoValue_DependencyRequest(kindAndType.kind(),
-            keyFactory.forQualifiedType(qualifier, kindAndType.type()),
-            requestElement);
+          keyFactory.forQualifiedType(qualifier, kindAndType.type()),
+          requestElement,
+          container,
+          allowsNull);
     }
-    
+
     @AutoValue
     static abstract class KindAndType {
       abstract Kind kind();
       abstract TypeMirror type();
     }
-    
+
     /**
      * Extracts the correct requesting type & kind out a request type. For example, if a user
      * requests Provider<Foo>, this will return Kind.PROVIDER with "Foo".
@@ -180,19 +235,19 @@ static KindAndType extractKindAndType(TypeMirror type) {
         return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.INSTANCE, type);
       } else if (isTypeOf(Provider.class, type)) {
         return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.PROVIDER,
-            Iterables.getOnlyElement(((DeclaredType)type).getTypeArguments()));
+            Iterables.getOnlyElement(((DeclaredType) type).getTypeArguments()));
       } else if (isTypeOf(Lazy.class, type)) {
         return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.LAZY,
-            Iterables.getOnlyElement(((DeclaredType)type).getTypeArguments()));
+            Iterables.getOnlyElement(((DeclaredType) type).getTypeArguments()));
       } else if (isTypeOf(MembersInjector.class, type)) {
         return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.MEMBERS_INJECTOR,
-            Iterables.getOnlyElement(((DeclaredType)type).getTypeArguments()));
+            Iterables.getOnlyElement(((DeclaredType) type).getTypeArguments()));
       } else if (isTypeOf(Producer.class, type)) {
         return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.PRODUCER,
-            Iterables.getOnlyElement(((DeclaredType)type).getTypeArguments()));
+            Iterables.getOnlyElement(((DeclaredType) type).getTypeArguments()));
       } else if (isTypeOf(Produced.class, type)) {
         return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.PRODUCED,
-            Iterables.getOnlyElement(((DeclaredType)type).getTypeArguments()));
+            Iterables.getOnlyElement(((DeclaredType) type).getTypeArguments()));
       } else {
         return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.INSTANCE, type);
       }
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
index fa36084ee..dd97665df 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
@@ -16,17 +16,21 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
 import com.google.common.base.Optional;
-import com.google.common.collect.Queues;
-import java.util.Deque;
+import java.util.List;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.SimpleElementVisitor6;
+import javax.lang.model.util.Types;
 
+import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.ErrorMessages.INDENT;
 
@@ -38,10 +42,10 @@
  * @since 2.0
  */
 final class DependencyRequestFormatter extends Formatter<DependencyRequest> {
-  private static final DependencyRequestFormatter INSTANCE = new DependencyRequestFormatter();
+  private final Types types;
 
-  static DependencyRequestFormatter instance() {
-    return INSTANCE;
+  DependencyRequestFormatter(Types types) {
+    this.types = types;
   }
 
   // TODO(user): Sweep this class for TypeMirror.toString() usage and do some preventive format.
@@ -58,7 +62,7 @@ static DependencyRequestFormatter instance() {
         if (method.getParameters().isEmpty()) {
           // some.package.name.MyComponent.myMethod()
           //     [component method with return type: @other.package.Qualifier some.package.name.Foo]
-          appendMember(method, builder).append("()\n")
+          appendEnclosingTypeAndMemberName(method, builder).append("()\n")
               .append(INDENT).append(INDENT).append("[component method with return type: ");
           if (qualifier.isPresent()) {
             // TODO(user) use chenying's annotation mirror stringifier
@@ -69,8 +73,8 @@ static DependencyRequestFormatter instance() {
           // some.package.name.MyComponent.myMethod(some.package.name.Foo foo)
           //     [component injection method for type: some.package.name.Foo]
           VariableElement componentMethodParameter = getOnlyElement(method.getParameters());
-          appendMember(method, builder).append("(");
-          appendParameter(componentMethodParameter, builder);
+          appendEnclosingTypeAndMemberName(method, builder).append("(");
+          appendParameter(componentMethodParameter, componentMethodParameter.asType(), builder);
           builder.append(")\n");
           builder.append(INDENT).append(INDENT).append("[component injection method for type: ")
               .append(componentMethodParameter.asType())
@@ -83,38 +87,47 @@ static DependencyRequestFormatter instance() {
       @Override public String visitVariable(
           VariableElement variable, Optional<AnnotationMirror> qualifier) {
         StringBuilder builder = new StringBuilder(INDENT);
+        TypeMirror resolvedVariableType =
+            MoreTypes.asMemberOf(types, request.enclosingType(), variable);
         if (variable.getKind().equals(ElementKind.PARAMETER)) {
           // some.package.name.MyClass.myMethod(some.package.name.Foo arg0, some.package.Bar arg1)
           //     [parameter: @other.package.Qualifier some.package.name.Foo arg0]
           ExecutableElement methodOrConstructor =
               MoreElements.asExecutable(variable.getEnclosingElement());
-          appendMember(methodOrConstructor, builder).append('(');
-          Deque<VariableElement> parameters =
-              Queues.newArrayDeque(methodOrConstructor.getParameters());
-          if (!parameters.isEmpty()) {
-            appendParameter(parameters.poll(), builder);
-          }
-          for(VariableElement current : parameters) {
-            appendParameter(current, builder.append(", "));
+          ExecutableType resolvedMethodOrConstructor = MoreTypes.asExecutable(
+              types.asMemberOf(request.enclosingType(), methodOrConstructor));
+          appendEnclosingTypeAndMemberName(methodOrConstructor, builder).append('(');
+          List<? extends VariableElement> parameters = methodOrConstructor.getParameters();
+          List<? extends TypeMirror> parameterTypes =
+              resolvedMethodOrConstructor.getParameterTypes();
+          checkState(parameters.size() == parameterTypes.size());
+          for (int i = 0; i < parameters.size(); i++) {
+            appendParameter(parameters.get(i), parameterTypes.get(i), builder);
+            if (i != parameters.size() - 1) {
+              builder.append(", ");
+            }
           }
           builder.append(")\n").append(INDENT).append(INDENT).append("[parameter: ");
         } else {
           // some.package.name.MyClass.myField
           //     [injected field of type: @other.package.Qualifier some.package.name.Foo myField]
-          appendMember(variable, builder).append("()\n")
+          appendEnclosingTypeAndMemberName(variable, builder).append("\n")
               .append(INDENT).append(INDENT).append("[injected field of type: ");
         }
         if (qualifier.isPresent()) {
           // TODO(user) use chenying's annotation mirror stringifier
           builder.append(qualifier.get()).append(' ');
         }
-        builder.append(variable.asType()).append(' ').append(variable.getSimpleName()).append(']');
+        builder.append(resolvedVariableType)
+            .append(' ')
+            .append(variable.getSimpleName())
+            .append(']');
         return builder.toString();
       }
 
       @Override
       public String visitType(TypeElement e, Optional<AnnotationMirror> p) {
-        return INDENT + e.getQualifiedName();
+        return ""; // types by themselves provide no useful information.
       }
 
       @Override protected String defaultAction(Element element, Optional<AnnotationMirror> ignore) {
@@ -124,11 +137,12 @@ public String visitType(TypeElement e, Optional<AnnotationMirror> p) {
     }, qualifier);
   }
 
-  private StringBuilder appendParameter(VariableElement parameter, StringBuilder builder) {
-    return builder.append(parameter.asType()).append(' ').append(parameter.getSimpleName());
+  private StringBuilder appendParameter(VariableElement parameter, TypeMirror type,
+      StringBuilder builder) {
+    return builder.append(type).append(' ').append(parameter.getSimpleName());
   }
 
-  private StringBuilder appendMember(Element member, StringBuilder builder) {
+  private StringBuilder appendEnclosingTypeAndMemberName(Element member, StringBuilder builder) {
     TypeElement type = MoreElements.asType(member.getEnclosingElement());
     return builder.append(type.getQualifiedName())
         .append('.')
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestMapper.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestMapper.java
index c0deb49b2..1dc48fc8b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestMapper.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestMapper.java
@@ -15,10 +15,15 @@
  */
 package dagger.internal.codegen;
 
+import com.google.common.base.Function;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableSet;
 import dagger.MembersInjector;
 import dagger.producers.Producer;
 import javax.inject.Provider;
 
+import static com.google.common.collect.Iterables.getOnlyElement;
+
 /**
  * A mapper for associating a {@link DependencyRequest} to a framework class, dependent on
  * the type of code to be generated (e.g., for {@link Provider} or {@link Producer}).
@@ -29,6 +34,27 @@
 abstract class DependencyRequestMapper {
   abstract Class<?> getFrameworkClass(DependencyRequest request);
 
+  /**
+   * Returns the framework class to use for a collection of requests of the same {@link BindingKey}.
+   * This allows factories to only take a single argument for multiple requests of the same key.
+   */
+  Class<?> getFrameworkClass(Iterable<DependencyRequest> requests) {
+    ImmutableSet<Class<?>> classes = FluentIterable.from(requests)
+        .transform(new Function<DependencyRequest, Class<?>>() {
+          @Override public Class<?> apply(DependencyRequest request) {
+            return getFrameworkClass(request);
+          }
+        })
+        .toSet();
+    if (classes.size() == 1) {
+      return getOnlyElement(classes);
+    } else if (classes.equals(ImmutableSet.of(Producer.class, Provider.class))) {
+      return Provider.class;
+    } else {
+      throw new IllegalStateException("Bad set of framework classes: " + classes);
+    }
+  }
+
   private static final class MapperForProvider extends DependencyRequestMapper {
     @Override public Class<?> getFrameworkClass(DependencyRequest request) {
       switch (request.kind()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index e76a01709..2518beddc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -140,6 +140,24 @@
   static final String BINDING_METHOD_WITH_SAME_NAME =
       "Cannot have more than one @%s method with the same name in a single module";
 
+  static final String MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT =
+      "Modules with type parameters must be abstract";
+
+  static final String REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT =
+      "%s is listed as a module, but is abstract";
+
+  static final String REFERENCED_MODULE_NOT_ANNOTATED =
+      "%s is listed as a module, but is not annotated with @%s";
+
+  static final String REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS =
+      "%s is listed as a module, but has type parameters";
+
+  static final String PROVIDES_METHOD_OVERRIDES_ANOTHER =
+      "@%s methods may not override another method. Overrides: %s";
+
+  static final String METHOD_OVERRIDES_PROVIDES_METHOD =
+      "@%s methods may not be overridden in modules. Overrides: %s";
+
   /*mapKey errors*/
   static final String MAPKEY_WITHOUT_FIELDS =
       "Map key annotation does not have fields";
@@ -151,20 +169,48 @@
   static final String MULTIPLE_BINDING_TYPES_FOR_KEY_FORMAT =
       "%s has incompatible bindings:\n";
 
+  static final String PROVIDER_ENTRY_POINT_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT =
+      "%s is a provision entry-point, which cannot depend on a production.";
+
+  static final String PROVIDER_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT =
+      "%s is a provision, which cannot depend on a production.";
+
   static final String REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT =
       "%s cannot be provided without an @Inject constructor or from an @Provides-annotated method.";
 
   static final String REQUIRES_PROVIDER_FORMAT =
       "%s cannot be provided without an @Provides-annotated method.";
 
+  static final String REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_OR_PRODUCER_FORMAT =
+      "%s cannot be provided without an @Inject constructor or from an @Provides- or "
+      + "@Produces-annotated method.";
+
+  static final String REQUIRES_PROVIDER_OR_PRODUCER_FORMAT =
+      "%s cannot be provided without an @Provides- or @Produces-annotated method.";
+
   static final String MEMBERS_INJECTION_DOES_NOT_IMPLY_PROVISION =
       "This type supports members injection but cannot be implicitly provided.";
 
+  static final String MEMBERS_INJECTION_WITH_RAW_TYPE =
+      "%s has type parameters, cannot members inject the raw type.";
+
+  static final String MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE =
+      "Type parameters must be bounded for members injection.";
+
   static final String CONTAINS_DEPENDENCY_CYCLE_FORMAT = "%s.%s() contains a dependency cycle:\n%s";
 
   static final String MALFORMED_MODULE_METHOD_FORMAT =
       "Cannot generated a graph because method %s on module %s was malformed";
 
+  static final String NULLABLE_TO_NON_NULLABLE =
+      "%s is not nullable, but is being provided by %s";
+
+  static final String CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD =
+      "Cannot return null from a non-@Nullable component method";
+
+  static final String CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD =
+      "Cannot return null from a non-@Nullable @Provides method";
+
   /**
    * A regular expression to match a small list of specific packages deemed to
    * be unhelpful to display in fully qualified types in error messages.
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index ae441f95c..205a724b7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -33,6 +33,7 @@
 import dagger.internal.codegen.writer.MethodWriter;
 import dagger.internal.codegen.writer.ParameterizedTypeName;
 import dagger.internal.codegen.writer.Snippet;
+import dagger.internal.codegen.writer.StringLiteral;
 import dagger.internal.codegen.writer.TypeName;
 import dagger.internal.codegen.writer.TypeNames;
 import dagger.internal.codegen.writer.TypeVariableName;
@@ -47,10 +48,11 @@
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeParameterElement;
 import javax.lang.model.type.TypeMirror;
+import javax.tools.Diagnostic;
 
 import static com.google.common.base.Preconditions.checkState;
 import static dagger.Provides.Type.SET;
-import static dagger.internal.codegen.ProvisionBinding.Kind.INJECTION;
+import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD;
 import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
@@ -69,10 +71,13 @@
  */
 final class FactoryGenerator extends SourceFileGenerator<ProvisionBinding> {
   private final DependencyRequestMapper dependencyRequestMapper;
+  private final Diagnostic.Kind nullableValidationType;
 
-  FactoryGenerator(Filer filer, DependencyRequestMapper dependencyRequestMapper) {
+  FactoryGenerator(Filer filer, DependencyRequestMapper dependencyRequestMapper,
+      Diagnostic.Kind nullableValidationType) {
     super(filer);
     this.dependencyRequestMapper = dependencyRequestMapper;
+    this.nullableValidationType = nullableValidationType;
   }
 
   @Override
@@ -93,7 +98,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
   @Override
   ImmutableSet<JavaWriter> write(ClassName generatedTypeName, ProvisionBinding binding) {
     // We don't want to write out resolved bindings -- we want to write out the generic version.
-    checkState(!binding.isResolved());
+    checkState(!binding.hasNonDefaultTypeParameters());
 
     TypeMirror keyType = binding.provisionType().equals(Type.MAP)
         ? Util.getProvidedValueTypeOfMap(MoreTypes.asDeclared(binding.key().type()))
@@ -117,7 +122,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
         // since we'll be implementing an erased version of it.
         if (!typeParameters.isEmpty()) {
           factoryWriter.annotate(SuppressWarnings.class).setValue("rawtypes");
-          providedTypeName = ((ParameterizedTypeName)providedTypeName).type();
+          providedTypeName = ((ParameterizedTypeName) providedTypeName).type();
         }
         break;
       case CLASS_CONSTRUCTOR:
@@ -128,9 +133,9 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
         constructorWriter.get().addModifiers(PUBLIC);
         factoryWriter = classWriter;
         if (binding.bindingKind().equals(PROVISION)) {
-          factoryWriter.addField(binding.bindingTypeElement(), "module")
-              .addModifiers(PRIVATE, FINAL);
-          constructorWriter.get().addParameter(binding.bindingTypeElement(), "module");
+          TypeName enclosingType = TypeNames.forTypeMirror(binding.bindingTypeElement().asType());
+          factoryWriter.addField(enclosingType, "module").addModifiers(PRIVATE, FINAL);
+          constructorWriter.get().addParameter(enclosingType, "module");
           constructorWriter.get().body()
               .addSnippet("assert module != null;")
               .addSnippet("this.module = module;");
@@ -174,41 +179,45 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
           .addSnippet("this.%1$s = %1$s;", field.name());
     }
     
-    // If constructing a factory for @Inject bindings, we use a static create method
+    // If constructing a factory for @Inject or @Provides bindings, we use a static create method
     // so that generated components can avoid having to refer to the generic types
     // of the factory.  (Otherwise they may have visibility problems referring to the types.)
-    if (binding.bindingKind().equals(INJECTION)) {
-      // The return type is usually the same as the implementing type, except in the case
-      // of enums with type variables (where we cast).
-      TypeName returnType = ParameterizedTypeName.create(ClassName.fromClass(Factory.class),
-          TypeNames.forTypeMirror(keyType));
-      MethodWriter createMethodWriter = factoryWriter.addMethod(returnType, "create");
-      createMethodWriter.addTypeParameters(typeParameters);
-      createMethodWriter.addModifiers(Modifier.PUBLIC, Modifier.STATIC);
-      Map<String, TypeName> params = constructorWriter.isPresent()
-          ? constructorWriter.get().parameters() : ImmutableMap.<String, TypeName>of();
-      for (Map.Entry<String, TypeName> param : params.entrySet()) {
-        createMethodWriter.addParameter(param.getValue(), param.getKey());      
-      }
-      switch (binding.factoryCreationStrategy()) {
-        case ENUM_INSTANCE:
-          if (typeParameters.isEmpty()) {
-            createMethodWriter.body().addSnippet(" return INSTANCE;");
-          } else {
-            // We use an unsafe cast here because the types are different.
-            // It's safe because the type is never referenced anywhere.
-            createMethodWriter.annotate(SuppressWarnings.class).setValue("unchecked");
-            createMethodWriter.body().addSnippet(" return (Factory) INSTANCE;");
-          }
-          break;
-        case CLASS_CONSTRUCTOR:
-          createMethodWriter.body().addSnippet(" return new %s(%s);",
-              parameterizedFactoryNameForProvisionBinding(binding),
-              Joiner.on(", ").join(params.keySet()));
-          break;
-        default:
-          throw new AssertionError();
-      }
+    switch(binding.bindingKind()) {
+      case INJECTION:
+      case PROVISION:
+        // The return type is usually the same as the implementing type, except in the case
+        // of enums with type variables (where we cast).
+        TypeName returnType = ParameterizedTypeName.create(ClassName.fromClass(Factory.class),
+            TypeNames.forTypeMirror(keyType));
+        MethodWriter createMethodWriter = factoryWriter.addMethod(returnType, "create");
+        createMethodWriter.addTypeParameters(typeParameters);
+        createMethodWriter.addModifiers(Modifier.PUBLIC, Modifier.STATIC);
+        Map<String, TypeName> params = constructorWriter.isPresent()
+            ? constructorWriter.get().parameters() : ImmutableMap.<String, TypeName>of();
+        for (Map.Entry<String, TypeName> param : params.entrySet()) {
+          createMethodWriter.addParameter(param.getValue(), param.getKey());      
+        }
+        switch (binding.factoryCreationStrategy()) {
+          case ENUM_INSTANCE:
+            if (typeParameters.isEmpty()) {
+              createMethodWriter.body().addSnippet("return INSTANCE;");
+            } else {
+              // We use an unsafe cast here because the types are different.
+              // It's safe because the type is never referenced anywhere.
+              createMethodWriter.annotate(SuppressWarnings.class).setValue("unchecked");
+              createMethodWriter.body().addSnippet("return (Factory) INSTANCE;");
+            }
+            break;
+          case CLASS_CONSTRUCTOR:
+            createMethodWriter.body().addSnippet("return new %s(%s);",
+                parameterizedFactoryNameForProvisionBinding(binding),
+                Joiner.on(", ").join(params.keySet()));
+            break;
+          default:
+            throw new AssertionError();
+        }
+        break;
+      default: // do nothing.
     }
 
     List<Snippet> parameters = Lists.newArrayList();
@@ -225,10 +234,28 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
             ClassName.fromClass(Collections.class),
             binding.bindingElement().getSimpleName(),
             parametersSnippet);
-      } else {
+      } else if (binding.nullableType().isPresent()
+          || nullableValidationType.equals(Diagnostic.Kind.WARNING)) {
+        if (binding.nullableType().isPresent()) {
+          getMethodWriter.annotate(
+              (ClassName) TypeNames.forTypeMirror(binding.nullableType().get()));
+        }
         getMethodWriter.body().addSnippet("return module.%s(%s);",
             binding.bindingElement().getSimpleName(),
             parametersSnippet);
+      } else {
+        StringLiteral failMsg =
+            StringLiteral.forValue(CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
+        getMethodWriter.body().addSnippet(Snippet.format(Joiner.on('\n').join(
+            "%s provided = module.%s(%s);",
+            "if (provided == null) {",
+            "  throw new NullPointerException(%s);",
+            "}",
+            "return provided;"),
+            getMethodWriter.returnType(),
+            binding.bindingElement().getSimpleName(),
+            parametersSnippet,
+            failMsg));
       }
     } else if (binding.memberInjectionRequest().isPresent()) {
       getMethodWriter.body().addSnippet("%1$s instance = new %1$s(%2$s);",
diff --git a/compiler/src/main/java/dagger/internal/codegen/Formatter.java b/compiler/src/main/java/dagger/internal/codegen/Formatter.java
index 76a2facba..880b78705 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Formatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Formatter.java
@@ -37,7 +37,8 @@
    * conformity with the {@link Function}{@code <T, String>} contract, delegating
    * to {@link #format(Object)}.
    *
-   * @deprecated Override {@link #format(T)} instead.
+   * @deprecated Call {@link #format(T)} instead.  This method exists to make
+   * formatters easy to use when functions are required, but shouldn't be called directly.
    */
   @SuppressWarnings("javadoc")
   @Deprecated
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index 515eef6f9..e41f6e9cf 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -63,7 +63,7 @@
   private final MembersInjectionBinding.Factory membersInjectionBindingFactory;
   private final MembersInjectorGenerator membersInjectorGenerator;
 
-  final class BindingsCollection<B extends Binding & ResolvableBinding> {
+  final class BindingsCollection<B extends Binding> {
     private final Map<Key, B> bindingsByKey = Maps.newLinkedHashMap();
     private final Deque<B> bindingsRequiringGeneration = Queues.newArrayDeque();
     private final Set<B> materializedBindings = Sets.newLinkedHashSet();
@@ -72,7 +72,7 @@ void generateBindings(SourceFileGenerator<B> generator) throws SourceFileGenerat
       for (B binding = bindingsRequiringGeneration.poll();
           binding != null;
           binding = bindingsRequiringGeneration.poll()) {
-        checkState(!binding.isResolved());
+        checkState(!binding.hasNonDefaultTypeParameters());
         generator.generate(binding);
         materializedBindings.add(binding);
       }
@@ -116,7 +116,7 @@ void tryToGenerateBinding(B binding, ClassName factoryName, boolean explicit) {
     
     /** Returns true if the binding needs to be generated. */
     private boolean shouldGenerateBinding(B binding, ClassName factoryName) {
-      return !binding.isResolved()
+      return !binding.hasNonDefaultTypeParameters()
           && elements.getTypeElement(factoryName.canonicalName()) == null
           && !materializedBindings.contains(binding)
           && !bindingsRequiringGeneration.contains(binding);
@@ -127,7 +127,7 @@ private boolean shouldGenerateBinding(B binding, ClassName factoryName) {
     private void tryToCacheBinding(B binding) {
       // We only cache resolved bindings or unresolved bindings w/o type arguments.
       // Unresolved bindings w/ type arguments aren't valid for the object graph.
-      if (binding.isResolved()          
+      if (binding.hasNonDefaultTypeParameters()          
           || binding.bindingTypeElement().getTypeParameters().isEmpty()) {        
         Key key = binding.key();
         Binding previousValue = bindingsByKey.put(key, binding);
@@ -183,7 +183,7 @@ MembersInjectionBinding registerBinding(MembersInjectionBinding binding) {
   private ProvisionBinding registerBinding(ProvisionBinding binding, boolean explicit) {
     ClassName factoryName = SourceFiles.factoryNameForProvisionBinding(binding);
     provisionBindings.tryRegisterBinding(binding, factoryName, explicit);
-    if (binding.isResolved()) {
+    if (binding.hasNonDefaultTypeParameters()) {
       provisionBindings.tryToGenerateBinding(provisionBindingFactory.unresolve(binding),
           factoryName, explicit);
     }
@@ -202,13 +202,13 @@ private MembersInjectionBinding registerBinding(
       // empty members injection bindings are special and don't need source files.
       // so, we just pretend
       membersInjectionBindings.pretendBindingGenerated(binding, membersInjectorName);
-      if (binding.isResolved()) {
+      if (binding.hasNonDefaultTypeParameters()) {
         membersInjectionBindings.pretendBindingGenerated(
             membersInjectionBindingFactory.unresolve(binding), membersInjectorName);
       }
     } else {
       membersInjectionBindings.tryRegisterBinding(binding, membersInjectorName, explicit);
-      if (binding.isResolved()) {
+      if (binding.hasNonDefaultTypeParameters()) {
         membersInjectionBindings.tryToGenerateBinding(
             membersInjectionBindingFactory.unresolve(binding), membersInjectorName, explicit);
       }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 4f93eac26..9f48deaa1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -26,6 +26,7 @@
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.MapKey;
 import dagger.Provides;
+import dagger.producers.Producer;
 import dagger.producers.Produces;
 import java.util.Map;
 import java.util.Set;
@@ -37,6 +38,7 @@
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
@@ -172,6 +174,14 @@ private TypeElement getProviderElement() {
       return elements.getTypeElement(Provider.class.getCanonicalName());
     }
 
+    private TypeElement getProducerElement() {
+      return elements.getTypeElement(Producer.class.getCanonicalName());
+    }
+
+    private TypeElement getClassElement(Class<?> cls) {
+      return elements.getTypeElement(cls.getCanonicalName());
+    }
+
     Key forComponentMethod(ExecutableElement componentMethod) {
       checkNotNull(componentMethod);
       checkArgument(componentMethod.getKind().equals(METHOD));
@@ -181,12 +191,25 @@ Key forComponentMethod(ExecutableElement componentMethod) {
           MoreTypes.equivalence().wrap(returnType));
     }
 
-    Key forProvidesMethod(ExecutableElement e) {
+    Key forProductionComponentMethod(ExecutableElement componentMethod) {
+      checkNotNull(componentMethod);
+      checkArgument(componentMethod.getKind().equals(METHOD));
+      TypeMirror returnType = normalize(componentMethod.getReturnType());
+      TypeMirror keyType = returnType;
+      if (MoreTypes.isTypeOf(ListenableFuture.class, returnType)) {
+        keyType = Iterables.getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments());
+      }
+      return new AutoValue_Key(
+          wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(componentMethod)),
+          MoreTypes.equivalence().wrap(keyType));
+    }
+
+    Key forProvidesMethod(ExecutableType executableType, ExecutableElement e) {
       checkNotNull(e);
       checkArgument(e.getKind().equals(METHOD));
       Provides providesAnnotation = e.getAnnotation(Provides.class);
       checkArgument(providesAnnotation != null);
-      TypeMirror returnType = normalize(e.getReturnType());
+      TypeMirror returnType = normalize(executableType.getReturnType());
       switch (providesAnnotation.type()) {
         case UNIQUE:
           return new AutoValue_Key(
@@ -224,12 +247,12 @@ Key forProvidesMethod(ExecutableElement e) {
 
     // TODO(user): Reconcile this method with forProvidesMethod when Provides.Type and
     // Produces.Type are no longer different.
-    Key forProducesMethod(ExecutableElement e) {
+    Key forProducesMethod(ExecutableType executableType, ExecutableElement e) {
       checkNotNull(e);
       checkArgument(e.getKind().equals(METHOD));
       Produces producesAnnotation = e.getAnnotation(Produces.class);
       checkArgument(producesAnnotation != null);
-      TypeMirror returnType = normalize(e.getReturnType());
+      TypeMirror returnType = normalize(executableType.getReturnType());
       TypeMirror keyType = returnType;
       if (MoreTypes.isTypeOf(ListenableFuture.class, returnType)) {
         keyType = Iterables.getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments());
@@ -251,7 +274,7 @@ Key forProducesMethod(ExecutableElement e) {
           TypeElement keyTypeElement =
               mapKey.unwrapValue() ? Util.getKeyTypeElement(mapKeyAnnotation, elements)
                   : (TypeElement) mapKeyAnnotation.getAnnotationType().asElement();
-          TypeMirror valueType = types.getDeclaredType(getProviderElement(), keyType);
+          TypeMirror valueType = types.getDeclaredType(getProducerElement(), keyType);
           TypeMirror mapType =
               types.getDeclaredType(getMapElement(), keyTypeElement.asType(), valueType);
           return new AutoValue_Key(
@@ -299,13 +322,36 @@ Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
      * {@link Map}{@code <K, V>}, a key of {@code Map<K, Provider<V>>} will be returned.
      */
     Optional<Key> implicitMapProviderKeyFrom(Key possibleMapKey) {
+      return maybeWrapMapValue(possibleMapKey, Provider.class);
+    }
+
+    /**
+     * Optionally extract a {@link Key} for the underlying production binding(s) if such a
+     * valid key can be inferred from the given key.  Specifically, if the key represents a
+     * {@link Map}{@code <K, V>}, a key of {@code Map<K, Producer<V>>} will be returned.
+     */
+    Optional<Key> implicitMapProducerKeyFrom(Key possibleMapKey) {
+      return maybeWrapMapValue(possibleMapKey, Producer.class);
+    }
+
+    /**
+     * Returns a key of {@link Map}{@code <K, WrappingClass<V>>} if the input key represents a
+     * {@code Map<K, V>}.
+     */
+    private Optional<Key> maybeWrapMapValue(Key possibleMapKey, Class<?> wrappingClass) {
       if (MoreTypes.isTypeOf(Map.class, possibleMapKey.type())) {
         DeclaredType declaredMapType = MoreTypes.asDeclared(possibleMapKey.type());
         TypeMirror mapValueType = Util.getValueTypeOfMap(declaredMapType);
-        if (!MoreTypes.isTypeOf(Provider.class, mapValueType)) {
+        if (!MoreTypes.isTypeOf(wrappingClass, mapValueType)) {
           DeclaredType keyType = Util.getKeyTypeOfMap(declaredMapType);
-          DeclaredType providerType = types.getDeclaredType(getProviderElement(), mapValueType);
-          TypeMirror mapType = types.getDeclaredType(getMapElement(), keyType, providerType);
+          TypeElement wrappingElement = getClassElement(wrappingClass);
+          if (wrappingElement == null) {
+            // This target might not be compiled with Producers, so wrappingClass might not have an
+            // associated element.
+            return Optional.absent();
+          }
+          DeclaredType wrappedType = types.getDeclaredType(wrappingElement, mapValueType);
+          TypeMirror mapType = types.getDeclaredType(getMapElement(), keyType, wrappedType);
           return Optional.<Key>of(new AutoValue_Key(
               possibleMapKey.wrappedQualifier(),
               MoreTypes.equivalence().wrap(mapType)));
diff --git a/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java b/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
index 146d03c04..7e342876e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
@@ -22,11 +22,6 @@
  * @since 2.0
  */
 final class KeyFormatter extends Formatter<Key> {
-  private static final KeyFormatter INSTANCE = new KeyFormatter();
-
-  static KeyFormatter instance() {
-    return INSTANCE;
-  }
 
   @Override public String format(Key request) {
     StringBuilder builder = new StringBuilder();
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index bebbcf727..9868c661d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -52,7 +52,7 @@
  * @since 2.0
  */
 @AutoValue
-abstract class MembersInjectionBinding extends Binding implements ResolvableBinding {
+abstract class MembersInjectionBinding extends Binding {
   @Override abstract TypeElement bindingElement();
 
   /** The set of individual sites where {@link Inject} is applied. */
@@ -119,6 +119,7 @@ private InjectionSite injectionSiteForInjectMethod(ExecutableElement methodEleme
       return new AutoValue_MembersInjectionBinding_InjectionSite(InjectionSite.Kind.METHOD,
           methodElement,
           dependencyRequestFactory.forRequiredResolvedVariables(
+              containingType,
               methodElement.getParameters(),
               resolved.getParameterTypes()));
     }
@@ -131,25 +132,23 @@ private InjectionSite injectionSiteForInjectField(VariableElement fieldElement,
       TypeMirror resolved = types.asMemberOf(containingType, fieldElement);
       return new AutoValue_MembersInjectionBinding_InjectionSite(InjectionSite.Kind.FIELD,
           fieldElement,
-          ImmutableSet.of(
-              dependencyRequestFactory.forRequiredResolvedVariable(fieldElement, resolved)));
+          ImmutableSet.of(dependencyRequestFactory.forRequiredResolvedVariable(
+              containingType, fieldElement, resolved)));
     }
-    
-    
+
     /** Returns an unresolved version of this binding. */
     MembersInjectionBinding unresolve(MembersInjectionBinding binding) {
-      checkState(binding.isResolved());
+      checkState(binding.hasNonDefaultTypeParameters());
       DeclaredType unresolved = MoreTypes.asDeclared(binding.bindingElement().asType());
       return forInjectedType(unresolved, Optional.<TypeMirror>absent());
     }
 
     /**
      * Returns a MembersInjectionBinding for the given type. If {@code resolvedType} is present,
-     * this will return a {@link ResolvableBinding#isResolved() resolved} binding, with the key &
-     * type resolved to the given type (using {@link Types#asMemberOf(DeclaredType, Element)}).
+     * this will return a resolved binding, with the key & type resolved to the given type (using
+     * {@link Types#asMemberOf(DeclaredType, Element)}).
      */
     MembersInjectionBinding forInjectedType(DeclaredType type, Optional<TypeMirror> resolvedType) {
-      boolean isResolved = false;
       // If the class this is injecting has some type arguments, resolve everything.
       if (!type.getTypeArguments().isEmpty() && resolvedType.isPresent()) {
         DeclaredType resolved = MoreTypes.asDeclared(resolvedType.get());
@@ -158,9 +157,8 @@ MembersInjectionBinding forInjectedType(DeclaredType type, Optional<TypeMirror>
             "erased expected type: %s, erased actual type: %s",
             types.erasure(resolved), types.erasure(type));
         type = resolved;
-        isResolved = true;
       }
-      
+
       TypeElement typeElement = MoreElements.asType(type.asElement());
       final DeclaredType resolved = type;
       ImmutableSortedSet.Builder<InjectionSite> injectionSitesBuilder =
@@ -205,7 +203,6 @@ MembersInjectionBinding forInjectedType(DeclaredType type, Optional<TypeMirror>
 
       Key key = keyFactory.forMembersInjectedType(type);
       return new AutoValue_MembersInjectionBinding(
-          isResolved,
           key,
           dependencies,
           new ImmutableSet.Builder<DependencyRequest>()
@@ -213,6 +210,7 @@ MembersInjectionBinding forInjectedType(DeclaredType type, Optional<TypeMirror>
               .addAll(parentInjectorRequest.asSet())
               .build(),
           findBindingPackage(key),
+          hasNonDefaultTypeParameters(typeElement, key.type(), types),
           typeElement,
           injectionSites,
           parentInjectorRequest);
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index 061359121..642d6e966 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -106,7 +106,7 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
   @Override
   ImmutableSet<JavaWriter> write(ClassName generatedTypeName, MembersInjectionBinding binding) {
     // We don't want to write out resolved bindings -- we want to write out the generic version.
-    checkState(!binding.isResolved());
+    checkState(!binding.hasNonDefaultTypeParameters());
 
     TypeName injectedTypeName = TypeNames.forTypeMirror(binding.key().type());
     JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
diff --git a/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java b/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java
index b54205990..71ddfe6d6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java
@@ -24,8 +24,12 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Types;
 
+import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
 
 /**
@@ -35,15 +39,28 @@
  * @since 2.0
  */
 final class MethodSignatureFormatter extends Formatter<ExecutableElement> {
-  private static final MethodSignatureFormatter INSTANCE = new MethodSignatureFormatter();
+  private final Types types;
 
-  static MethodSignatureFormatter instance() {
-    return INSTANCE;
+  MethodSignatureFormatter(Types types) {
+    this.types = types;
   }
 
   @Override public String format(ExecutableElement method) {
+    return format(method, Optional.<DeclaredType>absent());
+  }
+
+  /**
+   * Formats an ExecutableElement as if it were contained within the container, if the container is
+   * present.
+   */
+  public String format(ExecutableElement method, Optional<DeclaredType> container) {
     StringBuilder builder = new StringBuilder();
     TypeElement type = MoreElements.asType(method.getEnclosingElement());
+    ExecutableType executableType = MoreTypes.asExecutable(method.asType());
+    if (container.isPresent()) {
+      executableType = MoreTypes.asExecutable(types.asMemberOf(container.get(), method));
+      type = MoreElements.asType(container.get().asElement());
+    }
 
     // TODO(user): AnnotationMirror formatter.
     List<? extends AnnotationMirror> annotations = method.getAnnotationMirrors();
@@ -57,29 +74,32 @@ static MethodSignatureFormatter instance() {
       }
       builder.append(' ');
     }
-    builder.append(nameOfType(method.getReturnType()));
+    builder.append(nameOfType(executableType.getReturnType()));
     builder.append(' ');
     builder.append(type.getQualifiedName());
     builder.append('.');
     builder.append(method.getSimpleName());
     builder.append('(');
+    checkState(method.getParameters().size() == executableType.getParameterTypes().size());
     Iterator<? extends VariableElement> parameters = method.getParameters().iterator();
+    Iterator<? extends TypeMirror> parameterTypes = executableType.getParameterTypes().iterator();
     for (int i = 0; parameters.hasNext(); i++) {
       if (i > 0) {
         builder.append(", ");
       }
-      appendParameter(builder, parameters.next());
+      appendParameter(builder, parameters.next(), parameterTypes.next());
     }
     builder.append(')');
     return builder.toString();
   }
 
-  private static void appendParameter(StringBuilder builder, VariableElement parameter) {
+  private static void appendParameter(StringBuilder builder, VariableElement parameter,
+      TypeMirror type) {
     Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(parameter);
     if (qualifier.isPresent()) {
       builder.append(ErrorMessages.format(qualifier.get())).append(' ');
     }
-    builder.append(nameOfType(parameter.asType()));
+    builder.append(nameOfType(type));
   }
 
   private static String nameOfType(TypeMirror type) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
index a7d06a6a6..423848868 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
@@ -113,7 +113,8 @@ public void process(SetMultimap<Class<? extends Annotation>, Element> elementsBy
               .transform(new Function<ExecutableElement, ProvisionBinding>() {
                 @Override
                 public ProvisionBinding apply(ExecutableElement providesMethod) {
-                  return provisionBindingFactory.forProvidesMethod(providesMethod);
+                  return provisionBindingFactory.forProvidesMethod(providesMethod,
+                      providesMethod.getEnclosingElement().asType());
                 }
               })
               .toSet();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
index 9c360e8b0..f30ef9133 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
@@ -15,24 +15,33 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreElements;
 import com.google.auto.common.Visibility;
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;
 import com.google.common.base.Predicate;
+import com.google.common.collect.ArrayListMultimap;
 import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableListMultimap;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ListMultimap;
+import com.google.common.collect.Sets;
 import dagger.Module;
 import dagger.producers.ProducerModule;
 import java.lang.annotation.Annotation;
 import java.util.Collection;
 import java.util.List;
 import java.util.Map.Entry;
+import java.util.Set;
+import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
@@ -42,6 +51,13 @@
 import static com.google.auto.common.Visibility.effectiveVisibilityOfElement;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleIncludes;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;
+import static dagger.internal.codegen.ErrorMessages.METHOD_OVERRIDES_PROVIDES_METHOD;
+import static dagger.internal.codegen.ErrorMessages.MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_OVERRIDES_ANOTHER;
+import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS;
+import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULE_NOT_ANNOTATED;
+import static javax.lang.model.element.Modifier.ABSTRACT;
 
 /**
  * A {@link Validator} for {@link Module}s or {@link ProducerModule}s.
@@ -51,43 +67,167 @@
  */
 final class ModuleValidator implements Validator<TypeElement> {
   private final Types types;
+  private final Elements elements;
   private final Class<? extends Annotation> moduleClass;
   private final Class<? extends Annotation> methodClass;
+  private final MethodSignatureFormatter methodSignatureFormatter;
 
   ModuleValidator(
       Types types,
+      Elements elements,
+      MethodSignatureFormatter methodSignatureFormatter,
       Class<? extends Annotation> moduleClass,
       Class<? extends Annotation> methodClass) {
     this.types = types;
+    this.elements = elements;
     this.moduleClass = moduleClass;
     this.methodClass = methodClass;
+    this.methodSignatureFormatter = methodSignatureFormatter;
   }
 
   @Override
-  public ValidationReport<TypeElement> validate(TypeElement subject) {
-    ValidationReport.Builder<TypeElement> builder = ValidationReport.Builder.about(subject);
-
-    validateModuleVisibility(subject, builder);
+  public ValidationReport<TypeElement> validate(final TypeElement subject) {
+    final ValidationReport.Builder<TypeElement> builder = ValidationReport.Builder.about(subject);
 
     List<ExecutableElement> moduleMethods = ElementFilter.methodsIn(subject.getEnclosedElements());
-    ImmutableListMultimap.Builder<String, ExecutableElement> bindingMethodsByName =
-        ImmutableListMultimap.builder();
+    ListMultimap<String, ExecutableElement> allMethodsByName = ArrayListMultimap.create();
+    ListMultimap<String, ExecutableElement> bindingMethodsByName = ArrayListMultimap.create();
     for (ExecutableElement moduleMethod : moduleMethods) {
       if (isAnnotationPresent(moduleMethod, methodClass)) {
         bindingMethodsByName.put(moduleMethod.getSimpleName().toString(), moduleMethod);
       }
+      allMethodsByName.put(moduleMethod.getSimpleName().toString(), moduleMethod);
     }
+      
+    validateModuleVisibility(subject, builder);
+    validateMethodsWithSameName(builder, bindingMethodsByName);
+    validateProvidesOverrides(subject, builder, allMethodsByName, bindingMethodsByName);
+    validateModifiers(subject, builder);    
+    validateReferencedModules(subject, builder);
+    
+    // TODO(gak): port the dagger 1 module validation?
+    return builder.build();
+  }
+
+  private void validateModifiers(TypeElement subject,
+      ValidationReport.Builder<TypeElement> builder) {    
+    // This coupled with the check for abstract modules in ComponentValidator guarantees that
+    // only modules without type parameters are referenced from @Component(modules={...}). 
+    if (!subject.getTypeParameters().isEmpty() && !subject.getModifiers().contains(ABSTRACT)) {
+      builder.addItem(MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT, subject);
+    }
+  }
+  
+  private void validateMethodsWithSameName(ValidationReport.Builder<TypeElement> builder,
+      ListMultimap<String, ExecutableElement> bindingMethodsByName) {
     for (Entry<String, Collection<ExecutableElement>> entry :
-        bindingMethodsByName.build().asMap().entrySet()) {
+        bindingMethodsByName.asMap().entrySet()) {
       if (entry.getValue().size() > 1) {
         for (ExecutableElement offendingMethod : entry.getValue()) {
           builder.addItem(String.format(BINDING_METHOD_WITH_SAME_NAME, methodClass.getSimpleName()),
               offendingMethod);
         }
       }
+    }    
+  }
+  
+  private void validateReferencedModules(final TypeElement subject,
+      final ValidationReport.Builder<TypeElement> builder) {
+    // Validate that all the modules we include are valid for inclusion.
+    AnnotationMirror mirror = getAnnotationMirror(subject, moduleClass).get();
+    ImmutableList<TypeMirror> includedTypes = getModuleIncludes(mirror);
+    validateReferencedModules(subject,  builder, includedTypes);
+  }
+  
+  /**
+   * Used by {@link ModuleValidator} & {@link ComponentValidator} to validate referenced modules.
+   */
+  void validateReferencedModules(final TypeElement subject,
+      final ValidationReport.Builder<TypeElement> builder,
+      ImmutableList<TypeMirror> includedTypes) {
+    for (TypeMirror includedType : includedTypes) {
+      includedType.accept(new SimpleTypeVisitor6<Void, Void>() {
+        @Override
+        protected Void defaultAction(TypeMirror mirror, Void p) {
+          builder.addItem(mirror + " is not a valid module type.", subject);
+          return null;
+        }
+
+        @Override
+        public Void visitDeclared(DeclaredType t, Void p) {
+          TypeElement element = MoreElements.asType(t.asElement()); 
+          if (!t.getTypeArguments().isEmpty()) {
+            builder.addItem(String.format(REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS,
+                element.getQualifiedName()), subject);
+          }
+          if (!getAnnotationMirror(element, moduleClass).isPresent()) {
+            builder.addItem(String.format(REFERENCED_MODULE_NOT_ANNOTATED,
+                element.getQualifiedName(), moduleClass.getSimpleName()), subject);
+          }
+          if (element.getModifiers().contains(ABSTRACT)) {
+            builder.addItem(String.format(REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT,
+                element.getQualifiedName()), subject);
+          }
+          return null;
+        }
+      }, null);
+    }
+  }
+  
+  private void validateProvidesOverrides(TypeElement subject,
+      ValidationReport.Builder<TypeElement> builder,
+      ListMultimap<String, ExecutableElement> allMethodsByName,
+      ListMultimap<String, ExecutableElement> bindingMethodsByName) { 
+    // For every @Provides method, confirm it overrides nothing *and* nothing overrides it.
+    // Consider the following hierarchy:
+    // class Parent {
+    //    @Provides Foo a() {}
+    //    @Provides Foo b() {}
+    //    Foo c() {}
+    // }
+    // class Child extends Parent {
+    //    @Provides Foo a() {}
+    //    Foo b() {}
+    //    @Provides Foo c() {}
+    // }
+    // In each of those cases, we want to fail.  "a" is clear, "b" because Child is overriding
+    // a method marked @Provides in Parent, and "c" because Child is defining an @Provides
+    // method that overrides Parent.
+    TypeElement currentClass = subject;
+    TypeMirror objectType = elements.getTypeElement(Object.class.getCanonicalName()).asType();
+    // We keep track of methods that failed so we don't spam with multiple failures.
+    Set<ExecutableElement> failedMethods = Sets.newHashSet();
+    while (!types.isSameType(currentClass.getSuperclass(), objectType)) {
+      currentClass = MoreElements.asType(types.asElement(currentClass.getSuperclass()));
+      List<ExecutableElement> superclassMethods =
+          ElementFilter.methodsIn(currentClass.getEnclosedElements());
+      for (ExecutableElement superclassMethod : superclassMethods) {
+        String name = superclassMethod.getSimpleName().toString();
+        // For each method in the superclass, confirm our @Provides methods don't override it
+        for (ExecutableElement providesMethod : bindingMethodsByName.get(name)) {
+          if (!failedMethods.contains(providesMethod)
+              && elements.overrides(providesMethod, superclassMethod, subject)) {
+            failedMethods.add(providesMethod);
+            builder.addItem(String.format(PROVIDES_METHOD_OVERRIDES_ANOTHER,
+                methodClass.getSimpleName(), methodSignatureFormatter.format(superclassMethod)),
+                providesMethod);
+          }
+        }
+        // For each @Provides method in superclass, confirm our methods don't override it.
+        if (isAnnotationPresent(superclassMethod, methodClass)) {
+          for (ExecutableElement method : allMethodsByName.get(name)) {
+            if (!failedMethods.contains(method)
+                && elements.overrides(method, superclassMethod, subject)) {
+              failedMethods.add(method);
+              builder.addItem(String.format(METHOD_OVERRIDES_PROVIDES_METHOD,
+                  methodClass.getSimpleName(), methodSignatureFormatter.format(superclassMethod)),
+                  method);
+            }
+          }
+        }
+        allMethodsByName.put(superclassMethod.getSimpleName().toString(), superclassMethod);
+      }
     }
-    // TODO(gak): port the dagger 1 module validation?
-    return builder.build();
   }
 
   private void validateModuleVisibility(final TypeElement moduleElement,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java
index 9fd3161a3..3e7d81dc6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java
@@ -116,7 +116,8 @@ public void process(SetMultimap<Class<? extends Annotation>, Element> elementsBy
                 .transform(new Function<ExecutableElement, ProductionBinding>() {
                   @Override
                   public ProductionBinding apply(ExecutableElement producesMethod) {
-                    return productionBindingFactory.forProducesMethod(producesMethod);
+                    return productionBindingFactory.forProducesMethod(producesMethod,
+                        producesMethod.getEnclosingElement().asType());
                   }
                 })
                 .toSet();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index 0a8e946ec..f92bf94c0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -17,12 +17,18 @@
 
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
+import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Produces;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Types;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
@@ -47,6 +53,11 @@
     IMMEDIATE,
     /** Represents a binding configured by {@link Produces} that returns a future. */
     FUTURE_PRODUCTION,
+    /**
+     * Represents a binding from a production method on a component dependency that returns a
+     * future. Methods that return immediate values are considered provision bindings.
+     */
+    COMPONENT_PRODUCTION,
   }
 
   /**
@@ -77,22 +88,35 @@ BindingType bindingType() {
   }
 
   static final class Factory {
+    private final Types types;
     private final Key.Factory keyFactory;
     private final DependencyRequest.Factory dependencyRequestFactory;
 
-    Factory(Key.Factory keyFactory, DependencyRequest.Factory dependencyRequestFactory) {
+    Factory(Types types,
+        Key.Factory keyFactory,
+        DependencyRequest.Factory
+        dependencyRequestFactory) {
+      this.types = types;
       this.keyFactory = keyFactory;
       this.dependencyRequestFactory = dependencyRequestFactory;
     }
 
-    ProductionBinding forProducesMethod(ExecutableElement producesMethod) {
+    ProductionBinding forProducesMethod(
+        ExecutableElement producesMethod, TypeMirror contributedBy) {
       checkNotNull(producesMethod);
       checkArgument(producesMethod.getKind().equals(METHOD));
+      checkArgument(contributedBy.getKind().equals(TypeKind.DECLARED));
       Produces producesAnnotation = producesMethod.getAnnotation(Produces.class);
       checkArgument(producesAnnotation != null);
-      Key key = keyFactory.forProducesMethod(producesMethod);
+      DeclaredType declaredContainer = MoreTypes.asDeclared(contributedBy);
+      ExecutableType resolvedMethod =
+          MoreTypes.asExecutable(types.asMemberOf(declaredContainer, producesMethod));
+      Key key = keyFactory.forProducesMethod(resolvedMethod, producesMethod);
       ImmutableSet<DependencyRequest> dependencies =
-          dependencyRequestFactory.forRequiredVariables(producesMethod.getParameters());
+          dependencyRequestFactory.forRequiredResolvedVariables(
+              declaredContainer,
+              producesMethod.getParameters(),
+              resolvedMethod.getParameterTypes());
       Kind kind = MoreTypes.isTypeOf(ListenableFuture.class, producesMethod.getReturnType())
           ? Kind.FUTURE_PRODUCTION
           : Kind.IMMEDIATE;
@@ -101,9 +125,48 @@ ProductionBinding forProducesMethod(ExecutableElement producesMethod) {
           producesMethod,
           dependencies,
           findBindingPackage(key),
+          false,
+          ConfigurationAnnotations.getNullableType(producesMethod),
+          Optional.of(MoreTypes.asTypeElement(declaredContainer)),
           kind,
           producesAnnotation.type(),
           ImmutableList.copyOf(producesMethod.getThrownTypes()));
     }
+
+    ProductionBinding forImplicitMapBinding(DependencyRequest explicitRequest,
+        DependencyRequest implicitRequest) {
+      checkNotNull(explicitRequest);
+      checkNotNull(implicitRequest);
+      ImmutableSet<DependencyRequest> dependencies = ImmutableSet.of(implicitRequest);
+      return new AutoValue_ProductionBinding(
+          explicitRequest.key(),
+          implicitRequest.requestElement(),
+          dependencies,
+          findBindingPackage(explicitRequest.key()),
+          false,
+          Optional.<DeclaredType>absent(),
+          Optional.<TypeElement>absent(),
+          Kind.FUTURE_PRODUCTION,
+          Produces.Type.MAP,
+          ImmutableList.<TypeMirror>of());
+    }
+
+    ProductionBinding forComponentMethod(ExecutableElement componentMethod) {
+      checkNotNull(componentMethod);
+      checkArgument(componentMethod.getKind().equals(METHOD));
+      checkArgument(componentMethod.getParameters().isEmpty());
+      checkArgument(MoreTypes.isTypeOf(ListenableFuture.class, componentMethod.getReturnType()));
+      return new AutoValue_ProductionBinding(
+          keyFactory.forProductionComponentMethod(componentMethod),
+          componentMethod,
+          ImmutableSet.<DependencyRequest>of(),
+          Optional.<String>absent(),
+          false,
+          Optional.<DeclaredType>absent(),
+          Optional.<TypeElement>absent(),
+          Kind.COMPONENT_PRODUCTION,
+          Produces.Type.UNIQUE,
+          ImmutableList.copyOf(componentMethod.getThrownTypes()));
+    }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBindingFormatter.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBindingFormatter.java
new file mode 100644
index 000000000..e7e7e778a
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBindingFormatter.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Optional;
+
+import static com.google.auto.common.MoreElements.asExecutable;
+import static com.google.auto.common.MoreTypes.asDeclared;
+
+/**
+ * Formats a {@link ProductionBinding} into a {@link String} suitable for use in error messages.
+ *
+ * @author Jesse Beder
+ * @since 2.0
+ */
+final class ProductionBindingFormatter extends Formatter<ProductionBinding> {
+  private final MethodSignatureFormatter methodSignatureFormatter;
+
+  ProductionBindingFormatter(MethodSignatureFormatter methodSignatureFormatter) {
+    this.methodSignatureFormatter = methodSignatureFormatter;
+  }
+
+  @Override public String format(ProductionBinding binding) {
+    switch (binding.bindingKind()) {
+      case IMMEDIATE:
+      case FUTURE_PRODUCTION:
+        return methodSignatureFormatter.format(asExecutable(binding.bindingElement()),
+            Optional.of(asDeclared(binding.contributedBy().get().asType())));
+      case COMPONENT_PRODUCTION:
+        return methodSignatureFormatter.format(asExecutable(binding.bindingElement()));
+      default:
+        throw new UnsupportedOperationException(
+            "Not yet supporting " + binding.bindingKind() + " binding types.");
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java
index 7e2c667d3..187cecd73 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java
@@ -35,15 +35,24 @@
 final class ProductionComponentProcessingStep implements ProcessingStep {
   private final Messager messager;
   private final ProductionComponentValidator componentValidator;
+  private final BindingGraphValidator bindingGraphValidator;
   private final ComponentDescriptor.Factory componentDescriptorFactory;
+  private final BindingGraph.Factory bindingGraphFactory;
+  private final ComponentGenerator componentGenerator;
 
   ProductionComponentProcessingStep(
       Messager messager,
       ProductionComponentValidator componentValidator,
-      ComponentDescriptor.Factory componentDescriptorFactory) {
+      BindingGraphValidator bindingGraphValidator,
+      ComponentDescriptor.Factory componentDescriptorFactory,
+      BindingGraph.Factory bindingGraphFactory,
+      ComponentGenerator componentGenerator) {
     this.messager = messager;
     this.componentValidator = componentValidator;
+    this.bindingGraphValidator = bindingGraphValidator;
     this.componentDescriptorFactory = componentDescriptorFactory;
+    this.bindingGraphFactory = bindingGraphFactory;
+    this.componentGenerator = componentGenerator;
   }
 
   @Override
@@ -61,7 +70,19 @@ public void process(SetMultimap<Class<? extends Annotation>, Element> elementsBy
           componentValidator.validate(componentTypeElement);
       componentReport.printMessagesTo(messager);
       if (componentReport.isClean()) {
-        componentDescriptorFactory.forProductionComponent(componentTypeElement);
+        ComponentDescriptor componentDescriptor =
+            componentDescriptorFactory.forProductionComponent(componentTypeElement);
+        BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
+        ValidationReport<BindingGraph> graphReport =
+            bindingGraphValidator.validate(bindingGraph);
+        graphReport.printMessagesTo(messager);
+        if (graphReport.isClean()) {
+          try {
+            componentGenerator.generate(bindingGraph);
+          } catch (SourceFileGenerationException e) {
+            e.printMessageTo(messager);
+          }
+        }
       }
     }
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index dff5c16a6..f63eb1422 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -25,6 +25,8 @@
 import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.Provides;
+import dagger.Subcomponent;
+import dagger.producers.ProductionComponent;
 import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
@@ -33,6 +35,7 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
@@ -58,7 +61,7 @@
  * @since 2.0
  */
 @AutoValue
-abstract class ProvisionBinding extends ContributionBinding implements ResolvableBinding {
+abstract class ProvisionBinding extends ContributionBinding {
   @Override
   ImmutableSet<DependencyRequest> implicitDependencies() {
     return new ImmutableSet.Builder<DependencyRequest>()
@@ -147,19 +150,18 @@ FactoryCreationStrategy factoryCreationStrategy() {
       this.keyFactory = keyFactory;
       this.dependencyRequestFactory = dependencyRequestFactory;
     }
-    
-    
+
     /** Returns an unresolved version of this binding. */
     ProvisionBinding unresolve(ProvisionBinding binding) {
-      checkState(binding.isResolved());
+      checkState(binding.hasNonDefaultTypeParameters());
       return forInjectConstructor((ExecutableElement) binding.bindingElement(),
           Optional.<TypeMirror>absent());
     }
 
     /**
      * Returns a ProvisionBinding for the given element. If {@code resolvedType} is present, this
-     * will return a {@link ResolvableBinding#isResolved() resolved} binding, with the key & type
-     * resolved to the given type (using {@link Types#asMemberOf(DeclaredType, Element)}).
+     * will return a resolved binding, with the key & type resolved to the given type (using
+     * {@link Types#asMemberOf(DeclaredType, Element)}).
      */
     ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
         Optional<TypeMirror> resolvedType) {
@@ -168,7 +170,6 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
       checkArgument(isAnnotationPresent(constructorElement, Inject.class));
       checkArgument(!getQualifier(constructorElement).isPresent());
 
-      boolean isResolved = false;
       ExecutableType cxtorType = MoreTypes.asExecutable(constructorElement.asType());
       DeclaredType enclosingCxtorType =
           MoreTypes.asDeclared(constructorElement.getEnclosingElement().asType());
@@ -181,25 +182,30 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
             types.erasure(resolved), types.erasure(enclosingCxtorType));
         cxtorType = MoreTypes.asExecutable(types.asMemberOf(resolved, constructorElement));
         enclosingCxtorType = resolved;
-        isResolved = true;
       }
 
       Key key = keyFactory.forInjectConstructorWithResolvedType(enclosingCxtorType);
       checkArgument(!key.qualifier().isPresent());
       ImmutableSet<DependencyRequest> dependencies =
-          dependencyRequestFactory.forRequiredResolvedVariables(constructorElement.getParameters(),
+          dependencyRequestFactory.forRequiredResolvedVariables(enclosingCxtorType,
+              constructorElement.getParameters(),
               cxtorType.getParameterTypes());
       Optional<DependencyRequest> membersInjectionRequest =
           membersInjectionRequest(enclosingCxtorType);
       Optional<AnnotationMirror> scope =
           getScopeAnnotation(constructorElement.getEnclosingElement());
+      
+      TypeElement bindingTypeElement =
+          MoreElements.asType(constructorElement.getEnclosingElement());
 
       return new AutoValue_ProvisionBinding(
-          isResolved,
           key,
           constructorElement,
           dependencies,
           findBindingPackage(key),
+          hasNonDefaultTypeParameters(bindingTypeElement, key.type(), types),
+          Optional.<DeclaredType>absent(),
+          Optional.<TypeElement>absent(),
           Kind.INJECTION,
           Provides.Type.UNIQUE,
           wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), scope),
@@ -224,21 +230,30 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
       return Optional.absent();
     }
 
-    ProvisionBinding forProvidesMethod(ExecutableElement providesMethod) {
+    ProvisionBinding forProvidesMethod(ExecutableElement providesMethod, TypeMirror contributedBy) {
       checkNotNull(providesMethod);
       checkArgument(providesMethod.getKind().equals(METHOD));
+      checkArgument(contributedBy.getKind().equals(TypeKind.DECLARED));
       Provides providesAnnotation = providesMethod.getAnnotation(Provides.class);
       checkArgument(providesAnnotation != null);
-      Key key = keyFactory.forProvidesMethod(providesMethod);
+      DeclaredType declaredContainer = MoreTypes.asDeclared(contributedBy);
+      ExecutableType resolvedMethod =
+          MoreTypes.asExecutable(types.asMemberOf(declaredContainer, providesMethod));
+      Key key = keyFactory.forProvidesMethod(resolvedMethod, providesMethod);
       ImmutableSet<DependencyRequest> dependencies =
-          dependencyRequestFactory.forRequiredVariables(providesMethod.getParameters());
+          dependencyRequestFactory.forRequiredResolvedVariables(
+              declaredContainer,
+              providesMethod.getParameters(),
+              resolvedMethod.getParameterTypes());
       Optional<AnnotationMirror> scope = getScopeAnnotation(providesMethod);
       return new AutoValue_ProvisionBinding(
-          false /* not resolved */,
           key,
           providesMethod,
           dependencies,
           findBindingPackage(key),
+          false /* no non-default parameter types */,
+          ConfigurationAnnotations.getNullableType(providesMethod),
+          Optional.of(MoreTypes.asTypeElement(declaredContainer)),
           Kind.PROVISION,
           providesAnnotation.type(),
           wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), scope),
@@ -252,11 +267,13 @@ ProvisionBinding forImplicitMapBinding(DependencyRequest explicitRequest,
       ImmutableSet<DependencyRequest> dependencies = ImmutableSet.of(implicitRequest);
       Optional<AnnotationMirror> scope = getScopeAnnotation(implicitRequest.requestElement());
       return new AutoValue_ProvisionBinding(
-          false /* not resolved */,
           explicitRequest.key(),
           implicitRequest.requestElement(),
           dependencies,
           findBindingPackage(explicitRequest.key()),
+          false /* no non-default parameter types */,
+          Optional.<DeclaredType>absent(),
+          Optional.<TypeElement>absent(),
           Kind.SYNTHETIC_PROVISON,
           Provides.Type.MAP,
           wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), scope),
@@ -265,14 +282,14 @@ ProvisionBinding forImplicitMapBinding(DependencyRequest explicitRequest,
 
     ProvisionBinding forComponent(TypeElement componentDefinitionType) {
       checkNotNull(componentDefinitionType);
-      Component componentAnnotation = componentDefinitionType.getAnnotation(Component.class);
-      checkArgument(componentAnnotation != null);
       return new AutoValue_ProvisionBinding(
-          false /* not resolved */,
           keyFactory.forComponent(componentDefinitionType.asType()),
           componentDefinitionType,
           ImmutableSet.<DependencyRequest>of(),
           Optional.<String>absent(),
+          false /* no non-default parameter types */,
+          Optional.<DeclaredType>absent(),
+          Optional.<TypeElement>absent(),
           Kind.COMPONENT,
           Provides.Type.UNIQUE,
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
@@ -285,11 +302,13 @@ ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
       checkArgument(componentMethod.getParameters().isEmpty());
       Optional<AnnotationMirror> scope = getScopeAnnotation(componentMethod);
       return new AutoValue_ProvisionBinding(
-          false /* not resolved */,
           keyFactory.forComponentMethod(componentMethod),
           componentMethod,
           ImmutableSet.<DependencyRequest>of(),
           Optional.<String>absent(),
+          false /* no non-default parameter types */,
+          ConfigurationAnnotations.getNullableType(componentMethod),
+          Optional.<TypeElement>absent(),
           Kind.COMPONENT_PROVISION,
           Provides.Type.UNIQUE,
           wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), scope),
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBindingFormatter.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBindingFormatter.java
index b058f81c0..92d031042 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBindingFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBindingFormatter.java
@@ -15,7 +15,10 @@
  */
 package dagger.internal.codegen;
 
+import com.google.common.base.Optional;
+
 import static com.google.auto.common.MoreElements.asExecutable;
+import static com.google.auto.common.MoreTypes.asDeclared;
 
 /**
  * Formats a {@link ProvisionBinding} into a {@link String} suitable for use in error messages.
@@ -24,17 +27,19 @@
  * @since 2.0
  */
 final class ProvisionBindingFormatter extends Formatter<ProvisionBinding> {
-  private static final ProvisionBindingFormatter INSTANCE = new ProvisionBindingFormatter();
-
-  static ProvisionBindingFormatter instance() {
-    return INSTANCE;
+  private final MethodSignatureFormatter methodSignatureFormatter;
+  
+  ProvisionBindingFormatter(MethodSignatureFormatter methodSignatureFormatter) { 
+    this.methodSignatureFormatter = methodSignatureFormatter;
   }
 
   @Override public String format(ProvisionBinding binding) {
     switch (binding.bindingKind()) {
       case PROVISION:
+        return methodSignatureFormatter.format(asExecutable(binding.bindingElement()),
+            Optional.of(asDeclared(binding.contributedBy().get().asType())));
       case COMPONENT_PROVISION:
-        return MethodSignatureFormatter.instance().format(asExecutable(binding.bindingElement()));
+        return methodSignatureFormatter.format(asExecutable(binding.bindingElement()));
       default:
         throw new UnsupportedOperationException(
             "Not yet supporting " + binding.bindingKind() + " binding types.");
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 42a5adef1..62e034181 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -16,11 +16,11 @@
 import com.google.common.base.CaseFormat;
 import com.google.common.collect.ComparisonChain;
 import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Iterables;
-import com.google.common.collect.Maps;
 import com.google.common.collect.Ordering;
 import dagger.internal.DoubleCheckLazy;
 import dagger.internal.codegen.ContributionBinding.BindingType;
@@ -31,6 +31,7 @@
 import dagger.internal.codegen.writer.TypeNames;
 import java.util.Collection;
 import java.util.Iterator;
+import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 import javax.lang.model.element.ExecutableElement;
@@ -38,7 +39,6 @@
 import javax.lang.model.type.TypeMirror;
 
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
-import static com.google.common.base.Preconditions.checkState;
 
 /**
  * Utilities for generating files.
@@ -67,7 +67,7 @@ public int compare(DependencyRequest left, DependencyRequest right) {
 
   /**
    * A variant of {@link #indexDependenciesByKey} that maps from unresolved keys
-   * to resolved keys.  This is used when generating component's initialize()
+   * to requests.  This is used when generating component's initialize()
    * methods (and in members injectors) in order to instantiate dependent
    * providers.  Consider a generic type of {@code Foo<T>} with a constructor
    * of {@code Foo(T t, T t1, A a, A a1)}.  That will be collapsed to a factory
@@ -76,10 +76,13 @@ public int compare(DependencyRequest left, DependencyRequest right) {
    * pass two providers.  Naively (if we just referenced by resolved BindingKey),
    * we would have passed a single {@code aProvider}.
    */
-  static ImmutableMap<BindingKey, BindingKey> indexDependenciesByUnresolvedKey(
+  // TODO(user): Refactor these indexing methods so that the binding itself knows what sort of
+  // binding keys and framework classes that it needs.
+  static ImmutableSetMultimap<BindingKey, DependencyRequest> indexDependenciesByUnresolvedKey(
       Iterable<? extends DependencyRequest> dependencies) {
-    // We expect some duplicates while building, so not using ImmutableMap
-    Map<BindingKey, BindingKey> map = Maps.newLinkedHashMap();
+    ImmutableSetMultimap.Builder<BindingKey, DependencyRequest> dependenciesByKeyBuilder =
+        new ImmutableSetMultimap.Builder<BindingKey, DependencyRequest>().orderValuesBy(
+            DEPENDENCY_ORDERING);
     for (DependencyRequest dependency : dependencies) {
       BindingKey resolved = BindingKey.forDependencyRequest(dependency);
       // To get the proper unresolved type, we have to extract the proper type from the
@@ -88,17 +91,9 @@ public int compare(DependencyRequest left, DependencyRequest right) {
           DependencyRequest.Factory.extractKindAndType(dependency.requestElement().asType()).type();
       BindingKey unresolved =
           BindingKey.create(resolved.kind(), resolved.key().withType(unresolvedType));
-      BindingKey existingEntry = map.get(unresolved);
-      if (existingEntry == null) {
-        map.put(unresolved, resolved);
-      } else {
-        // If the entry exists in the map, it *must* be with the same resolved
-        // value.  Otherwise we have an unresolved key mapping to two different
-        // resolved keys!
-        checkState(existingEntry.equals(resolved));
-      }
+      dependenciesByKeyBuilder.put(unresolved, dependency);
     }
-    return ImmutableMap.copyOf(map);
+    return dependenciesByKeyBuilder.build();
   }
 
   /**
@@ -153,7 +148,8 @@ public int compare(DependencyRequest left, DependencyRequest right) {
       if (dependencyNames.size() == 1) {
         // if there's only one name, great! use it!
         String name = Iterables.getOnlyElement(dependencyNames);
-        bindingFields.put(bindingKey, FrameworkField.createWithTypeFromKey(frameworkClass, bindingKey, name));
+        bindingFields.put(bindingKey,
+            FrameworkField.createWithTypeFromKey(frameworkClass, bindingKey, name));
       } else {
         // in the event that a field is being used for a bunch of deps with different names,
         // add all the names together with "And"s in the middle. E.g.: stringAndS
@@ -178,6 +174,7 @@ static Snippet frameworkTypeUsageStatement(Snippet frameworkTypeMemberSelect,
         return Snippet.format("%s.create(%s)", ClassName.fromClass(DoubleCheckLazy.class),
             frameworkTypeMemberSelect);
       case INSTANCE:
+      case FUTURE:
         return Snippet.format("%s.get()", frameworkTypeMemberSelect);
       case PROVIDER:
       case PRODUCER:
@@ -209,18 +206,31 @@ static ClassName factoryNameForProvisionBinding(ProvisionBinding binding) {
   static TypeName parameterizedFactoryNameForProvisionBinding(
       ProvisionBinding binding) {
     ClassName factoryName = factoryNameForProvisionBinding(binding);
-    // Only parameterize injection unique bindings.
-    // Other kinds generate unique factories that have no type parameters.
-    if (binding.bindingType() == BindingType.UNIQUE
-        && binding.bindingKind() == ProvisionBinding.Kind.INJECTION) {
-      TypeName bindingName = TypeNames.forTypeMirror(binding.key().type());
-      // If the binding is parameterized, parameterize the factory.
-      if (bindingName instanceof ParameterizedTypeName) {
-        return ParameterizedTypeName.create(factoryName,
-            ((ParameterizedTypeName) bindingName).parameters());
+    List<TypeName> parameters = ImmutableList.of();
+    if (binding.bindingType().equals(BindingType.UNIQUE)) {
+      switch(binding.bindingKind()) {
+        case INJECTION:
+          TypeName bindingName = TypeNames.forTypeMirror(binding.key().type());
+          // If the binding is parameterized, parameterize the factory.
+          if (bindingName instanceof ParameterizedTypeName) {
+            parameters = ((ParameterizedTypeName) bindingName).parameters();
+          }
+          break;
+        case PROVISION:
+          // For provision bindings, we parameterize creation on the types of
+          // the module, not the types of the binding.
+          // Consider: Module<A, B, C> { @Provides List<B> provideB(B b) { .. }}
+          // The binding is just parameterized on <B>, but we need all of <A, B, C>.
+          if (!binding.bindingTypeElement().getTypeParameters().isEmpty()) {
+            parameters = ((ParameterizedTypeName) TypeNames.forTypeMirror(
+                binding.bindingTypeElement().asType())).parameters();
+          }
+          break;
+        default: // fall through.
       }
     }
-    return factoryName;
+    return parameters.isEmpty() ? factoryName
+        : ParameterizedTypeName.create(factoryName, parameters);
   }
 
   static ClassName factoryNameForProductionBinding(ProductionBinding binding) {
@@ -235,7 +245,7 @@ static ClassName factoryNameForProductionBinding(ProductionBinding binding) {
         throw new AssertionError();
     }
   }
-  
+
   /**
    * Returns the members injector's name parameterized with the binding's parameters (if necessary).
    */
diff --git a/compiler/src/main/java/dagger/internal/codegen/ValidationType.java b/compiler/src/main/java/dagger/internal/codegen/ValidationType.java
new file mode 100644
index 000000000..d60207241
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ValidationType.java
@@ -0,0 +1,40 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package dagger.internal.codegen;
+
+import com.google.common.base.Optional;
+import javax.tools.Diagnostic;
+
+/**
+ * Allows options to control how component process validates things such as scope cycles
+ * or nullability.
+ */
+enum ValidationType {
+  ERROR,
+  WARNING,
+  NONE;
+
+  Optional<Diagnostic.Kind> diagnosticKind() {
+    switch (this) {
+      case ERROR:
+        return Optional.of(Diagnostic.Kind.ERROR);
+      case WARNING:
+        return Optional.of(Diagnostic.Kind.WARNING);
+      default:
+        return Optional.absent();
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ClassName.java b/compiler/src/main/java/dagger/internal/codegen/writer/ClassName.java
index 63041aba3..0b2615e9a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ClassName.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ClassName.java
@@ -157,7 +157,7 @@ public static ClassName fromClass(Class<?> clazz) {
     Class<?> current = clazz.getEnclosingClass();
     while (current != null) {
       enclosingNames.add(current.getSimpleName());
-      current = clazz.getEnclosingClass();
+      current = current.getEnclosingClass();
     }
     Collections.reverse(enclosingNames);
     return create(clazz.getPackage().getName(), enclosingNames, clazz.getSimpleName());
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java
index e44a65f90..7831fe816 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java
@@ -49,6 +49,10 @@ public String name() {
     return name;
   }
   
+  public TypeName returnType() {
+    return returnType;
+  }
+  
   public void addTypeParameter(TypeVariableName typeVariableName) {
     this.typeParameters.add(typeVariableName);
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Modifiable.java b/compiler/src/main/java/dagger/internal/codegen/writer/Modifiable.java
index 0462bde1a..bb4c6ffd9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/Modifiable.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/Modifiable.java
@@ -42,12 +42,16 @@ public void addModifiers(Iterable<Modifier> modifiers) {
     Iterables.addAll(this.modifiers, modifiers);
   }
 
-  public AnnotationWriter annotate(Class<? extends Annotation> annotation) {
-    AnnotationWriter annotationWriter = new AnnotationWriter(ClassName.fromClass(annotation));
+  public AnnotationWriter annotate(ClassName annotation) {
+    AnnotationWriter annotationWriter = new AnnotationWriter(annotation);
     this.annotations.add(annotationWriter);
     return annotationWriter;
   }
 
+  public AnnotationWriter annotate(Class<? extends Annotation> annotation) {
+    return annotate(ClassName.fromClass(annotation));
+  }
+
   Appendable writeModifiers(Appendable appendable) throws IOException {
     for (Modifier modifier : modifiers) {
       appendable.append(modifier.toString()).append(' ');
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index 8d41a1013..d9613ddb3 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -17,6 +17,7 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
+import dagger.internal.codegen.writer.StringLiteral;
 import javax.tools.JavaFileObject;
 import org.junit.Ignore;
 import org.junit.Test;
@@ -26,9 +27,13 @@
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT;
 
 @RunWith(JUnit4.class)
 public class ComponentProcessorTest {
+  private static final StringLiteral NPE_LITERAL =
+      StringLiteral.forValue(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
+  
   @Test public void componentOnConcreteClass() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
         "package test;",
@@ -87,6 +92,81 @@
         .withErrorContaining("is not annotated with @Module");
   }
 
+  @Test public void cannotReferToAbstractModules() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module",
+        "abstract class TestModule {}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.BadComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = TestModule.class)",
+        "interface BadComponent {}");
+    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT, "test.TestModule"));
+  }
+
+  @Test public void doubleBindingFromResolvedModules() {
+    JavaFileObject parent = JavaFileObjects.forSourceLines("test.ParentModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import java.util.List;",
+        "",
+        "@Module",
+        "abstract class ParentModule<A> {",
+        "  @Provides List<A> provideListB(A a) { return null; }",
+        "}");
+    JavaFileObject child = JavaFileObjects.forSourceLines("test.ChildModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "class ChildNumberModule extends ParentModule<Integer> {",
+        "  @Provides Integer provideInteger() { return null; }",
+        "}");
+    JavaFileObject another = JavaFileObjects.forSourceLines("test.AnotherModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import java.util.List;",
+        "",
+        "@Module",
+        "class AnotherModule {",
+        "  @Provides List<Integer> provideListOfInteger() { return null; }",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.BadComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.List;",
+        "",
+        "@Component(modules = {ChildNumberModule.class, AnotherModule.class})",
+        "interface BadComponent {",
+        "  List<Integer> listOfInteger();",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(parent, child, another, componentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile().withErrorContaining(
+            "java.util.List<java.lang.Integer> is bound multiple times")
+        .and().withErrorContaining(
+            "@Provides List<Integer> test.ChildNumberModule.provideListB(Integer)")
+        .and().withErrorContaining(
+            "@Provides List<Integer> test.AnotherModule.provideListOfInteger()");
+  }
+
   @Test public void simpleComponent() {
     JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
         "package test;",
@@ -404,7 +484,7 @@
         "  }",
         "",
         "  private void initialize() {",
-        "    this.bProvider = new TestModule$$BFactory(testModule, C$$Factory.create());",
+        "    this.bProvider = TestModule$$BFactory.create(testModule, C$$Factory.create());",
         "    this.aProvider = A$$Factory.create(bProvider);",
         "  }",
         "",
@@ -443,22 +523,62 @@
   }
 
   @Test public void transitiveModuleDeps() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+    JavaFileObject always = JavaFileObjects.forSourceLines("test.AlwaysIncluded",
         "package test;",
         "",
         "import dagger.Module;",
         "",
-        "@Module(includes = DepModule.class)",
-        "final class TestModule {",
-        "}");
-    JavaFileObject depModuleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "@Module",
+        "final class AlwaysIncluded {}");
+    JavaFileObject testModule = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
         "import dagger.Module;",
         "",
-        "@Module",
-        "final class DepModule {",
-        "}");
+        "@Module(includes = {DepModule.class, AlwaysIncluded.class})",
+        "final class TestModule extends ParentTestModule {}");
+    JavaFileObject parentTest = JavaFileObjects.forSourceLines("test.ParentTestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module(includes = {ParentTestIncluded.class, AlwaysIncluded.class})",
+        "class ParentTestModule {}");
+    JavaFileObject parentTestIncluded = JavaFileObjects.forSourceLines("test.ParentTestIncluded",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module(includes = AlwaysIncluded.class)",
+        "final class ParentTestIncluded {}");
+    JavaFileObject depModule = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module(includes = {RefByDep.class, AlwaysIncluded.class})",
+        "final class DepModule extends ParentDepModule {}");
+    JavaFileObject refByDep = JavaFileObjects.forSourceLines("test.RefByDep",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module(includes = AlwaysIncluded.class)",
+        "final class RefByDep extends ParentDepModule {}");
+    JavaFileObject parentDep = JavaFileObjects.forSourceLines("test.ParentDepModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module(includes = {ParentDepIncluded.class, AlwaysIncluded.class})",
+        "class ParentDepModule {}");
+    JavaFileObject parentDepIncluded = JavaFileObjects.forSourceLines("test.ParentDepIncluded",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module(includes = AlwaysIncluded.class)",
+        "final class ParentDepIncluded {}");
 
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
         "package test;",
@@ -470,6 +590,8 @@
         "@Component(modules = TestModule.class)",
         "interface TestComponent {",
         "}");
+    // Generated code includes all includes, but excludes the parent modules.
+    // The "always" module should only be listed once.
     JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
         "test.Dagger_TestComponent",
         "package test;",
@@ -480,11 +602,19 @@
         "public final class Dagger_TestComponent implements TestComponent {",
         "  private final TestModule testModule;",
         "  private final DepModule depModule;",
+        "  private final AlwaysIncluded alwaysIncluded;",
+        "  private final ParentTestIncluded parentTestIncluded;",
+        "  private final RefByDep refByDep;",
+        "  private final ParentDepIncluded parentDepIncluded;",
         "",
         "  private Dagger_TestComponent(Builder builder) {",
         "    assert builder != null;",
         "    this.testModule = builder.testModule;",
         "    this.depModule = builder.depModule;",
+        "    this.alwaysIncluded = builder.alwaysIncluded;",
+        "    this.parentTestIncluded = builder.parentTestIncluded;",
+        "    this.refByDep = builder.refByDep;",
+        "    this.parentDepIncluded = builder.parentDepIncluded;",
         "  }",
         "",
         "  public static Builder builder() {",
@@ -498,6 +628,10 @@
         "  public static final class Builder {",
         "    private TestModule testModule;",
         "    private DepModule depModule;",
+        "    private AlwaysIncluded alwaysIncluded;",
+        "    private ParentTestIncluded parentTestIncluded;",
+        "    private RefByDep refByDep;",
+        "    private ParentDepIncluded parentDepIncluded;",
         "",
         "    private Builder() {",
         "    }",
@@ -509,6 +643,18 @@
         "      if (depModule == null) {",
         "        this.depModule = new DepModule();",
         "      }",
+        "      if (alwaysIncluded == null) {",
+        "        this.alwaysIncluded = new AlwaysIncluded();",
+        "      }",
+        "      if (parentTestIncluded == null) {",
+        "        this.parentTestIncluded = new ParentTestIncluded();",
+        "      }",
+        "      if (refByDep == null) {",
+        "        this.refByDep = new RefByDep();",
+        "      }",
+        "      if (parentDepIncluded == null) {",
+        "        this.parentDepIncluded = new ParentDepIncluded();",
+        "      }",
         "      return new Dagger_TestComponent(this);",
         "    }",
         "",
@@ -527,10 +673,50 @@
         "      this.depModule = depModule;",
         "      return this;",
         "    }",
+        "",
+        "    public Builder alwaysIncluded(AlwaysIncluded alwaysIncluded) {",
+        "      if (alwaysIncluded == null) {",
+        "        throw new NullPointerException(\"alwaysIncluded\");",
+        "      }",
+        "      this.alwaysIncluded = alwaysIncluded;",
+        "      return this;",
+        "    }",
+        "",
+        "    public Builder parentTestIncluded(ParentTestIncluded parentTestIncluded) {",
+        "      if (parentTestIncluded == null) {",
+        "        throw new NullPointerException(\"parentTestIncluded\");",
+        "      }",
+        "      this.parentTestIncluded = parentTestIncluded;",
+        "      return this;",
+        "    }",
+        "",
+        "    public Builder refByDep(RefByDep refByDep) {",
+        "      if (refByDep == null) {",
+        "        throw new NullPointerException(\"refByDep\");",
+        "      }",
+        "      this.refByDep = refByDep;",
+        "      return this;",
+        "    }",
+        "",
+        "    public Builder parentDepIncluded(ParentDepIncluded parentDepIncluded) {",
+        "      if (parentDepIncluded == null) {",
+        "        throw new NullPointerException(\"parentDepIncluded\");",
+        "      }",
+        "      this.parentDepIncluded = parentDepIncluded;",
+        "      return this;",
+        "    }",
         "  }",
         "}");
     assertAbout(javaSources())
-        .that(ImmutableList.of(moduleFile, depModuleFile, componentFile))
+        .that(ImmutableList.of(always,
+            testModule,
+            parentTest,
+            parentTestIncluded,
+            depModule,
+            refByDep,
+            parentDep,
+            parentDepIncluded,
+            componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
@@ -609,8 +795,8 @@
         "",
         "  private void initialize() {",
         "    this.setOfStringContribution1Provider =",
-        "        new EmptySetModule$$EmptySetFactory(emptySetModule);",
-        "    this.setOfStringContribution2Provider = new SetModule$$StringFactory(setModule);",
+        "        EmptySetModule$$EmptySetFactory.create(emptySetModule);",
+        "    this.setOfStringContribution2Provider = SetModule$$StringFactory.create(setModule);",
         "    this.setOfStringProvider = SetFactory.create(",
         "        setOfStringContribution1Provider, setOfStringContribution2Provider);",
         "  }",
@@ -1050,7 +1236,11 @@
         "  private void initialize() {",
         "    this.aProvider = new Factory<A>() {",
         "      @Override public A get() {",
-        "        return aComponent.a();",
+        "        A provided = aComponent.a();",
+        "        if (provided == null) {",
+        "          throw new NullPointerException(" + NPE_LITERAL + ");",
+        "        }",
+        "        return provided;",
         "      }",
         "    };",
         "    this.bProvider = B$$Factory.create(aProvider);",
@@ -1166,8 +1356,8 @@
         "  }",
         "",
         "  private void initialize() {",
-        "    this.aProvider = new test.TestModule$$AFactory(testModule);",
-        "    this.aProvider1 = new TestModule$$AFactory(testModule1);",
+        "    this.aProvider = test.TestModule$$AFactory.create(testModule);",
+        "    this.aProvider1 = TestModule$$AFactory.create(testModule1);",
         "  }",
         "",
         "  @Override",
@@ -1506,7 +1696,7 @@
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
   }
-  
+
   @Test public void wildcardGenericsRequiresAtProvides() {
     JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
         "package test;",
@@ -1552,100 +1742,10 @@
         .withErrorContaining(
             "test.B<? extends test.A> cannot be provided without an @Provides-annotated method");
   }
-  
-  @Test public void arrayGenericsRequiresAtProvides() {
-    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class A {",
-        "  @Inject A() {}",
-        "}");
-    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "import javax.inject.Provider;",
-        "",
-        "final class B<T> {",
-        "  @Inject B(T t) {}",
-        "}");
-    JavaFileObject cFile = JavaFileObjects.forSourceLines("test.C",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "import javax.inject.Provider;",
-        "",
-        "final class C {",
-        "  @Inject C(B<Object[]> b) {}",
-        "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import dagger.Lazy;",
-        "",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface SimpleComponent {",
-        "  C c();",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(aFile, bFile, cFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("test.B<java.lang.Object[]> cannot be provided without"
-            + " an @Provides-annotated method");
-  }
-  
-  @Test public void rawTypeGenericsRequiresAtProvides() {
-    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class A {",
-        "  @Inject A() {}",
-        "}");
-    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "import javax.inject.Provider;",
-        "",
-        "final class B<T> {",
-        "  @Inject B(T t) {}",
-        "}");
-    JavaFileObject cFile = JavaFileObjects.forSourceLines("test.C",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "import javax.inject.Provider;",
-        "",
-        "final class C {",
-        "  @Inject C(B b) {}",
-        "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import dagger.Lazy;",
-        "",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface SimpleComponent {",
-        "  C c();",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(aFile, bFile, cFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("test.B cannot be provided without an @Provides-annotated method");
-  }
  
   @Test
   @Ignore // modify this test as necessary while debugging for your situation.
+  @SuppressWarnings("unused")
   public void genericTestToLetMeDebugInEclipse() {
     JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
         "package test;",
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index 68b684588..7a67567e9 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -15,6 +15,8 @@
  */
 package dagger.internal.codegen;
 
+import com.google.common.base.Joiner;
+import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
 import java.util.Arrays;
 import javax.tools.JavaFileObject;
@@ -25,9 +27,14 @@
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.ErrorMessages.NULLABLE_TO_NON_NULLABLE;
 
 @RunWith(JUnit4.class)
 public class GraphValidationTest {
+  private final JavaFileObject NULLABLE = JavaFileObjects.forSourceLines("test.Nullable",
+      "package test;",
+      "public @interface Nullable {}");
+  
   @Test public void componentOnConcreteClass() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.MyComponent",
         "package test;",
@@ -545,7 +552,7 @@
         + "      test.TestClass.B.<init>(test.TestClass.A a)\n"
         + "          [parameter: test.TestClass.A a]";
     String secondError = errorText
-        + "      test.TestClass.C.b()\n"
+        + "      test.TestClass.C.b\n"
         + "          [injected field of type: test.TestClass.B b]\n"
         + "      test.TestClass.B.<init>(test.TestClass.A a)\n"
         + "          [parameter: test.TestClass.A a]";
@@ -555,4 +562,263 @@
         .withErrorContaining(firstError).in(component).onLine(33)
         .and().withErrorContaining(secondError).in(component).onLine(34);
   }
+  
+  @Test public void resolvedParametersInDependencyTrace() {
+    JavaFileObject generic = JavaFileObjects.forSourceLines("test.Generic",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "final class Generic<T> {",
+        "  @Inject Generic(T t) {}",
+        "}");
+    JavaFileObject testClass = JavaFileObjects.forSourceLines("test.TestClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import java.util.List;",
+        "",
+        "final class TestClass {",
+        "  @Inject TestClass(List list) {}",
+        "}");
+    JavaFileObject usesTest = JavaFileObjects.forSourceLines("test.UsesTest",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class UsesTest {",
+        "  @Inject UsesTest(Generic<TestClass> genericTestClass) {}",
+        "}");
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  UsesTest usesTest();",
+        "}");
+    String expectedMsg = Joiner.on("\n").join(
+        "java.util.List cannot be provided without an @Provides-annotated method.",
+        "      test.UsesTest.<init>(test.Generic<test.TestClass> genericTestClass)", 
+        "          [parameter: test.Generic<test.TestClass> genericTestClass]", 
+        "      test.Generic.<init>(test.TestClass t)", 
+        "          [parameter: test.TestClass t]", 
+        "      test.TestClass.<init>(java.util.List list)", 
+        "          [parameter: java.util.List list]");
+    assertAbout(javaSources()).that(ImmutableList.of(generic, testClass, usesTest, component))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedMsg);
+  }
+  
+  @Test public void resolvedVariablesInDependencyTrace() {
+    JavaFileObject generic = JavaFileObjects.forSourceLines("test.Generic",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "final class Generic<T> {",
+        "  @Inject T t;",
+        "  @Inject Generic() {}",
+        "}");
+    JavaFileObject testClass = JavaFileObjects.forSourceLines("test.TestClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import java.util.List;",
+        "",
+        "final class TestClass {",
+        "  @Inject TestClass(List list) {}",
+        "}");
+    JavaFileObject usesTest = JavaFileObjects.forSourceLines("test.UsesTest",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class UsesTest {",
+        "  @Inject UsesTest(Generic<TestClass> genericTestClass) {}",
+        "}");
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  UsesTest usesTest();",
+        "}");
+    String expectedMsg = Joiner.on("\n").join(
+        "java.util.List cannot be provided without an @Provides-annotated method.",
+        "      test.UsesTest.<init>(test.Generic<test.TestClass> genericTestClass)", 
+        "          [parameter: test.Generic<test.TestClass> genericTestClass]", 
+        "      test.Generic.t",
+        "          [injected field of type: test.TestClass t]", 
+        "      test.TestClass.<init>(java.util.List list)", 
+        "          [parameter: java.util.List list]");
+    assertAbout(javaSources()).that(ImmutableList.of(generic, testClass, usesTest, component))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedMsg);
+  }
+  
+  @Test public void nullCheckForConstructorParameters() {
+    JavaFileObject a = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject A(String string) {}",
+        "}");
+    JavaFileObject module = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "@dagger.Module",
+        "final class TestModule {",
+        "  @Nullable @Provides String provideString() { return null; }",
+        "}");
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = TestModule.class)",
+        "interface TestComponent {",
+        "  A a();",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(NULLABLE_TO_NON_NULLABLE, "java.lang.String",
+            "@test.Nullable @Provides String test.TestModule.provideString()"));
+
+    // but if we disable the validation, then it compiles fine.
+    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
+        .withCompilerOptions("-Adagger.nullableValidation=WARNING")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+
+  @Test public void nullCheckForMembersInjectParam() {
+    JavaFileObject a = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject A() {}",
+        "  @Inject void register(String string) {}",
+        "}");
+    JavaFileObject module = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "@dagger.Module",
+        "final class TestModule {",
+        "  @Nullable @Provides String provideString() { return null; }",
+        "}");
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = TestModule.class)",
+        "interface TestComponent {",
+        "  A a();",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(NULLABLE_TO_NON_NULLABLE, "java.lang.String",
+            "@test.Nullable @Provides String test.TestModule.provideString()"));
+
+    // but if we disable the validation, then it compiles fine.
+    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
+        .withCompilerOptions("-Adagger.nullableValidation=WARNING")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+
+  @Test public void nullCheckForVariable() {
+    JavaFileObject a = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject String string;",
+        "  @Inject A() {}",
+        "}");
+    JavaFileObject module = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "@dagger.Module",
+        "final class TestModule {",
+        "  @Nullable @Provides String provideString() { return null; }",
+        "}");
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = TestModule.class)",
+        "interface TestComponent {",
+        "  A a();",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(NULLABLE_TO_NON_NULLABLE, "java.lang.String",
+            "@test.Nullable @Provides String test.TestModule.provideString()"));
+
+    // but if we disable the validation, then it compiles fine.
+    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
+        .withCompilerOptions("-Adagger.nullableValidation=WARNING")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+
+  @Test public void nullCheckForComponentReturn() {
+    JavaFileObject module = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "@dagger.Module",
+        "final class TestModule {",
+        "  @Nullable @Provides String provideString() { return null; }",
+        "}");
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = TestModule.class)",
+        "interface TestComponent {",
+        "  String string();",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, module, component))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(NULLABLE_TO_NON_NULLABLE, "java.lang.String",
+            "@test.Nullable @Provides String test.TestModule.provideString()"));
+
+    // but if we disable the validation, then it compiles fine.
+    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, module, component))
+        .withCompilerOptions("-Adagger.nullableValidation=WARNING")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
index 2e5f216a2..461c6c3c8 100644
--- a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
@@ -32,6 +32,7 @@
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
@@ -86,7 +87,8 @@
         elements.getTypeElement(ProvidesMethodModule.class.getCanonicalName());
     ExecutableElement providesMethod =
         Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
-    assertThat(keyFactory.forProvidesMethod(providesMethod))
+    assertThat(
+        keyFactory.forProvidesMethod((ExecutableType) providesMethod.asType(), providesMethod))
         .isEqualTo(new AutoValue_Key(
             Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
             MoreTypes.equivalence().wrap(stringType)));
@@ -107,7 +109,8 @@
         elements.getTypeElement(QualifiedProvidesMethodModule.class.getCanonicalName());
     ExecutableElement providesMethod =
         Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
-    Key key = keyFactory.forProvidesMethod(providesMethod);
+    Key key =
+        keyFactory.forProvidesMethod((ExecutableType) providesMethod.asType(), providesMethod);
     assertThat(MoreTypes.equivalence().wrap(key.qualifier().get().getAnnotationType()))
         .isEqualTo(MoreTypes.equivalence().wrap(qualifierElement.asType()));
     assertThat(key.wrappedType()).isEqualTo(MoreTypes.equivalence().wrap(stringType));
@@ -118,7 +121,8 @@
         elements.getTypeElement(QualifiedProvidesMethodModule.class.getCanonicalName());
     ExecutableElement providesMethod =
         Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
-    Key provisionKey = keyFactory.forProvidesMethod(providesMethod);
+    Key provisionKey =
+        keyFactory.forProvidesMethod((ExecutableType) providesMethod.asType(), providesMethod);
 
     TypeMirror type = elements.getTypeElement(String.class.getCanonicalName()).asType();
     TypeElement injectableElement =
@@ -159,10 +163,11 @@ String provideQualifiedString() {
         elements.getTypeElement(SetProvidesMethodsModule.class.getCanonicalName());
     for (ExecutableElement providesMethod
         : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {
-      assertThat(keyFactory.forProvidesMethod(providesMethod))
-          .isEqualTo(new AutoValue_Key(
-              Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-              MoreTypes.equivalence().wrap(setOfStringsType)));
+      assertThat(
+          keyFactory.forProvidesMethod((ExecutableType) providesMethod.asType(), providesMethod))
+              .isEqualTo(new AutoValue_Key(
+                  Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
+                  MoreTypes.equivalence().wrap(setOfStringsType)));
     }
   }
 
@@ -207,8 +212,9 @@ String provideQualifiedString() {
     assertThat(integerType.getKind().isPrimitive()).isFalse();
     assertThat(types.isSameType(intType, integerType)).named("type equality").isFalse();
 
-    Key intKey = keyFactory.forProvidesMethod(intMethod);
-    Key integerKey = keyFactory.forProvidesMethod(integerMethod);
+    Key intKey = keyFactory.forProvidesMethod((ExecutableType) intMethod.asType(), intMethod);
+    Key integerKey =
+        keyFactory.forProvidesMethod((ExecutableType) integerMethod.asType(), integerMethod);
     assertThat(intKey).isEqualTo(integerKey);
   }
 
@@ -218,8 +224,9 @@ String provideQualifiedString() {
         elements.getTypeElement(ProducesMethodsModule.class.getCanonicalName());
     for (ExecutableElement producesMethod
         : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {
-      assertThat(keyFactory.forProducesMethod(producesMethod))
-          .isEqualTo(new AutoValue_Key(
+      assertThat(keyFactory.forProducesMethod(
+          (ExecutableType) producesMethod.asType(), producesMethod))
+              .isEqualTo(new AutoValue_Key(
                   Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
                   MoreTypes.equivalence().wrap(stringType)));
     }
@@ -244,7 +251,8 @@ String provideQualifiedString() {
         elements.getTypeElement(SetProducesMethodsModule.class.getCanonicalName());
     for (ExecutableElement producesMethod
         : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {
-      assertThat(keyFactory.forProducesMethod(producesMethod))
+      assertThat(keyFactory.forProducesMethod(
+          (ExecutableType) producesMethod.asType(), producesMethod))
           .isEqualTo(new AutoValue_Key(
                   Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
                   MoreTypes.equivalence().wrap(setOfStringsType)));
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
index 6ca89f8e4..4128b6828 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -142,9 +142,9 @@ public void mapBindingsWithEnumKey() {
         "",
         "  private void initialize() {",
         "    this.mapOfPathEnumAndProviderOfHandlerContribution1 =",
-        "        new MapModuleOne$$ProvideAdminHandlerFactory(mapModuleOne);",
+        "        MapModuleOne$$ProvideAdminHandlerFactory.create(mapModuleOne);",
         "    this.mapOfPathEnumAndProviderOfHandlerContribution2 =",
-        "        new MapModuleTwo$$ProvideLoginHandlerFactory(mapModuleTwo);",
+        "        MapModuleTwo$$ProvideLoginHandlerFactory.create(mapModuleTwo);",
         "    this.mapOfPathEnumAndProviderOfHandlerProvider =",
         "        MapProviderFactory.<PathEnum, Handler>builder(2)",
         "            .put(test.PathEnum.ADMIN,",
@@ -314,9 +314,9 @@ public void mapBindingsWithStringKey() {
         "",
         "  private void initialize() {",
         "    this.mapOfStringAndProviderOfHandlerContribution1 =",
-        "        new MapModuleOne$$ProvideAdminHandlerFactory(mapModuleOne);",
+        "        MapModuleOne$$ProvideAdminHandlerFactory.create(mapModuleOne);",
         "    this.mapOfStringAndProviderOfHandlerContribution2 =",
-        "        new MapModuleTwo$$ProvideLoginHandlerFactory(mapModuleTwo);",
+        "        MapModuleTwo$$ProvideLoginHandlerFactory.create(mapModuleTwo);",
         "    this.mapOfStringAndProviderOfHandlerProvider =",
         "        MapProviderFactory.<String, Handler>builder(2)",
         "            .put(\"Admin\", mapOfStringAndProviderOfHandlerContribution1)",
@@ -488,9 +488,9 @@ public void mapBindingsWithNonProviderValue() {
         "",
         "  private void initialize() {",
         "    this.mapOfPathEnumAndProviderOfHandlerContribution1 =",
-        "        new MapModuleOne$$ProvideAdminHandlerFactory(mapModuleOne);",
+        "        MapModuleOne$$ProvideAdminHandlerFactory.create(mapModuleOne);",
         "    this.mapOfPathEnumAndProviderOfHandlerContribution2 =",
-        "        new MapModuleTwo$$ProvideLoginHandlerFactory(mapModuleTwo);",
+        "        MapModuleTwo$$ProvideLoginHandlerFactory.create(mapModuleTwo);",
         "    this.mapOfPathEnumAndProviderOfHandlerProvider =",
         "        MapProviderFactory.<PathEnum, Handler>builder(2)",
         "            .put(test.PathEnum.ADMIN,",
@@ -612,7 +612,7 @@ public void injectMapWithoutMapBinding() {
         "  }",
         "",
         "  private void initialize() {",
-        "    this.provideAMapProvider = new MapModule$$ProvideAMapFactory(mapModule);",
+        "    this.provideAMapProvider = MapModule$$ProvideAMapFactory.create(mapModule);",
         "  }",
         "",
         "  @Override",
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
index ed0d99322..1b9fd0f12 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
@@ -183,9 +183,9 @@ public void mapKeyComponentFileWithDisorderedKeyField() {
         "",
         "  private void initialize() {",
         "    this.mapOfPathKeyAndProviderOfHandlerContribution1 =",
-        "        new MapModuleOne$$ProvideAdminHandlerFactory(mapModuleOne);",
+        "        MapModuleOne$$ProvideAdminHandlerFactory.create(mapModuleOne);",
         "    this.mapOfPathKeyAndProviderOfHandlerContribution2 =",
-        "        new MapModuleTwo$$ProvideLoginHandlerFactory(mapModuleTwo);",
+        "        MapModuleTwo$$ProvideLoginHandlerFactory.create(mapModuleTwo);",
         "    this.mapOfPathKeyAndProviderOfHandlerProvider =",
         "        MapProviderFactory.<PathKey, Handler>builder(2)",
         "            .put(PathKeyCreator.create(PathEnum.ADMIN, \"AdminPath\"),",
@@ -361,9 +361,9 @@ public void mapKeyComponentFileWithDefaultField() {
         "",
         "  private void initialize() {",
         "    this.mapOfPathKeyAndProviderOfHandlerContribution1 =",
-        "        new MapModuleOne$$ProvideAdminHandlerFactory(mapModuleOne);",
+        "        MapModuleOne$$ProvideAdminHandlerFactory.create(mapModuleOne);",
         "    this.mapOfPathKeyAndProviderOfHandlerContribution2 =",
-        "        new MapModuleTwo$$ProvideLoginHandlerFactory(mapModuleTwo);",
+        "        MapModuleTwo$$ProvideLoginHandlerFactory.create(mapModuleTwo);",
         "    this.mapOfPathKeyAndProviderOfHandlerProvider =",
         "        MapProviderFactory.<PathKey, Handler>builder(2)",
         "            .put(PathKeyCreator.create(PathEnum.ADMIN, \"DefaultPath\"),",
diff --git a/compiler/src/test/java/dagger/internal/codegen/MethodSignatureFormatterTest.java b/compiler/src/test/java/dagger/internal/codegen/MethodSignatureFormatterTest.java
index 440c486fb..45791c75c 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MethodSignatureFormatterTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MethodSignatureFormatterTest.java
@@ -51,7 +51,7 @@
     Elements elements = compilationRule.getElements();
     TypeElement inner = elements.getTypeElement(InnerClass.class.getCanonicalName());
     ExecutableElement method = Iterables.getOnlyElement(methodsIn(inner.getEnclosedElements()));
-    String formatted = MethodSignatureFormatter.instance().format(method);
+    String formatted = new MethodSignatureFormatter(compilationRule.getTypes()).format(method);
     // This is gross, but it turns out that annotation order is not guaranteed when getting
     // all the AnnotationMirrors from an Element, so I have to test this chopped-up to make it
     // less brittle.
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index a19b6e31e..fc716b4b8 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -17,12 +17,13 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
+import dagger.internal.codegen.writer.StringLiteral;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assert_;
+import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
@@ -33,11 +34,20 @@
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_STATIC;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;
+import static dagger.internal.codegen.ErrorMessages.MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_RETURN_TYPE;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RETURN_SET;
 
 @RunWith(JUnit4.class)
 public class ModuleFactoryGeneratorTest {
+
+  private final JavaFileObject NULLABLE = JavaFileObjects.forSourceLines("test.Nullable",
+      "package test;",
+      "public @interface Nullable {}");
+  
+  private static final StringLiteral NPE_LITERAL =
+      StringLiteral.forValue(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
+
   // TODO(gak): add tests for invalid combinations of scope and qualifier annotations like we have
   // for @Inject
 
@@ -60,7 +70,7 @@ private String formatModuleErrorMessage(String msg) {
         "    return \"\";",
         "  }",
         "}");
-    assert_().about(javaSource()).that(moduleFile)
+    assertAbout(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE));
@@ -77,7 +87,7 @@ private String formatModuleErrorMessage(String msg) {
         "abstract class TestModule {",
         "  @Provides abstract String provideString();",
         "}");
-    assert_().about(javaSource()).that(moduleFile)
+    assertAbout(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(formatErrorMessage(BINDING_METHOD_ABSTRACT));
@@ -96,7 +106,7 @@ private String formatModuleErrorMessage(String msg) {
         "    return \"\";",
         "  }",
         "}");
-    assert_().about(javaSource()).that(moduleFile)
+    assertAbout(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(formatErrorMessage(BINDING_METHOD_PRIVATE));
@@ -115,7 +125,7 @@ private String formatModuleErrorMessage(String msg) {
         "    return \"\";",
         "  }",
         "}");
-    assert_().about(javaSource()).that(moduleFile)
+    assertAbout(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(formatErrorMessage(BINDING_METHOD_STATIC));
@@ -132,7 +142,7 @@ private String formatModuleErrorMessage(String msg) {
         "final class TestModule {",
         "  @Provides void provideNothing() {}",
         "}");
-    assert_().about(javaSource()).that(moduleFile)
+    assertAbout(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE));
@@ -151,7 +161,7 @@ private String formatModuleErrorMessage(String msg) {
         "    return \"\";",
         "  }",
         "}");
-    assert_().about(javaSource()).that(moduleFile)
+    assertAbout(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER));
@@ -174,7 +184,7 @@ private String formatModuleErrorMessage(String msg) {
         "    return null;",
         "  }",
         "}");
-    assert_().about(javaSource()).that(moduleFile)
+    assertAbout(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(PROVIDES_METHOD_RETURN_TYPE);
@@ -197,7 +207,7 @@ private String formatModuleErrorMessage(String msg) {
         "    return null;",
         "  }",
         "}");
-    assert_().about(javaSource()).that(moduleFile)
+    assertAbout(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET));
@@ -220,12 +230,146 @@ private String formatModuleErrorMessage(String msg) {
         "    return null;",
         "  }",
         "}");
-    assert_().about(javaSource()).that(moduleFile)
+    assertAbout(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(PROVIDES_METHOD_SET_VALUES_RETURN_SET);
   }
 
+  @Test public void modulesWithTypeParamsMustBeAbstract() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule<A> {}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT);
+  }
+
+  @Test public void provideOverriddenByNoProvide() {
+    JavaFileObject parent = JavaFileObjects.forSourceLines("test.Parent",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "class Parent {",
+        "  @Provides String foo() { return null; }",
+        "}");
+    JavaFileObject child = JavaFileObjects.forSourceLines("test.Child",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module",
+        "class Child extends Parent{",
+        "  String foo() { return null; }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(parent, child))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(ErrorMessages.METHOD_OVERRIDES_PROVIDES_METHOD,
+            "Provides", "@Provides String test.Parent.foo()"));
+  }
+
+  @Test public void provideOverriddenByProvide() {
+    JavaFileObject parent = JavaFileObjects.forSourceLines("test.Parent",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "class Parent {",
+        "  @Provides String foo() { return null; }",
+        "}");
+    JavaFileObject child = JavaFileObjects.forSourceLines("test.Child",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "class Child extends Parent{",
+        "  @Provides String foo() { return null; }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(parent, child))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(ErrorMessages.PROVIDES_METHOD_OVERRIDES_ANOTHER,
+            "Provides", "@Provides String test.Parent.foo()"));
+  }
+
+  @Test public void providesOverridesNonProvides() {
+    JavaFileObject parent = JavaFileObjects.forSourceLines("test.Parent",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module",
+        "class Parent {",
+        "  String foo() { return null; }",
+        "}");
+    JavaFileObject child = JavaFileObjects.forSourceLines("test.Child",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "class Child extends Parent{",
+        "  @Provides String foo() { return null; }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(parent, child))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(ErrorMessages.PROVIDES_METHOD_OVERRIDES_ANOTHER,
+            "Provides", "String test.Parent.foo()"));
+  }
+
+  @Test public void validatesIncludedModules() {
+    JavaFileObject module = JavaFileObjects.forSourceLines("test.Parent",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module(includes = Void.class)",
+        "class TestModule {}");
+    assertAbout(javaSources()).that(ImmutableList.of(module))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(ErrorMessages.REFERENCED_MODULE_NOT_ANNOTATED,
+            "java.lang.Void", "Module"));
+  }
+
+  @Test public void referencedModulesMustNotBeAbstract() {
+    JavaFileObject module = JavaFileObjects.forSourceLines("test.Parent",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module(includes = AbstractModule.class)",
+        "class TestModule {}");
+    JavaFileObject abstractModule = JavaFileObjects.forSourceLines("test.AbstractModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module",
+        "abstract class AbstractModule {}");
+    assertAbout(javaSources()).that(ImmutableList.of(module, abstractModule))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(ErrorMessages.REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT,
+            "test.AbstractModule"));
+  }
+
   @Test public void singleProvidesMethodNoArgs() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
@@ -255,10 +399,103 @@ private String formatModuleErrorMessage(String msg) {
         "  }",
         "",
         "  @Override public String get() {",
+        "    String provided = module.provideString();",
+        "    if (provided == null) {",
+        "      throw new NullPointerException(" + NPE_LITERAL + ");",
+        "    }",
+        "    return provided;",
+        "  }",
+        "",
+        "  public static Factory<String> create(TestModule module) {",
+        "    return new TestModule$$ProvideStringFactory(module);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
+  @Test public void singleProvidesMethodNoArgs_disableNullable() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides String provideString() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule$$ProvideStringFactory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule$$ProvideStringFactory implements Factory<String> {",
+        "  private final TestModule module;",
+        "",
+        "  public TestModule$$ProvideStringFactory(TestModule module) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "  }",
+        "",
+        "  @Override public String get() {",
+        "    return module.provideString();",
+        "  }",
+        "",
+        "  public static Factory<String> create(TestModule module) {",
+        "    return new TestModule$$ProvideStringFactory(module);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .withCompilerOptions("-Adagger.nullableValidation=WARNING")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
+  @Test public void nullableProvides() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides @Nullable String provideString() { return null; }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule$$ProvideStringFactory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule$$ProvideStringFactory implements Factory<String> {",
+        "  private final TestModule module;",
+        "",
+        "  public TestModule$$ProvideStringFactory(TestModule module) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "  }",
+        "",
+        "  @Override",
+        "  @Nullable",
+        "  public String get() {",
         "    return module.provideString();",
         "  }",
+        "",
+        "  public static Factory<String> create(TestModule module) {",
+        "    return new TestModule$$ProvideStringFactory(module);",
+        "  }",
         "}");
-    assert_().about(javaSource()).that(moduleFile)
+    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, NULLABLE))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(factoryFile);
@@ -346,10 +583,24 @@ private String formatModuleErrorMessage(String msg) {
         "  }",
         "",
         "  @Override public List<Object> get() {",
-        "    return module.provideObjects(aProvider.get(), bProvider.get(), xMembersInjector);",
+        "    List<Object> provided =",
+        "        module.provideObjects(aProvider.get(), bProvider.get(), xMembersInjector);",
+        "    if (provided == null) {",
+        "      throw new NullPointerException(" + NPE_LITERAL + ");",
+        "    }",
+        "    return provided;",
+        "  }",
+        "",
+        "  public static Factory<List<Object>> create(",
+        "      TestModule module,",
+        "      Provider<Object> aProvider,",
+        "      Provider<Object> bProvider,",
+        "      MembersInjector<X> xMembersInjector) {",
+        "    return new TestModule$$ProvideObjectsFactory(",
+        "        module, aProvider, bProvider, xMembersInjector);",
         "  }",
         "}");
-    assert_().about(javaSources()).that(
+    assertAbout(javaSources()).that(
             ImmutableList.of(classXFile, moduleFile, QUALIFIER_A, QUALIFIER_B))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -392,14 +643,18 @@ private String formatModuleErrorMessage(String msg) {
         "  @Override public Set<String> get() {",
         "    return Collections.singleton(module.provideString());",
         "  }",
+        "",
+        "  public static Factory<Set<String>> create(TestModule module) {",
+        "    return new TestModule$$ProvideStringFactory(module);",
+        "  }",
         "}");
-    assert_().about(javaSource()).that(moduleFile)
+    assertAbout(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(factoryFile);
   }
 
-  @Test public void proviesSetValues() {
+  @Test public void providesSetValues() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
@@ -432,10 +687,18 @@ private String formatModuleErrorMessage(String msg) {
         "  }",
         "",
         "  @Override public Set<String> get() {",
-        "    return module.provideStrings();",
+        "    Set<String> provided = module.provideStrings();",
+        "    if (provided == null) {",
+        "      throw new NullPointerException(" + NPE_LITERAL + ");",
+        "    }",
+        "    return provided;",
+        "  }",
+        "",
+        "  public static Factory<Set<String>> create(TestModule module) {",
+        "    return new TestModule$$ProvideStringsFactory(module);",
         "  }",
         "}");
-    assert_().about(javaSource()).that(moduleFile)
+    assertAbout(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(factoryFile);
@@ -458,7 +721,7 @@ private String formatModuleErrorMessage(String msg) {
         "    return \"\";",
         "  }",
         "}");
-    assert_().about(javaSource()).that(moduleFile)
+    assertAbout(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
     .withErrorContaining(formatErrorMessage(BINDING_METHOD_WITH_SAME_NAME)).in(moduleFile).onLine(8)
@@ -502,7 +765,7 @@ public void providedTypes() {
         "    return null;",
         "  }",
         "}");
-    assert_().about(javaSource()).that(moduleFile)
+    assertAbout(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError();
   }
@@ -518,7 +781,7 @@ public void privateModule() {
         "  @Module private static final class PrivateModule {",
         "  }",
         "}");
-    assert_().about(javaSource())
+    assertAbout(javaSource())
         .that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
@@ -539,7 +802,7 @@ public void enclosedInPrivateModule() {
         "    }",
         "  }",
         "}");
-    assert_().about(javaSource())
+    assertAbout(javaSource())
         .that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
@@ -583,7 +846,7 @@ public void publicModuleNonPublicIncludes() {
         "@Module",
         "public final class OtherPublicModule {",
         "}");
-    assert_().about(javaSources())
+    assertAbout(javaSources())
         .that(ImmutableList.of(
             publicModuleFile, nonPublicModule1File, nonPublicModule2File, otherPublicModuleFile))
         .processedWith(new ComponentProcessor())
@@ -594,4 +857,157 @@ public void publicModuleNonPublicIncludes() {
             + "test.NonPublicModule1 and test.NonPublicModule2 public.")
         .in(publicModuleFile).onLine(8);
   }
+  
+  @Test
+  public void genericSubclassedModule() {
+    JavaFileObject parent = JavaFileObjects.forSourceLines("test.ParentModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import java.util.List;",
+        "import java.util.ArrayList;",
+        "",
+        "@Module",
+        "abstract class ParentModule<A extends CharSequence,",
+        "                            B,",
+        "                            C extends Number & Comparable<C>> {",
+        "  @Provides List<B> provideListB(B b) {",
+        "    List<B> list = new ArrayList<B>();",
+        "    list.add(b);",
+        "    return list;",
+        "  }",
+        "}");
+    JavaFileObject numberChild = JavaFileObjects.forSourceLines("test.ChildNumberModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "class ChildNumberModule extends ParentModule<String, Number, Double> {",
+        "  @Provides Number provideNumber() { return 1; }",
+        "}");
+    JavaFileObject integerChild = JavaFileObjects.forSourceLines("test.ChildIntegerModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "class ChildIntegerModule extends ParentModule<StringBuilder, Integer, Float> {",
+        "  @Provides Integer provideInteger() { return 2; }",
+        "}");
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.C",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.List;",
+        "",
+        "@Component(modules={ChildNumberModule.class, ChildIntegerModule.class})",
+        "interface C {",
+        "  List<Number> numberList();",
+        "  List<Integer> integerList();",
+        "}");
+    JavaFileObject listBFactory = JavaFileObjects.forSourceLines(
+        "test.ParentModule$$ProvidesListBFactory",
+        "package test;", 
+        "", 
+        "import dagger.Factory;", 
+        "import java.util.List;", 
+        "import javax.annotation.Generated;", 
+        "import javax.inject.Provider;", 
+        "", 
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")", 
+        "public final class ParentModule$$ProvideListBFactory<A extends CharSequence,",
+        "    B, C extends Number & Comparable<C>> implements Factory<List<B>> {", 
+        "  private final ParentModule<A, B, C> module;", 
+        "  private final Provider<B> bProvider;", 
+        "", 
+        "  public ParentModule$$ProvideListBFactory(",
+        "        ParentModule<A, B, C> module, Provider<B> bProvider) {", 
+        "    assert module != null;", 
+        "    this.module = module;", 
+        "    assert bProvider != null;", 
+        "    this.bProvider = bProvider;", 
+        "  }", 
+        "", 
+        "  @Override", 
+        "  public List<B> get() {  ", 
+        "    List<B> provided = module.provideListB(bProvider.get());",
+        "    if (provided == null) {",
+        "      throw new NullPointerException(" + NPE_LITERAL + ");",
+        "    }",
+        "    return provided;", 
+        "  }", 
+        "", 
+        "  public static <A extends CharSequence, B, C extends Number & Comparable<C>>",
+        "      Factory<List<B>> create(ParentModule<A, B, C> module, Provider<B> bProvider) {",
+        "    return new ParentModule$$ProvideListBFactory<A, B, C>(module, bProvider);", 
+        "  }", 
+        "}");
+    JavaFileObject numberFactory = JavaFileObjects.forSourceLines(
+        "test.ChildNumberModule$$ProvideNumberFactory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class ChildNumberModule$$ProvideNumberFactory implements Factory<Number> {",
+        "  private final ChildNumberModule module;",
+        "",
+        "  public ChildNumberModule$$ProvideNumberFactory(ChildNumberModule module) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "  }",
+        "",
+        "  @Override",
+        "  public Number get() {  ",
+        "    Number provided = module.provideNumber();",
+        "    if (provided == null) {",
+        "      throw new NullPointerException(" + NPE_LITERAL + ");",
+        "    }",
+        "    return provided;",
+        "  }",
+        "",
+        "  public static Factory<Number> create(ChildNumberModule module) {",
+        "    return new ChildNumberModule$$ProvideNumberFactory(module);",
+        "  }",
+        "}");
+    JavaFileObject integerFactory = JavaFileObjects.forSourceLines(
+        "test.ChildIntegerModule$$ProvideIntegerFactory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class ChildIntegerModule$$ProvideIntegerFactory",
+        "    implements Factory<Integer> {",
+        "  private final ChildIntegerModule module;",
+        "",
+        "  public ChildIntegerModule$$ProvideIntegerFactory(ChildIntegerModule module) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "  }",
+        "",
+        "  @Override",
+        "  public Integer get() {  ",
+        "    Integer provided = module.provideInteger();",
+        "    if (provided == null) {",
+        "      throw new NullPointerException(" + NPE_LITERAL + ");",
+        "    }",
+        "    return provided;",
+        "  }",
+        "",
+        "  public static Factory<Integer> create(ChildIntegerModule module) {",
+        "    return new ChildIntegerModule$$ProvideIntegerFactory(module);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(parent, numberChild, integerChild, component))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(listBFactory, numberFactory, integerFactory);
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
index ed29f0036..a57b94749 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -83,4 +83,143 @@
         .failsToCompile()
         .withErrorContaining("is not annotated with @Module or @ProducerModule");
   }
+
+  @Test public void simpleComponent() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "import dagger.producers.ProductionComponent;",
+        "import javax.inject.Inject;",
+        "",
+        "final class TestClass {",
+        "  static final class C {",
+        "    @Inject C() {}",
+        "  }",
+        "",
+        "  interface A {}",
+        "  interface B {}",
+        "",
+        "  @Module",
+        "  static final class BModule {",
+        "    @Provides B b(C c) {",
+        "      return null;",
+        "    }",
+        "  }",
+        "",
+        "  @ProducerModule",
+        "  static final class AModule {",
+        "    @Produces ListenableFuture<A> a(B b) {",
+        "      return null;",
+        "    }",
+        "  }",
+        "",
+        "  @ProductionComponent(modules = {AModule.class, BModule.class})",
+        "  interface SimpleComponent {",
+        "    ListenableFuture<A> a();",
+        "  }",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.Dagger_TestClass_SimpleComponent",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.Producer;",
+        "import dagger.producers.internal.Producers;",
+        "import java.util.concurrent.Executor;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "import test.TestClass.A;",
+        "import test.TestClass.AModule;",
+        "import test.TestClass.B;",
+        "import test.TestClass.BModule;",
+        "import test.TestClass.SimpleComponent;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_TestClass_SimpleComponent implements SimpleComponent {",
+        "  private final AModule aModule;",
+        "  private final BModule bModule;",
+        "  private final Executor executor;",
+        "  private Provider<B> bProvider;",
+        "  private Producer<A> aProducer;",
+        "",
+        "  private Dagger_TestClass_SimpleComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    this.aModule = builder.aModule;",
+        "    this.bModule = builder.bModule;",
+        "    this.executor = builder.executor;",
+        "    initialize();",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  private void initialize() {",
+        "    this.bProvider = TestClass$BModule$$BFactory.create(",
+        "        bModule, TestClass$C$$Factory.create());",
+        "    this.aProducer = new TestClass$AModule$$AFactory(",
+        "        aModule, executor, Producers.producerFromProvider(bProvider));",
+        "  }",
+        "",
+        "  @Override",
+        "  public ListenableFuture<A> a() {",
+        "    return aProducer.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private AModule aModule;",
+        "    private BModule bModule;",
+        "    private Executor executor;",
+        "",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public SimpleComponent build() {",
+        "      if (aModule == null) {",
+        "        this.aModule = new AModule();",
+        "      }",
+        "      if (bModule == null) {",
+        "        this.bModule = new BModule();",
+        "      }",
+        "      if (executor == null) {",
+        "        throw new IllegalStateException(\"executor must be set\");",
+        "      }",
+        "      return new Dagger_TestClass_SimpleComponent(this);",
+        "    }",
+        "",
+        "    public Builder aModule(AModule aModule) {",
+        "      if (aModule == null) {",
+        "        throw new NullPointerException(\"aModule\");",
+        "      }",
+        "      this.aModule = aModule;",
+        "      return this;",
+        "    }",
+        "",
+        "    public Builder bModule(BModule bModule) {",
+        "      if (bModule == null) {",
+        "        throw new NullPointerException(\"bModule\");",
+        "      }",
+        "      this.bModule = bModule;",
+        "      return this;",
+        "    }",
+        "",
+        "    public Builder executor(Executor executor) {",
+        "      if (executor == null) {",
+        "        throw new NullPointerException(\"executor\");",
+        "      }",
+        "      this.executor = executor;",
+        "      return this;",
+        "    }",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
new file mode 100644
index 000000000..9f577b722
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
@@ -0,0 +1,164 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.testing.compile.JavaFileObjects;
+import java.util.Arrays;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+
+/**
+ * Unit tests for {@link BindingGraphValidator} that exercise producer-specific logic.
+ */
+@RunWith(JUnit4.class)
+public class ProductionGraphValidationTest {
+  @Test public void componentWithUnprovidedInput() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.MyComponent",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.ProductionComponent;",
+        "",
+        "@ProductionComponent(modules = FooModule.class)",
+        "interface MyComponent {",
+        "  ListenableFuture<Foo> getFoo();",
+        "}");
+    JavaFileObject module = JavaFileObjects.forSourceLines("test.FooModule",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "class Foo {}",
+        "class Bar {}",
+        "",
+        "@ProducerModule",
+        "class FooModule {",
+        "  @Produces Foo foo(Bar bar) {",
+        "    return null;",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(Arrays.asList(module, component))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("test.Bar cannot be provided without an @Inject constructor or from "
+            + "an @Provides- or @Produces-annotated method.")
+            .in(component).onLine(8);
+  }
+
+  @Test public void componentProductionWithNoDependencyChain() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.ProductionComponent;",
+        "",
+        "final class TestClass {",
+        "  interface A {}",
+        "",
+        "  @ProductionComponent()",
+        "  interface AComponent {",
+        "    ListenableFuture<A> getA();",
+        "  }",
+        "}");
+    String expectedError =
+        "test.TestClass.A cannot be provided without an @Provides- or @Produces-annotated method.";
+    assertAbout(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError).in(component).onLine(11);
+  }
+
+  @Test public void provisionDependsOnProduction() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "import dagger.producers.ProductionComponent;",
+        "",
+        "final class TestClass {",
+        "  interface A {}",
+        "  interface B {}",
+        "",
+        "  @Module",
+        "  final class AModule {",
+        "    @Provides A a(B b) {",
+        "      return null;",
+        "    }",
+        "  }",
+        "",
+        "  @ProducerModule",
+        "  final class BModule {",
+        "    @Produces ListenableFuture<B> b() {",
+        "      return null;",
+        "    }",
+        "  }",
+        "",
+        "  @ProductionComponent(modules = {AModule.class, BModule.class})",
+        "  interface AComponent {",
+        "    ListenableFuture<A> getA();",
+        "  }",
+        "}");
+    String expectedError =
+        "test.TestClass.A is a provision, which cannot depend on a production.";
+    assertAbout(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError).in(component).onLine(30);
+  }
+
+  @Test public void provisionEntryPointDependsOnProduction() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "import dagger.producers.ProductionComponent;",
+        "",
+        "final class TestClass {",
+        "  interface A {}",
+        "",
+        "  @ProducerModule",
+        "  final class AModule {",
+        "    @Produces ListenableFuture<A> a() {",
+        "      return null;",
+        "    }",
+        "  }",
+        "",
+        "  @ProductionComponent(modules = AModule.class)",
+        "  interface AComponent {",
+        "    A getA();",
+        "  }",
+        "}");
+    String expectedError =
+        "test.TestClass.A is a provision entry-point, which cannot depend on a production.";
+    assertAbout(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError).in(component).onLine(20);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/writer/ClassNameTest.java b/compiler/src/test/java/dagger/internal/codegen/writer/ClassNameTest.java
index 518b85981..acf895e74 100644
--- a/compiler/src/test/java/dagger/internal/codegen/writer/ClassNameTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/writer/ClassNameTest.java
@@ -26,7 +26,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assert_;
+import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 
 @RunWith(JUnit4.class)
@@ -34,7 +34,7 @@
   @Rule public CompilationRule compilationRule = new CompilationRule();
 
   @Test public void bestGuessForString_simpleClass() {
-    assert_().that(ClassName.bestGuessFromString(String.class.getName()))
+    assertThat(ClassName.bestGuessFromString(String.class.getName()))
         .isEqualTo(ClassName.create("java.lang", "String"));
   }
 
@@ -43,20 +43,20 @@
   }
 
   @Test public void bestGuessForString_nestedClass() {
-    assert_().that(ClassName.bestGuessFromString(Map.Entry.class.getCanonicalName()))
+    assertThat(ClassName.bestGuessFromString(Map.Entry.class.getCanonicalName()))
         .isEqualTo(ClassName.create("java.util", ImmutableList.of("Map"), "Entry"));
-    assert_().that(ClassName.bestGuessFromString(OuterClass.InnerClass.class.getCanonicalName()))
+    assertThat(ClassName.bestGuessFromString(OuterClass.InnerClass.class.getCanonicalName()))
         .isEqualTo(
             ClassName.create("dagger.internal.codegen.writer",
                 ImmutableList.of("ClassNameTest", "OuterClass"), "InnerClass"));
   }
 
   @Test public void bestGuessForString_defaultPackage() {
-    assert_().that(ClassName.bestGuessFromString("SomeClass"))
+    assertThat(ClassName.bestGuessFromString("SomeClass"))
         .isEqualTo(ClassName.create("", "SomeClass"));
-    assert_().that(ClassName.bestGuessFromString("SomeClass.Nested"))
+    assertThat(ClassName.bestGuessFromString("SomeClass.Nested"))
         .isEqualTo(ClassName.create("", ImmutableList.of("SomeClass"), "Nested"));
-    assert_().that(ClassName.bestGuessFromString("SomeClass.Nested.EvenMore"))
+    assertThat(ClassName.bestGuessFromString("SomeClass.Nested.EvenMore"))
         .isEqualTo(ClassName.create("", ImmutableList.of("SomeClass", "Nested"), "EvenMore"));
   }
 
@@ -78,7 +78,7 @@
   @Test public void classNameFromTypeElement() {
     Elements elements = compilationRule.getElements();
     TypeElement element = elements.getTypeElement(Object.class.getCanonicalName());
-    assert_().that(ClassName.fromTypeElement(element).canonicalName())
+    assertThat(ClassName.fromTypeElement(element).canonicalName())
         .isEqualTo("java.lang.Object");
   }
 
@@ -87,7 +87,7 @@
     TypeElement element = elements.getTypeElement(ClassNameTest.class.getCanonicalName());
     ClassName className = ClassName.fromTypeElement(element);
     ClassName peerName = className.peerNamed("Foo");
-    assert_().that(peerName.canonicalName())
+    assertThat(peerName.canonicalName())
         .isEqualTo("dagger.internal.codegen.writer.Foo");
   }
 
@@ -96,7 +96,7 @@
     TypeElement element = elements.getTypeElement(OuterClass.class.getCanonicalName());
     ClassName className = ClassName.fromTypeElement(element);
     ClassName peerName = className.peerNamed("Foo");
-    assert_().that(peerName.canonicalName())
+    assertThat(peerName.canonicalName())
         .isEqualTo("dagger.internal.codegen.writer.ClassNameTest.Foo");
   }
 
@@ -105,7 +105,19 @@
     TypeElement element = elements.getTypeElement(InnerClass.class.getCanonicalName());
     ClassName className = ClassName.fromTypeElement(element);
     ClassName peerName = className.peerNamed("Foo");
-    assert_().that(peerName.canonicalName())
+    assertThat(peerName.canonicalName())
         .isEqualTo("dagger.internal.codegen.writer.ClassNameTest.OuterClass.Foo");
   }
+
+  @Test public void fromClass_NonNestedClass() {
+    ClassName className = ClassName.fromClass(ClassNameTest.class);
+    assertThat(className.canonicalName()).isEqualTo(
+        "dagger.internal.codegen.writer.ClassNameTest");
+  }
+
+  @Test public void fromClass_NestedClass() {
+    ClassName className = ClassName.fromClass(InnerClass.class);
+    assertThat(className.canonicalName()).isEqualTo(
+        "dagger.internal.codegen.writer.ClassNameTest.OuterClass.InnerClass");
+  }
 }
diff --git a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
index 427762409..9a561e9ad 100644
--- a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
@@ -95,7 +95,8 @@
       "  }",
       "",
       "  private void initialize() {",
-      "    this.primitiveIntProvider = new PrimitiveModule$$PrimitiveIntFactory(primitiveModule);",
+      "    this.primitiveIntProvider =",
+      "        PrimitiveModule$$PrimitiveIntFactory.create(primitiveModule);",
       "    this.primitiveInjectableProvider =",
       "        PrimitiveInjectable$$Factory.create(primitiveIntProvider);",
       "  }",
diff --git a/core/src/main/java/dagger/Component.java b/core/src/main/java/dagger/Component.java
index ed6c4699c..eb0344749 100644
--- a/core/src/main/java/dagger/Component.java
+++ b/core/src/main/java/dagger/Component.java
@@ -16,12 +16,14 @@
 package dagger;
 
 import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import javax.inject.Inject;
 import javax.inject.Provider;
 import javax.inject.Qualifier;
 
 import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
  * Annotates an interface or abstract class for which a fully-formed, dependency-injected
@@ -55,6 +57,7 @@
  */
 // TODO(gak): add missing spec for @Scope
 // TODO(gak): add missing spec for component dependencies
+@Retention(RUNTIME) // Allows runtimes to have specialized behavior interoperating with Dagger.
 @Target(TYPE)
 @Documented
 public @interface Component {
diff --git a/core/src/main/java/dagger/Subcomponent.java b/core/src/main/java/dagger/Subcomponent.java
new file mode 100644
index 000000000..1775050c5
--- /dev/null
+++ b/core/src/main/java/dagger/Subcomponent.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.TYPE;
+
+/**
+ * A component that inherits the bindings from a parent {@link Component} or {@link Subcomponent}.
+ *
+ * <p>Subcomponent implementations only exist in the context of a parent and are associated with
+ * parents using factory methods on the component.  Simply add a method that returns the
+ * subcomponent on the parent.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+// TODO(gak): add missing spec for @Scope, validation, etc.
+@Target(TYPE)
+@Documented
+public @interface Subcomponent {
+  /**
+   * A list of classes annotated with {@link Module} whose bindings are used to generate the
+   * component implementation.
+   *
+   * <p>At the moment, only modules without arguments are supported.
+   */
+  Class<?>[] modules() default {};
+}
diff --git a/pom.xml b/pom.xml
index 38c463780..df36e3670 100644
--- a/pom.xml
+++ b/pom.xml
@@ -34,6 +34,7 @@
   <modules>
     <module>compiler</module>
     <module>core</module>
+    <!-- examples are handled in a default profile (see below) -->
     <module>producers</module>
   </modules>
 
@@ -208,8 +209,10 @@
     </plugins>
   </build>
 
-  <!-- 
-    A profile which when switched off excludes example modules - used for javadoc publishing
+  <!--
+    A profile which when switched off excludes example modules.  By default the profile
+    is on and invokes examples.  However, when processing javadocs, it is switched off
+    omitting the example code from the javadoc.
   -->
   <profiles>
     <profile>
