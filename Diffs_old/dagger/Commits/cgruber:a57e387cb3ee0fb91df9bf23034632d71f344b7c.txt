diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 37331e249..046b70cd6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -36,7 +36,6 @@
 import com.google.common.collect.Sets.SetView;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Component;
-import dagger.MapKey;
 import dagger.MembersInjector;
 import dagger.internal.Factory;
 import dagger.internal.InstanceFactory;
@@ -66,7 +65,6 @@
 import dagger.producers.internal.SetProducer;
 import java.util.Collection;
 import java.util.EnumSet;
-import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
@@ -74,35 +72,28 @@
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
 import javax.inject.Provider;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.Name;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementKindVisitor6;
-import javax.lang.model.util.SimpleAnnotationValueVisitor6;
-import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
 
-import static com.google.auto.common.AnnotationMirrors.getAnnotationValuesWithDefaults;
 import static com.google.auto.common.MoreTypes.asDeclared;
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static com.google.common.collect.Iterables.transform;
 import static dagger.internal.codegen.Binding.bindingPackageFor;
-import static dagger.internal.codegen.ConfigurationAnnotations.getMapKeys;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
+import static dagger.internal.codegen.MapKeys.getMapKeySnippet;
 import static dagger.internal.codegen.MembersInjectionBinding.Strategy.NO_OP;
 import static dagger.internal.codegen.ProvisionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
 import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
@@ -111,7 +102,8 @@
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.membersInjectorNameForMembersInjectionBinding;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
-import static dagger.internal.codegen.writer.Snippet.makeParametersSnippet;
+import static dagger.internal.codegen.Util.getKeyTypeOfMap;
+import static dagger.internal.codegen.Util.getProvidedValueTypeOfMap;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -503,7 +495,6 @@ private void writeSubcomponent(ClassWriter componentWriter,
     componentMethod.addModifiers(PUBLIC);
     componentMethod.annotate(Override.class);
 
-    TypeName subcomponentTypeName = TypeNames.forTypeMirror(subcomponentType);
     TypeElement subcomponentElement = MoreTypes.asTypeElement(subcomponentType);
     checkState(subcomponentElement.getModifiers().contains(ABSTRACT));
     subcomponentWriter.setSupertype(subcomponentElement);
@@ -930,7 +921,7 @@ private void initializeFrameworkTypes(BindingGraph input,
                   ImmutableSet<ProvisionBinding> provisionBindings =
                       (ImmutableSet<ProvisionBinding>) bindings;
                   for (ProvisionBinding provisionBinding : provisionBindings) {
-                    if (!isNonProviderMap(provisionBinding)
+                    if (!isNonProviderMap(provisionBinding.key().type())
                         && multibindingContributionSnippets.containsKey(provisionBinding)) {
                       Snippet snippet = multibindingContributionSnippets.get(provisionBinding);
                       initializeMethod.body().addSnippet("this.%s = %s;",
@@ -1341,231 +1332,44 @@ private Snippet initializeMapBinding(
       ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets,
       ImmutableMap<ContributionBinding, Snippet> multibindingContributionSnippets,
       Set<ProvisionBinding> bindings) {
-    Iterator<ProvisionBinding> iterator = bindings.iterator();
-    // get type information from first binding in iterator
-    ProvisionBinding firstBinding = iterator.next();
-    if (isNonProviderMap(firstBinding)) {
-      return Snippet.format("%s.create(%s)",
-          ClassName.fromClass(MapFactory.class),
-          memberSelectSnippets.get(
-              Iterables.getOnlyElement(firstBinding.dependencies()).bindingKey())
-                  .getSnippetFor(componentName));
-    } else {
-      DeclaredType mapType = asDeclared(firstBinding.key().type());
-      TypeMirror mapKeyType = Util.getKeyTypeOfMap(mapType);
-      TypeMirror mapValueType = Util.getProvidedValueTypeOfMap(mapType); // V of Map<K, Provider<V>>
-      StringBuilder snippetFormatBuilder = new StringBuilder("%s.<%s, %s>builder(%d)");
-      for (int i = 0; i < bindings.size(); i++) {
-        snippetFormatBuilder.append("\n    .put(%s, %s)");
-      }
-      snippetFormatBuilder.append("\n    .build()");
-
-      List<Object> argsBuilder = Lists.newArrayList();
-      argsBuilder.add(ClassName.fromClass(MapProviderFactory.class));
-      argsBuilder.add(TypeNames.forTypeMirror(mapKeyType));
-      argsBuilder.add(TypeNames.forTypeMirror(mapValueType));
-      argsBuilder.add(bindings.size());
-
-      writeEntry(argsBuilder, firstBinding, multibindingContributionSnippets.get(firstBinding));
-      while (iterator.hasNext()) {
-        ProvisionBinding binding = iterator.next();
-        writeEntry(argsBuilder, binding, multibindingContributionSnippets.get(binding));
-      }
-
-      return Snippet.format(snippetFormatBuilder.toString(),
-          argsBuilder.toArray(new Object[0]));
-    }
-  }
-
-  // add one map entry for map Provider in Constructor
-  private void writeEntry(List<Object> argsBuilder, Binding binding,
-      Snippet factory) {
-    AnnotationMirror mapKeyAnnotation =
-        Iterables.getOnlyElement(getMapKeys(binding.bindingElement()));
-    TypeElement mapKeyAnnotationElement =
-        MoreTypes.asTypeElement(mapKeyAnnotation.getAnnotationType());
-    ClassName mapKeyCreator = Util.getMapKeyCreatorClassName(mapKeyAnnotationElement);
-    if (mapKeyAnnotationElement.getAnnotation(MapKey.class).unwrapValue()) {
-      AnnotationValue unwrapMember = getOnlyElement(mapKeyAnnotation.getElementValues().values());
-      argsBuilder.add(
-          new UnwrappedMapKeyValueVisitor(mapKeyCreator).visit(unwrapMember, unwrapMember));
-    } else {
-      argsBuilder.add(annotationSnippet(mapKeyAnnotation, new MapKeyValueVisitor(mapKeyCreator)));
-    }
-    argsBuilder.add(factory);
-  }
-
-  private boolean isNonProviderMap(Binding binding) {
-    TypeMirror bindingType = binding.key().type();
-    return MoreTypes.isTypeOf(Map.class, bindingType) // Implicitly guarantees a declared type.
-        && !MoreTypes.isTypeOf(Provider.class, asDeclared(bindingType).getTypeArguments().get(1));
-  }
-
-  // TODO(dpb): Extract all this map-key support into a separate file.
-
-  /**
-   * Returns a snippet that calls a static method on {@code mapKeyCreator} to create an annotation
-   * from {@code annotationMirror}.
-   */
-  private static Snippet annotationSnippet(
-      AnnotationMirror annotationMirror, final MapKeyValueVisitor mapKeyValueVisitor) {
-    return Snippet.format(
-        "%s.create%s(%s)",
-        mapKeyValueVisitor.mapKeyCreator,
-        annotationMirror.getAnnotationType().asElement().getSimpleName(),
-        makeParametersSnippet(
-            transform(
-                getAnnotationValuesWithDefaults(annotationMirror).entrySet(),
-                new Function<Map.Entry<ExecutableElement, AnnotationValue>, Snippet>() {
-                  @Override
-                  public Snippet apply(Map.Entry<ExecutableElement, AnnotationValue> entry) {
-                    return ARRAY_LITERAL_PREFIX.visit(
-                        entry.getKey().getReturnType(),
-                        mapKeyValueVisitor.visit(entry.getValue(), entry.getValue()));
-                  }
-                })));
-  }
-
-  /**
-   * Returns a snippet to create the visited value in code. Expects its parameter to be a class with
-   * static creation methods for all nested annotation types.
-   *
-   * <p>Note that {@link AnnotationValue#toString()} is the source-code representation of the value
-   * <em>when used in an annotation</em>, which is not always the same as the representation needed
-   * when creating the value in a method body.
-   *
-   * <p>For example, inside an annotation, a nested array of {@code int}s is simply
-   * <code>{1, 2, 3}</code>, but in code it would have to be <code> new int[] {1, 2, 3}</code>.
-   */
-  static class MapKeyValueVisitor extends SimpleAnnotationValueVisitor6<Snippet, AnnotationValue> {
-
-    final ClassName mapKeyCreator;
+    // Get type information from the first binding.
+    ProvisionBinding firstBinding = bindings.iterator().next();
+    DeclaredType mapType = asDeclared(firstBinding.key().type());
 
-    MapKeyValueVisitor(ClassName mapKeyCreator) {
-      this.mapKeyCreator = mapKeyCreator;
-    }
-
-    @Override
-    public Snippet visitEnumConstant(VariableElement c, AnnotationValue p) {
+    if (isNonProviderMap(mapType)) {
       return Snippet.format(
-          "%s.%s", TypeNames.forTypeMirror(c.getEnclosingElement().asType()), c.getSimpleName());
-    }
-
-    @Override
-    public Snippet visitAnnotation(AnnotationMirror a, AnnotationValue p) {
-      return annotationSnippet(a, this);
-    }
-
-    @Override
-    public Snippet visitType(TypeMirror t, AnnotationValue p) {
-      return Snippet.format("%s.class", TypeNames.forTypeMirror(t));
-    }
-
-    @Override
-    public Snippet visitString(String s, AnnotationValue p) {
-      return Snippet.format("%s", p);
-    }
-
-    @Override
-    public Snippet visitByte(byte b, AnnotationValue p) {
-      return Snippet.format("(byte) %s", b);
-    }
-
-    @Override
-    public Snippet visitChar(char c, AnnotationValue p) {
-      return Snippet.format("%s", p);
-    }
-
-    @Override
-    public Snippet visitDouble(double d, AnnotationValue p) {
-      return Snippet.format("%sD", d);
-    }
-
-    @Override
-    public Snippet visitFloat(float f, AnnotationValue p) {
-      return Snippet.format("%sF", f);
-    }
-
-    @Override
-    public Snippet visitInt(int i, AnnotationValue p) {
-      return Snippet.format("(int) %s", i);
-    }
-
-    @Override
-    public Snippet visitLong(long i, AnnotationValue p) {
-      return Snippet.format("%sL", i);
+          "%s.create(%s)",
+          ClassName.fromClass(MapFactory.class),
+          memberSelectSnippets
+              .get(getOnlyElement(firstBinding.dependencies()).bindingKey())
+              .getSnippetFor(componentName));
     }
 
-    @Override
-    public Snippet visitShort(short s, AnnotationValue p) {
-      return Snippet.format("(short) %s", s);
+    ImmutableList.Builder<dagger.internal.codegen.writer.Snippet> snippets =
+        ImmutableList.builder();
+    snippets.add(
+        Snippet.format(
+            "%s.<%s, %s>builder(%d)",
+            ClassName.fromClass(MapProviderFactory.class),
+            TypeNames.forTypeMirror(getKeyTypeOfMap(mapType)),
+            TypeNames.forTypeMirror(getProvidedValueTypeOfMap(mapType)), // V of Map<K, Provider<V>>
+            bindings.size()));
+
+    for (ProvisionBinding binding : bindings) {
+      snippets.add(
+          Snippet.format(
+              "    .put(%s, %s)",
+              getMapKeySnippet(binding.bindingElement()),
+              multibindingContributionSnippets.get(binding)));
     }
 
-    @Override
-    protected Snippet defaultAction(Object o, AnnotationValue p) {
-      return Snippet.format("%s", o);
-    }
+    snippets.add(Snippet.format("    .build()"));
 
-    @Override
-    public Snippet visitArray(List<? extends AnnotationValue> values, AnnotationValue p) {
-      ImmutableList.Builder<Snippet> snippets = ImmutableList.builder();
-      for (int i = 0; i < values.size(); i++) {
-        snippets.add(this.visit(values.get(i), p));
-      }
-      return Snippet.format("{%s}", makeParametersSnippet(snippets.build()));
-    }
+    return Snippet.join(Joiner.on('\n'), snippets.build());
   }
 
-  /**
-   * Returns a snippet for the visited value. Expects its parameter to be a class with static
-   * creation methods for all nested annotation types.
-   *
-   * <p>Throws {@link IllegalArgumentException} if the visited value is an array.
-   */
-  private static class UnwrappedMapKeyValueVisitor extends MapKeyValueVisitor {
-
-    UnwrappedMapKeyValueVisitor(ClassName mapKeyCreator) {
-      super(mapKeyCreator);
-    }
-
-    @Override
-    public Snippet visitArray(List<? extends AnnotationValue> values, AnnotationValue p) {
-      throw new IllegalArgumentException("Cannot unwrap arrays");
-    }
+  private boolean isNonProviderMap(TypeMirror type) {
+    return MoreTypes.isTypeOf(Map.class, type) // Implicitly guarantees a declared type.
+        && !MoreTypes.isTypeOf(Provider.class, asDeclared(type).getTypeArguments().get(1));
   }
-
-  /**
-   * If the visited type is an array, prefixes the parameter snippet with {@code new T[]}, where
-   * {@code T} is the raw array component type.
-   */
-  private static final SimpleTypeVisitor6<Snippet, Snippet> ARRAY_LITERAL_PREFIX =
-      new SimpleTypeVisitor6<Snippet, Snippet>() {
-
-        @Override
-        public Snippet visitArray(ArrayType t, Snippet p) {
-          return Snippet.format("new %s[] %s", RAW_TYPE_NAME.visit(t.getComponentType()), p);
-        }
-
-        @Override
-        protected Snippet defaultAction(TypeMirror e, Snippet p) {
-          return p;
-        }
-      };
-
-  /**
-   * If the visited type is an array, returns the name of its raw component type; otherwise returns
-   * the name of the type itself.
-   */
-  private static final SimpleTypeVisitor6<TypeName, Void> RAW_TYPE_NAME =
-      new SimpleTypeVisitor6<TypeName, Void>() {
-        @Override
-        public TypeName visitDeclared(DeclaredType t, Void p) {
-          return ClassName.fromTypeElement(MoreTypes.asTypeElement(t));
-        }
-
-        @Override
-        protected TypeName defaultAction(TypeMirror e, Void p) {
-          return TypeNames.forTypeMirror(e);
-        }
-      };
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
index 63425665b..55649f750 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -15,7 +15,6 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Function;
@@ -26,7 +25,6 @@
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Sets;
 import dagger.Component;
-import dagger.MapKey;
 import dagger.Module;
 import dagger.Subcomponent;
 import dagger.producers.ProducerModule;
@@ -95,10 +93,6 @@ static boolean isComponent(TypeElement componentDefinitionType) {
     return convertClassArrayToListOfTypes(moduleAnnotation, INJECTS_ATTRIBUTE);
   }
 
-  static ImmutableSet<? extends AnnotationMirror> getMapKeys(Element element) {
-    return AnnotationMirrors.getAnnotatedAnnotations(element, MapKey.class);
-  }
-
   /** Returns the first type that specifies this' nullability, or absent if none. */
   static Optional<DeclaredType> getNullableType(Element element) {
     List<? extends AnnotationMirror> mirrors = element.getAnnotationMirrors();
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index b9eb21560..cd7579659 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -48,9 +48,9 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.ConfigurationAnnotations.getMapKeys;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
-import static dagger.internal.codegen.Util.getUnwrappedMapKeyType;
+import static dagger.internal.codegen.MapKeys.getMapKey;
+import static dagger.internal.codegen.MapKeys.getUnwrappedMapKeyType;
 import static dagger.internal.codegen.Util.unwrapOptionalEquivalence;
 import static dagger.internal.codegen.Util.wrapOptionalInEquivalence;
 import static javax.lang.model.element.ElementKind.METHOD;
@@ -272,7 +272,7 @@ private TypeMirror mapOfFactoryType(
     }
 
     private TypeMirror mapKeyType(ExecutableElement method) {
-      AnnotationMirror mapKeyAnnotation = Iterables.getOnlyElement(getMapKeys(method));
+      AnnotationMirror mapKeyAnnotation = getMapKey(method).get();
       MapKey mapKey = mapKeyAnnotation.getAnnotationType().asElement().getAnnotation(MapKey.class);
       return mapKey.unwrapValue()
           ? getUnwrappedMapKeyType(mapKeyAnnotation.getAnnotationType(), types)
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
index 2c3c514ce..8d72e5e48 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
@@ -41,6 +41,7 @@
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.util.SimpleTypeVisitor6;
 
+import static dagger.internal.codegen.MapKeys.getMapKeyCreatorClassName;
 import static dagger.internal.codegen.writer.Snippet.makeParametersSnippet;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PUBLIC;
@@ -95,7 +96,7 @@ static MapKeyCreatorSpecification unwrappedMapKeyWithAnnotationValue(
 
   @Override
   ClassName nameGeneratedType(MapKeyCreatorSpecification mapKeyCreatorType) {
-    return Util.getMapKeyCreatorClassName(mapKeyCreatorType.mapKeyElement());
+    return getMapKeyCreatorClassName(mapKeyCreatorType.mapKeyElement());
   }
 
   @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
index cc5a5cbdf..c4a264aa6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
@@ -32,7 +32,7 @@
 
 import static dagger.internal.codegen.MapKeyGenerator.MapKeyCreatorSpecification.unwrappedMapKeyWithAnnotationValue;
 import static dagger.internal.codegen.MapKeyGenerator.MapKeyCreatorSpecification.wrappedMapKey;
-import static dagger.internal.codegen.Util.getUnwrappedMapKeyType;
+import static dagger.internal.codegen.MapKeys.getUnwrappedMapKeyType;
 
 /**
  * The annotation processor responsible for validating the mapKey annotation and auto-generate
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeys.java b/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
new file mode 100644
index 000000000..f378bbb26
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
@@ -0,0 +1,319 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Function;
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import dagger.MapKey;
+import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.Snippet;
+import dagger.internal.codegen.writer.TypeName;
+import dagger.internal.codegen.writer.TypeNames;
+import java.util.List;
+import java.util.Map;
+import java.util.NoSuchElementException;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.ArrayType;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.PrimitiveType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.SimpleAnnotationValueVisitor6;
+import javax.lang.model.util.SimpleTypeVisitor6;
+import javax.lang.model.util.Types;
+
+import static com.google.auto.common.AnnotationMirrors.getAnnotatedAnnotations;
+import static com.google.auto.common.AnnotationMirrors.getAnnotationValuesWithDefaults;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static com.google.common.collect.Iterables.transform;
+import static dagger.internal.codegen.writer.Snippet.makeParametersSnippet;
+import static javax.lang.model.util.ElementFilter.methodsIn;
+
+/**
+ * Methods for extracting {@link MapKey} annotations and key snippets from binding elements.
+ */
+final class MapKeys {
+
+  /**
+   * If {@code bindingElement} is annotated with a {@link MapKey} annotation, returns it.
+   *
+   * @throws IllegalArgumentException if the element is annotated with more than one {@code MapKey}
+   *     annotation
+   */
+  static Optional<? extends AnnotationMirror> getMapKey(Element bindingElement) {
+    ImmutableSet<? extends AnnotationMirror> mapKeys = getMapKeys(bindingElement);
+    return mapKeys.isEmpty()
+        ? Optional.<AnnotationMirror>absent()
+        : Optional.of(getOnlyElement(mapKeys));
+  }
+
+  /**
+   * Returns all of the {@link MapKey} annotations that annotate {@code bindingElement}.
+   */
+  static ImmutableSet<? extends AnnotationMirror> getMapKeys(Element bindingElement) {
+    return getAnnotatedAnnotations(bindingElement, MapKey.class);
+  }
+
+  /**
+   * Returns the map key type for an unwrapped {@link MapKey} annotation type. If the single member
+   * type is primitive, returns the boxed type.
+   *
+   * @throws IllegalArgumentException if {@code mapKeyAnnotationType} is not an annotation type or
+   *     has more than one member, or if its single member is an array
+   * @throws NoSuchElementException if the annotation has no members
+   */
+  public static DeclaredType getUnwrappedMapKeyType(
+      final DeclaredType mapKeyAnnotationType, final Types types) {
+    checkArgument(
+        MoreTypes.asTypeElement(mapKeyAnnotationType).getKind() == ElementKind.ANNOTATION_TYPE,
+        "%s is not an annotation type",
+        mapKeyAnnotationType);
+
+    final ExecutableElement onlyElement =
+        getOnlyElement(methodsIn(mapKeyAnnotationType.asElement().getEnclosedElements()));
+
+    SimpleTypeVisitor6<DeclaredType, Void> keyTypeElementVisitor =
+        new SimpleTypeVisitor6<DeclaredType, Void>() {
+
+          @Override
+          public DeclaredType visitArray(ArrayType t, Void p) {
+            throw new IllegalArgumentException(
+                mapKeyAnnotationType + "." + onlyElement.getSimpleName() + " cannot be an array");
+          }
+
+          @Override
+          public DeclaredType visitPrimitive(PrimitiveType t, Void p) {
+            return MoreTypes.asDeclared(types.boxedClass(t).asType());
+          }
+
+          @Override
+          public DeclaredType visitDeclared(DeclaredType t, Void p) {
+            return t;
+          }
+        };
+    return keyTypeElementVisitor.visit(onlyElement.getReturnType());
+  }
+
+  /**
+   * Returns the name of the generated class that contains the static {@code create} methods for a
+   * {@link MapKey} annotation type.
+   */
+  public static ClassName getMapKeyCreatorClassName(TypeElement mapKeyType) {
+    ClassName enclosingClassName = ClassName.fromTypeElement(mapKeyType);
+    return enclosingClassName
+        .topLevelClassName()
+        .peerNamed(enclosingClassName.classFileName() + "Creator");
+  }
+
+  /**
+   * Returns a snippet for the map key specified by the {@link MapKey} annotation on
+   * {@code bindingElement}.
+   *
+   * @throws IllegalArgumentException if the element is annotated with more than one {@code MapKey}
+   *     annotation
+   * @throws IllegalStateException if {@code bindingElement} is not annotated with a {@code MapKey}
+   *     annotation
+   */
+  static Snippet getMapKeySnippet(Element bindingElement) {
+    AnnotationMirror mapKey = getMapKey(bindingElement).get();
+    TypeElement mapKeyAnnotationType = MoreTypes.asTypeElement(mapKey.getAnnotationType());
+    ClassName mapKeyCreator = MapKeys.getMapKeyCreatorClassName(mapKeyAnnotationType);
+    if (mapKeyAnnotationType.getAnnotation(MapKey.class).unwrapValue()) {
+      AnnotationValue memberToUnwrap = getOnlyElement(mapKey.getElementValues().values());
+      return new MapKeySnippetExceptArrays(mapKeyCreator).visit(memberToUnwrap, memberToUnwrap);
+    } else {
+      return annotationSnippet(mapKey, new MapKeySnippet(mapKeyCreator));
+    }
+  }
+
+  /**
+   * Returns a snippet to create the visited value in code. Expects its parameter to be a class with
+   * static creation methods for all nested annotation types.
+   *
+   * <p>Note that {@link AnnotationValue#toString()} is the source-code representation of the value
+   * <em>when used in an annotation</em>, which is not always the same as the representation needed
+   * when creating the value in a method body.
+   *
+   * <p>For example, inside an annotation, a nested array of {@code int}s is simply
+   * <code>{1, 2, 3}</code>, but in code it would have to be <code> new int[] {1, 2, 3}</code>.
+   */
+  private static class MapKeySnippet
+      extends SimpleAnnotationValueVisitor6<Snippet, AnnotationValue> {
+
+    final ClassName mapKeyCreator;
+
+    MapKeySnippet(ClassName mapKeyCreator) {
+      this.mapKeyCreator = mapKeyCreator;
+    }
+
+    @Override
+    public Snippet visitEnumConstant(VariableElement c, AnnotationValue p) {
+      return Snippet.format(
+          "%s.%s", TypeNames.forTypeMirror(c.getEnclosingElement().asType()), c.getSimpleName());
+    }
+
+    @Override
+    public Snippet visitAnnotation(AnnotationMirror a, AnnotationValue p) {
+      return annotationSnippet(a, this);
+    }
+
+    @Override
+    public Snippet visitType(TypeMirror t, AnnotationValue p) {
+      return Snippet.format("%s.class", TypeNames.forTypeMirror(t));
+    }
+
+    @Override
+    public Snippet visitString(String s, AnnotationValue p) {
+      return Snippet.format("%s", p);
+    }
+
+    @Override
+    public Snippet visitByte(byte b, AnnotationValue p) {
+      return Snippet.format("(byte) %s", b);
+    }
+
+    @Override
+    public Snippet visitChar(char c, AnnotationValue p) {
+      return Snippet.format("%s", p);
+    }
+
+    @Override
+    public Snippet visitDouble(double d, AnnotationValue p) {
+      return Snippet.format("%sD", d);
+    }
+
+    @Override
+    public Snippet visitFloat(float f, AnnotationValue p) {
+      return Snippet.format("%sF", f);
+    }
+
+    @Override
+    public Snippet visitInt(int i, AnnotationValue p) {
+      return Snippet.format("(int) %s", i);
+    }
+
+    @Override
+    public Snippet visitLong(long i, AnnotationValue p) {
+      return Snippet.format("%sL", i);
+    }
+
+    @Override
+    public Snippet visitShort(short s, AnnotationValue p) {
+      return Snippet.format("(short) %s", s);
+    }
+
+    @Override
+    protected Snippet defaultAction(Object o, AnnotationValue p) {
+      return Snippet.format("%s", o);
+    }
+
+    @Override
+    public Snippet visitArray(List<? extends AnnotationValue> values, AnnotationValue p) {
+      ImmutableList.Builder<Snippet> snippets = ImmutableList.builder();
+      for (int i = 0; i < values.size(); i++) {
+        snippets.add(this.visit(values.get(i), p));
+      }
+      return Snippet.format("{%s}", makeParametersSnippet(snippets.build()));
+    }
+  }
+
+  /**
+   * Returns a snippet for the visited value. Expects its parameter to be a class with static
+   * creation methods for all nested annotation types.
+   *
+   * <p>Throws {@link IllegalArgumentException} if the visited value is an array.
+   */
+  private static class MapKeySnippetExceptArrays extends MapKeySnippet {
+
+    MapKeySnippetExceptArrays(ClassName mapKeyCreator) {
+      super(mapKeyCreator);
+    }
+
+    @Override
+    public Snippet visitArray(List<? extends AnnotationValue> values, AnnotationValue p) {
+      throw new IllegalArgumentException("Cannot unwrap arrays");
+    }
+  }
+
+  /**
+   * Returns a snippet that calls a static method on {@code mapKeySnippet.mapKeyCreator} to create
+   * an annotation from {@code mapKeyAnnotation}.
+   */
+  private static Snippet annotationSnippet(
+      AnnotationMirror mapKeyAnnotation, final MapKeySnippet mapKeySnippet) {
+    return Snippet.format(
+        "%s.create%s(%s)",
+        mapKeySnippet.mapKeyCreator,
+        mapKeyAnnotation.getAnnotationType().asElement().getSimpleName(),
+        makeParametersSnippet(
+            transform(
+                getAnnotationValuesWithDefaults(mapKeyAnnotation).entrySet(),
+                new Function<Map.Entry<ExecutableElement, AnnotationValue>, Snippet>() {
+                  @Override
+                  public Snippet apply(Map.Entry<ExecutableElement, AnnotationValue> entry) {
+                    return ARRAY_LITERAL_PREFIX.visit(
+                        entry.getKey().getReturnType(),
+                        mapKeySnippet.visit(entry.getValue(), entry.getValue()));
+                  }
+                })));
+  }
+
+  /**
+   * If the visited type is an array, prefixes the parameter snippet with {@code new T[]}, where
+   * {@code T} is the raw array component type.
+   */
+  private static final SimpleTypeVisitor6<Snippet, Snippet> ARRAY_LITERAL_PREFIX =
+      new SimpleTypeVisitor6<Snippet, Snippet>() {
+
+        @Override
+        public Snippet visitArray(ArrayType t, Snippet p) {
+          return Snippet.format("new %s[] %s", RAW_TYPE_NAME.visit(t.getComponentType()), p);
+        }
+
+        @Override
+        protected Snippet defaultAction(TypeMirror e, Snippet p) {
+          return p;
+        }
+      };
+
+  /**
+   * If the visited type is an array, returns the name of its raw component type; otherwise returns
+   * the name of the type itself.
+   */
+  private static final SimpleTypeVisitor6<TypeName, Void> RAW_TYPE_NAME =
+      new SimpleTypeVisitor6<TypeName, Void>() {
+        @Override
+        public TypeName visitDeclared(DeclaredType t, Void p) {
+          return ClassName.fromTypeElement(MoreTypes.asTypeElement(t));
+        }
+
+        @Override
+        protected TypeName defaultAction(TypeMirror e, Void p) {
+          return TypeNames.forTypeMirror(e);
+        }
+      };
+
+  private MapKeys() {}
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
index cf4b43ec7..a6e77a712 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
@@ -35,7 +35,6 @@
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.ConfigurationAnnotations.getMapKeys;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
@@ -48,6 +47,7 @@
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RAW_FUTURE;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RETURN_TYPE;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;
+import static dagger.internal.codegen.MapKeys.getMapKeys;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.type.TypeKind.ARRAY;
@@ -108,10 +108,9 @@ private TypeElement getSetElement() {
 
     // check mapkey is right
     if (!producesAnnotation.type().equals(Produces.Type.MAP)
-        && (getMapKeys(producesMethodElement) != null
-            && !getMapKeys(producesMethodElement).isEmpty())) {
-      builder.addItem(formatErrorMessage(BINDING_METHOD_NOT_MAP_HAS_MAP_KEY),
-          producesMethodElement);
+        && !getMapKeys(producesMethodElement).isEmpty()) {
+      builder.addItem(
+          formatErrorMessage(BINDING_METHOD_NOT_MAP_HAS_MAP_KEY), producesMethodElement);
     }
 
     ProvidesMethodValidator.validateMethodQualifiers(builder, producesMethodElement);
@@ -123,18 +122,17 @@ private TypeElement getSetElement() {
         break;
       case MAP:
         validateSingleReturnType(builder, returnType);
-        ImmutableSet<? extends AnnotationMirror> annotationMirrors =
-            getMapKeys(producesMethodElement);
-        switch (annotationMirrors.size()) {
+        ImmutableSet<? extends AnnotationMirror> mapKeys = getMapKeys(producesMethodElement);
+        switch (mapKeys.size()) {
           case 0:
-            builder.addItem(formatErrorMessage(BINDING_METHOD_WITH_NO_MAP_KEY),
-                producesMethodElement);
+            builder.addItem(
+                formatErrorMessage(BINDING_METHOD_WITH_NO_MAP_KEY), producesMethodElement);
             break;
           case 1:
             break;
           default:
-            builder.addItem(formatErrorMessage(BINDING_METHOD_WITH_MULTIPLE_MAP_KEY),
-                producesMethodElement);
+            builder.addItem(
+                formatErrorMessage(BINDING_METHOD_WITH_MULTIPLE_MAP_KEY), producesMethodElement);
             break;
         }
         break;
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
index 535c5fa26..af2e1f0d6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
@@ -33,7 +33,6 @@
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.ConfigurationAnnotations.getMapKeys;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
@@ -47,9 +46,9 @@
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RETURN_SET;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
+import static dagger.internal.codegen.MapKeys.getMapKeys;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.STATIC;
 import static javax.lang.model.type.TypeKind.ARRAY;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.VOID;
@@ -84,7 +83,7 @@ private TypeElement getSetElement() {
       builder.addItem(formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE),
           providesMethodElement);
     }
-    
+
     if (!providesMethodElement.getTypeParameters().isEmpty()) {
       builder.addItem(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER),
           providesMethodElement);
@@ -105,13 +104,12 @@ private TypeElement getSetElement() {
       builder.addItem(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE),
           providesMethodElement);
     }
-  
+
     // check mapkey is right
-    if (!providesAnnotation.type().equals(Provides.Type.MAP) 
-        && (getMapKeys(providesMethodElement) != null
-            && getMapKeys(providesMethodElement).size() > 0)) {
-      builder.addItem(formatErrorMessage(BINDING_METHOD_NOT_MAP_HAS_MAP_KEY),
-          providesMethodElement);
+    if (!providesAnnotation.type().equals(Provides.Type.MAP)
+        && !getMapKeys(providesMethodElement).isEmpty()) {
+      builder.addItem(
+          formatErrorMessage(BINDING_METHOD_NOT_MAP_HAS_MAP_KEY), providesMethodElement);
     }
 
     validateMethodQualifiers(builder, providesMethodElement);
@@ -123,18 +121,17 @@ private TypeElement getSetElement() {
         break;
       case MAP:
         validateKeyType(builder, returnType);
-        ImmutableSet<? extends AnnotationMirror> annotationMirrors =
-            getMapKeys(providesMethodElement);
-        switch (annotationMirrors.size()) {
+        ImmutableSet<? extends AnnotationMirror> mapKeys = getMapKeys(providesMethodElement);
+        switch (mapKeys.size()) {
           case 0:
-            builder.addItem(formatErrorMessage(BINDING_METHOD_WITH_NO_MAP_KEY),
-                providesMethodElement);
+            builder.addItem(
+                formatErrorMessage(BINDING_METHOD_WITH_NO_MAP_KEY), providesMethodElement);
             break;
           case 1:
             break;
           default:
-            builder.addItem(formatErrorMessage(BINDING_METHOD_WITH_MULTIPLE_MAP_KEY),
-                providesMethodElement);
+            builder.addItem(
+                formatErrorMessage(BINDING_METHOD_WITH_MULTIPLE_MAP_KEY), providesMethodElement);
             break;
         }
         break;
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 6aa0fb04b..ff5df098b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -24,34 +24,23 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
-import dagger.MapKey;
-import dagger.internal.codegen.writer.ClassName;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
-import java.util.NoSuchElementException;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
-import javax.lang.model.util.SimpleTypeVisitor6;
-import javax.lang.model.util.Types;
 
-import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkState;
-import static com.google.common.collect.Iterables.getOnlyElement;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.STATIC;
-import static javax.lang.model.util.ElementFilter.methodsIn;
 
 /**
  * Utilities for handling types in annotation processors
@@ -85,56 +74,6 @@ public static DeclaredType getKeyTypeOfMap(DeclaredType mapType) {
     return MoreTypes.asDeclared(mapArgs.get(0));
   }
 
-  /**
-   * Returns the map key type for an unwrapped {@link MapKey} annotation type. If the single member
-   * type is primitive, returns the boxed type.
-   *
-   * @throws IllegalArgumentException if {@code mapKeyAnnotationType} is not an annotation type or
-   *     has more than one member, or if its single member is an array
-   * @throws NoSuchElementException if the annotation has no members
-   */
-  public static DeclaredType getUnwrappedMapKeyType(
-      final DeclaredType mapKeyAnnotationType, final Types types) {
-    checkArgument(
-        MoreTypes.asTypeElement(mapKeyAnnotationType).getKind() == ElementKind.ANNOTATION_TYPE,
-        "%s is not an annotation type",
-        mapKeyAnnotationType);
-
-    final ExecutableElement onlyElement =
-        getOnlyElement(methodsIn(mapKeyAnnotationType.asElement().getEnclosedElements()));
-
-    SimpleTypeVisitor6<DeclaredType, Void> keyTypeElementVisitor =
-        new SimpleTypeVisitor6<DeclaredType, Void>() {
-
-          @Override
-          public DeclaredType visitArray(ArrayType t, Void p) {
-            throw new IllegalArgumentException(
-                mapKeyAnnotationType + "." + onlyElement.getSimpleName() + " cannot be an array");
-          }
-
-          @Override
-          public DeclaredType visitPrimitive(PrimitiveType t, Void p) {
-            return MoreTypes.asDeclared(types.boxedClass(t).asType());
-          }
-
-          @Override
-          public DeclaredType visitDeclared(DeclaredType t, Void p) {
-            return t;
-          }
-        };
-    return keyTypeElementVisitor.visit(onlyElement.getReturnType());
-  }
-
-  /**
-   * Returns the name of the generated class that contains the static {@code create} methods for a
-   * {@link MapKey} annotation type.
-   */
-  public static ClassName getMapKeyCreatorClassName(TypeElement mapKeyType) {
-    ClassName enclosingClassName = ClassName.fromTypeElement(mapKeyType);
-    return enclosingClassName.topLevelClassName().peerNamed(
-        enclosingClassName.classFileName() + "Creator");
-  }
-
   /**
    * Wraps an {@link Optional} of a type in an {@code Optional} of a {@link Wrapper} for that type.
    */
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java b/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java
index 52aeb44b0..50dc91838 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java
@@ -129,4 +129,46 @@ public static Snippet makeParametersSnippet(Iterable<Snippet> parameterSnippets)
     }
     return new Snippet(stringBuilder.toString(), typesBuilder.build(), argsBuilder.build());
   }
+
+  /**
+   * A snippet that concatenates its arguments.
+   */
+  public static Snippet concat(Iterable<Snippet> snippets) {
+    return join(Joiner.on(""), snippets);
+  }
+
+  /**
+   * A snippet that joins its arguments with {@code joiner}.
+   */
+  public static Snippet join(Joiner joiner, Iterable<Snippet> snippets) {
+    FluentIterable<Snippet> fluentSnippets = FluentIterable.from(snippets);
+    return new Snippet(
+        fluentSnippets
+            .transform(
+                new Function<Snippet, String>() {
+                  @Override
+                  public String apply(Snippet snippet) {
+                    return snippet.format;
+                  }
+                })
+            .join(joiner),
+        fluentSnippets
+            .transformAndConcat(
+                new Function<Snippet, ImmutableSet<TypeName>>() {
+                  @Override
+                  public ImmutableSet<TypeName> apply(Snippet snippet) {
+                    return snippet.types;
+                  }
+                })
+            .toSet(),
+        fluentSnippets
+            .transformAndConcat(
+                new Function<Snippet, ImmutableList<Object>>() {
+                  @Override
+                  public ImmutableList<Object> apply(Snippet snippet) {
+                    return snippet.args;
+                  }
+                })
+            .toList());
+  }
 }
