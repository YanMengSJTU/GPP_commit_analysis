diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index c468046ca..f170f3988 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -17,7 +17,6 @@
 
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Equivalence;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.cache.Cache;
@@ -456,11 +455,10 @@ private MembersInjectionBinding rollUpMembersInjectionBindings(Key key) {
 
         // look for scope separately.  we do this for the case where @Singleton can appear twice
         // in the â€  compatibility mode
-        Optional<Equivalence.Wrapper<AnnotationMirror>> bindingScope =
-            provisionBinding.wrappedScope();
+        Scope bindingScope = provisionBinding.scope();
         if (bindingScope.isPresent()) {
           for (Resolver requestResolver : getResolverLineage().reverse()) {
-            if (bindingScope.equals(requestResolver.componentDescriptor.wrappedScope())) {
+            if (bindingScope.equals(requestResolver.componentDescriptor.scope())) {
               return Optional.of(requestResolver);
             }
           }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index dcea41985..ec1b1d91f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -15,7 +15,6 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
@@ -54,7 +53,6 @@
 import java.util.Map;
 import java.util.Set;
 import javax.inject.Provider;
-import javax.inject.Singleton;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
@@ -69,7 +67,6 @@
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreTypes.asDeclared;
-import static com.google.auto.common.MoreTypes.isTypeOf;
 import static com.google.common.base.Predicates.equalTo;
 import static com.google.common.base.Predicates.not;
 import static com.google.common.base.Verify.verify;
@@ -90,7 +87,6 @@
 import static dagger.internal.codegen.ErrorMessages.duplicateMapKeysError;
 import static dagger.internal.codegen.ErrorMessages.inconsistentMapKeyAnnotationsError;
 import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
-import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
 import static dagger.internal.codegen.Util.getKeyTypeOfMap;
 import static dagger.internal.codegen.Util.getProvidedValueTypeOfMap;
 import static dagger.internal.codegen.Util.getValueTypeOfMap;
@@ -555,12 +551,12 @@ private void validateComponentHierarchy(
      */
     private void validateDependencyScopes() {
       ComponentDescriptor descriptor = subject.componentDescriptor();
-      Optional<AnnotationMirror> scope = descriptor.scope();
+      Scope scope = descriptor.scope();
       ImmutableSet<TypeElement> scopedDependencies = scopedTypesIn(descriptor.dependencies());
       if (scope.isPresent()) {
         // Dagger 1.x scope compatibility requires this be suppress-able.
         if (scopeCycleValidationType.diagnosticKind().isPresent()
-            && isTypeOf(Singleton.class, scope.get().getAnnotationType())) {
+            && scope.isSingleton()) {
           // Singleton is a special-case representing the longest lifetime, and therefore
           // @Singleton components may not depend on scoped components
           if (!scopedDependencies.isEmpty()) {
@@ -574,7 +570,7 @@ private void validateDependencyScopes() {
           }
         } else if (scopedDependencies.size() > 1) {
           // Scoped components may depend on at most one scoped component.
-          StringBuilder message = new StringBuilder(ErrorMessages.format(scope.get()))
+          StringBuilder message = new StringBuilder(scope.getReadableSource())
               .append(' ')
               .append(descriptor.componentDefinitionType().getQualifiedName())
               .append(" depends on more than one scoped component:\n");
@@ -588,7 +584,7 @@ private void validateDependencyScopes() {
           if (!scopeCycleValidationType.equals(ValidationType.NONE)) {
             validateScopeHierarchy(descriptor.componentDefinitionType(),
                 descriptor.componentDefinitionType(),
-                new ArrayDeque<Equivalence.Wrapper<AnnotationMirror>>(),
+                new ArrayDeque<Scope>(),
                 new ArrayDeque<TypeElement>());
           }
         }
@@ -661,13 +657,11 @@ public boolean apply(TypeElement input) {
      */
     private void validateScopeHierarchy(TypeElement rootComponent,
         TypeElement componentType,
-        Deque<Equivalence.Wrapper<AnnotationMirror>> scopeStack,
+        Deque<Scope> scopeStack,
         Deque<TypeElement> scopedDependencyStack) {
-      Optional<AnnotationMirror> scope = getScopeAnnotation(componentType);
+      Scope scope = Scope.scopeOf(componentType);
       if (scope.isPresent()) {
-        Equivalence.Wrapper<AnnotationMirror> wrappedScope =
-            AnnotationMirrors.equivalence().wrap(scope.get());
-        if (scopeStack.contains(wrappedScope)) {
+        if (scopeStack.contains(scope)) {
           scopedDependencyStack.push(componentType);
           // Current scope has already appeared in the component chain.
           StringBuilder message = new StringBuilder();
@@ -688,7 +682,7 @@ private void validateScopeHierarchy(TypeElement rootComponent,
                 MoreTypes.asTypeElements(getComponentDependencies(componentAnnotation.get())));
             if (scopedDependencies.size() == 1) {
               // empty can be ignored (base-case), and > 1 is a different error reported separately.
-              scopeStack.push(wrappedScope);
+              scopeStack.push(scope);
               scopedDependencyStack.push(componentType);
               validateScopeHierarchy(rootComponent, getOnlyElement(scopedDependencies),
                   scopeStack, scopedDependencyStack);
@@ -706,16 +700,15 @@ private void validateScopeHierarchy(TypeElement rootComponent,
      */
     void validateComponentScope() {
       ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings = subject.resolvedBindings();
-      Optional<Equivalence.Wrapper<AnnotationMirror>> componentScope =
-          subject.componentDescriptor().wrappedScope();
+      Scope componentScope = subject.componentDescriptor().scope();
       ImmutableSet.Builder<String> incompatiblyScopedMethodsBuilder = ImmutableSet.builder();
       for (ResolvedBindings bindings : resolvedBindings.values()) {
         if (bindings.bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION)) {
           for (ContributionBinding contributionBinding : bindings.ownedContributionBindings()) {
             if (contributionBinding instanceof ProvisionBinding) {
               ProvisionBinding provisionBinding = (ProvisionBinding) contributionBinding;
-              if (provisionBinding.scope().isPresent()
-                  && !componentScope.equals(provisionBinding.wrappedScope())) {
+              Scope bindingScope = provisionBinding.scope();
+              if (bindingScope.isPresent() && !componentScope.equals(bindingScope)) {
                 // Scoped components cannot reference bindings to @Provides methods or @Inject
                 // types decorated by a different scope annotation. Unscoped components cannot
                 // reference to scoped @Provides methods or @Inject types decorated by any
@@ -728,9 +721,8 @@ void validateComponentScope() {
                         methodSignatureFormatter.format(provisionMethod));
                     break;
                   case INJECTION:
-                    incompatiblyScopedMethodsBuilder.add(stripCommonTypePrefixes(
-                        provisionBinding.scope().get().toString()) + " class "
-                            + provisionBinding.bindingTypeElement().getQualifiedName());
+                    incompatiblyScopedMethodsBuilder.add(bindingScope.getReadableSource()
+                        + " class " + provisionBinding.bindingTypeElement().getQualifiedName());
                     break;
                   default:
                     throw new IllegalStateException();
@@ -746,7 +738,7 @@ void validateComponentScope() {
         StringBuilder message = new StringBuilder(componentType.getQualifiedName());
         if (componentScope.isPresent()) {
           message.append(" scoped with ");
-          message.append(stripCommonTypePrefixes(ErrorMessages.format(componentScope.get().get())));
+          message.append(componentScope.getReadableSource());
           message.append(" may not reference bindings with different scopes:\n");
         } else {
           message.append(" (unscoped) may not reference scoped bindings:\n");
@@ -1025,9 +1017,9 @@ private boolean suppressCycleWarnings(ImmutableList<DependencyRequest> pathEleme
   private void appendIndentedComponentsList(StringBuilder message, Iterable<TypeElement> types) {
     for (TypeElement scopedComponent : types) {
       message.append(INDENT);
-      Optional<AnnotationMirror> scope = getScopeAnnotation(scopedComponent);
+      Scope scope = Scope.scopeOf(scopedComponent);
       if (scope.isPresent()) {
-        message.append(ErrorMessages.format(scope.get())).append(' ');
+        message.append(scope.getReadableSource()).append(' ');
       }
       message.append(stripCommonTypePrefixes(scopedComponent.getQualifiedName().toString()))
           .append('\n');
@@ -1041,7 +1033,7 @@ private void appendIndentedComponentsList(StringBuilder message, Iterable<TypeEl
   private ImmutableSet<TypeElement> scopedTypesIn(Set<TypeElement> types) {
     return FluentIterable.from(types).filter(new Predicate<TypeElement>() {
       @Override public boolean apply(TypeElement input) {
-        return getScopeAnnotation(input).isPresent();
+        return Scope.scopeOf(input).isPresent();
       }
     }).toSet();
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index dcb33aa95..7a5c13520 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -15,11 +15,9 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Equivalence;
 import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
@@ -59,9 +57,6 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
 import static dagger.internal.codegen.ConfigurationAnnotations.isComponent;
-import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
-import static dagger.internal.codegen.Util.unwrapOptionalEquivalence;
-import static dagger.internal.codegen.Util.wrapOptionalInEquivalence;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.VOID;
 
@@ -191,18 +186,9 @@ boolean isTopLevel() {
   abstract Optional<TypeElement> executorDependency();
 
   /**
-   * An optional annotation constraining the scope of this component.
+   * The scope of the component.
    */
-  Optional<AnnotationMirror> scope() {
-    return unwrapOptionalEquivalence(wrappedScope());
-  }
-
-  /**
-   * An optional annotation constraining the scope of this component wrapped in an
-   * {@link com.google.common.base.Equivalence.Wrapper} to preserve comparison semantics of
-   * {@link AnnotationMirror}.
-   */
-  abstract Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedScope();
+  abstract Scope scope();
 
   abstract ImmutableMap<ComponentMethodDescriptor, ComponentDescriptor> subcomponents();
 
@@ -340,7 +326,7 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
       Optional<DeclaredType> builderType =
           Optional.fromNullable(getOnlyElement(enclosedBuilders, null));
 
-      Optional<AnnotationMirror> scope = getScopeAnnotation(componentDefinitionType);
+      Scope scope = Scope.scopeOf(componentDefinitionType);
       return new AutoValue_ComponentDescriptor(
           kind,
           componentMirror,
@@ -349,7 +335,7 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
           modules.build(),
           dependencyMethodIndex.build(),
           executorDependency,
-          wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), scope),
+          scope,
           subcomponentDescriptors.build(),
           componentMethodsBuilder.build(),
           createBuilderSpec(builderType));
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index aec51f038..8a3c203c8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -15,11 +15,9 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Equivalence;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
@@ -27,7 +25,6 @@
 import java.util.Set;
 import javax.inject.Inject;
 import javax.inject.Provider;
-import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
@@ -44,11 +41,8 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
-import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
 import static dagger.internal.codegen.ProvisionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
-import static dagger.internal.codegen.Util.unwrapOptionalEquivalence;
-import static dagger.internal.codegen.Util.wrapOptionalInEquivalence;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.ElementKind.FIELD;
 import static javax.lang.model.element.ElementKind.METHOD;
@@ -99,17 +93,10 @@
   /** Returns provision type that was used to bind the key. */
   abstract Provides.Type provisionType();
 
-  /** The scope in which the binding declares the {@link #key()}. */
-  Optional<AnnotationMirror> scope() {
-    return unwrapOptionalEquivalence(wrappedScope());
-  }
-
   /**
-   * An optional annotation constraining the scope of this component wrapped in an
-   * {@link com.google.common.base.Equivalence.Wrapper} to preserve comparison semantics of
-   * {@link AnnotationMirror}.
+   * The scope of the provider.
    */
-  abstract Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedScope();
+  abstract Scope scope();
 
   /** If this provision requires members injection, this will be the corresponding request. */
   abstract Optional<DependencyRequest> memberInjectionRequest();
@@ -211,8 +198,7 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
               cxtorType.getParameterTypes());
       Optional<DependencyRequest> membersInjectionRequest =
           membersInjectionRequest(enclosingCxtorType);
-      Optional<AnnotationMirror> scope =
-          getScopeAnnotation(constructorElement.getEnclosingElement());
+      Scope scope = Scope.scopeOf(constructorElement.getEnclosingElement());
 
       TypeElement bindingTypeElement =
           MoreElements.asType(constructorElement.getEnclosingElement());
@@ -227,7 +213,7 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
           Optional.<TypeElement>absent(),
           Kind.INJECTION,
           Provides.Type.UNIQUE,
-          wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), scope),
+          scope,
           membersInjectionRequest);
     }
 
@@ -264,7 +250,7 @@ ProvisionBinding forProvidesMethod(ExecutableElement providesMethod, TypeMirror
               declaredContainer,
               providesMethod.getParameters(),
               resolvedMethod.getParameterTypes());
-      Optional<AnnotationMirror> scope = getScopeAnnotation(providesMethod);
+      Scope scope = Scope.scopeOf(providesMethod);
       return new AutoValue_ProvisionBinding(
           key,
           providesMethod,
@@ -275,7 +261,7 @@ ProvisionBinding forProvidesMethod(ExecutableElement providesMethod, TypeMirror
           Optional.of(MoreTypes.asTypeElement(declaredContainer)),
           Kind.PROVISION,
           providesAnnotation.type(),
-          wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), scope),
+          scope,
           Optional.<DependencyRequest>absent());
     }
 
@@ -284,7 +270,7 @@ ProvisionBinding forImplicitMapBinding(DependencyRequest explicitRequest,
       checkNotNull(explicitRequest);
       checkNotNull(implicitRequest);
       ImmutableSet<DependencyRequest> dependencies = ImmutableSet.of(implicitRequest);
-      Optional<AnnotationMirror> scope = getScopeAnnotation(implicitRequest.requestElement());
+      Scope scope = Scope.scopeOf(implicitRequest.requestElement());
       return new AutoValue_ProvisionBinding(
           explicitRequest.key(),
           implicitRequest.requestElement(),
@@ -295,7 +281,7 @@ ProvisionBinding forImplicitMapBinding(DependencyRequest explicitRequest,
           Optional.<TypeElement>absent(),
           Kind.SYNTHETIC_PROVISON,
           Provides.Type.MAP,
-          wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), scope),
+          scope,
           Optional.<DependencyRequest>absent());
     }
 
@@ -311,7 +297,7 @@ ProvisionBinding forComponent(TypeElement componentDefinitionType) {
           Optional.<TypeElement>absent(),
           Kind.COMPONENT,
           Provides.Type.UNIQUE,
-          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
+          Scope.unscoped(),
           Optional.<DependencyRequest>absent());
     }
 
@@ -319,7 +305,7 @@ ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
       checkNotNull(componentMethod);
       checkArgument(componentMethod.getKind().equals(METHOD));
       checkArgument(componentMethod.getParameters().isEmpty());
-      Optional<AnnotationMirror> scope = getScopeAnnotation(componentMethod);
+      Scope scope = Scope.scopeOf(componentMethod);
       return new AutoValue_ProvisionBinding(
           keyFactory.forComponentMethod(componentMethod),
           componentMethod,
@@ -330,7 +316,7 @@ ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
           Optional.<TypeElement>absent(),
           Kind.COMPONENT_PROVISION,
           Provides.Type.UNIQUE,
-          wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), scope),
+          scope,
           Optional.<DependencyRequest>absent());
     }
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Scope.java b/compiler/src/main/java/dagger/internal/codegen/Scope.java
new file mode 100644
index 000000000..bcb009d1e
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/Scope.java
@@ -0,0 +1,145 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.AnnotationMirrors;
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Optional;
+import com.google.common.base.Preconditions;
+import javax.annotation.Nullable;
+import javax.inject.Singleton;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+
+import static com.google.auto.common.MoreTypes.isTypeOf;
+import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
+import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
+
+/**
+ * A representation of the scope (or lack of it) associated with a component, providing method
+ * or injection location.
+ */
+final class Scope {
+
+  /**
+   * An internal representation for an unscoped binding.
+   */
+  private static final Scope UNSCOPED = new Scope();
+
+  /**
+   * The underlying {@link AnnotationMirror} that represents the scope annotation.
+   */
+  @Nullable
+  private final AnnotationMirror annotationMirror;
+
+  private Scope(@Nullable AnnotationMirror annotationMirror) {
+    this.annotationMirror = annotationMirror;
+  }
+
+  private Scope() {
+    this(null);
+  }
+
+  /**
+   * Returns representation for an unscoped binding.
+   */
+  static Scope unscoped() {
+    return UNSCOPED;
+  }
+
+  /**
+   * If the source code element has an associated scoped annotation then returns a representation
+   * of that scope, otherwise returns a representation for an unscoped binding.
+   */
+  static Scope scopeOf(Element element) {
+    Optional<AnnotationMirror> scopeAnnotation = getScopeAnnotation(element);
+    return scopeAnnotation.isPresent() ? new Scope(scopeAnnotation.get()) : UNSCOPED;
+  }
+
+  /**
+   * Returns true if the scope is present, i.e. it's not unscoped binding.
+   */
+  public boolean isPresent() {
+    return annotationMirror != null;
+  }
+
+  /**
+   * Returns true if the scope represents the {@link Singleton @Singleton} annotation.
+   */
+  public boolean isSingleton() {
+    return annotationMirror != null
+        && isTypeOf(Singleton.class, annotationMirror.getAnnotationType());
+  }
+
+  /**
+   * Returns the readable source representation (name with @ prefix) of the annotation type.
+   *
+   * <p>It's readable source because it has had common package prefixes removed, e.g.
+   * {@code @javax.inject.Singleton} is returned as {@code @Singleton}.
+   *
+   * <p>Make sure that the scope is actually {@link #isPresent() present} before calling as it will
+   * throw an {@link IllegalStateException} otherwise. This does not return any annotation values
+   * as according to {@link javax.inject.Scope} scope annotations are not supposed to use them.
+   */
+  public String getReadableSource() {
+    return stripCommonTypePrefixes("@" + getQualifiedName());
+  }
+
+  /**
+   * Returns the fully qualified name of the annotation type.
+   *
+   * <p>Make sure that the scope is actually {@link #isPresent() present} before calling as it will
+   * throw an {@link IllegalStateException} otherwise. This does not return any annotation values
+   * as according to {@link javax.inject.Scope} scope annotations are not supposed to use them.
+   */
+  public String getQualifiedName() {
+    Preconditions.checkState(annotationMirror != null,
+        "Cannot create a stripped source representation of no annotation");
+    TypeElement typeElement = MoreTypes.asTypeElement(annotationMirror.getAnnotationType());
+    return typeElement.getQualifiedName().toString();
+  }
+
+  /**
+   * Scopes are equal if the underlying {@link AnnotationMirror} are equivalent according to
+   * {@link AnnotationMirrors#equivalence()}.
+   */
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) {
+      return true;
+    } else if (obj instanceof Scope) {
+      Scope that = (Scope) obj;
+      return AnnotationMirrors.equivalence()
+        .equivalent(this.annotationMirror, that.annotationMirror);
+    } else {
+      return false;
+    }
+  }
+
+  @Override
+  public int hashCode() {
+    return AnnotationMirrors.equivalence().hash(annotationMirror);
+  }
+
+  /**
+   * Returns a debug representation of the scope.
+   */
+  @Override
+  public String toString() {
+    return annotationMirror == null ? "UNSCOPED" : annotationMirror.toString();
+  }
+}
