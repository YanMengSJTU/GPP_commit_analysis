diff --git a/compiler/src/main/java/dagger/internal/codegen/Binding.java b/compiler/src/main/java/dagger/internal/codegen/Binding.java
new file mode 100644
index 000000000..44faf5f3b
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/Binding.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
+
+import javax.inject.Inject;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * An abstract type for classes representing a Dagger binding.  Particularly, contains the
+ * {@link Element} that generated the binding and the {@link DependencyRequest} instances that are
+ * required to satisfy the binding, but leaves the specifics of the <i>mechanism</i> of the binding
+ * to the subtypes.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+abstract class Binding {
+  /** The field or method annotated with {@link Inject}. */
+  abstract Element bindingElement();
+
+  /** The type enclosing the binding {@link #bindingElement()}. */
+  TypeElement enclosingType() {
+    return ElementUtil.asTypeElement(bindingElement().getEnclosingElement());
+  }
+
+  /**
+   * The set of {@link DependencyRequest dependencies} required to satisfy this binding. For fields
+   * this will be a single element for the field and for methods this will be an element for each of
+   * the method parameters.
+   */
+  abstract ImmutableSet<DependencyRequest> dependencies();
+
+  /** Returns the {@link #dependencies()} indexed by {@link Key}. */
+  ImmutableSetMultimap<Key, DependencyRequest> dependenciesByKey() {
+    ImmutableSetMultimap.Builder<Key, DependencyRequest> builder = ImmutableSetMultimap.builder();
+    for (DependencyRequest dependency : dependencies()) {
+      builder.put(dependency.key(), dependency);
+    }
+    return builder.build();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ClassName.java b/compiler/src/main/java/dagger/internal/codegen/ClassName.java
index a7c84025f..c3a58c110 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ClassName.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ClassName.java
@@ -37,7 +37,6 @@
 import java.util.List;
 
 import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.NestingKind;
 import javax.lang.model.element.PackageElement;
 import javax.lang.model.element.TypeElement;
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java b/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
new file mode 100644
index 000000000..b762831aa
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Ascii;
+import com.google.common.base.Function;
+
+import dagger.Lazy;
+
+import javax.inject.Provider;
+
+/**
+ * Picks a reasonable name for what we think is being provided from the variable name associated
+ * with the {@link DependencyRequest}.  I.e. strips out words like "lazy" and "provider" if we
+ * believe that those refer to {@link Lazy} and {@link Provider} rather than the type being
+ * provided.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+//TODO(gak): develop the heuristics to get better names
+final class DependencyVariableNamer implements Function<DependencyRequest, String> {
+  @Override
+  public String apply(DependencyRequest dependency) {
+    String variableName = dependency.requestElement().getSimpleName().toString();
+    switch (dependency.kind()) {
+      case INSTANCE:
+        return variableName;
+      case LAZY:
+        return variableName.startsWith("lazy") && !variableName.equals("lazy")
+            ? Ascii.toLowerCase(variableName.charAt(4)) + variableName.substring(5)
+            : variableName;
+      case PROVIDER:
+        return variableName.endsWith("Provider") && !variableName.equals("Provider")
+            ? variableName.substring(0, variableName.length() - 8)
+            : variableName;
+      default:
+        throw new AssertionError();
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectConstructorFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/InjectConstructorFactoryGenerator.java
new file mode 100644
index 000000000..d4b8652c6
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectConstructorFactoryGenerator.java
@@ -0,0 +1,203 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.squareup.javawriter.JavaWriter.stringLiteral;
+import static com.squareup.javawriter.JavaWriter.type;
+import static dagger.internal.codegen.SourceFiles.collectImportsFromDependencies;
+import static dagger.internal.codegen.SourceFiles.flattenVariableMap;
+import static dagger.internal.codegen.SourceFiles.generateProviderNames;
+import static dagger.internal.codegen.SourceFiles.providerUsageStatement;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+
+import com.google.common.base.Function;
+import com.google.common.base.Functions;
+import com.google.common.base.Joiner;
+import com.google.common.base.Optional;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableBiMap;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSortedSet;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Ordering;
+import com.squareup.javawriter.JavaWriter;
+
+import dagger.Factory;
+import dagger.MembersInjector;
+
+import java.io.IOException;
+import java.util.EnumSet;
+import java.util.Map;
+import java.util.Map.Entry;
+
+import javax.annotation.Generated;
+import javax.annotation.processing.Filer;
+import javax.inject.Inject;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * Generates {@link Factory} implementations from {@link ProvisionBinding} instances for
+ * {@link Inject} constructors.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+final class InjectConstructorFactoryGenerator extends SourceFileGenerator<ProvisionBinding> {
+  private final ProviderTypeRepository providerTypeRepository;
+
+  InjectConstructorFactoryGenerator(Filer filer, ProviderTypeRepository providerTypeRepository) {
+    super(filer);
+    this.providerTypeRepository = providerTypeRepository;
+  }
+
+  @Override
+  ClassName nameGeneratedType(ProvisionBinding binding) {
+    TypeElement providedElement = binding.enclosingType();
+    ClassName providedClassName = ClassName.fromTypeElement(providedElement);
+    return providedClassName.peerNamed(providedClassName.simpleName() + "$$Factory");
+  }
+
+  @Override
+  Iterable<? extends Element> getOriginatingElements(ProvisionBinding binding) {
+    return ImmutableSet.of(binding.bindingElement());
+  }
+
+  @Override
+  Optional<? extends Element> getElementForErrorReporting(ProvisionBinding binding) {
+    return Optional.of(binding.bindingElement());
+  }
+
+  @Override
+  void write(ClassName factoryClassName, JavaWriter writer, ProvisionBinding binding)
+      throws IOException {
+    ClassName providedClassName = ClassName.fromTypeElement(binding.enclosingType());
+
+    writer.emitPackage(factoryClassName.packageName());
+
+    FluentIterable<ClassName> importsBuilder = FluentIterable.from(
+        collectImportsFromDependencies(factoryClassName, binding.dependencies()))
+            .append(ClassName.fromClass(Factory.class))
+            .append(ClassName.fromClass(Generated.class));
+    if (binding.requiresMemberInjection()) {
+      importsBuilder = importsBuilder.append(ClassName.fromClass(MembersInjector.class));
+    }
+    ImmutableSortedSet<String> imports = importsBuilder.transform(Functions.toStringFunction())
+            .toSortedSet(Ordering.natural());
+    writer.emitImports(imports).emitEmptyLine();
+
+    writer.emitAnnotation(Generated.class, stringLiteral(InjectProcessor.class.getName()))
+        .beginType(factoryClassName.simpleName(), "class", EnumSet.of(PUBLIC, FINAL), null,
+            type(Factory.class, Util.typeToString(binding.providedKey().type())));
+
+    final ImmutableBiMap<Key, String> providerNames =
+        generateProviderNames(ImmutableList.of(binding));
+
+    ImmutableMap.Builder<String, String> variableMapBuilder =
+        new ImmutableMap.Builder<String, String>();
+    if (binding.requiresMemberInjection()) {
+      variableMapBuilder.put("membersInjector",
+          type(MembersInjector.class, providedClassName.simpleName()));
+    }
+    ImmutableMap<String, String> variableMap = variableMapBuilder
+        .putAll(providersAsVariableMap(providerNames))
+        .build();
+
+    if (binding.requiresMemberInjection()) {
+      writeMembersInjectorField(writer, providedClassName);
+    }
+    writeProviderFields(writer, providerNames);
+
+    writeConstructor(writer, variableMap);
+
+    writer.emitAnnotation(Override.class)
+        .beginMethod(providedClassName.simpleName(), "get", EnumSet.of(PUBLIC));
+    String parameterString =
+        Joiner.on(", ").join(FluentIterable.from(binding.dependencies())
+            .transform(new Function<DependencyRequest, String>() {
+              @Override public String apply(DependencyRequest input) {
+                return providerUsageStatement(providerNames.get(input.key()), input.kind());
+              }
+            }));
+    if (binding.requiresMemberInjection()) {
+      writer.emitStatement("%1$s instance = new %1$s(%2$s)",
+          providedClassName.simpleName(), parameterString);
+      writer.emitStatement("membersInjector.injectMembers(instance)");
+      writer.emitStatement("return instance");
+    } else {
+      writer.emitStatement("return new %s(%s)", providedClassName.simpleName(), parameterString);
+    }
+    writer.endMethod().emitEmptyLine();
+
+    writeToString(writer, providedClassName);
+
+    writer.endType();
+  }
+
+  private void writeMembersInjectorField(JavaWriter writer, ClassName providedClassName)
+      throws IOException {
+    writer.emitField(type(MembersInjector.class, providedClassName.fullyQualifiedName()),
+        "membersInjector", EnumSet.of(PRIVATE, FINAL));
+  }
+
+  private void writeProviderFields(JavaWriter writer, ImmutableBiMap<Key, String> providerNames)
+      throws IOException {
+    for (Entry<Key, String> providerEntry : providerNames.entrySet()) {
+      Key key = providerEntry.getKey();
+      // TODO(gak): provide more elaborate information about which requests relate
+      writer.emitJavadoc(key.toString())
+          .emitField(providerTypeString(key), providerEntry.getValue(),
+              EnumSet.of(PRIVATE, FINAL));
+    }
+    writer.emitEmptyLine();
+  }
+
+  private void writeConstructor(JavaWriter writer, Map<String, String> variableMap)
+      throws IOException {
+    writer.beginConstructor(EnumSet.of(PUBLIC),
+        flattenVariableMap(variableMap),
+        ImmutableList.<String>of());
+    for (String variableName : variableMap.keySet()) {
+      writer.emitStatement("assert %s != null", variableName);
+      writer.emitStatement("this.%1$s = %1$s", variableName);
+    }
+    writer.endConstructor().emitEmptyLine();
+  }
+
+  private void writeToString(JavaWriter writer, ClassName providedClassName) throws IOException {
+    writer.emitAnnotation(Override.class)
+        .beginMethod("String", "toString", EnumSet.of(PUBLIC))
+        .emitStatement("return \"%s<%s>\"",
+            Factory.class.getSimpleName(), providedClassName.simpleName())
+        .endMethod();
+  }
+
+  private Map<String, String> providersAsVariableMap(ImmutableBiMap<Key, String> providerNames) {
+    return Maps.transformValues(providerNames.inverse(), new Function<Key, String>() {
+      @Override public String apply(Key key) {
+        return providerTypeString(key);
+      }
+    });
+  }
+
+  private String providerTypeString(Key key) {
+    return Util.typeToString(providerTypeRepository.getProviderType(key));
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
index ce16bbf70..4edbc6c2b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
@@ -47,6 +47,7 @@
 import java.util.Set;
 
 import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.Filer;
 import javax.annotation.processing.Messager;
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.annotation.processing.RoundEnvironment;
@@ -75,19 +76,26 @@
 @SupportedSourceVersion(RELEASE_6)
 public final class InjectProcessor extends AbstractProcessor {
   private Messager messager;
+  private ProvisionBinding.Factory provisionBindingFactory;
+  private InjectConstructorFactoryGenerator factoryWriter;
   private MembersInjectionBinding.Factory membersInjectionBindingFactory;
-  private MembersInjectorWriter membersInjectorWriter;
+  private MembersInjectorGenerator membersInjectorWriter;
 
   @Override
   public synchronized void init(ProcessingEnvironment processingEnv) {
     super.init(processingEnv);
     this.messager = processingEnv.getMessager();
+    Filer filer = processingEnv.getFiler();
     Elements elements = processingEnv.getElementUtils();
     Types types = processingEnv.getTypeUtils();
-    this.membersInjectionBindingFactory = new MembersInjectionBinding.Factory(
-        new DependencyRequest.Factory(elements, types));
-    this.membersInjectorWriter = new MembersInjectorWriter(processingEnv.getFiler(),
-        new ProviderTypeRepository(elements, types));
+    DependencyRequest.Factory dependencyRequestFactory =
+        new DependencyRequest.Factory(elements, types);
+    ProviderTypeRepository providerTypeRepository = new ProviderTypeRepository(elements, types);
+    this.provisionBindingFactory = new ProvisionBinding.Factory(dependencyRequestFactory);
+    this.factoryWriter = new InjectConstructorFactoryGenerator(filer, providerTypeRepository);
+    this.membersInjectionBindingFactory =
+        new MembersInjectionBinding.Factory(dependencyRequestFactory);
+    this.membersInjectorWriter = new MembersInjectorGenerator(filer, providerTypeRepository);
   }
 
   @Override
@@ -98,6 +106,7 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
   @Override
   public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
     // TODO(gak): add some error handling for bad source files
+    final ImmutableSet.Builder<ProvisionBinding> provisions = ImmutableSet.builder();
     final ImmutableSet.Builder<MembersInjectionBinding> membersInjections = ImmutableSet.builder();
 
     for (Element injectElement : roundEnv.getElementsAnnotatedWith(Inject.class)) {
@@ -111,7 +120,7 @@ public Void visitExecutableAsConstructor(ExecutableElement constructorElement, V
               report.printMessagesTo(messager);
 
               if (report.isClean()) {
-                // collect bindings for generating factories
+                provisions.add(provisionBindingFactory.forInjectConstructor(constructorElement));
               }
 
               return null;
@@ -151,7 +160,7 @@ public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
         Multimaps.index(membersInjections.build(),
             new Function<MembersInjectionBinding, TypeElement>() {
               @Override public TypeElement apply(MembersInjectionBinding binding) {
-                return binding.targetEnclosingType();
+                return binding.enclosingType();
               }
             });
 
@@ -163,6 +172,14 @@ public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
       }
     }
 
+    for (ProvisionBinding binding : provisions.build()) {
+      try {
+        factoryWriter.generate(binding);
+      } catch (SourceFileGenerationException e) {
+        e.printMessageTo(messager);
+      }
+    }
+
     return false;
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/JavaWriterUtil.java b/compiler/src/main/java/dagger/internal/codegen/JavaWriterUtil.java
deleted file mode 100644
index 9e45716b2..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/JavaWriterUtil.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.common.collect.ImmutableList;
-import com.squareup.javawriter.JavaWriter;
-
-import java.util.Map;
-import java.util.Map.Entry;
-
-/**
- * Utilities for working with {@link JavaWriter} instances.
- *
- * @author Gregory Kick
- * @since 2.0
- */
-// TODO(gak): push changes upstream to obviate the need for such utilities
-class JavaWriterUtil {
-  /**
-   * Given a mapping from variable name to type, returns a list of tokens suitable for methods such
-   * as {@link JavaWriter#beginMethod(String, String, java.util.Set, String...)}.
-   */
-  static ImmutableList<String> flattenVariableMap(Map<String, String> variableMap) {
-    ImmutableList.Builder<String> tokenList = ImmutableList.builder();
-    for (Entry<String, String> variableEntry : variableMap.entrySet()) {
-      tokenList.add(variableEntry.getValue(), variableEntry.getKey());
-    }
-    return tokenList.build();
-  }
-
-  private JavaWriterUtil() {}
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index c05a2c3e7..c92a133cc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -23,13 +23,10 @@
 import com.google.auto.value.AutoValue;
 import com.google.common.collect.ComparisonChain;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Ordering;
 
 import javax.inject.Inject;
-import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 
 /**
@@ -40,11 +37,11 @@
  * @since 2.0
  */
 @AutoValue
-abstract class MembersInjectionBinding {
+abstract class MembersInjectionBinding extends Binding {
   /**
    * Returns an {@link Ordering} suitable for sorting bindings into an ordering that abides by the
    * injection ordering specified in {@link Inject}. This ordering should not be used with bindings
-   * from different {@link #targetEnclosingType() types}.
+   * from different {@link #enclosingType() types}.
    */
   static Ordering<MembersInjectionBinding> injectionOrdering() {
     return INJECTION_ORDERING;
@@ -56,7 +53,7 @@
         public int compare(MembersInjectionBinding left, MembersInjectionBinding right) {
           return ComparisonChain.start()
               // fields before methods
-              .compare(left.target().getKind(), right.target().getKind())
+              .compare(left.bindingElement().getKind(), right.bindingElement().getKind())
               // then sort by whichever element comes first in the parent
               // this isn't necessary, but makes the processor nice and predictable
               .compare(targetIndexInEnclosing(left), targetIndexInEnclosing(right))
@@ -65,31 +62,7 @@ public int compare(MembersInjectionBinding left, MembersInjectionBinding right)
       };
 
   private static int targetIndexInEnclosing(MembersInjectionBinding binding)  {
-    return binding.targetEnclosingType().getEnclosedElements().indexOf(binding.target());
-  }
-
-  /** The field or method annotated with {@link Inject}. */
-  abstract Element target();
-
-  /** The type enclosing the binding {@link #target()}. */
-  TypeElement targetEnclosingType() {
-    return ElementUtil.asTypeElement(target().getEnclosingElement());
-  }
-
-  /**
-   * The set of {@link DependencyRequest dependencies} required to satisfy this binding. For fields
-   * this will be a single element for the field and for methods this will be an element for each of
-   * the method parameters.
-   */
-  abstract ImmutableSet<DependencyRequest> dependencies();
-
-  /** Returns the {@link #dependencies()} indexed by {@link Key}. */
-  ImmutableSetMultimap<Key, DependencyRequest> dependenciesByKey() {
-    ImmutableSetMultimap.Builder<Key, DependencyRequest> builder = ImmutableSetMultimap.builder();
-    for (DependencyRequest dependency : dependencies()) {
-      builder.put(dependency.key(), dependency);
-    }
-    return builder.build();
+    return binding.enclosingType().getEnclosedElements().indexOf(binding.bindingElement());
   }
 
   /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorDescriptor.java
index 5fa3d4df2..ce8845bfd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorDescriptor.java
@@ -50,7 +50,7 @@ static MembersInjectorDescriptor create(Iterable<MembersInjectionBinding> bindin
     TypeElement injectedTypeElement = Iterables.getOnlyElement(FluentIterable.from(bindings)
         .transform(new Function<MembersInjectionBinding, TypeElement>() {
           @Override public TypeElement apply(MembersInjectionBinding binding) {
-            return binding.targetEnclosingType();
+            return binding.enclosingType();
           }
         })
         .toSet());
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
new file mode 100644
index 000000000..5df0f33ff
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -0,0 +1,224 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.squareup.javawriter.JavaWriter.stringLiteral;
+import static com.squareup.javawriter.JavaWriter.type;
+import static dagger.internal.codegen.SourceFiles.DEPENDENCY_ORDERING;
+import static dagger.internal.codegen.SourceFiles.collectImportsFromDependencies;
+import static dagger.internal.codegen.SourceFiles.flattenVariableMap;
+import static dagger.internal.codegen.SourceFiles.generateProviderNames;
+import static dagger.internal.codegen.SourceFiles.providerUsageStatement;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+
+import com.google.common.base.Function;
+import com.google.common.base.Functions;
+import com.google.common.base.Joiner;
+import com.google.common.base.Optional;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableBiMap;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSortedSet;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Ordering;
+import com.squareup.javawriter.JavaWriter;
+
+import dagger.MembersInjector;
+
+import java.io.IOException;
+import java.util.EnumSet;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+
+import javax.annotation.Generated;
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.Name;
+import javax.lang.model.element.VariableElement;
+
+/**
+ * Generates {@link MembersInjector} implementations from {@link MembersInjectionBinding} instances.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+final class MembersInjectorGenerator extends SourceFileGenerator<MembersInjectorDescriptor> {
+  private final ProviderTypeRepository providerTypeRepository;
+
+  MembersInjectorGenerator(Filer filer, ProviderTypeRepository providerTypeRepository) {
+    super(filer);
+    this.providerTypeRepository = providerTypeRepository;
+  }
+
+  @Override
+  ClassName nameGeneratedType(MembersInjectorDescriptor descriptor) {
+    ClassName injectedClassName = descriptor.injectedClassName();
+    return injectedClassName.peerNamed(injectedClassName.simpleName() + "$$MembersInjector");
+  }
+
+  @Override
+  Iterable<? extends Element> getOriginatingElements(
+      MembersInjectorDescriptor descriptor) {
+    return FluentIterable.from(descriptor.bindings())
+        .transform(new Function<MembersInjectionBinding, Element>() {
+          @Override public Element apply(MembersInjectionBinding binding) {
+            return binding.bindingElement();
+          }
+        })
+        .toSet();
+  }
+
+  @Override
+  Optional<? extends Element> getElementForErrorReporting(MembersInjectorDescriptor input) {
+    return Optional.of(input.injectedClass());
+  }
+
+  @Override
+  void write(ClassName injectorClassName, JavaWriter writer, MembersInjectorDescriptor descriptor)
+      throws IOException {
+    ClassName injectedClassName = descriptor.injectedClassName();
+    ImmutableSortedSet<MembersInjectionBinding> bindings = descriptor.bindings();
+
+    writer.emitPackage(injectedClassName.packageName());
+
+    ImmutableSortedSet<DependencyRequest> dependencies = FluentIterable.from(descriptor.bindings())
+        .transformAndConcat(new Function<MembersInjectionBinding, Set<DependencyRequest>>() {
+          @Override public Set<DependencyRequest> apply(MembersInjectionBinding input) {
+            return input.dependencies();
+          }
+        })
+        .toSortedSet(DEPENDENCY_ORDERING);
+
+    ImmutableSortedSet<String> imports =
+        FluentIterable.from(collectImportsFromDependencies(injectorClassName, dependencies))
+            .append(ClassName.fromClass(MembersInjector.class))
+            .append(ClassName.fromClass(Generated.class))
+            .transform(Functions.toStringFunction())
+            .toSortedSet(Ordering.natural());
+    writer.emitImports(imports).emitEmptyLine();
+
+    writer.emitJavadoc("A {@link MembersInjector} implementation for {@link %s}.",
+        injectedClassName.simpleName());
+
+    String membersInjectorType = type(MembersInjector.class, injectedClassName.simpleName());
+    // @Generated("dagger.internal.codegen.InjectProcessor")
+    // public final class Blah$$MembersInjector implements MembersInjector<Blah>
+    writer.emitAnnotation(Generated.class, stringLiteral(InjectProcessor.class.getName()))
+        .beginType(injectorClassName.simpleName(), "class", EnumSet.of(FINAL), null,
+            membersInjectorType);
+
+
+    final ImmutableBiMap<Key, String> providerNames = generateProviderNames(descriptor.bindings());
+
+    // Add the fields
+    writeProviderFields(writer, providerNames);
+
+    // Add the constructor
+    writeConstructor(writer, providerNames);
+
+    // @Override public void injectMembers(Blah instance)
+    writer.emitAnnotation(Override.class)
+        .beginMethod("void", "injectMembers", EnumSet.of(PUBLIC),
+            injectedClassName.simpleName(), "instance");
+    // TODO(gak): figure out what (if anything) to do about being passed a subtype of the class
+    // specified as the type parameter for the MembersInjector.
+    writer.beginControlFlow("if (instance == null)")
+        .emitStatement(
+            "throw new NullPointerException(\"Cannot inject members into a null reference\")")
+        .endControlFlow();
+
+    for (MembersInjectionBinding binding : bindings) {
+      Element target = binding.bindingElement();
+      switch (target.getKind()) {
+        case FIELD:
+          Name fieldName = ((VariableElement) target).getSimpleName();
+          DependencyRequest singleDependency = Iterables.getOnlyElement(binding.dependencies());
+          String providerName = providerNames.get(singleDependency.key());
+          writer.emitStatement("instance.%s = %s",
+              fieldName, providerUsageStatement(providerName, singleDependency.kind()));
+          break;
+        case METHOD:
+          Name methodName = ((ExecutableElement) target).getSimpleName();
+          String parameterString =
+              Joiner.on(", ").join(FluentIterable.from(binding.dependencies())
+                  .transform(new Function<DependencyRequest, String>() {
+                    @Override public String apply(DependencyRequest input) {
+                      return providerUsageStatement(providerNames.get(input.key()), input.kind());
+                    }
+                  }));
+          writer.emitStatement("instance.%s(%s)", methodName, parameterString);
+          break;
+        default:
+          throw new IllegalStateException(target.getKind().toString());
+      }
+    }
+    writer.endMethod();
+
+    writeToString(writer, injectedClassName);
+
+    writer.endType();
+  }
+
+  private void writeProviderFields(JavaWriter writer, ImmutableBiMap<Key, String> providerNames)
+      throws IOException {
+    for (Entry<Key, String> providerEntry : providerNames.entrySet()) {
+      Key key = providerEntry.getKey();
+      // TODO(gak): provide more elaborate information about which requests relate
+      writer.emitJavadoc(key.toString())
+          .emitField(providerTypeString(key), providerEntry.getValue(),
+              EnumSet.of(PRIVATE, FINAL));
+    }
+    writer.emitEmptyLine();
+  }
+
+  private void writeConstructor(JavaWriter writer, ImmutableBiMap<Key, String> providerNames)
+      throws IOException {
+    writer.beginConstructor(EnumSet.noneOf(Modifier.class),
+        flattenVariableMap(providersAsVariableMap(providerNames)),
+        ImmutableList.<String>of());
+    for (String providerName : providerNames.values()) {
+      writer.emitStatement("assert %s != null", providerName);
+      writer.emitStatement("this.%1$s = %1$s", providerName);
+    }
+    writer.endConstructor().emitEmptyLine();
+  }
+
+  private void writeToString(JavaWriter writer, ClassName injectedClassName) throws IOException {
+    writer.emitAnnotation(Override.class)
+        .beginMethod("String", "toString", EnumSet.of(PUBLIC))
+        .emitStatement("return \"%s<%s>\"",
+            MembersInjector.class.getSimpleName(), injectedClassName.simpleName())
+        .endMethod();
+  }
+
+  private Map<String, String> providersAsVariableMap(ImmutableBiMap<Key, String> providerNames) {
+    return Maps.transformValues(providerNames.inverse(), new Function<Key, String>() {
+      @Override public String apply(Key key) {
+        return providerTypeString(key);
+      }
+    });
+  }
+
+  private String providerTypeString(Key key) {
+    return Util.typeToString(providerTypeRepository.getProviderType(key));
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorWriter.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorWriter.java
deleted file mode 100644
index f91e5e442..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorWriter.java
+++ /dev/null
@@ -1,403 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import static com.google.common.base.CaseFormat.UPPER_CAMEL;
-import static com.squareup.javawriter.JavaWriter.stringLiteral;
-import static com.squareup.javawriter.JavaWriter.type;
-import static dagger.internal.codegen.JavaWriterUtil.flattenVariableMap;
-import static javax.lang.model.element.Modifier.FINAL;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.PUBLIC;
-
-import com.google.common.base.Ascii;
-import com.google.common.base.CaseFormat;
-import com.google.common.base.Function;
-import com.google.common.base.Joiner;
-import com.google.common.base.Optional;
-import com.google.common.collect.BiMap;
-import com.google.common.collect.ComparisonChain;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.HashBiMap;
-import com.google.common.collect.ImmutableBiMap;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.ImmutableSetMultimap;
-import com.google.common.collect.ImmutableSortedMap;
-import com.google.common.collect.ImmutableSortedSet;
-import com.google.common.collect.Iterables;
-import com.google.common.collect.Maps;
-import com.google.common.collect.Ordering;
-import com.google.common.collect.SetMultimap;
-import com.squareup.javawriter.JavaWriter;
-
-import dagger.Lazy;
-import dagger.MembersInjector;
-import dagger.internal.DoubleCheckLazy;
-
-import java.io.IOException;
-import java.util.Collection;
-import java.util.EnumSet;
-import java.util.Iterator;
-import java.util.Map;
-import java.util.Map.Entry;
-
-import javax.annotation.Generated;
-import javax.annotation.processing.Filer;
-import javax.inject.Inject;
-import javax.inject.Provider;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.Name;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
-
-/**
- * Writes {@link MembersInjector} implementations from {@link MembersInjectionBinding} instances.
- *
- * @author Gregory Kick
- * @since 2.0
- */
-final class MembersInjectorWriter extends SourceFileGenerator<MembersInjectorDescriptor> {
-  private final ProviderTypeRepository providerTypeRepository;
-
-  MembersInjectorWriter(Filer filer, ProviderTypeRepository providerTypeRepository) {
-    super(filer);
-    this.providerTypeRepository = providerTypeRepository;
-  }
-
-  @Override
-  ClassName nameGeneratedType(MembersInjectorDescriptor descriptor) {
-    ClassName injectedClassName = descriptor.injectedClassName();
-    return injectedClassName.peerNamed(injectedClassName.simpleName() + "$$MembersInjector");
-  }
-
-  @Override
-  Iterable<? extends Element> getOriginatingElements(
-      MembersInjectorDescriptor descriptor) {
-    return FluentIterable.from(descriptor.bindings())
-        .transform(new Function<MembersInjectionBinding, Element>() {
-          @Override public Element apply(MembersInjectionBinding binding) {
-            return binding.target();
-          }
-        })
-        .toSet();
-  }
-
-  @Override
-  Optional<? extends Element> getElementForErrorReporting(MembersInjectorDescriptor input) {
-    return Optional.of(input.injectedClass());
-  }
-
-  @Override
-  void write(ClassName injectorClassName, JavaWriter writer, MembersInjectorDescriptor descriptor)
-      throws IOException {
-    ClassName injectedClassName = descriptor.injectedClassName();
-    ImmutableSortedSet<MembersInjectionBinding> bindings = descriptor.bindings();
-
-    writer.emitPackage(injectedClassName.packageName());
-
-    for (ClassName className : collectImports(injectorClassName, bindings)) {
-      writer.emitImports(className.fullyQualifiedName());
-    }
-    writer.emitEmptyLine();
-
-    writer.emitJavadoc("A {@link MembersInjector} implementation for {@link %s}.",
-        injectedClassName.simpleName());
-
-    String membersInjectorType = type(MembersInjector.class, injectedClassName.simpleName());
-    // @Generated("dagger.internal.codegen.InjectProcessor")
-    // public final class Blah$$MembersInjector implements MembersInjector<Blah>
-    writer.emitAnnotation(Generated.class, stringLiteral(InjectProcessor.class.getName()))
-    .beginType(injectorClassName.simpleName(), "class", EnumSet.of(FINAL), null,
-        membersInjectorType);
-
-    // Require a Provider/MembersInjector for each request
-    ImmutableSetMultimap.Builder<Key, DependencyRequest> dependenciesByKeyBuilder =
-        new ImmutableSetMultimap.Builder<Key, DependencyRequest>()
-        .orderValuesBy(DEPENDENCY_ORDERING);
-    for (MembersInjectionBinding binding : bindings) {
-      for (DependencyRequest dependency : binding.dependencies()) {
-        dependenciesByKeyBuilder.put(dependency.key(), dependency);
-      }
-    }
-    ImmutableSetMultimap<Key, DependencyRequest> dependenciesByKey =
-        dependenciesByKeyBuilder.build();
-
-
-    final ImmutableBiMap<Key, String> providerNames = generateProviderNames(dependenciesByKey);
-
-    // Add the fields
-    writeProviderFields(writer, providerNames);
-
-    // Add the constructor
-    writeConstructor(writer, providerNames);
-
-    // @Override public void injectMembers(Blah instance)
-    writer.emitAnnotation(Override.class)
-    .beginMethod("void", "injectMembers", EnumSet.of(PUBLIC),
-        injectedClassName.simpleName(), "instance");
-    writer.beginControlFlow("if (instance == null)")
-    .emitStatement(
-        "throw new NullPointerException(\"Cannot inject members into a null reference\")")
-        .endControlFlow();
-
-    for (MembersInjectionBinding binding : bindings) {
-      Element target = binding.target();
-      switch (target.getKind()) {
-        case FIELD:
-          Name fieldName = ((VariableElement) target).getSimpleName();
-          DependencyRequest singleDependency = Iterables.getOnlyElement(binding.dependencies());
-          String providerName = providerNames.get(singleDependency.key());
-          switch (singleDependency.kind()) {
-            case LAZY:
-              writer.emitStatement("instance.%s = %s.create(%s)",
-                  fieldName, DoubleCheckLazy.class.getSimpleName(), providerName);
-              break;
-            case INSTANCE:
-              writer.emitStatement("instance.%s = %s.get()", fieldName, providerName);
-              break;
-            case PROVIDER:
-              writer.emitStatement("instance.%s = %s", fieldName, providerName);
-              break;
-            default:
-              throw new AssertionError();
-          }
-          break;
-        case METHOD:
-          Name methodName = ((ExecutableElement) target).getSimpleName();
-          String parameterString =
-              Joiner.on(", ").join(FluentIterable.from(binding.dependencies())
-                  .transform(new Function<DependencyRequest, String>() {
-                    @Override public String apply(DependencyRequest input) {
-                      String providerName = providerNames.get(input.key());
-                      switch (input.kind()) {
-                        case LAZY:
-                          return String.format("%s.create(%s)",
-                              DoubleCheckLazy.class.getSimpleName(), providerName);
-                        case INSTANCE:
-                          return String.format("%s.get()", providerName);
-                        case PROVIDER:
-                          return String.format("%s", providerName);
-                        default:
-                          throw new AssertionError();
-                      }
-                    }
-                  }));
-          writer.emitStatement("instance.%s(%s)", methodName, parameterString);
-          break;
-        default:
-          throw new IllegalStateException(target.getKind().toString());
-      }
-    }
-    writer.endMethod();
-
-    writeToString(writer, injectedClassName);
-
-    writer.endType();
-  }
-
-  private void writeProviderFields(JavaWriter writer, ImmutableBiMap<Key, String> providerNames)
-      throws IOException {
-    for (Entry<Key, String> providerEntry : providerNames.entrySet()) {
-      Key key = providerEntry.getKey();
-      // TODO(gak): provide more elaborate information about which requests relate
-      writer.emitJavadoc(key.toString())
-          .emitField(providerTypeString(key), providerEntry.getValue(),
-              EnumSet.of(PRIVATE, FINAL));
-    }
-    writer.emitEmptyLine();
-  }
-
-  private void writeConstructor(JavaWriter writer, ImmutableBiMap<Key, String> providerNames)
-      throws IOException {
-    writer.emitAnnotation(Inject.class);
-    writer.beginConstructor(EnumSet.noneOf(Modifier.class),
-        flattenVariableMap(providersAsVariableMap(providerNames)),
-        ImmutableList.<String>of());
-    for (String providerName : providerNames.values()) {
-      writer.emitStatement("assert %s != null", providerName);
-      writer.emitStatement("this.%1$s = %1$s", providerName);
-    }
-    writer.endConstructor().emitEmptyLine();
-  }
-
-  private void writeToString(JavaWriter writer, ClassName injectedClassName) throws IOException {
-    writer.emitAnnotation(Override.class)
-        .beginMethod("String", "toString", EnumSet.of(PUBLIC))
-        .emitStatement("return \"MembersInjector<%s>\"", injectedClassName.simpleName())
-        .endMethod();
-  }
-
-  private Map<String, String> providersAsVariableMap(ImmutableBiMap<Key, String> providerNames) {
-    return Maps.transformValues(providerNames.inverse(), new Function<Key, String>() {
-      @Override public String apply(Key key) {
-        return providerTypeString(key);
-      }
-    });
-  }
-
-  private String providerTypeString(Key key) {
-    return Util.typeToString(providerTypeRepository.getProviderType(key));
-  }
-
-  /**
-   * Returns the sorted set of all classes required by the {@link MembersInjector} implementation
-   * being generated.
-   */
-  private ImmutableSortedSet<ClassName> collectImports(ClassName topLevelClassName,
-      Iterable<MembersInjectionBinding> bindings) {
-    ImmutableSortedSet.Builder<ClassName> builder = ImmutableSortedSet.<ClassName>naturalOrder()
-        .add(ClassName.fromClass(Inject.class))
-        .add(ClassName.fromClass(MembersInjector.class))
-        .add(ClassName.fromClass(Generated.class));
-    ImmutableSet<String> packagesToSkip  =
-        ImmutableSet.of("java.lang", topLevelClassName.packageName());
-    for (MembersInjectionBinding binding : bindings) {
-      for (DependencyRequest dependency : binding.dependencies()) {
-        ImmutableSet<TypeElement> referencedTypes =
-            Mirrors.referencedTypes(dependency.key().type());
-        switch (dependency.kind()) {
-          case LAZY:
-            builder.add(ClassName.fromClass(Lazy.class), ClassName.fromClass(DoubleCheckLazy.class));
-            // fall through
-          case INSTANCE:
-          case PROVIDER:
-            builder.add(ClassName.fromClass(Provider.class));
-            break;
-          default:
-            throw new AssertionError();
-        }
-        for (TypeElement referencedType : referencedTypes) {
-          ClassName className = ClassName.fromTypeElement(referencedType);
-          // don't include classes in java.lang or the same package
-          if (!packagesToSkip.contains(className.packageName())
-              // or that are members of the same top-level class
-              && !className.nameOfTopLevelClass().equals(topLevelClassName)) {
-            builder.add(className);
-          }
-        }
-      }
-    }
-    return builder.build();
-  }
-
-
-  /**
-   * Sorts {@link DependencyRequest} instances in an order likely to reflect their logical
-   * importance.
-   */
-  private static final Ordering<DependencyRequest> DEPENDENCY_ORDERING =
-      new Ordering<DependencyRequest>() {
-        @Override
-        public int compare(DependencyRequest left, DependencyRequest right) {
-          return ComparisonChain.start()
-              // put fields before parameters
-              .compare(left.requestElement().getKind(), right.requestElement().getKind())
-              // order by dependency kind
-              .compare(left.kind(), right.kind())
-              // then sort by name
-              .compare(
-                  left.requestElement().getSimpleName().toString(),
-                  right.requestElement().getSimpleName().toString())
-              .result();
-        }
-      };
-
-  /**
-   * This method generates names for the {@link Provider} references necessary for all of the
-   * bindings. It is responsible for the following:
-   * <ul>
-   * <li>Choosing a name that associates the provider with all of the dependency requests for this
-   * type.
-   * <li>Choosing a name that is <i>probably</i> associated with the type being provided.
-   * <li>Ensuring that no two providers end up with the same name.
-   * </ul>
-   *
-   * @return Returns the mapping from {@link Key} to provider name sorted by the name of the
-   * provider.
-   */
-  private ImmutableBiMap<Key, String> generateProviderNames(
-      SetMultimap<Key, DependencyRequest> dependenciesByKey) {
-    Map<Key, Collection<DependencyRequest>> dependenciesByKeyMap = dependenciesByKey.asMap();
-    BiMap<Key, String> providerNames = HashBiMap.create(dependenciesByKeyMap.size());
-    for (Entry<Key, Collection<DependencyRequest>> entry : dependenciesByKeyMap.entrySet()) {
-      // collect together all of the names that we would want to call the provider
-      ImmutableSet<String> dependencyNames = FluentIterable.from(entry.getValue())
-          .transform(new Function<DependencyRequest, String>() {
-            @Override public String apply(DependencyRequest input) {
-              return nameForDependency(input);
-            }
-          })
-          .toSet();
-
-      final String baseProviderName;
-      if (dependencyNames.size() == 1) {
-        // if there's only one name, great!  use it!
-        String name = Iterables.getOnlyElement(dependencyNames);
-        baseProviderName = name.endsWith("Provider") ? name : name + "Provider";
-      } else {
-        // in the event that a provider is being used for a bunch of deps with different names,
-        // add all the names together with "And"s in the middle.  E.g.: stringAndS
-        Iterator<String> namesIterator = dependencyNames.iterator();
-        String first = namesIterator.next();
-        StringBuilder compositeNameBuilder = new StringBuilder(first);
-        while (namesIterator.hasNext()) {
-          compositeNameBuilder.append("And")
-              .append(CaseFormat.LOWER_CAMEL.to(UPPER_CAMEL, namesIterator.next()));
-        }
-        baseProviderName = compositeNameBuilder.append("Provider").toString();
-      }
-
-      // in the unlikely event that we have more that one provider with the exact same name,
-      // just add numbers at the end until there is no collision
-      String candidateName = baseProviderName;
-      for (int candidateNum = 2; providerNames.containsValue(candidateName); candidateNum++) {
-        candidateName = baseProviderName + candidateNum;
-      }
-
-      providerNames.put(entry.getKey(), candidateName);
-    }
-    // return the map so that it is sorted by name
-    return ImmutableBiMap.copyOf(ImmutableSortedMap.copyOf(providerNames.inverse())).inverse();
-  }
-
-  /**
-   * Picks a reasonable name for what we think is being provided from the variable name associated
-   * with the {@link DependencyRequest}.  I.e. strips out words like "lazy" and "Provider" if we
-   * believe that those refer to {@link Lazy} and {@link Provider} rather than the type being
-   * provided.
-   */
-  // TODO(gak): develop the heuristics to get better names
-  private String nameForDependency(DependencyRequest dependency) {
-    String variableName = dependency.requestElement().getSimpleName().toString();
-    switch (dependency.kind()) {
-      case INSTANCE:
-        return variableName;
-      case LAZY:
-        return variableName.startsWith("lazy") && !variableName.equals("lazy")
-            ? Ascii.toLowerCase(variableName.charAt(4)) + variableName.substring(5)
-            : variableName;
-      case PROVIDER:
-        return variableName.endsWith("Provider") && !variableName.equals("Provider")
-            ? variableName.substring(0, variableName.length() - 8)
-            : variableName;
-      default:
-        throw new AssertionError();
-    }
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 237035290..ba2760043 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -19,17 +19,22 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
+import static javax.lang.model.element.ElementKind.FIELD;
+import static javax.lang.model.element.ElementKind.METHOD;
 
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Sets;
 
 import dagger.Provides;
 
 import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
 
 /**
  * A value object representing the mechanism by which a {@link Key} can be provided. New instances
@@ -39,27 +44,22 @@
  * @since 2.0
  */
 @AutoValue
-abstract class ProvisionBinding {
-  /**
-   * The {@link Element} that actually implements the binding. This will the
-   * {@link ExecutableElement} for a {@link Provides} method or {@link Inject} constructor.
-   */
-  abstract ExecutableElement bindingElement();
-
+abstract class ProvisionBinding extends Binding {
   /** The {@link Key} that is provided by this binding. */
   abstract Key providedKey();
 
-  /**
-   * The set of {@linkplain DependencyRequest key requests} that satisfy the direct dependencies of
-   * this binding.
-   */
-  abstract ImmutableSet<DependencyRequest> dependencies();
-
   /** The scope in which the binding declares the {@link #providedKey()}. */
   abstract Optional<AnnotationMirror> scope();
 
+  /** Returns {@code true} if this provision binding requires members to be injected implicitly. */
+  abstract boolean requiresMemberInjection();
+
   static final class Factory {
-    private final DependencyRequest.Factory keyRequestFactory = null;
+    private final DependencyRequest.Factory keyRequestFactory;
+
+    Factory(DependencyRequest.Factory keyRequestFactory) {
+      this.keyRequestFactory = keyRequestFactory;
+    }
 
     ProvisionBinding forInjectConstructor(ExecutableElement constructorElement) {
       checkNotNull(constructorElement);
@@ -67,18 +67,36 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement) {
       checkArgument(constructorElement.getAnnotation(Inject.class) != null);
       Key key = Key.forInjectConstructor(constructorElement);
       checkArgument(!key.qualifier().isPresent());
-      return new AutoValue_ProvisionBinding(constructorElement, key,
+      return new AutoValue_ProvisionBinding(constructorElement,
           keyRequestFactory.forVariables(constructorElement.getParameters()),
-          getScopeAnnotation(constructorElement.getEnclosingElement()));
+          key,
+          getScopeAnnotation(constructorElement.getEnclosingElement()),
+          requiresMemeberInjection(
+              ElementUtil.asTypeElement(constructorElement.getEnclosingElement())));
+    }
+
+    private static final ImmutableSet<ElementKind> MEMBER_KINDS =
+        Sets.immutableEnumSet(METHOD, FIELD);
+
+    private static boolean requiresMemeberInjection(TypeElement type) {
+      for (Element enclosedElement : type.getEnclosedElements()) {
+        if (MEMBER_KINDS.contains(enclosedElement.getKind())
+            && (enclosedElement.getAnnotation(Inject.class) != null)) {
+          return true;
+        }
+      }
+      return false;
     }
 
     ProvisionBinding forProvidesMethod(ExecutableElement providesMethod) {
       checkNotNull(providesMethod);
       checkArgument(providesMethod.getKind().equals(CONSTRUCTOR));
       checkArgument(providesMethod.getAnnotation(Provides.class) != null);
-      return new AutoValue_ProvisionBinding(providesMethod, Key.forProvidesMethod(providesMethod),
+      return new AutoValue_ProvisionBinding(providesMethod,
           keyRequestFactory.forVariables(providesMethod.getParameters()),
-          getScopeAnnotation(providesMethod));
+          Key.forProvidesMethod(providesMethod),
+          getScopeAnnotation(providesMethod),
+          false);
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
index 9c93cad13..164499fc8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
@@ -45,7 +45,7 @@
     this.filer = checkNotNull(filer);
   }
 
-  void generate(T input) throws SourceFileGenerationException {
+  final void generate(T input) throws SourceFileGenerationException {
     ClassName generatedTypeName = nameGeneratedType(input);
     ImmutableSet<Element> originatingElements = ImmutableSet.copyOf(getOriginatingElements(input));
     JavaFileObject file = null;
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
new file mode 100644
index 000000000..55d4ece15
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -0,0 +1,202 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+
+import com.google.common.base.CaseFormat;
+import com.google.common.collect.BiMap;
+import com.google.common.collect.ComparisonChain;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.HashBiMap;
+import com.google.common.collect.ImmutableBiMap;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.ImmutableSortedMap;
+import com.google.common.collect.ImmutableSortedSet;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Ordering;
+import com.squareup.javawriter.JavaWriter;
+
+import dagger.Lazy;
+import dagger.MembersInjector;
+import dagger.internal.DoubleCheckLazy;
+
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Map.Entry;
+
+import javax.inject.Provider;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * Utilities for generating files.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+class SourceFiles {
+  /**
+   * Given a mapping from variable name to type, returns a list of tokens suitable for methods such
+   * as {@link JavaWriter#beginMethod(String, String, java.util.Set, String...)}.
+   */
+  // TODO(gak): push this change upstream to obviate the need for this utility
+  static ImmutableList<String> flattenVariableMap(Map<String, String> variableMap) {
+    ImmutableList.Builder<String> tokenList = ImmutableList.builder();
+    for (Entry<String, String> variableEntry : variableMap.entrySet()) {
+      tokenList.add(variableEntry.getValue(), variableEntry.getKey());
+    }
+    return tokenList.build();
+  }
+
+  /**
+   * Returns the sorted set of all classes required by the {@link MembersInjector} implementation
+   * being generated.
+   */
+  static ImmutableSortedSet<ClassName> collectImportsFromDependencies(ClassName topLevelClassName,
+      Iterable<? extends DependencyRequest> dependencies) {
+    ImmutableSortedSet.Builder<ClassName> builder = ImmutableSortedSet.<ClassName>naturalOrder();
+    ImmutableSet<String> packagesToSkip  =
+        ImmutableSet.of("java.lang", topLevelClassName.packageName());
+    for (DependencyRequest dependency : dependencies) {
+      ImmutableSet<TypeElement> referencedTypes = Mirrors.referencedTypes(dependency.key().type());
+      switch (dependency.kind()) {
+        case LAZY:
+          builder.add(ClassName.fromClass(Lazy.class), ClassName.fromClass(DoubleCheckLazy.class));
+          // fall through
+        case INSTANCE:
+        case PROVIDER:
+          builder.add(ClassName.fromClass(Provider.class));
+          break;
+        default:
+          throw new AssertionError();
+      }
+      for (TypeElement referencedType : referencedTypes) {
+        ClassName className = ClassName.fromTypeElement(referencedType);
+        // don't include classes in java.lang or the same package
+        if (!packagesToSkip.contains(className.packageName())
+            // or that are members of the same top-level class
+            && !className.nameOfTopLevelClass().equals(topLevelClassName)) {
+          builder.add(className);
+        }
+      }
+    }
+    return builder.build();
+  }
+
+  /**
+   * Sorts {@link DependencyRequest} instances in an order likely to reflect their logical
+   * importance.
+   */
+  static final Ordering<DependencyRequest> DEPENDENCY_ORDERING =
+      new Ordering<DependencyRequest>() {
+        @Override public int compare(DependencyRequest left, DependencyRequest right) {
+          return ComparisonChain.start()
+              // put fields before parameters
+              .compare(left.requestElement().getKind(), right.requestElement().getKind())
+              // order by dependency kind
+              .compare(left.kind(), right.kind())
+              // then sort by name
+              .compare(
+                  left.requestElement().getSimpleName().toString(),
+                  right.requestElement().getSimpleName().toString())
+              .result();
+        }
+      };
+
+  /**
+   * This method generates names for the {@link Provider} references necessary for all of the
+   * bindings. It is responsible for the following:
+   * <ul>
+   * <li>Choosing a name that associates the provider with all of the dependency requests for this
+   * type.
+   * <li>Choosing a name that is <i>probably</i> associated with the type being provided.
+   * <li>Ensuring that no two providers end up with the same name.
+   * </ul>
+   *
+   * @return Returns the mapping from {@link Key} to provider name sorted by the name of the
+   * provider.
+   */
+  static ImmutableBiMap<Key, String> generateProviderNames(
+      Iterable<? extends Binding> bindings) {
+    ImmutableSetMultimap.Builder<Key, DependencyRequest> dependenciesByKeyBuilder =
+        new ImmutableSetMultimap.Builder<Key, DependencyRequest>()
+            .orderValuesBy(DEPENDENCY_ORDERING);
+    for (Binding binding : bindings) {
+      for (DependencyRequest dependency : binding.dependencies()) {
+        dependenciesByKeyBuilder.put(dependency.key(), dependency);
+      }
+    }
+    ImmutableSetMultimap<Key, DependencyRequest> dependenciesByKey =
+        dependenciesByKeyBuilder.build();
+    Map<Key, Collection<DependencyRequest>> dependenciesByKeyMap = dependenciesByKey.asMap();
+    BiMap<Key, String> providerNames = HashBiMap.create(dependenciesByKeyMap.size());
+    for (Entry<Key, Collection<DependencyRequest>> entry : dependenciesByKeyMap.entrySet()) {
+      // collect together all of the names that we would want to call the provider
+      ImmutableSet<String> dependencyNames = FluentIterable.from(entry.getValue())
+          .transform(new DependencyVariableNamer())
+          .toSet();
+
+      final String baseProviderName;
+      if (dependencyNames.size() == 1) {
+        // if there's only one name, great!  use it!
+        String name = Iterables.getOnlyElement(dependencyNames);
+        baseProviderName = name.endsWith("Provider") ? name : name + "Provider";
+      } else {
+        // in the event that a provider is being used for a bunch of deps with different names,
+        // add all the names together with "And"s in the middle.  E.g.: stringAndS
+        Iterator<String> namesIterator = dependencyNames.iterator();
+        String first = namesIterator.next();
+        StringBuilder compositeNameBuilder = new StringBuilder(first);
+        while (namesIterator.hasNext()) {
+          compositeNameBuilder.append("And")
+              .append(CaseFormat.LOWER_CAMEL.to(UPPER_CAMEL, namesIterator.next()));
+        }
+        baseProviderName = compositeNameBuilder.append("Provider").toString();
+      }
+
+      // in the unlikely event that we have more that one provider with the exact same name,
+      // just add numbers at the end until there is no collision
+      String candidateName = baseProviderName;
+      for (int candidateNum = 2; providerNames.containsValue(candidateName); candidateNum++) {
+        candidateName = baseProviderName + candidateNum;
+      }
+
+      providerNames.put(entry.getKey(), candidateName);
+    }
+    // return the map so that it is sorted by name
+    return ImmutableBiMap.copyOf(ImmutableSortedMap.copyOf(providerNames.inverse())).inverse();
+  }
+
+  static String providerUsageStatement(String providerName,
+      DependencyRequest.Kind dependencyKind) {
+    switch (dependencyKind) {
+      case LAZY:
+        return String.format("%s.create(%s)",
+            DoubleCheckLazy.class.getSimpleName(), providerName);
+      case INSTANCE:
+        return String.format("%s.get()", providerName);
+      case PROVIDER:
+        return String.format("%s", providerName);
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  private SourceFiles() {}
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java
index 358806c39..dc23b0bfd 100644
--- a/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java
@@ -41,6 +41,7 @@
 import org.junit.runners.JUnit4;
 
 @RunWith(JUnit4.class)
+// TODO(gak): add tests for generation in the default package.
 public final class InjectProcessorTest {
   private static final JavaFileObject QUALIFIER_A =
       JavaFileObjects.forSourceLines("test.QualifierA",
@@ -289,7 +290,6 @@
         "import dagger.MembersInjector;",
         "import dagger.internal.DoubleCheckLazy;",
         "import javax.annotation.Generated;",
-        "import javax.inject.Inject;",
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.InjectProcessor\")",
@@ -298,7 +298,7 @@
         "",
         "  private final Provider<String> stringProvider;",
         "",
-        "  @Inject FieldInjection$$MembersInjector(Provider<String> stringProvider) {",
+        "  FieldInjection$$MembersInjector(Provider<String> stringProvider) {",
         "    assert stringProvider != null;",
         "    this.stringProvider = stringProvider;",
         "  }",
@@ -343,7 +343,6 @@
         "import dagger.MembersInjector;",
         "import dagger.internal.DoubleCheckLazy;",
         "import javax.annotation.Generated;",
-        "import javax.inject.Inject;",
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.InjectProcessor\")",
@@ -352,7 +351,7 @@
         "",
         "  private final Provider<String> stringProvider;",
         "",
-        "  @Inject MethodInjection$$MembersInjector(Provider<String> stringProvider) {",
+        "  MethodInjection$$MembersInjector(Provider<String> stringProvider) {",
         "    assert stringProvider != null;",
         "    this.stringProvider = stringProvider;",
         "  }",
@@ -396,7 +395,6 @@
         "",
         "import dagger.MembersInjector;",
         "import javax.annotation.Generated;",
-        "import javax.inject.Inject;",
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.InjectProcessor\")",
@@ -406,7 +404,7 @@
         "  private final Provider<Object> objectAndOProvider;",
         "  private final Provider<String> stringAndSProvider;",
         "",
-        "  @Inject MixedMemberInjection$$MembersInjector(Provider<Object> objectAndOProvider,",
+        "  MixedMemberInjection$$MembersInjector(Provider<Object> objectAndOProvider,",
         "      Provider<String> stringAndSProvider) {",
         "    assert objectAndOProvider != null;",
         "    this.objectAndOProvider = objectAndOProvider;",
@@ -432,4 +430,127 @@
         .compilesWithoutError()
         .and().generatesSources(expected);
   }
+
+  @Test public void injectConstructor() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.InjectConstructor",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class InjectConstructor {",
+        "  @Inject InjectConstructor(String s) {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines(
+        "test.InjectConstructor$$Factory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.InjectProcessor\")",
+        "public final class InjectConstructor$$Factory ",
+        "    implements Factory<InjectConstructor> {",
+        "",
+        "  private final Provider<String> sProvider;",
+        "",
+        "  public InjectConstructor$$Factory(Provider<String> sProvider) {",
+        "    assert sProvider != null;",
+        "    this.sProvider = sProvider;",
+        "  }",
+        "",
+        "  @Override public InjectConstructor get() {",
+        "    return new InjectConstructor(sProvider.get());",
+        "  }",
+        "",
+        "  @Override public String toString() {",
+        "    return \"Factory<InjectConstructor>\";",
+        "  }",
+        "}");
+    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test public void injectConstructorAndMembersInjection() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.AllInjections",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class AllInjections {",
+        "  @Inject String s;",
+        "  @Inject AllInjections(String s) {}",
+        "  @Inject void s(String s) {}",
+        "}");
+    JavaFileObject expectedFactory = JavaFileObjects.forSourceLines(
+        "test.AllInjections$$Factory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.InjectProcessor\")",
+        "public final class AllInjections$$Factory ",
+        "    implements Factory<AllInjections> {",
+        "",
+        "  private final MembersInjector<AllInjections> membersInjector;",
+        "  private final Provider<String> sProvider;",
+        "",
+        "  public AllInjections$$Factory(MembersInjector<AllInjections> membersInjector, ",
+        "      Provider<String> sProvider) {",
+        "    assert membersInjector != null;",
+        "    this.membersInjector = membersInjector;",
+        "    assert sProvider != null;",
+        "    this.sProvider = sProvider;",
+        "  }",
+        "",
+        "  @Override public AllInjections get() {",
+        "    AllInjections instance = new AllInjections(sProvider.get());",
+        "    membersInjector.injectMembers(instance);",
+        "    return instance;",
+        "  }",
+        "",
+        "  @Override public String toString() {",
+        "    return \"Factory<AllInjections>\";",
+        "  }",
+        "}");
+    JavaFileObject expectedMembersInjector = JavaFileObjects.forSourceLines(
+        "test.AllInjections$$MembersInjector",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.InjectProcessor\")",
+        "final class AllInjections$$MembersInjector ",
+        "    implements MembersInjector<AllInjections> {",
+        "",
+        "  private final Provider<String> sProvider;",
+        "",
+        "  AllInjections$$MembersInjector(Provider<String> sProvider) {",
+        "    assert sProvider != null;",
+        "    this.sProvider = sProvider;",
+        "  }",
+        "",
+        "  @Override public void injectMembers(AllInjections instance) {",
+        "    if (instance == null) {",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+        "    }",
+        "    instance.s = sProvider.get();",
+        "    instance.s(sProvider.get());",
+        "  }",
+        "",
+        "  @Override public String toString() {",
+        "    return \"MembersInjector<AllInjections>\";",
+        "  }",
+        "}");
+    ASSERT.about(javaSource()).that(file).processedWith(new InjectProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(expectedFactory, expectedMembersInjector);
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/SourceFileGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/SourceFileGeneratorTest.java
index e05d6e30c..7e5df19ad 100644
--- a/compiler/src/test/java/dagger/internal/codegen/SourceFileGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/SourceFileGeneratorTest.java
@@ -143,7 +143,7 @@ ClassName nameGeneratedType(Void input) {
     Iterable<? extends Element> getOriginatingElements(Void input) {
       return ImmutableSet.of();
     }
-    
+
     @Override
     Optional<? extends Element> getElementForErrorReporting(Void input) {
       return Optional.absent();
diff --git a/core/src/main/java/dagger/internal/NoOpMembersInjector.java b/core/src/main/java/dagger/internal/NoOpMembersInjector.java
deleted file mode 100644
index dd15e86de..000000000
--- a/core/src/main/java/dagger/internal/NoOpMembersInjector.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package dagger.internal;
-
-import dagger.MembersInjector;
-
-/**
- * A {@link MembersInjector} implementation that injects no members; a valid null object for types
- * that have no members (or inherited members) annotated with {@link javax.inject.Inject}.
- *
- * @since 2.0
- */
-public final class NoOpMembersInjector<T> implements MembersInjector<T> {
-  @SuppressWarnings("unchecked")
-  public <T> MembersInjector<T> create() {
-    // this cast is safe because this members injector is a no-op
-    return (MembersInjector<T>) INSTANCE;
-  }
-
-  private static final NoOpMembersInjector<Object> INSTANCE = new NoOpMembersInjector<Object>() ;
-
-  @Override
-  public void injectMembers(T instance) {}
-
-  private NoOpMembersInjector () {}
-}
