diff --git a/java/dagger/internal/codegen/BindingGraphConverter.java b/java/dagger/internal/codegen/BindingGraphConverter.java
index a4f06c127..5a69b18b5 100644
--- a/java/dagger/internal/codegen/BindingGraphConverter.java
+++ b/java/dagger/internal/codegen/BindingGraphConverter.java
@@ -98,9 +98,7 @@ private ComponentNode rootComponentNode(Network<Node, Edge> network) {
     protected void visitComponent(BindingGraph graph) {
       ComponentNode grandparentComponent = parentComponent;
       parentComponent = currentComponent;
-      currentComponent =
-          ComponentNodeImpl.create(
-              componentTreePath().toComponentPath(), graph.componentDescriptor());
+      currentComponent = ComponentNodeImpl.create(componentPath(), graph.componentDescriptor());
 
       network.addNode(currentComponent);
 
@@ -183,9 +181,7 @@ private boolean hasDependencyEdge(
 
     private ResolvedBindings resolvedDependencies(
         Node source, DependencyRequest dependencyRequest) {
-      return componentTreePath()
-          .pathFromRootToAncestor(source.componentPath().currentComponent())
-          .currentGraph()
+      return graphForAncestor(source.componentPath().currentComponent())
           .resolvedBindings(bindingRequest(dependencyRequest));
     }
 
@@ -214,7 +210,7 @@ private void addBinding(BindingNode binding) {
     private BindingNode bindingNode(
         ResolvedBindings resolvedBindings, Binding binding, TypeElement owningComponent) {
       return BindingNode.create(
-          componentTreePath().pathFromRootToAncestor(owningComponent).toComponentPath(),
+          pathFromRootToAncestor(owningComponent),
           binding,
           associatedDeclaringElements(resolvedBindings),
           () -> bindingDeclarationFormatter.format(binding));
@@ -230,10 +226,7 @@ private BindingNode bindingNode(
 
     private MissingBinding missingBindingNode(ResolvedBindings dependencies) {
       return BindingGraphProxies.missingBindingNode(
-          componentTreePath()
-              .pathFromRootToAncestor(dependencies.resolvingComponent())
-              .toComponentPath(),
-          dependencies.key());
+          pathFromRootToAncestor(dependencies.resolvingComponent()), dependencies.key());
     }
 
     private ComponentNode subcomponentNode(TypeMirror subcomponentBuilderType, BindingGraph graph) {
@@ -241,8 +234,7 @@ private ComponentNode subcomponentNode(TypeMirror subcomponentBuilderType, Bindi
       ComponentDescriptor subcomponent =
           graph.componentDescriptor().getChildComponentWithBuilderType(subcomponentBuilderElement);
       return ComponentNodeImpl.create(
-          componentTreePath().childPath(subcomponent.typeElement()).toComponentPath(),
-          subcomponent);
+          componentPath().childPath(subcomponent.typeElement()), subcomponent);
     }
 
     private ImmutableSet<TypeElement> subcomponentDeclaringModules(
diff --git a/java/dagger/internal/codegen/ComponentTreeTraverser.java b/java/dagger/internal/codegen/ComponentTreeTraverser.java
index e77ca3d34..98896f4de 100644
--- a/java/dagger/internal/codegen/ComponentTreeTraverser.java
+++ b/java/dagger/internal/codegen/ComponentTreeTraverser.java
@@ -17,23 +17,16 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.base.Verify.verify;
-import static java.util.stream.Collectors.joining;
-import static java.util.stream.Collectors.toList;
 
-import com.google.auto.value.AutoValue;
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Iterables;
 import com.google.common.collect.Iterators;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.model.ComponentPath;
 import dagger.model.DependencyRequest;
 import java.util.ArrayDeque;
 import java.util.Deque;
-import java.util.function.Predicate;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 
@@ -146,126 +139,41 @@ protected void visitEntryPoint(DependencyRequest entryPoint, BindingGraph graph)
    * Returns an immutable snapshot of the path from the root component to the currently visited
    * component.
    */
-  protected final ComponentTreePath componentTreePath() {
-    return ComponentTreePath.create(bindingGraphPath);
+  protected final ComponentPath componentPath() {
+    ImmutableList.Builder<TypeElement> path = ImmutableList.builder();
+    for (BindingGraph graph : bindingGraphPath) {
+      path.add(graph.componentTypeElement());
+    }
+    return ComponentPath.create(path.build());
   }
 
   /**
-   * A path from the root component to a component within the component tree during a {@linkplain
-   * ComponentTreeTraverser traversal}.
+   * Returns the subpath from the root component to the matching {@code ancestor} of the current
+   * component.
    */
-  @AutoValue
-  public abstract static class ComponentTreePath {
-
-    private static ComponentTreePath create(Iterable<BindingGraph> path) {
-      return new AutoValue_ComponentTreeTraverser_ComponentTreePath(ImmutableList.copyOf(path));
-    }
-
-    /**
-     * Returns the binding graphs in the path, starting from the {@linkplain #rootGraph() root
-     * graph} and ending with the {@linkplain #currentGraph() current graph}.
-     */
-    public abstract ImmutableList<BindingGraph> graphsInPath();
-
-    /** Returns the binding graph for the component at the end of the path. */
-    public BindingGraph currentGraph() {
-      return Iterables.getLast(graphsInPath());
-    }
-
-    /** Returns the type of the component at the end of the path. */
-    public TypeElement currentComponent() {
-      return currentGraph().componentTypeElement();
-    }
-
-    /**
-     * Returns the binding graph for the parent of the {@linkplain #currentGraph() current
-     * component}.
-     *
-     * @throws IllegalStateException if the current graph is the {@linkplain #atRoot() root graph}
-     */
-    public BindingGraph parentGraph() {
-      checkState(!atRoot());
-      return graphsInPath().reverse().get(1);
-    }
-
-    /** Returns the binding graph for the root component. */
-    public BindingGraph rootGraph() {
-      return graphsInPath().get(0);
-    }
-
-    /**
-     * Returns {@code true} if the {@linkplain #currentGraph() current graph} is the {@linkplain
-     * #rootGraph() root graph}.
-     */
-    public boolean atRoot() {
-      return graphsInPath().size() == 1;
-    }
-
-    /** Returns the rootmost binding graph in the component path among the given components. */
-    public BindingGraph rootmostGraph(Iterable<ComponentDescriptor> components) {
-      ImmutableSet<ComponentDescriptor> set = ImmutableSet.copyOf(components);
-      return rootmostGraph(graph -> set.contains(graph.componentDescriptor()));
-    }
-
-    /** Returns the binding graph within this path that represents the given component. */
-    public BindingGraph graphForComponent(ComponentDescriptor component) {
-      checkNotNull(component);
-      return rootmostGraph(graph -> graph.componentDescriptor().equals(component));
-    }
-
-    /**
-     * Returns the subpath from the root component to the matching {@code ancestor} of the current
-     * component.
-     */
-    ComponentTreePath pathFromRootToAncestor(TypeElement ancestor) {
-      ImmutableList.Builder<BindingGraph> path = ImmutableList.builder();
-      for (BindingGraph graph : graphsInPath()) {
-        path.add(graph);
-        if (graph.componentTypeElement().equals(ancestor)) {
-          return create(path.build());
-        }
+  protected final ComponentPath pathFromRootToAncestor(TypeElement ancestor) {
+    ImmutableList.Builder<TypeElement> path = ImmutableList.builder();
+    for (TypeElement component : componentPath().components()) {
+      path.add(component);
+      if (component.equals(ancestor)) {
+        return ComponentPath.create(path.build());
       }
-      throw new IllegalArgumentException(
-          String.format("%s is not in the current path: %s", ancestor.getQualifiedName(), this));
     }
+    throw new IllegalArgumentException(
+        String.format("%s is not in the current path: %s", ancestor.getQualifiedName(), this));
+  }
 
-    /**
-     * Returns the path from the root component to the child of the current component for a {@code
-     * subcomponent}.
-     *
-     * @throws IllegalArgumentException if {@code subcomponent} is not a child of the current
-     *     component
-     */
-    ComponentTreePath childPath(TypeElement subcomponent) {
-      for (BindingGraph child : currentGraph().subgraphs()) {
-        if (child.componentTypeElement().equals(subcomponent)) {
-          return create(
-              ImmutableList.<BindingGraph>builder().addAll(graphsInPath()).add(child).build());
-        }
+  /**
+   * Returns the BindingGraph for {@code ancestor}, where {@code ancestor} is in the component path
+   * of the current traversal.
+   */
+  protected final BindingGraph graphForAncestor(TypeElement ancestor) {
+    for (BindingGraph graph : bindingGraphPath) {
+      if (graph.componentTypeElement().equals(ancestor)) {
+        return graph;
       }
-      throw new IllegalArgumentException(
-          String.format(
-              "%s is not a child of %s",
-              subcomponent.getQualifiedName(),
-              currentGraph().componentTypeElement().getQualifiedName()));
-    }
-
-    private BindingGraph rootmostGraph(Predicate<? super BindingGraph> predicate) {
-      return graphsInPath().stream().filter(predicate).findFirst().get();
-    }
-
-    /** Converts this {@link ComponentTreePath} into a {@link ComponentPath}. */
-    ComponentPath toComponentPath() {
-      return ComponentPath.create(
-          graphsInPath().stream().map(BindingGraph::componentTypeElement).collect(toList()));
-    }
-
-    @Override
-    public final String toString() {
-      return graphsInPath().stream()
-          .map(BindingGraph::componentTypeElement)
-          .map(TypeElement::getQualifiedName)
-          .collect(joining(" → "));
     }
+    throw new IllegalArgumentException(
+        String.format("%s is not in the current path: %s", ancestor.getQualifiedName(), this));
   }
 }
diff --git a/java/dagger/model/ComponentPath.java b/java/dagger/model/ComponentPath.java
index 722595049..6bcbc9dfd 100644
--- a/java/dagger/model/ComponentPath.java
+++ b/java/dagger/model/ComponentPath.java
@@ -71,6 +71,11 @@ public final ComponentPath parent() {
     return create(components().subList(0, components().size() - 1));
   }
 
+  /** Returns the path from the root component to the {@code child} of the current component. */
+  public final ComponentPath childPath(TypeElement child) {
+    return create(ImmutableList.<TypeElement>builder().addAll(components()).add(child).build());
+  }
+
   /**
    * Returns {@code true} if the {@linkplain #currentComponent()} current component} is the
    * {@linkplain #rootComponent()} root component}.
