diff --git a/java/dagger/internal/codegen/ComponentImplementation.java b/java/dagger/internal/codegen/ComponentImplementation.java
index be2542b2f..147c4e86e 100644
--- a/java/dagger/internal/codegen/ComponentImplementation.java
+++ b/java/dagger/internal/codegen/ComponentImplementation.java
@@ -46,6 +46,7 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
@@ -487,7 +488,16 @@ void claimMethodName(CharSequence name) {
    * listener method.
    */
   ImmutableList<Key> getCancellableProducerKeys() {
-    return ImmutableList.copyOf(cancellableProducerKeys);
+    Optional<ComponentImplementation> currentSuperImplementation = superclassImplementation;
+    Set<Key> cancelledKeysFromSuperclass = new HashSet<>();
+    while (currentSuperImplementation.isPresent()) {
+      cancelledKeysFromSuperclass.addAll(
+          currentSuperImplementation.get().cancellableProducerKeys);
+      currentSuperImplementation = currentSuperImplementation.get().superclassImplementation;
+    }
+    return Sets.difference(cancellableProducerKeys, cancelledKeysFromSuperclass)
+        .immutableCopy()
+        .asList();
   }
 
   /**
diff --git a/java/dagger/internal/codegen/ComponentImplementationFactory.java b/java/dagger/internal/codegen/ComponentImplementationFactory.java
index b48e8eb3e..ca98509ec 100644
--- a/java/dagger/internal/codegen/ComponentImplementationFactory.java
+++ b/java/dagger/internal/codegen/ComponentImplementationFactory.java
@@ -271,12 +271,6 @@ final void addCancellationListenerImplementation() {
       }
 
       ImmutableList<CodeBlock> cancellationStatements = cancellationStatements();
-      if (cancellationStatements.isEmpty()
-          && componentImplementation.superclassImplementation().isPresent()) {
-        // Partial child implementations that have no new cancellations don't need to override
-        // the method just to call super().
-        return;
-      }
 
       if (cancellationStatements.size() < STATEMENTS_PER_METHOD) {
         methodBuilder.addCode(CodeBlocks.concat(cancellationStatements)).build();
@@ -296,12 +290,21 @@ final void addCancellationListenerImplementation() {
         }
       }
 
-      addCancelParentStatement(methodBuilder);
+      Optional<CodeBlock> cancelParentStatement = cancelParentStatement();
+      cancelParentStatement.ifPresent(methodBuilder::addCode);
+
+      if (cancellationStatements.isEmpty()
+          && !cancelParentStatement.isPresent()
+          && componentImplementation.superclassImplementation().isPresent()) {
+        // Partial child implementations that have no new cancellations don't need to override
+        // the method just to call super().
+        return;
+      }
 
       componentImplementation.addMethod(CANCELLATION_LISTENER_METHOD, methodBuilder.build());
     }
 
-    final ImmutableList<CodeBlock> cancellationStatements() {
+    private ImmutableList<CodeBlock> cancellationStatements() {
       // Reversing should order cancellations starting from entry points and going down to leaves
       // rather than the other way around. This shouldn't really matter but seems *slightly*
       // preferable because:
@@ -330,10 +333,11 @@ final void addCancellationListenerImplementation() {
       return cancellationStatements.build();
     }
 
-    void addCancelParentStatement(MethodSpec.Builder methodBuilder) {
-      // Does nothing by default. Overridden in subclass(es) to add a statement if and only if the
+    Optional<CodeBlock> cancelParentStatement() {
+      // Returns empty by default. Overridden in subclass(es) to add a statement if and only if the
       // component being generated is a concrete subcomponent implementation with a parent that
       // allows cancellation to propagate to it from subcomponents.
+      return Optional.empty();
     }
 
     final MethodSignature getMethodSignature(ComponentMethodDescriptor method) {
@@ -700,14 +704,18 @@ void addInterfaceMethods() {
     }
 
     @Override
-    void addCancelParentStatement(MethodSpec.Builder methodBuilder) {
-      if (shouldPropagateCancellationToParent()) {
-        methodBuilder.addStatement(
-            "$T.this.$L($L)",
-            parent.get().componentImplementation.name(),
-            CANCELLATION_LISTENER_METHOD_NAME,
-            MAY_INTERRUPT_IF_RUNNING);
+    Optional<CodeBlock> cancelParentStatement() {
+      if (!shouldPropagateCancellationToParent()){
+        return Optional.empty();
       }
+      return Optional.of(
+          CodeBlock.builder()
+              .addStatement(
+                  "$T.this.$N($N)",
+                  parent.get().componentImplementation.name(),
+                  CANCELLATION_LISTENER_METHOD_NAME,
+                  MAY_INTERRUPT_IF_RUNNING)
+              .build());
     }
 
     boolean shouldPropagateCancellationToParent() {
diff --git a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
index 87a1007d4..283ea1a46 100644
--- a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
+++ b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
@@ -4545,14 +4545,6 @@ public void productionSubcomponentAndModifiableFrameworkInstance() {
             "    protected Producer getSetOfResponseProducer() {",
             "      return setOfResponseProducer;",
             "    }",
-            "",
-            "    @Override",
-            "    public void onProducerFutureCancelled(boolean mayInterruptIfRunning) {",
-            "      super.onProducerFutureCancelled(mayInterruptIfRunning);",
-            // TODO(b/72748365): This call should ideally be omitted since the same key has already
-            // been canceled in the super invocation
-            "      Producers.cancel(getSetOfResponseProducer(), mayInterruptIfRunning);",
-            "    }",
             "  }",
             "}");
     compilation = compile(filesToCompile.build());
