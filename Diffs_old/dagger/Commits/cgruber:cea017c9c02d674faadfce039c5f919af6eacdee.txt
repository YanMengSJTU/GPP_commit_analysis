diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index c4cd6c541..9fff9a199 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -33,6 +33,7 @@
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
+import com.squareup.javapoet.TypeVariableName;
 import dagger.internal.DelegateFactory;
 import dagger.internal.MapFactory;
 import dagger.internal.MapProviderFactory;
@@ -109,7 +110,6 @@
 import static dagger.internal.codegen.TypeNames.SINGLE_CHECK;
 import static dagger.internal.codegen.TypeNames.STRING;
 import static dagger.internal.codegen.TypeNames.UNSUPPORTED_OPERATION_EXCEPTION;
-import static dagger.internal.codegen.TypeNames.providerOf;
 import static dagger.internal.codegen.TypeSpecs.addSupertype;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
 import static dagger.internal.codegen.Util.requiresAPassedInstance;
@@ -534,7 +534,8 @@ private boolean useRawType(Optional<String> bindingPackage) {
    * injector.
    */
   private Optional<MemberSelect> staticMemberSelect(ResolvedBindings resolvedBindings) {
-    switch (resolvedBindings.bindingKey().kind()) {
+    BindingKey bindingKey = resolvedBindings.bindingKey();
+    switch (bindingKey.kind()) {
       case CONTRIBUTION:
         ContributionBinding contributionBinding = resolvedBindings.contributionBinding();
         if (contributionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
@@ -554,6 +555,19 @@ private boolean useRawType(Optional<String> bindingPackage) {
                   emptySetFactoryStaticMemberSelect(
                       contributionBinding.bindingType(), contributionBinding.key()));
 
+            case INJECTION:
+            case PROVISION:
+              if (bindingKey.key().type().getKind().equals(DECLARED)) {
+                ImmutableList<TypeVariableName> typeVariables =
+                    SourceFiles.bindingTypeElementTypeVariableNames(contributionBinding);
+                if (!typeVariables.isEmpty()) {
+                  List<? extends TypeMirror> typeArguments =
+                      ((DeclaredType) bindingKey.key().type()).getTypeArguments();
+                  return Optional.of(MemberSelect.parameterizedFactoryCreateMethod(
+                      generatedClassNameForBinding(contributionBinding), typeArguments));
+                }
+              }
+
             default:
               return Optional.of(
                   staticMethod(
@@ -684,19 +698,6 @@ private void implementInterfaceMethods() {
               }
               break;
             case INSTANCE:
-              if (memberSelect.staticMember()
-                  && bindingKey.key().type().getKind().equals(DECLARED)
-                  && !((DeclaredType) bindingKey.key().type()).getTypeArguments().isEmpty()) {
-                // If using a parameterized enum type, then we need to store the factory
-                // in a temporary variable, in order to help javac be able to infer
-                // the generics of the Factory.create methods.
-                TypeName factoryType = providerOf(TypeName.get(requestType.getReturnType()));
-                interfaceMethod
-                    .addStatement("$T factory = $L", factoryType, memberSelectCodeBlock)
-                    .addStatement("return factory.get()");
-                break;
-              }
-              // fall through in the else case.
             case LAZY:
             case PRODUCED:
             case PRODUCER:
diff --git a/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java b/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
index 33a14838f..4343d3654 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
@@ -21,6 +21,7 @@
 import dagger.MembersInjector;
 import dagger.internal.MapProviderFactory;
 import dagger.producers.internal.MapOfProducerProducer;
+import java.util.List;
 import java.util.Set;
 import javax.lang.model.type.TypeMirror;
 
@@ -29,6 +30,7 @@
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.CodeBlocks.toCodeBlocks;
+import static dagger.internal.codegen.TypeNames.FACTORY;
 import static dagger.internal.codegen.TypeNames.MAP_OF_PRODUCER_PRODUCER;
 import static dagger.internal.codegen.TypeNames.MAP_PROVIDER_FACTORY;
 import static dagger.internal.codegen.TypeNames.MEMBERS_INJECTOR;
@@ -74,6 +76,19 @@ static MemberSelect staticMethod(ClassName owningClass, CodeBlock methodInvocati
     return new StaticMethod(owningClass, methodInvocationCodeBlock);
   }
 
+  /**
+   * Returns a {@link MemberSelect} for the instance of a {@code create()} method on a factory.
+   * This only applies for factories that do not have any dependencies.
+   */
+  static MemberSelect parameterizedFactoryCreateMethod(
+      ClassName owningClass, List<? extends TypeMirror> parameters) {
+    return new ParameterizedStaticMethod(
+        owningClass,
+        ImmutableList.<TypeMirror>copyOf(parameters),
+        CodeBlock.of("create()"),
+        FACTORY);
+  }
+
   private static final class StaticMethod extends MemberSelect {
     final CodeBlock methodCodeBlock;
 
