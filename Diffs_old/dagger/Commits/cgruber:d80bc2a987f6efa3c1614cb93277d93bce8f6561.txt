diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
index 6f1766612..2519ba792 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
@@ -24,14 +24,12 @@
 import dagger.multibindings.IntoSet;
 import dagger.multibindings.LongKey;
 import dagger.multibindings.StringKey;
-
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
-
 import javax.inject.Named;
 import javax.inject.Provider;
 
@@ -44,13 +42,13 @@
   @Provides
   @IntoMap
   @StringKey("foo")
-  static String provideFooKey(double doubleDependency) {
+  static String provideFooKey(@SuppressWarnings("unused") double doubleDependency) {
     return "foo value";
   }
 
   @Provides(type = MAP)
   @StringKey("foo @Provides(type)")
-  static String provideFooProvidesTypeKey(double doubleDependency) {
+  static String provideFooProvidesTypeKey(@SuppressWarnings("unused") double doubleDependency) {
     return "foo @Provides(type) value";
   }
 
@@ -64,7 +62,7 @@ static String provideBarKey() {
   @Provides
   @IntoMap
   @StringKey("foo")
-  static String[] provideFooArrayValue(double doubleDependency) {
+  static String[] provideFooArrayValue(@SuppressWarnings("unused") double doubleDependency) {
     return new String[] {"foo1", "foo2"};
   }
 
diff --git a/compiler/src/it/functional-tests/src/main/java/test/NeedsFactory.java b/compiler/src/it/functional-tests/src/main/java/test/NeedsFactory.java
index b78907382..cfe7cec03 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/NeedsFactory.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/NeedsFactory.java
@@ -19,7 +19,8 @@
 import javax.inject.Inject;
 
 class NeedsFactory {
-  @Inject NeedsFactory(NeedsFactory_SomethingFactory somethingFactory) {}
+  @Inject
+  NeedsFactory(@SuppressWarnings("unused") NeedsFactory_SomethingFactory somethingFactory) {}
 
   @AutoFactory
   static class Something {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/cycle/LongCycle.java b/compiler/src/it/functional-tests/src/main/java/test/cycle/LongCycle.java
index b4f61e096..0562ad610 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/cycle/LongCycle.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/cycle/LongCycle.java
@@ -19,6 +19,8 @@
 import javax.inject.Inject;
 import javax.inject.Provider;
 
+// Each nested class's constructor has an intentionally unused parameter.
+@SuppressWarnings("unused")
 final class LongCycle {
   static class Class1 { @Inject Class1(Class2 class2) {} }
   static class Class2 { @Inject Class2(Class3 class3) {} }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/sub/ContributionsModule.java b/compiler/src/it/functional-tests/src/main/java/test/sub/ContributionsModule.java
index 953012ca6..d0b7b64c0 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/sub/ContributionsModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/sub/ContributionsModule.java
@@ -28,7 +28,7 @@
 public final class ContributionsModule {
   @Provides
   @IntoSet
-  static int contributeAnInt(double doubleDependency) {
+  static int contributeAnInt(@SuppressWarnings("unused") double doubleDependency) {
     return 1742;
   }
 
diff --git a/compiler/src/it/functional-tests/src/main/java/test/sub/OtherThing.java b/compiler/src/it/functional-tests/src/main/java/test/sub/OtherThing.java
index 94935171f..1abea0f11 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/sub/OtherThing.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/sub/OtherThing.java
@@ -18,5 +18,6 @@
 import javax.inject.Inject;
 
 public final class OtherThing {
-  @Inject public OtherThing(int i) {}
+  @Inject
+  public OtherThing(@SuppressWarnings("unused") int i) {}
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/NeedsAnInterface.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/NeedsAnInterface.java
index bccde8589..7a5acb048 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/NeedsAnInterface.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/NeedsAnInterface.java
@@ -16,5 +16,5 @@
 package test.subcomponent;
 
 class NeedsAnInterface {
-  NeedsAnInterface(AnInterface anInterface) {}
+  NeedsAnInterface(@SuppressWarnings("unused") AnInterface anInterface) {}
 }
diff --git a/compiler/src/it/functional-tests/src/test/java/test/BasicTest.java b/compiler/src/it/functional-tests/src/test/java/test/BasicTest.java
index cc3c52584..ba2f38391 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/BasicTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/BasicTest.java
@@ -55,8 +55,8 @@
     assertThat(basicComponent.getInt()).isEqualTo(BOUND_INT);
     assertThat(basicComponent.getLong()).isEqualTo(BOUND_LONG);
     assertThat(basicComponent.getBoolean()).isEqualTo(BOUND_BOOLEAN);
-    assertThat(basicComponent.getFloat()).isEqualTo(BOUND_FLOAT);
-    assertThat(basicComponent.getDouble()).isEqualTo(BOUND_DOUBLE);
+    assertThat(basicComponent.getFloat()).isWithin(0).of(BOUND_FLOAT);
+    assertThat(basicComponent.getDouble()).isWithin(0).of(BOUND_DOUBLE);
   }
 
   @Theory public void boxedPrimitives(BasicComponent basicComponent) {
@@ -66,8 +66,8 @@
     assertThat(basicComponent.getBoxedInt()).isEqualTo(new Integer(BOUND_INT));
     assertThat(basicComponent.getBoxedLong()).isEqualTo(new Long(BOUND_LONG));
     assertThat(basicComponent.getBoxedBoolean()).isEqualTo(new Boolean(BOUND_BOOLEAN));
-    assertThat(basicComponent.getBoxedFloat()).isEqualTo(new Float(BOUND_FLOAT));
-    assertThat(basicComponent.getBoxedDouble()).isEqualTo(new Double(BOUND_DOUBLE));
+    assertThat(basicComponent.getBoxedFloat()).isWithin(0).of(BOUND_FLOAT);
+    assertThat(basicComponent.getBoxedDouble()).isWithin(0).of(BOUND_DOUBLE);
   }
 
   @Theory public void boxedPrimitiveProviders(BasicComponent basicComponent) {
@@ -77,8 +77,8 @@
     assertThat(basicComponent.getIntProvider().get()).isEqualTo(new Integer(BOUND_INT));
     assertThat(basicComponent.getLongProvider().get()).isEqualTo(new Long(BOUND_LONG));
     assertThat(basicComponent.getBooleanProvider().get()).isEqualTo(new Boolean(BOUND_BOOLEAN));
-    assertThat(basicComponent.getFloatProvider().get()).isEqualTo(new Float(BOUND_FLOAT));
-    assertThat(basicComponent.getDoubleProvider().get()).isEqualTo(new Double(BOUND_DOUBLE));
+    assertThat(basicComponent.getFloatProvider().get()).isWithin(0).of(BOUND_FLOAT);
+    assertThat(basicComponent.getDoubleProvider().get()).isWithin(0).of(BOUND_DOUBLE);
   }
 
   @Theory public void primitiveArrays(BasicComponent basicComponent) {
diff --git a/compiler/src/it/functional-tests/src/test/java/test/builder/BuilderTest.java b/compiler/src/it/functional-tests/src/test/java/test/builder/BuilderTest.java
index 46f5388ec..af7233a0e 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/builder/BuilderTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/builder/BuilderTest.java
@@ -45,7 +45,7 @@
     assertThat(component.s()).isEqualTo("sam");
     assertThat(component.i()).isEqualTo(1);
     assertThat(component.d()).isWithin(0).of(4.2d);
-    assertThat(component.f()).isEqualTo(5.5f);
+    assertThat(component.f()).isWithin(0).of(5.5f);
     assertThat(component.l()).isEqualTo(6L);
   }
 
@@ -69,7 +69,7 @@
     assertThat(component.s()).isEqualTo("sam");
     assertThat(component.i()).isEqualTo(1);
     assertThat(component.d()).isWithin(0).of(4.2d);
-    assertThat(component.f()).isEqualTo(5.5f);
+    assertThat(component.f()).isWithin(0).of(5.5f);
     assertThat(component.l()).isEqualTo(6L);
   }
 
@@ -93,7 +93,7 @@
     assertThat(component.s()).isEqualTo("sam");
     assertThat(component.i()).isEqualTo(1);
     assertThat(component.d()).isWithin(0).of(4.2d);
-    assertThat(component.f()).isEqualTo(5.5f);
+    assertThat(component.f()).isWithin(0).of(5.5f);
     assertThat(component.l()).isEqualTo(6L);
   }
 
@@ -117,7 +117,7 @@
     assertThat(component.s()).isEqualTo("sam");
     assertThat(component.i()).isEqualTo(1);
     assertThat(component.d()).isWithin(0).of(4.2d);
-    assertThat(component.f()).isEqualTo(5.5f);
+    assertThat(component.f()).isWithin(0).of(5.5f);
     assertThat(component.l()).isEqualTo(6L);
   }
   
@@ -137,7 +137,7 @@
     assertThat(child1.s()).isEqualTo("sam");
     assertThat(child1.i()).isEqualTo(1);
     assertThat(child1.d()).isWithin(0).of(4.2d);
-    assertThat(child1.f()).isEqualTo(5.5f);
+    assertThat(child1.f()).isWithin(0).of(5.5f);
     assertThat(child1.l()).isEqualTo(6L);
     assertThat(child1.b()).isEqualTo((byte)7);
   }
@@ -159,7 +159,7 @@
     assertThat(child2.s()).isEqualTo("tara");
     assertThat(child2.i()).isEqualTo(10);
     assertThat(child2.d()).isWithin(0).of(4.2d);
-    assertThat(child2.f()).isEqualTo(5.5f);
+    assertThat(child2.f()).isWithin(0).of(5.5f);
     assertThat(child2.l()).isEqualTo(6L);
     assertThat(child2.b()).isEqualTo((byte)70);
   }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedComponent.java
index a80ea4968..0d4dc13fd 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedComponent.java
@@ -15,7 +15,6 @@
  */
 package producerstest;
 
-import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Component;
 
 @Component(modules = DependedModule.class)
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedProducerModule.java
index fe47c9973..bd1bc7a6b 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedProducerModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedProducerModule.java
@@ -15,15 +15,9 @@
  */
 package producerstest;
 
-import com.google.common.base.Ascii;
-import com.google.common.collect.ImmutableList;
-import com.google.common.util.concurrent.Futures;
-import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
 
-import java.util.List;
-
 @ProducerModule
 final class DependedProducerModule {
 
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ResponseProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ResponseProducerModule.java
index 02fa7e91f..b250a53ba 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ResponseProducerModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ResponseProducerModule.java
@@ -40,11 +40,11 @@
   static ListenableFuture<String> intermediateGreeting(
       // TODO(beder): Allow Producer and Provider of the same type (which would force the binding
       // to be a provision binding), and add validation for that.
-      String greeting,
+      @SuppressWarnings("unused") String greeting,
       Producer<String> greetingProducer,
-      Produced<String> greetingProduced,
-      Provider<Integer> requestNumberProvider,
-      Lazy<Integer> requestNumberLazy) {
+      @SuppressWarnings("unused") Produced<String> greetingProduced,
+      @SuppressWarnings("unused") Provider<Integer> requestNumberProvider,
+      @SuppressWarnings("unused") Lazy<Integer> requestNumberLazy) {
     return greetingProducer.get();
   }
 
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleProducerModule.java
index 7e335cc3b..da58db06c 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleProducerModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleProducerModule.java
@@ -69,48 +69,57 @@ static String str() {
 
   @Produces
   @Qual(2)
-  static String strWithArg(int i) {
+  static String strWithArg(@SuppressWarnings("unused") int i) {
     return "str with arg";
   }
 
   @Produces
   @Qual(3)
-  static ListenableFuture<String> futureStrWithArg(int i) {
+  static ListenableFuture<String> futureStrWithArg(@SuppressWarnings("unused") int i) {
     return Futures.immediateFuture("future str with arg");
   }
 
   @Produces
   @Qual(4)
+  @SuppressWarnings("unused") // unthrown exception for test
   static String strThrowingException() throws IOException {
     return "str throwing exception";
   }
 
   @Produces
   @Qual(5)
+  @SuppressWarnings("unused") // unthrown exception for test
   static ListenableFuture<String> futureStrThrowingException() throws IOException {
     return Futures.immediateFuture("future str throwing exception");
   }
 
   @Produces
   @Qual(6)
+  @SuppressWarnings("unused") // unthrown exception for test, unused parameter for test
   static String strWithArgThrowingException(int i) throws IOException {
     return "str with arg throwing exception";
   }
 
   @Produces
   @Qual(7)
+  @SuppressWarnings("unused") // unthrown exception for test, unused parameter for test
   static ListenableFuture<String> futureStrWithArgThrowingException(int i) throws IOException {
     return Futures.immediateFuture("future str with arg throwing exception");
   }
 
   @Produces
   @Qual(8)
-  static String strWithArgs(int i, Produced<Double> b, Producer<Object> c, Provider<Boolean> d) {
+  static String strWithArgs(
+      @SuppressWarnings("unused") int i,
+      @SuppressWarnings("unused") Produced<Double> b,
+      @SuppressWarnings("unused") Producer<Object> c,
+      @SuppressWarnings("unused") Provider<Boolean> d) {
     return "str with args";
   }
 
   @Produces
   @Qual(9)
+  @SuppressWarnings("unused") // unthrown exception for test, unused parameters for test
   static String strWithArgsThrowingException(
       int i, Produced<Double> b, Producer<Object> c, Provider<Boolean> d) throws IOException {
     return "str with args throwing exception";
@@ -119,12 +128,16 @@ static String strWithArgsThrowingException(
   @Produces
   @Qual(10)
   static ListenableFuture<String> futureStrWithArgs(
-      int i, Produced<Double> b, Producer<Object> c, Provider<Boolean> d) {
+      @SuppressWarnings("unused") int i,
+      @SuppressWarnings("unused") Produced<Double> b,
+      @SuppressWarnings("unused") Producer<Object> c,
+      @SuppressWarnings("unused") Provider<Boolean> d) {
     return Futures.immediateFuture("future str with args");
   }
 
   @Produces
   @Qual(11)
+  @SuppressWarnings("unused") // unthrown exception for test, unused parameter for test
   static ListenableFuture<String> futureStrWithArgsThrowingException(
       int i, Produced<Double> b, Producer<Object> c, Provider<Boolean> d) throws IOException {
     return Futures.immediateFuture("str with args throwing exception");
@@ -133,9 +146,14 @@ static String strWithArgsThrowingException(
   @Produces
   @Qual(12)
   static String strWithFrameworkTypeArgs(
-      @Qual(1) int i, @Qual(1) Provider<Integer> iProvider, @Qual(1) Lazy<Integer> iLazy,
-      @Qual(2) int j, @Qual(2) Produced<Integer> jProduced, @Qual(2) Producer<Integer> jProducer,
-      @Qual(3) Produced<Integer> kProduced, @Qual(3) Producer<Integer> kProducer) {
+      @SuppressWarnings("unused") @Qual(1) int i,
+      @SuppressWarnings("unused") @Qual(1) Provider<Integer> iProvider,
+      @SuppressWarnings("unused") @Qual(1) Lazy<Integer> iLazy,
+      @SuppressWarnings("unused") @Qual(2) int j,
+      @SuppressWarnings("unused") @Qual(2) Produced<Integer> jProduced,
+      @SuppressWarnings("unused") @Qual(2) Producer<Integer> jProducer,
+      @SuppressWarnings("unused") @Qual(3) Produced<Integer> kProduced,
+      @SuppressWarnings("unused") @Qual(3) Producer<Integer> kProducer) {
     return "str with framework type args";
   }
 
@@ -149,6 +167,7 @@ static String setOfStrElement() {
 
   @Produces
   @IntoSet
+  @SuppressWarnings("unused") // unthrown exception for test
   static String setOfStrElementThrowingException() throws IOException {
     return "set of str element throwing exception";
   }
@@ -161,30 +180,33 @@ static String setOfStrElementThrowingException() throws IOException {
 
   @Produces
   @IntoSet
+  @SuppressWarnings("unused") // unthrown exception for test
   static ListenableFuture<String> setOfStrFutureElementThrowingException() throws IOException {
     return Futures.immediateFuture("set of str element throwing exception");
   }
 
   @Produces
   @IntoSet
-  static String setOfStrElementWithArg(int i) {
+  static String setOfStrElementWithArg(@SuppressWarnings("unused") int i) {
     return "set of str element with arg";
   }
 
   @Produces
   @IntoSet
+  @SuppressWarnings("unused") // unthrown exception for test, unused parameter for test
   static String setOfStrElementWithArgThrowingException(int i) throws IOException {
     return "set of str element with arg throwing exception";
   }
 
   @Produces
   @IntoSet
-  static ListenableFuture<String> setOfStrFutureElementWithArg(int i) {
+  static ListenableFuture<String> setOfStrFutureElementWithArg(@SuppressWarnings("unused") int i) {
     return Futures.immediateFuture("set of str element with arg");
   }
 
   @Produces
   @IntoSet
+  @SuppressWarnings("unused") // unthrown exception for test, unused parameter for test
   static ListenableFuture<String> setOfStrFutureElementWithArgThrowingException(int i)
       throws IOException {
     return Futures.immediateFuture("set of str element with arg throwing exception");
@@ -198,6 +220,7 @@ static String setOfStrElementWithArgThrowingException(int i) throws IOException
 
   @Produces
   @ElementsIntoSet
+  @SuppressWarnings("unused") // unthrown exception for test
   static Set<String> setOfStrValuesThrowingException() throws IOException {
     return ImmutableSet.of("set of str 1", "set of str 2 throwing exception");
   }
@@ -210,6 +233,7 @@ static String setOfStrElementWithArgThrowingException(int i) throws IOException
 
   @Produces
   @ElementsIntoSet
+  @SuppressWarnings("unused") // unthrown exception for test
   static ListenableFuture<Set<String>> setOfStrFutureValuesThrowingException() throws IOException {
     return Futures.<Set<String>>immediateFuture(
         ImmutableSet.of("set of str 1", "set of str 2 throwing exception"));
@@ -217,25 +241,28 @@ static String setOfStrElementWithArgThrowingException(int i) throws IOException
 
   @Produces
   @ElementsIntoSet
-  static Set<String> setOfStrValuesWithArg(int i) {
+  static Set<String> setOfStrValuesWithArg(@SuppressWarnings("unused") int i) {
     return ImmutableSet.of("set of str with arg 1", "set of str with arg 2");
   }
 
   @Produces
   @ElementsIntoSet
+  @SuppressWarnings("unused") // unthrown exception for test, unused parameter for test
   static Set<String> setOfStrValuesWithArgThrowingException(int i) throws IOException {
     return ImmutableSet.of("set of str with arg 1", "set of str with arg 2 throwing exception");
   }
 
   @Produces
   @ElementsIntoSet
-  static ListenableFuture<Set<String>> setOfStrFutureValuesWithArg(int i) {
+  static ListenableFuture<Set<String>> setOfStrFutureValuesWithArg(
+      @SuppressWarnings("unused") int i) {
     return Futures.<Set<String>>immediateFuture(
         ImmutableSet.of("set of str with arg 1", "set of str with arg 2"));
   }
 
   @Produces
   @ElementsIntoSet
+  @SuppressWarnings("unused") // unthrown exception for test, unused parameter for test
   static ListenableFuture<Set<String>> setOfStrFutureValuesWithArgThrowingException(int i)
       throws IOException {
     return Futures.<Set<String>>immediateFuture(
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/badexecutor/BadExecutorTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/badexecutor/BadExecutorTest.java
index 0e4d44d39..1f0db70b2 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/badexecutor/BadExecutorTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/badexecutor/BadExecutorTest.java
@@ -70,6 +70,6 @@ public void rejectSingleArgFromComponentDepMethod() throws Exception {
 
   @Test
   public void doNotRejectComponentDepMethod() throws Exception {
-    assertThat(component.doubleDep().get()).isEqualTo(42.0);
+    assertThat(component.doubleDep().get()).isWithin(0).of(42.0);
   }
 }
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/builder/ProductionComponentBuilderTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/builder/ProductionComponentBuilderTest.java
index 10e5f4fac..396bef65f 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/builder/ProductionComponentBuilderTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/builder/ProductionComponentBuilderTest.java
@@ -35,7 +35,7 @@ public void successfulBuild() throws Exception {
             .strModule(new StringModule())
             .build();
     assertThat(component.s().get()).isEqualTo("arg: 42");
-    assertThat(component.d().get()).isEqualTo(15.3);
+    assertThat(component.d().get()).isWithin(0).of(15.3);
   }
 
   @Test
@@ -45,7 +45,7 @@ public void successfulBuild_withMissingZeroArgModule() throws Exception {
             .depComponent(depComponent(15.3))
             .build();
     assertThat(component.s().get()).isEqualTo("arg: 42");
-    assertThat(component.d().get()).isEqualTo(15.3);
+    assertThat(component.d().get()).isWithin(0).of(15.3);
   }
 
   @Test(expected = IllegalStateException.class)
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index fe7d31792..58f54084f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -365,6 +365,7 @@ private void addBuildMethod(
    */
   private void addBuilderMethods(
       TypeSpec.Builder componentBuilder, Optional<BuilderSpec> builderSpec) {
+    ImmutableSet<TypeElement> componentRequirements = graph.componentRequirements();
     if (builderSpec.isPresent()) {
       UniqueNameSet parameterNames = new UniqueNameSet();
       for (Map.Entry<TypeElement, ExecutableElement> builderMethodEntry :
@@ -376,7 +377,7 @@ private void addBuilderMethods(
             parameterNames.getUniqueName(
                 Iterables.getOnlyElement(specMethod.getParameters()).getSimpleName());
         builderMethod.addParameter(ClassName.get(builderMethodType), parameterName);
-        if (graph.componentRequirements().contains(builderMethodType)) {
+        if (componentRequirements.contains(builderMethodType)) {
           // required type
           builderMethod.addStatement(
               "this.$N = $T.checkNotNull($L)",
@@ -407,7 +408,7 @@ private void addBuilderMethods(
                 .returns(builderName.get())
                 .addModifiers(PUBLIC)
                 .addParameter(ClassName.get(componentRequirement), componentRequirementName);
-        if (graph.componentRequirements().contains(componentRequirement)) {
+        if (componentRequirements.contains(componentRequirement)) {
           builderMethod.addStatement(
               "this.$N = $T.checkNotNull($L)",
               builderFields.get(componentRequirement),
@@ -484,27 +485,25 @@ private void addField(ResolvedBindings resolvedBindings) {
 
     // TODO(gak): get rid of the field for unscoped delegated bindings
 
-    FieldSpec frameworkField = addFrameworkField(resolvedBindings, Optional.<BindingType>absent());
-    memberSelects.put(
-        bindingKey,
-        localField(name, frameworkField.name));
+    FieldSpec frameworkField = addFrameworkField(resolvedBindings, Optional.<ClassName>absent());
+    memberSelects.put(bindingKey, localField(name, frameworkField.name));
   }
 
   /**
    * Adds a field representing the resolved bindings, optionally forcing it to use a particular
-   * binding type (instead of the type the resolved bindings would typically use).
+   * framework class (instead of the class the resolved bindings would typically use).
    */
   private FieldSpec addFrameworkField(
-      ResolvedBindings resolvedBindings, Optional<BindingType> bindingType) {
+      ResolvedBindings resolvedBindings, Optional<ClassName> frameworkClass) {
     boolean useRawType = useRawType(resolvedBindings);
 
     FrameworkField contributionBindingField =
-        FrameworkField.createForResolvedBindings(resolvedBindings, bindingType);
+        FrameworkField.forResolvedBindings(resolvedBindings, frameworkClass);
     FieldSpec.Builder contributionField =
         componentField(
             useRawType
-                ? contributionBindingField.frameworkType().rawType
-                : contributionBindingField.frameworkType(),
+                ? contributionBindingField.type().rawType
+                : contributionBindingField.type(),
             contributionBindingField.name());
     contributionField.addModifiers(PRIVATE);
     if (useRawType) {
@@ -872,7 +871,7 @@ private CodeBlock initializeProducersFromProviderDependencies(Binding binding) {
           continue;
         }
         FieldSpec frameworkField =
-            addFrameworkField(resolvedBindings, Optional.of(BindingType.PRODUCTION));
+            addFrameworkField(resolvedBindings, Optional.of(PRODUCER));
         memberSelect = localField(name, frameworkField.name);
         producerFromProviderMemberSelects.put(frameworkDependency.bindingKey(), memberSelect);
         initializations.add(
@@ -986,7 +985,7 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
               Lists.newArrayListWithCapacity(binding.dependencies().size() + 1);
           if (binding.bindingKind().equals(PROVISION)
               && !binding.bindingElement().getModifiers().contains(STATIC)) {
-            arguments.add(getComponentContributionExpression(binding.contributedBy().get()));
+            arguments.add(getComponentContributionExpression(binding.contributingModule().get()));
           }
           arguments.addAll(getDependencyArguments(binding));
 
@@ -1075,7 +1074,7 @@ private CodeBlock initializeMembersInjectorForBinding(MembersInjectionBinding bi
       case INJECT_MEMBERS:
         return CodeBlock.of(
             "$T.create($L)",
-            membersInjectorNameForType(binding.bindingElement()),
+            membersInjectorNameForType(binding.membersInjectedType()),
             makeParametersCodeBlock(getDependencyArguments(binding)));
       default:
         throw new AssertionError();
diff --git a/compiler/src/main/java/dagger/internal/codegen/Binding.java b/compiler/src/main/java/dagger/internal/codegen/Binding.java
index 71e1361ea..e3e6e49be 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Binding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Binding.java
@@ -21,8 +21,6 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
 import dagger.internal.codegen.BindingType.HasBindingType;
-import dagger.internal.codegen.Key.HasKey;
-import dagger.internal.codegen.SourceElement.HasSourceElement;
 import java.util.List;
 import java.util.Set;
 import javax.lang.model.element.Element;
@@ -48,7 +46,7 @@
  * @author Gregory Kick
  * @since 2.0
  */
-abstract class Binding implements HasBindingType, HasKey, HasSourceElement {
+abstract class Binding extends BindingDeclaration implements HasBindingType {
 
   /**
    * Returns the framework class associated with this binding.
@@ -61,16 +59,6 @@
   @Override
   public abstract Key key();
 
-  /** Returns the {@link Element} instance that is responsible for declaring the binding. */
-  Element bindingElement() {
-    return sourceElement().element();
-  }
-
-  /** The type enclosing the binding {@link #bindingElement()}. */
-  TypeElement bindingTypeElement() {
-    return sourceElement().enclosingTypeElement();
-  }
-
   /**
    * The explicit set of {@link DependencyRequest dependencies} required to satisfy this binding.
    */
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/BindingDeclaration.java
new file mode 100644
index 000000000..6a2a513f4
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingDeclaration.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreElements;
+import com.google.common.base.Function;
+import com.google.common.base.Optional;
+import com.google.common.base.Predicate;
+import dagger.internal.codegen.Key.HasKey;
+import java.util.Set;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Types;
+
+import static dagger.internal.codegen.Util.AS_DECLARED_TYPE;
+import static dagger.internal.codegen.Util.ENCLOSING_TYPE_ELEMENT;
+
+/** An object that declares or specifies a binding. */
+abstract class BindingDeclaration implements HasKey {
+
+  /** The {@link Element} that declares the binding. */
+  abstract Element bindingElement();
+
+  /**
+   * The {@link ExecutableElement} that declares the binding. Equivalent to
+   * {@code MoreElements.asExecutable(bindingElement())}.
+   *
+   * @throws IllegalStateException if {@link #bindingElement()} is not an executable element
+   */
+  ExecutableElement bindingElementAsExecutable() {
+    try {
+      return MoreElements.asExecutable(bindingElement());
+    } catch (IllegalArgumentException e) {
+      throw new IllegalStateException(e);
+    }
+  }
+
+  /** The type enclosing the {@link #bindingElement()}. */
+  TypeElement bindingTypeElement() {
+    return ENCLOSING_TYPE_ELEMENT.visit(bindingElement());
+  }
+
+  /**
+   * The installed module class that contributed the {@link #bindingElement()}. May be a subclass
+   * of the class that contains {@link #bindingElement()}.
+   */
+  abstract Optional<TypeElement> contributingModule();
+
+  /**
+   * The type of {@link #contributingModule()}.
+   */
+  Optional<DeclaredType> contributingModuleType() {
+    return contributingModule().transform(AS_DECLARED_TYPE);
+  }
+
+  /**
+   * The type of {@link #bindingElement()}, considered as a member of {@link #contributingModule()}
+   * if it is present.
+   */
+  TypeMirror declaredType(Types types) {
+    return contributingModuleType().isPresent()
+        ? types.asMemberOf(contributingModuleType().get(), bindingElement())
+        : bindingElement().asType();
+  }
+
+  static final Function<BindingDeclaration, Set<TypeElement>> CONTRIBUTING_MODULE =
+      new Function<BindingDeclaration, Set<TypeElement>>() {
+        @Override
+        public Set<TypeElement> apply(BindingDeclaration bindingDeclaration) {
+          return bindingDeclaration.contributingModule().asSet();
+        }
+      };
+
+  static Predicate<BindingDeclaration> bindingElementHasModifier(final Modifier modifier) {
+    return new Predicate<BindingDeclaration>() {
+      @Override
+      public boolean apply(BindingDeclaration bindingDeclaration) {
+        return bindingDeclaration.bindingElement().getModifiers().contains(modifier);
+      }
+    };
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingDeclarationFormatter.java b/compiler/src/main/java/dagger/internal/codegen/BindingDeclarationFormatter.java
new file mode 100644
index 000000000..ba6f1fde7
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingDeclarationFormatter.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
+
+/**
+ * Formats a {@link BindingDeclaration} into a {@link String} suitable for use in error messages.
+ */
+final class BindingDeclarationFormatter extends Formatter<BindingDeclaration> {
+  private final MethodSignatureFormatter methodSignatureFormatter;
+
+  BindingDeclarationFormatter(MethodSignatureFormatter methodSignatureFormatter) {
+    this.methodSignatureFormatter = methodSignatureFormatter;
+  }
+
+  @Override
+  public String format(BindingDeclaration bindingDeclaration) {
+    switch (bindingDeclaration.bindingElement().asType().getKind()) {
+      case EXECUTABLE:
+        return methodSignatureFormatter.format(
+            bindingDeclaration.bindingElementAsExecutable(),
+            bindingDeclaration.contributingModuleType());
+      case DECLARED:
+        return stripCommonTypePrefixes(bindingDeclaration.bindingElement().asType().toString());
+      default:
+        throw new IllegalArgumentException(
+            "Formatting unsupported for element: " + bindingDeclaration.bindingElement());
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 210ee33d9..8d91101d7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -56,8 +56,10 @@
 import javax.lang.model.util.Elements;
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static com.google.auto.common.MoreElements.hasModifiers;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Predicates.in;
+import static com.google.common.base.Predicates.not;
 import static com.google.common.base.Verify.verify;
 import static dagger.internal.codegen.BindingKey.Kind.CONTRIBUTION;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
@@ -70,6 +72,7 @@
 import static dagger.internal.codegen.ContributionBinding.Kind.IS_SYNTHETIC_MULTIBINDING_KIND;
 import static dagger.internal.codegen.Key.indexByKey;
 import static dagger.internal.codegen.Scope.reusableScope;
+import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.STATIC;
 
 /**
@@ -108,40 +111,34 @@
       };
 
   /**
-   * Returns the set of types necessary to implement the component, but are not part of the injected
-   * graph.  This includes modules and component dependencies.
+   * The types for which the component needs instances.
+   * <ul>
+   * <li>component dependencies
+   * <li>{@linkplain #ownedModules() owned modules} with concrete instance bindings that are used in
+   *     the graph
+   * </ul>
    */
   ImmutableSet<TypeElement> componentRequirements() {
     return SUBGRAPH_TRAVERSER
         .preOrderTraversal(this)
-        .transformAndConcat(
-            new Function<BindingGraph, Iterable<ResolvedBindings>>() {
-              @Override
-              public Iterable<ResolvedBindings> apply(BindingGraph input) {
-                return input.resolvedBindings().values();
-              }
-            })
-        .transformAndConcat(
-            new Function<ResolvedBindings, Set<ContributionBinding>>() {
-              @Override
-              public Set<ContributionBinding> apply(ResolvedBindings input) {
-                return input.contributionBindings();
-              }
-            })
-        .transformAndConcat(
-            new Function<ContributionBinding, Set<TypeElement>>() {
-              @Override
-              public Set<TypeElement> apply(ContributionBinding input) {
-                return input.bindingElement().getModifiers().contains(STATIC)
-                    ? ImmutableSet.<TypeElement>of()
-                    : input.contributedBy().asSet();
-              }
-            })
+        .transformAndConcat(RESOLVED_BINDINGS)
+        .transformAndConcat(ResolvedBindings.CONTRIBUTION_BINDINGS)
+        .filter(not(BindingDeclaration.bindingElementHasModifier(STATIC)))
+        .filter(not(BindingDeclaration.bindingElementHasModifier(ABSTRACT)))
+        .transformAndConcat(BindingDeclaration.CONTRIBUTING_MODULE)
         .filter(in(ownedModuleTypes()))
         .append(componentDescriptor().dependencies())
         .toSet();
   }
 
+  private static final Function<BindingGraph, Iterable<ResolvedBindings>> RESOLVED_BINDINGS =
+      new Function<BindingGraph, Iterable<ResolvedBindings>>() {
+        @Override
+        public Iterable<ResolvedBindings> apply(BindingGraph graph) {
+          return graph.resolvedBindings().values();
+        }
+      };
+
   /**
    * Returns the {@link ComponentDescriptor}s for this component and its subcomponents.
    */
@@ -159,10 +156,10 @@ public ComponentDescriptor apply(BindingGraph graph) {
   }
 
   ImmutableSet<TypeElement> availableDependencies() {
-    return new ImmutableSet.Builder<TypeElement>()
-        .addAll(componentDescriptor().transitiveModuleTypes())
-        .addAll(componentDescriptor().dependencies())
-        .build();
+    return FluentIterable.from(componentDescriptor().transitiveModuleTypes())
+        .filter(not(hasModifiers(ABSTRACT)))
+        .append(componentDescriptor().dependencies())
+        .toSet();
   }
 
   static final class Factory {
@@ -316,8 +313,9 @@ private BindingGraph create(
         ImmutableSetMultimap.Builder<Key, ContributionBinding> explicitMultibindingsBuilder =
             ImmutableSetMultimap.builder();
         for (ContributionBinding binding : explicitBindingsSet) {
-          if (binding.key().bindingMethod().isPresent()) {
-            explicitMultibindingsBuilder.put(binding.key().withoutBindingMethod(), binding);
+          if (binding.key().bindingMethodIdentifier().isPresent()) {
+            explicitMultibindingsBuilder.put(
+                binding.key().withoutBindingMethodIdentifier(), binding);
           }
         }
         this.explicitMultibindings = explicitMultibindingsBuilder.build();
@@ -586,8 +584,9 @@ private boolean isResolvedInParent(DependencyRequest request, ContributionBindin
       }
 
       /**
-       * Returns the explicit multibindings whose key (minus its {@link Key#bindingMethod()})
-       * matches the {@code requestKey} from this and all ancestor resolvers.
+       * Returns the explicit multibindings whose key (minus its
+       * {@link Key#bindingMethodIdentifier()}) matches the {@code requestKey} from this and all
+       * ancestor resolvers.
        */
       private ImmutableSet<ContributionBinding> getExplicitMultibindings(Key requestKey) {
         ImmutableSet.Builder<ContributionBinding> explicitMultibindingsForKey =
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 17ed72d44..3aadd6a3d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -43,7 +43,6 @@
 import dagger.MapKey;
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
-import dagger.internal.codegen.SourceElement.HasSourceElement;
 import dagger.producers.ProductionComponent;
 import java.util.ArrayDeque;
 import java.util.Collection;
@@ -111,7 +110,7 @@
   private final Types types;
   private final CompilerOptions compilerOptions;
   private final InjectBindingRegistry injectBindingRegistry;
-  private final HasSourceElementFormatter hasSourceElementFormatter;
+  private final BindingDeclarationFormatter bindingDeclarationFormatter;
   private final MethodSignatureFormatter methodSignatureFormatter;
   private final DependencyRequestFormatter dependencyRequestFormatter;
   private final KeyFormatter keyFormatter;
@@ -122,7 +121,7 @@
       Types types,
       CompilerOptions compilerOptions,
       InjectBindingRegistry injectBindingRegistry,
-      HasSourceElementFormatter hasSourceElementFormatter,
+      BindingDeclarationFormatter bindingDeclarationFormatter,
       MethodSignatureFormatter methodSignatureFormatter,
       DependencyRequestFormatter dependencyRequestFormatter,
       KeyFormatter keyFormatter,
@@ -131,7 +130,7 @@
     this.types = types;
     this.compilerOptions = compilerOptions;
     this.injectBindingRegistry = injectBindingRegistry;
-    this.hasSourceElementFormatter = hasSourceElementFormatter;
+    this.bindingDeclarationFormatter = bindingDeclarationFormatter;
     this.methodSignatureFormatter = methodSignatureFormatter;
     this.dependencyRequestFormatter = dependencyRequestFormatter;
     this.keyFormatter = keyFormatter;
@@ -334,13 +333,12 @@ private void traverseRequest(DependencyRequest request, DependencyPath path) {
           validateResolvedBinding(path);
 
           // Validate all dependencies within the component that owns the binding.
-          for (Map.Entry<ComponentDescriptor, Collection<Binding>> entry :
-              path.currentBinding().bindingsByComponent().asMap().entrySet()) {
+          for (Map.Entry<ComponentDescriptor, ? extends Binding> entry :
+              path.currentBinding().bindingsByComponent()) {
             Validation validation = validationForComponent(entry.getKey());
-            for (Binding binding : entry.getValue()) {
-              for (DependencyRequest nextRequest : binding.implicitDependencies()) {
-                validation.traverseRequest(nextRequest, path);
-              }
+            Binding binding = entry.getValue();
+            for (DependencyRequest nextRequest : binding.implicitDependencies()) {
+              validation.traverseRequest(nextRequest, path);
             }
           }
         }
@@ -491,10 +489,10 @@ private ResolvedBindings inlineSyntheticContributions(ResolvedBindings resolvedB
           multibindingDeclarations.build());
     }
 
-    private ImmutableListMultimap<ContributionType, HasSourceElement> declarationsByType(
+    private ImmutableListMultimap<ContributionType, BindingDeclaration> declarationsByType(
         ResolvedBindings resolvedBinding) {
       ResolvedBindings inlined = inlineSyntheticContributions(resolvedBinding);
-      return new ImmutableListMultimap.Builder<ContributionType, HasSourceElement>()
+      return new ImmutableListMultimap.Builder<ContributionType, BindingDeclaration>()
           .putAll(indexByContributionType(inlined.contributionBindings()))
           .putAll(indexByContributionType(inlined.multibindingDeclarations()))
           .build();
@@ -516,7 +514,7 @@ private void validateNullability(DependencyRequest request, Set<ContributionBind
       for (ContributionBinding binding : bindings) {
         if (binding.nullableType().isPresent()) {
           reportBuilder.addItem(
-              nullableToNonNullable(typeName, hasSourceElementFormatter.format(binding))
+              nullableToNonNullable(typeName, bindingDeclarationFormatter.format(binding))
                   + "\n at: "
                   + dependencyRequestFormatter.format(request),
               compilerOptions.nullableValidationKind(),
@@ -882,10 +880,9 @@ void validateComponentScope() {
             switch (contributionBinding.bindingKind()) {
               case SYNTHETIC_DELEGATE_BINDING:
               case PROVISION:
-                ExecutableElement provisionMethod =
-                    MoreElements.asExecutable(contributionBinding.bindingElement());
                 incompatiblyScopedMethodsBuilder.add(
-                    methodSignatureFormatter.format(provisionMethod));
+                    methodSignatureFormatter.format(
+                        contributionBinding.bindingElementAsExecutable()));
                 break;
               case INJECTION:
                 incompatiblyScopedMethodsBuilder.add(
@@ -1010,7 +1007,7 @@ private void reportDuplicateBindings(DependencyPath path) {
           .format(ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT, formatRootRequestKey(path));
       ImmutableSet<ContributionBinding> duplicateBindings =
           inlineSyntheticContributions(resolvedBinding).contributionBindings();
-      hasSourceElementFormatter.formatIndentedList(
+      bindingDeclarationFormatter.formatIndentedList(
           builder, duplicateBindings, 1, DUPLICATE_SIZE_LIMIT);
       owningReportBuilder(duplicateBindings).addError(builder.toString(), path.entryPointElement());
     }
@@ -1057,7 +1054,7 @@ private void reportMultipleBindingTypes(DependencyPath path) {
       new Formatter(builder)
           .format(ErrorMessages.MULTIPLE_BINDING_TYPES_FOR_KEY_FORMAT, formatRootRequestKey(path));
       ResolvedBindings resolvedBinding = path.currentBinding();
-      ImmutableListMultimap<ContributionType, HasSourceElement> declarationsByType =
+      ImmutableListMultimap<ContributionType, BindingDeclaration> declarationsByType =
           declarationsByType(resolvedBinding);
       verify(
           declarationsByType.keySet().size() > 1,
@@ -1069,7 +1066,7 @@ private void reportMultipleBindingTypes(DependencyPath path) {
         builder.append(INDENT);
         builder.append(formatContributionType(type));
         builder.append(" bindings and declarations:");
-        hasSourceElementFormatter.formatIndentedList(
+        bindingDeclarationFormatter.formatIndentedList(
             builder, declarationsByType.get(type), 2, DUPLICATE_SIZE_LIMIT);
         builder.append('\n');
       }
@@ -1080,7 +1077,7 @@ private void reportDuplicateMapKeys(
         DependencyPath path, Collection<ContributionBinding> mapBindings) {
       StringBuilder builder = new StringBuilder();
       builder.append(duplicateMapKeysError(formatRootRequestKey(path)));
-      hasSourceElementFormatter.formatIndentedList(builder, mapBindings, 1, DUPLICATE_SIZE_LIMIT);
+      bindingDeclarationFormatter.formatIndentedList(builder, mapBindings, 1, DUPLICATE_SIZE_LIMIT);
       reportBuilder.addError(builder.toString(), path.entryPointElement());
     }
 
@@ -1101,7 +1098,7 @@ private void reportInconsistentMapKeyAnnotations(
             .append(annotationType)
             .append(':');
 
-        hasSourceElementFormatter.formatIndentedList(builder, bindings, 2, DUPLICATE_SIZE_LIMIT);
+        bindingDeclarationFormatter.formatIndentedList(builder, bindings, 2, DUPLICATE_SIZE_LIMIT);
       }
       reportBuilder.addError(builder.toString(), path.entryPointElement());
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java
index 2184a8b92..700f35c5b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java
@@ -37,8 +37,8 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
-import static dagger.internal.codegen.ErrorMessages.BIND_METHOD_NOT_ABSTRACT;
-import static dagger.internal.codegen.ErrorMessages.BIND_METHOD_ONE_ASSIGNABLE_PARAMETER;
+import static dagger.internal.codegen.ErrorMessages.BINDS_METHOD_NOT_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER;
 import static dagger.internal.codegen.Validation.validateMethodQualifiers;
 import static dagger.internal.codegen.Validation.validateReturnType;
 import static dagger.internal.codegen.Validation.validateUncheckedThrows;
@@ -88,7 +88,7 @@
 
       Set<Modifier> modifiers = bindsMethodElement.getModifiers();
       if (!modifiers.contains(ABSTRACT)) {
-        builder.addError(formatErrorMessage(BIND_METHOD_NOT_ABSTRACT), bindsMethodElement);
+        builder.addError(formatErrorMessage(BINDS_METHOD_NOT_ABSTRACT), bindsMethodElement);
       }
       TypeMirror returnType = bindsMethodElement.getReturnType();
       validateReturnType(Binds.class, builder, returnType);
@@ -98,11 +98,11 @@
         VariableElement parameter = Iterables.getOnlyElement(parameters);
         if (!types.isAssignable(parameter.asType(), returnType)) {
           builder.addError(
-              formatErrorMessage(BIND_METHOD_ONE_ASSIGNABLE_PARAMETER), bindsMethodElement);
+              formatErrorMessage(BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER), bindsMethodElement);
         }
       } else {
         builder.addError(
-            formatErrorMessage(BIND_METHOD_ONE_ASSIGNABLE_PARAMETER), bindsMethodElement);
+            formatErrorMessage(BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER), bindsMethodElement);
       }
 
       validateUncheckedThrows(elements, types, bindsMethodElement, Binds.class, builder);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index e21aa8e53..219c68865 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -61,8 +61,8 @@ public SourceVersion getSupportedSourceVersion() {
     CompilerOptions compilerOptions = CompilerOptions.create(processingEnv, elements);
 
     MethodSignatureFormatter methodSignatureFormatter = new MethodSignatureFormatter(types);
-    HasSourceElementFormatter hasSourceElementFormatter =
-        new HasSourceElementFormatter(methodSignatureFormatter);
+    BindingDeclarationFormatter bindingDeclarationFormatter =
+        new BindingDeclarationFormatter(methodSignatureFormatter);
     DependencyRequestFormatter dependencyRequestFormatter =
         new DependencyRequestFormatter(types, elements);
     KeyFormatter keyFormatter = new KeyFormatter(methodSignatureFormatter);
@@ -150,7 +150,7 @@ public SourceVersion getSupportedSourceVersion() {
             types,
             compilerOptions,
             injectBindingRegistry,
-            hasSourceElementFormatter,
+            bindingDeclarationFormatter,
             methodSignatureFormatter,
             dependencyRequestFormatter,
             keyFormatter,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
index 4fd5f414b..f20bc8db6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
@@ -240,7 +240,7 @@ public ComponentValidationReport validate(final TypeElement subject,
         getAnnotationMirror(subject, componentKind.annotationType()).get();
     ImmutableList<TypeMirror> moduleTypes = getComponentModules(componentMirror);
     moduleValidator.validateReferencedModules(
-        subject, componentMirror, builder, moduleTypes, componentKind.moduleKinds());
+        subject, builder, moduleTypes, componentKind.moduleKinds());
 
     // Make sure we validate any subcomponents we're referencing, unless we know we validated
     // them already in this pass.
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index 2d9298e14..5ebf68472 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -36,7 +36,6 @@
 import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
-import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 
 import static com.google.common.collect.Sets.immutableEnumSet;
@@ -68,16 +67,6 @@
   /** Returns the type that specifies this' nullability, absent if not nullable. */
   abstract Optional<DeclaredType> nullableType();
 
-  /**
-   * If this is a provision request from an {@code @Provides} or {@code @Produces} method, this will
-   * be the element that contributed it. In the case of subclassed modules, this may differ than the
-   * binding's enclosed element, as this will return the subclass whereas the enclosed element will
-   * be the superclass.
-   */
-  Optional<TypeElement> contributedBy() {
-    return sourceElement().contributedBy();
-  }
-
   /**
    * Returns whether this binding is synthetic, i.e., not explicitly tied to code, but generated
    * implicitly by the framework.
diff --git a/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
index 78cc5d102..b7dc1076e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
@@ -18,11 +18,10 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
+import com.google.common.base.Optional;
 import com.google.common.collect.Iterables;
 import dagger.Binds;
 import dagger.internal.codegen.ContributionType.HasContributionType;
-import dagger.internal.codegen.Key.HasKey;
-import dagger.internal.codegen.SourceElement.HasSourceElement;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.ExecutableType;
@@ -35,7 +34,7 @@
  * The declaration for a delegate binding established by a {@link Bind} method.
  */
 @AutoValue
-abstract class DelegateDeclaration implements HasKey, HasSourceElement, HasContributionType {
+abstract class DelegateDeclaration extends BindingDeclaration implements HasContributionType {
   abstract DependencyRequest delegateRequest();
 
   @Override
@@ -58,16 +57,18 @@ public ContributionType contributionType() {
     DelegateDeclaration create(
         ExecutableElement bindsMethod, TypeElement contributingElement) {
       checkArgument(MoreElements.isAnnotationPresent(bindsMethod, Binds.class));
-      SourceElement sourceElement = SourceElement.forElement(bindsMethod, contributingElement);
       ExecutableType resolvedMethod =
-          MoreTypes.asExecutable(sourceElement.asMemberOfContributingType(types));
+          MoreTypes.asExecutable(
+              types.asMemberOf(MoreTypes.asDeclared(contributingElement.asType()), bindsMethod));
       DependencyRequest delegateRequest =
           dependencyRequestFactory.forRequiredResolvedVariable(
-              MoreTypes.asDeclared(contributingElement.asType()),
               Iterables.getOnlyElement(bindsMethod.getParameters()),
               Iterables.getOnlyElement(resolvedMethod.getParameterTypes()));
       return new AutoValue_DelegateDeclaration(
-          keyFactory.forBindsMethod(sourceElement), sourceElement, delegateRequest);
+          keyFactory.forBindsMethod(bindsMethod, resolvedMethod),
+          bindsMethod,
+          Optional.of(contributingElement),
+          delegateRequest);
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index f25b941a8..3dff2bf99 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -18,7 +18,6 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Equivalence;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
@@ -153,16 +152,6 @@ BindingKey bindingKey() {
 
   abstract Element requestElement();
 
-  /**
-   * Returns the possibly resolved type that contained the requesting element. For members injection
-   * requests, this is the type itself.
-   */
-  DeclaredType enclosingType() {
-    return wrappedEnclosingType().get();
-  }
-
-  abstract Equivalence.Wrapper<DeclaredType> wrappedEnclosingType();
-
   /** Returns true if this request allows null objects. */
   abstract boolean isNullable();
 
@@ -187,12 +176,12 @@ DeclaredType enclosingType() {
       this.keyFactory = keyFactory;
     }
 
-    ImmutableSet<DependencyRequest> forRequiredResolvedVariables(DeclaredType container,
+    ImmutableSet<DependencyRequest> forRequiredResolvedVariables(
         List<? extends VariableElement> variables, List<? extends TypeMirror> resolvedTypes) {
       checkState(resolvedTypes.size() == variables.size());
       ImmutableSet.Builder<DependencyRequest> builder = ImmutableSet.builder();
       for (int i = 0; i < variables.size(); i++) {
-        builder.add(forRequiredResolvedVariable(container, variables.get(i), resolvedTypes.get(i)));
+        builder.add(forRequiredResolvedVariable(variables.get(i), resolvedTypes.get(i)));
       }
       return builder.build();
     }
@@ -225,7 +214,6 @@ DependencyRequest forImplicitMapBinding(
           Kind.PROVIDER,
           mapOfFactoryKey,
           mapOfValueRequest.requestElement(),
-          mapOfValueRequest.wrappedEnclosingType(),
           false /* doesn't allow null */,
           Optional.<String>absent());
     }
@@ -237,14 +225,13 @@ DependencyRequest forImplicitMapBinding(
     DependencyRequest forMultibindingContribution(
         DependencyRequest request, ContributionBinding multibindingContribution) {
       checkArgument(
-          multibindingContribution.key().bindingMethod().isPresent(),
+          multibindingContribution.key().bindingMethodIdentifier().isPresent(),
           "multibindingContribution's key must have a binding method identifier: %s",
           multibindingContribution);
       return new AutoValue_DependencyRequest(
           multibindingContributionRequestKind(multibindingContribution),
           multibindingContribution.key(),
           request.requestElement(),
-          request.wrappedEnclosingType(),
           false /* doesn't allow null */,
           Optional.<String>absent());
     }
@@ -287,18 +274,16 @@ DependencyRequest forRequiredVariable(VariableElement variableElement, Optional<
       checkNotNull(variableElement);
       TypeMirror type = variableElement.asType();
       Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(variableElement);
-      return newDependencyRequest(
-          variableElement, type, qualifier, getEnclosingType(variableElement), name);
+      return newDependencyRequest(variableElement, type, qualifier, name);
     }
 
-    DependencyRequest forRequiredResolvedVariable(DeclaredType container,
-        VariableElement variableElement,
-        TypeMirror resolvedType) {
+    DependencyRequest forRequiredResolvedVariable(
+        VariableElement variableElement, TypeMirror resolvedType) {
       checkNotNull(variableElement);
       checkNotNull(resolvedType);
       Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(variableElement);
       return newDependencyRequest(
-          variableElement, resolvedType, qualifier, container, Optional.<String>absent());
+          variableElement, resolvedType, qualifier, Optional.<String>absent());
     }
 
     DependencyRequest forComponentProvisionMethod(ExecutableElement provisionMethod,
@@ -314,7 +299,6 @@ DependencyRequest forComponentProvisionMethod(ExecutableElement provisionMethod,
           provisionMethod,
           provisionMethodType.getReturnType(),
           qualifier,
-          getEnclosingType(provisionMethod),
           Optional.<String>absent());
     }
 
@@ -326,7 +310,6 @@ DependencyRequest forComponentProductionMethod(ExecutableElement productionMetho
           "Component production methods must be empty: %s", productionMethod);
       TypeMirror type = productionMethodType.getReturnType();
       Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(productionMethod);
-      DeclaredType container = getEnclosingType(productionMethod);
       // Only a component production method can be a request for a ListenableFuture, so we
       // special-case it here.
       if (isTypeOf(ListenableFuture.class, type)) {
@@ -335,12 +318,10 @@ DependencyRequest forComponentProductionMethod(ExecutableElement productionMetho
             keyFactory.forQualifiedType(
                 qualifier, Iterables.getOnlyElement(((DeclaredType) type).getTypeArguments())),
             productionMethod,
-            MoreTypes.equivalence().wrap(container),
             false /* doesn't allow null */,
             Optional.<String>absent());
       } else {
-        return newDependencyRequest(
-            productionMethod, type, qualifier, container, Optional.<String>absent());
+        return newDependencyRequest(productionMethod, type, qualifier, Optional.<String>absent());
       }
     }
 
@@ -352,8 +333,6 @@ DependencyRequest forComponentMembersInjectionMethod(ExecutableElement membersIn
           InjectionAnnotations.getQualifier(membersInjectionMethod);
       checkArgument(!qualifier.isPresent());
       TypeMirror returnType = membersInjectionMethodType.getReturnType();
-      Equivalence.Wrapper<DeclaredType> container =
-          MoreTypes.equivalence().wrap(getEnclosingType(membersInjectionMethod));
       TypeMirror membersInjectedType =
           MoreTypes.isType(returnType) && MoreTypes.isTypeOf(MembersInjector.class, returnType)
               ? getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments())
@@ -362,7 +341,6 @@ DependencyRequest forComponentMembersInjectionMethod(ExecutableElement membersIn
           Kind.MEMBERS_INJECTOR,
           keyFactory.forMembersInjectedType(membersInjectedType),
           membersInjectionMethod,
-          container,
           false /* doesn't allow null */,
           Optional.<String>absent());
     }
@@ -372,7 +350,6 @@ DependencyRequest forMembersInjectedType(DeclaredType type) {
           Kind.MEMBERS_INJECTOR,
           keyFactory.forMembersInjectedType(type),
           type.asElement(),
-          MoreTypes.equivalence().wrap(type),
           false /* doesn't allow null */,
           Optional.<String>absent());
     }
@@ -383,7 +360,6 @@ DependencyRequest forProductionImplementationExecutor() {
           Kind.PROVIDER,
           key,
           MoreTypes.asElement(key.type()),
-          MoreTypes.equivalence().wrap(MoreTypes.asDeclared(key.type())),
           false /* doesn't allow null */,
           Optional.<String>absent());
     }
@@ -403,7 +379,6 @@ private DependencyRequest newDependencyRequest(
         Element requestElement,
         TypeMirror type,
         Optional<AnnotationMirror> qualifier,
-        DeclaredType container,
         Optional<String> name) {
       KindAndType kindAndType = extractKindAndType(type);
       if (kindAndType.kind().equals(Kind.MEMBERS_INJECTOR)) {
@@ -418,7 +393,6 @@ private DependencyRequest newDependencyRequest(
           kindAndType.kind(),
           keyFactory.forQualifiedType(qualifier, kindAndType.type()),
           requestElement,
-          MoreTypes.equivalence().wrap(container),
           allowsNull,
           name);
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index b8a439417..6ecf713e6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -158,15 +158,15 @@ static String inconsistentMapKeyAnnotationsError(String key) {
 
   static final String BINDING_METHOD_ABSTRACT = "@%s methods cannot be abstract";
 
-  static final String BIND_METHOD_NOT_ABSTRACT = "@Bind methods must be abstract";
+  static final String BINDS_METHOD_NOT_ABSTRACT = "@Binds methods must be abstract";
 
   static final String BINDING_METHOD_PRIVATE = "@%s methods cannot be private";
 
   static final String BINDING_METHOD_TYPE_PARAMETER =
       "@%s methods may not have type parameters.";
 
-  static final String BIND_METHOD_ONE_ASSIGNABLE_PARAMETER =
-      "@Bind methods must have only one parameter whose type is assignable to the return type";
+  static final String BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER =
+      "@Binds methods must have only one parameter whose type is assignable to the return type";
 
   static final String BINDING_METHOD_NOT_IN_MODULE =
       "@%s methods can only be present within a @%s";
@@ -184,7 +184,7 @@ static String inconsistentMapKeyAnnotationsError(String key) {
       "Cannot have more than one @%s method with the same name in a single module";
 
   static final String INCOMPATIBLE_MODULE_METHODS =
-      "A @%1$s may contain non-static @%2$s methods or @Bind methods,"
+      "A @%1$s may contain non-static @%2$s methods or @Binds methods,"
           + " but not both at the same time.  (Static @%2$s may be used with either.)";
 
   static final String MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT =
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index a9350edfe..cb2a5141e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -29,7 +29,6 @@
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
 import com.squareup.javapoet.TypeVariableName;
-import dagger.Provides;
 import dagger.internal.Factory;
 import dagger.internal.MembersInjectors;
 import dagger.internal.Preconditions;
@@ -141,7 +140,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
         }
         for (FrameworkField bindingField : fields.values()) {
           addConstructorParameterAndTypeField(
-              bindingField.frameworkType(),
+              bindingField.type(),
               bindingField.name(),
               factoryBuilder,
               constructorBuilder.get());
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
index c1d4e1ac2..14e732c65 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
@@ -15,7 +15,6 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.CaseFormat;
 import com.google.common.base.Optional;
@@ -30,44 +29,47 @@
 import javax.lang.model.util.ElementKindVisitor6;
 
 /**
- * A value object that represents a field used by Dagger-generated code.
- *
- * @author Jesse Beder
- * @since 2.0
+ * A field that holds a {@link javax.inject.Provider}, {@link dagger.producers.Producer}, or other
+ * framework type.
  */
 @AutoValue
-// TODO(gak): Reexamine the this class and how consistently we're using it and its creation methods.
 abstract class FrameworkField {
-  static FrameworkField createWithTypeFromKey(Class<?> frameworkClass, Key key, String name) {
-    String suffix = frameworkClass.getSimpleName();
-    ParameterizedTypeName frameworkType =
-        ParameterizedTypeName.get(ClassName.get(frameworkClass), TypeName.get(key.type()));
+
+  /**
+   * Creates a framework field.
+   * 
+   * @param frameworkClassName the name of the framework class (e.g., {@link javax.inject.Provider})
+   * @param valueTypeName the name of the type parameter of the framework class (e.g., {@code Foo}
+   *     for {@code Provider<Foo>}
+   * @param fieldName the name of the field
+   */
+  static FrameworkField create(
+      ClassName frameworkClassName, TypeName valueTypeName, String fieldName) {
+    String suffix = frameworkClassName.simpleName();
     return new AutoValue_FrameworkField(
-        frameworkType, name.endsWith(suffix) ? name : name + suffix);
+        ParameterizedTypeName.get(frameworkClassName, valueTypeName),
+        fieldName.endsWith(suffix) ? fieldName : fieldName + suffix);
   }
 
-  private static FrameworkField createForMapBindingContribution(Key key, String name) {
-    TypeMirror type = MapType.from(key.type()).valueType();
-    String suffix = MoreTypes.asDeclared(type).asElement().getSimpleName().toString();
-    return new AutoValue_FrameworkField(
-        (ParameterizedTypeName) TypeName.get(type),
-        name.endsWith(suffix) ? name : name + suffix);
+  /**
+   * A framework field for a {@link ResolvedBindings}.
+   * 
+   * @param frameworkClass if present, the field will use this framework class instead of the normal
+   *     one for the bindings
+   */
+  static FrameworkField forResolvedBindings(
+      ResolvedBindings resolvedBindings, Optional<ClassName> frameworkClass) {
+    return create(frameworkClass.or(ClassName.get(resolvedBindings.frameworkClass())),
+        TypeName.get(fieldValueType(resolvedBindings)),
+        frameworkFieldName(resolvedBindings));
   }
 
-  static FrameworkField createForResolvedBindings(
-      ResolvedBindings resolvedBindings, Optional<BindingType> bindingType) {
-    if (resolvedBindings.isMultibindingContribution()
-        && resolvedBindings.contributionType().equals(ContributionType.MAP)) {
-      return createForMapBindingContribution(
-          resolvedBindings.key(), frameworkFieldName(resolvedBindings));
-    } else {
-      return createWithTypeFromKey(
-          bindingType.isPresent()
-              ? bindingType.get().frameworkClass()
-              : resolvedBindings.frameworkClass(),
-          resolvedBindings.key(),
-          frameworkFieldName(resolvedBindings));
-    }
+  private static TypeMirror fieldValueType(ResolvedBindings resolvedBindings) {
+    return resolvedBindings.isMultibindingContribution()
+            && resolvedBindings.contributionType().equals(ContributionType.MAP)
+        ? MapType.from(resolvedBindings.key().type())
+            .unwrappedValueType(resolvedBindings.frameworkClass())
+        : resolvedBindings.key().type();
   }
 
   private static String frameworkFieldName(ResolvedBindings resolvedBindings) {
@@ -104,6 +106,6 @@ public String visitType(TypeElement e, Binding p) {
         }
       };
 
-  abstract ParameterizedTypeName frameworkType();
+  abstract ParameterizedTypeName type();
   abstract String name();
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/HasSourceElementFormatter.java b/compiler/src/main/java/dagger/internal/codegen/HasSourceElementFormatter.java
deleted file mode 100644
index 9441f7172..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/HasSourceElementFormatter.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright (C) 2015 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.auto.common.MoreElements;
-import com.google.auto.common.MoreTypes;
-import com.google.common.base.Optional;
-import dagger.internal.codegen.SourceElement.HasSourceElement;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.DeclaredType;
-
-import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
-
-/**
- * Formats a {@link HasSourceElement} into a {@link String} suitable for use in error messages.
- */
-final class HasSourceElementFormatter extends Formatter<HasSourceElement> {
-  private final MethodSignatureFormatter methodSignatureFormatter;
-
-  HasSourceElementFormatter(MethodSignatureFormatter methodSignatureFormatter) {
-    this.methodSignatureFormatter = methodSignatureFormatter;
-  }
-
-  @Override
-  public String format(HasSourceElement hasElement) {
-    SourceElement sourceElement = hasElement.sourceElement();
-    switch (sourceElement.element().asType().getKind()) {
-      case EXECUTABLE:
-        Optional<TypeElement> contributedBy = sourceElement.contributedBy();
-        return methodSignatureFormatter.format(
-            MoreElements.asExecutable(sourceElement.element()),
-            contributedBy.isPresent()
-                ? Optional.of(MoreTypes.asDeclared(contributedBy.get().asType()))
-                : Optional.<DeclaredType>absent());
-      case DECLARED:
-        return stripCommonTypePrefixes(sourceElement.element().asType().toString());
-      default:
-        throw new IllegalArgumentException(
-            "Formatting unsupported for element: " + sourceElement.element());
-    }
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index 013c7af18..45cb39d6a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -203,7 +203,7 @@ private void registerBinding(MembersInjectionBinding binding, boolean warnIfNotA
      */
     warnIfNotAlreadyGenerated =
         warnIfNotAlreadyGenerated
-            && (!injectedConstructors(binding.bindingElement()).isEmpty()
+            && (!injectedConstructors(binding.membersInjectedType()).isEmpty()
                 ? !binding.injectionSites().isEmpty()
                 : binding.hasLocalInjectionSites());
     membersInjectionBindings.tryRegisterBinding(binding, warnIfNotAlreadyGenerated);
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index a27593174..f955b31ea 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -44,7 +44,6 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.PrimitiveType;
@@ -97,15 +96,32 @@
   abstract Equivalence.Wrapper<TypeMirror> wrappedType();
 
   /**
-   * For multibinding contributions, this is the binding method element. Each multibound map and set
-   * is represented by a
+   * Absent except for multibinding contributions. Each multibound map and set is represented by a
    * {@linkplain ProvisionBinding.Factory#syntheticMultibinding(DependencyRequest, Iterable)
    * synthetic binding} that depends on the specific contributions to that map or set. Each such
    * contribution binding therefore needs a key that identifies the specific binding, and not only
-   * the qualified type that is bound.
+   * the qualified type that is bound. For those bindings, this is the binding method element.
    */
-  abstract Optional<SourceElement> bindingMethod();
+  abstract Optional<BindingMethodIdentifier> bindingMethodIdentifier();
 
+  /** An object that uniquely identifies a multibinding contribution binding. */
+  @AutoValue
+  abstract static class BindingMethodIdentifier {
+    /**
+     * The {@link dagger.Provides} or {@link dagger.producers.Produces} method that contributes to
+     * the multibinding.
+     */
+    abstract ExecutableElement bindingMethod();
+
+    /** The installed module that contains or inherits the {@link #bindingMethod()}. */
+    abstract TypeElement contributingModule();
+
+    static BindingMethodIdentifier create(
+        ExecutableElement bindingMethod, TypeElement contributingModule) {
+      return new AutoValue_Key_BindingMethodIdentifier(bindingMethod, contributingModule);
+    }
+  }
+  
   /**
    * A {@link javax.inject.Qualifier} annotation that provides a unique namespace prefix
    * for the type of this key.
@@ -127,30 +143,32 @@ private static TypeMirror normalize(Types types, TypeMirror type) {
   }
 
   /**
-   * A key whose {@link #qualifier()} and {@link #bindingMethod()} are equivalent to this one's, but
-   * with {@code newType} (normalized) as its {@link #type()}.
+   * A key whose {@link #qualifier()} and {@link #bindingMethodIdentifier()} are equivalent to this
+   * one's, but with {@code newType} (normalized) as its {@link #type()}.
    */
   private Key withType(Types types, TypeMirror newType) {
     return new AutoValue_Key(
         wrappedQualifier(),
         MoreTypes.equivalence().wrap(normalize(types, newType)),
-        bindingMethod());
+        bindingMethodIdentifier());
   }
 
   /**
-   * A key whose {@link #qualifier()} and {@link #type()} are equivalent to this one's, but
-   * with {@code bindingMethod} as its {@link #bindingMethod()}.
+   * A key whose {@link #qualifier()} and {@link #type()} are equivalent to this one's, but with
+   * {@code bindingDeclaration} as its {@link #bindingMethodIdentifier()}.
    */
-  private Key withBindingMethod(SourceElement bindingMethod) {
-    return new AutoValue_Key(wrappedQualifier(), wrappedType(), Optional.of(bindingMethod));
+  private Key withBindingMethodIdentifier(BindingMethodIdentifier bindingMethodIdentifier) {
+    return new AutoValue_Key(
+        wrappedQualifier(), wrappedType(), Optional.of(bindingMethodIdentifier));
   }
 
   /**
    * A key whose {@link #qualifier()} and {@link #type()} are equivalent to this one's, but with an
-   * absent {@link #bindingMethod()}.
+   * absent {@link #bindingMethodIdentifier()}.
    */
-  Key withoutBindingMethod() {
-    return new AutoValue_Key(wrappedQualifier(), wrappedType(), Optional.<SourceElement>absent());
+  Key withoutBindingMethodIdentifier() {
+    return new AutoValue_Key(
+        wrappedQualifier(), wrappedType(), Optional.<BindingMethodIdentifier>absent());
   }
 
   boolean isValidMembersInjectionKey() {
@@ -205,7 +223,7 @@ public String toString() {
         .omitNullValues()
         .add("qualifier", qualifier().orNull())
         .add("type", type())
-        .add("bindingMethod", bindingMethod().orNull())
+        .add("bindingMethodIdentifier", bindingMethodIdentifier().orNull())
         .toString();
   }
 
@@ -302,20 +320,20 @@ Key forSubcomponentBuilderMethod(
       return forMethod(subcomponentBuilderMethod, returnType);
     }
 
-    Key forProvidesMethod(SourceElement sourceElement) {
-      return forProvidesOrProducesMethod(sourceElement, getProviderElement());
+    Key forProvidesMethod(ExecutableElement method, TypeElement contributingModule) {
+      return forProvidesOrProducesMethod(method, contributingModule, getProviderElement());
     }
 
-    Key forProducesMethod(SourceElement sourceElement) {
-      return forProvidesOrProducesMethod(sourceElement, getProducerElement());
+    Key forProducesMethod(ExecutableElement method, TypeElement contributingModule) {
+      return forProvidesOrProducesMethod(method, contributingModule, getProducerElement());
     }
 
     private Key forProvidesOrProducesMethod(
-        SourceElement sourceElement, TypeElement frameworkType) {
-      checkArgument(sourceElement.element().getKind().equals(METHOD));
-      ExecutableElement method = MoreElements.asExecutable(sourceElement.element());
+        ExecutableElement method, TypeElement contributingModule, TypeElement frameworkType) {
+      checkArgument(method.getKind().equals(METHOD));
       ExecutableType methodType =
-          MoreTypes.asExecutable(sourceElement.asMemberOfContributingType(types));
+          MoreTypes.asExecutable(
+              types.asMemberOf(MoreTypes.asDeclared(contributingModule.asType()), method));
       ContributionType contributionType = ContributionType.fromBindingMethod(method);
       TypeMirror returnType = normalize(types, methodType.getReturnType());
       if (frameworkType.equals(getProducerElement())
@@ -327,7 +345,8 @@ private Key forProvidesOrProducesMethod(
       Key key = forMethod(method, keyType);
       return contributionType.equals(ContributionType.UNIQUE)
           ? key
-          : key.withBindingMethod(sourceElement);
+          : key.withBindingMethodIdentifier(
+              BindingMethodIdentifier.create(method, contributingModule));
     }
 
     /**
@@ -353,24 +372,9 @@ Key forMultibindingsMethod(
     }
 
     /** Returns the key bound by a {@link Binds} method. */
-    Key forBindsMethod(SourceElement bindsMethodElement) {
-      ExecutableElement method = MoreElements.asExecutable(bindsMethodElement.element());
-      ExecutableType methodType =
-          MoreTypes.asExecutable(bindsMethodElement.asMemberOfContributingType(types));
-      checkArgument(isAnnotationPresent(method, Binds.class));
-      TypeMirror returnType = normalize(types, methodType.getReturnType());
-      return forMethod(method, returnType);
-    }
-
-    /** Returns the key for the single parameter of a {@link Binds} method. */
-    Key forBindParameter(SourceElement bindsMethodElement) {
-      ExecutableElement method = MoreElements.asExecutable(bindsMethodElement.element());
-      VariableElement parameterElement = Iterables.getOnlyElement(method.getParameters());
-      ExecutableType methodType =
-          MoreTypes.asExecutable(bindsMethodElement.asMemberOfContributingType(types));
+    Key forBindsMethod(ExecutableElement method, ExecutableType methodType) {
       checkArgument(isAnnotationPresent(method, Binds.class));
-      TypeMirror parameterType = Iterables.getOnlyElement(methodType.getParameterTypes());
-      return forQualifiedType(getQualifier(parameterElement), parameterType);
+      return forMethod(method, normalize(types, methodType.getReturnType()));
     }
 
     private TypeMirror providesOrProducesKeyType(
@@ -414,35 +418,35 @@ private Key forMethod(ExecutableElement method, TypeMirror keyType) {
       return new AutoValue_Key(
           wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(method)),
           MoreTypes.equivalence().wrap(keyType),
-          Optional.<SourceElement>absent());
+          Optional.<BindingMethodIdentifier>absent());
     }
 
     Key forInjectConstructorWithResolvedType(TypeMirror type) {
       return new AutoValue_Key(
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           MoreTypes.equivalence().wrap(type),
-          Optional.<SourceElement>absent());
+          Optional.<BindingMethodIdentifier>absent());
     }
 
     Key forComponent(TypeMirror type) {
       return new AutoValue_Key(
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           MoreTypes.equivalence().wrap(normalize(types, type)),
-          Optional.<SourceElement>absent());
+          Optional.<BindingMethodIdentifier>absent());
     }
 
     Key forMembersInjectedType(TypeMirror type) {
       return new AutoValue_Key(
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           MoreTypes.equivalence().wrap(normalize(types, type)),
-          Optional.<SourceElement>absent());
+          Optional.<BindingMethodIdentifier>absent());
     }
 
     Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
       return new AutoValue_Key(
           wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), qualifier),
           MoreTypes.equivalence().wrap(normalize(types, type)),
-          Optional.<SourceElement>absent());
+          Optional.<BindingMethodIdentifier>absent());
     }
 
     Key forProductionExecutor() {
diff --git a/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java b/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
index a670c1bae..d329627a0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
@@ -15,10 +15,6 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreElements;
-import com.google.auto.common.MoreTypes;
-import com.google.common.base.Optional;
-
 /**
  * Formats a {@link Key} into a {@link String} suitable for use in error messages and JSON keys.
  *
@@ -27,26 +23,24 @@
  */
 final class KeyFormatter extends Formatter<Key> {
   
-  private final MethodSignatureFormatter methodSignatureFormatter;
+  final MethodSignatureFormatter methodSignatureFormatter;
 
   KeyFormatter(MethodSignatureFormatter methodSignatureFormatter) {
     this.methodSignatureFormatter = methodSignatureFormatter;
   }
 
-  @Override public String format(Key request) {
-    if (request.bindingMethod().isPresent()) {
+  @Override
+  public String format(Key key) {
+    if (key.bindingMethodIdentifier().isPresent()) {
       // If there's a binding method, its signature is enough.
-      SourceElement bindingMethod = request.bindingMethod().get();
-      return methodSignatureFormatter.format(
-          MoreElements.asExecutable(bindingMethod.element()),
-          Optional.of(MoreTypes.asDeclared(bindingMethod.contributedBy().get().asType())));
+      return methodSignatureFormatter.format(key.bindingMethodIdentifier().get());
     }
     StringBuilder builder = new StringBuilder();
-    if (request.qualifier().isPresent()) {
-      builder.append(request.qualifier().get());
+    if (key.qualifier().isPresent()) {
+      builder.append(key.qualifier().get());
       builder.append(' ');
     }
-    builder.append(request.type());
+    builder.append(key.type());
     return builder.toString();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeys.java b/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
index 17643d2d1..099397369 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
@@ -88,7 +88,7 @@
     checkArgument(
         mapKeyAnnotation != null, "%s is not annotated with @MapKey", mapKey.getAnnotationType());
     return mapKeyAnnotation.unwrapValue()
-        ? Optional.of(getOnlyElement(mapKey.getElementValues().values()))
+        ? Optional.of(getOnlyElement(getAnnotationValuesWithDefaults(mapKey).values()))
         : Optional.<AnnotationValue>absent();
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index 53d15ee8d..3ca4f0cde 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -64,9 +64,8 @@
   @Override
   abstract Optional<MembersInjectionBinding> unresolved();
 
-  @Override
-  TypeElement bindingElement() {
-    return MoreElements.asType(super.bindingElement());
+  TypeElement membersInjectedType() {
+    return MoreElements.asType(bindingElement());
   }
 
   @Override
@@ -106,7 +105,7 @@ boolean hasLocalInjectionSites() {
             new Predicate<InjectionSite>() {
               @Override
               public boolean apply(InjectionSite injectionSite) {
-                return injectionSite.element().getEnclosingElement().equals(bindingElement());
+                return injectionSite.element().getEnclosingElement().equals(membersInjectedType());
               }
             });
   }
@@ -157,7 +156,7 @@ private InjectionSite injectionSiteForInjectMethod(
           InjectionSite.Kind.METHOD,
           methodElement,
           dependencyRequestFactory.forRequiredResolvedVariables(
-              containingType, methodElement.getParameters(), resolved.getParameterTypes()));
+              methodElement.getParameters(), resolved.getParameterTypes()));
     }
 
     private InjectionSite injectionSiteForInjectField(
@@ -170,8 +169,7 @@ private InjectionSite injectionSiteForInjectField(
           InjectionSite.Kind.FIELD,
           fieldElement,
           ImmutableSet.of(
-              dependencyRequestFactory.forRequiredResolvedVariable(
-                  containingType, fieldElement, resolved)));
+              dependencyRequestFactory.forRequiredResolvedVariable(fieldElement, resolved)));
     }
 
     /** Returns true if the type has some injected members in itself or any of its super classes. */
@@ -222,7 +220,8 @@ public Key apply(DeclaredType superclass) {
       Key key = keyFactory.forMembersInjectedType(declaredType);
       TypeElement typeElement = MoreElements.asType(declaredType.asElement());
       return new AutoValue_MembersInjectionBinding(
-          SourceElement.forElement(typeElement),
+          typeElement,
+          Optional.<TypeElement>absent(),
           key,
           dependencies,
           findBindingPackage(key),
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index ac1b505db..1310365c9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -81,12 +81,12 @@
 
   @Override
   ClassName nameGeneratedType(MembersInjectionBinding binding) {
-    return membersInjectorNameForType(binding.bindingElement());
+    return membersInjectorNameForType(binding.membersInjectedType());
   }
 
   @Override
   Optional<? extends Element> getElementForErrorReporting(MembersInjectionBinding binding) {
-    return Optional.of(binding.bindingElement());
+    return Optional.of(binding.membersInjectedType());
   }
 
   @Override
@@ -155,8 +155,8 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
       String fieldName = fieldNames.getUniqueName(bindingField.name());
       TypeName fieldType =
           useRawFrameworkType
-              ? bindingField.frameworkType().rawType
-              : bindingField.frameworkType();
+              ? bindingField.type().rawType
+              : bindingField.type();
       FieldSpec.Builder fieldBuilder = FieldSpec.builder(fieldType, fieldName, PRIVATE, FINAL);
       ParameterSpec.Builder parameterBuilder = ParameterSpec.builder(fieldType, fieldName);
 
@@ -193,7 +193,7 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
               ? directInjectMemberCodeBlock(binding, dependencyFields, injectionSite)
               : delegateInjectMemberCodeBlock(dependencyFields, injectionSite));
       if (!injectionSite.element().getModifiers().contains(PUBLIC)
-          && injectionSite.element().getEnclosingElement().equals(binding.bindingElement())
+          && injectionSite.element().getEnclosingElement().equals(binding.membersInjectedType())
           && delegateMethods.add(injectionSiteDelegateMethodName(injectionSite.element()))) {
         injectMethodsForSubclasses.add(
             injectorMethodForSubclasses(
@@ -224,7 +224,7 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
   // enclosed in a package-private element?
   private static boolean visibleToMembersInjector(
       MembersInjectionBinding binding, Element element) {
-    return getPackage(element).equals(getPackage(binding.bindingElement()))
+    return getPackage(element).equals(getPackage(binding.membersInjectedType()))
         || element.getModifiers().contains(PUBLIC);
   }
 
@@ -238,7 +238,7 @@ private CodeBlock directInjectMemberCodeBlock(
     return CodeBlock.of(
         injectionSite.element().getKind().isField() ? "$L.$L = $L;" : "$L.$L($L);",
         getInstanceCodeBlockWithPotentialCast(
-            injectionSite.element().getEnclosingElement(), binding.bindingElement()),
+            injectionSite.element().getEnclosingElement(), binding.membersInjectedType()),
         injectionSite.element().getSimpleName(),
         makeParametersCodeBlock(
             parameterCodeBlocks(dependencyFields, injectionSite.dependencies(), true)));
diff --git a/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java b/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java
index 896458650..fa2e55555 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java
@@ -17,8 +17,8 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
-import com.google.common.base.Function;
 import com.google.common.base.Optional;
+import dagger.internal.codegen.Key.BindingMethodIdentifier;
 import java.util.Iterator;
 import java.util.List;
 import javax.lang.model.element.AnnotationMirror;
@@ -94,18 +94,10 @@ public String format(ExecutableElement method, Optional<DeclaredType> container)
     return builder.toString();
   }
 
-  public String format(SourceElement sourceElement) {
+  String format(BindingMethodIdentifier bindingMethodIdentifier) {
     return format(
-        MoreElements.asExecutable(sourceElement.element()),
-        sourceElement
-            .contributedBy()
-            .transform(
-                new Function<TypeElement, DeclaredType>() {
-                  @Override
-                  public DeclaredType apply(TypeElement contributingModule) {
-                    return MoreTypes.asDeclared(contributingModule.asType());
-                  }
-                }));
+        MoreElements.asExecutable(bindingMethodIdentifier.bindingMethod()),
+        Optional.of(MoreTypes.asDeclared(bindingMethodIdentifier.contributingModule().asType())));
   }
 
   private static void appendParameter(StringBuilder builder, VariableElement parameter,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
index 5057dba7e..4d56bbe7d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
@@ -165,7 +165,7 @@ private void validateReferencedModules(
     // Validate that all the modules we include are valid for inclusion.
     AnnotationMirror mirror = getAnnotationMirror(subject, moduleKind.moduleAnnotation()).get();
     ImmutableList<TypeMirror> includes = getModuleIncludes(mirror);
-    validateReferencedModules(subject, mirror, builder, includes, ImmutableSet.of(moduleKind));
+    validateReferencedModules(subject, builder, includes, ImmutableSet.of(moduleKind));
   }
 
   private static ImmutableSet<? extends Class<? extends Annotation>> includedModuleClasses(
@@ -187,7 +187,6 @@ private void validateReferencedModules(
    */
   void validateReferencedModules(
       final TypeElement subject,
-      final AnnotationMirror moduleAnnotation,
       final ValidationReport.Builder<TypeElement> builder,
       ImmutableList<TypeMirror> includes,
       ImmutableSet<ModuleDescriptor.Kind> validModuleKinds) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java
index e708e35e9..c682d6497 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java
@@ -17,13 +17,12 @@
 
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
+import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
 import dagger.Module;
 import dagger.Multibindings;
 import dagger.internal.codegen.BindingType.HasBindingType;
 import dagger.internal.codegen.ContributionType.HasContributionType;
-import dagger.internal.codegen.Key.HasKey;
-import dagger.internal.codegen.SourceElement.HasSourceElement;
 import dagger.producers.Producer;
 import dagger.producers.ProducerModule;
 import java.util.Map;
@@ -48,15 +47,8 @@
  * method in a {@link Multibindings @Multibindings}-annotated interface nested within a module.
  */
 @AutoValue
-abstract class MultibindingDeclaration
-    implements HasBindingType, HasKey, HasSourceElement, HasContributionType {
-
-  /**
-   * The method in a {@link Multibindings @Multibindings} interface that declares that this map or
-   * set is available to be injected.
-   */
-  @Override
-  public abstract SourceElement sourceElement();
+abstract class MultibindingDeclaration extends BindingDeclaration
+    implements HasBindingType, HasContributionType {
 
   /**
    * The map or set key whose availability is declared. For maps, this will be {@code Map<K, F<V>>},
@@ -141,7 +133,8 @@ private MultibindingDeclaration forDeclaredMethod(
           "%s must return a set or map",
           method);
       return new AutoValue_MultibindingDeclaration(
-          SourceElement.forElement(method, interfaceElement),
+          method,
+          Optional.of(interfaceElement),
           keyFactory.forMultibindingsMethod(bindingType, methodType, method),
           contributionType(returnType),
           bindingType);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 41fd0c0e7..8fbd1d0f1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -117,9 +117,8 @@ ClassName nameGeneratedType(ProductionBinding binding) {
     }
 
     for (FrameworkField bindingField : fields.values()) {
-      TypeName fieldType = bindingField.frameworkType();
       addFieldAndConstructorParameter(
-          factoryBuilder, constructorBuilder, bindingField.name(), fieldType);
+          factoryBuilder, constructorBuilder, bindingField.name(), bindingField.type());
     }
 
     MethodSpec.Builder computeMethodBuilder =
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index 554abf1e5..268bfafab 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -90,13 +90,12 @@ public BindingType bindingType() {
     ProductionBinding forProducesMethod(
         ExecutableElement producesMethod, TypeElement contributedBy) {
       checkArgument(producesMethod.getKind().equals(METHOD));
-      SourceElement sourceElement = SourceElement.forElement(producesMethod, contributedBy);
-      Key key = keyFactory.forProducesMethod(sourceElement);
+      Key key = keyFactory.forProducesMethod(producesMethod, contributedBy);
       ExecutableType resolvedMethod =
-          MoreTypes.asExecutable(sourceElement.asMemberOfContributingType(types));
+          MoreTypes.asExecutable(
+              types.asMemberOf(MoreTypes.asDeclared(contributedBy.asType()), producesMethod));
       ImmutableSet<DependencyRequest> dependencies =
           dependencyRequestFactory.forRequiredResolvedVariables(
-              MoreTypes.asDeclared(contributedBy.asType()),
               producesMethod.getParameters(),
               resolvedMethod.getParameterTypes());
       DependencyRequest executorRequest =
@@ -108,7 +107,8 @@ ProductionBinding forProducesMethod(
           : Kind.IMMEDIATE;
       return new AutoValue_ProductionBinding(
           ContributionType.fromBindingMethod(producesMethod),
-          sourceElement,
+          producesMethod,
+          Optional.of(contributedBy),
           key,
           dependencies,
           findBindingPackage(key),
@@ -138,7 +138,8 @@ ProductionBinding syntheticMapOfValuesOrProducedBinding(
               requestForMapOfValuesOrProduced, mapOfProducersKey.get());
       return new AutoValue_ProductionBinding(
           ContributionType.UNIQUE,
-          SourceElement.forElement(requestForMapOfProducers.requestElement()),
+          requestForMapOfProducers.requestElement(),
+          Optional.<TypeElement>absent(),
           requestForMapOfValuesOrProduced.key(),
           ImmutableSet.of(requestForMapOfProducers),
           findBindingPackage(requestForMapOfValuesOrProduced.key()),
@@ -160,7 +161,8 @@ ProductionBinding syntheticMultibinding(
         final DependencyRequest request, Iterable<ContributionBinding> multibindingContributions) {
       return new AutoValue_ProductionBinding(
           ContributionType.UNIQUE,
-          SourceElement.forElement(request.requestElement()),
+          request.requestElement(),
+          Optional.<TypeElement>absent(),
           request.key(),
           dependencyRequestFactory.forMultibindingContributions(request, multibindingContributions),
           findBindingPackage(request.key()),
@@ -179,7 +181,8 @@ ProductionBinding forComponentMethod(ExecutableElement componentMethod) {
       checkArgument(MoreTypes.isTypeOf(ListenableFuture.class, componentMethod.getReturnType()));
       return new AutoValue_ProductionBinding(
           ContributionType.UNIQUE,
-          SourceElement.forElement(componentMethod),
+          componentMethod,
+          Optional.<TypeElement>absent(),
           keyFactory.forProductionComponentMethod(componentMethod),
           ImmutableSet.<DependencyRequest>of(),
           Optional.<String>absent(),
@@ -195,7 +198,8 @@ ProductionBinding delegate(
         DelegateDeclaration delegateDeclaration, ProductionBinding delegateBinding) {
       return new AutoValue_ProductionBinding(
           delegateBinding.contributionType(),
-          delegateDeclaration.sourceElement(),
+          delegateDeclaration.bindingElement(),
+          delegateDeclaration.contributingModule(),
           delegateDeclaration.key(),
           ImmutableSet.of(delegateDeclaration.delegateRequest()),
           findBindingPackage(delegateDeclaration.key()),
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 80b6d8230..13e8ba9ab 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -106,9 +106,8 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
       Key key = keyFactory.forInjectConstructorWithResolvedType(enclosingCxtorType);
       checkArgument(!key.qualifier().isPresent());
       ImmutableSet<DependencyRequest> dependencies =
-          dependencyRequestFactory.forRequiredResolvedVariables(enclosingCxtorType,
-              constructorElement.getParameters(),
-              cxtorType.getParameterTypes());
+          dependencyRequestFactory.forRequiredResolvedVariables(
+              constructorElement.getParameters(), cxtorType.getParameterTypes());
       Optional<DependencyRequest> membersInjectionRequest =
           membersInjectionRequest(enclosingCxtorType);
       Optional<Scope> scope = Scope.uniqueScopeOf(constructorElement.getEnclosingElement());
@@ -118,7 +117,8 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
 
       return new AutoValue_ProvisionBinding(
           ContributionType.UNIQUE,
-          SourceElement.forElement(constructorElement),
+          constructorElement,
+          Optional.<TypeElement>absent(),
           key,
           dependencies,
           findBindingPackage(key),
@@ -152,19 +152,19 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
     ProvisionBinding forProvidesMethod(
         ExecutableElement providesMethod, TypeElement contributedBy) {
       checkArgument(providesMethod.getKind().equals(METHOD));
-      SourceElement sourceElement = SourceElement.forElement(providesMethod, contributedBy);
       ExecutableType resolvedMethod =
-          MoreTypes.asExecutable(sourceElement.asMemberOfContributingType(types));
-      Key key = keyFactory.forProvidesMethod(sourceElement);
+          MoreTypes.asExecutable(
+              types.asMemberOf(MoreTypes.asDeclared(contributedBy.asType()), providesMethod));
+      Key key = keyFactory.forProvidesMethod(providesMethod, contributedBy);
       ImmutableSet<DependencyRequest> dependencies =
           dependencyRequestFactory.forRequiredResolvedVariables(
-              MoreTypes.asDeclared(contributedBy.asType()),
               providesMethod.getParameters(),
               resolvedMethod.getParameterTypes());
       Optional<Scope> scope = Scope.uniqueScopeOf(providesMethod);
       return new AutoValue_ProvisionBinding(
           ContributionType.fromBindingMethod(providesMethod),
-          sourceElement,
+          providesMethod,
+          Optional.of(contributedBy),
           key,
           dependencies,
           findBindingPackage(key),
@@ -191,7 +191,8 @@ ProvisionBinding syntheticMapOfValuesBinding(DependencyRequest requestForMapOfVa
               requestForMapOfValues, mapOfProvidersKey.get());
       return new AutoValue_ProvisionBinding(
           ContributionType.UNIQUE,
-          SourceElement.forElement(requestForMapOfProviders.requestElement()),
+          requestForMapOfProviders.requestElement(),
+          Optional.<TypeElement>absent(),
           requestForMapOfValues.key(),
           ImmutableSet.of(requestForMapOfProviders),
           findBindingPackage(requestForMapOfValues.key()),
@@ -212,7 +213,8 @@ ProvisionBinding syntheticMultibinding(
         final DependencyRequest request, Iterable<ContributionBinding> multibindingContributions) {
       return new AutoValue_ProvisionBinding(
           ContributionType.UNIQUE,
-          SourceElement.forElement(request.requestElement()),
+          request.requestElement(),
+          Optional.<TypeElement>absent(),
           request.key(),
           dependencyRequestFactory.forMultibindingContributions(request, multibindingContributions),
           findBindingPackage(request.key()),
@@ -227,7 +229,8 @@ ProvisionBinding forComponent(TypeElement componentDefinitionType) {
       checkNotNull(componentDefinitionType);
       return new AutoValue_ProvisionBinding(
           ContributionType.UNIQUE,
-          SourceElement.forElement(componentDefinitionType),
+          componentDefinitionType,
+          Optional.<TypeElement>absent(),
           keyFactory.forComponent(componentDefinitionType.asType()),
           ImmutableSet.<DependencyRequest>of(),
           Optional.<String>absent(),
@@ -245,7 +248,8 @@ ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
       Optional<Scope> scope = Scope.uniqueScopeOf(componentMethod);
       return new AutoValue_ProvisionBinding(
           ContributionType.UNIQUE,
-          SourceElement.forElement(componentMethod),
+          componentMethod,
+          Optional.<TypeElement>absent(),
           keyFactory.forComponentMethod(componentMethod),
           ImmutableSet.<DependencyRequest>of(),
           Optional.<String>absent(),
@@ -264,7 +268,8 @@ ProvisionBinding forSubcomponentBuilderMethod(
       DeclaredType declaredContainer = asDeclared(contributedBy.asType());
       return new AutoValue_ProvisionBinding(
           ContributionType.UNIQUE,
-          SourceElement.forElement(subcomponentBuilderMethod, contributedBy),
+          subcomponentBuilderMethod,
+          Optional.<TypeElement>absent(),
           keyFactory.forSubcomponentBuilderMethod(subcomponentBuilderMethod, declaredContainer),
           ImmutableSet.<DependencyRequest>of(),
           Optional.<String>absent(),
@@ -279,7 +284,8 @@ ProvisionBinding delegate(
         DelegateDeclaration delegateDeclaration, ProvisionBinding delegate) {
       return new AutoValue_ProvisionBinding(
           delegate.contributionType(),
-          delegateDeclaration.sourceElement(),
+          delegateDeclaration.bindingElement(),
+          delegateDeclaration.contributingModule(),
           delegateDeclaration.key(),
           ImmutableSet.of(delegateDeclaration.delegateRequest()),
           findBindingPackage(delegateDeclaration.key()),
@@ -287,7 +293,7 @@ ProvisionBinding delegate(
           Optional.<DependencyRequest>absent(),
           Kind.SYNTHETIC_DELEGATE_BINDING,
           Optional.<ProvisionBinding>absent(),
-          Scope.uniqueScopeOf(delegateDeclaration.sourceElement().element()));
+          Scope.uniqueScopeOf(delegateDeclaration.bindingElement()));
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
index 00ded026b..40f1e5e93 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
@@ -16,8 +16,10 @@
 package dagger.internal.codegen;
 
 import com.google.auto.value.AutoValue;
+import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
@@ -27,7 +29,8 @@
 import dagger.internal.codegen.BindingType.HasBindingType;
 import dagger.internal.codegen.ContributionType.HasContributionType;
 import dagger.internal.codegen.Key.HasKey;
-import dagger.internal.codegen.SourceElement.HasSourceElement;
+import java.util.Map;
+import java.util.Set;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkState;
@@ -97,14 +100,15 @@ public Key key() {
         throw new AssertionError(bindingKey());
     }
   }
-  
+
   /**
-   * All bindings for {@link #bindingKey()}, indexed by the component in which they were resolved.
+   * All bindings for {@link #bindingKey()}, together with the component in which they were
+   * resolved.
    */
-  ImmutableSetMultimap<ComponentDescriptor, Binding> bindingsByComponent() {
-    return new ImmutableSetMultimap.Builder<ComponentDescriptor, Binding>()
-        .putAll(allContributionBindings())
-        .putAll(allMembersInjectionBindings().entrySet())
+  ImmutableList<Map.Entry<ComponentDescriptor, ? extends Binding>> bindingsByComponent() {
+    return new ImmutableList.Builder<Map.Entry<ComponentDescriptor, ? extends Binding>>()
+        .addAll(allContributionBindings().entries())
+        .addAll(allMembersInjectionBindings().entrySet())
         .build();
   }
 
@@ -296,9 +300,9 @@ public ContributionType contributionType() {
    * The {@link #contributionBindings()} and {@link #multibindingDeclarations()}, indexed by
    * {@link ContributionType}.
    */
-  ImmutableListMultimap<ContributionType, HasSourceElement>
+  ImmutableListMultimap<ContributionType, BindingDeclaration>
       bindingsAndDeclarationsByContributionType() {
-    return new ImmutableListMultimap.Builder<ContributionType, HasSourceElement>()
+    return new ImmutableListMultimap.Builder<ContributionType, BindingDeclaration>()
         .putAll(indexByContributionType(contributionBindings()))
         .putAll(indexByContributionType(multibindingDeclarations()))
         .build();
@@ -332,4 +336,12 @@ public ContributionType contributionType() {
   Class<?> frameworkClass() {
     return bindingType().frameworkClass();
   }
+
+  static final Function<ResolvedBindings, Set<ContributionBinding>> CONTRIBUTION_BINDINGS =
+      new Function<ResolvedBindings, Set<ContributionBinding>>() {
+        @Override
+        public Set<ContributionBinding> apply(ResolvedBindings resolvedBindings) {
+          return resolvedBindings.contributionBindings();
+        }
+      };
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceElement.java b/compiler/src/main/java/dagger/internal/codegen/SourceElement.java
deleted file mode 100644
index b8bcf5263..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/SourceElement.java
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * Copyright (C) 2015 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.auto.common.MoreTypes;
-import com.google.auto.value.AutoValue;
-import com.google.common.base.Optional;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementVisitor;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.SimpleElementVisitor6;
-import javax.lang.model.util.Types;
-
-/**
- * An {@link Element}, optionally contributed by a subtype of the type that encloses it.
- */
-@AutoValue
-abstract class SourceElement {
-
-  /** An object that has a {@link SourceElement}. */
-  interface HasSourceElement {
-    /** The source element associated with this object. */
-    SourceElement sourceElement();
-  }
-
-  /** The {@link Element} instance.. */
-  abstract Element element();
-
-  /**
-   * The concrete class that contributed the {@link #element()}, if different from
-   * {@link #enclosingTypeElement()}.
-   */
-  abstract Optional<TypeElement> contributedBy();
-
-  /** The type enclosing the {@link #element()}. */
-  TypeElement enclosingTypeElement() {
-    return BINDING_TYPE_ELEMENT.visit(element());
-  }
-
-  /**
-   * The type of {@link #element()}, considered as a member of {@link #contributedBy()} if it is
-   * present.
-   */
-  TypeMirror asMemberOfContributingType(Types types) {
-    return contributedBy().isPresent()
-        ? types.asMemberOf(MoreTypes.asDeclared(contributedBy().get().asType()), element())
-        : element().asType();
-  }
-
-  private static final ElementVisitor<TypeElement, Void> BINDING_TYPE_ELEMENT =
-      new SimpleElementVisitor6<TypeElement, Void>() {
-        @Override
-        protected TypeElement defaultAction(Element e, Void p) {
-          return visit(e.getEnclosingElement());
-        }
-
-        @Override
-        public TypeElement visitType(TypeElement e, Void p) {
-          return e;
-        }
-      };
-
-  static SourceElement forElement(Element element) {
-    return new AutoValue_SourceElement(element, Optional.<TypeElement>absent());
-  }
-
-  static SourceElement forElement(Element element, TypeElement contributedBy) {
-    return new AutoValue_SourceElement(element, Optional.of(contributedBy));
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index e7885d99b..c31376055 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -29,7 +29,6 @@
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeVariableName;
 import java.util.Iterator;
-import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.TypeParameterElement;
 import javax.lang.model.type.TypeMirror;
@@ -88,9 +87,9 @@ public int compare(DependencyRequest left, DependencyRequest right) {
     for (FrameworkDependency frameworkDependency : frameworkDependenciesForBinding(binding)) {
       bindingFields.put(
           frameworkDependency.bindingKey(),
-          FrameworkField.createWithTypeFromKey(
-              frameworkDependency.frameworkClass(),
-              frameworkDependency.bindingKey().key(),
+          FrameworkField.create(
+              ClassName.get(frameworkDependency.frameworkClass()),
+              TypeName.get(frameworkDependency.bindingKey().key().type()),
               fieldNameForDependency(frameworkDependency)));
     }
     return bindingFields.build();
@@ -168,7 +167,8 @@ static ClassName generatedClassNameForBinding(Binding binding) {
         }
 
       case MEMBERS_INJECTION:
-        return membersInjectorNameForType(binding.bindingTypeElement());
+        return membersInjectorNameForType(
+            ((MembersInjectionBinding) binding).membersInjectedType());
 
       default:
         throw new AssertionError();
@@ -267,7 +267,7 @@ private static String factoryPrefix(ContributionBinding binding) {
       case IMMEDIATE:
       case FUTURE_PRODUCTION:
         return CaseFormat.LOWER_CAMEL.to(
-            UPPER_CAMEL, ((ExecutableElement) binding.bindingElement()).getSimpleName().toString());
+            UPPER_CAMEL, binding.bindingElement().getSimpleName().toString());
 
       default:
         throw new IllegalArgumentException();
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index e7d9685e1..606a088c3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -18,6 +18,7 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
+import com.google.common.base.Function;
 import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
@@ -27,9 +28,12 @@
 import java.lang.annotation.Annotation;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementVisitor;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
 import javax.lang.model.util.Elements;
+import javax.lang.model.util.SimpleElementVisitor6;
 
 import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
 import static com.google.auto.common.MoreElements.hasModifiers;
@@ -53,7 +57,7 @@ static boolean requiresAPassedInstance(Elements elements, TypeElement typeElemen
     boolean foundInstanceMethod = false;
     for (ExecutableElement method : methods) {
       if (method.getModifiers().contains(ABSTRACT) && !isAnnotationPresent(method, Binds.class)) {
-        /* We found an abstract method that isn't a @Bind method.  That automatically means that
+        /* We found an abstract method that isn't a @Binds method.  That automatically means that
          * a user will have to provide an instance because we don't know which subclass to use. */
         return true;
       } else if (!method.getModifiers().contains(STATIC)
@@ -140,5 +144,31 @@ public boolean apply(AnnotationMirror input) {
     };
   }
 
+  /** A function that returns the input as a {@link DeclaredType}. */
+  static final Function<TypeElement, DeclaredType> AS_DECLARED_TYPE =
+      new Function<TypeElement, DeclaredType>() {
+        @Override
+        public DeclaredType apply(TypeElement typeElement) {
+          return MoreTypes.asDeclared(typeElement.asType());
+        }
+      };
+
+  /**
+   * A visitor that returns the input or the closest enclosing element that is a
+   * {@link TypeElement}.
+   */
+  static final ElementVisitor<TypeElement, Void> ENCLOSING_TYPE_ELEMENT =
+      new SimpleElementVisitor6<TypeElement, Void>() {
+        @Override
+        protected TypeElement defaultAction(Element e, Void p) {
+          return visit(e.getEnclosingElement());
+        }
+
+        @Override
+        public TypeElement visitType(TypeElement e, Void p) {
+          return e;
+        }
+      };
+
   private Util() {}
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/BindingFieldTest.java b/compiler/src/test/java/dagger/internal/codegen/BindingFieldTest.java
deleted file mode 100644
index 607b5cbc0..000000000
--- a/compiler/src/test/java/dagger/internal/codegen/BindingFieldTest.java
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.common.collect.Iterables;
-import com.google.testing.compile.CompilationRule;
-import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.ParameterizedTypeName;
-import com.squareup.javapoet.TypeName;
-import dagger.MembersInjector;
-import javax.inject.Inject;
-import javax.inject.Provider;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.util.ElementFilter;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static com.google.common.truth.Truth.assertThat;
-
-/**
- * Test case for {@link FrameworkField}.
- */
-@RunWith(JUnit4.class)
-public class BindingFieldTest {
-  @Rule public CompilationRule compilationRule = new CompilationRule();
-
-  private Elements elements;
-  private Types types;
-  private Key.Factory keyFactory;
-
-  @Before public void setUp() {
-    this.types = compilationRule.getTypes();
-    this.elements = compilationRule.getElements();
-    this.keyFactory = new Key.Factory(types, elements);
-  }
-
-  private ExecutableElement getXConstructor() {
-    TypeElement classElement = elements.getTypeElement(X.class.getCanonicalName());
-    return Iterables.getOnlyElement(
-        ElementFilter.constructorsIn(classElement.getEnclosedElements()));
-  }
-
-  @Test public void frameworkType() {
-    Key key = keyFactory.forInjectConstructorWithResolvedType(
-        getXConstructor().getEnclosingElement().asType());
-    TypeName xClass = TypeName.get(key.type());
-    assertThat(FrameworkField.createWithTypeFromKey(Provider.class, key, "test").frameworkType())
-        .isEqualTo(ParameterizedTypeName.get(ClassName.get(Provider.class), xClass));
-    assertThat(
-            FrameworkField.createWithTypeFromKey(MembersInjector.class, key, "test")
-                .frameworkType())
-        .isEqualTo(ParameterizedTypeName.get(ClassName.get(MembersInjector.class), xClass));
-  }
-
-  @Test public void nameSuffix() {
-    Key key = keyFactory.forInjectConstructorWithResolvedType(
-        getXConstructor().getEnclosingElement().asType());
-    assertThat(FrameworkField.createWithTypeFromKey(Provider.class, key, "foo").name())
-        .isEqualTo("fooProvider");
-    assertThat(FrameworkField.createWithTypeFromKey(Provider.class, key, "fooProvider").name())
-        .isEqualTo("fooProvider");
-
-  }
-
-  static final class X {
-    @Inject X() {}
-  }
-}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
index 2a39030b4..3623d76d2 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
@@ -832,31 +832,44 @@ public void testMultipleSettersPerTypeIncludingResolvedGenericsFails() {
 
   @Test
   public void testExtraSettersFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  interface Builder {",
-        "    SimpleComponent build();",
-        "    void set1(String s);",
-        "    void set2(Integer s);",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "import javax.inject.Provider;",
+            "",
+            "@Component(modules = AbstractModule.class)",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    SimpleComponent build();",
+            "    void abstractModule(AbstractModule abstractModule);",
+            "    void other(String s);",
+            "  }",
+            "}");
+    JavaFileObject abstractModule =
+        JavaFileObjects.forSourceLines(
+            "test.AbstractModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "abstract class AbstractModule {}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(componentFile, abstractModule))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
-            String.format(MSGS.extraSetters(),
-                  "[void test.SimpleComponent.Builder.set1(String),"
-                  + " void test.SimpleComponent.Builder.set2(Integer)]"))
-            .in(componentFile).onLine(10);
-
+            String.format(
+                MSGS.extraSetters(),
+                "[void test.SimpleComponent.Builder.abstractModule(test.AbstractModule), "
+                    + "void test.SimpleComponent.Builder.other(String)]"))
+        .in(componentFile)
+        .onLine(10);
   }
 
   @Test
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index a9ff10681..fc1779e68 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -514,6 +514,115 @@
         .and().generatesSources(generatedComponent);
   }
 
+  @Test
+  public void componentWithAbstractModule() {
+    JavaFileObject aFile =
+        JavaFileObjects.forSourceLines(
+            "test.A",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class A {",
+            "  @Inject A(B b) {}",
+            "}");
+    JavaFileObject bFile =
+        JavaFileObjects.forSourceLines("test.B",
+            "package test;",
+            "",
+            "interface B {}");
+    JavaFileObject cFile =
+        JavaFileObjects.forSourceLines(
+            "test.C",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class C {",
+            "  @Inject C() {}",
+            "}");
+
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @Provides static B b(C c) { return null; }",
+            "}");
+
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "import javax.inject.Provider;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  A a();",
+            "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private Provider<B> bProvider;",
+            "  private Provider<A> aProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.bProvider = TestModule_BFactory.create(C_Factory.create());",
+            "    this.aProvider = A_Factory.create(bProvider);",
+            "  }",
+            "",
+            "  @Override",
+            "  public A a() {",
+            "    return aProvider.get();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(aFile, bFile, cFile, moduleFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedComponent);
+  }
+
   @Test public void transitiveModuleDeps() {
     JavaFileObject always = JavaFileObjects.forSourceLines("test.AlwaysIncluded",
         "package test;",
diff --git a/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java b/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java
index 856bc0f2a..2bc5fc017 100644
--- a/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java
@@ -130,15 +130,22 @@ private DependencyRequest dependencyRequestForProduced() {
 
   @Module
   static final class ProvidesMethodModule {
-    @Provides String provideString(
-        Integer a, Lazy<Integer> b, Provider<Integer> c, MembersInjector<Y> d) {
+    @Provides
+    static String provideString(
+        @SuppressWarnings("unused") Integer a,
+        @SuppressWarnings("unused") Lazy<Integer> b,
+        @SuppressWarnings("unused") Provider<Integer> c,
+        @SuppressWarnings("unused") MembersInjector<Y> d) {
       throw new UnsupportedOperationException();
     }
   }
 
   @ProducerModule
   static final class ProducesMethodModule {
-    @Produces String produceString(Producer<Integer> a, Produced<Integer> b) {
+    @Produces
+    static String produceString(
+        @SuppressWarnings("unused") Producer<Integer> a,
+        @SuppressWarnings("unused") Produced<Integer> b) {
       return null;
     }
   }
diff --git a/compiler/src/test/java/dagger/internal/codegen/FrameworkFieldTest.java b/compiler/src/test/java/dagger/internal/codegen/FrameworkFieldTest.java
new file mode 100644
index 000000000..118b8484b
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/FrameworkFieldTest.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.testing.compile.CompilationRule;
+import com.squareup.javapoet.ClassName;
+import javax.inject.Inject;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+import static dagger.internal.codegen.TypeNames.MEMBERS_INJECTOR;
+import static dagger.internal.codegen.TypeNames.PROVIDER;
+import static dagger.internal.codegen.TypeNames.membersInjectorOf;
+import static dagger.internal.codegen.TypeNames.providerOf;
+
+/**
+ * Test case for {@link FrameworkField}.
+ */
+@RunWith(JUnit4.class)
+public class FrameworkFieldTest {
+  @Rule public CompilationRule compilationRule = new CompilationRule();
+
+  private ClassName xTypeName;
+
+  @Before public void setUp() {
+    xTypeName =
+        ClassName.get(compilationRule.getElements().getTypeElement(X.class.getCanonicalName()));
+  }
+
+  @Test public void frameworkType() {
+    assertThat(FrameworkField.create(PROVIDER, xTypeName, "test").type())
+        .isEqualTo(providerOf(xTypeName));
+    assertThat(FrameworkField.create(MEMBERS_INJECTOR, xTypeName, "test").type())
+        .isEqualTo(membersInjectorOf(xTypeName));
+  }
+
+  @Test public void nameSuffix() {
+    assertThat(FrameworkField.create(PROVIDER, xTypeName, "foo").name())
+        .isEqualTo("fooProvider");
+    assertThat(FrameworkField.create(PROVIDER, xTypeName, "fooProvider").name())
+        .isEqualTo("fooProvider");
+  }
+
+  static final class X {
+    @Inject X() {}
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
index 8635fc713..3592fbb17 100644
--- a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
@@ -23,8 +23,9 @@
 import com.google.testing.compile.CompilationRule;
 import dagger.Module;
 import dagger.Provides;
-import dagger.multibindings.IntoSet;
+import dagger.internal.codegen.Key.BindingMethodIdentifier;
 import dagger.multibindings.ElementsIntoSet;
+import dagger.multibindings.IntoSet;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
 import java.util.Set;
@@ -75,7 +76,7 @@
             new AutoValue_Key(
                 Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
                 MoreTypes.equivalence().wrap(typeElement.asType()),
-                Optional.<SourceElement>absent()));
+                Optional.<BindingMethodIdentifier>absent()));
   }
 
   static final class InjectedClass {
@@ -89,13 +90,12 @@
         elements.getTypeElement(ProvidesMethodModule.class.getCanonicalName());
     ExecutableElement providesMethod =
         Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
-    assertThat(
-            keyFactory.forProvidesMethod(SourceElement.forElement(providesMethod, moduleElement)))
+    assertThat(keyFactory.forProvidesMethod(providesMethod, moduleElement))
         .isEqualTo(
             new AutoValue_Key(
                 Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
                 MoreTypes.equivalence().wrap(stringType),
-                Optional.<SourceElement>absent()));
+                Optional.<BindingMethodIdentifier>absent()));
   }
 
   @Module
@@ -113,7 +113,7 @@
         elements.getTypeElement(QualifiedProvidesMethodModule.class.getCanonicalName());
     ExecutableElement providesMethod =
         Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
-    Key key = keyFactory.forProvidesMethod(SourceElement.forElement(providesMethod, moduleElement));
+    Key key = keyFactory.forProvidesMethod(providesMethod, moduleElement);
     assertThat(MoreTypes.equivalence().wrap(key.qualifier().get().getAnnotationType()))
         .isEqualTo(MoreTypes.equivalence().wrap(qualifierElement.asType()));
     assertThat(key.wrappedType()).isEqualTo(MoreTypes.equivalence().wrap(stringType));
@@ -124,8 +124,7 @@
         elements.getTypeElement(QualifiedProvidesMethodModule.class.getCanonicalName());
     ExecutableElement providesMethod =
         Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
-    Key provisionKey =
-        keyFactory.forProvidesMethod(SourceElement.forElement(providesMethod, moduleElement));
+    Key provisionKey = keyFactory.forProvidesMethod(providesMethod, moduleElement);
 
     TypeMirror type = elements.getTypeElement(String.class.getCanonicalName()).asType();
     TypeElement injectableElement =
@@ -166,13 +165,12 @@ String provideQualifiedString() {
         elements.getTypeElement(SetProvidesMethodsModule.class.getCanonicalName());
     for (ExecutableElement providesMethod
         : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {
-      SourceElement sourceElement = SourceElement.forElement(providesMethod, moduleElement);
-      assertThat(keyFactory.forProvidesMethod(sourceElement))
+      assertThat(keyFactory.forProvidesMethod(providesMethod, moduleElement))
           .isEqualTo(
               new AutoValue_Key(
                   Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
                   MoreTypes.equivalence().wrap(setOfStringsType),
-                  Optional.of(sourceElement)));
+                  Optional.of(BindingMethodIdentifier.create(providesMethod, moduleElement))));
     }
   }
 
@@ -216,10 +214,8 @@ String provideQualifiedString() {
     TypeMirror integerType = integerMethod.getReturnType();
     assertThat(integerType.getKind().isPrimitive()).isFalse();
     assertThat(types.isSameType(intType, integerType)).named("type equality").isFalse();
-
-    Key intKey = keyFactory.forProvidesMethod(SourceElement.forElement(intMethod, primitiveHolder));
-    Key integerKey =
-        keyFactory.forProvidesMethod(SourceElement.forElement(integerMethod, boxedPrimitiveHolder));
+    Key intKey = keyFactory.forProvidesMethod(intMethod, primitiveHolder);
+    Key integerKey = keyFactory.forProvidesMethod(integerMethod, boxedPrimitiveHolder);
     assertThat(intKey).isEqualTo(integerKey);
   }
 
@@ -229,13 +225,12 @@ String provideQualifiedString() {
         elements.getTypeElement(ProducesMethodsModule.class.getCanonicalName());
     for (ExecutableElement producesMethod
         : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {
-      assertThat(
-              keyFactory.forProducesMethod(SourceElement.forElement(producesMethod, moduleElement)))
+      assertThat(keyFactory.forProducesMethod(producesMethod, moduleElement))
           .isEqualTo(
               new AutoValue_Key(
                   Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
                   MoreTypes.equivalence().wrap(stringType),
-                  Optional.<SourceElement>absent()));
+                  Optional.<BindingMethodIdentifier>absent()));
     }
   }
 
@@ -258,13 +253,12 @@ String provideQualifiedString() {
         elements.getTypeElement(SetProducesMethodsModule.class.getCanonicalName());
     for (ExecutableElement producesMethod
         : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {
-      SourceElement sourceElement = SourceElement.forElement(producesMethod, moduleElement);
-      assertThat(keyFactory.forProducesMethod(sourceElement))
+      assertThat(keyFactory.forProducesMethod(producesMethod, moduleElement))
           .isEqualTo(
               new AutoValue_Key(
                   Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
                   MoreTypes.equivalence().wrap(setOfStringsType),
-                  Optional.of(sourceElement)));
+                  Optional.of(BindingMethodIdentifier.create(producesMethod, moduleElement))));
     }
   }
 
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
index 388a26ad0..a26866ae8 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
@@ -24,6 +24,7 @@
 import org.junit.runners.JUnit4;
 
 import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourcesSubject.assertThat;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
@@ -477,4 +478,45 @@ public void mapKeyComponentFileWithDefaultField() {
         .and()
         .generatesSources(generatedComponent);
   }
+
+  @Test
+  public void mapKeyWithDefaultValue() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.MapModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "",
+            "@Module",
+            "final class MapModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @BoolKey int provideFalseValue() {",
+            "    return -1;",
+            "  }",
+            "",
+            "  @Provides",
+            "  @IntoMap",
+            "  @BoolKey(true) int provideTrueValue() {",
+            "    return 1;",
+            "  }",
+            "}");
+    JavaFileObject mapKey =
+        JavaFileObjects.forSourceLines(
+            "test.BoolKey",
+            "package test;",
+            "",
+            "import dagger.MapKey;",
+            "",
+            "@MapKey",
+            "@interface BoolKey {",
+            "  boolean value() default false;",
+            "}");
+    assertThat(module, mapKey)
+        .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
+        .compilesWithoutError();
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/MethodSignatureFormatterTest.java b/compiler/src/test/java/dagger/internal/codegen/MethodSignatureFormatterTest.java
index 45791c75c..62d688561 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MethodSignatureFormatterTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MethodSignatureFormatterTest.java
@@ -43,7 +43,11 @@
     static class InnerClass {
       @Foo(bar = String.class)
       @Singleton
-      String foo(@SuppressWarnings("unused") int a, ImmutableList<Boolean> blah) { return "foo"; }
+      String foo(
+          @SuppressWarnings("unused") int a,
+          @SuppressWarnings("unused") ImmutableList<Boolean> blah) {
+        return "foo";
+      }
     }
   }
 
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index acc6bb6e4..d32aac54f 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -1314,7 +1314,7 @@ public void genericSubclassedModule() {
         .withErrorContaining("Produced may only be injected in @Produces methods");
   }
 
-  private static final String BIND_METHOD = "@Binds abstract Foo bindFoo(FooImpl impl);";
+  private static final String BINDS_METHOD = "@Binds abstract Foo bindFoo(FooImpl impl);";
   private static final String STATIC_PROVIDES_METHOD =
       "@Provides static Bar provideBar() { return new Bar(); }";
   private static final String INSTANCE_PROVIDES_METHOD =
@@ -1323,10 +1323,10 @@ public void genericSubclassedModule() {
 
   @Test
   public void moduleMethodPermutations() {
-    assertThatMethodCombination(BIND_METHOD, INSTANCE_PROVIDES_METHOD)
+    assertThatMethodCombination(BINDS_METHOD, INSTANCE_PROVIDES_METHOD)
         .failsToCompile()
         .withErrorContaining("not both at the same time");
-    assertThatMethodCombination(BIND_METHOD, STATIC_PROVIDES_METHOD).compilesWithoutError();
+    assertThatMethodCombination(BINDS_METHOD, STATIC_PROVIDES_METHOD).compilesWithoutError();
     assertThatMethodCombination(INSTANCE_PROVIDES_METHOD, SOME_ABSTRACT_METHOD)
         .compilesWithoutError();
   }
diff --git a/core/src/main/java/dagger/internal/DoubleCheck.java b/core/src/main/java/dagger/internal/DoubleCheck.java
index 513722929..73d4ee6a3 100644
--- a/core/src/main/java/dagger/internal/DoubleCheck.java
+++ b/core/src/main/java/dagger/internal/DoubleCheck.java
@@ -57,7 +57,7 @@ public T get() {
   public static <T> Provider<T> provider(Provider<T> delegate) {
     checkNotNull(delegate);
     if (delegate instanceof DoubleCheck) {
-      /* This should be a rare case, but if we have a scoped @Bind that delegates to a scoped
+      /* This should be a rare case, but if we have a scoped @Binds that delegates to a scoped
        * binding, we shouldn't cache the value again. */
       return delegate;
     }
diff --git a/core/src/main/java/dagger/internal/SetFactory.java b/core/src/main/java/dagger/internal/SetFactory.java
index 90dbb23eb..b17156cfe 100644
--- a/core/src/main/java/dagger/internal/SetFactory.java
+++ b/core/src/main/java/dagger/internal/SetFactory.java
@@ -51,7 +51,7 @@
 
   @SuppressWarnings({"unchecked", "rawtypes"}) // safe covariant cast
   public static <T> Factory<Set<T>> create() {
-    return (Factory<Set<T>>) (Factory) EMPTY_FACTORY;
+    return (Factory) EMPTY_FACTORY;
   }
 
   /**
diff --git a/core/src/main/java/dagger/multibindings/ElementsIntoSet.java b/core/src/main/java/dagger/multibindings/ElementsIntoSet.java
index 8ff7dd97c..5d3e7dc8c 100644
--- a/core/src/main/java/dagger/multibindings/ElementsIntoSet.java
+++ b/core/src/main/java/dagger/multibindings/ElementsIntoSet.java
@@ -22,13 +22,6 @@
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-/**
- * The method's return type is {@code Set<T>} and all values are contributed to the set. The {@code
- * Set<T>} produced from the accumulation of values will be immutable. An example use is to provide
- * a default empty set binding, which is otherwise not possible using {@link IntoSet}.
- *
- * @see <a href=google.github.io/dagger/multibindings#set-multibindings>Set multibinding</a>
- */
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
diff --git a/producers/src/main/java/dagger/producers/internal/MapOfProducedProducer.java b/producers/src/main/java/dagger/producers/internal/MapOfProducedProducer.java
index 7217e8c11..a0ba0c51a 100644
--- a/producers/src/main/java/dagger/producers/internal/MapOfProducedProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/MapOfProducedProducer.java
@@ -108,7 +108,6 @@ private MapOfProducedProducer(Producer<Map<K, Producer<V>>> mapProducerProducer)
   private static <K, V>
       Function<Map.Entry<K, Producer<V>>, ListenableFuture<Map.Entry<K, Produced<V>>>>
           entryUnwrapper() {
-    return (Function<Map.Entry<K, Producer<V>>, ListenableFuture<Map.Entry<K, Produced<V>>>>)
-        (Function) ENTRY_UNWRAPPER;
+    return (Function) ENTRY_UNWRAPPER;
   }
 }
diff --git a/producers/src/main/java/dagger/producers/internal/MapOfProducerProducer.java b/producers/src/main/java/dagger/producers/internal/MapOfProducerProducer.java
index 18338d055..013266f2d 100644
--- a/producers/src/main/java/dagger/producers/internal/MapOfProducerProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/MapOfProducerProducer.java
@@ -24,6 +24,7 @@
 import java.util.Map;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.collect.Maps.newLinkedHashMapWithExpectedSize;
 
 /**
  * A {@link Producer} implementation used to implement {@link Map} bindings. This factory returns an
@@ -62,17 +63,15 @@ private MapOfProducerProducer(ImmutableMap<K, Producer<V>> contributingMap) {
    * A builder to help build the {@link MapOfProducerProducer}
    */
   public static final class Builder<K, V> {
-    private final ImmutableMap.Builder<K, Producer<V>> mapBuilder;
+    private final Map<K, Producer<V>> mapBuilder;
 
     private Builder(int size) {
-      // TODO(beder): It would be nice to use the size, but ImmutableMap doesn't allow a pre-sized
-      // map, and Dagger's internal Collections implementation is package-private.
-      this.mapBuilder = ImmutableMap.builder();
+      this.mapBuilder = newLinkedHashMapWithExpectedSize(size);
     }
 
     /** Returns a new {@link MapOfProducerProducer}. */
     public MapOfProducerProducer<K, V> build() {
-      return new MapOfProducerProducer<K, V>(mapBuilder.build());
+      return new MapOfProducerProducer<K, V>(ImmutableMap.copyOf(mapBuilder));
     }
 
     /** Associates k with producerOfValue in {@code Builder}. */
diff --git a/producers/src/main/java/dagger/producers/internal/MapProducer.java b/producers/src/main/java/dagger/producers/internal/MapProducer.java
index 61d6a28ac..61b7cfdbd 100644
--- a/producers/src/main/java/dagger/producers/internal/MapProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/MapProducer.java
@@ -100,7 +100,6 @@ private MapProducer(Producer<Map<K, Producer<V>>> mapProducerProducer) {
   @SuppressWarnings({"unchecked", "rawtypes"}) // bivariate implementation
   private static <K, V>
       Function<Map.Entry<K, Producer<V>>, ListenableFuture<Map.Entry<K, V>>> entryUnwrapper() {
-    return (Function<Map.Entry<K, Producer<V>>, ListenableFuture<Map.Entry<K, V>>>)
-        (Function) ENTRY_UNWRAPPER;
+    return (Function) ENTRY_UNWRAPPER;
   }
 }
diff --git a/producers/src/main/java/dagger/producers/internal/SetProducer.java b/producers/src/main/java/dagger/producers/internal/SetProducer.java
index 271d31b4d..090010d65 100644
--- a/producers/src/main/java/dagger/producers/internal/SetProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/SetProducer.java
@@ -44,7 +44,7 @@
 
   @SuppressWarnings({"unchecked", "rawtypes"}) // safe covariant cast
   public static <T> Producer<Set<T>> create() {
-    return (Producer<Set<T>>) (Producer) EMPTY_PRODUCER;
+    return (Producer) EMPTY_PRODUCER;
   }
 
   /**
diff --git a/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java b/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java
index 402b566e9..2d2bc8734 100644
--- a/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java
+++ b/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java
@@ -81,6 +81,8 @@
    *
    * <p>When multiple monitors are installed, the order that each monitor will call this method is
    * unspecified, but will remain consistent throughout the course of the execution of a component.
+   *
+   * <p>This implementation is a no-op.
    */
   public void requested() {}
 
@@ -89,6 +91,8 @@ public void requested() {}
    *
    * <p>When multiple monitors are installed, calls to this method will be in the reverse order from
    * calls to {@link #requested()}.
+   *
+   * <p>This implementation is a no-op.
    */
   public void methodStarting() {}
 
@@ -98,6 +102,8 @@ public void methodStarting() {}
    *
    * <p>When multiple monitors are installed, calls to this method will be in the reverse order from
    * calls to {@link #requested()}.
+   *
+   * <p>This implementation is a no-op.
    */
   public void methodFinished() {}
 
@@ -106,16 +112,20 @@ public void methodFinished() {}
    *
    * <p>When multiple monitors are installed, calls to this method will be in the reverse order from
    * calls to {@link #requested()}.
+   *
+   * <p>This implementation is a no-op.
    */
-  public void succeeded(Object o) {}
+  public void succeeded(@SuppressWarnings("unused") Object value) {}
 
   /**
    * Called when the producer's future has failed with an exception.
    *
    * <p>When multiple monitors are installed, calls to this method will be in the reverse order from
    * calls to {@link #requested()}.
+   *
+   * <p>This implementation is a no-op.
    */
-  public void failed(Throwable t) {}
+  public void failed(@SuppressWarnings("unused") Throwable t) {}
 
   /**
    * Adds this monitor's completion methods as a callback to the future. This is only intended to be
diff --git a/producers/src/main/java/dagger/producers/monitoring/ProductionComponentMonitor.java b/producers/src/main/java/dagger/producers/monitoring/ProductionComponentMonitor.java
index af3164bac..8adebdc1d 100644
--- a/producers/src/main/java/dagger/producers/monitoring/ProductionComponentMonitor.java
+++ b/producers/src/main/java/dagger/producers/monitoring/ProductionComponentMonitor.java
@@ -66,7 +66,7 @@ public static ProductionComponentMonitor noOp() {
     /** Creates a component-specific monitor when the component is created. */
     public abstract ProductionComponentMonitor create(Object component);
 
-    private static final Factory NO_OP =
+    private static final Factory NO_OP_FACTORY =
         new Factory() {
           @Override
           public ProductionComponentMonitor create(Object component) {
@@ -76,7 +76,7 @@ public ProductionComponentMonitor create(Object component) {
 
     /** Returns a factory that returns no-op monitors. */
     public static Factory noOp() {
-      return NO_OP;
+      return NO_OP_FACTORY;
     }
   }
 }
diff --git a/producers/src/main/java/dagger/producers/monitoring/internal/Monitors.java b/producers/src/main/java/dagger/producers/monitoring/internal/Monitors.java
index ce48907e8..b4e28b6af 100644
--- a/producers/src/main/java/dagger/producers/monitoring/internal/Monitors.java
+++ b/producers/src/main/java/dagger/producers/monitoring/internal/Monitors.java
@@ -314,7 +314,7 @@ public void failed(Throwable t) {
 
   private static final Provider<ProductionComponentMonitor>
       NO_OP_PRODUCTION_COMPONENT_MONITOR_PROVIDER =
-          new Provider() {
+          new Provider<ProductionComponentMonitor>() {
             @Override
             public ProductionComponentMonitor get() {
               return ProductionComponentMonitor.noOp();
diff --git a/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java b/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java
index 5eb1ea790..8bb8b7574 100644
--- a/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java
+++ b/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java
@@ -24,17 +24,17 @@
 import dagger.producers.monitoring.ProductionComponentMonitor;
 import java.util.concurrent.ExecutionException;
 import javax.inject.Provider;
-import org.mockito.Mock;
-import org.mockito.Mockito;
-import org.mockito.MockitoAnnotations;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+import org.mockito.Mockito;
+import org.mockito.MockitoAnnotations;
 
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
-import static org.mockito.Mockito.any;
+import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 import static org.mockito.Mockito.when;
@@ -96,7 +96,7 @@ public void monitor_success() throws Exception {
     ListenableFuture<Integer> future = producer.get();
     assertThat(future.isDone()).isFalse();
     verify(monitor).requested();
-    verify(monitor).addCallbackTo(any(ListenableFuture.class));
+    verify(monitor).addCallbackTo(anyListenableFuture());
     delegateFuture.set(-42);
     assertThat(future.get()).isEqualTo(-42);
     verify(monitor).succeeded(-42);
@@ -111,7 +111,7 @@ public void monitor_failure() throws Exception {
     ListenableFuture<Integer> future = producer.get();
     assertThat(future.isDone()).isFalse();
     verify(monitor).requested();
-    verify(monitor).addCallbackTo(any(ListenableFuture.class));
+    verify(monitor).addCallbackTo(anyListenableFuture());
     Throwable t = new RuntimeException("monkey");
     delegateFuture.setException(t);
     try {
@@ -124,6 +124,10 @@ public void monitor_failure() throws Exception {
     verifyNoMoreInteractions(monitor);
   }
 
+  private ListenableFuture<?> anyListenableFuture() {
+    return any(ListenableFuture.class);
+  }
+
   @Test(expected = NullPointerException.class)
   public void monitor_null() throws Exception {
     new DelegateProducer<>(null, Futures.immediateFuture(42));
diff --git a/producers/src/test/java/dagger/producers/internal/ProducersTest.java b/producers/src/test/java/dagger/producers/internal/ProducersTest.java
index c654b64c6..d0d4bf326 100644
--- a/producers/src/test/java/dagger/producers/internal/ProducersTest.java
+++ b/producers/src/test/java/dagger/producers/internal/ProducersTest.java
@@ -70,8 +70,8 @@
 
   private <T> ExecutionException getProducedException(Produced<T> produced) {
     try {
-      T unused = produced.get();
-      throw new IllegalArgumentException("produced did not throw");
+      T value = produced.get();
+      throw new IllegalArgumentException("produced did not throw, but returned " + value);
     } catch (ExecutionException e) {
       return e;
     }
