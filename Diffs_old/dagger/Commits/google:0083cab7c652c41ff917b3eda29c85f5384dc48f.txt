diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 62b044137..1757f1733 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -620,7 +620,7 @@ public Boolean visitPrimitive(PrimitiveType t, Void p) {
                               MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE,
                               arg.toString(),
                               type.toString(),
-                              dependencyRequestFormatter.toForwardDependencyTrace(path)),
+                              dependencyRequestFormatter.toDependencyTrace(path)),
                           path.entryPointElement());
                       return null;
                     }
@@ -1117,7 +1117,7 @@ private void reportCycle(DependencyPath path) {
               CONTAINS_DEPENDENCY_CYCLE_FORMAT,
               componentType.getQualifiedName(),
               path.entryPointElement().getSimpleName(),
-              dependencyRequestFormatter.toForwardDependencyTraceSkippingEntryPoint(path)),
+              dependencyRequestFormatter.toDependencyTrace(path)),
           ERROR,
           path.entryPointElement());
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
index 9a96c14cf..cd783be2a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
@@ -19,7 +19,6 @@
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
 import com.google.common.base.Predicates;
-import com.google.common.collect.FluentIterable;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import dagger.Provides;
 import dagger.internal.codegen.BindingGraphValidator.DependencyPath;
@@ -44,20 +43,20 @@
  * 
  * <dl>
  * <dt>For component provision methods
- * <dd>{@code ComponentType.method() injects @Qualifier SomeType}
+ * <dd>{@code @Qualifier SomeType is provided at\n    ComponentType.method()}
  * 
  * <dt>For component injection methods
- * <dd>{@code ComponentType.method(foo) injects SomeType}
+ * <dd>{@code SomeType is injected at\n    ComponentType.method(foo)}
  * 
  * <dt>For parameters to {@link Provides @Provides}, {@link Produces @Produces}, or
  * {@link Inject @Inject} methods:
- * <dd>{@code EnclosingType.method([…, ]param[, …]) injects @Qualified ResolvedType}
+ * <dd>{@code @Qualified ResolvedType is injected at\n    EnclosingType.method([…, ]param[, …])}
  * 
  * <dt>For parameters to {@link Inject @Inject} constructors:
- * <dd>{@code EnclosingType.<init>([…, ]param[, …]) injects @Qualified ResolvedType}
+ * <dd>{@code @Qualified ResolvedType is injected at\n    EnclosingType.<init>([…, ]param[, …])}
  * 
  * <dt>For {@link Inject @Inject} fields:
- * <dd>{@code EnclosingType.field injects @Qualified ResolvedType}
+ * <dd>{@code @Qualified ResolvedType is injected at\n    EnclosingType.field}
  * </dl>
  */
 final class DependencyRequestFormatter extends Formatter<DependencyRequest> {
@@ -76,31 +75,14 @@
    * entry point.
    */
   String toDependencyTrace(DependencyPath dependencyPath) {
-    return Joiner.on('\n').join(formattedRequests(dependencyPath).toList().reverse());
-  }
-
-  /**
-   * A string representation of the dependency trace, starting with the entry point and ending with
-   * the {@linkplain DependencyPath#currentDependencyRequest() current request}.
-   */
-  String toForwardDependencyTrace(DependencyPath dependencyPath) {
-    return Joiner.on('\n').join(formattedRequests(dependencyPath));
-  }
-
-  /**
-   * A string representation of the dependency trace, starting with the request after the entry
-   * point and ending with the {@linkplain DependencyPath#currentDependencyRequest() current
-   * request}.
-   */
-  String toForwardDependencyTraceSkippingEntryPoint(DependencyPath dependencyPath) {
-    return Joiner.on('\n').join(formattedRequests(dependencyPath).skip(1));
-  }
-
-  private FluentIterable<String> formattedRequests(DependencyPath dependencyPath) {
-    return dependencyPath
-        .nonsyntheticRequests()
-        .transform(this)
-        .filter(Predicates.not(Predicates.equalTo("")));
+    return Joiner.on('\n')
+        .join(
+            dependencyPath
+                .nonsyntheticRequests()
+                .transform(this)
+                .filter(Predicates.not(Predicates.equalTo("")))
+                .toList()
+                .reverse());
   }
 
   // TODO(cgruber): Sweep this class for TypeMirror.toString() usage and do some preventive format.
@@ -117,17 +99,17 @@ public String format(DependencyRequest request) {
               public String visitExecutableAsMethod(
                   ExecutableElement method, DependencyRequest request) {
                 StringBuilder builder = new StringBuilder(INDENT);
+                appendRequestedKeyAndVerb(
+                    builder,
+                    request.key().qualifier(),
+                    request.key().type(),
+                    componentMethodRequestVerb(request));
                 appendEnclosingTypeAndMemberName(method, builder);
                 builder.append('(');
                 for (VariableElement parameter : method.getParameters()) {
                   builder.append(parameter.getSimpleName());
                 }
                 builder.append(')');
-                appendRequest(
-                    builder,
-                    componentMethodRequestVerb(request),
-                    request.key().qualifier(),
-                    request.key().type());
                 return builder.toString();
               }
 
@@ -140,9 +122,10 @@ public String visitExecutableAsMethod(
               public String visitVariableAsParameter(
                   final VariableElement variable, DependencyRequest request) {
                 StringBuilder builder = new StringBuilder(INDENT);
+                appendRequestedKeyAndVerb(request, builder);
+
                 ExecutableElement methodOrConstructor =
                     asExecutable(variable.getEnclosingElement());
-
                 appendEnclosingTypeAndMemberName(methodOrConstructor, builder).append('(');
                 int parameterIndex = methodOrConstructor.getParameters().indexOf(variable);
                 if (parameterIndex > 0) {
@@ -153,7 +136,6 @@ public String visitVariableAsParameter(
                   builder.append(", …");
                 }
                 builder.append(')');
-                appendRequest(builder, request);
                 return builder.toString();
               }
 
@@ -162,8 +144,8 @@ public String visitVariableAsParameter(
               public String visitVariableAsField(
                   VariableElement variable, DependencyRequest request) {
                 StringBuilder builder = new StringBuilder(INDENT);
+                appendRequestedKeyAndVerb(request, builder);
                 appendEnclosingTypeAndMemberName(variable, builder);
-                appendRequest(builder, request);
                 return builder.toString();
               }
 
@@ -181,15 +163,18 @@ protected String defaultAction(Element element, DependencyRequest request) {
             request);
   }
 
-  private void appendRequest(StringBuilder builder, DependencyRequest request) {
-    appendRequest(
-        builder, "injects", request.key().qualifier(), requestedTypeWithFrameworkClass(request));
+  private void appendRequestedKeyAndVerb(DependencyRequest request, StringBuilder builder) {
+    appendRequestedKeyAndVerb(
+        builder, request.key().qualifier(), requestedTypeWithFrameworkClass(request), "injected");
   }
 
-  private void appendRequest(
-      StringBuilder builder, String verb, Optional<AnnotationMirror> qualifier, TypeMirror type) {
-    builder.append("\n    ").append(INDENT).append(verb).append(' ');
-    appendQualifiedType(builder, qualifier, type);
+  private void appendRequestedKeyAndVerb(
+      StringBuilder builder,
+      Optional<AnnotationMirror> qualifier,
+      TypeMirror requestedType,
+      String verb) {
+    appendQualifiedType(builder, qualifier, requestedType);
+    builder.append(" is ").append(verb).append(" at\n    ").append(INDENT);
   }
 
   private TypeMirror requestedTypeWithFrameworkClass(DependencyRequest request) {
@@ -211,22 +196,22 @@ private void appendQualifiedType(
   }
 
   /**
-   * Returns the verb for a component method dependency request. Returns "produces", "provides", or
-   * "injects", depending on the kind of request.
+   * Returns the verb for a component method dependency request. Returns "produced", "provided", or
+   * "injected", depending on the kind of request.
    */
   private String componentMethodRequestVerb(DependencyRequest request) {
     switch (request.kind()) {
       case FUTURE:
       case PRODUCER:
-        return "produces";
+        return "produced";
 
       case INSTANCE:
       case LAZY:
       case PROVIDER:
-        return "provides";
+        return "provided";
 
       case MEMBERS_INJECTOR:
-        return "injects";
+        return "injected";
 
       case PRODUCED:
       default:
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index 2e4666f17..e999a3414 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -189,13 +189,15 @@ public void membersInjectDependsOnUnboundedType() {
         .that(ImmutableList.of(injectsUnboundedType, component))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(Joiner.on('\n').join(
-            "Type parameters must be bounded for members injection."
-                + " ? required by java.util.ArrayList<?>, via:",
-                "      test.TestComponent.injectsUnboundedType(injects)",
-                "          injects test.InjectsUnboundedType",
-                "      test.InjectsUnboundedType.listInjector",
-                "          injects dagger.MembersInjector<java.util.ArrayList<?>>"))
+        .withErrorContaining(
+            Joiner.on('\n')
+                .join(
+                    "Type parameters must be bounded for members injection."
+                        + " ? required by java.util.ArrayList<?>, via:",
+                    "      dagger.MembersInjector<java.util.ArrayList<?>> is injected at",
+                    "          test.InjectsUnboundedType.listInjector",
+                    "      test.InjectsUnboundedType is injected at",
+                    "          test.TestComponent.injectsUnboundedType(injects)"))
         .in(component)
         .onLine(7);
   }
@@ -232,12 +234,14 @@ public void membersInjectDependsOnUnboundedType() {
         Joiner.on('\n')
             .join(
                 "test.Outer.CComponent.getC() contains a dependency cycle:",
-                "      test.Outer.C.<init>(bParam)",
-                "          injects test.Outer.B",
-                "      test.Outer.B.<init>(aParam)",
-                "          injects test.Outer.A",
-                "      test.Outer.A.<init>(cParam)",
-                "          injects test.Outer.C");
+                "      test.Outer.C is injected at",
+                "          test.Outer.A.<init>(cParam)",
+                "      test.Outer.A is injected at",
+                "          test.Outer.B.<init>(aParam)",
+                "      test.Outer.B is injected at",
+                "          test.Outer.C.<init>(bParam)",
+                "      test.Outer.C is provided at",
+                "          test.Outer.CComponent.getC()");
 
     assertAbout(javaSource()).that(component)
         .processedWith(new ComponentProcessor())
@@ -283,14 +287,16 @@ public void membersInjectDependsOnUnboundedType() {
         Joiner.on('\n')
             .join(
                 "test.Outer.DComponent.getD() contains a dependency cycle:",
-                "      test.Outer.D.<init>(cParam)",
-                "          injects test.Outer.C",
-                "      test.Outer.C.<init>(bParam)",
-                "          injects test.Outer.B",
-                "      test.Outer.B.<init>(aParam)",
-                "          injects test.Outer.A",
-                "      test.Outer.A.<init>(cParam)",
-                "          injects test.Outer.C");
+                "      test.Outer.C is injected at",
+                "          test.Outer.A.<init>(cParam)",
+                "      test.Outer.A is injected at",
+                "          test.Outer.B.<init>(aParam)",
+                "      test.Outer.B is injected at",
+                "          test.Outer.C.<init>(bParam)",
+                "      test.Outer.C is injected at",
+                "          test.Outer.D.<init>(cParam)",
+                "      test.Outer.D is provided at",
+                "          test.Outer.DComponent.getD()");
 
     assertAbout(javaSource())
         .that(component)
@@ -352,14 +358,16 @@ public void cyclicDependencyNotBrokenByMapBinding() {
         Joiner.on('\n')
             .join(
                 "test.Outer.CComponent.getC() contains a dependency cycle:",
-                "      test.Outer.C.<init>(bParam)",
-                "          injects test.Outer.B",
-                "      test.Outer.B.<init>(aParam)",
-                "          injects test.Outer.A",
-                "      test.Outer.A.<init>(cMap)",
-                "          injects java.util.Map<java.lang.String,test.Outer.C>",
-                "      test.Outer.CModule.c(c)",
-                "          injects test.Outer.C");
+                "      test.Outer.C is injected at",
+                "          test.Outer.CModule.c(c)",
+                "      java.util.Map<java.lang.String,test.Outer.C> is injected at",
+                "          test.Outer.A.<init>(cMap)",
+                "      test.Outer.A is injected at",
+                "          test.Outer.B.<init>(aParam)",
+                "      test.Outer.B is injected at",
+                "          test.Outer.C.<init>(bParam)",
+                "      test.Outer.C is provided at",
+                "          test.Outer.CComponent.getC()");
 
     assertAbout(javaSource())
         .that(component)
@@ -414,15 +422,16 @@ public void cyclicDependencyWithSetBinding() {
         Joiner.on('\n')
             .join(
                 "test.Outer.CComponent.getC() contains a dependency cycle:",
-                "      test.Outer.C.<init>(bParam)",
-                "          injects test.Outer.B",
-                "      test.Outer.B.<init>(aParam)",
-                "          injects test.Outer.A",
-                "      test.Outer.A.<init>(cSet)",
-                "          injects java.util.Set<test.Outer.C>",
-                "      test.Outer.CModule.c(c)",
-                "          injects test.Outer.C"
-                );
+                "      test.Outer.C is injected at",
+                "          test.Outer.CModule.c(c)",
+                "      java.util.Set<test.Outer.C> is injected at",
+                "          test.Outer.A.<init>(cSet)",
+                "      test.Outer.A is injected at",
+                "          test.Outer.B.<init>(aParam)",
+                "      test.Outer.B is injected at",
+                "          test.Outer.C.<init>(bParam)",
+                "      test.Outer.C is provided at",
+                "          test.Outer.CComponent.getC()");
 
     assertAbout(javaSource())
         .that(component)
@@ -473,14 +482,16 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
         Joiner.on('\n')
             .join(
                 "test.Outer.DComponent.getD() contains a dependency cycle:",
-                "      test.Outer.D.<init>(cParam)",
-                "          injects javax.inject.Provider<test.Outer.C>",
-                "      test.Outer.C.<init>(bParam)",
-                "          injects test.Outer.B",
-                "      test.Outer.B.<init>(aParam)",
-                "          injects test.Outer.A",
-                "      test.Outer.A.<init>(cParam)",
-                "          injects test.Outer.C");
+                "      test.Outer.C is injected at",
+                "          test.Outer.A.<init>(cParam)",
+                "      test.Outer.A is injected at",
+                "          test.Outer.B.<init>(aParam)",
+                "      test.Outer.B is injected at",
+                "          test.Outer.C.<init>(bParam)",
+                "      javax.inject.Provider<test.Outer.C> is injected at",
+                "          test.Outer.D.<init>(cParam)",
+                "      test.Outer.D is provided at",
+                "          test.Outer.DComponent.getD()");
 
     assertAbout(javaSource())
         .that(component)
@@ -887,26 +898,26 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration()
         Joiner.on('\n')
             .join(
                 errorText,
-                "      test.TestClass.B.<init>(a)",
-                "          injects test.TestClass.A",
-                "      test.TestClass.C.b",
-                "          injects test.TestClass.B",
-                "      test.TestClass.DImpl.<init>(c, …)",
-                "          injects test.TestClass.C",
-                "      test.TestClass.DModule.d(…, impl, …)",
-                "          injects test.TestClass.DImpl",
-                "      test.TestClass.AComponent.getFoo()",
-                "          provides @javax.inject.Named(\"slim shady\") test.TestClass.D");
+                "      test.TestClass.A is injected at",
+                "          test.TestClass.B.<init>(a)",
+                "      test.TestClass.B is injected at",
+                "          test.TestClass.C.b",
+                "      test.TestClass.C is injected at",
+                "          test.TestClass.DImpl.<init>(c, …)",
+                "      test.TestClass.DImpl is injected at",
+                "          test.TestClass.DModule.d(…, impl, …)",
+                "      @javax.inject.Named(\"slim shady\") test.TestClass.D is provided at",
+                "          test.TestClass.AComponent.getFoo()");
     String secondError =
         Joiner.on('\n')
             .join(
                 errorText,
-                "      test.TestClass.B.<init>(a)",
-                "          injects test.TestClass.A",
-                "      test.TestClass.C.b",
-                "          injects test.TestClass.B",
-                "      test.TestClass.AComponent.injectC(c)",
-                "          injects test.TestClass.C");
+                "      test.TestClass.A is injected at",
+                "          test.TestClass.B.<init>(a)",
+                "      test.TestClass.B is injected at",
+                "          test.TestClass.C.b",
+                "      test.TestClass.C is injected at",
+                "          test.TestClass.AComponent.injectC(c)");
     assertAbout(javaSource())
         .that(component)
         .processedWith(new ComponentProcessor())
@@ -960,14 +971,14 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration()
         Joiner.on("\n")
             .join(
                 "java.util.List cannot be provided without an @Provides-annotated method.",
-                "      test.TestClass.<init>(list)",
-                "          injects java.util.List",
-                "      test.Generic.<init>(t)",
-                "          injects test.TestClass",
-                "      test.UsesTest.<init>(genericTestClass)",
-                "          injects test.Generic<test.TestClass>",
-                "      test.TestComponent.usesTest()",
-                "          provides test.UsesTest");
+                "      java.util.List is injected at",
+                "          test.TestClass.<init>(list)",
+                "      test.TestClass is injected at",
+                "          test.Generic.<init>(t)",
+                "      test.Generic<test.TestClass> is injected at",
+                "          test.UsesTest.<init>(genericTestClass)",
+                "      test.UsesTest is provided at",
+                "          test.TestComponent.usesTest()");
     assertAbout(javaSources()).that(ImmutableList.of(generic, testClass, usesTest, component))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
@@ -1015,14 +1026,14 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration()
         Joiner.on("\n")
             .join(
                 "java.util.List cannot be provided without an @Provides-annotated method.",
-                "      test.TestClass.<init>(list)",
-                "          injects java.util.List",
-                "      test.Generic.t",
-                "          injects test.TestClass",
-                "      test.UsesTest.<init>(genericTestClass)",
-                "          injects test.Generic<test.TestClass>",
-                "      test.TestComponent.usesTest()",
-                "          provides test.UsesTest");
+                "      java.util.List is injected at",
+                "          test.TestClass.<init>(list)",
+                "      test.TestClass is injected at",
+                "          test.Generic.t",
+                "      test.Generic<test.TestClass> is injected at",
+                "          test.UsesTest.<init>(genericTestClass)",
+                "      test.UsesTest is provided at",
+                "          test.TestComponent.usesTest()");
     assertAbout(javaSources()).that(ImmutableList.of(generic, testClass, usesTest, component))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
