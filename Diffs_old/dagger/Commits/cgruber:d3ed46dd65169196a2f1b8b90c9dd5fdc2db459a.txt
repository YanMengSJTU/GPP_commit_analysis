diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 5bcaf8f16..a931dea17 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -199,10 +199,14 @@ java_library(
     name = "validation",
     srcs = [
         "AnyBindingMethodValidator.java",
+        "BindingElementValidator.java",
         "BindingGraphPlugins.java",
         "BindingGraphValidator.java",
         "BindingMethodProcessingStep.java",
         "BindingMethodValidator.java",
+        "BindsInstanceElementValidator.java",
+        "BindsInstanceMethodValidator.java",
+        "BindsInstanceParameterValidator.java",
         "BindsInstanceProcessingStep.java",
         "BindsMethodValidator.java",
         "BindsOptionalOfMethodValidator.java",
diff --git a/java/dagger/internal/codegen/BindingElementValidator.java b/java/dagger/internal/codegen/BindingElementValidator.java
new file mode 100644
index 000000000..198fbf200
--- /dev/null
+++ b/java/dagger/internal/codegen/BindingElementValidator.java
@@ -0,0 +1,372 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Verify.verifyNotNull;
+import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
+import static dagger.internal.codegen.MapKeys.getMapKeys;
+import static dagger.internal.codegen.Scopes.scopesOf;
+import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
+import static javax.lang.model.type.TypeKind.ARRAY;
+import static javax.lang.model.type.TypeKind.DECLARED;
+import static javax.lang.model.type.TypeKind.TYPEVAR;
+import static javax.lang.model.type.TypeKind.VOID;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.errorprone.annotations.FormatMethod;
+import com.google.errorprone.annotations.OverridingMethodsMustInvokeSuper;
+import dagger.MapKey;
+import dagger.Provides;
+import dagger.internal.codegen.ValidationReport.Builder;
+import dagger.model.Key;
+import dagger.model.Scope;
+import dagger.multibindings.ElementsIntoSet;
+import dagger.multibindings.IntoMap;
+import dagger.producers.Produces;
+import java.lang.annotation.Annotation;
+import java.util.Formatter;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Optional;
+import javax.inject.Qualifier;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+
+/** A validator for elements that represent binding declarations. */
+abstract class BindingElementValidator<E extends Element> {
+  private final Class<? extends Annotation> bindingAnnotation;
+  private final AllowsMultibindings allowsMultibindings;
+  private final AllowsScoping allowsScoping;
+  private final Map<E, ValidationReport<E>> cache = new HashMap<>();
+
+  /**
+   * Creates a validator object.
+   *
+   * @param bindingAnnotation the annotation on an element that identifies it as a binding element
+   */
+  protected BindingElementValidator(
+      Class<? extends Annotation> bindingAnnotation,
+      AllowsMultibindings allowsMultibindings,
+      AllowsScoping allowsScoping) {
+    this.bindingAnnotation = bindingAnnotation;
+    this.allowsMultibindings = allowsMultibindings;
+    this.allowsScoping = allowsScoping;
+  }
+
+  /**
+   * Returns an error message of the form "<{@link #bindingElements()}> <i>rule</i>", where
+   * <i>rule</i> comes from calling {@link String#format(String, Object...)} on {@code ruleFormat}
+   * and the other arguments.
+   */
+  @FormatMethod
+  protected final String bindingElements(String ruleFormat, Object... args) {
+    return new Formatter().format("%s ", bindingElements()).format(ruleFormat, args).toString();
+  }
+
+  /**
+   * The kind of elements that this validator validates. Should be plural. Used for error reporting.
+   */
+  protected abstract String bindingElements();
+
+  /** The verb describing the {@link #bindingElementType(Builder)} in error messages. */
+  // TODO(ronshapiro,dpb): improve the name of this method and it's documentation.
+  protected abstract String bindingElementTypeVerb();
+
+  /** Returns a {@link ValidationReport} for {@code element}. */
+  final ValidationReport<E> validate(E element) {
+    return reentrantComputeIfAbsent(cache, element, this::validateUncached);
+  }
+
+  private ValidationReport<E> validateUncached(E element) {
+    ValidationReport.Builder<E> report = ValidationReport.about(element);
+    checkElement(report);
+    return report.build();
+  }
+
+  /** Checks the element for validity. Adds errors to {@code builder}. */
+  @OverridingMethodsMustInvokeSuper
+  protected void checkElement(ValidationReport.Builder<E> builder) {
+    checkType(builder);
+    checkQualifiers(builder);
+    checkMapKeys(builder);
+    checkMultibindings(builder);
+    checkScopes(builder);
+  }
+
+  /**
+   * The type declared by this binding element. This may differ from a binding's {@link Key#type()},
+   * for example in multibindings. An {@link Optional#empty()} return value indicates that the
+   * contributed type is ambiguous or missing, i.e. a {@link @BindsInstance} method with zero or
+   * many parameters.
+   */
+  // TODO(dpb): should this be an ImmutableList<TypeMirror>, with this class checking the size?
+  protected abstract Optional<TypeMirror> bindingElementType(ValidationReport.Builder<E> report);
+
+  /**
+   * Adds an error if the {@link #bindingElementType(ValidationReport.Builder) binding element type}
+   * is not appropriate.
+   *
+   * <p>Adds an error if the type is not a primitive, array, declared type, or type variable.
+   *
+   * <p>If the binding is not a multibinding contribution, adds an error if the type is a framework
+   * type.
+   *
+   * <p>If the element has {@link ElementsIntoSet @ElementsIntoSet} or {@code SET_VALUES}, adds an
+   * error if the type is not a {@code Set<T>} for some {@code T}
+   */
+  protected void checkType(ValidationReport.Builder<E> builder) {
+    switch (ContributionType.fromBindingElement(builder.getSubject())) {
+      case UNIQUE:
+        /* Validate that a unique binding is not attempting to bind a framework type. This
+         * validation is only appropriate for unique bindings because multibindings may collect
+         * framework types.  E.g. Set<Provider<Foo>> is perfectly reasonable. */
+        checkFrameworkType(builder);
+        // fall through
+
+      case SET:
+      case MAP:
+        bindingElementType(builder).ifPresent(type -> checkKeyType(builder, type));
+        break;
+
+      case SET_VALUES:
+        checkSetValuesType(builder);
+        break;
+
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  /**
+   * Adds an error if {@code keyType} is not a primitive, declared type, array, or type variable.
+   */
+  protected void checkKeyType(ValidationReport.Builder<E> builder, TypeMirror keyType) {
+    TypeKind kind = keyType.getKind();
+    if (kind.equals(VOID)) {
+      builder.addError(bindingElements("must %s a value (not void)", bindingElementTypeVerb()));
+    } else if (!(kind.isPrimitive()
+        || kind.equals(DECLARED)
+        || kind.equals(ARRAY)
+        || kind.equals(TYPEVAR))) {
+      builder.addError(badTypeMessage());
+    }
+  }
+
+  /** The error message when a binding element has a bad type. */
+  protected String badTypeMessage() {
+    return bindingElements(
+        "must %s a primitive, an array, a type variable, or a declared type",
+        bindingElementTypeVerb());
+  }
+
+  /**
+   * Adds an error if the type for an element with {@link ElementsIntoSet @ElementsIntoSet} or
+   * {@code SET_VALUES} is not a a {@code Set<T>} for a reasonable {@code T}.
+   */
+  // TODO(gak): should we allow "covariant return" for set values?
+  protected void checkSetValuesType(ValidationReport.Builder<E> builder) {
+    bindingElementType(builder).ifPresent(keyType -> checkSetValuesType(builder, keyType));
+  }
+
+  /** Adds an error if {@code type} is not a {@code Set<T>} for a reasonable {@code T}. */
+  protected final void checkSetValuesType(ValidationReport.Builder<E> builder, TypeMirror type) {
+    if (!SetType.isSet(type)) {
+      builder.addError(elementsIntoSetNotASetMessage());
+    } else {
+      SetType setType = SetType.from(type);
+      if (setType.isRawType()) {
+        builder.addError(elementsIntoSetRawSetMessage());
+      } else {
+        checkKeyType(builder, setType.elementType());
+      }
+    }
+  }
+
+  /**
+   * The error message when a the type for a binding element with {@link
+   * ElementsIntoSet @ElementsIntoSet} or {@code SET_VALUES} is a not set type.
+   */
+  protected String elementsIntoSetNotASetMessage() {
+    return bindingElements(
+        "annotated with @ElementsIntoSet must %s a Set", bindingElementTypeVerb());
+  }
+
+  /**
+   * The error message when a the type for a binding element with {@link
+   * ElementsIntoSet @ElementsIntoSet} or {@code SET_VALUES} is a raw set.
+   */
+  protected String elementsIntoSetRawSetMessage() {
+    return bindingElements(
+        "annotated with @ElementsIntoSet cannot %s a raw Set", bindingElementTypeVerb());
+  }
+
+  /** Adds an error if the element has more than one {@linkplain Qualifier qualifier} annotation. */
+  private void checkQualifiers(ValidationReport.Builder<E> builder) {
+    ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(builder.getSubject());
+    if (qualifiers.size() > 1) {
+      for (AnnotationMirror qualifier : qualifiers) {
+        builder.addError(
+            bindingElements("may not use more than one @Qualifier"),
+            builder.getSubject(),
+            qualifier);
+      }
+    }
+  }
+
+  /**
+   * Adds an error if an {@link IntoMap @IntoMap} element doesn't have exactly one {@link
+   * MapKey @MapKey} annotation, or if an element that is {@link IntoMap @IntoMap} has any.
+   */
+  private void checkMapKeys(ValidationReport.Builder<E> builder) {
+    if (!allowsMultibindings.allowsMultibindings()) {
+      return;
+    }
+    ImmutableSet<? extends AnnotationMirror> mapKeys = getMapKeys(builder.getSubject());
+    if (ContributionType.fromBindingElement(builder.getSubject()).equals(ContributionType.MAP)) {
+      switch (mapKeys.size()) {
+        case 0:
+          builder.addError(bindingElements("of type map must declare a map key"));
+          break;
+        case 1:
+          break;
+        default:
+          builder.addError(bindingElements("may not have more than one map key"));
+          break;
+      }
+    } else if (!mapKeys.isEmpty()) {
+      builder.addError(bindingElements("of non map type cannot declare a map key"));
+    }
+  }
+
+  /**
+   * Adds errors if:
+   *
+   * <ul>
+   *   <li>the element doesn't allow {@linkplain MultibindingAnnotations multibinding annotations}
+   *       and has any
+   *   <li>the element does allow them but has more than one
+   *   <li>the element has a multibinding annotation and its {@link Provides} or {@link Produces}
+   *       annotation has a {@code type} parameter.
+   * </ul>
+   */
+  private void checkMultibindings(ValidationReport.Builder<E> builder) {
+    ImmutableSet<AnnotationMirror> multibindingAnnotations =
+        MultibindingAnnotations.forElement(builder.getSubject());
+
+    switch (allowsMultibindings) {
+      case NO_MULTIBINDINGS:
+        for (AnnotationMirror annotation : multibindingAnnotations) {
+          builder.addError(
+              bindingElements("cannot have multibinding annotations"),
+              builder.getSubject(),
+              annotation);
+        }
+        break;
+
+      case ALLOWS_MULTIBINDINGS:
+        if (multibindingAnnotations.size() > 1) {
+          for (AnnotationMirror annotation : multibindingAnnotations) {
+            builder.addError(
+                bindingElements("cannot have more than one multibinding annotation"),
+                builder.getSubject(),
+                annotation);
+          }
+        }
+        break;
+    }
+
+    // TODO(ronshapiro): move this into ProvidesMethodValidator
+    if (bindingAnnotation.equals(Provides.class)) {
+      AnnotationMirror bindingAnnotationMirror =
+          getAnnotationMirror(builder.getSubject(), bindingAnnotation).get();
+      boolean usesProvidesType = false;
+      for (ExecutableElement member : bindingAnnotationMirror.getElementValues().keySet()) {
+        usesProvidesType |= member.getSimpleName().contentEquals("type");
+      }
+      if (usesProvidesType && !multibindingAnnotations.isEmpty()) {
+        builder.addError(
+            "@Provides.type cannot be used with multibinding annotations", builder.getSubject());
+      }
+    }
+  }
+
+  /**
+   * Adds an error if the element has a scope but doesn't allow scoping, or if it has more than one
+   * {@linkplain Scope scope} annotation.
+   */
+  private void checkScopes(ValidationReport.Builder<E> builder) {
+    ImmutableSet<Scope> scopes = scopesOf(builder.getSubject());
+    String error = null;
+    switch (allowsScoping) {
+      case ALLOWS_SCOPING:
+        if (scopes.size() <= 1) {
+          return;
+        }
+        error = bindingElements("cannot use more than one @Scope");
+        break;
+      case NO_SCOPING:
+        error = bindingElements("cannot be scoped");
+        break;
+    }
+    verifyNotNull(error);
+    for (Scope scope : scopes) {
+      builder.addError(error, builder.getSubject(), scope.scopeAnnotation());
+    }
+  }
+
+  /**
+   * Adds an error if the {@link #bindingElementType(Builder) type} is a {@linkplain FrameworkTypes
+   * framework type}.
+   */
+  private void checkFrameworkType(ValidationReport.Builder<E> builder) {
+    if (bindingElementType(builder).filter(FrameworkTypes::isFrameworkType).isPresent()) {
+      builder.addError(bindingElements("must not %s framework types", bindingElementTypeVerb()));
+    }
+  }
+
+  /** Whether to check multibinding annotations. */
+  enum AllowsMultibindings {
+    /**
+     * This element disallows multibinding annotations, so don't bother checking for their validity.
+     * {@link MultibindingAnnotationsProcessingStep} will add errors if the element has any
+     * multibinding annotations.
+     */
+    NO_MULTIBINDINGS,
+
+    /** This element allows multibinding annotations, so validate them. */
+    ALLOWS_MULTIBINDINGS,
+    ;
+
+    private boolean allowsMultibindings() {
+      return this == ALLOWS_MULTIBINDINGS;
+    }
+  }
+
+  /** How to check scoping annotations. */
+  enum AllowsScoping {
+    /** This element disallows scoping, so check that no scope annotations are present. */
+    NO_SCOPING,
+
+    /** This element allows scoping, so validate that there's at most one scope annotation. */
+    ALLOWS_SCOPING,
+    ;
+  }
+}
diff --git a/java/dagger/internal/codegen/BindingFactory.java b/java/dagger/internal/codegen/BindingFactory.java
index 5405bfd2d..ef8f04969 100644
--- a/java/dagger/internal/codegen/BindingFactory.java
+++ b/java/dagger/internal/codegen/BindingFactory.java
@@ -214,7 +214,7 @@ B setMethodBindingProperties(
       builder.unresolved(create.apply(method, MoreElements.asType(method.getEnclosingElement())));
     }
     return builder
-        .contributionType(ContributionType.fromBindingMethod(method))
+        .contributionType(ContributionType.fromBindingElement(method))
         .bindingElement(method)
         .contributingModule(contributedBy)
         .key(key)
diff --git a/java/dagger/internal/codegen/BindingMethodValidator.java b/java/dagger/internal/codegen/BindingMethodValidator.java
index 4b829797f..8d042429d 100644
--- a/java/dagger/internal/codegen/BindingMethodValidator.java
+++ b/java/dagger/internal/codegen/BindingMethodValidator.java
@@ -16,43 +16,21 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.base.Verify.verifyNotNull;
-import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
 import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
-import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
-import static dagger.internal.codegen.MapKeys.getMapKeys;
-import static dagger.internal.codegen.Scopes.scopesOf;
-import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
 import static java.util.stream.Collectors.joining;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.type.TypeKind.ARRAY;
-import static javax.lang.model.type.TypeKind.DECLARED;
-import static javax.lang.model.type.TypeKind.TYPEVAR;
-import static javax.lang.model.type.TypeKind.VOID;
 
 import com.google.common.collect.ImmutableSet;
 import com.google.errorprone.annotations.FormatMethod;
-import com.google.errorprone.annotations.OverridingMethodsMustInvokeSuper;
-import dagger.MapKey;
-import dagger.Provides;
-import dagger.model.Scope;
-import dagger.multibindings.ElementsIntoSet;
-import dagger.multibindings.IntoMap;
-import dagger.producers.Produces;
 import java.lang.annotation.Annotation;
-import java.util.Formatter;
-import java.util.HashMap;
-import java.util.Map;
-import javax.inject.Qualifier;
-import javax.lang.model.element.AnnotationMirror;
+import java.util.Optional;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 
 /** A validator for methods that represent binding declarations. */
-abstract class BindingMethodValidator {
+abstract class BindingMethodValidator extends BindingElementValidator<ExecutableElement> {
 
   private final DaggerElements elements;
   private final DaggerTypes types;
@@ -61,9 +39,6 @@
   private final ImmutableSet<? extends Class<? extends Annotation>> enclosingElementAnnotations;
   private final Abstractness abstractness;
   private final ExceptionSuperclass exceptionSuperclass;
-  private final Map<ExecutableElement, ValidationReport<ExecutableElement>> cache = new HashMap<>();
-  private final AllowsMultibindings allowsMultibindings;
-  private final AllowsScoping allowsScoping;
 
   /**
    * Creates a validator object.
@@ -111,6 +86,7 @@ protected BindingMethodValidator(
       ExceptionSuperclass exceptionSuperclass,
       AllowsMultibindings allowsMultibindings,
       AllowsScoping allowsScoping) {
+    super(methodAnnotation, allowsMultibindings, allowsScoping);
     this.elements = elements;
     this.types = types;
     this.methodAnnotation = methodAnnotation;
@@ -118,8 +94,6 @@ protected BindingMethodValidator(
     this.dependencyRequestValidator = dependencyRequestValidator;
     this.abstractness = abstractness;
     this.exceptionSuperclass = exceptionSuperclass;
-    this.allowsMultibindings = allowsMultibindings;
-    this.allowsScoping = allowsScoping;
   }
 
   /** The annotation that identifies binding methods validated by this object. */
@@ -134,36 +108,33 @@ protected BindingMethodValidator(
    */
   @FormatMethod
   protected final String bindingMethods(String ruleFormat, Object... args) {
-    return new Formatter()
-        .format("@%s methods ", methodAnnotation.getSimpleName())
-        .format(ruleFormat, args)
-        .toString();
+    return bindingElements(ruleFormat, args);
   }
 
-  /** Returns a {@link ValidationReport} for {@code method}. */
-  final ValidationReport<ExecutableElement> validate(ExecutableElement method) {
-    return reentrantComputeIfAbsent(cache, method, this::validateUncached);
+  @Override
+  protected final String bindingElements() {
+    return String.format("@%s methods", methodAnnotation.getSimpleName());
   }
 
-  private ValidationReport<ExecutableElement> validateUncached(ExecutableElement m) {
-    ValidationReport.Builder<ExecutableElement> report = ValidationReport.about(m);
-    checkMethod(report);
-    return report.build();
+  @Override
+  protected final String bindingElementTypeVerb() {
+    return "return";
   }
 
-  /** Checks the method for validity. Adds errors to {@code builder}. */
-  @OverridingMethodsMustInvokeSuper
-  protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder) {
+  @Override
+  protected final Optional<TypeMirror> bindingElementType(
+      ValidationReport.Builder<ExecutableElement> report) {
+    return Optional.of(report.getSubject().getReturnType());
+  }
+
+  @Override
+  protected void checkElement(ValidationReport.Builder<ExecutableElement> builder) {
+    super.checkElement(builder);
     checkEnclosingElement(builder);
     checkTypeParameters(builder);
     checkNotPrivate(builder);
     checkAbstractness(builder);
-    checkReturnType(builder);
     checkThrows(builder);
-    checkQualifiers(builder);
-    checkMapKeys(builder);
-    checkMultibindings(builder);
-    checkScopes(builder);
     checkParameters(builder);
   }
 
@@ -177,8 +148,7 @@ private void checkEnclosingElement(ValidationReport.Builder<ExecutableElement> b
       builder.addError(
           bindingMethods(
               "can only be present within a @%s",
-              enclosingElementAnnotations
-                  .stream()
+              enclosingElementAnnotations.stream()
                   .map(Class::getSimpleName)
                   .collect(joining(" or @"))));
     }
@@ -219,86 +189,6 @@ private void checkAbstractness(ValidationReport.Builder<ExecutableElement> build
     }
   }
 
-  /**
-   * Adds an error if the return type is not appropriate for the method.
-   *
-   * <p>Adds an error if the method doesn't return a primitive, array, declared type, or type
-   * variable.
-   *
-   * <p>If the method is not a multibinding contribution, adds an error if it returns a framework
-   * type.
-   *
-   * <p>If the method is a {@link ElementsIntoSet @ElementsIntoSet} or {@code SET_VALUES}
-   * contribution, adds an error if the method doesn't return a {@code Set<T>} for some {@code T}
-   */
-  protected void checkReturnType(ValidationReport.Builder<ExecutableElement> builder) {
-    switch (ContributionType.fromBindingMethod(builder.getSubject())) {
-      case UNIQUE:
-        /* Validate that a unique binding is not attempting to bind a framework type. This
-         * validation is only appropriate for unique bindings because multibindings may collect
-         * framework types.  E.g. Set<Provider<Foo>> is perfectly reasonable. */
-        checkFrameworkType(builder);
-        // fall through
-
-      case SET:
-      case MAP:
-        checkKeyType(builder, builder.getSubject().getReturnType());
-        break;
-
-      case SET_VALUES:
-        checkSetValuesType(builder);
-        break;
-
-      default:
-        throw new AssertionError();
-    }
-  }
-
-  /**
-   * Adds an error if {@code keyType} is not a primitive, declared type, array, or type variable.
-   */
-  protected void checkKeyType(
-      ValidationReport.Builder<ExecutableElement> builder, TypeMirror keyType) {
-    TypeKind kind = keyType.getKind();
-    if (kind.equals(VOID)) {
-      builder.addError(bindingMethods("must return a value (not void)"));
-    } else if (!(kind.isPrimitive()
-        || kind.equals(DECLARED)
-        || kind.equals(ARRAY)
-        || kind.equals(TYPEVAR))) {
-      builder.addError(badReturnTypeMessage());
-    }
-  }
-
-  /** The error message when a non-{@code void} binding method returns a bad type. */
-  protected String badReturnTypeMessage() {
-    return bindingMethods("must return a primitive, an array, a type variable, or a declared type");
-  }
-
-  /**
-   * Adds an error if an {@link ElementsIntoSet @ElementsIntoSet} or {@code SET_VALUES} method
-   * doesn't return a {@code Set<T>} for a reasonable {@code T}.
-   */
-  // TODO(gak): should we allow "covariant return" for set values?
-  protected void checkSetValuesType(ValidationReport.Builder<ExecutableElement> builder) {
-    checkSetValuesType(builder, builder.getSubject().getReturnType());
-  }
-
-  /** Adds an error if {@code type} is not a {@code Set<T>} for a reasonable {@code T}. */
-  protected final void checkSetValuesType(
-      ValidationReport.Builder<ExecutableElement> builder, TypeMirror type) {
-    if (!SetType.isSet(type)) {
-      builder.addError(badSetValuesTypeMessage());
-    } else {
-      SetType setType = SetType.from(type);
-      if (setType.isRawType()) {
-        builder.addError(bindingMethods("annotated with @ElementsIntoSet cannot return a raw Set"));
-      } else {
-        checkKeyType(builder, setType.elementType());
-      }
-    }
-  }
-
   /**
    * Adds an error if the method declares throws anything but an {@link Error} or an appropriate
    * subtype of {@link Exception}.
@@ -307,110 +197,6 @@ private void checkThrows(ValidationReport.Builder<ExecutableElement> builder) {
     exceptionSuperclass.checkThrows(this, builder);
   }
 
-  /** Adds an error if the method has more than one {@linkplain Qualifier qualifier} annotation. */
-  protected void checkQualifiers(ValidationReport.Builder<ExecutableElement> builder) {
-    ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(builder.getSubject());
-    if (qualifiers.size() > 1) {
-      for (AnnotationMirror qualifier : qualifiers) {
-        builder.addError(
-            bindingMethods("may not use more than one @Qualifier"),
-            builder.getSubject(),
-            qualifier);
-      }
-    }
-  }
-
-  /**
-   * Adds an error if an {@link IntoMap @IntoMap} or {@code MAP} method doesn't have exactly one
-   * {@link MapKey @MapKey} annotation, or if a method that is neither {@link IntoMap @IntoMap} nor
-   * {@code MAP} has any.
-   */
-  protected void checkMapKeys(ValidationReport.Builder<ExecutableElement> builder) {
-    if (!allowsMultibindings.allowsMultibindings()) {
-      return;
-    }
-    ImmutableSet<? extends AnnotationMirror> mapKeys = getMapKeys(builder.getSubject());
-    if (ContributionType.fromBindingMethod(builder.getSubject()).equals(ContributionType.MAP)) {
-      switch (mapKeys.size()) {
-        case 0:
-          builder.addError(bindingMethods("of type map must declare a map key"));
-          break;
-        case 1:
-          break;
-        default:
-          builder.addError(bindingMethods("may not have more than one map key"));
-          break;
-      }
-    } else if (!mapKeys.isEmpty()) {
-      builder.addError(bindingMethods("of non map type cannot declare a map key"));
-    }
-  }
-
-  /**
-   * Adds errors if the method doesn't allow {@linkplain MultibindingAnnotations multibinding
-   * annotations} and has any, or if it does allow them but has more than one, or if it has a
-   * multibinding annotation and its {@link Provides} or {@link Produces} annotation has a {@code
-   * type} parameter.
-   */
-  protected void checkMultibindings(ValidationReport.Builder<ExecutableElement> builder) {
-    ImmutableSet<AnnotationMirror> multibindingAnnotations =
-        MultibindingAnnotations.forMethod(builder.getSubject());
-
-    switch (allowsMultibindings) {
-      case NO_MULTIBINDINGS:
-        for (AnnotationMirror annotation : multibindingAnnotations) {
-          builder.addError(
-              bindingMethods("cannot have multibinding annotations"),
-              builder.getSubject(),
-              annotation);
-        }
-        break;
-
-      case ALLOWS_MULTIBINDINGS:
-        if (multibindingAnnotations.size() > 1) {
-          for (AnnotationMirror annotation : multibindingAnnotations) {
-            builder.addError(
-                bindingMethods("cannot have more than one multibinding annotation"),
-                builder.getSubject(),
-                annotation);
-          }
-        }
-        break;
-    }
-
-    AnnotationMirror bindingAnnotationMirror =
-        getAnnotationMirror(builder.getSubject(), methodAnnotation).get();
-    boolean usesProvidesType = false;
-    for (ExecutableElement member : bindingAnnotationMirror.getElementValues().keySet()) {
-      usesProvidesType |= member.getSimpleName().contentEquals("type");
-    }
-    if (usesProvidesType && !multibindingAnnotations.isEmpty()) {
-      builder.addError(
-          "@Provides.type cannot be used with multibinding annotations", builder.getSubject());
-    }
-  }
-
-  /** Adds an error if the method has more than one {@linkplain Scope scope} annotation. */
-  private void checkScopes(ValidationReport.Builder<ExecutableElement> builder) {
-    ImmutableSet<Scope> scopes = scopesOf(builder.getSubject());
-    String error = null;
-    switch (allowsScoping) {
-      case ALLOWS_SCOPING:
-        if (scopes.size() <= 1) {
-          return;
-        }
-        error = bindingMethods("cannot use more than one @Scope");
-        break;
-      case NO_SCOPING:
-        error = bindingMethods("cannot be scoped");
-        break;
-    }
-    verifyNotNull(error);
-    for (Scope scope : scopes) {
-      builder.addError(error, builder.getSubject(), scope.scopeAnnotation());
-    }
-  }
-
   /** Adds errors for the method parameters. */
   protected void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
     for (VariableElement parameter : builder.getSubject().getParameters()) {
@@ -427,21 +213,6 @@ protected void checkParameter(
     dependencyRequestValidator.validateDependencyRequest(builder, parameter, parameter.asType());
   }
 
-  /** Adds an error if the method returns a {@linkplain FrameworkTypes framework type}. */
-  protected void checkFrameworkType(ValidationReport.Builder<ExecutableElement> builder) {
-    if (FrameworkTypes.isFrameworkType(builder.getSubject().getReturnType())) {
-      builder.addError(bindingMethods("must not return framework types"));
-    }
-  }
-
-  /**
-   * The error message when an {@link ElementsIntoSet @ElementsIntoSet} or {@code SET_VALUES} method
-   * returns a bad type.
-   */
-  protected String badSetValuesTypeMessage() {
-    return bindingMethods("annotated with @ElementsIntoSet must return a Set");
-  }
-
   /** An abstract/concrete restriction on methods. */
   protected enum Abstractness {
     MUST_BE_ABSTRACT,
@@ -519,32 +290,4 @@ protected void checkThrows(
 
     protected abstract String errorMessage(BindingMethodValidator validator);
   }
-
-  /** Whether to check multibinding annotations. */
-  protected enum AllowsMultibindings {
-    /**
-     * This method disallows multibinding annotations, so don't bother checking for their validity.
-     * {@link MultibindingAnnotationsProcessingStep} will add errors if the method has any
-     * multibinding annotations.
-     */
-    NO_MULTIBINDINGS,
-
-    /** This method allows multibinding annotations, so validate them. */
-    ALLOWS_MULTIBINDINGS,
-    ;
-
-    private boolean allowsMultibindings() {
-      return this == ALLOWS_MULTIBINDINGS;
-    }
-  }
-
-  /** How to check scoping annotations. */
-  protected enum AllowsScoping {
-    /** This method disallows scope annotations, so check that none are present. */
-    NO_SCOPING,
-
-    /** This method allows scoping, so validate that there's at most one. */
-    ALLOWS_SCOPING,
-    ;
-  }
 }
diff --git a/java/dagger/internal/codegen/BindsInstanceElementValidator.java b/java/dagger/internal/codegen/BindsInstanceElementValidator.java
new file mode 100644
index 000000000..9249c8ec5
--- /dev/null
+++ b/java/dagger/internal/codegen/BindsInstanceElementValidator.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import dagger.BindsInstance;
+import javax.lang.model.element.Element;
+
+abstract class BindsInstanceElementValidator<E extends Element> extends BindingElementValidator<E> {
+  BindsInstanceElementValidator() {
+    super(BindsInstance.class, AllowsMultibindings.NO_MULTIBINDINGS, AllowsScoping.NO_SCOPING);
+  }
+
+  @Override
+  protected final String bindingElements() {
+    // Even though @BindsInstance may be placed on methods, the subject of errors is the
+    // parameter
+    return "@BindsInstance parameters";
+  }
+
+  @Override
+  protected final String bindingElementTypeVerb() {
+    return "be";
+  }
+}
diff --git a/java/dagger/internal/codegen/BindsInstanceMethodValidator.java b/java/dagger/internal/codegen/BindsInstanceMethodValidator.java
new file mode 100644
index 000000000..653c698da
--- /dev/null
+++ b/java/dagger/internal/codegen/BindsInstanceMethodValidator.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.ComponentAnnotation.anyComponentAnnotation;
+import static dagger.internal.codegen.ModuleAnnotation.moduleAnnotation;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+
+import com.google.auto.common.MoreElements;
+import java.util.List;
+import java.util.Optional;
+import javax.inject.Inject;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+
+final class BindsInstanceMethodValidator extends BindsInstanceElementValidator<ExecutableElement> {
+  @Inject
+  BindsInstanceMethodValidator() {}
+
+  @Override
+  protected void checkElement(ValidationReport.Builder<ExecutableElement> report) {
+    super.checkElement(report);
+
+    ExecutableElement method = report.getSubject();
+    if (!method.getModifiers().contains(ABSTRACT)) {
+      report.addError("@BindsInstance methods must be abstract");
+    }
+    if (method.getParameters().size() != 1) {
+      report.addError(
+          "@BindsInstance methods should have exactly one parameter for the bound type");
+    }
+    TypeElement enclosingType = MoreElements.asType(method.getEnclosingElement());
+    moduleAnnotation(enclosingType)
+        .ifPresent(moduleAnnotation -> report.addError(didYouMeanBinds(moduleAnnotation)));
+    anyComponentAnnotation(enclosingType)
+        .ifPresent(
+            componentAnnotation ->
+                report.addError(
+                    String.format(
+                        "@BindsInstance methods should not be included in @%1$ss. "
+                            + "Did you mean to put it in a @%1$s.Builder?",
+                        componentAnnotation.simpleName())));
+  }
+
+  private static String didYouMeanBinds(ModuleAnnotation moduleAnnotation) {
+    return String.format(
+        "@BindsInstance methods should not be included in @%ss. Did you mean @Binds?",
+        moduleAnnotation.annotationClass().getSimpleName());
+  }
+
+  @Override
+  protected Optional<TypeMirror> bindingElementType(
+      ValidationReport.Builder<ExecutableElement> report) {
+    List<? extends VariableElement> parameters =
+        MoreElements.asExecutable(report.getSubject()).getParameters();
+    return parameters.size() == 1
+        ? Optional.of(getOnlyElement(parameters).asType())
+        : Optional.empty();
+  }
+}
diff --git a/java/dagger/internal/codegen/BindsInstanceParameterValidator.java b/java/dagger/internal/codegen/BindsInstanceParameterValidator.java
new file mode 100644
index 000000000..be14d4405
--- /dev/null
+++ b/java/dagger/internal/codegen/BindsInstanceParameterValidator.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static javax.lang.model.element.ElementKind.METHOD;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.type.TypeKind.DECLARED;
+import static javax.lang.model.type.TypeKind.TYPEVAR;
+
+import com.google.auto.common.MoreElements;
+import java.util.Optional;
+import javax.inject.Inject;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+
+final class BindsInstanceParameterValidator extends BindsInstanceElementValidator<VariableElement> {
+  @Inject
+  BindsInstanceParameterValidator() {}
+
+  @Override
+  protected void checkElement(ValidationReport.Builder<VariableElement> report) {
+    super.checkElement(report);
+
+    VariableElement parameter = report.getSubject();
+    Element enclosing = parameter.getEnclosingElement();
+    if (!enclosing.getKind().equals(METHOD)) {
+      report.addError("@BindsInstance should only be applied to methods or parameters of methods");
+      return;
+    }
+
+    ExecutableElement method = MoreElements.asExecutable(enclosing);
+    if (!method.getModifiers().contains(ABSTRACT)) {
+      report.addError("@BindsInstance parameters may only be used in abstract methods");
+    }
+
+    TypeKind returnKind = method.getReturnType().getKind();
+    if (!(returnKind.equals(DECLARED) || returnKind.equals(TYPEVAR))) {
+      report.addError(
+          "@BindsInstance parameters may not be used in methods with a void, array or primitive "
+              + "return type");
+    }
+  }
+
+  @Override
+  protected Optional<TypeMirror> bindingElementType(
+      ValidationReport.Builder<VariableElement> report) {
+    return Optional.of(report.getSubject().asType());
+  }
+}
diff --git a/java/dagger/internal/codegen/BindsInstanceProcessingStep.java b/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
index 6ee2485ec..4c222a9ac 100644
--- a/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
+++ b/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
@@ -16,14 +16,6 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.ComponentAnnotation.anyComponentAnnotation;
-import static dagger.internal.codegen.ModuleAnnotation.moduleAnnotation;
-import static javax.lang.model.element.ElementKind.METHOD;
-import static javax.lang.model.element.Modifier.ABSTRACT;
-import static javax.lang.model.type.TypeKind.DECLARED;
-import static javax.lang.model.type.TypeKind.TYPEVAR;
-
 import com.google.auto.common.MoreElements;
 import com.google.common.collect.ImmutableSet;
 import dagger.BindsInstance;
@@ -32,21 +24,24 @@
 import javax.annotation.processing.Messager;
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.TypeKind;
 
 /**
  * Processing step that validates that the {@code BindsInstance} annotation is applied to the
  * correct elements.
  */
 final class BindsInstanceProcessingStep extends TypeCheckingProcessingStep<Element> {
+  private final BindsInstanceMethodValidator methodValidator;
+  private final BindsInstanceParameterValidator parameterValidator;
   private final Messager messager;
 
   @Inject
-  BindsInstanceProcessingStep(Messager messager) {
+  BindsInstanceProcessingStep(
+      BindsInstanceMethodValidator methodValidator,
+      BindsInstanceParameterValidator parameterValidator,
+      Messager messager) {
     super(element -> element);
+    this.methodValidator = methodValidator;
+    this.parameterValidator = parameterValidator;
     this.messager = messager;
   }
 
@@ -57,82 +52,15 @@
 
   @Override
   protected void process(Element element, ImmutableSet<Class<? extends Annotation>> annotations) {
-    ValidationReport.Builder<Element> report = ValidationReport.about(element);
-
     switch (element.getKind()) {
-      case METHOD:
-        ExecutableElement method = MoreElements.asExecutable(element);
-        validateBindsInstanceMethod(method, report);
-        break;
       case PARAMETER:
-        VariableElement parameter = MoreElements.asVariable(element);
-        validateBindsInstanceParameterType(parameter, report);
-        validateBindsInstanceParameterEnclosingMethod(parameter, report);
+        parameterValidator.validate(MoreElements.asVariable(element)).printMessagesTo(messager);
+        break;
+      case METHOD:
+        methodValidator.validate(MoreElements.asExecutable(element)).printMessagesTo(messager);
         break;
       default:
-        // Shouldn't be possible given the target elements @BindsInstance allows.
-        throw new AssertionError();
-    }
-
-    report.build().printMessagesTo(messager);
-  }
-
-  private void validateBindsInstanceMethod(
-      ExecutableElement method, ValidationReport.Builder<Element> report) {
-    if (!method.getModifiers().contains(ABSTRACT)) {
-      report.addError("@BindsInstance methods must be abstract");
-    }
-    if (method.getParameters().size() != 1) {
-      report.addError(
-          "@BindsInstance methods should have exactly one parameter for the bound type");
-    } else {
-      validateBindsInstanceParameterType(getOnlyElement(method.getParameters()), report);
-    }
-    TypeElement enclosingType = MoreElements.asType(method.getEnclosingElement());
-    moduleAnnotation(enclosingType)
-        .ifPresent(moduleAnnotation -> report.addError(didYouMeanBinds(moduleAnnotation)));
-    anyComponentAnnotation(enclosingType)
-        .ifPresent(
-            componentAnnotation ->
-                report.addError(
-                    String.format(
-                        "@BindsInstance methods should not be included in @%1$ss. "
-                            + "Did you mean to put it in a @%1$s.Builder?",
-                        componentAnnotation.simpleName())));
-  }
-
-  private static String didYouMeanBinds(ModuleAnnotation moduleAnnotation) {
-    return String.format(
-        "@BindsInstance methods should not be included in @%ss. Did you mean @Binds?",
-        moduleAnnotation.annotationClass().getSimpleName());
-  }
-
-  private void validateBindsInstanceParameterType(
-      VariableElement parameter, ValidationReport.Builder<Element> report) {
-    if (FrameworkTypes.isFrameworkType(parameter.asType())) {
-      report.addError("@BindsInstance parameters may not be framework types", parameter);
-    }
-  }
-
-  private void validateBindsInstanceParameterEnclosingMethod(
-      VariableElement parameter, ValidationReport.Builder<Element> report) {
-    Element enclosing = parameter.getEnclosingElement();
-    if (!enclosing.getKind().equals(METHOD)) {
-      report.addError(
-          "@BindsInstance should only be applied to methods or parameters of methods");
-      return;
-    }
-
-    ExecutableElement method = MoreElements.asExecutable(enclosing);
-    if (!method.getModifiers().contains(ABSTRACT)) {
-      report.addError("@BindsInstance parameters may only be used in abstract methods");
-    }
-
-    TypeKind returnKind = method.getReturnType().getKind();
-    if (!(returnKind.equals(DECLARED) || returnKind.equals(TYPEVAR))) {
-      report.addError(
-          "@BindsInstance parameters may not be used in methods with a void, array or "
-              + "primitive return type");
+        throw new AssertionError(element);
     }
   }
 }
diff --git a/java/dagger/internal/codegen/BindsMethodValidator.java b/java/dagger/internal/codegen/BindsMethodValidator.java
index 1e017bc7e..7728fa8d2 100644
--- a/java/dagger/internal/codegen/BindsMethodValidator.java
+++ b/java/dagger/internal/codegen/BindsMethodValidator.java
@@ -16,9 +16,9 @@
 
 package dagger.internal.codegen;
 
+import static dagger.internal.codegen.BindingElementValidator.AllowsMultibindings.ALLOWS_MULTIBINDINGS;
+import static dagger.internal.codegen.BindingElementValidator.AllowsScoping.ALLOWS_SCOPING;
 import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_ABSTRACT;
-import static dagger.internal.codegen.BindingMethodValidator.AllowsMultibindings.ALLOWS_MULTIBINDINGS;
-import static dagger.internal.codegen.BindingMethodValidator.AllowsScoping.ALLOWS_SCOPING;
 import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.RUNTIME_EXCEPTION;
 
 import com.google.auto.common.MoreTypes;
@@ -31,9 +31,7 @@
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.TypeMirror;
 
-/**
- * A validator for {@link Binds} methods.
- */
+/** A validator for {@link Binds} methods. */
 final class BindsMethodValidator extends BindingMethodValidator {
   private final DaggerTypes types;
   private final BindsTypeChecker bindsTypeChecker;
@@ -58,8 +56,8 @@
   }
 
   @Override
-  protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder) {
-    super.checkMethod(builder);
+  protected void checkElement(ValidationReport.Builder<ExecutableElement> builder) {
+    super.checkElement(builder);
     checkParameters(builder);
   }
 
@@ -82,7 +80,7 @@ protected void checkParameter(
     ExecutableElement method = builder.getSubject();
     TypeMirror leftHandSide = boxIfNecessary(method.getReturnType());
     TypeMirror rightHandSide = parameter.asType();
-    ContributionType contributionType = ContributionType.fromBindingMethod(method);
+    ContributionType contributionType = ContributionType.fromBindingElement(method);
     if (contributionType.equals(ContributionType.SET_VALUES) && !SetType.isSet(leftHandSide)) {
       builder.addError(
           "@Binds @ElementsIntoSet methods must return a Set and take a Set parameter");
diff --git a/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java b/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java
index e8088d980..2468a15a0 100644
--- a/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java
+++ b/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java
@@ -16,9 +16,9 @@
 
 package dagger.internal.codegen;
 
+import static dagger.internal.codegen.BindingElementValidator.AllowsMultibindings.NO_MULTIBINDINGS;
+import static dagger.internal.codegen.BindingElementValidator.AllowsScoping.NO_SCOPING;
 import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_ABSTRACT;
-import static dagger.internal.codegen.BindingMethodValidator.AllowsMultibindings.NO_MULTIBINDINGS;
-import static dagger.internal.codegen.BindingMethodValidator.AllowsScoping.NO_SCOPING;
 import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.NO_EXCEPTIONS;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
 import static dagger.internal.codegen.InjectionAnnotations.injectedConstructors;
@@ -58,8 +58,8 @@
   }
 
   @Override
-  protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder) {
-    super.checkMethod(builder);
+  protected void checkElement(ValidationReport.Builder<ExecutableElement> builder) {
+    super.checkElement(builder);
     checkParameters(builder);
   }
 
diff --git a/java/dagger/internal/codegen/ContributionType.java b/java/dagger/internal/codegen/ContributionType.java
index e3f8e37a3..66b528985 100644
--- a/java/dagger/internal/codegen/ContributionType.java
+++ b/java/dagger/internal/codegen/ContributionType.java
@@ -22,7 +22,7 @@
 import dagger.multibindings.ElementsIntoSet;
 import dagger.multibindings.IntoMap;
 import dagger.multibindings.IntoSet;
-import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Element;
 
 /** Whether a binding or declaration is for a unique contribution or a map or set multibinding. */
 enum ContributionType {
@@ -49,16 +49,17 @@ boolean isMultibinding() {
   }
 
   /**
-   * The contribution type from a binding method annotations. Presumes a well-formed binding method
-   * (at most one of @IntoSet, @IntoMap, @ElementsIntoSet and @Provides.type). {@link
-   * ProvidesMethodValidator} and {@link ProducesMethodValidator} validate correctness on their own.
+   * The contribution type from a binding element's annotations. Presumes a well-formed binding
+   * element (at most one of @IntoSet, @IntoMap, @ElementsIntoSet and @Provides.type). {@link
+   * BindingMethodValidator} and {@link BindsInstanceProcessingStep} validate correctness on their
+   * own.
    */
-  static ContributionType fromBindingMethod(ExecutableElement method) {
-    if (isAnnotationPresent(method, IntoMap.class)) {
+  static ContributionType fromBindingElement(Element element) {
+    if (isAnnotationPresent(element, IntoMap.class)) {
       return ContributionType.MAP;
-    } else if (isAnnotationPresent(method, IntoSet.class)) {
+    } else if (isAnnotationPresent(element, IntoSet.class)) {
       return ContributionType.SET;
-    } else if (isAnnotationPresent(method, ElementsIntoSet.class)) {
+    } else if (isAnnotationPresent(element, ElementsIntoSet.class)) {
       return ContributionType.SET_VALUES;
     }
     return ContributionType.UNIQUE;
diff --git a/java/dagger/internal/codegen/DelegateDeclaration.java b/java/dagger/internal/codegen/DelegateDeclaration.java
index 2dbff78a9..120463ccf 100644
--- a/java/dagger/internal/codegen/DelegateDeclaration.java
+++ b/java/dagger/internal/codegen/DelegateDeclaration.java
@@ -79,7 +79,7 @@ DelegateDeclaration create(
               Iterables.getOnlyElement(bindsMethod.getParameters()),
               Iterables.getOnlyElement(resolvedMethod.getParameterTypes()));
       return new AutoValue_DelegateDeclaration(
-          ContributionType.fromBindingMethod(bindsMethod),
+          ContributionType.fromBindingElement(bindsMethod),
           keyFactory.forBindsMethod(bindsMethod, contributingModule),
           Optional.<Element>of(bindsMethod),
           Optional.of(contributingModule),
diff --git a/java/dagger/internal/codegen/KeyFactory.java b/java/dagger/internal/codegen/KeyFactory.java
index b6b355f8d..59d400356 100644
--- a/java/dagger/internal/codegen/KeyFactory.java
+++ b/java/dagger/internal/codegen/KeyFactory.java
@@ -157,7 +157,7 @@ private Key forBindingMethod(
     ExecutableType methodType =
         MoreTypes.asExecutable(
             types.asMemberOf(MoreTypes.asDeclared(contributingModule.asType()), method));
-    ContributionType contributionType = ContributionType.fromBindingMethod(method);
+    ContributionType contributionType = ContributionType.fromBindingElement(method);
     TypeMirror returnType = methodType.getReturnType();
     if (frameworkType.isPresent()
         && frameworkType.get().equals(elements.getTypeElement(Producer.class))
diff --git a/java/dagger/internal/codegen/MultibindingAnnotations.java b/java/dagger/internal/codegen/MultibindingAnnotations.java
index eaf7a1713..23eda31c8 100644
--- a/java/dagger/internal/codegen/MultibindingAnnotations.java
+++ b/java/dagger/internal/codegen/MultibindingAnnotations.java
@@ -23,14 +23,14 @@
 import dagger.multibindings.IntoMap;
 import dagger.multibindings.IntoSet;
 import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Element;
 
 /**
  * Utility methods related to processing {@link IntoSet}, {@link ElementsIntoSet}, and {@link
  * IntoMap}.
  */
 final class MultibindingAnnotations {
-  static ImmutableSet<AnnotationMirror> forMethod(ExecutableElement method) {
+  static ImmutableSet<AnnotationMirror> forElement(Element method) {
     return getAllAnnotations(method, IntoSet.class, ElementsIntoSet.class, IntoMap.class);
   }
 }
diff --git a/java/dagger/internal/codegen/MultibindsMethodValidator.java b/java/dagger/internal/codegen/MultibindsMethodValidator.java
index f912792d5..5a6876d92 100644
--- a/java/dagger/internal/codegen/MultibindsMethodValidator.java
+++ b/java/dagger/internal/codegen/MultibindsMethodValidator.java
@@ -16,9 +16,9 @@
 
 package dagger.internal.codegen;
 
+import static dagger.internal.codegen.BindingElementValidator.AllowsMultibindings.NO_MULTIBINDINGS;
+import static dagger.internal.codegen.BindingElementValidator.AllowsScoping.NO_SCOPING;
 import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_ABSTRACT;
-import static dagger.internal.codegen.BindingMethodValidator.AllowsMultibindings.NO_MULTIBINDINGS;
-import static dagger.internal.codegen.BindingMethodValidator.AllowsScoping.NO_SCOPING;
 import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.NO_EXCEPTIONS;
 import static dagger.internal.codegen.FrameworkTypes.isFrameworkType;
 
@@ -53,8 +53,8 @@
   }
 
   @Override
-  protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder) {
-    super.checkMethod(builder);
+  protected void checkElement(ValidationReport.Builder<ExecutableElement> builder) {
+    super.checkElement(builder);
 
     checkParameters(builder);
   }
@@ -68,7 +68,7 @@ protected void checkParameters(ValidationReport.Builder<ExecutableElement> build
 
   /** Adds an error unless the method returns a {@code Map<K, V>} or {@code Set<T>}. */
   @Override
-  protected void checkReturnType(ValidationReport.Builder<ExecutableElement> builder) {
+  protected void checkType(ValidationReport.Builder<ExecutableElement> builder) {
     if (!isPlainMap(builder.getSubject().getReturnType())
         && !isPlainSet(builder.getSubject().getReturnType())) {
       builder.addError(bindingMethods("must return Map<K, V> or Set<T>"));
diff --git a/java/dagger/internal/codegen/ProducesMethodValidator.java b/java/dagger/internal/codegen/ProducesMethodValidator.java
index 400370619..9b024b6bc 100644
--- a/java/dagger/internal/codegen/ProducesMethodValidator.java
+++ b/java/dagger/internal/codegen/ProducesMethodValidator.java
@@ -17,9 +17,9 @@
 package dagger.internal.codegen;
 
 import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.BindingElementValidator.AllowsMultibindings.ALLOWS_MULTIBINDINGS;
+import static dagger.internal.codegen.BindingElementValidator.AllowsScoping.NO_SCOPING;
 import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_CONCRETE;
-import static dagger.internal.codegen.BindingMethodValidator.AllowsMultibindings.ALLOWS_MULTIBINDINGS;
-import static dagger.internal.codegen.BindingMethodValidator.AllowsScoping.NO_SCOPING;
 import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.EXCEPTION;
 
 import com.google.auto.common.MoreTypes;
@@ -34,9 +34,7 @@
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 
-/**
- * A validator for {@link Produces} methods.
- */
+/** A validator for {@link Produces} methods. */
 final class ProducesMethodValidator extends BindingMethodValidator {
 
   @Inject
@@ -57,8 +55,8 @@
   }
 
   @Override
-  protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder) {
-    super.checkMethod(builder);
+  protected void checkElement(ValidationReport.Builder<ExecutableElement> builder) {
+    super.checkElement(builder);
     checkNullable(builder);
   }
 
@@ -71,7 +69,7 @@ private void checkNullable(ValidationReport.Builder<ExecutableElement> builder)
   }
 
   @Override
-  protected String badReturnTypeMessage() {
+  protected String badTypeMessage() {
     return "@Produces methods can return only a primitive, an array, a type variable, "
         + "a declared type, or a ListenableFuture of one of those types";
   }
@@ -106,7 +104,7 @@ protected void checkSetValuesType(ValidationReport.Builder<ExecutableElement> bu
   }
 
   @Override
-  protected String badSetValuesTypeMessage() {
+  protected String elementsIntoSetNotASetMessage() {
     return "@Produces methods of type set values must return a Set or ListenableFuture of Set";
   }
 
diff --git a/java/dagger/internal/codegen/ProductionBinding.java b/java/dagger/internal/codegen/ProductionBinding.java
index d9c26453e..271c73857 100644
--- a/java/dagger/internal/codegen/ProductionBinding.java
+++ b/java/dagger/internal/codegen/ProductionBinding.java
@@ -66,7 +66,7 @@ public BindingType bindingType() {
     static ProductionKind fromProducesMethod(ExecutableElement producesMethod) {
       if (isFutureType(producesMethod.getReturnType())) {
         return FUTURE;
-      } else if (ContributionType.fromBindingMethod(producesMethod)
+      } else if (ContributionType.fromBindingElement(producesMethod)
               .equals(ContributionType.SET_VALUES)
           && isFutureType(SetType.from(producesMethod.getReturnType()).elementType())) {
         return SET_OF_FUTURE;
diff --git a/java/dagger/internal/codegen/ProvidesMethodValidator.java b/java/dagger/internal/codegen/ProvidesMethodValidator.java
index db24e6685..07f7512f9 100644
--- a/java/dagger/internal/codegen/ProvidesMethodValidator.java
+++ b/java/dagger/internal/codegen/ProvidesMethodValidator.java
@@ -16,9 +16,9 @@
 
 package dagger.internal.codegen;
 
+import static dagger.internal.codegen.BindingElementValidator.AllowsMultibindings.ALLOWS_MULTIBINDINGS;
+import static dagger.internal.codegen.BindingElementValidator.AllowsScoping.ALLOWS_SCOPING;
 import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_CONCRETE;
-import static dagger.internal.codegen.BindingMethodValidator.AllowsMultibindings.ALLOWS_MULTIBINDINGS;
-import static dagger.internal.codegen.BindingMethodValidator.AllowsScoping.ALLOWS_SCOPING;
 import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.RUNTIME_EXCEPTION;
 
 import com.google.common.collect.ImmutableSet;
@@ -29,9 +29,7 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.VariableElement;
 
-/**
- * A validator for {@link Provides} methods.
- */
+/** A validator for {@link Provides} methods. */
 final class ProvidesMethodValidator extends BindingMethodValidator {
 
   private final DependencyRequestValidator dependencyRequestValidator;
@@ -55,8 +53,8 @@
   }
 
   @Override
-  protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder) {
-    super.checkMethod(builder);
+  protected void checkElement(ValidationReport.Builder<ExecutableElement> builder) {
+    super.checkElement(builder);
   }
 
   /** Adds an error if a {@link Provides @Provides} method depends on a producer type. */
diff --git a/javatests/dagger/internal/codegen/BindsInstanceValidationTest.java b/javatests/dagger/internal/codegen/BindsInstanceValidationTest.java
index 063cd738f..2496d8b61 100644
--- a/javatests/dagger/internal/codegen/BindsInstanceValidationTest.java
+++ b/javatests/dagger/internal/codegen/BindsInstanceValidationTest.java
@@ -152,12 +152,12 @@ public void bindsInstanceFrameworkType() {
     Compilation compilation = daggerCompiler().compile(bindsFrameworkType);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining("@BindsInstance parameters may not be framework types")
+        .hadErrorContaining("@BindsInstance parameters must not be framework types")
         .inFile(bindsFrameworkType)
         .onLine(8);
 
     assertThat(compilation)
-        .hadErrorContaining("@BindsInstance parameters may not be framework types")
+        .hadErrorContaining("@BindsInstance parameters must not be framework types")
         .inFile(bindsFrameworkType)
         .onLine(9);
   }
