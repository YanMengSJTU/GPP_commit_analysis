diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index f80d2f93d..dcea41985 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -33,10 +33,12 @@
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
+import com.google.common.collect.Multimap;
 import com.google.common.collect.Ordering;
 import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.Lazy;
+import dagger.MapKey;
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.ContributionBinding.BindingType;
@@ -75,7 +77,9 @@
 import static com.google.common.collect.Iterables.indexOf;
 import static com.google.common.collect.Iterables.skip;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
+import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByAnnotationType;
 import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByMapKey;
+import static dagger.internal.codegen.ErrorMessages.DUPLICATE_SIZE_LIMIT;
 import static dagger.internal.codegen.ErrorMessages.INDENT;
 import static dagger.internal.codegen.ErrorMessages.MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE;
 import static dagger.internal.codegen.ErrorMessages.NULLABLE_TO_NON_NULLABLE;
@@ -84,6 +88,7 @@
 import static dagger.internal.codegen.ErrorMessages.REQUIRES_PROVIDER_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.REQUIRES_PROVIDER_OR_PRODUCER_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.duplicateMapKeysError;
+import static dagger.internal.codegen.ErrorMessages.inconsistentMapKeyAnnotationsError;
 import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
 import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
 import static dagger.internal.codegen.Util.getKeyTypeOfMap;
@@ -284,7 +289,10 @@ private boolean validateResolvedBinding(
               reportDuplicateBindings(path);
               return false;
             case MAP:
-              return !hasDuplicateMapKeys(path, combined);
+              boolean duplicateMapKeys = hasDuplicateMapKeys(path, combined);
+              boolean inconsistentMapKeyAnnotationTypes =
+                  hasInconsistentMapKeyAnnotationTypes(path, combined);
+              return !duplicateMapKeys && !inconsistentMapKeyAnnotationTypes;
             case SET:
               break;
             default:
@@ -366,6 +374,21 @@ private boolean hasDuplicateMapKeys(
       return hasDuplicateMapKeys;
     }
 
+    /**
+     * Returns {@code true} (and reports errors) if {@code mapBindings} uses more than one
+     * {@link MapKey} annotation type.
+     */
+    private boolean hasInconsistentMapKeyAnnotationTypes(
+        Deque<ResolvedRequest> path, Set<ContributionBinding> mapBindings) {
+      ImmutableSetMultimap<Equivalence.Wrapper<DeclaredType>, ContributionBinding>
+          mapBindingsByAnnotationType = indexMapBindingsByAnnotationType(mapBindings);
+      if (mapBindingsByAnnotationType.keySet().size() > 1) {
+        reportInconsistentMapKeyAnnotations(path, mapBindingsByAnnotationType);
+        return true;
+      }
+      return false;
+    }
+
     /**
      * Validates a members injection binding, returning false (and reporting the error) if it wasn't
      * valid.
@@ -740,9 +763,10 @@ void validateComponentScope() {
     private void reportProviderMayNotDependOnProducer(Deque<ResolvedRequest> path) {
       StringBuilder errorMessage = new StringBuilder();
       if (path.size() == 1) {
-        new Formatter(errorMessage).format(
-            ErrorMessages.PROVIDER_ENTRY_POINT_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
-            keyFormatter.format(path.peek().request().key()));
+        new Formatter(errorMessage)
+            .format(
+                ErrorMessages.PROVIDER_ENTRY_POINT_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
+                formatRootRequestKey(path));
       } else {
         ImmutableSet<ProvisionBinding> dependentProvisions =
             provisionsDependingOnLatestRequest(path);
@@ -792,14 +816,12 @@ private void reportMissingBinding(Deque<ResolvedRequest> path) {
       reportBuilder.addError(errorMessage.toString(), path.getLast().request().requestElement());
     }
 
-    private static final int DUPLICATE_SIZE_LIMIT = 10;
-
     @SuppressWarnings("resource") // Appendable is a StringBuilder.
     private void reportDuplicateBindings(Deque<ResolvedRequest> path) {
       ResolvedBindings resolvedBinding = path.peek().binding();
       StringBuilder builder = new StringBuilder();
-      new Formatter(builder).format(ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT,
-          keyFormatter.format(path.peek().request().key()));
+      new Formatter(builder)
+          .format(ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT, formatRootRequestKey(path));
       for (Binding binding : Iterables.limit(resolvedBinding.bindings(), DUPLICATE_SIZE_LIMIT)) {
         builder.append('\n').append(INDENT).append(formatBinding(binding));
       }
@@ -818,8 +840,8 @@ private void reportDuplicateBindings(Deque<ResolvedRequest> path) {
     private void reportMultipleBindingTypes(Deque<ResolvedRequest> path) {
       ResolvedBindings resolvedBinding = path.peek().binding();
       StringBuilder builder = new StringBuilder();
-      new Formatter(builder).format(ErrorMessages.MULTIPLE_BINDING_TYPES_FOR_KEY_FORMAT,
-          keyFormatter.format(path.peek().request().key()));
+      new Formatter(builder)
+          .format(ErrorMessages.MULTIPLE_BINDING_TYPES_FOR_KEY_FORMAT, formatRootRequestKey(path));
       ImmutableListMultimap<BindingType, ContributionBinding> bindingsByType =
           ContributionBinding.<ContributionBinding>bindingTypesFor(
               resolvedBinding.contributionBindings());
@@ -843,21 +865,29 @@ private void reportMultipleBindingTypes(Deque<ResolvedRequest> path) {
     private void reportDuplicateMapKeys(
         Deque<ResolvedRequest> path, Collection<? extends ContributionBinding> mapBindings) {
       StringBuilder builder = new StringBuilder();
-      builder.append(duplicateMapKeysError(keyFormatter.format(path.peek().request().key())));
-      for (Binding binding : Iterables.limit(mapBindings, DUPLICATE_SIZE_LIMIT)) {
-        builder.append('\n').append(INDENT).append(formatBinding(binding));
-      }
-      int numberOfOtherBindings = mapBindings.size() - DUPLICATE_SIZE_LIMIT;
-      if (numberOfOtherBindings > 0) {
+      builder.append(duplicateMapKeysError(formatRootRequestKey(path)));
+      appendBindings(builder, mapBindings, 1);
+      reportBuilder.addError(builder.toString(), path.getLast().request().requestElement());
+    }
+
+    private void reportInconsistentMapKeyAnnotations(
+        Deque<ResolvedRequest> path,
+        Multimap<Equivalence.Wrapper<DeclaredType>, ContributionBinding>
+            mapBindingsByAnnotationType) {
+      StringBuilder builder =
+          new StringBuilder(inconsistentMapKeyAnnotationsError(formatRootRequestKey(path)));
+      for (Map.Entry<Equivalence.Wrapper<DeclaredType>, Collection<ContributionBinding>> entry :
+          mapBindingsByAnnotationType.asMap().entrySet()) {
+        DeclaredType annotationType = entry.getKey().get();
+        Collection<ContributionBinding> bindings = entry.getValue();
+
         builder
             .append('\n')
             .append(INDENT)
-            .append("and ")
-            .append(numberOfOtherBindings)
-            .append(" other");
-      }
-      if (numberOfOtherBindings > 1) {
-        builder.append('s');
+            .append(annotationType)
+            .append(':');
+
+        appendBindings(builder, bindings, 2);
       }
       reportBuilder.addError(builder.toString(), path.getLast().request().requestElement());
     }
@@ -1089,6 +1119,32 @@ private String formatBinding(Binding binding) {
     }
   }
 
+  private String formatRootRequestKey(Deque<ResolvedRequest> path) {
+    return keyFormatter.format(path.peek().request().key());
+  }
+
+  private void appendBindings(
+      StringBuilder builder, Collection<? extends Binding> bindings, int indentLevel) {
+    for (Binding binding : Iterables.limit(bindings, DUPLICATE_SIZE_LIMIT)) {
+      builder.append('\n');
+      for (int i = 0; i < indentLevel; i++) {
+        builder.append(INDENT);
+      }
+      builder.append(formatBinding(binding));
+    }
+    int numberOfOtherBindings = bindings.size() - DUPLICATE_SIZE_LIMIT;
+    if (numberOfOtherBindings > 0) {
+      builder.append('\n');
+      for (int i = 0; i < indentLevel; i++) {
+        builder.append(INDENT);
+      }
+      builder.append("and ").append(numberOfOtherBindings).append(" other");
+    }
+    if (numberOfOtherBindings > 1) {
+      builder.append('s');
+    }
+  }
+
   @AutoValue
   abstract static class ResolvedRequest {
     abstract DependencyRequest request();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index 6700741e5..f166ca250 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -15,10 +15,15 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Equivalence;
+import com.google.common.base.Equivalence.Wrapper;
+import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Iterables;
+import com.google.common.collect.Multimaps;
 import com.google.common.collect.Ordering;
 import dagger.MapKey;
 import java.util.EnumSet;
@@ -32,6 +37,7 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.MapKeys.getMapKey;
+import static dagger.internal.codegen.MapKeys.unwrapValue;
 
 /**
  * An abstract class for a value object representing the mechanism by which a {@link Key} can be
@@ -122,17 +128,33 @@ static BindingType bindingTypeFor(Iterable<? extends ContributionBinding> bindin
    */
   static ImmutableSetMultimap<Object, ContributionBinding> indexMapBindingsByMapKey(
       Set<? extends ContributionBinding> mapBindings) {
-    ImmutableSetMultimap.Builder<Object, ContributionBinding> mapBindingsByMapKey =
-        ImmutableSetMultimap.builder();
-    for (ContributionBinding mapBinding : mapBindings) {
-      AnnotationMirror mapKey = getMapKey(mapBinding.bindingElement()).get();
-      Optional<? extends AnnotationValue> unwrappedValue = MapKeys.unwrapValue(mapKey);
-      if (unwrappedValue.isPresent()) {
-        mapBindingsByMapKey.put(unwrappedValue.get().getValue(), mapBinding);
-      } else {
-        mapBindingsByMapKey.put(mapKey, mapBinding);
-      }
-    }
-    return mapBindingsByMapKey.build();
+    return ImmutableSetMultimap.copyOf(
+        Multimaps.index(
+            mapBindings,
+            new Function<ContributionBinding, Object>() {
+              @Override
+              public Object apply(ContributionBinding mapBinding) {
+                AnnotationMirror mapKey = getMapKey(mapBinding.bindingElement()).get();
+                Optional<? extends AnnotationValue> unwrappedValue = unwrapValue(mapKey);
+                return unwrappedValue.isPresent() ? unwrappedValue.get().getValue() : mapKey;
+              }
+            }));
+  }
+
+  /**
+   * Indexes map-multibindings by map key annotation type.
+   */
+  static ImmutableSetMultimap<Wrapper<DeclaredType>, ContributionBinding>
+      indexMapBindingsByAnnotationType(Set<ContributionBinding> mapBindings) {
+    return ImmutableSetMultimap.copyOf(
+        Multimaps.index(
+            mapBindings,
+            new Function<ContributionBinding, Equivalence.Wrapper<DeclaredType>>() {
+              @Override
+              public Equivalence.Wrapper<DeclaredType> apply(ContributionBinding mapBinding) {
+                return MoreTypes.equivalence()
+                    .wrap(getMapKey(mapBinding.bindingElement()).get().getAnnotationType());
+              }
+            }));
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 39e5e8ce9..c025eb48a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -31,6 +31,7 @@
    * Common constants.
    */
   static final String INDENT = "    ";
+  static final int DUPLICATE_SIZE_LIMIT = 10;
 
   /*
    * JSR-330 errors
@@ -104,6 +105,10 @@ static String duplicateMapKeysError(String key) {
     return "The same map key is bound more than once for " + key;
   }
 
+  static String inconsistentMapKeyAnnotationsError(String key) {
+    return key + " uses more than one @MapKey annotation type";
+  }
+
   static final String PROVIDES_METHOD_RETURN_TYPE =
       "@Provides methods must either return a primitive, an array or a declared type.";
 
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
index 24bd793cf..9e7f0665f 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -216,6 +216,7 @@ public void mapBindingsWithStringKey() {
                 "",
                 "import dagger.Module;",
                 "import dagger.Provides;",
+                "import dagger.mapkeys.StringKey;",
                 "",
                 "@Module",
                 "final class MapModuleOne {",
@@ -232,6 +233,7 @@ public void mapBindingsWithStringKey() {
                 "",
                 "import dagger.Module;",
                 "import dagger.Provides;",
+                "import dagger.mapkeys.StringKey;",
                 "",
                 "@Module",
                 "final class MapModuleTwo {",
@@ -239,17 +241,6 @@ public void mapBindingsWithStringKey() {
                 "    return new LoginHandler();",
                 "  }",
                 "}");
-    JavaFileObject stringKeyFile = JavaFileObjects.forSourceLines("test.StringKey",
-        "package test;",
-        "import dagger.MapKey;",
-        "import java.lang.annotation.Retention;",
-        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-        "",
-        "@MapKey(unwrapValue = true)",
-        "@Retention(RUNTIME)",
-        "public @interface StringKey {",
-        "  String value();",
-        "}");
     JavaFileObject HandlerFile = JavaFileObjects.forSourceLines("test.Handler",
         "package test;",
         "",
@@ -359,7 +350,6 @@ public void mapBindingsWithStringKey() {
     assertAbout(javaSources())
         .that(ImmutableList.of(mapModuleOneFile,
             mapModuleTwoFile,
-            stringKeyFile,
             HandlerFile,
             LoginHandlerFile,
             AdminHandlerFile,
@@ -384,7 +374,8 @@ public void mapBindingsWithWrappedKey() {
                 "",
                 "@Module",
                 "final class MapModuleOne {",
-                "  @Provides(type = MAP) @ClassKey(Integer.class) Handler provideAdminHandler() {",
+                "  @Provides(type = MAP)",
+                "  @WrappedClassKey(Integer.class) Handler provideAdminHandler() {",
                 "    return new AdminHandler();",
                 "  }",
                 "}");
@@ -400,11 +391,12 @@ public void mapBindingsWithWrappedKey() {
                 "",
                 "@Module",
                 "final class MapModuleTwo {",
-                "  @Provides(type = MAP) @ClassKey(Long.class) Handler provideLoginHandler() {",
+                "  @Provides(type = MAP)",
+                "  @WrappedClassKey(Long.class) Handler provideLoginHandler() {",
                 "    return new LoginHandler();",
                 "  }",
                 "}");
-    JavaFileObject classKeyFile = JavaFileObjects.forSourceLines("test.ClassKey",
+    JavaFileObject wrappedClassKeyFile = JavaFileObjects.forSourceLines("test.WrappedClassKey",
         "package test;",
         "import dagger.MapKey;",
         "import java.lang.annotation.Retention;",
@@ -412,7 +404,7 @@ public void mapBindingsWithWrappedKey() {
         "",
         "@MapKey(unwrapValue = false)",
         "@Retention(RUNTIME)",
-        "public @interface ClassKey {",
+        "public @interface WrappedClassKey {",
         "  Class<?> value();",
         "}");
     JavaFileObject HandlerFile = JavaFileObjects.forSourceLines("test.Handler",
@@ -440,7 +432,7 @@ public void mapBindingsWithWrappedKey() {
         "",
         "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
         "interface TestComponent {",
-        "  Map<ClassKey, Provider<Handler>> dispatcher();",
+        "  Map<WrappedClassKey, Provider<Handler>> dispatcher();",
         "}");
     JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.DaggerTestComponent",
         "package test;",
@@ -452,10 +444,10 @@ public void mapBindingsWithWrappedKey() {
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class DaggerTestComponent implements TestComponent {",
-        "  private Provider<Handler> mapOfClassKeyAndProviderOfHandlerContribution1;",
-        "  private Provider<Handler> mapOfClassKeyAndProviderOfHandlerContribution2;",
-        "  private Provider<Map<ClassKey, Provider<Handler>>>",
-        "      mapOfClassKeyAndProviderOfHandlerProvider;",
+        "  private Provider<Handler> mapOfWrappedClassKeyAndProviderOfHandlerContribution1;",
+        "  private Provider<Handler> mapOfWrappedClassKeyAndProviderOfHandlerContribution2;",
+        "  private Provider<Map<WrappedClassKey, Provider<Handler>>>",
+        "      mapOfWrappedClassKeyAndProviderOfHandlerProvider;",
         "",
         "  private DaggerTestComponent(Builder builder) {",
         "    assert builder != null;",
@@ -471,22 +463,22 @@ public void mapBindingsWithWrappedKey() {
         "  }",
         "",
         "  private void initialize(final Builder builder) {",
-        "    this.mapOfClassKeyAndProviderOfHandlerContribution1 =",
+        "    this.mapOfWrappedClassKeyAndProviderOfHandlerContribution1 =",
         "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
-        "    this.mapOfClassKeyAndProviderOfHandlerContribution2 =",
+        "    this.mapOfWrappedClassKeyAndProviderOfHandlerContribution2 =",
         "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
-        "    this.mapOfClassKeyAndProviderOfHandlerProvider =",
-        "        MapProviderFactory.<ClassKey, Handler>builder(2)",
-        "            .put(ClassKeyCreator.createClassKey(Integer.class),",
-        "                mapOfClassKeyAndProviderOfHandlerContribution1)",
-        "            .put(ClassKeyCreator.createClassKey(Long.class),",
-        "                mapOfClassKeyAndProviderOfHandlerContribution2)",
+        "    this.mapOfWrappedClassKeyAndProviderOfHandlerProvider =",
+        "        MapProviderFactory.<WrappedClassKey, Handler>builder(2)",
+        "            .put(WrappedClassKeyCreator.createWrappedClassKey(Integer.class),",
+        "                mapOfWrappedClassKeyAndProviderOfHandlerContribution1)",
+        "            .put(WrappedClassKeyCreator.createWrappedClassKey(Long.class),",
+        "                mapOfWrappedClassKeyAndProviderOfHandlerContribution2)",
         "            .build();",
         "  }",
         "",
         "  @Override",
-        "  public Map<ClassKey, Provider<Handler>> dispatcher() {",
-        "    return mapOfClassKeyAndProviderOfHandlerProvider.get();",
+        "  public Map<WrappedClassKey, Provider<Handler>> dispatcher() {",
+        "    return mapOfWrappedClassKeyAndProviderOfHandlerProvider.get();",
         "  }",
         "",
         "  public static final class Builder {",
@@ -526,7 +518,7 @@ public void mapBindingsWithWrappedKey() {
     assertAbout(javaSources())
         .that(ImmutableList.of(mapModuleOneFile,
             mapModuleTwoFile,
-            classKeyFile,
+            wrappedClassKeyFile,
             HandlerFile,
             LoginHandlerFile,
             AdminHandlerFile,
@@ -808,6 +800,7 @@ public void mapBindingsWithDuplicateKeys() {
             "",
             "import dagger.Module;",
             "import dagger.Provides;",
+            "import dagger.mapkeys.StringKey;",
             "",
             "import static dagger.Provides.Type.MAP;",
             "",
@@ -821,19 +814,64 @@ public void mapBindingsWithDuplicateKeys() {
             "    return \"one again\";",
             "  }",
             "}");
-    JavaFileObject stringKeyFile =
+    JavaFileObject componentFile =
         JavaFileObjects.forSourceLines(
-            "test.StringKey",
+            "test.TestComponent",
             "package test;",
             "",
-            "import dagger.MapKey;",
-            "import java.lang.annotation.Retention;",
+            "import dagger.Component;",
+            "import java.util.Map;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component(modules = {MapModule.class})",
+            "interface TestComponent {",
+            "  Map<String, Object> objects();",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(module, componentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("The same map key is bound more than once")
+        .and()
+        .withErrorContaining("provideObjectForAKey()")
+        .and()
+        .withErrorContaining("provideObjectForAKeyAgain()")
+        .and()
+        .withErrorCount(1);
+  }
+
+  @Test
+  public void mapBindingsWithInconsistentKeyAnnotations() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.MapModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.mapkeys.StringKey;",
+            "",
+            "import static dagger.Provides.Type.MAP;",
+            "",
+            "@Module",
+            "final class MapModule {",
+            "  @Provides(type = MAP) @StringKey(\"AKey\") Object provideObjectForAKey() {",
+            "    return \"one\";",
+            "  }",
+            "",
+            "  @Provides(type = MAP) @StringKeyTwo(\"BKey\") Object provideObjectForBKey() {",
+            "    return \"two\";",
+            "  }",
+            "}");
+    JavaFileObject stringKeyTwoFile =
+        JavaFileObjects.forSourceLines(
+            "test.StringKeyTwo",
+            "package test;",
             "",
-            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+            "import dagger.MapKey;",
             "",
             "@MapKey(unwrapValue = true)",
-            "@Retention(RUNTIME)",
-            "public @interface StringKey {",
+            "public @interface StringKeyTwo {",
             "  String value();",
             "}");
     JavaFileObject componentFile =
@@ -843,21 +881,20 @@ public void mapBindingsWithDuplicateKeys() {
             "",
             "import dagger.Component;",
             "import java.util.Map;",
-            "import javax.inject.Provider;",
             "",
             "@Component(modules = {MapModule.class})",
             "interface TestComponent {",
             "  Map<String, Object> objects();",
             "}");
     assertAbout(javaSources())
-        .that(ImmutableList.of(module, stringKeyFile, componentFile))
+        .that(ImmutableList.of(module, stringKeyTwoFile, componentFile))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining("The same map key is bound more than once")
+        .withErrorContaining("uses more than one @MapKey annotation type")
         .and()
         .withErrorContaining("provideObjectForAKey()")
         .and()
-        .withErrorContaining("provideObjectForAKeyAgain()")
+        .withErrorContaining("provideObjectForBKey()")
         .and()
         .withErrorCount(1);
   }
