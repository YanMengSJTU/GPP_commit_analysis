diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 814314114..8331d0094 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -106,5 +106,8 @@
   static final String PROVIDES_METHOD_NOT_IN_MODULE =
       "@Provides methods can only be present within a @Module";
 
+  static final String PROVIDES_METHOD_WITH_SAME_NAME =
+      "Cannot have more than one @Provides method with the same name in a single module";
+
   private ErrorMessages() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
index 58c549dfc..8cf007e57 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
@@ -15,8 +15,17 @@
  */
 package dagger.internal.codegen;
 
+import com.google.common.collect.ImmutableListMultimap;
 import dagger.Module;
+import dagger.Provides;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map.Entry;
+import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.ElementFilter;
+
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_WITH_SAME_NAME;
 
 /**
  * A {@link Validator} for {@link Module}s.
@@ -28,7 +37,23 @@
   @Override
   public ValidationReport<TypeElement> validate(TypeElement subject) {
     ValidationReport.Builder<TypeElement> builder = ValidationReport.Builder.about(subject);
-    // TODO(gak): port the module validation
+    List<ExecutableElement> moduleMethods = ElementFilter.methodsIn(subject.getEnclosedElements());
+    ImmutableListMultimap.Builder<String, ExecutableElement> providesMethodsByName =
+        ImmutableListMultimap.builder();
+    for (ExecutableElement moduleMethod : moduleMethods) {
+      if (moduleMethod.getAnnotation(Provides.class) != null) {
+        providesMethodsByName.put(moduleMethod.getSimpleName().toString(), moduleMethod);
+      }
+    }
+    for (Entry<String, Collection<ExecutableElement>> entry :
+        providesMethodsByName.build().asMap().entrySet()) {
+      if (entry.getValue().size() > 1) {
+        for (ExecutableElement offendingMethod : entry.getValue()) {
+          builder.addItem(PROVIDES_METHOD_WITH_SAME_NAME, offendingMethod);
+        }
+      }
+    }
+    // TODO(gak): port the dagger 1 module validation
     return builder.build();
   }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleProcessorTest.java
index 939777041..6a3b885d0 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleProcessorTest.java
@@ -33,6 +33,7 @@
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RETURN_SET;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_STATIC;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_TYPE_PARAMETER;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_WITH_SAME_NAME;
 import static org.truth0.Truth.ASSERT;
 
 @RunWith(JUnit4.class)
@@ -412,4 +413,28 @@
         .compilesWithoutError()
         .and().generatesSources(factoryFile);
   }
+
+  @Test public void multipleProvidesMethodsWithSameName() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides Object provide(int i) {",
+        "    return i;",
+        "  }",
+        "",
+        "  @Provides String provide() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    ASSERT.about(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(PROVIDES_METHOD_WITH_SAME_NAME).in(moduleFile).onLine(8)
+        .and().withErrorContaining(PROVIDES_METHOD_WITH_SAME_NAME).in(moduleFile).onLine(12);
+  }
 }
