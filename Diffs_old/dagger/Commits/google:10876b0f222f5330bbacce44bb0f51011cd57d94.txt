diff --git a/compiler/src/main/java/dagger/internal/codegen/Binding.java b/compiler/src/main/java/dagger/internal/codegen/Binding.java
index dc3641ff1..2b690f6ef 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Binding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Binding.java
@@ -16,7 +16,7 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.MoreElements;
-import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSetMultimap;
 
 import javax.lang.model.element.Element;
@@ -32,6 +32,8 @@
  * @author Gregory Kick
  * @since 2.0
  */
+// TODO(gak): make a decision about whether or not to bring MembersInjectionBinding under this
+// supertype or whether to just get rid of this.
 abstract class Binding {
   /** Returns the {@link Element} instance that is responsible for declaring the binding. */
   abstract Element bindingElement();
@@ -51,12 +53,8 @@ public TypeElement visitType(TypeElement e, Void p) {
     }, null);
   }
 
-  /**
-   * The set of {@link DependencyRequest dependencies} required to satisfy this binding. For fields
-   * this will be a single element for the field and for methods this will be an element for each of
-   * the method parameters.
-   */
-  abstract ImmutableSet<DependencyRequest> dependencies();
+  /** The list of {@link DependencyRequest dependencies} required to satisfy this binding. */
+  abstract ImmutableList<DependencyRequest> dependencies();
 
   /** Returns the {@link #dependencies()} indexed by {@link Key}. */
   ImmutableSetMultimap<Key, DependencyRequest> dependenciesByKey() {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 07d85ebc7..a59c45a79 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -16,24 +16,30 @@
 package dagger.internal.codegen;
 
 import static dagger.internal.codegen.AnnotationMirrors.getAnnotationMirror;
+import static dagger.internal.codegen.DependencyRequest.Kind.MEMBERS_INJECTOR;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.LinkedHashMultimap;
+import com.google.common.collect.Maps;
 import com.google.common.collect.Queues;
 import com.google.common.collect.SetMultimap;
 import com.google.common.collect.Sets;
 
 import dagger.Component;
+import dagger.MembersInjector;
 import dagger.Module;
 import dagger.Provides;
 
 import java.util.Deque;
 import java.util.LinkedHashSet;
 import java.util.List;
+import java.util.Map;
 import java.util.Queue;
 
 import javax.lang.model.element.AnnotationMirror;
@@ -61,18 +67,10 @@
   abstract TypeElement componentDefinitionType();
 
   /**
-   * The set of {@linkplain DependencyRequest dependency requests} representing  the provision
-   * methods in the component definition.  To access the method element itself, use
-   * {@link DependencyRequest#requestElement()}.
+   * The list of {@link DependencyRequest} instances whose sources are methods on the component
+   * definition type.  These are the user-requested dependencies.
    */
-  abstract ImmutableSet<DependencyRequest> provisionRequests();
-
-  /**
-   * The set of {@linkplain DependencyRequest dependency requests} representing the members
-   * injection methods in the component definition.  To access the method element itself, use
-   * {@link DependencyRequest#requestElement()}.
-   */
-  abstract ImmutableSet<DependencyRequest> membersInjectionRequests();
+  abstract ImmutableList<DependencyRequest> interfaceRequests();
 
   /**
    * The total set of modules (those declared in {@link Component#modules} and their transitive
@@ -81,10 +79,24 @@
   abstract ImmutableSet<TypeElement> moduleDependencies();
 
   /**
-   * Returns the mapping from {@link Key} to {@link ProvisionBinding} that represents the full
-   * adjacency matrix for the object graph.
+   * Returns the mapping from {@link Key} to {@link ProvisionBinding} that
+   * (with {@link #resolvedMembersInjectionBindings}) represents the full adjacency matrix for the
+   * object graph.
+   */
+  abstract ImmutableSetMultimap<Key, ProvisionBinding> resolvedProvisionBindings();
+
+  /**
+   * Returns the mapping from {@link Key} to {@link MembersInjectionBinding} that
+   * (with {@link #resolvedProvisionBindings}) represents the full adjacency matrix for the object
+   * graph.
    */
-  abstract ImmutableSetMultimap<Key, ProvisionBinding> resolvedBindings();
+  abstract ImmutableMap<Key, MembersInjectionBinding> resolvedMembersInjectionBindings();
+
+  /**
+   * The ordering of {@link Key keys} that will allow all of the {@link Factory} and
+   * {@link MembersInjector} implementations to initialize properly.
+   */
+  abstract ImmutableList<Key> initializationOrdering();
 
   static final class Factory {
     private final Elements elements;
@@ -148,9 +160,7 @@ ComponentDescriptor create(TypeElement componentDefinitionType) {
 
       ImmutableSetMultimap<Key, ProvisionBinding> explicitBindings = bindingIndexBuilder.build();
 
-      ImmutableSet.Builder<DependencyRequest> provisionRequestsBuilder = ImmutableSet.builder();
-      ImmutableSet.Builder<DependencyRequest> membersInjectionRequestsBuilder =
-          ImmutableSet.builder();
+      ImmutableList.Builder<DependencyRequest> interfaceRequestsBuilder = ImmutableList.builder();
 
       Deque<DependencyRequest> requestsToResolve = Queues.newArrayDeque();
 
@@ -163,13 +173,15 @@ ComponentDescriptor create(TypeElement componentDefinitionType) {
               // provision method
               DependencyRequest provisionRequest =
                   dependencyRequestFactory.forComponentProvisionMethod(componentMethod);
-              provisionRequestsBuilder.add(provisionRequest);
+              interfaceRequestsBuilder.add(provisionRequest);
               requestsToResolve.addLast(provisionRequest);
               break;
             case 1:
               // members injection method
-              membersInjectionRequestsBuilder.add(
-                  dependencyRequestFactory.forComponentMembersInjectionMethod(componentMethod));
+              DependencyRequest membersInjectionRequest =
+                  dependencyRequestFactory.forComponentMembersInjectionMethod(componentMethod);
+              interfaceRequestsBuilder.add(membersInjectionRequest);
+              requestsToResolve.addLast(membersInjectionRequest);
               break;
             default:
               throw new IllegalStateException();
@@ -177,41 +189,59 @@ ComponentDescriptor create(TypeElement componentDefinitionType) {
         }
       }
 
-      SetMultimap<Key, ProvisionBinding> resolvedBindings = LinkedHashMultimap.create();
+      SetMultimap<Key, ProvisionBinding> resolvedProvisionBindings = LinkedHashMultimap.create();
+      Map<Key, MembersInjectionBinding> resolvedMembersInjectionBindings = Maps.newLinkedHashMap();
+      // TODO(gak): we're really going to need to test this ordering
+      ImmutableSet.Builder<Key> resolutionOrder = ImmutableSet.builder();
 
       for (DependencyRequest requestToResolve = requestsToResolve.pollLast();
           requestToResolve != null;
           requestToResolve = requestsToResolve.pollLast()) {
         Key key = requestToResolve.key();
-        if (!resolvedBindings.containsKey(key)) {
-          ImmutableSet<ProvisionBinding> explicitBindingsForKey = explicitBindings.get(key);
-          if (explicitBindingsForKey.isEmpty()) {
-            Optional<ProvisionBinding> injectBinding =
-                injectBindingRegistry.getBindingForKey(key);
-            if (injectBinding.isPresent()) {
-              requestsToResolve.addAll(injectBinding.get().dependencies());
-              resolvedBindings.put(key, injectBinding.get());
+        if (requestToResolve.kind().equals(MEMBERS_INJECTOR)) {
+          if (!resolvedMembersInjectionBindings.containsKey(key)) {
+            Optional<MembersInjectionBinding> binding =
+                injectBindingRegistry.getMembersInjectionBindingForKey(key);
+            if (binding.isPresent()) {
+              requestsToResolve.addAll(binding.get().dependencySet());
+              resolvedMembersInjectionBindings.put(key, binding.get());
             } else {
-              // TODO(gak): generate a factory for an @Inject dependency that wasn't run with the
-              // processor
-              throw new UnsupportedOperationException("@Injected classes that weren't run with the "
-                  + "compoenent processor are (briefly) unsupported.");
+              // check and generate.
             }
-          } else {
-            resolvedBindings.putAll(key, explicitBindingsForKey);
           }
-          for (ProvisionBinding binding : explicitBindingsForKey) {
-            requestsToResolve.addAll(binding.dependencies());
+        } else { // all other requests are provision requests
+          if (!resolvedProvisionBindings.containsKey(key)) {
+            ImmutableSet<ProvisionBinding> explicitBindingsForKey = explicitBindings.get(key);
+            if (explicitBindingsForKey.isEmpty()) {
+              Optional<ProvisionBinding> injectBinding =
+                  injectBindingRegistry.getProvisionBindingForKey(key);
+              if (injectBinding.isPresent()) {
+                requestsToResolve.addAll(injectBinding.get().dependencies());
+                resolvedProvisionBindings.put(key, injectBinding.get());
+              } else {
+                // TODO(gak): support this
+                throw new UnsupportedOperationException(
+                    "@Injected classes that weren't run with the compoenent processor are "
+                    + "(briefly) unsupported: " + key);
+              }
+            } else {
+              resolvedProvisionBindings.putAll(key, explicitBindingsForKey);
+            }
+            for (ProvisionBinding binding : explicitBindingsForKey) {
+              requestsToResolve.addAll(binding.dependencies());
+            }
           }
         }
+        resolutionOrder.add(key);
       }
 
       return new AutoValue_ComponentDescriptor(
           componentDefinitionType,
-          provisionRequestsBuilder.build(),
-          membersInjectionRequestsBuilder.build(),
+          interfaceRequestsBuilder.build(),
           moduleTypes,
-          ImmutableSetMultimap.copyOf(resolvedBindings));
+          ImmutableSetMultimap.copyOf(resolvedProvisionBindings),
+          ImmutableMap.copyOf(resolvedMembersInjectionBindings),
+          resolutionOrder.build().asList().reverse());
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 630b8f16a..a0d4c9909 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -16,19 +16,24 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.Preconditions.checkNotNull;
 import static com.squareup.javawriter.JavaWriter.stringLiteral;
 import static dagger.Provides.Type.SET;
 import static dagger.Provides.Type.SET_VALUES;
+import static dagger.internal.codegen.DependencyRequest.Kind.MEMBERS_INJECTOR;
 import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.SourceFiles.collectImportsFromDependencies;
 import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
 import static dagger.internal.codegen.SourceFiles.flattenVariableMap;
+import static dagger.internal.codegen.SourceFiles.generateMembersInjectorNamesForBindings;
 import static dagger.internal.codegen.SourceFiles.generateProviderNamesForBindings;
+import static dagger.internal.codegen.SourceFiles.membersInjectorNameForMembersInjectionBinding;
 import static dagger.internal.codegen.SourceFiles.providerUsageStatement;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.type.TypeKind.VOID;
 
 import com.google.common.base.CaseFormat;
 import com.google.common.base.Function;
@@ -36,10 +41,10 @@
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
 import com.google.common.collect.Collections2;
-import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableBiMap;
 import com.google.common.collect.ImmutableCollection;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.ImmutableSortedSet;
@@ -50,6 +55,7 @@
 import com.squareup.javawriter.JavaWriter;
 
 import dagger.Component;
+import dagger.MembersInjector;
 import dagger.internal.SetFactory;
 
 import java.io.IOException;
@@ -64,7 +70,13 @@
 import javax.inject.Provider;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.Name;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
 /**
  * Generates the implementation of the abstract types annotated with {@link Component}.
@@ -73,11 +85,13 @@
  * @since 2.0
  */
 final class ComponentGenerator extends SourceFileGenerator<ComponentDescriptor> {
-  private final ProviderTypeRepository providerTypeRepository;
+  private final Elements elements;
+  private final Types types;
 
-  ComponentGenerator(Filer filer, ProviderTypeRepository providerTypeRepository) {
+  ComponentGenerator(Filer filer, Elements elements, Types types) {
     super(filer);
-    this.providerTypeRepository = providerTypeRepository;
+    this.elements = checkNotNull(elements);
+    this.types = checkNotNull(types);
   }
 
   @Override
@@ -103,16 +117,22 @@ void write(ClassName componentName, JavaWriter writer, ComponentDescriptor input
       throws IOException {
     writer.emitPackage(componentName.packageName());
 
-    writeImports(writer, componentName, input.provisionRequests(),
-        input.resolvedBindings().values());
+    writeImports(writer, componentName, input.interfaceRequests(),
+        input.resolvedProvisionBindings().values());
 
     writer.emitAnnotation(Generated.class, stringLiteral(ComponentProcessor.class.getName()));
     writer.beginType(componentName.simpleName(), "class", EnumSet.of(PUBLIC, FINAL), null,
         input.componentDefinitionType().getQualifiedName().toString());
 
-    ImmutableSetMultimap<Key, ProvisionBinding> resolvedBindings = input.resolvedBindings();
+    ImmutableSetMultimap<Key, ProvisionBinding> resolvedProvisionBindings =
+        input.resolvedProvisionBindings();
+    ImmutableMap<Key, MembersInjectionBinding> resolvedMembersInjectionBindings =
+        input.resolvedMembersInjectionBindings();
 
-    ImmutableBiMap<Key, String> providerNames = generateProviderNamesForBindings(resolvedBindings);
+    ImmutableBiMap<Key, String> providerNames =
+        generateProviderNamesForBindings(resolvedProvisionBindings);
+    ImmutableBiMap<Key, String> membersInjectorNames =
+        generateMembersInjectorNamesForBindings(resolvedMembersInjectionBindings);
 
     ImmutableBiMap<TypeElement, String> moduleNames =
         ImmutableBiMap.copyOf(Maps.asMap(input.moduleDependencies(), Functions.compose(
@@ -125,20 +145,22 @@ void write(ClassName componentName, JavaWriter writer, ComponentDescriptor input
 
     writeModuleFields(writer, moduleNames);
     writeProviderFields(writer, providerNames);
+    writeMembersInjectorFields(writer, membersInjectorNames);
 
-    writeConstructor(writer, resolvedBindings, providerNames, moduleNames);
+    writeConstructor(writer, input.initializationOrdering(), resolvedProvisionBindings,
+        resolvedMembersInjectionBindings, providerNames, moduleNames, membersInjectorNames);
 
-    writeProvisionMethods(writer, input.provisionRequests(), providerNames);
+    writeInterfaceMethods(writer, input.interfaceRequests(), providerNames, membersInjectorNames);
 
     writer.endType();
   }
 
   private void writeImports(JavaWriter writer, ClassName factoryClassName,
-      ImmutableSet<DependencyRequest> provisionRequests,
+      ImmutableList<DependencyRequest> interfaceRequests,
       ImmutableCollection<ProvisionBinding> bindings) throws IOException {
     ImmutableSortedSet.Builder<ClassName> importsBuilder =
         ImmutableSortedSet.<ClassName>naturalOrder()
-            .addAll(collectImportsFromDependencies(factoryClassName, provisionRequests))
+            .addAll(collectImportsFromDependencies(factoryClassName, interfaceRequests))
             .add(ClassName.fromClass(Generated.class))
             .add(ClassName.fromClass(Provider.class));
     for (ProvisionBinding binding : bindings) {
@@ -177,10 +199,25 @@ private void writeProviderFields(JavaWriter writer, ImmutableBiMap<Key, String>
     writer.emitEmptyLine();
   }
 
+  private void writeMembersInjectorFields(JavaWriter writer,
+      ImmutableBiMap<Key, String> membersInjectorNames) throws IOException {
+    for (Entry<Key, String> providerEntry : membersInjectorNames.entrySet()) {
+      Key key = providerEntry.getKey();
+      // TODO(gak): provide more elaborate information about which requests relate
+      writer.emitJavadoc(key.toString())
+          .emitField(membersInjectorTypeString(key), providerEntry.getValue(),
+              EnumSet.of(PRIVATE, FINAL));
+    }
+    writer.emitEmptyLine();
+  }
+
   private void writeConstructor(final JavaWriter writer,
-      ImmutableSetMultimap<Key, ProvisionBinding> resolvedBindings,
+      ImmutableList<Key> initializationOrdering,
+      ImmutableSetMultimap<Key, ProvisionBinding> resolvedProvisionBindings,
+      ImmutableMap<Key, MembersInjectionBinding> resolvedMembersInjectionBindings,
       ImmutableBiMap<Key, String> providerNames,
-      ImmutableBiMap<TypeElement, String> moduleNames)
+      ImmutableBiMap<TypeElement, String> moduleNames,
+      ImmutableBiMap<Key, String> membersInjectorNames)
           throws IOException {
     Map<String, String> variableMap =
         Maps.transformValues(moduleNames.inverse(), new Function<TypeElement, String>() {
@@ -199,23 +236,34 @@ public String apply(TypeElement input) {
       writer.emitStatement("this.%1$s = %1$s", variableName);
     }
 
-    for (Entry<String, Key> providerFieldEntry
-        : Lists.reverse(providerNames.inverse().entrySet().asList())) {
-      Set<ProvisionBinding> bindings = resolvedBindings.get(providerFieldEntry.getValue());
-      if (ProvisionBinding.isSetBindingCollection(bindings)) {
-        ImmutableList.Builder<String> setFactoryParameters = ImmutableList.builder();
-        for (ProvisionBinding binding : bindings) {
-          setFactoryParameters.add(
-              initializeFactoryForBinding(writer, binding, moduleNames, providerNames));
-        }
-        writer.emitStatement("this.%s = SetFactory.create(%n%s)",
-            providerFieldEntry.getKey(),
-            Joiner.on(",\n").join(setFactoryParameters.build()));
-      } else {
-        ProvisionBinding binding = Iterables.getOnlyElement(bindings);
+    for (Key key : initializationOrdering) {
+      // first members injectors
+      if (resolvedMembersInjectionBindings.containsKey(key)) {
         writer.emitStatement("this.%s = %s",
-            providerFieldEntry.getKey(),
-            initializeFactoryForBinding(writer, binding, moduleNames, providerNames));
+            membersInjectorNames.get(key),
+            initializeMembersInjectorForBinding(writer, resolvedMembersInjectionBindings.get(key),
+                providerNames, membersInjectorNames));
+      }
+
+      // then provisions
+      if (resolvedProvisionBindings.containsKey(key)) {
+        Set<ProvisionBinding> bindings = resolvedProvisionBindings.get(key);
+        if (ProvisionBinding.isSetBindingCollection(bindings)) {
+          ImmutableList.Builder<String> setFactoryParameters = ImmutableList.builder();
+          for (ProvisionBinding binding : bindings) {
+            setFactoryParameters.add(initializeFactoryForBinding(
+                writer, binding, moduleNames, providerNames,membersInjectorNames));
+          }
+          writer.emitStatement("this.%s = SetFactory.create(%n%s)",
+              providerNames.get(key),
+              Joiner.on(",\n").join(setFactoryParameters.build()));
+        } else {
+          ProvisionBinding binding = Iterables.getOnlyElement(bindings);
+          writer.emitStatement("this.%s = %s",
+              providerNames.get(key),
+              initializeFactoryForBinding(
+                  writer, binding, moduleNames, providerNames, membersInjectorNames));
+        }
       }
     }
 
@@ -224,39 +272,101 @@ public String apply(TypeElement input) {
 
   private static String initializeFactoryForBinding(JavaWriter writer, ProvisionBinding binding,
       ImmutableBiMap<TypeElement, String> moduleNames,
-      ImmutableBiMap<Key, String> providerNames) {
+      ImmutableBiMap<Key, String> providerNames,
+      ImmutableBiMap<Key, String> membersInjectorNames) {
     List<String> parameters = Lists.newArrayListWithCapacity(binding.dependencies().size() + 1);
     if (binding.bindingKind().equals(PROVISION)) {
-      parameters.add(moduleNames.get(binding.bindingElement().getEnclosingElement()));
+      parameters.add(moduleNames.get(binding.bindingTypeElement()));
     }
-    FluentIterable.from(binding.dependenciesByKey().keySet())
-        .transform(Functions.forMap(providerNames))
-        .copyInto(parameters);
+    parameters.addAll(
+        getDependencyParameters(binding.dependencies(), providerNames, membersInjectorNames));
     return String.format("new %s(%s)",
         writer.compressType(factoryNameForProvisionBinding(binding).toString()),
         Joiner.on(", ").join(parameters));
   }
 
-  private void writeProvisionMethods(JavaWriter writer,
-      ImmutableSet<DependencyRequest> provisionRequests,
-      ImmutableBiMap<Key, String> providerNames) throws IOException {
-    for (DependencyRequest provisionRequest : provisionRequests) {
-      ExecutableElement requestElement = (ExecutableElement) provisionRequest.requestElement();
-      writer.emitAnnotation(Override.class)
-          .beginMethod(Util.typeToString(requestElement.getReturnType()),
-              requestElement.getSimpleName().toString(),
-              Sets.difference(requestElement.getModifiers(), EnumSet.of(ABSTRACT)));
-
-      String providerName = providerNames.get(provisionRequest.key());
-
-      // look up the provider in the Key->name map and invoke.  Done.
-      writer.emitStatement("return "
-          + providerUsageStatement(providerName, provisionRequest.kind()));
+  private static String initializeMembersInjectorForBinding(JavaWriter writer,
+      MembersInjectionBinding binding,
+      ImmutableBiMap<Key, String> providerNames,
+      ImmutableBiMap<Key, String> membersInjectorNames) {
+    List<String> parameters = getDependencyParameters(binding.dependencySet(),
+        providerNames, membersInjectorNames);
+    return String.format("new %s(%s)",
+        writer.compressType(membersInjectorNameForMembersInjectionBinding(binding).toString()),
+        Joiner.on(", ").join(parameters));
+  }
+
+  private static List<String> getDependencyParameters(Iterable<DependencyRequest> dependencies,
+      ImmutableBiMap<Key, String> providerNames,
+      ImmutableBiMap<Key, String> membersInjectorNames) {
+    ImmutableList.Builder<String> parameters = ImmutableList.builder();
+    for (DependencyRequest dependency : dependencies) {
+        parameters.add(dependency.kind().equals(MEMBERS_INJECTOR)
+            ? membersInjectorNames.get(dependency.key())
+            : providerNames.get(dependency.key()));
+    }
+    return parameters.build();
+  }
+
+  private void writeInterfaceMethods(JavaWriter writer,
+      ImmutableList<DependencyRequest> interfaceRequests,
+      ImmutableBiMap<Key, String> providerNames,
+      ImmutableBiMap<Key, String> membersInjectorNames) throws IOException {
+    for (DependencyRequest interfaceRequest : interfaceRequests) {
+      ExecutableElement requestElement = (ExecutableElement) interfaceRequest.requestElement();
+      beginMethodOverride(writer, requestElement);
+      if (interfaceRequest.kind().equals(MEMBERS_INJECTOR)) {
+        String membersInjectorName = membersInjectorNames.get(interfaceRequest.key());
+        Name parameterName =
+            Iterables.getOnlyElement(requestElement.getParameters()).getSimpleName();
+        writer.emitStatement("%s.injectMembers(%s)", membersInjectorName, parameterName);
+        if (!requestElement.getReturnType().getKind().equals(VOID)) {
+          writer.emitStatement("return %s", parameterName);
+        }
+      } else {
+        // provision requests
+        String providerName = providerNames.get(interfaceRequest.key());
+
+        // look up the provider in the Key->name map and invoke.  Done.
+        writer.emitStatement("return "
+            + providerUsageStatement(providerName, interfaceRequest.kind()));
+      }
       writer.endMethod();
     }
   }
 
+  private JavaWriter beginMethodOverride(JavaWriter writer, ExecutableElement methodElement)
+      throws IOException {
+    String returnTypeString = methodElement.getReturnType().getKind().equals(VOID)
+        ? "void"
+        : writer.compressType(Util.typeToString(methodElement.getReturnType()));
+    String methodName = methodElement.getSimpleName().toString();
+    Set<Modifier> modifiers = Sets.difference(methodElement.getModifiers(), EnumSet.of(ABSTRACT));
+    ImmutableList.Builder<String> parametersBuilder = ImmutableList.builder();
+    for (VariableElement parameterElement : methodElement.getParameters()) {
+      parametersBuilder.add(writer.compressType(Util.typeToString(parameterElement.asType())),
+          parameterElement.getSimpleName().toString());
+    }
+    ImmutableList.Builder<String> thrownTypesBuilder = ImmutableList.builder();
+    for (TypeMirror thrownTypeMirror : methodElement.getThrownTypes()) {
+      thrownTypesBuilder.add(writer.compressType(Util.typeToString(thrownTypeMirror)));
+    }
+    return writer.emitAnnotation(Override.class)
+        .beginMethod(
+            returnTypeString,
+            methodName,
+            modifiers,
+            parametersBuilder.build(),
+            thrownTypesBuilder.build());
+  }
+
   private String providerTypeString(Key key) {
-    return Util.typeToString(providerTypeRepository.getProviderType(key));
+    return Util.typeToString(types.getDeclaredType(
+        elements.getTypeElement(Provider.class.getCanonicalName()), key.type()));
+  }
+
+  private String membersInjectorTypeString(Key key) {
+    return Util.typeToString(types.getDeclaredType(
+        elements.getTypeElement(MembersInjector.class.getCanonicalName()), key.type()));
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 11fd1a368..bdba18940 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -23,6 +23,7 @@
 import dagger.Component;
 import dagger.Module;
 import dagger.Provides;
+import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
 
 import java.util.Set;
 
@@ -75,7 +76,6 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
     ProvidesMethodValidator providesMethodValidator = new ProvidesMethodValidator(elements);
     ComponentValidator componentValidator = new ComponentValidator(elements);
 
-    ProviderTypeRepository providerTypeRepository = new ProviderTypeRepository(elements, types);
     InjectBindingRegistry injectBindingRegistry = new InjectBindingRegistry();
 
     Key.Factory keyFactory = new Key.Factory(types, elements);
@@ -83,16 +83,16 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
         new DependencyRequest.Factory(elements, types);
     ProvisionBinding.Factory provisionBindingFactory =
         new ProvisionBinding.Factory(keyFactory, dependencyRequestFactory);
-    MembersInjectionBinding.Factory methodInjectionBindingFactory =
-        new MembersInjectionBinding.Factory(dependencyRequestFactory);
+    InjectionSite.Factory injectionSiteFactory =
+        new InjectionSite.Factory(dependencyRequestFactory);
     ComponentDescriptor.Factory componentDescriptorFactory =
         new ComponentDescriptor.Factory(elements, types, injectBindingRegistry,
             provisionBindingFactory, dependencyRequestFactory);
 
-    FactoryGenerator factoryGenerator = new FactoryGenerator(filer, providerTypeRepository);
+    FactoryGenerator factoryGenerator = new FactoryGenerator(filer, elements, types);
     MembersInjectorGenerator membersInjectorGenerator =
-        new MembersInjectorGenerator(filer, providerTypeRepository);
-    ComponentGenerator componentGenerator = new ComponentGenerator(filer, providerTypeRepository);
+        new MembersInjectorGenerator(filer, elements, types);
+    ComponentGenerator componentGenerator = new ComponentGenerator(filer, elements, types);
 
     this.processingSteps = ImmutableList.<ProcessingStep>of(
         new InjectProcessingStep(
@@ -102,7 +102,7 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
             injectMethodValidator,
             provisionBindingFactory,
             factoryGenerator,
-            methodInjectionBindingFactory,
+            injectionSiteFactory,
             membersInjectorGenerator,
             injectBindingRegistry),
         new ModuleProcesssingStep(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
index c28e21e02..9c3cb1586 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
@@ -62,7 +62,7 @@
         ConfigurationAnnotations.getComponentModules(elements, componentMirror);
 
     // TODO(gak): make unused modules an error
-    for (TypeMirror moduleType: moduleTypes) {
+    for (TypeMirror moduleType : moduleTypes) {
       moduleType.accept(new SimpleTypeVisitor6<Void, Void>() {
         @Override
         protected Void defaultAction(TypeMirror e, Void p) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index 0cb323c17..6cdbaf7ba 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -22,7 +22,7 @@
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
 
 import dagger.Lazy;
@@ -60,6 +60,8 @@
     PROVIDER,
     /** A request for a {@link Lazy}.  E.g.: {@code Lazy<Blah>} */
     LAZY,
+    /** A request for a {@link MembersInjector}.  E.g.: {@code MembersInjector<Blah>} */
+    MEMBERS_INJECTOR,
   }
 
   abstract Kind kind();
@@ -75,7 +77,7 @@
       this.types = types;
     }
 
-    ImmutableSet<DependencyRequest> forRequiredVariables(
+    ImmutableList<DependencyRequest> forRequiredVariables(
         List<? extends VariableElement> variables) {
       return FluentIterable.from(variables)
           .transform(new Function<VariableElement, DependencyRequest>() {
@@ -83,7 +85,7 @@
               return forRequiredVariable(input);
             }
           })
-          .toSet();
+          .toList();
     }
 
     DependencyRequest forRequiredVariable(VariableElement variableElement) {
@@ -102,14 +104,13 @@ DependencyRequest forComponentProvisionMethod(ExecutableElement provisionMethod)
 
     DependencyRequest forComponentMembersInjectionMethod(ExecutableElement membersInjectionMethod) {
       checkNotNull(membersInjectionMethod);
-      DeclaredType membersInjectorType = types.getDeclaredType(
-          elements.getTypeElement(MembersInjector.class.getCanonicalName()),
-          Iterables.getOnlyElement(membersInjectionMethod.getParameters()).asType());
-      // this is where we need to wrap it in a MembersInjector
       Optional<AnnotationMirror> qualifier =
           InjectionAnnotations.getQualifier(membersInjectionMethod);
       checkArgument(!qualifier.isPresent());
-      return newDependencyRequest(membersInjectionMethod, membersInjectorType, qualifier);
+      return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR,
+          Key.create(qualifier,
+              Iterables.getOnlyElement(membersInjectionMethod.getParameters()).asType()),
+          membersInjectionMethod);
     }
 
     private DependencyRequest newDependencyRequest(Element requestElement, TypeMirror type,
@@ -126,6 +127,13 @@ private DependencyRequest newDependencyRequest(Element requestElement, TypeMirro
         return new AutoValue_DependencyRequest(Kind.LAZY,
             Key.create(qualifier, Iterables.getOnlyElement(lazyType.getTypeArguments())),
             requestElement);
+      } else if (elements.getTypeElement(MembersInjector.class.getCanonicalName())
+          .equals(types.asElement(type))) {
+        checkArgument(!qualifier.isPresent());
+        DeclaredType membersInjectorType = (DeclaredType) type;
+        return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR,
+            Key.create(qualifier, Iterables.getOnlyElement(membersInjectorType.getTypeArguments())),
+            requestElement);
       } else {
         return new AutoValue_DependencyRequest(Kind.INSTANCE, Key.create(qualifier, type),
             requestElement);
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 0e8d8a0bd..089dadb66 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkNotNull;
 import static com.squareup.javawriter.JavaWriter.stringLiteral;
 import static com.squareup.javawriter.JavaWriter.type;
 import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
@@ -40,22 +41,26 @@
 import com.google.common.collect.ImmutableSortedSet;
 import com.google.common.collect.Maps;
 import com.squareup.javawriter.JavaWriter;
+
 import dagger.Factory;
 import dagger.MembersInjector;
 import dagger.Provides;
+
 import java.io.IOException;
-import java.util.ArrayList;
 import java.util.Collections;
 import java.util.EnumSet;
-import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
+
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
 import javax.inject.Inject;
+import javax.inject.Provider;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
 /**
  * Generates {@link Factory} implementations from {@link ProvisionBinding} instances for
@@ -65,11 +70,13 @@
  * @since 2.0
  */
 final class FactoryGenerator extends SourceFileGenerator<ProvisionBinding> {
-  private final ProviderTypeRepository providerTypeRepository;
+  private final Elements elements;
+  private final Types types;
 
-  FactoryGenerator(Filer filer, ProviderTypeRepository providerTypeRepository) {
+  FactoryGenerator(Filer filer, Elements elements, Types types) {
     super(filer);
-    this.providerTypeRepository = providerTypeRepository;
+    this.elements = checkNotNull(elements);
+    this.types = checkNotNull(types);
   }
 
   @Override
@@ -241,6 +248,7 @@ private void writeGetMethod(JavaWriter writer, ProvisionBinding binding,
   }
 
   private String providerTypeString(Key key) {
-    return Util.typeToString(providerTypeRepository.getProviderType(key));
+    return Util.typeToString(types.getDeclaredType(
+        elements.getTypeElement(Provider.class.getCanonicalName()), key.type()));
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index 58875c286..7cd6c8421 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -26,28 +26,36 @@
 import javax.inject.Inject;
 
 /**
- * Maintains the collection of provision bindings from {@link Inject} constructors known to the
- * annotation processor.
+ * Maintains the collection of provision bindings from {@link Inject} constructors and members
+ * injection bindings from {@link Inject} fields and methods known to the annotation processor.
  *
  * @author Gregory Kick
  */
 final class InjectBindingRegistry {
-  private final Map<Key, ProvisionBinding> bindingsByKey;
+  private final Map<Key, ProvisionBinding> provisionBindingsByKey;
+  private final Map<Key, MembersInjectionBinding> membersInjectionBindingsByKey;
 
   InjectBindingRegistry() {
-    this.bindingsByKey = Maps.newLinkedHashMap();
+    this.provisionBindingsByKey = Maps.newLinkedHashMap();
+    this.membersInjectionBindingsByKey = Maps.newLinkedHashMap();
   }
 
-  boolean isRegistered(Key key) {
-    return bindingsByKey.containsKey(key);
+  void registerProvisionBinding(ProvisionBinding binding) {
+    ProvisionBinding previousValue = provisionBindingsByKey.put(binding.providedKey(), binding);
+    checkState(previousValue == null);
   }
 
-  void registerBinding(ProvisionBinding binding) {
-    ProvisionBinding previousValue = bindingsByKey.put(binding.providedKey(), binding);
+  void registerMembersInjectionBinding(MembersInjectionBinding binding) {
+    MembersInjectionBinding previousValue = membersInjectionBindingsByKey.put(
+        Key.create(binding.injectedType().asType()), binding);
     checkState(previousValue == null);
   }
 
-  Optional<ProvisionBinding> getBindingForKey(Key key) {
-    return Optional.fromNullable(bindingsByKey.get(checkNotNull(key)));
+  Optional<ProvisionBinding> getProvisionBindingForKey(Key key) {
+    return Optional.fromNullable(provisionBindingsByKey.get(checkNotNull(key)));
+  }
+
+  Optional<MembersInjectionBinding> getMembersInjectionBindingForKey(Key key) {
+    return Optional.fromNullable(membersInjectionBindingsByKey.get(checkNotNull(key)));
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
index b0f80db7d..805ba3ba7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
@@ -17,11 +17,14 @@
 
 import static javax.lang.model.SourceVersion.RELEASE_6;
 
+import com.google.auto.common.MoreElements;
 import com.google.common.base.Function;
 import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Multimaps;
 
+import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
+
 import java.util.Collection;
 import java.util.Set;
 
@@ -50,9 +53,9 @@
   private final InjectMethodValidator methodValidator;
   private final ProvisionBinding.Factory provisionBindingFactory;
   private final FactoryGenerator factoryGenerator;
-  private final MembersInjectionBinding.Factory membersInjectionBindingFactory;
+  private final InjectionSite.Factory injectionSiteFactory;
   private final MembersInjectorGenerator membersInjectorWriter;
-  private final InjectBindingRegistry factoryRegistrar;
+  private final InjectBindingRegistry injectBindingRegistry;
 
 
   InjectProcessingStep(Messager messager,
@@ -61,7 +64,7 @@
       InjectMethodValidator methodValidator,
       ProvisionBinding.Factory provisionBindingFactory,
       FactoryGenerator factoryGenerator,
-      MembersInjectionBinding.Factory membersInjectionBindingFactory,
+      InjectionSite.Factory injectionSiteFactory,
       MembersInjectorGenerator membersInjectorWriter,
       InjectBindingRegistry factoryRegistrar) {
     this.messager = messager;
@@ -70,16 +73,16 @@
     this.methodValidator = methodValidator;
     this.provisionBindingFactory = provisionBindingFactory;
     this.factoryGenerator = factoryGenerator;
-    this.membersInjectionBindingFactory = membersInjectionBindingFactory;
+    this.injectionSiteFactory = injectionSiteFactory;
     this.membersInjectorWriter = membersInjectorWriter;
-    this.factoryRegistrar = factoryRegistrar;
+    this.injectBindingRegistry = factoryRegistrar;
   }
 
   @Override
   public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
     // TODO(gak): add some error handling for bad source files
     final ImmutableSet.Builder<ProvisionBinding> provisions = ImmutableSet.builder();
-    final ImmutableSet.Builder<MembersInjectionBinding> membersInjections = ImmutableSet.builder();
+    final ImmutableSet.Builder<InjectionSite> memberInjectionSites = ImmutableSet.builder();
 
     for (Element injectElement : roundEnv.getElementsAnnotatedWith(Inject.class)) {
       injectElement.accept(
@@ -105,8 +108,7 @@ public Void visitVariableAsField(VariableElement fieldElement, Void p) {
               report.printMessagesTo(messager);
 
               if (report.isClean()) {
-                membersInjections.add(
-                    membersInjectionBindingFactory.forInjectField(fieldElement));
+                memberInjectionSites.add(injectionSiteFactory.forInjectField(fieldElement));
               }
 
               return null;
@@ -119,8 +121,7 @@ public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
               report.printMessagesTo(messager);
 
               if (report.isClean()) {
-                membersInjections.add(
-                    membersInjectionBindingFactory.forInjectMethod(methodElement));
+                memberInjectionSites.add(injectionSiteFactory.forInjectMethod(methodElement));
               }
 
               return null;
@@ -128,17 +129,19 @@ public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
           }, null);
     }
 
-    ImmutableListMultimap<TypeElement, MembersInjectionBinding> membersInjectionsByType =
-        Multimaps.index(membersInjections.build(),
-            new Function<MembersInjectionBinding, TypeElement>() {
-              @Override public TypeElement apply(MembersInjectionBinding binding) {
-                return binding.bindingTypeElement();
+    ImmutableListMultimap<TypeElement, InjectionSite> membersInjectionsByType =
+        Multimaps.index(memberInjectionSites.build(),
+            new Function<InjectionSite, TypeElement>() {
+              @Override public TypeElement apply(InjectionSite injectionSite) {
+                return MoreElements.asType(injectionSite.element().getEnclosingElement());
               }
             });
 
-    for (Collection<MembersInjectionBinding> bindings : membersInjectionsByType.asMap().values()) {
+    for (Collection<InjectionSite> injectionSites : membersInjectionsByType.asMap().values()) {
       try {
-        membersInjectorWriter.generate(MembersInjectorDescriptor.create(bindings));
+        MembersInjectionBinding binding = MembersInjectionBinding.create(injectionSites);
+        membersInjectorWriter.generate(binding);
+        injectBindingRegistry.registerMembersInjectionBinding(binding);
       } catch (SourceFileGenerationException e) {
         e.printMessageTo(messager);
       }
@@ -147,7 +150,7 @@ public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
     for (ProvisionBinding binding : provisions.build()) {
       try {
         factoryGenerator.generate(binding);
-        factoryRegistrar.registerBinding(binding);
+        injectBindingRegistry.registerProvisionBinding(binding);
       } catch (SourceFileGenerationException e) {
         e.printMessageTo(messager);
       }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index 67974b3ed..229140170 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -17,80 +17,136 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
-import static javax.lang.model.element.ElementKind.FIELD;
-import static javax.lang.model.element.ElementKind.METHOD;
 
+import com.google.auto.common.MoreElements;
 import com.google.auto.value.AutoValue;
+import com.google.common.base.Function;
 import com.google.common.collect.ComparisonChain;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.ImmutableSortedSet;
+import com.google.common.collect.Iterables;
 import com.google.common.collect.Ordering;
 
+import java.util.List;
+
 import javax.inject.Inject;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 
 /**
- * A value object representing a binding for an {@link Inject} annotation on a member (as opposed to
- * a constructor). New instances should be created using an instance of the {@link Factory}.
+ * Represents the full members injection of a particular type. This does not pay attention to
+ * injected members on supertypes.
  *
  * @author Gregory Kick
  * @since 2.0
  */
 @AutoValue
-abstract class MembersInjectionBinding extends Binding {
+abstract class MembersInjectionBinding {
   /**
-   * Returns an {@link Ordering} suitable for sorting bindings into an ordering that abides by the
-   * injection ordering specified in {@link Inject}. This ordering should not be used with bindings
-   * from different {@link #bindingTypeElement() types}.
+   * Creates a {@link MembersInjectionBinding} for the given bindings.
+   *
+   * @throws IllegalArgumentException if the bindings are not all associated with the same type.
    */
-  static Ordering<MembersInjectionBinding> injectionOrdering() {
-    return INJECTION_ORDERING;
+  static MembersInjectionBinding create(Iterable<InjectionSite> injectionSites) {
+    ImmutableSortedSet<InjectionSite> injectionSiteSet =
+        ImmutableSortedSet.copyOf(INJECTION_ORDERING, injectionSites);
+    TypeElement injectedTypeElement = Iterables.getOnlyElement(FluentIterable.from(injectionSiteSet)
+        .transform(new Function<InjectionSite, TypeElement>() {
+          @Override public TypeElement apply(InjectionSite injectionSite) {
+            return MoreElements.asType(injectionSite.element().getEnclosingElement());
+          }
+        })
+        .toSet());
+    return new AutoValue_MembersInjectionBinding(injectedTypeElement, injectionSiteSet);
+  }
+
+  /** The type on which members are injected. */
+  abstract TypeElement injectedType();
+
+  /** The set of individual sites where {@link Inject} is applied. */
+  abstract ImmutableSortedSet<InjectionSite> injectionSites();
+
+  /** The total set of dependencies required by all injection sites. */
+  final ImmutableSet<DependencyRequest> dependencySet() {
+    return FluentIterable.from(injectionSites())
+        .transformAndConcat(new Function<InjectionSite, List<DependencyRequest>>() {
+          @Override public List<DependencyRequest> apply(InjectionSite input) {
+            return input.dependencies();
+          }
+        })
+        .toSet();
   }
 
-  private static final Ordering<MembersInjectionBinding> INJECTION_ORDERING =
-      new Ordering<MembersInjectionBinding>() {
+  ImmutableSetMultimap<Key, DependencyRequest> dependenciesByKey() {
+    ImmutableSetMultimap.Builder<Key, DependencyRequest> builder = ImmutableSetMultimap.builder();
+    for (DependencyRequest dependency : dependencySet()) {
+      builder.put(dependency.key(), dependency);
+    }
+    return builder.build();
+  }
+
+  private static final Ordering<InjectionSite> INJECTION_ORDERING =
+      new Ordering<InjectionSite>() {
         @Override
-        public int compare(MembersInjectionBinding left, MembersInjectionBinding right) {
+        public int compare(InjectionSite left, InjectionSite right) {
+          checkArgument(left.element().getEnclosingElement()
+              .equals(right.element().getEnclosingElement()));
           return ComparisonChain.start()
               // fields before methods
-              .compare(left.bindingElement().getKind(), right.bindingElement().getKind())
+              .compare(left.element().getKind(), right.element().getKind())
               // then sort by whichever element comes first in the parent
               // this isn't necessary, but makes the processor nice and predictable
               .compare(targetIndexInEnclosing(left), targetIndexInEnclosing(right))
               .result();
         }
+
+        private int targetIndexInEnclosing(InjectionSite injectionSite)  {
+          return injectionSite.element().getEnclosingElement().getEnclosedElements()
+              .indexOf(injectionSite.element());
+        }
       };
 
-  private static int targetIndexInEnclosing(MembersInjectionBinding binding)  {
-    return binding.bindingTypeElement().getEnclosedElements().indexOf(binding.bindingElement());
-  }
+  @AutoValue
+  abstract static class InjectionSite {
+    enum Kind {
+      FIELD,
+      METHOD,
+    }
 
-  /**
-   * A factory for creating {@link MembersInjectionBinding} instances.
-   */
-  static final class Factory {
-    private final DependencyRequest.Factory dependencyRequestFactory;
+    abstract Kind kind();
 
-    Factory(DependencyRequest.Factory dependencyRequestFactory) {
-      this.dependencyRequestFactory = checkNotNull(dependencyRequestFactory);
-    }
+    abstract Element element();
 
-    /** Returns the method injection binding for a method annotated with {@link Inject}. */
-    MembersInjectionBinding forInjectMethod(ExecutableElement methodElement) {
-      checkNotNull(methodElement);
-      checkArgument(methodElement.getKind().equals(METHOD));
-      checkArgument(methodElement.getAnnotation(Inject.class) != null);
-      return new AutoValue_MembersInjectionBinding(methodElement,
-          dependencyRequestFactory.forRequiredVariables(methodElement.getParameters()));
-    }
+    abstract ImmutableList<DependencyRequest> dependencies();
+
+    static final class Factory {
+      private final DependencyRequest.Factory dependencyRequestFactory;
+
+      Factory(DependencyRequest.Factory dependencyRequestFactory) {
+        this.dependencyRequestFactory = checkNotNull(dependencyRequestFactory);
+      }
+
+      InjectionSite forInjectMethod(ExecutableElement methodElement) {
+        checkNotNull(methodElement);
+        checkArgument(methodElement.getKind().equals(ElementKind.METHOD));
+        checkArgument(methodElement.getAnnotation(Inject.class) != null);
+        return new AutoValue_MembersInjectionBinding_InjectionSite(Kind.METHOD, methodElement,
+            dependencyRequestFactory.forRequiredVariables(methodElement.getParameters()));
+      }
 
-    /** Returns the field injection binding for a field annotated with {@link Inject}. */
-    MembersInjectionBinding forInjectField(VariableElement fieldElement) {
-      checkNotNull(fieldElement);
-      checkArgument(fieldElement.getKind().equals(FIELD));
-      checkArgument(fieldElement.getAnnotation(Inject.class) != null);
-      return new AutoValue_MembersInjectionBinding(fieldElement,
-          ImmutableSet.of(dependencyRequestFactory.forRequiredVariable(fieldElement)));
+      InjectionSite forInjectField(VariableElement fieldElement) {
+        checkNotNull(fieldElement);
+        checkArgument(fieldElement.getKind().equals(ElementKind.FIELD));
+        checkArgument(fieldElement.getAnnotation(Inject.class) != null);
+        return new AutoValue_MembersInjectionBinding_InjectionSite(Kind.FIELD, fieldElement,
+            ImmutableList.of(dependencyRequestFactory.forRequiredVariable(fieldElement)));
+      }
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorDescriptor.java
deleted file mode 100644
index ed0640340..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorDescriptor.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.auto.value.AutoValue;
-import com.google.common.base.Function;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableSortedSet;
-import com.google.common.collect.Iterables;
-
-import javax.lang.model.element.TypeElement;
-
-/**
- * Represents the collection of {@link MembersInjectionBinding} instances that represent the total
- * set of bindings for a single class.
- *
- * @author Gregory Kick
- * @since 2.0
- */
-@AutoValue
-abstract class MembersInjectorDescriptor {
-  abstract ImmutableSortedSet<MembersInjectionBinding> bindings();
-  abstract TypeElement injectedClass();
-
-  ClassName injectedClassName() {
-    return ClassName.fromTypeElement(injectedClass());
-  }
-
-  /**
-   * Creates a {@link MembersInjectorDescriptor} for the given bindings.
-   *
-   * @throws IllegalArgumentException if the bindings are not all associated with the same type.
-   */
-  static MembersInjectorDescriptor create(Iterable<MembersInjectionBinding> bindings) {
-    ImmutableSortedSet<MembersInjectionBinding> bindingSet =
-        ImmutableSortedSet.copyOf(MembersInjectionBinding.injectionOrdering(), bindings);
-    TypeElement injectedTypeElement = Iterables.getOnlyElement(FluentIterable.from(bindings)
-        .transform(new Function<MembersInjectionBinding, TypeElement>() {
-          @Override public TypeElement apply(MembersInjectionBinding binding) {
-            return binding.bindingTypeElement();
-          }
-        })
-        .toSet());
-    return new AutoValue_MembersInjectorDescriptor(bindingSet, injectedTypeElement);
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index a92a4adb2..51655087d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -15,9 +15,9 @@
  */
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkNotNull;
 import static com.squareup.javawriter.JavaWriter.stringLiteral;
 import static com.squareup.javawriter.JavaWriter.type;
-import static dagger.internal.codegen.SourceFiles.DEPENDENCY_ORDERING;
 import static dagger.internal.codegen.SourceFiles.collectImportsFromDependencies;
 import static dagger.internal.codegen.SourceFiles.flattenVariableMap;
 import static dagger.internal.codegen.SourceFiles.generateProviderNamesForDependencies;
@@ -33,26 +33,33 @@
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableBiMap;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSortedSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Ordering;
 import com.squareup.javawriter.JavaWriter;
+
 import dagger.MembersInjector;
+import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
+
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.EnumSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
-import java.util.Set;
+
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
+import javax.inject.Provider;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.Name;
 import javax.lang.model.element.VariableElement;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
 /**
  * Generates {@link MembersInjector} implementations from {@link MembersInjectionBinding} instances.
@@ -60,52 +67,47 @@
  * @author Gregory Kick
  * @since 2.0
  */
-final class MembersInjectorGenerator extends SourceFileGenerator<MembersInjectorDescriptor> {
-  private final ProviderTypeRepository providerTypeRepository;
+final class MembersInjectorGenerator extends SourceFileGenerator<MembersInjectionBinding> {
+  private final Elements elements;
+  private final Types types;
 
-  MembersInjectorGenerator(Filer filer, ProviderTypeRepository providerTypeRepository) {
+  MembersInjectorGenerator(Filer filer, Elements elements, Types types) {
     super(filer);
-    this.providerTypeRepository = providerTypeRepository;
+    this.elements = checkNotNull(elements);
+    this.types = checkNotNull(types);
   }
 
   @Override
-  ClassName nameGeneratedType(MembersInjectorDescriptor descriptor) {
-    ClassName injectedClassName = descriptor.injectedClassName();
+  ClassName nameGeneratedType(MembersInjectionBinding binding) {
+    ClassName injectedClassName = ClassName.fromTypeElement(binding.injectedType());
     return injectedClassName.peerNamed(injectedClassName.simpleName() + "$$MembersInjector");
   }
 
   @Override
   Iterable<? extends Element> getOriginatingElements(
-      MembersInjectorDescriptor descriptor) {
-    return FluentIterable.from(descriptor.bindings())
-        .transform(new Function<MembersInjectionBinding, Element>() {
-          @Override public Element apply(MembersInjectionBinding binding) {
-            return binding.bindingElement();
+      MembersInjectionBinding binding) {
+    return FluentIterable.from(binding.injectionSites())
+        .transform(new Function<InjectionSite, Element>() {
+          @Override public Element apply(InjectionSite injectionSite) {
+            return injectionSite.element();
           }
         })
         .toSet();
   }
 
   @Override
-  Optional<? extends Element> getElementForErrorReporting(MembersInjectorDescriptor input) {
-    return Optional.of(input.injectedClass());
+  Optional<? extends Element> getElementForErrorReporting(MembersInjectionBinding binding) {
+    return Optional.of(binding.injectedType());
   }
 
   @Override
-  void write(ClassName injectorClassName, JavaWriter writer, MembersInjectorDescriptor descriptor)
+  void write(ClassName injectorClassName, JavaWriter writer, MembersInjectionBinding binding)
       throws IOException {
-    ClassName injectedClassName = descriptor.injectedClassName();
-    ImmutableSortedSet<MembersInjectionBinding> bindings = descriptor.bindings();
+    ClassName injectedClassName = ClassName.fromTypeElement(binding.injectedType());
 
     writer.emitPackage(injectedClassName.packageName());
 
-    ImmutableSortedSet<DependencyRequest> dependencies = FluentIterable.from(descriptor.bindings())
-        .transformAndConcat(new Function<MembersInjectionBinding, Set<DependencyRequest>>() {
-          @Override public Set<DependencyRequest> apply(MembersInjectionBinding input) {
-            return input.dependencies();
-          }
-        })
-        .toSortedSet(DEPENDENCY_ORDERING);
+    ImmutableSet<DependencyRequest> dependencies = binding.dependencySet();
 
     List<ClassName> importsBuilder = new ArrayList<ClassName>();
     importsBuilder.addAll(collectImportsFromDependencies(injectorClassName, dependencies));
@@ -147,20 +149,20 @@ void write(ClassName injectorClassName, JavaWriter writer, MembersInjectorDescri
             "throw new NullPointerException(\"Cannot inject members into a null reference\")")
         .endControlFlow();
 
-    for (MembersInjectionBinding binding : bindings) {
-      Element target = binding.bindingElement();
-      switch (target.getKind()) {
+    for (InjectionSite injectionSite : binding.injectionSites()) {
+      switch (injectionSite.kind()) {
         case FIELD:
-          Name fieldName = ((VariableElement) target).getSimpleName();
-          DependencyRequest singleDependency = Iterables.getOnlyElement(binding.dependencies());
+          Name fieldName = ((VariableElement) injectionSite.element()).getSimpleName();
+          DependencyRequest singleDependency =
+              Iterables.getOnlyElement(injectionSite.dependencies());
           String providerName = providerNames.get(singleDependency.key());
           writer.emitStatement("instance.%s = %s",
               fieldName, providerUsageStatement(providerName, singleDependency.kind()));
           break;
         case METHOD:
-          Name methodName = ((ExecutableElement) target).getSimpleName();
+          Name methodName = ((ExecutableElement) injectionSite.element()).getSimpleName();
           String parameterString =
-              Joiner.on(", ").join(FluentIterable.from(binding.dependencies())
+              Joiner.on(", ").join(FluentIterable.from(injectionSite.dependencies())
                   .transform(new Function<DependencyRequest, String>() {
                     @Override public String apply(DependencyRequest input) {
                       return providerUsageStatement(providerNames.get(input.key()), input.kind());
@@ -169,7 +171,7 @@ void write(ClassName injectorClassName, JavaWriter writer, MembersInjectorDescri
           writer.emitStatement("instance.%s(%s)", methodName, parameterString);
           break;
         default:
-          throw new IllegalStateException(target.getKind().toString());
+          throw new AssertionError();
       }
     }
     writer.endMethod();
@@ -210,6 +212,7 @@ private void writeConstructor(JavaWriter writer, ImmutableBiMap<Key, String> pro
   }
 
   private String providerTypeString(Key key) {
-    return Util.typeToString(providerTypeRepository.getProviderType(key));
+    return Util.typeToString(types.getDeclaredType(
+        elements.getTypeElement(Provider.class.getCanonicalName()), key.type()));
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProviderTypeRepository.java b/compiler/src/main/java/dagger/internal/codegen/ProviderTypeRepository.java
deleted file mode 100644
index 67c7b8eda..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/ProviderTypeRepository.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-
-import com.google.common.cache.CacheBuilder;
-import com.google.common.cache.CacheLoader;
-import com.google.common.cache.LoadingCache;
-
-import javax.inject.Provider;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
-
-/**
- * A simple repository for {@link Provider} {@link DeclaredType types} for a given {@link Key}. For
- * example, a key for {@code @Named("foo") Set<String>} would return the type representing
- * {@code Provider<Set<String>>}.
- *
- * @author Gregory Kick
- * @since 2.0
- */
-final class ProviderTypeRepository {
-  private final LoadingCache<Key, DeclaredType> providerTypeCache;
-
-  ProviderTypeRepository(final Elements elements, final Types types) {
-    checkNotNull(elements);
-    checkNotNull(types);
-    this.providerTypeCache = CacheBuilder.newBuilder()
-        .concurrencyLevel(1)
-        .softValues() // just to make sure we don't OOME the compiler
-        .build(new CacheLoader<Key, DeclaredType>() {
-          TypeElement providerTypeElement =
-              elements.getTypeElement(Provider.class.getCanonicalName());
-
-          @Override public DeclaredType load(Key key) {
-            return types.getDeclaredType(providerTypeElement, key.type());
-          }
-        });
-  }
-
-  DeclaredType getProviderType(Key key) {
-    checkNotNull(key);
-    return providerTypeCache.getUnchecked(key);
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 71cc0d1bf..7b9880f64 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -18,6 +18,7 @@
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 
 import com.google.common.base.CaseFormat;
+import com.google.common.base.Function;
 import com.google.common.collect.BiMap;
 import com.google.common.collect.ComparisonChain;
 import com.google.common.collect.FluentIterable;
@@ -29,6 +30,7 @@
 import com.google.common.collect.ImmutableSortedMap;
 import com.google.common.collect.ImmutableSortedSet;
 import com.google.common.collect.Iterables;
+import com.google.common.collect.Maps;
 import com.google.common.collect.Ordering;
 import com.google.common.collect.SetMultimap;
 import com.squareup.javawriter.JavaWriter;
@@ -87,6 +89,9 @@
         case PROVIDER:
           builder.add(ClassName.fromClass(Provider.class));
           break;
+        case MEMBERS_INJECTOR:
+          builder.add(ClassName.fromClass(MembersInjector.class));
+          break;
         default:
           throw new AssertionError();
       }
@@ -196,26 +201,19 @@
         name = new KeyVariableNamer().apply(entry.getKey()) + "Provider";
       } else {
         ProvisionBinding binding = Iterables.getOnlyElement(bindingsForKey);
-        switch (binding.bindingKind()) {
-          case INJECTION:
-          case PROVISION:
-            name = binding.bindingElement().accept(
-                new ElementKindVisitor6<String, Void>() {
-                  @Override
-                  public String visitExecutableAsConstructor(ExecutableElement e, Void p) {
-                    return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL,
-                        e.getEnclosingElement().getSimpleName().toString());
-                  }
+        name = binding.bindingElement().accept(
+            new ElementKindVisitor6<String, Void>() {
+              @Override
+              public String visitExecutableAsConstructor(ExecutableElement e, Void p) {
+                return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL,
+                    e.getEnclosingElement().getSimpleName().toString());
+              }
 
-                  @Override
-                  public String visitExecutableAsMethod(ExecutableElement e, Void p) {
-                    return e.getSimpleName().toString();
-                  }
-                }, null) + "Provider";
-            break;
-          default:
-            throw new AssertionError();
-        }
+              @Override
+              public String visitExecutableAsMethod(ExecutableElement e, Void p) {
+                return e.getSimpleName().toString();
+              }
+            }, null) + "Provider";
       }
       providerNames.put(entry.getKey(), name);
     }
@@ -223,6 +221,17 @@ public String visitExecutableAsMethod(ExecutableElement e, Void p) {
     return ImmutableBiMap.copyOf(ImmutableSortedMap.copyOf(providerNames.inverse())).inverse();
   }
 
+  static ImmutableBiMap<Key, String> generateMembersInjectorNamesForBindings(
+      Map<Key, MembersInjectionBinding> bindings) {
+    return ImmutableBiMap.copyOf(Maps.transformValues(bindings,
+        new Function<MembersInjectionBinding, String>() {
+          @Override public String apply(MembersInjectionBinding input) {
+            return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL,
+                input.injectedType().getSimpleName().toString()) + "MembersInjector";
+          }
+        }));
+  }
+
   static String providerUsageStatement(String providerName,
       DependencyRequest.Kind dependencyKind) {
     switch (dependencyKind) {
@@ -251,6 +260,12 @@ static ClassName factoryNameForProvisionBinding(ProvisionBinding binding) {
     }
   }
 
+  static ClassName membersInjectorNameForMembersInjectionBinding(MembersInjectionBinding binding) {
+    TypeElement injectedTypeElement = binding.injectedType();
+    ClassName injectedClassName = ClassName.fromTypeElement(injectedTypeElement);
+    return injectedClassName.peerNamed(injectedClassName.classFileName() + "$$MembersInjector");
+  }
+
   private static String factoryPrefix(ProvisionBinding binding) {
     switch (binding.bindingKind()) {
       case INJECTION:
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index 9f26ab4df..b77c8292d 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -303,4 +303,70 @@
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
   }
+
+  @Test public void membersInjection() {
+    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class SomeInjectableType {",
+        "  @Inject SomeInjectableType() {}",
+        "}");
+    JavaFileObject injectedTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectedType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class SomeInjectedType {",
+        "  @Inject SomeInjectableType injectedField;",
+        "  SomeInjectedType() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SimpleComponent {",
+        "  void inject(SomeInjectedType instance);",
+        "  SomeInjectedType injectAndReturn(SomeInjectedType instance);",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.Dagger_SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_SimpleComponent implements SimpleComponent {",
+        "  private final Provider<SomeInjectableType> someInjectableTypeProvider;",
+        "  private final MembersInjector<SomeInjectedType> someInjectedTypeMembersInjector;",
+        "",
+        "  public Dagger_SimpleComponent() {",
+        "    this.someInjectableTypeProvider = new SomeInjectableType$$Factory();",
+        "    this.someInjectedTypeMembersInjector = ",
+        "        new SomeInjectedType$$MembersInjector(someInjectableTypeProvider);",
+        "  }",
+        "",
+        "  @Override public void inject(SomeInjectedType instance) {",
+        "    someInjectedTypeMembersInjector.injectMembers(instance);",
+        "  }",
+        "",
+        "  @Override public SomeInjectedType injectAndReturn(SomeInjectedType instance) {",
+        "    someInjectedTypeMembersInjector.injectMembers(instance);",
+        "    return instance;",
+        "  }",
+        "}");
+    ASSERT.about(javaSources())
+        .that(ImmutableList.of(injectableTypeFile, injectedTypeFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
 }
