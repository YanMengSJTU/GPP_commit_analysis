diff --git a/compiler/pom.xml b/compiler/pom.xml
index 8c674618d..577481e9b 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -36,6 +36,11 @@
       <artifactId>dagger</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>dagger-producers</artifactId>
+      <version>${project.version}</version>
+    </dependency>
     <dependency>
       <groupId>com.google.auto</groupId>
       <artifactId>auto-common</artifactId>
@@ -57,7 +62,6 @@
     <dependency>
       <groupId>com.google.auto.value</groupId>
       <artifactId>auto-value</artifactId>
-      <version>1.0-SNAPSHOT</version>
       <optional>true</optional>
     </dependency>
 
diff --git a/compiler/src/it/functional-tests/pom.xml b/compiler/src/it/functional-tests/pom.xml
index 2b6ea007c..a7dbbc8b1 100644
--- a/compiler/src/it/functional-tests/pom.xml
+++ b/compiler/src/it/functional-tests/pom.xml
@@ -50,6 +50,10 @@ limitations under the License.
       <artifactId>truth</artifactId>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+    </dependency>
   </dependencies>
   <build>
     <plugins>
diff --git a/compiler/src/it/functional-tests/src/main/java/test/A.java b/compiler/src/it/functional-tests/src/main/java/test/A.java
new file mode 100644
index 000000000..030f8556c
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/A.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Inject;
+
+class A {
+  @Inject A() {}
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/B.java b/compiler/src/it/functional-tests/src/main/java/test/B.java
new file mode 100644
index 000000000..dec8e2e58
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/B.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Inject;
+
+class B {
+  @Inject B() {}
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/BoundedGenericComponent.java b/compiler/src/it/functional-tests/src/main/java/test/BoundedGenericComponent.java
new file mode 100644
index 000000000..b30522f57
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/BoundedGenericComponent.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Component;
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Set;
+
+@Component(modules = BoundedGenericModule.class)
+interface BoundedGenericComponent {
+  BoundedGenerics<Integer, ArrayList<String>, LinkedList<CharSequence>, Integer, List<Integer>>
+      bounds1();
+  BoundedGenerics<Double, LinkedList<String>, LinkedList<Comparable<String>>, Double, Set<Double>>
+      bounds2();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/BoundedGenericModule.java b/compiler/src/it/functional-tests/src/main/java/test/BoundedGenericModule.java
new file mode 100644
index 000000000..963e0325c
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/BoundedGenericModule.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Sets;
+import dagger.Module;
+import dagger.Provides;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Set;
+
+@Module
+class BoundedGenericModule {
+
+  @Provides
+  Integer provideInteger() {
+    return 1;
+  }
+
+  @Provides
+  Double provideDouble() {
+    return 2d;
+  }
+
+  @Provides
+  ArrayList<String> provideArrayListString() {
+    return Lists.newArrayList("arrayListOfString");
+  }
+
+  @Provides
+  LinkedList<String> provideLinkedListString() {
+    return BoundedGenericModule.newLinkedList("linkedListOfString");
+  }
+
+  @Provides
+  LinkedList<CharSequence> provideLinkedListCharSeq() {
+    return BoundedGenericModule.<CharSequence>newLinkedList("linkedListOfCharSeq");
+  }
+
+  @Provides
+  @SuppressWarnings("unchecked")
+  LinkedList<Comparable<String>> provideArrayListOfComparableString() {
+    return BoundedGenericModule.<Comparable<String>>newLinkedList("arrayListOfComparableOfString");
+  }
+
+  @Provides
+  List<Integer> provideListOfInteger() {
+    return Lists.newArrayList(3);
+  }
+
+  @Provides
+  Set<Double> provideSetOfDouble() {
+    return Sets.newHashSet(4d);
+  }
+
+  private static <E> LinkedList<E> newLinkedList(E... elements) {
+    LinkedList<E> list = Lists.newLinkedList();
+    Collections.addAll(list, elements);
+    return list;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/BoundedGenerics.java b/compiler/src/it/functional-tests/src/main/java/test/BoundedGenerics.java
new file mode 100644
index 000000000..e26d64351
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/BoundedGenerics.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import java.util.List;
+import javax.inject.Inject;
+
+class BoundedGenerics<A extends Number & Comparable<? super A>, 
+      B extends List<? extends CharSequence>,
+      C extends List<? super String>,
+      D extends A,
+      E extends Iterable<D>> {
+  
+  final A a;
+  final B b;
+  final C c;
+  final D d;
+  final E e;
+  
+  @Inject BoundedGenerics(A a, B b, C c, D d, E e) {
+    this.a = a;
+    this.b = b;
+    this.c = c;
+    this.d = d;
+    this.e = e;
+  }
+
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ComplexGenerics.java b/compiler/src/it/functional-tests/src/main/java/test/ComplexGenerics.java
new file mode 100644
index 000000000..e2e327494
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/ComplexGenerics.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Lazy;
+import javax.inject.Inject;
+import javax.inject.Provider;
+
+class ComplexGenerics {
+  
+  final Generic2<Generic<A>> g2ga;
+  final Lazy<Generic2<Generic<A>>> g2gaLazy;
+  final Provider<Generic2<Generic<A>>> g2gaProvider;
+  final Generic2<Generic<B>> g2gb;
+  final Lazy<Generic2<Generic<B>>> g2gbLazy;
+  final Provider<Generic2<Generic<B>>> g2gbProvider;
+  final Generic2<A> g2a;
+  final Generic<Generic2<A>> gg2a;
+  final Generic<Generic2<B>> gg2b;
+  
+  @Inject ComplexGenerics(
+      Generic2<Generic<A>> g2ga,
+      Lazy<Generic2<Generic<A>>> g2gaLazy,
+      Provider<Generic2<Generic<A>>> g2gaProvider,
+      Generic2<Generic<B>> g2gb,
+      Lazy<Generic2<Generic<B>>> g2gbLazy,
+      Provider<Generic2<Generic<B>>> g2gbProvider,
+      Generic2<A> g2a,
+      Generic<Generic2<A>> gg2a,
+      Generic<Generic2<B>> gg2b) {
+    this.g2ga = g2ga;
+    this.g2gaLazy = g2gaLazy;
+    this.g2gaProvider = g2gaProvider;
+    this.g2gb = g2gb;
+    this.g2gbLazy = g2gbLazy;
+    this.g2gbProvider = g2gbProvider;
+    this.g2a = g2a;
+    this.gg2a = gg2a;
+    this.gg2b = gg2b;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/Generic.java b/compiler/src/it/functional-tests/src/main/java/test/Generic.java
new file mode 100644
index 000000000..ee1aa0992
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/Generic.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Inject;
+
+public class Generic<T> {
+  final T t;
+
+  @Inject public Generic(T t) {
+    this.t = t;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/Generic2.java b/compiler/src/it/functional-tests/src/main/java/test/Generic2.java
new file mode 100644
index 000000000..4a56df3ec
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/Generic2.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Inject;
+
+public class Generic2<T> {
+  final T t;
+
+  @Inject Generic2(T t) {
+    this.t = t;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/GenericChild.java b/compiler/src/it/functional-tests/src/main/java/test/GenericChild.java
new file mode 100644
index 000000000..5c65dc03e
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/GenericChild.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Inject;
+
+class GenericChild<T> extends GenericParent<T, B> {
+  
+  A registeredA;
+  T registeredT;
+  
+  @Inject GenericChild() {}
+  
+  @Inject A a;
+  @Inject T t;
+  
+  @Inject void registerA(A a) { this.registeredA = a; }
+  @Inject void registerT(T t) { this.registeredT = t; }
+
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/GenericComponent.java b/compiler/src/it/functional-tests/src/main/java/test/GenericComponent.java
new file mode 100644
index 000000000..37b8881c6
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/GenericComponent.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Component;
+import test.sub.Exposed;
+import test.sub.PublicSubclass;
+
+@Component
+interface GenericComponent {
+  ReferencesGeneric referencesGeneric();
+  GenericDoubleReferences<A> doubleGenericA();
+  GenericDoubleReferences<B> doubleGenericB();
+  ComplexGenerics complexGenerics();
+  GenericNoDeps<A> noDepsA();
+  GenericNoDeps<B> noDepsB();
+  
+  void injectA(GenericChild<A> childA);
+  void injectB(GenericChild<B> childB);
+
+  Exposed exposed();
+  PublicSubclass publicSubclass();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/GenericDoubleReferences.java b/compiler/src/it/functional-tests/src/main/java/test/GenericDoubleReferences.java
new file mode 100644
index 000000000..6785c7c5f
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/GenericDoubleReferences.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Inject;
+
+class GenericDoubleReferences<T> {
+  final T t;
+  final T t2;
+  final Thing a;
+  final Thing a2;
+
+  @Inject GenericDoubleReferences(T t, Thing a, T t2, Thing a2) {
+    this.t = t;
+    this.a = a;
+    this.t2 = t2;
+    this.a2 = a2;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/GenericNoDeps.java b/compiler/src/it/functional-tests/src/main/java/test/GenericNoDeps.java
new file mode 100644
index 000000000..e065f7926
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/GenericNoDeps.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Inject;
+
+class GenericNoDeps<T> {
+  
+  @Inject GenericNoDeps() {}
+
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/GenericParent.java b/compiler/src/it/functional-tests/src/main/java/test/GenericParent.java
new file mode 100644
index 000000000..0e01f5f7e
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/GenericParent.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Inject;
+
+class GenericParent<X, Y> {
+  
+  X registeredX;
+  Y registeredY;
+  B registeredB;
+  
+  
+  @Inject GenericParent() {}
+  
+  @Inject X x;
+  @Inject Y y;
+  @Inject B b;
+  
+  @Inject void registerX(X x) { this.registeredX = x; }
+  @Inject void registerY(Y y) { this.registeredY = y; }
+  @Inject void registerB(B b) { this.registeredB = b; }
+
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ReferencesGeneric.java b/compiler/src/it/functional-tests/src/main/java/test/ReferencesGeneric.java
new file mode 100644
index 000000000..812c45d35
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/ReferencesGeneric.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Inject;
+
+class ReferencesGeneric {
+  final Generic<A> genericA;
+  
+  @Inject ReferencesGeneric(Generic<A> genericA) {
+    this.genericA = genericA;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ScopedGeneric.java b/compiler/src/it/functional-tests/src/main/java/test/ScopedGeneric.java
new file mode 100644
index 000000000..37d68e01e
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/ScopedGeneric.java
@@ -0,0 +1,12 @@
+package test;
+
+import javax.inject.Inject;
+import javax.inject.Singleton;
+
+@Singleton
+class ScopedGeneric<T> { 
+  final T t;  
+  @Inject ScopedGeneric(T t) {
+    this.t = t;
+  }  
+}
\ No newline at end of file
diff --git a/compiler/src/it/functional-tests/src/main/java/test/SingletonGenericComponent.java b/compiler/src/it/functional-tests/src/main/java/test/SingletonGenericComponent.java
new file mode 100644
index 000000000..44a2cb553
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/SingletonGenericComponent.java
@@ -0,0 +1,13 @@
+package test;
+
+import dagger.Component;
+import javax.inject.Singleton;
+
+@Singleton
+@Component
+interface SingletonGenericComponent {
+  
+  ScopedGeneric<A> scopedGenericA();
+  ScopedGeneric<B> scopedGenericB();
+
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/sub/Exposed.java b/compiler/src/it/functional-tests/src/main/java/test/sub/Exposed.java
new file mode 100644
index 000000000..9195b33f9
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/sub/Exposed.java
@@ -0,0 +1,19 @@
+package test.sub;
+
+import javax.inject.Inject;
+import test.Generic;
+import test.Generic2;
+
+public class Exposed {
+  
+  @Inject public Generic2<PackagePrivate> gpp2;
+  @Inject public Generic2<PackagePrivateContainer.PublicEnclosed> gppc2;
+
+  public Generic<PackagePrivate> gpp;
+  public Generic<PackagePrivateContainer.PublicEnclosed> gppc;
+  
+  @Inject Exposed(Generic<PackagePrivate> gpp, Generic<PackagePrivateContainer.PublicEnclosed> gppc) {
+    this.gpp = gpp;
+    this.gppc = gppc;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/sub/PackagePrivate.java b/compiler/src/it/functional-tests/src/main/java/test/sub/PackagePrivate.java
new file mode 100644
index 000000000..9af646a50
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/sub/PackagePrivate.java
@@ -0,0 +1,7 @@
+package test.sub;
+
+import javax.inject.Inject;
+
+class PackagePrivate {  
+  @Inject PackagePrivate() {}
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/sub/PackagePrivateContainer.java b/compiler/src/it/functional-tests/src/main/java/test/sub/PackagePrivateContainer.java
new file mode 100644
index 000000000..765b01504
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/sub/PackagePrivateContainer.java
@@ -0,0 +1,9 @@
+package test.sub;
+
+import javax.inject.Inject;
+
+class PackagePrivateContainer {  
+  public static class PublicEnclosed {
+    @Inject PublicEnclosed() {}
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/sub/PublicSubclass.java b/compiler/src/it/functional-tests/src/main/java/test/sub/PublicSubclass.java
new file mode 100644
index 000000000..586d55d93
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/sub/PublicSubclass.java
@@ -0,0 +1,10 @@
+package test.sub;
+
+import javax.inject.Inject;
+import test.Generic;
+
+public class PublicSubclass extends Generic<PackagePrivate> {
+  @Inject public PublicSubclass(PackagePrivate pp) {
+    super(pp);
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/sub/PublicSubclass2.java b/compiler/src/it/functional-tests/src/main/java/test/sub/PublicSubclass2.java
new file mode 100644
index 000000000..c356fa8f0
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/sub/PublicSubclass2.java
@@ -0,0 +1,10 @@
+package test.sub;
+
+import javax.inject.Inject;
+import test.Generic;
+
+public class PublicSubclass2 extends Generic<PackagePrivateContainer.PublicEnclosed> {
+  @Inject public PublicSubclass2(PackagePrivateContainer.PublicEnclosed pp) {
+    super(pp);
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/GenericTest.java b/compiler/src/it/functional-tests/src/test/java/test/GenericTest.java
new file mode 100644
index 000000000..844f3e4a8
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/GenericTest.java
@@ -0,0 +1,141 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Set;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import test.sub.Exposed;
+import test.sub.PublicSubclass;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+
+@RunWith(JUnit4.class)
+public class GenericTest {
+
+  @Test public void testGenericComponentCreate() {
+    GenericComponent component = Dagger_GenericComponent.create();
+    assertThat(component).isNotNull();
+  }
+  
+  @Test public void testGenericSimpleReferences() {
+    GenericComponent component = Dagger_GenericComponent.create();
+    assertThat(component.referencesGeneric().genericA.t).isNotNull();    
+  }
+  
+  @Test public void testGenericDoubleReferences() {
+    GenericComponent component = Dagger_GenericComponent.create();
+    GenericDoubleReferences<A> doubleA = component.doubleGenericA();
+    assertThat(doubleA.a).isNotNull();
+    assertThat(doubleA.a2).isNotNull();
+    assertThat(doubleA.t).isNotNull();
+    assertThat(doubleA.t2).isNotNull();
+
+    GenericDoubleReferences<B> doubleB = component.doubleGenericB();
+    assertThat(doubleB.a).isNotNull();
+    assertThat(doubleB.a2).isNotNull();
+    assertThat(doubleB.t).isNotNull();
+    assertThat(doubleB.t2).isNotNull();
+  }
+  
+  @Test public void complexGenerics() {
+    GenericComponent component = Dagger_GenericComponent.create();
+    // validate these can be called w/o exceptions.
+    component.complexGenerics();
+  }
+  
+  @Test public void noDepsGenerics() {
+    GenericComponent component = Dagger_GenericComponent.create();
+    // validate these can be called w/o exceptions.
+    component.noDepsA();
+    component.noDepsB();
+  }
+  
+  @Test public void boundedGenerics() {
+    BoundedGenericModule expected = new BoundedGenericModule();
+    BoundedGenericComponent component = Dagger_BoundedGenericComponent.create();
+    BoundedGenerics<Integer, ArrayList<String>, LinkedList<CharSequence>, Integer, List<Integer>>
+        b1 = component.bounds1();
+    assertEquals(expected.provideInteger(), b1.a);
+    assertEquals(expected.provideArrayListString(), b1.b);
+    assertEquals(expected.provideLinkedListCharSeq(), b1.c);
+    assertEquals(expected.provideInteger(), b1.d);
+    assertEquals(expected.provideListOfInteger(), b1.e);
+
+    BoundedGenerics<Double, LinkedList<String>, LinkedList<Comparable<String>>, Double, Set<Double>>
+        b2 = component.bounds2();
+    assertEquals(expected.provideDouble(), b2.a);
+    assertEquals(expected.provideLinkedListString(), b2.b);
+    assertEquals(expected.provideArrayListOfComparableString(), b2.c);
+    assertEquals(expected.provideDouble(), b2.d);
+    assertEquals(expected.provideSetOfDouble(), b2.e);
+  }
+  
+  @Test public void membersInjections() {
+    GenericComponent component = Dagger_GenericComponent.create();
+    GenericChild<A> childA = new GenericChild<A>();
+    component.injectA(childA);
+    assertThat(childA.a).isNotNull();
+    assertThat(childA.b).isNotNull();
+    assertThat(childA.registeredA).isNotNull();
+    assertThat(childA.registeredB).isNotNull();
+    assertThat(childA.registeredT).isNotNull();
+    assertThat(childA.registeredX).isNotNull();
+    assertThat(childA.registeredY).isNotNull();
+    
+    GenericChild<B> childB = new GenericChild<B>();
+    component.injectB(childB);
+    assertThat(childB.a).isNotNull();
+    assertThat(childB.b).isNotNull();
+    assertThat(childB.registeredA).isNotNull();
+    assertThat(childB.registeredB).isNotNull();
+    assertThat(childB.registeredT).isNotNull();
+    assertThat(childB.registeredX).isNotNull();
+    assertThat(childB.registeredY).isNotNull();
+  }
+  
+  @Test public void packagePrivateTypeParameterDependencies() {
+    GenericComponent component = Dagger_GenericComponent.create();
+    Exposed exposed = component.exposed();
+    assertThat(exposed.gpp.t).isNotNull();
+    assertThat(exposed.gpp2).isNotNull();
+  }
+  
+  @SuppressWarnings("rawtypes")
+  @Test public void publicSubclassWithPackagePrivateTypeParameterOfSuperclass() {
+    GenericComponent component = Dagger_GenericComponent.create();
+    PublicSubclass publicSubclass = component.publicSubclass();
+    assertThat(((Generic)publicSubclass).t).isNotNull();
+  }
+  
+  @Test public void singletonScopesAppliesToEachResolvedType() {
+    SingletonGenericComponent component = Dagger_SingletonGenericComponent.create();
+    ScopedGeneric<A> a = component.scopedGenericA();
+    assertThat(a).isSameAs(component.scopedGenericA());
+    assertThat(a.t).isNotNull();
+    
+    ScopedGeneric<B> b = component.scopedGenericB();
+    assertThat(b).isSameAs(component.scopedGenericB());
+    assertThat(b.t).isNotNull();
+    
+    assertThat(a).isNotSameAs(b);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java b/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java
deleted file mode 100644
index 64889e2fe..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java
+++ /dev/null
@@ -1,159 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.auto.common.MoreElements;
-import com.google.auto.common.MoreTypes;
-import com.google.common.base.Equivalence;
-import com.google.common.base.Predicate;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Maps;
-import java.lang.annotation.Annotation;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.AnnotationValue;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.ElementFilter;
-import javax.lang.model.util.Elements;
-
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.base.Preconditions.checkNotNull;
-
-/**
- * A utility class for working with {@link AnnotationMirror} instances.
- *
- * @author Gregory Kick
- */
-final class AnnotationMirrors {
-  /**
-   * Takes a {@link Map} like that returned from {@link Elements#getElementValuesWithDefaults} and
-   * key it by the member name rather than the {@link ExecutableElement}.
-   */
-  static ImmutableMap<String, AnnotationValue> simplifyAnnotationValueMap(
-      Map<? extends ExecutableElement, ? extends AnnotationValue> annotationValueMap) {
-    ImmutableMap.Builder<String, AnnotationValue> builder = ImmutableMap.builder();
-    for (Entry<? extends ExecutableElement, ? extends AnnotationValue> entry
-        : annotationValueMap.entrySet()) {
-      builder.put(entry.getKey().getSimpleName().toString(), entry.getValue());
-    }
-    return builder.build();
-  }
-
-  static ImmutableList<TypeMirror> getAttributeAsListOfTypes(AnnotationMirror annotationMirror,
-      String attributeName) {
-    checkNotNull(annotationMirror);
-    checkNotNull(attributeName);
-    ImmutableMap<String, AnnotationValue> valueMap =
-        simplifyAnnotationValueMap(getAnnotationValuesWithDefaults(annotationMirror));
-    ImmutableList.Builder<TypeMirror> builder = ImmutableList.builder();
-
-    @SuppressWarnings("unchecked") // that's the whole point of this method
-    List<? extends AnnotationValue> typeValues =
-        (List<? extends AnnotationValue>) valueMap.get(attributeName).getValue();
-    for (AnnotationValue typeValue : typeValues) {
-      builder.add((TypeMirror) typeValue.getValue());
-    }
-    return builder.build();
-  }
-
-  private static final Equivalence<AnnotationMirror> ANNOTATION_MIRROR_EQUIVALENCE =
-      new Equivalence<AnnotationMirror>() {
-        @Override
-        protected boolean doEquivalent(AnnotationMirror left, AnnotationMirror right) {
-          return MoreTypes.equivalence().equivalent(left.getAnnotationType(),
-              right.getAnnotationType()) && AnnotationValues.equivalence().pairwise().equivalent(
-              getAnnotationValuesWithDefaults(left).values(),
-              getAnnotationValuesWithDefaults(right).values());
-        }
-        @Override
-        protected int doHash(AnnotationMirror annotation) {
-          DeclaredType type = annotation.getAnnotationType();
-          Iterable<AnnotationValue> annotationValues =
-              getAnnotationValuesWithDefaults(annotation).values();
-          return Arrays.hashCode(new int[] {MoreTypes.equivalence().hash(type),
-              AnnotationValues.equivalence().pairwise().hash(annotationValues)});
-        }
-    };
-
-  /**
-   * Returns an {@link Equivalence} for {@link AnnotationMirror} as some implementations
-   * delegate equality tests to {@link Object#equals} whereas the documentation explicitly
-   * states that instance/reference equality is not the proper test.
-   *
-   * Note: The contract of this equivalence is not quite that described in the javadoc, as
-   * hash code values returned by {@link Equivalence#hash} are not the same as would
-   * be returned from {@link AnnotationMirror#hashCode}, though the proper invariants
-   * relating hashCode() and equals() hold for {@code hash(T)} and {@code equivalent(T, T)}.
-   */
-  static Equivalence<AnnotationMirror> equivalence() {
-    return ANNOTATION_MIRROR_EQUIVALENCE;
-  }
-
-  /**
-   * Returns the {@link AnnotationMirror}'s map of {@link AnnotationValue} indexed by
-   * {@link ExecutableElement}, supplying default values from the annotation if the
-   * annotation property has not been set.  This is equivalent to
-   * {@link Elements#getElementValuesWithDefaults(AnnotationMirror)} but can be called
-   * statically without an {@Elements} instance.
-   */
-  static Map<ExecutableElement, AnnotationValue> getAnnotationValuesWithDefaults(
-      AnnotationMirror annotation) {
-    Map<ExecutableElement, AnnotationValue> values = Maps.newLinkedHashMap();
-    Map<? extends ExecutableElement, ? extends AnnotationValue> declaredValues =
-        annotation.getElementValues();
-    for (ExecutableElement method :
-        ElementFilter.methodsIn(annotation.getAnnotationType().asElement().getEnclosedElements())) {
-      // Must iterate and put in this order, to ensure consistency in generated code.
-      if (declaredValues.containsKey(method)) {
-        values.put(method, declaredValues.get(method));
-      } else if (method.getDefaultValue() != null) {
-        values.put(method, method.getDefaultValue());
-      } else {
-        throw new IllegalStateException(
-            "Unset annotation value without default should never happen: "
-            + MoreElements.asType(method.getEnclosingElement()).getQualifiedName()
-            + '.' + method.getSimpleName() + "()");
-      }
-    }
-    return values;
-  }
-
-  /**
-   * Returns all {@linkplain AnnotationMirror annotations} that are present on the given
-   * {@link Element} which are themselves annotated with {@code annotationType}.
-   */
-  static ImmutableSet<? extends AnnotationMirror> getAnnotatedAnnotations(Element element,
-      final Class<? extends Annotation> annotationType) {
-    List<? extends AnnotationMirror> annotations = element.getAnnotationMirrors();
-    return FluentIterable.from(annotations)
-        .filter(new Predicate<AnnotationMirror>() {
-          @Override public boolean apply(AnnotationMirror input) {
-            return isAnnotationPresent(input.getAnnotationType().asElement(), annotationType);
-          }
-        })
-        .toSet();
-  }
-  private AnnotationMirrors() {}
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/AnnotationValues.java b/compiler/src/main/java/dagger/internal/codegen/AnnotationValues.java
deleted file mode 100644
index d578180fe..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/AnnotationValues.java
+++ /dev/null
@@ -1,127 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.auto.common.MoreTypes;
-import com.google.common.base.Equivalence;
-import java.util.List;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.AnnotationValue;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.SimpleAnnotationValueVisitor6;
-
-/**
- * A utility class for working with {@link AnnotationValue} instances.
- *
- * @author Christian Gruber
- */
-final class AnnotationValues {
-  private static final Equivalence<AnnotationValue> ANNOTATION_VALUE_EQUIVALENCE =
-      new Equivalence<AnnotationValue>() {
-        @Override protected boolean doEquivalent(AnnotationValue left, AnnotationValue right) {
-          return left.accept(new SimpleAnnotationValueVisitor6<Boolean, AnnotationValue>() {
-            // LHS is not an annotation or array of annotation values, so just test equality.
-            @Override protected Boolean defaultAction(Object left, AnnotationValue right) {
-              return left.equals(right.accept(
-                  new SimpleAnnotationValueVisitor6<Object, Void>() {
-                    @Override protected Object defaultAction(Object object, Void unused) {
-                      return object;
-                    }
-                  }, null));
-            }
-
-            // LHS is an annotation mirror so test equivalence for RHS annotation mirrors
-            // and false for other types.
-            @Override public Boolean visitAnnotation(AnnotationMirror left, AnnotationValue right) {
-              return right.accept(
-                  new SimpleAnnotationValueVisitor6<Boolean, AnnotationMirror>() {
-                    @Override protected Boolean defaultAction(Object right, AnnotationMirror left) {
-                      return false; // Not an annotation mirror, so can't be equal to such.
-                    }
-                    @Override
-                    public Boolean visitAnnotation(AnnotationMirror right, AnnotationMirror left) {
-                      return AnnotationMirrors.equivalence().equivalent(left, right);
-                    }
-                  }, left);
-            }
-
-            // LHS is a list of annotation values have to collect-test equivalences, or false
-            // for any other types.
-            @Override
-            public Boolean visitArray(List<? extends AnnotationValue> left, AnnotationValue right) {
-              return right.accept(
-                  new SimpleAnnotationValueVisitor6<Boolean, List<? extends AnnotationValue>>() {
-                    @Override protected Boolean defaultAction(
-                        Object ignored, List<? extends AnnotationValue> alsoIgnored) {
-                      return false; // Not an annotation mirror, so can't be equal to such.
-                    }
-
-                    @SuppressWarnings("unchecked") // safe covariant cast
-                    @Override public Boolean visitArray(
-                        List<? extends AnnotationValue> right ,
-                        List<? extends AnnotationValue> left) {
-                      return AnnotationValues.equivalence().pairwise().equivalent(
-                          (List<AnnotationValue>) left, (List<AnnotationValue>) right);
-                    }
-                  }, left);
-            }
-
-            @Override
-            public Boolean visitType(TypeMirror left, AnnotationValue right) {
-              return right.accept(
-                  new SimpleAnnotationValueVisitor6<Boolean, TypeMirror>() {
-                    @Override protected Boolean defaultAction(
-                        Object ignored, TypeMirror alsoIgnored) {
-                      return false; // Not an annotation mirror, so can't be equal to such.
-                    }
-
-                    @Override public Boolean visitType(TypeMirror right, TypeMirror left) {
-                      return MoreTypes.equivalence().equivalent(left, right);
-                    }
-                  }, left);
-            }
-          }, right);
-        }
-
-        @Override protected int doHash(AnnotationValue value) {
-          return value.accept(new SimpleAnnotationValueVisitor6<Integer, Void>() {
-            @Override public Integer visitAnnotation(AnnotationMirror value, Void ignore) {
-              return AnnotationMirrors.equivalence().hash(value);
-            }
-
-            @SuppressWarnings("unchecked") // safe covariant cast
-            @Override public Integer visitArray(
-                List<? extends AnnotationValue> values, Void ignore) {
-              return AnnotationValues.equivalence().pairwise().hash((List<AnnotationValue>) values);
-            }
-
-            @Override public Integer visitType(TypeMirror value, Void ignore) {
-              return MoreTypes.equivalence().hash(value);
-            }
-
-            @Override protected Integer defaultAction(Object value, Void ignored) {
-              return value.hashCode();
-            }
-          }, null);
-        }
-      };
-
-  static Equivalence<AnnotationValue> equivalence() {
-    return ANNOTATION_VALUE_EQUIVALENCE;
-  }
-
-  private AnnotationValues() {}
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Binding.java b/compiler/src/main/java/dagger/internal/codegen/Binding.java
index 88ed8b6e2..22cae1c9f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Binding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Binding.java
@@ -26,7 +26,6 @@
 import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.type.TypeVariable;
 import javax.lang.model.type.WildcardType;
 import javax.lang.model.util.SimpleElementVisitor6;
 import javax.lang.model.util.SimpleTypeVisitor6;
@@ -42,9 +41,23 @@
  * @author Gregory Kick
  * @since 2.0
  */
-// TODO(gak): make a decision about whether or not to bring MembersInjectionBinding under this
-// supertype or whether to just get rid of this.
 abstract class Binding {
+  static Optional<String> bindingPackageFor(Iterable<? extends Binding> bindings) {
+    ImmutableSet.Builder<String> bindingPackagesBuilder = ImmutableSet.builder();
+    for (Binding binding : bindings) {
+      bindingPackagesBuilder.addAll(binding.bindingPackage().asSet());
+    }
+    ImmutableSet<String> bindingPackages = bindingPackagesBuilder.build();
+    switch (bindingPackages.size()) {
+      case 0:
+        return Optional.absent();
+      case 1:
+        return Optional.of(bindingPackages.iterator().next());
+      default:
+        throw new IllegalArgumentException();
+    }
+  }
+
   /** The {@link Key} that is provided by this binding. */
   protected abstract Key key();
 
@@ -115,6 +128,10 @@ public Void visitDeclared(DeclaredType t, ImmutableSet.Builder<String> p) {
           Name qualifiedName = elementPackage.getQualifiedName();
           p.add(qualifiedName.toString());
         }
+        // Also make sure enclosing types are visible, otherwise we're fooled by
+        // class Foo { public class Bar }
+        // (Note: we can't use t.getEnclosingType() because it doesn't work!)
+        typeElement.getEnclosingElement().asType().accept(this, p);
         return null;
       }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 9ec404d94..d0c1888c0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -17,22 +17,16 @@
 
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Function;
 import com.google.common.base.Optional;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Queues;
 import dagger.Provides;
-import dagger.internal.codegen.BindingGraph.ResolvedBindings.State;
-import dagger.internal.codegen.ProvisionBinding.BindingType;
 import java.util.Deque;
 import java.util.List;
 import java.util.Map;
-import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
@@ -44,7 +38,7 @@
 import javax.lang.model.util.Types;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.collect.Iterables.getOnlyElement;
+import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentProvisionMethod;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
@@ -62,22 +56,29 @@
   abstract ComponentDescriptor componentDescriptor();
   abstract ImmutableSet<DependencyRequest> entryPoints();
   abstract ImmutableMap<TypeElement, ImmutableSet<TypeElement>> transitiveModules();
-  abstract ImmutableMap<Key, ResolvedBindings> resolvedBindings();
+  abstract ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings();
 
   @AutoValue
-  static abstract class ResolvedBindings {
-    enum State {
-      COMPLETE,
-      INCOMPLETE,
-      MULTIPLE_BINDING_TYPES,
-      DUPLICATE_BINDINGS,
-      CYCLE,
-      MALFORMED,
-      MISSING,
+  abstract static class ResolvedBindings {
+    abstract BindingKey bindingKey();
+    abstract ImmutableSet<? extends Binding> bindings();
+
+    static ResolvedBindings create(
+        BindingKey bindingKey, ImmutableSet<? extends Binding> bindings) {
+      return new AutoValue_BindingGraph_ResolvedBindings(bindingKey, bindings);
     }
 
-    abstract State state();
-    abstract ImmutableSet<? extends Binding> bindings();
+    @SuppressWarnings("unchecked")  // checked by validator
+    ImmutableSet<? extends ContributionBinding> contributionBindings() {
+      checkState(bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION));
+      return (ImmutableSet<? extends ContributionBinding>) bindings();
+    }
+
+    @SuppressWarnings("unchecked")  // checked by validator
+    ImmutableSet<? extends MembersInjectionBinding> membersInjectionBindings() {
+      checkState(bindingKey().kind().equals(BindingKey.Kind.MEMBERS_INJECTION));
+      return (ImmutableSet<? extends MembersInjectionBinding>) bindings();
+    }
   }
 
   static final class Factory {
@@ -91,9 +92,9 @@
     Factory(Elements elements,
         Types types,
         InjectBindingRegistry injectBindingRegistry,
-        dagger.internal.codegen.Key.Factory keyFactory,
-        dagger.internal.codegen.DependencyRequest.Factory dependencyRequestFactory,
-        dagger.internal.codegen.ProvisionBinding.Factory provisionBindingFactory) {
+        Key.Factory keyFactory,
+        DependencyRequest.Factory dependencyRequestFactory,
+        ProvisionBinding.Factory provisionBindingFactory) {
       this.elements = elements;
       this.types = types;
       this.injectBindingRegistry = injectBindingRegistry;
@@ -200,8 +201,8 @@ private boolean isComponentMembersInjectionMethod(ExecutableElement method) {
 
     private final class RequestResolver {
       final ImmutableSetMultimap<Key, ProvisionBinding> explicitBindings;
-      final Map<Key, ResolvedBindings> resolvedBindings;
-      final Deque<Key> cycleStack = Queues.newArrayDeque();
+      final Map<BindingKey, ResolvedBindings> resolvedBindings;
+      final Deque<BindingKey> cycleStack = Queues.newArrayDeque();
 
       RequestResolver(ImmutableSetMultimap<Key, ProvisionBinding> explicitBindings) {
         assert explicitBindings != null;
@@ -209,145 +210,82 @@ private boolean isComponentMembersInjectionMethod(ExecutableElement method) {
         this.resolvedBindings = Maps.newLinkedHashMap();
       }
 
-      State resolve(DependencyRequest request) {
-        Key requestKey = request.key();
+      ImmutableSet<? extends Binding> lookUpBindings(DependencyRequest request) {
+        BindingKey bindingKey = BindingKey.forDependencyRequest(request);
+        switch (bindingKey.kind()) {
+          case CONTRIBUTION:
+            // First, check for explicit keys (those from modules and components)
+            ImmutableSet<ProvisionBinding> explicitBindingsForKey =
+                explicitBindings.get(bindingKey.key());
+            if (explicitBindingsForKey.isEmpty()) {
+              // If the key is Map<K, V>, get its implicit binding key which is
+              // Map<K, Provider<V>>
+              Optional<Key> mapProviderKey =
+                  keyFactory.implicitMapProviderKeyFrom(bindingKey.key());
+              if (mapProviderKey.isPresent()) {
+                DependencyRequest implicitRequest =
+                    dependencyRequestFactory.forImplicitMapBinding(request, mapProviderKey.get());
+                return ImmutableSet.of(provisionBindingFactory.forImplicitMapBinding(
+                    request, implicitRequest));
+              } else {
+                // no explicit binding, look it up.
+                Optional<ProvisionBinding> provisionBinding =
+                    injectBindingRegistry.getOrFindProvisionBinding(bindingKey.key());
+                return ImmutableSet.copyOf(provisionBinding.asSet());
+              }
+            } else {
+              // If this is an explicit Map<K, V> request then add in any map binding provision
+              // methods which are implied by and must collide with explicit Map<K, V> bindings.
+              Optional<Key> underlyingMapKey =
+                  keyFactory.implicitMapProviderKeyFrom(bindingKey.key());
+              if (underlyingMapKey.isPresent()) {
+                explicitBindingsForKey = ImmutableSet.<ProvisionBinding>builder()
+                    .addAll(explicitBindingsForKey)
+                    .addAll(explicitBindings.get(underlyingMapKey.get()))
+                    .build();
+              }
+              return explicitBindingsForKey;
+            }
+          case MEMBERS_INJECTION:
+            // no explicit deps for members injection, so just look it up
+            MembersInjectionBinding membersInjectionBinding =
+                injectBindingRegistry.getOrFindMembersInjectionBinding(bindingKey.key());
+            return ImmutableSet.of(membersInjectionBinding);
+          default:
+            throw new AssertionError();
+        }
+      }
+
+      void resolve(DependencyRequest request) {
+        BindingKey bindingKey = BindingKey.forDependencyRequest(request);
 
-        ResolvedBindings previouslyResolvedBinding = resolvedBindings.get(requestKey);
+        ResolvedBindings previouslyResolvedBinding = resolvedBindings.get(bindingKey);
         if (previouslyResolvedBinding != null) {
-          return previouslyResolvedBinding.state();
+          return;
         }
 
-        if (cycleStack.contains(requestKey)) {
-          // return malformed, but don't add a resolved binding.
-          // the original request will add it with all of the other resolved deps
-          return State.CYCLE;
+        if (cycleStack.contains(bindingKey)) {
+          // We found a cycle. Don't add a resolved binding, since the original request will add it
+          // with all of the other resolved deps
+          return;
         }
 
-        cycleStack.push(requestKey);
+        cycleStack.push(bindingKey);
         try {
-          switch (request.kind()) {
-            case INSTANCE:
-            case LAZY:
-            case PROVIDER:
-              // First, check for explicit keys (those from modules and components)
-              ImmutableSet<ProvisionBinding> explicitBindingsForKey =
-                  explicitBindings.get(requestKey);
-              if (explicitBindingsForKey.isEmpty()) {
-                // If the key is Map<K, V>, get its implicit binding key which is
-                // Map<K, Provider<V>>
-                Optional<Key> mapProviderKey = keyFactory.implicitMapProviderKeyFrom(request.key());
-                if (mapProviderKey.isPresent()) {
-                  DependencyRequest implicitRequest =
-                      dependencyRequestFactory.forImplicitMapBinding(request, mapProviderKey.get());
-                  ProvisionBinding implicitBinding =
-                      provisionBindingFactory.forImplicitMapBinding(request, implicitRequest);
-                  State implicitState = resolve(implicitRequest);
-                  resolvedBindings.put(requestKey,
-                      new AutoValue_BindingGraph_ResolvedBindings(
-                          implicitState.equals(State.COMPLETE) ? State.COMPLETE : State.INCOMPLETE,
-                          ImmutableSet.of(implicitBinding)));
-                  return State.COMPLETE;
-                } else {
-                  // no explicit binding, look it up.
-                  Optional<ProvisionBinding> provisionBinding =
-                      injectBindingRegistry.getOrFindProvisionBinding(requestKey);
-                  if (provisionBinding.isPresent()) {
-                    // found a binding, resolve its deps and then mark it resolved
-                    State bindingState =
-                        resolveDependencies(provisionBinding.get().implicitDependencies());
-                    resolvedBindings.put(requestKey,
-                        new AutoValue_BindingGraph_ResolvedBindings(
-                            bindingState,
-                            ImmutableSet.copyOf(provisionBinding.asSet())));
-                    return bindingState;
-                  } else {
-                    // no explicit binding, no inject binding.  it's missing
-                    resolvedBindings.put(requestKey,
-                        new AutoValue_BindingGraph_ResolvedBindings(
-                            State.MISSING, ImmutableSet.<Binding>of()));
-                    return State.MISSING;
-                  }
-                }
-              } else {
-                // If this is an explicit Map<K, V> request then add in any map binding provision
-                // methods which are implied by and must collide with explicit Map<K, V> bindings.
-                Optional<Key> underlyingMapKey =
-                    keyFactory.implicitMapProviderKeyFrom(request.key());
-                if (underlyingMapKey.isPresent()) {
-                  explicitBindingsForKey = ImmutableSet.<ProvisionBinding>builder()
-                      .addAll(explicitBindingsForKey)
-                      .addAll(explicitBindings.get(underlyingMapKey.get()))
-                      .build();
-                }
-                ImmutableSet<DependencyRequest> allDeps =
-                    FluentIterable.from(explicitBindingsForKey)
-                        .transformAndConcat(
-                            new Function<ProvisionBinding, Set<DependencyRequest>>() {
-                              @Override
-                              public Set<DependencyRequest> apply(ProvisionBinding input) {
-                                return input.implicitDependencies();
-                              }
-                            })
-                        .toSet();
-                State bindingState = resolveDependencies(allDeps);
-                if (explicitBindingsForKey.size() > 1) {
-                  // Multiple Explicit bindings. Validate that they are multi-bindings.
-                  ImmutableListMultimap<BindingType, ProvisionBinding> bindingsByType =
-                      ProvisionBinding.bindingTypesFor(explicitBindingsForKey);
-                  if (bindingsByType.keySet().size() > 1) {
-                    resolvedBindings.put(requestKey,
-                        new AutoValue_BindingGraph_ResolvedBindings(
-                            State.MULTIPLE_BINDING_TYPES,
-                            explicitBindingsForKey));
-                    return State.MULTIPLE_BINDING_TYPES;
-                  } else if (getOnlyElement(bindingsByType.keySet()).equals(BindingType.UNIQUE)) {
-                    resolvedBindings.put(requestKey,
-                        new AutoValue_BindingGraph_ResolvedBindings(
-                            State.DUPLICATE_BINDINGS,
-                            explicitBindingsForKey));
-                    return State.DUPLICATE_BINDINGS;
-                  }
-                }
-                resolvedBindings.put(requestKey,
-                    new AutoValue_BindingGraph_ResolvedBindings(
-                        bindingState, explicitBindingsForKey));
-                return bindingState;
-              }
-            case MEMBERS_INJECTOR:
-              // no explicit deps for members injection, so just look it up
-              Optional<MembersInjectionBinding> membersInjectionBinding = Optional.fromNullable(
-                  injectBindingRegistry.getOrFindMembersInjectionBinding(requestKey));
-              if (membersInjectionBinding.isPresent()) {
-                // found a binding, resolve its deps and then mark it resolved
-                State bindingState =
-                    resolveDependencies(membersInjectionBinding.get().implicitDependencies());
-                resolvedBindings.put(requestKey,
-                    new AutoValue_BindingGraph_ResolvedBindings(
-                        bindingState,
-                        ImmutableSet.copyOf(membersInjectionBinding.asSet())));
-                return bindingState;
-              } else {
-                return State.MISSING;
-              }
-            default:
-              throw new AssertionError();
+          ImmutableSet<? extends Binding> bindings = lookUpBindings(request);
+          for (Binding binding : bindings) {
+            resolveDependencies(binding.implicitDependencies());
           }
+          resolvedBindings.put(bindingKey, ResolvedBindings.create(bindingKey, bindings));
         } finally {
           cycleStack.pop();
         }
       }
 
-      private State resolveDependencies(Iterable<DependencyRequest> dependencies) {
-        State bindingState = State.COMPLETE;
+      private void resolveDependencies(Iterable<DependencyRequest> dependencies) {
         for (DependencyRequest dependency : dependencies) {
-          State dependencyState = resolve(dependency);
-          if (dependencyState.equals(State.CYCLE)) {
-            bindingState = State.CYCLE;
-          } else if (!bindingState.equals(State.CYCLE) && !dependencyState.equals(State.COMPLETE)) {
-            bindingState = State.INCOMPLETE;
-          }
+          resolve(dependency);
         }
-        return bindingState;
       }
     }
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index e0f025a23..947a753a7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -1,10 +1,28 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package dagger.internal.codegen;
 
+import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
+import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableListMultimap;
@@ -13,118 +31,324 @@
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Ordering;
+import dagger.Component;
 import dagger.internal.codegen.BindingGraph.ResolvedBindings;
-import dagger.internal.codegen.BindingGraph.ResolvedBindings.State;
-import dagger.internal.codegen.ProvisionBinding.BindingType;
+import dagger.internal.codegen.ContributionBinding.BindingType;
+import dagger.internal.codegen.ValidationReport.Builder;
+import dagger.internal.codegen.writer.TypeNames;
+import java.util.ArrayDeque;
 import java.util.Deque;
 import java.util.Formatter;
+import java.util.HashSet;
 import java.util.LinkedList;
 import java.util.Set;
+import javax.inject.Singleton;
 import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.Name;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
+import javax.tools.Diagnostic;
 
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static com.google.auto.common.MoreTypes.isTypeOf;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ErrorMessages.INDENT;
 import static dagger.internal.codegen.ErrorMessages.REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.REQUIRES_PROVIDER_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
+import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
 
 public class BindingGraphValidator implements Validator<BindingGraph> {
+
   private final Types types;
   private final InjectBindingRegistry injectBindingRegistry;
+  private final ScopeCycleValidation disableInterComponentScopeCycles;
 
-  BindingGraphValidator(Types types, InjectBindingRegistry injectBindingRegistry) {
+  BindingGraphValidator(
+      Types types,
+      InjectBindingRegistry injectBindingRegistry,
+      ScopeCycleValidation disableInterComponentScopeCycles) {
     this.types = types;
     this.injectBindingRegistry = injectBindingRegistry;
+    this.disableInterComponentScopeCycles = disableInterComponentScopeCycles;
   }
 
   @Override
   public ValidationReport<BindingGraph> validate(final BindingGraph subject) {
     final ValidationReport.Builder<BindingGraph> reportBuilder =
         ValidationReport.Builder.about(subject);
-    ImmutableMap<Key, ResolvedBindings> resolvedBindings = subject.resolvedBindings();
+    ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings = subject.resolvedBindings();
 
     validateComponentScope(subject, reportBuilder, resolvedBindings);
+    validateDependencyScopes(subject, reportBuilder);
 
     for (DependencyRequest entryPoint : subject.entryPoints()) {
-      ResolvedBindings resolvedBinding = resolvedBindings.get(entryPoint.key());
-      if (!resolvedBinding.state().equals(State.COMPLETE)) {
-        LinkedList<DependencyRequest> requestPath = Lists.newLinkedList();
-        requestPath.push(entryPoint);
-        traversalHelper(subject, requestPath, new Traverser() {
-          @Override
-          boolean visitResolvedBinding(
-              Deque<DependencyRequest> requestPath, ResolvedBindings binding) {
-            switch (binding.state()) {
-              case COMPLETE:
-              case INCOMPLETE:
-                return true;
-              case MISSING:
-                reportMissingBinding(requestPath, reportBuilder);
-                return false;
-              case DUPLICATE_BINDINGS:
-                reportDuplicateBindings(requestPath, binding, reportBuilder);
-                return false;
-              case MULTIPLE_BINDING_TYPES:
-                reportMultipleBindingTypes(requestPath, binding, reportBuilder);
-                return false;
-              case CYCLE:
-                reportCycle(requestPath, subject, reportBuilder);
-                return false;
-              case MALFORMED:
-                return false;
-              default:
-                throw new AssertionError();
+      LinkedList<DependencyRequest> requestPath = Lists.newLinkedList();
+      requestPath.push(entryPoint);
+      traversalHelper(subject, requestPath, new Traverser() {
+        final Set<BindingKey> visitedBindings = new HashSet<>();
+
+        @Override
+        boolean visitResolvedBinding(
+            Deque<DependencyRequest> requestPath, ResolvedBindings binding) {
+          for (DependencyRequest request : Iterables.skip(requestPath, 1)) {
+            if (BindingKey.forDependencyRequest(request).equals(binding.bindingKey())) {
+              reportCycle(requestPath, subject, reportBuilder);
+              return false;
             }
           }
-        });
-      }
+
+          if (!visitedBindings.add(binding.bindingKey())) {
+            return false;
+          }
+
+          return validateResolvedBinding(requestPath, binding, reportBuilder);
+        }
+      });
     }
 
     return reportBuilder.build();
   }
 
+  /**
+   * Validates that the set of bindings resolved is consistent with the type of the binding, and
+   * returns true if the bindings are valid.
+   */
+  private boolean validateResolvedBinding(
+      Deque<DependencyRequest> requestPath,
+      ResolvedBindings resolvedBinding,
+      Builder<BindingGraph> reportBuilder) {
+    if (resolvedBinding.bindings().isEmpty()) {
+      reportMissingBinding(requestPath, reportBuilder);
+      return false;
+    }
+
+    ImmutableSet.Builder<ContributionBinding> contributionBindingsBuilder =
+        ImmutableSet.builder();
+    ImmutableSet.Builder<MembersInjectionBinding> membersInjectionBindingsBuilder =
+        ImmutableSet.builder();
+    for (Binding binding : resolvedBinding.bindings()) {
+      if (binding instanceof ContributionBinding) {
+        contributionBindingsBuilder.add((ContributionBinding) binding);
+      }
+      if (binding instanceof MembersInjectionBinding) {
+        membersInjectionBindingsBuilder.add((MembersInjectionBinding) binding);
+      }
+    }
+    ImmutableSet<ContributionBinding> contributionBindings =
+        contributionBindingsBuilder.build();
+    ImmutableSet<MembersInjectionBinding> membersInjectionBindings =
+        membersInjectionBindingsBuilder.build();
+
+    switch (resolvedBinding.bindingKey().kind()) {
+      case CONTRIBUTION:
+        if (!membersInjectionBindings.isEmpty()) {
+          throw new IllegalArgumentException(
+              "contribution binding keys should never have members injection bindings");
+        }
+        if (contributionBindings.size() <= 1) {
+          return true;
+        }
+        ImmutableListMultimap<BindingType, ContributionBinding> bindingsByType =
+            ContributionBinding.bindingTypesFor(contributionBindings);
+        if (bindingsByType.keySet().size() > 1) {
+          reportMultipleBindingTypes(requestPath, resolvedBinding, reportBuilder);
+          return false;
+        } else if (getOnlyElement(bindingsByType.keySet()).equals(BindingType.UNIQUE)) {
+          reportDuplicateBindings(requestPath, resolvedBinding, reportBuilder);
+          return false;
+        }
+        break;
+      case MEMBERS_INJECTION:
+        if (!contributionBindings.isEmpty()) {
+          throw new IllegalArgumentException(
+              "members injection binding keys should never have contribution bindings");
+        }
+        if (membersInjectionBindings.size() > 1) {
+          reportDuplicateBindings(requestPath, resolvedBinding, reportBuilder);
+          return false;
+        }
+        break;
+      default:
+        throw new AssertionError();
+    }
+    return true;
+  }
+
+  /**
+   * Validates that among the dependencies are at most one scoped dependency,
+   * that there are no cycles within the scoping chain, and that singleton
+   * components have no scoped dependencies.
+   */
+  private void validateDependencyScopes(BindingGraph subject,
+      Builder<BindingGraph> reportBuilder) {
+    ComponentDescriptor descriptor = subject.componentDescriptor();
+    Optional<AnnotationMirror> scope = subject.componentDescriptor().scope();
+    ImmutableSet<TypeElement> scopedDependencies = scopedTypesIn(descriptor.dependencies());
+    if (scope.isPresent()) {
+      // Dagger 1.x scope compatibility requires this be suppress-able.
+      if (disableInterComponentScopeCycles.diagnosticKind().isPresent()
+          && isTypeOf(Singleton.class, scope.get().getAnnotationType())) {
+        // Singleton is a special-case representing the longest lifetime, and therefore
+        // @Singleton components may not depend on scoped components
+        if (!scopedDependencies.isEmpty()) {
+          StringBuilder message = new StringBuilder(
+              "This @Singleton component cannot depend on scoped components:\n");
+          appendIndentedComponentsList(message, scopedDependencies);
+          reportBuilder.addItem(message.toString(),
+              disableInterComponentScopeCycles.diagnosticKind().get(),
+              descriptor.componentDefinitionType(),
+              descriptor.componentAnnotation());
+        }
+      } else if (scopedDependencies.size() > 1) {
+        // Scoped components may depend on at most one scoped component.
+        StringBuilder message = new StringBuilder(ErrorMessages.format(scope.get()))
+            .append(' ')
+            .append(descriptor.componentDefinitionType().getQualifiedName())
+            .append(" depends on more than one scoped component:\n");
+        appendIndentedComponentsList(message, scopedDependencies);
+        reportBuilder.addItem(message.toString(),
+            descriptor.componentDefinitionType(),
+            descriptor.componentAnnotation());
+      } else {
+        // Dagger 1.x scope compatibility requires this be suppress-able.
+        if (!disableInterComponentScopeCycles.equals(ScopeCycleValidation.NONE)) {
+          validateScopeHierarchy(descriptor.componentDefinitionType(),
+              descriptor.componentDefinitionType(),
+              reportBuilder,
+              new ArrayDeque<Equivalence.Wrapper<AnnotationMirror>>(),
+              new ArrayDeque<TypeElement>());
+        }
+      }
+    } else {
+      // Scopeless components may not depend on scoped components.
+      if (!scopedDependencies.isEmpty()) {
+        StringBuilder message =
+            new StringBuilder(descriptor.componentDefinitionType().getQualifiedName())
+                .append(" (unscoped) cannot depend on scoped components:\n");
+        appendIndentedComponentsList(message, scopedDependencies);
+        reportBuilder.addItem(message.toString(),
+            descriptor.componentDefinitionType(),
+            descriptor.componentAnnotation());
+      }
+    }
+  }
+
+  /**
+   * Append and format a list of indented component types (with their scope annotations)
+   */
+  private void appendIndentedComponentsList(StringBuilder message, Iterable<TypeElement> types) {
+    for (TypeElement scopedComponent : types) {
+      message.append(INDENT);
+      Optional<AnnotationMirror> scope = getScopeAnnotation(scopedComponent);
+      if (scope.isPresent()) {
+        message.append(ErrorMessages.format(scope.get())).append(' ');
+      }
+      message.append(stripCommonTypePrefixes(scopedComponent.getQualifiedName().toString()))
+          .append('\n');
+    }
+  }
+
+  /**
+   * Returns a set of type elements containing only those found in the input set that have
+   * a scoping annotation.
+   */
+  private ImmutableSet<TypeElement> scopedTypesIn(Set<TypeElement> types) {
+    return FluentIterable.from(types).filter(new Predicate<TypeElement>() {
+      @Override public boolean apply(TypeElement input) {
+        return getScopeAnnotation(input).isPresent();
+      }
+    }).toSet();
+  }
+
+  /**
+   * Validates that scopes do not participate in a scoping cycle - that is to say, scoped
+   * components are in a hierarchical relationship terminating with Singleton.
+   *
+   * <p>As a side-effect, this means scoped components cannot have a dependency cycle between
+   * themselves, since a component's presence within its own dependency path implies a cyclical
+   * relationship between scopes.
+   */
+  private void validateScopeHierarchy(TypeElement rootComponent,
+      TypeElement componentType,
+      Builder<BindingGraph> reportBuilder,
+      Deque<Equivalence.Wrapper<AnnotationMirror>> scopeStack,
+      Deque<TypeElement> scopedDependencyStack) {
+    Optional<AnnotationMirror> scope = getScopeAnnotation(componentType);
+    if (scope.isPresent()) {
+      Equivalence.Wrapper<AnnotationMirror> wrappedScope =
+          AnnotationMirrors.equivalence().wrap(scope.get());
+      if (scopeStack.contains(wrappedScope)) {
+        scopedDependencyStack.push(componentType);
+        // Current scope has already appeared in the component chain.
+        StringBuilder message = new StringBuilder();
+        message.append(rootComponent.getQualifiedName());
+        message.append(" depends on scoped components in a non-hierarchical scope ordering:\n");
+        appendIndentedComponentsList(message, scopedDependencyStack);
+        if (disableInterComponentScopeCycles.diagnosticKind().isPresent()) {
+          reportBuilder.addItem(message.toString(),
+              disableInterComponentScopeCycles.diagnosticKind().get(),
+              rootComponent, getAnnotationMirror(rootComponent, Component.class).get());
+        }
+        scopedDependencyStack.pop();
+      } else {
+        Optional<AnnotationMirror> componentAnnotation =
+            getAnnotationMirror(componentType, Component.class);
+        if (componentAnnotation.isPresent()) {
+          ImmutableSet<TypeElement> scopedDependencies = scopedTypesIn(
+              MoreTypes.asTypeElements(types, getComponentDependencies(componentAnnotation.get())));
+          if (scopedDependencies.size() == 1) {
+            // empty can be ignored (base-case), and > 1 is a different error reported separately.
+            scopeStack.push(wrappedScope);
+            scopedDependencyStack.push(componentType);
+            validateScopeHierarchy(rootComponent, getOnlyElement(scopedDependencies),
+                reportBuilder, scopeStack, scopedDependencyStack);
+            scopedDependencyStack.pop();
+            scopeStack.pop();
+          }
+        } // else: we skip component dependencies which are not components
+      }
+    }
+  }
+
   /**
    * Validates that the scope (if any) of this component are compatible with the scopes of the
    * bindings available in this component
    */
   void validateComponentScope(final BindingGraph subject,
       final ValidationReport.Builder<BindingGraph> reportBuilder,
-      ImmutableMap<Key, ResolvedBindings> resolvedBindings) {
+      ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings) {
     Optional<Equivalence.Wrapper<AnnotationMirror>> componentScope =
         subject.componentDescriptor().wrappedScope();
     ImmutableSet.Builder<String> incompatiblyScopedMethodsBuilder = ImmutableSet.builder();
     for (ResolvedBindings bindings : resolvedBindings.values()) {
-      for (Binding binding : bindings.bindings()) {
-        if (binding instanceof ProvisionBinding) {
-          ProvisionBinding provisionBinding = (ProvisionBinding) binding;
-          if (provisionBinding.scope().isPresent()
-              && !componentScope.equals(provisionBinding.wrappedScope())) {
-            // Scoped components cannot reference bindings to @Provides methods or @Inject
-            // types decorated by a different scope annotation. Unscoped components cannot
-            // reference to scoped @Provides methods or @Inject types decorated by any
-            // scope annotation.
-            switch (provisionBinding.bindingKind()) {
-              case PROVISION:
-                ExecutableElement provisionMethod =
-                    MoreElements.asExecutable(provisionBinding.bindingElement());
-                incompatiblyScopedMethodsBuilder.add(
-                    MethodSignatureFormatter.instance().format(provisionMethod));
-                break;
-              case INJECTION:
-                incompatiblyScopedMethodsBuilder.add(
-                    stripCommonTypePrefixes(provisionBinding.scope().get().toString()) + " class "
-                        + provisionBinding.bindingTypeElement().getQualifiedName());
-                break;
-              default:
-                throw new IllegalStateException();
+      if (bindings.bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION)) {
+        for (ContributionBinding contributionBinding : bindings.contributionBindings()) {
+          if (contributionBinding instanceof ProvisionBinding) {
+            ProvisionBinding provisionBinding = (ProvisionBinding) contributionBinding;
+            if (provisionBinding.scope().isPresent()
+                && !componentScope.equals(provisionBinding.wrappedScope())) {
+              // Scoped components cannot reference bindings to @Provides methods or @Inject
+              // types decorated by a different scope annotation. Unscoped components cannot
+              // reference to scoped @Provides methods or @Inject types decorated by any
+              // scope annotation.
+              switch (provisionBinding.bindingKind()) {
+                case PROVISION:
+                  ExecutableElement provisionMethod =
+                      MoreElements.asExecutable(provisionBinding.bindingElement());
+                  incompatiblyScopedMethodsBuilder.add(
+                      MethodSignatureFormatter.instance().format(provisionMethod));
+                  break;
+                case INJECTION:
+                  incompatiblyScopedMethodsBuilder.add(stripCommonTypePrefixes(
+                      provisionBinding.scope().get().toString()) + " class "
+                          + provisionBinding.bindingTypeElement().getQualifiedName());
+                  break;
+                default:
+                  throw new IllegalStateException();
+              }
             }
           }
         }
@@ -153,25 +377,10 @@ private void reportMissingBinding(
       Deque<DependencyRequest> requestPath, ValidationReport.Builder<BindingGraph> reportBuilder) {
     Key key = requestPath.peek().key();
     TypeMirror type = key.type();
-    Name typeName = MoreElements.asType(types.asElement(type)).getQualifiedName();
-    boolean requiresProvidesMethod = type.accept(new SimpleTypeVisitor6<Boolean, Void>() {
-      @Override protected Boolean defaultAction(TypeMirror e, Void p) {
-        return true;
-      }
-
-      @Override public Boolean visitDeclared(DeclaredType type, Void ignored) {
-        // Note - this logic is also in InjectConstructorValidator but is woven into errors.
-        TypeElement typeElement = MoreElements.asType(type.asElement());
-        if (typeElement.getTypeParameters().isEmpty()
-            && typeElement.getKind().equals(ElementKind.CLASS)
-            && !typeElement.getModifiers().contains(Modifier.ABSTRACT)) {
-          return false;
-        }
-        return true;
-      }
-    }, null);
+    String typeName = TypeNames.forTypeMirror(type).toString();
+    boolean requiresProvidesMethod = !key.isValidImplicitProvisionKey(types);
     StringBuilder errorMessage = new StringBuilder();
-    if(requiresProvidesMethod) {
+    if (requiresProvidesMethod) {
       errorMessage.append(String.format(REQUIRES_PROVIDER_FORMAT, typeName));
     } else {
       errorMessage.append(
@@ -187,7 +396,7 @@ private void reportMissingBinding(
             .transform(DependencyRequestFormatter.instance())
             .toList()
             .reverse();
-    for(String dependency :
+    for (String dependency :
         printableDependencyPath.subList(1, printableDependencyPath.size())) {
       errorMessage.append("\n").append(dependency);
     }
@@ -255,37 +464,25 @@ private String formatBindingType(BindingType type) {
 
   private void reportCycle(Deque<DependencyRequest> requestPath,
       BindingGraph graph, final ValidationReport.Builder<BindingGraph> reportBuilder) {
-    final DependencyRequest startingRequest = requestPath.peek();
-    final Key cycleKey = startingRequest.key();
-    traversalHelper(graph, requestPath, new Traverser() {
-      @Override
-      boolean visitResolvedBinding(Deque<DependencyRequest> requestPath, ResolvedBindings binding) {
-        DependencyRequest request = requestPath.peek();
-        boolean endOfCycle = !startingRequest.equals(request) && cycleKey.equals(request.key());
-        if (endOfCycle) {
-          ImmutableList<String> printableDependencyPath = FluentIterable.from(requestPath)
-              .transform(DependencyRequestFormatter.instance()).toList().reverse();
-          DependencyRequest rootRequest = requestPath.getLast();
-          TypeElement componentType =
-              MoreElements.asType(rootRequest.requestElement().getEnclosingElement());
-          // TODO(user): Restructure to provide a hint for the start and end of the cycle.
-          reportBuilder.addItem(
-              String.format(ErrorMessages.CONTAINS_DEPENDENCY_CYCLE_FORMAT,
-                  componentType.getQualifiedName(),
-                  rootRequest.requestElement().getSimpleName(),
-                  Joiner.on("\n")
-                      .join(printableDependencyPath.subList(1, printableDependencyPath.size()))),
-                  rootRequest.requestElement());
-        }
-        return !endOfCycle;
-      }
-    });
-
+    ImmutableList<String> printableDependencyPath = FluentIterable.from(requestPath)
+        .transform(DependencyRequestFormatter.instance()).toList().reverse();
+    DependencyRequest rootRequest = requestPath.getLast();
+    TypeElement componentType =
+        MoreElements.asType(rootRequest.requestElement().getEnclosingElement());
+    // TODO(user): Restructure to provide a hint for the start and end of the cycle.
+    reportBuilder.addItem(
+        String.format(ErrorMessages.CONTAINS_DEPENDENCY_CYCLE_FORMAT,
+            componentType.getQualifiedName(),
+            rootRequest.requestElement().getSimpleName(),
+            Joiner.on("\n")
+            .join(printableDependencyPath.subList(1, printableDependencyPath.size()))),
+        rootRequest.requestElement());
   }
 
   private void traversalHelper(BindingGraph graph, Deque<DependencyRequest> requestPath,
       Traverser traverser) {
-    ResolvedBindings resolvedBinding = graph.resolvedBindings().get(requestPath.peek().key());
+    ResolvedBindings resolvedBinding = graph.resolvedBindings().get(
+        BindingKey.forDependencyRequest(requestPath.peek()));
     ImmutableSet<DependencyRequest> allDeps =
         FluentIterable.from(resolvedBinding.bindings())
             .transformAndConcat(
@@ -306,8 +503,34 @@ private void traversalHelper(BindingGraph graph, Deque<DependencyRequest> reques
     }
   }
 
-  static abstract class Traverser {
+  abstract static class Traverser {
     abstract boolean visitResolvedBinding(
         Deque<DependencyRequest> requestPath, ResolvedBindings binding);
   }
+
+  /**
+   * {@code -Adagger.disableInterComponentScopeValidation=none} will suppress validation of
+   * scoping relationships between dagger {@code @Component} interfaces. This is a migration
+   * tool to permit easier migration from Dagger 1.x which used {@code @Singleton} for scoped
+   * graphs in any lifetime.
+   *
+   * <p>The value can be (case-insensitively) set to any of {@code ERROR}, {@code WARNING},
+   * or {@code NONE} and defaults to {@code ERROR}.
+   */
+  enum ScopeCycleValidation {
+    ERROR,
+    WARNING,
+    NONE;
+
+    Optional<Diagnostic.Kind> diagnosticKind() {
+      switch (this) {
+        case ERROR:
+          return Optional.of(Diagnostic.Kind.ERROR);
+        case WARNING:
+          return Optional.of(Diagnostic.Kind.WARNING);
+        default:
+          return Optional.absent();
+      }
+    }
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingKey.java b/compiler/src/main/java/dagger/internal/codegen/BindingKey.java
new file mode 100644
index 000000000..ed599e267
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingKey.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.value.AutoValue;
+
+/**
+ * A value object that pairs a {@link Key} with the style of its binding (i.e., whether it's a
+ * members injector or normal contribution).
+ *
+ *  @author Gregory Kick
+ *  @since 2.0
+ */
+@AutoValue
+abstract class BindingKey {
+  /** The style of binding that makes a {@link Key} available. */
+  enum Kind {
+    CONTRIBUTION, MEMBERS_INJECTION;
+  }
+
+  static BindingKey forDependencyRequest(DependencyRequest request) {
+    switch (request.kind()) {
+      case INSTANCE:
+      case LAZY:
+      case PROVIDER:
+      case PRODUCER:
+      case PRODUCED:
+        return BindingKey.create(Kind.CONTRIBUTION, request.key());
+      case MEMBERS_INJECTOR:
+        return BindingKey.create(Kind.MEMBERS_INJECTION, request.key());
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  static BindingKey create(Kind kind, Key key) {
+    return new AutoValue_BindingKey(kind, key);
+  }
+
+  abstract Kind kind();
+  abstract Key key();
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index ddddf9cf0..adb25639e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -15,14 +15,16 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.ImmutableSetMultimap;
 import dagger.Component;
+import dagger.producers.ProductionComponent;
+import java.lang.annotation.Annotation;
 import java.util.List;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
@@ -39,7 +41,7 @@
 import static javax.lang.model.type.TypeKind.VOID;
 
 /**
- * The logical representation of a {@link Component} definition.
+ * The logical representation of a {@link Component} or {@link ProductionComponent} definition.
  *
  * @author Gregory Kick
  * @since 2.0
@@ -48,6 +50,23 @@
 abstract class ComponentDescriptor {
   ComponentDescriptor() {}
 
+  enum Kind {
+    COMPONENT(Component.class),
+    PRODUCTION_COMPONENT(ProductionComponent.class);
+
+    private final Class<? extends Annotation> annotationType;
+
+    Kind(Class<? extends Annotation> annotationType) {
+      this.annotationType = annotationType;
+    }
+
+    Class<? extends Annotation> annotationType() {
+      return annotationType;
+    }
+  }
+
+  abstract Kind kind();
+
   abstract AnnotationMirror componentAnnotation();
 
   /**
@@ -63,8 +82,8 @@
 
   /**
    * An index of the type to which this component holds a reference (the type listed in
-   * {@link Component#dependencies} as opposed to the enclosing type) for each method from a
-   * component dependency that can be used for binding.
+   * {@link Component#dependencies} or {@link ProductionComponent#dependencies} as opposed to the
+   * enclosing type) for each method from a component dependency that can be used for binding.
    */
   abstract ImmutableMap<ExecutableElement, TypeElement> dependencyMethodIndex();
 
@@ -85,42 +104,34 @@
   static final class Factory {
     private final Elements elements;
     private final Types types;
-    private final ProvisionBinding.Factory provisionBindingFactory;
 
-    Factory(Elements elements, Types types, ProvisionBinding.Factory provisionBindingFactory) {
+    Factory(Elements elements, Types types) {
       this.elements = elements;
       this.types = types;
-      this.provisionBindingFactory = provisionBindingFactory;
     }
 
-    ComponentDescriptor create(TypeElement componentDefinitionType) {
+    ComponentDescriptor forComponent(TypeElement componentDefinitionType) {
+      return create(componentDefinitionType, Kind.COMPONENT);
+    }
+
+    ComponentDescriptor forProductionComponent(TypeElement componentDefinitionType) {
+      return create(componentDefinitionType, Kind.PRODUCTION_COMPONENT);
+    }
+
+    private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kind) {
       AnnotationMirror componentMirror =
-          getAnnotationMirror(componentDefinitionType, Component.class).get();
+          getAnnotationMirror(componentDefinitionType, kind.annotationType()).get();
       ImmutableSet<TypeElement> componentDependencyTypes =
           MoreTypes.asTypeElements(types, getComponentDependencies(componentMirror));
 
-      ProvisionBinding componentBinding =
-          provisionBindingFactory.forComponent(componentDefinitionType);
-
-      ImmutableSetMultimap.Builder<Key, ProvisionBinding> explicitBindingIndexBuilder =
-          new ImmutableSetMultimap.Builder<Key, ProvisionBinding>()
-              .put(componentBinding.key(), componentBinding);
       ImmutableMap.Builder<ExecutableElement, TypeElement> dependencyMethodIndex =
           ImmutableMap.builder();
 
       for (TypeElement componentDependency : componentDependencyTypes) {
-        ProvisionBinding componentDependencyBinding =
-            provisionBindingFactory.forComponent(componentDependency);
-        explicitBindingIndexBuilder.put(
-            componentDependencyBinding.key(), componentDependencyBinding);
         List<ExecutableElement> dependencyMethods =
             ElementFilter.methodsIn(elements.getAllMembers(componentDependency));
         for (ExecutableElement dependencyMethod : dependencyMethods) {
           if (isComponentProvisionMethod(elements, dependencyMethod)) {
-            ProvisionBinding componentMethodBinding =
-                provisionBindingFactory.forComponentMethod(dependencyMethod);
-            explicitBindingIndexBuilder
-                .put(componentMethodBinding.key(), componentMethodBinding);
             dependencyMethodIndex.put(dependencyMethod, componentDependency);
           }
         }
@@ -128,6 +139,7 @@ ComponentDescriptor create(TypeElement componentDefinitionType) {
 
       Optional<AnnotationMirror> scope = getScopeAnnotation(componentDefinitionType);
       return new AutoValue_ComponentDescriptor(
+          kind,
           componentMirror,
           componentDefinitionType,
           componentDependencyTypes,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index c3e874175..8e75f5393 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
@@ -34,6 +35,7 @@
 import dagger.Component;
 import dagger.Factory;
 import dagger.MapKey;
+import dagger.MembersInjector;
 import dagger.internal.InstanceFactory;
 import dagger.internal.MapFactory;
 import dagger.internal.MapProviderFactory;
@@ -41,7 +43,7 @@
 import dagger.internal.ScopedProvider;
 import dagger.internal.SetFactory;
 import dagger.internal.codegen.BindingGraph.ResolvedBindings;
-import dagger.internal.codegen.ProvisionBinding.BindingType;
+import dagger.internal.codegen.ContributionBinding.BindingType;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.ClassWriter;
 import dagger.internal.codegen.writer.ConstructorWriter;
@@ -80,13 +82,11 @@
 
 import static com.google.auto.common.MoreTypes.asDeclared;
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static dagger.internal.codegen.Binding.bindingPackageFor;
 import static dagger.internal.codegen.ConfigurationAnnotations.getMapKeys;
-import static dagger.internal.codegen.DependencyRequest.Kind.MEMBERS_INJECTOR;
 import static dagger.internal.codegen.ProvisionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
-import static dagger.internal.codegen.ProvisionBinding.Kind.COMPONENT;
-import static dagger.internal.codegen.ProvisionBinding.Kind.COMPONENT_PROVISION;
-import static dagger.internal.codegen.ProvisionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
+import static dagger.internal.codegen.ProvisionBinding.Kind.SYNTHETIC_PROVISON;
 import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.membersInjectorNameForMembersInjectionBinding;
@@ -114,8 +114,9 @@
   ClassName nameGeneratedType(BindingGraph input) {
     ClassName componentDefinitionClassName =
         ClassName.fromTypeElement(input.componentDescriptor().componentDefinitionType());
-    return componentDefinitionClassName.topLevelClassName().peerNamed(
-        "Dagger_" + componentDefinitionClassName.classFileName());
+    String componentName =
+        "Dagger_" + componentDefinitionClassName.classFileName().replace('$', '_');
+    return componentDefinitionClassName.topLevelClassName().peerNamed(componentName);
   }
 
   @Override
@@ -158,8 +159,6 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
     builderFactoryMethod.addModifiers(PUBLIC, STATIC);
     builderFactoryMethod.body().addSnippet("return new %s();", builderWriter.name());
 
-    ImmutableMap<Key, String> frameworkTypeNames = generateFrameworkTypeNames(input);
-
     // the full set of types that calling code uses to construct a component instance
     ImmutableMap<TypeElement, String> componentContributionNames =
         ImmutableMap.copyOf(Maps.asMap(
@@ -223,47 +222,37 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
       }
     }
 
-    ImmutableMap.Builder<Key, Snippet> memberSelectSnippetsBuilder =
+    ImmutableMap.Builder<BindingKey, Snippet> memberSelectSnippetsBuilder =
+        ImmutableMap.builder();
+    ImmutableMap.Builder<ContributionBinding, Snippet> multibindingContributionSnippetsBuilder =
         ImmutableMap.builder();
+    ImmutableSet.Builder<BindingKey> enumBindingKeysBuilder = ImmutableSet.builder();
 
     ImmutableSet.Builder<JavaWriter> proxyWriters = ImmutableSet.builder();
     Map<String, ProxyClassAndField> packageProxies = Maps.newHashMap();
 
-    for (Entry<Key, ResolvedBindings> resolvedBindingsEntry : input.resolvedBindings().entrySet()) {
-      Key key = resolvedBindingsEntry.getKey();
+    for (ResolvedBindings resolvedBindings : input.resolvedBindings().values()) {
+      BindingKey bindingKey = resolvedBindings.bindingKey();
 
-      ImmutableSet<? extends Binding> bindings = resolvedBindingsEntry.getValue().bindings();
-      if (bindings.size() == 1) {
-        Binding onlyBinding = bindings.iterator().next();
-        if (onlyBinding instanceof ProvisionBinding) {
-          ProvisionBinding provisionBinding = ((ProvisionBinding) onlyBinding);
+      if (resolvedBindings.bindings().size() == 1
+          && bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION)) {
+        ContributionBinding contributionBinding =
+            Iterables.getOnlyElement(resolvedBindings.contributionBindings());
+        if (contributionBinding instanceof ProvisionBinding) {
+          ProvisionBinding provisionBinding = (ProvisionBinding) contributionBinding;
           if (provisionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
               && !provisionBinding.scope().isPresent()) {
+            enumBindingKeysBuilder.add(bindingKey);
             // skip keys whose factories are enum instances and aren't scoped
-            memberSelectSnippetsBuilder.put(key, Snippet.format("%s.INSTANCE",
-                factoryNameForProvisionBinding(provisionBinding)));
+            memberSelectSnippetsBuilder.put(bindingKey, Snippet.format("%s.create()",
+                    factoryNameForProvisionBinding(provisionBinding)));
             continue;
           }
         }
       }
 
-      ImmutableSet.Builder<String> bindingPackagesBuilder = ImmutableSet.builder();
-      for (Binding binding : bindings) {
-        bindingPackagesBuilder.addAll(binding.bindingPackage().asSet());
-      }
-      ImmutableSet<String> bindingPackages = bindingPackagesBuilder.build();
-
-      final String bindingPackage;
-      switch (bindingPackages.size()) {
-        case 0:
-          bindingPackage = componentName.packageName();
-          break;
-        case 1:
-          bindingPackage = bindingPackages.iterator().next();
-          break;
-        default:
-          throw new IllegalStateException();
-      }
+      String bindingPackage = bindingPackageFor(resolvedBindings.bindings())
+          .or(componentName.packageName());
 
       final Optional<String> proxySelector;
       final TypeWriter classWithFields;
@@ -289,8 +278,8 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
           proxyWriter.addModifiers(PUBLIC, FINAL);
           // create the field for the proxy in the component
           FieldWriter proxyFieldWriter =
-              componentWriter.addField(proxyWriter.name(), bindingPackage.replace('.', '_')
-                  + "_Proxy");
+              componentWriter.addField(proxyWriter.name(),
+                  bindingPackage.replace('.', '_') + "_Proxy");
           proxyFieldWriter.addModifiers(PRIVATE, FINAL);
           proxyFieldWriter.setInitializer("new %s()", proxyWriter.name());
           proxyClassAndField = ProxyClassAndField.create(proxyWriter, proxyFieldWriter);
@@ -304,21 +293,43 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
         fieldModifiers = EnumSet.of(PUBLIC);
       }
 
-      TypeName frameworkTypeName = ParameterizedTypeName.create(
-          ClassName.fromClass(key.kind().frameworkClass()),
-          TypeNames.forTypeMirror(key.type()));
-
-      String fieldName = frameworkTypeNames.get(key);
+      if (bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION)) {
+        ImmutableSet<? extends ContributionBinding> contributionBindings =
+            resolvedBindings.contributionBindings();
+        if (ContributionBinding.bindingTypeFor(contributionBindings).isMultibinding()) {
+          int contributionNumber = 0;
+          for (ContributionBinding contributionBinding : contributionBindings) {
+            if (isSytheticProvisionBinding(contributionBinding)) {
+              contributionNumber++;
+              FrameworkField contributionBindingField = frameworkFieldForSyntheticProvisionBinding(
+                  bindingKey, contributionNumber, contributionBinding);
+              FieldWriter contributionField = classWithFields.addField(
+                  contributionBindingField.frameworkType(), contributionBindingField.name());
+              contributionField.addModifiers(fieldModifiers);
+
+              ImmutableList<String> contirubtionSelectTokens = new ImmutableList.Builder<String>()
+                  .addAll(proxySelector.asSet())
+                  .add(contributionField.name())
+                  .build();
+              multibindingContributionSnippetsBuilder.put(contributionBinding,
+                  Snippet.memberSelectSnippet(contirubtionSelectTokens));
+            }
+          }
+        }
+      }
 
-      FieldWriter frameworkField = classWithFields.addField(frameworkTypeName, fieldName);
+      FrameworkField bindingField = frameworkFieldForResolvedBindings(resolvedBindings);
+      FieldWriter frameworkField =
+          classWithFields.addField(bindingField.frameworkType(), bindingField.name());
       frameworkField.addModifiers(fieldModifiers);
 
       ImmutableList<String> memberSelectTokens = new ImmutableList.Builder<String>()
           .addAll(proxySelector.asSet())
           .add(frameworkField.name())
           .build();
-      memberSelectSnippetsBuilder.put(key,
+      memberSelectSnippetsBuilder.put(bindingKey,
           Snippet.memberSelectSnippet(memberSelectTokens));
+
     }
 
     buildMethod.body().addSnippet("return new %s(this);", componentWriter.name());
@@ -330,9 +341,13 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
       factoryMethod.body().addSnippet("return builder().build();");
     }
 
-    ImmutableMap<Key, Snippet> memberSelectSnippets = memberSelectSnippetsBuilder.build();
+    ImmutableMap<BindingKey, Snippet> memberSelectSnippets = memberSelectSnippetsBuilder.build();
+    ImmutableMap<ContributionBinding, Snippet> multibindingContributionSnippets =
+        multibindingContributionSnippetsBuilder.build();
+    ImmutableSet<BindingKey> enumBindingKeys = enumBindingKeysBuilder.build();
 
-    List<List<Key>> partitions = Lists.partition(input.resolvedBindings().keySet().asList(), 100);
+    List<List<BindingKey>> partitions = Lists.partition(
+        input.resolvedBindings().keySet().asList(), 100);
     for (int i = 0; i < partitions.size(); i++) {
       MethodWriter initializeMethod =
           componentWriter.addMethod(VoidName.VOID, "initialize" + ((i == 0) ? "" : i));
@@ -340,35 +355,47 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
       initializeMethod.addModifiers(PRIVATE);
       constructorWriter.body().addSnippet("%s();", initializeMethod.name());
 
-      for (Key key : partitions.get(i)) {
-        Snippet memberSelectSnippet = memberSelectSnippets.get(key);
-        switch (key.kind()) {
-          case PROVIDER:
-            @SuppressWarnings("unchecked")
-            Set<ProvisionBinding> bindings =
-                (Set<ProvisionBinding>) input.resolvedBindings().get(key).bindings();
-            BindingType bindingsType = ProvisionBinding.bindingTypeFor(bindings);
-            switch (bindingsType) {
+      for (BindingKey bindingKey : partitions.get(i)) {
+        Snippet memberSelectSnippet = memberSelectSnippets.get(bindingKey);
+        switch (bindingKey.kind()) {
+          case CONTRIBUTION:
+            @SuppressWarnings("unchecked")  // checked during validation
+            ImmutableSet<ProvisionBinding> bindings =
+                (ImmutableSet<ProvisionBinding>) input.resolvedBindings()
+                .get(bindingKey)
+                .contributionBindings();
+
+            switch (ContributionBinding.bindingTypeFor(bindings)) {
               case SET:
-                ImmutableList.Builder<Snippet> setFactoryParameters = ImmutableList.builder();
-                for (ProvisionBinding binding : bindings) {
-                  setFactoryParameters.add(initializeFactoryForBinding(binding,
-                      input.componentDescriptor().dependencyMethodIndex(),
-                      componentContributionFields,
-                      memberSelectSnippets));
+                for (ProvisionBinding provisionBinding : bindings) {
+                  initializeMethod.body().addSnippet("this.%s = %s;",
+                      multibindingContributionSnippets.get(provisionBinding),
+                      initializeFactoryForBinding(provisionBinding,
+                          input.componentDescriptor().dependencyMethodIndex(),
+                          componentContributionFields,
+                          memberSelectSnippets));
                 }
                 Snippet initializeSetSnippet = Snippet.format("%s.create(%s)",
                     ClassName.fromClass(SetFactory.class),
-                    Snippet.makeParametersSnippet(setFactoryParameters.build()));
+                    Snippet.makeParametersSnippet(Iterables.transform(bindings,
+                        Functions.forMap(multibindingContributionSnippets))));
                 initializeMethod.body().addSnippet("this.%s = %s;",
                     memberSelectSnippet, initializeSetSnippet);
                 break;
               case MAP:
+                for (ProvisionBinding provisionBinding : bindings) {
+                  if (!isNonProviderMap(provisionBinding)) {
+                    initializeMethod.body().addSnippet("this.%s = %s;",
+                        multibindingContributionSnippets.get(provisionBinding),
+                        initializeFactoryForBinding(provisionBinding,
+                            input.componentDescriptor().dependencyMethodIndex(),
+                            componentContributionFields,
+                            memberSelectSnippets));
+                  }
+                }
                 if (!bindings.isEmpty()) {
-                  Snippet initializeMapSnippet =
-                      initializeMapBinding(componentContributionFields,
-                          input.componentDescriptor().dependencyMethodIndex(),
-                          memberSelectSnippets, bindings);
+                  Snippet initializeMapSnippet = initializeMapBinding(
+                      memberSelectSnippets, multibindingContributionSnippets, bindings);
                   initializeMethod.body().addSnippet("this.%s = %s;",
                       memberSelectSnippet, initializeMapSnippet);
                 }
@@ -388,9 +415,9 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
                 throw new IllegalStateException();
             }
             break;
-          case MEMBERS_INJECTOR:
-            MembersInjectionBinding binding = (MembersInjectionBinding) Iterables.getOnlyElement(
-                input.resolvedBindings().get(key).bindings());
+          case MEMBERS_INJECTION:
+            MembersInjectionBinding binding = Iterables.getOnlyElement(
+                input.resolvedBindings().get(bindingKey).membersInjectionBindings());
             initializeMethod.body().addSnippet("this.%s = %s;",
                 memberSelectSnippet,
                 initializeMembersInjectorForBinding(binding, memberSelectSnippets));
@@ -415,22 +442,45 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
                     requestElement.getSimpleName().toString());
             interfaceMethod.annotate(Override.class);
             interfaceMethod.addModifiers(PUBLIC);
-            Key key = interfaceRequest.key();
-            if (interfaceRequest.kind().equals(MEMBERS_INJECTOR)) {
-              Snippet membersInjectorName = memberSelectSnippets.get(key);
-              VariableElement parameter = Iterables.getOnlyElement(requestElement.getParameters());
-              Name parameterName = parameter.getSimpleName();
-              interfaceMethod.addParameter(
-                  TypeNames.forTypeMirror(parameter.asType()), parameterName.toString());
-              interfaceMethod.body()
-              .addSnippet("%s.injectMembers(%s);", membersInjectorName, parameterName);
-              if (!requestElement.getReturnType().getKind().equals(VOID)) {
-                interfaceMethod.body().addSnippet("return %s;", parameterName);
-              }
-            } else {
-              interfaceMethod.body().addSnippet("return %s;",
-                  frameworkTypeUsageStatement(memberSelectSnippets.get(key),
-                      interfaceRequest.kind()));
+            BindingKey bindingKey = BindingKey.forDependencyRequest(interfaceRequest);
+            switch(interfaceRequest.kind()) {
+              case MEMBERS_INJECTOR:
+                Snippet membersInjectorName = memberSelectSnippets.get(bindingKey);
+                VariableElement parameter = Iterables.getOnlyElement(requestElement.getParameters());
+                Name parameterName = parameter.getSimpleName();
+                interfaceMethod.addParameter(
+                    TypeNames.forTypeMirror(parameter.asType()), parameterName.toString());
+                interfaceMethod.body()
+                    .addSnippet("%s.injectMembers(%s);", membersInjectorName, parameterName);
+                if (!requestElement.getReturnType().getKind().equals(VOID)) {
+                  interfaceMethod.body().addSnippet("return %s;", parameterName);
+                }
+                break;
+              case INSTANCE:
+                if (enumBindingKeys.contains(bindingKey)
+                    && !MoreTypes.asDeclared(bindingKey.key().type())
+                            .getTypeArguments().isEmpty()) {
+                  // If using a parameterized enum type, then we need to store the factory
+                  // in a temporary variable, in order to help javac be able to infer
+                  // the generics of the Factory.create methods.
+                  TypeName factoryType = ParameterizedTypeName.create(Provider.class,
+                      TypeNames.forTypeMirror(requestElement.getReturnType()));
+                  interfaceMethod.body().addSnippet("%s factory = %s;", factoryType,
+                      memberSelectSnippets.get(bindingKey));
+                  interfaceMethod.body().addSnippet("return factory.get();");
+                  break;
+                }
+                // fall through in the else case.
+              case LAZY:
+              case PRODUCED:
+              case PRODUCER:
+              case PROVIDER:
+                interfaceMethod.body().addSnippet("return %s;",
+                    frameworkTypeUsageStatement(memberSelectSnippets.get(bindingKey),
+                        interfaceRequest.kind()));
+                break;
+              default:
+                throw new AssertionError();
             }
       }
     }
@@ -441,72 +491,105 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
         .build();
   }
 
-  private ImmutableMap<Key, String> generateFrameworkTypeNames(BindingGraph graph) {
-    ImmutableMap.Builder<Key, String> names = ImmutableMap.builder();
-    for (Entry<Key, ResolvedBindings> entry : graph.resolvedBindings().entrySet()) {
-      Key key = entry.getKey();
-      switch (key.kind()) {
-        case PROVIDER:
-          @SuppressWarnings("unchecked")
-          ImmutableSet<ProvisionBinding> bindingsForKey =
-              (ImmutableSet<ProvisionBinding>) entry.getValue().bindings();
-          BindingType bindingsType = ProvisionBinding.bindingTypeFor(bindingsForKey);
-          switch (bindingsType) {
-            case SET:
-              names.put(key,
-                  new KeyVariableNamer().apply(key) + "Provider");
-              break;
-            case MAP:
-              names.put(key,
-                  new KeyVariableNamer().apply(key) + "Provider");
-              break;
-            case UNIQUE:
-              ProvisionBinding binding = Iterables.getOnlyElement(bindingsForKey);
-              names.put(key,
-                  binding.bindingElement().accept(new ElementKindVisitor6<String, Void>() {
-                    @Override
-                    public String visitExecutableAsConstructor(ExecutableElement e, Void p) {
-                      return e.getEnclosingElement().accept(this, null);
-                    }
-
-                    @Override
-                    public String visitExecutableAsMethod(ExecutableElement e, Void p) {
-                      return e.getSimpleName().toString();
-                    }
-
-                    @Override
-                    public String visitType(TypeElement e, Void p) {
-                      return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL,
-                          e.getSimpleName().toString());
-                    }
-                  }, null) + "Provider");
-              break;
-            default:
-              throw new AssertionError();
-          }
-          break;
-        case MEMBERS_INJECTOR:
-          names.put(key, CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL,
-              Iterables.getOnlyElement(entry.getValue().bindings())
-                  .bindingElement().getSimpleName().toString()) + "MembersInjector");
-          break;
-        default:
-          throw new AssertionError();
-      }
+  private static FrameworkField frameworkFieldForSyntheticProvisionBinding(BindingKey bindingKey,
+      int contributionNumber, ContributionBinding contributionBinding) throws AssertionError {
+    FrameworkField contributionBindingField;
+    switch (contributionBinding.bindingType()) {
+      case MAP:
+        contributionBindingField = FrameworkField.createForMapBindingContribution(
+            Provider.class,
+            BindingKey.create(bindingKey.kind(), contributionBinding.key()),
+            KeyVariableNamer.INSTANCE.apply(bindingKey.key())
+                + "Contribution" + contributionNumber);
+        break;
+      case SET:
+        contributionBindingField = FrameworkField.createWithTypeFromKey(
+            Provider.class,
+            bindingKey,
+            KeyVariableNamer.INSTANCE.apply(bindingKey.key())
+                + "Contribution" + contributionNumber);
+        break;
+      case UNIQUE:
+        contributionBindingField = FrameworkField.createWithTypeFromKey(
+            Provider.class,
+            bindingKey,
+            KeyVariableNamer.INSTANCE.apply(bindingKey.key())
+                + "Contribution" + contributionNumber);
+        break;
+      default:
+        throw new AssertionError();
+    }
+    return contributionBindingField;
+  }
+
+  private static boolean isSytheticProvisionBinding(ContributionBinding contributionBinding) {
+    return !(contributionBinding instanceof ProvisionBinding
+        && ((ProvisionBinding) contributionBinding)
+            .bindingKind().equals(SYNTHETIC_PROVISON));
+  }
+
+  private FrameworkField frameworkFieldForResolvedBindings(ResolvedBindings resolvedBindings) {
+    BindingKey bindingKey = resolvedBindings.bindingKey();
+    switch (bindingKey.kind()) {
+      case CONTRIBUTION:
+        ImmutableSet<? extends ContributionBinding> contributionBindings =
+            resolvedBindings.contributionBindings();
+        BindingType bindingsType = ProvisionBinding.bindingTypeFor(contributionBindings);
+        switch (bindingsType) {
+          case SET:
+          case MAP:
+            return FrameworkField.createWithTypeFromKey(
+                Provider.class,
+                bindingKey,
+                KeyVariableNamer.INSTANCE.apply(bindingKey.key()));
+          case UNIQUE:
+            ContributionBinding binding = Iterables.getOnlyElement(contributionBindings);
+            return FrameworkField.createWithTypeFromKey(
+                Provider.class,
+                bindingKey,
+                binding.bindingElement().accept(new ElementKindVisitor6<String, Void>() {
+                  @Override
+                  public String visitExecutableAsConstructor(ExecutableElement e, Void p) {
+                    return e.getEnclosingElement().accept(this, null);
+                  }
+
+                  @Override
+                  public String visitExecutableAsMethod(ExecutableElement e, Void p) {
+                    return e.getSimpleName().toString();
+                  }
+
+                  @Override
+                  public String visitType(TypeElement e, Void p) {
+                    return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL,
+                        e.getSimpleName().toString());
+                  }
+                }, null));
+          default:
+            throw new AssertionError();
+        }
+      case MEMBERS_INJECTION:
+        return FrameworkField.createWithTypeFromKey(
+            MembersInjector.class,
+            bindingKey,
+            CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL,
+                Iterables.getOnlyElement(resolvedBindings.bindings())
+                .bindingElement().getSimpleName().toString()));
+      default:
+        throw new AssertionError();
     }
-    return names.build();
   }
 
   private Snippet initializeFactoryForBinding(ProvisionBinding binding,
       ImmutableMap<ExecutableElement, TypeElement> dependencyMethodIndex,
       Map<TypeElement, FieldWriter> contributionFields,
-      ImmutableMap<Key, Snippet> memberSelectSnippets) {
-    if (binding.bindingKind().equals(COMPONENT)) {
-      return Snippet.format("%s.<%s>create(this)",
-          ClassName.fromClass(InstanceFactory.class),
-          TypeNames.forTypeMirror(binding.key().type()));
-    } else if (binding.bindingKind().equals(COMPONENT_PROVISION)) {
-      return Snippet.format(Joiner.on('\n').join(
+      ImmutableMap<BindingKey, Snippet> memberSelectSnippets) {
+    switch(binding.bindingKind()) {
+      case COMPONENT:
+        return Snippet.format("%s.<%s>create(this)",
+            ClassName.fromClass(InstanceFactory.class),
+            TypeNames.forTypeMirror(binding.key().type()));
+      case COMPONENT_PROVISION:
+        return Snippet.format(Joiner.on('\n').join(
           "new %s<%2$s>() {",
           "  @Override public %2$s get() {",
           "    return %3$s.%4$s();",
@@ -516,45 +599,56 @@ private Snippet initializeFactoryForBinding(ProvisionBinding binding,
           TypeNames.forTypeMirror(binding.key().type()),
           contributionFields.get(dependencyMethodIndex.get(binding.bindingElement())).name(),
           binding.bindingElement().getSimpleName().toString());
-    } else {
-      if (binding.bindingKind().equals(INJECTION) && binding.implicitDependencies().isEmpty()) {
-        return binding.scope().isPresent()
-            ? Snippet.format("%s.create(%s.INSTANCE)",
-                ClassName.fromClass(ScopedProvider.class),
-                factoryNameForProvisionBinding(binding))
-            : Snippet.format("%s.INSTANCE",
-                factoryNameForProvisionBinding(binding));
-      }
-      List<Snippet> parameters = Lists.newArrayListWithCapacity(binding.dependencies().size() + 1);
-      if (binding.bindingKind().equals(PROVISION)) {
-        parameters.add(Snippet.format(contributionFields.get(binding.bindingTypeElement()).name()));
-      }
-      if (binding.memberInjectionRequest().isPresent()) {
-        parameters.add(memberSelectSnippets.get(binding.memberInjectionRequest().get().key()));
-      }
-      parameters.addAll(getDependencyParameters(binding.dependencies(), memberSelectSnippets));
-
-      return binding.scope().isPresent()
-          ? Snippet.format("%s.create(new %s(%s))",
-              ClassName.fromClass(ScopedProvider.class),
-              factoryNameForProvisionBinding(binding),
-              Snippet.makeParametersSnippet(parameters))
-          : Snippet.format("new %s(%s)",
-              factoryNameForProvisionBinding(binding),
-              Snippet.makeParametersSnippet(parameters));
+      case INJECTION:
+      case PROVISION:
+        List<Snippet> parameters =
+            Lists.newArrayListWithCapacity(binding.dependencies().size() + 1);
+        if (binding.bindingKind().equals(PROVISION)) {
+          parameters.add(
+              Snippet.format(contributionFields.get(binding.bindingTypeElement()).name()));
+        }
+        if (binding.memberInjectionRequest().isPresent()) {
+          parameters.add(memberSelectSnippets.get(
+              BindingKey.forDependencyRequest(binding.memberInjectionRequest().get())));
+        }
+        parameters.addAll(getDependencyParameters(binding.dependencies(), memberSelectSnippets));
+
+        if (binding.bindingKind().equals(PROVISION)) {
+          // Factories from @Provides methods don't have .create() methods.
+          return binding.scope().isPresent()
+              ? Snippet.format("%s.create(new %s(%s))",
+                  ClassName.fromClass(ScopedProvider.class),
+                  factoryNameForProvisionBinding(binding),
+                  Snippet.makeParametersSnippet(parameters))
+              : Snippet.format("new %s(%s)",
+                  factoryNameForProvisionBinding(binding),
+                  Snippet.makeParametersSnippet(parameters));
+        } else {
+          // Factories from @Inject classes have .create() methods.
+          return binding.scope().isPresent()
+              ? Snippet.format("%s.create(%s.create(%s))",
+                  ClassName.fromClass(ScopedProvider.class),
+                  factoryNameForProvisionBinding(binding),
+                  Snippet.makeParametersSnippet(parameters))
+              : Snippet.format("%s.create(%s)",
+                  factoryNameForProvisionBinding(binding),
+                  Snippet.makeParametersSnippet(parameters));
+        }
+
+      default:
+        throw new AssertionError();
     }
   }
 
   private static Snippet initializeMembersInjectorForBinding(
       MembersInjectionBinding binding,
-      ImmutableMap<Key, Snippet> memberSelectSnippets) {
+      ImmutableMap<BindingKey, Snippet> memberSelectSnippets) {
     if (binding.injectionSites().isEmpty()) {
       if (binding.parentInjectorRequest().isPresent()) {
         DependencyRequest parentInjectorRequest = binding.parentInjectorRequest().get();
         return Snippet.format("%s.delegatingTo(%s)",
             ClassName.fromClass(MembersInjectors.class),
-            memberSelectSnippets.get(
-                parentInjectorRequest.key()));
+            memberSelectSnippets.get(BindingKey.forDependencyRequest(parentInjectorRequest)));
       } else {
         return Snippet.format("%s.noOp()",
             ClassName.fromClass(MembersInjectors.class));
@@ -563,25 +657,25 @@ private static Snippet initializeMembersInjectorForBinding(
       List<Snippet> parameters = getDependencyParameters(
           Sets.union(binding.parentInjectorRequest().asSet(), binding.dependencies()),
           memberSelectSnippets);
-      return Snippet.format("new %s(%s)",
+      return Snippet.format("%s.create(%s)",
           membersInjectorNameForMembersInjectionBinding(binding),
           Snippet.makeParametersSnippet(parameters));
     }
   }
 
-  private static List<Snippet> getDependencyParameters(Iterable<DependencyRequest> dependencies,
-      ImmutableMap<Key, Snippet> memberSelectSnippets) {
+  private static List<Snippet> getDependencyParameters(
+      Iterable<DependencyRequest> dependencies,
+      ImmutableMap<BindingKey, Snippet> memberSelectSnippets) {
     ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
-    for (Key dependencyKey : SourceFiles.indexDependenciesByKey(dependencies).keySet()) {
-      parameters.add(memberSelectSnippets.get(dependencyKey));
+    for (BindingKey keys : SourceFiles.indexDependenciesByUnresolvedKey(dependencies).values()) {
+      parameters.add(memberSelectSnippets.get(keys));
     }
     return parameters.build();
   }
 
   private Snippet initializeMapBinding(
-      Map<TypeElement, FieldWriter> contributionFields,
-      ImmutableMap<ExecutableElement, TypeElement> dependencyMethodIndex,
-      ImmutableMap<Key, Snippet> memberSelectSnippets,
+      ImmutableMap<BindingKey, Snippet> memberSelectSnippets,
+      ImmutableMap<ContributionBinding, Snippet> multibindingContributionSnippets,
       Set<ProvisionBinding> bindings) {
     Iterator<ProvisionBinding> iterator = bindings.iterator();
     // get type information from first binding in iterator
@@ -589,7 +683,8 @@ private Snippet initializeMapBinding(
     if (isNonProviderMap(firstBinding)) {
       return Snippet.format("%s.create(%s)",
           ClassName.fromClass(MapFactory.class),
-          memberSelectSnippets.get(Iterables.getOnlyElement(firstBinding.dependencies()).key()));
+          memberSelectSnippets.get(BindingKey.forDependencyRequest(
+              Iterables.getOnlyElement(firstBinding.dependencies()))));
     } else {
       DeclaredType mapType = asDeclared(firstBinding.key().type());
       TypeMirror mapKeyType = Util.getKeyTypeOfMap(mapType);
@@ -606,12 +701,10 @@ private Snippet initializeMapBinding(
       argsBuilder.add(TypeNames.forTypeMirror(mapValueType));
       argsBuilder.add(bindings.size());
 
-      writeEntry(argsBuilder, firstBinding, initializeFactoryForBinding(
-          firstBinding, dependencyMethodIndex, contributionFields, memberSelectSnippets));
+      writeEntry(argsBuilder, firstBinding, multibindingContributionSnippets.get(firstBinding));
       while (iterator.hasNext()) {
         ProvisionBinding binding = iterator.next();
-        writeEntry(argsBuilder, binding, initializeFactoryForBinding(
-            binding, dependencyMethodIndex, contributionFields, memberSelectSnippets));
+        writeEntry(argsBuilder, binding, multibindingContributionSnippets.get(binding));
       }
 
       return Snippet.format(snippetFormatBuilder.toString(),
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
index 067194867..b458ee322 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -15,13 +15,15 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.auto.common.MoreElements;
-import com.google.auto.common.SuperficialValidation;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
 import dagger.Component;
 import dagger.internal.codegen.ComponentDescriptor.Factory;
+import java.lang.annotation.Annotation;
 import java.util.Set;
 import javax.annotation.processing.Messager;
-import javax.annotation.processing.RoundEnvironment;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 
@@ -55,33 +57,34 @@
   }
 
   @Override
-  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
-    Set<? extends Element> componentElements = roundEnv.getElementsAnnotatedWith(Component.class);
+  public Set<Class<? extends Annotation>> annotations() {
+    return ImmutableSet.<Class<? extends Annotation>>of(Component.class);
+  }
+
+  @Override
+  public void process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    Set<? extends Element> componentElements = elementsByAnnotation.get(Component.class);
 
     for (Element element : componentElements) {
-      if (SuperficialValidation.validateElement(element)) {
-        TypeElement componentTypeElement = MoreElements.asType(element);
-        ValidationReport<TypeElement> componentReport =
-            componentValidator.validate(componentTypeElement);
-        componentReport.printMessagesTo(messager);
-        if (componentReport.isClean()) {
-          ComponentDescriptor componentDescriptor =
-              componentDescriptorFactory.create(componentTypeElement);
-          BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
-          ValidationReport<BindingGraph> graphReport =
-              bindingGraphValidator.validate(bindingGraph);
-          graphReport.printMessagesTo(messager);
-          if (graphReport.isClean()) {
-            try {
-              componentGenerator.generate(bindingGraph);
-            } catch (SourceFileGenerationException e) {
-              e.printMessageTo(messager);
-            }
+      TypeElement componentTypeElement = MoreElements.asType(element);
+      ValidationReport<TypeElement> componentReport =
+          componentValidator.validate(componentTypeElement);
+      componentReport.printMessagesTo(messager);
+      if (componentReport.isClean()) {
+        ComponentDescriptor componentDescriptor =
+            componentDescriptorFactory.forComponent(componentTypeElement);
+        BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
+        ValidationReport<BindingGraph> graphReport =
+            bindingGraphValidator.validate(bindingGraph);
+        graphReport.printMessagesTo(messager);
+        if (graphReport.isClean()) {
+          try {
+            componentGenerator.generate(bindingGraph);
+          } catch (SourceFileGenerationException e) {
+            e.printMessageTo(messager);
           }
         }
       }
     }
-
-    return false;
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index b01d7ee54..3e449e4fe 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -15,26 +15,27 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.BasicAnnotationProcessor;
 import com.google.auto.service.AutoService;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
-import dagger.Component;
-import dagger.MapKey;
 import dagger.Module;
 import dagger.Provides;
+import dagger.internal.codegen.BindingGraphValidator.ScopeCycleValidation;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import java.util.Map;
 import java.util.Set;
-import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.Filer;
 import javax.annotation.processing.Messager;
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.annotation.processing.Processor;
-import javax.annotation.processing.RoundEnvironment;
-import javax.inject.Inject;
 import javax.lang.model.SourceVersion;
-import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
+import static javax.tools.Diagnostic.Kind.ERROR;
+
 /**
  * The annotation processor responsible for generating the classes that drive the Dagger 2.0
  * implementation.
@@ -45,29 +46,21 @@
  * @since 2.0
  */
 @AutoService(Processor.class)
-public final class ComponentProcessor extends AbstractProcessor {
-  private ImmutableList<ProcessingStep> processingSteps;
+public final class ComponentProcessor extends BasicAnnotationProcessor {
   private InjectBindingRegistry injectBindingRegistry;
 
-  @Override
-  public Set<String> getSupportedAnnotationTypes() {
-    return ImmutableSet.of(
-        Component.class.getName(),
-        Inject.class.getName(),
-        Module.class.getName(),
-        Provides.class.getName(),
-        MapKey.class.getName());
-  }
-
   @Override
   public SourceVersion getSupportedSourceVersion() {
     return SourceVersion.latestSupported();
   }
 
   @Override
-  public synchronized void init(ProcessingEnvironment processingEnv) {
-    super.init(processingEnv);
+  public Set<String> getSupportedOptions() {
+    return ImmutableSet.of(DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY);
+  }
 
+  @Override
+  protected Iterable<ProcessingStep> initSteps() {
     Messager messager = processingEnv.getMessager();
     Types types = processingEnv.getTypeUtils();
     Elements elements = processingEnv.getElementUtils();
@@ -76,22 +69,30 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
     InjectConstructorValidator injectConstructorValidator = new InjectConstructorValidator();
     InjectFieldValidator injectFieldValidator = new InjectFieldValidator();
     InjectMethodValidator injectMethodValidator = new InjectMethodValidator();
-    ModuleValidator moduleValidator = new ModuleValidator(types);
+    ModuleValidator moduleValidator = new ModuleValidator(types, Module.class, Provides.class);
     ProvidesMethodValidator providesMethodValidator = new ProvidesMethodValidator(elements);
     ComponentValidator componentValidator = new ComponentValidator();
     MapKeyValidator mapKeyValidator = new MapKeyValidator();
+    ModuleValidator producerModuleValidator = new ModuleValidator(
+        types, ProducerModule.class, Produces.class);
+    ProducesMethodValidator producesMethodValidator = new ProducesMethodValidator(elements);
+    ProductionComponentValidator productionComponentValidator = new ProductionComponentValidator();
 
     Key.Factory keyFactory = new Key.Factory(types, elements);
 
-    FactoryGenerator factoryGenerator = new FactoryGenerator(filer);
+    FactoryGenerator factoryGenerator =
+        new FactoryGenerator(filer, DependencyRequestMapper.FOR_PROVIDER);
     MembersInjectorGenerator membersInjectorGenerator =
-        new MembersInjectorGenerator(filer, elements, types);
+        new MembersInjectorGenerator(filer, elements, types, DependencyRequestMapper.FOR_PROVIDER);
     ComponentGenerator componentGenerator = new ComponentGenerator(filer);
+    ProducerFactoryGenerator producerFactoryGenerator =
+        new ProducerFactoryGenerator(filer, DependencyRequestMapper.FOR_PRODUCER);
 
-    DependencyRequest.Factory dependencyRequestFactory =
-        new DependencyRequest.Factory(elements, types, keyFactory);
+    DependencyRequest.Factory dependencyRequestFactory = new DependencyRequest.Factory(keyFactory);
     ProvisionBinding.Factory provisionBindingFactory =
         new ProvisionBinding.Factory(elements, types, keyFactory, dependencyRequestFactory);
+    ProductionBinding.Factory productionBindingFactory =
+        new ProductionBinding.Factory(keyFactory, dependencyRequestFactory);
 
     MembersInjectionBinding.Factory membersInjectionBindingFactory =
         new MembersInjectionBinding.Factory(elements, types, keyFactory, dependencyRequestFactory);
@@ -101,18 +102,19 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
         membersInjectionBindingFactory, membersInjectorGenerator);
 
     ComponentDescriptor.Factory componentDescriptorFactory =
-        new ComponentDescriptor.Factory(elements, types, provisionBindingFactory);
+        new ComponentDescriptor.Factory(elements, types);
 
     BindingGraph.Factory bindingGraphFactory = new BindingGraph.Factory(
-        elements, types, injectBindingRegistry, keyFactory, dependencyRequestFactory,
-        provisionBindingFactory);
+        elements, types, injectBindingRegistry, keyFactory,
+        dependencyRequestFactory, provisionBindingFactory);
 
     MapKeyGenerator mapKeyGenerator = new MapKeyGenerator(filer);
+    BindingGraphValidator bindingGraphValidator = new BindingGraphValidator(
+        types,
+        injectBindingRegistry,
+        disableInterComponentScopeValidation(processingEnv));
 
-    BindingGraphValidator bindingGraphValidator = new BindingGraphValidator(types,
-        injectBindingRegistry);
-
-    this.processingSteps = ImmutableList.<ProcessingStep>of(
+    return ImmutableList.<ProcessingStep>of(
         new MapKeyProcessingStep(
             messager,
             mapKeyValidator,
@@ -137,19 +139,45 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
             bindingGraphValidator,
             componentDescriptorFactory,
             bindingGraphFactory,
-            componentGenerator));
+            componentGenerator),
+        new ProducerModuleProcessingStep(
+            messager,
+            producerModuleValidator,
+            producesMethodValidator,
+            productionBindingFactory,
+            producerFactoryGenerator),
+        new ProductionComponentProcessingStep(
+            messager,
+            productionComponentValidator,
+            componentDescriptorFactory));
   }
 
   @Override
-  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
-    for (ProcessingStep processingStep : processingSteps) {
-      processingStep.process(annotations, roundEnv);
-    }
+  protected void postProcess() {
     try {
       injectBindingRegistry.generateSourcesForRequiredBindings();
     } catch (SourceFileGenerationException e) {
       e.printMessageTo(processingEnv.getMessager());
     }
-    return false;
+  }
+
+  private static final String DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY =
+      "dagger.disableInterComponentScopeValidation";
+
+  private static ScopeCycleValidation disableInterComponentScopeValidation(
+      ProcessingEnvironment processingEnv) {
+    Map<String, String> options = processingEnv.getOptions();
+    if (options.containsKey(DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY)) {
+      try {
+        return ScopeCycleValidation.valueOf(
+            options.get(DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY).toUpperCase());
+      } catch (IllegalArgumentException e) {
+        processingEnv.getMessager().printMessage(ERROR, "Processor option -A"
+            + DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY
+            + " may only have the values ERROR, WARNING, or NONE (case insensitive) "
+            + " found: " + options.get(DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY));
+      }
+    }
+    return ScopeCycleValidation.ERROR;
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
index 58d72fea6..f60e07f35 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -15,8 +15,11 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.common.MoreTypes;
+import com.google.common.base.Function;
 import com.google.common.base.Optional;
+import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
@@ -25,17 +28,19 @@
 import dagger.Component;
 import dagger.MapKey;
 import dagger.Module;
+import java.util.List;
 import java.util.Map;
 import java.util.Queue;
 import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Types;
 
+import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.AnnotationMirrors.getAttributeAsListOfTypes;
 /**
  * Utility methods related to dagger configuration annotations (e.g.: {@link Component}
  * and {@link Module}).
@@ -47,34 +52,46 @@
 
   static ImmutableList<TypeMirror> getComponentModules(AnnotationMirror componentAnnotation) {
     checkNotNull(componentAnnotation);
-    return getAttributeAsListOfTypes(componentAnnotation, MODULES_ATTRIBUTE);
+    return convertClassArrayToListOfTypes(componentAnnotation, MODULES_ATTRIBUTE);
   }
 
   private static final String DEPENDENCIES_ATTRIBUTE = "dependencies";
 
   static ImmutableList<TypeMirror> getComponentDependencies(AnnotationMirror componentAnnotation) {
     checkNotNull(componentAnnotation);
-    return getAttributeAsListOfTypes(componentAnnotation, DEPENDENCIES_ATTRIBUTE);
+    return convertClassArrayToListOfTypes(componentAnnotation, DEPENDENCIES_ATTRIBUTE);
   }
 
   private static final String INCLUDES_ATTRIBUTE = "includes";
 
   static ImmutableList<TypeMirror> getModuleIncludes(AnnotationMirror moduleAnnotation) {
     checkNotNull(moduleAnnotation);
-    return getAttributeAsListOfTypes(moduleAnnotation, INCLUDES_ATTRIBUTE);
+    return convertClassArrayToListOfTypes(moduleAnnotation, INCLUDES_ATTRIBUTE);
   }
 
   private static final String INJECTS_ATTRIBUTE = "injects";
 
   static ImmutableList<TypeMirror> getModuleInjects(AnnotationMirror moduleAnnotation) {
     checkNotNull(moduleAnnotation);
-    return getAttributeAsListOfTypes(moduleAnnotation, INJECTS_ATTRIBUTE);
+    return convertClassArrayToListOfTypes(moduleAnnotation, INJECTS_ATTRIBUTE);
   }
 
   static ImmutableSet<? extends AnnotationMirror> getMapKeys(Element element) {
     return AnnotationMirrors.getAnnotatedAnnotations(element, MapKey.class);
   }
 
+  static ImmutableList<TypeMirror> convertClassArrayToListOfTypes(
+      AnnotationMirror annotationMirror, final String elementName) {
+    @SuppressWarnings("unchecked") // that's the whole point of this method
+    List<? extends AnnotationValue> listValue = (List<? extends AnnotationValue>)
+        getAnnotationValue(annotationMirror, elementName).getValue();
+    return FluentIterable.from(listValue).transform(new Function<AnnotationValue, TypeMirror>() {
+      @Override public TypeMirror apply(AnnotationValue typeValue) {
+        return (TypeMirror) typeValue.getValue();
+      }
+    }).toList();
+  }
+
   /**
    * Returns the full set of modules transitively {@linkplain Module#includes included} from the
    * given seed modules.  If a module is malformed and a type listed in {@link Module#includes}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
new file mode 100644
index 000000000..688018fac
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableListMultimap;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Ordering;
+import java.util.EnumSet;
+import java.util.Set;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+
+/**
+ * An abstract class for a value object representing the mechanism by which a {@link Key} can be
+ * contributed to a dependency graph.
+ *
+ * @author Jesse Beder
+ * @since 2.0
+ */
+abstract class ContributionBinding extends Binding {
+  static enum BindingType {
+    /** Represents map bindings. */
+    MAP,
+    /** Represents set bindings. */
+    SET,
+    /** Represents a valid non-collection binding. */
+    UNIQUE;
+
+    boolean isMultibinding() {
+      return !this.equals(UNIQUE);
+    }
+  }
+
+  abstract BindingType bindingType();
+
+  /**
+   * Returns the set of {@link BindingType} enum values implied by a given
+   * {@link ContributionBinding} collection.
+   */
+  static <B extends ContributionBinding> ImmutableListMultimap<BindingType, B> bindingTypesFor(
+      Iterable<B> bindings) {
+    ImmutableListMultimap.Builder<BindingType, B> builder =
+        ImmutableListMultimap.builder();
+    builder.orderKeysBy(Ordering.<BindingType>natural());
+    for (B binding : bindings) {
+      builder.put(binding.bindingType(), binding);
+    }
+    return builder.build();
+  }
+
+  /**
+   * Returns a single {@code BindingsType} represented by a given collection of
+   * {@code ContributionBindings} or throws an IllegalArgumentException if the given bindings
+   * are not all of one type.
+   */
+  static BindingType bindingTypeFor(Iterable<? extends ContributionBinding> bindings) {
+    checkNotNull(bindings);
+    checkArgument(!Iterables.isEmpty(bindings), "no bindings");
+    Set<BindingType> types = EnumSet.noneOf(BindingType.class);
+    for (ContributionBinding binding : bindings) {
+      types.add(binding.bindingType());
+    }
+    if (types.size() > 1) {
+      throw new IllegalArgumentException(
+          String.format(ErrorMessages.MULTIPLE_BINDING_TYPES_FORMAT, types));
+    }
+    return Iterables.getOnlyElement(types);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index cad93e194..68c2a6a18 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -24,21 +24,23 @@
 import dagger.Lazy;
 import dagger.MembersInjector;
 import dagger.Provides;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
 import java.util.List;
 import javax.inject.Inject;
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 
+import static com.google.auto.common.MoreTypes.isTypeOf;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
 
 /**
  * Represents a request for a key at an injection point. Parameters to {@link Inject} constructors
@@ -59,6 +61,10 @@
     LAZY,
     /** A request for a {@link MembersInjector}.  E.g.: {@code MembersInjector<Blah>} */
     MEMBERS_INJECTOR,
+    /** A request for a {@link Producer}.  E.g.: {@code Producer<Blah>} */
+    PRODUCER,
+    /** A request for a {@link Produced}.  E.g.: {@code Produced<Blah>} */
+    PRODUCED,
   }
 
   abstract Kind kind();
@@ -66,16 +72,22 @@
   abstract Element requestElement();
 
   static final class Factory {
-    private final Elements elements;
-    private final Types types;
     private final Key.Factory keyFactory;
 
-    Factory(Elements elements, Types types, Key.Factory keyFactory) {
-      this.elements = elements;
-      this.types = types;
+    Factory(Key.Factory keyFactory) {
       this.keyFactory = keyFactory;
     }
 
+    ImmutableSet<DependencyRequest> forRequiredResolvedVariables(
+        List<? extends VariableElement> variables, List<? extends TypeMirror> resolvedTypes) {
+      checkState(resolvedTypes.size() == variables.size());
+      ImmutableSet.Builder<DependencyRequest> builder = ImmutableSet.builder();
+      for (int i = 0; i < variables.size(); i++) {
+         builder.add(forRequiredResolvedVariable(variables.get(i), resolvedTypes.get(i)));
+      }
+      return builder.build();
+    }
+
     ImmutableSet<DependencyRequest> forRequiredVariables(
         List<? extends VariableElement> variables) {
       return FluentIterable.from(variables)
@@ -105,6 +117,14 @@ DependencyRequest forRequiredVariable(VariableElement variableElement) {
       return newDependencyRequest(variableElement, type, qualifier);
     }
 
+    DependencyRequest forRequiredResolvedVariable(VariableElement variableElement,
+        TypeMirror resolvedType) {
+      checkNotNull(variableElement);
+      checkNotNull(resolvedType);
+      Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(variableElement);
+      return newDependencyRequest(variableElement, resolvedType, qualifier);
+    }
+
     DependencyRequest forComponentProvisionMethod(ExecutableElement provisionMethod) {
       checkNotNull(provisionMethod);
       checkArgument(provisionMethod.getParameters().isEmpty(),
@@ -125,43 +145,57 @@ DependencyRequest forComponentMembersInjectionMethod(ExecutableElement membersIn
           membersInjectionMethod);
     }
 
-    DependencyRequest forMembersInjectedType(TypeElement type) {
+    DependencyRequest forMembersInjectedType(DeclaredType type) {
       return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR,
-          // TODO(gak): handle this better
-          keyFactory.forMembersInjectedType(types.erasure(type.asType())),
-          type);
+          keyFactory.forMembersInjectedType(type),
+          type.asElement());
     }
 
     private DependencyRequest newDependencyRequest(Element requestElement, TypeMirror type,
         Optional<AnnotationMirror> qualifier) {
-      if (isTypeOf(Provider.class, type)) {
-        return new AutoValue_DependencyRequest(Kind.PROVIDER,
-            qualifiedTypeForParameter(qualifier, (DeclaredType) type),
+      KindAndType kindAndType = extractKindAndType(type);
+      if (kindAndType.kind() == Kind.MEMBERS_INJECTOR) {
+        checkArgument(!qualifier.isPresent());
+      }
+      return new AutoValue_DependencyRequest(kindAndType.kind(),
+            keyFactory.forQualifiedType(qualifier, kindAndType.type()),
             requestElement);
+    }
+    
+    @AutoValue
+    static abstract class KindAndType {
+      abstract Kind kind();
+      abstract TypeMirror type();
+    }
+    
+    /**
+     * Extracts the correct requesting type & kind out a request type. For example, if a user
+     * requests Provider<Foo>, this will return Kind.PROVIDER with "Foo".
+     */
+    static KindAndType extractKindAndType(TypeMirror type) {
+      // We must check TYPEVAR explicitly before the below checks because calling
+      // isTypeOf(..) on a TYPEVAR throws an exception (because it can't be
+      // represented as a Class).
+      if (type.getKind().equals(TypeKind.TYPEVAR)) {
+        return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.INSTANCE, type);
+      } else if (isTypeOf(Provider.class, type)) {
+        return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.PROVIDER,
+            Iterables.getOnlyElement(((DeclaredType)type).getTypeArguments()));
       } else if (isTypeOf(Lazy.class, type)) {
-        return new AutoValue_DependencyRequest(Kind.LAZY,
-            qualifiedTypeForParameter(qualifier, (DeclaredType) type),
-            requestElement);
+        return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.LAZY,
+            Iterables.getOnlyElement(((DeclaredType)type).getTypeArguments()));
       } else if (isTypeOf(MembersInjector.class, type)) {
-        checkArgument(!qualifier.isPresent());
-        return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR,
-            qualifiedTypeForParameter(qualifier, (DeclaredType) type),
-            requestElement);
+        return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.MEMBERS_INJECTOR,
+            Iterables.getOnlyElement(((DeclaredType)type).getTypeArguments()));
+      } else if (isTypeOf(Producer.class, type)) {
+        return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.PRODUCER,
+            Iterables.getOnlyElement(((DeclaredType)type).getTypeArguments()));
+      } else if (isTypeOf(Produced.class, type)) {
+        return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.PRODUCED,
+            Iterables.getOnlyElement(((DeclaredType)type).getTypeArguments()));
       } else {
-        return new AutoValue_DependencyRequest(Kind.INSTANCE,
-            keyFactory.forQualifiedType(qualifier, type),
-            requestElement);
+        return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.INSTANCE, type);
       }
     }
-
-    private Key qualifiedTypeForParameter(
-        Optional<AnnotationMirror> qualifier, DeclaredType type) {
-      return keyFactory.forQualifiedType(qualifier,
-          Iterables.getOnlyElement(type.getTypeArguments()));
-    }
-
-    private boolean isTypeOf(Class<?> type, TypeMirror mirror) {
-      return elements.getTypeElement(type.getCanonicalName()).equals(types.asElement(mirror));
-    }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestMapper.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestMapper.java
new file mode 100644
index 000000000..c0deb49b2
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestMapper.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import dagger.MembersInjector;
+import dagger.producers.Producer;
+import javax.inject.Provider;
+
+/**
+ * A mapper for associating a {@link DependencyRequest} to a framework class, dependent on
+ * the type of code to be generated (e.g., for {@link Provider} or {@link Producer}).
+ *
+ *  @author Jesse Beder
+ *  @since 2.0
+ */
+abstract class DependencyRequestMapper {
+  abstract Class<?> getFrameworkClass(DependencyRequest request);
+
+  private static final class MapperForProvider extends DependencyRequestMapper {
+    @Override public Class<?> getFrameworkClass(DependencyRequest request) {
+      switch (request.kind()) {
+        case INSTANCE:
+        case PROVIDER:
+        case LAZY:
+          return Provider.class;
+        case MEMBERS_INJECTOR:
+          return MembersInjector.class;
+        case PRODUCED:
+        case PRODUCER:
+          throw new IllegalArgumentException();
+        default:
+          throw new AssertionError();
+      }
+    }
+  }
+
+  static final DependencyRequestMapper FOR_PROVIDER = new MapperForProvider();
+
+  private static final class MapperForProducer extends DependencyRequestMapper {
+    @Override public Class<?> getFrameworkClass(DependencyRequest request) {
+      switch (request.kind()) {
+        case INSTANCE:
+        case PRODUCED:
+        case PRODUCER:
+          return Producer.class;
+        case PROVIDER:
+        case LAZY:
+          return Provider.class;
+        case MEMBERS_INJECTOR:
+          return MembersInjector.class;
+        default:
+          throw new AssertionError();
+      }
+    }
+  }
+
+  static final DependencyRequestMapper FOR_PRODUCER = new MapperForProducer();
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java b/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
index 668a2767e..1643adbc4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
@@ -45,6 +45,18 @@ public String apply(DependencyRequest dependency) {
         return variableName.endsWith("Provider") && !variableName.equals("Provider")
             ? variableName.substring(0, variableName.length() - 8)
             : variableName;
+      case MEMBERS_INJECTOR:
+        return variableName.endsWith("MembersInjector") && !variableName.equals("MembersInjector")
+            ? variableName.substring(0, variableName.length() - 15)
+            : variableName;
+      case PRODUCED:
+        return variableName.startsWith("produced") && !variableName.equals("produced")
+            ? Ascii.toLowerCase(variableName.charAt(8)) + variableName.substring(9)
+            : variableName;
+      case PRODUCER:
+        return variableName.endsWith("Producer") && !variableName.equals("Producer")
+            ? variableName.substring(0, variableName.length() - 8)
+            : variableName;
       default:
         throw new AssertionError();
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 52be09233..e76a01709 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -68,11 +68,10 @@
       "Dagger does not support injection into private constructors";
   static final String INJECT_CONSTRUCTOR_ON_INNER_CLASS =
       "@Inject constructors are invalid on inner classes";
-  static final String INJECT_CONSTRUCTOR_ON_GENERIC_CLASS =
-      "Generic types may not use @Inject constructors. "
-          + "Use a @Provides method to bind the type parameters.";
   static final String INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS =
       "@Inject is nonsense on the constructor of an abstract class";
+    static final String QUALIFIER_ON_INJECT_CONSTRUCTOR =
+      "@Qualifier annotations are not allowed on @Inject constructors.";
 
   /* fields */
   static final String PRIVATE_INJECT_FIELD =
@@ -98,38 +97,48 @@
   static final String PROVIDES_METHOD_RETURN_TYPE =
       "@Provides methods must either return a primitive, an array or a declared type.";
 
-  static final String PROVIDES_METHOD_SET_VALUES_RAW_SET =
-      "@Provides methods of type set values cannot return a raw Set";
+  static final String PRODUCES_METHOD_RETURN_TYPE =
+      "@Produces methods must either return a primitive, an array or a declared type, or a"
+      + " ListenableFuture of one of those types.";
+
+  static final String PRODUCES_METHOD_RAW_FUTURE =
+      "@Produces methods cannot return a raw ListenableFuture.";
+
+  static final String BINDING_METHOD_SET_VALUES_RAW_SET =
+      "@%s methods of type set values cannot return a raw Set";
 
   static final String PROVIDES_METHOD_SET_VALUES_RETURN_SET =
       "@Provides methods of type set values must return a Set";
 
-  static final String PROVIDES_METHOD_MUST_RETURN_A_VALUE =
-      "@Provides methods must return a value (not void).";
+  static final String PRODUCES_METHOD_SET_VALUES_RETURN_SET =
+      "@Produces methods of type set values must return a Set or ListenableFuture of Set";
+
+  static final String BINDING_METHOD_MUST_RETURN_A_VALUE =
+      "@%s methods must return a value (not void).";
 
-  static final String PROVIDES_METHOD_ABSTRACT = "@Provides methods cannot be abstract";
+  static final String BINDING_METHOD_ABSTRACT = "@%s methods cannot be abstract";
 
-  static final String PROVIDES_METHOD_STATIC = "@Provides methods cannot be static";
+  static final String BINDING_METHOD_STATIC = "@%s methods cannot be static";
 
-  static final String PROVIDES_METHOD_PRIVATE = "@Provides methods cannot be private";
+  static final String BINDING_METHOD_PRIVATE = "@%s methods cannot be private";
 
-  static final String PROVIDES_METHOD_TYPE_PARAMETER =
-      "@Provides methods may not have type parameters.";
+  static final String BINDING_METHOD_TYPE_PARAMETER =
+      "@%s methods may not have type parameters.";
 
-  static final String PROVIDES_METHOD_NOT_IN_MODULE =
-      "@Provides methods can only be present within a @Module";
+  static final String BINDING_METHOD_NOT_IN_MODULE =
+      "@%s methods can only be present within a @%s";
 
-  static final String PROVIDES_METHOD_NOT_MAP_HAS_MAP_KEY =
-      "@Provides methods of non map type cannot declare a map key";
+  static final String BINDING_METHOD_NOT_MAP_HAS_MAP_KEY =
+      "@%s methods of non map type cannot declare a map key";
 
-  static final String PROVIDES_METHOD_WITH_NO_MAP_KEY =
-      "@Provides methods of type map must declare a map key";
+  static final String BINDING_METHOD_WITH_NO_MAP_KEY =
+      "@%s methods of type map must declare a map key";
 
-  static final String PROVIDES_METHOD_WITH_MULTIPLE_MAP_KEY =
-      "@Provides methods may not have more than one @MapKey-marked annotation";
+  static final String BINDING_METHOD_WITH_MULTIPLE_MAP_KEY =
+      "@%s methods may not have more than one @MapKey-marked annotation";
 
-  static final String PROVIDES_METHOD_WITH_SAME_NAME =
-      "Cannot have more than one @Provides method with the same name in a single module";
+  static final String BINDING_METHOD_WITH_SAME_NAME =
+      "Cannot have more than one @%s method with the same name in a single module";
 
   /*mapKey errors*/
   static final String MAPKEY_WITHOUT_FIELDS =
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index d52a9c849..ae441f95c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -16,6 +16,7 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.MoreTypes;
+import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
@@ -34,21 +35,26 @@
 import dagger.internal.codegen.writer.Snippet;
 import dagger.internal.codegen.writer.TypeName;
 import dagger.internal.codegen.writer.TypeNames;
+import dagger.internal.codegen.writer.TypeVariableName;
 import dagger.internal.codegen.writer.TypeWriter;
 import java.util.Collections;
 import java.util.List;
-import java.util.Map.Entry;
+import java.util.Map;
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
 import javax.inject.Inject;
-import javax.inject.Provider;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeParameterElement;
 import javax.lang.model.type.TypeMirror;
 
+import static com.google.common.base.Preconditions.checkState;
 import static dagger.Provides.Type.SET;
+import static dagger.internal.codegen.ProvisionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
+import static dagger.internal.codegen.SourceFiles.parameterizedFactoryNameForProvisionBinding;
 import static dagger.internal.codegen.writer.Snippet.makeParametersSnippet;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -62,8 +68,11 @@
  * @since 2.0
  */
 final class FactoryGenerator extends SourceFileGenerator<ProvisionBinding> {
-  FactoryGenerator(Filer filer) {
+  private final DependencyRequestMapper dependencyRequestMapper;
+
+  FactoryGenerator(Filer filer, DependencyRequestMapper dependencyRequestMapper) {
     super(filer);
+    this.dependencyRequestMapper = dependencyRequestMapper;
   }
 
   @Override
@@ -83,6 +92,9 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
 
   @Override
   ImmutableSet<JavaWriter> write(ClassName generatedTypeName, ProvisionBinding binding) {
+    // We don't want to write out resolved bindings -- we want to write out the generic version.
+    checkState(!binding.isResolved());
+
     TypeMirror keyType = binding.provisionType().equals(Type.MAP)
         ? Util.getProvidedValueTypeOfMap(MoreTypes.asDeclared(binding.key().type()))
         : binding.key().type();
@@ -91,15 +103,26 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
 
     final TypeWriter factoryWriter;
     final Optional<ConstructorWriter> constructorWriter;
+    List<TypeVariableName> typeParameters = Lists.newArrayList();
+    for (TypeParameterElement typeParameter : binding.bindingTypeElement().getTypeParameters()) {
+     typeParameters.add(TypeVariableName.fromTypeParameterElement(typeParameter));          
+    }
     switch (binding.factoryCreationStrategy()) {
       case ENUM_INSTANCE:
         EnumWriter enumWriter = writer.addEnum(generatedTypeName.simpleName());
         enumWriter.addConstant("INSTANCE");
         constructorWriter = Optional.absent();
         factoryWriter = enumWriter;
+        // If we have type parameters, then remove the parameters from our providedTypeName,
+        // since we'll be implementing an erased version of it.
+        if (!typeParameters.isEmpty()) {
+          factoryWriter.annotate(SuppressWarnings.class).setValue("rawtypes");
+          providedTypeName = ((ParameterizedTypeName)providedTypeName).type();
+        }
         break;
       case CLASS_CONSTRUCTOR:
         ClassWriter classWriter = writer.addClass(generatedTypeName.simpleName());
+        classWriter.addTypeParameters(typeParameters);
         classWriter.addModifiers(FINAL);
         constructorWriter = Optional.of(classWriter.addConstructor());
         constructorWriter.get().addModifiers(PUBLIC);
@@ -119,11 +142,11 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
 
     factoryWriter.annotate(Generated.class).setValue(ComponentProcessor.class.getName());
     factoryWriter.addModifiers(PUBLIC);
-    factoryWriter.addImplementedType(ParameterizedTypeName.create(
-        ClassName.fromClass(Factory.class),
-        providedTypeName));
+    factoryWriter.addImplementedType(
+        ParameterizedTypeName.create(ClassName.fromClass(Factory.class), providedTypeName));
+    
 
-    MethodWriter getMethodWriter = factoryWriter.addMethod(keyType, "get");
+    MethodWriter getMethodWriter = factoryWriter.addMethod(providedTypeName, "get");
     getMethodWriter.annotate(Override.class);
     getMethodWriter.addModifiers(PUBLIC);
 
@@ -137,38 +160,61 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
           .addSnippet("this.membersInjector = membersInjector;");
     }
 
-    ImmutableMap<Key, String> names =
-        SourceFiles.generateFrameworkReferenceNamesForDependencies(binding.dependencies());
-
-    for (Entry<Key, String> nameEntry : names.entrySet()) {
-      final FieldWriter field;
-      switch (nameEntry.getKey().kind()) {
-        case PROVIDER:
-          ParameterizedTypeName providerType = ParameterizedTypeName.create(
-              ClassName.fromClass(Provider.class),
-              TypeNames.forTypeMirror(nameEntry.getKey().type()));
-          field = factoryWriter.addField(providerType, nameEntry.getValue());
-          break;
-        case MEMBERS_INJECTOR:
-          ParameterizedTypeName membersInjectorType = ParameterizedTypeName.create(
-              ClassName.fromClass(MembersInjector.class),
-              TypeNames.forTypeMirror(nameEntry.getKey().type()));
-          field = factoryWriter.addField(membersInjectorType, nameEntry.getValue());
-          break;
-        default:
-          throw new AssertionError();
-      }
+    ImmutableMap<BindingKey, FrameworkField> fields =
+        SourceFiles.generateBindingFieldsForDependencies(
+            dependencyRequestMapper, binding.dependencies());
+
+    for (FrameworkField bindingField : fields.values()) {
+      TypeName fieldType = bindingField.frameworkType();
+      FieldWriter field = factoryWriter.addField(fieldType, bindingField.name());
       field.addModifiers(PRIVATE, FINAL);
       constructorWriter.get().addParameter(field.type(), field.name());
       constructorWriter.get().body()
           .addSnippet("assert %s != null;", field.name())
           .addSnippet("this.%1$s = %1$s;", field.name());
     }
+    
+    // If constructing a factory for @Inject bindings, we use a static create method
+    // so that generated components can avoid having to refer to the generic types
+    // of the factory.  (Otherwise they may have visibility problems referring to the types.)
+    if (binding.bindingKind().equals(INJECTION)) {
+      // The return type is usually the same as the implementing type, except in the case
+      // of enums with type variables (where we cast).
+      TypeName returnType = ParameterizedTypeName.create(ClassName.fromClass(Factory.class),
+          TypeNames.forTypeMirror(keyType));
+      MethodWriter createMethodWriter = factoryWriter.addMethod(returnType, "create");
+      createMethodWriter.addTypeParameters(typeParameters);
+      createMethodWriter.addModifiers(Modifier.PUBLIC, Modifier.STATIC);
+      Map<String, TypeName> params = constructorWriter.isPresent()
+          ? constructorWriter.get().parameters() : ImmutableMap.<String, TypeName>of();
+      for (Map.Entry<String, TypeName> param : params.entrySet()) {
+        createMethodWriter.addParameter(param.getValue(), param.getKey());      
+      }
+      switch (binding.factoryCreationStrategy()) {
+        case ENUM_INSTANCE:
+          if (typeParameters.isEmpty()) {
+            createMethodWriter.body().addSnippet(" return INSTANCE;");
+          } else {
+            // We use an unsafe cast here because the types are different.
+            // It's safe because the type is never referenced anywhere.
+            createMethodWriter.annotate(SuppressWarnings.class).setValue("unchecked");
+            createMethodWriter.body().addSnippet(" return (Factory) INSTANCE;");
+          }
+          break;
+        case CLASS_CONSTRUCTOR:
+          createMethodWriter.body().addSnippet(" return new %s(%s);",
+              parameterizedFactoryNameForProvisionBinding(binding),
+              Joiner.on(", ").join(params.keySet()));
+          break;
+        default:
+          throw new AssertionError();
+      }
+    }
 
     List<Snippet> parameters = Lists.newArrayList();
     for (DependencyRequest dependency : binding.dependencies()) {
       parameters.add(frameworkTypeUsageStatement(
-          Snippet.format(names.get(dependency.key())),
+          Snippet.format(fields.get(BindingKey.forDependencyRequest(dependency)).name()),
           dependency.kind()));
     }
     Snippet parametersSnippet = makeParametersSnippet(parameters);
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
new file mode 100644
index 000000000..f6b207c09
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.ParameterizedTypeName;
+import dagger.internal.codegen.writer.TypeName;
+import dagger.internal.codegen.writer.TypeNames;
+import javax.lang.model.type.TypeMirror;
+
+/**
+ * A value object that represents a field used by Dagger-generated code.
+ *
+ * @author Jesse Beder
+ * @since 2.0
+ */
+@AutoValue
+abstract class FrameworkField {
+  // TODO(gak): reexamine the this class and how consistently we're using it and its creation
+  // methods
+
+  static FrameworkField createWithTypeFromKey(
+      Class<?> frameworkClass, BindingKey bindingKey, String name) {
+    String suffix = frameworkClass.getSimpleName();
+    ParameterizedTypeName frameworkType = ParameterizedTypeName.create(
+        ClassName.fromClass(frameworkClass),
+        TypeNames.forTypeMirror(bindingKey.key().type()));
+    return new AutoValue_FrameworkField(frameworkClass, frameworkType, bindingKey,
+        name.endsWith(suffix) ? name : name + suffix);
+  }
+
+  static FrameworkField createForMapBindingContribution(
+      Class<?> frameworkClass, BindingKey bindingKey, String name) {
+    TypeMirror mapValueType =
+        MoreTypes.asDeclared(bindingKey.key().type()).getTypeArguments().get(1);
+    return new AutoValue_FrameworkField(frameworkClass,
+        TypeNames.forTypeMirror(mapValueType),
+        bindingKey,
+        name);
+  }
+
+  abstract Class<?> frameworkClass();
+  abstract TypeName frameworkType();
+  abstract BindingKey bindingKey();
+  abstract String name();
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index b05cfc62d..515eef6f9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -16,6 +16,7 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
 import com.google.common.base.Optional;
 import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
@@ -44,8 +45,6 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
-import static com.google.common.base.Verify.verify;
-import static dagger.internal.codegen.Key.Kind.PROVIDER;
 
 /**
  * Maintains the collection of provision bindings from {@link Inject} constructors and members
@@ -64,9 +63,84 @@
   private final MembersInjectionBinding.Factory membersInjectionBindingFactory;
   private final MembersInjectorGenerator membersInjectorGenerator;
 
-  private final Map<Key, Binding> bindingsByKey = Maps.newLinkedHashMap();
-  private final Deque<Binding> bindingsRequiringGeneration = Queues.newArrayDeque();
-  private final Set<Binding> materializedBindings = Sets.newLinkedHashSet();
+  final class BindingsCollection<B extends Binding & ResolvableBinding> {
+    private final Map<Key, B> bindingsByKey = Maps.newLinkedHashMap();
+    private final Deque<B> bindingsRequiringGeneration = Queues.newArrayDeque();
+    private final Set<B> materializedBindings = Sets.newLinkedHashSet();
+
+    void generateBindings(SourceFileGenerator<B> generator) throws SourceFileGenerationException {
+      for (B binding = bindingsRequiringGeneration.poll();
+          binding != null;
+          binding = bindingsRequiringGeneration.poll()) {
+        checkState(!binding.isResolved());
+        generator.generate(binding);
+        materializedBindings.add(binding);
+      }
+    }
+
+    /** Returns a previously cached binding. */
+    B getBinding(Key key) {
+      return bindingsByKey.get(key);
+    }
+
+    /** Caches the binding and pretends a binding is generated without actually generating it. */
+    B pretendBindingGenerated(B binding, ClassName factoryName) {
+      tryToCacheBinding(binding);
+      if (shouldGenerateBinding(binding, factoryName)) {
+        materializedBindings.add(binding);
+      }
+      return binding;
+    }
+
+    /** Caches the binding and generates it if it needs generation. */
+    void tryRegisterBinding(B binding, ClassName factoryName, boolean explicit) {
+      tryToCacheBinding(binding);
+      tryToGenerateBinding(binding, factoryName, explicit);
+    }
+    
+    /**
+     * Tries to generate a binding, not generating if it already is generated. For resolved
+     * bindings, this will try to generate the unresolved version of the binding.
+     */
+    void tryToGenerateBinding(B binding, ClassName factoryName, boolean explicit) {
+      if (shouldGenerateBinding(binding, factoryName)) {
+        bindingsRequiringGeneration.offer(binding);
+        if (!explicit) {
+          messager.printMessage(Kind.NOTE, String.format(
+              "Generating a MembersInjector or Factory for %s. "
+                    + "Prefer to run the dagger processor over that class instead.",
+              types.erasure(binding.key().type()))); // erasure to strip <T> from msgs.
+        }
+      }
+    }
+    
+    /** Returns true if the binding needs to be generated. */
+    private boolean shouldGenerateBinding(B binding, ClassName factoryName) {
+      return !binding.isResolved()
+          && elements.getTypeElement(factoryName.canonicalName()) == null
+          && !materializedBindings.contains(binding)
+          && !bindingsRequiringGeneration.contains(binding);
+        
+    }
+
+    /** Caches the binding for future lookups by key. */
+    private void tryToCacheBinding(B binding) {
+      // We only cache resolved bindings or unresolved bindings w/o type arguments.
+      // Unresolved bindings w/ type arguments aren't valid for the object graph.
+      if (binding.isResolved()          
+          || binding.bindingTypeElement().getTypeParameters().isEmpty()) {        
+        Key key = binding.key();
+        Binding previousValue = bindingsByKey.put(key, binding);
+        checkState(previousValue == null || binding.equals(previousValue),
+            "couldn't register %s. %s was already registered for %s",
+            binding, previousValue, key);
+      }
+    }
+  }
+
+  private final BindingsCollection<ProvisionBinding> provisionBindings = new BindingsCollection<>();
+  private final BindingsCollection<MembersInjectionBinding> membersInjectionBindings =
+      new BindingsCollection<>();
 
   InjectBindingRegistry(Elements elements,
       Types types,
@@ -90,68 +164,53 @@
    * {@link #getOrFindMembersInjectionBinding} or {@link #getOrFindProvisionBinding}) are generated.
    */
   void generateSourcesForRequiredBindings() throws SourceFileGenerationException {
-    for (Binding binding = bindingsRequiringGeneration.poll();
-        binding != null;
-        binding = bindingsRequiringGeneration.poll()) {
-      switch (binding.key().kind()) {
-        case PROVIDER:
-          factoryGenerator.generate((ProvisionBinding) binding);
-          break;
-        case MEMBERS_INJECTOR:
-          membersInjectorGenerator.generate((MembersInjectionBinding) binding);
-          break;
-        default:
-          throw new AssertionError();
-      }
-      materializedBindings.add(binding);
-    }
+    provisionBindings.generateBindings(factoryGenerator);
+    membersInjectionBindings.generateBindings(membersInjectorGenerator);
   }
 
-  <B extends Binding> B registerBinding(B binding) {
+  ProvisionBinding registerBinding(ProvisionBinding binding) {
     return registerBinding(binding, true);
   }
 
-  private <B extends Binding> B registerBinding(B binding, boolean explicit) {
-    Key key = binding.key();
-    Binding previousValue = bindingsByKey.put(key, binding);
-    checkState(previousValue == null || binding.equals(previousValue),
-        "couldn't register %s. %s was already registered for %s",
-        binding, previousValue, key);
-    if (!materializedBindings.contains(binding) && !bindingsRequiringGeneration.contains(binding)) {
-      switch (key.kind()) {
-        case PROVIDER:
-          ProvisionBinding provisionBinding =  (ProvisionBinding) binding;
-          ClassName factoryName = SourceFiles.factoryNameForProvisionBinding(provisionBinding);
-          if (elements.getTypeElement(factoryName.canonicalName()) == null) {
-            bindingsRequiringGeneration.offer(provisionBinding);
-            if (!explicit) {
-              messager.printMessage(Kind.NOTE, String.format("Generating a Factory for %s. "
-                  + "Prefer to run the dagger processor over that class instead.", key.type()));
-            }
-          }
-          break;
-        case MEMBERS_INJECTOR:
-          MembersInjectionBinding membersInjectionBinding = (MembersInjectionBinding) binding;
-          if (membersInjectionBinding.injectionSites().isEmpty()) {
-            // empty members injection bindings are special and don't need source files.
-            // so, we just pretend
-            materializedBindings.add(binding);
-          } else  {
-            ClassName membersInjectorName =
-                SourceFiles.membersInjectorNameForMembersInjectionBinding(membersInjectionBinding);
-            if (elements.getTypeElement(membersInjectorName.canonicalName()) == null) {
-              bindingsRequiringGeneration.offer(membersInjectionBinding);
-              if (!explicit) {
-                messager.printMessage(Kind.NOTE, String.format(
-                    "Generating a MembersInjector for %s. "
-                          + "Prefer to run the dagger processor over that class instead.",
-                    key.type()));
-              }
-            }
-          }
-          break;
-        default:
-          throw new AssertionError();
+  MembersInjectionBinding registerBinding(MembersInjectionBinding binding) {
+    return registerBinding(binding, true);
+  }
+
+  /**
+   * Registers the binding for generation & later lookup. If the binding is resolved, we also
+   * attempt to register an unresolved version of it.
+   */
+  private ProvisionBinding registerBinding(ProvisionBinding binding, boolean explicit) {
+    ClassName factoryName = SourceFiles.factoryNameForProvisionBinding(binding);
+    provisionBindings.tryRegisterBinding(binding, factoryName, explicit);
+    if (binding.isResolved()) {
+      provisionBindings.tryToGenerateBinding(provisionBindingFactory.unresolve(binding),
+          factoryName, explicit);
+    }
+    return binding;
+  }
+
+  /**
+   * Registers the binding for generation & later lookup. If the binding is resolved, we also
+   * attempt to register an unresolved version of it.
+   */
+  private MembersInjectionBinding registerBinding(
+      MembersInjectionBinding binding, boolean explicit) {
+    ClassName membersInjectorName =
+        SourceFiles.membersInjectorNameForMembersInjectionBinding(binding);
+    if (binding.injectionSites().isEmpty()) {
+      // empty members injection bindings are special and don't need source files.
+      // so, we just pretend
+      membersInjectionBindings.pretendBindingGenerated(binding, membersInjectorName);
+      if (binding.isResolved()) {
+        membersInjectionBindings.pretendBindingGenerated(
+            membersInjectionBindingFactory.unresolve(binding), membersInjectorName);
+      }
+    } else {
+      membersInjectionBindings.tryRegisterBinding(binding, membersInjectorName, explicit);
+      if (binding.isResolved()) {
+        membersInjectionBindings.tryToGenerateBinding(
+            membersInjectionBindingFactory.unresolve(binding), membersInjectorName, explicit);
       }
     }
     return binding;
@@ -159,15 +218,14 @@ void generateSourcesForRequiredBindings() throws SourceFileGenerationException {
 
   Optional<ProvisionBinding> getOrFindProvisionBinding(Key key) {
     checkNotNull(key);
-    checkArgument(key.kind().equals(PROVIDER));
-    if (key.qualifier().isPresent()) {
+    if (!key.isValidImplicitProvisionKey(types)) {
       return Optional.absent();
     }
-    Binding binding = bindingsByKey.get(key);
+    ProvisionBinding binding = provisionBindings.getBinding(key);
     if (binding != null) {
-      verify(binding instanceof ProvisionBinding);
-      return Optional.of((ProvisionBinding) binding);
+      return Optional.of(binding);
     }
+    
     // ok, let's see if we can find an @Inject constructor
     TypeElement element = MoreElements.asType(types.asElement(key.type()));
     List<ExecutableElement> constructors =
@@ -184,7 +242,7 @@ void generateSourcesForRequiredBindings() throws SourceFileGenerationException {
         return Optional.absent();
       case 1:
         ProvisionBinding constructorBinding = provisionBindingFactory.forInjectConstructor(
-            Iterables.getOnlyElement(injectConstructors));
+            Iterables.getOnlyElement(injectConstructors), Optional.of(key.type()));
         return Optional.of(registerBinding(constructorBinding, false));
       default:
         throw new IllegalStateException("Found multiple @Inject constructors: "
@@ -196,12 +254,11 @@ MembersInjectionBinding getOrFindMembersInjectionBinding(Key key) {
     checkNotNull(key);
     // TODO(gak): is checking the kind enough?
     checkArgument(key.isValidMembersInjectionKey());
-    Binding binding = bindingsByKey.get(key);
-    if (binding == null) {
-      TypeElement element = MoreElements.asType(types.asElement(key.type()));
-      binding = registerBinding(membersInjectionBindingFactory.forInjectedType(element), false);
+    MembersInjectionBinding binding = membersInjectionBindings.getBinding(key);
+    if (binding != null) {
+      return binding;
     }
-    verify(binding instanceof MembersInjectionBinding);
-    return (MembersInjectionBinding) binding;
+    return registerBinding(membersInjectionBindingFactory.forInjectedType(
+        MoreTypes.asDeclared(key.type()), Optional.of(key.type())), false);
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java b/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java
index c5b689a64..ac4f914e3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java
@@ -30,13 +30,13 @@
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS;
-import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_GENERIC_CLASS;
 import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_INNER_CLASS;
 import static dagger.internal.codegen.ErrorMessages.INJECT_INTO_PRIVATE_CLASS;
 import static dagger.internal.codegen.ErrorMessages.INJECT_ON_PRIVATE_CONSTRUCTOR;
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_INJECT_CONSTRUCTORS;
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_QUALIFIERS;
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_SCOPES;
+import static dagger.internal.codegen.ErrorMessages.QUALIFIER_ON_INJECT_CONSTRUCTOR;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
 import static dagger.internal.codegen.InjectionAnnotations.getScopes;
 import static javax.lang.model.element.Modifier.ABSTRACT;
@@ -58,6 +58,10 @@
       builder.addItem(INJECT_ON_PRIVATE_CONSTRUCTOR, constructorElement);
     }
 
+    for (AnnotationMirror qualifier : getQualifiers(constructorElement)) {
+      builder.addItem(QUALIFIER_ON_INJECT_CONSTRUCTOR, constructorElement, qualifier);
+    }
+
     for (VariableElement parameter : constructorElement.getParameters()) {
       ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(parameter);
       if (qualifiers.size() > 1) {
@@ -79,10 +83,6 @@
       builder.addItem(INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS, constructorElement);
     }
 
-    if (!enclosingElement.getTypeParameters().isEmpty()) {
-      builder.addItem(INJECT_CONSTRUCTOR_ON_GENERIC_CLASS, constructorElement);
-    }
-
     if (enclosingElement.getNestingKind().isNested()
         && !typeModifiers.contains(STATIC)) {
       builder.addItem(INJECT_CONSTRUCTOR_ON_INNER_CLASS, constructorElement);
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
index 587df5bc7..faa69dc5f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
@@ -15,17 +15,20 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreElements;
-import com.google.auto.common.SuperficialValidation;
+import com.google.auto.common.BasicAnnotationProcessor;
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import java.lang.annotation.Annotation;
 import java.util.Set;
 import javax.annotation.processing.Messager;
-import javax.annotation.processing.RoundEnvironment;
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementKindVisitor6;
 
 /**
@@ -35,7 +38,7 @@
  * @author Gregory Kick
  * @since 2.0
  */
-final class InjectProcessingStep implements ProcessingStep {
+final class InjectProcessingStep implements BasicAnnotationProcessor.ProcessingStep {
   private final Messager messager;
   private final InjectConstructorValidator constructorValidator;
   private final InjectFieldValidator fieldValidator;
@@ -61,71 +64,74 @@
   }
 
   @Override
-  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
+  public Set<Class<? extends Annotation>> annotations() {
+    return ImmutableSet.<Class<? extends Annotation>>of(Inject.class);
+  }
+
+  @Override
+  public void process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
     // TODO(gak): add some error handling for bad source files
     final ImmutableSet.Builder<ProvisionBinding> provisions = ImmutableSet.builder();
     // TODO(gak): instead, we should collect reports by type and check later
-    final ImmutableSet.Builder<TypeElement> membersInjectedTypes = ImmutableSet.builder();
-
-    for (Element injectElement : roundEnv.getElementsAnnotatedWith(Inject.class)) {
-      if (SuperficialValidation.validateElement(injectElement)) {
-        injectElement.accept(
-            new ElementKindVisitor6<Void, Void>() {
-              @Override
-              public Void visitExecutableAsConstructor(
-                  ExecutableElement constructorElement, Void v) {
-                ValidationReport<ExecutableElement> report =
-                    constructorValidator.validate(constructorElement);
-
-                report.printMessagesTo(messager);
-
-                if (report.isClean()) {
-                  provisions.add(provisionBindingFactory.forInjectConstructor(constructorElement));
-                }
-
-                return null;
+    final ImmutableSet.Builder<DeclaredType> membersInjectedTypes = ImmutableSet.builder();
+
+    for (Element injectElement : elementsByAnnotation.get(Inject.class)) {
+      injectElement.accept(
+          new ElementKindVisitor6<Void, Void>() {
+            @Override
+            public Void visitExecutableAsConstructor(
+                ExecutableElement constructorElement, Void v) {
+              ValidationReport<ExecutableElement> report =
+                  constructorValidator.validate(constructorElement);
+
+              report.printMessagesTo(messager);
+
+              if (report.isClean()) {
+                provisions.add(provisionBindingFactory.forInjectConstructor(constructorElement,
+                    Optional.<TypeMirror>absent()));
               }
 
-              @Override
-              public Void visitVariableAsField(VariableElement fieldElement, Void p) {
-                ValidationReport<VariableElement> report = fieldValidator.validate(fieldElement);
+              return null;
+            }
 
-                report.printMessagesTo(messager);
+            @Override
+            public Void visitVariableAsField(VariableElement fieldElement, Void p) {
+              ValidationReport<VariableElement> report = fieldValidator.validate(fieldElement);
 
-                if (report.isClean()) {
-                  membersInjectedTypes.add(MoreElements.asType(fieldElement.getEnclosingElement()));
-                }
+              report.printMessagesTo(messager);
 
-                return null;
+              if (report.isClean()) {
+                membersInjectedTypes.add(
+                    MoreTypes.asDeclared(fieldElement.getEnclosingElement().asType()));
               }
 
-              @Override
-              public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
-                ValidationReport<ExecutableElement> report =
-                    methodValidator.validate(methodElement);
+              return null;
+            }
 
-                report.printMessagesTo(messager);
+            @Override
+            public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
+              ValidationReport<ExecutableElement> report =
+                  methodValidator.validate(methodElement);
 
-                if (report.isClean()) {
-                  membersInjectedTypes.add(
-                      MoreElements.asType(methodElement.getEnclosingElement()));
-                }
+              report.printMessagesTo(messager);
 
-                return null;
+              if (report.isClean()) {
+                membersInjectedTypes.add(
+                    MoreTypes.asDeclared(methodElement.getEnclosingElement().asType()));
               }
-            }, null);
-      }
+
+              return null;
+            }
+          }, null);
     }
 
-    for (TypeElement injectedType : membersInjectedTypes.build()) {
-      injectBindingRegistry.registerBinding(
-          membersInjectionBindingFactory.forInjectedType(injectedType));
+    for (DeclaredType injectedType : membersInjectedTypes.build()) {
+      injectBindingRegistry.registerBinding(membersInjectionBindingFactory.forInjectedType(
+          injectedType, Optional.<TypeMirror>absent()));
     }
 
     for (ProvisionBinding binding : provisions.build()) {
       injectBindingRegistry.registerBinding(binding);
     }
-
-    return false;
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
index ec57fe1be..b3b245dfb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.AnnotationMirrors;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
 import javax.inject.Qualifier;
@@ -55,7 +56,7 @@
         return Optional.<AnnotationMirror>of(qualifierAnnotations.iterator().next());
       default:
         throw new IllegalArgumentException(
-            e + " was annotated with more than one @Scope annotation");
+            e + " was annotated with more than one @Qualifier annotation");
     }
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 430d66cf4..4f93eac26 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -15,21 +15,26 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.AnnotationMirrors;
+import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
 import com.google.common.base.MoreObjects;
 import com.google.common.base.Optional;
 import com.google.common.collect.Iterables;
+import com.google.common.util.concurrent.ListenableFuture;
 import dagger.MapKey;
-import dagger.MembersInjector;
 import dagger.Provides;
+import dagger.producers.Produces;
 import java.util.Map;
 import java.util.Set;
 import javax.inject.Provider;
 import javax.inject.Qualifier;
 import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.PrimitiveType;
@@ -45,7 +50,6 @@
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
 import static dagger.internal.codegen.Util.unwrapOptionalEquivalence;
 import static dagger.internal.codegen.Util.wrapOptionalInEquivalence;
-import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.ElementKind.METHOD;
 import static javax.lang.model.type.TypeKind.DECLARED;
 
@@ -57,29 +61,6 @@
  */
 @AutoValue
 abstract class Key {
-  /**
-   * The aspect of the framework for which a {@link Key} is an identifier. Particularly, whether a
-   * key is for a {@link Provider} or a {@link MembersInjector}.
-   */
-  enum Kind {
-    PROVIDER(Provider.class),
-    MEMBERS_INJECTOR(MembersInjector.class),
-    ;
-
-    private final Class<?> frameworkClass;
-
-    Kind(Class<?> frameworkClass) {
-      this.frameworkClass = frameworkClass;
-    }
-
-    Class<?> frameworkClass() {
-      return frameworkClass;
-    }
-  }
-
-  /** Returns the particular kind of this key. */
-  abstract Kind kind();
-
   /**
    * A {@link javax.inject.Qualifier} annotation that provides a unique namespace prefix
    * for the type of this key.
@@ -106,21 +87,60 @@ TypeMirror type() {
     return wrappedType().get();
   }
 
+  Key withType(TypeMirror newType) {
+    return new AutoValue_Key(wrappedQualifier(), MoreTypes.equivalence().wrap(newType));
+  }
+
   boolean isValidMembersInjectionKey() {
-    return !qualifier().isPresent()
-        && type().accept(new SimpleTypeVisitor6<Boolean, Void>(false) {
-          @Override
-          public Boolean visitDeclared(DeclaredType t, Void p) {
-            return t.getTypeArguments().isEmpty();
+    return !qualifier().isPresent();
+  }
+
+  /**
+   * Returns true if the key is valid as an implicit key (that is, if it's valid for a just-in-time
+   * binding by discovering an {@code @Inject} constructor).
+   */
+  boolean isValidImplicitProvisionKey(final Types types) {
+    // Qualifiers disqualify implicit provisioning.
+    if (qualifier().isPresent()) {
+      return false;
+    }
+
+    return type().accept(new SimpleTypeVisitor6<Boolean, Void>() {
+      @Override protected Boolean defaultAction(TypeMirror e, Void p) {
+        return false; // Only declared types are allowed.
+      }
+
+      @Override public Boolean visitDeclared(DeclaredType type, Void ignored) {
+        // Non-classes or abstract classes aren't allowed.
+        TypeElement element = MoreElements.asType(type.asElement());
+        if (!element.getKind().equals(ElementKind.CLASS)
+            || element.getModifiers().contains(Modifier.ABSTRACT)) {
+          return false;
+        }
+
+        // If the key has type arguments, validate that each type argument is declared.
+        // Otherwise the type argument may be a wildcard (or other type), and we can't
+        // resolve that to actual types.
+        for (TypeMirror arg : type.getTypeArguments()) {
+          if (arg.getKind() != TypeKind.DECLARED) {
+            return false;
           }
-        }, null);
+        }
+
+        // Also validate that the key is not the erasure of a generic type.
+        // If it is, that means the user referred to Foo<T> as just 'Foo',
+        // which we don't allow.  (This is a judgement call -- we *could*
+        // allow it and instantiate the type bounds... but we don't.)
+        return MoreTypes.asDeclared(element.asType()).getTypeArguments().isEmpty()
+            || !types.isSameType(types.erasure(element.asType()), type());
+      }
+    }, null);
   }
 
   @Override
   public String toString() {
     return MoreObjects.toStringHelper(Key.class)
         .omitNullValues()
-        .addValue(kind())
         .add("qualifier", qualifier().orNull())
         .add("type", type())
         .toString();
@@ -156,7 +176,7 @@ Key forComponentMethod(ExecutableElement componentMethod) {
       checkNotNull(componentMethod);
       checkArgument(componentMethod.getKind().equals(METHOD));
       TypeMirror returnType = normalize(componentMethod.getReturnType());
-      return new AutoValue_Key(Kind.PROVIDER,
+      return new AutoValue_Key(
           wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(componentMethod)),
           MoreTypes.equivalence().wrap(returnType));
     }
@@ -169,12 +189,12 @@ Key forProvidesMethod(ExecutableElement e) {
       TypeMirror returnType = normalize(e.getReturnType());
       switch (providesAnnotation.type()) {
         case UNIQUE:
-          return new AutoValue_Key(Kind.PROVIDER,
+          return new AutoValue_Key(
               wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(e)),
               MoreTypes.equivalence().wrap(returnType));
         case SET:
           TypeMirror setType = types.getDeclaredType(getSetElement(), returnType);
-          return new AutoValue_Key(Kind.PROVIDER,
+          return new AutoValue_Key(
               wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(e)),
               MoreTypes.equivalence().wrap(setType));
         case MAP:
@@ -187,14 +207,14 @@ Key forProvidesMethod(ExecutableElement e) {
           TypeMirror valueType = types.getDeclaredType(getProviderElement(), returnType);
           TypeMirror mapType =
               types.getDeclaredType(getMapElement(), keyTypeElement.asType(), valueType);
-          return new AutoValue_Key(Kind.PROVIDER,
+          return new AutoValue_Key(
               wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(e)),
               MoreTypes.equivalence().wrap(mapType));
         case SET_VALUES:
           // TODO(gak): do we want to allow people to use "covariant return" here?
           checkArgument(returnType.getKind().equals(DECLARED));
           checkArgument(((DeclaredType) returnType).asElement().equals(getSetElement()));
-          return new AutoValue_Key(Kind.PROVIDER,
+          return new AutoValue_Key(
               wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(e)),
               MoreTypes.equivalence().wrap(returnType));
         default:
@@ -202,31 +222,73 @@ Key forProvidesMethod(ExecutableElement e) {
       }
     }
 
-    Key forInjectConstructor(ExecutableElement e) {
+    // TODO(user): Reconcile this method with forProvidesMethod when Provides.Type and
+    // Produces.Type are no longer different.
+    Key forProducesMethod(ExecutableElement e) {
       checkNotNull(e);
-      checkArgument(e.getKind().equals(CONSTRUCTOR));
-      checkArgument(!getQualifier(e).isPresent());
-      // Must use the enclosing element.  The return type is void for constructors(?!)
-      TypeMirror type = e.getEnclosingElement().asType();
-      return new AutoValue_Key(Kind.PROVIDER,
+      checkArgument(e.getKind().equals(METHOD));
+      Produces producesAnnotation = e.getAnnotation(Produces.class);
+      checkArgument(producesAnnotation != null);
+      TypeMirror returnType = normalize(e.getReturnType());
+      TypeMirror keyType = returnType;
+      if (MoreTypes.isTypeOf(ListenableFuture.class, returnType)) {
+        keyType = Iterables.getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments());
+      }
+      switch (producesAnnotation.type()) {
+        case UNIQUE:
+          return new AutoValue_Key(
+              wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(e)),
+              MoreTypes.equivalence().wrap(keyType));
+        case SET:
+          TypeMirror setType = types.getDeclaredType(getSetElement(), keyType);
+          return new AutoValue_Key(
+              wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(e)),
+              MoreTypes.equivalence().wrap(setType));
+        case MAP:
+          AnnotationMirror mapKeyAnnotation = Iterables.getOnlyElement(getMapKeys(e));
+          MapKey mapKey =
+              mapKeyAnnotation.getAnnotationType().asElement().getAnnotation(MapKey.class);
+          TypeElement keyTypeElement =
+              mapKey.unwrapValue() ? Util.getKeyTypeElement(mapKeyAnnotation, elements)
+                  : (TypeElement) mapKeyAnnotation.getAnnotationType().asElement();
+          TypeMirror valueType = types.getDeclaredType(getProviderElement(), keyType);
+          TypeMirror mapType =
+              types.getDeclaredType(getMapElement(), keyTypeElement.asType(), valueType);
+          return new AutoValue_Key(
+              wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(e)),
+              MoreTypes.equivalence().wrap(mapType));
+        case SET_VALUES:
+          // TODO(gak): do we want to allow people to use "covariant return" here?
+          checkArgument(keyType.getKind().equals(DECLARED));
+          checkArgument(((DeclaredType) keyType).asElement().equals(getSetElement()));
+          return new AutoValue_Key(
+              wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(e)),
+              MoreTypes.equivalence().wrap(keyType));
+        default:
+          throw new AssertionError();
+      }
+    }
+
+    Key forInjectConstructorWithResolvedType(TypeMirror type) {
+      return new AutoValue_Key(
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           MoreTypes.equivalence().wrap(type));
     }
 
     Key forComponent(TypeMirror type) {
-      return new AutoValue_Key(Kind.PROVIDER,
+      return new AutoValue_Key(
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           MoreTypes.equivalence().wrap(normalize(type)));
     }
 
     Key forMembersInjectedType(TypeMirror type) {
-      return new AutoValue_Key(Kind.MEMBERS_INJECTOR,
+      return new AutoValue_Key(
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           MoreTypes.equivalence().wrap(normalize(type)));
     }
 
     Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
-      return new AutoValue_Key(Kind.PROVIDER,
+      return new AutoValue_Key(
           wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), qualifier),
           MoreTypes.equivalence().wrap(normalize(type)));
     }
@@ -244,7 +306,7 @@ Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
           DeclaredType keyType = Util.getKeyTypeOfMap(declaredMapType);
           DeclaredType providerType = types.getDeclaredType(getProviderElement(), mapValueType);
           TypeMirror mapType = types.getDeclaredType(getMapElement(), keyType, providerType);
-          return Optional.<Key>of(new AutoValue_Key(Kind.PROVIDER,
+          return Optional.<Key>of(new AutoValue_Key(
               possibleMapKey.wrappedQualifier(),
               MoreTypes.equivalence().wrap(mapType)));
         }
diff --git a/compiler/src/main/java/dagger/internal/codegen/KeyVariableNamer.java b/compiler/src/main/java/dagger/internal/codegen/KeyVariableNamer.java
index 7bca5500c..c32d50806 100644
--- a/compiler/src/main/java/dagger/internal/codegen/KeyVariableNamer.java
+++ b/compiler/src/main/java/dagger/internal/codegen/KeyVariableNamer.java
@@ -31,7 +31,9 @@
  * @author Gregory Kick
  * @since 2.0
  */
-final class KeyVariableNamer implements Function<Key, String> {
+enum KeyVariableNamer implements Function<Key, String> {
+  INSTANCE;
+
   @Override
   public String apply(Key key) {
     StringBuilder builder = new StringBuilder();
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
index 0715ca724..b11eeec9a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
@@ -15,8 +15,6 @@
  */
 package dagger.internal.codegen;
 
-import dagger.internal.codegen.writer.TypeWriter;
-
 import com.google.auto.value.AutoAnnotation;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
@@ -25,6 +23,7 @@
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.JavaWriter;
 import dagger.internal.codegen.writer.MethodWriter;
+import dagger.internal.codegen.writer.TypeWriter;
 import java.util.ArrayList;
 import java.util.List;
 import javax.annotation.Generated;
@@ -34,6 +33,7 @@
 import javax.lang.model.element.Name;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
+
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
index 94513a31e..488f031c1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
@@ -15,13 +15,14 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.SuperficialValidation;
+import com.google.auto.common.BasicAnnotationProcessor;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
 import dagger.MapKey;
+import java.lang.annotation.Annotation;
 import java.util.Set;
 import javax.annotation.processing.Messager;
-import javax.annotation.processing.RoundEnvironment;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.TypeElement;
 
 /**
  * The annotation processor responsible for validating the mapKey annotation and auto-generate
@@ -30,40 +31,39 @@
  * @author Chenying Hou
  * @since 2.0
  */
-public class MapKeyProcessingStep implements ProcessingStep {
+public class MapKeyProcessingStep implements BasicAnnotationProcessor.ProcessingStep {
   private final Messager messager;
   private final MapKeyValidator mapKeyValidator;
   private final MapKeyGenerator mapKeyGenerator;
 
-  MapKeyProcessingStep(Messager messager, MapKeyValidator mapKeyValidator, MapKeyGenerator mapKeyGenerator) {
+  MapKeyProcessingStep(Messager messager, MapKeyValidator mapKeyValidator,
+      MapKeyGenerator mapKeyGenerator) {
     this.messager = messager;
     this.mapKeyValidator = mapKeyValidator;
     this.mapKeyGenerator = mapKeyGenerator;
   }
 
   @Override
-  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
-    if (!roundEnv.getElementsAnnotatedWith(MapKey.class).isEmpty()) {
-      // for each element annotated with @mapKey, validate it and auto generate key creator file for
-      // any unwrapped key
-      for (Element element : roundEnv.getElementsAnnotatedWith(MapKey.class)) {
-        if (SuperficialValidation.validateElement(element)) {
-          ValidationReport<Element> mapKeyReport = mapKeyValidator.validate(element);
-          mapKeyReport.printMessagesTo(messager);
+  public Set<Class<? extends Annotation>> annotations() {
+    return ImmutableSet.<Class<? extends Annotation>>of(MapKey.class);
+  }
+
+  @Override
+  public void process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    for (Element element : elementsByAnnotation.get(MapKey.class)) {
+      ValidationReport<Element> mapKeyReport = mapKeyValidator.validate(element);
+      mapKeyReport.printMessagesTo(messager);
 
-          if (mapKeyReport.isClean()) {
-            MapKey mapkey = element.getAnnotation(MapKey.class);
-            if (!mapkey.unwrapValue()) {
-              try {
-                mapKeyGenerator.generate(element);
-              } catch (SourceFileGenerationException e) {
-                e.printMessageTo(messager);
-              }
-            }
+      if (mapKeyReport.isClean()) {
+        MapKey mapkey = element.getAnnotation(MapKey.class);
+        if (!mapkey.unwrapValue()) {
+          try {
+            mapKeyGenerator.generate(element);
+          } catch (SourceFileGenerationException e) {
+            e.printMessageTo(messager);
           }
         }
       }
     }
-    return false;
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index 9fd1e7d4c..bebbcf727 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -16,6 +16,7 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
@@ -31,6 +32,8 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementKindVisitor6;
 import javax.lang.model.util.Elements;
@@ -39,7 +42,7 @@
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
-import static javax.lang.model.type.TypeKind.NONE;
+import static com.google.common.base.Preconditions.checkState;
 
 /**
  * Represents the full members injection of a particular type. This does not pay attention to
@@ -49,7 +52,7 @@
  * @since 2.0
  */
 @AutoValue
-abstract class MembersInjectionBinding extends Binding {
+abstract class MembersInjectionBinding extends Binding implements ResolvableBinding {
   @Override abstract TypeElement bindingElement();
 
   /** The set of individual sites where {@link Inject} is applied. */
@@ -106,25 +109,60 @@ private int targetIndexInEnclosing(InjectionSite injectionSite)  {
       this.dependencyRequestFactory = checkNotNull(dependencyRequestFactory);
     }
 
-    private InjectionSite injectionSiteForInjectMethod(ExecutableElement methodElement) {
+    private InjectionSite injectionSiteForInjectMethod(ExecutableElement methodElement,
+        DeclaredType containingType) {
       checkNotNull(methodElement);
       checkArgument(methodElement.getKind().equals(ElementKind.METHOD));
       checkArgument(isAnnotationPresent(methodElement, Inject.class));
+      ExecutableType resolved =
+          MoreTypes.asExecutable(types.asMemberOf(containingType, methodElement));
       return new AutoValue_MembersInjectionBinding_InjectionSite(InjectionSite.Kind.METHOD,
           methodElement,
-          dependencyRequestFactory.forRequiredVariables(methodElement.getParameters()));
+          dependencyRequestFactory.forRequiredResolvedVariables(
+              methodElement.getParameters(),
+              resolved.getParameterTypes()));
     }
 
-    private InjectionSite injectionSiteForInjectField(VariableElement fieldElement) {
+    private InjectionSite injectionSiteForInjectField(VariableElement fieldElement,
+        DeclaredType containingType) {
       checkNotNull(fieldElement);
       checkArgument(fieldElement.getKind().equals(ElementKind.FIELD));
       checkArgument(isAnnotationPresent(fieldElement, Inject.class));
+      TypeMirror resolved = types.asMemberOf(containingType, fieldElement);
       return new AutoValue_MembersInjectionBinding_InjectionSite(InjectionSite.Kind.FIELD,
           fieldElement,
-          ImmutableSet.of(dependencyRequestFactory.forRequiredVariable(fieldElement)));
+          ImmutableSet.of(
+              dependencyRequestFactory.forRequiredResolvedVariable(fieldElement, resolved)));
+    }
+    
+    
+    /** Returns an unresolved version of this binding. */
+    MembersInjectionBinding unresolve(MembersInjectionBinding binding) {
+      checkState(binding.isResolved());
+      DeclaredType unresolved = MoreTypes.asDeclared(binding.bindingElement().asType());
+      return forInjectedType(unresolved, Optional.<TypeMirror>absent());
     }
 
-    MembersInjectionBinding forInjectedType(TypeElement typeElement) {
+    /**
+     * Returns a MembersInjectionBinding for the given type. If {@code resolvedType} is present,
+     * this will return a {@link ResolvableBinding#isResolved() resolved} binding, with the key &
+     * type resolved to the given type (using {@link Types#asMemberOf(DeclaredType, Element)}).
+     */
+    MembersInjectionBinding forInjectedType(DeclaredType type, Optional<TypeMirror> resolvedType) {
+      boolean isResolved = false;
+      // If the class this is injecting has some type arguments, resolve everything.
+      if (!type.getTypeArguments().isEmpty() && resolvedType.isPresent()) {
+        DeclaredType resolved = MoreTypes.asDeclared(resolvedType.get());
+        // Validate that we're resolving from the correct type.
+        checkState(types.isSameType(types.erasure(resolved), types.erasure(type)),
+            "erased expected type: %s, erased actual type: %s",
+            types.erasure(resolved), types.erasure(type));
+        type = resolved;
+        isResolved = true;
+      }
+      
+      TypeElement typeElement = MoreElements.asType(type.asElement());
+      final DeclaredType resolved = type;
       ImmutableSortedSet.Builder<InjectionSite> injectionSitesBuilder =
           ImmutableSortedSet.orderedBy(INJECTION_ORDERING);
       for (Element enclosedElement : typeElement.getEnclosedElements()) {
@@ -135,14 +173,14 @@ MembersInjectionBinding forInjectedType(TypeElement typeElement) {
                   public Optional<InjectionSite> visitExecutableAsMethod(ExecutableElement e,
                       Void p) {
                     return isAnnotationPresent(e, Inject.class)
-                        ? Optional.of(injectionSiteForInjectMethod(e))
+                        ? Optional.of(injectionSiteForInjectMethod(e, resolved))
                         : Optional.<InjectionSite>absent();
                   }
 
                   @Override
                   public Optional<InjectionSite> visitVariableAsField(VariableElement e, Void p) {
                     return isAnnotationPresent(e, Inject.class)
-                        ? Optional.of(injectionSiteForInjectField(e))
+                        ? Optional.of(injectionSiteForInjectField(e, resolved))
                         : Optional.<InjectionSite>absent();
                   }
                 }, null).asSet());
@@ -157,15 +195,17 @@ MembersInjectionBinding forInjectedType(TypeElement typeElement) {
           })
           .toSet();
 
-      Optional<DependencyRequest> parentInjectorRequest = nonObjectSupertype(typeElement)
-          .transform(new Function<TypeElement, DependencyRequest>() {
-            @Override public DependencyRequest apply(TypeElement input) {
-              return dependencyRequestFactory.forMembersInjectedType(input);
-            }
-          });
+      Optional<DependencyRequest> parentInjectorRequest =
+          MoreTypes.nonObjectSuperclass(types, elements, type)
+              .transform(new Function<DeclaredType, DependencyRequest>() {
+                @Override public DependencyRequest apply(DeclaredType input) {
+                  return dependencyRequestFactory.forMembersInjectedType(input);
+                }
+              });
 
-      Key key = keyFactory.forMembersInjectedType(typeElement.asType());
+      Key key = keyFactory.forMembersInjectedType(type);
       return new AutoValue_MembersInjectionBinding(
+          isResolved,
           key,
           dependencies,
           new ImmutableSet.Builder<DependencyRequest>()
@@ -177,15 +217,5 @@ MembersInjectionBinding forInjectedType(TypeElement typeElement) {
           injectionSites,
           parentInjectorRequest);
     }
-
-    private Optional<TypeElement> nonObjectSupertype(TypeElement type) {
-      TypeMirror superclass = type.getSuperclass();
-      boolean nonObjectSuperclass = !superclass.getKind().equals(NONE)
-          && !types.isSameType(
-              elements.getTypeElement(Object.class.getCanonicalName()).asType(), superclass);
-      return nonObjectSuperclass
-          ? Optional.of(MoreElements.asType(types.asElement(superclass)))
-          : Optional.<TypeElement>absent();
-    }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index bf3b9635a..061359121 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -15,7 +15,7 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
@@ -24,6 +24,7 @@
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
 import dagger.MembersInjector;
 import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
 import dagger.internal.codegen.writer.ClassName;
@@ -34,20 +35,26 @@
 import dagger.internal.codegen.writer.MethodWriter;
 import dagger.internal.codegen.writer.ParameterizedTypeName;
 import dagger.internal.codegen.writer.Snippet;
+import dagger.internal.codegen.writer.TypeName;
 import dagger.internal.codegen.writer.TypeNames;
+import dagger.internal.codegen.writer.TypeVariableName;
 import dagger.internal.codegen.writer.VoidName;
+import java.util.List;
+import java.util.Map;
 import java.util.Map.Entry;
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
-import javax.inject.Provider;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.TypeMirror;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeParameterElement;
+import javax.lang.model.type.DeclaredType;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
+import static dagger.internal.codegen.SourceFiles.parameterizedMembersInjectorNameForMembersInjectionBinding;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
@@ -61,11 +68,17 @@
 final class MembersInjectorGenerator extends SourceFileGenerator<MembersInjectionBinding> {
   private final Elements elements;
   private final Types types;
+  private final DependencyRequestMapper dependencyRequestMapper;
 
-  MembersInjectorGenerator(Filer filer, Elements elements, Types types) {
+  MembersInjectorGenerator(
+      Filer filer,
+      Elements elements,
+      Types types,
+      DependencyRequestMapper dependencyRequestMapper) {
     super(filer);
     this.elements = checkNotNull(elements);
     this.types = checkNotNull(types);
+    this.dependencyRequestMapper = dependencyRequestMapper;
   }
 
   @Override
@@ -91,33 +104,42 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
   }
 
   @Override
-  ImmutableSet<JavaWriter> write(ClassName injectorClassName, MembersInjectionBinding binding) {
-    ClassName injectedClassName = ClassName.fromTypeElement(binding.bindingElement());
+  ImmutableSet<JavaWriter> write(ClassName generatedTypeName, MembersInjectionBinding binding) {
+    // We don't want to write out resolved bindings -- we want to write out the generic version.
+    checkState(!binding.isResolved());
 
-    JavaWriter writer = JavaWriter.inPackage(injectedClassName.packageName());
+    TypeName injectedTypeName = TypeNames.forTypeMirror(binding.key().type());
+    JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
 
-    ClassWriter injectorWriter = writer.addClass(injectorClassName.simpleName());
+    ClassWriter injectorWriter = writer.addClass(generatedTypeName.simpleName());
+    List<TypeVariableName> typeParameters = Lists.newArrayList();
+    for (TypeParameterElement typeParameter : binding.bindingTypeElement().getTypeParameters()) {
+      typeParameters.add(TypeVariableName.fromTypeParameterElement(typeParameter));
+    }
+    injectorWriter.addTypeParameters(typeParameters);
     injectorWriter.annotate(Generated.class)
         .setValue(ComponentProcessor.class.getCanonicalName());
     injectorWriter.addModifiers(PUBLIC, FINAL);
-    injectorWriter.addImplementedType(
-        ParameterizedTypeName.create(MembersInjector.class, injectedClassName));
+    TypeName implementedType =
+        ParameterizedTypeName.create(MembersInjector.class, injectedTypeName);
+    injectorWriter.addImplementedType(implementedType);
 
     ConstructorWriter constructorWriter = injectorWriter.addConstructor();
     constructorWriter.addModifiers(PUBLIC);
     MethodWriter injectMembersWriter = injectorWriter.addMethod(VoidName.VOID, "injectMembers");
     injectMembersWriter.addModifiers(PUBLIC);
     injectMembersWriter.annotate(Override.class);
-    injectMembersWriter.addParameter(injectedClassName, "instance");
+    injectMembersWriter.addParameter(injectedTypeName, "instance");
     injectMembersWriter.body().addSnippet(Joiner.on('\n').join(
         "if (instance == null) {",
         "  throw new NullPointerException(\"Cannot inject members into a null reference\");",
         "}"));
 
-    Optional<TypeElement> supertype = supertype(binding.bindingElement());
+    Optional<DeclaredType> supertype =
+        MoreTypes.nonObjectSuperclass(types, elements, MoreTypes.asDeclared(binding.key().type()));
     if (supertype.isPresent()) {
       ParameterizedTypeName supertypeMemebersInjectorType = ParameterizedTypeName.create(
-          MembersInjector.class, ClassName.fromTypeElement(supertype.get()));
+          MembersInjector.class, TypeNames.forTypeMirror(supertype.get()));
       injectorWriter
           .addField(supertypeMemebersInjectorType, "supertypeInjector")
           .addModifiers(PRIVATE, FINAL);
@@ -128,44 +150,46 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
       injectMembersWriter.body().addSnippet("supertypeInjector.injectMembers(instance);");
     }
 
-    ImmutableMap<Key, String> names =
-        SourceFiles.generateFrameworkReferenceNamesForDependencies(
-            ImmutableSet.copyOf(binding.dependencies()));
+    ImmutableMap<BindingKey, FrameworkField> fields =
+        SourceFiles.generateBindingFieldsForDependencies(
+            dependencyRequestMapper, ImmutableSet.copyOf(binding.dependencies()));
 
-    ImmutableMap.Builder<Key, FieldWriter> dependencyFieldsBuilder =
+    ImmutableMap.Builder<BindingKey, FieldWriter> dependencyFieldsBuilder =
         ImmutableMap.builder();
 
-    for (Entry<Key, String> nameEntry : names.entrySet()) {
-      final FieldWriter field;
-      switch (nameEntry.getKey().kind()) {
-        case PROVIDER:
-          ParameterizedTypeName providerType = ParameterizedTypeName.create(
-              ClassName.fromClass(Provider.class),
-              TypeNames.forTypeMirror(nameEntry.getKey().type()));
-          field = injectorWriter.addField(providerType, nameEntry.getValue());
-          break;
-        case MEMBERS_INJECTOR:
-          ParameterizedTypeName membersInjectorType = ParameterizedTypeName.create(
-              ClassName.fromClass(MembersInjector.class),
-              TypeNames.forTypeMirror(nameEntry.getKey().type()));
-          field = injectorWriter.addField(membersInjectorType, nameEntry.getValue());
-          break;
-        default:
-          throw new AssertionError();
-      }
+    for (Entry<BindingKey, FrameworkField> fieldEntry : fields.entrySet()) {
+      FrameworkField bindingField = fieldEntry.getValue();
+      TypeName fieldType = bindingField.frameworkType();
+      FieldWriter field = injectorWriter.addField(fieldType, bindingField.name());
       field.addModifiers(PRIVATE, FINAL);
       constructorWriter.addParameter(field.type(), field.name());
       constructorWriter.body().addSnippet("assert %s != null;", field.name());
       constructorWriter.body().addSnippet("this.%1$s = %1$s;", field.name());
-      dependencyFieldsBuilder.put(nameEntry.getKey(), field);
+      dependencyFieldsBuilder.put(fieldEntry.getKey(), field);
+    }
+    
+    // We use a static create method so that generated components can avoid having
+    // to refer to the generic types of the factory.
+    // (Otherwise they may have visibility problems referring to the types.)
+    MethodWriter createMethodWriter = injectorWriter.addMethod(implementedType, "create");
+    createMethodWriter.addTypeParameters(typeParameters);
+    createMethodWriter.addModifiers(Modifier.PUBLIC, Modifier.STATIC);
+    Map<String, TypeName> params = constructorWriter.parameters();
+    for (Map.Entry<String, TypeName> param : params.entrySet()) {
+      createMethodWriter.addParameter(param.getValue(), param.getKey());      
     }
-    ImmutableMap<Key, FieldWriter> depedencyFields = dependencyFieldsBuilder.build();
+    createMethodWriter.body().addSnippet("  return new %s(%s);",
+        parameterizedMembersInjectorNameForMembersInjectionBinding(binding),
+        Joiner.on(", ").join(params.keySet()));
+    
+    ImmutableMap<BindingKey, FieldWriter> depedencyFields = dependencyFieldsBuilder.build();
     for (InjectionSite injectionSite : binding.injectionSites()) {
       switch (injectionSite.kind()) {
         case FIELD:
           DependencyRequest fieldDependency =
               Iterables.getOnlyElement(injectionSite.dependencies());
-          FieldWriter singleField = depedencyFields.get(fieldDependency.key());
+          FieldWriter singleField = depedencyFields.get(
+              BindingKey.forDependencyRequest(fieldDependency));
           injectMembersWriter.body().addSnippet("instance.%s = %s;",
               injectionSite.element().getSimpleName(),
               frameworkTypeUsageStatement(Snippet.format(singleField.name()),
@@ -174,8 +198,8 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
         case METHOD:
           ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
           for (DependencyRequest methodDependency : injectionSite.dependencies()) {
-            FieldWriter field =
-            depedencyFields.get(methodDependency.key());
+            FieldWriter field = depedencyFields.get(
+                BindingKey.forDependencyRequest(methodDependency));
             parameters.add(frameworkTypeUsageStatement(Snippet.format(field.name()),
                 methodDependency.kind()));
           }
@@ -189,13 +213,4 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
     }
     return ImmutableSet.of(writer);
   }
-
-  private Optional<TypeElement> supertype(TypeElement type) {
-    TypeMirror superclass = type.getSuperclass();
-    boolean nonObjectSuperclass = !types.isSameType(
-        elements.getTypeElement(Object.class.getCanonicalName()).asType(), superclass);
-    return nonObjectSuperclass
-        ? Optional.of(MoreElements.asType(types.asElement(superclass)))
-        : Optional.<TypeElement>absent();
-  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
index 0dca93377..a7d06a6a6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
@@ -15,18 +15,19 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.BasicAnnotationProcessor;
 import com.google.auto.common.MoreElements;
-import com.google.auto.common.SuperficialValidation;
 import com.google.common.base.Function;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
 import com.google.common.collect.Sets;
 import dagger.Module;
 import dagger.Provides;
+import java.lang.annotation.Annotation;
 import java.util.List;
 import java.util.Set;
 import javax.annotation.processing.Messager;
-import javax.annotation.processing.RoundEnvironment;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -42,7 +43,7 @@
  * @author Gregory Kick
  * @since 2.0
  */
-final class ModuleProcessingStep implements ProcessingStep {
+final class ModuleProcessingStep implements BasicAnnotationProcessor.ProcessingStep {
   private final Messager messager;
   private final ModuleValidator moduleValidator;
   private final ProvidesMethodValidator providesMethodValidator;
@@ -64,10 +65,15 @@
   }
 
   @Override
-  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
+  public Set<Class<? extends Annotation>> annotations() {
+    return ImmutableSet.of(Module.class, Provides.class);
+  }
+
+  @Override
+  public void process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
     // first, check and collect all provides methods
     ImmutableSet.Builder<ExecutableElement> validProvidesMethodsBuilder = ImmutableSet.builder();
-    for (Element providesElement : roundEnv.getElementsAnnotatedWith(Provides.class)) {
+    for (Element providesElement : elementsByAnnotation.get(Provides.class)) {
       if (providesElement.getKind().equals(METHOD)) {
         ExecutableElement providesMethodElement = (ExecutableElement) providesElement;
         ValidationReport<ExecutableElement> methodReport =
@@ -82,49 +88,46 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
 
     // process each module
     for (Element moduleElement :
-        Sets.difference(roundEnv.getElementsAnnotatedWith(Module.class), processedModuleElements)) {
-      if (SuperficialValidation.validateElement(moduleElement)) {
-        ValidationReport<TypeElement> report =
-            moduleValidator.validate(MoreElements.asType(moduleElement));
-        report.printMessagesTo(messager);
+        Sets.difference(elementsByAnnotation.get(Module.class), processedModuleElements)) {
+      ValidationReport<TypeElement> report =
+          moduleValidator.validate(MoreElements.asType(moduleElement));
+      report.printMessagesTo(messager);
 
-        if (report.isClean()) {
-          ImmutableSet.Builder<ExecutableElement> moduleProvidesMethodsBuilder =
-              ImmutableSet.builder();
-          List<ExecutableElement> moduleMethods =
-              ElementFilter.methodsIn(moduleElement.getEnclosedElements());
-          for (ExecutableElement methodElement : moduleMethods) {
-            if (isAnnotationPresent(methodElement, Provides.class)) {
-              moduleProvidesMethodsBuilder.add(methodElement);
-            }
+      if (report.isClean()) {
+        ImmutableSet.Builder<ExecutableElement> moduleProvidesMethodsBuilder =
+            ImmutableSet.builder();
+        List<ExecutableElement> moduleMethods =
+            ElementFilter.methodsIn(moduleElement.getEnclosedElements());
+        for (ExecutableElement methodElement : moduleMethods) {
+          if (isAnnotationPresent(methodElement, Provides.class)) {
+            moduleProvidesMethodsBuilder.add(methodElement);
           }
-          ImmutableSet<ExecutableElement> moduleProvidesMethods =
-              moduleProvidesMethodsBuilder.build();
+        }
+        ImmutableSet<ExecutableElement> moduleProvidesMethods =
+            moduleProvidesMethodsBuilder.build();
 
-          if (Sets.difference(moduleProvidesMethods, validProvidesMethods).isEmpty()) {
-            // all of the provides methods in this module are valid!
-            // time to generate some factories!
-            ImmutableSet<ProvisionBinding> bindings = FluentIterable.from(moduleProvidesMethods)
-                .transform(new Function<ExecutableElement, ProvisionBinding>() {
-                  @Override
-                  public ProvisionBinding apply(ExecutableElement providesMethod) {
-                    return provisionBindingFactory.forProvidesMethod(providesMethod);
-                  }
-                })
-                .toSet();
+        if (Sets.difference(moduleProvidesMethods, validProvidesMethods).isEmpty()) {
+          // all of the provides methods in this module are valid!
+          // time to generate some factories!
+          ImmutableSet<ProvisionBinding> bindings = FluentIterable.from(moduleProvidesMethods)
+              .transform(new Function<ExecutableElement, ProvisionBinding>() {
+                @Override
+                public ProvisionBinding apply(ExecutableElement providesMethod) {
+                  return provisionBindingFactory.forProvidesMethod(providesMethod);
+                }
+              })
+              .toSet();
 
-            try {
-              for (ProvisionBinding binding : bindings) {
-                factoryGenerator.generate(binding);
-              }
-            } catch (SourceFileGenerationException e) {
-              e.printMessageTo(messager);
+          try {
+            for (ProvisionBinding binding : bindings) {
+              factoryGenerator.generate(binding);
             }
+          } catch (SourceFileGenerationException e) {
+            e.printMessageTo(messager);
           }
         }
-        processedModuleElements.add(moduleElement);
       }
+      processedModuleElements.add(moduleElement);
     }
-    return false;
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
index f84212aa4..9c360e8b0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
@@ -23,7 +23,8 @@
 import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableSet;
 import dagger.Module;
-import dagger.Provides;
+import dagger.producers.ProducerModule;
+import java.lang.annotation.Annotation;
 import java.util.Collection;
 import java.util.List;
 import java.util.Map.Entry;
@@ -40,19 +41,26 @@
 import static com.google.auto.common.Visibility.PUBLIC;
 import static com.google.auto.common.Visibility.effectiveVisibilityOfElement;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleIncludes;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_WITH_SAME_NAME;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;
 
 /**
- * A {@link Validator} for {@link Module}s.
+ * A {@link Validator} for {@link Module}s or {@link ProducerModule}s.
  *
  * @author Gregory Kick
  * @since 2.0
  */
 final class ModuleValidator implements Validator<TypeElement> {
   private final Types types;
+  private final Class<? extends Annotation> moduleClass;
+  private final Class<? extends Annotation> methodClass;
 
-  ModuleValidator(Types types) {
+  ModuleValidator(
+      Types types,
+      Class<? extends Annotation> moduleClass,
+      Class<? extends Annotation> methodClass) {
     this.types = types;
+    this.moduleClass = moduleClass;
+    this.methodClass = methodClass;
   }
 
   @Override
@@ -62,18 +70,19 @@
     validateModuleVisibility(subject, builder);
 
     List<ExecutableElement> moduleMethods = ElementFilter.methodsIn(subject.getEnclosedElements());
-    ImmutableListMultimap.Builder<String, ExecutableElement> providesMethodsByName =
+    ImmutableListMultimap.Builder<String, ExecutableElement> bindingMethodsByName =
         ImmutableListMultimap.builder();
     for (ExecutableElement moduleMethod : moduleMethods) {
-      if (isAnnotationPresent(moduleMethod, Provides.class)) {
-        providesMethodsByName.put(moduleMethod.getSimpleName().toString(), moduleMethod);
+      if (isAnnotationPresent(moduleMethod, methodClass)) {
+        bindingMethodsByName.put(moduleMethod.getSimpleName().toString(), moduleMethod);
       }
     }
     for (Entry<String, Collection<ExecutableElement>> entry :
-        providesMethodsByName.build().asMap().entrySet()) {
+        bindingMethodsByName.build().asMap().entrySet()) {
       if (entry.getValue().size() > 1) {
         for (ExecutableElement offendingMethod : entry.getValue()) {
-          builder.addItem(PROVIDES_METHOD_WITH_SAME_NAME, offendingMethod);
+          builder.addItem(String.format(BINDING_METHOD_WITH_SAME_NAME, methodClass.getSimpleName()),
+              offendingMethod);
         }
       }
     }
@@ -99,7 +108,7 @@ private void validateModuleVisibility(final TypeElement moduleElement,
       case TOP_LEVEL:
         if (moduleVisibility.equals(PUBLIC)) {
           ImmutableSet<Element> nonPublicModules = FluentIterable.from(getModuleIncludes(
-              getAnnotationMirror(moduleElement, Module.class).get()))
+              getAnnotationMirror(moduleElement, moduleClass).get()))
                   .transform(new Function<TypeMirror, Element>() {
                     @Override public Element apply(TypeMirror input) {
                       return types.asElement(input);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
new file mode 100644
index 000000000..895dd647f
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -0,0 +1,378 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Function;
+import com.google.common.base.Joiner;
+import com.google.common.base.Optional;
+import com.google.common.base.Predicate;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import com.google.common.util.concurrent.AsyncFunction;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.Provides.Type;
+import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.ClassWriter;
+import dagger.internal.codegen.writer.ConstructorWriter;
+import dagger.internal.codegen.writer.FieldWriter;
+import dagger.internal.codegen.writer.JavaWriter;
+import dagger.internal.codegen.writer.MethodWriter;
+import dagger.internal.codegen.writer.ParameterizedTypeName;
+import dagger.internal.codegen.writer.Snippet;
+import dagger.internal.codegen.writer.TypeName;
+import dagger.internal.codegen.writer.TypeNames;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import dagger.producers.Produces;
+import dagger.producers.internal.AbstractProducer;
+import dagger.producers.internal.Producers;
+import java.util.List;
+import java.util.concurrent.Callable;
+import java.util.concurrent.Executor;
+import javax.annotation.Generated;
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.Element;
+import javax.lang.model.type.TypeMirror;
+
+import static dagger.internal.codegen.SourceFiles.factoryNameForProductionBinding;
+import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
+import static dagger.internal.codegen.writer.Snippet.makeParametersSnippet;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PROTECTED;
+import static javax.lang.model.element.Modifier.PUBLIC;
+
+/**
+ * Generates {@link Producer} implementations from {@link ProductionBinding} instances.
+ *
+ * @author Jesse Beder
+ * @since 2.0
+ */
+final class ProducerFactoryGenerator extends SourceFileGenerator<ProductionBinding> {
+  private final DependencyRequestMapper dependencyRequestMapper;
+
+  ProducerFactoryGenerator(Filer filer, DependencyRequestMapper dependencyRequestMapper) {
+    super(filer);
+    this.dependencyRequestMapper = dependencyRequestMapper;
+  }
+
+  @Override
+  ClassName nameGeneratedType(ProductionBinding binding) {
+    return factoryNameForProductionBinding(binding);
+  }
+
+  @Override
+  Iterable<? extends Element> getOriginatingElements(ProductionBinding binding) {
+    return ImmutableSet.of(binding.bindingElement());
+  }
+
+  @Override
+  Optional<? extends Element> getElementForErrorReporting(ProductionBinding binding) {
+    return Optional.of(binding.bindingElement());
+  }
+
+  @Override
+  ImmutableSet<JavaWriter> write(ClassName generatedTypeName, ProductionBinding binding) {
+    TypeMirror keyType = binding.productionType().equals(Type.MAP)
+        ? Util.getProvidedValueTypeOfMap(MoreTypes.asDeclared(binding.key().type()))
+        : binding.key().type();
+    TypeName providedTypeName = TypeNames.forTypeMirror(keyType);
+    TypeName futureTypeName = ParameterizedTypeName.create(
+        ClassName.fromClass(ListenableFuture.class), providedTypeName);
+    JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
+
+    ClassWriter factoryWriter = writer.addClass(generatedTypeName.simpleName());
+    ConstructorWriter constructorWriter = factoryWriter.addConstructor();
+    constructorWriter.addModifiers(PUBLIC);
+
+    factoryWriter.addField(binding.bindingTypeElement(), "module")
+        .addModifiers(PRIVATE, FINAL);
+    constructorWriter.addParameter(binding.bindingTypeElement(), "module");
+    constructorWriter.body()
+        .addSnippet("assert module != null;")
+        .addSnippet("this.module = module;");
+
+    factoryWriter.addField(Executor.class, "executor")
+        .addModifiers(PRIVATE, FINAL);
+    constructorWriter.addParameter(Executor.class, "executor");
+    constructorWriter.body()
+        .addSnippet("assert executor != null;")
+        .addSnippet("this.executor = executor;");
+
+    factoryWriter.annotate(Generated.class).setValue(ComponentProcessor.class.getName());
+    factoryWriter.addModifiers(PUBLIC);
+    factoryWriter.addModifiers(FINAL);
+    factoryWriter.setSuperType(
+        ParameterizedTypeName.create(AbstractProducer.class, providedTypeName));
+
+    MethodWriter getMethodWriter = factoryWriter.addMethod(futureTypeName, "compute");
+    getMethodWriter.annotate(Override.class);
+    getMethodWriter.addModifiers(PROTECTED);
+
+    final ImmutableMap<BindingKey, FrameworkField> fields =
+        SourceFiles.generateBindingFieldsForDependencies(
+            dependencyRequestMapper, binding.dependencies());
+
+    for (FrameworkField bindingField : fields.values()) {
+      TypeName fieldType = bindingField.frameworkType();
+      FieldWriter field = factoryWriter.addField(fieldType, bindingField.name());
+      field.addModifiers(PRIVATE, FINAL);
+      constructorWriter.addParameter(field.type(), field.name());
+      constructorWriter.body()
+          .addSnippet("assert %s != null;", field.name())
+          .addSnippet("this.%1$s = %1$s;", field.name());
+    }
+
+    boolean returnsFuture = binding.bindingKind().equals(ProductionBinding.Kind.FUTURE_PRODUCTION);
+    ImmutableList<DependencyRequest> asyncDependencies = FluentIterable
+        .from(binding.dependencies())
+        .filter(new Predicate<DependencyRequest>() {
+          @Override public boolean apply(DependencyRequest dependency) {
+            return isAsyncDependency(dependency);
+          }
+        })
+        .toList();
+
+    for (DependencyRequest dependency : asyncDependencies) {
+      ParameterizedTypeName futureType = ParameterizedTypeName.create(
+          ClassName.fromClass(ListenableFuture.class),
+          asyncDependencyType(dependency));
+      String name = fields.get(BindingKey.forDependencyRequest(dependency)).name();
+      Snippet futureAccess = Snippet.format("%s.get()", name);
+      getMethodWriter.body().addSnippet("%s %sFuture = %s;",
+          futureType,
+          name,
+          dependency.kind().equals(DependencyRequest.Kind.PRODUCED)
+              ? Snippet.format("%s.createFutureProduced(%s)",
+                  ClassName.fromClass(Producers.class), futureAccess)
+              : futureAccess);
+    }
+
+    if (asyncDependencies.isEmpty()) {
+      ImmutableList.Builder<Snippet> parameterSnippets = ImmutableList.builder();
+      for (DependencyRequest dependency : binding.dependencies()) {
+        parameterSnippets.add(frameworkTypeUsageStatement(
+            Snippet.format(fields.get(BindingKey.forDependencyRequest(dependency)).name()),
+            dependency.kind()));
+      }
+      final boolean wrapWithFuture = false;  // since submitToExecutor will create the future
+      Snippet invocationSnippet = getInvocationSnippet(wrapWithFuture, binding,
+          parameterSnippets.build());
+      TypeName callableReturnType = returnsFuture ? futureTypeName : providedTypeName;
+      Snippet throwsClause = getThrowsClause(binding.thrownTypes());
+      Snippet callableSnippet = Snippet.format(Joiner.on('\n').join(
+          "new %1$s<%2$s>() {",
+          "  @Override public %2$s call() %3$s{",
+          "    return %4$s;",
+          "  }",
+          "}"),
+          ClassName.fromClass(Callable.class),
+          callableReturnType,
+          throwsClause,
+          invocationSnippet);
+      getMethodWriter.body().addSnippet("%s future = %s.submitToExecutor(%s, executor);",
+          ParameterizedTypeName.create(
+              ClassName.fromClass(ListenableFuture.class),
+              callableReturnType),
+          ClassName.fromClass(Producers.class),
+          callableSnippet);
+      getMethodWriter.body().addSnippet("return %s;",
+          returnsFuture
+              ? Snippet.format("%s.dereference(future)", ClassName.fromClass(Futures.class))
+              : "future");
+    } else {
+      final Snippet futureSnippet;
+      final Snippet transformSnippet;
+      if (asyncDependencies.size() == 1) {
+        DependencyRequest asyncDependency = Iterables.getOnlyElement(asyncDependencies);
+        futureSnippet = Snippet.format("%s",
+            fields.get(BindingKey.forDependencyRequest(asyncDependency)).name() + "Future");
+        String argName = asyncDependency.requestElement().getSimpleName().toString();
+        ImmutableList.Builder<Snippet> parameterSnippets = ImmutableList.builder();
+        for (DependencyRequest dependency : binding.dependencies()) {
+          // We really want to compare instances here, because asyncDependency is an element in the
+          // set binding.dependencies().
+          if (dependency == asyncDependency) {
+            parameterSnippets.add(Snippet.format("%s", argName));
+          } else {
+            parameterSnippets.add(frameworkTypeUsageStatement(
+                Snippet.format(fields.get(BindingKey.forDependencyRequest(dependency)).name()),
+                dependency.kind()));
+          }
+        }
+        boolean wrapWithFuture = !returnsFuture;  // only wrap if we don't already have a future
+        Snippet invocationSnippet = getInvocationSnippet(wrapWithFuture, binding,
+            parameterSnippets.build());
+        Snippet throwsClause = getThrowsClause(binding.thrownTypes());
+        transformSnippet = Snippet.format(Joiner.on('\n').join(
+            "new %1$s<%2$s, %3$s>() {",
+            "  @Override public %4$s apply(%2$s %5$s) %6$s{",
+            "    return %7$s;",
+            "  }",
+            "}"),
+            ClassName.fromClass(AsyncFunction.class),
+            asyncDependencyType(asyncDependency),
+            providedTypeName,
+            futureTypeName,
+            argName,
+            throwsClause,
+            invocationSnippet);
+      } else {
+        futureSnippet = Snippet.format("%s.<%s>allAsList(%s)",
+            ClassName.fromClass(Futures.class),
+            ClassName.fromClass(Object.class),
+            Joiner.on(",").join(FluentIterable
+                .from(asyncDependencies)
+                .transform(new Function<DependencyRequest, String>() {
+                  @Override public String apply(DependencyRequest dependency) {
+                    return fields.get(BindingKey.forDependencyRequest(dependency)).name()
+                        + "Future";
+                  }
+                })));
+        ImmutableList<Snippet> parameterSnippets = getParameterSnippets(binding, fields, "args");
+        boolean wrapWithFuture = !returnsFuture;  // only wrap if we don't already have a future
+        Snippet invocationSnippet = getInvocationSnippet(wrapWithFuture, binding,
+            parameterSnippets);
+        ParameterizedTypeName listOfObject = ParameterizedTypeName.create(
+            ClassName.fromClass(List.class), ClassName.fromClass(Object.class));
+        Snippet throwsClause = getThrowsClause(binding.thrownTypes());
+        transformSnippet = Snippet.format(Joiner.on('\n').join(
+            "new %1$s<%2$s, %3$s>() {",
+            "  @SuppressWarnings(\"unchecked\")  // safe by specification",
+            "  @Override public %4$s apply(%2$s args) %5$s{",
+            "    return %6$s;",
+            "  }",
+            "}"),
+            ClassName.fromClass(AsyncFunction.class),
+            listOfObject,
+            providedTypeName,
+            futureTypeName,
+            throwsClause,
+            invocationSnippet);
+      }
+      getMethodWriter.body().addSnippet("return %s.%s(%s, %s, executor);",
+          ClassName.fromClass(Futures.class),
+          "transform",
+          futureSnippet,
+          transformSnippet);
+    }
+
+    // TODO(gak): write a sensible toString
+    return ImmutableSet.of(writer);
+  }
+
+  private boolean isAsyncDependency(DependencyRequest dependency) {
+    switch (dependency.kind()) {
+      case INSTANCE:
+      case PRODUCED:
+        return true;
+      default:
+        return false;
+    }
+  }
+
+  private TypeName asyncDependencyType(DependencyRequest dependency) {
+    TypeName keyName = TypeNames.forTypeMirror(dependency.key().type());
+    switch (dependency.kind()) {
+      case INSTANCE:
+        return keyName;
+      case PRODUCED:
+        return ParameterizedTypeName.create(ClassName.fromClass(Produced.class), keyName);
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  private ImmutableList<Snippet> getParameterSnippets(ProductionBinding binding,
+      ImmutableMap<BindingKey, FrameworkField> fields,
+      String listArgName) {
+    int argIndex = 0;
+    ImmutableList.Builder<Snippet> snippets = ImmutableList.builder();
+    for (DependencyRequest dependency : binding.dependencies()) {
+      if (isAsyncDependency(dependency)) {
+        snippets.add(Snippet.format(
+            "(%s) %s.get(%s)",
+            asyncDependencyType(dependency),
+            listArgName,
+            argIndex));
+        argIndex++;
+      } else {
+        snippets.add(frameworkTypeUsageStatement(
+            Snippet.format(fields.get(BindingKey.forDependencyRequest(dependency)).name()),
+            dependency.kind()));
+      }
+    }
+    return snippets.build();
+  }
+
+  /**
+   * Creates a Snippet for the invocation of the producer method from the module.
+   *
+   * @param wrapWithFuture If true, wraps the result of the call to the producer method
+   *        in an immediate future.
+   * @param binding The binding to generate the invocation snippet for.
+   * @param parameterSnippets The snippets for all the parameters to the producer method.
+   */
+  private Snippet getInvocationSnippet(boolean wrapWithFuture, ProductionBinding binding,
+      ImmutableList<Snippet> parameterSnippets) {
+    Snippet moduleSnippet = Snippet.format("module.%s(%s)",
+        binding.bindingElement().getSimpleName(),
+        makeParametersSnippet(parameterSnippets));
+    if (wrapWithFuture) {
+      moduleSnippet = Snippet.format("%s.immediateFuture(%s)",
+          ClassName.fromClass(Futures.class),
+          moduleSnippet);
+    }
+    if (binding.productionType().equals(Produces.Type.SET)) {
+      if (binding.bindingKind().equals(ProductionBinding.Kind.FUTURE_PRODUCTION)) {
+        return Snippet.format("%s.createFutureSingletonSet(%s)",
+            ClassName.fromClass(Producers.class),
+            moduleSnippet);
+      } else {
+        return Snippet.format("%s.of(%s)",
+            ClassName.fromClass(ImmutableSet.class),
+            moduleSnippet);
+      }
+    } else {
+      return moduleSnippet;
+    }
+  }
+
+  /**
+   * Creates a Snippet for the throws clause.
+   *
+   * @param thrownTypes the list of thrown types.
+   */
+  private Snippet getThrowsClause(List<? extends TypeMirror> thrownTypes) {
+    if (thrownTypes.isEmpty()) {
+      return Snippet.format("");
+    }
+    return Snippet.format("throws %s ",
+        Snippet.makeParametersSnippet(FluentIterable
+            .from(thrownTypes)
+            .transform(new Function<TypeMirror, Snippet>() {
+              @Override public Snippet apply(TypeMirror thrownType) {
+                return Snippet.format("%s", TypeNames.forTypeMirror(thrownType));
+              }
+            })
+            .toList()));
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java
new file mode 100644
index 000000000..9fd3161a3
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.SuperficialValidation;
+import com.google.common.base.Function;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import com.google.common.collect.Sets;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import java.lang.annotation.Annotation;
+import java.util.List;
+import java.util.Set;
+import javax.annotation.processing.Messager;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.ElementFilter;
+
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static javax.lang.model.element.ElementKind.METHOD;
+
+/**
+ * An annotation processor for generating Dagger implementation code based on the
+ * {@link ProducerModule} (and {@link Produces}) annotation.
+ *
+ * @author Jesse Beder
+ * @since 2.0
+ */
+final class ProducerModuleProcessingStep implements ProcessingStep {
+  private final Messager messager;
+  private final ModuleValidator moduleValidator;
+  private final ProducesMethodValidator producesMethodValidator;
+  private final ProductionBinding.Factory productionBindingFactory;
+  private final ProducerFactoryGenerator factoryGenerator;
+  private final Set<Element> processedModuleElements = Sets.newLinkedHashSet();
+
+  ProducerModuleProcessingStep(
+      Messager messager,
+      ModuleValidator moduleValidator,
+      ProducesMethodValidator producesMethodValidator,
+      ProductionBinding.Factory productionBindingFactory,
+      ProducerFactoryGenerator factoryGenerator) {
+    this.messager = messager;
+    this.moduleValidator = moduleValidator;
+    this.producesMethodValidator = producesMethodValidator;
+    this.productionBindingFactory = productionBindingFactory;
+    this.factoryGenerator = factoryGenerator;
+  }
+
+  @Override
+  public Set<Class<? extends Annotation>> annotations() {
+    return ImmutableSet.of(Produces.class, ProducerModule.class);
+  }
+
+  @Override
+  public void process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    // first, check and collect all produces methods
+    ImmutableSet.Builder<ExecutableElement> validProducesMethodsBuilder = ImmutableSet.builder();
+    for (Element producesElement : elementsByAnnotation.get(Produces.class)) {
+      if (producesElement.getKind().equals(METHOD)) {
+        ExecutableElement producesMethodElement = (ExecutableElement) producesElement;
+        ValidationReport<ExecutableElement> methodReport =
+            producesMethodValidator.validate(producesMethodElement);
+        methodReport.printMessagesTo(messager);
+        if (methodReport.isClean()) {
+          validProducesMethodsBuilder.add(producesMethodElement);
+        }
+      }
+    }
+    ImmutableSet<ExecutableElement> validProducesMethods = validProducesMethodsBuilder.build();
+
+    // process each module
+    for (Element moduleElement :
+        Sets.difference(elementsByAnnotation.get(ProducerModule.class),
+            processedModuleElements)) {
+      if (SuperficialValidation.validateElement(moduleElement)) {
+        ValidationReport<TypeElement> report =
+            moduleValidator.validate(MoreElements.asType(moduleElement));
+        report.printMessagesTo(messager);
+
+        if (report.isClean()) {
+          ImmutableSet.Builder<ExecutableElement> moduleProducesMethodsBuilder =
+              ImmutableSet.builder();
+          List<ExecutableElement> moduleMethods =
+              ElementFilter.methodsIn(moduleElement.getEnclosedElements());
+          for (ExecutableElement methodElement : moduleMethods) {
+            if (isAnnotationPresent(methodElement, Produces.class)) {
+              moduleProducesMethodsBuilder.add(methodElement);
+            }
+          }
+          ImmutableSet<ExecutableElement> moduleProducesMethods =
+              moduleProducesMethodsBuilder.build();
+
+          if (Sets.difference(moduleProducesMethods, validProducesMethods).isEmpty()) {
+            // all of the produces methods in this module are valid!
+            // time to generate some factories!
+            ImmutableSet<ProductionBinding> bindings = FluentIterable.from(moduleProducesMethods)
+                .transform(new Function<ExecutableElement, ProductionBinding>() {
+                  @Override
+                  public ProductionBinding apply(ExecutableElement producesMethod) {
+                    return productionBindingFactory.forProducesMethod(producesMethod);
+                  }
+                })
+                .toSet();
+
+            try {
+              for (ProductionBinding binding : bindings) {
+                factoryGenerator.generate(binding);
+              }
+            } catch (SourceFileGenerationException e) {
+              e.printMessageTo(messager);
+            }
+          }
+        }
+
+        processedModuleElements.add(moduleElement);
+      }
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
new file mode 100644
index 000000000..24cff39b5
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
@@ -0,0 +1,213 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import java.util.Set;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.ConfigurationAnnotations.getMapKeys;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_MAP_HAS_MAP_KEY;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_STATIC;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_MULTIPLE_MAP_KEY;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_NO_MAP_KEY;
+import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RAW_FUTURE;
+import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RETURN_TYPE;
+import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.STATIC;
+import static javax.lang.model.type.TypeKind.ARRAY;
+import static javax.lang.model.type.TypeKind.DECLARED;
+import static javax.lang.model.type.TypeKind.VOID;
+
+/**
+ * A {@link Validator} for {@link Produces} methods.
+ *
+ * @author Jesse Beder
+ * @since 2.0
+ */
+// TODO(user): Consider unifying this with the ProvidesMethodValidator after Provides.Type and
+// Produces.Type are reconciled.
+final class ProducesMethodValidator implements Validator<ExecutableElement> {
+  private final Elements elements;
+
+  ProducesMethodValidator(Elements elements) {
+    this.elements = checkNotNull(elements);
+  }
+
+  private TypeElement getSetElement() {
+    return elements.getTypeElement(Set.class.getCanonicalName());
+  }
+
+  @Override
+  public ValidationReport<ExecutableElement> validate(ExecutableElement producesMethodElement) {
+    ValidationReport.Builder<ExecutableElement> builder =
+        ValidationReport.Builder.about(producesMethodElement);
+
+    Produces producesAnnotation = producesMethodElement.getAnnotation(Produces.class);
+    checkArgument(producesAnnotation != null);
+
+    Element enclosingElement = producesMethodElement.getEnclosingElement();
+    if (!isAnnotationPresent(enclosingElement, ProducerModule.class)) {
+      builder.addItem(formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE),
+          producesMethodElement);
+    }
+
+    if (!producesMethodElement.getTypeParameters().isEmpty()) {
+      builder.addItem(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER), producesMethodElement);
+    }
+
+    Set<Modifier> modifiers = producesMethodElement.getModifiers();
+    if (modifiers.contains(PRIVATE)) {
+      builder.addItem(formatErrorMessage(BINDING_METHOD_PRIVATE), producesMethodElement);
+    }
+    if (modifiers.contains(STATIC)) {
+      // TODO(gak): why not?
+      builder.addItem(formatErrorMessage(BINDING_METHOD_STATIC), producesMethodElement);
+    }
+    if (modifiers.contains(ABSTRACT)) {
+      builder.addItem(formatErrorMessage(BINDING_METHOD_ABSTRACT), producesMethodElement);
+    }
+
+    TypeMirror returnType = producesMethodElement.getReturnType();
+    TypeKind returnTypeKind = returnType.getKind();
+    if (returnTypeKind.equals(VOID)) {
+      builder.addItem(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE),
+          producesMethodElement);
+    }
+
+    // check mapkey is right
+    if (!producesAnnotation.type().equals(Produces.Type.MAP)
+        && (getMapKeys(producesMethodElement) != null
+            && !getMapKeys(producesMethodElement).isEmpty())) {
+      builder.addItem(formatErrorMessage(BINDING_METHOD_NOT_MAP_HAS_MAP_KEY),
+          producesMethodElement);
+    }
+
+    switch (producesAnnotation.type()) {
+      case UNIQUE: // fall through
+      case SET:
+        validateSingleReturnType(builder, returnType);
+        break;
+      case MAP:
+        validateSingleReturnType(builder, returnType);
+        ImmutableSet<? extends AnnotationMirror> annotationMirrors =
+            getMapKeys(producesMethodElement);
+        switch (annotationMirrors.size()) {
+          case 0:
+            builder.addItem(formatErrorMessage(BINDING_METHOD_WITH_NO_MAP_KEY),
+                producesMethodElement);
+            break;
+          case 1:
+            break;
+          default:
+            builder.addItem(formatErrorMessage(BINDING_METHOD_WITH_MULTIPLE_MAP_KEY),
+                producesMethodElement);
+            break;
+        }
+        break;
+      case SET_VALUES:
+        if (returnTypeKind.equals(DECLARED)
+            && MoreTypes.isTypeOf(ListenableFuture.class, returnType)) {
+          DeclaredType declaredReturnType = MoreTypes.asDeclared(returnType);
+          if (!declaredReturnType.getTypeArguments().isEmpty()) {
+            validateSetType(builder, Iterables.getOnlyElement(
+                declaredReturnType.getTypeArguments()));
+          }
+        } else {
+          validateSetType(builder, returnType);
+        }
+        break;
+      default:
+        throw new AssertionError();
+    }
+
+    return builder.build();
+  }
+
+  private String formatErrorMessage(String msg) {
+    return String.format(msg, Produces.class.getSimpleName());
+  }
+
+  private String formatModuleErrorMessage(String msg) {
+    return String.format(msg, Produces.class.getSimpleName(), ProducerModule.class.getSimpleName());
+  }
+
+  private void validateKeyType(ValidationReport.Builder<? extends Element> reportBuilder,
+      TypeMirror type) {
+    TypeKind kind = type.getKind();
+    if (!(kind.isPrimitive() || kind.equals(DECLARED) || kind.equals(ARRAY))) {
+      reportBuilder.addItem(PRODUCES_METHOD_RETURN_TYPE, reportBuilder.getSubject());
+    }
+  }
+
+  private void validateSingleReturnType(ValidationReport.Builder<? extends Element> reportBuilder,
+      TypeMirror type) {
+    if (type.getKind().equals(DECLARED) && MoreTypes.isTypeOf(ListenableFuture.class, type)) {
+      DeclaredType declaredType = MoreTypes.asDeclared(type);
+      if (declaredType.getTypeArguments().isEmpty()) {
+        reportBuilder.addItem(PRODUCES_METHOD_RAW_FUTURE, reportBuilder.getSubject());
+      } else {
+        validateKeyType(reportBuilder, Iterables.getOnlyElement(declaredType.getTypeArguments()));
+      }
+    } else {
+      validateKeyType(reportBuilder, type);
+    }
+  }
+
+  private void validateSetType(ValidationReport.Builder<? extends Element> reportBuilder,
+      TypeMirror type) {
+    if (!type.getKind().equals(DECLARED)) {
+      reportBuilder.addItem(PRODUCES_METHOD_SET_VALUES_RETURN_SET, reportBuilder.getSubject());
+      return;
+    }
+
+    // TODO(gak): should we allow "covariant return" for set values?
+    DeclaredType declaredType = MoreTypes.asDeclared(type);
+    if (!declaredType.asElement().equals(getSetElement())) {
+      reportBuilder.addItem(PRODUCES_METHOD_SET_VALUES_RETURN_SET, reportBuilder.getSubject());
+    } else if (declaredType.getTypeArguments().isEmpty()) {
+      reportBuilder.addItem(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET),
+          reportBuilder.getSubject());
+    } else {
+      validateSingleReturnType(reportBuilder,
+          Iterables.getOnlyElement(declaredType.getTypeArguments()));
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
new file mode 100644
index 000000000..0a8e946ec
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.Produces;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.type.TypeMirror;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static javax.lang.model.element.ElementKind.METHOD;
+
+/**
+ * A value object representing the mechanism by which a {@link Key} can be produced. New instances
+ * should be created using an instance of the {@link Factory}.
+ *
+ * @author Jesse Beder
+ * @since 2.0
+ */
+@AutoValue
+abstract class ProductionBinding extends ContributionBinding {
+  @Override
+  ImmutableSet<DependencyRequest> implicitDependencies() {
+    return dependencies();
+  }
+
+  enum Kind {
+    /** Represents a binding configured by {@link Produces} that doesn't return a future. */
+    IMMEDIATE,
+    /** Represents a binding configured by {@link Produces} that returns a future. */
+    FUTURE_PRODUCTION,
+  }
+
+  /**
+   * The type of binding (whether the {@link Produces} method returns a future). For the particular
+   * type of production, use {@link #productionType}.
+   */
+  abstract Kind bindingKind();
+
+  /** Returns provision type that was used to bind the key. */
+  abstract Produces.Type productionType();
+
+  /** Returns the list of types in the throws clause of the method. */
+  abstract ImmutableList<? extends TypeMirror> thrownTypes();
+
+  @Override
+  BindingType bindingType() {
+    switch (productionType()) {
+      case SET:
+      case SET_VALUES:
+        return BindingType.SET;
+      case MAP:
+        return BindingType.MAP;
+      case UNIQUE:
+        return BindingType.UNIQUE;
+      default:
+        throw new IllegalStateException("Unknown production type: " + productionType());
+    }
+  }
+
+  static final class Factory {
+    private final Key.Factory keyFactory;
+    private final DependencyRequest.Factory dependencyRequestFactory;
+
+    Factory(Key.Factory keyFactory, DependencyRequest.Factory dependencyRequestFactory) {
+      this.keyFactory = keyFactory;
+      this.dependencyRequestFactory = dependencyRequestFactory;
+    }
+
+    ProductionBinding forProducesMethod(ExecutableElement producesMethod) {
+      checkNotNull(producesMethod);
+      checkArgument(producesMethod.getKind().equals(METHOD));
+      Produces producesAnnotation = producesMethod.getAnnotation(Produces.class);
+      checkArgument(producesAnnotation != null);
+      Key key = keyFactory.forProducesMethod(producesMethod);
+      ImmutableSet<DependencyRequest> dependencies =
+          dependencyRequestFactory.forRequiredVariables(producesMethod.getParameters());
+      Kind kind = MoreTypes.isTypeOf(ListenableFuture.class, producesMethod.getReturnType())
+          ? Kind.FUTURE_PRODUCTION
+          : Kind.IMMEDIATE;
+      return new AutoValue_ProductionBinding(
+          key,
+          producesMethod,
+          dependencies,
+          findBindingPackage(key),
+          kind,
+          producesAnnotation.type(),
+          ImmutableList.copyOf(producesMethod.getThrownTypes()));
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java
new file mode 100644
index 000000000..7e2c667d3
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.auto.common.MoreElements;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import dagger.producers.ProductionComponent;
+import java.lang.annotation.Annotation;
+import java.util.Set;
+import javax.annotation.processing.Messager;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * A {@link ProcessingStep} that is responsible for dealing with the {@link ProductionComponent}
+ * annotation as part of the {@link ComponentProcessor}.
+ *
+ * @author Jesse Beder
+ */
+final class ProductionComponentProcessingStep implements ProcessingStep {
+  private final Messager messager;
+  private final ProductionComponentValidator componentValidator;
+  private final ComponentDescriptor.Factory componentDescriptorFactory;
+
+  ProductionComponentProcessingStep(
+      Messager messager,
+      ProductionComponentValidator componentValidator,
+      ComponentDescriptor.Factory componentDescriptorFactory) {
+    this.messager = messager;
+    this.componentValidator = componentValidator;
+    this.componentDescriptorFactory = componentDescriptorFactory;
+  }
+
+  @Override
+  public Set<Class<? extends Annotation>> annotations() {
+    return ImmutableSet.<Class<? extends Annotation>>of(ProductionComponent.class);
+  }
+
+  @Override
+  public void process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    Set<? extends Element> componentElements = elementsByAnnotation.get(ProductionComponent.class);
+
+    for (Element element : componentElements) {
+      TypeElement componentTypeElement = MoreElements.asType(element);
+      ValidationReport<TypeElement> componentReport =
+          componentValidator.validate(componentTypeElement);
+      componentReport.printMessagesTo(messager);
+      if (componentReport.isClean()) {
+        componentDescriptorFactory.forProductionComponent(componentTypeElement);
+      }
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProductionComponentValidator.java
new file mode 100644
index 000000000..6107280e4
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionComponentValidator.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreElements;
+import com.google.common.collect.ImmutableList;
+import dagger.Module;
+import dagger.producers.ProducerModule;
+import dagger.producers.ProductionComponent;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.SimpleTypeVisitor6;
+
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static com.google.common.base.Preconditions.checkState;
+import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
+import static javax.lang.model.element.ElementKind.CLASS;
+import static javax.lang.model.element.ElementKind.INTERFACE;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+
+/**
+ * Performs superficial validation of the contract of the {@link ProductionComponent} annotation.
+ *
+ * @author Jesse Beder
+ */
+final class ProductionComponentValidator implements Validator<TypeElement> {
+  @Override public ValidationReport<TypeElement> validate(final TypeElement subject) {
+    final ValidationReport.Builder<TypeElement> builder = ValidationReport.Builder.about(subject);
+
+    if (!subject.getKind().equals(INTERFACE)
+        && !(subject.getKind().equals(CLASS) && subject.getModifiers().contains(ABSTRACT))) {
+      builder.addItem("@ProductionComponent may only be applied to an interface or abstract class",
+          subject);
+    }
+
+    AnnotationMirror componentMirror =
+        getAnnotationMirror(subject, ProductionComponent.class).get();
+    ImmutableList<TypeMirror> moduleTypes = getComponentModules(componentMirror);
+
+    // TODO(gak): make unused modules an error
+    for (TypeMirror moduleType : moduleTypes) {
+      moduleType.accept(new SimpleTypeVisitor6<Void, Void>() {
+        @Override
+        protected Void defaultAction(TypeMirror mirror, Void p) {
+          builder.addItem(mirror + " is not a valid module type.", subject);
+          return null;
+        }
+
+        @Override
+        public Void visitDeclared(DeclaredType t, Void p) {
+          checkState(t.getTypeArguments().isEmpty());
+          TypeElement moduleElement = MoreElements.asType(t.asElement());
+          if (!getAnnotationMirror(moduleElement, Module.class).isPresent()
+              && !getAnnotationMirror(moduleElement, ProducerModule.class).isPresent()) {
+            builder.addItem(moduleElement.getQualifiedName()
+                + " is listed as a module, but is not annotated with @Module or @ProducerModule",
+                subject);
+          }
+          return null;
+        }
+      }, null);
+    }
+
+    return builder.build();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
index fa4e70d30..1a4161410 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
@@ -34,18 +34,18 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.ConfigurationAnnotations.getMapKeys;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_ABSTRACT;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_MUST_RETURN_A_VALUE;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_NOT_IN_MODULE;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_NOT_MAP_HAS_MAP_KEY;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_PRIVATE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_MAP_HAS_MAP_KEY;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_STATIC;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_MULTIPLE_MAP_KEY;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_NO_MAP_KEY;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_RETURN_TYPE;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RAW_SET;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RETURN_SET;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_STATIC;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_TYPE_PARAMETER;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_WITH_MULTIPLE_MAP_KEY;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_WITH_NO_MAP_KEY;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
@@ -80,37 +80,41 @@ private TypeElement getSetElement() {
 
     Element enclosingElement = providesMethodElement.getEnclosingElement();
     if (!isAnnotationPresent(enclosingElement, Module.class)) {
-      builder.addItem(PROVIDES_METHOD_NOT_IN_MODULE,
+      builder.addItem(formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE),
           providesMethodElement);
     }
     
     if (!providesMethodElement.getTypeParameters().isEmpty()) {
-      builder.addItem(PROVIDES_METHOD_TYPE_PARAMETER, providesMethodElement);
+      builder.addItem(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER),
+          providesMethodElement);
     }
 
     Set<Modifier> modifiers = providesMethodElement.getModifiers();
     if (modifiers.contains(PRIVATE)) {
-      builder.addItem(PROVIDES_METHOD_PRIVATE, providesMethodElement);
+      builder.addItem(formatErrorMessage(BINDING_METHOD_PRIVATE),
+          providesMethodElement);
     }
     if (modifiers.contains(STATIC)) {
       // TODO(gak): why not?
-      builder.addItem(PROVIDES_METHOD_STATIC, providesMethodElement);
+      builder.addItem(formatErrorMessage(BINDING_METHOD_STATIC), providesMethodElement);
     }
     if (modifiers.contains(ABSTRACT)) {
-      builder.addItem(PROVIDES_METHOD_ABSTRACT, providesMethodElement);
+      builder.addItem(formatErrorMessage(BINDING_METHOD_ABSTRACT), providesMethodElement);
     }
 
     TypeMirror returnType = providesMethodElement.getReturnType();
     TypeKind returnTypeKind = returnType.getKind();
     if (returnTypeKind.equals(VOID)) {
-      builder.addItem(PROVIDES_METHOD_MUST_RETURN_A_VALUE, providesMethodElement);
+      builder.addItem(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE),
+          providesMethodElement);
     }
   
     // check mapkey is right
     if (!providesAnnotation.type().equals(Provides.Type.MAP) 
         && (getMapKeys(providesMethodElement) != null
             && getMapKeys(providesMethodElement).size() > 0)) {
-      builder.addItem(PROVIDES_METHOD_NOT_MAP_HAS_MAP_KEY, providesMethodElement);
+      builder.addItem(formatErrorMessage(BINDING_METHOD_NOT_MAP_HAS_MAP_KEY),
+          providesMethodElement);
     }
 
     switch (providesAnnotation.type()) {
@@ -124,12 +128,14 @@ private TypeElement getSetElement() {
             getMapKeys(providesMethodElement);
         switch (annotationMirrors.size()) {
           case 0:
-            builder.addItem(PROVIDES_METHOD_WITH_NO_MAP_KEY, providesMethodElement);
+            builder.addItem(formatErrorMessage(BINDING_METHOD_WITH_NO_MAP_KEY),
+                providesMethodElement);
             break;
           case 1:
             break;
           default:
-            builder.addItem(PROVIDES_METHOD_WITH_MULTIPLE_MAP_KEY, providesMethodElement);
+            builder.addItem(formatErrorMessage(BINDING_METHOD_WITH_MULTIPLE_MAP_KEY),
+                providesMethodElement);
             break;
         }
         break;
@@ -142,7 +148,8 @@ private TypeElement getSetElement() {
           if (!declaredReturnType.asElement().equals(getSetElement())) {
             builder.addItem(PROVIDES_METHOD_SET_VALUES_RETURN_SET, providesMethodElement);
           } else if (declaredReturnType.getTypeArguments().isEmpty()) {
-            builder.addItem(PROVIDES_METHOD_SET_VALUES_RAW_SET, providesMethodElement);
+            builder.addItem(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET),
+                providesMethodElement);
           } else {
             validateKeyType(builder,
                 Iterables.getOnlyElement(declaredReturnType.getTypeArguments()));
@@ -156,6 +163,14 @@ private TypeElement getSetElement() {
     return builder.build();
   }
 
+  private String formatErrorMessage(String msg) {
+    return String.format(msg, Provides.class.getSimpleName());
+  }
+
+  private String formatModuleErrorMessage(String msg) {
+    return String.format(msg, Provides.class.getSimpleName(), Module.class.getSimpleName());
+  }
+
   private void validateKeyType(ValidationReport.Builder<? extends Element> reportBuilder,
       TypeMirror type) {
     TypeKind kind = type.getKind();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 25cd5879b..dff5c16a6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -15,30 +15,33 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Optional;
-import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Iterables;
-import com.google.common.collect.Ordering;
 import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.Provides;
-import java.util.Set;
 import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
 import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
 import static dagger.internal.codegen.ProvisionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.Util.unwrapOptionalEquivalence;
@@ -55,7 +58,7 @@
  * @since 2.0
  */
 @AutoValue
-abstract class ProvisionBinding extends Binding {
+abstract class ProvisionBinding extends ContributionBinding implements ResolvableBinding {
   @Override
   ImmutableSet<DependencyRequest> implicitDependencies() {
     return new ImmutableSet.Builder<DependencyRequest>()
@@ -69,6 +72,11 @@
     INJECTION,
     /** Represents a binding configured by {@link Provides}. */
     PROVISION,
+    /**
+     * Represents a binding that is not explicitly tied to code, but generated implicitly by the
+     * framework.
+     */
+    SYNTHETIC_PROVISON,
     /** Represents the implicit binding to the component. */
     COMPONENT,
     /** Represents a binding from a provision method on a component dependency. */
@@ -96,18 +104,10 @@
    */
   abstract Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedScope();
 
-  /** If this provision requires members injeciton, this will be the corresonding request. */
+  /** If this provision requires members injection, this will be the corresponding request. */
   abstract Optional<DependencyRequest> memberInjectionRequest();
 
-  static enum BindingType {
-    /** Represents map bindings. */
-    MAP,
-    /** Represents set bindings. */
-    SET,
-    /** Represents a valid non-collection binding. */
-    UNIQUE;
-  }
-
+  @Override
   BindingType bindingType() {
     switch (provisionType()) {
       case SET:
@@ -122,52 +122,16 @@ BindingType bindingType() {
     }
   }
 
-  /**
-   * Returns the set of {@link BindingType} enum values implied by a given
-   * {@link ProvisionBinding} collection.
-   */
-  static ImmutableListMultimap<BindingType, ProvisionBinding> bindingTypesFor(
-      Iterable<ProvisionBinding> bindings) {
-    ImmutableListMultimap.Builder<BindingType, ProvisionBinding> builder =
-        ImmutableListMultimap.builder();
-    builder.orderKeysBy(Ordering.<BindingType>natural());
-    for (ProvisionBinding binding : bindings) {
-      builder.put(binding.bindingType(), binding);
-    }
-    return builder.build();
-  }
-
-  /**
-   * Returns a single {@code BindingsType} represented by a given collection of
-   * {@code ProvisionBindings} or throws an IllegalArgumentException if the given bindings
-   * are not all of one type.
-   */
-  static BindingType bindingTypeFor(Iterable<ProvisionBinding> bindings) {
-    checkNotNull(bindings);
-    switch (Iterables.size(bindings)) {
-      case 0:
-        throw new IllegalArgumentException("no bindings");
-      case 1:
-        return Iterables.getOnlyElement(bindings).bindingType();
-      default:
-        Set<BindingType> types = bindingTypesFor(bindings).keySet();
-        if (types.size() > 1) {
-          throw new IllegalArgumentException(
-              String.format(ErrorMessages.MULTIPLE_BINDING_TYPES_FORMAT, types));
-        }
-        return Iterables.getOnlyElement(types);
-    }
-  }
-
   enum FactoryCreationStrategy {
     ENUM_INSTANCE,
     CLASS_CONSTRUCTOR,
   }
 
   FactoryCreationStrategy factoryCreationStrategy() {
-    return (bindingKind().equals(INJECTION) && implicitDependencies().isEmpty())
-        ? FactoryCreationStrategy.ENUM_INSTANCE
-        : FactoryCreationStrategy.CLASS_CONSTRUCTOR;
+    return (bindingKind().equals(INJECTION)
+          && implicitDependencies().isEmpty())
+          ? FactoryCreationStrategy.ENUM_INSTANCE
+          : FactoryCreationStrategy.CLASS_CONSTRUCTOR;
   }
 
   static final class Factory {
@@ -183,20 +147,55 @@ FactoryCreationStrategy factoryCreationStrategy() {
       this.keyFactory = keyFactory;
       this.dependencyRequestFactory = dependencyRequestFactory;
     }
+    
+    
+    /** Returns an unresolved version of this binding. */
+    ProvisionBinding unresolve(ProvisionBinding binding) {
+      checkState(binding.isResolved());
+      return forInjectConstructor((ExecutableElement) binding.bindingElement(),
+          Optional.<TypeMirror>absent());
+    }
 
-    ProvisionBinding forInjectConstructor(ExecutableElement constructorElement) {
+    /**
+     * Returns a ProvisionBinding for the given element. If {@code resolvedType} is present, this
+     * will return a {@link ResolvableBinding#isResolved() resolved} binding, with the key & type
+     * resolved to the given type (using {@link Types#asMemberOf(DeclaredType, Element)}).
+     */
+    ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
+        Optional<TypeMirror> resolvedType) {
       checkNotNull(constructorElement);
       checkArgument(constructorElement.getKind().equals(CONSTRUCTOR));
       checkArgument(isAnnotationPresent(constructorElement, Inject.class));
-      Key key = keyFactory.forInjectConstructor(constructorElement);
+      checkArgument(!getQualifier(constructorElement).isPresent());
+
+      boolean isResolved = false;
+      ExecutableType cxtorType = MoreTypes.asExecutable(constructorElement.asType());
+      DeclaredType enclosingCxtorType =
+          MoreTypes.asDeclared(constructorElement.getEnclosingElement().asType());
+      // If the class this is constructing has some type arguments, resolve everything.
+      if (!enclosingCxtorType.getTypeArguments().isEmpty() && resolvedType.isPresent()) {
+        DeclaredType resolved = MoreTypes.asDeclared(resolvedType.get());
+        // Validate that we're resolving from the correct type.
+        checkState(types.isSameType(types.erasure(resolved), types.erasure(enclosingCxtorType)),
+            "erased expected type: %s, erased actual type: %s",
+            types.erasure(resolved), types.erasure(enclosingCxtorType));
+        cxtorType = MoreTypes.asExecutable(types.asMemberOf(resolved, constructorElement));
+        enclosingCxtorType = resolved;
+        isResolved = true;
+      }
+
+      Key key = keyFactory.forInjectConstructorWithResolvedType(enclosingCxtorType);
       checkArgument(!key.qualifier().isPresent());
       ImmutableSet<DependencyRequest> dependencies =
-          dependencyRequestFactory.forRequiredVariables(constructorElement.getParameters());
-      Optional<DependencyRequest> membersInjectionRequest = membersInjectionRequest(
-          MoreElements.asType(constructorElement.getEnclosingElement()));
+          dependencyRequestFactory.forRequiredResolvedVariables(constructorElement.getParameters(),
+              cxtorType.getParameterTypes());
+      Optional<DependencyRequest> membersInjectionRequest =
+          membersInjectionRequest(enclosingCxtorType);
       Optional<AnnotationMirror> scope =
           getScopeAnnotation(constructorElement.getEnclosingElement());
+
       return new AutoValue_ProvisionBinding(
+          isResolved,
           key,
           constructorElement,
           dependencies,
@@ -210,12 +209,13 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement) {
     private static final ImmutableSet<ElementKind> MEMBER_KINDS =
         Sets.immutableEnumSet(METHOD, FIELD);
 
-    private Optional<DependencyRequest> membersInjectionRequest(TypeElement type) {
+    private Optional<DependencyRequest> membersInjectionRequest(DeclaredType type) {
+      TypeElement typeElement = MoreElements.asType(type.asElement());
       if (!types.isSameType(elements.getTypeElement(Object.class.getCanonicalName()).asType(),
-          type.getSuperclass())) {
+          typeElement.getSuperclass())) {
         return Optional.of(dependencyRequestFactory.forMembersInjectedType(type));
       }
-      for (Element enclosedElement : type.getEnclosedElements()) {
+      for (Element enclosedElement : typeElement.getEnclosedElements()) {
         if (MEMBER_KINDS.contains(enclosedElement.getKind())
             && (isAnnotationPresent(enclosedElement, Inject.class))) {
           return Optional.of(dependencyRequestFactory.forMembersInjectedType(type));
@@ -234,6 +234,7 @@ ProvisionBinding forProvidesMethod(ExecutableElement providesMethod) {
           dependencyRequestFactory.forRequiredVariables(providesMethod.getParameters());
       Optional<AnnotationMirror> scope = getScopeAnnotation(providesMethod);
       return new AutoValue_ProvisionBinding(
+          false /* not resolved */,
           key,
           providesMethod,
           dependencies,
@@ -251,11 +252,12 @@ ProvisionBinding forImplicitMapBinding(DependencyRequest explicitRequest,
       ImmutableSet<DependencyRequest> dependencies = ImmutableSet.of(implicitRequest);
       Optional<AnnotationMirror> scope = getScopeAnnotation(implicitRequest.requestElement());
       return new AutoValue_ProvisionBinding(
+          false /* not resolved */,
           explicitRequest.key(),
           implicitRequest.requestElement(),
           dependencies,
           findBindingPackage(explicitRequest.key()),
-          Kind.PROVISION,
+          Kind.SYNTHETIC_PROVISON,
           Provides.Type.MAP,
           wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), scope),
           Optional.<DependencyRequest>absent());
@@ -266,6 +268,7 @@ ProvisionBinding forComponent(TypeElement componentDefinitionType) {
       Component componentAnnotation = componentDefinitionType.getAnnotation(Component.class);
       checkArgument(componentAnnotation != null);
       return new AutoValue_ProvisionBinding(
+          false /* not resolved */,
           keyFactory.forComponent(componentDefinitionType.asType()),
           componentDefinitionType,
           ImmutableSet.<DependencyRequest>of(),
@@ -282,6 +285,7 @@ ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
       checkArgument(componentMethod.getParameters().isEmpty());
       Optional<AnnotationMirror> scope = getScopeAnnotation(componentMethod);
       return new AutoValue_ProvisionBinding(
+          false /* not resolved */,
           keyFactory.forComponentMethod(componentMethod),
           componentMethod,
           ImmutableSet.<DependencyRequest>of(),
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ResolvableBinding.java
similarity index 56%
rename from compiler/src/main/java/dagger/internal/codegen/ProcessingStep.java
rename to compiler/src/main/java/dagger/internal/codegen/ResolvableBinding.java
index 14d7751d6..7dc52f78b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ResolvableBinding.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2015 Google, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,17 +15,15 @@
  */
 package dagger.internal.codegen;
 
-import java.util.Set;
-import javax.annotation.processing.RoundEnvironment;
-import javax.lang.model.element.TypeElement;
-
 /**
- * This represents work to be done in an annotation processor that must run with other steps due to
- * shared state between them or a particular execution order.
- *
- * @author Gregory Kick
- * @since 2.0
+ * A Binding that can be resolved at request time. For example, a ProvisionBinding for
+ * {@code List<T>} might be resolved to {@code List<Foo>} or {@code List<Bar>}
+ * depending on how it's requested.
  */
-interface ProcessingStep {
-  boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv);
+interface ResolvableBinding {  
+  /**
+   * True if this represents a binding that refers to a type with parameters, and the
+   * parameters have been resolved based on a requesting key.
+   */
+  boolean isResolved();
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index dfd68f090..42a5adef1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -20,19 +20,25 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Iterables;
+import com.google.common.collect.Maps;
 import com.google.common.collect.Ordering;
 import dagger.internal.DoubleCheckLazy;
+import dagger.internal.codegen.ContributionBinding.BindingType;
 import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.ParameterizedTypeName;
 import dagger.internal.codegen.writer.Snippet;
+import dagger.internal.codegen.writer.TypeName;
+import dagger.internal.codegen.writer.TypeNames;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Map.Entry;
-import javax.inject.Provider;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
 
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+import static com.google.common.base.Preconditions.checkState;
 
 /**
  * Utilities for generating files.
@@ -59,47 +65,97 @@ public int compare(DependencyRequest left, DependencyRequest right) {
     }
   };
 
-  static ImmutableSetMultimap<Key, DependencyRequest> indexDependenciesByKey(
+  /**
+   * A variant of {@link #indexDependenciesByKey} that maps from unresolved keys
+   * to resolved keys.  This is used when generating component's initialize()
+   * methods (and in members injectors) in order to instantiate dependent
+   * providers.  Consider a generic type of {@code Foo<T>} with a constructor
+   * of {@code Foo(T t, T t1, A a, A a1)}.  That will be collapsed to a factory
+   * taking a {@code Provider<T> tProvider, Provider<A> aProvider}. However,
+   * if it was referenced as {@code Foo<A>}, we need to make sure we still
+   * pass two providers.  Naively (if we just referenced by resolved BindingKey),
+   * we would have passed a single {@code aProvider}.
+   */
+  static ImmutableMap<BindingKey, BindingKey> indexDependenciesByUnresolvedKey(
+      Iterable<? extends DependencyRequest> dependencies) {
+    // We expect some duplicates while building, so not using ImmutableMap
+    Map<BindingKey, BindingKey> map = Maps.newLinkedHashMap();
+    for (DependencyRequest dependency : dependencies) {
+      BindingKey resolved = BindingKey.forDependencyRequest(dependency);
+      // To get the proper unresolved type, we have to extract the proper type from the
+      // request type again (because we're looking at the actual element's type).
+      TypeMirror unresolvedType =
+          DependencyRequest.Factory.extractKindAndType(dependency.requestElement().asType()).type();
+      BindingKey unresolved =
+          BindingKey.create(resolved.kind(), resolved.key().withType(unresolvedType));
+      BindingKey existingEntry = map.get(unresolved);
+      if (existingEntry == null) {
+        map.put(unresolved, resolved);
+      } else {
+        // If the entry exists in the map, it *must* be with the same resolved
+        // value.  Otherwise we have an unresolved key mapping to two different
+        // resolved keys!
+        checkState(existingEntry.equals(resolved));
+      }
+    }
+    return ImmutableMap.copyOf(map);
+  }
+
+  /**
+   * Allows dependency requests to be grouped by the key they're requesting.
+   * This is used by factory generation in order to minimize the number of parameters
+   * required in the case where a given key is requested more than once.  This expects
+   * unresolved dependency requests, otherwise we may generate factories based on
+   * a particular usage of a class as opposed to the generic types of the class.
+   */
+  static ImmutableSetMultimap<BindingKey, DependencyRequest> indexDependenciesByKey(
       Iterable<? extends DependencyRequest> dependencies) {
-    ImmutableSetMultimap.Builder<Key, DependencyRequest> dependenciesByKeyBuilder =
-        new ImmutableSetMultimap.Builder<Key, DependencyRequest>().orderValuesBy(
+    ImmutableSetMultimap.Builder<BindingKey, DependencyRequest> dependenciesByKeyBuilder =
+        new ImmutableSetMultimap.Builder<BindingKey, DependencyRequest>().orderValuesBy(
             DEPENDENCY_ORDERING);
     for (DependencyRequest dependency : dependencies) {
-      dependenciesByKeyBuilder.put(dependency.key(), dependency);
+      dependenciesByKeyBuilder.put(
+          BindingKey.forDependencyRequest(dependency), dependency);
     }
     return dependenciesByKeyBuilder.build();
   }
 
   /**
-   * This method generates names for the {@link Provider} references necessary for all of the
+   * This method generates names and keys for the framework classes necessary for all of the
    * bindings. It is responsible for the following:
    * <ul>
-   * <li>Choosing a name that associates the provider with all of the dependency requests for this
+   * <li>Choosing a name that associates the binding with all of the dependency requests for this
    * type.
-   * <li>Choosing a name that is <i>probably</i> associated with the type being provided.
-   * <li>Ensuring that no two providers end up with the same name.
+   * <li>Choosing a name that is <i>probably</i> associated with the type being bound.
+   * <li>Ensuring that no two bindings end up with the same name.
    * </ul>
    *
-   * @return Returns the mapping from {@link Key} to provider name sorted by the name of the
-   *         provider.
+   * @return Returns the mapping from {@link BindingKey} to field, sorted by the name of the field.
    */
-  static ImmutableMap<Key, String> generateFrameworkReferenceNamesForDependencies(
+  static ImmutableMap<BindingKey, FrameworkField> generateBindingFieldsForDependencies(
+      DependencyRequestMapper dependencyRequestMapper,
       Iterable<? extends DependencyRequest> dependencies) {
-    ImmutableSetMultimap<Key, DependencyRequest> dependenciesByKey =
+    ImmutableSetMultimap<BindingKey, DependencyRequest> dependenciesByKey =
         indexDependenciesByKey(dependencies);
-    Map<Key, Collection<DependencyRequest>> dependenciesByKeyMap = dependenciesByKey.asMap();
-    ImmutableMap.Builder<Key, String> providerNames = ImmutableMap.builder();
-    for (Entry<Key, Collection<DependencyRequest>> entry : dependenciesByKeyMap.entrySet()) {
+    Map<BindingKey, Collection<DependencyRequest>> dependenciesByKeyMap =
+        dependenciesByKey.asMap();
+    ImmutableMap.Builder<BindingKey, FrameworkField> bindingFields = ImmutableMap.builder();
+    for (Entry<BindingKey, Collection<DependencyRequest>> entry
+        : dependenciesByKeyMap.entrySet()) {
+      BindingKey bindingKey = entry.getKey();
+      Collection<DependencyRequest> requests = entry.getValue();
+      Class<?> frameworkClass =
+          dependencyRequestMapper.getFrameworkClass(requests.iterator().next());
       // collect together all of the names that we would want to call the provider
       ImmutableSet<String> dependencyNames =
-          FluentIterable.from(entry.getValue()).transform(new DependencyVariableNamer()).toSet();
+          FluentIterable.from(requests).transform(new DependencyVariableNamer()).toSet();
 
       if (dependencyNames.size() == 1) {
         // if there's only one name, great! use it!
         String name = Iterables.getOnlyElement(dependencyNames);
-        providerNames.put(entry.getKey(), name.endsWith("Provider") ? name : name + "Provider");
+        bindingFields.put(bindingKey, FrameworkField.createWithTypeFromKey(frameworkClass, bindingKey, name));
       } else {
-        // in the event that a provider is being used for a bunch of deps with different names,
+        // in the event that a field is being used for a bunch of deps with different names,
         // add all the names together with "And"s in the middle. E.g.: stringAndS
         Iterator<String> namesIterator = dependencyNames.iterator();
         String first = namesIterator.next();
@@ -108,10 +164,11 @@ public int compare(DependencyRequest left, DependencyRequest right) {
           compositeNameBuilder.append("And").append(
               CaseFormat.LOWER_CAMEL.to(UPPER_CAMEL, namesIterator.next()));
         }
-        providerNames.put(entry.getKey(), compositeNameBuilder.append("Provider").toString());
+        bindingFields.put(bindingKey, FrameworkField.createWithTypeFromKey(
+            frameworkClass, bindingKey, compositeNameBuilder.toString()));
       }
     }
-    return providerNames.build();
+    return bindingFields.build();
   }
 
   static Snippet frameworkTypeUsageStatement(Snippet frameworkTypeMemberSelect,
@@ -123,6 +180,7 @@ static Snippet frameworkTypeUsageStatement(Snippet frameworkTypeMemberSelect,
       case INSTANCE:
         return Snippet.format("%s.get()", frameworkTypeMemberSelect);
       case PROVIDER:
+      case PRODUCER:
       case MEMBERS_INJECTOR:
         return Snippet.format("%s", frameworkTypeMemberSelect);
       default:
@@ -138,10 +196,60 @@ static ClassName factoryNameForProvisionBinding(ProvisionBinding binding) {
       case PROVISION:
         return enclosingClassName.topLevelClassName().peerNamed(
             enclosingClassName.classFileName() + "$$" + factoryPrefix(binding) + "Factory");
+      case SYNTHETIC_PROVISON:
+        throw new IllegalArgumentException();
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  /**
+   * Returns the factory name parameterized with the ProvisionBinding's parameters (if necessary).
+   */
+  static TypeName parameterizedFactoryNameForProvisionBinding(
+      ProvisionBinding binding) {
+    ClassName factoryName = factoryNameForProvisionBinding(binding);
+    // Only parameterize injection unique bindings.
+    // Other kinds generate unique factories that have no type parameters.
+    if (binding.bindingType() == BindingType.UNIQUE
+        && binding.bindingKind() == ProvisionBinding.Kind.INJECTION) {
+      TypeName bindingName = TypeNames.forTypeMirror(binding.key().type());
+      // If the binding is parameterized, parameterize the factory.
+      if (bindingName instanceof ParameterizedTypeName) {
+        return ParameterizedTypeName.create(factoryName,
+            ((ParameterizedTypeName) bindingName).parameters());
+      }
+    }
+    return factoryName;
+  }
+
+  static ClassName factoryNameForProductionBinding(ProductionBinding binding) {
+    TypeElement enclosingTypeElement = binding.bindingTypeElement();
+    ClassName enclosingClassName = ClassName.fromTypeElement(enclosingTypeElement);
+    switch (binding.bindingKind()) {
+      case IMMEDIATE:
+      case FUTURE_PRODUCTION:
+        return enclosingClassName.topLevelClassName().peerNamed(
+            enclosingClassName.classFileName() + "$$" + factoryPrefix(binding) + "Factory");
       default:
         throw new AssertionError();
     }
   }
+  
+  /**
+   * Returns the members injector's name parameterized with the binding's parameters (if necessary).
+   */
+  static TypeName parameterizedMembersInjectorNameForMembersInjectionBinding(
+      MembersInjectionBinding binding) {
+    ClassName factoryName = membersInjectorNameForMembersInjectionBinding(binding);
+    TypeName bindingName = TypeNames.forTypeMirror(binding.key().type());
+    // If the binding is parameterized, parameterize the MembersInjector.
+    if (bindingName instanceof ParameterizedTypeName) {
+      return ParameterizedTypeName.create(factoryName,
+          ((ParameterizedTypeName) bindingName).parameters());
+    }
+    return factoryName;
+  }
 
   static ClassName membersInjectorNameForMembersInjectionBinding(MembersInjectionBinding binding) {
     ClassName injectedClassName = ClassName.fromTypeElement(binding.bindingElement());
@@ -161,5 +269,16 @@ private static String factoryPrefix(ProvisionBinding binding) {
     }
   }
 
+  private static String factoryPrefix(ProductionBinding binding) {
+    switch (binding.bindingKind()) {
+      case IMMEDIATE:
+      case FUTURE_PRODUCTION:
+        return CaseFormat.LOWER_CAMEL.to(UPPER_CAMEL,
+            ((ExecutableElement) binding.bindingElement()).getSimpleName().toString());
+      default:
+        throw new IllegalArgumentException();
+    }
+  }
+
   private SourceFiles() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 48df244c9..34df7eac9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -19,6 +19,7 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Equivalence;
+import com.google.common.base.Equivalence.Wrapper;
 import com.google.common.base.Optional;
 import com.google.common.collect.Iterables;
 import java.util.List;
@@ -99,8 +100,7 @@ protected TypeElement defaultAction(Object o, Void v) {
   }
 
   /**
-   * Wraps an {@link Optional} of a type in an {@code Optional} of an {@link Equivalence.Wrapper}
-   * for that type.
+   * Wraps an {@link Optional} of a type in an {@code Optional} of a {@link Wrapper} for that type.
    */
   static <T> Optional<Equivalence.Wrapper<T>> wrapOptionalInEquivalence(
       Equivalence<T> equivalence, Optional<T> optional) {
@@ -110,8 +110,8 @@ protected TypeElement defaultAction(Object o, Void v) {
   }
 
   /**
-   * Unwraps an {@link Optional} of an {@link Equivalence.Wrapper} into an {@code Optional} of
-   * the underlying type.
+   * Unwraps an {@link Optional} of a {@link Wrapper} into an {@code Optional} of the underlying
+   * type.
    */
   static <T> Optional<T> unwrapOptionalEquivalence(
       Optional<Equivalence.Wrapper<T>> wrappedOptional) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java b/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
index a93a11027..6f1be009f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
@@ -21,6 +21,7 @@
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
+import javax.tools.Diagnostic.Kind;
 
 import static javax.tools.Diagnostic.Kind.ERROR;
 
@@ -39,7 +40,15 @@
   abstract ImmutableSet<Item> items();
 
   boolean isClean() {
-    return items().isEmpty();
+    for (Item item : items()) {
+      switch (item.kind()) {
+        case ERROR:
+          return false;
+        default:
+          break;
+      }
+    }
+    return true;
   }
 
   void printMessagesTo(Messager messager) {
@@ -51,15 +60,16 @@ void printMessagesTo(Messager messager) {
   @AutoValue
   static abstract class Item implements PrintableErrorMessage {
     abstract String message();
+    abstract Kind kind();
     abstract Element element();
     abstract Optional<AnnotationMirror> annotation();
 
     @Override
     public void printMessageTo(Messager messager) {
       if (annotation().isPresent()) {
-        messager.printMessage(ERROR, message(), element(), annotation().get());
+        messager.printMessage(kind(), message(), element(), annotation().get());
       } else {
-        messager.printMessage(ERROR, message(), element());
+        messager.printMessage(kind(), message(), element());
       }
     }
   }
@@ -81,13 +91,28 @@ T getSubject() {
     }
 
     Builder<T> addItem(String message, Element element) {
-      items.add(new AutoValue_ValidationReport_Item(message, element,
-          Optional.<AnnotationMirror>absent()));
+      addItem(message, ERROR, element, Optional.<AnnotationMirror>absent());
+      return this;
+    }
+
+    Builder<T> addItem(String message, Kind kind, Element element) {
+      addItem(message, kind, element, Optional.<AnnotationMirror>absent());
       return this;
     }
 
     Builder<T> addItem(String message, Element element, AnnotationMirror annotation) {
-      items.add(new AutoValue_ValidationReport_Item(message, element, Optional.of(annotation)));
+      addItem(message, ERROR, element, Optional.of(annotation));
+      return this;
+    }
+
+    Builder<T> addItem(String message, Kind kind, Element element, AnnotationMirror annotation) {
+      addItem(message, kind, element, Optional.of(annotation));
+      return this;
+    }
+
+    private Builder<T> addItem(String message, Kind kind, Element element,
+        Optional<AnnotationMirror> annotation) {
+      items.add(new AutoValue_ValidationReport_Item(message, kind, element, annotation));
       return this;
     }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
index 841ee1ed7..20b373f40 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
@@ -16,13 +16,12 @@
 package dagger.internal.codegen.writer;
 
 import com.google.common.base.Function;
-import com.google.common.base.Joiner;
 import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
 import java.io.IOException;
-import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
 import javax.lang.model.element.Modifier;
@@ -33,12 +32,12 @@
 
 public final class ClassWriter extends TypeWriter {
   private final List<ConstructorWriter> constructorWriters;
-  private final List<TypeVariableName> typeVariables;
+  private final List<TypeVariableName> typeParameters;
 
   ClassWriter(ClassName className) {
     super(className);
     this.constructorWriters = Lists.newArrayList();
-    this.typeVariables = Lists.newArrayList();
+    this.typeParameters = Lists.newArrayList();
   }
 
   public ConstructorWriter addConstructor() {
@@ -46,6 +45,18 @@ public ConstructorWriter addConstructor() {
     constructorWriters.add(constructorWriter);
     return constructorWriter;
   }
+  
+  public void addTypeParameter(TypeVariableName typeVariableName) {
+    this.typeParameters.add(typeVariableName);
+  }
+  
+  public void addTypeParameters(Iterable<TypeVariableName> typeVariableNames) {
+    Iterables.addAll(typeParameters, typeVariableNames);
+  }
+  
+  public List<TypeVariableName> typeParameters() {
+    return ImmutableList.copyOf(typeParameters);
+  }
 
   @Override
   public Appendable write(Appendable appendable, Context context) throws IOException {
@@ -58,24 +69,12 @@ public Appendable write(Appendable appendable, Context context) throws IOExcepti
         .toSet());
     writeAnnotations(appendable, context);
     writeModifiers(appendable).append("class ").append(name.simpleName());
-    if (!typeVariables.isEmpty()) {
-      appendable.append('<');
-      Joiner.on(", ").appendTo(appendable, typeVariables);
-      appendable.append('>');
-    }
+    Writables.join(", ", typeParameters, "<", ">", appendable, context);
     if (supertype.isPresent()) {
       appendable.append(" extends ");
       supertype.get().write(appendable, context);
     }
-    Iterator<TypeName> implementedTypesIterator = implementedTypes.iterator();
-    if (implementedTypesIterator.hasNext()) {
-      appendable.append(" implements ");
-      implementedTypesIterator.next().write(appendable, context);
-      while (implementedTypesIterator.hasNext()) {
-        appendable.append(", ");
-        implementedTypesIterator.next().write(appendable, context);
-      }
-    }
+    Writables.join(", ", implementedTypes, " implements ", "", appendable, context);
     appendable.append(" {");
     if (!fieldWriters.isEmpty()) {
       appendable.append('\n');
@@ -115,7 +114,7 @@ private boolean isDefaultConstructor(ConstructorWriter constructorWriter) {
     @SuppressWarnings("unchecked")
     Iterable<? extends HasClassReferences> concat =
         Iterables.concat(nestedTypeWriters, fieldWriters.values(), constructorWriters,
-            methodWriters, implementedTypes, supertype.asSet(), annotations);
+            methodWriters, implementedTypes, supertype.asSet(), annotations, typeParameters);
     return FluentIterable.from(concat)
         .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
           @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ConstructorWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/ConstructorWriter.java
index 8e1c6987a..f4a2c15f7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ConstructorWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ConstructorWriter.java
@@ -18,10 +18,10 @@
 import com.google.common.base.Function;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
 import java.io.IOException;
-import java.util.Iterator;
 import java.util.Map;
 import java.util.Set;
 import javax.lang.model.element.TypeElement;
@@ -56,6 +56,14 @@ public VariableWriter addParameter(TypeName type, String name) {
     parameterWriters.put(name, parameterWriter);
     return parameterWriter;
   }
+  
+  public Map<String, TypeName> parameters() {
+    ImmutableMap.Builder<String, TypeName> params = ImmutableMap.builder();
+    for (Map.Entry<String, VariableWriter> entry : parameterWriters.entrySet()) {
+      params.put(entry.getKey(), entry.getValue().type());
+    }
+    return params.build();
+  }
 
   public BlockWriter body() {
     return blockWriter;
@@ -84,14 +92,7 @@ private VariableWriter addParameter(ClassName type, String name) {
   @Override
   public Appendable write(Appendable appendable, Context context) throws IOException {
     writeModifiers(appendable).append(name).append('(');
-    Iterator<VariableWriter> parameterWritersIterator = parameterWriters.values().iterator();
-    if (parameterWritersIterator.hasNext()) {
-      parameterWritersIterator.next().write(appendable, context);
-    }
-    while (parameterWritersIterator.hasNext()) {
-      appendable.append(", ");
-      parameterWritersIterator.next().write(appendable, context);
-    }
+    Writables.join(", ", parameterWriters.values(), appendable, context);
     appendable.append(") {");
     blockWriter.write(new IndentingAppendable(appendable), context);
     return appendable.append("}\n");
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
index 2d37757a7..51d7970d0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
@@ -86,7 +86,7 @@ public ClassWriter addClass(String simpleName) {
 
   public EnumWriter addEnum(String simpleName) {
     checkNotNull(simpleName);
-    EnumWriter writer = new EnumWriter(ClassName.create(simpleName, simpleName));
+    EnumWriter writer = new EnumWriter(ClassName.create(packageName, simpleName));
     typeWriters.add(writer);
     return writer;
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java
index 5ef8eabfc..e44a65f90 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java
@@ -20,9 +20,10 @@
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import java.io.IOException;
-import java.util.Iterator;
+import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import javax.lang.model.element.TypeElement;
@@ -33,18 +34,28 @@
   private final TypeName returnType;
   private final String name;
   private final Map<String, VariableWriter> parameterWriters;
+  private final List<TypeVariableName> typeParameters;
   private Optional<BlockWriter> body;
 
   MethodWriter(TypeName returnType, String name) {
     this.returnType = returnType;
     this.name = name;
     this.parameterWriters = Maps.newLinkedHashMap();
+    this.typeParameters = Lists.newArrayList();
     this.body = Optional.absent();
   }
 
   public String name() {
     return name;
   }
+  
+  public void addTypeParameter(TypeVariableName typeVariableName) {
+    this.typeParameters.add(typeVariableName);
+  }
+  
+  public void addTypeParameters(Iterable<TypeVariableName> typeVariableNames) {
+    Iterables.addAll(typeParameters, typeVariableNames);
+  }
 
   public VariableWriter addParameter(Class<?> type, String name) {
     return addParameter(ClassName.fromClass(type), name);
@@ -79,16 +90,10 @@ public BlockWriter body() {
   public Appendable write(Appendable appendable, Context context) throws IOException {
     writeAnnotations(appendable, context);
     writeModifiers(appendable);
+    Writables.join(", ", typeParameters, "<", "> ", appendable, context);
     returnType.write(appendable, context);
     appendable.append(' ').append(name).append('(');
-    Iterator<VariableWriter> parameterWritersIterator = parameterWriters.values().iterator();
-    if (parameterWritersIterator.hasNext()) {
-      parameterWritersIterator.next().write(appendable, context);
-    }
-    while (parameterWritersIterator.hasNext()) {
-      appendable.append(", ");
-      parameterWritersIterator.next().write(appendable, context);
-    }
+    Writables.join(", ", parameterWriters.values(), appendable, context);
     appendable.append(")");
     if (body.isPresent()) {
       appendable.append(" {");
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ParameterizedTypeName.java b/compiler/src/main/java/dagger/internal/codegen/writer/ParameterizedTypeName.java
index 7e816165d..63cf3dd95 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ParameterizedTypeName.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ParameterizedTypeName.java
@@ -27,12 +27,20 @@
 
 public final class ParameterizedTypeName implements TypeName {
   private final ClassName type;
-  private final ImmutableList<? extends TypeName> parameters;
+  private final ImmutableList<TypeName> parameters;
 
   ParameterizedTypeName(ClassName type, Iterable<? extends TypeName> parameters) {
     this.type = type;
     this.parameters = ImmutableList.copyOf(parameters);
   }
+  
+  public ClassName type() {
+    return type;
+  }
+  
+  public ImmutableList<TypeName> parameters() {
+    return parameters;
+  }
 
   @Override
   public Set<ClassName> referencedClasses() {
@@ -85,6 +93,11 @@ public static ParameterizedTypeName create(ClassName className,
     return new ParameterizedTypeName(className, ImmutableList.copyOf(parameters));
   }
 
+  public static ParameterizedTypeName create(ClassName className,
+      Iterable<? extends TypeName> parameters) {
+    return new ParameterizedTypeName(className, ImmutableList.copyOf(parameters));
+  }
+
   public static ParameterizedTypeName create(Class<?> parameterizedClass,
       TypeName... parameters) {
     checkArgument(parameterizedClass.getTypeParameters().length == parameters.length);
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java b/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java
index 07cbf766b..52aeb44b0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java
@@ -25,7 +25,6 @@
 import java.util.Collections;
 import java.util.Formatter;
 import java.util.Iterator;
-import java.util.List;
 import java.util.Set;
 
 public final class Snippet implements HasClassReferences, Writable {
@@ -111,7 +110,7 @@ public static Snippet memberSelectSnippet(Iterable<? extends Object> selectors)
         selectors);
   }
 
-  public static Snippet makeParametersSnippet(List<Snippet> parameterSnippets) {
+  public static Snippet makeParametersSnippet(Iterable<Snippet> parameterSnippets) {
     Iterator<Snippet> iterator = parameterSnippets.iterator();
     StringBuilder stringBuilder = new StringBuilder();
     ImmutableSet.Builder<TypeName> typesBuilder = ImmutableSet.builder();
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/TypeNames.java b/compiler/src/main/java/dagger/internal/codegen/writer/TypeNames.java
index b97b06fe2..4bc234739 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/TypeNames.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/TypeNames.java
@@ -24,6 +24,7 @@
 import javax.lang.model.type.NullType;
 import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.TypeVariable;
 import javax.lang.model.type.WildcardType;
 import javax.lang.model.util.SimpleTypeVisitor6;
 
@@ -53,6 +54,11 @@ public static TypeName forTypeMirror(TypeMirror mirror) {
       protected TypeName defaultAction(TypeMirror e, Void p) {
         throw new IllegalArgumentException(e.toString());
       }
+      
+      @Override
+      public TypeName visitTypeVariable(TypeVariable t, Void p) {
+        return TypeVariableName.fromTypeVariable(t);
+      }
 
       @Override
       public ArrayTypeName visitArray(ArrayType t, Void p) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/TypeVariableName.java b/compiler/src/main/java/dagger/internal/codegen/writer/TypeVariableName.java
index 4d46167d5..c6ee533ca 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/TypeVariableName.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/TypeVariableName.java
@@ -15,34 +15,38 @@
  */
 package dagger.internal.codegen.writer;
 
-import com.google.common.base.Optional;
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Objects;
+import com.google.common.base.Predicate;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
 import java.io.IOException;
+import java.util.Iterator;
 import java.util.Set;
+import javax.lang.model.element.TypeParameterElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.TypeVariable;
 
 public final class TypeVariableName implements TypeName {
-  private final String name;
-  private final Optional<TypeName> extendsBound;
-  private final Optional<TypeName> superBound;
-  TypeVariableName(String name, Optional<TypeName> extendsBound,
-      Optional<TypeName> superBound) {
+  private final CharSequence name;
+  private final Iterable<? extends TypeName> extendsBounds;
+
+  TypeVariableName(CharSequence name, Iterable<? extends TypeName> extendsBounds) {
     this.name = name;
-    this.extendsBound = extendsBound;
-    this.superBound = superBound;
+    this.extendsBounds = extendsBounds;
   }
 
-  public String name() {
+  public CharSequence name() {
     return name;
   }
 
   @Override
   public Set<ClassName> referencedClasses() {
     ImmutableSet.Builder<ClassName> builder = new ImmutableSet.Builder<ClassName>();
-    if (extendsBound.isPresent()) {
-      builder.addAll(extendsBound.get().referencedClasses());
-    }
-    if (superBound.isPresent()) {
-      builder.addAll(superBound.get().referencedClasses());
+    for (TypeName bound : extendsBounds) {
+      builder.addAll(bound.referencedClasses());
     }
     return builder.build();
   }
@@ -50,13 +54,14 @@ public String name() {
   @Override
   public Appendable write(Appendable appendable, Context context) throws IOException {
     appendable.append(name);
-    if (extendsBound.isPresent()) {
-      appendable.append(' ');
-      extendsBound.get().write(appendable, context);
-    }
-    if (superBound.isPresent()) {
-      appendable.append(' ');
-      superBound.get().write(appendable, context);
+    if (!Iterables.isEmpty(extendsBounds)) {
+      appendable.append(" extends ");
+      Iterator<? extends TypeName> iter = extendsBounds.iterator();
+      iter.next().write(appendable, context);
+      while (iter.hasNext()) {
+        appendable.append(" & ");
+        iter.next().write(appendable, context);  
+      }
     }
     return appendable;
   }
@@ -66,8 +71,45 @@ public String toString() {
     return Writables.writeToString(this);
   }
 
-  static TypeVariableName named(String name) {
-    return new TypeVariableName(
-        name, Optional.<TypeName>absent(), Optional.<TypeName>absent());
+  @Override
+  public boolean equals(Object obj) {
+    if (obj instanceof TypeVariableName) {
+      TypeVariableName that = (TypeVariableName) obj;
+      return this.name.toString().equals(that.name.toString())
+          && this.extendsBounds.equals(that.extendsBounds);
+    } else {
+      return false;
+    }
+  }
+
+  @Override
+  public int hashCode() {
+    return Objects.hashCode(name, extendsBounds);
+  }
+
+  static TypeVariableName named(CharSequence name) {
+    return new TypeVariableName(name, ImmutableList.<TypeName>of());
+  }
+  
+  public static TypeVariableName fromTypeVariable(TypeVariable variable) {
+    // Note: We don't have any use right now for the bounds because these are references
+    // to the type & not the specification of the type itself.  We never generate
+    // code with type variables that include upper or lower bounds.
+    return named(variable.asElement().getSimpleName());
+  }
+
+  // TODO(sameb): Consider making this a whole different thing: TypeParameterName since it
+  // has different semantics than a TypeVariable (parameters only have upper bounds).
+  public static TypeVariableName fromTypeParameterElement(TypeParameterElement element) {
+    // We filter out bounds of type Object because those would just clutter the generated code.
+    Iterable<? extends TypeName> bounds =
+        FluentIterable.from(element.getBounds())
+            .filter(new Predicate<TypeMirror>() {
+              @Override public boolean apply(TypeMirror input) {
+                return !MoreTypes.isType(input) || !MoreTypes.isTypeOf(Object.class, input);
+              }
+            })
+            .transform(TypeNames.FOR_TYPE_MIRROR);
+    return new TypeVariableName(element.getSimpleName(), bounds);
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java
index 69dba9f96..364b3a239 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java
@@ -23,6 +23,8 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
 
+import static com.google.common.base.Preconditions.checkState;
+
 /**
  * Only named types. Doesn't cover anonymous inner classes.
  */
@@ -89,6 +91,15 @@ public void addImplementedType(TypeElement typeElement) {
     implementedTypes.add(ClassName.fromTypeElement(typeElement));
   }
 
+  public void setSuperType(TypeName typeReference) {
+    checkState(!supertype.isPresent());
+    supertype = Optional.of(typeReference);
+  }
+
+  public void setSuperType(TypeElement typeElement) {
+    setSuperType(ClassName.fromTypeElement(typeElement));
+  }
+
   public FieldWriter addField(Class<?> type, String name) {
     return addField(ClassName.fromClass(type), name);
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Writables.java b/compiler/src/main/java/dagger/internal/codegen/writer/Writables.java
index 86999cc83..0186cbfcf 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/Writables.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/Writables.java
@@ -17,9 +17,36 @@
 
 import dagger.internal.codegen.writer.Writable.Context;
 import java.io.IOException;
+import java.util.Iterator;
 import java.util.Set;
 
 final class Writables {
+
+  /**
+   * Joins the writables by the given delimiter, writing out the
+   * prefix & suffix if there's at least one element.
+   */
+  static void join(String delimiter, Iterable<? extends Writable> writables,
+      String prefix, String suffix,
+      Appendable appendable, Context context) throws IOException {
+    Iterator<? extends Writable> iter = writables.iterator();
+    if (iter.hasNext()) {
+      appendable.append(prefix);
+      iter.next().write(appendable, context);
+      while (iter.hasNext()) {
+        appendable.append(delimiter);
+        iter.next().write(appendable, context);
+      }
+      appendable.append(suffix);
+    }
+  }
+
+  /** Joins the writables by the given delimiter. */
+  static void join(String delimiter, Iterable<? extends Writable> writables,
+      Appendable appendable, Context context) throws IOException {
+    join(delimiter, writables, "", "", appendable, context);
+  }
+
   static Writable toStringWritable(final Object object) {
     return new Writable() {
       @Override
diff --git a/compiler/src/test/java/dagger/internal/codegen/AnnotationMirrorsTest.java b/compiler/src/test/java/dagger/internal/codegen/AnnotationMirrorsTest.java
deleted file mode 100644
index 5e277284a..000000000
--- a/compiler/src/test/java/dagger/internal/codegen/AnnotationMirrorsTest.java
+++ /dev/null
@@ -1,185 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.common.testing.EquivalenceTester;
-import com.google.testing.compile.CompilationRule;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.AnnotationValue;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.SimpleAnnotationValueVisitor6;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static com.google.common.collect.Iterables.getOnlyElement;
-import static com.google.common.truth.Truth.assert_;
-import static dagger.internal.codegen.AnnotationMirrorsTest.SimpleEnum.BLAH;
-import static dagger.internal.codegen.AnnotationMirrorsTest.SimpleEnum.FOO;
-
-/**
- * Tests {@link AnnotationMirrors}.
- */
-@RunWith(JUnit4.class)
-public class AnnotationMirrorsTest {
-  @Rule public CompilationRule compilationRule = new CompilationRule();
-
-  private Elements elements;
-
-  @Before public void setUp() {
-    this.elements = compilationRule.getElements();
-  }
-
-  @interface SimpleAnnotation {}
-
-  @SimpleAnnotation class SimplyAnnotated {}
-  @SimpleAnnotation class AlsoSimplyAnnotated {}
-
-  enum SimpleEnum{
-    BLAH, FOO
-  }
-
-  @interface Outer {
-    SimpleEnum value();
-  }
-
-  @Outer(BLAH) static class TestClassBlah {}
-  @Outer(BLAH) static class TestClassBlah2 {}
-  @Outer(FOO) static class TestClassFoo {}
-
-  @interface DefaultingOuter {
-    SimpleEnum value() default SimpleEnum.BLAH;
-  }
-
-  @DefaultingOuter class TestWithDefaultingOuterDefault {}
-  @DefaultingOuter(BLAH) class TestWithDefaultingOuterBlah {}
-  @DefaultingOuter(FOO) class TestWithDefaultingOuterFoo {}
-
-  @interface AnnotatedOuter {
-    DefaultingOuter value();
-  }
-
-  @AnnotatedOuter(@DefaultingOuter) class TestDefaultNestedAnnotated {}
-  @AnnotatedOuter(@DefaultingOuter(BLAH)) class TestBlahNestedAnnotated {}
-  @AnnotatedOuter(@DefaultingOuter(FOO)) class TestFooNestedAnnotated {}
-
-  @interface OuterWithValueArray {
-    DefaultingOuter[] value() default {};
-  }
-
-  @OuterWithValueArray class TestValueArrayWithDefault {}
-  @OuterWithValueArray({}) class TestValueArrayWithEmpty {}
-
-  @OuterWithValueArray({@DefaultingOuter}) class TestValueArrayWithOneDefault {}
-  @OuterWithValueArray(@DefaultingOuter(BLAH)) class TestValueArrayWithOneBlah {}
-  @OuterWithValueArray(@DefaultingOuter(FOO)) class TestValueArrayWithOneFoo {}
-
-  @OuterWithValueArray({@DefaultingOuter(FOO), @DefaultingOuter})
-  class TestValueArrayWithFooAndDefaultBlah {}
-  @OuterWithValueArray({@DefaultingOuter(FOO), @DefaultingOuter(BLAH)})
-  class TestValueArrayWithFooBlah {}
-  @OuterWithValueArray({@DefaultingOuter(FOO), @DefaultingOuter(BLAH)})
-  class TestValueArrayWithFooBlah2 {} // Different instances than on TestValueArrayWithFooBlah.
-  @OuterWithValueArray({@DefaultingOuter(BLAH), @DefaultingOuter(FOO)})
-  class TestValueArrayWithBlahFoo {}
-
-  @Test public void testEquivalences() {
-    EquivalenceTester<AnnotationMirror> tester =
-        EquivalenceTester.of(AnnotationMirrors.equivalence());
-
-    tester.addEquivalenceGroup(
-        annotationOn(SimplyAnnotated.class),
-        annotationOn(AlsoSimplyAnnotated.class));
-
-    tester.addEquivalenceGroup(
-        annotationOn(TestClassBlah.class),
-        annotationOn(TestClassBlah2.class));
-
-    tester.addEquivalenceGroup(
-        annotationOn(TestClassFoo.class));
-
-    tester.addEquivalenceGroup(
-        annotationOn(TestWithDefaultingOuterDefault.class),
-        annotationOn(TestWithDefaultingOuterBlah.class));
-
-    tester.addEquivalenceGroup(
-        annotationOn(TestWithDefaultingOuterFoo.class));
-
-    tester.addEquivalenceGroup(
-        annotationOn(TestDefaultNestedAnnotated.class),
-        annotationOn(TestBlahNestedAnnotated.class));
-
-    tester.addEquivalenceGroup(
-        annotationOn(TestFooNestedAnnotated.class));
-
-    tester.addEquivalenceGroup(
-        annotationOn(TestValueArrayWithDefault.class),
-        annotationOn(TestValueArrayWithEmpty.class));
-
-    tester.addEquivalenceGroup(
-        annotationOn(TestValueArrayWithOneDefault.class),
-        annotationOn(TestValueArrayWithOneBlah.class));
-
-    tester.addEquivalenceGroup(
-        annotationOn(TestValueArrayWithOneFoo.class));
-
-    tester.addEquivalenceGroup(
-        annotationOn(TestValueArrayWithFooAndDefaultBlah.class),
-        annotationOn(TestValueArrayWithFooBlah.class),
-        annotationOn(TestValueArrayWithFooBlah2.class));
-
-    tester.addEquivalenceGroup(
-        annotationOn(TestValueArrayWithBlahFoo.class));
-
-    tester.test();
-  }
-
-  @interface Stringy {
-    String value() default "default";
-  }
-
-  @Stringy class StringyUnset {}
-  @Stringy("foo") class StringySet {}
-
-  @Test public void testGetDefaultValuesUnset() {
-    assert_().that(annotationOn(StringyUnset.class).getElementValues()).isEmpty();
-    Iterable<AnnotationValue> values = AnnotationMirrors.getAnnotationValuesWithDefaults(
-        annotationOn(StringyUnset.class)).values();
-    String value = getOnlyElement(values).accept(new SimpleAnnotationValueVisitor6<String, Void>() {
-          @Override public String visitString(String value, Void ignored) {
-            return value;
-          }
-        }, null);
-    assert_().that(value).isEqualTo("default");
-  }
-
-  @Test public void testGetDefaultValuesSet() {
-    Iterable<AnnotationValue> values = AnnotationMirrors.getAnnotationValuesWithDefaults(
-        annotationOn(StringySet.class)).values();
-    String value = getOnlyElement(values).accept(new SimpleAnnotationValueVisitor6<String, Void>() {
-          @Override public String visitString(String value, Void ignored) {
-            return value;
-          }
-        }, null);
-    assert_().that(value).isEqualTo("foo");
-  }
-
-  private AnnotationMirror annotationOn(Class<?> clazz) {
-    return getOnlyElement(elements.getTypeElement(clazz.getCanonicalName()).getAnnotationMirrors());
-  }
-}
diff --git a/compiler/src/test/java/dagger/internal/codegen/BindingFieldTest.java b/compiler/src/test/java/dagger/internal/codegen/BindingFieldTest.java
new file mode 100644
index 000000000..eaaa595d3
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/BindingFieldTest.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.Iterables;
+import com.google.testing.compile.CompilationRule;
+import dagger.MembersInjector;
+import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.ParameterizedTypeName;
+import dagger.internal.codegen.writer.TypeName;
+import dagger.internal.codegen.writer.TypeNames;
+import javax.inject.Inject;
+import javax.inject.Provider;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+/**
+ * Test case for {@link FrameworkField}.
+ */
+@RunWith(JUnit4.class)
+public class BindingFieldTest {
+  @Rule public CompilationRule compilationRule = new CompilationRule();
+
+  private Elements elements;
+  private Types types;
+  private Key.Factory keyFactory;
+
+  @Before public void setUp() {
+    this.types = compilationRule.getTypes();
+    this.elements = compilationRule.getElements();
+    this.keyFactory = new Key.Factory(types, elements);
+  }
+
+  private ExecutableElement getXConstructor() {
+    TypeElement classElement = elements.getTypeElement(X.class.getCanonicalName());
+    return Iterables.getOnlyElement(
+        ElementFilter.constructorsIn(classElement.getEnclosedElements()));
+  }
+
+  @Test public void frameworkType() {
+    Key key = keyFactory.forInjectConstructorWithResolvedType(
+        getXConstructor().getEnclosingElement().asType());
+    TypeName xClass = TypeNames.forTypeMirror(key.type());
+    assertThat(FrameworkField.createWithTypeFromKey(Provider.class,
+            BindingKey.create(BindingKey.Kind.CONTRIBUTION, key), "test")
+        .frameworkType())
+        .isEqualTo(ParameterizedTypeName.create(
+            ClassName.fromClass(Provider.class), xClass));
+    assertThat(FrameworkField.createWithTypeFromKey(MembersInjector.class,
+            BindingKey.create(BindingKey.Kind.MEMBERS_INJECTION, key), "test")
+        .frameworkType())
+        .isEqualTo(ParameterizedTypeName.create(
+            ClassName.fromClass(MembersInjector.class), xClass));
+  }
+
+  @Test public void nameSuffix() {
+    Key key = keyFactory.forInjectConstructorWithResolvedType(
+        getXConstructor().getEnclosingElement().asType());
+    assertThat(FrameworkField.createWithTypeFromKey(Provider.class,
+            BindingKey.create(BindingKey.Kind.CONTRIBUTION, key), "foo").name())
+        .isEqualTo("fooProvider");
+    assertThat(FrameworkField.createWithTypeFromKey(Provider.class,
+            BindingKey.create(BindingKey.Kind.CONTRIBUTION, key), "fooProvider").name())
+        .isEqualTo("fooProvider");
+
+  }
+
+  static final class X {
+    @Inject X() {}
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index 73854c5fd..8d41a1013 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -18,11 +18,12 @@
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assert_;
+import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 
@@ -36,7 +37,7 @@
         "",
         "@Component",
         "final class NotAComponent {}");
-    assert_().about(javaSource()).that(componentFile)
+    assertAbout(javaSource()).that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining("interface");
@@ -52,7 +53,7 @@
         "enum NotAComponent {",
         "  INSTANCE",
         "}");
-    assert_().about(javaSource()).that(componentFile)
+    assertAbout(javaSource()).that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining("interface");
@@ -66,7 +67,7 @@
         "",
         "@Component",
         "@interface NotAComponent {}");
-    assert_().about(javaSource()).that(componentFile)
+    assertAbout(javaSource()).that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining("interface");
@@ -80,7 +81,7 @@
         "",
         "@Component(modules = Object.class)",
         "interface NotAComponent {}");
-    assert_().about(javaSource()).that(componentFile)
+    assertAbout(javaSource()).that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining("is not annotated with @Module");
@@ -138,17 +139,17 @@
         "",
         "  @Override",
         "  public SomeInjectableType someInjectableType() {",
-        "    return SomeInjectableType$$Factory.INSTANCE.get();",
+        "    return SomeInjectableType$$Factory.create().get();",
         "  }",
         "",
         "  @Override",
         "  public Lazy<SomeInjectableType> lazySomeInjectableType() {",
-        "    return DoubleCheckLazy.create(SomeInjectableType$$Factory.INSTANCE);",
+        "    return DoubleCheckLazy.create(SomeInjectableType$$Factory.create());",
         "  }",
         "",
         "  @Override",
         "  public Provider<SomeInjectableType> someInjectableTypeProvider() {",
-        "    return SomeInjectableType$$Factory.INSTANCE;",
+        "    return SomeInjectableType$$Factory.create();",
         "  }",
         "",
         "  public static final class Builder {",
@@ -160,7 +161,7 @@
         "    }",
         "  }",
         "}");
-    assert_().about(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
+    assertAbout(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
@@ -221,7 +222,7 @@
         "",
         "  private void initialize() {",
         "    this.someInjectableTypeProvider =",
-        "        ScopedProvider.create(SomeInjectableType$$Factory.INSTANCE);",
+        "        ScopedProvider.create(SomeInjectableType$$Factory.create());",
         "  }",
         "",
         "  @Override",
@@ -248,7 +249,7 @@
         "    }",
         "  }",
         "}");
-    assert_().about(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
+    assertAbout(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
@@ -273,51 +274,9 @@
         "    void inject(B b);",
         "  }",
         "}");
-    JavaFileObject aFactory = JavaFileObjects.forSourceLines(
-        "test.OuterType$A$$Factory",
-        "package test;",
-        "",
-        "import dagger.Factory;",
-        "import javax.annotation.Generated;",
-        "import test.OuterType.A;",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public enum OuterType$A$$Factory implements Factory<A> {",
-        "  INSTANCE;",
-        "",
-        "  @Override public A get() {",
-        "    return new A();",
-        "  }",
-        "}");
-    JavaFileObject bMembersInjector = JavaFileObjects.forSourceLines(
-        "test.OuterType$B$$MembersInjector",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "import test.OuterType.A;",
-        "import test.OuterType.B;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class OuterType$B$$MembersInjector implements MembersInjector<B> {",
-        "  private final Provider<A> aProvider;",
-        "",
-        "  public OuterType$B$$MembersInjector(Provider<A> aProvider) {",
-        "    assert aProvider != null;",
-        "    this.aProvider = aProvider;",
-        "  }",
-         "",
-        "  @Override",
-        "  public void injectMembers(B instance) {",
-        "    if (instance == null) {",
-        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
-        "    }",
-        "    instance.a = aProvider.get();",
-        "  }",
-        "}");
 
     JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.Dagger_OuterType$SimpleComponent",
+        "test.Dagger_OuterType_SimpleComponent",
         "package test;",
         "",
         "import dagger.MembersInjector;",
@@ -327,10 +286,10 @@
         "import test.OuterType.SimpleComponent;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class Dagger_OuterType$SimpleComponent implements SimpleComponent {",
+        "public final class Dagger_OuterType_SimpleComponent implements SimpleComponent {",
         "  private MembersInjector<B> bMembersInjector;",
         "",
-        "  private Dagger_OuterType$SimpleComponent(Builder builder) {",
+        "  private Dagger_OuterType_SimpleComponent(Builder builder) {",
         "    assert builder != null;",
         "    initialize();",
         "  }",
@@ -345,12 +304,12 @@
         "",
         "  private void initialize() {",
         "    this.bMembersInjector =",
-        "        new OuterType$B$$MembersInjector(OuterType$A$$Factory.INSTANCE);",
+        "        OuterType$B$$MembersInjector.create(OuterType$A$$Factory.create());",
         "  }",
         "",
         "  @Override",
         "  public A a() {",
-        "    return OuterType$A$$Factory.INSTANCE.get();",
+        "    return OuterType$A$$Factory.create().get();",
         "  }",
         "",
         "  @Override",
@@ -363,14 +322,14 @@
         "    }",
         "",
         "    public SimpleComponent build() {",
-        "      return new Dagger_OuterType$SimpleComponent(this);",
+        "      return new Dagger_OuterType_SimpleComponent(this);",
         "    }",
         "  }",
         "}");
-    assert_().about(javaSources()).that(ImmutableList.of(nestedTypesFile))
+    assertAbout(javaSources()).that(ImmutableList.of(nestedTypesFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(aFactory, bMembersInjector, generatedComponent);
+        .and().generatesSources(generatedComponent);
   }
 
   @Test public void componentWithModule() {
@@ -445,8 +404,8 @@
         "  }",
         "",
         "  private void initialize() {",
-        "    this.bProvider = new TestModule$$BFactory(testModule, C$$Factory.INSTANCE);",
-        "    this.aProvider = new A$$Factory(bProvider);",
+        "    this.bProvider = new TestModule$$BFactory(testModule, C$$Factory.create());",
+        "    this.aProvider = A$$Factory.create(bProvider);",
         "  }",
         "",
         "  @Override",
@@ -476,7 +435,7 @@
         "    }",
         "  }",
         "}");
-    assert_().about(javaSources())
+    assertAbout(javaSources())
         .that(ImmutableList.of(aFile, bFile, cFile, moduleFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -570,7 +529,7 @@
         "    }",
         "  }",
         "}");
-    assert_().about(javaSources())
+    assertAbout(javaSources())
         .that(ImmutableList.of(moduleFile, depModuleFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -629,6 +588,8 @@
         "public final class Dagger_TestComponent implements TestComponent {",
         "  private final EmptySetModule emptySetModule;",
         "  private final SetModule setModule;",
+        "  private Provider<Set<String>> setOfStringContribution1Provider;",
+        "  private Provider<Set<String>> setOfStringContribution2Provider;",
         "  private Provider<Set<String>> setOfStringProvider;",
         "",
         "  private Dagger_TestComponent(Builder builder) {",
@@ -647,9 +608,11 @@
         "  }",
         "",
         "  private void initialize() {",
-        "    this.setOfStringProvider =",
-        "        SetFactory.create(new EmptySetModule$$EmptySetFactory(emptySetModule),",
-        "            new SetModule$$StringFactory(setModule));",
+        "    this.setOfStringContribution1Provider =",
+        "        new EmptySetModule$$EmptySetFactory(emptySetModule);",
+        "    this.setOfStringContribution2Provider = new SetModule$$StringFactory(setModule);",
+        "    this.setOfStringProvider = SetFactory.create(",
+        "        setOfStringContribution1Provider, setOfStringContribution2Provider);",
         "  }",
         "",
         "  @Override",
@@ -691,7 +654,7 @@
         "    }",
         "  }",
         "}");
-    assert_().about(javaSources())
+    assertAbout(javaSources())
         .that(ImmutableList.of(emptySetModuleFile, setModuleFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -755,7 +718,7 @@
         "",
         "  private void initialize() {",
         "    this.someInjectedTypeMembersInjector =",
-        "        new SomeInjectedType$$MembersInjector(SomeInjectableType$$Factory.INSTANCE);",
+        "        SomeInjectedType$$MembersInjector.create(SomeInjectableType$$Factory.create());",
         "  }",
         "",
         "  @Override",
@@ -778,7 +741,7 @@
         "    }",
         "  }",
         "}");
-    assert_().about(javaSources())
+    assertAbout(javaSources())
         .that(ImmutableList.of(injectableTypeFile, injectedTypeFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -835,7 +798,7 @@
         "  private void initialize() {",
         "    this.simpleComponentProvider = InstanceFactory.<SimpleComponent>create(this);",
         "    this.someInjectableTypeProvider =",
-        "        new SomeInjectableType$$Factory(simpleComponentProvider);",
+        "        SomeInjectableType$$Factory.create(simpleComponentProvider);",
         "  }",
         "",
         "  @Override",
@@ -852,7 +815,7 @@
         "    }",
         "  }",
         "}");
-    assert_().about(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
+    assertAbout(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
@@ -913,9 +876,9 @@
         "",
         "  private void initialize() {",
         "    this.someInjectedTypeMembersInjector =",
-        "        new SomeInjectedType$$MembersInjector(SomeInjectableType$$Factory.INSTANCE);",
+        "        SomeInjectedType$$MembersInjector.create(SomeInjectableType$$Factory.create());",
         "    this.someInjectedTypeProvider =",
-        "        new SomeInjectedType$$Factory(someInjectedTypeMembersInjector);",
+        "        SomeInjectedType$$Factory.create(someInjectedTypeMembersInjector);",
         "  }",
         "",
         "  @Override",
@@ -932,13 +895,93 @@
         "    }",
         "  }",
         "}");
-    assert_().about(javaSources())
+    assertAbout(javaSources())
         .that(ImmutableList.of(injectableTypeFile, injectedTypeFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
   }
 
+  @Test public void injectionWithGenericBaseClass() {
+    JavaFileObject genericType = JavaFileObjects.forSourceLines("test.AbstractGenericType",
+        "package test;",
+        "",
+        "abstract class AbstractGenericType<T> {",
+        "}");
+    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class SomeInjectableType extends AbstractGenericType<String> {",
+        "  @Inject SomeInjectableType() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface SimpleComponent {",
+        "  SomeInjectableType someInjectableType();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.Dagger_SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import dagger.internal.MembersInjectors;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_SimpleComponent implements SimpleComponent {",
+        "  private MembersInjector<AbstractGenericType<String>> abstractGenericTypeMembersInjector;",
+        "  private MembersInjector<SomeInjectableType> someInjectableTypeMembersInjector;",
+        "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
+        "",
+        "  private Dagger_SimpleComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize();",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static SimpleComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize() {",
+        "    this.abstractGenericTypeMembersInjector = MembersInjectors.noOp();",
+        "    this.someInjectableTypeMembersInjector = MembersInjectors.delegatingTo(",
+        "        abstractGenericTypeMembersInjector);",
+        "    this.someInjectableTypeProvider =",
+        "        SomeInjectableType$$Factory.create(someInjectableTypeMembersInjector);",
+        "  }",
+        "",
+        "  @Override",
+        "  public SomeInjectableType someInjectableType() {",
+        "    return someInjectableTypeProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public SimpleComponent build() {",
+        "      return new Dagger_SimpleComponent(this);",
+        "    }",
+        "  }",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(genericType, injectableTypeFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+
   @Test public void componentDependency() {
     JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
         "package test;",
@@ -1010,7 +1053,7 @@
         "        return aComponent.a();",
         "      }",
         "    };",
-        "    this.bProvider = new B$$Factory(aProvider);",
+        "    this.bProvider = B$$Factory.create(aProvider);",
         "  }",
         "",
         "  @Override",
@@ -1040,7 +1083,7 @@
         "    }",
         "  }",
         "}");
-    assert_().about(javaSources())
+    assertAbout(javaSources())
         .that(ImmutableList.of(aFile, bFile, aComponentFile, bComponentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -1171,7 +1214,7 @@
         "    }",
         "  }",
         "}");
-    assert_().about(javaSources())
+    assertAbout(javaSources())
         .that(ImmutableList.of(aFile, otherAFile, moduleFile, otherModuleFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -1252,9 +1295,9 @@
         "  }",
         "",
         "  private void initialize() {",
-        "    this.bProvider = new B$$Factory(C$$Factory.INSTANCE);",
-        "    this.aProvider = new A$$Factory(bProvider);",
-        "    this.xProvider = new X$$Factory(C$$Factory.INSTANCE);",
+        "    this.bProvider = B$$Factory.create(C$$Factory.create());",
+        "    this.aProvider = A$$Factory.create(bProvider);",
+        "    this.xProvider = X$$Factory.create(C$$Factory.create());",
         "  }",
         "",
         "  @Override",
@@ -1264,7 +1307,7 @@
         "",
         "  @Override",
         "  public C c() {",
-        "    return C$$Factory.INSTANCE.get();",
+        "    return C$$Factory.create().get();",
         "  }",
         "",
         "  @Override",
@@ -1281,7 +1324,7 @@
         "    }",
         "  }",
         "}");
-    assert_().about(javaSources())
+    assertAbout(javaSources())
         .that(ImmutableList.of(aFile, bFile, cFile, xFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -1357,7 +1400,7 @@
         "",
         "  @Override",
         "  public SomeInjectableType someInjectableType() {",
-        "    return SomeInjectableType$$Factory.INSTANCE.get();",
+        "    return SomeInjectableType$$Factory.create().get();",
         "  }",
         "",
         "  public static final class Builder {",
@@ -1369,7 +1412,7 @@
         "    }",
         "  }",
         "}");
-    assert_().about(javaSources()).that(ImmutableList.of(
+    assertAbout(javaSources()).that(ImmutableList.of(
             injectableTypeFile, componentSupertypeAFile, componentSupertypeBFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -1445,7 +1488,7 @@
         "",
         "  @Override",
         "  public SomeInjectableType someInjectableType() {",
-        "    return SomeInjectableType$$Factory.INSTANCE.get();",
+        "    return SomeInjectableType$$Factory.create().get();",
         "  }",
         "",
         "  public static final class Builder {",
@@ -1457,10 +1500,238 @@
         "    }",
         "  }",
         "}");
-    assert_().about(javaSources()).that(ImmutableList.of(
+    assertAbout(javaSources()).that(ImmutableList.of(
             injectableTypeFile, componentSupertype, depComponentFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
   }
+  
+  @Test public void wildcardGenericsRequiresAtProvides() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject A() {}",
+        "}");
+    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "final class B<T> {",
+        "  @Inject B(T t) {}",
+        "}");
+    JavaFileObject cFile = JavaFileObjects.forSourceLines("test.C",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "final class C {",
+        "  @Inject C(B<? extends A> bA) {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SimpleComponent {",
+        "  C c();",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(aFile, bFile, cFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "test.B<? extends test.A> cannot be provided without an @Provides-annotated method");
+  }
+  
+  @Test public void arrayGenericsRequiresAtProvides() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject A() {}",
+        "}");
+    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "final class B<T> {",
+        "  @Inject B(T t) {}",
+        "}");
+    JavaFileObject cFile = JavaFileObjects.forSourceLines("test.C",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "final class C {",
+        "  @Inject C(B<Object[]> b) {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SimpleComponent {",
+        "  C c();",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(aFile, bFile, cFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("test.B<java.lang.Object[]> cannot be provided without"
+            + " an @Provides-annotated method");
+  }
+  
+  @Test public void rawTypeGenericsRequiresAtProvides() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject A() {}",
+        "}");
+    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "final class B<T> {",
+        "  @Inject B(T t) {}",
+        "}");
+    JavaFileObject cFile = JavaFileObjects.forSourceLines("test.C",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "final class C {",
+        "  @Inject C(B b) {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SimpleComponent {",
+        "  C c();",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(aFile, bFile, cFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("test.B cannot be provided without an @Provides-annotated method");
+  }
+ 
+  @Test
+  @Ignore // modify this test as necessary while debugging for your situation.
+  public void genericTestToLetMeDebugInEclipse() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+         "import javax.inject.Inject;",
+         "",
+         "public final class A {",
+         "  @Inject A() {}",
+         "}");
+     JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
+         "package test;",
+         "",
+         "import javax.inject.Inject;",
+         "import javax.inject.Provider;",
+         "",
+         "public class B<T> {",
+         "  @Inject B() {}",
+         "}");
+     JavaFileObject dFile = JavaFileObjects.forSourceLines("test.sub.D",
+         "package test.sub;",
+         "",
+         "import javax.inject.Inject;",
+         "import javax.inject.Provider;",
+         "import test.B;",
+         "",
+         "public class D {",
+         "  @Inject D(B<A.InA> ba) {}",
+         "}");
+     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+         "package test;",
+         "",
+         "import dagger.Component;",
+         "import dagger.Lazy;",
+         "",
+         "import javax.inject.Provider;",
+         "",
+         "@Component",
+         "interface SimpleComponent {",
+         "  B<A> d();",
+         "  Provider<B<A>> d2();",
+         "}");
+     JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+         "test.Dagger_SimpleComponent",
+         "package test;",
+         "",
+         "import javax.annotation.Generated;",
+         "import javax.inject.Provider;",
+         "",
+         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+         "public final class Dagger_SimpleComponent implements SimpleComponent {",
+         "  private Provider<D> dProvider;",
+         "",
+         "  private Dagger_SimpleComponent(Builder builder) {",
+         "    assert builder != null;",
+         "    initialize();",
+         "  }",
+         "",
+         "  public static Builder builder() {",
+         "    return new Builder();",
+         "  }",
+         "",
+         "  public static SimpleComponent create() {",
+         "    return builder().build();",
+         "  }",
+         "",
+         "  private void initialize() {",
+         "    this.dProvider = new D$$Factory(B$$Factory.INSTANCE);",
+         "  }",
+         "",
+         "  @Override",
+         "  public D d() {",
+         "    return dProvider.get();",
+         "  }",
+         "",
+         "  public static final class Builder {",
+         "    private Builder() {",
+         "    }",
+         "",
+         "    public SimpleComponent build() {",
+         "      return new Dagger_SimpleComponent(this);",
+         "    }",
+         "  }",
+         "}");
+     assertAbout(javaSources()).that(ImmutableList.of(aFile, bFile, componentFile))
+         .processedWith(new ComponentProcessor())
+         .compilesWithoutError()
+         .and().generatesSources(generatedComponent);
+   }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java b/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java
new file mode 100644
index 000000000..0232d1c38
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java
@@ -0,0 +1,145 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.Iterables;
+import com.google.testing.compile.CompilationRule;
+import dagger.Lazy;
+import dagger.MembersInjector;
+import dagger.Module;
+import dagger.Provides;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import java.util.List;
+import javax.inject.Provider;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+/**
+ * Test case for {@link DependencyRequestMapper}.
+ */
+@RunWith(JUnit4.class)
+public class DependencyRequestMapperTest {
+  @Rule public CompilationRule compilationRule = new CompilationRule();
+
+  private Elements elements;
+  private Types types;
+  private Key.Factory keyFactory;
+  private DependencyRequest.Factory dependencyRequestFactory;
+
+  @Before public void setUp() {
+    this.types = compilationRule.getTypes();
+    this.elements = compilationRule.getElements();
+    this.keyFactory = new Key.Factory(types, elements);
+    this.dependencyRequestFactory = new DependencyRequest.Factory(keyFactory);
+  }
+
+  private List<? extends VariableElement> sampleProviderParameters() {
+    TypeElement moduleElement =
+        elements.getTypeElement(ProvidesMethodModule.class.getCanonicalName());
+    ExecutableElement providesMethod =
+        Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
+    return providesMethod.getParameters();
+  }
+
+  private List<? extends VariableElement> sampleProducerParameters() {
+    TypeElement moduleElement =
+        elements.getTypeElement(ProducesMethodModule.class.getCanonicalName());
+    ExecutableElement producesMethod =
+        Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
+    return producesMethod.getParameters();
+  }
+
+  private DependencyRequest dependencyRequestForInstance() {
+    return dependencyRequestFactory.forRequiredVariable(sampleProviderParameters().get(0));
+  }
+
+  private DependencyRequest dependencyRequestForLazy() {
+    return dependencyRequestFactory.forRequiredVariable(sampleProviderParameters().get(1));
+  }
+
+  private DependencyRequest dependencyRequestForProvider() {
+    return dependencyRequestFactory.forRequiredVariable(sampleProviderParameters().get(2));
+  }
+
+  private DependencyRequest dependencyRequestForMembersInjector() {
+    return dependencyRequestFactory.forRequiredVariable(sampleProviderParameters().get(3));
+  }
+
+  private DependencyRequest dependencyRequestForProducer() {
+    return dependencyRequestFactory.forRequiredVariable(sampleProducerParameters().get(0));
+  }
+
+  private DependencyRequest dependencyRequestForProduced() {
+    return dependencyRequestFactory.forRequiredVariable(sampleProducerParameters().get(1));
+  }
+
+  @Test public void forProvider() {
+    DependencyRequestMapper mapper = DependencyRequestMapper.FOR_PROVIDER;
+    assertThat(mapper.getFrameworkClass(dependencyRequestForInstance()))
+        .isEqualTo(Provider.class);
+    assertThat(mapper.getFrameworkClass(dependencyRequestForLazy()))
+        .isEqualTo(Provider.class);
+    assertThat(mapper.getFrameworkClass(dependencyRequestForProvider()))
+        .isEqualTo(Provider.class);
+    assertThat(mapper.getFrameworkClass(dependencyRequestForMembersInjector()))
+        .isEqualTo(MembersInjector.class);
+  }
+
+  @Test public void forProducer() {
+    DependencyRequestMapper mapper = DependencyRequestMapper.FOR_PRODUCER;
+    assertThat(mapper.getFrameworkClass(dependencyRequestForInstance()))
+        .isEqualTo(Producer.class);
+    assertThat(mapper.getFrameworkClass(dependencyRequestForLazy()))
+        .isEqualTo(Provider.class);
+    assertThat(mapper.getFrameworkClass(dependencyRequestForProvider()))
+        .isEqualTo(Provider.class);
+    assertThat(mapper.getFrameworkClass(dependencyRequestForMembersInjector()))
+        .isEqualTo(MembersInjector.class);
+    assertThat(mapper.getFrameworkClass(dependencyRequestForProducer()))
+        .isEqualTo(Producer.class);
+    assertThat(mapper.getFrameworkClass(dependencyRequestForProduced()))
+        .isEqualTo(Producer.class);
+  }
+
+  @Module(library = true)
+  static final class ProvidesMethodModule {
+    @Provides String provideString(
+        Integer a, Lazy<Integer> b, Provider<Integer> c, MembersInjector<Integer> d) {
+      return null;
+    }
+  }
+
+  @ProducerModule
+  static final class ProducesMethodModule {
+    @Produces String produceString(Producer<Integer> a, Produced<Integer> b) {
+      return null;
+    }
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ElementUtilTest.java b/compiler/src/test/java/dagger/internal/codegen/ElementUtilTest.java
deleted file mode 100644
index 2f638f21c..000000000
--- a/compiler/src/test/java/dagger/internal/codegen/ElementUtilTest.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.auto.common.MoreElements;
-import com.google.testing.compile.CompilationRule;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.util.ElementFilter;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static com.google.common.truth.Truth.assert_;
-import static org.junit.Assert.fail;
-
-@RunWith(JUnit4.class)
-public class ElementUtilTest {
-  @Rule public CompilationRule compilation = new CompilationRule();
-
-  @Test public void asTypeElement() {
-    Element typeElement =
-        compilation.getElements().getTypeElement(String.class.getCanonicalName());
-    assert_().that(MoreElements.asType(typeElement)).isEqualTo(typeElement);
-  }
-
-  @Test public void asTypeElement_notATypeElement() {
-    TypeElement typeElement =
-        compilation.getElements().getTypeElement(String.class.getCanonicalName());
-    for (ExecutableElement e : ElementFilter.methodsIn(typeElement.getEnclosedElements())) {
-      try {
-        MoreElements.asType(e);
-        fail();
-      } catch (IllegalArgumentException expected) {
-      }
-    }
-  }
-}
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java
new file mode 100644
index 000000000..da0c2b06c
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java
@@ -0,0 +1,347 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assert_;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static java.util.Arrays.asList;
+
+@RunWith(JUnit4.class)
+public class GraphValidationScopingTest {
+  @Test public void componentWithoutScopeIncludesScopedBindings_Fail() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.MyComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Component(modules = ScopedModule.class)",
+        "interface MyComponent {",
+        "  ScopedType string();",
+        "}");
+    JavaFileObject typeFile = JavaFileObjects.forSourceLines("test.ScopedType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Singleton",
+        "class ScopedType {",
+        "  @Inject ScopedType(String s, long l, float f) {}",
+        "}");
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.ScopedModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Module",
+        "class ScopedModule {",
+        "  @Provides @Singleton String string() { return \"a string\"; }",
+        "  @Provides long integer() { return 0L; }",
+        "  @Provides float floatingPoint() { return 0.0f; }",
+        "}");
+    String errorMessage = "test.MyComponent (unscoped) may not reference scoped bindings:\n"
+        + "      @Provides @Singleton String test.ScopedModule.string()\n"
+        + "      @Singleton class test.ScopedType";
+    assert_().about(javaSources()).that(asList(componentFile, typeFile, moduleFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(errorMessage);
+  }
+
+  @Test public void componentWithScopeIncludesIncompatiblyScopedBindings_Fail() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.MyComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Singleton",
+        "@Component(modules = ScopedModule.class)",
+        "interface MyComponent {",
+        "  ScopedType string();",
+        "}");
+    JavaFileObject scopeFile = JavaFileObjects.forSourceLines("test.PerTest",
+        "package test;",
+        "",
+        "import javax.inject.Scope;",
+        "",
+        "@Scope",
+        "@interface PerTest {}");
+    JavaFileObject typeFile = JavaFileObjects.forSourceLines("test.ScopedType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "@PerTest", // incompatible scope
+        "class ScopedType {",
+        "  @Inject ScopedType(String s, long l, float f) {}",
+        "}");
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.ScopedModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Module",
+        "class ScopedModule {",
+        "  @Provides @PerTest String string() { return \"a string\"; }", // incompatible scope
+        "  @Provides long integer() { return 0L; }", // unscoped - valid
+        "  @Provides @Singleton float floatingPoint() { return 0.0f; }", // same scope - valid
+        "}");
+    String errorMessage = "test.MyComponent scoped with @Singleton "
+        + "may not reference bindings with different scopes:\n"
+        + "      @Provides @test.PerTest String test.ScopedModule.string()\n"
+        + "      @test.PerTest class test.ScopedType";
+    assert_().about(javaSources()).that(asList(componentFile, scopeFile, typeFile, moduleFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(errorMessage);
+  }
+
+  @Test public void componentWithScopeMayDependOnOnlyOneScopedComponent() {
+    // If a scoped component will have dependencies, they must only include, at most, a single
+    // scoped component
+    JavaFileObject type = JavaFileObjects.forSourceLines("test.SimpleType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class SimpleType {",
+        "  static class A { @Inject A() {} }",
+        "  static class B { @Inject B() {} }",
+        "}");
+    JavaFileObject simpleScope = JavaFileObjects.forSourceLines("test.SimpleScope",
+        "package test;",
+        "",
+        "import javax.inject.Scope;",
+        "",
+        "@Scope @interface SimpleScope {}");
+    JavaFileObject singletonScopedA = JavaFileObjects.forSourceLines("test.SingletonComponentA",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Singleton",
+        "@Component",
+        "interface SingletonComponentA {",
+        "  SimpleType.A type();",
+        "}");
+    JavaFileObject singletonScopedB = JavaFileObjects.forSourceLines("test.SingletonComponentB",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Singleton",
+        "@Component",
+        "interface SingletonComponentB {",
+        "  SimpleType.B type();",
+        "}");
+    JavaFileObject scopeless = JavaFileObjects.forSourceLines("test.ScopelessComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface ScopelessComponent {",
+        "  SimpleType type();",
+        "}");
+    JavaFileObject simpleScoped = JavaFileObjects.forSourceLines("test.SimpleScopedComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@SimpleScope",
+        "@Component(dependencies = {SingletonComponentA.class, SingletonComponentB.class})",
+        "interface SimpleScopedComponent {",
+        "  SimpleType.A type();",
+        "}");
+    String errorMessage =
+        "@test.SimpleScope test.SimpleScopedComponent depends on more than one scoped component:\n"
+        + "      @Singleton test.SingletonComponentA\n"
+        + "      @Singleton test.SingletonComponentB";
+    assert_().about(javaSources())
+        .that(
+            asList(type, simpleScope, simpleScoped, singletonScopedA, singletonScopedB, scopeless))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(errorMessage);
+  }
+
+  @Test public void componentWithoutScopeCannotDependOnScopedComponent() {
+    JavaFileObject type = JavaFileObjects.forSourceLines("test.SimpleType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class SimpleType {",
+        "  @Inject SimpleType() {}",
+        "}");
+    JavaFileObject scopedComponent = JavaFileObjects.forSourceLines("test.ScopedComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Singleton",
+        "@Component",
+        "interface ScopedComponent {",
+        "  SimpleType type();",
+        "}");
+    JavaFileObject unscopedComponent = JavaFileObjects.forSourceLines("test.UnscopedComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Component(dependencies = ScopedComponent.class)",
+        "interface UnscopedComponent {",
+        "  SimpleType type();",
+        "}");
+    String errorMessage =
+        "test.UnscopedComponent (unscoped) cannot depend on scoped components:\n"
+        + "      @Singleton test.ScopedComponent";
+    assert_().about(javaSources())
+        .that(asList(type, scopedComponent, unscopedComponent))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(errorMessage);
+  }
+
+  @Test public void componentWithSingletonScopeMayNotDependOnOtherScope() {
+    // Singleton must be the widest lifetime of present scopes.
+    JavaFileObject type = JavaFileObjects.forSourceLines("test.SimpleType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class SimpleType {",
+        "  @Inject SimpleType() {}",
+        "}");
+    JavaFileObject simpleScope = JavaFileObjects.forSourceLines("test.SimpleScope",
+        "package test;",
+        "",
+        "import javax.inject.Scope;",
+        "",
+        "@Scope @interface SimpleScope {}");
+    JavaFileObject simpleScoped = JavaFileObjects.forSourceLines("test.SimpleScopedComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@SimpleScope",
+        "@Component",
+        "interface SimpleScopedComponent {",
+        "  SimpleType type();",
+        "}");
+    JavaFileObject singletonScoped = JavaFileObjects.forSourceLines("test.SingletonComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Singleton",
+        "@Component(dependencies = SimpleScopedComponent.class)",
+        "interface SingletonComponent {",
+        "  SimpleType type();",
+        "}");
+    String errorMessage =
+        "This @Singleton component cannot depend on scoped components:\n"
+        + "      @test.SimpleScope test.SimpleScopedComponent";
+    assert_().about(javaSources())
+        .that(asList(type, simpleScope, simpleScoped, singletonScoped))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(errorMessage);
+  }
+
+  @Test public void componentScopeAncestryMustNotCycle() {
+    // The dependency relationship of components is necessarily from shorter lifetimes to
+    // longer lifetimes.  The scoping annotations must reflect this, and so one cannot declare
+    // scopes on components such that they cycle.
+    JavaFileObject type = JavaFileObjects.forSourceLines("test.SimpleType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class SimpleType {",
+        "  @Inject SimpleType() {}",
+        "}");
+    JavaFileObject scopeA = JavaFileObjects.forSourceLines("test.ScopeA",
+        "package test;",
+        "",
+        "import javax.inject.Scope;",
+        "",
+        "@Scope @interface ScopeA {}");
+    JavaFileObject scopeB = JavaFileObjects.forSourceLines("test.ScopeB",
+        "package test;",
+        "",
+        "import javax.inject.Scope;",
+        "",
+        "@Scope @interface ScopeB {}");
+    JavaFileObject longLifetime = JavaFileObjects.forSourceLines("test.ComponentLong",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@ScopeA",
+        "@Component",
+        "interface ComponentLong {",
+        "  SimpleType type();",
+        "}");
+    JavaFileObject mediumLifetime = JavaFileObjects.forSourceLines("test.ComponentMedium",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@ScopeB",
+        "@Component(dependencies = ComponentLong.class)",
+        "interface ComponentMedium {",
+        "  SimpleType type();",
+        "}");
+    JavaFileObject shortLifetime = JavaFileObjects.forSourceLines("test.ComponentShort",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@ScopeA",
+        "@Component(dependencies = ComponentMedium.class)",
+        "interface ComponentShort {",
+        "  SimpleType type();",
+        "}");
+    String errorMessage =
+        "test.ComponentShort depends on scoped components in a non-hierarchical scope ordering:\n"
+        + "      @test.ScopeA test.ComponentLong\n"
+        + "      @test.ScopeB test.ComponentMedium\n"
+        + "      @test.ScopeA test.ComponentShort";
+    assert_().about(javaSources())
+        .that(asList(type, scopeA, scopeB, longLifetime, mediumLifetime, shortLifetime))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(errorMessage);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index ee3507709..68b684588 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -22,10 +22,9 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assert_;
+import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static java.util.Arrays.asList;
 
 @RunWith(JUnit4.class)
 public class GraphValidationTest {
@@ -53,7 +52,7 @@
         "import javax.inject.Inject;",
         "",
         "interface Bar {}");
-    assert_().about(javaSources()).that(Arrays.asList(component, injectable, nonInjectable))
+    assertAbout(javaSources()).that(Arrays.asList(component, injectable, nonInjectable))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining("test.Bar cannot be provided without an @Provides-annotated method.")
@@ -76,7 +75,7 @@
         "}");
     String expectedError =
         "test.TestClass.A cannot be provided without an @Provides-annotated method.";
-    assert_().about(javaSource()).that(component)
+    assertAbout(javaSource()).that(component)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(expectedError).in(component).onLine(10);
@@ -103,7 +102,7 @@
         "}");
     String expectedError = "test.TestClass.A cannot be provided without an "
         + "@Inject constructor or from an @Provides-annotated method.";
-    assert_().about(javaSource()).that(component)
+    assertAbout(javaSource()).that(component)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(expectedError).in(component).onLine(15);
@@ -135,7 +134,7 @@
     String expectedError = "test.TestClass.B cannot be provided without an "
         + "@Inject constructor or from an @Provides-annotated method. "
         + "This type supports members injection but cannot be implicitly provided.";
-    assert_().about(javaSource()).that(component)
+    assertAbout(javaSource()).that(component)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(expectedError).in(component).onLine(19);
@@ -177,12 +176,60 @@
         + "      test.Outer.A.<init>(test.Outer.C cParam)\n"
         + "          [parameter: test.Outer.C cParam]";
 
-    assert_().about(javaSource()).that(component)
+    assertAbout(javaSource()).that(component)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(expectedError).in(component).onLine(23);
   }
 
+  @Test public void cyclicDependencyNotIncludingEntryPoint() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "final class Outer {",
+        "  static class A {",
+        "    @Inject A(C cParam) {}",
+        "  }",
+        "",
+        "  static class B {",
+        "    @Inject B(A aParam) {}",
+        "  }",
+        "",
+        "  static class C {",
+        "    @Inject C(B bParam) {}",
+        "  }",
+
+        "  static class D {",
+        "    @Inject D(C cParam) {}",
+        "  }",
+        "",
+        "  @Component()",
+        "  interface DComponent {",
+        "    D getD();",
+        "  }",
+        "}");
+
+    String expectedError = "test.Outer.DComponent.getD() contains a dependency cycle:\n"
+        + "      test.Outer.D.<init>(test.Outer.C cParam)\n"
+        + "          [parameter: test.Outer.C cParam]\n"
+        + "      test.Outer.C.<init>(test.Outer.B bParam)\n"
+        + "          [parameter: test.Outer.B bParam]\n"
+        + "      test.Outer.B.<init>(test.Outer.A aParam)\n"
+        + "          [parameter: test.Outer.A aParam]\n"
+        + "      test.Outer.A.<init>(test.Outer.C cParam)\n"
+        + "          [parameter: test.Outer.C cParam]";
+
+    assertAbout(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError).in(component).onLine(26);
+  }
+
   @Test public void duplicateExplicitBindings_ProvidesAndComponentProvision() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
         "package test;",
@@ -222,7 +269,7 @@
         + "      test.Outer.A test.Outer.Parent.getA()\n"
         + "      @Provides test.Outer.A test.Outer.AModule.provideA(String)";
 
-    assert_().about(javaSource()).that(component)
+    assertAbout(javaSource()).that(component)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(expectedError).in(component).onLine(30);
@@ -261,7 +308,7 @@
         + "      @Provides test.Outer.A test.Outer.Module1.provideA1()\n"
         + "      @Provides test.Outer.A test.Outer.Module2.provideA2(String)";
 
-    assert_().about(javaSource()).that(component)
+    assertAbout(javaSource()).that(component)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(expectedError).in(component).onLine(24);
@@ -331,7 +378,7 @@
             + "      Unique bindings:\n"
             + "          @Provides Map<String,String> test.Outer.TestModule2.stringMap()";
 
-    assert_().about(javaSource()).that(component)
+    assertAbout(javaSource()).that(component)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(expectedSetError).in(component).onLine(43)
@@ -442,7 +489,7 @@
         + "      @Provides test.Outer.A test.Outer.Module10.provideA()\n"
         + "      and 2 others";
 
-    assert_().about(javaSource()).that(component)
+    assertAbout(javaSource()).that(component)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(expectedError).in(component).onLine(86);
@@ -502,104 +549,10 @@
         + "          [injected field of type: test.TestClass.B b]\n"
         + "      test.TestClass.B.<init>(test.TestClass.A a)\n"
         + "          [parameter: test.TestClass.A a]";
-    assert_().about(javaSource()).that(component)
+    assertAbout(javaSource()).that(component)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(firstError).in(component).onLine(33)
         .and().withErrorContaining(secondError).in(component).onLine(34);
   }
-
-  @Test public void componentWithoutScopeIncludesScopedBindings() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.MyComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Singleton;",
-        "",
-        "@Component(modules = ScopedModule.class)",
-        "interface MyComponent {",
-        "  ScopedType string();",
-        "}");
-    JavaFileObject typeFile = JavaFileObjects.forSourceLines("test.ScopedType",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "import javax.inject.Singleton;",
-        "",
-        "@Singleton",
-        "class ScopedType {",
-        "  @Inject ScopedType(String s, long l, float f) {}",
-        "}");
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.ScopedModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Singleton;",
-        "",
-        "@Module",
-        "class ScopedModule {",
-        "  @Provides @Singleton String string() { return \"a string\"; }",
-        "  @Provides long integer() { return 0L; }",
-        "  @Provides float floatingPoint() { return 0.0f; }",
-        "}");
-    String errorMessage = "test.MyComponent (unscoped) may not reference scoped bindings:\n"
-        + "      @Provides @Singleton String test.ScopedModule.string()\n"
-        + "      @Singleton class test.ScopedType";
-    assert_().about(javaSources()).that(asList(componentFile, typeFile, moduleFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(errorMessage);
-  }
-
-  @Test public void componentWithScopeIncludesIncompatiblyScopedBindings() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.MyComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Singleton;",
-        "",
-        "@Singleton",
-        "@Component(modules = ScopedModule.class)",
-        "interface MyComponent {",
-        "  ScopedType string();",
-        "}");
-    JavaFileObject scopeFile = JavaFileObjects.forSourceLines("test.PerTest",
-        "package test;",
-        "",
-        "import javax.inject.Scope;",
-        "",
-        "@Scope",
-        "@interface PerTest {}");
-    JavaFileObject typeFile = JavaFileObjects.forSourceLines("test.ScopedType",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "@PerTest", // incompatible scope
-        "class ScopedType {",
-        "  @Inject ScopedType(String s, long l, float f) {}",
-        "}");
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.ScopedModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Singleton;",
-        "",
-        "@Module",
-        "class ScopedModule {",
-        "  @Provides @PerTest String string() { return \"a string\"; }", // incompatible scope
-        "  @Provides long integer() { return 0L; }", // unscoped - valid
-        "  @Provides @Singleton float floatingPoint() { return 0.0f; }", // same scope - valid
-        "}");
-    String errorMessage = "test.MyComponent scoped with @Singleton "
-        + "may not reference bindings with different scopes:\n"
-        + "      @Provides @test.PerTest String test.ScopedModule.string()\n"
-        + "      @test.PerTest class test.ScopedType";
-    assert_().about(javaSources()).that(asList(componentFile, scopeFile, typeFile, moduleFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(errorMessage);
-  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
index 8d6d1eb20..0f3586746 100644
--- a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
@@ -22,14 +22,13 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assert_;
+import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.ErrorMessages.ABSTRACT_INJECT_METHOD;
 import static dagger.internal.codegen.ErrorMessages.FINAL_INJECT_FIELD;
 import static dagger.internal.codegen.ErrorMessages.GENERIC_INJECT_METHOD;
 import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS;
-import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_GENERIC_CLASS;
 import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_INNER_CLASS;
 import static dagger.internal.codegen.ErrorMessages.INJECT_ON_PRIVATE_CONSTRUCTOR;
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_INJECT_CONSTRUCTORS;
@@ -37,6 +36,7 @@
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_SCOPES;
 import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_FIELD;
 import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_METHOD;
+import static dagger.internal.codegen.ErrorMessages.QUALIFIER_ON_INJECT_CONSTRUCTOR;
 
 @RunWith(JUnit4.class)
 // TODO(gak): add tests for generation in the default package.
@@ -79,7 +79,7 @@
         "class PrivateConstructor {",
         "  @Inject private PrivateConstructor() {}",
         "}");
-    assert_().about(javaSource()).that(file)
+    assertAbout(javaSource()).that(file)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(INJECT_ON_PRIVATE_CONSTRUCTOR).in(file).onLine(6);
@@ -96,7 +96,7 @@
         "    @Inject InnerClass() {}",
         "  }",
         "}");
-    assert_().about(javaSource()).that(file)
+    assertAbout(javaSource()).that(file)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(INJECT_CONSTRUCTOR_ON_INNER_CLASS).in(file).onLine(7);
@@ -111,13 +111,100 @@
         "abstract class AbstractClass {",
         "  @Inject AbstractClass() {}",
         "}");
-    assert_().about(javaSource()).that(file)
+    assertAbout(javaSource()).that(file)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS).in(file).onLine(6);
   }
 
   @Test public void injectConstructorOnGenericClass() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.GenericClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class GenericClass<T> {",
+        "  @Inject GenericClass(T t) {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass$$Factory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class GenericClass$$Factory<T> implements Factory<GenericClass<T>> {",
+        "  private final Provider<T> tProvider;",
+        "",
+        "  public GenericClass$$Factory(Provider<T> tProvider) {",
+        "    assert tProvider != null;",
+        "    this.tProvider = tProvider;",
+        "  }",
+        "",
+        "  @Override",
+        "  public GenericClass<T> get() {",
+        "    return new GenericClass<T>(tProvider.get());",
+        "  }",
+        "",
+        "  public static <T> Factory<GenericClass<T>> create(Provider<T> tProvider) {",
+        "    return new GenericClass$$Factory<T>(tProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(file)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test public void fieldAndMethodGenerics() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.GenericClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class GenericClass<A, B> {",
+        "  @Inject A a;",
+        "",
+        "  @Inject GenericClass() {}",
+        "",
+        " @Inject void register(B b) {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass$$Factory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class GenericClass$$Factory<A, B> implements Factory<GenericClass<A, B>> {",
+        "  private final MembersInjector<GenericClass<A, B>> membersInjector;",
+        "",
+        "  public GenericClass$$Factory(MembersInjector<GenericClass<A, B>> membersInjector) {",
+        "    assert membersInjector != null;",
+        "    this.membersInjector = membersInjector;",
+        "  }",
+        "",
+        "  @Override",
+        "  public GenericClass<A, B> get() {",
+        "    GenericClass<A, B> instance = new GenericClass<A, B>();",
+        "    membersInjector.injectMembers(instance);",
+        "    return instance;",
+        "  }",
+        "",
+        "  public static <A, B> Factory<GenericClass<A, B>> create(",
+        "      MembersInjector<GenericClass<A, B>> membersInjector) {",
+        "    return new GenericClass$$Factory<A, B>(membersInjector);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(file)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test public void genericClassWithNoDependencies() {
     JavaFileObject file = JavaFileObjects.forSourceLines("test.GenericClass",
         "package test;",
         "",
@@ -126,10 +213,227 @@
         "class GenericClass<T> {",
         "  @Inject GenericClass() {}",
         "}");
-    assert_().about(javaSource()).that(file)
+    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass$$Factory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import javax.annotation.Generated;",
+        "",
+        "@SuppressWarnings(\"rawtypes\")",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public enum GenericClass$$Factory implements Factory<GenericClass> {",
+        "  INSTANCE;",
+        "",
+        "  @Override",
+        "  public GenericClass get() {",
+        "    return new GenericClass();",
+        "  }",
+        "",
+        "  @SuppressWarnings(\"unchecked\")",
+        "  public static <T> Factory<GenericClass<T>> create() {",
+        "    return (Factory) INSTANCE;",
+        "  }",
+        "",
+        "}");
+    assertAbout(javaSource()).that(file)
         .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(INJECT_CONSTRUCTOR_ON_GENERIC_CLASS).in(file).onLine(6);
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test public void twoGenericTypes() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.GenericClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class GenericClass<A, B> {",
+        "  @Inject GenericClass(A a, B b) {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass$$Factory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class GenericClass$$Factory<A, B> implements Factory<GenericClass<A, B>> {",
+        "  private final Provider<A> aProvider;",
+        "  private final Provider<B> bProvider;",
+        "",
+        "  public GenericClass$$Factory(Provider<A> aProvider, Provider<B> bProvider) {",
+        "    assert aProvider != null;",
+        "    this.aProvider = aProvider;",
+        "    assert bProvider != null;",
+        "    this.bProvider = bProvider;",
+        "  }",
+        "",
+        "  @Override",
+        "  public GenericClass<A, B> get() {",
+        "    return new GenericClass<A, B>(aProvider.get(), bProvider.get());",
+        "  }",
+        "",
+        "  public static <A, B> Factory<GenericClass<A, B>> create(",
+        "      Provider<A> aProvider, Provider<B> bProvider) {",
+        "    return new GenericClass$$Factory<A, B>(aProvider, bProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(file)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+  
+  @Test public void boundedGenerics() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.GenericClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import java.util.List;",
+        "",
+        "class GenericClass<A extends Number & Comparable<A>,",
+        "    B extends List<? extends String>,",
+        "    C extends List<? super String>> {",
+        "  @Inject GenericClass(A a, B b, C c) {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass$$Factory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import java.util.List;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class GenericClass$$Factory<A extends Number & Comparable<A>,",
+        "        B extends List<? extends String>,",
+        "        C extends List<? super String>>",
+        "    implements Factory<GenericClass<A, B, C>> {",
+        "  private final Provider<A> aProvider;",
+        "  private final Provider<B> bProvider;",
+        "  private final Provider<C> cProvider;",
+        "",
+        "  public GenericClass$$Factory(Provider<A> aProvider,",
+        "      Provider<B> bProvider,",
+        "      Provider<C> cProvider) {",
+        "    assert aProvider != null;",
+        "    this.aProvider = aProvider;",
+        "    assert bProvider != null;",
+        "    this.bProvider = bProvider;",
+        "    assert cProvider != null;",
+        "    this.cProvider = cProvider;",
+        "  }",
+        "",
+        "  @Override",
+        "  public GenericClass<A, B, C> get() {",
+        "    return new GenericClass<A, B, C>(aProvider.get(), bProvider.get(), cProvider.get());",
+        "  }",
+        "",
+        "  public static <A extends Number & Comparable<A>,",
+        "      B extends List<? extends String>,",
+        "      C extends List<? super String>> Factory<GenericClass<A, B, C>> create(",
+        "          Provider<A> aProvider, Provider<B> bProvider, Provider<C> cProvider) {",
+        "    return new GenericClass$$Factory<A, B, C>(aProvider, bProvider, cProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(file)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test public void multipleSameTypesWithGenericsAndQualifiersAndLazies() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.GenericClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "import dagger.Lazy;",
+        "",
+        "class GenericClass<A, B> {",
+        "  @Inject GenericClass(A a, A a2, Provider<A> pa, @QualifierA A qa, Lazy<A> la, ",
+        "                       String s, String s2, Provider<String> ps, ",
+        "                       @QualifierA String qs, Lazy<String> ls,",
+        "                       B b, B b2, Provider<B> pb, @QualifierA B qb, Lazy<B> lb) {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass$$Factory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import dagger.internal.DoubleCheckLazy;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class GenericClass$$Factory<A, B> implements Factory<GenericClass<A, B>> {",
+        "  private final Provider<A> aAndA2AndPaAndLaProvider;",
+        "  private final Provider<A> qaProvider;",
+        "  private final Provider<String> sAndS2AndPsAndLsProvider;",
+        "  private final Provider<String> qsProvider;",
+        "  private final Provider<B> bAndB2AndPbAndLbProvider;",
+        "  private final Provider<B> qbProvider;",
+        "",
+        "  public GenericClass$$Factory(Provider<A> aAndA2AndPaAndLaProvider,",
+        "      Provider<A> qaProvider,", 
+        "      Provider<String> sAndS2AndPsAndLsProvider,",
+        "      Provider<String> qsProvider,",
+        "      Provider<B> bAndB2AndPbAndLbProvider,",
+        "      Provider<B> qbProvider) {",
+        "    assert aAndA2AndPaAndLaProvider != null;",
+        "    this.aAndA2AndPaAndLaProvider = aAndA2AndPaAndLaProvider;",
+        "    assert qaProvider != null;",
+        "    this.qaProvider = qaProvider;",
+        "    assert sAndS2AndPsAndLsProvider != null;",
+        "    this.sAndS2AndPsAndLsProvider = sAndS2AndPsAndLsProvider;",
+        "    assert qsProvider != null;",
+        "    this.qsProvider = qsProvider;",
+        "    assert bAndB2AndPbAndLbProvider != null;",
+        "    this.bAndB2AndPbAndLbProvider = bAndB2AndPbAndLbProvider;",
+        "    assert qbProvider != null;",
+        "    this.qbProvider = qbProvider;",
+        "  }",
+        "",
+        "  @Override",
+        "  public GenericClass<A, B> get() {",
+        "    return new GenericClass<A, B>(",
+        "      aAndA2AndPaAndLaProvider.get(),",
+        "      aAndA2AndPaAndLaProvider.get(),",
+        "      aAndA2AndPaAndLaProvider,",
+        "      qaProvider.get(),",
+        "      DoubleCheckLazy.create(aAndA2AndPaAndLaProvider),",
+        "      sAndS2AndPsAndLsProvider.get(),",
+        "      sAndS2AndPsAndLsProvider.get(),",
+        "      sAndS2AndPsAndLsProvider,",
+        "      qsProvider.get(),",
+        "      DoubleCheckLazy.create(sAndS2AndPsAndLsProvider),",
+        "      bAndB2AndPbAndLbProvider.get(),",
+        "      bAndB2AndPbAndLbProvider.get(),", 
+        "      bAndB2AndPbAndLbProvider,",
+        "      qbProvider.get(),",
+        "      DoubleCheckLazy.create(bAndB2AndPbAndLbProvider));",
+        "  }",
+        "",
+        "  public static <A, B> Factory<GenericClass<A, B>> create(",
+        "      Provider<A> aAndA2AndPaAndLaProvider,",
+        "      Provider<A> qaProvider,", 
+        "      Provider<String> sAndS2AndPsAndLsProvider,",
+        "      Provider<String> qsProvider,",
+        "      Provider<B> bAndB2AndPbAndLbProvider,",
+        "      Provider<B> qbProvider) {",
+        "    return new GenericClass$$Factory<A, B>(",
+        "        aAndA2AndPaAndLaProvider,",
+        "        qaProvider,",
+        "        sAndS2AndPsAndLsProvider,",
+        "        qsProvider,",
+        "        bAndB2AndPbAndLbProvider,",
+        "        qbProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(file, QUALIFIER_A))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
   }
 
   @Test public void multipleInjectConstructors() {
@@ -143,7 +447,7 @@
         "  TooManyInjectConstructors(int i) {}",
         "  @Inject TooManyInjectConstructors(String s) {}",
         "}");
-    assert_().about(javaSource()).that(file)
+    assertAbout(javaSource()).that(file)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(MULTIPLE_INJECT_CONSTRUCTORS).in(file).onLine(6)
@@ -159,7 +463,7 @@
         "class MultipleQualifierConstructorParam {",
         "  @Inject MultipleQualifierConstructorParam(@QualifierA @QualifierB String s) {}",
         "}");
-    assert_().about(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))
+    assertAbout(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))
         .processedWith(new ComponentProcessor()).failsToCompile()
         // for whatever reason, javac only reports the error once on the constructor
         .withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6);
@@ -174,12 +478,30 @@
         "@ScopeA @ScopeB class MultipleScopeClass {",
         "  @Inject MultipleScopeClass() {}",
         "}");
-    assert_().about(javaSources()).that(ImmutableList.of(file, SCOPE_A, SCOPE_B))
+    assertAbout(javaSources()).that(ImmutableList.of(file, SCOPE_A, SCOPE_B))
         .processedWith(new ComponentProcessor()).failsToCompile()
         .withErrorContaining(MULTIPLE_SCOPES).in(file).onLine(5).atColumn(1)
         .and().withErrorContaining(MULTIPLE_SCOPES).in(file).onLine(5).atColumn(9);
   }
 
+  @Test public void injectConstructorWithQualifier() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.MultipleScopeClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class MultipleScopeClass {",
+        "  @Inject",
+        "  @QualifierA",
+        "  @QualifierB",
+        "  MultipleScopeClass() {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))
+        .processedWith(new ComponentProcessor()).failsToCompile()
+        .withErrorContaining(QUALIFIER_ON_INJECT_CONSTRUCTOR).in(file).onLine(7)
+        .and().withErrorContaining(QUALIFIER_ON_INJECT_CONSTRUCTOR).in(file).onLine(8);
+  }
+
   @Test public void finalInjectField() {
     JavaFileObject file = JavaFileObjects.forSourceLines("test.FinalInjectField",
         "package test;",
@@ -189,7 +511,7 @@
         "class FinalInjectField {",
         "  @Inject final String s;",
         "}");
-    assert_().about(javaSource()).that(file)
+    assertAbout(javaSource()).that(file)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(FINAL_INJECT_FIELD).in(file).onLine(6);
@@ -204,7 +526,7 @@
         "class PrivateInjectField {",
         "  @Inject private String s;",
         "}");
-    assert_().about(javaSource()).that(file)
+    assertAbout(javaSource()).that(file)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(PRIVATE_INJECT_FIELD).in(file).onLine(6);
@@ -219,7 +541,7 @@
         "class MultipleQualifierInjectField {",
         "  @Inject @QualifierA @QualifierB String s;",
         "}");
-    assert_().about(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))
+    assertAbout(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))
         .processedWith(new ComponentProcessor()).failsToCompile()
         .withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6).atColumn(11)
         .and().withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6).atColumn(23);
@@ -234,7 +556,7 @@
         "abstract class AbstractInjectMethod {",
         "  @Inject abstract void method();",
         "}");
-    assert_().about(javaSource()).that(file)
+    assertAbout(javaSource()).that(file)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(ABSTRACT_INJECT_METHOD).in(file).onLine(6);
@@ -249,7 +571,7 @@
         "class PrivateInjectMethod {",
         "  @Inject private void method();",
         "}");
-    assert_().about(javaSource()).that(file)
+    assertAbout(javaSource()).that(file)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(PRIVATE_INJECT_METHOD).in(file).onLine(6);
@@ -264,7 +586,7 @@
         "class AbstractInjectMethod {",
         "  @Inject <T> void method();",
         "}");
-    assert_().about(javaSource()).that(file)
+    assertAbout(javaSource()).that(file)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(GENERIC_INJECT_METHOD).in(file).onLine(6);
@@ -279,160 +601,13 @@
         "class MultipleQualifierMethodParam {",
         "  @Inject void method(@QualifierA @QualifierB String s) {}",
         "}");
-    assert_().about(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))
+    assertAbout(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         // for whatever reason, javac only reports the error once on the method
         .withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6);
   }
 
-  @Test public void fieldInjection() {
-    JavaFileObject file = JavaFileObjects.forSourceLines("test.FieldInjection",
-        "package test;",
-        "",
-        "import dagger.Lazy;",
-        "import javax.inject.Inject;",
-        "import javax.inject.Provider;",
-        "",
-        "class FieldInjection {",
-        "  @Inject String string;",
-        "  @Inject Lazy<String> lazyString;",
-        "  @Inject Provider<String> stringProvider;",
-        "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines("test.FieldInjection$$MembersInjector",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import dagger.internal.DoubleCheckLazy;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class FieldInjection$$MembersInjector ",
-        "    implements MembersInjector<FieldInjection> {",
-        "",
-        "  private final Provider<String> stringProvider;",
-        "",
-        "  public FieldInjection$$MembersInjector(Provider<String> stringProvider) {",
-        "    assert stringProvider != null;",
-        "    this.stringProvider = stringProvider;",
-        "  }",
-        "",
-        "  @Override public void injectMembers(FieldInjection instance) {",
-        "    if (instance == null) {",
-        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
-        "    }",
-        "    instance.string = stringProvider.get();",
-        "    instance.lazyString = DoubleCheckLazy.create(stringProvider);",
-        "    instance.stringProvider = stringProvider;",
-        "  }",
-        "}");
-    assert_().about(javaSource()).that(file).processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(expected);
-  }
-
-  @Test public void methodInjection() {
-    JavaFileObject file = JavaFileObjects.forSourceLines("test.MethodInjection",
-        "package test;",
-        "",
-        "import dagger.Lazy;",
-        "import javax.inject.Inject;",
-        "import javax.inject.Provider;",
-        "",
-        "class MethodInjection {",
-        "  @Inject void noArgs() {}",
-        "  @Inject void oneArg(String string) {}",
-        "  @Inject void manyArgs(",
-        "      String string, Lazy<String> lazyString, Provider<String> stringProvider) {}",
-        "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines(
-        "test.MethodInjection$$MembersInjector",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import dagger.internal.DoubleCheckLazy;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class MethodInjection$$MembersInjector ",
-        "    implements MembersInjector<MethodInjection> {",
-        "",
-        "  private final Provider<String> stringProvider;",
-        "",
-        "  public MethodInjection$$MembersInjector(Provider<String> stringProvider) {",
-        "    assert stringProvider != null;",
-        "    this.stringProvider = stringProvider;",
-        "  }",
-        "",
-        "  @Override public void injectMembers(MethodInjection instance) {",
-        "    if (instance == null) {",
-        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
-        "    }",
-        "    instance.noArgs();",
-        "    instance.oneArg(stringProvider.get());",
-        "    instance.manyArgs(stringProvider.get(), DoubleCheckLazy.create(stringProvider),",
-        "        stringProvider);",
-        "  }",
-        "}");
-    assert_().about(javaSource()).that(file).processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(expected);
-  }
-
-  @Test public void mixedMemberInjection() {
-    JavaFileObject file = JavaFileObjects.forSourceLines("test.MixedMemberInjection",
-        "package test;",
-        "",
-        "import dagger.Lazy;",
-        "import javax.inject.Inject;",
-        "import javax.inject.Provider;",
-        "",
-        "class MixedMemberInjection {",
-        "  @Inject String string;",
-        "  @Inject void setString(String s) {}",
-        "  @Inject Object object;",
-        "  @Inject void setObject(Object o) {}",
-        "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines(
-        "test.MixedMemberInjection$$MembersInjector",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class MixedMemberInjection$$MembersInjector ",
-        "    implements MembersInjector<MixedMemberInjection> {",
-        "",
-        "  private final Provider<String> stringAndSProvider;",
-        "  private final Provider<Object> objectAndOProvider;",
-        "",
-        "  public MixedMemberInjection$$MembersInjector(Provider<String> stringAndSProvider,",
-        "      Provider<Object> objectAndOProvider) {",
-        "    assert stringAndSProvider != null;",
-        "    this.stringAndSProvider = stringAndSProvider;",
-        "    assert objectAndOProvider != null;",
-        "    this.objectAndOProvider = objectAndOProvider;",
-        "  }",
-        "",
-        "  @Override public void injectMembers(MixedMemberInjection instance) {",
-        "    if (instance == null) {",
-        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
-        "    }",
-        "    instance.string = stringAndSProvider.get();",
-        "    instance.object = objectAndOProvider.get();",
-        "    instance.setString(stringAndSProvider.get());",
-        "    instance.setObject(objectAndOProvider.get());",
-        "  }",
-        "}");
-    assert_().about(javaSource()).that(file).processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(expected);
-  }
-
   @Test public void injectConstructor() {
     JavaFileObject file = JavaFileObjects.forSourceLines("test.InjectConstructor",
         "package test;",
@@ -464,8 +639,12 @@
         "  @Override public InjectConstructor get() {",
         "    return new InjectConstructor(sProvider.get());",
         "  }",
+        "",
+        "  public static Factory<InjectConstructor> create(Provider<String> sProvider) {",
+        "    return new InjectConstructor$$Factory(sProvider);",
+        "  }",
         "}");
-    assert_().about(javaSource()).that(file).processedWith(new ComponentProcessor())
+    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(expected);
   }
@@ -510,38 +689,17 @@
         "    membersInjector.injectMembers(instance);",
         "    return instance;",
         "  }",
-        "}");
-    JavaFileObject expectedMembersInjector = JavaFileObjects.forSourceLines(
-        "test.AllInjections$$MembersInjector",
-        "package test;",
         "",
-        "import dagger.MembersInjector;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class AllInjections$$MembersInjector ",
-        "    implements MembersInjector<AllInjections> {",
-        "",
-        "  private final Provider<String> sProvider;",
-        "",
-        "  public AllInjections$$MembersInjector(Provider<String> sProvider) {",
-        "    assert sProvider != null;",
-        "    this.sProvider = sProvider;",
-        "  }",
-        "",
-        "  @Override public void injectMembers(AllInjections instance) {",
-        "    if (instance == null) {",
-        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
-        "    }",
-        "    instance.s = sProvider.get();",
-        "    instance.s(sProvider.get());",
+        "  public static Factory<AllInjections> create(",
+        "      MembersInjector<AllInjections> membersInjector, ",
+        "      Provider<String> sProvider) {",
+        "    return new AllInjections$$Factory(membersInjector, sProvider);",
         "  }",
         "}");
-    assert_().about(javaSource()).that(file).processedWith(new ComponentProcessor())
+    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
-        .generatesSources(expectedFactory, expectedMembersInjector);
+        .generatesSources(expectedFactory);
   }
 
   @Test public void supertypeRequiresMemberInjection() {
@@ -580,61 +738,15 @@
         "    membersInjector.injectMembers(instance);",
         "    return instance;",
         "  }",
-        "}");
-    assert_().about(javaSources()).that(ImmutableList.of(aFile, bFile))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(expectedFactory);
-  }
-
-  @Test public void supertypeMembersInjection() {
-    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
-        "package test;",
         "",
-        "class A {}");
-    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "class B extends A {",
-        "  @Inject String s;",
-        "}");
-    JavaFileObject expectedMembersInjector = JavaFileObjects.forSourceLines(
-        "test.AllInjections$$MembersInjector",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class B$$MembersInjector ",
-        "    implements MembersInjector<B> {",
-        "",
-        "  private final MembersInjector<A> supertypeInjector;",
-        "  private final Provider<String> sProvider;",
-        "",
-        "  public B$$MembersInjector(MembersInjector<A> supertypeInjector,",
-        "      Provider<String> sProvider) {",
-        "    assert supertypeInjector != null;",
-        "    this.supertypeInjector = supertypeInjector;",
-        "    assert sProvider != null;",
-        "    this.sProvider = sProvider;",
-        "  }",
-        "",
-        "  @Override public void injectMembers(B instance) {",
-        "    if (instance == null) {",
-        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
-        "    }",
-        "    supertypeInjector.injectMembers(instance);",
-        "    instance.s = sProvider.get();",
+        "  public static Factory<B> create(MembersInjector<B> membersInjector) {",
+        "    return new B$$Factory(membersInjector);",
         "  }",
         "}");
-    assert_().about(javaSources()).that(ImmutableList.of(aFile, bFile))
+    assertAbout(javaSources()).that(ImmutableList.of(aFile, bFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(expectedMembersInjector);
+        .and().generatesSources(expectedFactory);
   }
 
   @Test
@@ -671,8 +783,13 @@ public void wildcardDependency() {
         "  @Override public InjectConstructor get() {",
         "    return new InjectConstructor(objectsProvider.get());",
         "  }",
+        "",
+        "  public static Factory<InjectConstructor> create(",
+        "      Provider<List<? extends Object>> objectsProvider) {",
+        "    return new InjectConstructor$$Factory(objectsProvider);",
+        "  }",
         "}");
-    assert_().about(javaSource()).that(file).processedWith(new ComponentProcessor())
+    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(expected);
   }
@@ -714,8 +831,13 @@ public void basicNameCollision() {
         "  @Override public InjectConstructor get() {",
         "    return new InjectConstructor(factoryProvider.get());",
         "  }",
+        "",
+        "  public static Factory<InjectConstructor> create(",
+        "      Provider<other.pkg.Factory> factoryProvider) {",
+        "    return new InjectConstructor$$Factory(factoryProvider);",
+        "  }",
         "}");
-    assert_().about(javaSources()).that(ImmutableList.of(factoryFile, file))
+    assertAbout(javaSources()).that(ImmutableList.of(factoryFile, file))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(expected);
@@ -761,8 +883,13 @@ public void nestedNameCollision() {
         "  @Override public InjectConstructor get() {",
         "    return new InjectConstructor(factoryProvider.get());",
         "  }",
+        "",
+        "  public static Factory<InjectConstructor> create(",
+        "      Provider<Outer.Factory> factoryProvider) {",
+        "    return new InjectConstructor$$Factory(factoryProvider);",
+        "  }",
         "}");
-    assert_().about(javaSources()).that(ImmutableList.of(factoryFile, file))
+    assertAbout(javaSources()).that(ImmutableList.of(factoryFile, file))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(expected);
@@ -814,8 +941,14 @@ public void samePackageNameCollision() {
         "  @Override public InjectConstructor get() {",
         "    return new InjectConstructor(otherPackageProvider.get(), samePackageProvider.get());",
         "  }",
+        "",
+        "  public static Factory<InjectConstructor> create(",
+        "      Provider<CommonName> otherPackageProvider,",
+        "      Provider<test.CommonName> samePackageProvider) {",
+        "    return new InjectConstructor$$Factory(otherPackageProvider, samePackageProvider);",
+        "  }",
         "}");
-    assert_().about(javaSources())
+    assertAbout(javaSources())
         .that(ImmutableList.of(samePackageInterface, differentPackageInterface, file))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -845,11 +978,59 @@ public void noDeps() {
         "  @Override public SimpleType get() {",
         "    return new SimpleType();",
         "  }",
+        "",
+        "  public static Factory<SimpleType> create() {",
+        "    return INSTANCE;",
+        "  }",
         "}");
-    assert_().about(javaSource())
+    assertAbout(javaSource())
         .that(simpleType)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(factory);
   }
+
+  @Test public void simpleComponentWithNesting() {
+    JavaFileObject nestedTypesFile = JavaFileObjects.forSourceLines("test.OuterType",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Inject;",
+        "",
+        "final class OuterType {",
+        "  static class A {",
+        "    @Inject A() {}",
+        "  }",
+        "  static class B {",
+        "    @Inject A a;",
+        "  }",
+        "  @Component interface SimpleComponent {",
+        "    A a();",
+        "    void inject(B b);",
+        "  }",
+        "}");
+    JavaFileObject aFactory = JavaFileObjects.forSourceLines(
+        "test.OuterType$A$$Factory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import javax.annotation.Generated;",
+        "import test.OuterType.A;",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public enum OuterType$A$$Factory implements Factory<A> {",
+        "  INSTANCE;",
+        "",
+        "  @Override public A get() {",
+        "    return new A();",
+        "  }",
+        "",
+        "  public static Factory<A> create() {",
+        "    return INSTANCE;",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(nestedTypesFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(aFactory);
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
index 62ba6f402..2e5f216a2 100644
--- a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
@@ -19,10 +19,12 @@
 import com.google.common.base.Equivalence;
 import com.google.common.base.Optional;
 import com.google.common.collect.Iterables;
+import com.google.common.util.concurrent.ListenableFuture;
 import com.google.testing.compile.CompilationRule;
 import dagger.Module;
 import dagger.Provides;
-import dagger.internal.codegen.Key.Kind;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
 import java.util.Set;
 import javax.inject.Inject;
 import javax.inject.Qualifier;
@@ -40,7 +42,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assert_;
+import static com.google.common.truth.Truth.assertThat;
 import static dagger.Provides.Type.SET;
 import static dagger.Provides.Type.SET_VALUES;
 
@@ -61,13 +63,14 @@
     this.keyFactory = new Key.Factory(types, elements);
   }
 
-  @Test public void forInjectConstructor() {
+  @Test public void forInjectConstructorWithResolvedType() {
     TypeElement typeElement =
         compilationRule.getElements().getTypeElement(InjectedClass.class.getCanonicalName());
     ExecutableElement constructor =
         Iterables.getOnlyElement(ElementFilter.constructorsIn(typeElement.getEnclosedElements()));
-    assert_().that(keyFactory.forInjectConstructor(constructor))
-        .isEqualTo(new AutoValue_Key(Kind.PROVIDER,
+    assertThat(
+        keyFactory.forInjectConstructorWithResolvedType(constructor.getEnclosingElement().asType()))
+        .isEqualTo(new AutoValue_Key(
             Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
             MoreTypes.equivalence().wrap(typeElement.asType())));
   }
@@ -83,8 +86,8 @@
         elements.getTypeElement(ProvidesMethodModule.class.getCanonicalName());
     ExecutableElement providesMethod =
         Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
-    assert_().that(keyFactory.forProvidesMethod(providesMethod))
-        .isEqualTo(new AutoValue_Key(Kind.PROVIDER,
+    assertThat(keyFactory.forProvidesMethod(providesMethod))
+        .isEqualTo(new AutoValue_Key(
             Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
             MoreTypes.equivalence().wrap(stringType)));
   }
@@ -105,9 +108,9 @@
     ExecutableElement providesMethod =
         Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
     Key key = keyFactory.forProvidesMethod(providesMethod);
-    assert_().that(MoreTypes.equivalence().wrap(key.qualifier().get().getAnnotationType()))
+    assertThat(MoreTypes.equivalence().wrap(key.qualifier().get().getAnnotationType()))
         .isEqualTo(MoreTypes.equivalence().wrap(qualifierElement.asType()));
-    assert_().that(key.wrappedType()).isEqualTo(MoreTypes.equivalence().wrap(stringType));
+    assertThat(key.wrappedType()).isEqualTo(MoreTypes.equivalence().wrap(stringType));
   }
 
   @Test public void qualifiedKeyEquivalents() {
@@ -125,7 +128,7 @@
     AnnotationMirror qualifier = Iterables.getOnlyElement(injectionField.getAnnotationMirrors());
     Key injectionKey = keyFactory.forQualifiedType(Optional.<AnnotationMirror>of(qualifier), type);
 
-    assert_().that(provisionKey).isEqualTo(injectionKey);
+    assertThat(provisionKey).isEqualTo(injectionKey);
   }
 
   @Module(library = true)
@@ -156,8 +159,8 @@ String provideQualifiedString() {
         elements.getTypeElement(SetProvidesMethodsModule.class.getCanonicalName());
     for (ExecutableElement providesMethod
         : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {
-      assert_().that(keyFactory.forProvidesMethod(providesMethod))
-          .isEqualTo(new AutoValue_Key(Kind.PROVIDER,
+      assertThat(keyFactory.forProvidesMethod(providesMethod))
+          .isEqualTo(new AutoValue_Key(
               Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
               MoreTypes.equivalence().wrap(setOfStringsType)));
     }
@@ -199,13 +202,72 @@ String provideQualifiedString() {
 
     // TODO(user): Truth subject for TypeMirror and TypeElement
     TypeMirror intType = intMethod.getReturnType();
-    assert_().that(intType.getKind().isPrimitive()).isTrue();
+    assertThat(intType.getKind().isPrimitive()).isTrue();
     TypeMirror integerType = integerMethod.getReturnType();
-    assert_().that(integerType.getKind().isPrimitive()).isFalse();
-    assert_().that(types.isSameType(intType, integerType)).named("type equality").isFalse();
+    assertThat(integerType.getKind().isPrimitive()).isFalse();
+    assertThat(types.isSameType(intType, integerType)).named("type equality").isFalse();
 
     Key intKey = keyFactory.forProvidesMethod(intMethod);
     Key integerKey = keyFactory.forProvidesMethod(integerMethod);
-    assert_().that(intKey).isEqualTo(integerKey);
+    assertThat(intKey).isEqualTo(integerKey);
+  }
+
+  @Test public void forProducesMethod() {
+    TypeMirror stringType = elements.getTypeElement(String.class.getCanonicalName()).asType();
+    TypeElement moduleElement =
+        elements.getTypeElement(ProducesMethodsModule.class.getCanonicalName());
+    for (ExecutableElement producesMethod
+        : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {
+      assertThat(keyFactory.forProducesMethod(producesMethod))
+          .isEqualTo(new AutoValue_Key(
+                  Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
+                  MoreTypes.equivalence().wrap(stringType)));
+    }
+  }
+
+  @ProducerModule
+  static final class ProducesMethodsModule {
+    @Produces String produceString() {
+      return null;
+    }
+
+    @Produces ListenableFuture<String> produceFutureString() {
+      return null;
+    }
+  }
+
+  @Test public void forProducesMethod_sets() {
+    TypeElement setElement = elements.getTypeElement(Set.class.getCanonicalName());
+    TypeMirror stringType = elements.getTypeElement(String.class.getCanonicalName()).asType();
+    TypeMirror setOfStringsType = types.getDeclaredType(setElement, stringType);
+    TypeElement moduleElement =
+        elements.getTypeElement(SetProducesMethodsModule.class.getCanonicalName());
+    for (ExecutableElement producesMethod
+        : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {
+      assertThat(keyFactory.forProducesMethod(producesMethod))
+          .isEqualTo(new AutoValue_Key(
+                  Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
+                  MoreTypes.equivalence().wrap(setOfStringsType)));
+    }
+  }
+
+  @ProducerModule
+  static final class SetProducesMethodsModule {
+    @Produces(type = Produces.Type.SET) String produceString() {
+      return null;
+    }
+
+    @Produces(type = Produces.Type.SET) ListenableFuture<String> produceFutureString() {
+      return null;
+    }
+
+    @Produces(type = Produces.Type.SET_VALUES) Set<String> produceStrings() {
+      return null;
+    }
+
+    @Produces(type = Produces.Type.SET_VALUES)
+    ListenableFuture<Set<String>> produceFutureStrings() {
+      return null;
+    }
   }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
index ea13e5202..6ca89f8e4 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -120,6 +120,8 @@ public void mapBindingsWithEnumKey() {
         "public final class Dagger_TestComponent implements TestComponent {",
         "  private final MapModuleOne mapModuleOne;",
         "  private final MapModuleTwo mapModuleTwo;",
+        "  private Provider<Handler> mapOfPathEnumAndProviderOfHandlerContribution1;",
+        "  private Provider<Handler> mapOfPathEnumAndProviderOfHandlerContribution2;",
         "  private Provider<Map<PathEnum, Provider<Handler>>>",
         "      mapOfPathEnumAndProviderOfHandlerProvider;",
         "",
@@ -139,12 +141,16 @@ public void mapBindingsWithEnumKey() {
         "  }",
         "",
         "  private void initialize() {",
+        "    this.mapOfPathEnumAndProviderOfHandlerContribution1 =",
+        "        new MapModuleOne$$ProvideAdminHandlerFactory(mapModuleOne);",
+        "    this.mapOfPathEnumAndProviderOfHandlerContribution2 =",
+        "        new MapModuleTwo$$ProvideLoginHandlerFactory(mapModuleTwo);",
         "    this.mapOfPathEnumAndProviderOfHandlerProvider =",
         "        MapProviderFactory.<PathEnum, Handler>builder(2)",
         "            .put(test.PathEnum.ADMIN,",
-        "                new MapModuleOne$$ProvideAdminHandlerFactory(mapModuleOne))",
+        "                mapOfPathEnumAndProviderOfHandlerContribution1)",
         "            .put(test.PathEnum.LOGIN,",
-        "                new MapModuleTwo$$ProvideLoginHandlerFactory(mapModuleTwo))",
+        "                mapOfPathEnumAndProviderOfHandlerContribution2)",
         "            .build();",
         "  }",
         "",
@@ -286,7 +292,10 @@ public void mapBindingsWithStringKey() {
         "public final class Dagger_TestComponent implements TestComponent {",
         "  private final MapModuleOne mapModuleOne;",
         "  private final MapModuleTwo mapModuleTwo;",
-        "  private Provider<Map<String, Provider<Handler>>> mapOfStringAndProviderOfHandlerProvider;",
+        "  private Provider<Handler> mapOfStringAndProviderOfHandlerContribution1;",
+        "  private Provider<Handler> mapOfStringAndProviderOfHandlerContribution2;",
+        "  private Provider<Map<String, Provider<Handler>>>",
+        "      mapOfStringAndProviderOfHandlerProvider;",
         "",
         "  private Dagger_TestComponent(Builder builder) {",
         "    assert builder != null;",
@@ -304,10 +313,14 @@ public void mapBindingsWithStringKey() {
         "  }",
         "",
         "  private void initialize() {",
+        "    this.mapOfStringAndProviderOfHandlerContribution1 =",
+        "        new MapModuleOne$$ProvideAdminHandlerFactory(mapModuleOne);",
+        "    this.mapOfStringAndProviderOfHandlerContribution2 =",
+        "        new MapModuleTwo$$ProvideLoginHandlerFactory(mapModuleTwo);",
         "    this.mapOfStringAndProviderOfHandlerProvider =",
         "        MapProviderFactory.<String, Handler>builder(2)",
-        "            .put(\"Admin\", new MapModuleOne$$ProvideAdminHandlerFactory(mapModuleOne))",
-        "            .put(\"Login\", new MapModuleTwo$$ProvideLoginHandlerFactory(mapModuleTwo))",
+        "            .put(\"Admin\", mapOfStringAndProviderOfHandlerContribution1)",
+        "            .put(\"Login\", mapOfStringAndProviderOfHandlerContribution2)",
         "            .build();",
         "  }",
         "",
@@ -452,6 +465,8 @@ public void mapBindingsWithNonProviderValue() {
         "public final class Dagger_TestComponent implements TestComponent {",
         "  private final MapModuleOne mapModuleOne;",
         "  private final MapModuleTwo mapModuleTwo;",
+        "  private Provider<Handler> mapOfPathEnumAndProviderOfHandlerContribution1;",
+        "  private Provider<Handler> mapOfPathEnumAndProviderOfHandlerContribution2;",
         "  private Provider<Map<PathEnum, Provider<Handler>>>",
         "      mapOfPathEnumAndProviderOfHandlerProvider;",
         "  private Provider<Map<PathEnum, Handler>> mapOfPathEnumAndHandlerProvider;",
@@ -472,12 +487,16 @@ public void mapBindingsWithNonProviderValue() {
         "  }",
         "",
         "  private void initialize() {",
+        "    this.mapOfPathEnumAndProviderOfHandlerContribution1 =",
+        "        new MapModuleOne$$ProvideAdminHandlerFactory(mapModuleOne);",
+        "    this.mapOfPathEnumAndProviderOfHandlerContribution2 =",
+        "        new MapModuleTwo$$ProvideLoginHandlerFactory(mapModuleTwo);",
         "    this.mapOfPathEnumAndProviderOfHandlerProvider =",
         "        MapProviderFactory.<PathEnum, Handler>builder(2)",
         "            .put(test.PathEnum.ADMIN,",
-        "                new MapModuleOne$$ProvideAdminHandlerFactory(mapModuleOne))",
+        "                mapOfPathEnumAndProviderOfHandlerContribution1)",
         "            .put(test.PathEnum.LOGIN,",
-        "                new MapModuleTwo$$ProvideLoginHandlerFactory(mapModuleTwo))",
+        "                mapOfPathEnumAndProviderOfHandlerContribution2)",
         "            .build();",
         "    this.mapOfPathEnumAndHandlerProvider =",
         "        MapFactory.create(mapOfPathEnumAndProviderOfHandlerProvider);",
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
index 64749c9aa..ed0d99322 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
@@ -161,6 +161,8 @@ public void mapKeyComponentFileWithDisorderedKeyField() {
         "public final class Dagger_TestComponent implements TestComponent {",
         "  private final MapModuleOne mapModuleOne;",
         "  private final MapModuleTwo mapModuleTwo;",
+        "  private Provider<Handler> mapOfPathKeyAndProviderOfHandlerContribution1;",
+        "  private Provider<Handler> mapOfPathKeyAndProviderOfHandlerContribution2;",
         "  private Provider<Map<PathKey, Provider<Handler>>>",
         "      mapOfPathKeyAndProviderOfHandlerProvider;",
         "",
@@ -180,12 +182,16 @@ public void mapKeyComponentFileWithDisorderedKeyField() {
         "  }",
         "",
         "  private void initialize() {",
+        "    this.mapOfPathKeyAndProviderOfHandlerContribution1 =",
+        "        new MapModuleOne$$ProvideAdminHandlerFactory(mapModuleOne);",
+        "    this.mapOfPathKeyAndProviderOfHandlerContribution2 =",
+        "        new MapModuleTwo$$ProvideLoginHandlerFactory(mapModuleTwo);",
         "    this.mapOfPathKeyAndProviderOfHandlerProvider =",
         "        MapProviderFactory.<PathKey, Handler>builder(2)",
         "            .put(PathKeyCreator.create(PathEnum.ADMIN, \"AdminPath\"),",
-        "                new MapModuleOne$$ProvideAdminHandlerFactory(mapModuleOne))",
+        "                mapOfPathKeyAndProviderOfHandlerContribution1)",
         "            .put(PathKeyCreator.create(PathEnum.LOGIN, \"LoginPath\"),",
-        "                new MapModuleTwo$$ProvideLoginHandlerFactory(mapModuleTwo))",
+        "                mapOfPathKeyAndProviderOfHandlerContribution2)",
         "            .build();",
         "  }",
         "",
@@ -333,6 +339,8 @@ public void mapKeyComponentFileWithDefaultField() {
         "public final class Dagger_TestComponent implements TestComponent {",
         "  private final MapModuleOne mapModuleOne;",
         "  private final MapModuleTwo mapModuleTwo;",
+        "  private Provider<Handler> mapOfPathKeyAndProviderOfHandlerContribution1;",
+        "  private Provider<Handler> mapOfPathKeyAndProviderOfHandlerContribution2;",
         "  private Provider<Map<PathKey, Provider<Handler>>>",
         "      mapOfPathKeyAndProviderOfHandlerProvider;",
         "",
@@ -352,12 +360,16 @@ public void mapKeyComponentFileWithDefaultField() {
         "  }",
         "",
         "  private void initialize() {",
+        "    this.mapOfPathKeyAndProviderOfHandlerContribution1 =",
+        "        new MapModuleOne$$ProvideAdminHandlerFactory(mapModuleOne);",
+        "    this.mapOfPathKeyAndProviderOfHandlerContribution2 =",
+        "        new MapModuleTwo$$ProvideLoginHandlerFactory(mapModuleTwo);",
         "    this.mapOfPathKeyAndProviderOfHandlerProvider =",
         "        MapProviderFactory.<PathKey, Handler>builder(2)",
         "            .put(PathKeyCreator.create(PathEnum.ADMIN, \"DefaultPath\"),",
-        "                new MapModuleOne$$ProvideAdminHandlerFactory(mapModuleOne))",
+        "                mapOfPathKeyAndProviderOfHandlerContribution1)",
         "            .put(PathKeyCreator.create(PathEnum.LOGIN, \"LoginPath\"),",
-        "                new MapModuleTwo$$ProvideLoginHandlerFactory(mapModuleTwo))",
+        "                mapOfPathKeyAndProviderOfHandlerContribution2)",
         "            .build();",
         "  }",
         "",
diff --git a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
index 2c80a64b3..fe330a201 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
@@ -1,3 +1,18 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package dagger.internal.codegen;
 
 import com.google.common.collect.ImmutableList;
@@ -7,7 +22,8 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assert_;
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 
 @RunWith(JUnit4.class)
@@ -68,7 +84,7 @@ public void parentClass_noInjectedMembers() {
         "  private void initialize() {",
         "    this.parentMembersInjector = MembersInjectors.noOp();",
         "    this.childMembersInjector = MembersInjectors.delegatingTo(parentMembersInjector);",
-        "    this.childProvider = new Child$$Factory(childMembersInjector);",
+        "    this.childProvider = Child$$Factory.create(childMembersInjector);",
         "  }",
         "",
         "  @Override",
@@ -85,7 +101,7 @@ public void parentClass_noInjectedMembers() {
         "    }",
         "  }",
         "}");
-    assert_().about(javaSources())
+    assertAbout(javaSources())
         .that(ImmutableList.of(childFile, parentFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -157,9 +173,9 @@ public void parentClass_injectedMembersInSupertype() {
         "  }",
         "",
         "  private void initialize() {",
-        "    this.parentMembersInjector = new Parent$$MembersInjector(Dep$$Factory.INSTANCE);",
+        "    this.parentMembersInjector = Parent$$MembersInjector.create(Dep$$Factory.create());",
         "    this.childMembersInjector = MembersInjectors.delegatingTo(parentMembersInjector);",
-        "    this.childProvider = new Child$$Factory(childMembersInjector);",
+        "    this.childProvider = Child$$Factory.create(childMembersInjector);",
         "  }",
         "",
         "  @Override",
@@ -176,10 +192,474 @@ public void parentClass_injectedMembersInSupertype() {
         "    }",
         "  }",
         "}");
-    assert_().about(javaSources())
+    assertAbout(javaSources())
         .that(ImmutableList.of(childFile, parentFile, depFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
   }
+
+  @Test public void fieldAndMethodGenerics() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.GenericClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class GenericClass<A, B> {",
+        "  @Inject A a;",
+        "",
+        "  @Inject GenericClass() {}",
+        "",
+        " @Inject void register(B b) {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass$$MembersInjector",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class GenericClass$$MembersInjector<A, B>",
+        "    implements MembersInjector<GenericClass<A, B>> {",
+        "  private final Provider<A> aProvider;",
+        "  private final Provider<B> bProvider;",
+        "",
+        "  public GenericClass$$MembersInjector(Provider<A> aProvider, Provider<B> bProvider) {",
+        "    assert aProvider != null;",
+        "    this.aProvider = aProvider;",
+        "    assert bProvider != null;",
+        "    this.bProvider = bProvider;",
+        "  }",
+        "",
+        "  @Override",
+        "  public void injectMembers(GenericClass<A, B> instance) {",
+        "    if (instance == null) {",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\")",
+        "    }",
+        "    instance.a = aProvider.get();",
+        "    instance.register(bProvider.get())",
+        "  }",
+        "",
+        "  public static <A, B> MembersInjector<GenericClass<A, B>> create(",
+        "      Provider<A> aProvider, Provider<B> bProvider) {",
+        "    return new GenericClass$$MembersInjector<A, B>(aProvider, bProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(file)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test public void subclassedGenericMembersInjectors() {
+    JavaFileObject a = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject A() {}",
+        "}");
+    JavaFileObject a2 = JavaFileObjects.forSourceLines("test.A2",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A2 {",
+        "  @Inject A2() {}",
+        "}");
+    JavaFileObject parent = JavaFileObjects.forSourceLines("test.Parent",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class Parent<X, Y> {",
+        "  @Inject X x;",
+        "  @Inject Y y;",
+        "  @Inject A2 a2;",
+        "",
+        "  @Inject Parent() {}",
+        "}");
+    JavaFileObject child = JavaFileObjects.forSourceLines("test.Child",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class Child<T> extends Parent<T, A> {",
+        "  @Inject A a;",
+        "  @Inject T t;",
+        "",
+        "  @Inject Child() {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass$$MembersInjector",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Child$$MembersInjector<T>",
+        "    implements MembersInjector<Child<T>> {",
+        "  private final MembersInjector<Parent<T, A>> supertypeInjector;",
+        "  private final Provider<A> aProvider;",
+        "  private final Provider<T> tProvider;",
+        "",
+        "  public Child$$MembersInjector(",
+        "      MembersInjector<Parent<T, A>> supertypeInjector, ",
+        "      Provider<A> aProvider, Provider<T> tProvider) {",
+        "    assert supertypeInjector != null;",
+        "    this.supertypeInjector = supertypeInjector;",
+        "    assert aProvider != null;",
+        "    this.aProvider = aProvider;",
+        "    assert tProvider != null;",
+        "    this.tProvider = tProvider;",
+        "  }",
+        "",
+        "  @Override",
+        "  public void injectMembers(Child<T> instance) {",
+        "    if (instance == null) {",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\")",
+        "    }",
+        "    supertypeInjector.injectMembers(instance);",
+        "    instance.a = aProvider.get();",
+        "    instance.t = tProvider.get();",
+        "  }",
+        "",
+        "  public static <T> MembersInjector<Child<T>> create(",
+        "      MembersInjector<Parent<T, A>> supertypeInjector, ",
+        "      Provider<A> aProvider, Provider<T> tProvider) {",
+        "    return new Child$$MembersInjector<T>(supertypeInjector, aProvider, tProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(a, a2, parent, child))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test public void fieldInjection() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.FieldInjection",
+        "package test;",
+        "",
+        "import dagger.Lazy;",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "class FieldInjection {",
+        "  @Inject String string;",
+        "  @Inject Lazy<String> lazyString;",
+        "  @Inject Provider<String> stringProvider;",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines("test.FieldInjection$$MembersInjector",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import dagger.internal.DoubleCheckLazy;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class FieldInjection$$MembersInjector ",
+        "    implements MembersInjector<FieldInjection> {",
+        "",
+        "  private final Provider<String> stringProvider;",
+        "",
+        "  public FieldInjection$$MembersInjector(Provider<String> stringProvider) {",
+        "    assert stringProvider != null;",
+        "    this.stringProvider = stringProvider;",
+        "  }",
+        "",
+        "  @Override public void injectMembers(FieldInjection instance) {",
+        "    if (instance == null) {",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+        "    }",
+        "    instance.string = stringProvider.get();",
+        "    instance.lazyString = DoubleCheckLazy.create(stringProvider);",
+        "    instance.stringProvider = stringProvider;",
+        "  }",
+        "",
+        "  public static MembersInjector<FieldInjection> create(",
+        "      Provider<String> stringProvider) {",
+        "    return new FieldInjection$$MembersInjector(stringProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test public void methodInjection() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.MethodInjection",
+        "package test;",
+        "",
+        "import dagger.Lazy;",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "class MethodInjection {",
+        "  @Inject void noArgs() {}",
+        "  @Inject void oneArg(String string) {}",
+        "  @Inject void manyArgs(",
+        "      String string, Lazy<String> lazyString, Provider<String> stringProvider) {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines(
+        "test.MethodInjection$$MembersInjector",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import dagger.internal.DoubleCheckLazy;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class MethodInjection$$MembersInjector ",
+        "    implements MembersInjector<MethodInjection> {",
+        "",
+        "  private final Provider<String> stringProvider;",
+        "",
+        "  public MethodInjection$$MembersInjector(Provider<String> stringProvider) {",
+        "    assert stringProvider != null;",
+        "    this.stringProvider = stringProvider;",
+        "  }",
+        "",
+        "  @Override public void injectMembers(MethodInjection instance) {",
+        "    if (instance == null) {",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+        "    }",
+        "    instance.noArgs();",
+        "    instance.oneArg(stringProvider.get());",
+        "    instance.manyArgs(stringProvider.get(), DoubleCheckLazy.create(stringProvider),",
+        "        stringProvider);",
+        "  }",
+        "",
+        "  public static MembersInjector<MethodInjection> create(",
+        "      Provider<String> stringProvider) {",
+        "    return new MethodInjection$$MembersInjector(stringProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test public void mixedMemberInjection() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.MixedMemberInjection",
+        "package test;",
+        "",
+        "import dagger.Lazy;",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "class MixedMemberInjection {",
+        "  @Inject String string;",
+        "  @Inject void setString(String s) {}",
+        "  @Inject Object object;",
+        "  @Inject void setObject(Object o) {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines(
+        "test.MixedMemberInjection$$MembersInjector",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class MixedMemberInjection$$MembersInjector ",
+        "    implements MembersInjector<MixedMemberInjection> {",
+        "",
+        "  private final Provider<String> stringAndSProvider;",
+        "  private final Provider<Object> objectAndOProvider;",
+        "",
+        "  public MixedMemberInjection$$MembersInjector(Provider<String> stringAndSProvider,",
+        "      Provider<Object> objectAndOProvider) {",
+        "    assert stringAndSProvider != null;",
+        "    this.stringAndSProvider = stringAndSProvider;",
+        "    assert objectAndOProvider != null;",
+        "    this.objectAndOProvider = objectAndOProvider;",
+        "  }",
+        "",
+        "  @Override public void injectMembers(MixedMemberInjection instance) {",
+        "    if (instance == null) {",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+        "    }",
+        "    instance.string = stringAndSProvider.get();",
+        "    instance.object = objectAndOProvider.get();",
+        "    instance.setString(stringAndSProvider.get());",
+        "    instance.setObject(objectAndOProvider.get());",
+        "  }",
+        "",
+        "  public static MembersInjector<MixedMemberInjection> create(",
+        "      Provider<String> stringAndSProvider,",
+        "      Provider<Object> objectAndOProvider) {",
+        "    return new MixedMemberInjection$$MembersInjector(",
+        "        stringAndSProvider, objectAndOProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test public void injectConstructorAndMembersInjection() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.AllInjections",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class AllInjections {",
+        "  @Inject String s;",
+        "  @Inject AllInjections(String s) {}",
+        "  @Inject void s(String s) {}",
+        "}");
+    JavaFileObject expectedMembersInjector = JavaFileObjects.forSourceLines(
+        "test.AllInjections$$MembersInjector",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class AllInjections$$MembersInjector ",
+        "    implements MembersInjector<AllInjections> {",
+        "",
+        "  private final Provider<String> sProvider;",
+        "",
+        "  public AllInjections$$MembersInjector(Provider<String> sProvider) {",
+        "    assert sProvider != null;",
+        "    this.sProvider = sProvider;",
+        "  }",
+        "",
+        "  @Override public void injectMembers(AllInjections instance) {",
+        "    if (instance == null) {",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+        "    }",
+        "    instance.s = sProvider.get();",
+        "    instance.s(sProvider.get());",
+        "  }",
+        "",
+        "  public static MembersInjector<AllInjections> create(Provider<String> sProvider) {",
+        "    return new AllInjections$$MembersInjector(sProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(expectedMembersInjector);
+  }
+
+  @Test public void supertypeMembersInjection() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "class A {}");
+    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class B extends A {",
+        "  @Inject String s;",
+        "}");
+    JavaFileObject expectedMembersInjector = JavaFileObjects.forSourceLines(
+        "test.AllInjections$$MembersInjector",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class B$$MembersInjector ",
+        "    implements MembersInjector<B> {",
+        "",
+        "  private final MembersInjector<A> supertypeInjector;",
+        "  private final Provider<String> sProvider;",
+        "",
+        "  public B$$MembersInjector(MembersInjector<A> supertypeInjector,",
+        "      Provider<String> sProvider) {",
+        "    assert supertypeInjector != null;",
+        "    this.supertypeInjector = supertypeInjector;",
+        "    assert sProvider != null;",
+        "    this.sProvider = sProvider;",
+        "  }",
+        "",
+        "  @Override public void injectMembers(B instance) {",
+        "    if (instance == null) {",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+        "    }",
+        "    supertypeInjector.injectMembers(instance);",
+        "    instance.s = sProvider.get();",
+        "  }",
+        "",
+        "  public static MembersInjector<B> create(",
+        "      MembersInjector<A> supertypeInjector,",
+        "      Provider<String> sProvider) {",
+        "    return new B$$MembersInjector(supertypeInjector, sProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(aFile, bFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expectedMembersInjector);
+  }
+
+  @Test public void simpleComponentWithNesting() {
+    JavaFileObject nestedTypesFile = JavaFileObjects.forSourceLines("test.OuterType",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Inject;",
+        "",
+        "final class OuterType {",
+        "  static class A {",
+        "    @Inject A() {}",
+        "  }",
+        "  static class B {",
+        "    @Inject A a;",
+        "  }",
+        "  @Component interface SimpleComponent {",
+        "    A a();",
+        "    void inject(B b);",
+        "  }",
+        "}");
+    JavaFileObject bMembersInjector = JavaFileObjects.forSourceLines(
+        "test.OuterType$B$$MembersInjector",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "import test.OuterType.A;",
+        "import test.OuterType.B;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class OuterType$B$$MembersInjector implements MembersInjector<B> {",
+        "  private final Provider<A> aProvider;",
+        "",
+        "  public OuterType$B$$MembersInjector(Provider<A> aProvider) {",
+        "    assert aProvider != null;",
+        "    this.aProvider = aProvider;",
+        "  }",
+         "",
+        "  @Override",
+        "  public void injectMembers(B instance) {",
+        "    if (instance == null) {",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+        "    }",
+        "    instance.a = aProvider.get();",
+        "  }",
+        "",
+        "  public static MembersInjector<B> create(Provider<A> aProvider) {",
+        "    return new OuterType$B$$MembersInjector(aProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(nestedTypesFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(bMembersInjector);
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/MethodSignatureFormatterTest.java b/compiler/src/test/java/dagger/internal/codegen/MethodSignatureFormatterTest.java
index 49ce70c5b..440c486fb 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MethodSignatureFormatterTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MethodSignatureFormatterTest.java
@@ -43,7 +43,7 @@
     static class InnerClass {
       @Foo(bar = String.class)
       @Singleton
-      String foo(int a, ImmutableList<Boolean> blah) { return "foo"; }
+      String foo(@SuppressWarnings("unused") int a, ImmutableList<Boolean> blah) { return "foo"; }
     }
   }
 
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index 35cfa5fa2..a19b6e31e 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -25,22 +25,30 @@
 import static com.google.common.truth.Truth.assert_;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_ABSTRACT;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_MUST_RETURN_A_VALUE;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_NOT_IN_MODULE;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_PRIVATE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_STATIC;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_RETURN_TYPE;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RAW_SET;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RETURN_SET;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_STATIC;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_TYPE_PARAMETER;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_WITH_SAME_NAME;
 
 @RunWith(JUnit4.class)
 public class ModuleFactoryGeneratorTest {
   // TODO(gak): add tests for invalid combinations of scope and qualifier annotations like we have
   // for @Inject
 
+  private String formatErrorMessage(String msg) {
+    return String.format(msg, "Provides");
+  }
+
+  private String formatModuleErrorMessage(String msg) {
+    return String.format(msg, "Provides", "Module");
+  }
+
   @Test public void providesMethodNotInModule() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
@@ -55,7 +63,7 @@
     assert_().about(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(PROVIDES_METHOD_NOT_IN_MODULE);
+        .withErrorContaining(formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE));
   }
 
   @Test public void providesMethodAbstract() {
@@ -72,7 +80,7 @@
     assert_().about(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(PROVIDES_METHOD_ABSTRACT);
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_ABSTRACT));
   }
 
   @Test public void providesMethodPrivate() {
@@ -91,7 +99,7 @@
     assert_().about(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(PROVIDES_METHOD_PRIVATE);
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_PRIVATE));
   }
 
   @Test public void providesMethodStatic() {
@@ -110,7 +118,7 @@
     assert_().about(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(PROVIDES_METHOD_STATIC);
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_STATIC));
   }
 
   @Test public void providesMethodReturnVoid() {
@@ -127,7 +135,7 @@
     assert_().about(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(PROVIDES_METHOD_MUST_RETURN_A_VALUE);
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE));
   }
 
   @Test public void providesMethodWithTypeParameter() {
@@ -146,7 +154,7 @@
     assert_().about(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(PROVIDES_METHOD_TYPE_PARAMETER);
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER));
   }
 
   @Test public void providesMethodSetValuesWildcard() {
@@ -192,7 +200,7 @@
     assert_().about(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(PROVIDES_METHOD_SET_VALUES_RAW_SET);
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET));
   }
 
   @Test public void providesMethodSetValuesNotASet() {
@@ -272,9 +280,18 @@
           "@Qualifier @interface QualifierB {}");
 
   @Test public void multipleProvidesMethods() {
+    JavaFileObject classXFile = JavaFileObjects.forSourceLines("test.X",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class X {",
+        "  @Inject public String s;",
+        "}");
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
+        "import dagger.MembersInjector;",
         "import dagger.Module;",
         "import dagger.Provides;",
         "",
@@ -283,7 +300,8 @@
         "",
         "@Module",
         "final class TestModule {",
-        "  @Provides List<Object> provideObjects(@QualifierA Object a, @QualifierB Object b) {",
+        "  @Provides List<Object> provideObjects(",
+        "      @QualifierA Object a, @QualifierB Object b, MembersInjector<X> x) {",
         "    return Arrays.asList(a, b);",
         "  }",
         "",
@@ -300,6 +318,7 @@
         "package test;",
         "",
         "import dagger.Factory;",
+        "import dagger.MembersInjector;",
         "import java.util.List;",
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
@@ -309,28 +328,35 @@
         "  private final TestModule module;",
         "  private final Provider<Object> aProvider;",
         "  private final Provider<Object> bProvider;",
+        "  private final MembersInjector<X> xMembersInjector;",
         "",
-        "  public TestModule$$ProvideObjectsFactory(TestModule module,",
-        "       Provider<Object> aProvider, Provider<Object> bProvider) {",
+        "  public TestModule$$ProvideObjectsFactory(",
+        "      TestModule module,",
+        "      Provider<Object> aProvider,",
+        "      Provider<Object> bProvider,",
+        "      MembersInjector<X> xMembersInjector) {",
         "    assert module != null;",
         "    this.module = module;",
         "    assert aProvider != null;",
         "    this.aProvider = aProvider;",
         "    assert bProvider != null;",
         "    this.bProvider = bProvider;",
+        "    assert xMembersInjector != null;",
+        "    this.xMembersInjector = xMembersInjector;",
         "  }",
         "",
         "  @Override public List<Object> get() {",
-        "    return module.provideObjects(aProvider.get(), bProvider.get());",
+        "    return module.provideObjects(aProvider.get(), bProvider.get(), xMembersInjector);",
         "  }",
         "}");
-    assert_().about(javaSources()).that(ImmutableList.of(moduleFile, QUALIFIER_A, QUALIFIER_B))
+    assert_().about(javaSources()).that(
+            ImmutableList.of(classXFile, moduleFile, QUALIFIER_A, QUALIFIER_B))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(listFactoryFile);
   }
 
-  @Test public void proviesSetElement() {
+  @Test public void providesSetElement() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
@@ -435,8 +461,9 @@
     assert_().about(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(PROVIDES_METHOD_WITH_SAME_NAME).in(moduleFile).onLine(8)
-        .and().withErrorContaining(PROVIDES_METHOD_WITH_SAME_NAME).in(moduleFile).onLine(12);
+    .withErrorContaining(formatErrorMessage(BINDING_METHOD_WITH_SAME_NAME)).in(moduleFile).onLine(8)
+        .and().withErrorContaining(formatErrorMessage(BINDING_METHOD_WITH_SAME_NAME))
+        .in(moduleFile).onLine(12);
   }
 
   @Test
diff --git a/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java b/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java
index 2fb63b9cf..a2b8e297f 100644
--- a/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java
@@ -92,13 +92,13 @@
         "",
         "  private void initialize() {",
         "    this.foreign_Proxy.nonPublicClass1Provider =",
-        "        new NonPublicClass1$$Factory(NoDepClass$$Factory.INSTANCE);",
+        "        NonPublicClass1$$Factory.create(NoDepClass$$Factory.create());",
         "    this.foreign_Proxy.nonPublicClass2Provider =",
-        "        new NonPublicClass2$$Factory(NoDepClass$$Factory.INSTANCE);",
-        "    this.publicClassProvider = new PublicClass$$Factory(",
+        "        NonPublicClass2$$Factory.create(NoDepClass$$Factory.create());",
+        "    this.publicClassProvider = PublicClass$$Factory.create(",
         "        foreign_Proxy.nonPublicClass1Provider,",
         "        foreign_Proxy.nonPublicClass2Provider,",
-        "        NoDepClass$$Factory.INSTANCE);",
+        "        NoDepClass$$Factory.create());",
         "  }",
         "",
         "  @Override",
@@ -217,13 +217,13 @@
         "  }",
         "",
         "  private void initialize() {",
-        "    this.dMembersInjector = new D$$MembersInjector(NoDepClass$$Factory.INSTANCE);",
+        "    this.dMembersInjector = D$$MembersInjector.create(NoDepClass$$Factory.create());",
         "    this.foreign_Proxy.cMembersInjector =",
-        "        new C$$MembersInjector(dMembersInjector, NoDepClass$$Factory.INSTANCE);",
-        "    this.bMembersInjector = new B$$MembersInjector(",
-        "        foreign_Proxy.cMembersInjector, NoDepClass$$Factory.INSTANCE);",
-        "    this.aMembersInjector = new A$$MembersInjector(",
-        "        bMembersInjector, NoDepClass$$Factory.INSTANCE);",
+        "        C$$MembersInjector.create(dMembersInjector, NoDepClass$$Factory.create());",
+        "    this.bMembersInjector = B$$MembersInjector.create(",
+        "        foreign_Proxy.cMembersInjector, NoDepClass$$Factory.create());",
+        "    this.aMembersInjector = A$$MembersInjector.create(",
+        "        bMembersInjector, NoDepClass$$Factory.create());",
         "  }",
         "",
         "  @Override",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
new file mode 100644
index 000000000..83c96aca1
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -0,0 +1,1157 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_STATIC;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;
+import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RAW_FUTURE;
+import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RETURN_TYPE;
+import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;
+
+@RunWith(JUnit4.class)
+public class ProducerModuleFactoryGeneratorTest {
+  private String formatErrorMessage(String msg) {
+    return String.format(msg, "Produces");
+  }
+
+  private String formatModuleErrorMessage(String msg) {
+    return String.format(msg, "Produces", "ProducerModule");
+  }
+
+  @Test public void producesMethodNotInModule() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.producers.Produces;",
+        "",
+        "final class TestModule {",
+        "  @Produces String produceString() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE));
+  }
+
+  @Test public void producesMethodAbstract() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "@ProducerModule",
+        "abstract class TestModule {",
+        "  @Produces abstract String produceString();",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_ABSTRACT));
+  }
+
+  @Test public void producesMethodPrivate() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces private String produceString() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_PRIVATE));
+  }
+
+  @Test public void producesMethodStatic() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces static String produceString() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_STATIC));
+  }
+
+  @Test public void producesMethodReturnVoid() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces void produceNothing() {}",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE));
+  }
+
+  @Test public void producesMethodReturnRawFuture() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces ListenableFuture produceRaw() {}",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(PRODUCES_METHOD_RAW_FUTURE);
+  }
+
+  @Test public void producesMethodReturnWildcardFuture() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces ListenableFuture<?> produceRaw() {}",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(PRODUCES_METHOD_RETURN_TYPE);
+  }
+
+  @Test public void producesMethodWithTypeParameter() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces <T> String produceString() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER));
+  }
+
+  @Test public void producesMethodSetValuesWildcard() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import static dagger.producers.Produces.Type.SET_VALUES;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "import java.util.Set;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces(type = SET_VALUES) Set<?> produceWildcard() {",
+        "    return null;",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(PRODUCES_METHOD_RETURN_TYPE);
+  }
+
+  @Test public void producesMethodSetValuesRawSet() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import static dagger.producers.Produces.Type.SET_VALUES;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "import java.util.Set;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces(type = SET_VALUES) Set produceSomething() {",
+        "    return null;",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET));
+  }
+
+  @Test public void producesMethodSetValuesNotASet() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import static dagger.producers.Produces.Type.SET_VALUES;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "import java.util.List;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces(type = SET_VALUES) List<String> produceStrings() {",
+        "    return null;",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(PRODUCES_METHOD_SET_VALUES_RETURN_SET);
+  }
+
+  @Test public void producesMethodSetValuesWildcardInFuture() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import static dagger.producers.Produces.Type.SET_VALUES;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "import java.util.Set;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces(type = SET_VALUES) ListenableFuture<Set<?>> produceWildcard() {",
+        "    return null;",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(PRODUCES_METHOD_RETURN_TYPE);
+  }
+
+  @Test public void producesMethodSetValuesFutureRawSet() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import static dagger.producers.Produces.Type.SET_VALUES;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "import java.util.Set;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces(type = SET_VALUES) ListenableFuture<Set> produceSomething() {",
+        "    return null;",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET));
+  }
+
+  @Test public void producesMethodSetValuesFutureNotASet() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import static dagger.producers.Produces.Type.SET_VALUES;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "import java.util.List;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces(type = SET_VALUES) ListenableFuture<List<String>> produceStrings() {",
+        "    return null;",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(PRODUCES_METHOD_SET_VALUES_RETURN_SET);
+  }
+
+  @Test public void multipleProducesMethodsWithSameName() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces Object produce(int i) {",
+        "    return i;",
+        "  }",
+        "",
+        "  @Produces String produce() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    String errorMessage = String.format(BINDING_METHOD_WITH_SAME_NAME, "Produces");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(errorMessage).in(moduleFile).onLine(8)
+        .and().withErrorContaining(errorMessage).in(moduleFile).onLine(12);
+  }
+
+  @Test
+  public void privateModule() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.Enclosing",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "",
+        "final class Enclosing {",
+        "  @ProducerModule private static final class PrivateModule {",
+        "  }",
+        "}");
+    assertAbout(javaSource())
+        .that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("Modules cannot be private.")
+        .in(moduleFile).onLine(6);
+  }
+
+  @Test
+  public void enclosedInPrivateModule() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.Enclosing",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "",
+        "final class Enclosing {",
+        "  private static final class PrivateEnclosing {",
+        "    @ProducerModule static final class TestModule {",
+        "    }",
+        "  }",
+        "}");
+    assertAbout(javaSource())
+        .that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("Modules cannot be enclosed in private types.")
+        .in(moduleFile).onLine(7);
+  }
+
+  @Test
+  public void publicModuleNonPublicIncludes() {
+    JavaFileObject publicModuleFile = JavaFileObjects.forSourceLines("test.PublicModule",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "",
+        "@ProducerModule(includes = {",
+        "    NonPublicModule1.class, OtherPublicModule.class, NonPublicModule2.class",
+        "})",
+        "public final class PublicModule {",
+        "}");
+    JavaFileObject nonPublicModule1File = JavaFileObjects.forSourceLines("test.NonPublicModule1",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "",
+        "@ProducerModule",
+        "final class NonPublicModule1 {",
+        "}");
+    JavaFileObject nonPublicModule2File = JavaFileObjects.forSourceLines("test.NonPublicModule2",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "",
+        "@ProducerModule",
+        "final class NonPublicModule2 {",
+        "}");
+    JavaFileObject otherPublicModuleFile = JavaFileObjects.forSourceLines("test.OtherPublicModule",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "",
+        "@ProducerModule",
+        "public final class OtherPublicModule {",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(
+            publicModuleFile, nonPublicModule1File, nonPublicModule2File, otherPublicModuleFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("This module is public, but it includes non-public "
+            + "(or effectively non-public) modules. "
+            + "Either reduce the visibility of this module or make "
+            + "test.NonPublicModule1 and test.NonPublicModule2 public.")
+        .in(publicModuleFile).onLine(8);
+  }
+
+  @Test public void singleProducesMethodNoArgsFuture() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces ListenableFuture<String> produceString() {",
+        "    return null;",
+        "  }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule$$ProduceStringFactory",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.Futures;",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.internal.AbstractProducer;",
+        "import dagger.producers.internal.Producers;",
+        "import java.util.concurrent.Callable;",
+        "import java.util.concurrent.Executor;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule$$ProduceStringFactory extends AbstractProducer<String> {",
+        "  private final TestModule module;",
+        "  private final Executor executor;",
+        "",
+        "  public TestModule$$ProduceStringFactory(TestModule module, Executor executor) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "    assert executor != null;",
+        "    this.executor = executor;",
+        "  }",
+        "",
+        "  @Override protected ListenableFuture<String> compute() {",
+        "    ListenableFuture<ListenableFuture<String>> future = Producers.submitToExecutor(",
+        "      new Callable<ListenableFuture<String>>() {",
+        "        @Override public ListenableFuture<String> call() {",
+        "          return module.produceString();",
+        "        }",
+        "      }, executor);",
+        "    return Futures.dereference(future);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
+  @Test public void singleProducesMethodNoArgsFutureSet() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces(type = Produces.Type.SET)",
+        "  ListenableFuture<String> produceString() {",
+        "    return null;",
+        "  }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule$$ProduceStringFactory",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.Futures;",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.internal.AbstractProducer;",
+        "import dagger.producers.internal.Producers;",
+        "import java.util.Set;",
+        "import java.util.concurrent.Callable;",
+        "import java.util.concurrent.Executor;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule$$ProduceStringFactory",
+        "    extends AbstractProducer<Set<String>> {",
+        "  private final TestModule module;",
+        "  private final Executor executor;",
+        "",
+        "  public TestModule$$ProduceStringFactory(TestModule module, Executor executor) {  ",
+        "    assert module != null;",
+        "    this.module = module;",
+        "    assert executor != null;",
+        "    this.executor = executor;",
+        "  }",
+        "",
+        "  @Override",
+        "  protected ListenableFuture<Set<String>> compute() {  ",
+        "    ListenableFuture<ListenableFuture<Set<String>>> future =",
+        "        Producers.submitToExecutor(new Callable<ListenableFuture<Set<String>>>() {",
+        "      @Override public ListenableFuture<Set<String>> call() {",
+        "        return Producers.createFutureSingletonSet(module.produceString());",
+        "      }",
+        "    }, executor);",
+        "    return Futures.dereference(future);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
+  @Test public void singleProducesMethodNoArgsNoFuture() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces String produceString() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule$$ProduceStringFactory",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.internal.AbstractProducer;",
+        "import dagger.producers.internal.Producers;",
+        "import java.util.concurrent.Callable;",
+        "import java.util.concurrent.Executor;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule$$ProduceStringFactory extends AbstractProducer<String> {",
+        "  private final TestModule module;",
+        "  private final Executor executor;",
+        "",
+        "  public TestModule$$ProduceStringFactory(TestModule module, Executor executor) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "    assert executor != null;",
+        "    this.executor = executor;",
+        "  }",
+        "",
+        "  @Override protected ListenableFuture<String> compute() {",
+        "    ListenableFuture<String> future = Producers.submitToExecutor(",
+        "      new Callable<String>() {",
+        "        @Override public String call() {",
+        "          return module.produceString();",
+        "        }",
+        "      }, executor);",
+        "    return future;",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
+  @Test public void singleProducesMethodNoArgsNoFutureSet() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces(type = Produces.Type.SET)",
+        "  String produceString() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule$$ProduceStringFactory",
+        "package test;",
+        "",
+        "import com.google.common.collect.ImmutableSet;",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.internal.AbstractProducer;",
+        "import dagger.producers.internal.Producers;",
+        "import java.util.Set;",
+        "import java.util.concurrent.Callable;",
+        "import java.util.concurrent.Executor;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule$$ProduceStringFactory",
+        "    extends AbstractProducer<Set<String>> {",
+        "  private final TestModule module;",
+        "  private final Executor executor;",
+        "",
+        "  public TestModule$$ProduceStringFactory(TestModule module, Executor executor) {  ",
+        "    assert module != null;",
+        "    this.module = module;",
+        "    assert executor != null;",
+        "    this.executor = executor;",
+        "  }",
+        "",
+        "  @Override",
+        "  protected ListenableFuture<Set<String>> compute() {  ",
+        "    ListenableFuture<Set<String>> future =",
+        "        Producers.submitToExecutor(new Callable<Set<String>>() {",
+        "      @Override public Set<String> call() {",
+        "        return ImmutableSet.of(module.produceString());",
+        "      }",
+        "    }, executor);",
+        "    return future;",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
+  @Test public void singleProducesMethodArgsFuture() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.Produced;",
+        "import dagger.producers.Producer;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "import javax.inject.Provider;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces ListenableFuture<String> produceString(",
+        "      int a, Produced<Double> b, Producer<Object> c, Provider<Boolean> d) {",
+        "    return null;",
+        "  }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule$$ProduceStringFactory",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.AsyncFunction;",
+        "import com.google.common.util.concurrent.Futures;",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.Produced;",
+        "import dagger.producers.Producer;",
+        "import dagger.producers.internal.AbstractProducer;",
+        "import dagger.producers.internal.Producers;",
+        "import java.util.List;",
+        "import java.util.concurrent.Executor;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule$$ProduceStringFactory extends AbstractProducer<String> {",
+        "  private final TestModule module;",
+        "  private final Executor executor;",
+        "  private final Producer<Integer> aProducer;",
+        "  private final Producer<Double> bProducer;",
+        "  private final Producer<Object> cProducer;",
+        "  private final Provider<Boolean> dProvider;",
+        "",
+        "  public TestModule$$ProduceStringFactory(",
+        "      TestModule module,",
+        "      Executor executor,",
+        "      Producer<Integer> aProducer,",
+        "      Producer<Double> bProducer,",
+        "      Producer<Object> cProducer,",
+        "      Provider<Boolean> dProvider) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "    assert executor != null;",
+        "    this.executor = executor;",
+        "    assert aProducer != null;",
+        "    this.aProducer = aProducer;",
+        "    assert bProducer != null;",
+        "    this.bProducer = bProducer;",
+        "    assert cProducer != null;",
+        "    this.cProducer = cProducer;",
+        "    assert dProvider != null;",
+        "    this.dProvider = dProvider;",
+        "  }",
+        "",
+        "  @Override protected ListenableFuture<String> compute() {",
+        "    ListenableFuture<Integer> aProducerFuture = aProducer.get();",
+        "    ListenableFuture<Produced<Double>> bProducerFuture =",
+        "        Producers.createFutureProduced(bProducer.get());",
+        "    return Futures.transform(",
+        "        Futures.<Object>allAsList(aProducerFuture, bProducerFuture),",
+        "        new AsyncFunction<List<Object>, String>() {",
+        "          @SuppressWarnings(\"unchecked\")  // safe by specification",
+        "          @Override public ListenableFuture<String> apply(List<Object> args) {",
+        "            return module.produceString(",
+        "                (Integer) args.get(0),",
+        "                (Produced<Double>) args.get(1),",
+        "                cProducer,",
+        "                dProvider);",
+        "          }",
+        "        }, executor);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
+  @Test public void singleProducesMethodArgsNoFuture() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.producers.Produced;",
+        "import dagger.producers.Producer;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "import javax.inject.Provider;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces String produceString(",
+        "      int a, Produced<Double> b, Producer<Object> c, Provider<Boolean> d) {",
+        "    return \"\";",
+        "  }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule$$ProduceStringFactory",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.AsyncFunction;",
+        "import com.google.common.util.concurrent.Futures;",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.Produced;",
+        "import dagger.producers.Producer;",
+        "import dagger.producers.internal.AbstractProducer;",
+        "import dagger.producers.internal.Producers;",
+        "import java.util.List;",
+        "import java.util.concurrent.Executor;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule$$ProduceStringFactory extends AbstractProducer<String> {",
+        "  private final TestModule module;",
+        "  private final Executor executor;",
+        "  private final Producer<Integer> aProducer;",
+        "  private final Producer<Double> bProducer;",
+        "  private final Producer<Object> cProducer;",
+        "  private final Provider<Boolean> dProvider;",
+        "",
+        "  public TestModule$$ProduceStringFactory(",
+        "      TestModule module,",
+        "      Executor executor,",
+        "      Producer<Integer> aProducer,",
+        "      Producer<Double> bProducer,",
+        "      Producer<Object> cProducer,",
+        "      Provider<Boolean> dProvider) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "    assert executor != null;",
+        "    this.executor = executor;",
+        "    assert aProducer != null;",
+        "    this.aProducer = aProducer;",
+        "    assert bProducer != null;",
+        "    this.bProducer = bProducer;",
+        "    assert cProducer != null;",
+        "    this.cProducer = cProducer;",
+        "    assert dProvider != null;",
+        "    this.dProvider = dProvider;",
+        "  }",
+        "",
+        "  @Override protected ListenableFuture<String> compute() {",
+        "    ListenableFuture<Integer> aProducerFuture = aProducer.get();",
+        "    ListenableFuture<Produced<Double>> bProducerFuture =",
+        "        Producers.createFutureProduced(bProducer.get());",
+        "    return Futures.transform(",
+        "        Futures.<Object>allAsList(aProducerFuture, bProducerFuture),",
+        "        new AsyncFunction<List<Object>, String>() {",
+        "          @SuppressWarnings(\"unchecked\")  // safe by specification",
+        "          @Override public ListenableFuture<String> apply(List<Object> args) {",
+        "            return Futures.immediateFuture(module.produceString(",
+        "                (Integer) args.get(0),",
+        "                (Produced<Double>) args.get(1),",
+        "                cProducer,",
+        "                dProvider));",
+        "          }",
+        "        }, executor);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
+  @Test public void singleProducesMethodSingleArgsFuture() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces ListenableFuture<String> produceString(int a) {",
+        "    return null;",
+        "  }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule$$ProduceStringFactory",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.AsyncFunction;",
+        "import com.google.common.util.concurrent.Futures;",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.Producer;",
+        "import dagger.producers.internal.AbstractProducer;",
+        "import java.util.concurrent.Executor;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule$$ProduceStringFactory extends AbstractProducer<String> {",
+        "  private final TestModule module;",
+        "  private final Executor executor;",
+        "  private final Producer<Integer> aProducer;",
+        "",
+        "  public TestModule$$ProduceStringFactory(",
+        "      TestModule module,",
+        "      Executor executor,",
+        "      Producer<Integer> aProducer) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "    assert executor != null;",
+        "    this.executor = executor;",
+        "    assert aProducer != null;",
+        "    this.aProducer = aProducer;",
+        "  }",
+        "",
+        "  @Override protected ListenableFuture<String> compute() {",
+        "    ListenableFuture<Integer> aProducerFuture = aProducer.get();",
+        "    return Futures.transform(aProducerFuture,",
+        "        new AsyncFunction<Integer, String>() {",
+        "          @Override public ListenableFuture<String> apply(Integer a) {",
+        "            return module.produceString(a);",
+        "          }",
+        "        }, executor);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
+  @Test public void singleProducesMethodCheckedException() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "import java.io.IOException;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces ListenableFuture<String> produceString()",
+        "      throws InterruptedException, IOException {",
+        "    return null;",
+        "  }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule$$ProduceStringFactory",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.Futures;",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.internal.AbstractProducer;",
+        "import dagger.producers.internal.Producers;",
+        "import java.io.IOException;",
+        "import java.util.concurrent.Callable;",
+        "import java.util.concurrent.Executor;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule$$ProduceStringFactory extends AbstractProducer<String> {",
+        "  private final TestModule module;",
+        "  private final Executor executor;",
+        "",
+        "  public TestModule$$ProduceStringFactory(TestModule module, Executor executor) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "    assert executor != null;",
+        "    this.executor = executor;",
+        "  }",
+        "",
+        "  @Override protected ListenableFuture<String> compute() {",
+        "    ListenableFuture<ListenableFuture<String>> future = Producers.submitToExecutor(",
+        "      new Callable<ListenableFuture<String>>() {",
+        "        @Override public ListenableFuture<String> call()",
+        "            throws InterruptedException, IOException {",
+        "          return module.produceString();",
+        "        }",
+        "      }, executor);",
+        "    return Futures.dereference(future);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
+  @Test public void singleProducesMethodCheckedExceptionNoFuture() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "import java.io.IOException;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces String produceString() throws IOException {",
+        "    return \"\";",
+        "  }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule$$ProduceStringFactory",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.internal.AbstractProducer;",
+        "import dagger.producers.internal.Producers;",
+        "import java.io.IOException;",
+        "import java.util.concurrent.Callable;",
+        "import java.util.concurrent.Executor;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule$$ProduceStringFactory extends AbstractProducer<String> {",
+        "  private final TestModule module;",
+        "  private final Executor executor;",
+        "",
+        "  public TestModule$$ProduceStringFactory(TestModule module, Executor executor) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "    assert executor != null;",
+        "    this.executor = executor;",
+        "  }",
+        "",
+        "  @Override protected ListenableFuture<String> compute() {",
+        "    ListenableFuture<String> future = Producers.submitToExecutor(",
+        "      new Callable<String>() {",
+        "        @Override public String call() throws IOException {",
+        "          return module.produceString();",
+        "        }",
+        "      }, executor);",
+        "    return future;",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
+  @Test public void singleProducesMethodCheckedExceptionFuture() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.Produced;",
+        "import dagger.producers.Producer;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "import java.io.IOException;",
+        "import javax.inject.Provider;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces ListenableFuture<String> produceString(",
+        "      int a, Produced<Double> b, Producer<Object> c, Provider<Boolean> d)",
+        "          throws IOException {",
+        "    return null;",
+        "  }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule$$ProduceStringFactory",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.AsyncFunction;",
+        "import com.google.common.util.concurrent.Futures;",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.Produced;",
+        "import dagger.producers.Producer;",
+        "import dagger.producers.internal.AbstractProducer;",
+        "import dagger.producers.internal.Producers;",
+        "import java.io.IOException;",
+        "import java.util.List;",
+        "import java.util.concurrent.Executor;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule$$ProduceStringFactory extends AbstractProducer<String> {",
+        "  private final TestModule module;",
+        "  private final Executor executor;",
+        "  private final Producer<Integer> aProducer;",
+        "  private final Producer<Double> bProducer;",
+        "  private final Producer<Object> cProducer;",
+        "  private final Provider<Boolean> dProvider;",
+        "",
+        "  public TestModule$$ProduceStringFactory(",
+        "      TestModule module,",
+        "      Executor executor,",
+        "      Producer<Integer> aProducer,",
+        "      Producer<Double> bProducer,",
+        "      Producer<Object> cProducer,",
+        "      Provider<Boolean> dProvider) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "    assert executor != null;",
+        "    this.executor = executor;",
+        "    assert aProducer != null;",
+        "    this.aProducer = aProducer;",
+        "    assert bProducer != null;",
+        "    this.bProducer = bProducer;",
+        "    assert cProducer != null;",
+        "    this.cProducer = cProducer;",
+        "    assert dProvider != null;",
+        "    this.dProvider = dProvider;",
+        "  }",
+        "",
+        "  @Override protected ListenableFuture<String> compute() {",
+        "    ListenableFuture<Integer> aProducerFuture = aProducer.get();",
+        "    ListenableFuture<Produced<Double>> bProducerFuture =",
+        "        Producers.createFutureProduced(bProducer.get());",
+        "    return Futures.transform(",
+        "        Futures.<Object>allAsList(aProducerFuture, bProducerFuture),",
+        "        new AsyncFunction<List<Object>, String>() {",
+        "          @SuppressWarnings(\"unchecked\")  // safe by specification",
+        "          @Override public ListenableFuture<String> apply(List<Object> args)",
+        "              throws IOException {",
+        "            return module.produceString(",
+        "                (Integer) args.get(0),",
+        "                (Produced<Double>) args.get(1),",
+        "                cProducer,",
+        "                dProvider);",
+        "          }",
+        "        }, executor);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
+  @Test public void singleProducesMethodCheckedExceptionNoArgsFutureSet() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "import java.io.IOException;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces(type = Produces.Type.SET)",
+        "  ListenableFuture<String> produceString() throws IOException {",
+        "    return null;",
+        "  }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule$$ProduceStringFactory",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.Futures;",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.internal.AbstractProducer;",
+        "import dagger.producers.internal.Producers;",
+        "import java.io.IOException;",
+        "import java.util.Set;",
+        "import java.util.concurrent.Callable;",
+        "import java.util.concurrent.Executor;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule$$ProduceStringFactory",
+        "    extends AbstractProducer<Set<String>> {",
+        "  private final TestModule module;",
+        "  private final Executor executor;",
+        "",
+        "  public TestModule$$ProduceStringFactory(TestModule module, Executor executor) {  ",
+        "    assert module != null;",
+        "    this.module = module;",
+        "    assert executor != null;",
+        "    this.executor = executor;",
+        "  }",
+        "",
+        "  @Override",
+        "  protected ListenableFuture<Set<String>> compute() {  ",
+        "    ListenableFuture<ListenableFuture<Set<String>>> future =",
+        "        Producers.submitToExecutor(new Callable<ListenableFuture<Set<String>>>() {",
+        "      @Override public ListenableFuture<Set<String>> call() throws IOException {",
+        "        return Producers.createFutureSingletonSet(module.produceString());",
+        "      }",
+        "    }, executor);",
+        "    return Futures.dereference(future);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
new file mode 100644
index 000000000..ed29f0036
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+
+@RunWith(JUnit4.class)
+public class ProductionComponentProcessorTest {
+  @Test public void componentOnConcreteClass() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
+        "package test;",
+        "",
+        "import dagger.producers.ProductionComponent;",
+        "",
+        "@ProductionComponent",
+        "final class NotAComponent {}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("interface");
+  }
+
+  @Test public void componentOnEnum() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
+        "package test;",
+        "",
+        "import dagger.producers.ProductionComponent;",
+        "",
+        "@ProductionComponent",
+        "enum NotAComponent {",
+        "  INSTANCE",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("interface");
+  }
+
+  @Test public void componentOnAnnotation() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
+        "package test;",
+        "",
+        "import dagger.producers.ProductionComponent;",
+        "",
+        "@ProductionComponent",
+        "@interface NotAComponent {}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("interface");
+  }
+
+  @Test public void nonModuleModule() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
+        "package test;",
+        "",
+        "import dagger.producers.ProductionComponent;",
+        "",
+        "@ProductionComponent(modules = Object.class)",
+        "interface NotAComponent {}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("is not annotated with @Module or @ProducerModule");
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/writer/ClassNameTest.java b/compiler/src/test/java/dagger/internal/codegen/writer/ClassNameTest.java
index 3467b3570..518b85981 100644
--- a/compiler/src/test/java/dagger/internal/codegen/writer/ClassNameTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/writer/ClassNameTest.java
@@ -15,10 +15,9 @@
  */
 package dagger.internal.codegen.writer;
 
-import dagger.internal.codegen.writer.ClassNameTest.OuterClass.InnerClass;
-
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.CompilationRule;
+import dagger.internal.codegen.writer.ClassNameTest.OuterClass.InnerClass;
 import java.util.Map;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.Elements;
@@ -26,6 +25,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
+
 import static com.google.common.truth.Truth.assert_;
 import static org.junit.Assert.fail;
 
diff --git a/compiler/src/test/java/dagger/internal/codegen/writer/TypeNamesTest.java b/compiler/src/test/java/dagger/internal/codegen/writer/TypeNamesTest.java
index 39f40bff2..ec82e9605 100644
--- a/compiler/src/test/java/dagger/internal/codegen/writer/TypeNamesTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/writer/TypeNamesTest.java
@@ -27,7 +27,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assert_;
+import static com.google.common.truth.Truth.assertThat;
 
 @RunWith(JUnit4.class)
 public class TypeNamesTest {
@@ -43,11 +43,11 @@ private TypeMirror getType(Class<?> clazz) {
 
   @Test
   public void forTypeMirror_basicTypes() {
-    assert_().that(TypeNames.forTypeMirror(getType(Object.class)))
+    assertThat(TypeNames.forTypeMirror(getType(Object.class)))
         .isEqualTo(ClassName.fromClass(Object.class));
-    assert_().that(TypeNames.forTypeMirror(getType(Charset.class)))
+    assertThat(TypeNames.forTypeMirror(getType(Charset.class)))
         .isEqualTo(ClassName.fromClass(Charset.class));
-    assert_().that(TypeNames.forTypeMirror(getType(TypeNamesTest.class)))
+    assertThat(TypeNames.forTypeMirror(getType(TypeNamesTest.class)))
         .isEqualTo(ClassName.fromClass(TypeNamesTest.class));
   }
 
@@ -55,45 +55,52 @@ public void forTypeMirror_basicTypes() {
   public void forTypeMirror_parameterizedType() {
     DeclaredType setType =
         compilation.getTypes().getDeclaredType(getElement(Set.class), getType(Object.class));
-    assert_().that(TypeNames.forTypeMirror(setType))
+    assertThat(TypeNames.forTypeMirror(setType))
         .isEqualTo(ParameterizedTypeName.create(Set.class, ClassName.fromClass(Object.class)));
   }
 
+  @Test
+  public void forTypeMirror_typeVariables() {
+    TypeMirror setType = getType(Set.class);
+    assertThat(TypeNames.forTypeMirror(setType))
+        .isEqualTo(ParameterizedTypeName.create(Set.class, TypeVariableName.named("E")));
+  }
+
   @Test
   public void forTypeMirror_primitive() {
-    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.BOOLEAN)))
+    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.BOOLEAN)))
         .isEqualTo(PrimitiveName.BOOLEAN);
-    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.BYTE)))
+    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.BYTE)))
         .isEqualTo(PrimitiveName.BYTE);
-    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.SHORT)))
+    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.SHORT)))
         .isEqualTo(PrimitiveName.SHORT);
-    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.INT)))
+    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.INT)))
         .isEqualTo(PrimitiveName.INT);
-    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.LONG)))
+    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.LONG)))
         .isEqualTo(PrimitiveName.LONG);
-    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.CHAR)))
+    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.CHAR)))
         .isEqualTo(PrimitiveName.CHAR);
-    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.FLOAT)))
+    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.FLOAT)))
         .isEqualTo(PrimitiveName.FLOAT);
-    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.DOUBLE)))
+    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.DOUBLE)))
         .isEqualTo(PrimitiveName.DOUBLE);
   }
 
   @Test
   public void forTypeMirror_arrays() {
-    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getArrayType(getType(Object.class))))
+    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getArrayType(getType(Object.class))))
         .isEqualTo(new ArrayTypeName(ClassName.fromClass(Object.class)));
   }
 
   @Test
   public void forTypeMirror_void() {
-    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getNoType(TypeKind.VOID)))
+    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getNoType(TypeKind.VOID)))
         .isEqualTo(VoidName.VOID);
   }
 
   @Test
   public void forTypeMirror_null() {
-    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getNullType()))
+    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getNullType()))
         .isEqualTo(NullName.NULL);
   }
 }
diff --git a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
index 8ed583d10..427762409 100644
--- a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
@@ -97,7 +97,7 @@
       "  private void initialize() {",
       "    this.primitiveIntProvider = new PrimitiveModule$$PrimitiveIntFactory(primitiveModule);",
       "    this.primitiveInjectableProvider =",
-      "        new PrimitiveInjectable$$Factory(primitiveIntProvider);",
+      "        PrimitiveInjectable$$Factory.create(primitiveIntProvider);",
       "  }",
       "",
       "  @Override",
diff --git a/core/pom.xml b/core/pom.xml
index 3551075be..73da51c47 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -26,6 +26,11 @@
   <artifactId>dagger</artifactId>
   <name>Dagger</name>
 
+  <properties>
+    <!-- Runtime must remain Java6 to support android. -->
+    <java.version>1.6</java.version>
+  </properties>
+
   <dependencies>
     <dependency>
       <groupId>javax.inject</groupId>
@@ -64,7 +69,7 @@
         <configuration>
           <signature>
             <groupId>org.codehaus.mojo.signature</groupId>
-            <artifactId>java15</artifactId>
+            <artifactId>java16</artifactId>
             <version>1.0</version>
           </signature>
         </configuration>
diff --git a/core/src/main/java/dagger/MapKey.java b/core/src/main/java/dagger/MapKey.java
index 06c3b65d9..ca88661c9 100644
--- a/core/src/main/java/dagger/MapKey.java
+++ b/core/src/main/java/dagger/MapKey.java
@@ -15,13 +15,13 @@
  */
 package dagger;
 
-import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
+import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 /**
  * It enables to define customized key type annotation for map binding by
  * annotating an annotation of a {@code Map}'s key type. The defined key type
diff --git a/core/src/main/java/dagger/internal/DoubleCheckLazy.java b/core/src/main/java/dagger/internal/DoubleCheckLazy.java
index 29315d3af..6db11f381 100644
--- a/core/src/main/java/dagger/internal/DoubleCheckLazy.java
+++ b/core/src/main/java/dagger/internal/DoubleCheckLazy.java
@@ -25,30 +25,32 @@
  * @author Gregory Kick
  * @since 2.0
  */
+// TODO(gak): Unify the duplicated code between this and ScopedProvider.
 public final class DoubleCheckLazy<T> implements Lazy<T> {
+  private static final Object UNINITIALIZED = new Object();
+
   private final Provider<T> provider;
-  private volatile T instance = null;
+  private volatile Object instance = UNINITIALIZED;
 
   private DoubleCheckLazy(Provider<T> provider) {
     assert provider != null;
     this.provider = provider;
   }
 
+  @SuppressWarnings("unchecked") // cast only happens when result comes from the factory
   @Override
   public T get() {
-    T result = instance;
-    if (result == null) {
+    // to suppress it.
+    Object result = instance;
+    if (result == UNINITIALIZED) {
       synchronized (this) {
         result = instance;
-        if (result == null) {
+        if (result == UNINITIALIZED) {
           instance = result = provider.get();
-          if (result == null) {
-            throw new NullPointerException(provider + " returned null");
-          }
         }
       }
     }
-    return result;
+    return (T) result;
   }
 
   public static <T> Lazy<T> create(Provider<T> provider) {
diff --git a/core/src/main/java/dagger/internal/MembersInjectors.java b/core/src/main/java/dagger/internal/MembersInjectors.java
index 1b9bc105f..ee4c7b4cf 100644
--- a/core/src/main/java/dagger/internal/MembersInjectors.java
+++ b/core/src/main/java/dagger/internal/MembersInjectors.java
@@ -16,7 +16,6 @@
 package dagger.internal;
 
 import dagger.MembersInjector;
-
 import javax.inject.Inject;
 
 /**
diff --git a/core/src/main/java/dagger/internal/Memoizer.java b/core/src/main/java/dagger/internal/Memoizer.java
deleted file mode 100644
index 5b36208d8..000000000
--- a/core/src/main/java/dagger/internal/Memoizer.java
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal;
-
-import java.util.HashMap;
-import java.util.Map;
-import java.util.concurrent.locks.Lock;
-import java.util.concurrent.locks.ReadWriteLock;
-import java.util.concurrent.locks.ReentrantReadWriteLock;
-
-/**
- * An abstract supertype that provides
- * <a href="http://en.wikipedia.org/wiki/Memoize">memoization</a> for idempotent operations that
- * <i>may</i> be computed more than once, but for which performance is prohibitive. Subclasses
- * implement the {@link #create} method with the operation to be memoized, while callers invoke the
- * {@link #get} method to utilize the memoization.
- *
- * <p>Synchronization on this class is implemented using a {@link ReadWriteLock}. Multiple threads
- * may accessed previously memoized results without contention.
- *
- * <p>This class is implemented such that concurrent requests for the same key may result in
- * simultaneous computation in multiple threads - the instance of the result that is persisted for
- * subsequent invocations in not guaranteed.
- *
- * <p><b>Warning:</b> there is no eviction. Large input sets will result in growth without bound.
- */
-abstract class Memoizer<K, V> {
-  private final Map<K, V> map;
-  private final Lock readLock;
-  private final Lock writeLock;
-
-  Memoizer() {
-    // Don't use LinkedHashMap. This is a performance-oriented class and we don't want overhead
-    this.map = new HashMap<K, V>();
-    ReadWriteLock lock = new ReentrantReadWriteLock();
-    this.readLock = lock.readLock();
-    this.writeLock = lock.writeLock();
-  }
-
-  final V get(K key) {
-    if (key == null) {
-      throw new NullPointerException("key == null");
-    }
-
-    // check to see if we already have a value
-    readLock.lock();
-    try {
-      V value = map.get(key);
-      if (value != null) {
-        return value;
-      }
-    } finally {
-      readLock.unlock();
-    }
-
-    // create a new value.  this may race and we might create more than one instance, but that's ok
-    V newValue = create(key);
-    if (newValue == null) {
-      throw new NullPointerException("create returned null");
-    }
-
-    // write the new value and return it
-    writeLock.lock();
-    try {
-      map.put(key, newValue);
-      return newValue;
-    } finally {
-      writeLock.unlock();
-    }
-  }
-
-  abstract V create(K key);
-
-  @Override public final String toString() {
-    readLock.lock();
-    try {
-      return map.toString();
-    } finally {
-      readLock.unlock();
-    }
-  }
-}
diff --git a/core/src/test/java/dagger/internal/DoubleCheckLazyTest.java b/core/src/test/java/dagger/internal/DoubleCheckLazyTest.java
index 01790c787..684c2aff2 100644
--- a/core/src/test/java/dagger/internal/DoubleCheckLazyTest.java
+++ b/core/src/test/java/dagger/internal/DoubleCheckLazyTest.java
@@ -28,6 +28,7 @@
 import java.util.concurrent.Future;
 import java.util.concurrent.atomic.AtomicInteger;
 import javax.inject.Provider;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -65,7 +66,8 @@
     assert_().that(results.size()).is(1);
   }
 
-  @Test public void get_null() {
+  // TODO(gak): reenable this test once we can ensure that factories are no longer providing null
+  @Ignore @Test public void get_null() {
     Lazy<Object> lazy = DoubleCheckLazy.create(new Provider<Object> () {
       @Override public Object get() {
         return null;
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeActivity.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeActivity.java
index dd939d311..3b5b9c9ea 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeActivity.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeActivity.java
@@ -28,7 +28,7 @@
 
   @Override protected void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
-    Dagger_HomeActivity$HomeComponent.builder()
+    Dagger_HomeActivity_HomeComponent.builder()
         .applicationComponent(((DemoApplication) getApplication()).component())
         .activityModule(new ActivityModule(this))
         .build()
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication.java b/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication.java
index fbe08cc02..0a08d987b 100644
--- a/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication.java
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication.java
@@ -25,8 +25,10 @@
 import javax.inject.Singleton;
 
 public class DemoApplication extends Application {
+  
   @Singleton
-  @Component(modules = AndroidModule.class) interface ApplicationComponent {
+  @Component(modules = AndroidModule.class)
+  public interface ApplicationComponent {
     void inject(DemoApplication application);
     void inject(HomeActivity homeActivity);
     void inject(DemoActivity demoActivity);
@@ -38,7 +40,7 @@
 
   @Override public void onCreate() {
     super.onCreate();
-    component = Dagger_DemoApplication$ApplicationComponent.builder()
+    component = Dagger_DemoApplication_ApplicationComponent.builder()
         .androidModule(new AndroidModule(this))
         .build();
     component().inject(this); // As of now, LocationManager should be injected into this.
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/ui/HomeActivity.java b/examples/android-simple/src/main/java/com/example/dagger/simple/ui/HomeActivity.java
index dfdcbd895..7e33b8eec 100644
--- a/examples/android-simple/src/main/java/com/example/dagger/simple/ui/HomeActivity.java
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/ui/HomeActivity.java
@@ -17,7 +17,9 @@
 
 import android.location.LocationManager;
 import android.os.Bundle;
+import android.util.Log;
 import com.example.dagger.simple.DemoActivity;
+import com.example.dagger.simple.DemoApplication;
 import javax.inject.Inject;
 
 public class HomeActivity extends DemoActivity {
@@ -25,8 +27,9 @@
 
   @Override protected void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
-    // After the super.onCreate call returns we are guaranteed our injections are available.
+    ((DemoApplication) getApplication()).component().inject(this);
 
     // TODO do something with the injected dependencies here!
+    Log.d("HomeActivity", locationManager.toString());
   }
 }
diff --git a/examples/simple/src/main/java/coffee/CoffeeApp.java b/examples/simple/src/main/java/coffee/CoffeeApp.java
index ea1ed20e9..0789a86f1 100644
--- a/examples/simple/src/main/java/coffee/CoffeeApp.java
+++ b/examples/simple/src/main/java/coffee/CoffeeApp.java
@@ -11,7 +11,7 @@
   }
 
   public static void main(String[] args) {
-    Coffee coffee = Dagger_CoffeeApp$Coffee.builder().build();
+    Coffee coffee = Dagger_CoffeeApp_Coffee.builder().build();
     coffee.maker().brew();
   }
 }
diff --git a/examples/simple/src/main/java/coffee/CoffeeMaker.java b/examples/simple/src/main/java/coffee/CoffeeMaker.java
index 372bb3409..6410336d0 100644
--- a/examples/simple/src/main/java/coffee/CoffeeMaker.java
+++ b/examples/simple/src/main/java/coffee/CoffeeMaker.java
@@ -1,7 +1,6 @@
 package coffee;
 
 import dagger.Lazy;
-
 import javax.inject.Inject;
 
 class CoffeeMaker {
diff --git a/pom.xml b/pom.xml
index 9db58a1f4..38c463780 100644
--- a/pom.xml
+++ b/pom.xml
@@ -34,18 +34,19 @@
   <modules>
     <module>compiler</module>
     <module>core</module>
+    <module>producers</module>
   </modules>
 
   <properties>
     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
 
     <!-- Compilation -->
-    <java.version>1.6</java.version>
+    <java.version>1.7</java.version>
     <javax.inject.version>1</javax.inject.version>
     <javawriter.version>2.5.0</javawriter.version>
     <auto.common.version>1.0-SNAPSHOT</auto.common.version>
     <auto.service.version>1.0-rc1</auto.service.version>
-    <auto.value.version>1.0-SNAPSHOT</auto.value.version>
+    <auto.value.version>1.0</auto.value.version>
     <guava.version>18.0</guava.version>
 
     <!-- Test Dependencies -->
@@ -143,16 +144,17 @@
     <pluginManagement>
       <plugins>
         <plugin>
-          <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-invoker-plugin</artifactId>
           <version>1.7</version>
         </plugin>
-
         <plugin>
-          <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-compiler-plugin</artifactId>
           <version>3.1</version>
         </plugin>
+        <plugin>
+          <artifactId>maven-jar-plugin</artifactId>
+          <version>2.5</version>
+        </plugin>
       </plugins>
     </pluginManagement>
 
@@ -219,6 +221,7 @@
         <module>core</module>
         <module>compiler</module>
         <module>examples</module>
+        <module>producers</module>
       </modules>
     </profile>
   </profiles>
diff --git a/producers/pom.xml b/producers/pom.xml
new file mode 100644
index 000000000..1dda109a7
--- /dev/null
+++ b/producers/pom.xml
@@ -0,0 +1,53 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+ Copyright (C) 2014 Google, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.google.dagger</groupId>
+    <artifactId>dagger-parent</artifactId>
+    <version>2.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>dagger-producers</artifactId>
+  <name>Dagger Production Graphs</name>
+  <description>
+    An asynchronous dependency injection system that extends JSR-330.
+  </description>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>dagger</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.google.truth</groupId>
+      <artifactId>truth</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/producers/src/main/java/dagger/producers/Produced.java b/producers/src/main/java/dagger/producers/Produced.java
new file mode 100644
index 000000000..137244bad
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/Produced.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2014 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers;
+
+import java.util.concurrent.ExecutionException;
+
+/**
+ * An interface that represents the result of a {@linkplain Producer production} of type {@code T},
+ * or an exception that was thrown during that production. For any type {@code T} that can be
+ * injected, you can also inject {@code Produced<T>}, which enables handling of any exceptions that
+ * were thrown during the production of {@code T}.
+ *
+ * <p>For example: <pre>   {@code
+ *
+ *   @Produces Html getResponse(UserInfo criticalInfo, Produced<ExtraInfo> noncriticalInfo) {
+ *     try {
+ *       return new Html(criticalInfo, noncriticalInfo.get());
+ *     } catch (ExecutionException e) {
+ *       logger.warning(e, "Noncritical info");
+ *       return new Html(criticalInfo);
+ *     }
+ *   }}</pre>
+ *
+ * @author Jesse Beder
+ */
+public interface Produced<T> {
+  /**
+   * Returns the result of a production.
+   *
+   * @throws ExecutionException if the production threw an exception
+   */
+  T get() throws ExecutionException;
+}
diff --git a/producers/src/main/java/dagger/producers/Producer.java b/producers/src/main/java/dagger/producers/Producer.java
new file mode 100644
index 000000000..cccf78376
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/Producer.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2014 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers;
+
+import com.google.common.util.concurrent.ListenableFuture;
+
+/**
+ * An interface that represents the production of a type {@code T}. You can also inject
+ * {@code Producer<T>} instead of {@code T}, which will delay the execution of any code that
+ * produces the {@code T} until {@link #get} is called.
+ *
+ * <p>For example, you might inject {@code Producer} to lazily choose between several different
+ * implementations of some type: <pre>   {@code
+ *
+ *   @Produces ListenableFuture<Heater> getHeater(
+ *       HeaterFlag flag,
+ *       @Electric Producer<Heater> electricHeater,
+ *       @Gas Producer<Heater> gasHeater) {
+ *     return flag.useElectricHeater() ? electricHeater.get() : gasHeater.get();
+ *   }}</pre>
+ *
+ * <p>Here is a complete example that demonstrates how calling {@code get()} will cause each
+ * method to be executed: <pre>   {@code
+ *
+ *   @ProducerModule
+ *   final class MyModule {
+ *     @Produces ListenableFuture<A> a() {
+ *       System.out.println("a");
+ *       return Futures.immediateFuture(new A());
+ *     }
+ *
+ *     @Produces ListenableFuture<B> b(A a) {
+ *       System.out.println("b");
+ *       return Futures.immediateFuture(new B(a));
+ *     }
+ *
+ *     @Produces ListenableFuture<C> c(B b) {
+ *       System.out.println("c");
+ *       return Futures.immediateFuture(new C(b));
+ *     }
+ *
+ *     @Produces @Delayed ListenableFuture<C> delayedC(A a, Producer<C> c) {
+ *       System.out.println("delayed c");
+ *       return c.get();
+ *     }
+ *   }
+ *
+ *   @ProductionComponent(modules = MyModule.class)
+ *   interface MyComponent {
+ *     @Delayed ListenableFuture<C> delayedC();
+ *   }}</pre>
+ * Suppose we instantiate the generated implementation of this component and call
+ * {@code delayedC()}: <pre>   {@code
+ *
+ *   MyComponent component = Dagger_MyComponent
+ *       .builder()
+ *       .executor(MoreExecutors.directExecutor())
+ *       .build();
+ *   System.out.println("Constructed component");
+ *   ListenableFuture<C> cFuture = component.delayedC();
+ *   System.out.println("Retrieved future");
+ *   C c = cFuture.get();
+ *   System.out.println("Retrieved c");}</pre>
+ * Here, we're using {@code MoreExecutors.directExecutor} in order to illustrate how each call
+ * directly causes code to execute. The above code will print: <pre>   {@code
+ *   Constructed component
+ *   a
+ *   delayed c
+ *   b
+ *   c
+ *   Retrieved future
+ *   Retrieved c}</pre>
+ *
+ * @author Jesse Beder
+ */
+public interface Producer<T> {
+  /**
+   * Returns a future representing a running task that produces a value. Calling this method will
+   * trigger the submission of this task to the executor, if it has not already been triggered. In
+   * order to trigger this task's submission, the transitive dependencies required to produce the
+   * {@code T} will be submitted to the executor, as their dependencies become available.
+   *
+   * <p>If the key is bound to a {@link Produces} method, then calling this method multiple times
+   * will return the same future.
+   */
+  ListenableFuture<T> get();
+}
diff --git a/producers/src/main/java/dagger/producers/ProducerModule.java b/producers/src/main/java/dagger/producers/ProducerModule.java
new file mode 100644
index 000000000..f86cf12a3
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/ProducerModule.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2014 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers;
+
+import dagger.Module;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.TYPE;
+
+/**
+ * Annotates a class that contributes {@link Produces} bindings to the production component.
+ *
+ * @author Jesse Beder
+ */
+@Documented @Target(TYPE)
+public @interface ProducerModule {
+  /**
+   * Additional {@code @ProducerModule}- or {@link Module}-annotated classes from which this module
+   * is composed. The de-duplicated contributions of the modules in {@code includes}, and of their
+   * inclusions recursively, are all contributed to the object graph.
+   */
+  Class<?>[] includes() default {};
+}
diff --git a/producers/src/main/java/dagger/producers/Produces.java b/producers/src/main/java/dagger/producers/Produces.java
new file mode 100644
index 000000000..6f77c3c2d
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/Produces.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2014 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+/**
+ * Annotates methods of a producer module to create a production binding. If the method returns
+ * a {@link ListenableFuture}, then the parameter type of the future is bound to the value that the
+ * future provides; otherwise, the return type is bound to the returned value. The production
+ * component will pass dependencies to the method as parameters.
+ *
+ * @author Jesse Beder
+ */
+@Documented @Target(METHOD)
+public @interface Produces {
+  /** The type of binding into which the return type of the annotated method contributes. */
+  enum Type {
+    /**
+     * The method is the only one which can produce the value for the specified type. This is the
+     * default behavior.
+     */
+    UNIQUE,
+
+    /**
+     * The method's resulting type forms the generic type argument of a {@code Set<T>}, and the
+     * returned value or future is contributed to the set. The {@code Set<T>} produced from the
+     * accumulation of values will be immutable.
+     */
+    SET,
+
+    /**
+     * Like {@link #SET}, except the method's return type is either {@code Set<T>} or
+     * {@code Set<ListenableFuture<T>>}, where any values are contributed to the set. An example use
+     * is to provide a default empty set binding, which is otherwise not possible using
+     * {@link #SET}.
+     */
+    SET_VALUES,
+
+    /**
+     * The method's return type forms the type argument for the value of a
+     * {@code Map<K, Producer<V>>}, and the combination of the annotated key and the returned value
+     * is contributed to the map as a key/value pair. The {@code Map<K, Producer<V>>} produced from
+     * the accumulation of values will be immutable.
+     */
+    MAP;
+  }
+
+  Type type() default Type.UNIQUE;
+}
diff --git a/producers/src/main/java/dagger/producers/ProductionComponent.java b/producers/src/main/java/dagger/producers/ProductionComponent.java
new file mode 100644
index 000000000..b6376b0b0
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/ProductionComponent.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2014 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.Module;
+import dagger.Provides;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Target;
+import javax.inject.Inject;
+import javax.inject.Qualifier;
+
+import static java.lang.annotation.ElementType.TYPE;
+
+/**
+ * Annotates an interface or abstract class for which a fully-formed, dependency-injected
+ * implementation is to be generated from a set of {@linkplain #modules}. The generated class will
+ * have the name of the type annotated with {@code @ProductionComponent} prepended with
+ * {@code Dagger_}.  For example, {@code @ProductionComponent interface MyComponent {...}} will
+ * produce an implementation named {@code Dagger_MyComponent}.
+ *
+ * <p>Each {@link Produces} method that contributes to the component will be called at most once per
+ * component instance, no matter how many times that binding is used as a dependency.
+ * TODO(user): Decide on how scope works for producers.
+ *
+ * <h2>Component methods</h2>
+ *
+ * <p>Every type annotated with {@code @ProductionComponent} must contain at least one abstract
+ * component method. Component methods must represent {@linkplain Producer production}.
+ *
+ * Production methods have no arguments and return either a {@link ListenableFuture} or
+ * {@link Producer} of a type that is {@link Inject injected}, {@link Provides provided}, or
+ * {@link Produces produced}. Each may have a {@link Qualifier} annotation as well. The following
+ * are all valid production method declarations: <pre>   {@code
+ *
+ *   ListenableFuture<SomeType> getSomeType();
+ *   Producer<Set<SomeType>> getSomeTypes();
+ *   @Response ListenableFuture<Html> getResponse();}</pre>
+ *
+ * <h2>Exceptions</h2>
+ *
+ * <p>When a producer throws an exception, the exception will be propagated to its downstream
+ * producers in the following way: if the downstream producer injects a type {@code T}, then that
+ * downstream producer will be skipped, and the exception propagated to its downstream producers;
+ * and if the downstream producer injects a {@code Produced<T>}, then the downstream producer will
+ * be run with the exception stored in the {@code Produced<T>}.
+ *
+ * <p>If a non-execution exception is thrown (e.g., an {@code InterruptedException} or
+ * {@code CancellationException}), then exception is handled as in
+ * {@link com.google.common.util.concurrent.Futures#transform}.
+ * TODO(user): Explain this more thoroughly, and possibly update the javadocs of those utilities.
+ *
+ * @author Jesse Beder
+ */
+@Documented @Target(TYPE)
+public @interface ProductionComponent {
+  /**
+   * A list of classes annotated with {@link Module} or {@link ProducerModule} whose bindings are
+   * used to generate the component implementation.
+   */
+  Class<?>[] modules() default {};
+
+  /**
+   * A list of types that are to be used as component dependencies.
+   */
+  Class<?>[] dependencies() default {};
+}
diff --git a/producers/src/main/java/dagger/producers/internal/AbstractProducer.java b/producers/src/main/java/dagger/producers/internal/AbstractProducer.java
new file mode 100644
index 000000000..43659980b
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/internal/AbstractProducer.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.internal;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.Producer;
+
+/**
+ * An abstract {@link Producer} implementation that memoizes the result of its compute method.
+ *
+ * @author Jesse Beder
+ * @since 2.0
+ */
+public abstract class AbstractProducer<T> implements Producer<T> {
+  private volatile ListenableFuture<T> instance = null;
+
+  /** Computes this producer's future, which is then cached in {@link #get}. */
+  protected abstract ListenableFuture<T> compute();
+
+  @Override
+  public final ListenableFuture<T> get() {
+    // double-check idiom from EJ2: Item 71
+    ListenableFuture<T> result = instance;
+    if (result == null) {
+      synchronized (this) {
+        result = instance;
+        if (result == null) {
+          instance = result = compute();
+          if (result == null) {
+            throw new NullPointerException("compute returned null");
+          }
+        }
+      }
+    }
+    return result;
+  }
+}
diff --git a/producers/src/main/java/dagger/producers/internal/Producers.java b/producers/src/main/java/dagger/producers/internal/Producers.java
new file mode 100644
index 000000000..c850caa33
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/internal/Producers.java
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.internal;
+
+import com.google.common.base.Function;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.util.concurrent.FutureFallback;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.ListenableFutureTask;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import java.util.Set;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Executor;
+import java.util.concurrent.RejectedExecutionException;
+import javax.inject.Provider;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+/**
+ * Utility methods for use in generated producer code.
+ *
+ * @author Jesse Beder
+ * @since 2.0
+ */
+public final class Producers {
+  /**
+   * Returns a future of {@link Produced} that represents the completion (either success or failure)
+   * of the given future. If the input future succeeds, then the resulting future also succeeds with
+   * a successful {@code Produced}; if the input future fails, then the resulting future succeeds
+   * with a failing {@code Produced}.
+   *
+   * <p>Cancelling the resulting future will propagate the cancellation to the input future; but
+   * cancelling the input future will trigger the resulting future to succeed with a failing
+   * {@code Produced}.
+   */
+  // TODO(user): Document what happens with an InterruptedException after you figure out how to
+  // trigger one in a test.
+  public static <T> ListenableFuture<Produced<T>> createFutureProduced(ListenableFuture<T> future) {
+    return Futures.withFallback(
+        Futures.transform(future, new Function<T, Produced<T>>() {
+          @Override public Produced<T> apply(final T value) {
+            return new Produced<T>() {
+              @Override public T get() {
+                return value;
+              }
+            };
+          }
+        }), Producers.<T>futureFallbackForProduced());
+
+  }
+
+  private static final FutureFallback<Produced<Object>> FUTURE_FALLBACK_FOR_PRODUCED =
+      new FutureFallback<Produced<Object>>() {
+    @Override public ListenableFuture<Produced<Object>> create(final Throwable t) {
+      Produced<Object> produced = new Produced<Object>() {
+        @Override public Object get() throws ExecutionException {
+          throw new ExecutionException(t);
+        }
+      };
+      return Futures.immediateFuture(produced);
+    }
+  };
+
+  @SuppressWarnings({"unchecked", "rawtypes"})  // bivariant implementation
+  private static <T> FutureFallback<Produced<T>> futureFallbackForProduced() {
+    return (FutureFallback) FUTURE_FALLBACK_FOR_PRODUCED;
+  }
+
+  /**
+   * Returns a future of a {@code Set} that contains a single element: the result of the input
+   * future.
+   */
+  public static <T> ListenableFuture<Set<T>> createFutureSingletonSet(ListenableFuture<T> future) {
+    return Futures.transform(future, new Function<T, Set<T>>() {
+      @Override public Set<T> apply(T value) {
+        return ImmutableSet.of(value);
+      }
+    });
+  }
+
+  /**
+   * Submits a callable to an executor, returning the future representing the task. This mirrors
+   * {@link com.google.common.util.concurrent.ListeningExecutorService#submit}, but only requires an
+   * {@link Executor}.
+   *
+   * @throws RejectedExecutionException if this task cannot be accepted for execution.
+   */
+  public static <T> ListenableFuture<T> submitToExecutor(Callable<T> callable, Executor executor) {
+    ListenableFutureTask<T> future = ListenableFutureTask.create(callable);
+    executor.execute(future);
+    return future;
+  }
+
+  /**
+   * Returns a producer that immediately executes the binding logic for the given provider every
+   * time it is called.
+   */
+  public static <T> Producer<T> producerFromProvider(final Provider<T> provider) {
+    checkNotNull(provider);
+    return new AbstractProducer<T>() {
+      @Override protected ListenableFuture<T> compute() {
+        return Futures.immediateFuture(provider.get());
+      }
+    };
+  }
+
+  private Producers() {}
+}
diff --git a/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java b/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java
new file mode 100644
index 000000000..b7a17004a
--- /dev/null
+++ b/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.internal;
+
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.Producer;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+/**
+ * Tests {@link AbstractProducer}.
+ */
+@RunWith(JUnit4.class)
+public class AbstractProducerTest {
+  @Test public void get_nullPointerException() {
+    Producer<Object> producer = new AbstractProducer<Object>() {
+      @Override public ListenableFuture<Object> compute() {
+        return null;
+      }
+    };
+    try {
+      producer.get();
+      fail();
+    } catch (NullPointerException expected) {
+    }
+  }
+
+  @Test public void get() throws Exception {
+    Producer<Integer> producer = new AbstractProducer<Integer>() {
+      int i = 0;
+
+      @Override public ListenableFuture<Integer> compute() {
+        return Futures.immediateFuture(i++);
+      }
+    };
+    assertThat(producer.get().get()).is(0);
+    assertThat(producer.get().get()).is(0);
+    assertThat(producer.get().get()).is(0);
+  }
+}
diff --git a/producers/src/test/java/dagger/producers/internal/ProducersTest.java b/producers/src/test/java/dagger/producers/internal/ProducersTest.java
new file mode 100644
index 000000000..43564089f
--- /dev/null
+++ b/producers/src/test/java/dagger/producers/internal/ProducersTest.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.internal;
+
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.MoreExecutors;
+import com.google.common.util.concurrent.SettableFuture;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import java.util.Set;
+import java.util.concurrent.Callable;
+import java.util.concurrent.CancellationException;
+import java.util.concurrent.ExecutionException;
+import javax.inject.Provider;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+/**
+ * Tests {@link Producers}.
+ */
+@RunWith(JUnit4.class)
+public class ProducersTest {
+  @Test public void createFutureProduced_success() throws Exception {
+    ListenableFuture<String> future = Futures.immediateFuture("monkey");
+    ListenableFuture<Produced<String>> producedFuture = Producers.createFutureProduced(future);
+    assertThat(producedFuture.isDone()).isTrue();
+    assertThat(producedFuture.get().get()).isEqualTo("monkey");
+  }
+
+  @Test public void createFutureProduced_failure() throws Exception {
+    ListenableFuture<String> future = Futures.immediateFailedFuture(new RuntimeException("monkey"));
+    ListenableFuture<Produced<String>> producedFuture = Producers.createFutureProduced(future);
+    assertThat(producedFuture.isDone()).isTrue();
+    assertThat(getProducedException(producedFuture.get()).getCause()).hasMessage("monkey");
+  }
+
+  @Test public void createFutureProduced_cancelPropagatesBackwards() throws Exception {
+    ListenableFuture<String> future = SettableFuture.create();
+    ListenableFuture<Produced<String>> producedFuture = Producers.createFutureProduced(future);
+    assertThat(producedFuture.isDone()).isFalse();
+    producedFuture.cancel(false);
+    assertThat(future.isCancelled()).isTrue();
+  }
+
+  @Test public void createFutureProduced_cancelDoesNotPropagateForwards() throws Exception {
+    ListenableFuture<String> future = SettableFuture.create();
+    ListenableFuture<Produced<String>> producedFuture = Producers.createFutureProduced(future);
+    assertThat(producedFuture.isDone()).isFalse();
+    future.cancel(false);
+    assertThat(producedFuture.isCancelled()).isFalse();
+    assertThat(getProducedException(producedFuture.get()).getCause())
+        .isInstanceOf(CancellationException.class);
+  }
+
+  private <T> ExecutionException getProducedException(Produced<T> produced) {
+    try {
+      produced.get();
+      throw new IllegalArgumentException("produced did not throw");
+    } catch (ExecutionException e) {
+      return e;
+    }
+  }
+
+  @Test public void createFutureSingletonSet_success() throws Exception {
+    ListenableFuture<String> future = Futures.immediateFuture("monkey");
+    ListenableFuture<Set<String>> setFuture = Producers.createFutureSingletonSet(future);
+    assertThat(setFuture.isDone()).isTrue();
+    assertThat(setFuture.get()).containsExactly("monkey");
+  }
+
+  @Test public void createFutureSingletonSet_failure() throws Exception {
+    ListenableFuture<String> future = Futures.immediateFailedFuture(new RuntimeException("monkey"));
+    ListenableFuture<Set<String>> setFuture = Producers.createFutureSingletonSet(future);
+    assertThat(setFuture.isDone()).isTrue();
+    try {
+      setFuture.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).hasMessage("monkey");
+    }
+  }
+
+  @Test public void submitToExecutor() throws Exception {
+    ListenableFuture<Integer> future = Producers.submitToExecutor(new Callable<Integer>() {
+      @Override public Integer call() {
+        return 42;
+      }
+    }, MoreExecutors.directExecutor());
+    assertThat(future.isDone()).isTrue();
+    assertThat(future.get()).isEqualTo(42);
+  }
+
+  @Test public void producerFromProvider() throws Exception {
+    Producer<Integer> producer = Producers.producerFromProvider(new Provider<Integer>() {
+      int i = 0;
+
+      @Override public Integer get() {
+        return i++;
+      }
+    });
+    assertThat(producer.get().get()).isEqualTo(0);
+    assertThat(producer.get().get()).isEqualTo(0);
+    assertThat(producer.get().get()).isEqualTo(0);
+  }
+}
