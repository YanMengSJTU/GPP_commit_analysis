diff --git a/compiler/src/main/java/dagger/internal/codegen/ClassName.java b/compiler/src/main/java/dagger/internal/codegen/ClassName.java
index c3a58c110..a6bbde5e4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ClassName.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ClassName.java
@@ -124,7 +124,7 @@ static ClassName fromTypeElement(TypeElement element) {
     while (current.getKind().isClass() || current.getKind().isInterface()) {
       checkArgument(ACCEPTABLE_NESTING_KINDS.contains(element.getNestingKind()));
       enclosingNames.add(current.getSimpleName().toString());
-      current = element.getEnclosingElement();
+      current = current.getEnclosingElement();
     }
     PackageElement packageElement = Util.getPackage(current);
     Collections.reverse(enclosingNames);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 5bf939f7f..967ed8ff2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -223,6 +223,12 @@ ComponentDescriptor create(TypeElement componentDefinitionType) {
               if (injectBinding.isPresent()) {
                 requestsToResolve.addAll(injectBinding.get().dependencies());
                 resolvedProvisionBindings.put(key, injectBinding.get());
+                if (injectBinding.get().requiresMemberInjection()) {
+                  DependencyRequest forMembersInjectedType =
+                      dependencyRequestFactory.forMembersInjectedType(
+                          injectBinding.get().providedKey().type());
+                  requestsToResolve.add(forMembersInjectedType);
+                }
               } else {
                 // TODO(gak): support this
                 throw new UnsupportedOperationException(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 44b857116..88c6b8b0b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -15,27 +15,6 @@
  */
 package dagger.internal.codegen;
 
-import static com.google.common.base.CaseFormat.LOWER_CAMEL;
-import static com.google.common.base.Preconditions.checkNotNull;
-import static com.squareup.javawriter.JavaWriter.stringLiteral;
-import static dagger.Provides.Type.SET;
-import static dagger.Provides.Type.SET_VALUES;
-import static dagger.internal.codegen.DependencyRequest.Kind.MEMBERS_INJECTOR;
-import static dagger.internal.codegen.ProvisionBinding.Kind.COMPONENT;
-import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
-import static dagger.internal.codegen.SourceFiles.collectImportsFromDependencies;
-import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
-import static dagger.internal.codegen.SourceFiles.flattenVariableMap;
-import static dagger.internal.codegen.SourceFiles.generateMembersInjectorNamesForBindings;
-import static dagger.internal.codegen.SourceFiles.generateProviderNamesForBindings;
-import static dagger.internal.codegen.SourceFiles.membersInjectorNameForMembersInjectionBinding;
-import static dagger.internal.codegen.SourceFiles.providerUsageStatement;
-import static javax.lang.model.element.Modifier.ABSTRACT;
-import static javax.lang.model.element.Modifier.FINAL;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.PUBLIC;
-import static javax.lang.model.type.TypeKind.VOID;
-
 import com.google.common.base.CaseFormat;
 import com.google.common.base.Function;
 import com.google.common.base.Functions;
@@ -54,20 +33,17 @@
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import com.squareup.javawriter.JavaWriter;
-
 import dagger.Component;
 import dagger.MembersInjector;
 import dagger.internal.InstanceFactory;
 import dagger.internal.ScopedProvider;
 import dagger.internal.SetFactory;
-
 import java.io.IOException;
 import java.util.EnumSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
-
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
 import javax.inject.Provider;
@@ -77,10 +53,32 @@
 import javax.lang.model.element.Name;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
+import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.squareup.javawriter.JavaWriter.stringLiteral;
+import static dagger.Provides.Type.SET;
+import static dagger.Provides.Type.SET_VALUES;
+import static dagger.internal.codegen.DependencyRequest.Kind.MEMBERS_INJECTOR;
+import static dagger.internal.codegen.ProvisionBinding.Kind.COMPONENT;
+import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
+import static dagger.internal.codegen.SourceFiles.collectImportsFromDependencies;
+import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
+import static dagger.internal.codegen.SourceFiles.flattenVariableMap;
+import static dagger.internal.codegen.SourceFiles.generateMembersInjectorNamesForBindings;
+import static dagger.internal.codegen.SourceFiles.generateProviderNamesForBindings;
+import static dagger.internal.codegen.SourceFiles.membersInjectorNameForMembersInjectionBinding;
+import static dagger.internal.codegen.SourceFiles.providerUsageStatement;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.type.TypeKind.VOID;
+
 /**
  * Generates the implementation of the abstract types annotated with {@link Component}.
  *
@@ -90,11 +88,13 @@
 final class ComponentGenerator extends SourceFileGenerator<ComponentDescriptor> {
   private final Elements elements;
   private final Types types;
+  private final Key.Factory keyFactory;
 
-  ComponentGenerator(Filer filer, Elements elements, Types types) {
+  ComponentGenerator(Filer filer, Elements elements, Types types, Key.Factory keyFactory) {
     super(filer);
     this.elements = checkNotNull(elements);
     this.types = checkNotNull(types);
+    this.keyFactory = keyFactory;
   }
 
   @Override
@@ -176,6 +176,9 @@ private void writeImports(JavaWriter writer, ClassName factoryClassName,
       if (binding.provisionType().equals(SET) || binding.provisionType().equals(SET_VALUES)) {
         importsBuilder.add(ClassName.fromClass(SetFactory.class));
       }
+      if (binding.requiresMemberInjection()) {
+        importsBuilder.add(ClassName.fromClass(MembersInjector.class));
+      }
       for (TypeElement referencedType : MoreTypes.referencedTypes(binding.providedKey().type())) {
         ClassName className = ClassName.fromTypeElement(referencedType);
         if (!className.packageName().equals("java.lang")
@@ -279,7 +282,7 @@ public String apply(TypeElement input) {
     writer.endConstructor().emitEmptyLine();
   }
 
-  private static String initializeFactoryForBinding(JavaWriter writer, ProvisionBinding binding,
+  private String initializeFactoryForBinding(JavaWriter writer, ProvisionBinding binding,
       ImmutableBiMap<TypeElement, String> moduleNames,
       ImmutableBiMap<Key, String> providerNames,
       ImmutableBiMap<Key, String> membersInjectorNames) {
@@ -291,6 +294,15 @@ private static String initializeFactoryForBinding(JavaWriter writer, ProvisionBi
       if (binding.bindingKind().equals(PROVISION)) {
         parameters.add(moduleNames.get(binding.bindingTypeElement()));
       }
+      if (binding.requiresMemberInjection()) {
+        String membersInjectorName =
+            membersInjectorNames.get(keyFactory.forType(binding.providedKey().type()));
+        if (membersInjectorName != null) {
+          parameters.add(membersInjectorName);
+        } else {
+	    throw new UnsupportedOperationException("Non-generated MembersInjector");
+        }
+      }
       parameters.addAll(
           getDependencyParameters(binding.dependencies(), providerNames, membersInjectorNames));
       return String.format(
@@ -352,9 +364,7 @@ private void writeInterfaceMethods(JavaWriter writer,
 
   private JavaWriter beginMethodOverride(JavaWriter writer, ExecutableElement methodElement)
       throws IOException {
-    String returnTypeString = methodElement.getReturnType().getKind().equals(VOID)
-        ? "void"
-        : writer.compressType(Util.typeToString(methodElement.getReturnType()));
+    String returnTypeString = writer.compressType(returnTypeString(methodElement.getReturnType()));
     String methodName = methodElement.getSimpleName().toString();
     Set<Modifier> modifiers = Sets.difference(methodElement.getModifiers(), EnumSet.of(ABSTRACT));
     ImmutableList.Builder<String> parametersBuilder = ImmutableList.builder();
@@ -375,6 +385,18 @@ private JavaWriter beginMethodOverride(JavaWriter writer, ExecutableElement meth
             thrownTypesBuilder.build());
   }
 
+  private String returnTypeString(TypeMirror returnType) {
+    TypeKind returnTypeKind = returnType.getKind();
+    if (returnTypeKind.equals(VOID)) {
+      return "void";
+    } else if (returnTypeKind.isPrimitive()) {
+      // TypeMirrors don't have names but PrimitiveType#toString() reflects the simple type name.
+      return returnType.toString();
+    }
+    // Util.typeToString() does boxing, so cannot be used for primitive types.
+    return Util.typeToString(returnType);
+  }
+
   private String providerTypeString(Key key) {
     return Util.typeToString(types.getDeclaredType(
         elements.getTypeElement(Provider.class.getCanonicalName()), key.type()));
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index bdba18940..82a9f343a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -15,18 +15,13 @@
  */
 package dagger.internal.codegen;
 
-import static javax.lang.model.SourceVersion.RELEASE_6;
-
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
-
 import dagger.Component;
 import dagger.Module;
 import dagger.Provides;
 import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
-
 import java.util.Set;
-
 import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.Filer;
 import javax.annotation.processing.Messager;
@@ -38,6 +33,8 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
+import static javax.lang.model.SourceVersion.RELEASE_6;
+
 /**
  * The annotation processor responsible for generating the classes that drive the Dagger 2.0
  * implementation.
@@ -76,13 +73,14 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
     ProvidesMethodValidator providesMethodValidator = new ProvidesMethodValidator(elements);
     ComponentValidator componentValidator = new ComponentValidator(elements);
 
-    InjectBindingRegistry injectBindingRegistry = new InjectBindingRegistry();
-
     Key.Factory keyFactory = new Key.Factory(types, elements);
+
+    InjectBindingRegistry injectBindingRegistry = new InjectBindingRegistry(keyFactory);
+
     DependencyRequest.Factory dependencyRequestFactory =
-        new DependencyRequest.Factory(elements, types);
+        new DependencyRequest.Factory(elements, types, keyFactory);
     ProvisionBinding.Factory provisionBindingFactory =
-        new ProvisionBinding.Factory(keyFactory, dependencyRequestFactory);
+        new ProvisionBinding.Factory(elements, types, keyFactory, dependencyRequestFactory);
     InjectionSite.Factory injectionSiteFactory =
         new InjectionSite.Factory(dependencyRequestFactory);
     ComponentDescriptor.Factory componentDescriptorFactory =
@@ -92,7 +90,8 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
     FactoryGenerator factoryGenerator = new FactoryGenerator(filer, elements, types);
     MembersInjectorGenerator membersInjectorGenerator =
         new MembersInjectorGenerator(filer, elements, types);
-    ComponentGenerator componentGenerator = new ComponentGenerator(filer, elements, types);
+    ComponentGenerator componentGenerator =
+        new ComponentGenerator(filer, elements, types, keyFactory);
 
     this.processingSteps = ImmutableList.<ProcessingStep>of(
         new InjectProcessingStep(
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index 6cdbaf7ba..e960aa07c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -15,22 +15,16 @@
  */
 package dagger.internal.codegen;
 
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
-
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
-
 import dagger.Lazy;
 import dagger.MembersInjector;
 import dagger.Provides;
-
 import java.util.List;
-
 import javax.inject.Inject;
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
@@ -42,6 +36,9 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+
 
 /**
  * Represents a request for a key at an injection point. Parameters to {@link Inject} constructors
@@ -71,10 +68,12 @@
   static final class Factory {
     private final Elements elements;
     private final Types types;
+    private final Key.Factory keyFactory;
 
-    Factory(Elements elements, Types types) {
+    Factory(Elements elements, Types types, Key.Factory keyFactory) {
       this.elements = elements;
       this.types = types;
+      this.keyFactory = keyFactory;
     }
 
     ImmutableList<DependencyRequest> forRequiredVariables(
@@ -108,34 +107,43 @@ DependencyRequest forComponentMembersInjectionMethod(ExecutableElement membersIn
           InjectionAnnotations.getQualifier(membersInjectionMethod);
       checkArgument(!qualifier.isPresent());
       return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR,
-          Key.create(qualifier,
+          keyFactory.forQualifiedType(qualifier,
               Iterables.getOnlyElement(membersInjectionMethod.getParameters()).asType()),
           membersInjectionMethod);
     }
 
+    DependencyRequest forMembersInjectedType(TypeMirror type) {
+      return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR, keyFactory.forType(type),
+          types.asElement(type));
+    }
+
     private DependencyRequest newDependencyRequest(Element requestElement, TypeMirror type,
         Optional<AnnotationMirror> qualifier) {
       if (elements.getTypeElement(Provider.class.getCanonicalName())
           .equals(types.asElement(type))) {
         DeclaredType providerType = (DeclaredType) type;
         return new AutoValue_DependencyRequest(Kind.PROVIDER,
-            Key.create(qualifier, Iterables.getOnlyElement(providerType.getTypeArguments())),
+            keyFactory.forQualifiedType(qualifier,
+                Iterables.getOnlyElement(providerType.getTypeArguments())),
             requestElement);
       } else if (elements.getTypeElement(Lazy.class.getCanonicalName())
           .equals(types.asElement(type))) {
         DeclaredType lazyType = (DeclaredType) type;
         return new AutoValue_DependencyRequest(Kind.LAZY,
-            Key.create(qualifier, Iterables.getOnlyElement(lazyType.getTypeArguments())),
+            keyFactory.forQualifiedType(qualifier,
+                Iterables.getOnlyElement(lazyType.getTypeArguments())),
             requestElement);
       } else if (elements.getTypeElement(MembersInjector.class.getCanonicalName())
           .equals(types.asElement(type))) {
         checkArgument(!qualifier.isPresent());
         DeclaredType membersInjectorType = (DeclaredType) type;
         return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR,
-            Key.create(qualifier, Iterables.getOnlyElement(membersInjectorType.getTypeArguments())),
+            keyFactory.forQualifiedType(qualifier,
+                Iterables.getOnlyElement(membersInjectorType.getTypeArguments())),
             requestElement);
       } else {
-        return new AutoValue_DependencyRequest(Kind.INSTANCE, Key.create(qualifier, type),
+        return new AutoValue_DependencyRequest(Kind.INSTANCE,
+            keyFactory.forQualifiedType(qualifier, type),
             requestElement);
       }
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index 7cd6c8421..e4fb2586e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -15,16 +15,14 @@
  */
 package dagger.internal.codegen;
 
-import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.base.Preconditions.checkState;
-
 import com.google.common.base.Optional;
 import com.google.common.collect.Maps;
-
 import java.util.Map;
-
 import javax.inject.Inject;
 
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
+
 /**
  * Maintains the collection of provision bindings from {@link Inject} constructors and members
  * injection bindings from {@link Inject} fields and methods known to the annotation processor.
@@ -34,10 +32,12 @@
 final class InjectBindingRegistry {
   private final Map<Key, ProvisionBinding> provisionBindingsByKey;
   private final Map<Key, MembersInjectionBinding> membersInjectionBindingsByKey;
+  private final Key.Factory keyFactory;
 
-  InjectBindingRegistry() {
+  InjectBindingRegistry(Key.Factory keyFactory) {
     this.provisionBindingsByKey = Maps.newLinkedHashMap();
     this.membersInjectionBindingsByKey = Maps.newLinkedHashMap();
+    this.keyFactory = keyFactory;
   }
 
   void registerProvisionBinding(ProvisionBinding binding) {
@@ -47,7 +47,7 @@ void registerProvisionBinding(ProvisionBinding binding) {
 
   void registerMembersInjectionBinding(MembersInjectionBinding binding) {
     MembersInjectionBinding previousValue = membersInjectionBindingsByKey.put(
-        Key.create(binding.injectedType().asType()), binding);
+        keyFactory.forType(binding.injectedType().asType()), binding);
     checkState(previousValue == null);
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index f7ab2aa23..216fcb2fd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -15,32 +15,30 @@
  */
 package dagger.internal.codegen;
 
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
-import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
-import static javax.lang.model.element.ElementKind.METHOD;
-import static javax.lang.model.type.TypeKind.DECLARED;
-
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Objects;
 import com.google.common.base.Optional;
-
 import dagger.Provides;
-
 import java.util.Set;
-
 import javax.inject.Qualifier;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
+import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
+import static javax.lang.model.element.ElementKind.METHOD;
+import static javax.lang.model.type.TypeKind.DECLARED;
+
 /**
  * Represents a unique combination of {@linkplain TypeMirror type} and
  * {@linkplain Qualifier qualifier} to which binding can occur.
@@ -49,11 +47,17 @@
  */
 @AutoValue
 abstract class Key {
+  /**
+   * A {@link javax.inject.Qualifier} annotation that provides a unique namespace prefix
+   * for the type of this key.
+   */
   abstract Optional<AnnotationMirror> qualifier();
 
   /**
+   * The type represented by this key.
+   *
    * As documented in {@link TypeMirror}, equals and hashCode aren't implemented to represent
-   * logical equality, so we use {@link MoreTypes#equivalence()} for this object.
+   * logical equality, so {@link MoreTypes#equivalence()} wraps this type.
    */
   abstract Equivalence.Wrapper<TypeMirror> wrappedType();
 
@@ -70,15 +74,6 @@ public String toString() {
         .toString();
   }
 
-  static Key create(TypeMirror type) {
-    return new AutoValue_Key(Optional.<AnnotationMirror>absent(),
-        MoreTypes.equivalence().wrap(type));
-  }
-
-  static Key create(Optional<AnnotationMirror> qualifier, TypeMirror type) {
-    return new AutoValue_Key(qualifier, MoreTypes.equivalence().wrap(type));
-  }
-
   static final class Factory {
     private final Types types;
     private final Elements elements;
@@ -90,7 +85,7 @@ static Key create(Optional<AnnotationMirror> qualifier, TypeMirror type) {
 
     private TypeMirror normalize(TypeMirror type) {
       TypeKind kind = type.getKind();
-      return kind.isPrimitive() ? types.getPrimitiveType(kind) : type;
+      return kind.isPrimitive() ? types.boxedClass((PrimitiveType) type).asType() : type;
     }
 
     private TypeElement getSetElement() {
@@ -129,5 +124,14 @@ Key forInjectConstructor(ExecutableElement e) {
       return new AutoValue_Key(Optional.<AnnotationMirror>absent(),
           MoreTypes.equivalence().wrap(type));
     }
+
+    Key forType(TypeMirror type) {
+      return new AutoValue_Key(Optional.<AnnotationMirror>absent(),
+          MoreTypes.equivalence().wrap(normalize(type)));
+    }
+
+    Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
+      return new AutoValue_Key(qualifier, MoreTypes.equivalence().wrap(normalize(type)));
+    }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index 51655087d..f65289bed 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -26,6 +26,7 @@
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
 
+import com.google.auto.common.MoreElements;
 import com.google.common.base.Function;
 import com.google.common.base.Functions;
 import com.google.common.base.Joiner;
@@ -33,6 +34,7 @@
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableBiMap;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSortedSet;
 import com.google.common.collect.Iterables;
@@ -57,7 +59,9 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.Name;
+import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
@@ -108,11 +112,18 @@ void write(ClassName injectorClassName, JavaWriter writer, MembersInjectionBindi
     writer.emitPackage(injectedClassName.packageName());
 
     ImmutableSet<DependencyRequest> dependencies = binding.dependencySet();
+    Optional<TypeElement> supertype = supertype(binding.injectedType());
 
     List<ClassName> importsBuilder = new ArrayList<ClassName>();
     importsBuilder.addAll(collectImportsFromDependencies(injectorClassName, dependencies));
     importsBuilder.add(ClassName.fromClass(MembersInjector.class));
     importsBuilder.add(ClassName.fromClass(Generated.class));
+    if (supertype.isPresent()) {
+      ClassName supertypeClassName = ClassName.fromTypeElement(supertype.get());
+      if (!supertypeClassName.packageName().equals(injectorClassName.packageName())) {
+        importsBuilder.add(supertypeClassName);
+      }
+    }
     ImmutableSortedSet<String> imports = FluentIterable.from(importsBuilder)
         .transform(Functions.toStringFunction())
         .toSortedSet(Ordering.natural());
@@ -128,15 +139,16 @@ void write(ClassName injectorClassName, JavaWriter writer, MembersInjectionBindi
         .beginType(injectorClassName.simpleName(), "class", EnumSet.of(FINAL), null,
             membersInjectorType);
 
-
     final ImmutableBiMap<Key, String> providerNames =
         generateProviderNamesForDependencies(dependencies);
 
+    writeSupertypeInjectorField(writer, supertype);
+
     // Add the fields
     writeProviderFields(writer, providerNames);
 
     // Add the constructor
-    writeConstructor(writer, providerNames);
+    writeConstructor(writer, supertype, providerNames);
 
     // @Override public void injectMembers(Blah instance)
     writer.emitAnnotation(Override.class)
@@ -149,6 +161,10 @@ void write(ClassName injectorClassName, JavaWriter writer, MembersInjectionBindi
             "throw new NullPointerException(\"Cannot inject members into a null reference\")")
         .endControlFlow();
 
+    if (supertype.isPresent()) {
+      writer.emitStatement("supertypeInjector.injectMembers(instance)");
+    }
+
     for (InjectionSite injectionSite : binding.injectionSites()) {
       switch (injectionSite.kind()) {
         case FIELD:
@@ -179,6 +195,23 @@ void write(ClassName injectorClassName, JavaWriter writer, MembersInjectionBindi
     writer.endType();
   }
 
+  private Optional<TypeElement> supertype(TypeElement type) {
+    TypeMirror superclass = type.getSuperclass();
+    boolean nonObjectSuperclass = !types.isSameType(
+        elements.getTypeElement(Object.class.getCanonicalName()).asType(), superclass);
+    return nonObjectSuperclass
+        ? Optional.of(MoreElements.asType(types.asElement(superclass)))
+        : Optional.<TypeElement>absent();
+  }
+
+  private void writeSupertypeInjectorField(JavaWriter writer, Optional<TypeElement> supertype)
+      throws IOException {
+    if (supertype.isPresent()) {
+      writer.emitField(type(MembersInjector.class, supertype.get().getQualifiedName().toString()),
+          "supertypeInjector", EnumSet.of(PRIVATE, FINAL));
+    }
+  }
+
   private void writeProviderFields(JavaWriter writer, ImmutableBiMap<Key, String> providerNames)
       throws IOException {
     for (Entry<Key, String> providerEntry : providerNames.entrySet()) {
@@ -191,11 +224,21 @@ private void writeProviderFields(JavaWriter writer, ImmutableBiMap<Key, String>
     writer.emitEmptyLine();
   }
 
-  private void writeConstructor(JavaWriter writer, ImmutableBiMap<Key, String> providerNames)
-      throws IOException {
+  private void writeConstructor(JavaWriter writer, Optional<TypeElement> supertype,
+      ImmutableBiMap<Key, String> providerNames) throws IOException {
+    ImmutableMap.Builder<String, String> variableMapBuilder = ImmutableMap.builder();
+    if (supertype.isPresent()) {
+      variableMapBuilder.put("supertypeInjector",
+          type(MembersInjector.class, supertype.get().getQualifiedName().toString()));
+    }
+    variableMapBuilder.putAll(providersAsVariableMap(providerNames));
     writer.beginConstructor(EnumSet.noneOf(Modifier.class),
-        flattenVariableMap(providersAsVariableMap(providerNames)),
+        flattenVariableMap(variableMapBuilder.build()),
         ImmutableList.<String>of());
+    if (supertype.isPresent()) {
+      writer.emitStatement("assert %s != null", "supertypeInjector");
+      writer.emitStatement("this.%1$s = %1$s", "supertypeInjector");
+    }
     for (String providerName : providerNames.values()) {
       writer.emitStatement("assert %s != null", providerName);
       writer.emitStatement("this.%1$s = %1$s", providerName);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 5be75d01b..c3276c1f7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -15,34 +15,33 @@
  */
 package dagger.internal.codegen;
 
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.collect.Sets.immutableEnumSet;
-import static dagger.Provides.Type.SET;
-import static dagger.Provides.Type.SET_VALUES;
-import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
-import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
-import static javax.lang.model.element.ElementKind.FIELD;
-import static javax.lang.model.element.ElementKind.METHOD;
-
 import com.google.auto.common.MoreElements;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
-
 import dagger.Component;
 import dagger.Provides;
-
 import java.util.Iterator;
-
 import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.collect.Sets.immutableEnumSet;
+import static dagger.Provides.Type.SET;
+import static dagger.Provides.Type.SET_VALUES;
+import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
+import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
+import static javax.lang.model.element.ElementKind.FIELD;
+import static javax.lang.model.element.ElementKind.METHOD;
 
 /**
  * A value object representing the mechanism by which a {@link Key} can be provided. New instances
@@ -102,10 +101,15 @@ static boolean isSetBindingCollection(Iterable<ProvisionBinding> bindings) {
   }
 
   static final class Factory {
+    private final Elements elements;
+    private final Types types;
     private final Key.Factory keyFactory;
     private final DependencyRequest.Factory dependencyRequestFactory;
 
-    Factory(Key.Factory keyFactory, DependencyRequest.Factory dependencyRequestFactory) {
+    Factory(Elements elements, Types types, Key.Factory keyFactory,
+        DependencyRequest.Factory dependencyRequestFactory) {
+      this.elements = elements;
+      this.types = types;
       this.keyFactory = keyFactory;
       this.dependencyRequestFactory = dependencyRequestFactory;
     }
@@ -130,7 +134,11 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement) {
     private static final ImmutableSet<ElementKind> MEMBER_KINDS =
         Sets.immutableEnumSet(METHOD, FIELD);
 
-    private static boolean requiresMemeberInjection(TypeElement type) {
+    private boolean requiresMemeberInjection(TypeElement type) {
+      if (!types.isSameType(elements.getTypeElement(Object.class.getCanonicalName()).asType(),
+          type.getSuperclass())) {
+        return true;
+      }
       for (Element enclosedElement : type.getEnclosedElements()) {
         if (MEMBER_KINDS.contains(enclosedElement.getKind())
             && (enclosedElement.getAnnotation(Inject.class) != null)) {
@@ -164,7 +172,7 @@ ProvisionBinding forComponent(TypeElement componentDefinitionType) {
           ImmutableList.<DependencyRequest>of(),
           Kind.COMPONENT,
           Provides.Type.UNIQUE,
-          Key.create(componentDefinitionType.asType()),
+          keyFactory.forType(componentDefinitionType.asType()),
           Optional.<AnnotationMirror>absent(),
           false);
     }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index e6640f1a1..7d13efcca 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -482,4 +482,64 @@
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
   }
+
+  @Test public void membersInjectionInsideProvision() {
+    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class SomeInjectableType {",
+        "  @Inject SomeInjectableType() {}",
+        "}");
+    JavaFileObject injectedTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectedType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class SomeInjectedType {",
+        "  @Inject SomeInjectableType injectedField;",
+        "  @Inject SomeInjectedType() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface SimpleComponent {",
+        "  SomeInjectedType createAndInject();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.Dagger_SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_SimpleComponent implements SimpleComponent {",
+        "  private final Provider<SomeInjectableType> someInjectableTypeProvider;",
+        "  private final Provider<SomeInjectedType> someInjectedTypeProvider;",
+        "  private final MembersInjector<SomeInjectedType> someInjectedTypeMembersInjector;",
+        "",
+        "  public Dagger_SimpleComponent() {",
+        "    this.someInjectableTypeProvider = new SomeInjectableType$$Factory();",
+        "    this.someInjectedTypeMembersInjector = ",
+        "        new SomeInjectedType$$MembersInjector(someInjectableTypeProvider);",
+        "    this.someInjectedTypeProvider = ",
+        "        new SomeInjectedType$$Factory(someInjectedTypeMembersInjector);",
+        "  }",
+        "",
+        "  @Override public SomeInjectedType createAndInject() {",
+        "    return someInjectedTypeProvider.get();",
+        "  }",
+        "}");
+    ASSERT.about(javaSources())
+        .that(ImmutableList.of(injectableTypeFile, injectedTypeFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java
index 329e5dc48..335d82a37 100644
--- a/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java
@@ -529,4 +529,96 @@
         .and()
         .generatesSources(expectedFactory, expectedMembersInjector);
   }
+
+  @Test public void supertypeRequiresMemberInjection() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "class A {}");
+    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class B extends A {",
+        "  @Inject B() {}",
+        "}");
+    JavaFileObject expectedFactory = JavaFileObjects.forSourceLines(
+        "test.B$$Factory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class B$$Factory implements Factory<B> {",
+        "",
+        "  private final MembersInjector<B> membersInjector;",
+        "",
+        "  public B$$Factory(MembersInjector<B> membersInjector) {",
+        "    assert membersInjector != null;",
+        "    this.membersInjector = membersInjector;",
+        "  }",
+        "",
+        "  @Override public B get() {",
+        "    B instance = new B();",
+        "    membersInjector.injectMembers(instance);",
+        "    return instance;",
+        "  }",
+        "}");
+    ASSERT.about(javaSources()).that(ImmutableList.of(aFile, bFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expectedFactory);
+  }
+
+  @Test public void supertypeMembersInjection() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "class A {}");
+    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class B extends A {",
+        "  @Inject String s;",
+        "}");
+    JavaFileObject expectedMembersInjector = JavaFileObjects.forSourceLines(
+        "test.AllInjections$$MembersInjector",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "final class B$$MembersInjector ",
+        "    implements MembersInjector<B> {",
+        "",
+        "  private final MembersInjector<A> supertypeInjector;",
+        "  private final Provider<String> sProvider;",
+        "",
+        "  B$$MembersInjector(MembersInjector<A> supertypeInjector, Provider<String> sProvider) {",
+        "    assert supertypeInjector != null;",
+        "    this.supertypeInjector = supertypeInjector;",
+        "    assert sProvider != null;",
+        "    this.sProvider = sProvider;",
+        "  }",
+        "",
+        "  @Override public void injectMembers(B instance) {",
+        "    if (instance == null) {",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+        "    }",
+        "    supertypeInjector.injectMembers(instance);",
+        "    instance.s = sProvider.get();",
+        "  }",
+        "}");
+    ASSERT.about(javaSources()).that(ImmutableList.of(aFile, bFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expectedMembersInjector);
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
index f903d3050..fc7a911f6 100644
--- a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
@@ -15,18 +15,12 @@
  */
 package dagger.internal.codegen;
 
-import static dagger.Provides.Type.SET;
-import static dagger.Provides.Type.SET_VALUES;
-import static org.truth0.Truth.ASSERT;
-
 import com.google.common.collect.Iterables;
 import com.google.testing.compile.CompilationRule;
-
 import dagger.Module;
 import dagger.Provides;
-
+import java.util.List;
 import java.util.Set;
-
 import javax.inject.Inject;
 import javax.inject.Qualifier;
 import javax.lang.model.element.ExecutableElement;
@@ -36,13 +30,16 @@
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
-
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+import static dagger.Provides.Type.SET;
+import static dagger.Provides.Type.SET_VALUES;
+import static org.truth0.Truth.ASSERT;
+
 /**
  * Tests {@link Key}.
  */
@@ -50,10 +47,14 @@
 public class KeyTest {
   @Rule public CompilationRule compilationRule = new CompilationRule();
 
+  private Elements elements;
+  private Types types;
   private Key.Factory keyFactory;
 
   @Before public void setUp() {
-    this.keyFactory = new Key.Factory(compilationRule.getTypes(), compilationRule.getElements());
+    this.elements = compilationRule.getElements();
+    this.types = compilationRule.getTypes();
+    this.keyFactory = new Key.Factory(types, elements);
   }
 
   @Test public void forInjectConstructor() {
@@ -62,7 +63,7 @@
     ExecutableElement constructor =
         Iterables.getOnlyElement(ElementFilter.constructorsIn(typeElement.getEnclosedElements()));
     ASSERT.that(keyFactory.forInjectConstructor(constructor))
-        .isEqualTo(Key.create(typeElement.asType()));
+        .isEqualTo(keyFactory.forType(typeElement.asType()));
   }
 
   static final class InjectedClass {
@@ -71,13 +72,13 @@
   }
 
   @Test public void forProvidesMethod() {
-    Elements elements = compilationRule.getElements();
     TypeMirror stringType = elements.getTypeElement(String.class.getCanonicalName()).asType();
     TypeElement moduleElement =
         elements.getTypeElement(ProvidesMethodModule.class.getCanonicalName());
     ExecutableElement providesMethod =
         Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
-    ASSERT.that(keyFactory.forProvidesMethod(providesMethod)).isEqualTo(Key.create(stringType));
+    ASSERT.that(keyFactory.forProvidesMethod(providesMethod))
+        .isEqualTo(keyFactory.forType(stringType));
   }
 
   @Module(library = true)
@@ -88,7 +89,6 @@
   }
 
   @Test public void forProvidesMethod_qualified() {
-    Elements elements = compilationRule.getElements();
     TypeMirror stringType = elements.getTypeElement(String.class.getCanonicalName()).asType();
     TypeElement qualifierElement =
         elements.getTypeElement(TestQualifier.class.getCanonicalName());
@@ -113,8 +113,6 @@
   @interface TestQualifier {}
 
   @Test public void forProvidesMethod_sets() {
-    Elements elements = compilationRule.getElements();
-    Types types = compilationRule.getTypes();
     TypeElement setElement = elements.getTypeElement(Set.class.getCanonicalName());
     TypeMirror stringType = elements.getTypeElement(String.class.getCanonicalName()).asType();
     DeclaredType setOfStringsType = types.getDeclaredType(setElement, stringType);
@@ -123,7 +121,7 @@
     for (ExecutableElement providesMethod
         : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {
       ASSERT.that(keyFactory.forProvidesMethod(providesMethod))
-          .isEqualTo(Key.create(setOfStringsType));
+          .isEqualTo(keyFactory.forType(setOfStringsType));
     }
   }
 
@@ -137,4 +135,25 @@
       return null;
     }
   }
+
+  interface PrimitiveTypes {
+    int foo();
+    Integer bar();
+  }
+
+  @Test public void primitiveKeysMatchBoxedKeys() {
+    TypeElement holder = elements.getTypeElement(PrimitiveTypes.class.getCanonicalName());
+    List<ExecutableElement> methods = (List<ExecutableElement>) holder.getEnclosedElements();
+
+    // TODO(cgruber): Truth subject for TypeMirror and TypeElement
+    TypeMirror intType = methods.get(0).getReturnType();
+    ASSERT.that(intType.getKind().isPrimitive()).isTrue();
+    TypeMirror integerType = methods.get(1).getReturnType();
+    ASSERT.that(integerType.getKind().isPrimitive()).isFalse();
+    ASSERT.that(types.isSameType(intType, integerType)).named("type equality").isFalse();
+
+    Key intKey = keyFactory.forType(intType);
+    Key integerKey = keyFactory.forType(integerType);
+    ASSERT.that(intKey).isEqualTo(integerKey);
+  }
 }
diff --git a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
index 6b6bbf81c..9f83b1c1a 100644
--- a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
@@ -16,49 +16,92 @@
  */
 package dagger.tests.integration.operation;
 
-import dagger.Module;
-import dagger.ObjectGraph;
-import dagger.Provides;
-import javax.inject.Inject;
+import com.google.testing.compile.JavaFileObjects;
+import dagger.internal.codegen.ComponentProcessor;
+import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static org.fest.assertions.Assertions.assertThat;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static java.util.Arrays.asList;
+import static org.truth0.Truth.ASSERT;
 
 @RunWith(JUnit4.class)
 public final class PrimitiveInjectionTest {
-  static class ArrayInjectable {
-    @Inject byte[] byteArray;
-    @Inject int[] integerArray;
-    @Inject boolean[] booleanArray;
-    @Inject char[] charArray;
-    @Inject long[] longArray;
-    @Inject float[] floatArray;
-    @Inject double[] doubleArray;
-  }
 
-  @Module(injects = ArrayInjectable.class)
-  static class PrimitiveArrayModule {
-    @Provides byte[] byteArray() { return new byte[] { Byte.MAX_VALUE }; }
-    @Provides int[] intArray() { return new int[] { Integer.MAX_VALUE }; }
-    @Provides boolean[] booleanArray() { return new boolean[] { true }; }
-    @Provides long[] longArray() { return new long[] { Long.MAX_VALUE }; }
-    @Provides char[] charArray() { return new char[] { Character.MAX_VALUE }; }
-    @Provides float[] floatArray() { return new float[] { Float.MAX_VALUE }; }
-    @Provides double[] doubleArray() { return new double[] { Double.MAX_VALUE }; }
-  }
+  // TODO(cgruber): Use @test.ForTest to qualify primitives once qualifier equivalence is working.
+  /*
+  JavaFileObject annotation = JavaFileObjects.forSourceLines("test.ForTest",
+      "package test;",
+      "import javax.inject.Qualifier;",
+      "@Qualifier",
+      "public @interface ForTest {",
+      "}");
+  */
+
+  // TODO(cgruber): Expand test to support more primitive types when b/15512877 is fixed.
+  JavaFileObject primitiveInjectable = JavaFileObjects.forSourceLines("test.PrimitiveInjectable",
+      "package test;",
+      "import javax.inject.Inject;",
+      "class PrimitiveInjectable {",
+      "  @Inject PrimitiveInjectable(int ignored) {}",
+      "}");
+
+  JavaFileObject primitiveModule = JavaFileObjects.forSourceLines("test.PrimitiveModule",
+      "package test;",
+      "import dagger.Module;",
+      "import dagger.Provides;",
+      "@Module",
+      "class PrimitiveModule {",
+      "  @Provides int primitiveInt() { return Integer.MAX_VALUE; }",
+      "}");
+
+  JavaFileObject component = JavaFileObjects.forSourceLines("test.PrimitiveComponent",
+      "package test;",
+      "import dagger.Component;",
+      "import dagger.Provides;",
+      "@Component(modules = PrimitiveModule.class)",
+      "interface PrimitiveComponent {",
+      "  int primitiveInt();",
+      "  PrimitiveInjectable primitiveInjectable();",
+      "}");
+
+  JavaFileObject expectedComponent = JavaFileObjects.forSourceLines(
+      "test.Dagger_PrimitiveComponent",
+      "package test;",
+      "import javax.annotation.Generated;",
+      "import javax.inject.Provider;",
+      "",
+      "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+      "public final class Dagger_PrimitiveComponent implements PrimitiveComponent {",
+      "  private final PrimitiveModule primitiveModule;",
+      "  private final Provider<PrimitiveInjectable> primitiveInjectableProvider;",
+      "  private final Provider<Integer> primitiveIntProvider;",
+      "  public Dagger_PrimitiveComponent(PrimitiveModule primitiveModule) {",
+      "    if (primitiveModule == null) {",
+      "      throw new NullPointerException(\"primitiveModule\");",
+      "    }",
+      "    this.primitiveModule = primitiveModule;",
+      "    this.primitiveIntProvider = new PrimitiveModule$$PrimitiveIntFactory(primitiveModule);",
+      "    this.primitiveInjectableProvider = ",
+      "        new PrimitiveInjectable$$Factory(primitiveIntProvider);",
+      "  }",
+      "  @Override",
+      "  public int primitiveInt() {",
+      "    return primitiveIntProvider.get();",
+      "  }",
+      "  @Override",
+      "  public PrimitiveInjectable primitiveInjectable() {",
+      "    return primitiveInjectableProvider.get();",
+      "  }",
+      "}");
 
   @Test public void primitiveArrayTypesAllInjected() {
-    ArrayInjectable result = ObjectGraph.create(PrimitiveArrayModule.class)
-        .get(ArrayInjectable.class);
-    assertThat(result).isNotNull();
-    assertThat(result.byteArray).isEqualTo(new byte[] { Byte.MAX_VALUE });
-    assertThat(result.integerArray).isEqualTo(new int[] { Integer.MAX_VALUE });
-    assertThat(result.booleanArray).isEqualTo(new boolean[] { true });
-    assertThat(result.charArray).isEqualTo(new char[] { Character.MAX_VALUE });
-    assertThat(result.longArray).isEqualTo(new long[] { Long.MAX_VALUE });
-    assertThat(result.floatArray).isEqualTo(new float[] { Float.MAX_VALUE });
-    assertThat(result.doubleArray).isEqualTo(new double[] { Double.MAX_VALUE });
+    ASSERT.about(javaSources())
+        .that(asList(component, primitiveInjectable, primitiveModule))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expectedComponent);
   }
 }
