diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 88de072ae..f348a2551 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -293,6 +293,7 @@ java_library(
     srcs = [
         "BindingGraphConverter.java",
         "BindingGraphFactory.java",
+        "BindingGraphPlugins.java",
         "BindingGraphPluginsModule.java",
         "BindingMethodValidatorsModule.java",
         "CanReleaseReferencesProcessingStep.java",
diff --git a/java/dagger/internal/codegen/BindingGraphPlugins.java b/java/dagger/internal/codegen/BindingGraphPlugins.java
new file mode 100644
index 000000000..f21abac4f
--- /dev/null
+++ b/java/dagger/internal/codegen/BindingGraphPlugins.java
@@ -0,0 +1,113 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+import static java.lang.annotation.ElementType.FIELD;
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Maps;
+import dagger.internal.codegen.DiagnosticReporterFactory.DiagnosticReporterImpl;
+import dagger.model.BindingGraph;
+import dagger.spi.BindingGraphPlugin;
+import dagger.spi.DiagnosticReporter;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import java.util.Map;
+import java.util.Set;
+import javax.annotation.processing.Filer;
+import javax.inject.Qualifier;
+import javax.inject.Singleton;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+import javax.tools.Diagnostic;
+
+/** The set of SPI and validation plugins. */
+@Singleton
+final class BindingGraphPlugins {
+
+  @Qualifier
+  @Retention(RUNTIME)
+  @Target({FIELD, PARAMETER, METHOD})
+  @interface TestingPlugins {}
+
+  private final ImmutableSet<BindingGraphPlugin> plugins;
+  private final Filer filer;
+  private final Types types;
+  private final Elements elements;
+  private final Map<String, String> processingOptions;
+  private final DiagnosticReporterFactory diagnosticReporterFactory;
+
+  BindingGraphPlugins(
+      Iterable<BindingGraphPlugin> plugins,
+      Filer filer,
+      Types types,
+      Elements elements,
+      Map<String, String> processingOptions,
+      DiagnosticReporterFactory diagnosticReporterFactory) {
+    this.plugins = ImmutableSet.copyOf(plugins);
+    this.filer = checkNotNull(filer);
+    this.types = checkNotNull(types);
+    this.elements = checkNotNull(elements);
+    this.processingOptions = checkNotNull(processingOptions);
+    this.diagnosticReporterFactory = checkNotNull(diagnosticReporterFactory);
+  }
+
+  /** Returns {@link BindingGraphPlugin#supportedOptions()} from all the plugins. */
+  ImmutableSet<String> allSupportedOptions() {
+    return plugins
+        .stream()
+        .flatMap(plugin -> plugin.supportedOptions().stream())
+        .collect(toImmutableSet());
+  }
+
+  /** Initializes the plugins. */
+  void initializePlugins() {
+    plugins.forEach(this::initializePlugin);
+  }
+
+  private void initializePlugin(BindingGraphPlugin plugin) {
+    plugin.initFiler(filer);
+    plugin.initTypes(types);
+    plugin.initElements(elements);
+    Set<String> supportedOptions = plugin.supportedOptions();
+    if (!supportedOptions.isEmpty()) {
+      plugin.initOptions(Maps.filterKeys(processingOptions, supportedOptions::contains));
+    }
+  }
+
+  /**
+   * Calls {@link BindingGraphPlugin#visitGraph(BindingGraph, DiagnosticReporter)} on each of the
+   * SPI plugins
+   *
+   * @return the kinds of diagnostics that were reported
+   */
+  // TODO(ronshapiro): Should we validate the uniqueness of plugin names?
+  ImmutableSet<Diagnostic.Kind> visitGraph(BindingGraph graph) {
+    ImmutableSet.Builder<Diagnostic.Kind> diagnosticKinds = ImmutableSet.builder();
+    for (BindingGraphPlugin plugin : plugins) {
+      DiagnosticReporterImpl reporter = diagnosticReporterFactory.reporter(graph, plugin);
+      plugin.visitGraph(graph, reporter);
+      diagnosticKinds.addAll(reporter.reportedDiagnosticKinds());
+    }
+    return diagnosticKinds.build();
+  }
+}
diff --git a/java/dagger/internal/codegen/BindingGraphPluginsModule.java b/java/dagger/internal/codegen/BindingGraphPluginsModule.java
index b64d914c0..0f34c7608 100644
--- a/java/dagger/internal/codegen/BindingGraphPluginsModule.java
+++ b/java/dagger/internal/codegen/BindingGraphPluginsModule.java
@@ -16,12 +16,13 @@
 
 package dagger.internal.codegen;
 
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Maps;
+import com.google.common.collect.ImmutableSet;
 import dagger.Module;
 import dagger.Provides;
+import dagger.internal.codegen.BindingGraphPlugins.TestingPlugins;
 import dagger.spi.BindingGraphPlugin;
 import java.util.Map;
+import java.util.Optional;
 import java.util.ServiceLoader;
 import java.util.Set;
 import javax.annotation.processing.Filer;
@@ -29,31 +30,45 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
-/**
- * Provides and configures the {@link BindingGraphPlugin}s available on the annotation processing
- * path.
- */
+/** Contains the bindings for {@link BindingGraphPlugins}. */
 @Module
-interface BindingGraphPluginsModule {
+abstract class BindingGraphPluginsModule {
+  private BindingGraphPluginsModule() {}
+
   @Provides
   @Singleton
-  static ImmutableList<BindingGraphPlugin> bindingGraphPlugins(
+  static BindingGraphPlugins spiPlugins(
+      @TestingPlugins Optional<ImmutableSet<BindingGraphPlugin>> testingPlugins,
       Filer filer,
       Types types,
       Elements elements,
-      @ProcessingOptions Map<String, String> processingOptions) {
-    ClassLoader classLoader = BindingGraphPluginsModule.class.getClassLoader();
-    ImmutableList<BindingGraphPlugin> bindingGraphPlugins =
-        ImmutableList.copyOf(ServiceLoader.load(BindingGraphPlugin.class, classLoader));
-    for (BindingGraphPlugin plugin : bindingGraphPlugins) {
-      plugin.initFiler(filer);
-      plugin.initTypes(types);
-      plugin.initElements(elements);
-      Set<String> supportedOptions = plugin.supportedOptions();
-      if (!supportedOptions.isEmpty()) {
-        plugin.initOptions(Maps.filterKeys(processingOptions, supportedOptions::contains));
-      }
-    }
-    return bindingGraphPlugins;
+      @ProcessingOptions Map<String, String> processingOptions,
+      DiagnosticReporterFactory diagnosticReporterFactory) {
+    return new BindingGraphPlugins(
+        testingPlugins.orElseGet(BindingGraphPluginsModule::loadPlugins),
+        filer,
+        types,
+        elements,
+        processingOptions,
+        diagnosticReporterFactory);
+  }
+
+  @Provides
+  @Singleton
+  @Validation
+  static BindingGraphPlugins validationPlugins(
+      @Validation Set<BindingGraphPlugin> validationPlugins,
+      Filer filer,
+      Types types,
+      Elements elements,
+      @ProcessingOptions Map<String, String> processingOptions,
+      DiagnosticReporterFactory diagnosticReporterFactory) {
+    return new BindingGraphPlugins(
+        validationPlugins, filer, types, elements, processingOptions, diagnosticReporterFactory);
+  }
+
+  private static ImmutableSet<BindingGraphPlugin> loadPlugins() {
+    return ImmutableSet.copyOf(
+        ServiceLoader.load(BindingGraphPlugin.class, BindingGraphPlugins.class.getClassLoader()));
   }
 }
diff --git a/java/dagger/internal/codegen/ComponentProcessingStep.java b/java/dagger/internal/codegen/ComponentProcessingStep.java
index 7a0cf5bf1..17d06dc7c 100644
--- a/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -22,7 +22,6 @@
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.auto.common.MoreElements;
 import com.google.common.base.Predicates;
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Multimaps;
@@ -30,11 +29,8 @@
 import dagger.Component;
 import dagger.Subcomponent;
 import dagger.internal.codegen.ComponentValidator.ComponentValidationReport;
-import dagger.internal.codegen.DiagnosticReporterFactory.DiagnosticReporterImpl;
 import dagger.producers.ProductionComponent;
 import dagger.producers.ProductionSubcomponent;
-import dagger.spi.BindingGraphPlugin;
-import dagger.spi.DiagnosticReporter;
 import java.lang.annotation.Annotation;
 import java.util.Map;
 import java.util.Set;
@@ -42,7 +38,6 @@
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
-import javax.tools.Diagnostic;
 
 /**
  * A {@link ProcessingStep} that is responsible for dealing with a component or production component
@@ -58,9 +53,8 @@
   private final BindingGraphFactory bindingGraphFactory;
   private final ComponentGenerator componentGenerator;
   private final BindingGraphConverter bindingGraphConverter;
-  private final ImmutableSet<BindingGraphPlugin> validationPlugins;
-  private final ImmutableList<BindingGraphPlugin> spiPlugins;
-  private final DiagnosticReporterFactory diagnosticReporterFactory;
+  private final BindingGraphPlugins validationPlugins;
+  private final BindingGraphPlugins spiPlugins;
 
   @Inject
   ComponentProcessingStep(
@@ -72,10 +66,9 @@
       ComponentDescriptor.Factory componentDescriptorFactory,
       BindingGraphFactory bindingGraphFactory,
       ComponentGenerator componentGenerator,
-      @Validation Set<BindingGraphPlugin> validationPlugins,
       BindingGraphConverter bindingGraphConverter,
-      ImmutableList<BindingGraphPlugin> spiPlugins,
-      DiagnosticReporterFactory diagnosticReporterFactory) {
+      @Validation BindingGraphPlugins validationPlugins,
+      BindingGraphPlugins spiPlugins) {
     this.messager = messager;
     this.componentValidator = componentValidator;
     this.builderValidator = builderValidator;
@@ -84,10 +77,9 @@
     this.componentDescriptorFactory = componentDescriptorFactory;
     this.bindingGraphFactory = bindingGraphFactory;
     this.componentGenerator = componentGenerator;
-    this.validationPlugins = ImmutableSet.copyOf(validationPlugins);
     this.bindingGraphConverter = bindingGraphConverter;
+    this.validationPlugins = validationPlugins;
     this.spiPlugins = spiPlugins;
-    this.diagnosticReporterFactory = diagnosticReporterFactory;
   }
 
   @Override
@@ -166,29 +158,10 @@ private boolean isValid(BindingGraph bindingGraph) {
     graphReport.printMessagesTo(messager);
 
     dagger.model.BindingGraph modelGraph = bindingGraphConverter.convert(bindingGraph);
-    if (executePlugins(modelGraph, validationPlugins).contains(ERROR) || !graphReport.isClean()) {
+    if (validationPlugins.visitGraph(modelGraph).contains(ERROR) || !graphReport.isClean()) {
       return false;
     }
-    return !executePlugins(modelGraph, spiPlugins).contains(ERROR);
-  }
-
-  /**
-   * Calls {@link BindingGraphPlugin#visitGraph(dagger.model.BindingGraph, DiagnosticReporter)} on
-   * each of {@code plugins}.
-   *
-   * @return the kinds of diagnostics that were reported
-   */
-  private ImmutableSet<Diagnostic.Kind> executePlugins(
-      dagger.model.BindingGraph graph, Iterable<BindingGraphPlugin> plugins) {
-    // TODO(ronshapiro): Should we validate the uniqueness of plugin names?
-    ImmutableSet.Builder<Diagnostic.Kind> diagnosticKinds = ImmutableSet.builder();
-    for (BindingGraphPlugin plugin : plugins) {
-      DiagnosticReporterImpl reporter = diagnosticReporterFactory.reporter(graph, plugin);
-      plugin.visitGraph(graph, reporter);
-      diagnosticKinds.addAll(reporter.reportedDiagnosticKinds());
-    }
-
-    return diagnosticKinds.build();
+    return !spiPlugins.visitGraph(modelGraph).contains(ERROR);
   }
 
   private void generateComponent(BindingGraph bindingGraph) {
diff --git a/java/dagger/internal/codegen/ComponentProcessor.java b/java/dagger/internal/codegen/ComponentProcessor.java
index f14d046cc..0614a7873 100644
--- a/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/java/dagger/internal/codegen/ComponentProcessor.java
@@ -18,6 +18,7 @@
 
 import com.google.auto.common.BasicAnnotationProcessor;
 import com.google.auto.service.AutoService;
+import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
@@ -28,8 +29,11 @@
 import dagger.Component;
 import dagger.Module;
 import dagger.Provides;
+import dagger.internal.codegen.BindingGraphPlugins.TestingPlugins;
 import dagger.spi.BindingGraphPlugin;
+import java.util.Arrays;
 import java.util.Map;
+import java.util.Optional;
 import java.util.Set;
 import javax.annotation.processing.Filer;
 import javax.annotation.processing.Messager;
@@ -45,14 +49,44 @@
  * The annotation processor responsible for generating the classes that drive the Dagger 2.0
  * implementation.
  *
- * TODO(gak): give this some better documentation
+ * <p>TODO(gak): give this some better documentation
  */
 @AutoService(Processor.class)
-public final class ComponentProcessor extends BasicAnnotationProcessor {
+public class ComponentProcessor extends BasicAnnotationProcessor {
+  private final Optional<ImmutableSet<BindingGraphPlugin>> testingPlugins;
+
   @Inject InjectBindingRegistry injectBindingRegistry;
   @Inject FactoryGenerator factoryGenerator;
   @Inject MembersInjectorGenerator membersInjectorGenerator;
-  @Inject ImmutableList<BindingGraphPlugin> bindingGraphPlugins;
+  @Inject ImmutableList<ProcessingStep> processingSteps;
+  @Inject BindingGraphPlugins spiPlugins;
+  @Inject @Validation BindingGraphPlugins validationPlugins;
+
+  public ComponentProcessor() {
+    this.testingPlugins = Optional.empty();
+  }
+
+  private ComponentProcessor(Iterable<BindingGraphPlugin> testingPlugins) {
+    this.testingPlugins = Optional.of(ImmutableSet.copyOf(testingPlugins));
+  }
+
+  /**
+   * Creates a component processor that uses given {@link BindingGraphPlugin}s instead of loading
+   * them from a {@link java.util.ServiceLoader}.
+   */
+  @VisibleForTesting
+  public static ComponentProcessor forTesting(BindingGraphPlugin... testingPlugins) {
+    return forTesting(Arrays.asList(testingPlugins));
+  }
+
+  /**
+   * Creates a component processor that uses given {@link BindingGraphPlugin}s instead of loading
+   * them from a {@link java.util.ServiceLoader}.
+   */
+  @VisibleForTesting
+  public static ComponentProcessor forTesting(Iterable<BindingGraphPlugin> testingPlugins) {
+    return new ComponentProcessor(testingPlugins);
+  }
 
   @Override
   public SourceVersion getSupportedSourceVersion() {
@@ -63,9 +97,8 @@ public SourceVersion getSupportedSourceVersion() {
   public Set<String> getSupportedOptions() {
     ImmutableSet.Builder<String> options = ImmutableSet.builder();
     options.addAll(CompilerOptions.SUPPORTED_OPTIONS);
-    for (BindingGraphPlugin plugin : bindingGraphPlugins) {
-      options.addAll(plugin.supportedOptions());
-    }
+    options.addAll(spiPlugins.allSupportedOptions());
+    options.addAll(validationPlugins.allSupportedOptions());
     return options.build();
   }
 
@@ -81,7 +114,8 @@ public SourceVersion getSupportedSourceVersion() {
             .sourceVersion(processingEnv.getSourceVersion())
             .messager(messager)
             .processingOptions(processingEnv.getOptions())
-            .compilerOptions(compilerOptions);
+            .compilerOptions(compilerOptions)
+            .testingPlugins(testingPlugins);
 
     Filer filer;
     if (compilerOptions.headerCompilation()) {
@@ -92,7 +126,9 @@ public SourceVersion getSupportedSourceVersion() {
 
     ProcessorComponent component = builder.build();
     component.inject(this);
-    return component.processingSteps();
+    spiPlugins.initializePlugins();
+    validationPlugins.initializePlugins();
+    return processingSteps;
   }
 
   @Singleton
@@ -106,7 +142,6 @@ public SourceVersion getSupportedSourceVersion() {
   )
   interface ProcessorComponent {
     void inject(ComponentProcessor processor);
-    ImmutableList<ProcessingStep> processingSteps();
 
     @CanIgnoreReturnValue
     @Component.Builder
@@ -121,6 +156,11 @@ public SourceVersion getSupportedSourceVersion() {
 
       @BindsInstance Builder compilerOptions(CompilerOptions compilerOptions);
       @BindsInstance Builder processingOptions(@ProcessingOptions Map<String, String> options);
+
+      @BindsInstance
+      Builder testingPlugins(
+          @TestingPlugins Optional<ImmutableSet<BindingGraphPlugin>> testingPlugins);
+
       @CheckReturnValue ProcessorComponent build();
     }
   }
