diff --git a/.travis.yml b/.travis.yml
index a04b263a0..2f56dbd00 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -11,12 +11,12 @@ android:
   licenses:
     - android-sdk-license-5be876d5
 
-install: mvn install clean --fail-never --quiet -DskipTests=true -Dinvoker.skip=true
+install: mvn -P!standard-with-extra-repos -U install clean --fail-never --quiet -DskipTests=true -Dinvoker.skip=true
 
-script: mvn verify
+script: mvn -P!standard-with-extra-repos -U verify
 
 notifications:
-  email: false
+  email: dagger-firehose@googlegroups.com
 
 branches:
   except:
diff --git a/compiler/pom.xml b/compiler/pom.xml
index 8b7120a5b..ce817e7c9 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -40,6 +40,11 @@
       <groupId>com.google.auto</groupId>
       <artifactId>auto-common</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.auto.service</groupId>
+      <artifactId>auto-service</artifactId>
+      <optional>true</optional>
+    </dependency>
     <dependency>
       <groupId>com.squareup</groupId>
       <artifactId>javawriter</artifactId>
@@ -49,16 +54,10 @@
       <artifactId>guava</artifactId>
     </dependency>
 
-    <dependency>
-      <groupId>com.google.auto.service</groupId>
-      <artifactId>auto-service</artifactId>
-      <scope>provided</scope> <!-- to leave out of the all-deps jar -->
-    </dependency>
     <dependency>
       <groupId>com.google.auto.value</groupId>
       <artifactId>auto-value</artifactId>
-      <version>1.0-rc1</version>
-      <scope>provided</scope> <!-- to leave out of the all-deps jar -->
+      <optional>true</optional>
     </dependency>
 
     <dependency>
@@ -104,27 +103,28 @@
     <plugins>
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-invoker-plugin</artifactId>
-        <configuration>
-          <addTestClassPath>true</addTestClassPath>
-          <cloneProjectsTo>${project.build.directory}/it</cloneProjectsTo>
-          <pomIncludes>
-            <pomInclude>*/pom.xml</pomInclude>
-          </pomIncludes>
-          <localRepositoryPath>${project.build.directory}/local-repo</localRepositoryPath>
-          <postBuildHookScript>verify</postBuildHookScript>
-          <filterProperties>
-            <dagger.version>${project.version}</dagger.version>
-            <dagger.groupId>${project.groupId}</dagger.groupId>
-          </filterProperties>
-        </configuration>
+        <artifactId>maven-compiler-plugin</artifactId>
         <executions>
           <execution>
-            <id>integration-test</id>
-            <goals>
-              <goal>install</goal>
-              <goal>run</goal>
-            </goals>
+            <id>default-compile</id>
+            <goals><goal>compile</goal></goals>
+            <configuration>
+              <annotationProcessors>
+                <annotationProcessor>com.google.auto.value.processor.AutoValueProcessor</annotationProcessor>
+              </annotationProcessors>
+            </configuration>
+          </execution>
+          <execution>
+            <id>default-test-compile</id>
+            <goals><goal>testCompile</goal></goals>
+            <configuration>
+              <annotationProcessors>
+                <annotationProcessor>dagger.internal.codegen.dagger1.ValidationProcessor</annotationProcessor>
+                <annotationProcessor>dagger.internal.codegen.dagger1.InjectAdapterProcessor</annotationProcessor>
+                <annotationProcessor>dagger.internal.codegen.dagger1.ModuleAdapterProcessor</annotationProcessor>
+                <annotationProcessor>dagger.internal.codegen.dagger1.GraphAnalysisProcessor</annotationProcessor>
+              </annotationProcessors>
+            </configuration>
           </execution>
         </executions>
       </plugin>
diff --git a/compiler/src/it/missing-at-inject-constructor/src/main/java/test/TestApp.java b/compiler/src/it/missing-at-inject-constructor/src/main/java/test/TestApp.java
index 43fda9f84..935218f8f 100644
--- a/compiler/src/it/missing-at-inject-constructor/src/main/java/test/TestApp.java
+++ b/compiler/src/it/missing-at-inject-constructor/src/main/java/test/TestApp.java
@@ -34,7 +34,7 @@ public static void main(String[] args) {
   
   static class Dependency {
     // missing @Inject Dependency() {}
-    public void doit() { throw new AssertionError(); }
+    public void doit() { throw AssertionError(); };
   }
   
   @Module(injects = TestApp.class)
diff --git a/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java b/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java
index f7b67d6fd..e87afb0e1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java
@@ -17,21 +17,27 @@
 
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Equivalence;
-import com.google.common.base.Objects;
+import com.google.common.base.Predicate;
+import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Maps;
+import java.lang.annotation.Annotation;
+import java.util.Arrays;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkNotNull;
 
 /**
@@ -72,21 +78,22 @@
   }
 
   private static final Equivalence<AnnotationMirror> ANNOTATION_MIRROR_EQUIVALENCE =
-    new Equivalence<AnnotationMirror>() {
-      @Override protected boolean doEquivalent(AnnotationMirror left, AnnotationMirror right) {
-        return MoreTypes.equivalence()
-            .equivalent(left.getAnnotationType(), right.getAnnotationType())
-            && AnnotationValues.equivalence().pairwise().equivalent(
-                getAnnotationValuesWithDefaults(left),
-                getAnnotationValuesWithDefaults(right));
-      }
-
-      @Override protected int doHash(AnnotationMirror annotation) {
-        DeclaredType type = annotation.getAnnotationType();
-        Iterable<AnnotationValue> annotationValues = getAnnotationValuesWithDefaults(annotation);
-        return Objects.hashCode(type,
-            AnnotationValues.equivalence().pairwise().hash(annotationValues));
-      }
+      new Equivalence<AnnotationMirror>() {
+        @Override
+        protected boolean doEquivalent(AnnotationMirror left, AnnotationMirror right) {
+          return MoreTypes.equivalence().equivalent(left.getAnnotationType(),
+              right.getAnnotationType()) && AnnotationValues.equivalence().pairwise().equivalent(
+              getAnnotationValuesWithDefaults(left).values(),
+              getAnnotationValuesWithDefaults(right).values());
+        }
+        @Override
+        protected int doHash(AnnotationMirror annotation) {
+          DeclaredType type = annotation.getAnnotationType();
+          Iterable<AnnotationValue> annotationValues =
+              getAnnotationValuesWithDefaults(annotation).values();
+          return Arrays.hashCode(new int[] {MoreTypes.equivalence().hash(type),
+              AnnotationValues.equivalence().pairwise().hash(annotationValues)});
+        }
     };
 
   /**
@@ -95,8 +102,8 @@
    * states that instance/reference equality is not the proper test.
    *
    * Note: The contract of this equivalence is not quite that described in the javadoc, as
-   * hashcode values returned by {@link Equivalence#hash(T)} are not the same as would
-   * be returned from {@link AnnotationMirror#hashCode()}, though the proper invariants
+   * hash code values returned by {@link Equivalence#hash} are not the same as would
+   * be returned from {@link AnnotationMirror#hashCode}, though the proper invariants
    * relating hashCode() and equals() hold for {@code hash(T)} and {@code equivalent(T, T)}.
    */
   static Equivalence<AnnotationMirror> equivalence() {
@@ -110,16 +117,31 @@
    * {@link Elements#getElementValuesWithDefaults(AnnotationMirror)} but can be called
    * statically without an {@Elements} instance.
    */
-  static Iterable<AnnotationValue> getAnnotationValuesWithDefaults(
+  static Map<ExecutableElement, AnnotationValue> getAnnotationValuesWithDefaults(
       AnnotationMirror annotation) {
-    Map<ExecutableElement, AnnotationValue> values = Maps.newHashMap();
+    Map<ExecutableElement, AnnotationValue> values = Maps.newLinkedHashMap();
     for (ExecutableElement method :
         ElementFilter.methodsIn(annotation.getAnnotationType().asElement().getEnclosedElements())) {
       values.put(method, method.getDefaultValue());
     }
     values.putAll(annotation.getElementValues());
-    return values.values();
+    return values;
   }
 
+  /**
+   * Returns all {@linkplain AnnotationMirror annotations} that are present on the given
+   * {@link Element} which are themselves annotated with {@code annotationType}.
+   */
+  static ImmutableSet<? extends AnnotationMirror> getAnnotatedAnnotations(Element element,
+      final Class<? extends Annotation> annotationType) {
+    List<? extends AnnotationMirror> annotations = element.getAnnotationMirrors();
+    return FluentIterable.from(annotations)
+        .filter(new Predicate<AnnotationMirror>() {
+          @Override public boolean apply(AnnotationMirror input) {
+            return isAnnotationPresent(input.getAnnotationType().asElement(), annotationType);
+          }
+        })
+        .toSet();
+  }
   private AnnotationMirrors() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/AnnotationValues.java b/compiler/src/main/java/dagger/internal/codegen/AnnotationValues.java
index 4897ee6b4..d578180fe 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AnnotationValues.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AnnotationValues.java
@@ -15,10 +15,12 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreTypes;
 import com.google.common.base.Equivalence;
 import java.util.List;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.SimpleAnnotationValueVisitor6;
 
 /**
@@ -67,6 +69,7 @@ public Boolean visitArray(List<? extends AnnotationValue> left, AnnotationValue
                       return false; // Not an annotation mirror, so can't be equal to such.
                     }
 
+                    @SuppressWarnings("unchecked") // safe covariant cast
                     @Override public Boolean visitArray(
                         List<? extends AnnotationValue> right ,
                         List<? extends AnnotationValue> left) {
@@ -75,6 +78,21 @@ public Boolean visitArray(List<? extends AnnotationValue> left, AnnotationValue
                     }
                   }, left);
             }
+
+            @Override
+            public Boolean visitType(TypeMirror left, AnnotationValue right) {
+              return right.accept(
+                  new SimpleAnnotationValueVisitor6<Boolean, TypeMirror>() {
+                    @Override protected Boolean defaultAction(
+                        Object ignored, TypeMirror alsoIgnored) {
+                      return false; // Not an annotation mirror, so can't be equal to such.
+                    }
+
+                    @Override public Boolean visitType(TypeMirror right, TypeMirror left) {
+                      return MoreTypes.equivalence().equivalent(left, right);
+                    }
+                  }, left);
+            }
           }, right);
         }
 
@@ -90,6 +108,10 @@ public Boolean visitArray(List<? extends AnnotationValue> left, AnnotationValue
               return AnnotationValues.equivalence().pairwise().hash((List<AnnotationValue>) values);
             }
 
+            @Override public Integer visitType(TypeMirror value, Void ignore) {
+              return MoreTypes.equivalence().hash(value);
+            }
+
             @Override protected Integer defaultAction(Object value, Void ignored) {
               return value.hashCode();
             }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Binding.java b/compiler/src/main/java/dagger/internal/codegen/Binding.java
index 7d34dc270..1a88f1c2c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Binding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Binding.java
@@ -16,8 +16,8 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.MoreElements;
+import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.ImmutableSetMultimap;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.SimpleElementVisitor6;
@@ -34,6 +34,9 @@
 // TODO(gak): make a decision about whether or not to bring MembersInjectionBinding under this
 // supertype or whether to just get rid of this.
 abstract class Binding {
+  /** The {@link Key} that is provided by this binding. */
+  protected abstract Key key();
+
   /** Returns the {@link Element} instance that is responsible for declaring the binding. */
   abstract Element bindingElement();
 
@@ -52,16 +55,21 @@ public TypeElement visitType(TypeElement e, Void p) {
     }, null);
   }
 
-  /** The set of {@link DependencyRequest dependencies} required to satisfy this binding. */
+  /**
+   * The explicit set of {@link DependencyRequest dependencies} required to satisfy this binding.
+   */
   abstract ImmutableSet<DependencyRequest> dependencies();
 
-  /** Returns the {@link #dependencies()} indexed by {@link Key}. */
-  ImmutableSetMultimap<FrameworkKey, DependencyRequest> dependenciesByKey() {
-    ImmutableSetMultimap.Builder<FrameworkKey, DependencyRequest> builder =
-        ImmutableSetMultimap.builder();
-    for (DependencyRequest dependency : dependencies()) {
-      builder.put(FrameworkKey.forDependencyRequest(dependency), dependency);
-    }
-    return builder.build();
-  }
+  /**
+   * The set of {@link DependencyRequest dependencies} required to satisfy this binding. This is a
+   * superset of {@link #dependencies()}.
+   */
+  abstract ImmutableSet<DependencyRequest> implicitDependencies();
+
+  /**
+   * Returns the name of the package in which this binding must be managed. E.g.: a binding
+   * may reference non-public types.
+   */
+  abstract Optional<String> bindingPackage();
+
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index b551c51be..303668368 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Optional;
@@ -29,12 +30,11 @@
 import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.MembersInjector;
-import dagger.Module;
 import dagger.Provides;
 import java.util.Deque;
-import java.util.LinkedHashSet;
 import java.util.List;
-import java.util.Queue;
+import java.util.Map.Entry;
+import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -45,6 +45,8 @@
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkState;
+import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.type.TypeKind.VOID;
 
@@ -65,10 +67,17 @@
   abstract TypeElement componentDefinitionType();
 
   /**
-   *  The set of component dependencies listed in {@link Component#dependencies}.
+   * The set of component dependencies listed in {@link Component#dependencies}.
    */
   abstract ImmutableSet<TypeElement> dependencies();
 
+  /**
+   * An index of the type to which this component holds a reference (the type listed in
+   * {@link Component#dependencies} as opposed to the enclosing type) for each method from a
+   * component dependency that can be used for binding.
+   */
+  abstract ImmutableMap<ExecutableElement, TypeElement> dependencyMethodIndex();
+
   /**
    * The list of {@link DependencyRequest} instances whose sources are methods on the component
    * definition type.  These are the user-requested dependencies.
@@ -95,78 +104,70 @@
    */
   abstract ImmutableMap<Key, MembersInjectionBinding> resolvedMembersInjectionBindings();
 
+  /** The package in which each {@link Key} initialization must happen.  */
+  abstract ImmutableSetMultimap<String, Key> initializationByPackage();
+
   /**
    * The ordering of {@link Key keys} that will allow all of the {@link Factory} and
    * {@link MembersInjector} implementations to initialize properly.
    */
-  abstract ImmutableList<FrameworkKey> initializationOrdering();
+  abstract ImmutableList<Key> initializationOrdering();
 
   static final class Factory {
     private final Elements elements;
     private final Types types;
     private final InjectBindingRegistry injectBindingRegistry;
+    private final Key.Factory keyFactory;
     private final ProvisionBinding.Factory provisionBindingFactory;
     private final DependencyRequest.Factory dependencyRequestFactory;
 
-    Factory(Elements elements, Types types, InjectBindingRegistry injectBindingRegistry,
-        ProvisionBinding.Factory provisionBindingFactory,
-        DependencyRequest.Factory dependencyRequestFactory) {
+    Factory(Elements elements, Types types,
+        InjectBindingRegistry injectBindingRegistry,
+        DependencyRequest.Factory dependencyRequestFactory,
+        Key.Factory keyFactory,
+        ProvisionBinding.Factory provisionBindingFactory) {
       this.elements = elements;
       this.types = types;
       this.injectBindingRegistry = injectBindingRegistry;
-      this.provisionBindingFactory = provisionBindingFactory;
       this.dependencyRequestFactory = dependencyRequestFactory;
+      this.keyFactory = keyFactory;
+      this.provisionBindingFactory = provisionBindingFactory;
     }
 
-    private ImmutableSet<TypeElement> getTransitiveModules(ImmutableSet<TypeElement> seedModules) {
-      Queue<TypeElement> moduleQueue = Queues.newArrayDeque(seedModules);
-      LinkedHashSet<TypeElement> moduleElements = Sets.newLinkedHashSet();
-      for (TypeElement moduleElement = moduleQueue.poll();
-          moduleElement != null;
-          moduleElement = moduleQueue.poll()) {
-        moduleElements.add(moduleElement);
-        AnnotationMirror moduleMirror =
-            getAnnotationMirror(moduleElement, Module.class).get();
-        ImmutableSet<TypeElement> moduleDependencies = MoreTypes.asTypeElements(types,
-            ConfigurationAnnotations.getModuleIncludes(elements, moduleMirror));
-        for (TypeElement dependencyType : moduleDependencies) {
-          if (!moduleElements.contains(dependencyType)) {
-            moduleQueue.add(dependencyType);
-          }
-        }
-      }
-      return ImmutableSet.copyOf(moduleElements);
-    }
-
-    ComponentDescriptor create(TypeElement componentDefinitionType) {
+    ComponentDescriptor create(TypeElement componentDefinitionType)
+        throws SourceFileGenerationException {
       AnnotationMirror componentMirror =
           getAnnotationMirror(componentDefinitionType, Component.class).get();
       ImmutableSet<TypeElement> moduleTypes = MoreTypes.asTypeElements(types,
           ConfigurationAnnotations.getComponentModules(elements, componentMirror));
       ImmutableSet<TypeElement> componentDependencyTypes = MoreTypes.asTypeElements(types,
           ConfigurationAnnotations.getComponentDependencies(elements, componentMirror));
-      ImmutableSet<TypeElement> transitiveModules = getTransitiveModules(moduleTypes);
+      ImmutableSet<TypeElement> transitiveModules =
+          getTransitiveModules(elements, types, moduleTypes);
 
       ProvisionBinding componentBinding =
           provisionBindingFactory.forComponent(componentDefinitionType);
 
-      ImmutableSetMultimap.Builder<Key, ProvisionBinding> bindingIndexBuilder =
+      ImmutableSetMultimap.Builder<Key, ProvisionBinding> explicitBindingIndexBuilder =
           new ImmutableSetMultimap.Builder<Key, ProvisionBinding>()
-              .put(componentBinding.providedKey(), componentBinding);
-
+              .put(componentBinding.key(), componentBinding);
+      ImmutableMap.Builder<ExecutableElement, TypeElement> dependencyMethodIndex =
+          ImmutableMap.builder();
 
       for (TypeElement componentDependency : componentDependencyTypes) {
         ProvisionBinding componentDependencyBinding =
             provisionBindingFactory.forComponent(componentDependency);
-        bindingIndexBuilder.put(
-            componentDependencyBinding.providedKey(), componentDependencyBinding);
+        explicitBindingIndexBuilder.put(
+            componentDependencyBinding.key(), componentDependencyBinding);
         List<ExecutableElement> dependencyMethods =
             ElementFilter.methodsIn(elements.getAllMembers(componentDependency));
         for (ExecutableElement dependencyMethod : dependencyMethods) {
           if (isComponentProvisionMethod(dependencyMethod)) {
             ProvisionBinding componentMethodBinding =
                 provisionBindingFactory.forComponentMethod(dependencyMethod);
-            bindingIndexBuilder.put(componentMethodBinding.providedKey(), componentMethodBinding);
+            explicitBindingIndexBuilder
+                .put(componentMethodBinding.key(), componentMethodBinding);
+            dependencyMethodIndex.put(dependencyMethod, componentDependency);
           }
         }
       }
@@ -179,12 +180,16 @@ ComponentDescriptor create(TypeElement componentDefinitionType) {
           if (isAnnotationPresent(moduleMethod, Provides.class)) {
             ProvisionBinding providesMethodBinding =
                 provisionBindingFactory.forProvidesMethod(moduleMethod);
-            bindingIndexBuilder.put(providesMethodBinding.providedKey(), providesMethodBinding);
+            explicitBindingIndexBuilder
+                .put(providesMethodBinding.key(), providesMethodBinding);
           }
         }
       }
 
-      ImmutableSetMultimap<Key, ProvisionBinding> explicitBindings = bindingIndexBuilder.build();
+      ImmutableSetMultimap<Key, ProvisionBinding> explicitBindings =
+          explicitBindingIndexBuilder.build();
+
+      Set<MethodSignature> interfaceMethods = Sets.newHashSet();
 
       ImmutableList.Builder<DependencyRequest> interfaceRequestsBuilder = ImmutableList.builder();
 
@@ -193,24 +198,28 @@ ComponentDescriptor create(TypeElement componentDefinitionType) {
       for (ExecutableElement componentMethod
           : ElementFilter.methodsIn(elements.getAllMembers(componentDefinitionType))) {
         if (componentMethod.getModifiers().contains(ABSTRACT)) {
-          List<? extends VariableElement> parameters = componentMethod.getParameters();
-          switch (parameters.size()) {
-            case 0:
-              // provision method
-              DependencyRequest provisionRequest =
-                  dependencyRequestFactory.forComponentProvisionMethod(componentMethod);
-              interfaceRequestsBuilder.add(provisionRequest);
-              requestsToResolve.addLast(provisionRequest);
-              break;
-            case 1:
-              // members injection method
-              DependencyRequest membersInjectionRequest =
-                  dependencyRequestFactory.forComponentMembersInjectionMethod(componentMethod);
-              interfaceRequestsBuilder.add(membersInjectionRequest);
-              requestsToResolve.addLast(membersInjectionRequest);
-              break;
-            default:
-              throw new IllegalStateException();
+          MethodSignature signature = MethodSignature.fromExecutableElement(componentMethod);
+          if (!interfaceMethods.contains(signature)) {
+            List<? extends VariableElement> parameters = componentMethod.getParameters();
+            switch (parameters.size()) {
+              case 0:
+                // provision method
+                DependencyRequest provisionRequest =
+                dependencyRequestFactory.forComponentProvisionMethod(componentMethod);
+                interfaceRequestsBuilder.add(provisionRequest);
+                requestsToResolve.addLast(provisionRequest);
+                break;
+              case 1:
+                // members injection method
+                DependencyRequest membersInjectionRequest =
+                dependencyRequestFactory.forComponentMembersInjectionMethod(componentMethod);
+                interfaceRequestsBuilder.add(membersInjectionRequest);
+                requestsToResolve.addLast(membersInjectionRequest);
+                break;
+              default:
+                throw new IllegalStateException();
+            }
+            interfaceMethods.add(signature);
           }
         }
       }
@@ -219,7 +228,7 @@ ComponentDescriptor create(TypeElement componentDefinitionType) {
           ImmutableSetMultimap.builder();
       ImmutableMap.Builder<Key, MembersInjectionBinding> resolvedMembersInjectionBindings =
           ImmutableMap.builder();
-      SetMultimap<FrameworkKey, Binding> resolvedBindings =
+      SetMultimap<Key, Binding> resolvedBindings =
           MultimapBuilder.linkedHashKeys().linkedHashSetValues().build();
 
       ImmutableList<DependencyRequest> interfaceRequests = interfaceRequestsBuilder.build();
@@ -229,24 +238,35 @@ ComponentDescriptor create(TypeElement componentDefinitionType) {
             resolvedProvisionBindings, resolvedMembersInjectionBindings);
       }
 
+      ImmutableSetMultimap.Builder<String, Key> initializationByPackageBuilder =
+          ImmutableSetMultimap.builder();
+      for (Entry<Key, Binding> resolvedBindingEntry : resolvedBindings.entries()) {
+        initializationByPackageBuilder.put(
+            resolvedBindingEntry.getValue().bindingPackage().or(
+                  MoreElements.getPackage(componentDefinitionType).getQualifiedName().toString()),
+            resolvedBindingEntry.getKey());
+      }
+
       return new AutoValue_ComponentDescriptor(
           componentDefinitionType,
           componentDependencyTypes,
+          dependencyMethodIndex.build(),
           interfaceRequests,
           transitiveModules,
           resolvedProvisionBindings.build(),
           resolvedMembersInjectionBindings.build(),
+          initializationByPackageBuilder.build(),
           ImmutableList.copyOf(resolvedBindings.keySet()));
     }
 
     private void resolveRequest(DependencyRequest request,
         ImmutableSetMultimap<Key, ProvisionBinding> explicitBindings,
-        SetMultimap<FrameworkKey, Binding> resolvedBindings,
+        SetMultimap<Key, Binding> resolvedBindings,
         ImmutableSetMultimap.Builder<Key, ProvisionBinding> resolvedProvisionsBindingBuilder,
-        ImmutableMap.Builder<Key, MembersInjectionBinding> resolvedMembersIjectionBindingsBuilder) {
-      FrameworkKey frameworkKey = FrameworkKey.forDependencyRequest(request);
+        ImmutableMap.Builder<Key, MembersInjectionBinding> resolvedMembersInjectionBindingsBuilder)
+            throws SourceFileGenerationException {
       Key requestKey = request.key();
-      if (resolvedBindings.containsKey(frameworkKey)) {
+      if (resolvedBindings.containsKey(requestKey)) {
         return;
       }
       switch (request.kind()) {
@@ -257,57 +277,65 @@ private void resolveRequest(DependencyRequest request,
           ImmutableSet<ProvisionBinding> explicitBindingsForKey =
               explicitBindings.get(requestKey);
           if (explicitBindingsForKey.isEmpty()) {
-            // no explicit binding, look it up
-            Optional<ProvisionBinding> provisionBinding =
-                injectBindingRegistry.getProvisionBindingForKey(requestKey);
-            if (provisionBinding.isPresent()) {
+            // If the key is Map<K, V>, get its implicit binding key which is Map<K, Provider<V>>
+            Optional<Key> key = keyFactory.implicitMapProviderKeyFrom(request.key());
+            if (key.isPresent()) {
+              DependencyRequest implicitRequest =
+                  dependencyRequestFactory.forImplicitMapBinding(request, key.get());
+              ProvisionBinding implicitBinding =
+                  provisionBindingFactory.forImplicitMapBinding(request, implicitRequest);
+              resolveRequest(Iterables.getOnlyElement(implicitBinding.dependencies()),
+                  explicitBindings, resolvedBindings, resolvedProvisionsBindingBuilder,
+                  resolvedMembersInjectionBindingsBuilder);
+              resolvedBindings.put(requestKey, implicitBinding);
+              resolvedProvisionsBindingBuilder.put(request.key(), implicitBinding);
+            } else {
+              // no explicit binding, look it up
+              Optional<ProvisionBinding> provisionBinding =
+                  injectBindingRegistry.getOrFindProvisionBinding(requestKey);
+              checkState(provisionBinding.isPresent(),
+                  "Can not find a provision binding for %s. this should not have passed validation",
+                  requestKey);
               // found a binding, resolve its deps and then mark it resolved
               for (DependencyRequest dependency : Iterables.concat(
                   provisionBinding.get().dependencies(),
                   provisionBinding.get().memberInjectionRequest().asSet())) {
                 resolveRequest(dependency, explicitBindings, resolvedBindings,
-                    resolvedProvisionsBindingBuilder, resolvedMembersIjectionBindingsBuilder);
+                    resolvedProvisionsBindingBuilder, resolvedMembersInjectionBindingsBuilder);
               }
-              resolvedBindings.put(frameworkKey, provisionBinding.get());
+              resolvedBindings.put(requestKey, provisionBinding.get());
               resolvedProvisionsBindingBuilder.put(requestKey, provisionBinding.get());
-            } else {
-              throw new UnsupportedOperationException(
-                  "@Injected classes that weren't run with the compoenent processor are "
-                      + "(briefly) unsupported: " + requestKey);
-
             }
           } else {
             // we found explicit bindings. resolve the deps and them mark them resolved
-            for (ProvisionBinding explicitBinding : explicitBindingsForKey) {
+            for (Binding explicitBinding : explicitBindingsForKey) {
               for (DependencyRequest dependency : explicitBinding.dependencies()) {
                 resolveRequest(dependency, explicitBindings, resolvedBindings,
-                    resolvedProvisionsBindingBuilder, resolvedMembersIjectionBindingsBuilder);
+                    resolvedProvisionsBindingBuilder, resolvedMembersInjectionBindingsBuilder);
               }
             }
-            resolvedBindings.putAll(frameworkKey, explicitBindingsForKey);
+            resolvedBindings.putAll(requestKey, explicitBindingsForKey);
             resolvedProvisionsBindingBuilder.putAll(requestKey, explicitBindingsForKey);
           }
           break;
         case MEMBERS_INJECTOR:
-          // no explicit deps for members injection, so just look it up
-          Optional<MembersInjectionBinding> membersInjectionBinding =
-              injectBindingRegistry.getMembersInjectionBindingForKey(requestKey);
-          if (membersInjectionBinding.isPresent()) {
-            // found a binding, resolve its deps and then mark it resolved
-            for (DependencyRequest dependency : membersInjectionBinding.get().dependencies()) {
-              resolveRequest(dependency, explicitBindings, resolvedBindings,
-                  resolvedProvisionsBindingBuilder, resolvedMembersIjectionBindingsBuilder);
-            }
-            resolvedBindings.put(frameworkKey, membersInjectionBinding.get());
-            resolvedMembersIjectionBindingsBuilder.put(requestKey, membersInjectionBinding.get());
-          } else {
-            // TOOD(gak): make an implicit injector for cases where we need one, but it has no
-            // members
+         // no explicit deps for members injection, so just look it up
+          MembersInjectionBinding membersInjectionBinding =
+              injectBindingRegistry.getOrFindMembersInjectionBinding(requestKey);
+          //resolve its deps and then mark it resolved
+          for (DependencyRequest dependency : Iterables.concat(
+              membersInjectionBinding.dependencies(),
+              membersInjectionBinding.parentInjectorRequest().asSet())) {
+            resolveRequest(dependency, explicitBindings, resolvedBindings,
+                resolvedProvisionsBindingBuilder, resolvedMembersInjectionBindingsBuilder);
           }
+          resolvedBindings.put(requestKey, membersInjectionBinding);
+          resolvedMembersInjectionBindingsBuilder.put(requestKey, membersInjectionBinding);
           break;
         default:
           throw new AssertionError();
       }
+
     }
 
     private static boolean isComponentProvisionMethod(ExecutableElement method) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 3fbea2496..8628417f0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -21,6 +21,7 @@
 import com.google.common.base.Functions;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
+import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
@@ -28,13 +29,18 @@
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
+import com.google.common.collect.Multimaps;
 import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.Factory;
-import dagger.MembersInjector;
+import dagger.MapKey;
 import dagger.internal.InstanceFactory;
+import dagger.internal.MapFactory;
+import dagger.internal.MapProviderFactory;
+import dagger.internal.MembersInjectors;
 import dagger.internal.ScopedProvider;
 import dagger.internal.SetFactory;
+import dagger.internal.codegen.ProvisionBinding.BindingType;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.ClassWriter;
 import dagger.internal.codegen.writer.ConstructorWriter;
@@ -45,9 +51,10 @@
 import dagger.internal.codegen.writer.Snippet;
 import dagger.internal.codegen.writer.StringLiteral;
 import dagger.internal.codegen.writer.TypeName;
-import dagger.internal.codegen.writer.VoidName;
 import dagger.internal.codegen.writer.TypeNames;
 import dagger.internal.codegen.writer.VoidName;
+import java.util.EnumSet;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
@@ -55,13 +62,22 @@
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
 import javax.inject.Provider;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.AnnotationValueVisitor;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
 import javax.lang.model.element.Name;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.SimpleAnnotationValueVisitor6;
 
+import static com.google.auto.common.MoreTypes.asDeclared;
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static dagger.internal.codegen.ConfigurationAnnotations.getMapKeys;
 import static dagger.internal.codegen.DependencyRequest.Kind.MEMBERS_INJECTOR;
 import static dagger.internal.codegen.ProvisionBinding.Kind.COMPONENT;
 import static dagger.internal.codegen.ProvisionBinding.Kind.COMPONENT_PROVISION;
@@ -71,10 +87,13 @@
 import static dagger.internal.codegen.SourceFiles.generateMembersInjectorNamesForBindings;
 import static dagger.internal.codegen.SourceFiles.generateProviderNamesForBindings;
 import static dagger.internal.codegen.SourceFiles.membersInjectorNameForMembersInjectionBinding;
+import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
+import static javax.lang.model.element.NestingKind.MEMBER;
+import static javax.lang.model.element.NestingKind.TOP_LEVEL;
 import static javax.lang.model.type.TypeKind.VOID;
 
 /**
@@ -84,11 +103,8 @@
  * @since 2.0
  */
 final class ComponentGenerator extends SourceFileGenerator<ComponentDescriptor> {
-  private final Key.Factory keyFactory;
-
-  ComponentGenerator(Filer filer, Key.Factory keyFactory) {
+  ComponentGenerator(Filer filer) {
     super(filer);
-    this.keyFactory = keyFactory;
   }
 
   @Override
@@ -110,7 +126,7 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
   }
 
   @Override
-  JavaWriter write(ClassName componentName, ComponentDescriptor input)  {
+  ImmutableSet<JavaWriter> write(ClassName componentName, ComponentDescriptor input) {
     ClassName componentDefinitionTypeName =
         ClassName.fromTypeElement(input.componentDefinitionType());
 
@@ -136,10 +152,8 @@ JavaWriter write(ClassName componentName, ComponentDescriptor input)  {
 
     ImmutableMap<Key, String> providerNames =
         generateProviderNamesForBindings(resolvedProvisionBindings);
-    Map<Key, FieldWriter> providerFields = Maps.newHashMap();
     ImmutableMap<Key, String> membersInjectorNames =
         generateMembersInjectorNamesForBindings(resolvedMembersInjectionBindings);
-    Map<Key, FieldWriter> membersInjectorFields = Maps.newHashMap();
 
     // the full set of types that calling code uses to construct a component instance
     ImmutableMap<TypeElement, String> componentContributionNames =
@@ -153,6 +167,8 @@ JavaWriter write(ClassName componentName, ComponentDescriptor input)  {
                   }
                 })));
 
+    ImmutableSet.Builder<JavaWriter> packageProxies = ImmutableSet.builder();
+
     ConstructorWriter constructorWriter = componentWriter.addConstructor();
     constructorWriter.addModifiers(PRIVATE);
     constructorWriter.addParameter(builderWriter, "builder");
@@ -186,22 +202,90 @@ JavaWriter write(ClassName componentName, ComponentDescriptor input)  {
           .addSnippet("}")
           .addSnippet("this.%s = %s;", builderField.name(), contributionName)
           .addSnippet("return this;");
-      if (Util.getNoArgsConstructor(contributionElement) == null) {
-        requiresBuilder = true;
+      if (hasNoArgsConstructor(contributionElement)) {
         buildMethod.body()
             .addSnippet("if (%s == null) {", builderField.name())
-            .addSnippet("  throw new IllegalStateException(\"%s must be set\");",
-                builderField.name())
+            .addSnippet("  this.%s = new %s();",
+                builderField.name(), ClassName.fromTypeElement(contributionElement))
             .addSnippet("}");
       } else {
+        requiresBuilder = true;
         buildMethod.body()
             .addSnippet("if (%s == null) {", builderField.name())
-            .addSnippet("  this.%s = new %s();",
-                builderField.name(), ClassName.fromTypeElement(contributionElement))
+            .addSnippet("  throw new IllegalStateException(\"%s must be set\");",
+                builderField.name())
             .addSnippet("}");
       }
     }
 
+    ImmutableMap.Builder<Key, Snippet> memberSelectSnippetsBuilder =
+        ImmutableMap.builder();
+
+    for (Entry<String, Set<Key>> packageEntry :
+        Multimaps.asMap(input.initializationByPackage()).entrySet()) {
+      String packageName = packageEntry.getKey();
+
+      final Optional<String> proxySelector;
+      final ClassWriter classWithFields;
+      final Set<Modifier> fieldModifiers;
+
+      if (packageName.equals(componentName.packageName())) {
+        // no proxy
+        proxySelector = Optional.absent();
+        // component gets the fields
+        classWithFields = componentWriter;
+        // private fields
+        fieldModifiers = EnumSet.of(PRIVATE);
+      } else {
+        // create the proxy
+        JavaWriter proxyWriter = JavaWriter.inPackage(packageName);
+        packageProxies.add(proxyWriter);
+        ClassWriter proxyClassWriter =
+            proxyWriter.addClass(componentName.simpleName() + "__PackageProxy");
+        proxyClassWriter.addModifiers(PUBLIC, FINAL);
+        // create the field for the proxy in the component
+        FieldWriter proxyField =
+            componentWriter.addField(proxyClassWriter.name(), packageName.replace('.', '_')
+                + "_Proxy");
+        proxyField.addModifiers(PRIVATE, FINAL);
+        proxyField.setInitializer("new %s()", proxyClassWriter.name());
+        // add the field for the member select
+        proxySelector = Optional.of(proxyField.name());
+        // proxy gets the fields
+        classWithFields = proxyClassWriter;
+        // public fields in the proxy
+        fieldModifiers = EnumSet.of(PUBLIC);
+      }
+
+      for (Key key : packageEntry.getValue()) {
+        TypeName frameworkTypeName = ParameterizedTypeName.create(
+            ClassName.fromClass(key.kind().frameworkClass()),
+            TypeNames.forTypeMirror(key.type()));
+
+        final String fieldName;
+        switch (key.kind()) {
+          case PROVIDER:
+            fieldName = providerNames.get(key);
+            break;
+          case MEMBERS_INJECTOR:
+            fieldName = membersInjectorNames.get(key);
+            break;
+          default:
+            throw new AssertionError();
+        }
+
+        FieldWriter frameworkField = classWithFields.addField(frameworkTypeName, fieldName);
+        frameworkField.addModifiers(fieldModifiers);
+
+        ImmutableList<String> memberSelectTokens = new ImmutableList.Builder<String>()
+            .addAll(proxySelector.asSet())
+            .add(frameworkField.name())
+            .build();
+        memberSelectSnippetsBuilder.put(key,
+            Snippet.memberSelectSnippet(memberSelectTokens));
+      }
+    }
+
     buildMethod.body().addSnippet("return new %s(this);", componentWriter.name());
 
     if (!requiresBuilder) {
@@ -211,59 +295,64 @@ JavaWriter write(ClassName componentName, ComponentDescriptor input)  {
       factoryMethod.body().addSnippet("return builder().build();");
     }
 
-    for (Entry<Key, String> providerEntry : providerNames.entrySet()) {
-      Key key = providerEntry.getKey();
-      // TODO(gak): provide more elaborate information about which requests relate
-      TypeName providerTypeReferece = ParameterizedTypeName.create(
-          ClassName.fromClass(Provider.class),
-          TypeNames.forTypeMirror(key.type()));
-      FieldWriter providerField =
-          componentWriter.addField(providerTypeReferece, providerEntry.getValue());
-      providerField.addModifiers(PRIVATE, FINAL);
-      providerFields.put(key, providerField);
-    }
+    ImmutableMap<Key, Snippet> memberSelectSnippets = memberSelectSnippetsBuilder.build();
 
-    for (Entry<Key, String> membersInjectorEntry : membersInjectorNames.entrySet()) {
-      Key key = membersInjectorEntry.getKey();
-      // TODO(gak): provide more elaborate information about which requests relate
-      TypeName membersInjectorTypeReferece = ParameterizedTypeName.create(
-          ClassName.fromClass(MembersInjector.class),
-          TypeNames.forTypeMirror(key.type()));
-      FieldWriter membersInjectorField =
-          componentWriter.addField(membersInjectorTypeReferece, membersInjectorEntry.getValue());
-      membersInjectorField.addModifiers(PRIVATE, FINAL);
-      membersInjectorFields.put(key, membersInjectorField);
-    }
+    List<List<Key>> partitions = Lists.partition(input.initializationOrdering(), 100);
+    for (int i = 0; i < partitions.size(); i++) {
+      MethodWriter initializeMethod =
+          componentWriter.addMethod(VoidName.VOID, "initialize" + ((i == 0) ? "" : i));
+      initializeMethod.addModifiers(PRIVATE);
+      constructorWriter.body().addSnippet("%s();", initializeMethod.name());
 
-    for (FrameworkKey frameworkKey : input.initializationOrdering()) {
-      Key key = frameworkKey.key();
-      if (frameworkKey.frameworkClass().equals(Provider.class)) {
-        Set<ProvisionBinding> bindings = resolvedProvisionBindings.get(key);
-        if (ProvisionBinding.isSetBindingCollection(bindings)) {
-          ImmutableList.Builder<Snippet> setFactoryParameters = ImmutableList.builder();
-          for (ProvisionBinding binding : bindings) {
-            setFactoryParameters.add(initializeFactoryForBinding(
-                binding, componentContributionFields, providerFields, membersInjectorFields));
-          }
-          constructorWriter.body().addSnippet("this.%s = %s.create(%n%s);",
-              providerFields.get(key).name(),
-              ClassName.fromClass(SetFactory.class),
-              Snippet.makeParametersSnippet(setFactoryParameters.build()));
-        } else {
-          ProvisionBinding binding = Iterables.getOnlyElement(bindings);
-          constructorWriter.body().addSnippet("this.%s = %s;",
-              providerFields.get(key).name(),
-              initializeFactoryForBinding(
-                  binding, componentContributionFields, providerFields, membersInjectorFields));
+      for (Key key : partitions.get(i)) {
+        Snippet memberSelectSnippet = memberSelectSnippets.get(key);
+        switch (key.kind()) {
+          case PROVIDER:
+            Set<ProvisionBinding> bindings = resolvedProvisionBindings.get(key);
+            BindingType bindingsType = ProvisionBinding.bindingTypeFor(bindings);
+            switch (bindingsType) {
+              case SET:
+                ImmutableList.Builder<Snippet> setFactoryParameters = ImmutableList.builder();
+                for (ProvisionBinding binding : bindings) {
+                  setFactoryParameters.add(initializeFactoryForBinding(binding,
+                      input.dependencyMethodIndex(), componentContributionFields,
+                      memberSelectSnippets));
+                }
+                Snippet initializeSetSnippet = Snippet.format("%s.create(%s)",
+                    ClassName.fromClass(SetFactory.class),
+                    Snippet.makeParametersSnippet(setFactoryParameters.build()));
+                initializeMethod.body().addSnippet("this.%s = %s;",
+                    memberSelectSnippet, initializeSetSnippet);
+                break;
+              case MAP:
+                if (!bindings.isEmpty()) {
+                  Snippet initializeMapSnippet =
+                      initializeMapBinding(componentContributionFields,
+                          input.dependencyMethodIndex(), memberSelectSnippets, bindings);
+                  initializeMethod.body().addSnippet("this.%s = %s;",
+                      memberSelectSnippet, initializeMapSnippet);
+                }
+                break;
+              case UNIQUE:
+                ProvisionBinding binding = Iterables.getOnlyElement(bindings);
+                initializeMethod.body().addSnippet("this.%s = %s;",
+                    memberSelectSnippet,
+                    initializeFactoryForBinding(binding, input.dependencyMethodIndex(),
+                        componentContributionFields, memberSelectSnippets));
+                break;
+              default:
+                throw new IllegalStateException();
+            }
+            break;
+          case MEMBERS_INJECTOR:
+            MembersInjectionBinding binding = resolvedMembersInjectionBindings.get(key);
+            initializeMethod.body().addSnippet("this.%s = %s;",
+                memberSelectSnippet,
+                initializeMembersInjectorForBinding(binding, memberSelectSnippets));
+            break;
+          default:
+            throw new AssertionError();
         }
-      } else if (frameworkKey.frameworkClass().equals(MembersInjector.class)) {
-        constructorWriter.body().addSnippet("this.%s = %s;",
-            membersInjectorFields.get(key).name(),
-            initializeMembersInjectorForBinding(resolvedMembersInjectionBindings.get(key),
-                providerFields, membersInjectorFields));
-      } else {
-        throw new IllegalStateException(
-            "unknown framework class: " + frameworkKey.frameworkClass());
       }
     }
 
@@ -271,40 +360,43 @@ JavaWriter write(ClassName componentName, ComponentDescriptor input)  {
       ExecutableElement requestElement = (ExecutableElement) interfaceRequest.requestElement();
       MethodWriter interfaceMethod = requestElement.getReturnType().getKind().equals(VOID)
           ? componentWriter.addMethod(VoidName.VOID, requestElement.getSimpleName().toString())
-          : componentWriter.addMethod(requestElement.getReturnType(),
-              requestElement.getSimpleName().toString());
+              : componentWriter.addMethod(requestElement.getReturnType(),
+                  requestElement.getSimpleName().toString());
       interfaceMethod.annotate(Override.class);
       interfaceMethod.addModifiers(PUBLIC);
+      Key key = interfaceRequest.key();
       if (interfaceRequest.kind().equals(MEMBERS_INJECTOR)) {
-        String membersInjectorName = membersInjectorFields.get(interfaceRequest.key()).name();
+        Snippet membersInjectorName = memberSelectSnippets.get(key);
         VariableElement parameter = Iterables.getOnlyElement(requestElement.getParameters());
         Name parameterName = parameter.getSimpleName();
         interfaceMethod.addParameter(
             TypeNames.forTypeMirror(parameter.asType()), parameterName.toString());
         interfaceMethod.body()
-            .addSnippet("%s.injectMembers(%s);", membersInjectorName, parameterName);
+        .addSnippet("%s.injectMembers(%s);", membersInjectorName, parameterName);
         if (!requestElement.getReturnType().getKind().equals(VOID)) {
           interfaceMethod.body().addSnippet("return %s;", parameterName);
         }
       } else {
-        // look up the provider in the Key->field map and invoke.  Done.
         interfaceMethod.body().addSnippet("return %s;",
-            frameworkTypeUsageStatement(providerFields.get(interfaceRequest.key()).name(),
+            frameworkTypeUsageStatement(memberSelectSnippets.get(key),
                 interfaceRequest.kind()));
       }
     }
 
-    return writer;
+    return new ImmutableSet.Builder<JavaWriter>()
+        .addAll(packageProxies.build())
+        .add(writer)
+        .build();
   }
 
   private Snippet initializeFactoryForBinding(ProvisionBinding binding,
+      ImmutableMap<ExecutableElement, TypeElement> dependencyMethodIndex,
       Map<TypeElement, FieldWriter> contributionFields,
-      Map<Key, FieldWriter> providerFields,
-      Map<Key, FieldWriter> membersInjectorFields) {
+      ImmutableMap<Key, Snippet> memberSelectSnippets) {
     if (binding.bindingKind().equals(COMPONENT)) {
       return Snippet.format("%s.<%s>create(this)",
           ClassName.fromClass(InstanceFactory.class),
-          TypeNames.forTypeMirror(binding.providedKey().type()));
+          TypeNames.forTypeMirror(binding.key().type()));
     } else if (binding.bindingKind().equals(COMPONENT_PROVISION)) {
       return Snippet.format(Joiner.on('\n').join(
           "new %s<%2$s>() {",
@@ -313,25 +405,24 @@ private Snippet initializeFactoryForBinding(ProvisionBinding binding,
           "  }",
           "}"),
           ClassName.fromClass(Factory.class),
-          TypeNames.forTypeMirror(binding.providedKey().type()),
-          contributionFields.get(binding.bindingTypeElement()).name(),
+          TypeNames.forTypeMirror(binding.key().type()),
+          contributionFields.get(dependencyMethodIndex.get(binding.bindingElement())).name(),
           binding.bindingElement().getSimpleName().toString());
     } else {
-      List<String> parameters = Lists.newArrayListWithCapacity(binding.dependencies().size() + 1);
+      List<Snippet> parameters = Lists.newArrayListWithCapacity(binding.dependencies().size() + 1);
       if (binding.bindingKind().equals(PROVISION)) {
-        parameters.add(contributionFields.get(binding.bindingTypeElement()).name());
+        parameters.add(Snippet.format(contributionFields.get(binding.bindingTypeElement()).name()));
       }
       if (binding.memberInjectionRequest().isPresent()) {
-        FieldWriter membersInjectorField =
-            membersInjectorFields.get(keyFactory.forType(binding.providedKey().type()));
-        if (membersInjectorField != null) {
-          parameters.add(membersInjectorField.name());
+        Snippet snippet = memberSelectSnippets.get(
+            binding.memberInjectionRequest().get().key());
+        if (snippet != null) {
+          parameters.add(snippet);
         } else {
           throw new UnsupportedOperationException("Non-generated MembersInjector");
         }
       }
-      parameters.addAll(
-          getDependencyParameters(binding.dependencies(), providerFields, membersInjectorFields));
+      parameters.addAll(getDependencyParameters(binding.dependencies(), memberSelectSnippets));
       return binding.scope().isPresent()
           ? Snippet.format("%s.create(new %s(%s))",
               ClassName.fromClass(ScopedProvider.class),
@@ -345,24 +436,186 @@ private Snippet initializeFactoryForBinding(ProvisionBinding binding,
 
   private static Snippet initializeMembersInjectorForBinding(
       MembersInjectionBinding binding,
-      Map<Key, FieldWriter> providerFields,
-      Map<Key, FieldWriter> membersInjectorFields) {
-    List<String> parameters = getDependencyParameters(binding.dependencySet(),
-        providerFields, membersInjectorFields);
-    return Snippet.format("new %s(%s)",
-       membersInjectorNameForMembersInjectionBinding(binding).toString(),
-        Joiner.on(", ").join(parameters));
+      ImmutableMap<Key, Snippet> memberSelectSnippets) {
+    if (binding.injectionSites().isEmpty()) {
+      if (binding.parentInjectorRequest().isPresent()) {
+        DependencyRequest parentInjectorRequest = binding.parentInjectorRequest().get();
+        return Snippet.format("%s.delegatingTo(%s)",
+            ClassName.fromClass(MembersInjectors.class),
+            memberSelectSnippets.get(
+                parentInjectorRequest.key()));
+      } else {
+        return Snippet.format("%s.noOp()",
+            ClassName.fromClass(MembersInjectors.class));
+      }
+    } else {
+      List<Snippet> parameters = getDependencyParameters(
+          Sets.union(binding.parentInjectorRequest().asSet(), binding.dependencies()),
+          memberSelectSnippets);
+      return Snippet.format("new %s(%s)",
+          membersInjectorNameForMembersInjectionBinding(binding),
+          Joiner.on(", ").join(parameters));
+    }
   }
 
-  private static List<String> getDependencyParameters(Iterable<DependencyRequest> dependencies,
-      Map<Key, FieldWriter> providerFields,
-      Map<Key, FieldWriter> membersInjectorFields) {
-    ImmutableList.Builder<String> parameters = ImmutableList.builder();
+  private static List<Snippet> getDependencyParameters(Iterable<DependencyRequest> dependencies,
+      ImmutableMap<Key, Snippet> memberSelectSnippets) {
+    ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
     for (DependencyRequest dependency : dependencies) {
-        parameters.add(dependency.kind().equals(MEMBERS_INJECTOR)
-            ? membersInjectorFields.get(dependency.key()).name()
-            : providerFields.get(dependency.key()).name());
+      parameters.add(memberSelectSnippets.get(dependency.key()));
     }
     return parameters.build();
   }
+
+  private Snippet initializeMapBinding(
+      Map<TypeElement, FieldWriter> contributionFields,
+      ImmutableMap<ExecutableElement, TypeElement> dependencyMethodIndex,
+      ImmutableMap<Key, Snippet> memberSelectSnippets,
+      Set<ProvisionBinding> bindings) {
+    Iterator<ProvisionBinding> iterator = bindings.iterator();
+    // get type information from first binding in iterator
+    ProvisionBinding firstBinding = iterator.next();
+    if (isNonProviderMap(firstBinding)) {
+      return Snippet.format("%s.create(%s)",
+          ClassName.fromClass(MapFactory.class),
+          memberSelectSnippets.get(Iterables.getOnlyElement(firstBinding.dependencies()).key()));
+    } else {
+      DeclaredType mapType = asDeclared(firstBinding.key().type());
+      TypeMirror mapKeyType = Util.getKeyTypeOfMap(mapType);
+      TypeMirror mapValueType = Util.getProvidedValueTypeOfMap(mapType); // V of Map<K, Provider<V>>
+      StringBuilder snippetFormatBuilder = new StringBuilder("%s.<%s, %s>builder(%d)");
+      for (int i = 0; i < bindings.size(); i++) {
+        snippetFormatBuilder.append("\n    .put(%s, %s)");
+      }
+      snippetFormatBuilder.append("\n    .build()");
+
+      List<Object> argsBuilder = Lists.newArrayList();
+      argsBuilder.add(ClassName.fromClass(MapProviderFactory.class));
+      argsBuilder.add(TypeNames.forTypeMirror(mapKeyType));
+      argsBuilder.add(TypeNames.forTypeMirror(mapValueType));
+      argsBuilder.add(bindings.size());
+
+      writeEntry(argsBuilder, firstBinding, initializeFactoryForBinding(
+          firstBinding, dependencyMethodIndex, contributionFields, memberSelectSnippets));
+      while (iterator.hasNext()) {
+        ProvisionBinding binding = iterator.next();
+        writeEntry(argsBuilder, binding, initializeFactoryForBinding(
+            binding, dependencyMethodIndex, contributionFields, memberSelectSnippets));
+      }
+
+      return Snippet.format(snippetFormatBuilder.toString(),
+          argsBuilder.toArray(new Object[0]));
+    }
+  }
+
+  // add one map entry for map Provider in Constructor
+  private void writeEntry(List<Object> argsBuilder, Binding binding,
+      Snippet factory) {
+    AnnotationMirror mapKeyAnnotationMirror =
+        Iterables.getOnlyElement(getMapKeys(binding.bindingElement()));
+    Map<? extends ExecutableElement, ? extends AnnotationValue> map =
+        mapKeyAnnotationMirror.getElementValues();
+    MapKey mapKey =
+        mapKeyAnnotationMirror.getAnnotationType().asElement().getAnnotation(MapKey.class);
+    if (!mapKey.unwrapValue()) {// wrapped key case
+      FluentIterable<AnnotationValue> originIterable = FluentIterable.from(
+          AnnotationMirrors.getAnnotationValuesWithDefaults(mapKeyAnnotationMirror).values());
+      FluentIterable<Snippet> annotationValueNames =
+          originIterable.transform(new Function<AnnotationValue, Snippet>() {
+            @Override
+            public Snippet apply(AnnotationValue value) {
+              return getValueSnippet(value);
+            }
+          });
+      ImmutableList.Builder<Snippet> snippets = ImmutableList.builder();
+      for (Snippet snippet : annotationValueNames) {
+        snippets.add(snippet);
+      }
+      argsBuilder.add(Snippet.format("%sCreator.create(%s)",
+          TypeNames.forTypeMirror(mapKeyAnnotationMirror.getAnnotationType()),
+          Snippet.makeParametersSnippet(snippets.build())));
+      argsBuilder.add(factory);
+    } else { // unwrapped key case
+      argsBuilder.add(Iterables.getOnlyElement(map.entrySet()).getValue());
+      argsBuilder.add(factory);
+    }
+  }
+
+  // Get the Snippet representation of a Annotation Value
+  // TODO(user) write corresponding test to verify the AnnotationValueVisitor is right
+  private Snippet getValueSnippet(AnnotationValue value) {
+    AnnotationValueVisitor<Snippet, Void> mapKeyVisitor =
+        new SimpleAnnotationValueVisitor6<Snippet, Void>() {
+          @Override
+          public Snippet visitEnumConstant(VariableElement c, Void p) {
+            return Snippet.format("%s.%s",
+                TypeNames.forTypeMirror(c.getEnclosingElement().asType()), c.getSimpleName());
+          }
+
+          @Override
+          public Snippet visitAnnotation(AnnotationMirror a, Void p) {
+            if (a.getElementValues().isEmpty()) {
+              return Snippet.format("@%s", TypeNames.forTypeMirror(a.getAnnotationType()));
+            } else {
+              Map<ExecutableElement, AnnotationValue> map =
+                  AnnotationMirrors.getAnnotationValuesWithDefaults(a);
+              // build "@Annotation(a = , b = , c = ))
+              ImmutableList.Builder<Snippet> snippets = ImmutableList.builder();
+              for (Entry<ExecutableElement, AnnotationValue> entry : map.entrySet()) {
+                snippets.add(Snippet.format("%s = %s",
+                    TypeNames.forTypeMirror(entry.getKey().asType()),
+                    getValueSnippet(entry.getValue())));
+
+              }
+              return Snippet.format("@%s(%s)", TypeNames.forTypeMirror(a.getAnnotationType()),
+                  Snippet.makeParametersSnippet(snippets.build()));
+            }
+          }
+
+          @Override
+          public Snippet visitType(TypeMirror t, Void p) {
+            return Snippet.format("%s", TypeNames.forTypeMirror(t));
+          }
+
+          @Override
+          public Snippet visitString(String s, Void p) {
+            return Snippet.format("\"%s\"", s);
+          }
+
+          @Override
+          protected Snippet defaultAction(Object o, Void v) {
+            return Snippet.format("%s", o);
+          }
+
+          @Override
+          public Snippet visitArray(List<? extends AnnotationValue> values, Void v) {
+            ImmutableList.Builder<Snippet> snippets = ImmutableList.builder();
+            for (int i = 0; i < values.size(); i++) {
+              snippets.add(values.get(i).accept(this, null));
+            }
+            return Snippet.format("[%s]", Snippet.makeParametersSnippet(snippets.build()));
+          }
+        };
+    return value.accept(mapKeyVisitor, null);
+  }
+
+  private boolean isNonProviderMap(Binding binding) {
+    TypeMirror bindingType = binding.key().type();
+    return MoreTypes.isTypeOf(Map.class, bindingType) // Implicitly guarantees a declared type.
+        && !MoreTypes.isTypeOf(Provider.class, asDeclared(bindingType).getTypeArguments().get(1));
+  }
+
+  private boolean hasNoArgsConstructor(TypeElement type) {
+    if (type.getNestingKind().equals(TOP_LEVEL)
+        || type.getNestingKind().equals(MEMBER) && type.getModifiers().contains(STATIC)) {
+      for (Element enclosed : type.getEnclosedElements()) {
+        if (enclosed.getKind().equals(CONSTRUCTOR)) {
+          if (((ExecutableElement) enclosed).getParameters().isEmpty()) {
+            return true;
+          }
+        }
+      }
+    }
+    return false;
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
index e94c48348..a0a956a4d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -36,16 +36,19 @@
   private final ComponentValidator componentValidator;
   private final ComponentDescriptor.Factory componentDescriptorFactory;
   private final ComponentGenerator componentGenerator;
+  private final GraphValidator graphValidator;
 
   ComponentProcessingStep(
       Messager messager,
       ComponentValidator componentValidator,
+      GraphValidator graphValidator,
       Factory componentDescriptorFactory,
       ComponentGenerator componentGenerator) {
     this.messager = messager;
     this.componentValidator = componentValidator;
     this.componentDescriptorFactory = componentDescriptorFactory;
     this.componentGenerator = componentGenerator;
+    this.graphValidator = graphValidator;
   }
 
   @Override
@@ -55,11 +58,13 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
     for (Element element : componentElements) {
       if (SuperficialValidation.validateElement(element)) {
         TypeElement componentTypeElement = MoreElements.asType(element);
-        ValidationReport<TypeElement> report =
+        ValidationReport<TypeElement> componentReport =
             componentValidator.validate(componentTypeElement);
-        report.printMessagesTo(messager);
-
-        if (report.isClean()) {
+        componentReport.printMessagesTo(messager);
+        ValidationReport<TypeElement> graphReport =
+            graphValidator.validate(componentTypeElement);
+        graphReport.printMessagesTo(messager);
+        if (componentReport.isClean() && graphReport.isClean()) {
           try {
             componentGenerator.generate(componentDescriptorFactory.create(componentTypeElement));
           } catch (SourceFileGenerationException e) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index a13950504..644d79173 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -18,9 +18,9 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import dagger.Component;
+import dagger.MapKey;
 import dagger.Module;
 import dagger.Provides;
-import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
 import java.util.Set;
 import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.Filer;
@@ -44,6 +44,7 @@
  */
 public final class ComponentProcessor extends AbstractProcessor {
   private ImmutableList<ProcessingStep> processingSteps;
+  private InjectBindingRegistry injectBindingRegistry;
 
   @Override
   public Set<String> getSupportedAnnotationTypes() {
@@ -51,7 +52,8 @@
         Component.class.getName(),
         Inject.class.getName(),
         Module.class.getName(),
-        Provides.class.getName());
+        Provides.class.getName(),
+        MapKey.class.getName());
   }
 
   @Override
@@ -71,40 +73,50 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
     InjectConstructorValidator injectConstructorValidator = new InjectConstructorValidator();
     InjectFieldValidator injectFieldValidator = new InjectFieldValidator();
     InjectMethodValidator injectMethodValidator = new InjectMethodValidator();
-    ModuleValidator moduleValidator = new ModuleValidator();
+    ModuleValidator moduleValidator = new ModuleValidator(elements, types);
     ProvidesMethodValidator providesMethodValidator = new ProvidesMethodValidator(elements);
     ComponentValidator componentValidator = new ComponentValidator(elements);
+    MapKeyValidator mapKeyValidator = new MapKeyValidator();
 
     Key.Factory keyFactory = new Key.Factory(types, elements);
 
-    InjectBindingRegistry injectBindingRegistry = new InjectBindingRegistry(keyFactory);
+    FactoryGenerator factoryGenerator = new FactoryGenerator(filer);
+    MembersInjectorGenerator membersInjectorGenerator =
+        new MembersInjectorGenerator(filer, elements, types);
+    ComponentGenerator componentGenerator = new ComponentGenerator(filer);
 
     DependencyRequest.Factory dependencyRequestFactory =
         new DependencyRequest.Factory(elements, types, keyFactory);
     ProvisionBinding.Factory provisionBindingFactory =
         new ProvisionBinding.Factory(elements, types, keyFactory, dependencyRequestFactory);
-    InjectionSite.Factory injectionSiteFactory =
-        new InjectionSite.Factory(dependencyRequestFactory);
+
+    MembersInjectionBinding.Factory membersInjectionBindingFactory =
+        new MembersInjectionBinding.Factory(elements, types, keyFactory, dependencyRequestFactory);
+
+    this.injectBindingRegistry = new InjectBindingRegistry(
+        elements, types, messager, provisionBindingFactory, factoryGenerator,
+        membersInjectionBindingFactory, membersInjectorGenerator);
+
     ComponentDescriptor.Factory componentDescriptorFactory =
         new ComponentDescriptor.Factory(elements, types, injectBindingRegistry,
-            provisionBindingFactory, dependencyRequestFactory);
+            dependencyRequestFactory, keyFactory, provisionBindingFactory);
+    MapKeyGenerator mapKeyGenerator = new MapKeyGenerator(filer);
 
-    FactoryGenerator factoryGenerator = new FactoryGenerator(filer);
-    MembersInjectorGenerator membersInjectorGenerator =
-        new MembersInjectorGenerator(filer, elements, types);
-    ComponentGenerator componentGenerator =
-        new ComponentGenerator(filer, keyFactory);
+    GraphValidator graphValidator = new GraphValidator(elements, types, injectBindingRegistry,
+        dependencyRequestFactory, keyFactory, provisionBindingFactory);
 
     this.processingSteps = ImmutableList.<ProcessingStep>of(
+        new MapKeyProcessingStep(
+            messager,
+            mapKeyValidator,
+            mapKeyGenerator),
         new InjectProcessingStep(
             messager,
             injectConstructorValidator,
             injectFieldValidator,
             injectMethodValidator,
             provisionBindingFactory,
-            factoryGenerator,
-            injectionSiteFactory,
-            membersInjectorGenerator,
+            membersInjectionBindingFactory,
             injectBindingRegistry),
         new ModuleProcessingStep(
             messager,
@@ -115,6 +127,7 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
         new ComponentProcessingStep(
             messager,
             componentValidator,
+            graphValidator,
             componentDescriptorFactory,
             componentGenerator));
   }
@@ -124,6 +137,11 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
     for (ProcessingStep processingStep : processingSteps) {
       processingStep.process(annotations, roundEnv);
     }
+    try {
+      injectBindingRegistry.generateSourcesForRequiredBindings();
+    } catch (SourceFileGenerationException e) {
+      e.printMessageTo(processingEnv.getMessager());
+    }
     return false;
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
index b625a09e8..6cf1ced26 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
@@ -37,8 +37,6 @@
  *
  * @author Gregory Kick
  */
-// TODO(gak): this class does superficial component validation, but we need to do graph validation
-// as well
 final class ComponentValidator implements Validator<TypeElement> {
   private final Elements elements;
 
@@ -63,8 +61,8 @@
     for (TypeMirror moduleType : moduleTypes) {
       moduleType.accept(new SimpleTypeVisitor6<Void, Void>() {
         @Override
-        protected Void defaultAction(TypeMirror e, Void p) {
-          builder.addItem(Util.typeToString(e) + " is not a valid module type.", subject);
+        protected Void defaultAction(TypeMirror mirror, Void p) {
+          builder.addItem(mirror + " is not a valid module type.", subject);
           return null;
         }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
index 1449649e7..ae0cafeb8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -15,16 +15,27 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Queues;
+import com.google.common.collect.Sets;
 import dagger.Component;
+import dagger.MapKey;
 import dagger.Module;
+import java.util.Queue;
+import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.AnnotationMirrors.getAttributeAsListOfTypes;
-
 /**
  * Utility methods related to dagger configuration annotations (e.g.: {@link Component}
  * and {@link Module}).
@@ -68,5 +79,36 @@
     return getAttributeAsListOfTypes(elements, moduleAnnotation, INJECTS_ATTRIBUTE);
   }
 
+  static ImmutableSet<? extends AnnotationMirror> getMapKeys(Element element) {
+    return AnnotationMirrors.getAnnotatedAnnotations(element, MapKey.class);
+  }
+
+  /**
+   * Returns the full set of modules transitively {@linkplain Module#includes included} from the
+   * given seed modules.  If a module is malformed and a type listed in {@link Module#includes}
+   * is not annotated with {@link Module}, it is ignored.
+   */
+  static ImmutableSet<TypeElement> getTransitiveModules(Elements elements, Types types,
+      ImmutableSet<TypeElement> seedModules) {
+    Queue<TypeElement> moduleQueue = Queues.newArrayDeque(seedModules);
+    Set<TypeElement> moduleElements = Sets.newLinkedHashSet();
+    for (TypeElement moduleElement = moduleQueue.poll();
+        moduleElement != null;
+        moduleElement = moduleQueue.poll()) {
+      moduleElements.add(moduleElement);
+      Optional<AnnotationMirror> moduleMirror = getAnnotationMirror(moduleElement, Module.class);
+      if (moduleMirror.isPresent()) {
+        ImmutableSet<TypeElement> moduleDependencies = MoreTypes.asTypeElements(types,
+            ConfigurationAnnotations.getModuleIncludes(elements, moduleMirror.get()));
+        for (TypeElement dependencyType : moduleDependencies) {
+          if (!moduleElements.contains(dependencyType)) {
+            moduleQueue.add(dependencyType);
+          }
+        }
+      }
+    }
+    return ImmutableSet.copyOf(moduleElements);
+  }
+
   private ConfigurationAnnotations() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index 013830eb8..cad93e194 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -30,6 +30,7 @@
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
@@ -39,7 +40,6 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 
-
 /**
  * Represents a request for a key at an injection point. Parameters to {@link Inject} constructors
  * or {@link Provides} methods are examples of key requests.
@@ -87,6 +87,17 @@
           .toSet();
     }
 
+    /**
+     * Creates a DependencyRequest for implictMapBinding, this request's key will be
+     * {@code Map<K, Provider<V>>}, this DependencyRequest is depended by the DependencyRequest
+     * whose key is {@code Map<K, V>}
+     */
+    DependencyRequest forImplicitMapBinding(DependencyRequest delegatingRequest, Key delegateKey) {
+      checkNotNull(delegatingRequest);
+      return new AutoValue_DependencyRequest(Kind.PROVIDER, delegateKey,
+          delegatingRequest.requestElement());
+    }
+
     DependencyRequest forRequiredVariable(VariableElement variableElement) {
       checkNotNull(variableElement);
       TypeMirror type = variableElement.asType();
@@ -96,6 +107,8 @@ DependencyRequest forRequiredVariable(VariableElement variableElement) {
 
     DependencyRequest forComponentProvisionMethod(ExecutableElement provisionMethod) {
       checkNotNull(provisionMethod);
+      checkArgument(provisionMethod.getParameters().isEmpty(),
+          "Component provision methods must be empty: " + provisionMethod);
       TypeMirror type = provisionMethod.getReturnType();
       Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(provisionMethod);
       return newDependencyRequest(provisionMethod, type, qualifier);
@@ -107,14 +120,16 @@ DependencyRequest forComponentMembersInjectionMethod(ExecutableElement membersIn
           InjectionAnnotations.getQualifier(membersInjectionMethod);
       checkArgument(!qualifier.isPresent());
       return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR,
-          keyFactory.forQualifiedType(qualifier,
+          keyFactory.forMembersInjectedType(
               Iterables.getOnlyElement(membersInjectionMethod.getParameters()).asType()),
           membersInjectionMethod);
     }
 
-    DependencyRequest forMembersInjectedType(TypeMirror type) {
-      return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR, keyFactory.forType(type),
-          types.asElement(type));
+    DependencyRequest forMembersInjectedType(TypeElement type) {
+      return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR,
+          // TODO(gak): handle this better
+          keyFactory.forMembersInjectedType(types.erasure(type.asType())),
+          type);
     }
 
     private DependencyRequest newDependencyRequest(Element requestElement, TypeMirror type,
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
new file mode 100644
index 000000000..170ee831e
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
@@ -0,0 +1,132 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreElements;
+import com.google.common.base.Optional;
+import com.google.common.collect.Queues;
+import java.util.Deque;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.util.SimpleElementVisitor6;
+
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.ErrorMessages.INDENT;
+
+/**
+ * Formats a {@link DependencyRequest} into a {@link String} suitable for an error message listing
+ * a chain of dependencies.
+ *
+ * @author Christian Gruber
+ * @since 2.0
+ */
+final class DependencyRequestFormatter extends Formatter<DependencyRequest> {
+  private static final DependencyRequestFormatter INSTANCE = new DependencyRequestFormatter();
+
+  static DependencyRequestFormatter instance() {
+    return INSTANCE;
+  }
+
+  // TODO(user): Sweep this class for TypeMirror.toString() usage and do some preventive format.
+  // TODO(user): consider returning a small structure containing strings to be indented later.
+  @Override public String format(DependencyRequest request) {
+    Element requestElement = request.requestElement();
+    Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(requestElement);
+    return requestElement.accept(new SimpleElementVisitor6<String, Optional<AnnotationMirror>>(){
+
+      /* Handle component methods */
+      @Override public String visitExecutable(
+          ExecutableElement method, Optional<AnnotationMirror> qualifier) {
+        StringBuilder builder = new StringBuilder(INDENT);
+        if (method.getParameters().isEmpty()) {
+          // some.package.name.MyComponent.myMethod()
+          //     [component method with return type: @other.package.Qualifier some.package.name.Foo]
+          appendMember(method, builder).append("()\n")
+              .append(INDENT).append(INDENT).append("[component method with return type: ");
+          if (qualifier.isPresent()) {
+            // TODO(user) use chenying's annotation mirror stringifier
+            builder.append(qualifier.get()).append(' ');
+          }
+          builder.append(method.getReturnType()).append(']');
+        } else {
+          // some.package.name.MyComponent.myMethod(some.package.name.Foo foo)
+          //     [component injection method for type: some.package.name.Foo]
+          VariableElement componentMethodParameter = getOnlyElement(method.getParameters());
+          appendMember(method, builder).append("(");
+          appendParameter(componentMethodParameter, builder);
+          builder.append(")\n");
+          builder.append(INDENT).append(INDENT).append("[component injection method for type: ")
+              .append(componentMethodParameter.asType())
+              .append(']');
+        }
+        return builder.toString();
+      }
+
+      /* Handle injected fields or method/constructor parameter injection. */
+      @Override public String visitVariable(
+          VariableElement variable, Optional<AnnotationMirror> qualifier) {
+        StringBuilder builder = new StringBuilder(INDENT);
+        if (variable.getKind().equals(ElementKind.PARAMETER)) {
+          // some.package.name.MyClass.myMethod(some.package.name.Foo arg0, some.package.Bar arg1)
+          //     [parameter: @other.package.Qualifier some.package.name.Foo arg0]
+          ExecutableElement methodOrConstructor =
+              MoreElements.asExecutable(variable.getEnclosingElement());
+          appendMember(methodOrConstructor, builder).append('(');
+          Deque<VariableElement> parameters =
+              Queues.newArrayDeque(methodOrConstructor.getParameters());
+          if (!parameters.isEmpty()) {
+            appendParameter(parameters.poll(), builder);
+          }
+          for(VariableElement current : parameters) {
+            appendParameter(current, builder.append(", "));
+          }
+          builder.append(")\n").append(INDENT).append(INDENT).append("[parameter: ");
+        } else {
+          // some.package.name.MyClass.myField
+          //     [injected field of type: @other.package.Qualifier some.package.name.Foo myField]
+          appendMember(variable, builder).append("()\n")
+              .append(INDENT).append(INDENT).append("[injected field of type: ");
+        }
+        if (qualifier.isPresent()) {
+          // TODO(user) use chenying's annotation mirror stringifier
+          builder.append(qualifier.get()).append(' ');
+        }
+        builder.append(variable.asType()).append(' ').append(variable.getSimpleName()).append(']');
+        return builder.toString();
+      }
+
+      @Override protected String defaultAction(Element element, Optional<AnnotationMirror> ignore) {
+        throw new IllegalStateException(
+            "Invalid request " + element.getKind() +  " element " + element);
+      }
+    }, qualifier);
+  }
+
+  private StringBuilder appendParameter(VariableElement parameter, StringBuilder builder) {
+    return builder.append(parameter.asType()).append(' ').append(parameter.getSimpleName());
+  }
+
+  private StringBuilder appendMember(Element member, StringBuilder builder) {
+    TypeElement type = MoreElements.asType(member.getEnclosingElement());
+    return builder.append(type.getQualifiedName())
+        .append('.')
+        .append(member.getSimpleName());
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 8331d0094..0cd4df5fc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -22,6 +22,11 @@
  * @since 2.0
  */
 final class ErrorMessages {
+  /*
+   * Common constants.
+   */
+  static final String INDENT = "    ";
+
   /*
    * JSR-330 errors
    *
@@ -82,6 +87,9 @@
    * These are errors that relate specifically to the Dagger configuration API (@Module, @Provides,
    * etc.)
    */
+  static final String DUPLICATE_BINDINGS_FOR_KEY_FORMAT =
+      "%s is bound multiple times:";
+
   static final String PROVIDES_METHOD_RETURN_TYPE =
       "@Provides methods must either return a primitive, an array or a declared type.";
 
@@ -106,8 +114,42 @@
   static final String PROVIDES_METHOD_NOT_IN_MODULE =
       "@Provides methods can only be present within a @Module";
 
+  static final String PROVIDES_METHOD_NOT_MAP_HAS_MAP_KEY =
+      "@Provides methods of non map type cannot declare a map key";
+
+  static final String PROVIDES_METHOD_WITH_NO_MAP_KEY =
+      "@Provides methods of type map must declare a map key";
+
+  static final String PROVIDES_METHOD_WITH_MULTIPLE_MAP_KEY =
+      "@Provides methods may not have more than one @MapKey-marked annotation";
+
   static final String PROVIDES_METHOD_WITH_SAME_NAME =
       "Cannot have more than one @Provides method with the same name in a single module";
 
+  /*mapKey errors*/
+  static final String MAPKEY_WITHOUT_FIELDS =
+      "Map key annotation does not have fields";
+
+  /* collection binding errors */
+  static final String MULTIPLE_BINDING_TYPES_FORMAT =
+      "More than one binding present of different types %s";
+
+  static final String MULTIPLE_BINDING_TYPES_FOR_KEY_FORMAT =
+      "%s has incompatible bindings:\n";
+
+  static final String REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT =
+      "%s cannot be provided without an @Inject constructor or from an @Provides-annotated method.";
+
+  static final String REQUIRES_PROVIDER_FORMAT =
+      "%s cannot be provided without an @Provides-annotated method.";
+
+  static final String MEMBERS_INJECTION_DOES_NOT_IMPLY_PROVISION =
+      "This type supports members injection but cannot be implicitly provided.";
+
+  static final String CONTAINS_DEPENDENCY_CYCLE_FORMAT = "%s.%s() contains a dependency cycle:\n%s";
+
+  static final String MALFORMED_MODULE_METHOD_FORMAT =
+      "Cannot generated a graph because method %s on module %s was malformed";
+
   private ErrorMessages() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 8aafacd97..4a9cb8868 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -15,13 +15,16 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
+import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
 import dagger.Factory;
 import dagger.MembersInjector;
+import dagger.Provides.Type;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.ClassWriter;
 import dagger.internal.codegen.writer.ConstructorWriter;
@@ -30,17 +33,21 @@
 import dagger.internal.codegen.writer.MethodWriter;
 import dagger.internal.codegen.writer.ParameterizedTypeName;
 import dagger.internal.codegen.writer.Snippet;
+import dagger.internal.codegen.writer.StringLiteral;
 import dagger.internal.codegen.writer.TypeName;
 import dagger.internal.codegen.writer.TypeNames;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map.Entry;
+import java.util.logging.Logger;
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
 import javax.inject.Inject;
 import javax.inject.Provider;
 import javax.lang.model.element.Element;
+import javax.lang.model.type.TypeMirror;
 
+import static dagger.Provides.Type.SET;
 import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
@@ -48,6 +55,7 @@
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
 
 /**
  * Generates {@link Factory} implementations from {@link ProvisionBinding} instances for
@@ -76,10 +84,13 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     return Optional.of(binding.bindingElement());
   }
 
-
   @Override
-  JavaWriter write(ClassName generatedTypeName, ProvisionBinding binding) {
-    TypeName providedTypeName = TypeNames.forTypeMirror(binding.providedKey().type());
+  ImmutableSet<JavaWriter> write(ClassName generatedTypeName, ProvisionBinding binding) {
+    TypeMirror keyType = binding.provisionType().equals(Type.MAP)
+
+        ? Util.getProvidedValueTypeOfMap(MoreTypes.asDeclared(binding.key().type()))
+        : binding.key().type();
+    TypeName providedTypeName = TypeNames.forTypeMirror(keyType);
     JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
 
     ClassWriter factoryWriter = writer.addClass(generatedTypeName.simpleName());
@@ -89,8 +100,17 @@ JavaWriter write(ClassName generatedTypeName, ProvisionBinding binding) {
         ClassName.fromClass(Factory.class),
         providedTypeName));
 
+    // TODO(gak): stop doing this weird thing with the optional when javawriter lets me put fields
+    // in arbitrary places
+    Optional<FieldWriter> loggerField = Optional.absent();
+    if (binding.bindingKind().equals(PROVISION)) {
+      loggerField = Optional.of(factoryWriter.addField(Logger.class, "logger"));
+      loggerField.get().addModifiers(PRIVATE, STATIC, FINAL);
+      loggerField.get().setInitializer("%s.getLogger(%s.class.getCanonicalName())",
+          ClassName.fromClass(Logger.class), factoryWriter.name());
+    }
 
-    MethodWriter getMethodWriter = factoryWriter.addMethod(binding.providedKey().type(), "get");
+    MethodWriter getMethodWriter = factoryWriter.addMethod(keyType, "get");
     getMethodWriter.annotate(Override.class);
     getMethodWriter.addModifiers(PUBLIC);
 
@@ -114,23 +134,26 @@ JavaWriter write(ClassName generatedTypeName, ProvisionBinding binding) {
           .addSnippet("this.membersInjector = membersInjector;");
     }
 
-    ImmutableMap<FrameworkKey, String> names =
+    ImmutableMap<Key, String> names =
         SourceFiles.generateFrameworkReferenceNamesForDependencies(binding.dependencies());
 
-    for (Entry<FrameworkKey, String> nameEntry : names.entrySet()) {
+    for (Entry<Key, String> nameEntry : names.entrySet()) {
       final FieldWriter field;
-      if (nameEntry.getKey().frameworkClass().equals(Provider.class)) {
-        ParameterizedTypeName providerType = ParameterizedTypeName.create(
-            ClassName.fromClass(Provider.class),
-            TypeNames.forTypeMirror(nameEntry.getKey().key().type()));
-        field = factoryWriter.addField(providerType, nameEntry.getValue());
-      } else if (nameEntry.getKey().frameworkClass().equals(MembersInjector.class)) {
-        ParameterizedTypeName membersInjectorType = ParameterizedTypeName.create(
-            ClassName.fromClass(MembersInjector.class),
-            TypeNames.forTypeMirror(nameEntry.getKey().key().type()));
-        field = factoryWriter.addField(membersInjectorType, nameEntry.getValue());
-      } else {
-        throw new IllegalStateException();
+      switch (nameEntry.getKey().kind()) {
+        case PROVIDER:
+          ParameterizedTypeName providerType = ParameterizedTypeName.create(
+              ClassName.fromClass(Provider.class),
+              TypeNames.forTypeMirror(nameEntry.getKey().type()));
+          field = factoryWriter.addField(providerType, nameEntry.getValue());
+          break;
+        case MEMBERS_INJECTOR:
+          ParameterizedTypeName membersInjectorType = ParameterizedTypeName.create(
+              ClassName.fromClass(MembersInjector.class),
+              TypeNames.forTypeMirror(nameEntry.getKey().type()));
+          field = factoryWriter.addField(membersInjectorType, nameEntry.getValue());
+          break;
+        default:
+          throw new AssertionError();
       }
       field.addModifiers(PRIVATE, FINAL);
       constructorWriter.addParameter(field.type(), field.name());
@@ -142,24 +165,34 @@ JavaWriter write(ClassName generatedTypeName, ProvisionBinding binding) {
     List<Snippet> parameters = Lists.newArrayList();
     for (DependencyRequest dependency : binding.dependencies()) {
       parameters.add(frameworkTypeUsageStatement(
-          names.get(FrameworkKey.forDependencyRequest(dependency)), dependency.kind()));
+          Snippet.format(names.get(dependency.key())),
+          dependency.kind()));
     }
     Snippet parametersSnippet = makeParametersSnippet(parameters);
 
     if (binding.bindingKind().equals(PROVISION)) {
-      switch (binding.provisionType()) {
-        case UNIQUE:
-        case SET_VALUES:
-          getMethodWriter.body().addSnippet("return module.%s(%s);",
-              binding.bindingElement().getSimpleName(), parametersSnippet);
-          break;
-        case SET:
-          getMethodWriter.body().addSnippet("return %s.singleton(module.%s(%s));",
-              ClassName.fromClass(Collections.class),
-              binding.bindingElement().getSimpleName(), parametersSnippet);
-          break;
-        default:
-          throw new AssertionError();
+      TypeMirror providesMethodReturnType =
+          MoreElements.asExecutable(binding.bindingElement()).getReturnType();
+      getMethodWriter.body().addSnippet("%s result = module.%s(%s);",
+          TypeNames.forTypeMirror(providesMethodReturnType),
+          binding.bindingElement().getSimpleName(), parametersSnippet);
+      if (!providesMethodReturnType.getKind().isPrimitive()) {
+        getMethodWriter.body().addSnippet(Joiner.on('\n').join(
+            "if (result == null) {",
+            "  %s.warning(%s);",
+            "}"),
+            loggerField.get().name(),
+            StringLiteral.forValue(String.format(
+                "%s.%s provided null. "
+                    + "This is not allowed and will soon throw a NullPointerException.",
+                    binding.bindingTypeElement().getQualifiedName(),
+                    binding.bindingElement())));
+      }
+      if (binding.provisionType().equals(SET)) {
+        getMethodWriter.body().addSnippet("return %s.singleton(result);",
+            ClassName.fromClass(Collections.class));
+      } else {
+        getMethodWriter.body().addSnippet("return result;");
       }
     } else if (binding.memberInjectionRequest().isPresent()) {
       getMethodWriter.body().addSnippet("%1$s instance = new %1$s(%2$s);",
@@ -172,6 +205,6 @@ JavaWriter write(ClassName generatedTypeName, ProvisionBinding binding) {
     }
 
     // TODO(gak): write a sensible toString
-    return writer;
+    return ImmutableSet.of(writer);
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Formatter.java b/compiler/src/main/java/dagger/internal/codegen/Formatter.java
new file mode 100644
index 000000000..76a2facba
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/Formatter.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Function;
+
+/**
+ * A formatter which transforms an instance of a particular type into a string
+ * representation.
+ *
+ * @param <T> the type of the object to be transformed.
+ * @author Christian Gruber
+ * @since 2.0
+ */
+abstract class Formatter<T> implements Function<T, String> {
+
+  /**
+   * Performs the transformation of an object into a string representation.
+   */
+  public abstract String format(T object);
+
+  /**
+   * Performs the transformation of an object into a string representation in
+   * conformity with the {@link Function}{@code <T, String>} contract, delegating
+   * to {@link #format(Object)}.
+   *
+   * @deprecated Override {@link #format(T)} instead.
+   */
+  @SuppressWarnings("javadoc")
+  @Deprecated
+  @Override final public String apply(T object) {
+    return format(object);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkKey.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkKey.java
deleted file mode 100644
index ba4f0d003..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkKey.java
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.auto.value.AutoValue;
-import com.google.common.base.Function;
-import dagger.MembersInjector;
-import javax.inject.Provider;
-
-import static com.google.common.base.Preconditions.checkArgument;
-
-/**
- * A value object that pairs a {@link Key} with a framework class (e.g.: {@link Provider},
- * {@link MembersInjector}) related to that key.
- *
- *  @author Gregory Kick
- *  @since 2.0
- */
-@AutoValue
-abstract class FrameworkKey {
-  static final Function<DependencyRequest, FrameworkKey> REQUEST_TO_FRAMEWORK_KEY =
-      new Function<DependencyRequest, FrameworkKey>() {
-        @Override public FrameworkKey apply(DependencyRequest input) {
-          return forDependencyRequest(input);
-        }
-      };
-
-  // TODO(gak): maybe just put this on DependencyRequest?
-  static FrameworkKey forDependencyRequest(DependencyRequest dependencyRequest) {
-    final Class<?> frameworkClass;
-    switch (dependencyRequest.kind()) {
-      case INSTANCE:
-      case LAZY:
-      case PROVIDER:
-        frameworkClass = Provider.class;
-        break;
-      case MEMBERS_INJECTOR:
-        checkArgument(!dependencyRequest.key().qualifier().isPresent());
-        frameworkClass = MembersInjector.class;
-        break;
-      default:
-        throw new AssertionError();
-    }
-    return new AutoValue_FrameworkKey(dependencyRequest.key(), frameworkClass);
-  }
-
-  abstract Key key();
-  abstract Class<?> frameworkClass();
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/GraphValidator.java
new file mode 100644
index 000000000..7d9954371
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphValidator.java
@@ -0,0 +1,424 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Joiner;
+import com.google.common.base.Optional;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableListMultimap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.ListMultimap;
+import com.google.common.collect.Ordering;
+import com.google.common.collect.Queues;
+import dagger.Component;
+import dagger.Provides;
+import dagger.internal.codegen.ProvisionBinding.BindingType;
+import dagger.internal.codegen.ValidationReport.Builder;
+import java.util.Deque;
+import java.util.Formatter;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Set;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.Name;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.SimpleTypeVisitor6;
+import javax.lang.model.util.Types;
+
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
+import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
+import static dagger.internal.codegen.ErrorMessages.INDENT;
+import static dagger.internal.codegen.ErrorMessages.REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT;
+import static dagger.internal.codegen.ErrorMessages.REQUIRES_PROVIDER_FORMAT;
+import static javax.lang.model.type.TypeKind.VOID;
+import static javax.lang.model.util.ElementFilter.methodsIn;
+
+/**
+ * Performs validation of object graphs rooted in the provision and injection methods of
+ * a {link @Component} interface.
+ *
+ * @author Christian Gruber
+ */
+public class GraphValidator implements Validator<TypeElement> {
+  private final Elements elements;
+  private final Types types;
+  private final InjectBindingRegistry bindingRegistry;
+  private final DependencyRequest.Factory dependencyRequestFactory;
+  private final Key.Factory keyFactory;
+  private final ProvisionBinding.Factory provisionBindingFactory;
+
+  GraphValidator(
+      Elements elements,
+      Types types,
+      InjectBindingRegistry bindingRegistry,
+      DependencyRequest.Factory dependencyRequestFactory,
+      Key.Factory keyFactory,
+      ProvisionBinding.Factory provisionBindingFactory) {
+    this.elements = elements;
+    this.types = types;
+    this.bindingRegistry = bindingRegistry;
+    this.dependencyRequestFactory = dependencyRequestFactory;
+    this.keyFactory = keyFactory;
+    this.provisionBindingFactory = provisionBindingFactory;
+  }
+
+  @Override
+  public ValidationReport<TypeElement> validate(TypeElement subject) {
+    ValidationReport.Builder<TypeElement> reportBuilder = ValidationReport.Builder.about(subject);
+    validateGraph(subject, reportBuilder);
+    return reportBuilder.build();
+  }
+
+  void validateGraph(TypeElement component,
+      ValidationReport.Builder<TypeElement> reportBuilder) {
+    AnnotationMirror componentMirror =
+        getAnnotationMirror(component, Component.class).get();
+    ImmutableSet.Builder<ProvisionBinding> explicitBindingsBuilder = ImmutableSet.builder();
+    ProvisionBinding componentBinding = provisionBindingFactory.forComponent(component);
+    explicitBindingsBuilder.add(componentBinding);
+
+    // Collect Component dependencies.
+    ImmutableSet<TypeElement> componentDependencyTypes = MoreTypes.asTypeElements(types,
+        ConfigurationAnnotations.getComponentDependencies(elements, componentMirror));
+    for (TypeElement componentDependency : componentDependencyTypes) {
+      explicitBindingsBuilder.add(provisionBindingFactory.forComponent(componentDependency));
+      List<ExecutableElement> dependencyMethods =
+          ElementFilter.methodsIn(elements.getAllMembers(componentDependency));
+      for (ExecutableElement method : dependencyMethods) {
+        if (isComponentProvisionMethod(method)) {
+          // MembersInjection methods aren't "provided" explicitly, so ignore them.
+          try {
+            explicitBindingsBuilder.add(provisionBindingFactory.forComponentMethod(method));
+          } catch (IllegalArgumentException e) {
+            // Should not ever get here due to previous component validation.
+            reportBuilder.addItem("Component provision methods cannot have parameters.", method);
+          }
+        }
+      }
+    }
+
+    // Collect transitive modules provisions.
+    ImmutableSet<TypeElement> moduleTypes =
+        MoreTypes.asTypeElements(types, getComponentModules(elements, componentMirror));
+
+    for (TypeElement module : getTransitiveModules(elements, types, moduleTypes)) {
+      // traverse the modules, collect the bindings
+      List<ExecutableElement> moduleMethods = methodsIn(elements.getAllMembers(module));
+      for (ExecutableElement moduleMethod : moduleMethods) {
+        if (isAnnotationPresent(moduleMethod, Provides.class)) {
+          try {
+            explicitBindingsBuilder.add(provisionBindingFactory.forProvidesMethod(moduleMethod));
+          } catch (IllegalArgumentException e) {
+            // Should not ever get here due to previous module validation.
+            reportBuilder.addItem(
+                String.format(ErrorMessages.MALFORMED_MODULE_METHOD_FORMAT,
+                    moduleMethod.getSimpleName(),
+                    MoreElements.asType(moduleMethod.getEnclosingElement()).getQualifiedName()),
+                component);
+          }
+        }
+      }
+    }
+
+    for (DependencyRequest componentMethodRequest : componentMethodRequests(component)) {
+      Deque<Key> cycleStack = Queues.newArrayDeque();
+      Deque<DependencyRequest> dependencyPath = Queues.newArrayDeque();
+      resolveRequest(
+          componentMethodRequest,
+          componentMethodRequest,
+          reportBuilder,
+          explicitBindingsByKey(explicitBindingsBuilder.build()),
+          new LinkedHashSet<Key>(),
+          cycleStack,
+          dependencyPath);
+    }
+  }
+
+  private ImmutableSetMultimap<Key, ProvisionBinding> explicitBindingsByKey(
+      Iterable<ProvisionBinding> bindings) {
+    // Multimaps.index() doesn't do ImmutableSetMultimaps.
+    ImmutableSetMultimap.Builder<Key, ProvisionBinding> builder = ImmutableSetMultimap.builder();
+    for (ProvisionBinding binding : bindings) {
+      builder.put(binding.key(), binding);
+    }
+    return builder.build();
+  }
+
+  private ImmutableList<DependencyRequest> componentMethodRequests(TypeElement componentType) {
+    ImmutableList.Builder<DependencyRequest> interfaceRequestsBuilder = ImmutableList.builder();
+    for (ExecutableElement componentMethod : methodsIn(elements.getAllMembers(componentType))) {
+      if (componentMethod.getModifiers().contains(Modifier.ABSTRACT)) { // Elide Object.*;
+        if (isComponentProvisionMethod(componentMethod)) {
+          interfaceRequestsBuilder.add(
+              dependencyRequestFactory.forComponentProvisionMethod(componentMethod));
+        } else if (isComponentMembersInjectionMethod(componentMethod)) {
+          interfaceRequestsBuilder.add(
+              dependencyRequestFactory.forComponentMembersInjectionMethod(componentMethod));
+        }
+      }
+    }
+    return interfaceRequestsBuilder.build();
+  }
+
+  private void resolveRequest(DependencyRequest request,
+      DependencyRequest rootRequest,
+      ValidationReport.Builder<TypeElement> reportBuilder,
+      ImmutableSetMultimap<Key, ProvisionBinding> explicitBindings,
+      Set<Key> resolvedBindings,
+      Deque<Key> cycleStack,
+      Deque<DependencyRequest> dependencyPath) {
+
+    Key requestKey = request.key();
+    if (cycleStack.contains(requestKey) && !isComponent(requestKey.type())) {
+      resolvedBindings.add(requestKey); // it's present, but bad, and we report that.
+      dependencyPath = Queues.newArrayDeque(dependencyPath); // copy
+      dependencyPath.push(request); // add current request.
+      dependencyPath.pollLast(); // strip off original request from the component method.
+      ImmutableList<String> printableDependencyPath = FluentIterable.from(dependencyPath)
+          .transform(DependencyRequestFormatter.instance()).toList().reverse();
+      TypeElement componentType =
+          MoreElements.asType(rootRequest.requestElement().getEnclosingElement());
+      // TODO(user): Restructure to provide a hint for the start and end of the cycle.
+      reportBuilder.addItem(
+          String.format(ErrorMessages.CONTAINS_DEPENDENCY_CYCLE_FORMAT,
+              componentType.getQualifiedName(),
+              rootRequest.requestElement().getSimpleName(),
+              Joiner.on("\n").join(printableDependencyPath)),
+          rootRequest.requestElement());
+
+      return;
+    }
+    if (resolvedBindings.contains(requestKey)) {
+      return;
+    }
+
+    dependencyPath.push(request);
+    cycleStack.push(requestKey);
+    try {
+      switch (request.kind()) {
+        case INSTANCE:
+        case LAZY:
+        case PROVIDER:
+          // First, check for explicit keys (those from modules and components)
+          ImmutableSet<ProvisionBinding> explicitBindingsForKey = explicitBindings.get(requestKey);
+          if (explicitBindingsForKey.isEmpty()) {
+            // If the key is Map<K, V>, get its implicit binding key which is Map<K, Provider<V>>
+            Optional<Key> key = keyFactory.implicitMapProviderKeyFrom(request.key());
+            if (key.isPresent()) {
+              DependencyRequest implicitRequest =
+                  dependencyRequestFactory.forImplicitMapBinding(request, key.get());
+              Binding implicitBinding =
+                  provisionBindingFactory.forImplicitMapBinding(request, implicitRequest);
+              resolveRequest(Iterables.getOnlyElement(implicitBinding.dependencies()),
+                  rootRequest, reportBuilder, explicitBindings, resolvedBindings, cycleStack,
+                  dependencyPath);
+              resolvedBindings.add(requestKey);
+            } else {
+              // no explicit binding, look it up or fail.
+              Optional<ProvisionBinding> provisionBinding =
+                  findProvidableType(requestKey, reportBuilder, rootRequest, dependencyPath);
+              if (provisionBinding.isPresent()) {
+                // found a binding, resolve its deps and then mark it resolved
+                for (DependencyRequest dependency : provisionBinding.get().implicitDependencies()) {
+                  resolveRequest(dependency, rootRequest, reportBuilder, explicitBindings,
+                      resolvedBindings, cycleStack, dependencyPath);
+                }
+                resolvedBindings.add(requestKey);
+              }
+            }
+          } else {
+            // If this is an explicit Map<K, V> request then add in any map binding provision
+            // methods which are implied by and must collide with explicit Map<K, V> bindings.
+            Optional<Key> underlyingMapKey = keyFactory.implicitMapProviderKeyFrom(request.key());
+            if (underlyingMapKey.isPresent()) {
+              explicitBindingsForKey = ImmutableSet.<ProvisionBinding>builder()
+                  .addAll(explicitBindingsForKey)
+                  .addAll(explicitBindings.get(underlyingMapKey.get()))
+                  .build();
+            }
+            if (explicitBindingsForKey.size() > 1) {
+              // Multiple Explicit bindings. Validate that they are multi-bindings.
+              ImmutableListMultimap<BindingType, ProvisionBinding> bindingsByType =
+                  ProvisionBinding.bindingTypesFor(explicitBindingsForKey);
+              if (bindingsByType.keySet().size() > 1) {
+                reportMultipleBindingTypes(rootRequest, requestKey, bindingsByType, reportBuilder);
+              } else if (getOnlyElement(bindingsByType.keySet()).equals(BindingType.UNIQUE)) {
+                reportDuplicateBindings(rootRequest, requestKey, bindingsByType, reportBuilder);
+              }
+            }
+            for (Binding explicitBinding : explicitBindingsForKey) {
+              for (DependencyRequest dependency : explicitBinding.dependencies()) {
+                resolveRequest(dependency, rootRequest, reportBuilder, explicitBindings,
+                    resolvedBindings, cycleStack, dependencyPath);
+              }
+            }
+            resolvedBindings.add(requestKey);
+          }
+          break;
+        case MEMBERS_INJECTOR:
+          // no explicit deps for members injection, so just look it up
+          Optional<MembersInjectionBinding> membersInjectionBinding =
+              Optional.fromNullable(bindingRegistry.getOrFindMembersInjectionBinding(requestKey));
+          if (membersInjectionBinding.isPresent()) {
+            // found a binding, resolve its deps and then mark it resolved
+            for (DependencyRequest dependency : membersInjectionBinding.get().dependencies()) {
+              resolveRequest(dependency, rootRequest, reportBuilder, explicitBindings,
+                  resolvedBindings, cycleStack, dependencyPath);
+            }
+            resolvedBindings.add(requestKey);
+          }
+          break;
+        default:
+          throw new AssertionError();
+      }
+    } finally {
+      dependencyPath.pop();
+      cycleStack.pop();
+    }
+  }
+
+  @SuppressWarnings("resource") // Appendable is a StringBuilder.
+  private void reportDuplicateBindings(DependencyRequest rootRequest, Key requestKey,
+      ListMultimap<BindingType, ProvisionBinding> bindingsByType,
+      ValidationReport.Builder<TypeElement> reportBuilder) {
+    StringBuilder builder = new StringBuilder();
+    new Formatter(builder).format(ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT,
+        KeyFormatter.instance().format(requestKey));
+    for (ProvisionBinding binding : bindingsByType.values()) {
+      builder.append('\n').append(INDENT);
+      builder.append(ProvisionBindingFormatter.instance().format(binding));
+    }
+    reportBuilder.addItem(builder.toString(), rootRequest.requestElement());
+  }
+
+  @SuppressWarnings("resource") // Appendable is a StringBuilder.
+  private void reportMultipleBindingTypes(DependencyRequest rootRequest, Key requestKey,
+      ListMultimap<BindingType, ProvisionBinding> bindingsByType,
+      ValidationReport.Builder<TypeElement> reportBuilder) {
+    StringBuilder builder = new StringBuilder();
+    new Formatter(builder).format(ErrorMessages.MULTIPLE_BINDING_TYPES_FOR_KEY_FORMAT,
+        KeyFormatter.instance().format(requestKey));
+    for (BindingType type :
+        Ordering.natural().immutableSortedCopy(bindingsByType.keySet())) {
+      builder.append(INDENT);
+      builder.append(formatBindingType(type));
+      builder.append(" bindings:\n");
+      for (ProvisionBinding binding : bindingsByType.get(type)) {
+        builder.append(INDENT).append(INDENT);
+        builder.append(ProvisionBindingFormatter.instance().format(binding));
+        builder.append('\n');
+      }
+    }
+    reportBuilder.addItem(builder.toString(), rootRequest.requestElement());
+  }
+
+  private String formatBindingType(BindingType type) {
+    switch(type) {
+      case MAP:
+        return "Map";
+      case SET:
+        return "Set";
+      case UNIQUE:
+        return "Unique";
+      default:
+        throw new IllegalStateException("Unknown binding type: " + type);
+    }
+  }
+
+  // TODO(user) determine what bits of InjectBindingRegistry's findOrCreate logic to factor out.
+  private Optional<ProvisionBinding> findProvidableType(Key key, Builder<TypeElement> reportBuilder,
+      DependencyRequest rootRequest, Deque<DependencyRequest> dependencyPath) {
+    Optional<ProvisionBinding> binding = bindingRegistry.getOrFindProvisionBinding(key);
+    if (!binding.isPresent()) {
+      TypeMirror type = key.type();
+      Name typeName = MoreElements.asType(types.asElement(type)).getQualifiedName();
+      boolean requiresProvidesMethod = type.accept(new SimpleTypeVisitor6<Boolean, Void>() {
+        @Override protected Boolean defaultAction(TypeMirror e, Void p) {
+          return true;
+        }
+
+        @Override public Boolean visitDeclared(DeclaredType type, Void ignored) {
+          // Note - this logic is also in InjectConstructorValidator but is woven into errors.
+          TypeElement typeElement = MoreElements.asType(type.asElement());
+          if (typeElement.getTypeParameters().isEmpty()
+              && typeElement.getKind().equals(ElementKind.CLASS)
+              && !typeElement.getModifiers().contains(Modifier.ABSTRACT)) {
+            return false;
+          }
+          return true;
+        }
+      }, null);
+      StringBuilder errorMessage = new StringBuilder();
+      if(requiresProvidesMethod) {
+        errorMessage.append(String.format(REQUIRES_PROVIDER_FORMAT, typeName));
+      } else {
+        errorMessage.append(
+            String.format(REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT, typeName));
+      }
+      if (key.isValidMembersInjectionKey()
+          && !bindingRegistry.getOrFindMembersInjectionBinding(key).injectionSites().isEmpty()) {
+        errorMessage.append(" ").append(ErrorMessages.MEMBERS_INJECTION_DOES_NOT_IMPLY_PROVISION);
+      }
+      dependencyPath = Queues.newArrayDeque(dependencyPath); // copy
+      dependencyPath.pollLast();
+      ImmutableList<String> printableDependencyPath = FluentIterable.from(dependencyPath)
+          .transform(DependencyRequestFormatter.instance()).toList().reverse();
+      for(String dependency : printableDependencyPath) {
+        errorMessage.append("\n").append(dependency);
+      }
+      reportBuilder.addItem(errorMessage.toString(), rootRequest.requestElement());
+    }
+    return binding;
+  }
+
+  private boolean isComponent(TypeMirror type) {
+    // No need to fully validate. Components themselves will be validated by the ComponentValidator
+    return MoreElements.isAnnotationPresent(types.asElement(type), Component.class);
+  }
+
+  private boolean isComponentProvisionMethod(ExecutableElement method) {
+    return method.getParameters().isEmpty()
+        && !method.getReturnType().getKind().equals(VOID)
+        && !elements.getTypeElement(Object.class.getCanonicalName())
+            .equals(method.getEnclosingElement());
+  }
+
+  private boolean isComponentMembersInjectionMethod(ExecutableElement method) {
+    List<? extends VariableElement> parameters = method.getParameters();
+    TypeMirror returnType = method.getReturnType();
+    return parameters.size() == 1
+        && (returnType.getKind().equals(VOID)
+            || MoreTypes.equivalence().equivalent(returnType, parameters.get(0).asType()))
+        && !elements.getTypeElement(Object.class.getCanonicalName())
+            .equals(method.getEnclosingElement());
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index 836d33cca..b05cfc62d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -15,47 +15,193 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreElements;
 import com.google.common.base.Optional;
+import com.google.common.base.Predicate;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
+import com.google.common.collect.Queues;
+import com.google.common.collect.Sets;
+import dagger.Component;
+import dagger.Provides;
+import dagger.internal.codegen.writer.ClassName;
+import java.util.Deque;
+import java.util.List;
 import java.util.Map;
+import java.util.Set;
+import javax.annotation.processing.Messager;
 import javax.inject.Inject;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+import javax.tools.Diagnostic.Kind;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.base.Verify.verify;
+import static dagger.internal.codegen.Key.Kind.PROVIDER;
 
 /**
  * Maintains the collection of provision bindings from {@link Inject} constructors and members
  * injection bindings from {@link Inject} fields and methods known to the annotation processor.
+ * Note that this registry <b>does not</b> handle any explicit bindings (those from {@link Provides}
+ * methods, {@link Component} dependencies, etc.).
  *
  * @author Gregory Kick
  */
 final class InjectBindingRegistry {
-  private final Map<Key, ProvisionBinding> provisionBindingsByKey;
-  private final Map<Key, MembersInjectionBinding> membersInjectionBindingsByKey;
-  private final Key.Factory keyFactory;
-
-  InjectBindingRegistry(Key.Factory keyFactory) {
-    this.provisionBindingsByKey = Maps.newLinkedHashMap();
-    this.membersInjectionBindingsByKey = Maps.newLinkedHashMap();
-    this.keyFactory = keyFactory;
+  private final Elements elements;
+  private final Types types;
+  private final Messager messager;
+  private final ProvisionBinding.Factory provisionBindingFactory;
+  private final FactoryGenerator factoryGenerator;
+  private final MembersInjectionBinding.Factory membersInjectionBindingFactory;
+  private final MembersInjectorGenerator membersInjectorGenerator;
+
+  private final Map<Key, Binding> bindingsByKey = Maps.newLinkedHashMap();
+  private final Deque<Binding> bindingsRequiringGeneration = Queues.newArrayDeque();
+  private final Set<Binding> materializedBindings = Sets.newLinkedHashSet();
+
+  InjectBindingRegistry(Elements elements,
+      Types types,
+      Messager messager,
+      ProvisionBinding.Factory provisionBindingFactory,
+      FactoryGenerator factoryGenerator,
+      MembersInjectionBinding.Factory membersInjectionBindingFactory,
+      MembersInjectorGenerator membersInjectorGenerator) {
+    this.elements = elements;
+    this.types = types;
+    this.messager = messager;
+    this.provisionBindingFactory = provisionBindingFactory;
+    this.factoryGenerator = factoryGenerator;
+    this.membersInjectionBindingFactory = membersInjectionBindingFactory;
+    this.membersInjectorGenerator = membersInjectorGenerator;
+  }
+
+  /**
+   * This method ensures that sources for all registered {@link Binding bindings} (either
+   * {@linkplain #registerBinding explicitly} or implicitly via
+   * {@link #getOrFindMembersInjectionBinding} or {@link #getOrFindProvisionBinding}) are generated.
+   */
+  void generateSourcesForRequiredBindings() throws SourceFileGenerationException {
+    for (Binding binding = bindingsRequiringGeneration.poll();
+        binding != null;
+        binding = bindingsRequiringGeneration.poll()) {
+      switch (binding.key().kind()) {
+        case PROVIDER:
+          factoryGenerator.generate((ProvisionBinding) binding);
+          break;
+        case MEMBERS_INJECTOR:
+          membersInjectorGenerator.generate((MembersInjectionBinding) binding);
+          break;
+        default:
+          throw new AssertionError();
+      }
+      materializedBindings.add(binding);
+    }
   }
 
-  void registerProvisionBinding(ProvisionBinding binding) {
-    ProvisionBinding previousValue = provisionBindingsByKey.put(binding.providedKey(), binding);
-    checkState(previousValue == null);
+  <B extends Binding> B registerBinding(B binding) {
+    return registerBinding(binding, true);
   }
 
-  void registerMembersInjectionBinding(MembersInjectionBinding binding) {
-    MembersInjectionBinding previousValue = membersInjectionBindingsByKey.put(
-        keyFactory.forType(binding.bindingElement().asType()), binding);
-    checkState(previousValue == null);
+  private <B extends Binding> B registerBinding(B binding, boolean explicit) {
+    Key key = binding.key();
+    Binding previousValue = bindingsByKey.put(key, binding);
+    checkState(previousValue == null || binding.equals(previousValue),
+        "couldn't register %s. %s was already registered for %s",
+        binding, previousValue, key);
+    if (!materializedBindings.contains(binding) && !bindingsRequiringGeneration.contains(binding)) {
+      switch (key.kind()) {
+        case PROVIDER:
+          ProvisionBinding provisionBinding =  (ProvisionBinding) binding;
+          ClassName factoryName = SourceFiles.factoryNameForProvisionBinding(provisionBinding);
+          if (elements.getTypeElement(factoryName.canonicalName()) == null) {
+            bindingsRequiringGeneration.offer(provisionBinding);
+            if (!explicit) {
+              messager.printMessage(Kind.NOTE, String.format("Generating a Factory for %s. "
+                  + "Prefer to run the dagger processor over that class instead.", key.type()));
+            }
+          }
+          break;
+        case MEMBERS_INJECTOR:
+          MembersInjectionBinding membersInjectionBinding = (MembersInjectionBinding) binding;
+          if (membersInjectionBinding.injectionSites().isEmpty()) {
+            // empty members injection bindings are special and don't need source files.
+            // so, we just pretend
+            materializedBindings.add(binding);
+          } else  {
+            ClassName membersInjectorName =
+                SourceFiles.membersInjectorNameForMembersInjectionBinding(membersInjectionBinding);
+            if (elements.getTypeElement(membersInjectorName.canonicalName()) == null) {
+              bindingsRequiringGeneration.offer(membersInjectionBinding);
+              if (!explicit) {
+                messager.printMessage(Kind.NOTE, String.format(
+                    "Generating a MembersInjector for %s. "
+                          + "Prefer to run the dagger processor over that class instead.",
+                    key.type()));
+              }
+            }
+          }
+          break;
+        default:
+          throw new AssertionError();
+      }
+    }
+    return binding;
   }
 
-  Optional<ProvisionBinding> getProvisionBindingForKey(Key key) {
-    return Optional.fromNullable(provisionBindingsByKey.get(checkNotNull(key)));
+  Optional<ProvisionBinding> getOrFindProvisionBinding(Key key) {
+    checkNotNull(key);
+    checkArgument(key.kind().equals(PROVIDER));
+    if (key.qualifier().isPresent()) {
+      return Optional.absent();
+    }
+    Binding binding = bindingsByKey.get(key);
+    if (binding != null) {
+      verify(binding instanceof ProvisionBinding);
+      return Optional.of((ProvisionBinding) binding);
+    }
+    // ok, let's see if we can find an @Inject constructor
+    TypeElement element = MoreElements.asType(types.asElement(key.type()));
+    List<ExecutableElement> constructors =
+        ElementFilter.constructorsIn(element.getEnclosedElements());
+    ImmutableSet<ExecutableElement> injectConstructors = FluentIterable.from(constructors)
+        .filter(new Predicate<ExecutableElement>() {
+          @Override public boolean apply(ExecutableElement input) {
+            return isAnnotationPresent(input, Inject.class);
+          }
+        }).toSet();
+    switch (injectConstructors.size()) {
+      case 0:
+        // No constructor found.
+        return Optional.absent();
+      case 1:
+        ProvisionBinding constructorBinding = provisionBindingFactory.forInjectConstructor(
+            Iterables.getOnlyElement(injectConstructors));
+        return Optional.of(registerBinding(constructorBinding, false));
+      default:
+        throw new IllegalStateException("Found multiple @Inject constructors: "
+            + injectConstructors);
+    }
   }
 
-  Optional<MembersInjectionBinding> getMembersInjectionBindingForKey(Key key) {
-    return Optional.fromNullable(membersInjectionBindingsByKey.get(checkNotNull(key)));
+  MembersInjectionBinding getOrFindMembersInjectionBinding(Key key) {
+    checkNotNull(key);
+    // TODO(gak): is checking the kind enough?
+    checkArgument(key.isValidMembersInjectionKey());
+    Binding binding = bindingsByKey.get(key);
+    if (binding == null) {
+      TypeElement element = MoreElements.asType(types.asElement(key.type()));
+      binding = registerBinding(membersInjectionBindingFactory.forInjectedType(element), false);
+    }
+    verify(binding instanceof MembersInjectionBinding);
+    return (MembersInjectionBinding) binding;
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
index 1a0959c3c..587df5bc7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
@@ -17,12 +17,7 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.SuperficialValidation;
-import com.google.common.base.Function;
-import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Multimaps;
-import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
-import java.util.Collection;
 import java.util.Set;
 import javax.annotation.processing.Messager;
 import javax.annotation.processing.RoundEnvironment;
@@ -46,29 +41,22 @@
   private final InjectFieldValidator fieldValidator;
   private final InjectMethodValidator methodValidator;
   private final ProvisionBinding.Factory provisionBindingFactory;
-  private final FactoryGenerator factoryGenerator;
-  private final InjectionSite.Factory injectionSiteFactory;
-  private final MembersInjectorGenerator membersInjectorWriter;
+  private final MembersInjectionBinding.Factory membersInjectionBindingFactory;
   private final InjectBindingRegistry injectBindingRegistry;
 
-
   InjectProcessingStep(Messager messager,
       InjectConstructorValidator constructorValidator,
       InjectFieldValidator fieldValidator,
       InjectMethodValidator methodValidator,
       ProvisionBinding.Factory provisionBindingFactory,
-      FactoryGenerator factoryGenerator,
-      InjectionSite.Factory injectionSiteFactory,
-      MembersInjectorGenerator membersInjectorWriter,
+      MembersInjectionBinding.Factory membersInjectionBindingFactory,
       InjectBindingRegistry factoryRegistrar) {
     this.messager = messager;
     this.constructorValidator = constructorValidator;
     this.fieldValidator = fieldValidator;
     this.methodValidator = methodValidator;
     this.provisionBindingFactory = provisionBindingFactory;
-    this.factoryGenerator = factoryGenerator;
-    this.injectionSiteFactory = injectionSiteFactory;
-    this.membersInjectorWriter = membersInjectorWriter;
+    this.membersInjectionBindingFactory = membersInjectionBindingFactory;
     this.injectBindingRegistry = factoryRegistrar;
   }
 
@@ -76,7 +64,8 @@
   public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
     // TODO(gak): add some error handling for bad source files
     final ImmutableSet.Builder<ProvisionBinding> provisions = ImmutableSet.builder();
-    final ImmutableSet.Builder<InjectionSite> memberInjectionSites = ImmutableSet.builder();
+    // TODO(gak): instead, we should collect reports by type and check later
+    final ImmutableSet.Builder<TypeElement> membersInjectedTypes = ImmutableSet.builder();
 
     for (Element injectElement : roundEnv.getElementsAnnotatedWith(Inject.class)) {
       if (SuperficialValidation.validateElement(injectElement)) {
@@ -104,7 +93,7 @@ public Void visitVariableAsField(VariableElement fieldElement, Void p) {
                 report.printMessagesTo(messager);
 
                 if (report.isClean()) {
-                  memberInjectionSites.add(injectionSiteFactory.forInjectField(fieldElement));
+                  membersInjectedTypes.add(MoreElements.asType(fieldElement.getEnclosingElement()));
                 }
 
                 return null;
@@ -118,7 +107,8 @@ public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
                 report.printMessagesTo(messager);
 
                 if (report.isClean()) {
-                  memberInjectionSites.add(injectionSiteFactory.forInjectMethod(methodElement));
+                  membersInjectedTypes.add(
+                      MoreElements.asType(methodElement.getEnclosingElement()));
                 }
 
                 return null;
@@ -127,31 +117,13 @@ public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
       }
     }
 
-    ImmutableListMultimap<TypeElement, InjectionSite> membersInjectionsByType =
-        Multimaps.index(memberInjectionSites.build(),
-            new Function<InjectionSite, TypeElement>() {
-              @Override public TypeElement apply(InjectionSite injectionSite) {
-                return MoreElements.asType(injectionSite.element().getEnclosingElement());
-              }
-            });
-
-    for (Collection<InjectionSite> injectionSites : membersInjectionsByType.asMap().values()) {
-      try {
-        MembersInjectionBinding binding = MembersInjectionBinding.create(injectionSites);
-        membersInjectorWriter.generate(binding);
-        injectBindingRegistry.registerMembersInjectionBinding(binding);
-      } catch (SourceFileGenerationException e) {
-        e.printMessageTo(messager);
-      }
+    for (TypeElement injectedType : membersInjectedTypes.build()) {
+      injectBindingRegistry.registerBinding(
+          membersInjectionBindingFactory.forInjectedType(injectedType));
     }
 
     for (ProvisionBinding binding : provisions.build()) {
-      try {
-        factoryGenerator.generate(binding);
-        injectBindingRegistry.registerProvisionBinding(binding);
-      } catch (SourceFileGenerationException e) {
-        e.printMessageTo(messager);
-      }
+      injectBindingRegistry.registerBinding(binding);
     }
 
     return false;
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
index c1769865e..ec57fe1be 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
@@ -16,17 +16,12 @@
 package dagger.internal.codegen;
 
 import com.google.common.base.Optional;
-import com.google.common.base.Predicate;
-import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
-import java.lang.annotation.Annotation;
-import java.util.List;
 import javax.inject.Qualifier;
 import javax.inject.Scope;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkNotNull;
 
 /**
@@ -65,23 +60,11 @@
   }
 
   static ImmutableSet<? extends AnnotationMirror> getQualifiers(Element element) {
-    return getAnnotatedAnnotations(element, Qualifier.class);
+    return AnnotationMirrors.getAnnotatedAnnotations(element, Qualifier.class);
   }
 
   static ImmutableSet<? extends AnnotationMirror> getScopes(Element element) {
-    return getAnnotatedAnnotations(element, Scope.class);
-  }
-
-  private static ImmutableSet<? extends AnnotationMirror> getAnnotatedAnnotations(Element element,
-      final Class<? extends Annotation> annotationType) {
-    List<? extends AnnotationMirror> annotations = element.getAnnotationMirrors();
-    return FluentIterable.from(annotations)
-        .filter(new Predicate<AnnotationMirror>() {
-          @Override public boolean apply(AnnotationMirror input) {
-            return isAnnotationPresent(input.getAnnotationType().asElement(), annotationType);
-          }
-        })
-        .toSet();
+    return AnnotationMirrors.getAnnotatedAnnotations(element, Scope.class);
   }
 
   private InjectionAnnotations() {}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index e52e337e5..0510730c4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -19,10 +19,15 @@
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Function;
-import com.google.common.base.Objects;
+import com.google.common.base.MoreObjects;
 import com.google.common.base.Optional;
+import com.google.common.collect.Iterables;
+import dagger.MapKey;
+import dagger.MembersInjector;
 import dagger.Provides;
+import java.util.Map;
 import java.util.Set;
+import javax.inject.Provider;
 import javax.inject.Qualifier;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
@@ -32,10 +37,12 @@
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
+import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.ConfigurationAnnotations.getMapKeys;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.ElementKind.METHOD;
@@ -49,12 +56,35 @@
  */
 @AutoValue
 abstract class Key {
+  /**
+   * The aspect of the framework for which a {@link Key} is an identifier. Particularly, whether a
+   * key is for a {@link Provider} or a {@link MembersInjector}.
+   */
+  enum Kind {
+    PROVIDER(Provider.class),
+    MEMBERS_INJECTOR(MembersInjector.class),
+    ;
+
+    private final Class<?> frameworkClass;
+
+    Kind(Class<?> frameworkClass) {
+      this.frameworkClass = frameworkClass;
+    }
+
+    Class<?> frameworkClass() {
+      return frameworkClass;
+    }
+  }
+
+  /** Returns the particular kind of this key. */
+  abstract Kind kind();
+
   /**
    * A {@link javax.inject.Qualifier} annotation that provides a unique namespace prefix
    * for the type of this key.
    *
    * Despite documentation in {@link AnnotationMirror}, equals and hashCode aren't implemented
-   * to represent logical equality, so {@link MoreTypes#annotationMirrorEquivalence()}
+   * to represent logical equality, so {@link AnnotationMirrors#equivalence()}
    * provides this facility.
    */
   abstract Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedQualifier();
@@ -80,10 +110,21 @@ TypeMirror type() {
     return wrappedType().get();
   }
 
+  boolean isValidMembersInjectionKey() {
+    return !qualifier().isPresent()
+        && type().accept(new SimpleTypeVisitor6<Boolean, Void>(false) {
+          @Override
+          public Boolean visitDeclared(DeclaredType t, Void p) {
+            return t.getTypeArguments().isEmpty();
+          }
+        }, null);
+  }
+
   @Override
   public String toString() {
-    return Objects.toStringHelper(Key.class)
+    return MoreObjects.toStringHelper(Key.class)
         .omitNullValues()
+        .addValue(kind())
         .add("qualifier", qualifier().orNull())
         .add("type", type())
         .toString();
@@ -107,12 +148,21 @@ private TypeElement getSetElement() {
       return elements.getTypeElement(Set.class.getCanonicalName());
     }
 
+    private TypeElement getMapElement() {
+      return elements.getTypeElement(Map.class.getCanonicalName());
+    }
+
+    private TypeElement getProviderElement() {
+      return elements.getTypeElement(Provider.class.getCanonicalName());
+    }
+
     Key forComponentMethod(ExecutableElement componentMethod) {
       checkNotNull(componentMethod);
       checkArgument(componentMethod.getKind().equals(METHOD));
       TypeMirror returnType = normalize(componentMethod.getReturnType());
       Optional<AnnotationMirror> qualifier = getQualifier(componentMethod);
-      return new AutoValue_Key(rewrap(qualifier), MoreTypes.equivalence().wrap(returnType));
+      return new AutoValue_Key(Kind.PROVIDER, rewrap(qualifier),
+          MoreTypes.equivalence().wrap(returnType));
     }
 
     Key forProvidesMethod(ExecutableElement e) {
@@ -124,15 +174,30 @@ Key forProvidesMethod(ExecutableElement e) {
       Optional<AnnotationMirror> qualifier = getQualifier(e);
       switch (providesAnnotation.type()) {
         case UNIQUE:
-          return new AutoValue_Key(rewrap(qualifier), MoreTypes.equivalence().wrap(returnType));
+          return new AutoValue_Key(Kind.PROVIDER, rewrap(qualifier),
+              MoreTypes.equivalence().wrap(returnType));
         case SET:
           TypeMirror setType = types.getDeclaredType(getSetElement(), returnType);
-          return new AutoValue_Key(rewrap(qualifier), MoreTypes.equivalence().wrap(setType));
+          return new AutoValue_Key(Kind.PROVIDER, rewrap(qualifier),
+              MoreTypes.equivalence().wrap(setType));
+        case MAP:
+          AnnotationMirror mapKeyAnnotation = Iterables.getOnlyElement(getMapKeys(e));
+          MapKey mapKey =
+              mapKeyAnnotation.getAnnotationType().asElement().getAnnotation(MapKey.class);
+          TypeElement keyTypeElement =
+              mapKey.unwrapValue() ? Util.getKeyTypeElement(mapKeyAnnotation, elements)
+                  : (TypeElement) mapKeyAnnotation.getAnnotationType().asElement();
+          TypeMirror valueType = types.getDeclaredType(getProviderElement(), returnType);
+          TypeMirror mapType =
+              types.getDeclaredType(getMapElement(), keyTypeElement.asType(), valueType);
+          return new AutoValue_Key(Kind.PROVIDER, rewrap(qualifier),
+              MoreTypes.equivalence().wrap(mapType));
         case SET_VALUES:
           // TODO(gak): do we want to allow people to use "covariant return" here?
           checkArgument(returnType.getKind().equals(DECLARED));
           checkArgument(((DeclaredType) returnType).asElement().equals(getSetElement()));
-          return new AutoValue_Key(rewrap(qualifier), MoreTypes.equivalence().wrap(returnType));
+          return new AutoValue_Key(Kind.PROVIDER, rewrap(qualifier),
+              MoreTypes.equivalence().wrap(returnType));
         default:
           throw new AssertionError();
       }
@@ -144,19 +209,47 @@ Key forInjectConstructor(ExecutableElement e) {
       checkArgument(!getQualifier(e).isPresent());
       // Must use the enclosing element.  The return type is void for constructors(?!)
       TypeMirror type = e.getEnclosingElement().asType();
-      return new AutoValue_Key(
+      return new AutoValue_Key(Kind.PROVIDER,
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           MoreTypes.equivalence().wrap(type));
     }
 
-    Key forType(TypeMirror type) {
-      return new AutoValue_Key(
+    Key forComponent(TypeMirror type) {
+      return new AutoValue_Key(Kind.PROVIDER,
+          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
+          MoreTypes.equivalence().wrap(normalize(type)));
+    }
+
+    Key forMembersInjectedType(TypeMirror type) {
+      return new AutoValue_Key(Kind.MEMBERS_INJECTOR,
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           MoreTypes.equivalence().wrap(normalize(type)));
     }
 
     Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
-      return new AutoValue_Key(rewrap(qualifier), MoreTypes.equivalence().wrap(normalize(type)));
+      return new AutoValue_Key(Kind.PROVIDER,
+          rewrap(qualifier), MoreTypes.equivalence().wrap(normalize(type)));
+    }
+
+    /**
+     * Optionally extract a {@link Key} for the underlying provision binding(s) if such a
+     * valid key can be inferred from the given key.  Specifically, if the key represents a
+     * {@link Map}{@code <K, V>}, a key of {@code Map<K, Provider<V>>} will be returned.
+     */
+    Optional<Key> implicitMapProviderKeyFrom(Key possibleMapKey) {
+      if (MoreTypes.isTypeOf(Map.class, possibleMapKey.type())) {
+        DeclaredType declaredMapType = MoreTypes.asDeclared(possibleMapKey.type());
+        TypeMirror mapValueType = Util.getValueTypeOfMap(declaredMapType);
+        if (!MoreTypes.isTypeOf(Provider.class, mapValueType)) {
+          DeclaredType keyType = Util.getKeyTypeOfMap(declaredMapType);
+          DeclaredType providerType = types.getDeclaredType(getProviderElement(), mapValueType);
+          TypeMirror mapType = types.getDeclaredType(getMapElement(), keyType, providerType);
+          return Optional.<Key>of(new AutoValue_Key(Kind.PROVIDER,
+              possibleMapKey.wrappedQualifier(),
+              MoreTypes.equivalence().wrap(mapType)));
+        }
+      }
+      return Optional.absent();
     }
 
     private Optional<Equivalence.Wrapper<AnnotationMirror>>
diff --git a/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java b/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
new file mode 100644
index 000000000..146d03c04
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+/**
+ * Formats a {@link Key} into a {@link String} suitable for use in error messages
+ *
+ * @author Christian Gruber
+ * @since 2.0
+ */
+final class KeyFormatter extends Formatter<Key> {
+  private static final KeyFormatter INSTANCE = new KeyFormatter();
+
+  static KeyFormatter instance() {
+    return INSTANCE;
+  }
+
+  @Override public String format(Key request) {
+    StringBuilder builder = new StringBuilder();
+    if (request.qualifier().isPresent()) {
+      builder.append(request.qualifier()); // TODO(user): Use AnnotationMirrorFormatter.
+      builder.append(' ');
+    }
+    builder.append(request.type()); // TODO(user): Use TypeMirrorFormatter.
+    return builder.toString();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
new file mode 100644
index 000000000..2fa5ff219
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
@@ -0,0 +1,104 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.value.AutoAnnotation;
+import com.google.common.base.Joiner;
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableSet;
+import dagger.MapKey;
+import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.ClassWriter;
+import dagger.internal.codegen.writer.JavaWriter;
+import dagger.internal.codegen.writer.MethodWriter;
+import java.util.ArrayList;
+import java.util.List;
+import javax.annotation.Generated;
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Name;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
+
+/**
+ * Generates implementations to create{@link MapKey} instances
+ *
+ * @author Chenying Hou
+ * @since 2.0
+ */
+final class MapKeyGenerator extends SourceFileGenerator<Element> {
+  MapKeyGenerator(Filer filer) {
+    super(filer);
+  }
+
+  @Override
+  ClassName nameGeneratedType(Element e) {
+    ClassName enclosingClassName = ClassName.fromTypeElement((TypeElement)e);
+    return enclosingClassName.topLevelClassName().peerNamed(
+        enclosingClassName.classFileName() + "Creator");
+  }
+
+  @Override
+  Iterable<? extends Element> getOriginatingElements(Element e) {
+    return ImmutableSet.of(e);
+  }
+
+  @Override
+  Optional<? extends Element> getElementForErrorReporting(Element e) {
+    return Optional.of(e);
+  }
+
+  @Override
+  ImmutableSet<JavaWriter> write(ClassName generatedTypeName, Element e) {
+    JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
+    ClassWriter mapKeyWriter = writer.addClass(generatedTypeName.simpleName());
+    mapKeyWriter.annotate(Generated.class).setValue(ComponentProcessor.class.getName());
+    mapKeyWriter.addModifiers(PUBLIC);
+
+    //create map key create method, which will return an instance of map key
+    MethodWriter getMethodWriter = mapKeyWriter.addMethod(e.asType(), "create");
+    //get parameter list of create method
+    List<? extends Element> enclosingElements = e.getEnclosedElements();
+    List<String> paraList = new ArrayList<String>();
+
+    //Using AutoAnnotation to generate mapkey creator files later
+    getMethodWriter.annotate(AutoAnnotation.class);
+    getMethodWriter.addModifiers(PUBLIC, STATIC);
+
+    for (Element element : enclosingElements) {
+      if (element instanceof ExecutableElement) {
+        ExecutableElement executableElement = (ExecutableElement) element;
+        Name parameterName = executableElement.getSimpleName();
+        getMethodWriter.addParameter(
+            (TypeElement) ((DeclaredType) (executableElement.getReturnType())).asElement(),
+            parameterName.toString());
+        paraList.add(parameterName.toString());
+      } else {
+        throw new IllegalStateException();
+      }
+    }
+
+    getMethodWriter.body().addSnippet(
+        "return new AutoAnnotation_" + generatedTypeName.simpleName() + "_create(%s);",
+        Joiner.on(", ").join(paraList));
+
+    return ImmutableSet.of(writer);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
new file mode 100644
index 000000000..94513a31e
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.SuperficialValidation;
+import dagger.MapKey;
+import java.util.Set;
+import javax.annotation.processing.Messager;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * The annotation processor responsible for validating the mapKey annotation and auto-generate
+ * implementation of annotations marked with &#064MapKey where necessary.
+ *
+ * @author Chenying Hou
+ * @since 2.0
+ */
+public class MapKeyProcessingStep implements ProcessingStep {
+  private final Messager messager;
+  private final MapKeyValidator mapKeyValidator;
+  private final MapKeyGenerator mapKeyGenerator;
+
+  MapKeyProcessingStep(Messager messager, MapKeyValidator mapKeyValidator, MapKeyGenerator mapKeyGenerator) {
+    this.messager = messager;
+    this.mapKeyValidator = mapKeyValidator;
+    this.mapKeyGenerator = mapKeyGenerator;
+  }
+
+  @Override
+  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
+    if (!roundEnv.getElementsAnnotatedWith(MapKey.class).isEmpty()) {
+      // for each element annotated with @mapKey, validate it and auto generate key creator file for
+      // any unwrapped key
+      for (Element element : roundEnv.getElementsAnnotatedWith(MapKey.class)) {
+        if (SuperficialValidation.validateElement(element)) {
+          ValidationReport<Element> mapKeyReport = mapKeyValidator.validate(element);
+          mapKeyReport.printMessagesTo(messager);
+
+          if (mapKeyReport.isClean()) {
+            MapKey mapkey = element.getAnnotation(MapKey.class);
+            if (!mapkey.unwrapValue()) {
+              try {
+                mapKeyGenerator.generate(element);
+              } catch (SourceFileGenerationException e) {
+                e.printMessageTo(messager);
+              }
+            }
+          }
+        }
+      }
+    }
+    return false;
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyValidator.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyValidator.java
new file mode 100644
index 000000000..8411b20fb
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyValidator.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import dagger.MapKey;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+
+import static dagger.internal.codegen.ErrorMessages.MAPKEY_WITHOUT_FIELDS;
+
+/**
+ * A {@link Validator} for {@link MapKey} Annotation.
+ *
+ * @author Chenying Hou
+ * @since 2.0
+ */
+final class MapKeyValidator implements Validator<Element> {
+  @Override
+  public ValidationReport<Element> validate(Element element) {
+    ValidationReport.Builder<Element> builder = ValidationReport.Builder.about(element);
+    if (((TypeElement) element).getEnclosedElements().isEmpty()) {
+      builder.addItem(MAPKEY_WITHOUT_FIELDS, element);
+    }
+    return builder.build();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index d55980e7c..afa771b36 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -18,11 +18,11 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Function;
+import com.google.common.base.Optional;
 import com.google.common.collect.ComparisonChain;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSortedSet;
-import com.google.common.collect.Iterables;
 import com.google.common.collect.Ordering;
 import java.util.Set;
 import javax.inject.Inject;
@@ -31,10 +31,15 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.ElementKindVisitor6;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
+import static javax.lang.model.type.TypeKind.NONE;
 
 /**
  * Represents the full members injection of a particular type. This does not pay attention to
@@ -47,39 +52,10 @@
 abstract class MembersInjectionBinding extends Binding {
   @Override abstract TypeElement bindingElement();
 
-  /**
-   * Creates a {@link MembersInjectionBinding} for the given bindings.
-   *
-   * @throws IllegalArgumentException if the bindings are not all associated with the same type.
-   */
-  static MembersInjectionBinding create(Iterable<InjectionSite> injectionSites) {
-    ImmutableSortedSet<InjectionSite> injectionSiteSet =
-        ImmutableSortedSet.copyOf(INJECTION_ORDERING, injectionSites);
-    TypeElement injectedTypeElement = Iterables.getOnlyElement(FluentIterable.from(injectionSiteSet)
-        .transform(new Function<InjectionSite, TypeElement>() {
-          @Override public TypeElement apply(InjectionSite injectionSite) {
-            return MoreElements.asType(injectionSite.element().getEnclosingElement());
-          }
-        })
-        .toSet());
-    ImmutableSet<DependencyRequest> dependencies = FluentIterable.from(injectionSiteSet)
-        .transformAndConcat(new Function<InjectionSite, Set<DependencyRequest>>() {
-          @Override public Set<DependencyRequest> apply(InjectionSite input) {
-            return input.dependencies();
-          }
-        })
-        .toSet();
-    return new AutoValue_MembersInjectionBinding(
-        dependencies, injectedTypeElement, injectionSiteSet);
-  }
-
   /** The set of individual sites where {@link Inject} is applied. */
   abstract ImmutableSortedSet<InjectionSite> injectionSites();
 
-  /** The total set of dependencies required by all injection sites. */
-  final ImmutableSet<DependencyRequest> dependencySet() {
-    return ImmutableSet.copyOf(dependencies());
-  }
+  abstract Optional<DependencyRequest> parentInjectorRequest();
 
   private static final Ordering<InjectionSite> INJECTION_ORDERING =
       new Ordering<InjectionSite>() {
@@ -114,29 +90,101 @@ private int targetIndexInEnclosing(InjectionSite injectionSite)  {
     abstract Element element();
 
     abstract ImmutableSet<DependencyRequest> dependencies();
+  }
 
-    static final class Factory {
-      private final DependencyRequest.Factory dependencyRequestFactory;
+  static final class Factory {
+    private final Elements elements;
+    private final Types types;
+    private final Key.Factory keyFactory;
+    private final DependencyRequest.Factory dependencyRequestFactory;
+
+    Factory(Elements elements, Types types, Key.Factory keyFactory,
+        DependencyRequest.Factory dependencyRequestFactory) {
+      this.elements = checkNotNull(elements);
+      this.types = checkNotNull(types);
+      this.keyFactory = checkNotNull(keyFactory);
+      this.dependencyRequestFactory = checkNotNull(dependencyRequestFactory);
+    }
 
-      Factory(DependencyRequest.Factory dependencyRequestFactory) {
-        this.dependencyRequestFactory = checkNotNull(dependencyRequestFactory);
-      }
+    private InjectionSite injectionSiteForInjectMethod(ExecutableElement methodElement) {
+      checkNotNull(methodElement);
+      checkArgument(methodElement.getKind().equals(ElementKind.METHOD));
+      checkArgument(isAnnotationPresent(methodElement, Inject.class));
+      return new AutoValue_MembersInjectionBinding_InjectionSite(InjectionSite.Kind.METHOD,
+          methodElement,
+          dependencyRequestFactory.forRequiredVariables(methodElement.getParameters()));
+    }
 
-      InjectionSite forInjectMethod(ExecutableElement methodElement) {
-        checkNotNull(methodElement);
-        checkArgument(methodElement.getKind().equals(ElementKind.METHOD));
-        checkArgument(isAnnotationPresent(methodElement, Inject.class));
-        return new AutoValue_MembersInjectionBinding_InjectionSite(Kind.METHOD, methodElement,
-            dependencyRequestFactory.forRequiredVariables(methodElement.getParameters()));
-      }
+    private InjectionSite injectionSiteForInjectField(VariableElement fieldElement) {
+      checkNotNull(fieldElement);
+      checkArgument(fieldElement.getKind().equals(ElementKind.FIELD));
+      checkArgument(isAnnotationPresent(fieldElement, Inject.class));
+      return new AutoValue_MembersInjectionBinding_InjectionSite(InjectionSite.Kind.FIELD,
+          fieldElement,
+          ImmutableSet.of(dependencyRequestFactory.forRequiredVariable(fieldElement)));
+    }
 
-      InjectionSite forInjectField(VariableElement fieldElement) {
-        checkNotNull(fieldElement);
-        checkArgument(fieldElement.getKind().equals(ElementKind.FIELD));
-        checkArgument(isAnnotationPresent(fieldElement, Inject.class));
-        return new AutoValue_MembersInjectionBinding_InjectionSite(Kind.FIELD, fieldElement,
-            ImmutableSet.of(dependencyRequestFactory.forRequiredVariable(fieldElement)));
+    MembersInjectionBinding forInjectedType(TypeElement typeElement) {
+      ImmutableSortedSet.Builder<InjectionSite> injectionSitesBuilder =
+          ImmutableSortedSet.orderedBy(INJECTION_ORDERING);
+      for (Element enclosedElement : typeElement.getEnclosedElements()) {
+        injectionSitesBuilder.addAll(enclosedElement.accept(
+            new ElementKindVisitor6<Optional<InjectionSite>, Void>(
+                Optional.<InjectionSite>absent()) {
+                  @Override
+                  public Optional<InjectionSite> visitExecutableAsMethod(ExecutableElement e,
+                      Void p) {
+                    return isAnnotationPresent(e, Inject.class)
+                        ? Optional.of(injectionSiteForInjectMethod(e))
+                        : Optional.<InjectionSite>absent();
+                  }
+
+                  @Override
+                  public Optional<InjectionSite> visitVariableAsField(VariableElement e, Void p) {
+                    return isAnnotationPresent(e, Inject.class)
+                        ? Optional.of(injectionSiteForInjectField(e))
+                        : Optional.<InjectionSite>absent();
+                  }
+                }, null).asSet());
       }
+      ImmutableSortedSet<InjectionSite> injectionSites = injectionSitesBuilder.build();
+
+      ImmutableSet<DependencyRequest> dependencies = FluentIterable.from(injectionSites)
+          .transformAndConcat(new Function<InjectionSite, Set<DependencyRequest>>() {
+            @Override public Set<DependencyRequest> apply(InjectionSite input) {
+              return input.dependencies();
+            }
+          })
+          .toSet();
+
+      Optional<DependencyRequest> parentInjectorRequest = nonObjectSupertype(typeElement)
+          .transform(new Function<TypeElement, DependencyRequest>() {
+            @Override public DependencyRequest apply(TypeElement input) {
+              return dependencyRequestFactory.forMembersInjectedType(input);
+            }
+          });
+
+      return new AutoValue_MembersInjectionBinding(
+          keyFactory.forMembersInjectedType(typeElement.asType()),
+          dependencies,
+          new ImmutableSet.Builder<DependencyRequest>()
+              .addAll(dependencies)
+              .addAll(parentInjectorRequest.asSet())
+              .build(),
+          Optional.of(MoreElements.getPackage(typeElement).getQualifiedName().toString()),
+          typeElement,
+          injectionSites,
+          parentInjectorRequest);
+    }
+
+    private Optional<TypeElement> nonObjectSupertype(TypeElement type) {
+      TypeMirror superclass = type.getSuperclass();
+      boolean nonObjectSuperclass = !superclass.getKind().equals(NONE)
+          && !types.isSameType(
+              elements.getTypeElement(Object.class.getCanonicalName()).asType(), superclass);
+      return nonObjectSuperclass
+          ? Optional.of(MoreElements.asType(types.asElement(superclass)))
+          : Optional.<TypeElement>absent();
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index 773903b45..bf3b9635a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -22,6 +22,7 @@
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import dagger.MembersInjector;
 import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
@@ -90,7 +91,7 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
   }
 
   @Override
-  JavaWriter write(ClassName injectorClassName, MembersInjectionBinding binding) {
+  ImmutableSet<JavaWriter> write(ClassName injectorClassName, MembersInjectionBinding binding) {
     ClassName injectedClassName = ClassName.fromTypeElement(binding.bindingElement());
 
     JavaWriter writer = JavaWriter.inPackage(injectedClassName.packageName());
@@ -113,7 +114,6 @@ JavaWriter write(ClassName injectorClassName, MembersInjectionBinding binding) {
         "  throw new NullPointerException(\"Cannot inject members into a null reference\");",
         "}"));
 
-
     Optional<TypeElement> supertype = supertype(binding.bindingElement());
     if (supertype.isPresent()) {
       ParameterizedTypeName supertypeMemebersInjectorType = ParameterizedTypeName.create(
@@ -128,26 +128,30 @@ JavaWriter write(ClassName injectorClassName, MembersInjectionBinding binding) {
       injectMembersWriter.body().addSnippet("supertypeInjector.injectMembers(instance);");
     }
 
-    ImmutableMap<FrameworkKey, String> names =
-        SourceFiles.generateFrameworkReferenceNamesForDependencies(binding.dependencySet());
+    ImmutableMap<Key, String> names =
+        SourceFiles.generateFrameworkReferenceNamesForDependencies(
+            ImmutableSet.copyOf(binding.dependencies()));
 
-    ImmutableMap.Builder<FrameworkKey, FieldWriter> dependencyFieldsBuilder =
+    ImmutableMap.Builder<Key, FieldWriter> dependencyFieldsBuilder =
         ImmutableMap.builder();
 
-    for (Entry<FrameworkKey, String> nameEntry : names.entrySet()) {
+    for (Entry<Key, String> nameEntry : names.entrySet()) {
       final FieldWriter field;
-      if (nameEntry.getKey().frameworkClass().equals(Provider.class)) {
-        ParameterizedTypeName providerType = ParameterizedTypeName.create(
-            ClassName.fromClass(Provider.class),
-            TypeNames.forTypeMirror(nameEntry.getKey().key().type()));
-        field = injectorWriter.addField(providerType, nameEntry.getValue());
-      } else if (nameEntry.getKey().frameworkClass().equals(MembersInjector.class)) {
-        ParameterizedTypeName membersInjectorType = ParameterizedTypeName.create(
-            ClassName.fromClass(MembersInjector.class),
-            TypeNames.forTypeMirror(nameEntry.getKey().key().type()));
-        field = injectorWriter.addField(membersInjectorType, nameEntry.getValue());
-      } else {
-        throw new IllegalStateException();
+      switch (nameEntry.getKey().kind()) {
+        case PROVIDER:
+          ParameterizedTypeName providerType = ParameterizedTypeName.create(
+              ClassName.fromClass(Provider.class),
+              TypeNames.forTypeMirror(nameEntry.getKey().type()));
+          field = injectorWriter.addField(providerType, nameEntry.getValue());
+          break;
+        case MEMBERS_INJECTOR:
+          ParameterizedTypeName membersInjectorType = ParameterizedTypeName.create(
+              ClassName.fromClass(MembersInjector.class),
+              TypeNames.forTypeMirror(nameEntry.getKey().type()));
+          field = injectorWriter.addField(membersInjectorType, nameEntry.getValue());
+          break;
+        default:
+          throw new AssertionError();
       }
       field.addModifiers(PRIVATE, FINAL);
       constructorWriter.addParameter(field.type(), field.name());
@@ -155,24 +159,25 @@ JavaWriter write(ClassName injectorClassName, MembersInjectionBinding binding) {
       constructorWriter.body().addSnippet("this.%1$s = %1$s;", field.name());
       dependencyFieldsBuilder.put(nameEntry.getKey(), field);
     }
-    ImmutableMap<FrameworkKey, FieldWriter> depedencyFields = dependencyFieldsBuilder.build();
+    ImmutableMap<Key, FieldWriter> depedencyFields = dependencyFieldsBuilder.build();
     for (InjectionSite injectionSite : binding.injectionSites()) {
       switch (injectionSite.kind()) {
         case FIELD:
           DependencyRequest fieldDependency =
               Iterables.getOnlyElement(injectionSite.dependencies());
-          FieldWriter singleField = depedencyFields.get(FrameworkKey.forDependencyRequest(
-              fieldDependency));
+          FieldWriter singleField = depedencyFields.get(fieldDependency.key());
           injectMembersWriter.body().addSnippet("instance.%s = %s;",
               injectionSite.element().getSimpleName(),
-              frameworkTypeUsageStatement(singleField.name(), fieldDependency.kind()));
+              frameworkTypeUsageStatement(Snippet.format(singleField.name()),
+                  fieldDependency.kind()));
           break;
         case METHOD:
           ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
-          for (DependencyRequest methodDependnecy : injectionSite.dependencies()) {
+          for (DependencyRequest methodDependency : injectionSite.dependencies()) {
             FieldWriter field =
-            depedencyFields.get(FrameworkKey.forDependencyRequest(methodDependnecy));
-            parameters.add(frameworkTypeUsageStatement(field.name(), methodDependnecy.kind()));
+            depedencyFields.get(methodDependency.key());
+            parameters.add(frameworkTypeUsageStatement(Snippet.format(field.name()),
+                methodDependency.kind()));
           }
           injectMembersWriter.body().addSnippet("instance.%s(%s);",
               injectionSite.element().getSimpleName(),
@@ -182,7 +187,7 @@ JavaWriter write(ClassName injectorClassName, MembersInjectionBinding binding) {
           throw new AssertionError();
       }
     }
-    return writer;
+    return ImmutableSet.of(writer);
   }
 
   private Optional<TypeElement> supertype(TypeElement type) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/MethodSignature.java b/compiler/src/main/java/dagger/internal/codegen/MethodSignature.java
new file mode 100644
index 000000000..d45fd8758
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MethodSignature.java
@@ -0,0 +1,34 @@
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Equivalence;
+import com.google.common.collect.ImmutableList;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+@AutoValue
+abstract class MethodSignature {
+  abstract String name();
+  abstract ImmutableList<Equivalence.Wrapper<TypeMirror>> parameterTypes();
+  abstract ImmutableList<Equivalence.Wrapper<TypeMirror>> thrownTypes();
+
+  static MethodSignature fromExecutableElement(ExecutableElement method) {
+    checkNotNull(method);
+    ImmutableList.Builder<Equivalence.Wrapper<TypeMirror>> parameters = ImmutableList.builder();
+    ImmutableList.Builder<Equivalence.Wrapper<TypeMirror>> thrownTypes = ImmutableList.builder();
+    for (VariableElement parameter : method.getParameters()) {
+      parameters.add(MoreTypes.equivalence().wrap(parameter.asType()));
+    }
+    for (TypeMirror thrownType : method.getThrownTypes()) {
+      thrownTypes.add(MoreTypes.equivalence().wrap(thrownType));
+    }
+    return new AutoValue_MethodSignature(
+        method.getSimpleName().toString(),
+        parameters.build(),
+        thrownTypes.build());
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
index bbec9ccb9..00465243f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
@@ -15,17 +15,31 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.Visibility;
+import com.google.common.base.Function;
+import com.google.common.base.Joiner;
+import com.google.common.base.Predicate;
+import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableListMultimap;
+import com.google.common.collect.ImmutableSet;
 import dagger.Module;
 import dagger.Provides;
 import java.util.Collection;
 import java.util.List;
 import java.util.Map.Entry;
+import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.auto.common.Visibility.PRIVATE;
+import static com.google.auto.common.Visibility.PUBLIC;
+import static com.google.auto.common.Visibility.effectiveVisibilityOfElement;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_WITH_SAME_NAME;
 
 /**
@@ -35,9 +49,20 @@
  * @since 2.0
  */
 final class ModuleValidator implements Validator<TypeElement> {
+  private final Elements elements;
+  private final Types types;
+
+  ModuleValidator(Elements elements, Types types) {
+    this.elements =  elements;
+    this.types = types;
+  }
+
   @Override
   public ValidationReport<TypeElement> validate(TypeElement subject) {
     ValidationReport.Builder<TypeElement> builder = ValidationReport.Builder.about(subject);
+
+    validateModuleVisibility(subject, builder);
+
     List<ExecutableElement> moduleMethods = ElementFilter.methodsIn(subject.getEnclosedElements());
     ImmutableListMultimap.Builder<String, ExecutableElement> providesMethodsByName =
         ImmutableListMultimap.builder();
@@ -54,7 +79,68 @@
         }
       }
     }
-    // TODO(gak): port the dagger 1 module validation
+    // TODO(gak): port the dagger 1 module validation?
     return builder.build();
   }
+
+  private void validateModuleVisibility(final TypeElement moduleElement,
+      final ValidationReport.Builder<?> reportBuilder) {
+    Visibility moduleVisibility = Visibility.ofElement(moduleElement);
+    if (moduleVisibility.equals(PRIVATE)) {
+      reportBuilder.addItem("Modules cannot be private.", moduleElement);
+    } else if (effectiveVisibilityOfElement(moduleElement).equals(PRIVATE)) {
+      reportBuilder.addItem("Modules cannot be enclosed in private types.", moduleElement);
+    }
+
+    switch (moduleElement.getNestingKind()) {
+      case ANONYMOUS:
+        throw new IllegalStateException("Can't apply @Module to an anonymous class");
+      case LOCAL:
+        throw new IllegalStateException("Local classes shouldn't show up in the processor");
+      case MEMBER:
+      case TOP_LEVEL:
+        if (moduleVisibility.equals(PUBLIC)) {
+          ImmutableSet<Element> nonPublicModules =
+              FluentIterable.from(ConfigurationAnnotations.getModuleIncludes(elements,
+                  MoreElements.getAnnotationMirror(moduleElement, Module.class).get()))
+                      .transform(new Function<TypeMirror, Element>() {
+                        @Override public Element apply(TypeMirror input) {
+                          return types.asElement(input);
+                        }
+                      })
+                      .filter(new Predicate<Element>() {
+                        @Override public boolean apply(Element input) {
+                          return effectiveVisibilityOfElement(input).compareTo(PUBLIC) < 0;
+                        }
+                      })
+                      .toSet();
+          if (!nonPublicModules.isEmpty()) {
+            reportBuilder.addItem(
+                String.format(
+                    "This module is public, but it includes non-public "
+                        + "(or effectively non-public) modules. "
+                        + "Either reduce the visibility of this module or make %s public.",
+                    formatListForErrorMessage(nonPublicModules.asList())),
+                moduleElement);
+          }
+        }
+        break;
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  private static String formatListForErrorMessage(List<?> things) {
+    switch (things.size()) {
+      case 0:
+        return "";
+      case 1:
+        return things.get(0).toString();
+      default:
+        StringBuilder output = new StringBuilder();
+        Joiner.on(", ").appendTo(output, things.subList(0, things.size() - 1));
+        output.append(" and ").append(things.get(things.size() - 1));
+        return output.toString();
+    }
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
index bd83613cf..fa4e70d30 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
@@ -15,10 +15,12 @@
  */
 package dagger.internal.codegen;
 
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import dagger.Module;
 import dagger.Provides;
 import java.util.Set;
+import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
@@ -31,15 +33,19 @@
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.ConfigurationAnnotations.getMapKeys;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_ABSTRACT;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_MUST_RETURN_A_VALUE;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_NOT_IN_MODULE;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_NOT_MAP_HAS_MAP_KEY;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_PRIVATE;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_RETURN_TYPE;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RAW_SET;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RETURN_SET;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_STATIC;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_TYPE_PARAMETER;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_WITH_MULTIPLE_MAP_KEY;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_WITH_NO_MAP_KEY;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
@@ -77,7 +83,7 @@ private TypeElement getSetElement() {
       builder.addItem(PROVIDES_METHOD_NOT_IN_MODULE,
           providesMethodElement);
     }
-
+    
     if (!providesMethodElement.getTypeParameters().isEmpty()) {
       builder.addItem(PROVIDES_METHOD_TYPE_PARAMETER, providesMethodElement);
     }
@@ -99,12 +105,34 @@ private TypeElement getSetElement() {
     if (returnTypeKind.equals(VOID)) {
       builder.addItem(PROVIDES_METHOD_MUST_RETURN_A_VALUE, providesMethodElement);
     }
+  
+    // check mapkey is right
+    if (!providesAnnotation.type().equals(Provides.Type.MAP) 
+        && (getMapKeys(providesMethodElement) != null
+            && getMapKeys(providesMethodElement).size() > 0)) {
+      builder.addItem(PROVIDES_METHOD_NOT_MAP_HAS_MAP_KEY, providesMethodElement);
+    }
 
     switch (providesAnnotation.type()) {
       case UNIQUE: // fall through
       case SET:
         validateKeyType(builder, returnType);
         break;
+      case MAP:
+        validateKeyType(builder, returnType);
+        ImmutableSet<? extends AnnotationMirror> annotationMirrors =
+            getMapKeys(providesMethodElement);
+        switch (annotationMirrors.size()) {
+          case 0:
+            builder.addItem(PROVIDES_METHOD_WITH_NO_MAP_KEY, providesMethodElement);
+            break;
+          case 1:
+            break;
+          default:
+            builder.addItem(PROVIDES_METHOD_WITH_MULTIPLE_MAP_KEY, providesMethodElement);
+            break;
+        }
+        break;
       case SET_VALUES:
         if (!returnTypeKind.equals(DECLARED)) {
           builder.addItem(PROVIDES_METHOD_SET_VALUES_RETURN_SET, providesMethodElement);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 0d02cb879..6eaa59687 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -18,30 +18,39 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Ordering;
 import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.Provides;
-import java.util.Iterator;
+import java.util.Set;
 import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Name;
+import javax.lang.model.element.PackageElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.ArrayType;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.TypeVariable;
+import javax.lang.model.type.WildcardType;
 import javax.lang.model.util.Elements;
+import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.collect.Sets.immutableEnumSet;
-import static dagger.Provides.Type.SET;
-import static dagger.Provides.Type.SET_VALUES;
 import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.ElementKind.FIELD;
 import static javax.lang.model.element.ElementKind.METHOD;
+import static javax.lang.model.element.Modifier.PUBLIC;
 
 /**
  * A value object representing the mechanism by which a {@link Key} can be provided. New instances
@@ -52,6 +61,14 @@
  */
 @AutoValue
 abstract class ProvisionBinding extends Binding {
+  @Override
+  ImmutableSet<DependencyRequest> implicitDependencies() {
+    return new ImmutableSet.Builder<DependencyRequest>()
+        .addAll(dependencies())
+        .addAll(memberInjectionRequest().asSet())
+        .build();
+  }
+
   enum Kind {
     /** Represents an {@link Inject} binding. */
     INJECTION,
@@ -72,34 +89,70 @@
   /** Returns provision type that was used to bind the key. */
   abstract Provides.Type provisionType();
 
-  /** The {@link Key} that is provided by this binding. */
-  abstract Key providedKey();
-
-  /** The scope in which the binding declares the {@link #providedKey()}. */
+  /** The scope in which the binding declares the {@link #key()}. */
   abstract Optional<AnnotationMirror> scope();
 
   /** If this provision requires members injeciton, this will be the corresonding request. */
   abstract Optional<DependencyRequest> memberInjectionRequest();
 
-  private static ImmutableSet<Provides.Type> SET_BINDING_TYPES = immutableEnumSet(SET, SET_VALUES);
+  static enum BindingType {
+    /** Represents map bindings. */
+    MAP,
+    /** Represents set bindings. */
+    SET,
+    /** Represents a valid non-collection binding. */
+    UNIQUE;
+  }
+
+  BindingType bindingType() {
+    switch (provisionType()) {
+      case SET:
+      case SET_VALUES:
+        return BindingType.SET;
+      case MAP:
+        return BindingType.MAP;
+      case UNIQUE:
+        return BindingType.UNIQUE;
+      default:
+        throw new IllegalStateException("Unknown provision type: " + provisionType());
+    }
+  }
+
+  /**
+   * Returns the set of {@link BindingType} enum values implied by a given
+   * {@link ProvisionBinding} collection.
+   */
+  static ImmutableListMultimap<BindingType, ProvisionBinding> bindingTypesFor(
+      Iterable<ProvisionBinding> bindings) {
+    ImmutableListMultimap.Builder<BindingType, ProvisionBinding> builder =
+        ImmutableListMultimap.builder();
+    builder.orderKeysBy(Ordering.<BindingType>natural());
+    for (ProvisionBinding binding : bindings) {
+      builder.put(binding.bindingType(), binding);
+    }
+    return builder.build();
+  }
 
   /**
-   * Returns {@code true} if the given bindings are all contributors to a set binding.
-   *
-   * @throws IllegalArgumentException if some of the bindings are set bindings and some are not.
+   * Returns a single {@code BindingsType} represented by a given collection of
+   * {@code ProvisionBindings} or throws an IllegalArgumentException if the given bindings
+   * are not all of one type.
    */
-  static boolean isSetBindingCollection(Iterable<ProvisionBinding> bindings) {
+  static BindingType bindingTypeFor(Iterable<ProvisionBinding> bindings) {
     checkNotNull(bindings);
-    Iterator<ProvisionBinding> iterator = bindings.iterator();
-    checkArgument(iterator.hasNext(), "no bindings");
-    boolean setBinding = SET_BINDING_TYPES.contains(iterator.next().provisionType());
-    while (iterator.hasNext()) {
-      checkArgument(setBinding,
-          "more than one binding present, but found a non-set binding");
-      checkArgument(SET_BINDING_TYPES.contains(iterator.next().provisionType()),
-          "more than one binding present, but found a non-set binding");
+    switch (Iterables.size(bindings)) {
+      case 0:
+        throw new IllegalArgumentException("no bindings");
+      case 1:
+        return Iterables.getOnlyElement(bindings).bindingType();
+      default:
+        Set<BindingType> types = bindingTypesFor(bindings).keySet();
+        if (types.size() > 1) {
+          throw new IllegalArgumentException(
+              String.format(ErrorMessages.MULTIPLE_BINDING_TYPES_FORMAT, types));
+        }
+        return Iterables.getOnlyElement(types);
     }
-    return setBinding;
   }
 
   static final class Factory {
@@ -116,21 +169,81 @@ static boolean isSetBindingCollection(Iterable<ProvisionBinding> bindings) {
       this.dependencyRequestFactory = dependencyRequestFactory;
     }
 
+    private static Optional<String> findBindingPackage(Key providedKey) {
+      Set<String> packages = nonPublicPackageUse(providedKey.type());
+      switch (packages.size()) {
+        case 0:
+          return Optional.absent();
+        case 1:
+          return Optional.of(packages.iterator().next());
+        default:
+          throw new IllegalStateException();
+      }
+    }
+
+    private static Set<String> nonPublicPackageUse(TypeMirror typeMirror) {
+      ImmutableSet.Builder<String> packages = ImmutableSet.builder();
+      typeMirror.accept(new SimpleTypeVisitor6<Void, ImmutableSet.Builder<String>>() {
+        @Override
+        public Void visitArray(ArrayType t, ImmutableSet.Builder<String> p) {
+          return t.getComponentType().accept(this, p);
+        }
+
+        @Override
+        public Void visitDeclared(DeclaredType t, ImmutableSet.Builder<String> p) {
+          for (TypeMirror typeArgument : t.getTypeArguments()) {
+            typeArgument.accept(this, p);
+          }
+          // TODO(gak): address public nested types in non-public types
+          TypeElement typeElement = MoreElements.asType(t.asElement());
+          if (!typeElement.getModifiers().contains(PUBLIC)) {
+            PackageElement elementPackage = MoreElements.getPackage(typeElement);
+            Name qualifiedName = elementPackage.getQualifiedName();
+            p.add(qualifiedName.toString());
+          }
+          return null;
+        }
+
+        @Override
+        public Void visitTypeVariable(TypeVariable t, ImmutableSet.Builder<String> p) {
+          t.getLowerBound().accept(this, p);
+          t.getUpperBound().accept(this, p);
+          return null;
+        }
+
+        @Override
+        public Void visitWildcard(WildcardType t, ImmutableSet.Builder<String> p) {
+          if (t.getExtendsBound() != null) {
+            t.getExtendsBound().accept(this, p);
+          }
+          if (t.getSuperBound() != null) {
+            t.getSuperBound().accept(this, p);
+          }
+          return null;
+        }
+      }, packages);
+      return packages.build();
+    }
+
     ProvisionBinding forInjectConstructor(ExecutableElement constructorElement) {
       checkNotNull(constructorElement);
       checkArgument(constructorElement.getKind().equals(CONSTRUCTOR));
       checkArgument(isAnnotationPresent(constructorElement, Inject.class));
       Key key = keyFactory.forInjectConstructor(constructorElement);
       checkArgument(!key.qualifier().isPresent());
+      ImmutableSet<DependencyRequest> dependencies =
+          dependencyRequestFactory.forRequiredVariables(constructorElement.getParameters());
+      Optional<DependencyRequest> membersInjectionRequest = membersInjectionRequest(
+          MoreElements.asType(constructorElement.getEnclosingElement()));
       return new AutoValue_ProvisionBinding(
+          key,
           constructorElement,
-          dependencyRequestFactory.forRequiredVariables(constructorElement.getParameters()),
+          dependencies,
+          findBindingPackage(key),
           Kind.INJECTION,
           Provides.Type.UNIQUE,
-          key,
           getScopeAnnotation(constructorElement.getEnclosingElement()),
-          membersInjectionRequest(
-              MoreElements.asType(constructorElement.getEnclosingElement())));
+          membersInjectionRequest);
     }
 
     private static final ImmutableSet<ElementKind> MEMBER_KINDS =
@@ -139,12 +252,12 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement) {
     private Optional<DependencyRequest> membersInjectionRequest(TypeElement type) {
       if (!types.isSameType(elements.getTypeElement(Object.class.getCanonicalName()).asType(),
           type.getSuperclass())) {
-        return Optional.of(dependencyRequestFactory.forMembersInjectedType(type.asType()));
+        return Optional.of(dependencyRequestFactory.forMembersInjectedType(type));
       }
       for (Element enclosedElement : type.getEnclosedElements()) {
         if (MEMBER_KINDS.contains(enclosedElement.getKind())
             && (isAnnotationPresent(enclosedElement, Inject.class))) {
-          return Optional.of(dependencyRequestFactory.forMembersInjectedType(type.asType()));
+          return Optional.of(dependencyRequestFactory.forMembersInjectedType(type));
         }
       }
       return Optional.absent();
@@ -155,26 +268,47 @@ ProvisionBinding forProvidesMethod(ExecutableElement providesMethod) {
       checkArgument(providesMethod.getKind().equals(METHOD));
       Provides providesAnnotation = providesMethod.getAnnotation(Provides.class);
       checkArgument(providesAnnotation != null);
+      Key key = keyFactory.forProvidesMethod(providesMethod);
+      ImmutableSet<DependencyRequest> dependencies =
+          dependencyRequestFactory.forRequiredVariables(providesMethod.getParameters());
       return new AutoValue_ProvisionBinding(
+          key,
           providesMethod,
-          dependencyRequestFactory.forRequiredVariables(providesMethod.getParameters()),
+          dependencies,
+          findBindingPackage(key),
           Kind.PROVISION,
           providesAnnotation.type(),
-          keyFactory.forProvidesMethod(providesMethod),
           getScopeAnnotation(providesMethod),
           Optional.<DependencyRequest>absent());
     }
 
+    ProvisionBinding forImplicitMapBinding(DependencyRequest explicitRequest,
+        DependencyRequest implicitRequest) {
+      checkNotNull(explicitRequest);
+      checkNotNull(implicitRequest);
+      ImmutableSet<DependencyRequest> dependencies = ImmutableSet.of(implicitRequest);
+      return new AutoValue_ProvisionBinding(
+          explicitRequest.key(),
+          implicitRequest.requestElement(),
+          dependencies,
+          findBindingPackage(explicitRequest.key()),
+          Kind.PROVISION,
+          Provides.Type.MAP,
+          getScopeAnnotation(implicitRequest.requestElement()),
+          Optional.<DependencyRequest>absent());
+    }
+
     ProvisionBinding forComponent(TypeElement componentDefinitionType) {
       checkNotNull(componentDefinitionType);
       Component componentAnnotation = componentDefinitionType.getAnnotation(Component.class);
       checkArgument(componentAnnotation != null);
       return new AutoValue_ProvisionBinding(
+          keyFactory.forComponent(componentDefinitionType.asType()),
           componentDefinitionType,
           ImmutableSet.<DependencyRequest>of(),
+          Optional.<String>absent(),
           Kind.COMPONENT,
           Provides.Type.UNIQUE,
-          keyFactory.forType(componentDefinitionType.asType()),
           Optional.<AnnotationMirror>absent(),
           Optional.<DependencyRequest>absent());
     }
@@ -184,11 +318,12 @@ ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
       checkArgument(componentMethod.getKind().equals(METHOD));
       checkArgument(componentMethod.getParameters().isEmpty());
       return new AutoValue_ProvisionBinding(
+          keyFactory.forComponentMethod(componentMethod),
           componentMethod,
           ImmutableSet.<DependencyRequest>of(),
+          Optional.<String>absent(),
           Kind.COMPONENT_PROVISION,
           Provides.Type.UNIQUE,
-          keyFactory.forComponentMethod(componentMethod),
           getScopeAnnotation(componentMethod),
           Optional.<DependencyRequest>absent());
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBindingFormatter.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBindingFormatter.java
new file mode 100644
index 000000000..61e915704
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBindingFormatter.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreElements;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+
+/**
+ * Formats a {@link Key} into a {@link String} suitable for use in error messages.
+ *
+ * @author Christian Gruber
+ * @since 2.0
+ */
+final class ProvisionBindingFormatter extends Formatter<ProvisionBinding> {
+  private static final ProvisionBindingFormatter INSTANCE = new ProvisionBindingFormatter();
+
+  static ProvisionBindingFormatter instance() {
+    return INSTANCE;
+  }
+
+  @Override public String format(ProvisionBinding binding) {
+    StringBuilder builder = new StringBuilder();
+    switch (binding.bindingKind()) {
+      case PROVISION:
+      case COMPONENT_PROVISION:
+        ExecutableElement method = MoreElements.asExecutable(binding.bindingElement());
+        TypeElement type = MoreElements.asType(method.getEnclosingElement());
+        builder.append(type.getQualifiedName());
+        builder.append('.');
+        builder.append(method.getSimpleName());
+        builder.append('(');
+        for (VariableElement parameter : method.getParameters()) {
+          builder.append(parameter.asType()); // TODO(user): Use TypeMirrorFormatter.
+        }
+        builder.append(')');
+        return builder.toString();
+      default:
+        throw new UnsupportedOperationException(
+            "Not yet supporting " + binding.bindingKind() + " binding types.");
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java
index 725c24e37..6ea9729d1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java
@@ -16,6 +16,8 @@
 package dagger.internal.codegen;
 
 import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
 import dagger.internal.codegen.writer.ClassName;
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.Element;
@@ -34,35 +36,39 @@
  * @since 2.0
  */
 final class SourceFileGenerationException extends Exception implements PrintableErrorMessage {
-  private final ClassName generatedClassName;
+  private final ImmutableSet<ClassName> generatedClassNames;
   private final Optional<? extends Element> associatedElement;
 
-  SourceFileGenerationException(ClassName generatedClassName, Throwable cause,
+  SourceFileGenerationException(Iterable<ClassName> generatedClassNames, Throwable cause,
       Optional<? extends Element> associatedElement) {
-    super(createMessage(generatedClassName, cause.getMessage()), cause);
-    this.generatedClassName = checkNotNull(generatedClassName);
+    super(createMessage(generatedClassNames, cause.getMessage()), cause);
+    this.generatedClassNames = ImmutableSet.copyOf(generatedClassNames);
     this.associatedElement = checkNotNull(associatedElement);
   }
 
-  SourceFileGenerationException(ClassName generatedClassName, Throwable cause) {
-    this(generatedClassName, cause, Optional.<Element>absent());
+  SourceFileGenerationException(Iterable<ClassName> generatedClassNames, Throwable cause) {
+    this(generatedClassNames, cause, Optional.<Element>absent());
   }
 
-  SourceFileGenerationException(ClassName generatedClassName, Throwable cause,
+  SourceFileGenerationException(Iterable<ClassName> generatedClassNames, Throwable cause,
       Element associatedElement) {
-    this(generatedClassName, cause, Optional.of(associatedElement));
+    this(generatedClassNames, cause, Optional.of(associatedElement));
   }
 
-  public ClassName generatedClassName() {
-    return generatedClassName;
+  public ImmutableSet<ClassName> generatedClassNames() {
+    return generatedClassNames;
   }
 
   public Optional<? extends Element> associatedElement() {
     return associatedElement;
   }
 
-  private static String createMessage(ClassName generatedClassName, String message) {
-    return String.format("Could not generate %s: %s.", generatedClassName, message);
+  private static String createMessage(Iterable<ClassName> generatedClassNames, String message) {
+    return String.format("Could not generate %s: %s.",
+        Iterables.isEmpty(generatedClassNames)
+            ? "unknown files"
+            : Iterables.toString(generatedClassNames),
+        message);
   }
 
   @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
index 9cfd003ec..13430c670 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
@@ -15,11 +15,15 @@
  */
 package dagger.internal.codegen;
 
+import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.base.Throwables;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.JavaWriter;
+import dagger.internal.codegen.writer.TypeWriter;
 import java.io.IOException;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
@@ -42,27 +46,36 @@
     this.filer = checkNotNull(filer);
   }
 
-  final ClassName generate(T input) throws SourceFileGenerationException {
+  final void generate(T input) throws SourceFileGenerationException {
     ClassName generatedTypeName = nameGeneratedType(input);
     ImmutableSet<Element> originatingElements = ImmutableSet.copyOf(getOriginatingElements(input));
     try {
-      JavaWriter javaWriter = write(generatedTypeName, input);
-      try {
-        javaWriter.file(filer, originatingElements);
-      } catch (IOException e) {
-        throw new SourceFileGenerationException(generatedTypeName, e,
-            getElementForErrorReporting(input));
+      ImmutableSet<JavaWriter> writers = write(generatedTypeName, input);
+      for (JavaWriter javaWriter : writers) {
+        try {
+          javaWriter.file(filer, originatingElements);
+        } catch (IOException e) {
+          throw new SourceFileGenerationException(getNamesForWriters(javaWriter.getTypeWriters()),
+              e, getElementForErrorReporting(input));
+        }
       }
-      return generatedTypeName;
     } catch (Exception e) {
       // if the code above threw a SFGE, use that
       Throwables.propagateIfPossible(e, SourceFileGenerationException.class);
       // otherwise, throw a new one
-      throw new SourceFileGenerationException(generatedTypeName, e,
+      throw new SourceFileGenerationException(ImmutableList.<ClassName>of(), e,
           getElementForErrorReporting(input));
     }
   }
 
+  private static Iterable<ClassName> getNamesForWriters(Iterable<TypeWriter> typeWriters) {
+    return Iterables.transform(typeWriters, new Function<TypeWriter, ClassName>() {
+      @Override public ClassName apply(TypeWriter input) {
+        return input.name();
+      }
+    });
+  }
+
   /**
    * Implementations should return the {@link ClassName} for the top-level type to be generated.
    */
@@ -82,5 +95,5 @@ final ClassName generate(T input) throws SourceFileGenerationException {
 
   /**
    */
-  abstract JavaWriter write(ClassName generatedTypeName, T input);
+  abstract ImmutableSet<JavaWriter> write(ClassName generatedTypeName, T input);
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 1863d7b57..21d4a3e06 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -32,7 +32,9 @@
 import dagger.Lazy;
 import dagger.MembersInjector;
 import dagger.internal.DoubleCheckLazy;
+import dagger.internal.codegen.ProvisionBinding.BindingType;
 import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.JavaWriter;
 import dagger.internal.codegen.writer.Snippet;
 import java.util.Collection;
 import java.util.Iterator;
@@ -137,21 +139,21 @@
    * @return Returns the mapping from {@link Key} to provider name sorted by the name of the
    * provider.
    */
-  static ImmutableMap<FrameworkKey, String> generateFrameworkReferenceNamesForDependencies(
+  static ImmutableMap<Key, String> generateFrameworkReferenceNamesForDependencies(
       Iterable<? extends DependencyRequest> dependencies) {
-    ImmutableSetMultimap.Builder<FrameworkKey, DependencyRequest> dependenciesByKeyBuilder =
-        new ImmutableSetMultimap.Builder<FrameworkKey, DependencyRequest>()
+    ImmutableSetMultimap.Builder<Key, DependencyRequest> dependenciesByKeyBuilder =
+        new ImmutableSetMultimap.Builder<Key, DependencyRequest>()
             .orderValuesBy(DEPENDENCY_ORDERING);
     for (DependencyRequest dependency : dependencies) {
       dependenciesByKeyBuilder.put(
-          FrameworkKey.forDependencyRequest(dependency), dependency);
+          dependency.key(), dependency);
     }
-    ImmutableSetMultimap<FrameworkKey, DependencyRequest> dependenciesByKey =
+    ImmutableSetMultimap<Key, DependencyRequest> dependenciesByKey =
         dependenciesByKeyBuilder.build();
-    Map<FrameworkKey, Collection<DependencyRequest>> dependenciesByKeyMap =
+    Map<Key, Collection<DependencyRequest>> dependenciesByKeyMap =
         dependenciesByKey.asMap();
-    ImmutableMap.Builder<FrameworkKey, String> providerNames = ImmutableMap.builder();
-    for (Entry<FrameworkKey, Collection<DependencyRequest>> entry :
+    ImmutableMap.Builder<Key, String> providerNames = ImmutableMap.builder();
+    for (Entry<Key, Collection<DependencyRequest>> entry :
       dependenciesByKeyMap.entrySet()) {
       // collect together all of the names that we would want to call the provider
       ImmutableSet<String> dependencyNames = FluentIterable.from(entry.getValue())
@@ -184,31 +186,40 @@
     ImmutableMap.Builder<Key, String> providerNames = ImmutableMap.builder();
     for (Entry<Key, Collection<ProvisionBinding>> entry : bindings.asMap().entrySet()) {
       Collection<ProvisionBinding> bindingsForKey = entry.getValue();
-      final String name;
-      if (ProvisionBinding.isSetBindingCollection(bindingsForKey)) {
-        name = new KeyVariableNamer().apply(entry.getKey()) + "Provider";
-      } else {
-        ProvisionBinding binding = Iterables.getOnlyElement(bindingsForKey);
-        name = binding.bindingElement().accept(
-            new ElementKindVisitor6<String, Void>() {
-              @Override
-              public String visitExecutableAsConstructor(ExecutableElement e, Void p) {
-                return e.getEnclosingElement().accept(this, null);
-              }
+      BindingType bindingsType = ProvisionBinding.bindingTypeFor(bindingsForKey);
+      switch (bindingsType) {
+        case SET:
+          providerNames.put(entry.getKey(),
+              new KeyVariableNamer().apply(entry.getKey()) + "Provider");
+          break;
+        case MAP:
+          providerNames.put(entry.getKey(),
+              new KeyVariableNamer().apply(entry.getKey()) + "Provider");
+          break;
+        case UNIQUE:
+          Binding binding = Iterables.getOnlyElement(bindingsForKey);
+          providerNames.put(entry.getKey(),
+              binding.bindingElement().accept(new ElementKindVisitor6<String, Void>() {
+                @Override
+                public String visitExecutableAsConstructor(ExecutableElement e, Void p) {
+                  return e.getEnclosingElement().accept(this, null);
+                }
 
-              @Override
-              public String visitExecutableAsMethod(ExecutableElement e, Void p) {
-                return e.getSimpleName().toString();
-              }
+                @Override
+                public String visitExecutableAsMethod(ExecutableElement e, Void p) {
+                  return e.getSimpleName().toString();
+                }
 
-              @Override
-              public String visitType(TypeElement e, Void p) {
-                return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL,
-                    e.getSimpleName().toString());
-              }
-            }, null) + "Provider";
+                @Override
+                public String visitType(TypeElement e, Void p) {
+                  return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL,
+                      e.getSimpleName().toString());
+                }
+              }, null) + "Provider");
+          break;
+        default:
+          throw new IllegalStateException();
       }
-      providerNames.put(entry.getKey(), name);
     }
     Ordering<Entry<?, String>> entryValueOrdering =
         Ordering.natural().onResultOf(new Function<Entry<?, String>, String>() {
@@ -236,17 +247,17 @@ public String apply(Entry<?, String> input) {
         }));
   }
 
-  static Snippet frameworkTypeUsageStatement(String frameworkTypeName,
+  static Snippet frameworkTypeUsageStatement(Snippet frameworkTypeMemberSelect,
       DependencyRequest.Kind dependencyKind) {
     switch (dependencyKind) {
       case LAZY:
         return Snippet.format("%s.create(%s)",
-            ClassName.fromClass(DoubleCheckLazy.class), frameworkTypeName);
+            ClassName.fromClass(DoubleCheckLazy.class), frameworkTypeMemberSelect);
       case INSTANCE:
-        return Snippet.format("%s.get()", frameworkTypeName);
+        return Snippet.format("%s.get()", frameworkTypeMemberSelect);
       case PROVIDER:
       case MEMBERS_INJECTOR:
-        return Snippet.format("%s", frameworkTypeName);
+        return Snippet.format("%s", frameworkTypeMemberSelect);
       default:
         throw new AssertionError();
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 826ddec01..77ea7b2f7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -16,371 +16,84 @@
  */
 package dagger.internal.codegen;
 
-import dagger.internal.Keys;
-import java.lang.reflect.Method;
-import java.util.Arrays;
-import java.util.LinkedHashMap;
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.Iterables;
 import java.util.List;
 import java.util.Map;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.AnnotationValueVisitor;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.PackageElement;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.ArrayType;
+import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.ErrorType;
-import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.type.TypeVariable;
-import javax.lang.model.type.WildcardType;
+import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleAnnotationValueVisitor6;
-import javax.lang.model.util.SimpleTypeVisitor6;
-
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
 
 /**
  * Utilities for handling types in annotation processors
  */
 final class Util {
-  private Util() {
-  }
-
-  public static PackageElement getPackage(Element type) {
-    while (type.getKind() != ElementKind.PACKAGE) {
-      type = type.getEnclosingElement();
-    }
-    return (PackageElement) type;
-  }
-
-  /**
-   * Returns the supertype, or {@code null} if the supertype is a platform
-   * class. This is intended for annotation processors that assume platform
-   * classes will never be annotated with application annotations.
-   */
-  public static TypeMirror getApplicationSupertype(TypeElement type) {
-    TypeMirror supertype = type.getSuperclass();
-    return Keys.isPlatformType(supertype.toString()) ? null : supertype;
-  }
-
-  /** Returns a fully qualified class name to complement {@code type}. */
-  public static String adapterName(TypeElement typeElement, String suffix) {
-    StringBuilder builder = new StringBuilder();
-    rawTypeToString(builder, typeElement, '$');
-    builder.append(suffix);
-    return builder.toString();
-  }
-
-  /** Returns a string for {@code type}. Primitive types are always boxed. */
-  public static String typeToString(TypeMirror type) {
-    StringBuilder result = new StringBuilder();
-    typeToString(type, result, '.');
-    return result.toString();
-  }
-
-  /** Returns a string for the raw type of {@code type}. Primitive types are always boxed. */
-  public static String rawTypeToString(TypeMirror type, char innerClassSeparator) {
-    if (!(type instanceof DeclaredType)) {
-      throw new IllegalArgumentException("Unexpected type: " + type);
-    }
-    StringBuilder result = new StringBuilder();
-    DeclaredType declaredType = (DeclaredType) type;
-    rawTypeToString(result, (TypeElement) declaredType.asElement(), innerClassSeparator);
-    return result.toString();
-  }
-
-  /**
-   * Appends a string for {@code type} to {@code result}. Primitive types are
-   * always boxed.
-   *
-   * @param innerClassSeparator either '.' or '$', which will appear in a
-   *     class name like "java.lang.Map.Entry" or "java.lang.Map$Entry".
-   *     Use '.' for references to existing types in code. Use '$' to define new
-   *     class names and for strings that will be used by runtime reflection.
-   */
-  public static void typeToString(final TypeMirror type, final StringBuilder result,
-      final char innerClassSeparator) {
-    type.accept(new SimpleTypeVisitor6<Void, Void>() {
-      @Override public Void visitDeclared(DeclaredType declaredType, Void v) {
-        TypeElement typeElement = (TypeElement) declaredType.asElement();
-        rawTypeToString(result, typeElement, innerClassSeparator);
-        List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();
-        if (!typeArguments.isEmpty()) {
-          result.append("<");
-          for (int i = 0; i < typeArguments.size(); i++) {
-            if (i != 0) {
-              result.append(", ");
-            }
-            typeToString(typeArguments.get(i), result, innerClassSeparator);
-          }
-          result.append(">");
-        }
-        return null;
-      }
-      @Override public Void visitPrimitive(PrimitiveType primitiveType, Void v) {
-        result.append(box((PrimitiveType) type).getName());
-        return null;
-      }
-      @Override public Void visitArray(ArrayType arrayType, Void v) {
-        TypeMirror type = arrayType.getComponentType();
-        if (type instanceof PrimitiveType) {
-          result.append(type.toString()); // Don't box, since this is an array.
-        } else {
-          typeToString(arrayType.getComponentType(), result, innerClassSeparator);
-        }
-        result.append("[]");
-        return null;
-      }
-      @Override public Void visitTypeVariable(TypeVariable typeVariable, Void v) {
-        result.append(typeVariable.asElement().getSimpleName());
-        return null;
-      }
-      @Override public Void visitError(ErrorType errorType, Void v) {
-        // Error type found, a type may not yet have been generated, but we need the type
-        // so we can generate the correct code in anticipation of the type being available
-        // to the compiler.
-
-        // Paramterized types which don't exist are returned as an error type whose name is "<any>"
-        if ("<any>".equals(errorType.toString())) {
-          throw new CodeGenerationIncompleteException(
-              "Type reported as <any> is likely a not-yet generated parameterized type.");
-        }
-        // TODO(cgruber): Figure out a strategy for non-FQCN cases.
-        result.append(errorType.toString());
-        return null;
-      }
-      public Void visitWildcard(WildcardType wildcardType, Void v) {
-        result.append("?");
-        if (wildcardType.getExtendsBound() != null) {
-          result.append(" extends ");
-          typeToString(wildcardType.getExtendsBound(), result, innerClassSeparator);
-        } else if (wildcardType.getSuperBound() != null) {
-          result.append(" super ");
-          typeToString(wildcardType.getSuperBound(), result, innerClassSeparator);
-        }
-        return null;
-      }
-      @Override protected Void defaultAction(TypeMirror typeMirror, Void v) {
-        throw new UnsupportedOperationException(
-            "Unexpected TypeKind " + typeMirror.getKind() + " for "  + typeMirror);
-      }
-    }, null);
-  }
-
-  private static final AnnotationValueVisitor<Object, Void> VALUE_EXTRACTOR =
-      new SimpleAnnotationValueVisitor6<Object, Void>() {
-        @Override public Object visitString(String s, Void p) {
-          if ("<error>".equals(s)) {
-            throw new CodeGenerationIncompleteException("Unknown type returned as <error>.");
-          } else if ("<any>".equals(s)) {
-            throw new CodeGenerationIncompleteException("Unknown type returned as <any>.");
-          }
-          return s;
-        }
-        @Override public Object visitType(TypeMirror t, Void p) {
-          return t;
-        }
-        @Override protected Object defaultAction(Object o, Void v) {
-          return o;
-        }
-        @Override public Object visitArray(List<? extends AnnotationValue> values, Void v) {
-          Object[] result = new Object[values.size()];
-          for (int i = 0; i < values.size(); i++) {
-            result[i] = values.get(i).accept(this, null);
-          }
-          return result;
-        }
-      };
-
   /**
-   * Returns the annotation on {@code element} formatted as a Map. This returns
-   * a Map rather than an instance of the annotation interface to work-around
-   * the fact that Class and Class[] fields won't work at code generation time.
-   * See http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5089128
+   * Returns the {@code V} type for a {@link Map} type like Map<K, Provider<V>>} if the map
+   * includes such a construction
    */
-  public static Map<String, Object> getAnnotation(Class<?> annotationType, Element element) {
-    for (AnnotationMirror annotation : element.getAnnotationMirrors()) {
-      if (!rawTypeToString(annotation.getAnnotationType(), '$')
-          .equals(annotationType.getName())) {
-        continue;
-      }
-
-      Map<String, Object> result = new LinkedHashMap<String, Object>();
-      for (Method m : annotationType.getMethods()) {
-        result.put(m.getName(), m.getDefaultValue());
-      }
-      for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> e
-          : annotation.getElementValues().entrySet()) {
-        String name = e.getKey().getSimpleName().toString();
-        Object value = e.getValue().accept(VALUE_EXTRACTOR, null);
-        Object defaultValue = result.get(name);
-        if (!lenientIsInstance(defaultValue.getClass(), value)) {
-          throw new IllegalStateException(String.format(
-              "Value of %s.%s is a %s but expected a %s\n    value: %s",
-              annotationType, name, value.getClass().getName(), defaultValue.getClass().getName(),
-              value instanceof Object[] ? Arrays.toString((Object[]) value) : value));
-        }
-        result.put(name, value);
-      }
-      return result;
-    }
-    return null; // Annotation not found.
+  public static TypeMirror getProvidedValueTypeOfMap(DeclaredType mapType) {
+    checkState(MoreTypes.isTypeOf(Map.class, mapType), "%s is not a Map.", mapType);
+    return MoreTypes.asDeclared(mapType.getTypeArguments().get(1)).getTypeArguments().get(0);
   }
 
+  // TODO(user): Consider an object that holds and exposes the various parts of a Map type.
   /**
-   * Returns true if {@code value} can be assigned to {@code expectedClass}.
-   * Like {@link Class#isInstance} but more lenient for {@code Class<?>} values.
+   * returns the value type for a {@link Map} type like Map<K, V>}.
    */
-  private static boolean lenientIsInstance(Class<?> expectedClass, Object value) {
-    if (expectedClass.isArray()) {
-      Class<?> componentType = expectedClass.getComponentType();
-      if (!(value instanceof Object[])) {
-        return false;
-      }
-      for (Object element : (Object[]) value) {
-        if (!lenientIsInstance(componentType, element)) return false;
-      }
-      return true;
-    } else if (expectedClass == Class.class) {
-      return value instanceof TypeMirror;
-    } else {
-      return expectedClass == value.getClass();
-    }
-  }
-
-  // TODO(sgoldfed): better format for other types of elements?
-  static String elementToString(Element element) {
-    switch (element.getKind()) {
-      case FIELD:
-      // fall through
-      case CONSTRUCTOR:
-      // fall through
-      case METHOD:
-        return element.getEnclosingElement() + "." + element;
-      default:
-        return element.toString();
-    }
-  }
-
-  static void rawTypeToString(StringBuilder result, TypeElement type,
-      char innerClassSeparator) {
-    String packageName = getPackage(type).getQualifiedName().toString();
-    String qualifiedName = type.getQualifiedName().toString();
-    if (packageName.isEmpty()) {
-        result.append(qualifiedName.replace('.', innerClassSeparator));
-    } else {
-      result.append(packageName);
-      result.append('.');
-      result.append(
-          qualifiedName.substring(packageName.length() + 1).replace('.', innerClassSeparator));
-    }
-  }
-
-  private static Class<?> box(PrimitiveType primitiveType) {
-    switch (primitiveType.getKind()) {
-      case BYTE:
-        return Byte.class;
-      case SHORT:
-        return Short.class;
-      case INT:
-        return Integer.class;
-      case LONG:
-        return Long.class;
-      case FLOAT:
-        return Float.class;
-      case DOUBLE:
-        return Double.class;
-      case BOOLEAN:
-        return Boolean.class;
-      case CHAR:
-        return Character.class;
-      case VOID:
-        return Void.class;
-      default:
-        throw new AssertionError();
-    }
+  public static TypeMirror getValueTypeOfMap(DeclaredType mapType) {
+    checkState(MoreTypes.isTypeOf(Map.class, mapType), "%s is not a Map.", mapType);
+    List<? extends TypeMirror> mapArgs = mapType.getTypeArguments();
+    return mapArgs.get(1);
   }
 
   /**
-   * Returns the no-args constructor for {@code type}, or null if no such
-   * constructor exists.
+   * Returns the key type for a {@link Map} type like Map<K, Provider<V>>}
    */
-  public static ExecutableElement getNoArgsConstructor(TypeElement type) {
-    for (Element enclosed : type.getEnclosedElements()) {
-      if (enclosed.getKind() != ElementKind.CONSTRUCTOR) {
-        continue;
-      }
-      ExecutableElement constructor = (ExecutableElement) enclosed;
-      if (constructor.getParameters().isEmpty()) {
-        return constructor;
-      }
-    }
-    return null;
+  public static DeclaredType getKeyTypeOfMap(DeclaredType mapType) {
+    checkState(MoreTypes.isTypeOf(Map.class, mapType), "%s is not a Map.", mapType);
+    List<? extends TypeMirror> mapArgs = mapType.getTypeArguments();
+    return MoreTypes.asDeclared(mapArgs.get(0));
   }
 
   /**
-   * Returns true if generated code can invoke {@code constructor}. That is, if
-   * the constructor is non-private and its enclosing class is either a
-   * top-level class or a static nested class.
+   * Returns the unwrapped key's {@link TypeElement} for a {@link Map} given the
+   * {@link AnnotationMirror} of the key.
    */
-  public static boolean isCallableConstructor(ExecutableElement constructor) {
-    if (constructor.getModifiers().contains(Modifier.PRIVATE)) {
-      return false;
-    }
-    TypeElement type = (TypeElement) constructor.getEnclosingElement();
-    return type.getEnclosingElement().getKind() == ElementKind.PACKAGE
-        || type.getModifiers().contains(Modifier.STATIC);
-  }
-
-
-  /**
-   * Returns a user-presentable string like {@code coffee.CoffeeModule}.
-   */
-  public static String className(ExecutableElement method) {
-    return ((TypeElement) method.getEnclosingElement()).getQualifiedName().toString();
-  }
-
-  public static boolean isInterface(TypeMirror typeMirror) {
-    return typeMirror instanceof DeclaredType
-        && ((DeclaredType) typeMirror).asElement().getKind() == ElementKind.INTERFACE;
-  }
+  public static TypeElement getKeyTypeElement(AnnotationMirror mapKey, final Elements elements) {
+    Map<? extends ExecutableElement, ? extends AnnotationValue> map = mapKey.getElementValues();
+    // TODO(user) Support literals other than String and Enum
+    AnnotationValueVisitor<TypeElement, Void> mapKeyVisitor =
+        new SimpleAnnotationValueVisitor6<TypeElement, Void>() {
+          @Override
+          public TypeElement visitEnumConstant(VariableElement c, Void p) {
+            return MoreElements.asType(c.getEnclosingElement()) ;
+          }
 
-  static boolean isStatic(Element element) {
-    for (Modifier modifier : element.getModifiers()) {
-      if (modifier.equals(Modifier.STATIC)) {
-        return true;
-      }
-    }
-    return false;
-  }
+          @Override
+          public TypeElement visitString(String s, Void p) {
+            return elements.getTypeElement(String.class.getCanonicalName());
+          }
 
-  static boolean isValidJavaIdentifier(String possibleIdentifier) {
-    checkNotNull(possibleIdentifier);
-    checkArgument(!possibleIdentifier.isEmpty());
-    if (!Character.isJavaIdentifierStart(possibleIdentifier.charAt(0))) {
-      return false;
-    }
-    for (int i = 1; i < possibleIdentifier.length(); i++) {
-      if (!Character.isJavaIdentifierPart(possibleIdentifier.charAt(i))) {
-        return false;
-      }
-    }
-    return true;
+          @Override
+          protected TypeElement defaultAction(Object o, Void v) {
+            throw new IllegalStateException(
+                "Non-supported key type for map binding " + o.getClass().getCanonicalName());
+          }
+        };
+    TypeElement keyTypeElement =
+        Iterables.getOnlyElement(map.entrySet()).getValue().accept(mapKeyVisitor, null);
+    return keyTypeElement;
   }
 
-  /**
-   * An exception thrown when a type is not extant (returns as an error type),
-   * usually as a result of another processor not having yet generated its types upon
-   * which a dagger-annotated type depends.
-   */
-  final static class CodeGenerationIncompleteException extends IllegalStateException {
-    public CodeGenerationIncompleteException(String s) {
-      super(s);
-    }
-  }
+  private Util() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/AdapterJavadocs.java b/compiler/src/main/java/dagger/internal/codegen/dagger1/AdapterJavadocs.java
similarity index 98%
rename from compiler/src/main/java/dagger/internal/codegen/AdapterJavadocs.java
rename to compiler/src/main/java/dagger/internal/codegen/dagger1/AdapterJavadocs.java
index 5f0b52af6..bd289ec31 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AdapterJavadocs.java
+++ b/compiler/src/main/java/dagger/internal/codegen/dagger1/AdapterJavadocs.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.internal.codegen.dagger1;
 
 /**
  * Utility class providing some commonly used boilerplate between {@code InjectAdapterProcessor}
diff --git a/compiler/src/main/java/dagger/internal/codegen/GeneratorKeys.java b/compiler/src/main/java/dagger/internal/codegen/dagger1/GeneratorKeys.java
similarity index 95%
rename from compiler/src/main/java/dagger/internal/codegen/GeneratorKeys.java
rename to compiler/src/main/java/dagger/internal/codegen/dagger1/GeneratorKeys.java
index 17f1800b5..cddc4390f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GeneratorKeys.java
+++ b/compiler/src/main/java/dagger/internal/codegen/dagger1/GeneratorKeys.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.internal.codegen.dagger1;
 
 import java.util.List;
 import java.util.Map;
@@ -25,8 +25,8 @@
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.TypeMirror;
 
-import static dagger.internal.codegen.Util.rawTypeToString;
-import static dagger.internal.codegen.Util.typeToString;
+import static dagger.internal.codegen.dagger1.Util.rawTypeToString;
+import static dagger.internal.codegen.dagger1.Util.typeToString;
 
 /**
  * Creates keys using javac's mirror APIs. Unlike {@code Keys}, this class uses
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisErrorHandler.java b/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisErrorHandler.java
similarity index 97%
rename from compiler/src/main/java/dagger/internal/codegen/GraphAnalysisErrorHandler.java
rename to compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisErrorHandler.java
index 121bbaebd..d7ba79704 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisErrorHandler.java
+++ b/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisErrorHandler.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.internal.codegen.dagger1;
 
 import dagger.internal.Linker;
 import java.util.List;
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisInjectBinding.java b/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisInjectBinding.java
similarity index 97%
rename from compiler/src/main/java/dagger/internal/codegen/GraphAnalysisInjectBinding.java
rename to compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisInjectBinding.java
index cbda5a496..4bd7106f3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisInjectBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisInjectBinding.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.internal.codegen.dagger1;
 
 import dagger.internal.Binding;
 import dagger.internal.Linker;
@@ -31,7 +31,7 @@
 import javax.lang.model.type.TypeMirror;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static dagger.internal.codegen.Util.getApplicationSupertype;
+import static dagger.internal.codegen.dagger1.Util.getApplicationSupertype;
 
 /**
  * A build time binding that injects the constructor and fields of a class.
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisLoader.java b/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisLoader.java
similarity index 98%
rename from compiler/src/main/java/dagger/internal/codegen/GraphAnalysisLoader.java
rename to compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisLoader.java
index c3cd022d9..78ac9ecd9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisLoader.java
+++ b/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisLoader.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.internal.codegen.dagger1;
 
 import dagger.internal.Binding;
 import dagger.internal.Loader;
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java b/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisProcessor.java
similarity index 97%
rename from compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
rename to compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisProcessor.java
index ca305c7fa..a2ee6a642 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisProcessor.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.internal.codegen.dagger1;
 
 import com.google.auto.service.AutoService;
 import dagger.Module;
@@ -25,7 +25,7 @@
 import dagger.internal.ProblemDetector;
 import dagger.internal.ProvidesBinding;
 import dagger.internal.SetBinding;
-import dagger.internal.codegen.Util.CodeGenerationIncompleteException;
+import dagger.internal.codegen.dagger1.Util.CodeGenerationIncompleteException;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.io.StringWriter;
@@ -61,10 +61,10 @@
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static dagger.Provides.Type.SET;
 import static dagger.Provides.Type.SET_VALUES;
-import static dagger.internal.codegen.Util.className;
-import static dagger.internal.codegen.Util.getAnnotation;
-import static dagger.internal.codegen.Util.getPackage;
-import static dagger.internal.codegen.Util.isInterface;
+import static dagger.internal.codegen.dagger1.Util.className;
+import static dagger.internal.codegen.dagger1.Util.getAnnotation;
+import static dagger.internal.codegen.dagger1.Util.getPackage;
+import static dagger.internal.codegen.dagger1.Util.isInterface;
 import static java.util.Arrays.asList;
 
 /**
@@ -289,7 +289,7 @@ void collectIncludesRecursively(
       TypeElement module, Map<String, TypeElement> result, Deque<String> path) {
     Map<String, Object> annotation = getAnnotation(Module.class, module);
     if (annotation == null) {
-      // TODO(tbroyer): pass annotation information
+      // TODO(user): pass annotation information
       throw new ModuleValidationException("No @Module on " + module, module);
     }
 
@@ -321,7 +321,7 @@ void collectIncludesRecursively(
     if (!annotation.get("addsTo").equals(Void.class)) seedModules.add(annotation.get("addsTo"));
     for (Object include : seedModules) {
       if (!(include instanceof TypeMirror)) {
-        // TODO(tbroyer): pass annotation information
+        // TODO(user): pass annotation information
         processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING,
             "Unexpected value for include: " + include + " in " + module, module);
         continue;
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisStaticInjection.java b/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisStaticInjection.java
similarity index 93%
rename from compiler/src/main/java/dagger/internal/codegen/GraphAnalysisStaticInjection.java
rename to compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisStaticInjection.java
index dee437651..5ca2d422f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisStaticInjection.java
+++ b/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisStaticInjection.java
@@ -13,14 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.internal.codegen.dagger1;
 
 import dagger.internal.Linker;
 import dagger.internal.StaticInjection;
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
 
-import static dagger.internal.codegen.Util.isStatic;
+import static dagger.internal.codegen.dagger1.Util.isStatic;
 
 public final class GraphAnalysisStaticInjection extends StaticInjection {
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java b/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphVisualizer.java
similarity index 99%
rename from compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java
rename to compiler/src/main/java/dagger/internal/codegen/dagger1/GraphVisualizer.java
index a0fe29ce7..e0c251c9c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java
+++ b/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphVisualizer.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.internal.codegen.dagger1;
 
 import dagger.internal.Binding;
 import java.io.IOException;
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphVizWriter.java b/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphVizWriter.java
similarity index 99%
rename from compiler/src/main/java/dagger/internal/codegen/GraphVizWriter.java
rename to compiler/src/main/java/dagger/internal/codegen/dagger1/GraphVizWriter.java
index d149d167e..624d1963e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphVizWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphVizWriter.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.internal.codegen.dagger1;
 
 import com.squareup.javawriter.JavaWriter;
 import java.io.Closeable;
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/dagger1/InjectAdapterProcessor.java
similarity index 97%
rename from compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
rename to compiler/src/main/java/dagger/internal/codegen/dagger1/InjectAdapterProcessor.java
index b222ff37b..7c3b9e271 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/dagger1/InjectAdapterProcessor.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.internal.codegen.dagger1;
 
 import com.google.auto.common.SuperficialValidation;
 import com.google.auto.service.AutoService;
@@ -50,14 +50,14 @@
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static dagger.internal.Keys.isPlatformType;
-import static dagger.internal.codegen.AdapterJavadocs.bindingTypeDocs;
-import static dagger.internal.codegen.Util.adapterName;
-import static dagger.internal.codegen.Util.elementToString;
-import static dagger.internal.codegen.Util.getNoArgsConstructor;
-import static dagger.internal.codegen.Util.getPackage;
-import static dagger.internal.codegen.Util.isCallableConstructor;
-import static dagger.internal.codegen.Util.rawTypeToString;
-import static dagger.internal.codegen.Util.typeToString;
+import static dagger.internal.codegen.dagger1.AdapterJavadocs.bindingTypeDocs;
+import static dagger.internal.codegen.dagger1.Util.adapterName;
+import static dagger.internal.codegen.dagger1.Util.elementToString;
+import static dagger.internal.codegen.dagger1.Util.getNoArgsConstructor;
+import static dagger.internal.codegen.dagger1.Util.getPackage;
+import static dagger.internal.codegen.dagger1.Util.isCallableConstructor;
+import static dagger.internal.codegen.dagger1.Util.rawTypeToString;
+import static dagger.internal.codegen.dagger1.Util.typeToString;
 import static dagger.internal.loaders.GeneratedAdapters.INJECT_ADAPTER_SUFFIX;
 import static dagger.internal.loaders.GeneratedAdapters.STATIC_INJECTION_SUFFIX;
 import static javax.lang.model.element.Modifier.ABSTRACT;
@@ -191,17 +191,17 @@ private InjectedClass createInjectedClass(String injectedClassName) {
           break;
         case CONSTRUCTOR:
           if (constructor != null) {
-            // TODO(tbroyer): pass annotation information
+            // TODO(user): pass annotation information
             error("Too many injectable constructors on " + type.getQualifiedName(), member);
           } else if (isAbstract) {
-            // TODO(tbroyer): pass annotation information
+            // TODO(user): pass annotation information
             error("Abstract class " + type.getQualifiedName()
                 + " must not have an @Inject-annotated constructor.", member);
           }
           constructor = (ExecutableElement) member;
           break;
         default:
-          // TODO(tbroyer): pass annotation information
+          // TODO(user): pass annotation information
           error("Cannot inject " + elementToString(member), member);
           break;
       }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/dagger1/ModuleAdapterProcessor.java
similarity index 96%
rename from compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
rename to compiler/src/main/java/dagger/internal/codegen/dagger1/ModuleAdapterProcessor.java
index ba3328a71..3ec8b41e8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/dagger1/ModuleAdapterProcessor.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.internal.codegen.dagger1;
 
 import com.google.auto.service.AutoService;
 import com.squareup.javawriter.JavaWriter;
@@ -26,7 +26,7 @@
 import dagger.internal.ModuleAdapter;
 import dagger.internal.ProvidesBinding;
 import dagger.internal.SetBinding;
-import dagger.internal.codegen.Util.CodeGenerationIncompleteException;
+import dagger.internal.codegen.dagger1.Util.CodeGenerationIncompleteException;
 import java.io.IOException;
 import java.io.StringWriter;
 import java.io.Writer;
@@ -64,15 +64,15 @@
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static dagger.Provides.Type.SET;
 import static dagger.Provides.Type.SET_VALUES;
-import static dagger.internal.codegen.AdapterJavadocs.bindingTypeDocs;
-import static dagger.internal.codegen.Util.adapterName;
-import static dagger.internal.codegen.Util.elementToString;
-import static dagger.internal.codegen.Util.getAnnotation;
-import static dagger.internal.codegen.Util.getNoArgsConstructor;
-import static dagger.internal.codegen.Util.getPackage;
-import static dagger.internal.codegen.Util.isCallableConstructor;
-import static dagger.internal.codegen.Util.isInterface;
-import static dagger.internal.codegen.Util.typeToString;
+import static dagger.internal.codegen.dagger1.AdapterJavadocs.bindingTypeDocs;
+import static dagger.internal.codegen.dagger1.Util.adapterName;
+import static dagger.internal.codegen.dagger1.Util.elementToString;
+import static dagger.internal.codegen.dagger1.Util.getAnnotation;
+import static dagger.internal.codegen.dagger1.Util.getNoArgsConstructor;
+import static dagger.internal.codegen.dagger1.Util.getPackage;
+import static dagger.internal.codegen.dagger1.Util.isCallableConstructor;
+import static dagger.internal.codegen.dagger1.Util.isInterface;
+import static dagger.internal.codegen.dagger1.Util.typeToString;
 import static dagger.internal.loaders.GeneratedAdapters.MODULE_ADAPTER_SUFFIX;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
@@ -116,7 +116,7 @@
         // CodeGenerationIncompleteException.
         Map<String, Object> parsedAnnotation = getAnnotation(Module.class, type);
 
-        //TODO(cgruber): Figure out an initial sizing of the StringWriter.
+        //TODO(user): Figure out an initial sizing of the StringWriter.
         StringWriter stringWriter = new StringWriter();
         String adapterName = adapterName(type, MODULE_ADAPTER_SUFFIX);
         generateModuleAdapter(stringWriter, adapterName, type, parsedAnnotation, providesTypes);
@@ -161,7 +161,7 @@ private void error(String msg, Element element) {
         case CLASS:
           break; // valid, move along
         default:
-          // TODO(tbroyer): pass annotation information
+          // TODO(user): pass annotation information
           error("Unexpected @Provides on " + elementToString(providerMethod), providerMethod);
           continue;
       }
@@ -303,7 +303,7 @@ private void generateModuleAdapter(Writer ioWriter, String adapterName, TypeElem
     StringBuilder includesField = new StringBuilder().append("{ ");
     for (Object include : includes) {
       if (!(include instanceof TypeMirror)) {
-        // TODO(tbroyer): pass annotation information
+        // TODO(user): pass annotation information
         processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING,
             "Unexpected value: " + include + " in includes of " + type, type);
         continue;
diff --git a/compiler/src/main/java/dagger/internal/codegen/dagger1/Util.java b/compiler/src/main/java/dagger/internal/codegen/dagger1/Util.java
new file mode 100644
index 000000000..1afad0dcb
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/dagger1/Util.java
@@ -0,0 +1,386 @@
+/*
+ * Copyright (C) 2013 Google, Inc.
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen.dagger1;
+
+import dagger.internal.Keys;
+import java.lang.reflect.Method;
+import java.util.Arrays;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.AnnotationValueVisitor;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.PackageElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.ArrayType;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ErrorType;
+import javax.lang.model.type.PrimitiveType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.TypeVariable;
+import javax.lang.model.type.WildcardType;
+import javax.lang.model.util.SimpleAnnotationValueVisitor6;
+import javax.lang.model.util.SimpleTypeVisitor6;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+
+/**
+ * Utilities for handling types in annotation processors
+ */
+final class Util {
+  private Util() {
+  }
+
+  public static PackageElement getPackage(Element type) {
+    while (type.getKind() != ElementKind.PACKAGE) {
+      type = type.getEnclosingElement();
+    }
+    return (PackageElement) type;
+  }
+
+  /**
+   * Returns the supertype, or {@code null} if the supertype is a platform
+   * class. This is intended for annotation processors that assume platform
+   * classes will never be annotated with application annotations.
+   */
+  public static TypeMirror getApplicationSupertype(TypeElement type) {
+    TypeMirror supertype = type.getSuperclass();
+    return Keys.isPlatformType(supertype.toString()) ? null : supertype;
+  }
+
+  /** Returns a fully qualified class name to complement {@code type}. */
+  public static String adapterName(TypeElement typeElement, String suffix) {
+    StringBuilder builder = new StringBuilder();
+    rawTypeToString(builder, typeElement, '$');
+    builder.append(suffix);
+    return builder.toString();
+  }
+
+  /** Returns a string for {@code type}. Primitive types are always boxed. */
+  public static String typeToString(TypeMirror type) {
+    StringBuilder result = new StringBuilder();
+    typeToString(type, result, '.');
+    return result.toString();
+  }
+
+  /** Returns a string for the raw type of {@code type}. Primitive types are always boxed. */
+  public static String rawTypeToString(TypeMirror type, char innerClassSeparator) {
+    if (!(type instanceof DeclaredType)) {
+      throw new IllegalArgumentException("Unexpected type: " + type);
+    }
+    StringBuilder result = new StringBuilder();
+    DeclaredType declaredType = (DeclaredType) type;
+    rawTypeToString(result, (TypeElement) declaredType.asElement(), innerClassSeparator);
+    return result.toString();
+  }
+
+  /**
+   * Appends a string for {@code type} to {@code result}. Primitive types are
+   * always boxed.
+   *
+   * @param innerClassSeparator either '.' or '$', which will appear in a
+   *     class name like "java.lang.Map.Entry" or "java.lang.Map$Entry".
+   *     Use '.' for references to existing types in code. Use '$' to define new
+   *     class names and for strings that will be used by runtime reflection.
+   */
+  public static void typeToString(final TypeMirror type, final StringBuilder result,
+      final char innerClassSeparator) {
+    type.accept(new SimpleTypeVisitor6<Void, Void>() {
+      @Override public Void visitDeclared(DeclaredType declaredType, Void v) {
+        TypeElement typeElement = (TypeElement) declaredType.asElement();
+        rawTypeToString(result, typeElement, innerClassSeparator);
+        List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();
+        if (!typeArguments.isEmpty()) {
+          result.append("<");
+          for (int i = 0; i < typeArguments.size(); i++) {
+            if (i != 0) {
+              result.append(", ");
+            }
+            typeToString(typeArguments.get(i), result, innerClassSeparator);
+          }
+          result.append(">");
+        }
+        return null;
+      }
+      @Override public Void visitPrimitive(PrimitiveType primitiveType, Void v) {
+        result.append(box((PrimitiveType) type).getName());
+        return null;
+      }
+      @Override public Void visitArray(ArrayType arrayType, Void v) {
+        TypeMirror type = arrayType.getComponentType();
+        if (type instanceof PrimitiveType) {
+          result.append(type.toString()); // Don't box, since this is an array.
+        } else {
+          typeToString(arrayType.getComponentType(), result, innerClassSeparator);
+        }
+        result.append("[]");
+        return null;
+      }
+      @Override public Void visitTypeVariable(TypeVariable typeVariable, Void v) {
+        result.append(typeVariable.asElement().getSimpleName());
+        return null;
+      }
+      @Override public Void visitError(ErrorType errorType, Void v) {
+        // Error type found, a type may not yet have been generated, but we need the type
+        // so we can generate the correct code in anticipation of the type being available
+        // to the compiler.
+
+        // Paramterized types which don't exist are returned as an error type whose name is "<any>"
+        if ("<any>".equals(errorType.toString())) {
+          throw new CodeGenerationIncompleteException(
+              "Type reported as <any> is likely a not-yet generated parameterized type.");
+        }
+        // TODO(user): Figure out a strategy for non-FQCN cases.
+        result.append(errorType.toString());
+        return null;
+      }
+      public Void visitWildcard(WildcardType wildcardType, Void v) {
+        result.append("?");
+        if (wildcardType.getExtendsBound() != null) {
+          result.append(" extends ");
+          typeToString(wildcardType.getExtendsBound(), result, innerClassSeparator);
+        } else if (wildcardType.getSuperBound() != null) {
+          result.append(" super ");
+          typeToString(wildcardType.getSuperBound(), result, innerClassSeparator);
+        }
+        return null;
+      }
+      @Override protected Void defaultAction(TypeMirror typeMirror, Void v) {
+        throw new UnsupportedOperationException(
+            "Unexpected TypeKind " + typeMirror.getKind() + " for "  + typeMirror);
+      }
+    }, null);
+  }
+
+  private static final AnnotationValueVisitor<Object, Void> VALUE_EXTRACTOR =
+      new SimpleAnnotationValueVisitor6<Object, Void>() {
+        @Override public Object visitString(String s, Void p) {
+          if ("<error>".equals(s)) {
+            throw new CodeGenerationIncompleteException("Unknown type returned as <error>.");
+          } else if ("<any>".equals(s)) {
+            throw new CodeGenerationIncompleteException("Unknown type returned as <any>.");
+          }
+          return s;
+        }
+        @Override public Object visitType(TypeMirror t, Void p) {
+          return t;
+        }
+        @Override protected Object defaultAction(Object o, Void v) {
+          return o;
+        }
+        @Override public Object visitArray(List<? extends AnnotationValue> values, Void v) {
+          Object[] result = new Object[values.size()];
+          for (int i = 0; i < values.size(); i++) {
+            result[i] = values.get(i).accept(this, null);
+          }
+          return result;
+        }
+      };
+
+  /**
+   * Returns the annotation on {@code element} formatted as a Map. This returns
+   * a Map rather than an instance of the annotation interface to work-around
+   * the fact that Class and Class[] fields won't work at code generation time.
+   * See http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5089128
+   */
+  public static Map<String, Object> getAnnotation(Class<?> annotationType, Element element) {
+    for (AnnotationMirror annotation : element.getAnnotationMirrors()) {
+      if (!rawTypeToString(annotation.getAnnotationType(), '$')
+          .equals(annotationType.getName())) {
+        continue;
+      }
+
+      Map<String, Object> result = new LinkedHashMap<String, Object>();
+      for (Method m : annotationType.getMethods()) {
+        result.put(m.getName(), m.getDefaultValue());
+      }
+      for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> e
+          : annotation.getElementValues().entrySet()) {
+        String name = e.getKey().getSimpleName().toString();
+        Object value = e.getValue().accept(VALUE_EXTRACTOR, null);
+        Object defaultValue = result.get(name);
+        if (!lenientIsInstance(defaultValue.getClass(), value)) {
+          throw new IllegalStateException(String.format(
+              "Value of %s.%s is a %s but expected a %s\n    value: %s",
+              annotationType, name, value.getClass().getName(), defaultValue.getClass().getName(),
+              value instanceof Object[] ? Arrays.toString((Object[]) value) : value));
+        }
+        result.put(name, value);
+      }
+      return result;
+    }
+    return null; // Annotation not found.
+  }
+
+  /**
+   * Returns true if {@code value} can be assigned to {@code expectedClass}.
+   * Like {@link Class#isInstance} but more lenient for {@code Class<?>} values.
+   */
+  private static boolean lenientIsInstance(Class<?> expectedClass, Object value) {
+    if (expectedClass.isArray()) {
+      Class<?> componentType = expectedClass.getComponentType();
+      if (!(value instanceof Object[])) {
+        return false;
+      }
+      for (Object element : (Object[]) value) {
+        if (!lenientIsInstance(componentType, element)) return false;
+      }
+      return true;
+    } else if (expectedClass == Class.class) {
+      return value instanceof TypeMirror;
+    } else {
+      return expectedClass == value.getClass();
+    }
+  }
+
+  // TODO(user): better format for other types of elements?
+  static String elementToString(Element element) {
+    switch (element.getKind()) {
+      case FIELD:
+      // fall through
+      case CONSTRUCTOR:
+      // fall through
+      case METHOD:
+        return element.getEnclosingElement() + "." + element;
+      default:
+        return element.toString();
+    }
+  }
+
+  static void rawTypeToString(StringBuilder result, TypeElement type,
+      char innerClassSeparator) {
+    String packageName = getPackage(type).getQualifiedName().toString();
+    String qualifiedName = type.getQualifiedName().toString();
+    if (packageName.isEmpty()) {
+        result.append(qualifiedName.replace('.', innerClassSeparator));
+    } else {
+      result.append(packageName);
+      result.append('.');
+      result.append(
+          qualifiedName.substring(packageName.length() + 1).replace('.', innerClassSeparator));
+    }
+  }
+
+  private static Class<?> box(PrimitiveType primitiveType) {
+    switch (primitiveType.getKind()) {
+      case BYTE:
+        return Byte.class;
+      case SHORT:
+        return Short.class;
+      case INT:
+        return Integer.class;
+      case LONG:
+        return Long.class;
+      case FLOAT:
+        return Float.class;
+      case DOUBLE:
+        return Double.class;
+      case BOOLEAN:
+        return Boolean.class;
+      case CHAR:
+        return Character.class;
+      case VOID:
+        return Void.class;
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  /**
+   * Returns the no-args constructor for {@code type}, or null if no such
+   * constructor exists.
+   */
+  public static ExecutableElement getNoArgsConstructor(TypeElement type) {
+    for (Element enclosed : type.getEnclosedElements()) {
+      if (enclosed.getKind() != ElementKind.CONSTRUCTOR) {
+        continue;
+      }
+      ExecutableElement constructor = (ExecutableElement) enclosed;
+      if (constructor.getParameters().isEmpty()) {
+        return constructor;
+      }
+    }
+    return null;
+  }
+
+  /**
+   * Returns true if generated code can invoke {@code constructor}. That is, if
+   * the constructor is non-private and its enclosing class is either a
+   * top-level class or a static nested class.
+   */
+  public static boolean isCallableConstructor(ExecutableElement constructor) {
+    if (constructor.getModifiers().contains(Modifier.PRIVATE)) {
+      return false;
+    }
+    TypeElement type = (TypeElement) constructor.getEnclosingElement();
+    return type.getEnclosingElement().getKind() == ElementKind.PACKAGE
+        || type.getModifiers().contains(Modifier.STATIC);
+  }
+
+  /**
+   * Returns a user-presentable string like {@code coffee.CoffeeModule}.
+   */
+  public static String className(ExecutableElement method) {
+    return ((TypeElement) method.getEnclosingElement()).getQualifiedName().toString();
+  }
+
+  public static boolean isInterface(TypeMirror typeMirror) {
+    return typeMirror instanceof DeclaredType
+        && ((DeclaredType) typeMirror).asElement().getKind() == ElementKind.INTERFACE;
+  }
+
+  static boolean isStatic(Element element) {
+    for (Modifier modifier : element.getModifiers()) {
+      if (modifier.equals(Modifier.STATIC)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  static boolean isValidJavaIdentifier(String possibleIdentifier) {
+    checkNotNull(possibleIdentifier);
+    checkArgument(!possibleIdentifier.isEmpty());
+    if (!Character.isJavaIdentifierStart(possibleIdentifier.charAt(0))) {
+      return false;
+    }
+    for (int i = 1; i < possibleIdentifier.length(); i++) {
+      if (!Character.isJavaIdentifierPart(possibleIdentifier.charAt(i))) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  /**
+   * An exception thrown when a type is not extant (returns as an error type),
+   * usually as a result of another processor not having yet generated its types upon
+   * which a dagger-annotated type depends.
+   */
+  final static class CodeGenerationIncompleteException extends IllegalStateException {
+    public CodeGenerationIncompleteException(String s) {
+      super(s);
+    }
+  }
+
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ValidationProcessor.java b/compiler/src/main/java/dagger/internal/codegen/dagger1/ValidationProcessor.java
similarity index 97%
rename from compiler/src/main/java/dagger/internal/codegen/ValidationProcessor.java
rename to compiler/src/main/java/dagger/internal/codegen/dagger1/ValidationProcessor.java
index 75cf77a40..e58e1a080 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ValidationProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/dagger1/ValidationProcessor.java
@@ -14,12 +14,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.internal.codegen.dagger1;
 
 import com.google.auto.service.AutoService;
 import dagger.Module;
 import dagger.Provides;
-import dagger.internal.codegen.Util.CodeGenerationIncompleteException;
+import dagger.internal.codegen.dagger1.Util.CodeGenerationIncompleteException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.LinkedHashMap;
@@ -41,7 +41,7 @@
 import javax.tools.Diagnostic;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static dagger.internal.codegen.Util.elementToString;
+import static dagger.internal.codegen.dagger1.Util.elementToString;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.ElementKind.METHOD;
 import static javax.lang.model.element.Modifier.ABSTRACT;
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
index 27cda36ed..107062f22 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
@@ -20,14 +20,12 @@
 import static javax.lang.model.element.Modifier.PUBLIC;
 
 public final class ClassWriter extends TypeWriter {
-  private final List<TypeWriter> nestedTypeWriters;
   private final Map<String, FieldWriter> fieldWriters;
   private final List<ConstructorWriter> constructorWriters;
   private final List<TypeVariableName> typeVariables;
 
   ClassWriter(ClassName className) {
     super(className);
-    this.nestedTypeWriters = Lists.newArrayList();
     this.fieldWriters = Maps.newLinkedHashMap();
     this.constructorWriters = Lists.newArrayList();
     this.typeVariables = Lists.newArrayList();
@@ -67,12 +65,6 @@ public ConstructorWriter addConstructor() {
     return constructorWriter;
   }
 
-  public ClassWriter addNestedClass(String name) {
-    ClassWriter innerClassWriter = new ClassWriter(this.name.nestedClassNamed(name));
-    nestedTypeWriters.add(innerClassWriter);
-    return innerClassWriter;
-  }
-
   @Override
   public Appendable write(Appendable appendable, Context context) throws IOException {
     context = context.createSubcontext(FluentIterable.from(nestedTypeWriters)
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java
index f777100c1..08182a41b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java
@@ -12,12 +12,9 @@
 
 public class InterfaceWriter extends TypeWriter {
   private final List<TypeVariableName> typeVariables;
-  private final List<TypeWriter> nestedTypeWriters;
-
   InterfaceWriter(ClassName name) {
     super(name);
     this.typeVariables = Lists.newArrayList();
-    this.nestedTypeWriters = Lists.newArrayList();
   }
 
   public void addTypeVariable(TypeVariableName typeVariable) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
index f57e354b3..60ac493d1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
@@ -10,26 +10,21 @@
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Ordering;
+import com.google.common.collect.Queues;
 import com.google.common.collect.Sets;
-import com.google.common.escape.Escapers;
 import com.google.common.io.Closer;
 import dagger.internal.codegen.writer.Writable.Context;
 import java.io.IOException;
+import java.util.Deque;
 import java.util.List;
 import java.util.Set;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.Modifier;
 import javax.lang.model.element.PackageElement;
 import javax.tools.JavaFileObject;
 
-import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.PROTECTED;
-import static javax.lang.model.element.Modifier.STATIC;
+import static java.util.Collections.unmodifiableList;
 
 /**
  * Writes a single compilation unit.
@@ -48,7 +43,7 @@ public static JavaWriter inPackage(PackageElement packageElement) {
   }
 
   private final String packageName;
-  // TODO(gak): disallow multiple types in a file
+  // TODO(gak): disallow multiple types in a file?
   private final List<TypeWriter> typeWriters;
   private final List<ClassName> explicitImports;
 
@@ -58,20 +53,17 @@ private JavaWriter(String packageName) {
     this.explicitImports = Lists.newArrayList();
   }
 
+  public List<TypeWriter> getTypeWriters() {
+    return unmodifiableList(typeWriters);
+  }
+
   public JavaWriter addImport(Class<?> importedClass) {
     explicitImports.add(ClassName.fromClass(importedClass));
     return this;
   }
 
   public ClassWriter addClass(String simpleName) {
-    Set<Modifier> modifiers = ImmutableSet.<Modifier>of();
-    checkNotNull(modifiers);
     checkNotNull(simpleName);
-    checkArgument(!modifiers.contains(PROTECTED));
-    checkArgument(!modifiers.contains(PRIVATE));
-    checkArgument(!modifiers.contains(STATIC));
-    checkNotNull(Optional.<Class<?>>absent());
-    checkNotNull(ImmutableSet.<Class<?>>of());
     ClassWriter classWriter = new ClassWriter(ClassName.create(packageName, simpleName));
     typeWriters.add(classWriter);
     return classWriter;
@@ -83,18 +75,6 @@ public InterfaceWriter addInterface(String simpleName) {
     return writer;
   }
 
-  static ImmutableSet<ClassName> collectReferencedClasses(
-      Iterable<? extends HasClassReferences> iterable) {
-    return FluentIterable.from(iterable)
-        .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
-          @Override
-          public Set<ClassName> apply(HasClassReferences input) {
-            return input.referencedClasses();
-          }
-        })
-        .toSet();
-  }
-
   public Appendable write(Appendable appendable) throws IOException {
     appendable.append("package ").append(packageName).append(';').append("\n\n");
 
@@ -107,8 +87,7 @@ public Appendable write(Appendable appendable) throws IOException {
           }
         })
         .toSet();
-    BiMap<String, ClassName> importedClassIndex = HashBiMap.create();
-    // TODO(gak): check for collisions with types declared in this compilation unit too
+
     ImmutableSortedSet<ClassName> importCandidates = ImmutableSortedSet.<ClassName>naturalOrder()
         .addAll(explicitImports)
         .addAll(classNames)
@@ -120,6 +99,18 @@ public Appendable write(Appendable appendable) throws IOException {
           }
         })
         .toSet();
+
+    ImmutableSet.Builder<String> declaredSimpleNamesBuilder = ImmutableSet.builder();
+    Deque<TypeWriter> declaredTypes = Queues.newArrayDeque(typeWriters);
+    while (!declaredTypes.isEmpty()) {
+      TypeWriter currentType = declaredTypes.pop();
+      declaredSimpleNamesBuilder.add(currentType.name().simpleName());
+      declaredTypes.addAll(currentType.nestedTypeWriters);
+    }
+
+    ImmutableSet<String> declaredSimpleNames = declaredSimpleNamesBuilder.build();
+
+    BiMap<String, ClassName> importedClassIndex = HashBiMap.create();
     for (ClassName className : importCandidates) {
       if (!(className.packageName().equals(packageName)
               && !className.enclosingClassName().isPresent())
@@ -128,7 +119,8 @@ public Appendable write(Appendable appendable) throws IOException {
           && !typeNames.contains(className.topLevelClassName())) {
         Optional<ClassName> importCandidate = Optional.of(className);
         while (importCandidate.isPresent()
-            && importedClassIndex.containsKey(importCandidate.get().simpleName())) {
+            && (importedClassIndex.containsKey(importCandidate.get().simpleName())
+                || declaredSimpleNames.contains(importCandidate.get().simpleName()))) {
           importCandidate = importCandidate.get().enclosingClassName();
         }
         if (importCandidate.isPresent()) {
@@ -152,8 +144,12 @@ public Appendable write(Appendable appendable) throws IOException {
 
   public void file(Filer filer, Iterable<? extends Element> originatingElements)
       throws IOException {
-    JavaFileObject sourceFile = filer.createSourceFile(
-        Iterables.getOnlyElement(typeWriters).name.canonicalName(),
+    file(filer, Iterables.getOnlyElement(typeWriters).name.canonicalName(), originatingElements);
+  }
+
+  public void file(Filer filer, CharSequence name,  Iterable<? extends Element> originatingElements)
+      throws IOException {
+    JavaFileObject sourceFile = filer.createSourceFile(name,
         Iterables.toArray(originatingElements, Element.class));
     Closer closer = Closer.create();
     try {
@@ -179,7 +175,6 @@ public String toString() {
     }
   }
 
-
   static final class CompilationUnitContext implements Writable.Context {
     private final String packageName;
     private final ImmutableSortedSet<ClassName> visibleClasses;
@@ -234,27 +229,5 @@ private boolean isImported(ClassName className) {
           || (className.packageName().equals("java.lang")
               && className.enclosingSimpleNames().isEmpty());
     }
-
-    private static final String JAVA_IDENTIFIER_REGEX =
-        "\\p{javaJavaIdentifierStart}\\p{javaJavaIdentifierPart}*";
-
-    @Override
-    public String compressTypesWithin(String snippet) {
-      // TODO(gak): deal with string literals
-      for (ClassName importedClass : visibleClasses) {
-        snippet = snippet.replace(importedClass.canonicalName(), importedClass.simpleName());
-      }
-      Pattern samePackagePattern = Pattern.compile(
-          packageName.replace(".", "\\.") + "\\.(" + JAVA_IDENTIFIER_REGEX + ")([^\\.])");
-      Matcher matcher = samePackagePattern.matcher(snippet);
-      StringBuffer buffer = new StringBuffer();
-      while (matcher.find()) {
-        matcher.appendReplacement(buffer, collidesWithVisibleClass(matcher.group(1))
-            ? Escapers.builder().addEscape('$', "\\$").build().escape(matcher.group())
-            : "$1$2");
-      }
-      matcher.appendTail(buffer);
-      return buffer.toString();
-    }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java
index d8d71c8e9..eaae2eea1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java
@@ -14,7 +14,6 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 
-
 public class MethodWriter extends Modifiable implements HasClassReferences, Writable {
   private final TypeName returnType;
   private final String name;
@@ -28,6 +27,10 @@
     this.body = Optional.absent();
   }
 
+  public String name() {
+    return name;
+  }
+
   public VariableWriter addParameter(Class<?> type, String name) {
     return addParameter(ClassName.fromClass(type), name);
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Modifiable.java b/compiler/src/main/java/dagger/internal/codegen/writer/Modifiable.java
index 9840ef830..0e9bab058 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/Modifiable.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/Modifiable.java
@@ -1,5 +1,6 @@
 package dagger.internal.codegen.writer;
 
+import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import dagger.internal.codegen.writer.Writable.Context;
 import java.io.IOException;
@@ -19,7 +20,11 @@
   }
 
   public void addModifiers(Modifier first, Modifier... rest) {
-    this.modifiers.addAll(Lists.asList(first, rest));
+    addModifiers(Lists.asList(first, rest));
+  }
+
+  public void addModifiers(Iterable<Modifier> modifiers) {
+    Iterables.addAll(this.modifiers, modifiers);
   }
 
   public AnnotationWriter annotate(Class<? extends Annotation> annotation) {
@@ -28,7 +33,6 @@ public AnnotationWriter annotate(Class<? extends Annotation> annotation) {
     return annotationWriter;
   }
 
-
   Appendable writeModifiers(Appendable appendable) throws IOException {
     for (Modifier modifier : modifiers) {
       appendable.append(modifier.toString()).append(' ');
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java b/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java
index cbd0af712..7dd810e61 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java
@@ -1,24 +1,35 @@
 package dagger.internal.codegen.writer;
 
 import com.google.common.base.Function;
+import com.google.common.base.Joiner;
 import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
 import java.io.IOException;
+import java.util.Collections;
+import java.util.Formatter;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
 
 public final class Snippet implements HasClassReferences, Writable {
-  private final String value;
+  private final String format;
   private final ImmutableSet<TypeName> types;
+  private final ImmutableList<Object> args;
 
-  Snippet(String value, ImmutableSet<TypeName> types) {
-    this.value = value;
+  private Snippet(String format, ImmutableSet<TypeName> types, ImmutableList<Object> args) {
+    this.format = format;
     this.types = types;
+    this.args = args;
   }
 
-  public String value() {
-    return value;
+  public String format() {
+    return format;
+  }
+
+  public ImmutableList<Object> args() {
+    return args;
   }
 
   public ImmutableSet<TypeName> types() {
@@ -27,7 +38,7 @@ public String value() {
 
   @Override
   public String toString() {
-    return value;
+    return Writables.writeToString(this);
   }
 
   @Override
@@ -44,11 +55,23 @@ public String toString() {
 
   @Override
   public Appendable write(Appendable appendable, Context context) throws IOException {
-    return appendable.append(context.compressTypesWithin(value));
+    ImmutableList.Builder<Object> formattedArgsBuilder = ImmutableList.builder();
+    for (Object arg : args) {
+      if (arg instanceof Writable) {
+        formattedArgsBuilder.add(((Writable) arg).write(new StringBuilder(), context).toString());
+      } else {
+        formattedArgsBuilder.add(arg);
+      }
+    }
+
+    @SuppressWarnings("resource") // intentionally don't close the formatter
+    Formatter formatter = new Formatter(appendable);
+    formatter.format(format, formattedArgsBuilder.build().toArray(new Object[0]));
+
+    return appendable;
   }
 
   public static Snippet format(String format, Object... args) {
-    String value = String.format(format, args);
     ImmutableSet.Builder<TypeName> types = ImmutableSet.builder();
     for (Object arg : args) {
       if (arg instanceof Snippet) {
@@ -61,27 +84,35 @@ public static Snippet format(String format, Object... args) {
         types.add(((HasTypeName) arg).name());
       }
     }
-    return new Snippet(value, types.build());
+    return new Snippet(format, types.build(), ImmutableList.copyOf(args));
+  }
+
+  public static Snippet format(String format, Iterable<? extends Object> args) {
+    return format(format, Iterables.toArray(args, Object.class));
   }
 
-  public static Snippet create(String value, Iterable<TypeName> types) {
-    return new Snippet(value, ImmutableSet.copyOf(types));
+  public static Snippet memberSelectSnippet(Iterable<? extends Object> selectors) {
+    return format(Joiner.on('.').join(Collections.nCopies(Iterables.size(selectors), "%s")),
+        selectors);
   }
 
   public static Snippet makeParametersSnippet(List<Snippet> parameterSnippets) {
     Iterator<Snippet> iterator = parameterSnippets.iterator();
     StringBuilder stringBuilder = new StringBuilder();
     ImmutableSet.Builder<TypeName> typesBuilder = ImmutableSet.builder();
+    ImmutableList.Builder<Object> argsBuilder = ImmutableList.builder();
     if (iterator.hasNext()) {
       Snippet firstSnippet = iterator.next();
-      stringBuilder.append(firstSnippet.value());
+      stringBuilder.append(firstSnippet.format());
       typesBuilder.addAll(firstSnippet.types());
+      argsBuilder.addAll(firstSnippet.args());
     }
     while (iterator.hasNext()) {
       Snippet nextSnippet = iterator.next();
-      stringBuilder.append(", ").append(nextSnippet.value());
+      stringBuilder.append(", ").append(nextSnippet.format());
       typesBuilder.addAll(nextSnippet.types());
+      argsBuilder.addAll(nextSnippet.args());
     }
-    return Snippet.create(stringBuilder.toString(), typesBuilder.build());
+    return new Snippet(stringBuilder.toString(), typesBuilder.build(), argsBuilder.build());
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java
index 9405aca75..aa7ba02e5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java
@@ -5,7 +5,6 @@
 import java.util.List;
 import javax.lang.model.type.TypeMirror;
 
-
 /**
  * Only named types. Doesn't cover anonymous inner classes.
  */
@@ -15,16 +14,18 @@
   Optional<TypeName> supertype;
   final List<TypeName> implementedTypes;
   final List<MethodWriter> methodWriters;
+  final List<TypeWriter> nestedTypeWriters;
 
   TypeWriter(ClassName name) {
     this.name = name;
     this.supertype = Optional.absent();
     this.implementedTypes = Lists.newArrayList();
     this.methodWriters = Lists.newArrayList();
+    nestedTypeWriters = Lists.newArrayList();
   }
 
   @Override
-  public TypeName name() {
+  public ClassName name() {
     return name;
   }
 
@@ -53,4 +54,10 @@ public MethodWriter addMethod(Class<?> returnType, String name) {
     methodWriters.add(methodWriter);
     return methodWriter;
   }
+
+  public ClassWriter addNestedClass(String name) {
+    ClassWriter innerClassWriter = new ClassWriter(this.name.nestedClassNamed(name));
+    nestedTypeWriters.add(innerClassWriter);
+    return innerClassWriter;
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java
index 53339127c..44d1a11b7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java
@@ -3,7 +3,6 @@
 import java.io.IOException;
 import java.util.Set;
 
-
 public class VariableWriter extends Modifiable implements Writable, HasClassReferences {
   private final TypeName type;
   private final String name;
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Writable.java b/compiler/src/main/java/dagger/internal/codegen/writer/Writable.java
index 2ef319744..84e4943a3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/Writable.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/Writable.java
@@ -6,7 +6,6 @@
 interface Writable {
   interface Context {
     String sourceReferenceForClassName(ClassName className);
-    String compressTypesWithin(String snippet);
     Context createSubcontext(Set<ClassName> newTypes);
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Writables.java b/compiler/src/main/java/dagger/internal/codegen/writer/Writables.java
index 8db7a2f6c..be43fbefb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/Writables.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/Writables.java
@@ -20,11 +20,6 @@ public String sourceReferenceForClassName(ClassName className) {
       return className.canonicalName();
     }
 
-    @Override
-    public String compressTypesWithin(String snippet) {
-      return snippet;
-    }
-
     @Override
     public Context createSubcontext(Set<ClassName> newTypes) {
       throw new UnsupportedOperationException();
@@ -36,7 +31,7 @@ static String writeToString(Writable writable) {
     try {
       writable.write(builder, DEFAULT_CONTEXT);
     } catch (IOException e) {
-      throw new AssertionError("StringBuilder doesn't throw IOException", e);
+      throw new AssertionError("StringBuilder doesn't throw IOException" + e);
     }
     return builder.toString();
   }
diff --git a/compiler/src/test/java/dagger/internal/codegen/AnnotationMirrorsTest.java b/compiler/src/test/java/dagger/internal/codegen/AnnotationMirrorsTest.java
index 7138a197c..5e277284a 100644
--- a/compiler/src/test/java/dagger/internal/codegen/AnnotationMirrorsTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/AnnotationMirrorsTest.java
@@ -28,9 +28,9 @@
 import org.junit.runners.JUnit4;
 
 import static com.google.common.collect.Iterables.getOnlyElement;
+import static com.google.common.truth.Truth.assert_;
 import static dagger.internal.codegen.AnnotationMirrorsTest.SimpleEnum.BLAH;
 import static dagger.internal.codegen.AnnotationMirrorsTest.SimpleEnum.FOO;
-import static org.truth0.Truth.ASSERT;
 
 /**
  * Tests {@link AnnotationMirrors}.
@@ -45,6 +45,11 @@
     this.elements = compilationRule.getElements();
   }
 
+  @interface SimpleAnnotation {}
+
+  @SimpleAnnotation class SimplyAnnotated {}
+  @SimpleAnnotation class AlsoSimplyAnnotated {}
+
   enum SimpleEnum{
     BLAH, FOO
   }
@@ -65,8 +70,6 @@
   @DefaultingOuter(BLAH) class TestWithDefaultingOuterBlah {}
   @DefaultingOuter(FOO) class TestWithDefaultingOuterFoo {}
 
-  @interface SimpleAnnotation {}
-
   @interface AnnotatedOuter {
     DefaultingOuter value();
   }
@@ -95,11 +98,14 @@
   @OuterWithValueArray({@DefaultingOuter(BLAH), @DefaultingOuter(FOO)})
   class TestValueArrayWithBlahFoo {}
 
-
   @Test public void testEquivalences() {
     EquivalenceTester<AnnotationMirror> tester =
         EquivalenceTester.of(AnnotationMirrors.equivalence());
 
+    tester.addEquivalenceGroup(
+        annotationOn(SimplyAnnotated.class),
+        annotationOn(AlsoSimplyAnnotated.class));
+
     tester.addEquivalenceGroup(
         annotationOn(TestClassBlah.class),
         annotationOn(TestClassBlah2.class));
@@ -151,26 +157,26 @@
   @Stringy("foo") class StringySet {}
 
   @Test public void testGetDefaultValuesUnset() {
-    ASSERT.that(annotationOn(StringyUnset.class).getElementValues()).isEmpty();
+    assert_().that(annotationOn(StringyUnset.class).getElementValues()).isEmpty();
     Iterable<AnnotationValue> values = AnnotationMirrors.getAnnotationValuesWithDefaults(
-        annotationOn(StringyUnset.class));
+        annotationOn(StringyUnset.class)).values();
     String value = getOnlyElement(values).accept(new SimpleAnnotationValueVisitor6<String, Void>() {
           @Override public String visitString(String value, Void ignored) {
             return value;
           }
         }, null);
-    ASSERT.that(value).isEqualTo("default");
+    assert_().that(value).isEqualTo("default");
   }
 
   @Test public void testGetDefaultValuesSet() {
     Iterable<AnnotationValue> values = AnnotationMirrors.getAnnotationValuesWithDefaults(
-        annotationOn(StringySet.class));
+        annotationOn(StringySet.class)).values();
     String value = getOnlyElement(values).accept(new SimpleAnnotationValueVisitor6<String, Void>() {
           @Override public String visitString(String value, Void ignored) {
             return value;
           }
         }, null);
-    ASSERT.that(value).isEqualTo("foo");
+    assert_().that(value).isEqualTo("foo");
   }
 
   private AnnotationMirror annotationOn(Class<?> clazz) {
diff --git a/compiler/src/test/java/dagger/internal/codegen/ClassNameTest.java b/compiler/src/test/java/dagger/internal/codegen/ClassNameTest.java
index 3a520ec73..d61fe4340 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ClassNameTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ClassNameTest.java
@@ -27,15 +27,15 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+import static com.google.common.truth.Truth.assert_;
 import static org.junit.Assert.fail;
-import static org.truth0.Truth.ASSERT;
 
 @RunWith(JUnit4.class)
 public class ClassNameTest {
   @Rule public CompilationRule compilationRule = new CompilationRule();
 
   @Test public void bestGuessForString_simpleClass() {
-    ASSERT.that(ClassName.bestGuessFromString(String.class.getName()))
+    assert_().that(ClassName.bestGuessFromString(String.class.getName()))
         .isEqualTo(ClassName.create("java.lang", "String"));
   }
 
@@ -44,20 +44,20 @@
   }
 
   @Test public void bestGuessForString_nestedClass() {
-    ASSERT.that(ClassName.bestGuessFromString(Map.Entry.class.getCanonicalName()))
+    assert_().that(ClassName.bestGuessFromString(Map.Entry.class.getCanonicalName()))
         .isEqualTo(ClassName.create("java.util", ImmutableList.of("Map"), "Entry"));
-    ASSERT.that(ClassName.bestGuessFromString(OuterClass.InnerClass.class.getCanonicalName()))
+    assert_().that(ClassName.bestGuessFromString(OuterClass.InnerClass.class.getCanonicalName()))
         .isEqualTo(
             ClassName.create("dagger.internal.codegen",
                 ImmutableList.of("ClassNameTest", "OuterClass"), "InnerClass"));
   }
 
   @Test public void bestGuessForString_defaultPackage() {
-    ASSERT.that(ClassName.bestGuessFromString("SomeClass"))
+    assert_().that(ClassName.bestGuessFromString("SomeClass"))
         .isEqualTo(ClassName.create("", "SomeClass"));
-    ASSERT.that(ClassName.bestGuessFromString("SomeClass.Nested"))
+    assert_().that(ClassName.bestGuessFromString("SomeClass.Nested"))
         .isEqualTo(ClassName.create("", ImmutableList.of("SomeClass"), "Nested"));
-    ASSERT.that(ClassName.bestGuessFromString("SomeClass.Nested.EvenMore"))
+    assert_().that(ClassName.bestGuessFromString("SomeClass.Nested.EvenMore"))
         .isEqualTo(ClassName.create("", ImmutableList.of("SomeClass", "Nested"), "EvenMore"));
   }
 
@@ -79,7 +79,7 @@
   @Test public void classNameFromTypeElement() {
     Elements elements = compilationRule.getElements();
     TypeElement element = elements.getTypeElement(Object.class.getCanonicalName());
-    ASSERT.that(ClassName.fromTypeElement(element).canonicalName())
+    assert_().that(ClassName.fromTypeElement(element).canonicalName())
         .isEqualTo("java.lang.Object");
   }
 
@@ -88,7 +88,7 @@
     TypeElement element = elements.getTypeElement(ClassNameTest.class.getCanonicalName());
     ClassName className = ClassName.fromTypeElement(element);
     ClassName peerName = className.peerNamed("Foo");
-    ASSERT.that(peerName.canonicalName())
+    assert_().that(peerName.canonicalName())
         .isEqualTo("dagger.internal.codegen.Foo");
   }
 
@@ -97,7 +97,7 @@
     TypeElement element = elements.getTypeElement(OuterClass.class.getCanonicalName());
     ClassName className = ClassName.fromTypeElement(element);
     ClassName peerName = className.peerNamed("Foo");
-    ASSERT.that(peerName.canonicalName())
+    assert_().that(peerName.canonicalName())
         .isEqualTo("dagger.internal.codegen.ClassNameTest.Foo");
   }
 
@@ -106,7 +106,7 @@
     TypeElement element = elements.getTypeElement(InnerClass.class.getCanonicalName());
     ClassName className = ClassName.fromTypeElement(element);
     ClassName peerName = className.peerNamed("Foo");
-    ASSERT.that(peerName.canonicalName())
+    assert_().that(peerName.canonicalName())
         .isEqualTo("dagger.internal.codegen.ClassNameTest.OuterClass.Foo");
   }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index de78e852e..91a4fe954 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -120,11 +120,11 @@
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class Dagger_SimpleComponent implements SimpleComponent {",
-        "  private final Provider<SomeInjectableType> someInjectableTypeProvider;",
+        "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
         "",
         "  private Dagger_SimpleComponent(Builder builder) {",
         "    assert builder != null;",
-        "    this.someInjectableTypeProvider = new SomeInjectableType$$Factory();",
+        "    initialize();",
         "  }",
         "",
         "  public static Builder builder() {",
@@ -135,6 +135,10 @@
         "    return builder().build();",
         "  }",
         "",
+        "  private void initialize() {",
+        "    this.someInjectableTypeProvider = new SomeInjectableType$$Factory();",
+        "  }",
+        "",
         "  @Override",
         "  public SomeInjectableType someInjectableType() {",
         "    return someInjectableTypeProvider.get();",
@@ -203,12 +207,11 @@
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class Dagger_SimpleComponent implements SimpleComponent {",
-        "  private final Provider<SomeInjectableType> someInjectableTypeProvider;",
+        "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
         "",
         "  private Dagger_SimpleComponent(Builder builder) {",
         "    assert builder != null;",
-        "    this.someInjectableTypeProvider =",
-        "        ScopedProvider.create(new SomeInjectableType$$Factory());",
+        "    initialize();",
         "  }",
         "",
         "  public static Builder builder() {",
@@ -219,6 +222,11 @@
         "    return builder().build();",
         "  }",
         "",
+        "  private void initialize() {",
+        "    this.someInjectableTypeProvider =",
+        "        ScopedProvider.create(new SomeInjectableType$$Factory());",
+        "  }",
+        "",
         "  @Override",
         "  public SomeInjectableType someInjectableType() {",
         "    return someInjectableTypeProvider.get();",
@@ -323,13 +331,12 @@
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class Dagger_OuterType$SimpleComponent implements SimpleComponent {",
-        "  private final Provider<A> aProvider;",
-        "  private final MembersInjector<B> bMembersInjector;",
+        "  private Provider<A> aProvider;",
+        "  private MembersInjector<B> bMembersInjector;",
         "",
         "  private Dagger_OuterType$SimpleComponent(Builder builder) {",
         "    assert builder != null;",
-        "    this.aProvider = new OuterType$A$$Factory();",
-        "    this.bMembersInjector = new OuterType$B$$MembersInjector(aProvider);",
+        "    initialize();",
         "  }",
         "",
         "  public static Builder builder() {",
@@ -340,6 +347,11 @@
         "    return builder().build();",
         "  }",
         "",
+        "  private void initialize() {",
+        "    this.aProvider = new OuterType$A$$Factory();",
+        "    this.bMembersInjector = new OuterType$B$$MembersInjector(aProvider);",
+        "  }",
+        "",
         "  @Override",
         "  public A a() {",
         "    return aProvider.get();",
@@ -419,16 +431,14 @@
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class Dagger_TestComponent implements TestComponent {",
         "  private final TestModule testModule;",
-        "  private final Provider<A> aProvider;",
-        "  private final Provider<B> bProvider;",
-        "  private final Provider<C> cProvider;",
+        "  private Provider<C> cProvider;",
+        "  private Provider<B> bProvider;",
+        "  private Provider<A> aProvider;",
         "",
         "  private Dagger_TestComponent(Builder builder) {",
         "    assert builder != null;",
         "    this.testModule = builder.testModule;",
-        "    this.cProvider = new C$$Factory();",
-        "    this.bProvider = new TestModule$$BFactory(testModule, cProvider);",
-        "    this.aProvider = new A$$Factory(bProvider);",
+        "    initialize();",
         "  }",
         "",
         "  public static Builder builder() {",
@@ -439,14 +449,22 @@
         "    return builder().build();",
         "  }",
         "",
-        "  @Override public A a() {",
+        "  private void initialize() {",
+        "    this.cProvider = new C$$Factory();",
+        "    this.bProvider = new TestModule$$BFactory(testModule, cProvider);",
+        "    this.aProvider = new A$$Factory(bProvider);",
+        "  }",
+        "",
+        "  @Override",
+        "  public A a() {",
         "    return aProvider.get();",
         "  }",
         "",
         "  public static final class Builder {",
         "    private TestModule testModule;",
         "",
-        "    private Builder() {}",
+        "    private Builder() {",
+        "    }",
         "",
         "    public TestComponent build() {",
         "      if (testModule == null) {",
@@ -528,7 +546,8 @@
         "    private TestModule testModule;",
         "    private DepModule depModule;",
         "",
-        "    private Builder() {}",
+        "    private Builder() {",
+        "    }",
         "",
         "    public TestComponent build() {",
         "      if (testModule == null) {",
@@ -616,14 +635,13 @@
         "public final class Dagger_TestComponent implements TestComponent {",
         "  private final EmptySetModule emptySetModule;",
         "  private final SetModule setModule;",
-        "  private final Provider<Set<String>> setOfStringProvider;",
+        "  private Provider<Set<String>> setOfStringProvider;",
         "",
         "  private Dagger_TestComponent(Builder builder) {",
         "    assert builder != null;",
         "    this.emptySetModule = builder.emptySetModule;",
         "    this.setModule = builder.setModule;",
-        "    this.setOfStringProvider = SetFactory.create(",
-        "    new EmptySetModule$$EmptySetFactory(emptySetModule), new SetModule$$StringFactory(setModule));",
+        "    initialize();",
         "  }",
         "",
         "  public static Builder builder() {",
@@ -634,6 +652,12 @@
         "    return builder().build();",
         "  }",
         "",
+        "  private void initialize() {",
+        "    this.setOfStringProvider =",
+        "        SetFactory.create(new EmptySetModule$$EmptySetFactory(emptySetModule),",
+        "            new SetModule$$StringFactory(setModule));",
+        "  }",
+        "",
         "  @Override",
         "  public Set<String> strings() {",
         "    return setOfStringProvider.get();",
@@ -721,14 +745,12 @@
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class Dagger_SimpleComponent implements SimpleComponent {",
-        "  private final Provider<SomeInjectableType> someInjectableTypeProvider;",
-        "  private final MembersInjector<SomeInjectedType> someInjectedTypeMembersInjector;",
+        "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
+        "  private MembersInjector<SomeInjectedType> someInjectedTypeMembersInjector;",
         "",
         "  private Dagger_SimpleComponent(Builder builder) {",
         "    assert builder != null;",
-        "    this.someInjectableTypeProvider = new SomeInjectableType$$Factory();",
-        "    this.someInjectedTypeMembersInjector =",
-        "        new SomeInjectedType$$MembersInjector(someInjectableTypeProvider);",
+        "    initialize();",
         "  }",
         "",
         "  public static Builder builder() {",
@@ -739,17 +761,26 @@
         "    return builder().build();",
         "  }",
         "",
-        "  @Override public void inject(SomeInjectedType instance) {",
+        "  private void initialize() {",
+        "    this.someInjectableTypeProvider = new SomeInjectableType$$Factory();",
+        "    this.someInjectedTypeMembersInjector =",
+        "        new SomeInjectedType$$MembersInjector(someInjectableTypeProvider);",
+        "  }",
+        "",
+        "  @Override",
+        "  public void inject(SomeInjectedType instance) {",
         "    someInjectedTypeMembersInjector.injectMembers(instance);",
         "  }",
         "",
-        "  @Override public SomeInjectedType injectAndReturn(SomeInjectedType instance) {",
+        "  @Override",
+        "  public SomeInjectedType injectAndReturn(SomeInjectedType instance) {",
         "    someInjectedTypeMembersInjector.injectMembers(instance);",
         "    return instance;",
         "  }",
         "",
         "  public static final class Builder {",
-        "    private Builder() {}",
+        "    private Builder() {",
+        "    }",
         "",
         "    public SimpleComponent build() {",
         "      return new Dagger_SimpleComponent(this);",
@@ -794,14 +825,12 @@
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class Dagger_SimpleComponent implements SimpleComponent {",
-        "  private final Provider<SimpleComponent> simpleComponentProvider;",
-        "  private final Provider<SomeInjectableType> someInjectableTypeProvider;",
+        "  private Provider<SimpleComponent> simpleComponentProvider;",
+        "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
         "",
         "  private Dagger_SimpleComponent(Builder builder) {",
         "    assert builder != null;",
-        "    this.simpleComponentProvider = InstanceFactory.<SimpleComponent>create(this);",
-        "    this.someInjectableTypeProvider =",
-        "        new SomeInjectableType$$Factory(simpleComponentProvider);",
+        "    initialize();",
         "  }",
         "",
         "  public static Builder builder() {",
@@ -812,6 +841,12 @@
         "    return builder().build();",
         "  }",
         "",
+        "  private void initialize() {",
+        "    this.simpleComponentProvider = InstanceFactory.<SimpleComponent>create(this);",
+        "    this.someInjectableTypeProvider =",
+        "        new SomeInjectableType$$Factory(simpleComponentProvider);",
+        "  }",
+        "",
         "  @Override",
         "  public SomeInjectableType someInjectableType() {",
         "    return someInjectableTypeProvider.get();",
@@ -869,17 +904,13 @@
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class Dagger_SimpleComponent implements SimpleComponent {",
-        "  private final Provider<SomeInjectableType> someInjectableTypeProvider;",
-        "  private final Provider<SomeInjectedType> someInjectedTypeProvider;",
-        "  private final MembersInjector<SomeInjectedType> someInjectedTypeMembersInjector;",
+        "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
+        "  private MembersInjector<SomeInjectedType> someInjectedTypeMembersInjector;",
+        "  private Provider<SomeInjectedType> someInjectedTypeProvider;",
         "",
         "  private Dagger_SimpleComponent(Builder builder) {",
         "    assert builder != null;",
-        "    this.someInjectableTypeProvider = new SomeInjectableType$$Factory();",
-        "    this.someInjectedTypeMembersInjector =",
-        "        new SomeInjectedType$$MembersInjector(someInjectableTypeProvider);",
-        "    this.someInjectedTypeProvider =",
-        "        new SomeInjectedType$$Factory(someInjectedTypeMembersInjector);",
+        "    initialize();",
         "  }",
         "",
         "  public static Builder builder() {",
@@ -890,6 +921,14 @@
         "    return builder().build();",
         "  }",
         "",
+        "  private void initialize() {",
+        "    this.someInjectableTypeProvider = new SomeInjectableType$$Factory();",
+        "    this.someInjectedTypeMembersInjector =",
+        "        new SomeInjectedType$$MembersInjector(someInjectableTypeProvider);",
+        "    this.someInjectedTypeProvider =",
+        "        new SomeInjectedType$$Factory(someInjectedTypeMembersInjector);",
+        "  }",
+        "",
         "  @Override",
         "  public SomeInjectedType createAndInject() {",
         "    return someInjectedTypeProvider.get();",
@@ -963,12 +1002,20 @@
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class Dagger_BComponent implements BComponent {",
         "  private final AComponent aComponent;",
-        "  private final Provider<A> aProvider;",
-        "  private final Provider<B> bProvider;",
+        "  private Provider<A> aProvider;",
+        "  private Provider<B> bProvider;",
         "",
-        "  private Dagger_BComponent(Builder builder) {  ",
+        "  private Dagger_BComponent(Builder builder) {",
         "    assert builder != null;",
         "    this.aComponent = builder.aComponent;",
+        "    initialize();",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  private void initialize() {",
         "    this.aProvider = new Factory<A>() {",
         "      @Override public A get() {",
         "        return aComponent.a();",
@@ -977,29 +1024,25 @@
         "    this.bProvider = new B$$Factory(aProvider);",
         "  }",
         "",
-        "  public static Builder builder() {  ",
-        "    return new Builder();",
-        "  }",
-        "",
         "  @Override",
-        "  public B b() {  ",
+        "  public B b() {",
         "    return bProvider.get();",
         "  }",
         "",
         "  public static final class Builder {",
         "    private AComponent aComponent;",
-        "  ",
-        "    private Builder() {  ",
+        "",
+        "    private Builder() {",
         "    }",
-        "  ",
-        "    public BComponent build() {  ",
+        "",
+        "    public BComponent build() {",
         "      if (aComponent == null) {",
         "        throw new IllegalStateException(\"aComponent must be set\");",
         "      }",
         "      return new Dagger_BComponent(this);",
         "    }",
-        "  ",
-        "    public Builder aComponent(AComponent aComponent) {  ",
+        "",
+        "    public Builder aComponent(AComponent aComponent) {",
         "      if (aComponent == null) {",
         "        throw new NullPointerException(\"aComponent\");",
         "      }",
@@ -1072,15 +1115,14 @@
         "public final class Dagger_TestComponent implements TestComponent {",
         "  private final test.TestModule testModule;",
         "  private final TestModule testModule1;",
-        "  private final Provider<test.A> aProvider;",
-        "  private final Provider<A> aProvider1;",
+        "  private Provider<test.A> aProvider;",
+        "  private Provider<A> aProvider1;",
         "",
         "  private Dagger_TestComponent(Builder builder) {",
         "    assert builder != null;",
         "    this.testModule = builder.testModule;",
         "    this.testModule1 = builder.testModule1;",
-        "    this.aProvider = new test.TestModule$$AFactory(testModule);",
-        "    this.aProvider1 = new TestModule$$AFactory(testModule1);",
+        "    initialize();",
         "  }",
         "",
         "  public static Builder builder() {",
@@ -1091,11 +1133,18 @@
         "    return builder().build();",
         "  }",
         "",
-        "  @Override public test.A a() {",
+        "  private void initialize() {",
+        "    this.aProvider = new test.TestModule$$AFactory(testModule);",
+        "    this.aProvider1 = new TestModule$$AFactory(testModule1);",
+        "  }",
+        "",
+        "  @Override",
+        "  public test.A a() {",
         "    return aProvider.get();",
         "  }",
         "",
-        "  @Override public A otherA() {",
+        "  @Override",
+        "  public A otherA() {",
         "    return aProvider1.get();",
         "  }",
         "",
@@ -1103,7 +1152,8 @@
         "    private test.TestModule testModule;",
         "    private TestModule testModule1;",
         "",
-        "    private Builder() {}",
+        "    private Builder() {",
+        "    }",
         "",
         "    public TestComponent build() {",
         "      if (testModule == null) {",
@@ -1195,17 +1245,14 @@
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class Dagger_TestComponent implements TestComponent {",
-        "  private final Provider<A> aProvider;",
-        "  private final Provider<B> bProvider;",
-        "  private final Provider<C> cProvider;",
-        "  private final Provider<X> xProvider;",
+        "  private Provider<C> cProvider;",
+        "  private Provider<B> bProvider;",
+        "  private Provider<A> aProvider;",
+        "  private Provider<X> xProvider;",
         "",
         "  private Dagger_TestComponent(Builder builder) {",
         "    assert builder != null;",
-        "    this.cProvider = new C$$Factory();",
-        "    this.bProvider = new B$$Factory(cProvider);",
-        "    this.aProvider = new A$$Factory(bProvider);",
-        "    this.xProvider = new X$$Factory(cProvider);",
+        "    initialize();",
         "  }",
         "",
         "  public static Builder builder() {",
@@ -1216,20 +1263,31 @@
         "    return builder().build();",
         "  }",
         "",
-        "  @Override public A a() {",
+        "  private void initialize() {",
+        "    this.cProvider = new C$$Factory();",
+        "    this.bProvider = new B$$Factory(cProvider);",
+        "    this.aProvider = new A$$Factory(bProvider);",
+        "    this.xProvider = new X$$Factory(cProvider);",
+        "  }",
+        "",
+        "  @Override",
+        "  public A a() {",
         "    return aProvider.get();",
         "  }",
         "",
-        "  @Override public C c() {",
+        "  @Override",
+        "  public C c() {",
         "    return cProvider.get();",
         "  }",
         "",
-        "  @Override public X x() {",
+        "  @Override",
+        "  public X x() {",
         "    return xProvider.get();",
         "  }",
         "",
         "  public static final class Builder {",
-        "    private Builder() {}",
+        "    private Builder() {",
+        "    }",
         "",
         "    public TestComponent build() {",
         "      return new Dagger_TestComponent(this);",
@@ -1242,4 +1300,190 @@
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
   }
+
+  @Test public void simpleComponent_redundantComponentMethod() {
+    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class SomeInjectableType {",
+        "  @Inject SomeInjectableType() {}",
+        "}");
+    JavaFileObject componentSupertypeAFile = JavaFileObjects.forSourceLines("test.SupertypeA",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SupertypeA {",
+        "  SomeInjectableType someInjectableType();",
+        "}");
+    JavaFileObject componentSupertypeBFile = JavaFileObjects.forSourceLines("test.SupertypeB",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SupertypeB {",
+        "  SomeInjectableType someInjectableType();",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SimpleComponent extends SupertypeA, SupertypeB {",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.Dagger_SimpleComponent",
+        "package test;",
+        "",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_SimpleComponent implements SimpleComponent {",
+        "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
+        "",
+        "  private Dagger_SimpleComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize();",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static SimpleComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize() {",
+        "    this.someInjectableTypeProvider = new SomeInjectableType$$Factory();",
+        "  }",
+        "",
+        "  @Override",
+        "  public SomeInjectableType someInjectableType() {",
+        "    return someInjectableTypeProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public SimpleComponent build() {",
+        "      return new Dagger_SimpleComponent(this);",
+        "    }",
+        "  }",
+        "}");
+    assert_().about(javaSources()).that(ImmutableList.of(
+            injectableTypeFile, componentSupertypeAFile, componentSupertypeBFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+
+  @Test public void simpleComponent_inheritedComponentMethodDep() {
+    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class SomeInjectableType {",
+        "  @Inject SomeInjectableType() {}",
+        "}");
+    JavaFileObject componentSupertype = JavaFileObjects.forSourceLines("test.Supertype",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface Supertype {",
+        "  SomeInjectableType someInjectableType();",
+        "}");
+    JavaFileObject depComponentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SimpleComponent extends Supertype {",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ComponentWithDep",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(dependencies = SimpleComponent.class)",
+        "interface ComponentWithDep {",
+        "  SomeInjectableType someInjectableType();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.Dagger_SimpleComponent",
+        "package test;",
+        "",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_SimpleComponent implements SimpleComponent {",
+        "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
+        "",
+        "  private Dagger_SimpleComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize();",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static SimpleComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize() {",
+        "    this.someInjectableTypeProvider = new SomeInjectableType$$Factory();",
+        "  }",
+        "",
+        "  @Override",
+        "  public SomeInjectableType someInjectableType() {",
+        "    return someInjectableTypeProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public SimpleComponent build() {",
+        "      return new Dagger_SimpleComponent(this);",
+        "    }",
+        "  }",
+        "}");
+    assert_().about(javaSources()).that(ImmutableList.of(
+            injectableTypeFile, componentSupertype, depComponentFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ElementUtilTest.java b/compiler/src/test/java/dagger/internal/codegen/ElementUtilTest.java
index 16a91fec1..2f638f21c 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ElementUtilTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ElementUtilTest.java
@@ -26,8 +26,8 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+import static com.google.common.truth.Truth.assert_;
 import static org.junit.Assert.fail;
-import static org.truth0.Truth.ASSERT;
 
 @RunWith(JUnit4.class)
 public class ElementUtilTest {
@@ -36,7 +36,7 @@
   @Test public void asTypeElement() {
     Element typeElement =
         compilation.getElements().getTypeElement(String.class.getCanonicalName());
-    ASSERT.that(MoreElements.asType(typeElement)).is(typeElement);
+    assert_().that(MoreElements.asType(typeElement)).isEqualTo(typeElement);
   }
 
   @Test public void asTypeElement_notATypeElement() {
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
new file mode 100644
index 000000000..71ddde94b
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -0,0 +1,399 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.testing.compile.JavaFileObjects;
+import java.util.Arrays;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assert_;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+
+@RunWith(JUnit4.class)
+public class GraphValidationTest {
+  @Test public void componentOnConcreteClass() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.MyComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface MyComponent {",
+        "  Foo getFoo();",
+        "}");
+    JavaFileObject injectable = JavaFileObjects.forSourceLines("test.Foo",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class Foo {",
+        "  @Inject Foo(Bar bar) {}",
+        "}");
+    JavaFileObject nonInjectable = JavaFileObjects.forSourceLines("test.Bar",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "interface Bar {}");
+    assert_().about(javaSources()).that(Arrays.asList(component, injectable, nonInjectable))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("test.Bar cannot be provided without an @Provides-annotated method.")
+            .in(component).onLine(7);
+  }
+
+  @Test public void componentProvisionWithNoDependencyChain() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "final class TestClass {",
+        "  interface A {}",
+        "",
+        "  @Component()",
+        "  interface AComponent {",
+        "    A getA();",
+        "  }",
+        "}");
+    String expectedError =
+        "test.TestClass.A cannot be provided without an @Provides-annotated method.";
+    assert_().about(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError).in(component).onLine(10);
+  }
+
+  @Test public void constructorInjectionWithoutAnnotation() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "final class TestClass {",
+        "  static class A {",
+        "    A() {}",
+        "  }",
+        "",
+        "  @Component()",
+        "  interface AComponent {",
+        "    A getA();",
+        "  }",
+        "}");
+    String expectedError = "test.TestClass.A cannot be provided without an "
+        + "@Inject constructor or from an @Provides-annotated method.";
+    assert_().about(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError).in(component).onLine(15);
+  }
+
+  @Test public void membersInjectWithoutProvision() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "final class TestClass {",
+        "  static class A {",
+        "    @Inject A() {}",
+        "  }",
+        "",
+        "  static class B {",
+        "    @Inject A a;",
+        "  }",
+        "",
+        "  @Component()",
+        "  interface AComponent {",
+        "    B getB();",
+        "  }",
+        "}");
+    String expectedError = "test.TestClass.B cannot be provided without an "
+        + "@Inject constructor or from an @Provides-annotated method. "
+        + "This type supports members injection but cannot be implicitly provided.";
+    assert_().about(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError).in(component).onLine(19);
+  }
+
+  @Test public void cyclicDependency() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "final class Outer {",
+        "  static class A {",
+        "    @Inject A(C cParam) {}",
+        "  }",
+        "",
+        "  static class B {",
+        "    @Inject B(A aParam) {}",
+        "  }",
+        "",
+        "  static class C {",
+        "    @Inject C(B bParam) {}",
+        "  }",
+        "",
+        "  @Component()",
+        "  interface CComponent {",
+        "    C getC();",
+        "  }",
+        "}");
+
+    String expectedError = "test.Outer.CComponent.getC() contains a dependency cycle:\n"
+        + "      test.Outer.C.<init>(test.Outer.B bParam)\n"
+        + "          [parameter: test.Outer.B bParam]\n"
+        + "      test.Outer.B.<init>(test.Outer.A aParam)\n"
+        + "          [parameter: test.Outer.A aParam]\n"
+        + "      test.Outer.A.<init>(test.Outer.C cParam)\n"
+        + "          [parameter: test.Outer.C cParam]";
+
+    assert_().about(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError).in(component).onLine(23);
+  }
+
+  @Test public void duplicateExplicitBindings_ProvidesAndComponentProvision() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "final class Outer {",
+        "  interface A {}",
+        "",
+        "  interface B {}",
+        "",
+        "  @Module",
+        "  static class AModule {",
+        "    @Provides String provideString() { return \"\"; }",
+        "    @Provides A provideA(String s) { return new A() {}; }",
+        "  }",
+        "",
+        "  @Component(modules = AModule.class)",
+        "  interface Parent {",
+        "    A getA();",
+        "  }",
+        "",
+        "  @Module",
+        "  static class BModule {",
+        "    @Provides B provideB(A a) { return new B() {}; }",
+        "  }",
+        "",
+        "  @Component(dependencies = Parent.class, modules = { BModule.class, AModule.class})",
+        "  interface Child {",
+        "    B getB();",
+        "  }",
+        "}");
+
+    String expectedError = "test.Outer.A is bound multiple times:\n"
+        + "      test.Outer.Parent.getA()\n"
+        + "      test.Outer.AModule.provideA(java.lang.String)";
+
+    assert_().about(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError).in(component).onLine(30);
+  }
+
+  @Test public void duplicateExplicitBindings_TwoProvidesMethods() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "final class Outer {",
+        "  interface A {}",
+        "",
+        "  @Module",
+        "  static class Module1 {",
+        "    @Provides A provideA1() { return new A() {}; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class Module2 {",
+        "    @Provides String provideString() { return \"\"; }",
+        "    @Provides A provideA2(String s) { return new A() {}; }",
+        "  }",
+        "",
+        "  @Component(modules = { Module1.class, Module2.class})",
+        "  interface TestComponent {",
+        "    A getA();",
+        "  }",
+        "}");
+
+    String expectedError = "test.Outer.A is bound multiple times:\n"
+        + "      test.Outer.Module1.provideA1()\n"
+        + "      test.Outer.Module2.provideA2(java.lang.String)";
+
+    assert_().about(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError).in(component).onLine(24);
+  }
+
+  @Test public void duplicateExplicitBindings_MultipleProvisionTypes() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.MapKey;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import dagger.MapKey;",
+        "import java.util.HashMap;",
+        "import java.util.HashSet;",
+        "import java.util.Map;",
+        "import java.util.Set;",
+        "",
+        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+        "import static dagger.Provides.Type.MAP;",
+        "import static dagger.Provides.Type.SET;",
+        "",
+        "final class Outer {",
+        "  @MapKey(unwrapValue = true)",
+        "  @interface StringKey {",
+        "    String value();",
+        "  }",
+        "",
+        "  @Module",
+        "  static class TestModule1 {",
+        "    @Provides(type = MAP)",
+        "    @StringKey(\"foo\")",
+        "    String provideStringMapEntry() { return \"\"; }",
+        "",
+        "    @Provides(type = SET) String provideStringSetElement() { return \"\"; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class TestModule2 {",
+        "    @Provides Set<String> provideStringSet() { return new HashSet<String>(); }",
+        "",
+        "    @Provides Map<String, String> provideStringMap() {",
+        "      return new HashMap<String, String>();",
+        "    }",
+        "  }",
+        "",
+        "  @Component(modules = { TestModule1.class, TestModule2.class })",
+        "  interface TestComponent {",
+        "    Set<String> getStringSet();",
+        "    Map<String, String> getStringMap();",
+        "  }",
+        "}");
+
+    String expectedSetError =
+        "java.util.Set<java.lang.String> has incompatible bindings:\n"
+            + "      Set bindings:\n"
+            + "          test.Outer.TestModule1.provideStringSetElement()\n"
+            + "      Unique bindings:\n"
+            + "          test.Outer.TestModule2.provideStringSet()";
+
+    String expectedMapError =
+        "java.util.Map<java.lang.String,java.lang.String> has incompatible bindings:\n"
+            + "      Map bindings:\n"
+            + "          test.Outer.TestModule1.provideStringMapEntry()\n"
+            + "      Unique bindings:\n"
+            + "          test.Outer.TestModule2.provideStringMap()";
+
+    assert_().about(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedSetError).in(component).onLine(43)
+        .and().withErrorContaining(expectedMapError).in(component).onLine(44);
+  }
+
+  @Test public void longChainOfDependencies() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "final class TestClass {",
+        "  interface A {}",
+        "",
+        "  static class B {",
+        "    @Inject B(A a) {}",
+        "  }",
+        "",
+        "  static class C {",
+        "    @Inject B b;",
+        "    @Inject C(B b) {}",
+        "  }",
+        "",
+        "  interface D { }",
+        "",
+        "  static class DImpl implements D {",
+        "    @Inject DImpl(C c, B b) {}",
+        "  }",
+        "",
+        "  @Module",
+        "  static class DModule {",
+        "    @Provides D d(DImpl impl) { return impl; }",
+        "  }",
+        "",
+        "  @Component(modules = { DModule.class })",
+        "  interface AComponent {",
+        "    D getFoo();",
+        "    C injectC(C c);",
+        "  }",
+        "}");
+    String errorText =
+        "test.TestClass.A cannot be provided without an @Provides-annotated method.\n";
+    String firstError = errorText
+        + "      test.TestClass.DModule.d(test.TestClass.DImpl impl)\n"
+        + "          [parameter: test.TestClass.DImpl impl]\n"
+        + "      test.TestClass.DImpl.<init>(test.TestClass.C c, test.TestClass.B b)\n"
+        + "          [parameter: test.TestClass.C c]\n"
+        + "      test.TestClass.C.<init>(test.TestClass.B b)\n"
+        + "          [parameter: test.TestClass.B b]\n"
+        + "      test.TestClass.B.<init>(test.TestClass.A a)\n"
+        + "          [parameter: test.TestClass.A a]";
+    String secondError = errorText
+        + "      test.TestClass.C.b()\n"
+        + "          [injected field of type: test.TestClass.B b]\n"
+        + "      test.TestClass.B.<init>(test.TestClass.A a)\n"
+        + "          [parameter: test.TestClass.A a]";
+    assert_().about(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(firstError).in(component).onLine(33)
+        .and().withErrorContaining(secondError).in(component).onLine(34);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
similarity index 99%
rename from compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java
rename to compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
index ca8f7ec87..29675bb16 100644
--- a/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
@@ -40,7 +40,7 @@
 
 @RunWith(JUnit4.class)
 // TODO(gak): add tests for generation in the default package.
-public final class InjectProcessorTest {
+public final class InjectConstructorFactoryGeneratorTest {
   private static final JavaFileObject QUALIFIER_A =
       JavaFileObjects.forSourceLines("test.QualifierA",
           "package test;",
diff --git a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
index 1f3dda556..62ba6f402 100644
--- a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
@@ -16,12 +16,13 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.MoreTypes;
+import com.google.common.base.Equivalence;
 import com.google.common.base.Optional;
 import com.google.common.collect.Iterables;
 import com.google.testing.compile.CompilationRule;
 import dagger.Module;
 import dagger.Provides;
-import java.util.List;
+import dagger.internal.codegen.Key.Kind;
 import java.util.Set;
 import javax.inject.Inject;
 import javax.inject.Qualifier;
@@ -29,7 +30,6 @@
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
@@ -40,7 +40,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.ASSERT;
+import static com.google.common.truth.Truth.assert_;
 import static dagger.Provides.Type.SET;
 import static dagger.Provides.Type.SET_VALUES;
 
@@ -66,8 +66,10 @@
         compilationRule.getElements().getTypeElement(InjectedClass.class.getCanonicalName());
     ExecutableElement constructor =
         Iterables.getOnlyElement(ElementFilter.constructorsIn(typeElement.getEnclosedElements()));
-    ASSERT.that(keyFactory.forInjectConstructor(constructor))
-        .isEqualTo(keyFactory.forType(typeElement.asType()));
+    assert_().that(keyFactory.forInjectConstructor(constructor))
+        .isEqualTo(new AutoValue_Key(Kind.PROVIDER,
+            Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
+            MoreTypes.equivalence().wrap(typeElement.asType())));
   }
 
   static final class InjectedClass {
@@ -81,8 +83,10 @@
         elements.getTypeElement(ProvidesMethodModule.class.getCanonicalName());
     ExecutableElement providesMethod =
         Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
-    ASSERT.that(keyFactory.forProvidesMethod(providesMethod))
-        .isEqualTo(keyFactory.forType(stringType));
+    assert_().that(keyFactory.forProvidesMethod(providesMethod))
+        .isEqualTo(new AutoValue_Key(Kind.PROVIDER,
+            Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
+            MoreTypes.equivalence().wrap(stringType)));
   }
 
   @Module(library = true)
@@ -101,9 +105,9 @@
     ExecutableElement providesMethod =
         Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
     Key key = keyFactory.forProvidesMethod(providesMethod);
-    ASSERT.that(MoreTypes.equivalence().wrap(key.qualifier().get().getAnnotationType()))
+    assert_().that(MoreTypes.equivalence().wrap(key.qualifier().get().getAnnotationType()))
         .isEqualTo(MoreTypes.equivalence().wrap(qualifierElement.asType()));
-    ASSERT.that(key.wrappedType()).isEqualTo(MoreTypes.equivalence().wrap(stringType));
+    assert_().that(key.wrappedType()).isEqualTo(MoreTypes.equivalence().wrap(stringType));
   }
 
   @Test public void qualifiedKeyEquivalents() {
@@ -121,7 +125,7 @@
     AnnotationMirror qualifier = Iterables.getOnlyElement(injectionField.getAnnotationMirrors());
     Key injectionKey = keyFactory.forQualifiedType(Optional.<AnnotationMirror>of(qualifier), type);
 
-    ASSERT.that(provisionKey).isEqualTo(injectionKey);
+    assert_().that(provisionKey).isEqualTo(injectionKey);
   }
 
   @Module(library = true)
@@ -147,13 +151,15 @@ String provideQualifiedString() {
   @Test public void forProvidesMethod_sets() {
     TypeElement setElement = elements.getTypeElement(Set.class.getCanonicalName());
     TypeMirror stringType = elements.getTypeElement(String.class.getCanonicalName()).asType();
-    DeclaredType setOfStringsType = types.getDeclaredType(setElement, stringType);
+    TypeMirror setOfStringsType = types.getDeclaredType(setElement, stringType);
     TypeElement moduleElement =
         elements.getTypeElement(SetProvidesMethodsModule.class.getCanonicalName());
     for (ExecutableElement providesMethod
         : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {
-      ASSERT.that(keyFactory.forProvidesMethod(providesMethod))
-          .isEqualTo(keyFactory.forType(setOfStringsType));
+      assert_().that(keyFactory.forProvidesMethod(providesMethod))
+          .isEqualTo(new AutoValue_Key(Kind.PROVIDER,
+              Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
+              MoreTypes.equivalence().wrap(setOfStringsType)));
     }
   }
 
@@ -168,24 +174,38 @@ String provideQualifiedString() {
     }
   }
 
-  interface PrimitiveTypes {
-    int foo();
-    Integer bar();
+  @Module(library = true)
+  static final class PrimitiveTypes {
+    @Provides int foo() {
+      return 0;
+    }
+  }
+
+  @Module(library = true)
+  static final class BoxedPrimitiveTypes {
+    @Provides Integer foo() {
+      return 0;
+    }
   }
 
   @Test public void primitiveKeysMatchBoxedKeys() {
-    TypeElement holder = elements.getTypeElement(PrimitiveTypes.class.getCanonicalName());
-    List<ExecutableElement> methods = (List<ExecutableElement>) holder.getEnclosedElements();
-
-    // TODO(cgruber): Truth subject for TypeMirror and TypeElement
-    TypeMirror intType = methods.get(0).getReturnType();
-    ASSERT.that(intType.getKind().isPrimitive()).isTrue();
-    TypeMirror integerType = methods.get(1).getReturnType();
-    ASSERT.that(integerType.getKind().isPrimitive()).isFalse();
-    ASSERT.that(types.isSameType(intType, integerType)).named("type equality").isFalse();
-
-    Key intKey = keyFactory.forType(intType);
-    Key integerKey = keyFactory.forType(integerType);
-    ASSERT.that(intKey).isEqualTo(integerKey);
+    TypeElement primitiveHolder = elements.getTypeElement(PrimitiveTypes.class.getCanonicalName());
+    ExecutableElement intMethod =
+        Iterables.getOnlyElement(ElementFilter.methodsIn(primitiveHolder.getEnclosedElements()));
+    TypeElement boxedPrimitiveHolder =
+        elements.getTypeElement(BoxedPrimitiveTypes.class.getCanonicalName());
+    ExecutableElement integerMethod = Iterables.getOnlyElement(
+        ElementFilter.methodsIn(boxedPrimitiveHolder.getEnclosedElements()));
+
+    // TODO(user): Truth subject for TypeMirror and TypeElement
+    TypeMirror intType = intMethod.getReturnType();
+    assert_().that(intType.getKind().isPrimitive()).isTrue();
+    TypeMirror integerType = integerMethod.getReturnType();
+    assert_().that(integerType.getKind().isPrimitive()).isFalse();
+    assert_().that(types.isSameType(intType, integerType)).named("type equality").isFalse();
+
+    Key intKey = keyFactory.forProvidesMethod(intMethod);
+    Key integerKey = keyFactory.forProvidesMethod(integerMethod);
+    assert_().that(intKey).isEqualTo(integerKey);
   }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
new file mode 100644
index 000000000..ea13e5202
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -0,0 +1,630 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assert_;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+
+@RunWith(JUnit4.class)
+public class MapBindingComponentProcessorTest {
+
+  @Test
+  public void mapBindingsWithEnumKey() {
+    JavaFileObject mapModuleOneFile =
+        JavaFileObjects
+            .forSourceLines("test.MapModuleOne",
+                "package test;",
+                "",
+                "import static dagger.Provides.Type.MAP;",
+                "",
+                "import dagger.Module;",
+                "import dagger.Provides;",
+                "",
+                "@Module",
+                "final class MapModuleOne {",
+                "  @Provides(type = MAP) @PathKey(PathEnum.ADMIN) Handler provideAdminHandler() {",
+                "    return new AdminHandler();",
+                "  }",
+                "}");
+    JavaFileObject mapModuleTwoFile =
+        JavaFileObjects
+            .forSourceLines("test.MapModuleTwo",
+                "package test;",
+                "",
+                "import static dagger.Provides.Type.MAP;",
+                "",
+                "import dagger.Module;",
+                "import dagger.Provides;",
+                "",
+                "@Module",
+                "final class MapModuleTwo {",
+                "  @Provides(type = MAP) @PathKey(PathEnum.LOGIN) Handler provideLoginHandler() {",
+                "    return new LoginHandler();",
+                "  }",
+                "}");
+    JavaFileObject enumKeyFile = JavaFileObjects.forSourceLines("test.PathKey",
+        "package test;",
+        "import dagger.MapKey;",
+        "import java.lang.annotation.Retention;",
+        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+        "",
+        "@MapKey(unwrapValue = true)",
+        "@Retention(RUNTIME)",
+        "public @interface PathKey {",
+        "  PathEnum value();",
+        "}");
+    JavaFileObject pathEnumFile = JavaFileObjects.forSourceLines("test.PathEnum",
+        "package test;",
+        "",
+        "public enum PathEnum {",
+        "    ADMIN,",
+        "    LOGIN;",
+        "}");
+
+    JavaFileObject HandlerFile = JavaFileObjects.forSourceLines("test.Handler",
+        "package test;",
+        "",
+        "interface Handler {}");
+    JavaFileObject LoginHandlerFile = JavaFileObjects.forSourceLines("test.LoginHandler",
+        "package test;",
+        "",
+        "class LoginHandler implements Handler {",
+        "  public LoginHandler() {}",
+        "}");
+    JavaFileObject AdminHandlerFile = JavaFileObjects.forSourceLines("test.AdminHandler",
+        "package test;",
+        "",
+        "class AdminHandler implements Handler {",
+        "  public AdminHandler() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.Map;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
+        "interface TestComponent {",
+        "  Map<PathEnum, Provider<Handler>> dispatcher();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.Dagger_TestComponent",
+        "package test;",
+        "",
+        "import dagger.internal.MapProviderFactory;",
+        "import java.util.Map;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_TestComponent implements TestComponent {",
+        "  private final MapModuleOne mapModuleOne;",
+        "  private final MapModuleTwo mapModuleTwo;",
+        "  private Provider<Map<PathEnum, Provider<Handler>>>",
+        "      mapOfPathEnumAndProviderOfHandlerProvider;",
+        "",
+        "  private Dagger_TestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    this.mapModuleOne = builder.mapModuleOne;",
+        "    this.mapModuleTwo = builder.mapModuleTwo;",
+        "    initialize();",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize() {",
+        "    this.mapOfPathEnumAndProviderOfHandlerProvider =",
+        "        MapProviderFactory.<PathEnum, Handler>builder(2)",
+        "            .put(test.PathEnum.ADMIN,",
+        "                new MapModuleOne$$ProvideAdminHandlerFactory(mapModuleOne))",
+        "            .put(test.PathEnum.LOGIN,",
+        "                new MapModuleTwo$$ProvideLoginHandlerFactory(mapModuleTwo))",
+        "            .build();",
+        "  }",
+        "",
+        "  @Override",
+        "  public Map<PathEnum, Provider<Handler>> dispatcher() {",
+        "    return mapOfPathEnumAndProviderOfHandlerProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private MapModuleOne mapModuleOne;",
+        "    private MapModuleTwo mapModuleTwo;",
+        "",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public TestComponent build() {",
+        "      if (mapModuleOne == null) {",
+        "        this.mapModuleOne = new MapModuleOne();",
+        "      }",
+        "      if (mapModuleTwo == null) {",
+        "        this.mapModuleTwo = new MapModuleTwo();",
+        "      }",
+        "      return new Dagger_TestComponent(this);",
+        "    }",
+        "",
+        "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+        "      if (mapModuleOne == null) {",
+        "        throw new NullPointerException(\"mapModuleOne\");",
+        "      }",
+        "      this.mapModuleOne = mapModuleOne;",
+        "      return this;",
+        "    }",
+        "",
+        "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+        "      if (mapModuleTwo == null) {",
+        "        throw new NullPointerException(\"mapModuleTwo\");",
+        "      }",
+        "      this.mapModuleTwo = mapModuleTwo;",
+        "      return this;",
+        "    }",
+        "  }",
+        "}");
+    assert_().about(javaSources())
+        .that(ImmutableList.of(mapModuleOneFile,
+            mapModuleTwoFile,
+            enumKeyFile,
+            pathEnumFile,
+            HandlerFile,
+            LoginHandlerFile,
+            AdminHandlerFile,
+            componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedComponent);
+  }
+
+  @Test
+  public void mapBindingsWithStringKey() {
+    JavaFileObject mapModuleOneFile =
+        JavaFileObjects
+            .forSourceLines("test.MapModuleOne",
+                "package test;",
+                "",
+                "import static dagger.Provides.Type.MAP;",
+                "",
+                "import dagger.Module;",
+                "import dagger.Provides;",
+                "",
+                "@Module",
+                "final class MapModuleOne {",
+                "  @Provides(type = MAP) @StringKey(\"Admin\") Handler provideAdminHandler() {",
+                "    return new AdminHandler();",
+                "  }",
+                "}");
+    JavaFileObject mapModuleTwoFile =
+        JavaFileObjects
+            .forSourceLines("test.MapModuleTwo",
+                "package test;",
+                "",
+                "import static dagger.Provides.Type.MAP;",
+                "",
+                "import dagger.Module;",
+                "import dagger.Provides;",
+                "",
+                "@Module",
+                "final class MapModuleTwo {",
+                "  @Provides(type = MAP) @StringKey(\"Login\") Handler provideLoginHandler() {",
+                "    return new LoginHandler();",
+                "  }",
+                "}");
+    JavaFileObject stringKeyFile = JavaFileObjects.forSourceLines("test.StringKey",
+        "package test;",
+        "import dagger.MapKey;",
+        "import java.lang.annotation.Retention;",
+        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+        "",
+        "@MapKey(unwrapValue = true)",
+        "@Retention(RUNTIME)",
+        "public @interface StringKey {",
+        "  String value();",
+        "}");
+    JavaFileObject HandlerFile = JavaFileObjects.forSourceLines("test.Handler",
+        "package test;",
+        "",
+        "interface Handler {}");
+    JavaFileObject LoginHandlerFile = JavaFileObjects.forSourceLines("test.LoginHandler",
+        "package test;",
+        "",
+        "class LoginHandler implements Handler {",
+        "  public LoginHandler() {}",
+        "}");
+    JavaFileObject AdminHandlerFile = JavaFileObjects.forSourceLines("test.AdminHandler",
+        "package test;",
+        "",
+        "class AdminHandler implements Handler {",
+        "  public AdminHandler() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.Map;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
+        "interface TestComponent {",
+        "  Map<String, Provider<Handler>> dispatcher();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.Dagger_TestComponent",
+        "package test;",
+        "",
+        "import dagger.internal.MapProviderFactory;",
+        "import java.util.Map;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_TestComponent implements TestComponent {",
+        "  private final MapModuleOne mapModuleOne;",
+        "  private final MapModuleTwo mapModuleTwo;",
+        "  private Provider<Map<String, Provider<Handler>>> mapOfStringAndProviderOfHandlerProvider;",
+        "",
+        "  private Dagger_TestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    this.mapModuleOne = builder.mapModuleOne;",
+        "    this.mapModuleTwo = builder.mapModuleTwo;",
+        "    initialize();",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize() {",
+        "    this.mapOfStringAndProviderOfHandlerProvider =",
+        "        MapProviderFactory.<String, Handler>builder(2)",
+        "            .put(\"Admin\", new MapModuleOne$$ProvideAdminHandlerFactory(mapModuleOne))",
+        "            .put(\"Login\", new MapModuleTwo$$ProvideLoginHandlerFactory(mapModuleTwo))",
+        "            .build();",
+        "  }",
+        "",
+        "  @Override",
+        "  public Map<String, Provider<Handler>> dispatcher() {",
+        "    return mapOfStringAndProviderOfHandlerProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private MapModuleOne mapModuleOne;",
+        "    private MapModuleTwo mapModuleTwo;",
+        "",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public TestComponent build() {",
+        "      if (mapModuleOne == null) {",
+        "        this.mapModuleOne = new MapModuleOne();",
+        "      }",
+        "      if (mapModuleTwo == null) {",
+        "        this.mapModuleTwo = new MapModuleTwo();",
+        "      }",
+        "      return new Dagger_TestComponent(this);",
+        "    }",
+        "",
+        "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+        "      if (mapModuleOne == null) {",
+        "        throw new NullPointerException(\"mapModuleOne\");",
+        "      }",
+        "      this.mapModuleOne = mapModuleOne;",
+        "      return this;",
+        "    }",
+        "",
+        "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+        "      if (mapModuleTwo == null) {",
+        "        throw new NullPointerException(\"mapModuleTwo\");",
+        "      }",
+        "      this.mapModuleTwo = mapModuleTwo;",
+        "      return this;",
+        "    }",
+        "  }",
+        "}");
+    assert_().about(javaSources())
+        .that(ImmutableList.of(mapModuleOneFile,
+            mapModuleTwoFile,
+            stringKeyFile,
+            HandlerFile,
+            LoginHandlerFile,
+            AdminHandlerFile,
+            componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedComponent);
+  }
+
+  @Test
+  public void mapBindingsWithNonProviderValue() {
+    JavaFileObject mapModuleOneFile = JavaFileObjects.forSourceLines("test.MapModuleOne",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.MAP;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class MapModuleOne {",
+        "  @Provides(type = MAP) @PathKey(PathEnum.ADMIN) Handler provideAdminHandler() {",
+        "    return new AdminHandler();",
+        "  }",
+        "}");
+    JavaFileObject mapModuleTwoFile = JavaFileObjects.forSourceLines("test.MapModuleTwo",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.MAP;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class MapModuleTwo {",
+        "  @Provides(type = MAP) @PathKey(PathEnum.LOGIN) Handler provideLoginHandler() {",
+        "    return new LoginHandler();",
+        "  }",
+        "}");
+    JavaFileObject enumKeyFile = JavaFileObjects.forSourceLines("test.PathKey",
+        "package test;",
+        "import dagger.MapKey;",
+        "import java.lang.annotation.Retention;",
+        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+        "",
+        "@MapKey(unwrapValue = true)",
+        "@Retention(RUNTIME)",
+        "public @interface PathKey {",
+        "  PathEnum value();",
+        "}");
+    JavaFileObject pathEnumFile = JavaFileObjects.forSourceLines("test.PathEnum",
+        "package test;",
+        "",
+        "public enum PathEnum {",
+        "    ADMIN,",
+        "    LOGIN;",
+        "}");
+    JavaFileObject HandlerFile = JavaFileObjects.forSourceLines("test.Handler",
+        "package test;",
+        "",
+        "interface Handler {}");
+    JavaFileObject LoginHandlerFile = JavaFileObjects.forSourceLines("test.LoginHandler",
+        "package test;",
+        "",
+        "class LoginHandler implements Handler {",
+        "  public LoginHandler() {}",
+        "}");
+    JavaFileObject AdminHandlerFile = JavaFileObjects.forSourceLines("test.AdminHandler",
+        "package test;",
+        "",
+        "class AdminHandler implements Handler {",
+        "  public AdminHandler() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.Map;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
+        "interface TestComponent {",
+        "  Map<PathEnum, Handler> dispatcher();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.Dagger_TestComponent",
+        "package test;",
+        "",
+        "import dagger.internal.MapFactory;",
+        "import dagger.internal.MapProviderFactory;",
+        "import java.util.Map;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_TestComponent implements TestComponent {",
+        "  private final MapModuleOne mapModuleOne;",
+        "  private final MapModuleTwo mapModuleTwo;",
+        "  private Provider<Map<PathEnum, Provider<Handler>>>",
+        "      mapOfPathEnumAndProviderOfHandlerProvider;",
+        "  private Provider<Map<PathEnum, Handler>> mapOfPathEnumAndHandlerProvider;",
+        "",
+        "  private Dagger_TestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    this.mapModuleOne = builder.mapModuleOne;",
+        "    this.mapModuleTwo = builder.mapModuleTwo;",
+        "    initialize();",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize() {",
+        "    this.mapOfPathEnumAndProviderOfHandlerProvider =",
+        "        MapProviderFactory.<PathEnum, Handler>builder(2)",
+        "            .put(test.PathEnum.ADMIN,",
+        "                new MapModuleOne$$ProvideAdminHandlerFactory(mapModuleOne))",
+        "            .put(test.PathEnum.LOGIN,",
+        "                new MapModuleTwo$$ProvideLoginHandlerFactory(mapModuleTwo))",
+        "            .build();",
+        "    this.mapOfPathEnumAndHandlerProvider =",
+        "        MapFactory.create(mapOfPathEnumAndProviderOfHandlerProvider);",
+        "  }",
+        "",
+        "  @Override",
+        "  public Map<PathEnum, Handler> dispatcher() {",
+        "    return mapOfPathEnumAndHandlerProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private MapModuleOne mapModuleOne;",
+        "    private MapModuleTwo mapModuleTwo;",
+        "",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public TestComponent build() {",
+        "      if (mapModuleOne == null) {",
+        "        this.mapModuleOne = new MapModuleOne();",
+        "      }",
+        "      if (mapModuleTwo == null) {",
+        "        this.mapModuleTwo = new MapModuleTwo();",
+        "      }",
+        "      return new Dagger_TestComponent(this);",
+        "    }",
+        "",
+        "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+        "      if (mapModuleOne == null) {",
+        "        throw new NullPointerException(\"mapModuleOne\");",
+        "      }",
+        "      this.mapModuleOne = mapModuleOne;",
+        "      return this;",
+        "    }",
+        "",
+        "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+        "      if (mapModuleTwo == null) {",
+        "        throw new NullPointerException(\"mapModuleTwo\");",
+        "      }",
+        "      this.mapModuleTwo = mapModuleTwo;",
+        "      return this;",
+        "    }",
+        "  }",
+        "}");
+    assert_().about(javaSources())
+        .that(ImmutableList.of(mapModuleOneFile,
+            mapModuleTwoFile,
+            enumKeyFile,
+            pathEnumFile,
+            HandlerFile,
+            LoginHandlerFile,
+            AdminHandlerFile,
+            componentFile)).
+        processedWith(new ComponentProcessor())
+            .compilesWithoutError()
+            .and().generatesSources(generatedComponent);
+  }
+
+  @Test
+  public void injectMapWithoutMapBinding() {
+    JavaFileObject mapModuleFile = JavaFileObjects.forSourceLines("test.MapModule",
+        "package test;",
+        "",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import java.util.HashMap;",
+        "import java.util.Map;",
+        "",
+        "@Module",
+        "final class MapModule {",
+        "  @Provides Map<String, String> provideAMap() {",
+        "    Map<String, String> map = new HashMap<String, String>();",
+        "    map.put(\"Hello\", \"World\");",
+        "    return map;",
+        "  }",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.Map;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = {MapModule.class})",
+        "interface TestComponent {",
+        "  Map<String, String> dispatcher();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.Dagger_TestComponent",
+        "package test;",
+        "",
+        "import java.util.Map;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_TestComponent implements TestComponent {",
+        "  private final MapModule mapModule;",
+        "  private Provider<Map<String, String>> provideAMapProvider;",
+        "",
+        "  private Dagger_TestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    this.mapModule = builder.mapModule;",
+        "    initialize();",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize() {",
+        "    this.provideAMapProvider = new MapModule$$ProvideAMapFactory(mapModule);",
+        "  }",
+        "",
+        "  @Override",
+        "  public Map<String, String> dispatcher() {",
+        "    return provideAMapProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private MapModule mapModule;",
+        "",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public TestComponent build() {",
+        "      if (mapModule == null) {",
+        "        this.mapModule = new MapModule();",
+        "      }",
+        "      return new Dagger_TestComponent(this);",
+        "    }",
+        "",
+        "    public Builder mapModule(MapModule mapModule) {",
+        "      if (mapModule == null) {",
+        "        throw new NullPointerException(\"mapModule\");",
+        "      }",
+        "      this.mapModule = mapModule;",
+        "      return this;",
+        "    }",
+        "  }",
+        "}");
+    assert_().about(javaSources()).that(ImmutableList.of(mapModuleFile,componentFile))
+        .processedWith(new ComponentProcessor()).compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
new file mode 100644
index 000000000..64749c9aa
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
@@ -0,0 +1,418 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.value.processor.AutoAnnotationProcessor;
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assert_;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+
+@RunWith(JUnit4.class)
+public class MapKeyProcessorTest {
+  @Test
+  public void mapKeyCreatorFile() {
+    JavaFileObject enumKeyFile = JavaFileObjects.forSourceLines("test.PathKey",
+        "package test;",
+        "import dagger.MapKey;",
+        "import java.lang.annotation.Retention;",
+        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+        "",
+        "@MapKey(unwrapValue = false)",
+        "@Retention(RUNTIME)",
+        "public @interface PathKey {",
+        "  PathEnum value();",
+        "  String relativePath() default \"Defaultpath\";",
+        "}");
+    JavaFileObject pathEnumFile = JavaFileObjects.forSourceLines("test.PathEnum",
+        "package test;",
+        "",
+        "public enum PathEnum {",
+        "    ADMIN,",
+        "    LOGIN;",
+        "}");
+    JavaFileObject generatedKeyCreator = JavaFileObjects.forSourceLines("test.PathKeyCreator",
+        "package test;",
+        "",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public class PathKeyCreator {",
+        "  @com.google.auto.value.AutoAnnotation",
+        "  public static PathKey create(PathEnum value, String relativePath) {",
+        "    return new AutoAnnotation_PathKeyCreator_create(value, relativePath);",
+        "  }",
+        "}");
+    assert_().about(javaSources())
+    .that(ImmutableList.of(
+        enumKeyFile,
+        pathEnumFile))
+    .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
+    .compilesWithoutError()
+    .and()
+    .generatesSources(generatedKeyCreator);
+  }
+
+  @Test
+  public void mapKeyComponentFileWithDisorderedKeyField() {
+    JavaFileObject mapModuleOneFile = JavaFileObjects.forSourceLines("test.MapModuleOne",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.MAP;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class MapModuleOne {",
+        "  @Provides(type = MAP) @PathKey(relativePath = \"AdminPath\", value = PathEnum.ADMIN)",
+        "      Handler provideAdminHandler() {",
+        "    return new AdminHandler();",
+        "  }",
+        "}");
+    JavaFileObject mapModuleTwoFile =JavaFileObjects.forSourceLines("test.MapModuleTwo",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.MAP;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class MapModuleTwo {",
+        "  @Provides(type = MAP) @PathKey(value = PathEnum.LOGIN, relativePath = \"LoginPath\")",
+        "      Handler provideLoginHandler() {",
+        "    return new LoginHandler();",
+        "  }",
+        "}");
+    JavaFileObject enumKeyFile = JavaFileObjects.forSourceLines("test.PathKey",
+        "package test;",
+        "import dagger.MapKey;",
+        "import java.lang.annotation.Retention;",
+        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+        "",
+        "@MapKey(unwrapValue = false)",
+        "@Retention(RUNTIME)",
+        "public @interface PathKey {",
+        "  PathEnum value();",
+        "  String relativePath() default \"DefaultPath\";",
+        "}");
+    JavaFileObject pathEnumFile = JavaFileObjects.forSourceLines("test.PathEnum",
+        "package test;",
+        "",
+        "public enum PathEnum {",
+        "    ADMIN,",
+        "    LOGIN;",
+        "}");
+    JavaFileObject handlerFile = JavaFileObjects.forSourceLines("test.Handler",
+        "package test;",
+        "",
+        "interface Handler {}");
+    JavaFileObject loginHandlerFile = JavaFileObjects.forSourceLines("test.LoginHandler",
+        "package test;",
+        "",
+        "class LoginHandler implements Handler {",
+        "  public LoginHandler() {}",
+        "}");
+    JavaFileObject adminHandlerFile = JavaFileObjects.forSourceLines("test.AdminHandler",
+        "package test;",
+        "",
+        "class AdminHandler implements Handler {",
+        "  public AdminHandler() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.Map;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
+        "interface TestComponent {",
+        "  Map<PathKey, Provider<Handler>> dispatcher();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.Dagger_TestComponent",
+        "package test;",
+        "",
+        "import dagger.internal.MapProviderFactory;",
+        "import java.util.Map;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_TestComponent implements TestComponent {",
+        "  private final MapModuleOne mapModuleOne;",
+        "  private final MapModuleTwo mapModuleTwo;",
+        "  private Provider<Map<PathKey, Provider<Handler>>>",
+        "      mapOfPathKeyAndProviderOfHandlerProvider;",
+        "",
+        "  private Dagger_TestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    this.mapModuleOne = builder.mapModuleOne;",
+        "    this.mapModuleTwo = builder.mapModuleTwo;",
+        "    initialize();",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize() {",
+        "    this.mapOfPathKeyAndProviderOfHandlerProvider =",
+        "        MapProviderFactory.<PathKey, Handler>builder(2)",
+        "            .put(PathKeyCreator.create(PathEnum.ADMIN, \"AdminPath\"),",
+        "                new MapModuleOne$$ProvideAdminHandlerFactory(mapModuleOne))",
+        "            .put(PathKeyCreator.create(PathEnum.LOGIN, \"LoginPath\"),",
+        "                new MapModuleTwo$$ProvideLoginHandlerFactory(mapModuleTwo))",
+        "            .build();",
+        "  }",
+        "",
+        "  @Override",
+        "  public Map<PathKey, Provider<Handler>> dispatcher() {",
+        "    return mapOfPathKeyAndProviderOfHandlerProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private MapModuleOne mapModuleOne;",
+        "    private MapModuleTwo mapModuleTwo;",
+        "",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public TestComponent build() {",
+        "      if (mapModuleOne == null) {",
+        "        this.mapModuleOne = new MapModuleOne();",
+        "      }",
+        "      if (mapModuleTwo == null) {",
+        "        this.mapModuleTwo = new MapModuleTwo();",
+        "      }",
+        "      return new Dagger_TestComponent(this);",
+        "    }",
+        "",
+        "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+        "      if (mapModuleOne == null) {",
+        "        throw new NullPointerException(\"mapModuleOne\");",
+        "      }",
+        "      this.mapModuleOne = mapModuleOne;",
+        "      return this;",
+        "    }",
+        "",
+        "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+        "      if (mapModuleTwo == null) {",
+        "        throw new NullPointerException(\"mapModuleTwo\");",
+        "      }",
+        "      this.mapModuleTwo = mapModuleTwo;",
+        "      return this;",
+        "    }",
+        "  }",
+        "}");
+    assert_().about(javaSources())
+        .that(ImmutableList.of(
+            mapModuleOneFile,
+            mapModuleTwoFile,
+            enumKeyFile,
+            pathEnumFile,
+            handlerFile,
+            loginHandlerFile,
+            adminHandlerFile,
+            componentFile))
+        .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedComponent);
+  }
+
+  @Test
+  public void mapKeyComponentFileWithDefaultField() {
+    JavaFileObject mapModuleOneFile = JavaFileObjects.forSourceLines("test.MapModuleOne",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.MAP;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class MapModuleOne {",
+        "  @Provides(type = MAP) @PathKey(value = PathEnum.ADMIN) Handler provideAdminHandler() {",
+        "    return new AdminHandler();",
+        "  }",
+        "}");
+    JavaFileObject mapModuleTwoFile =JavaFileObjects.forSourceLines("test.MapModuleTwo",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.MAP;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class MapModuleTwo {",
+        "  @Provides(type = MAP) @PathKey(value = PathEnum.LOGIN, relativePath = \"LoginPath\")",
+        "      Handler provideLoginHandler() {",
+        "    return new LoginHandler();",
+        "  }",
+        "}");
+    JavaFileObject enumKeyFile = JavaFileObjects.forSourceLines("test.PathKey",
+        "package test;",
+        "import dagger.MapKey;",
+        "import java.lang.annotation.Retention;",
+        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+        "",
+        "@MapKey(unwrapValue = false)",
+        "@Retention(RUNTIME)",
+        "public @interface PathKey {",
+        "  PathEnum value();",
+        "  String relativePath() default \"DefaultPath\";",
+        "}");
+    JavaFileObject pathEnumFile = JavaFileObjects.forSourceLines("test.PathEnum",
+        "package test;",
+        "",
+        "public enum PathEnum {",
+        "    ADMIN,",
+        "    LOGIN;",
+        "}");
+    JavaFileObject handlerFile = JavaFileObjects.forSourceLines("test.Handler",
+        "package test;",
+        "",
+        "interface Handler {}");
+    JavaFileObject loginHandlerFile = JavaFileObjects.forSourceLines("test.LoginHandler",
+        "package test;",
+        "",
+        "class LoginHandler implements Handler {",
+        "  public LoginHandler() {}",
+        "}");
+    JavaFileObject adminHandlerFile = JavaFileObjects.forSourceLines("test.AdminHandler",
+        "package test;",
+        "",
+        "class AdminHandler implements Handler {",
+        "  public AdminHandler() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.Map;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
+        "interface TestComponent {",
+        "  Map<PathKey, Provider<Handler>> dispatcher();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.Dagger_TestComponent",
+        "package test;",
+        "",
+        "import dagger.internal.MapProviderFactory;",
+        "import java.util.Map;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_TestComponent implements TestComponent {",
+        "  private final MapModuleOne mapModuleOne;",
+        "  private final MapModuleTwo mapModuleTwo;",
+        "  private Provider<Map<PathKey, Provider<Handler>>>",
+        "      mapOfPathKeyAndProviderOfHandlerProvider;",
+        "",
+        "  private Dagger_TestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    this.mapModuleOne = builder.mapModuleOne;",
+        "    this.mapModuleTwo = builder.mapModuleTwo;",
+        "    initialize();",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize() {",
+        "    this.mapOfPathKeyAndProviderOfHandlerProvider =",
+        "        MapProviderFactory.<PathKey, Handler>builder(2)",
+        "            .put(PathKeyCreator.create(PathEnum.ADMIN, \"DefaultPath\"),",
+        "                new MapModuleOne$$ProvideAdminHandlerFactory(mapModuleOne))",
+        "            .put(PathKeyCreator.create(PathEnum.LOGIN, \"LoginPath\"),",
+        "                new MapModuleTwo$$ProvideLoginHandlerFactory(mapModuleTwo))",
+        "            .build();",
+        "  }",
+        "",
+        "  @Override",
+        "  public Map<PathKey, Provider<Handler>> dispatcher() {",
+        "    return mapOfPathKeyAndProviderOfHandlerProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private MapModuleOne mapModuleOne;",
+        "    private MapModuleTwo mapModuleTwo;",
+        "",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public TestComponent build() {",
+        "      if (mapModuleOne == null) {",
+        "        this.mapModuleOne = new MapModuleOne();",
+        "      }",
+        "      if (mapModuleTwo == null) {",
+        "        this.mapModuleTwo = new MapModuleTwo();",
+        "      }",
+        "      return new Dagger_TestComponent(this);",
+        "    }",
+        "",
+        "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+        "      if (mapModuleOne == null) {",
+        "        throw new NullPointerException(\"mapModuleOne\");",
+        "      }",
+        "      this.mapModuleOne = mapModuleOne;",
+        "      return this;",
+        "    }",
+        "",
+        "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+        "      if (mapModuleTwo == null) {",
+        "        throw new NullPointerException(\"mapModuleTwo\");",
+        "      }",
+        "      this.mapModuleTwo = mapModuleTwo;",
+        "      return this;",
+        "    }",
+        "  }",
+        "}");
+    assert_().about(javaSources())
+        .that(ImmutableList.of(
+            mapModuleOneFile,
+            mapModuleTwoFile,
+            enumKeyFile,
+            pathEnumFile,
+            handlerFile,
+            loginHandlerFile,
+            adminHandlerFile,
+            componentFile))
+        .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedComponent);
+  }
+}
\ No newline at end of file
diff --git a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
new file mode 100644
index 000000000..e6c119e5b
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
@@ -0,0 +1,187 @@
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assert_;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+
+@RunWith(JUnit4.class)
+public class MembersInjectionTest {
+  @Test
+  public void parentClass_noInjectedMembers() {
+    JavaFileObject childFile = JavaFileObjects.forSourceLines("test.Child",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "public final class Child extends Parent {",
+        "  @Inject Child() {}",
+        "}");
+    JavaFileObject parentFile = JavaFileObjects.forSourceLines("test.Parent",
+        "package test;",
+        "",
+        "public abstract class Parent {}");
+
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  Child child();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.Dagger_TestComponent",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import dagger.internal.MembersInjectors;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_TestComponent implements TestComponent {",
+        "  private MembersInjector<Parent> parentMembersInjector;",
+        "  private MembersInjector<Child> childMembersInjector;",
+        "  private Provider<Child> childProvider;",
+        "",
+        "  private Dagger_TestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize();",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize() {",
+        "    this.parentMembersInjector = MembersInjectors.noOp();",
+        "    this.childMembersInjector = MembersInjectors.delegatingTo(parentMembersInjector);",
+        "    this.childProvider = new Child$$Factory(childMembersInjector);",
+        "  }",
+        "",
+        "  @Override",
+        "  public Child child() {",
+        "    return childProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public TestComponent build() {",
+        "      return new Dagger_TestComponent(this);",
+        "    }",
+        "  }",
+        "}");
+    assert_().about(javaSources())
+        .that(ImmutableList.of(childFile, parentFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+
+  @Test
+  public void parentClass_injectedMembersInSupertype() {
+    JavaFileObject childFile = JavaFileObjects.forSourceLines("test.Child",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "public final class Child extends Parent {",
+        "  @Inject Child() {}",
+        "}");
+    JavaFileObject parentFile = JavaFileObjects.forSourceLines("test.Parent",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "public abstract class Parent {",
+        "  @Inject Dep dep;",
+        "}");
+    JavaFileObject depFile = JavaFileObjects.forSourceLines("test.Dep",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class Dep {",
+        "  @Inject Dep() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  Child child();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.Dagger_TestComponent",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import dagger.internal.MembersInjectors;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_TestComponent implements TestComponent {",
+        "  private Provider<Dep> depProvider;",
+        "  private MembersInjector<Parent> parentMembersInjector;",
+        "  private MembersInjector<Child> childMembersInjector;",
+        "  private Provider<Child> childProvider;",
+        "",
+        "  private Dagger_TestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize();",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize() {",
+        "    this.depProvider = new Dep$$Factory();",
+        "    this.parentMembersInjector = new Parent$$MembersInjector(depProvider);",
+        "    this.childMembersInjector = MembersInjectors.delegatingTo(parentMembersInjector);",
+        "    this.childProvider = new Child$$Factory(childMembersInjector);",
+        "  }",
+        "",
+        "  @Override",
+        "  public Child child() {",
+        "    return childProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public TestComponent build() {",
+        "      return new Dagger_TestComponent(this);",
+        "    }",
+        "  }",
+        "}");
+    assert_().about(javaSources())
+        .that(ImmutableList.of(childFile, parentFile, depFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
similarity index 72%
rename from compiler/src/test/java/dagger/internal/codegen/ModuleProcessorTest.java
rename to compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index c48282c42..cdf270a1d 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -22,7 +22,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.ASSERT;
+import static com.google.common.truth.Truth.assert_;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_ABSTRACT;
@@ -37,7 +37,7 @@
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_WITH_SAME_NAME;
 
 @RunWith(JUnit4.class)
-public class ModuleProcessorTest {
+public class ModuleFactoryGeneratorTest {
   // TODO(gak): add tests for invalid combinations of scope and qualifier annotations like we have
   // for @Inject
 
@@ -52,7 +52,7 @@
         "    return \"\";",
         "  }",
         "}");
-    ASSERT.about(javaSource()).that(moduleFile)
+    assert_().about(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(PROVIDES_METHOD_NOT_IN_MODULE);
@@ -69,7 +69,7 @@
         "abstract class TestModule {",
         "  @Provides abstract String provideString();",
         "}");
-    ASSERT.about(javaSource()).that(moduleFile)
+    assert_().about(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(PROVIDES_METHOD_ABSTRACT);
@@ -88,7 +88,7 @@
         "    return \"\";",
         "  }",
         "}");
-    ASSERT.about(javaSource()).that(moduleFile)
+    assert_().about(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(PROVIDES_METHOD_PRIVATE);
@@ -107,7 +107,7 @@
         "    return \"\";",
         "  }",
         "}");
-    ASSERT.about(javaSource()).that(moduleFile)
+    assert_().about(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(PROVIDES_METHOD_STATIC);
@@ -124,7 +124,7 @@
         "final class TestModule {",
         "  @Provides void provideNothing() {}",
         "}");
-    ASSERT.about(javaSource()).that(moduleFile)
+    assert_().about(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(PROVIDES_METHOD_MUST_RETURN_A_VALUE);
@@ -143,7 +143,7 @@
         "    return \"\";",
         "  }",
         "}");
-    ASSERT.about(javaSource()).that(moduleFile)
+    assert_().about(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(PROVIDES_METHOD_TYPE_PARAMETER);
@@ -166,7 +166,7 @@
         "    return null;",
         "  }",
         "}");
-    ASSERT.about(javaSource()).that(moduleFile)
+    assert_().about(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(PROVIDES_METHOD_RETURN_TYPE);
@@ -189,7 +189,7 @@
         "    return null;",
         "  }",
         "}");
-    ASSERT.about(javaSource()).that(moduleFile)
+    assert_().about(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(PROVIDES_METHOD_SET_VALUES_RAW_SET);
@@ -212,7 +212,7 @@
         "    return null;",
         "  }",
         "}");
-    ASSERT.about(javaSource()).that(moduleFile)
+    assert_().about(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(PROVIDES_METHOD_SET_VALUES_RETURN_SET);
@@ -235,10 +235,13 @@
         "package test;",
         "",
         "import dagger.Factory;",
+        "import java.util.logging.Logger;",
         "import javax.annotation.Generated;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class TestModule$$ProvideStringFactory implements Factory<String> {",
+        "  private static final Logger logger =",
+        "      Logger.getLogger(TestModule$$ProvideStringFactory.class.getCanonicalName());",
         "  private final TestModule module;",
         "",
         "  public TestModule$$ProvideStringFactory(TestModule module) {",
@@ -247,10 +250,16 @@
         "  }",
         "",
         "  @Override public String get() {",
-        "    return module.provideString();",
+        "    String result =  module.provideString();",
+        "    if (result == null) {",
+        "      logger.warning("
+            + "\"test.TestModule.provideString() provided null. "
+            + "This is not allowed and will soon throw a NullPointerException.\");",
+        "    }",
+        "    return result;",
         "  }",
         "}");
-    ASSERT.about(javaSource()).that(moduleFile)
+    assert_().about(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(factoryFile);
@@ -301,11 +310,14 @@
         "",
         "import dagger.Factory;",
         "import java.util.List;",
+        "import java.util.logging.Logger;",
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class TestModule$$ProvideObjectsFactory implements Factory<List<Object>> {",
+        "  private static final Logger logger =",
+        "      Logger.getLogger(TestModule$$ProvideObjectsFactory.class.getCanonicalName());",
         "  private final TestModule module;",
         "  private final Provider<Object> aProvider;",
         "  private final Provider<Object> bProvider;",
@@ -321,10 +333,16 @@
         "  }",
         "",
         "  @Override public List<Object> get() {",
-        "    return module.provideObjects(aProvider.get(), bProvider.get());",
+        "    List<Object> result = module.provideObjects(aProvider.get(), bProvider.get());",
+        "    if (result == null) {",
+        "      logger.warning("
+            + "\"test.TestModule.provideObjects(java.lang.Object,java.lang.Object) provided null. "
+            + "This is not allowed and will soon throw a NullPointerException.\");",
+        "    }",
+        "    return result;",
         "  }",
         "}");
-    ASSERT.about(javaSources()).that(ImmutableList.of(moduleFile, QUALIFIER_A, QUALIFIER_B))
+    assert_().about(javaSources()).that(ImmutableList.of(moduleFile, QUALIFIER_A, QUALIFIER_B))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(listFactoryFile);
@@ -336,6 +354,7 @@
         "",
         "import static dagger.Provides.Type.SET;",
         "",
+        "import java.util.logging.Logger;",
         "import dagger.Module;",
         "import dagger.Provides;",
         "",
@@ -351,10 +370,13 @@
         "import dagger.Factory;",
         "import java.util.Collections;",
         "import java.util.Set;",
+        "import java.util.logging.Logger;",
         "import javax.annotation.Generated;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class TestModule$$ProvideStringFactory implements Factory<Set<String>> {",
+        "  private static final Logger logger =",
+        "      Logger.getLogger(TestModule$$ProvideStringFactory.class.getCanonicalName());",
         "  private final TestModule module;",
         "",
         "  public TestModule$$ProvideStringFactory(TestModule module) {",
@@ -363,10 +385,16 @@
         "  }",
         "",
         "  @Override public Set<String> get() {",
-        "    return Collections.singleton(module.provideString());",
+        "    String result =  module.provideString();",
+        "    if (result == null) {",
+        "      logger.warning("
+            + "\"test.TestModule.provideString() provided null. "
+            + "This is not allowed and will soon throw a NullPointerException.\");",
+        "    }",
+        "    return Collections.singleton(result);",
         "  }",
         "}");
-    ASSERT.about(javaSource()).that(moduleFile)
+    assert_().about(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(factoryFile);
@@ -393,10 +421,13 @@
         "",
         "import dagger.Factory;",
         "import java.util.Set;",
+        "import java.util.logging.Logger;",
         "import javax.annotation.Generated;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class TestModule$$ProvideStringsFactory implements Factory<Set<String>> {",
+        "  private static final Logger logger =",
+        "      Logger.getLogger(TestModule$$ProvideStringsFactory.class.getCanonicalName());",
         "  private final TestModule module;",
         "",
         "  public TestModule$$ProvideStringsFactory(TestModule module) {",
@@ -405,10 +436,16 @@
         "  }",
         "",
         "  @Override public Set<String> get() {",
-        "    return module.provideStrings();",
+        "    Set<String> result = module.provideStrings();",
+        "    if (result == null) {",
+        "      logger.warning("
+            + "\"test.TestModule.provideStrings() provided null. "
+            + "This is not allowed and will soon throw a NullPointerException.\");",
+        "    }",
+        "    return result;",
         "  }",
         "}");
-    ASSERT.about(javaSource()).that(moduleFile)
+    assert_().about(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(factoryFile);
@@ -431,7 +468,7 @@
         "    return \"\";",
         "  }",
         "}");
-    ASSERT.about(javaSource()).that(moduleFile)
+    assert_().about(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(PROVIDES_METHOD_WITH_SAME_NAME).in(moduleFile).onLine(8)
@@ -474,8 +511,96 @@ public void providedTypes() {
         "    return null;",
         "  }",
         "}");
-    ASSERT.about(javaSource()).that(moduleFile)
+    assert_().about(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError();
   }
+
+  @Test
+  public void privateModule() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.Enclosing",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "final class Enclosing {",
+        "  @Module private static final class PrivateModule {",
+        "  }",
+        "}");
+    assert_().about(javaSource())
+        .that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("Modules cannot be private.")
+        .in(moduleFile).onLine(6);
+  }
+
+  @Test
+  public void enclosedInPrivateModule() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.Enclosing",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "final class Enclosing {",
+        "  private static final class PrivateEnclosing {",
+        "    @Module static final class TestModule {",
+        "    }",
+        "  }",
+        "}");
+    assert_().about(javaSource())
+        .that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("Modules cannot be enclosed in private types.")
+        .in(moduleFile).onLine(7);
+  }
+
+  @Test
+  public void publicModuleNonPublicIncludes() {
+    JavaFileObject publicModuleFile = JavaFileObjects.forSourceLines("test.PublicModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module(includes = {",
+        "    NonPublicModule1.class, OtherPublicModule.class, NonPublicModule2.class",
+        "})",
+        "public final class PublicModule {",
+        "}");
+    JavaFileObject nonPublicModule1File = JavaFileObjects.forSourceLines("test.NonPublicModule1",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module",
+        "final class NonPublicModule1 {",
+        "}");
+    JavaFileObject nonPublicModule2File = JavaFileObjects.forSourceLines("test.NonPublicModule2",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module",
+        "final class NonPublicModule2 {",
+        "}");
+    JavaFileObject otherPublicModuleFile = JavaFileObjects.forSourceLines("test.OtherPublicModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module",
+        "public final class OtherPublicModule {",
+        "}");
+    assert_().about(javaSources())
+        .that(ImmutableList.of(
+            publicModuleFile, nonPublicModule1File, nonPublicModule2File, otherPublicModuleFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("This module is public, but it includes non-public "
+            + "(or effectively non-public) modules. "
+            + "Either reduce the visibility of this module or make "
+            + "test.NonPublicModule1 and test.NonPublicModule2 public.")
+        .in(publicModuleFile).onLine(8);
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java b/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java
new file mode 100644
index 000000000..c404cce56
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java
@@ -0,0 +1,101 @@
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assert_;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+
+@RunWith(JUnit4.class)
+public class PackageProxyTest {
+  @Test public void testPackageProxy() {
+    JavaFileObject publicClassFile = JavaFileObjects.forSourceLines("foreign.PublicClass",
+        "package foreign;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "public final class PublicClass {",
+        "  @Inject PublicClass(NonPublicClass dep) {}",
+        "}");
+    JavaFileObject nonPublicClassFile = JavaFileObjects.forSourceLines("foreign.NonPublicClass",
+        "package foreign;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class NonPublicClass {",
+        "  @Inject NonPublicClass() {}",
+        "}");
+
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import foreign.PublicClass;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  PublicClass publicClass();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.Dagger_TestComponent",
+        "package test;",
+        "",
+        "import foreign.Dagger_TestComponent__PackageProxy;",
+        "import foreign.NonPublicClass$$Factory;",
+        "import foreign.PublicClass;",
+        "import foreign.PublicClass$$Factory;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_TestComponent implements TestComponent {",
+        "  private final Dagger_TestComponent__PackageProxy foreign_Proxy =",
+        "      new Dagger_TestComponent__PackageProxy();",
+        "  private Provider<PublicClass> publicClassProvider;",
+        "",
+        "  private Dagger_TestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize();",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize() {",
+        "    this.foreign_Proxy.nonPublicClassProvider = new NonPublicClass$$Factory();",
+        "    this.publicClassProvider =",
+        "        new PublicClass$$Factory(foreign_Proxy.nonPublicClassProvider);",
+        "  }",
+        "",
+        "  @Override",
+        "  public PublicClass publicClass() {",
+        "    return publicClassProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public TestComponent build() {",
+        "      return new Dagger_TestComponent(this);",
+        "    }",
+        "  }",
+        "}");
+    assert_().about(javaSources())
+        .that(ImmutableList.of(publicClassFile, nonPublicClassFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/DotWriterTest.java b/compiler/src/test/java/dagger/internal/codegen/dagger1/DotWriterTest.java
similarity index 98%
rename from compiler/src/test/java/dagger/internal/codegen/DotWriterTest.java
rename to compiler/src/test/java/dagger/internal/codegen/dagger1/DotWriterTest.java
index e1ce8e261..5eecefbfc 100644
--- a/compiler/src/test/java/dagger/internal/codegen/DotWriterTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/dagger1/DotWriterTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.internal.codegen.dagger1;
 
 import java.io.IOException;
 import java.io.StringWriter;
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphVisualizerTest.java b/compiler/src/test/java/dagger/internal/codegen/dagger1/GraphVisualizerTest.java
similarity index 98%
rename from compiler/src/test/java/dagger/internal/codegen/GraphVisualizerTest.java
rename to compiler/src/test/java/dagger/internal/codegen/dagger1/GraphVisualizerTest.java
index e511c65ca..8afd7b9bc 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphVisualizerTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/dagger1/GraphVisualizerTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.internal.codegen.dagger1;
 
 import dagger.internal.Keys;
 import java.lang.reflect.Field;
diff --git a/compiler/src/test/java/dagger/internal/codegen/writer/JavaWriterTest.java b/compiler/src/test/java/dagger/internal/codegen/writer/JavaWriterTest.java
new file mode 100644
index 000000000..e775f7487
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/writer/JavaWriterTest.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen.writer;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public class JavaWriterTest {
+  @Test public void referencedAndDeclaredSimpleName() {
+    JavaWriter javaWriter = JavaWriter.inPackage("test");
+    ClassWriter topClass = javaWriter.addClass("Top");
+    topClass.addNestedClass("Middle").addNestedClass("Bottom");
+    topClass.addField(ClassName.create("some.other.pkg", "Bottom"), "field");
+    assertThat(topClass.toString()).doesNotContain("import some.other.pkg.Bottom;");
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/writer/TypeNamesTest.java b/compiler/src/test/java/dagger/internal/codegen/writer/TypeNamesTest.java
index 08a114f84..c637b7ced 100644
--- a/compiler/src/test/java/dagger/internal/codegen/writer/TypeNamesTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/writer/TypeNamesTest.java
@@ -12,7 +12,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static org.truth0.Truth.ASSERT;
+import static com.google.common.truth.Truth.assert_;
 
 @RunWith(JUnit4.class)
 public class TypeNamesTest {
@@ -28,11 +28,11 @@ private TypeMirror getType(Class<?> clazz) {
 
   @Test
   public void forTypeMirror_basicTypes() {
-    ASSERT.that(TypeNames.forTypeMirror(getType(Object.class)))
+    assert_().that(TypeNames.forTypeMirror(getType(Object.class)))
         .isEqualTo(ClassName.fromClass(Object.class));
-    ASSERT.that(TypeNames.forTypeMirror(getType(Charset.class)))
+    assert_().that(TypeNames.forTypeMirror(getType(Charset.class)))
         .isEqualTo(ClassName.fromClass(Charset.class));
-    ASSERT.that(TypeNames.forTypeMirror(getType(TypeNamesTest.class)))
+    assert_().that(TypeNames.forTypeMirror(getType(TypeNamesTest.class)))
         .isEqualTo(ClassName.fromClass(TypeNamesTest.class));
   }
 
@@ -40,45 +40,45 @@ public void forTypeMirror_basicTypes() {
   public void forTypeMirror_parameterizedType() {
     DeclaredType setType =
         compilation.getTypes().getDeclaredType(getElement(Set.class), getType(Object.class));
-    ASSERT.that(TypeNames.forTypeMirror(setType))
+    assert_().that(TypeNames.forTypeMirror(setType))
         .isEqualTo(ParameterizedTypeName.create(Set.class, ClassName.fromClass(Object.class)));
   }
 
   @Test
   public void forTypeMirror_primitive() {
-    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.BOOLEAN)))
+    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.BOOLEAN)))
         .isEqualTo(PrimitiveName.BOOLEAN);
-    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.BYTE)))
+    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.BYTE)))
         .isEqualTo(PrimitiveName.BYTE);
-    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.SHORT)))
+    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.SHORT)))
         .isEqualTo(PrimitiveName.SHORT);
-    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.INT)))
+    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.INT)))
         .isEqualTo(PrimitiveName.INT);
-    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.LONG)))
+    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.LONG)))
         .isEqualTo(PrimitiveName.LONG);
-    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.CHAR)))
+    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.CHAR)))
         .isEqualTo(PrimitiveName.CHAR);
-    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.FLOAT)))
+    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.FLOAT)))
         .isEqualTo(PrimitiveName.FLOAT);
-    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.DOUBLE)))
+    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.DOUBLE)))
         .isEqualTo(PrimitiveName.DOUBLE);
   }
 
   @Test
   public void forTypeMirror_arrays() {
-    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getArrayType(getType(Object.class))))
+    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getArrayType(getType(Object.class))))
         .isEqualTo(new ArrayTypeName(ClassName.fromClass(Object.class)));
   }
 
   @Test
   public void forTypeMirror_void() {
-    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getNoType(TypeKind.VOID)))
+    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getNoType(TypeKind.VOID)))
         .isEqualTo(VoidName.VOID);
   }
 
   @Test
   public void forTypeMirror_null() {
-    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getNullType()))
+    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getNullType()))
         .isEqualTo(NullName.NULL);
   }
 }
diff --git a/compiler/src/test/java/dagger/testing/it/BuildLogValidator.java b/compiler/src/test/java/dagger/testing/it/BuildLogValidator.java
index 9eb15cfe4..ebd11b68e 100644
--- a/compiler/src/test/java/dagger/testing/it/BuildLogValidator.java
+++ b/compiler/src/test/java/dagger/testing/it/BuildLogValidator.java
@@ -22,6 +22,7 @@
 import java.nio.channels.FileChannel;
 import java.nio.charset.Charset;
 
+// TODO(user) remove when invoker tests are deleted.
 public class BuildLogValidator {
 
   /**
diff --git a/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/dagger1/InjectAdapterGenerationTest.java
similarity index 91%
rename from compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
rename to compiler/src/test/java/dagger/tests/integration/codegen/dagger1/InjectAdapterGenerationTest.java
index 3e7cc064e..257f99d8e 100644
--- a/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/codegen/dagger1/InjectAdapterGenerationTest.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.tests.integration.codegen;
+package dagger.tests.integration.codegen.dagger1;
 
 import com.google.common.base.Joiner;
 import com.google.testing.compile.JavaFileObjects;
@@ -23,9 +23,9 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.ASSERT;
+import static com.google.common.truth.Truth.assert_;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
+import static dagger.tests.integration.dagger1.ProcessorTestUtils.daggerProcessors;
 
 @RunWith(JUnit4.class)
 public final class InjectAdapterGenerationTest {
@@ -71,7 +71,7 @@
             "  }",
             "}"));
 
-    ASSERT.about(javaSource()).that(sourceFile).processedWith(daggerProcessors())
+    assert_().about(javaSource()).that(sourceFile).processedWith(daggerProcessors())
         .compilesWithoutError().and()
         .generatesSources(expectedModuleAdapter, expectedInjectAdapter);
 
diff --git a/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/dagger1/ModuleAdapterGenerationTest.java
similarity index 96%
rename from compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
rename to compiler/src/test/java/dagger/tests/integration/codegen/dagger1/ModuleAdapterGenerationTest.java
index 251eb8003..17dfa7ce0 100644
--- a/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/codegen/dagger1/ModuleAdapterGenerationTest.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.tests.integration.codegen;
+package dagger.tests.integration.codegen.dagger1;
 
 import com.google.common.base.Joiner;
 import com.google.testing.compile.JavaFileObjects;
@@ -23,10 +23,10 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.ASSERT;
+import static com.google.common.truth.Truth.assert_;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
+import static dagger.tests.integration.dagger1.ProcessorTestUtils.daggerProcessors;
 import static java.util.Arrays.asList;
 
 @RunWith(JUnit4.class)
@@ -120,7 +120,7 @@
             "  }",
             "}"));
 
-    ASSERT.about(javaSource()).that(sourceFile).processedWith(daggerProcessors())
+    assert_().about(javaSource()).that(sourceFile).processedWith(daggerProcessors())
         .compilesWithoutError()
         .and()
         .generatesSources(expectedModuleAdapter, expectedInjectAdapter);
@@ -232,13 +232,12 @@
             "    object.name = name.get();", // Inject field.
             "  }",
             "}"));
-    ASSERT.about(javaSource()).that(sourceFile).processedWith(daggerProcessors())
+    assert_().about(javaSource()).that(sourceFile).processedWith(daggerProcessors())
         .compilesWithoutError()
         .and()
         .generatesSources(expectedModuleAdapter, expectedInjectAdapterA, expectedInjectAdapterB);
   }
 
-
   @Test public void providesHasParameterNamedModule() {
     JavaFileObject a = JavaFileObjects.forSourceString("A", Joiner.on("\n").join(
         "import javax.inject.Inject;",
@@ -254,7 +253,7 @@
         "@Module(injects = B.class)",
         "class BModule { @Provides B b(A module) { return new B(); }}"));
 
-    ASSERT.about(javaSources()).that(asList(a, b, module)).processedWith(daggerProcessors())
+    assert_().about(javaSources()).that(asList(a, b, module)).processedWith(daggerProcessors())
         .compilesWithoutError();
   }
 
diff --git a/compiler/src/test/java/dagger/tests/integration/ProcessorTestUtils.java b/compiler/src/test/java/dagger/tests/integration/dagger1/ProcessorTestUtils.java
similarity index 77%
rename from compiler/src/test/java/dagger/tests/integration/ProcessorTestUtils.java
rename to compiler/src/test/java/dagger/tests/integration/dagger1/ProcessorTestUtils.java
index 12ff02dda..ea4c6f6d5 100644
--- a/compiler/src/test/java/dagger/tests/integration/ProcessorTestUtils.java
+++ b/compiler/src/test/java/dagger/tests/integration/dagger1/ProcessorTestUtils.java
@@ -14,12 +14,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.tests.integration;
+package dagger.tests.integration.dagger1;
 
-import dagger.internal.codegen.GraphAnalysisProcessor;
-import dagger.internal.codegen.InjectAdapterProcessor;
-import dagger.internal.codegen.ModuleAdapterProcessor;
-import dagger.internal.codegen.ValidationProcessor;
+import dagger.internal.codegen.dagger1.GraphAnalysisProcessor;
+import dagger.internal.codegen.dagger1.InjectAdapterProcessor;
+import dagger.internal.codegen.dagger1.ModuleAdapterProcessor;
+import dagger.internal.codegen.dagger1.ValidationProcessor;
 import java.util.Arrays;
 import javax.annotation.processing.Processor;
 
diff --git a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
index 8c4258c04..8ed583d10 100644
--- a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
@@ -23,14 +23,14 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.ASSERT;
+import static com.google.common.truth.Truth.assert_;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static java.util.Arrays.asList;
 
 @RunWith(JUnit4.class)
 public final class PrimitiveInjectionTest {
 
-  // TODO(cgruber): Use @test.ForTest to qualify primitives once qualifier equivalence is working.
+  // TODO(user): Use @test.ForTest to qualify primitives once qualifier equivalence is working.
   /*
   JavaFileObject annotation = JavaFileObjects.forSourceLines("test.ForTest",
       "package test;",
@@ -40,7 +40,7 @@
       "}");
   */
 
-  // TODO(cgruber): Expand test to support more primitive types when b/15512877 is fixed.
+  // TODO(user): Expand test to support more primitive types when b/15512877 is fixed.
   JavaFileObject primitiveInjectable = JavaFileObjects.forSourceLines("test.PrimitiveInjectable",
       "package test;",
       "import javax.inject.Inject;",
@@ -77,15 +77,13 @@
       "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
       "public final class Dagger_PrimitiveComponent implements PrimitiveComponent {",
       "  private final PrimitiveModule primitiveModule;",
-      "  private final Provider<PrimitiveInjectable> primitiveInjectableProvider;",
-      "  private final Provider<Integer> primitiveIntProvider;",
+      "  private Provider<Integer> primitiveIntProvider;",
+      "  private Provider<PrimitiveInjectable> primitiveInjectableProvider;",
       "",
       "  private Dagger_PrimitiveComponent(Builder builder) {",
       "    assert builder != null;",
       "    this.primitiveModule = builder.primitiveModule;",
-      "    this.primitiveIntProvider = new PrimitiveModule$$PrimitiveIntFactory(primitiveModule);",
-      "    this.primitiveInjectableProvider =",
-      "        new PrimitiveInjectable$$Factory(primitiveIntProvider);",
+      "    initialize();",
       "  }",
       "",
       "  public static Builder builder() {",
@@ -96,6 +94,12 @@
       "    return builder().build();",
       "  }",
       "",
+      "  private void initialize() {",
+      "    this.primitiveIntProvider = new PrimitiveModule$$PrimitiveIntFactory(primitiveModule);",
+      "    this.primitiveInjectableProvider =",
+      "        new PrimitiveInjectable$$Factory(primitiveIntProvider);",
+      "  }",
+      "",
       "  @Override",
       "  public int primitiveInt() {",
       "    return primitiveIntProvider.get();",
@@ -130,7 +134,7 @@
       "}");
 
   @Test public void primitiveArrayTypesAllInjected() {
-    ASSERT.about(javaSources())
+    assert_().about(javaSources())
         .that(asList(component, primitiveInjectable, primitiveModule))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
diff --git a/compiler/src/test/java/dagger/tests/integration/operation/dagger1/FailureModeErrorsTest.java b/compiler/src/test/java/dagger/tests/integration/operation/dagger1/FailureModeErrorsTest.java
new file mode 100644
index 000000000..fd530d9ad
--- /dev/null
+++ b/compiler/src/test/java/dagger/tests/integration/operation/dagger1/FailureModeErrorsTest.java
@@ -0,0 +1,77 @@
+/**
+ * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.tests.integration.operation.dagger1;
+
+import dagger.Module;
+import dagger.ObjectGraph;
+import javax.inject.Inject;
+import javax.inject.Qualifier;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static junit.framework.Assert.fail;
+import static org.fest.assertions.Assertions.assertThat;
+
+@RunWith(JUnit4.class)
+public final class FailureModeErrorsTest {
+
+  @Module
+  static class CompleteModule {}
+
+  static class ArrayFoo {
+    @Inject ArrayFoo(String[] ignored) {}
+  }
+
+  @Module(injects = ArrayFoo.class, complete = false)
+  static class ArrayFooModule {}
+
+  @Test public void failOnMissingModule_array_or_generics() {
+    // Generics here are crazy to try to test for, but this code path is legit regardless.
+    try {
+      ObjectGraph.create(new CompleteModule(), new ArrayFooModule()).get(ArrayFoo.class);
+      fail("Should have thrown.");
+    } catch (IllegalStateException e) {
+      assertThat(e.getMessage()).contains(
+          "java.lang.String[] is a generic class or an array and can only be bound with "
+              + "concrete type parameter(s) in a @Provides method. required by class "
+              + FailureModeErrorsTest.class.getCanonicalName() + "$ArrayFoo");
+    }
+  }
+
+  @Qualifier @interface MyFoo {}
+
+  static class QualifyingFoo {
+    @Inject QualifyingFoo(@MyFoo String ignored) {}
+  }
+
+  @Module(injects = QualifyingFoo.class, complete = false)
+  static class QualifyingFooModule {}
+
+  @Test public void failOnMissingModule_qualified() {
+    try {
+      ObjectGraph.create(new CompleteModule(), new QualifyingFooModule()).get(QualifyingFoo.class);
+      fail("Should have thrown.");
+    } catch (IllegalStateException e) {
+      assertThat(e.getMessage()).contains(
+          "@" + FailureModeErrorsTest.class.getCanonicalName() + "$MyFoo()/java.lang.String "
+              + "is a @Qualifier-annotated type and must be bound by a @Provides method. required "
+              + "by class "
+              + FailureModeErrorsTest.class.getCanonicalName() + "$QualifyingFoo");
+    }
+  }
+}
diff --git a/compiler/src/test/java/dagger/tests/integration/operation/SimpleInjectionTest.java b/compiler/src/test/java/dagger/tests/integration/operation/dagger1/SimpleInjectionTest.java
similarity index 88%
rename from compiler/src/test/java/dagger/tests/integration/operation/SimpleInjectionTest.java
rename to compiler/src/test/java/dagger/tests/integration/operation/dagger1/SimpleInjectionTest.java
index 6a5ae37ce..c5b3acd0b 100644
--- a/compiler/src/test/java/dagger/tests/integration/operation/SimpleInjectionTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/operation/dagger1/SimpleInjectionTest.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.tests.integration.operation;
+package dagger.tests.integration.operation.dagger1;
 
 import dagger.Module;
 import dagger.ObjectGraph;
@@ -24,7 +24,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static org.truth0.Truth.ASSERT;
+import static com.google.common.truth.Truth.assert_;
 
 @RunWith(JUnit4.class)
 public final class SimpleInjectionTest {
@@ -52,18 +52,18 @@
   @Test public void memberInject_WithoutProvidesMethod() {
     Foo foo = new Foo();
     ObjectGraph.create(FooModule.class).inject(foo);
-    ASSERT.that(foo.blah).isEqualTo("blah");
+    assert_().that(foo.blah).isEqualTo("blah");
   }
 
   @Test public void membersInject_WithProvidesMethod() {
     Foo foo = new Foo();
     ObjectGraph.create(ProvidingFooModule.class).inject(foo);
-    ASSERT.that(foo.blah).isEqualTo("blah");
+    assert_().that(foo.blah).isEqualTo("blah");
   }
 
   @Test public void get_WithProvidesMethod() {
     Foo foo = ObjectGraph.create(ProvidingFooModule.class).get(Foo.class);
-    ASSERT.that(foo.blah).isEqualTo("blah");
+    assert_().that(foo.blah).isEqualTo("blah");
   }
 
   static class Bar { }
@@ -84,7 +84,7 @@
 
   @Test public void membersInject_WithProvidedNonInjectable() {
     Bar bar = ObjectGraph.create(ProvidingBarModule.class).get(Bar.class);
-    ASSERT.that(bar).isNotNull();
+    assert_().that(bar).isNotNull();
   }
 
 }
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/CyclicDependencyTest.java b/compiler/src/test/java/dagger/tests/integration/validation/dagger1/CyclicDependencyTest.java
similarity index 88%
rename from compiler/src/test/java/dagger/tests/integration/validation/CyclicDependencyTest.java
rename to compiler/src/test/java/dagger/tests/integration/validation/dagger1/CyclicDependencyTest.java
index 027a1457f..f09be125d 100644
--- a/compiler/src/test/java/dagger/tests/integration/validation/CyclicDependencyTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/dagger1/CyclicDependencyTest.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.tests.integration.validation;
+package dagger.tests.integration.validation.dagger1;
 
 import com.google.common.base.Joiner;
 import com.google.testing.compile.JavaFileObjects;
@@ -23,9 +23,9 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.ASSERT;
+import static com.google.common.truth.Truth.assert_;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
+import static dagger.tests.integration.dagger1.ProcessorTestUtils.daggerProcessors;
 
 @RunWith(JUnit4.class)
 public class CyclicDependencyTest {
@@ -51,7 +51,7 @@
         "  static class TestModule { }",
         "}"));
 
-    ASSERT.about(javaSource()).that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
+    assert_().about(javaSource()).that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
         .withErrorContaining("0. CyclicDeps$Foo bound by").in(sourceFile).onLine(17).and()
         .withErrorContaining("1. CyclicDeps$Bar bound by").in(sourceFile).onLine(17).and()
         .withErrorContaining("2. CyclicDeps$Blah bound by").in(sourceFile).onLine(17);
@@ -75,7 +75,7 @@
         "  }",
         "}"));
 
-    ASSERT.about(javaSource()).that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
+    assert_().about(javaSource()).that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
         .withErrorContaining("0. CyclicDeps$A bound by Provides").in(sourceFile).onLine(9).and()
         .withErrorContaining("1. CyclicDeps$D bound by Provides").in(sourceFile).onLine(9).and()
         .withErrorContaining("2. CyclicDeps$C bound by Provides").in(sourceFile).onLine(9).and()
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/CyclicModuleIncludesTest.java b/compiler/src/test/java/dagger/tests/integration/validation/dagger1/CyclicModuleIncludesTest.java
similarity index 87%
rename from compiler/src/test/java/dagger/tests/integration/validation/CyclicModuleIncludesTest.java
rename to compiler/src/test/java/dagger/tests/integration/validation/dagger1/CyclicModuleIncludesTest.java
index 2a9fd1761..b7e43f4dc 100644
--- a/compiler/src/test/java/dagger/tests/integration/validation/CyclicModuleIncludesTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/dagger1/CyclicModuleIncludesTest.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.tests.integration.validation;
+package dagger.tests.integration.validation.dagger1;
 
 import com.google.common.base.Joiner;
 import com.google.testing.compile.JavaFileObjects;
@@ -23,9 +23,9 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.ASSERT;
+import static com.google.common.truth.Truth.assert_;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
+import static dagger.tests.integration.dagger1.ProcessorTestUtils.daggerProcessors;
 
 @RunWith(JUnit4.class)
 public class CyclicModuleIncludesTest {
@@ -48,13 +48,13 @@
           "}"));
 
   @Test public void cyclicModuleSelfIncludes() {
-    ASSERT.about(javaSource()).that(javaFile).processedWith(daggerProcessors()).failsToCompile()
+    assert_().about(javaSource()).that(javaFile).processedWith(daggerProcessors()).failsToCompile()
         .withErrorContaining("CyclicModules.SelfReferencingModule includes itself directly")
             .in(javaFile).onLine(4);
   }
 
   @Test public void cyclicModuleIncludes_full_cycle() {
-    ASSERT.about(javaSource()).that(javaFile).processedWith(daggerProcessors()).failsToCompile()
+    assert_().about(javaSource()).that(javaFile).processedWith(daggerProcessors()).failsToCompile()
         .withErrorContaining("0. CyclicModules.Rock included by CyclicModules.Paper")
             .in(javaFile).onLine(6).and()
         .withErrorContaining("1. CyclicModules.Paper included by CyclicModules.Scissors")
@@ -68,7 +68,7 @@
   }
 
   @Test public void cyclicModuleIncludes_initial_inclusion() {
-    ASSERT.about(javaSource()).that(javaFile).processedWith(daggerProcessors()).failsToCompile()
+    assert_().about(javaSource()).that(javaFile).processedWith(daggerProcessors()).failsToCompile()
         .withErrorContaining("0. CyclicModules.Rock included by CyclicModules.Paper")
             .in(javaFile).onLine(6).and()
         .withErrorContaining("0. CyclicModules.Paper included by CyclicModules.Scissors")
@@ -81,5 +81,4 @@
             .in(javaFile).onLine(14);
   }
 
-
 }
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/GeneratedTypesNotReadyTest.java b/compiler/src/test/java/dagger/tests/integration/validation/dagger1/GeneratedTypesNotReadyTest.java
similarity index 91%
rename from compiler/src/test/java/dagger/tests/integration/validation/GeneratedTypesNotReadyTest.java
rename to compiler/src/test/java/dagger/tests/integration/validation/dagger1/GeneratedTypesNotReadyTest.java
index b189201e7..1e41f2292 100644
--- a/compiler/src/test/java/dagger/tests/integration/validation/GeneratedTypesNotReadyTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/dagger1/GeneratedTypesNotReadyTest.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.tests.integration.validation;
+package dagger.tests.integration.validation.dagger1;
 
 import com.google.common.base.Joiner;
 import com.google.testing.compile.JavaFileObjects;
@@ -32,9 +32,9 @@
 import org.junit.runners.JUnit4;
 
 import static com.google.common.collect.Iterables.concat;
-import static com.google.common.truth.Truth.ASSERT;
+import static com.google.common.truth.Truth.assert_;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
+import static dagger.tests.integration.dagger1.ProcessorTestUtils.daggerProcessors;
 import static java.util.Arrays.asList;
 
 /**
@@ -56,7 +56,7 @@
       "}"));
 
   @Test public void withstandsMissingTypeReferencedInInjects() {
-    // TODO(cgruber): remove Foo (interface) from this when injects= analysis is fixed.
+    // TODO(user): remove Foo (interface) from this when injects= analysis is fixed.
     JavaFileObject module = JavaFileObjects.forSourceString("FooModule", Joiner.on("\n").join(
         "import dagger.Module;",
         "import dagger.Provides;",
@@ -68,7 +68,7 @@
         "  }",
         "}"));
 
-    ASSERT.about(javaSources()).that(asList(foo, main, module))
+    assert_().about(javaSources()).that(asList(foo, main, module))
         .processedWith(concat(asList(new FooImplGenerator()), daggerProcessors()))
         .compilesWithoutError();
   }
@@ -85,7 +85,7 @@
         "  }",
         "}"));
 
-    ASSERT.about(javaSources()).that(asList(foo, module, main))
+    assert_().about(javaSources()).that(asList(foo, module, main))
         .processedWith(concat(daggerProcessors(), asList(new FooImplGenerator())))
         .compilesWithoutError();
   }
@@ -106,7 +106,7 @@
         "  }",
         "}"));
 
-    ASSERT.about(javaSources()).that(asList(foo, module, main))
+    assert_().about(javaSources()).that(asList(foo, module, main))
         .processedWith(concat(daggerProcessors(), asList(new FooImplGenerator())))
         .compilesWithoutError();
   }
@@ -127,10 +127,10 @@
         "  }",
         "}"));
 
-    ASSERT.about(javaSources()).that(asList(foo, module, main))
+    assert_().about(javaSources()).that(asList(foo, module, main))
         .processedWith(new FooImplGenerator())
         .compilesWithoutError();
-    ASSERT.about(javaSources()).that(asList(foo, module, main))
+    assert_().about(javaSources()).that(asList(foo, module, main))
         .processedWith(concat(daggerProcessors(), asList(new FooImplGenerator())))
         .failsToCompile()
         .withErrorContaining("Could not find types required by provides methods for [FooModule]");
@@ -150,7 +150,7 @@
         "class FooModule {",
         "}"));
 
-    ASSERT.about(javaSources()).that(asList(foo, module, main))
+    assert_().about(javaSources()).that(asList(foo, module, main))
         .processedWith(concat(daggerProcessors(), asList(new FooImplGenerator())))
         .compilesWithoutError();
   }
@@ -166,7 +166,7 @@
         "    return impl;",
         "  }",
         "}"));
-    ASSERT.about(javaSources()).that(asList(foo, module, main))
+    assert_().about(javaSources()).that(asList(foo, module, main))
         .processedWith(new FooImplGenerator())
         .compilesWithoutError();
   }
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/LibraryModuleTest.java b/compiler/src/test/java/dagger/tests/integration/validation/dagger1/LibraryModuleTest.java
similarity index 88%
rename from compiler/src/test/java/dagger/tests/integration/validation/LibraryModuleTest.java
rename to compiler/src/test/java/dagger/tests/integration/validation/dagger1/LibraryModuleTest.java
index 80d01dc84..32368f24e 100644
--- a/compiler/src/test/java/dagger/tests/integration/validation/LibraryModuleTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/dagger1/LibraryModuleTest.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.tests.integration.validation;
+package dagger.tests.integration.validation.dagger1;
 
 import com.google.common.base.Joiner;
 import com.google.testing.compile.JavaFileObjects;
@@ -24,10 +24,10 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.ASSERT;
+import static com.google.common.truth.Truth.assert_;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
+import static dagger.tests.integration.dagger1.ProcessorTestUtils.daggerProcessors;
 
 @RunWith(JUnit4.class)
 public final class LibraryModuleTest {
@@ -42,7 +42,7 @@
         "    return \"string\";",
         "  }",
         "}"));
-    ASSERT.about(javaSource())
+    assert_().about(javaSource())
         .that(source).processedWith(daggerProcessors()).compilesWithoutError();
   }
 
@@ -57,7 +57,7 @@
         "    return \"string\";",
         "  }",
         "}"));
-    ASSERT.about(javaSource()).that(source).processedWith(daggerProcessors()).failsToCompile()
+    assert_().about(javaSource()).that(source).processedWith(daggerProcessors()).failsToCompile()
         .withErrorContaining("Graph validation failed:").in(source).onLine(5).and()
         .withErrorContaining("You have these unused @Provider methods:").in(source).onLine(5).and()
         .withErrorContaining("1. TestModule.string()").in(source).onLine(5).and()
@@ -76,7 +76,7 @@
         "    return new Foo() {};",
         "  }",
         "}"));
-    ASSERT.about(javaSources()).that(Arrays.asList(foo, module))
+    assert_().about(javaSources()).that(Arrays.asList(foo, module))
         .processedWith(daggerProcessors())
         .compilesWithoutError();
   }
@@ -93,7 +93,7 @@
         "    return new Foo() {};",
         "  }",
         "}"));
-    ASSERT.about(javaSources()).that(Arrays.asList(foo, module))
+    assert_().about(javaSources()).that(Arrays.asList(foo, module))
         .processedWith(daggerProcessors())
         .compilesWithoutError();
   }
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/ScopeAnnotationUseTest.java b/compiler/src/test/java/dagger/tests/integration/validation/dagger1/ScopeAnnotationUseTest.java
similarity index 87%
rename from compiler/src/test/java/dagger/tests/integration/validation/ScopeAnnotationUseTest.java
rename to compiler/src/test/java/dagger/tests/integration/validation/dagger1/ScopeAnnotationUseTest.java
index 1d508657b..8895778ae 100644
--- a/compiler/src/test/java/dagger/tests/integration/validation/ScopeAnnotationUseTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/dagger1/ScopeAnnotationUseTest.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.tests.integration.validation;
+package dagger.tests.integration.validation.dagger1;
 
 import com.google.common.base.Joiner;
 import com.google.testing.compile.JavaFileObjects;
@@ -23,24 +23,24 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.ASSERT;
+import static com.google.common.truth.Truth.assert_;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
+import static dagger.tests.integration.dagger1.ProcessorTestUtils.daggerProcessors;
 import static java.util.Arrays.asList;
 
 /**
  * Integration tests for the validation processors related to the use
  * of Scoping Annotations.
  */
-// TODO(cgruber): Audit this class when http://github.com/google/compile-testing
+// TODO(user): Audit this class when http://github.com/google/compile-testing
 //                has error/warning counts and other warning predicates available.
 @RunWith(JUnit4.class)
 public class ScopeAnnotationUseTest {
   private static final String ABSTRACTION_SCOPING_TEXT =
       "Scoping annotations are only allowed on concrete types and @Provides methods:";
 
-  // TODO(cgruber): uncomment when http://github.com/google/compile-testing supports warnings.
+  // TODO(user): uncomment when http://github.com/google/compile-testing supports warnings.
   //private static final String MISUSED_SCOPE_TEXT =
   //    "Dagger will ignore scoping annotations on methods that are not @Provides methods:";
 
@@ -53,8 +53,8 @@
         "  @Inject public Test() { }",
         "}"));
 
-    // TODO(cgruber): uncomment when http://github.com/google/compile-testing has hasNoWarnings()
-    ASSERT.about(javaSource())
+    // TODO(user): uncomment when http://github.com/google/compile-testing has hasNoWarnings()
+    assert_().about(javaSource())
         .that(sourceFile).processedWith(daggerProcessors()).compilesWithoutError();
         //.and().hasNoWarnings();
   }
@@ -69,8 +69,8 @@
         "  @Provides @Singleton public String provideString() { return \"\"; }",
         "}"));
 
-    // TODO(cgruber): uncomment when http://github.com/google/compile-testing has hasNoWarnings()
-    ASSERT.about(javaSource())
+    // TODO(user): uncomment when http://github.com/google/compile-testing has hasNoWarnings()
+    assert_().about(javaSource())
         .that(sourceFile).processedWith(daggerProcessors()).compilesWithoutError();
         //.and().hasNoWarnings();
   }
@@ -83,8 +83,8 @@
         "  @Singleton void method() { }",
         "}"));
 
-    // TODO(cgruber): uncomment when http://github.com/google/compile-testing has hasNoWarnings()
-    ASSERT.about(javaSource())
+    // TODO(user): uncomment when http://github.com/google/compile-testing has hasNoWarnings()
+    assert_().about(javaSource())
         .that(sourceFile).processedWith(daggerProcessors()).compilesWithoutError();
         //.and().hasNoWarnings();
   }
@@ -97,8 +97,8 @@
         "  @Singleton void method() { }",
         "}"));
 
-    // TODO(cgruber): uncomment when http://github.com/google/compile-testing has hasNoWarnings()
-    ASSERT.about(javaSource())
+    // TODO(user): uncomment when http://github.com/google/compile-testing has hasNoWarnings()
+    assert_().about(javaSource())
         .that(sourceFile).processedWith(daggerProcessors()).compilesWithoutError();
         //.and().hasNoWarnings();
   }
@@ -110,8 +110,8 @@
         "  @Singleton void method() { }",
         "}"));
 
-    // TODO(cgruber): uncomment when http://github.com/google/compile-testing supports warnings.
-    ASSERT.about(javaSource())
+    // TODO(user): uncomment when http://github.com/google/compile-testing supports warnings.
+    assert_().about(javaSource())
         .that(sourceFile).processedWith(daggerProcessors()).compilesWithoutError();
         //.withWarningContaining(MISUSED_SCOPE_TEXT).in(sourceFile).onLine(3).atColumn(49).and()
         //.withWarningContaining("Test.method()").in(sourceFile).onLine(3).atColumn(49);
@@ -125,8 +125,8 @@
         "  @Singleton void method() { }",
         "}"));
 
-    // TODO(cgruber): uncomment when http://github.com/google/compile-testing supports warnings.
-    ASSERT.about(javaSource())
+    // TODO(user): uncomment when http://github.com/google/compile-testing supports warnings.
+    assert_().about(javaSource())
         .that(sourceFile).processedWith(daggerProcessors()).compilesWithoutError();
         //.withWarningContaining(MISUSED_SCOPE_TEXT).in(sourceFile).onLine(4).atColumn(49).and()
         //.withWarningContaining("Test.method()").in(sourceFile).onLine(4).atColumn(49);
@@ -141,7 +141,7 @@
         "  @Singleton interface TestType { }",
         "}"));
 
-    ASSERT.about(javaSource())
+    assert_().about(javaSource())
         .that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
         .withErrorContaining(ABSTRACTION_SCOPING_TEXT).in(sourceFile).onLine(5).atColumn(14).and()
         .withErrorContaining("Test.TestType").in(sourceFile).onLine(5).atColumn(14);
@@ -156,7 +156,7 @@
         "  @Singleton abstract class TestType { }",
         "}"));
 
-    ASSERT.about(javaSource())
+    assert_().about(javaSource())
         .that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
         .withErrorContaining(ABSTRACTION_SCOPING_TEXT).in(sourceFile).onLine(5).atColumn(23).and()
         .withErrorContaining("Test.TestType").in(sourceFile).onLine(5).atColumn(23);
@@ -173,7 +173,7 @@
         "  @Module(injects = Test.class) class TestModule { }",
         "}"));
 
-    ASSERT.about(javaSource())
+    assert_().about(javaSource())
         .that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
         .withErrorContaining(ABSTRACTION_SCOPING_TEXT).in(sourceFile).onLine(5).atColumn(21).and()
         .withErrorContaining("Test.field").in(sourceFile).onLine(5).atColumn(21);
@@ -190,7 +190,7 @@
         "  @Provides String provideString(@Singleton int intParam) { return \"\"; }",
         "}"));
 
-    ASSERT.about(javaSource())
+    assert_().about(javaSource())
         .that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
         .withErrorContaining(ABSTRACTION_SCOPING_TEXT).in(sourceFile).onLine(7).atColumn(49).and()
         .withErrorContaining("intParam").in(sourceFile).onLine(7).atColumn(49);
@@ -222,7 +222,7 @@
 
     String error = "Only one scoping annotation is allowed per element: ";
 
-    ASSERT.about(javaSources()).that(asList(annotation, module, injectable))
+    assert_().about(javaSources()).that(asList(annotation, module, injectable))
         .processedWith(daggerProcessors()).failsToCompile()
         .withErrorContaining(error + "MyModule.method()").in(module).onLine(6).atColumn(40).and()
         .withErrorContaining(error + "Injectable").in(injectable).onLine(4).atColumn(1);
@@ -242,11 +242,10 @@
         + "Singleton annotations have no effect on constructors. "
         + "Did you mean to annotate the class?";
 
-    ASSERT.about(javaSource())
+    assert_().about(javaSource())
         .that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
         .withErrorContaining(ABSTRACTION_SCOPING_TEXT).in(sourceFile).onLine(5).atColumn(29).and()
         .withErrorContaining("Test.Test()").in(sourceFile).onLine(5).atColumn(29).and()
         .withErrorContaining(singletonErrorText).in(sourceFile).onLine(6).atColumn(33);
   }
 }
-
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/SimpleMissingDependencyTest.java b/compiler/src/test/java/dagger/tests/integration/validation/dagger1/SimpleMissingDependencyTest.java
similarity index 89%
rename from compiler/src/test/java/dagger/tests/integration/validation/SimpleMissingDependencyTest.java
rename to compiler/src/test/java/dagger/tests/integration/validation/dagger1/SimpleMissingDependencyTest.java
index 4b58d28c8..0534ba42d 100644
--- a/compiler/src/test/java/dagger/tests/integration/validation/SimpleMissingDependencyTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/dagger1/SimpleMissingDependencyTest.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.tests.integration.validation;
+package dagger.tests.integration.validation.dagger1;
 
 import com.google.common.base.Joiner;
 import com.google.testing.compile.JavaFileObjects;
@@ -23,9 +23,9 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.ASSERT;
+import static com.google.common.truth.Truth.assert_;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
+import static dagger.tests.integration.dagger1.ProcessorTestUtils.daggerProcessors;
 
 @RunWith(JUnit4.class)
 public class SimpleMissingDependencyTest {
@@ -45,7 +45,7 @@
         "  }",
         "}"));
 
-    ASSERT.about(javaSource())
+    assert_().about(javaSource())
         .that(file).processedWith(daggerProcessors())
         .failsToCompile()
         .withErrorContaining("MissingDep$Dependency could not be bound").in(file).onLine(9).and()
diff --git a/core/src/main/java/dagger/Component.java b/core/src/main/java/dagger/Component.java
index cd676f142..abfc34880 100644
--- a/core/src/main/java/dagger/Component.java
+++ b/core/src/main/java/dagger/Component.java
@@ -30,7 +30,7 @@
  * {@code DaggerComponent_}.  For example, {@code @Component interface MyComponent {...}} will
  * produce an implementation named {@code DaggerComponent_MyComponent}.
  *
- * <h2>Component methods
+ * <h2>Component methods</h2>
  *
  * <p>Every type annotated with {@code @Component} must contain at least one abstract component
  * method. Component methods must either represent {@linkplain Provider provision} or
diff --git a/core/src/main/java/dagger/MapKey.java b/core/src/main/java/dagger/MapKey.java
new file mode 100644
index 000000000..06c3b65d9
--- /dev/null
+++ b/core/src/main/java/dagger/MapKey.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger;
+
+import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+/**
+ * It enables to define customized key type annotation for map binding by
+ * annotating an annotation of a {@code Map}'s key type. The defined key type
+ * annotation can be later applied to the key of the {@code Map}. Currently
+ * {@code String} and {@code enum} key types are supported for map binding.
+ *
+ * <h2>Example</h2> For example, if you want to define a key type annotation
+ * called StringKey, you can define it the following way:
+ *
+ * <pre><code>
+ *&#64;MapKey(unwrapValue = true)
+ *&#64;Retention(RUNTIME)
+ *public &#64;interface StringKey {
+ *String value();
+ *}
+ *</code></pre>
+ *
+ * if {@code unwrapValue} is false, then the whole annotation will be the key
+ * type for the map and annotation instances will be the keys. If
+ * {@code unwrapValue} is true, the value() type of key type annotation will be
+ * the key type for injected map and the value instances will be the keys.
+ */
+@Documented
+@Target(ANNOTATION_TYPE)
+@Retention(RUNTIME)
+public @interface MapKey {
+  /**
+   * if {@code unwrapValue} is false, then the whole annotation will be the type and annotation
+   * instances will be the keys. If {@code unwrapValue} is true, the value() type of key type
+   * annotation will be the key type for injected map and the value instances will be the keys.
+   * Currently only support {@code unwrapValue} to be true.
+   */
+  boolean unwrapValue();
+}
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index 6432c84e3..f9c84ae7b 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -29,12 +29,12 @@
 import dagger.internal.SetBinding;
 import dagger.internal.StaticInjection;
 import dagger.internal.ThrowingErrorHandler;
+import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 
-
 /**
  * A graph of objects linked by their dependencies.
  *
@@ -141,7 +141,7 @@ public static ObjectGraph createWith(Loader loader, Object... modules) {
     return DaggerObjectGraph.makeGraph(null, loader, modules);
   }
 
-  // TODO(cgruber): Move this internal implementation of ObjectGraph into the internal package.
+  // TODO(user): Move this internal implementation of ObjectGraph into the internal package.
   static class DaggerObjectGraph extends ObjectGraph {
     private final DaggerObjectGraph base;
     private final Linker linker;
@@ -325,7 +325,6 @@ private void linkInjectableTypes() {
     }
   }
 
-
   /**
    * A BindingsGroup which fails when existing values are clobbered and sets aside
    * {@link SetBinding}.
diff --git a/core/src/main/java/dagger/Provides.java b/core/src/main/java/dagger/Provides.java
index edcb27b64..df4ad904d 100644
--- a/core/src/main/java/dagger/Provides.java
+++ b/core/src/main/java/dagger/Provides.java
@@ -53,7 +53,15 @@
      * contributed to the set. An example use is to provide a default empty set binding, which is
      * otherwise not possible using {@link #SET}.
      */
-    SET_VALUES;
+    SET_VALUES,
+
+    /**
+     * The method's return type forms the type argument for the value of a
+     * {@code Map<K, Provider<V>>}, and the combination of the annotated key and the returned value
+     * is contributed to the map as a key/value pair. The {@code Map<K, Provider<V>>} produced from
+     * the accumulation of values will be immutable.
+     */
+    MAP;
   }
 
   Type type() default Type.UNIQUE;
diff --git a/core/src/main/java/dagger/internal/ArrayQueue.java b/core/src/main/java/dagger/internal/ArrayQueue.java
index 690b6d9e5..fbcc27e66 100644
--- a/core/src/main/java/dagger/internal/ArrayQueue.java
+++ b/core/src/main/java/dagger/internal/ArrayQueue.java
@@ -349,7 +349,6 @@ public boolean isEmpty() {
         return new QueueIterator();
     }
 
-
     private class QueueIterator implements Iterator<E> {
         /**
          * Index of element to be returned by subsequent call to next.
diff --git a/core/src/main/java/dagger/internal/BuiltInBinding.java b/core/src/main/java/dagger/internal/BuiltInBinding.java
index 0991c7a97..425c4ff94 100644
--- a/core/src/main/java/dagger/internal/BuiltInBinding.java
+++ b/core/src/main/java/dagger/internal/BuiltInBinding.java
@@ -15,7 +15,6 @@
  */
 package dagger.internal;
 
-
 /**
  * Injects a Provider or a MembersInjector.
  */
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index 5852e265b..e9cf9f4b6 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -217,9 +217,14 @@ private void assertLockHeld() {
     }
 
     String className = Keys.getClassName(key);
-    if (className == null || Keys.isAnnotated(key)) {
-      // Cannot jit-bind annotated keys or generic types.
-      throw new IllegalArgumentException(key);
+    if (className == null) {
+      throw new InvalidBindingException(key,
+          "is a generic class or an array and can only be bound with concrete type parameter(s) "
+          + "in a @Provides method.");
+    }
+    if (Keys.isAnnotated(key)) {
+      throw new InvalidBindingException(key,
+          "is a @Qualifier-annotated type and must be bound by a @Provides method.");
     }
     Binding<?> binding =
         plugin.getAtInjectBinding(key, className, classLoader, mustHaveInjections);
diff --git a/core/src/main/java/dagger/internal/Loader.java b/core/src/main/java/dagger/internal/Loader.java
index 35b5e6775..16e0e2322 100644
--- a/core/src/main/java/dagger/internal/Loader.java
+++ b/core/src/main/java/dagger/internal/Loader.java
@@ -18,7 +18,6 @@
 
 import java.lang.reflect.AccessibleObject;
 
-
 /**
  * Provides a point of configuration of the basic resolving functions within Dagger, namely
  * that of Module handling, injection binding creation, and static injection.  A plugin must
diff --git a/core/src/main/java/dagger/internal/MapFactory.java b/core/src/main/java/dagger/internal/MapFactory.java
new file mode 100644
index 000000000..10fd6169f
--- /dev/null
+++ b/core/src/main/java/dagger/internal/MapFactory.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import dagger.Factory;
+
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+
+import javax.inject.Provider;
+
+/**
+ * A {@link Factory} implementation used to implement {@link Map} bindings. This factory returns a
+ * {@code Map<K, V>} when calling {@link #get} (as specified by {@link Factory}).
+ *
+ * @author Chenying Hou
+ * @since 2.0
+ *
+ */
+public class MapFactory<K, V> implements Factory<Map<K, V>> {
+  private final Map<K, Provider<V>> contributingMap;
+  
+  private MapFactory(Map<K, Provider<V>> map) {
+    this.contributingMap = Collections.unmodifiableMap(map);
+  }
+
+  /**
+   * Returns a new MapFactory.
+   */
+  public static <K, V> MapFactory<K, V> create(Provider<Map<K, Provider<V>>> mapProviderFactory) {
+    Map<K, Provider<V>> map = mapProviderFactory.get();
+    return new MapFactory<K, V>(map);
+  }
+
+  /**
+   * Returns a {@code Map<K, V>} whose iteration order is that of the elements
+   * given by each of the providers, which are invoked in the order given at creation.
+   *
+   */
+  @Override
+  public Map<K, V> get() {
+    LinkedHashMap<K, V> result = new LinkedHashMap<K, V>();
+    for (Entry<K, Provider<V>> entry: contributingMap.entrySet()) {
+      result.put(entry.getKey(), entry.getValue().get());
+    }
+    return result;
+  }
+}
diff --git a/core/src/main/java/dagger/internal/MapProviderFactory.java b/core/src/main/java/dagger/internal/MapProviderFactory.java
new file mode 100644
index 000000000..5cc62c312
--- /dev/null
+++ b/core/src/main/java/dagger/internal/MapProviderFactory.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import dagger.Factory;
+
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+import javax.inject.Provider;
+
+/**
+ * A {@link Factory} implementation used to implement {@link Map} bindings. This factory returns a
+ * {@code Map<K, Provider<V>>} when calling {@link #get} (as specified by {@link Factory}).
+ *
+ * @author Chenying Hou
+ * @since 2.0
+ *
+ */
+public class MapProviderFactory<K, V> implements Factory<Map<K, Provider<V>>> {
+  private final Map<K, Provider<V>> contributingMap;
+
+  /**
+   * Returns a new {@link Builder}
+   */
+  public static <K, V> Builder<K, V> builder(int size) {
+    return new Builder<K, V>(size);
+  }
+
+  private MapProviderFactory(LinkedHashMap<K, Provider<V>> contributingMap) {
+    this.contributingMap = Collections.unmodifiableMap(contributingMap);
+  }
+
+  /**
+   * Returns a {@code Map<K, Provider<V>>} whose iteration order is that of the elements
+   * given by each of the providers, which are invoked in the order given at creation.
+   *
+   */
+  @Override
+  public Map<K, Provider<V>> get() {
+    return this.contributingMap;
+  }
+
+  /**
+   * A builder to help build the {@link MapProviderFactory}
+   */
+  public static class Builder<K, V> {
+    private final LinkedHashMap<K, Provider<V>> mapBuilder;
+
+    private Builder(int size) {
+      // TODO(user): consider which way to initialize mapBuilder is better
+      this.mapBuilder = newLinkedHashMapWithExpectedSize(size);
+    }
+
+    /**
+     * Returns a new {@link MapProviderFactory}
+     */
+    public MapProviderFactory<K, V> build() {
+      return new MapProviderFactory<K, V>(this.mapBuilder);
+    }
+
+    /**
+     * Associate k with providerOfValue in {@code Builder}
+     */
+    public Builder<K, V> put(K key, Provider<V> providerOfValue) {
+      if (key == null) {
+        throw new NullPointerException("The key is null");
+      }
+      if (providerOfValue == null) {
+        throw new NullPointerException("The provider of the value is null");
+      }
+
+      this.mapBuilder.put(key, providerOfValue);
+      return this;
+    }
+
+    private static <K, V> LinkedHashMap<K, Provider<V>> newLinkedHashMapWithExpectedSize(
+        int expectedSize) {
+      if (expectedSize < 0) {
+        throw new IllegalArgumentException("The expected size of map cannot be negative.");
+      }
+      int initialCapacity = (expectedSize < 3) ? expectedSize + 1
+          : (expectedSize < (1 << (Integer.SIZE - 2))) ? expectedSize + expectedSize / 3
+              : Integer.MAX_VALUE;
+      return new LinkedHashMap<K, Provider<V>>(initialCapacity);
+    }
+  }
+}
diff --git a/core/src/main/java/dagger/internal/ModuleAdapter.java b/core/src/main/java/dagger/internal/ModuleAdapter.java
index 2986ad66a..ba7bc7062 100644
--- a/core/src/main/java/dagger/internal/ModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/ModuleAdapter.java
@@ -16,7 +16,6 @@
  */
 package dagger.internal;
 
-
 /**
  * Extracts bindings from an {@code @Module}-annotated class.
  */
diff --git a/core/src/main/java/dagger/internal/ReflectiveLoader.java b/core/src/main/java/dagger/internal/ReflectiveLoader.java
index 0272bf4b8..4d20522a0 100644
--- a/core/src/main/java/dagger/internal/ReflectiveLoader.java
+++ b/core/src/main/java/dagger/internal/ReflectiveLoader.java
@@ -16,7 +16,6 @@
  */
 package dagger.internal;
 
-
 import dagger.internal.loaders.ReflectiveAtInjectBinding;
 import dagger.internal.loaders.ReflectiveModuleAdapter;
 import dagger.internal.loaders.ReflectiveStaticInjection;
diff --git a/core/src/main/java/dagger/internal/ScopedProvider.java b/core/src/main/java/dagger/internal/ScopedProvider.java
index be7a00148..90a679a90 100644
--- a/core/src/main/java/dagger/internal/ScopedProvider.java
+++ b/core/src/main/java/dagger/internal/ScopedProvider.java
@@ -25,30 +25,30 @@
  * @since 2.0
  */
 public final class ScopedProvider<T> implements Provider<T> {
+  private static final Object UNINITIALIZED = new Object();
+
   private final Factory<T> factory;
-  private volatile T instance = null;
+  private volatile Object instance = UNINITIALIZED;
 
   private ScopedProvider(Factory<T> factory) {
     assert factory != null;
     this.factory = factory;
   }
 
+  @SuppressWarnings("unchecked") // cast only happens when result comes from the factory
   @Override
   public T get() {
     // double-check idiom from EJ2: Item 71
-    T result = instance;
-    if (result == null) {
+    Object result = instance;
+    if (result == UNINITIALIZED) {
       synchronized (this) {
         result = instance;
-        if (result == null) {
+        if (result == UNINITIALIZED) {
           instance = result = factory.get();
-          if (result == null) {
-            throw new NullPointerException(factory + " returned null");
-          }
         }
       }
     }
-    return result;
+    return (T) result;
   }
 
   /** Returns a new scoped provider for the given factory. */
diff --git a/core/src/main/java/dagger/internal/StaticInjection.java b/core/src/main/java/dagger/internal/StaticInjection.java
index 92a73a48a..d9399a37a 100644
--- a/core/src/main/java/dagger/internal/StaticInjection.java
+++ b/core/src/main/java/dagger/internal/StaticInjection.java
@@ -16,7 +16,6 @@
  */
 package dagger.internal;
 
-
 /**
  * Injects the static fields of a class.
  */
diff --git a/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java b/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java
index 72a825aaf..3c126898b 100644
--- a/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java
+++ b/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java
@@ -16,7 +16,6 @@
  */
 package dagger.internal.loaders;
 
-
 /**
  * A single point for API used in common by Adapters and Adapter generators
  */
diff --git a/core/src/main/java/dagger/internal/loaders/ReflectiveModuleAdapter.java b/core/src/main/java/dagger/internal/loaders/ReflectiveModuleAdapter.java
index a9c28bada..a37ebb791 100644
--- a/core/src/main/java/dagger/internal/loaders/ReflectiveModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/loaders/ReflectiveModuleAdapter.java
@@ -36,7 +36,6 @@
 import javax.inject.Provider;
 import javax.inject.Singleton;
 
-
 /**
  * @deprecated this is in place to temporarily support obfuscation needs and
  *     will not exist as of Dagger 2.0
diff --git a/core/src/test/java/dagger/InjectionTest.java b/core/src/test/java/dagger/InjectionTest.java
index ef5b275fe..884c43928 100644
--- a/core/src/test/java/dagger/InjectionTest.java
+++ b/core/src/test/java/dagger/InjectionTest.java
@@ -121,7 +121,6 @@
     assertThat(entryPoint.aProvider.get()).isNotSameAs(entryPoint.aProvider.get());
   }
 
-
   @Test public void singletons() {
     class TestEntryPoint {
       @Inject Provider<F> fProvider;
diff --git a/core/src/test/java/dagger/MembersInjectorTest.java b/core/src/test/java/dagger/MembersInjectorTest.java
index 5a0197f20..f8abe0de9 100644
--- a/core/src/test/java/dagger/MembersInjectorTest.java
+++ b/core/src/test/java/dagger/MembersInjectorTest.java
@@ -83,7 +83,6 @@
     assertThat(object.injected).isEqualTo("injected");
   }
 
-
   @Test public void injectionOfUnconstructableFails() {
     class TestEntryPoint {
       @Inject Unconstructable unconstructable;
diff --git a/core/src/test/java/dagger/SetBindingTest.java b/core/src/test/java/dagger/SetBindingTest.java
index 6a029060a..4474d217a 100644
--- a/core/src/test/java/dagger/SetBindingTest.java
+++ b/core/src/test/java/dagger/SetBindingTest.java
@@ -171,7 +171,7 @@
     assertEquals(set("string4", "string3"), ep.fooStrings);
   }
 
-  // TODO(cgruber): Move this into an example project.
+  // TODO(user): Move this into an example project.
   @Test public void sampleMultiBindingLogger() {
     class TestEntryPoint {
       @Inject Logger logger;
diff --git a/core/src/test/java/dagger/ThreadSafetyTest.java b/core/src/test/java/dagger/ThreadSafetyTest.java
index ba4986d73..a92d4c51a 100644
--- a/core/src/test/java/dagger/ThreadSafetyTest.java
+++ b/core/src/test/java/dagger/ThreadSafetyTest.java
@@ -45,7 +45,6 @@
   private final ExecutorService es = Executors.newFixedThreadPool(THREAD_COUNT);
   private final CountDownLatch latch = new CountDownLatch(THREAD_COUNT + 1);
 
-
   static class LazyEntryPoint {
     @Inject Lazy<Integer> lazy;
   }
diff --git a/core/src/test/java/dagger/internal/DoubleCheckLazyTest.java b/core/src/test/java/dagger/internal/DoubleCheckLazyTest.java
index 8cec447bd..01790c787 100644
--- a/core/src/test/java/dagger/internal/DoubleCheckLazyTest.java
+++ b/core/src/test/java/dagger/internal/DoubleCheckLazyTest.java
@@ -32,8 +32,8 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+import static com.google.common.truth.Truth.assert_;
 import static org.junit.Assert.fail;
-import static org.truth0.Truth.ASSERT;
 
 @RunWith(JUnit4.class)
 public class DoubleCheckLazyTest {
@@ -57,12 +57,12 @@
 
     List<Future<Object>> futures = executor.invokeAll(tasks);
 
-    ASSERT.that(provider.provisions.get()).is(1);
+    assert_().that(provider.provisions.get()).is(1);
     Set<Object> results = Sets.newIdentityHashSet();
     for (Future<Object> future : futures) {
       results.add(future.get());
     }
-    ASSERT.that(results.size()).is(1);
+    assert_().that(results.size()).is(1);
   }
 
   @Test public void get_null() {
diff --git a/core/src/test/java/dagger/internal/InstanceFactoryTest.java b/core/src/test/java/dagger/internal/InstanceFactoryTest.java
index 4bc273caf..dd8b1e2df 100644
--- a/core/src/test/java/dagger/internal/InstanceFactoryTest.java
+++ b/core/src/test/java/dagger/internal/InstanceFactoryTest.java
@@ -22,7 +22,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static org.truth0.Truth.ASSERT;
+import static com.google.common.truth.Truth.assert_;
 
 @RunWith(JUnit4.class)
 public final class InstanceFactoryTest {
@@ -31,9 +31,9 @@
   @Test public void instanceFactory() {
     Object instance = new Object();
     Factory<Object> factory = InstanceFactory.create(instance);
-    ASSERT.that(factory.get()).is(instance);
-    ASSERT.that(factory.get()).is(instance);
-    ASSERT.that(factory.get()).is(instance);
+    assert_().that(factory.get()).isEqualTo(instance);
+    assert_().that(factory.get()).isEqualTo(instance);
+    assert_().that(factory.get()).isEqualTo(instance);
   }
 
   @Test public void create_throwsNullPointerException() {
diff --git a/core/src/test/java/dagger/internal/MapProviderFactoryTest.java b/core/src/test/java/dagger/internal/MapProviderFactoryTest.java
new file mode 100644
index 000000000..e14402172
--- /dev/null
+++ b/core/src/test/java/dagger/internal/MapProviderFactoryTest.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import dagger.Factory;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicInteger;
+import javax.inject.Provider;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assert_;
+
+@RunWith(JUnit4.class)
+@SuppressWarnings("unchecked")
+public class MapProviderFactoryTest {
+  @Rule
+  public ExpectedException thrown = ExpectedException.none();
+
+  @Test
+  public void nullKey() {
+    thrown.expect(NullPointerException.class);
+    MapProviderFactory.<String, Integer>builder(1).put(null, incrementingIntegerProvider(1));
+  }
+
+  @Test
+  public void nullValue() {
+    thrown.expect(NullPointerException.class);
+    MapProviderFactory.<String, Integer>builder(1).put("Hello", null);
+  }
+
+  @Test
+  public void iterationOrder() {
+    Provider<Integer> p1 = incrementingIntegerProvider(10);
+    Provider<Integer> p2 = incrementingIntegerProvider(20);
+    Provider<Integer> p3 = incrementingIntegerProvider(30);
+    Provider<Integer> p4 = incrementingIntegerProvider(40);
+    Provider<Integer> p5 = incrementingIntegerProvider(50);
+
+    Factory<Map<String, Provider<Integer>>> factory = MapProviderFactory
+        .<String, Integer>builder(4)
+        .put("two", p2)
+        .put("one", p1)
+        .put("three", p3)
+        .put("one", p5)
+        .put("four", p4)
+        .build();
+
+    Map<String, Provider<Integer>> expectedMap = new LinkedHashMap<String, Provider<Integer>>();
+    expectedMap.put("two", p2);
+    expectedMap.put("one", p1);
+    expectedMap.put("three", p3);
+    expectedMap.put("one", p5);
+    expectedMap.put("four", p4);
+    assert_().that(factory.get().entrySet()).iteratesAs(expectedMap.entrySet());
+  }
+
+  private static Provider<Integer> incrementingIntegerProvider(int seed) {
+    final AtomicInteger value = new AtomicInteger(seed);
+    return new Provider<Integer>() {
+      @Override
+      public Integer get() {
+        return value.getAndIncrement();
+      }
+    };
+  }
+}
diff --git a/core/src/test/java/dagger/internal/ScopedProviderTest.java b/core/src/test/java/dagger/internal/ScopedProviderTest.java
index dd330339e..30cdd4121 100644
--- a/core/src/test/java/dagger/internal/ScopedProviderTest.java
+++ b/core/src/test/java/dagger/internal/ScopedProviderTest.java
@@ -17,12 +17,13 @@
 
 import dagger.Factory;
 import javax.inject.Provider;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+import static com.google.common.truth.Truth.assert_;
 import static org.junit.Assert.fail;
-import static org.truth0.Truth.ASSERT;
 
 /**
  * Tests {@link ScopedProvider}.
@@ -36,7 +37,8 @@
     } catch (NullPointerException expected) { }
   }
 
-  @Test public void get_nullPointerException() {
+  // TODO(gak): reenable this test once we can ensure that factories are no longer providing null
+  @Ignore @Test public void get_nullPointerException() {
     Provider<Object> scopedProvider = ScopedProvider.create(new Factory<Object>() {
       @Override public Object get() {
         return null;
@@ -57,8 +59,8 @@
         return i++;
       }
     });
-    ASSERT.that(scopedProvider.get()).is(0);
-    ASSERT.that(scopedProvider.get()).is(0);
-    ASSERT.that(scopedProvider.get()).is(0);
+    assert_().that(scopedProvider.get()).is(0);
+    assert_().that(scopedProvider.get()).is(0);
+    assert_().that(scopedProvider.get()).is(0);
   }
 }
diff --git a/core/src/test/java/dagger/internal/SetFactoryTest.java b/core/src/test/java/dagger/internal/SetFactoryTest.java
index f5e3ccb5e..8f2df0c81 100644
--- a/core/src/test/java/dagger/internal/SetFactoryTest.java
+++ b/core/src/test/java/dagger/internal/SetFactoryTest.java
@@ -30,7 +30,7 @@
 import org.junit.runners.JUnit4;
 
 import static com.google.common.collect.DiscreteDomain.integers;
-import static org.truth0.Truth.ASSERT;
+import static com.google.common.truth.Truth.assert_;
 
 @RunWith(JUnit4.class)
 @SuppressWarnings("unchecked")
@@ -94,9 +94,9 @@ public void invokesProvidersEverytTime() {
         incrementingIntegerProvider(0),
         incrementingIntegerProvider(10),
         incrementingIntegerProvider(20));
-    ASSERT.that(factory.get()).has().exactly(0, 10, 20);
-    ASSERT.that(factory.get()).has().exactly(1, 11, 21);
-    ASSERT.that(factory.get()).has().exactly(2, 12, 22);
+    assert_().that(factory.get()).has().exactly(0, 10, 20);
+    assert_().that(factory.get()).has().exactly(1, 11, 21);
+    assert_().that(factory.get()).has().exactly(2, 12, 22);
   }
 
   @Test
@@ -105,7 +105,7 @@ public void iterationOrder() {
         integerSetProvider(Range.closed(5, 9)),
         integerSetProvider(Range.closed(3, 6)),
         integerSetProvider(Range.closed(0, 5)));
-    ASSERT.that(factory.get()).iteratesAs(5, 6, 7, 8, 9, 3, 4, 0, 1, 2);
+    assert_().that(factory.get()).iteratesAs(5, 6, 7, 8, 9, 3, 4, 0, 1, 2);
   }
 
   private static Provider<Set<Integer>> incrementingIntegerProvider(int seed) {
diff --git a/core/src/test/java/dagger/internal/TestingLoader.java b/core/src/test/java/dagger/internal/TestingLoader.java
index 0767446a6..fd2996d1e 100644
--- a/core/src/test/java/dagger/internal/TestingLoader.java
+++ b/core/src/test/java/dagger/internal/TestingLoader.java
@@ -16,7 +16,6 @@
  */
 package dagger.internal;
 
-
 import dagger.internal.loaders.ReflectiveAtInjectBinding;
 import dagger.internal.loaders.ReflectiveStaticInjection;
 
diff --git a/pom.xml b/pom.xml
index 615a0cea0..71cd67042 100644
--- a/pom.xml
+++ b/pom.xml
@@ -46,7 +46,8 @@
     <javawriter.version>2.5.0</javawriter.version>
     <auto.common.version>1.0-SNAPSHOT</auto.common.version>
     <auto.service.version>1.0-rc1</auto.service.version>
-    <guava.version>17.0</guava.version>
+    <auto.value.version>1.0-SNAPSHOT</auto.value.version>
+    <guava.version>18.0</guava.version>
 
     <!-- Test Dependencies -->
     <compile-testing.version>0.6-SNAPSHOT</compile-testing.version>
@@ -112,6 +113,11 @@
         <artifactId>auto-service</artifactId>
         <version>${auto.service.version}</version>
       </dependency>
+      <dependency>
+        <groupId>com.google.auto.value</groupId>
+        <artifactId>auto-value</artifactId>
+        <version>${auto.value.version}</version>
+      </dependency>
       <dependency>
         <groupId>junit</groupId>
         <artifactId>junit</artifactId>
