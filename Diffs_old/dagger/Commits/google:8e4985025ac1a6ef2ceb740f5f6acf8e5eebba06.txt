diff --git a/compiler/pom.xml b/compiler/pom.xml
index 0d8691a9d..68ac8360d 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.2.1-SNAPSHOT</version>
+    <version>2.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>dagger-compiler</artifactId>
diff --git a/compiler/src/main/java/dagger/internal/codegen/Binding.java b/compiler/src/main/java/dagger/internal/codegen/Binding.java
index dc3641ff1..2b690f6ef 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Binding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Binding.java
@@ -16,7 +16,7 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.MoreElements;
-import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSetMultimap;
 
 import javax.lang.model.element.Element;
@@ -32,6 +32,8 @@
  * @author Gregory Kick
  * @since 2.0
  */
+// TODO(gak): make a decision about whether or not to bring MembersInjectionBinding under this
+// supertype or whether to just get rid of this.
 abstract class Binding {
   /** Returns the {@link Element} instance that is responsible for declaring the binding. */
   abstract Element bindingElement();
@@ -51,12 +53,8 @@ public TypeElement visitType(TypeElement e, Void p) {
     }, null);
   }
 
-  /**
-   * The set of {@link DependencyRequest dependencies} required to satisfy this binding. For fields
-   * this will be a single element for the field and for methods this will be an element for each of
-   * the method parameters.
-   */
-  abstract ImmutableSet<DependencyRequest> dependencies();
+  /** The list of {@link DependencyRequest dependencies} required to satisfy this binding. */
+  abstract ImmutableList<DependencyRequest> dependencies();
 
   /** Returns the {@link #dependencies()} indexed by {@link Key}. */
   ImmutableSetMultimap<Key, DependencyRequest> dependenciesByKey() {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 07d85ebc7..a59c45a79 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -16,24 +16,30 @@
 package dagger.internal.codegen;
 
 import static dagger.internal.codegen.AnnotationMirrors.getAnnotationMirror;
+import static dagger.internal.codegen.DependencyRequest.Kind.MEMBERS_INJECTOR;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.LinkedHashMultimap;
+import com.google.common.collect.Maps;
 import com.google.common.collect.Queues;
 import com.google.common.collect.SetMultimap;
 import com.google.common.collect.Sets;
 
 import dagger.Component;
+import dagger.MembersInjector;
 import dagger.Module;
 import dagger.Provides;
 
 import java.util.Deque;
 import java.util.LinkedHashSet;
 import java.util.List;
+import java.util.Map;
 import java.util.Queue;
 
 import javax.lang.model.element.AnnotationMirror;
@@ -61,18 +67,10 @@
   abstract TypeElement componentDefinitionType();
 
   /**
-   * The set of {@linkplain DependencyRequest dependency requests} representing  the provision
-   * methods in the component definition.  To access the method element itself, use
-   * {@link DependencyRequest#requestElement()}.
+   * The list of {@link DependencyRequest} instances whose sources are methods on the component
+   * definition type.  These are the user-requested dependencies.
    */
-  abstract ImmutableSet<DependencyRequest> provisionRequests();
-
-  /**
-   * The set of {@linkplain DependencyRequest dependency requests} representing the members
-   * injection methods in the component definition.  To access the method element itself, use
-   * {@link DependencyRequest#requestElement()}.
-   */
-  abstract ImmutableSet<DependencyRequest> membersInjectionRequests();
+  abstract ImmutableList<DependencyRequest> interfaceRequests();
 
   /**
    * The total set of modules (those declared in {@link Component#modules} and their transitive
@@ -81,10 +79,24 @@
   abstract ImmutableSet<TypeElement> moduleDependencies();
 
   /**
-   * Returns the mapping from {@link Key} to {@link ProvisionBinding} that represents the full
-   * adjacency matrix for the object graph.
+   * Returns the mapping from {@link Key} to {@link ProvisionBinding} that
+   * (with {@link #resolvedMembersInjectionBindings}) represents the full adjacency matrix for the
+   * object graph.
+   */
+  abstract ImmutableSetMultimap<Key, ProvisionBinding> resolvedProvisionBindings();
+
+  /**
+   * Returns the mapping from {@link Key} to {@link MembersInjectionBinding} that
+   * (with {@link #resolvedProvisionBindings}) represents the full adjacency matrix for the object
+   * graph.
    */
-  abstract ImmutableSetMultimap<Key, ProvisionBinding> resolvedBindings();
+  abstract ImmutableMap<Key, MembersInjectionBinding> resolvedMembersInjectionBindings();
+
+  /**
+   * The ordering of {@link Key keys} that will allow all of the {@link Factory} and
+   * {@link MembersInjector} implementations to initialize properly.
+   */
+  abstract ImmutableList<Key> initializationOrdering();
 
   static final class Factory {
     private final Elements elements;
@@ -148,9 +160,7 @@ ComponentDescriptor create(TypeElement componentDefinitionType) {
 
       ImmutableSetMultimap<Key, ProvisionBinding> explicitBindings = bindingIndexBuilder.build();
 
-      ImmutableSet.Builder<DependencyRequest> provisionRequestsBuilder = ImmutableSet.builder();
-      ImmutableSet.Builder<DependencyRequest> membersInjectionRequestsBuilder =
-          ImmutableSet.builder();
+      ImmutableList.Builder<DependencyRequest> interfaceRequestsBuilder = ImmutableList.builder();
 
       Deque<DependencyRequest> requestsToResolve = Queues.newArrayDeque();
 
@@ -163,13 +173,15 @@ ComponentDescriptor create(TypeElement componentDefinitionType) {
               // provision method
               DependencyRequest provisionRequest =
                   dependencyRequestFactory.forComponentProvisionMethod(componentMethod);
-              provisionRequestsBuilder.add(provisionRequest);
+              interfaceRequestsBuilder.add(provisionRequest);
               requestsToResolve.addLast(provisionRequest);
               break;
             case 1:
               // members injection method
-              membersInjectionRequestsBuilder.add(
-                  dependencyRequestFactory.forComponentMembersInjectionMethod(componentMethod));
+              DependencyRequest membersInjectionRequest =
+                  dependencyRequestFactory.forComponentMembersInjectionMethod(componentMethod);
+              interfaceRequestsBuilder.add(membersInjectionRequest);
+              requestsToResolve.addLast(membersInjectionRequest);
               break;
             default:
               throw new IllegalStateException();
@@ -177,41 +189,59 @@ ComponentDescriptor create(TypeElement componentDefinitionType) {
         }
       }
 
-      SetMultimap<Key, ProvisionBinding> resolvedBindings = LinkedHashMultimap.create();
+      SetMultimap<Key, ProvisionBinding> resolvedProvisionBindings = LinkedHashMultimap.create();
+      Map<Key, MembersInjectionBinding> resolvedMembersInjectionBindings = Maps.newLinkedHashMap();
+      // TODO(gak): we're really going to need to test this ordering
+      ImmutableSet.Builder<Key> resolutionOrder = ImmutableSet.builder();
 
       for (DependencyRequest requestToResolve = requestsToResolve.pollLast();
           requestToResolve != null;
           requestToResolve = requestsToResolve.pollLast()) {
         Key key = requestToResolve.key();
-        if (!resolvedBindings.containsKey(key)) {
-          ImmutableSet<ProvisionBinding> explicitBindingsForKey = explicitBindings.get(key);
-          if (explicitBindingsForKey.isEmpty()) {
-            Optional<ProvisionBinding> injectBinding =
-                injectBindingRegistry.getBindingForKey(key);
-            if (injectBinding.isPresent()) {
-              requestsToResolve.addAll(injectBinding.get().dependencies());
-              resolvedBindings.put(key, injectBinding.get());
+        if (requestToResolve.kind().equals(MEMBERS_INJECTOR)) {
+          if (!resolvedMembersInjectionBindings.containsKey(key)) {
+            Optional<MembersInjectionBinding> binding =
+                injectBindingRegistry.getMembersInjectionBindingForKey(key);
+            if (binding.isPresent()) {
+              requestsToResolve.addAll(binding.get().dependencySet());
+              resolvedMembersInjectionBindings.put(key, binding.get());
             } else {
-              // TODO(gak): generate a factory for an @Inject dependency that wasn't run with the
-              // processor
-              throw new UnsupportedOperationException("@Injected classes that weren't run with the "
-                  + "compoenent processor are (briefly) unsupported.");
+              // check and generate.
             }
-          } else {
-            resolvedBindings.putAll(key, explicitBindingsForKey);
           }
-          for (ProvisionBinding binding : explicitBindingsForKey) {
-            requestsToResolve.addAll(binding.dependencies());
+        } else { // all other requests are provision requests
+          if (!resolvedProvisionBindings.containsKey(key)) {
+            ImmutableSet<ProvisionBinding> explicitBindingsForKey = explicitBindings.get(key);
+            if (explicitBindingsForKey.isEmpty()) {
+              Optional<ProvisionBinding> injectBinding =
+                  injectBindingRegistry.getProvisionBindingForKey(key);
+              if (injectBinding.isPresent()) {
+                requestsToResolve.addAll(injectBinding.get().dependencies());
+                resolvedProvisionBindings.put(key, injectBinding.get());
+              } else {
+                // TODO(gak): support this
+                throw new UnsupportedOperationException(
+                    "@Injected classes that weren't run with the compoenent processor are "
+                    + "(briefly) unsupported: " + key);
+              }
+            } else {
+              resolvedProvisionBindings.putAll(key, explicitBindingsForKey);
+            }
+            for (ProvisionBinding binding : explicitBindingsForKey) {
+              requestsToResolve.addAll(binding.dependencies());
+            }
           }
         }
+        resolutionOrder.add(key);
       }
 
       return new AutoValue_ComponentDescriptor(
           componentDefinitionType,
-          provisionRequestsBuilder.build(),
-          membersInjectionRequestsBuilder.build(),
+          interfaceRequestsBuilder.build(),
           moduleTypes,
-          ImmutableSetMultimap.copyOf(resolvedBindings));
+          ImmutableSetMultimap.copyOf(resolvedProvisionBindings),
+          ImmutableMap.copyOf(resolvedMembersInjectionBindings),
+          resolutionOrder.build().asList().reverse());
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 630b8f16a..a0d4c9909 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -16,19 +16,24 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.Preconditions.checkNotNull;
 import static com.squareup.javawriter.JavaWriter.stringLiteral;
 import static dagger.Provides.Type.SET;
 import static dagger.Provides.Type.SET_VALUES;
+import static dagger.internal.codegen.DependencyRequest.Kind.MEMBERS_INJECTOR;
 import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.SourceFiles.collectImportsFromDependencies;
 import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
 import static dagger.internal.codegen.SourceFiles.flattenVariableMap;
+import static dagger.internal.codegen.SourceFiles.generateMembersInjectorNamesForBindings;
 import static dagger.internal.codegen.SourceFiles.generateProviderNamesForBindings;
+import static dagger.internal.codegen.SourceFiles.membersInjectorNameForMembersInjectionBinding;
 import static dagger.internal.codegen.SourceFiles.providerUsageStatement;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.type.TypeKind.VOID;
 
 import com.google.common.base.CaseFormat;
 import com.google.common.base.Function;
@@ -36,10 +41,10 @@
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
 import com.google.common.collect.Collections2;
-import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableBiMap;
 import com.google.common.collect.ImmutableCollection;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.ImmutableSortedSet;
@@ -50,6 +55,7 @@
 import com.squareup.javawriter.JavaWriter;
 
 import dagger.Component;
+import dagger.MembersInjector;
 import dagger.internal.SetFactory;
 
 import java.io.IOException;
@@ -64,7 +70,13 @@
 import javax.inject.Provider;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.Name;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
 /**
  * Generates the implementation of the abstract types annotated with {@link Component}.
@@ -73,11 +85,13 @@
  * @since 2.0
  */
 final class ComponentGenerator extends SourceFileGenerator<ComponentDescriptor> {
-  private final ProviderTypeRepository providerTypeRepository;
+  private final Elements elements;
+  private final Types types;
 
-  ComponentGenerator(Filer filer, ProviderTypeRepository providerTypeRepository) {
+  ComponentGenerator(Filer filer, Elements elements, Types types) {
     super(filer);
-    this.providerTypeRepository = providerTypeRepository;
+    this.elements = checkNotNull(elements);
+    this.types = checkNotNull(types);
   }
 
   @Override
@@ -103,16 +117,22 @@ void write(ClassName componentName, JavaWriter writer, ComponentDescriptor input
       throws IOException {
     writer.emitPackage(componentName.packageName());
 
-    writeImports(writer, componentName, input.provisionRequests(),
-        input.resolvedBindings().values());
+    writeImports(writer, componentName, input.interfaceRequests(),
+        input.resolvedProvisionBindings().values());
 
     writer.emitAnnotation(Generated.class, stringLiteral(ComponentProcessor.class.getName()));
     writer.beginType(componentName.simpleName(), "class", EnumSet.of(PUBLIC, FINAL), null,
         input.componentDefinitionType().getQualifiedName().toString());
 
-    ImmutableSetMultimap<Key, ProvisionBinding> resolvedBindings = input.resolvedBindings();
+    ImmutableSetMultimap<Key, ProvisionBinding> resolvedProvisionBindings =
+        input.resolvedProvisionBindings();
+    ImmutableMap<Key, MembersInjectionBinding> resolvedMembersInjectionBindings =
+        input.resolvedMembersInjectionBindings();
 
-    ImmutableBiMap<Key, String> providerNames = generateProviderNamesForBindings(resolvedBindings);
+    ImmutableBiMap<Key, String> providerNames =
+        generateProviderNamesForBindings(resolvedProvisionBindings);
+    ImmutableBiMap<Key, String> membersInjectorNames =
+        generateMembersInjectorNamesForBindings(resolvedMembersInjectionBindings);
 
     ImmutableBiMap<TypeElement, String> moduleNames =
         ImmutableBiMap.copyOf(Maps.asMap(input.moduleDependencies(), Functions.compose(
@@ -125,20 +145,22 @@ void write(ClassName componentName, JavaWriter writer, ComponentDescriptor input
 
     writeModuleFields(writer, moduleNames);
     writeProviderFields(writer, providerNames);
+    writeMembersInjectorFields(writer, membersInjectorNames);
 
-    writeConstructor(writer, resolvedBindings, providerNames, moduleNames);
+    writeConstructor(writer, input.initializationOrdering(), resolvedProvisionBindings,
+        resolvedMembersInjectionBindings, providerNames, moduleNames, membersInjectorNames);
 
-    writeProvisionMethods(writer, input.provisionRequests(), providerNames);
+    writeInterfaceMethods(writer, input.interfaceRequests(), providerNames, membersInjectorNames);
 
     writer.endType();
   }
 
   private void writeImports(JavaWriter writer, ClassName factoryClassName,
-      ImmutableSet<DependencyRequest> provisionRequests,
+      ImmutableList<DependencyRequest> interfaceRequests,
       ImmutableCollection<ProvisionBinding> bindings) throws IOException {
     ImmutableSortedSet.Builder<ClassName> importsBuilder =
         ImmutableSortedSet.<ClassName>naturalOrder()
-            .addAll(collectImportsFromDependencies(factoryClassName, provisionRequests))
+            .addAll(collectImportsFromDependencies(factoryClassName, interfaceRequests))
             .add(ClassName.fromClass(Generated.class))
             .add(ClassName.fromClass(Provider.class));
     for (ProvisionBinding binding : bindings) {
@@ -177,10 +199,25 @@ private void writeProviderFields(JavaWriter writer, ImmutableBiMap<Key, String>
     writer.emitEmptyLine();
   }
 
+  private void writeMembersInjectorFields(JavaWriter writer,
+      ImmutableBiMap<Key, String> membersInjectorNames) throws IOException {
+    for (Entry<Key, String> providerEntry : membersInjectorNames.entrySet()) {
+      Key key = providerEntry.getKey();
+      // TODO(gak): provide more elaborate information about which requests relate
+      writer.emitJavadoc(key.toString())
+          .emitField(membersInjectorTypeString(key), providerEntry.getValue(),
+              EnumSet.of(PRIVATE, FINAL));
+    }
+    writer.emitEmptyLine();
+  }
+
   private void writeConstructor(final JavaWriter writer,
-      ImmutableSetMultimap<Key, ProvisionBinding> resolvedBindings,
+      ImmutableList<Key> initializationOrdering,
+      ImmutableSetMultimap<Key, ProvisionBinding> resolvedProvisionBindings,
+      ImmutableMap<Key, MembersInjectionBinding> resolvedMembersInjectionBindings,
       ImmutableBiMap<Key, String> providerNames,
-      ImmutableBiMap<TypeElement, String> moduleNames)
+      ImmutableBiMap<TypeElement, String> moduleNames,
+      ImmutableBiMap<Key, String> membersInjectorNames)
           throws IOException {
     Map<String, String> variableMap =
         Maps.transformValues(moduleNames.inverse(), new Function<TypeElement, String>() {
@@ -199,23 +236,34 @@ public String apply(TypeElement input) {
       writer.emitStatement("this.%1$s = %1$s", variableName);
     }
 
-    for (Entry<String, Key> providerFieldEntry
-        : Lists.reverse(providerNames.inverse().entrySet().asList())) {
-      Set<ProvisionBinding> bindings = resolvedBindings.get(providerFieldEntry.getValue());
-      if (ProvisionBinding.isSetBindingCollection(bindings)) {
-        ImmutableList.Builder<String> setFactoryParameters = ImmutableList.builder();
-        for (ProvisionBinding binding : bindings) {
-          setFactoryParameters.add(
-              initializeFactoryForBinding(writer, binding, moduleNames, providerNames));
-        }
-        writer.emitStatement("this.%s = SetFactory.create(%n%s)",
-            providerFieldEntry.getKey(),
-            Joiner.on(",\n").join(setFactoryParameters.build()));
-      } else {
-        ProvisionBinding binding = Iterables.getOnlyElement(bindings);
+    for (Key key : initializationOrdering) {
+      // first members injectors
+      if (resolvedMembersInjectionBindings.containsKey(key)) {
         writer.emitStatement("this.%s = %s",
-            providerFieldEntry.getKey(),
-            initializeFactoryForBinding(writer, binding, moduleNames, providerNames));
+            membersInjectorNames.get(key),
+            initializeMembersInjectorForBinding(writer, resolvedMembersInjectionBindings.get(key),
+                providerNames, membersInjectorNames));
+      }
+
+      // then provisions
+      if (resolvedProvisionBindings.containsKey(key)) {
+        Set<ProvisionBinding> bindings = resolvedProvisionBindings.get(key);
+        if (ProvisionBinding.isSetBindingCollection(bindings)) {
+          ImmutableList.Builder<String> setFactoryParameters = ImmutableList.builder();
+          for (ProvisionBinding binding : bindings) {
+            setFactoryParameters.add(initializeFactoryForBinding(
+                writer, binding, moduleNames, providerNames,membersInjectorNames));
+          }
+          writer.emitStatement("this.%s = SetFactory.create(%n%s)",
+              providerNames.get(key),
+              Joiner.on(",\n").join(setFactoryParameters.build()));
+        } else {
+          ProvisionBinding binding = Iterables.getOnlyElement(bindings);
+          writer.emitStatement("this.%s = %s",
+              providerNames.get(key),
+              initializeFactoryForBinding(
+                  writer, binding, moduleNames, providerNames, membersInjectorNames));
+        }
       }
     }
 
@@ -224,39 +272,101 @@ public String apply(TypeElement input) {
 
   private static String initializeFactoryForBinding(JavaWriter writer, ProvisionBinding binding,
       ImmutableBiMap<TypeElement, String> moduleNames,
-      ImmutableBiMap<Key, String> providerNames) {
+      ImmutableBiMap<Key, String> providerNames,
+      ImmutableBiMap<Key, String> membersInjectorNames) {
     List<String> parameters = Lists.newArrayListWithCapacity(binding.dependencies().size() + 1);
     if (binding.bindingKind().equals(PROVISION)) {
-      parameters.add(moduleNames.get(binding.bindingElement().getEnclosingElement()));
+      parameters.add(moduleNames.get(binding.bindingTypeElement()));
     }
-    FluentIterable.from(binding.dependenciesByKey().keySet())
-        .transform(Functions.forMap(providerNames))
-        .copyInto(parameters);
+    parameters.addAll(
+        getDependencyParameters(binding.dependencies(), providerNames, membersInjectorNames));
     return String.format("new %s(%s)",
         writer.compressType(factoryNameForProvisionBinding(binding).toString()),
         Joiner.on(", ").join(parameters));
   }
 
-  private void writeProvisionMethods(JavaWriter writer,
-      ImmutableSet<DependencyRequest> provisionRequests,
-      ImmutableBiMap<Key, String> providerNames) throws IOException {
-    for (DependencyRequest provisionRequest : provisionRequests) {
-      ExecutableElement requestElement = (ExecutableElement) provisionRequest.requestElement();
-      writer.emitAnnotation(Override.class)
-          .beginMethod(Util.typeToString(requestElement.getReturnType()),
-              requestElement.getSimpleName().toString(),
-              Sets.difference(requestElement.getModifiers(), EnumSet.of(ABSTRACT)));
-
-      String providerName = providerNames.get(provisionRequest.key());
-
-      // look up the provider in the Key->name map and invoke.  Done.
-      writer.emitStatement("return "
-          + providerUsageStatement(providerName, provisionRequest.kind()));
+  private static String initializeMembersInjectorForBinding(JavaWriter writer,
+      MembersInjectionBinding binding,
+      ImmutableBiMap<Key, String> providerNames,
+      ImmutableBiMap<Key, String> membersInjectorNames) {
+    List<String> parameters = getDependencyParameters(binding.dependencySet(),
+        providerNames, membersInjectorNames);
+    return String.format("new %s(%s)",
+        writer.compressType(membersInjectorNameForMembersInjectionBinding(binding).toString()),
+        Joiner.on(", ").join(parameters));
+  }
+
+  private static List<String> getDependencyParameters(Iterable<DependencyRequest> dependencies,
+      ImmutableBiMap<Key, String> providerNames,
+      ImmutableBiMap<Key, String> membersInjectorNames) {
+    ImmutableList.Builder<String> parameters = ImmutableList.builder();
+    for (DependencyRequest dependency : dependencies) {
+        parameters.add(dependency.kind().equals(MEMBERS_INJECTOR)
+            ? membersInjectorNames.get(dependency.key())
+            : providerNames.get(dependency.key()));
+    }
+    return parameters.build();
+  }
+
+  private void writeInterfaceMethods(JavaWriter writer,
+      ImmutableList<DependencyRequest> interfaceRequests,
+      ImmutableBiMap<Key, String> providerNames,
+      ImmutableBiMap<Key, String> membersInjectorNames) throws IOException {
+    for (DependencyRequest interfaceRequest : interfaceRequests) {
+      ExecutableElement requestElement = (ExecutableElement) interfaceRequest.requestElement();
+      beginMethodOverride(writer, requestElement);
+      if (interfaceRequest.kind().equals(MEMBERS_INJECTOR)) {
+        String membersInjectorName = membersInjectorNames.get(interfaceRequest.key());
+        Name parameterName =
+            Iterables.getOnlyElement(requestElement.getParameters()).getSimpleName();
+        writer.emitStatement("%s.injectMembers(%s)", membersInjectorName, parameterName);
+        if (!requestElement.getReturnType().getKind().equals(VOID)) {
+          writer.emitStatement("return %s", parameterName);
+        }
+      } else {
+        // provision requests
+        String providerName = providerNames.get(interfaceRequest.key());
+
+        // look up the provider in the Key->name map and invoke.  Done.
+        writer.emitStatement("return "
+            + providerUsageStatement(providerName, interfaceRequest.kind()));
+      }
       writer.endMethod();
     }
   }
 
+  private JavaWriter beginMethodOverride(JavaWriter writer, ExecutableElement methodElement)
+      throws IOException {
+    String returnTypeString = methodElement.getReturnType().getKind().equals(VOID)
+        ? "void"
+        : writer.compressType(Util.typeToString(methodElement.getReturnType()));
+    String methodName = methodElement.getSimpleName().toString();
+    Set<Modifier> modifiers = Sets.difference(methodElement.getModifiers(), EnumSet.of(ABSTRACT));
+    ImmutableList.Builder<String> parametersBuilder = ImmutableList.builder();
+    for (VariableElement parameterElement : methodElement.getParameters()) {
+      parametersBuilder.add(writer.compressType(Util.typeToString(parameterElement.asType())),
+          parameterElement.getSimpleName().toString());
+    }
+    ImmutableList.Builder<String> thrownTypesBuilder = ImmutableList.builder();
+    for (TypeMirror thrownTypeMirror : methodElement.getThrownTypes()) {
+      thrownTypesBuilder.add(writer.compressType(Util.typeToString(thrownTypeMirror)));
+    }
+    return writer.emitAnnotation(Override.class)
+        .beginMethod(
+            returnTypeString,
+            methodName,
+            modifiers,
+            parametersBuilder.build(),
+            thrownTypesBuilder.build());
+  }
+
   private String providerTypeString(Key key) {
-    return Util.typeToString(providerTypeRepository.getProviderType(key));
+    return Util.typeToString(types.getDeclaredType(
+        elements.getTypeElement(Provider.class.getCanonicalName()), key.type()));
+  }
+
+  private String membersInjectorTypeString(Key key) {
+    return Util.typeToString(types.getDeclaredType(
+        elements.getTypeElement(MembersInjector.class.getCanonicalName()), key.type()));
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 11fd1a368..bdba18940 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -23,6 +23,7 @@
 import dagger.Component;
 import dagger.Module;
 import dagger.Provides;
+import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
 
 import java.util.Set;
 
@@ -75,7 +76,6 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
     ProvidesMethodValidator providesMethodValidator = new ProvidesMethodValidator(elements);
     ComponentValidator componentValidator = new ComponentValidator(elements);
 
-    ProviderTypeRepository providerTypeRepository = new ProviderTypeRepository(elements, types);
     InjectBindingRegistry injectBindingRegistry = new InjectBindingRegistry();
 
     Key.Factory keyFactory = new Key.Factory(types, elements);
@@ -83,16 +83,16 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
         new DependencyRequest.Factory(elements, types);
     ProvisionBinding.Factory provisionBindingFactory =
         new ProvisionBinding.Factory(keyFactory, dependencyRequestFactory);
-    MembersInjectionBinding.Factory methodInjectionBindingFactory =
-        new MembersInjectionBinding.Factory(dependencyRequestFactory);
+    InjectionSite.Factory injectionSiteFactory =
+        new InjectionSite.Factory(dependencyRequestFactory);
     ComponentDescriptor.Factory componentDescriptorFactory =
         new ComponentDescriptor.Factory(elements, types, injectBindingRegistry,
             provisionBindingFactory, dependencyRequestFactory);
 
-    FactoryGenerator factoryGenerator = new FactoryGenerator(filer, providerTypeRepository);
+    FactoryGenerator factoryGenerator = new FactoryGenerator(filer, elements, types);
     MembersInjectorGenerator membersInjectorGenerator =
-        new MembersInjectorGenerator(filer, providerTypeRepository);
-    ComponentGenerator componentGenerator = new ComponentGenerator(filer, providerTypeRepository);
+        new MembersInjectorGenerator(filer, elements, types);
+    ComponentGenerator componentGenerator = new ComponentGenerator(filer, elements, types);
 
     this.processingSteps = ImmutableList.<ProcessingStep>of(
         new InjectProcessingStep(
@@ -102,7 +102,7 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
             injectMethodValidator,
             provisionBindingFactory,
             factoryGenerator,
-            methodInjectionBindingFactory,
+            injectionSiteFactory,
             membersInjectorGenerator,
             injectBindingRegistry),
         new ModuleProcesssingStep(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
index c28e21e02..9c3cb1586 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
@@ -62,7 +62,7 @@
         ConfigurationAnnotations.getComponentModules(elements, componentMirror);
 
     // TODO(gak): make unused modules an error
-    for (TypeMirror moduleType: moduleTypes) {
+    for (TypeMirror moduleType : moduleTypes) {
       moduleType.accept(new SimpleTypeVisitor6<Void, Void>() {
         @Override
         protected Void defaultAction(TypeMirror e, Void p) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index 0cb323c17..6cdbaf7ba 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -22,7 +22,7 @@
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
 
 import dagger.Lazy;
@@ -60,6 +60,8 @@
     PROVIDER,
     /** A request for a {@link Lazy}.  E.g.: {@code Lazy<Blah>} */
     LAZY,
+    /** A request for a {@link MembersInjector}.  E.g.: {@code MembersInjector<Blah>} */
+    MEMBERS_INJECTOR,
   }
 
   abstract Kind kind();
@@ -75,7 +77,7 @@
       this.types = types;
     }
 
-    ImmutableSet<DependencyRequest> forRequiredVariables(
+    ImmutableList<DependencyRequest> forRequiredVariables(
         List<? extends VariableElement> variables) {
       return FluentIterable.from(variables)
           .transform(new Function<VariableElement, DependencyRequest>() {
@@ -83,7 +85,7 @@
               return forRequiredVariable(input);
             }
           })
-          .toSet();
+          .toList();
     }
 
     DependencyRequest forRequiredVariable(VariableElement variableElement) {
@@ -102,14 +104,13 @@ DependencyRequest forComponentProvisionMethod(ExecutableElement provisionMethod)
 
     DependencyRequest forComponentMembersInjectionMethod(ExecutableElement membersInjectionMethod) {
       checkNotNull(membersInjectionMethod);
-      DeclaredType membersInjectorType = types.getDeclaredType(
-          elements.getTypeElement(MembersInjector.class.getCanonicalName()),
-          Iterables.getOnlyElement(membersInjectionMethod.getParameters()).asType());
-      // this is where we need to wrap it in a MembersInjector
       Optional<AnnotationMirror> qualifier =
           InjectionAnnotations.getQualifier(membersInjectionMethod);
       checkArgument(!qualifier.isPresent());
-      return newDependencyRequest(membersInjectionMethod, membersInjectorType, qualifier);
+      return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR,
+          Key.create(qualifier,
+              Iterables.getOnlyElement(membersInjectionMethod.getParameters()).asType()),
+          membersInjectionMethod);
     }
 
     private DependencyRequest newDependencyRequest(Element requestElement, TypeMirror type,
@@ -126,6 +127,13 @@ private DependencyRequest newDependencyRequest(Element requestElement, TypeMirro
         return new AutoValue_DependencyRequest(Kind.LAZY,
             Key.create(qualifier, Iterables.getOnlyElement(lazyType.getTypeArguments())),
             requestElement);
+      } else if (elements.getTypeElement(MembersInjector.class.getCanonicalName())
+          .equals(types.asElement(type))) {
+        checkArgument(!qualifier.isPresent());
+        DeclaredType membersInjectorType = (DeclaredType) type;
+        return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR,
+            Key.create(qualifier, Iterables.getOnlyElement(membersInjectorType.getTypeArguments())),
+            requestElement);
       } else {
         return new AutoValue_DependencyRequest(Kind.INSTANCE, Key.create(qualifier, type),
             requestElement);
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 0e8d8a0bd..089dadb66 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkNotNull;
 import static com.squareup.javawriter.JavaWriter.stringLiteral;
 import static com.squareup.javawriter.JavaWriter.type;
 import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
@@ -40,22 +41,26 @@
 import com.google.common.collect.ImmutableSortedSet;
 import com.google.common.collect.Maps;
 import com.squareup.javawriter.JavaWriter;
+
 import dagger.Factory;
 import dagger.MembersInjector;
 import dagger.Provides;
+
 import java.io.IOException;
-import java.util.ArrayList;
 import java.util.Collections;
 import java.util.EnumSet;
-import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
+
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
 import javax.inject.Inject;
+import javax.inject.Provider;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
 /**
  * Generates {@link Factory} implementations from {@link ProvisionBinding} instances for
@@ -65,11 +70,13 @@
  * @since 2.0
  */
 final class FactoryGenerator extends SourceFileGenerator<ProvisionBinding> {
-  private final ProviderTypeRepository providerTypeRepository;
+  private final Elements elements;
+  private final Types types;
 
-  FactoryGenerator(Filer filer, ProviderTypeRepository providerTypeRepository) {
+  FactoryGenerator(Filer filer, Elements elements, Types types) {
     super(filer);
-    this.providerTypeRepository = providerTypeRepository;
+    this.elements = checkNotNull(elements);
+    this.types = checkNotNull(types);
   }
 
   @Override
@@ -241,6 +248,7 @@ private void writeGetMethod(JavaWriter writer, ProvisionBinding binding,
   }
 
   private String providerTypeString(Key key) {
-    return Util.typeToString(providerTypeRepository.getProviderType(key));
+    return Util.typeToString(types.getDeclaredType(
+        elements.getTypeElement(Provider.class.getCanonicalName()), key.type()));
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index 58875c286..7cd6c8421 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -26,28 +26,36 @@
 import javax.inject.Inject;
 
 /**
- * Maintains the collection of provision bindings from {@link Inject} constructors known to the
- * annotation processor.
+ * Maintains the collection of provision bindings from {@link Inject} constructors and members
+ * injection bindings from {@link Inject} fields and methods known to the annotation processor.
  *
  * @author Gregory Kick
  */
 final class InjectBindingRegistry {
-  private final Map<Key, ProvisionBinding> bindingsByKey;
+  private final Map<Key, ProvisionBinding> provisionBindingsByKey;
+  private final Map<Key, MembersInjectionBinding> membersInjectionBindingsByKey;
 
   InjectBindingRegistry() {
-    this.bindingsByKey = Maps.newLinkedHashMap();
+    this.provisionBindingsByKey = Maps.newLinkedHashMap();
+    this.membersInjectionBindingsByKey = Maps.newLinkedHashMap();
   }
 
-  boolean isRegistered(Key key) {
-    return bindingsByKey.containsKey(key);
+  void registerProvisionBinding(ProvisionBinding binding) {
+    ProvisionBinding previousValue = provisionBindingsByKey.put(binding.providedKey(), binding);
+    checkState(previousValue == null);
   }
 
-  void registerBinding(ProvisionBinding binding) {
-    ProvisionBinding previousValue = bindingsByKey.put(binding.providedKey(), binding);
+  void registerMembersInjectionBinding(MembersInjectionBinding binding) {
+    MembersInjectionBinding previousValue = membersInjectionBindingsByKey.put(
+        Key.create(binding.injectedType().asType()), binding);
     checkState(previousValue == null);
   }
 
-  Optional<ProvisionBinding> getBindingForKey(Key key) {
-    return Optional.fromNullable(bindingsByKey.get(checkNotNull(key)));
+  Optional<ProvisionBinding> getProvisionBindingForKey(Key key) {
+    return Optional.fromNullable(provisionBindingsByKey.get(checkNotNull(key)));
+  }
+
+  Optional<MembersInjectionBinding> getMembersInjectionBindingForKey(Key key) {
+    return Optional.fromNullable(membersInjectionBindingsByKey.get(checkNotNull(key)));
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
index b0f80db7d..805ba3ba7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
@@ -17,11 +17,14 @@
 
 import static javax.lang.model.SourceVersion.RELEASE_6;
 
+import com.google.auto.common.MoreElements;
 import com.google.common.base.Function;
 import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Multimaps;
 
+import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
+
 import java.util.Collection;
 import java.util.Set;
 
@@ -50,9 +53,9 @@
   private final InjectMethodValidator methodValidator;
   private final ProvisionBinding.Factory provisionBindingFactory;
   private final FactoryGenerator factoryGenerator;
-  private final MembersInjectionBinding.Factory membersInjectionBindingFactory;
+  private final InjectionSite.Factory injectionSiteFactory;
   private final MembersInjectorGenerator membersInjectorWriter;
-  private final InjectBindingRegistry factoryRegistrar;
+  private final InjectBindingRegistry injectBindingRegistry;
 
 
   InjectProcessingStep(Messager messager,
@@ -61,7 +64,7 @@
       InjectMethodValidator methodValidator,
       ProvisionBinding.Factory provisionBindingFactory,
       FactoryGenerator factoryGenerator,
-      MembersInjectionBinding.Factory membersInjectionBindingFactory,
+      InjectionSite.Factory injectionSiteFactory,
       MembersInjectorGenerator membersInjectorWriter,
       InjectBindingRegistry factoryRegistrar) {
     this.messager = messager;
@@ -70,16 +73,16 @@
     this.methodValidator = methodValidator;
     this.provisionBindingFactory = provisionBindingFactory;
     this.factoryGenerator = factoryGenerator;
-    this.membersInjectionBindingFactory = membersInjectionBindingFactory;
+    this.injectionSiteFactory = injectionSiteFactory;
     this.membersInjectorWriter = membersInjectorWriter;
-    this.factoryRegistrar = factoryRegistrar;
+    this.injectBindingRegistry = factoryRegistrar;
   }
 
   @Override
   public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
     // TODO(gak): add some error handling for bad source files
     final ImmutableSet.Builder<ProvisionBinding> provisions = ImmutableSet.builder();
-    final ImmutableSet.Builder<MembersInjectionBinding> membersInjections = ImmutableSet.builder();
+    final ImmutableSet.Builder<InjectionSite> memberInjectionSites = ImmutableSet.builder();
 
     for (Element injectElement : roundEnv.getElementsAnnotatedWith(Inject.class)) {
       injectElement.accept(
@@ -105,8 +108,7 @@ public Void visitVariableAsField(VariableElement fieldElement, Void p) {
               report.printMessagesTo(messager);
 
               if (report.isClean()) {
-                membersInjections.add(
-                    membersInjectionBindingFactory.forInjectField(fieldElement));
+                memberInjectionSites.add(injectionSiteFactory.forInjectField(fieldElement));
               }
 
               return null;
@@ -119,8 +121,7 @@ public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
               report.printMessagesTo(messager);
 
               if (report.isClean()) {
-                membersInjections.add(
-                    membersInjectionBindingFactory.forInjectMethod(methodElement));
+                memberInjectionSites.add(injectionSiteFactory.forInjectMethod(methodElement));
               }
 
               return null;
@@ -128,17 +129,19 @@ public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
           }, null);
     }
 
-    ImmutableListMultimap<TypeElement, MembersInjectionBinding> membersInjectionsByType =
-        Multimaps.index(membersInjections.build(),
-            new Function<MembersInjectionBinding, TypeElement>() {
-              @Override public TypeElement apply(MembersInjectionBinding binding) {
-                return binding.bindingTypeElement();
+    ImmutableListMultimap<TypeElement, InjectionSite> membersInjectionsByType =
+        Multimaps.index(memberInjectionSites.build(),
+            new Function<InjectionSite, TypeElement>() {
+              @Override public TypeElement apply(InjectionSite injectionSite) {
+                return MoreElements.asType(injectionSite.element().getEnclosingElement());
               }
             });
 
-    for (Collection<MembersInjectionBinding> bindings : membersInjectionsByType.asMap().values()) {
+    for (Collection<InjectionSite> injectionSites : membersInjectionsByType.asMap().values()) {
       try {
-        membersInjectorWriter.generate(MembersInjectorDescriptor.create(bindings));
+        MembersInjectionBinding binding = MembersInjectionBinding.create(injectionSites);
+        membersInjectorWriter.generate(binding);
+        injectBindingRegistry.registerMembersInjectionBinding(binding);
       } catch (SourceFileGenerationException e) {
         e.printMessageTo(messager);
       }
@@ -147,7 +150,7 @@ public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
     for (ProvisionBinding binding : provisions.build()) {
       try {
         factoryGenerator.generate(binding);
-        factoryRegistrar.registerBinding(binding);
+        injectBindingRegistry.registerProvisionBinding(binding);
       } catch (SourceFileGenerationException e) {
         e.printMessageTo(messager);
       }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index 67974b3ed..229140170 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -17,80 +17,136 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
-import static javax.lang.model.element.ElementKind.FIELD;
-import static javax.lang.model.element.ElementKind.METHOD;
 
+import com.google.auto.common.MoreElements;
 import com.google.auto.value.AutoValue;
+import com.google.common.base.Function;
 import com.google.common.collect.ComparisonChain;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.ImmutableSortedSet;
+import com.google.common.collect.Iterables;
 import com.google.common.collect.Ordering;
 
+import java.util.List;
+
 import javax.inject.Inject;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 
 /**
- * A value object representing a binding for an {@link Inject} annotation on a member (as opposed to
- * a constructor). New instances should be created using an instance of the {@link Factory}.
+ * Represents the full members injection of a particular type. This does not pay attention to
+ * injected members on supertypes.
  *
  * @author Gregory Kick
  * @since 2.0
  */
 @AutoValue
-abstract class MembersInjectionBinding extends Binding {
+abstract class MembersInjectionBinding {
   /**
-   * Returns an {@link Ordering} suitable for sorting bindings into an ordering that abides by the
-   * injection ordering specified in {@link Inject}. This ordering should not be used with bindings
-   * from different {@link #bindingTypeElement() types}.
+   * Creates a {@link MembersInjectionBinding} for the given bindings.
+   *
+   * @throws IllegalArgumentException if the bindings are not all associated with the same type.
    */
-  static Ordering<MembersInjectionBinding> injectionOrdering() {
-    return INJECTION_ORDERING;
+  static MembersInjectionBinding create(Iterable<InjectionSite> injectionSites) {
+    ImmutableSortedSet<InjectionSite> injectionSiteSet =
+        ImmutableSortedSet.copyOf(INJECTION_ORDERING, injectionSites);
+    TypeElement injectedTypeElement = Iterables.getOnlyElement(FluentIterable.from(injectionSiteSet)
+        .transform(new Function<InjectionSite, TypeElement>() {
+          @Override public TypeElement apply(InjectionSite injectionSite) {
+            return MoreElements.asType(injectionSite.element().getEnclosingElement());
+          }
+        })
+        .toSet());
+    return new AutoValue_MembersInjectionBinding(injectedTypeElement, injectionSiteSet);
+  }
+
+  /** The type on which members are injected. */
+  abstract TypeElement injectedType();
+
+  /** The set of individual sites where {@link Inject} is applied. */
+  abstract ImmutableSortedSet<InjectionSite> injectionSites();
+
+  /** The total set of dependencies required by all injection sites. */
+  final ImmutableSet<DependencyRequest> dependencySet() {
+    return FluentIterable.from(injectionSites())
+        .transformAndConcat(new Function<InjectionSite, List<DependencyRequest>>() {
+          @Override public List<DependencyRequest> apply(InjectionSite input) {
+            return input.dependencies();
+          }
+        })
+        .toSet();
   }
 
-  private static final Ordering<MembersInjectionBinding> INJECTION_ORDERING =
-      new Ordering<MembersInjectionBinding>() {
+  ImmutableSetMultimap<Key, DependencyRequest> dependenciesByKey() {
+    ImmutableSetMultimap.Builder<Key, DependencyRequest> builder = ImmutableSetMultimap.builder();
+    for (DependencyRequest dependency : dependencySet()) {
+      builder.put(dependency.key(), dependency);
+    }
+    return builder.build();
+  }
+
+  private static final Ordering<InjectionSite> INJECTION_ORDERING =
+      new Ordering<InjectionSite>() {
         @Override
-        public int compare(MembersInjectionBinding left, MembersInjectionBinding right) {
+        public int compare(InjectionSite left, InjectionSite right) {
+          checkArgument(left.element().getEnclosingElement()
+              .equals(right.element().getEnclosingElement()));
           return ComparisonChain.start()
               // fields before methods
-              .compare(left.bindingElement().getKind(), right.bindingElement().getKind())
+              .compare(left.element().getKind(), right.element().getKind())
               // then sort by whichever element comes first in the parent
               // this isn't necessary, but makes the processor nice and predictable
               .compare(targetIndexInEnclosing(left), targetIndexInEnclosing(right))
               .result();
         }
+
+        private int targetIndexInEnclosing(InjectionSite injectionSite)  {
+          return injectionSite.element().getEnclosingElement().getEnclosedElements()
+              .indexOf(injectionSite.element());
+        }
       };
 
-  private static int targetIndexInEnclosing(MembersInjectionBinding binding)  {
-    return binding.bindingTypeElement().getEnclosedElements().indexOf(binding.bindingElement());
-  }
+  @AutoValue
+  abstract static class InjectionSite {
+    enum Kind {
+      FIELD,
+      METHOD,
+    }
 
-  /**
-   * A factory for creating {@link MembersInjectionBinding} instances.
-   */
-  static final class Factory {
-    private final DependencyRequest.Factory dependencyRequestFactory;
+    abstract Kind kind();
 
-    Factory(DependencyRequest.Factory dependencyRequestFactory) {
-      this.dependencyRequestFactory = checkNotNull(dependencyRequestFactory);
-    }
+    abstract Element element();
 
-    /** Returns the method injection binding for a method annotated with {@link Inject}. */
-    MembersInjectionBinding forInjectMethod(ExecutableElement methodElement) {
-      checkNotNull(methodElement);
-      checkArgument(methodElement.getKind().equals(METHOD));
-      checkArgument(methodElement.getAnnotation(Inject.class) != null);
-      return new AutoValue_MembersInjectionBinding(methodElement,
-          dependencyRequestFactory.forRequiredVariables(methodElement.getParameters()));
-    }
+    abstract ImmutableList<DependencyRequest> dependencies();
+
+    static final class Factory {
+      private final DependencyRequest.Factory dependencyRequestFactory;
+
+      Factory(DependencyRequest.Factory dependencyRequestFactory) {
+        this.dependencyRequestFactory = checkNotNull(dependencyRequestFactory);
+      }
+
+      InjectionSite forInjectMethod(ExecutableElement methodElement) {
+        checkNotNull(methodElement);
+        checkArgument(methodElement.getKind().equals(ElementKind.METHOD));
+        checkArgument(methodElement.getAnnotation(Inject.class) != null);
+        return new AutoValue_MembersInjectionBinding_InjectionSite(Kind.METHOD, methodElement,
+            dependencyRequestFactory.forRequiredVariables(methodElement.getParameters()));
+      }
 
-    /** Returns the field injection binding for a field annotated with {@link Inject}. */
-    MembersInjectionBinding forInjectField(VariableElement fieldElement) {
-      checkNotNull(fieldElement);
-      checkArgument(fieldElement.getKind().equals(FIELD));
-      checkArgument(fieldElement.getAnnotation(Inject.class) != null);
-      return new AutoValue_MembersInjectionBinding(fieldElement,
-          ImmutableSet.of(dependencyRequestFactory.forRequiredVariable(fieldElement)));
+      InjectionSite forInjectField(VariableElement fieldElement) {
+        checkNotNull(fieldElement);
+        checkArgument(fieldElement.getKind().equals(ElementKind.FIELD));
+        checkArgument(fieldElement.getAnnotation(Inject.class) != null);
+        return new AutoValue_MembersInjectionBinding_InjectionSite(Kind.FIELD, fieldElement,
+            ImmutableList.of(dependencyRequestFactory.forRequiredVariable(fieldElement)));
+      }
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorDescriptor.java
deleted file mode 100644
index ed0640340..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorDescriptor.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.auto.value.AutoValue;
-import com.google.common.base.Function;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableSortedSet;
-import com.google.common.collect.Iterables;
-
-import javax.lang.model.element.TypeElement;
-
-/**
- * Represents the collection of {@link MembersInjectionBinding} instances that represent the total
- * set of bindings for a single class.
- *
- * @author Gregory Kick
- * @since 2.0
- */
-@AutoValue
-abstract class MembersInjectorDescriptor {
-  abstract ImmutableSortedSet<MembersInjectionBinding> bindings();
-  abstract TypeElement injectedClass();
-
-  ClassName injectedClassName() {
-    return ClassName.fromTypeElement(injectedClass());
-  }
-
-  /**
-   * Creates a {@link MembersInjectorDescriptor} for the given bindings.
-   *
-   * @throws IllegalArgumentException if the bindings are not all associated with the same type.
-   */
-  static MembersInjectorDescriptor create(Iterable<MembersInjectionBinding> bindings) {
-    ImmutableSortedSet<MembersInjectionBinding> bindingSet =
-        ImmutableSortedSet.copyOf(MembersInjectionBinding.injectionOrdering(), bindings);
-    TypeElement injectedTypeElement = Iterables.getOnlyElement(FluentIterable.from(bindings)
-        .transform(new Function<MembersInjectionBinding, TypeElement>() {
-          @Override public TypeElement apply(MembersInjectionBinding binding) {
-            return binding.bindingTypeElement();
-          }
-        })
-        .toSet());
-    return new AutoValue_MembersInjectorDescriptor(bindingSet, injectedTypeElement);
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index a92a4adb2..51655087d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -15,9 +15,9 @@
  */
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkNotNull;
 import static com.squareup.javawriter.JavaWriter.stringLiteral;
 import static com.squareup.javawriter.JavaWriter.type;
-import static dagger.internal.codegen.SourceFiles.DEPENDENCY_ORDERING;
 import static dagger.internal.codegen.SourceFiles.collectImportsFromDependencies;
 import static dagger.internal.codegen.SourceFiles.flattenVariableMap;
 import static dagger.internal.codegen.SourceFiles.generateProviderNamesForDependencies;
@@ -33,26 +33,33 @@
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableBiMap;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSortedSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Ordering;
 import com.squareup.javawriter.JavaWriter;
+
 import dagger.MembersInjector;
+import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
+
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.EnumSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
-import java.util.Set;
+
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
+import javax.inject.Provider;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.Name;
 import javax.lang.model.element.VariableElement;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
 /**
  * Generates {@link MembersInjector} implementations from {@link MembersInjectionBinding} instances.
@@ -60,52 +67,47 @@
  * @author Gregory Kick
  * @since 2.0
  */
-final class MembersInjectorGenerator extends SourceFileGenerator<MembersInjectorDescriptor> {
-  private final ProviderTypeRepository providerTypeRepository;
+final class MembersInjectorGenerator extends SourceFileGenerator<MembersInjectionBinding> {
+  private final Elements elements;
+  private final Types types;
 
-  MembersInjectorGenerator(Filer filer, ProviderTypeRepository providerTypeRepository) {
+  MembersInjectorGenerator(Filer filer, Elements elements, Types types) {
     super(filer);
-    this.providerTypeRepository = providerTypeRepository;
+    this.elements = checkNotNull(elements);
+    this.types = checkNotNull(types);
   }
 
   @Override
-  ClassName nameGeneratedType(MembersInjectorDescriptor descriptor) {
-    ClassName injectedClassName = descriptor.injectedClassName();
+  ClassName nameGeneratedType(MembersInjectionBinding binding) {
+    ClassName injectedClassName = ClassName.fromTypeElement(binding.injectedType());
     return injectedClassName.peerNamed(injectedClassName.simpleName() + "$$MembersInjector");
   }
 
   @Override
   Iterable<? extends Element> getOriginatingElements(
-      MembersInjectorDescriptor descriptor) {
-    return FluentIterable.from(descriptor.bindings())
-        .transform(new Function<MembersInjectionBinding, Element>() {
-          @Override public Element apply(MembersInjectionBinding binding) {
-            return binding.bindingElement();
+      MembersInjectionBinding binding) {
+    return FluentIterable.from(binding.injectionSites())
+        .transform(new Function<InjectionSite, Element>() {
+          @Override public Element apply(InjectionSite injectionSite) {
+            return injectionSite.element();
           }
         })
         .toSet();
   }
 
   @Override
-  Optional<? extends Element> getElementForErrorReporting(MembersInjectorDescriptor input) {
-    return Optional.of(input.injectedClass());
+  Optional<? extends Element> getElementForErrorReporting(MembersInjectionBinding binding) {
+    return Optional.of(binding.injectedType());
   }
 
   @Override
-  void write(ClassName injectorClassName, JavaWriter writer, MembersInjectorDescriptor descriptor)
+  void write(ClassName injectorClassName, JavaWriter writer, MembersInjectionBinding binding)
       throws IOException {
-    ClassName injectedClassName = descriptor.injectedClassName();
-    ImmutableSortedSet<MembersInjectionBinding> bindings = descriptor.bindings();
+    ClassName injectedClassName = ClassName.fromTypeElement(binding.injectedType());
 
     writer.emitPackage(injectedClassName.packageName());
 
-    ImmutableSortedSet<DependencyRequest> dependencies = FluentIterable.from(descriptor.bindings())
-        .transformAndConcat(new Function<MembersInjectionBinding, Set<DependencyRequest>>() {
-          @Override public Set<DependencyRequest> apply(MembersInjectionBinding input) {
-            return input.dependencies();
-          }
-        })
-        .toSortedSet(DEPENDENCY_ORDERING);
+    ImmutableSet<DependencyRequest> dependencies = binding.dependencySet();
 
     List<ClassName> importsBuilder = new ArrayList<ClassName>();
     importsBuilder.addAll(collectImportsFromDependencies(injectorClassName, dependencies));
@@ -147,20 +149,20 @@ void write(ClassName injectorClassName, JavaWriter writer, MembersInjectorDescri
             "throw new NullPointerException(\"Cannot inject members into a null reference\")")
         .endControlFlow();
 
-    for (MembersInjectionBinding binding : bindings) {
-      Element target = binding.bindingElement();
-      switch (target.getKind()) {
+    for (InjectionSite injectionSite : binding.injectionSites()) {
+      switch (injectionSite.kind()) {
         case FIELD:
-          Name fieldName = ((VariableElement) target).getSimpleName();
-          DependencyRequest singleDependency = Iterables.getOnlyElement(binding.dependencies());
+          Name fieldName = ((VariableElement) injectionSite.element()).getSimpleName();
+          DependencyRequest singleDependency =
+              Iterables.getOnlyElement(injectionSite.dependencies());
           String providerName = providerNames.get(singleDependency.key());
           writer.emitStatement("instance.%s = %s",
               fieldName, providerUsageStatement(providerName, singleDependency.kind()));
           break;
         case METHOD:
-          Name methodName = ((ExecutableElement) target).getSimpleName();
+          Name methodName = ((ExecutableElement) injectionSite.element()).getSimpleName();
           String parameterString =
-              Joiner.on(", ").join(FluentIterable.from(binding.dependencies())
+              Joiner.on(", ").join(FluentIterable.from(injectionSite.dependencies())
                   .transform(new Function<DependencyRequest, String>() {
                     @Override public String apply(DependencyRequest input) {
                       return providerUsageStatement(providerNames.get(input.key()), input.kind());
@@ -169,7 +171,7 @@ void write(ClassName injectorClassName, JavaWriter writer, MembersInjectorDescri
           writer.emitStatement("instance.%s(%s)", methodName, parameterString);
           break;
         default:
-          throw new IllegalStateException(target.getKind().toString());
+          throw new AssertionError();
       }
     }
     writer.endMethod();
@@ -210,6 +212,7 @@ private void writeConstructor(JavaWriter writer, ImmutableBiMap<Key, String> pro
   }
 
   private String providerTypeString(Key key) {
-    return Util.typeToString(providerTypeRepository.getProviderType(key));
+    return Util.typeToString(types.getDeclaredType(
+        elements.getTypeElement(Provider.class.getCanonicalName()), key.type()));
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProviderTypeRepository.java b/compiler/src/main/java/dagger/internal/codegen/ProviderTypeRepository.java
deleted file mode 100644
index 67c7b8eda..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/ProviderTypeRepository.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-
-import com.google.common.cache.CacheBuilder;
-import com.google.common.cache.CacheLoader;
-import com.google.common.cache.LoadingCache;
-
-import javax.inject.Provider;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
-
-/**
- * A simple repository for {@link Provider} {@link DeclaredType types} for a given {@link Key}. For
- * example, a key for {@code @Named("foo") Set<String>} would return the type representing
- * {@code Provider<Set<String>>}.
- *
- * @author Gregory Kick
- * @since 2.0
- */
-final class ProviderTypeRepository {
-  private final LoadingCache<Key, DeclaredType> providerTypeCache;
-
-  ProviderTypeRepository(final Elements elements, final Types types) {
-    checkNotNull(elements);
-    checkNotNull(types);
-    this.providerTypeCache = CacheBuilder.newBuilder()
-        .concurrencyLevel(1)
-        .softValues() // just to make sure we don't OOME the compiler
-        .build(new CacheLoader<Key, DeclaredType>() {
-          TypeElement providerTypeElement =
-              elements.getTypeElement(Provider.class.getCanonicalName());
-
-          @Override public DeclaredType load(Key key) {
-            return types.getDeclaredType(providerTypeElement, key.type());
-          }
-        });
-  }
-
-  DeclaredType getProviderType(Key key) {
-    checkNotNull(key);
-    return providerTypeCache.getUnchecked(key);
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 71cc0d1bf..7b9880f64 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -18,6 +18,7 @@
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 
 import com.google.common.base.CaseFormat;
+import com.google.common.base.Function;
 import com.google.common.collect.BiMap;
 import com.google.common.collect.ComparisonChain;
 import com.google.common.collect.FluentIterable;
@@ -29,6 +30,7 @@
 import com.google.common.collect.ImmutableSortedMap;
 import com.google.common.collect.ImmutableSortedSet;
 import com.google.common.collect.Iterables;
+import com.google.common.collect.Maps;
 import com.google.common.collect.Ordering;
 import com.google.common.collect.SetMultimap;
 import com.squareup.javawriter.JavaWriter;
@@ -87,6 +89,9 @@
         case PROVIDER:
           builder.add(ClassName.fromClass(Provider.class));
           break;
+        case MEMBERS_INJECTOR:
+          builder.add(ClassName.fromClass(MembersInjector.class));
+          break;
         default:
           throw new AssertionError();
       }
@@ -196,26 +201,19 @@
         name = new KeyVariableNamer().apply(entry.getKey()) + "Provider";
       } else {
         ProvisionBinding binding = Iterables.getOnlyElement(bindingsForKey);
-        switch (binding.bindingKind()) {
-          case INJECTION:
-          case PROVISION:
-            name = binding.bindingElement().accept(
-                new ElementKindVisitor6<String, Void>() {
-                  @Override
-                  public String visitExecutableAsConstructor(ExecutableElement e, Void p) {
-                    return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL,
-                        e.getEnclosingElement().getSimpleName().toString());
-                  }
+        name = binding.bindingElement().accept(
+            new ElementKindVisitor6<String, Void>() {
+              @Override
+              public String visitExecutableAsConstructor(ExecutableElement e, Void p) {
+                return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL,
+                    e.getEnclosingElement().getSimpleName().toString());
+              }
 
-                  @Override
-                  public String visitExecutableAsMethod(ExecutableElement e, Void p) {
-                    return e.getSimpleName().toString();
-                  }
-                }, null) + "Provider";
-            break;
-          default:
-            throw new AssertionError();
-        }
+              @Override
+              public String visitExecutableAsMethod(ExecutableElement e, Void p) {
+                return e.getSimpleName().toString();
+              }
+            }, null) + "Provider";
       }
       providerNames.put(entry.getKey(), name);
     }
@@ -223,6 +221,17 @@ public String visitExecutableAsMethod(ExecutableElement e, Void p) {
     return ImmutableBiMap.copyOf(ImmutableSortedMap.copyOf(providerNames.inverse())).inverse();
   }
 
+  static ImmutableBiMap<Key, String> generateMembersInjectorNamesForBindings(
+      Map<Key, MembersInjectionBinding> bindings) {
+    return ImmutableBiMap.copyOf(Maps.transformValues(bindings,
+        new Function<MembersInjectionBinding, String>() {
+          @Override public String apply(MembersInjectionBinding input) {
+            return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL,
+                input.injectedType().getSimpleName().toString()) + "MembersInjector";
+          }
+        }));
+  }
+
   static String providerUsageStatement(String providerName,
       DependencyRequest.Kind dependencyKind) {
     switch (dependencyKind) {
@@ -251,6 +260,12 @@ static ClassName factoryNameForProvisionBinding(ProvisionBinding binding) {
     }
   }
 
+  static ClassName membersInjectorNameForMembersInjectionBinding(MembersInjectionBinding binding) {
+    TypeElement injectedTypeElement = binding.injectedType();
+    ClassName injectedClassName = ClassName.fromTypeElement(injectedTypeElement);
+    return injectedClassName.peerNamed(injectedClassName.classFileName() + "$$MembersInjector");
+  }
+
   private static String factoryPrefix(ProvisionBinding binding) {
     switch (binding.bindingKind()) {
       case INJECTION:
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index 9f26ab4df..b77c8292d 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -303,4 +303,70 @@
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
   }
+
+  @Test public void membersInjection() {
+    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class SomeInjectableType {",
+        "  @Inject SomeInjectableType() {}",
+        "}");
+    JavaFileObject injectedTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectedType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class SomeInjectedType {",
+        "  @Inject SomeInjectableType injectedField;",
+        "  SomeInjectedType() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SimpleComponent {",
+        "  void inject(SomeInjectedType instance);",
+        "  SomeInjectedType injectAndReturn(SomeInjectedType instance);",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.Dagger_SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_SimpleComponent implements SimpleComponent {",
+        "  private final Provider<SomeInjectableType> someInjectableTypeProvider;",
+        "  private final MembersInjector<SomeInjectedType> someInjectedTypeMembersInjector;",
+        "",
+        "  public Dagger_SimpleComponent() {",
+        "    this.someInjectableTypeProvider = new SomeInjectableType$$Factory();",
+        "    this.someInjectedTypeMembersInjector = ",
+        "        new SomeInjectedType$$MembersInjector(someInjectableTypeProvider);",
+        "  }",
+        "",
+        "  @Override public void inject(SomeInjectedType instance) {",
+        "    someInjectedTypeMembersInjector.injectMembers(instance);",
+        "  }",
+        "",
+        "  @Override public SomeInjectedType injectAndReturn(SomeInjectedType instance) {",
+        "    someInjectedTypeMembersInjector.injectMembers(instance);",
+        "    return instance;",
+        "  }",
+        "}");
+    ASSERT.about(javaSources())
+        .that(ImmutableList.of(injectableTypeFile, injectedTypeFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
 }
diff --git a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
index 5f7451c6b..6b6bbf81c 100644
--- a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
@@ -41,12 +41,12 @@
   @Module(injects = ArrayInjectable.class)
   static class PrimitiveArrayModule {
     @Provides byte[] byteArray() { return new byte[] { Byte.MAX_VALUE }; }
-    @Provides int[] provideInt() { return new int[] { Integer.MAX_VALUE }; }
-    @Provides boolean[] provideBoolean() { return new boolean[] { true }; }
-    @Provides long[] provideLong() { return new long[] { Long.MAX_VALUE }; }
-    @Provides char[] provideChar() { return new char[] { Character.MAX_VALUE }; }
-    @Provides float[] provideFloat() { return new float[] { Float.MAX_VALUE }; }
-    @Provides double[] provideDouble() { return new double[] { Double.MAX_VALUE }; }
+    @Provides int[] intArray() { return new int[] { Integer.MAX_VALUE }; }
+    @Provides boolean[] booleanArray() { return new boolean[] { true }; }
+    @Provides long[] longArray() { return new long[] { Long.MAX_VALUE }; }
+    @Provides char[] charArray() { return new char[] { Character.MAX_VALUE }; }
+    @Provides float[] floatArray() { return new float[] { Float.MAX_VALUE }; }
+    @Provides double[] doubleArray() { return new double[] { Double.MAX_VALUE }; }
   }
 
   @Test public void primitiveArrayTypesAllInjected() {
diff --git a/compiler/src/test/java/dagger/tests/integration/operation/SimpleInjectionTest.java b/compiler/src/test/java/dagger/tests/integration/operation/SimpleInjectionTest.java
index 994c7800b..6a5ae37ce 100644
--- a/compiler/src/test/java/dagger/tests/integration/operation/SimpleInjectionTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/operation/SimpleInjectionTest.java
@@ -52,18 +52,18 @@
   @Test public void memberInject_WithoutProvidesMethod() {
     Foo foo = new Foo();
     ObjectGraph.create(FooModule.class).inject(foo);
-    ASSERT.that(foo.blah).equals("blah");
+    ASSERT.that(foo.blah).isEqualTo("blah");
   }
 
   @Test public void membersInject_WithProvidesMethod() {
     Foo foo = new Foo();
     ObjectGraph.create(ProvidingFooModule.class).inject(foo);
-    ASSERT.that(foo.blah).equals("blah");
+    ASSERT.that(foo.blah).isEqualTo("blah");
   }
 
   @Test public void get_WithProvidesMethod() {
     Foo foo = ObjectGraph.create(ProvidingFooModule.class).get(Foo.class);
-    ASSERT.that(foo.blah).equals("blah");
+    ASSERT.that(foo.blah).isEqualTo("blah");
   }
 
   static class Bar { }
diff --git a/core/pom.xml b/core/pom.xml
index 401e02cb4..c980ca36f 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.2.1-SNAPSHOT</version>
+    <version>2.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>dagger</artifactId>
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index 1e86b1b82..6432c84e3 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -33,7 +33,6 @@
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.Map.Entry;
 
 
 /**
@@ -130,8 +129,15 @@ public static ObjectGraph create(Object... modules) {
     return DaggerObjectGraph.makeGraph(null, new FailoverLoader(), modules);
   }
 
-  // visible for testing
-  static ObjectGraph createWith(Loader loader, Object... modules) {
+  /**
+   * Load the graph with a custom loading strategy.  If you're not using this to work around
+   * proguard obfuscation, then use {@link #create(Object...)}
+   *
+   * @deprecated Recreated for reflective use of Dagger in the obfuscation case, and will be
+   *     entirely obsolete in Dagger 2.0.
+   */
+  @Deprecated
+  public static ObjectGraph createWith(Loader loader, Object... modules) {
     return DaggerObjectGraph.makeGraph(null, loader, modules);
   }
 
diff --git a/core/src/main/java/dagger/internal/FailoverLoader.java b/core/src/main/java/dagger/internal/FailoverLoader.java
index a9fb26031..e55daf06a 100644
--- a/core/src/main/java/dagger/internal/FailoverLoader.java
+++ b/core/src/main/java/dagger/internal/FailoverLoader.java
@@ -16,9 +16,10 @@
  */
 package dagger.internal;
 
-
 import dagger.internal.loaders.ReflectiveAtInjectBinding;
 import dagger.internal.loaders.ReflectiveStaticInjection;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
 
 import static dagger.internal.loaders.GeneratedAdapters.INJECT_ADAPTER_SUFFIX;
 import static dagger.internal.loaders.GeneratedAdapters.MODULE_ADAPTER_SUFFIX;
@@ -57,21 +58,108 @@
     return (ModuleAdapter<T>) loadedAdapters.get(type);
   }
 
+  private final Memoizer<AtInjectBindingKey, AtInjectBindingInfo> atInjectBindings =
+      new Memoizer<AtInjectBindingKey, AtInjectBindingInfo>() {
+        @Override protected AtInjectBindingInfo create(AtInjectBindingKey key) {
+          return getAtInjectBindingInfo(key.classLoader, key.className);
+        }
+      };
+
+  private static final class AtInjectBindingKey {
+    // classLoader can be null
+    private final ClassLoader classLoader;
+    private final String className;
+
+    AtInjectBindingKey(ClassLoader classLoader, String className) {
+      this.classLoader = classLoader;
+      this.className = className;
+    }
+
+    @Override
+    public int hashCode() {
+      // It is highly unlikely for the same class name to be present in multiple class loaders. If
+      // this does happen, we'll just let those keys collide.
+      return className.hashCode();
+    }
+
+    @Override
+    public boolean equals(Object object) {
+      if (object == this) {
+        return true;
+      }
+      if (object instanceof AtInjectBindingKey) {
+        AtInjectBindingKey other = (AtInjectBindingKey) object;
+        return (classLoader == other.classLoader) && className.equals(other.className);
+      }
+      return false;
+
+    }
+  }
+
+  private static final class AtInjectBindingInfo {
+    private final Constructor<Binding<?>> adapterConstructor;
+    private final ReflectiveAtInjectBinding.Factory<?> reflectiveBindingFactory;
+
+    AtInjectBindingInfo(Constructor<Binding<?>> adapterConstructor,
+        ReflectiveAtInjectBinding.Factory<?> reflectiveBindingFactory) {
+      this.adapterConstructor = adapterConstructor;
+      this.reflectiveBindingFactory = reflectiveBindingFactory;
+    }
+  }
+
   @Override public Binding<?> getAtInjectBinding(
       String key, String className, ClassLoader classLoader, boolean mustHaveInjections) {
-    Binding<?> result = instantiate(className.concat(INJECT_ADAPTER_SUFFIX), classLoader);
-    if (result != null) {
-      return result; // Found loadable adapter, returning it.
+    AtInjectBindingInfo info = atInjectBindings.get(new AtInjectBindingKey(classLoader, className));
+    if (info.adapterConstructor != null) {
+      try {
+        return info.adapterConstructor.newInstance();
+        // Duplicated catch statements becase: android.
+      } catch (InstantiationException e) {
+        throw new IllegalStateException(
+            "Could not create an instance of the inject adapter for class " + className, e);
+      } catch (IllegalAccessException e) {
+        throw new IllegalStateException(
+            "Could not create an instance of the inject adapter for class " + className, e);
+      } catch (IllegalArgumentException e) {
+        throw new IllegalStateException(
+            "Could not create an instance of the inject adapter for class " + className, e);
+      } catch (InvocationTargetException e) {
+        throw new IllegalStateException(
+            "Could not create an instance of the inject adapter for class " + className, e);
+      }
+    } else if (info.reflectiveBindingFactory != null) {
+      return info.reflectiveBindingFactory.create(mustHaveInjections);
+    } else {
+      return null;
+    }
+  }
+
+  private AtInjectBindingInfo getAtInjectBindingInfo(ClassLoader classLoader, String className) {
+    Class<?> adapterClass = loadClass(classLoader, className.concat(INJECT_ADAPTER_SUFFIX));
+    if (!adapterClass.equals(Void.class)) {
+      // Found loadable adapter, using it.
+      try {
+        @SuppressWarnings("unchecked")
+        Constructor<Binding<?>> constructor
+            = (Constructor<Binding<?>>) adapterClass.getConstructor();
+        return new AtInjectBindingInfo(constructor, null);
+      } catch (NoSuchMethodException e) {
+        throw new IllegalStateException(
+            "Couldn't find default constructor in the generated inject adapter for class "
+            + className);
+      }
     }
     Class<?> type = loadClass(classLoader, className);
     if (type.equals(Void.class)) {
-      throw new IllegalStateException(
-          String.format("Could not load class %s needed for binding %s", className, key));
+      throw new IllegalStateException("Could not load class " + className);
     }
     if (type.isInterface()) {
-      return null; // Short-circuit since we can't build reflective bindings for interfaces.
+      // Short-circuit since we can't build reflective bindings for interfaces.
+      return new AtInjectBindingInfo(null, null);
     }
-    return ReflectiveAtInjectBinding.create(type, mustHaveInjections);
+    ReflectiveAtInjectBinding.Factory<?> reflectiveBindingFactory
+        = ReflectiveAtInjectBinding.createFactory(type);
+    return new AtInjectBindingInfo(null, reflectiveBindingFactory);
   }
 
   @Override public StaticInjection getStaticInjection(Class<?> injectedClass) {
diff --git a/core/src/main/java/dagger/internal/ReflectiveLoader.java b/core/src/main/java/dagger/internal/ReflectiveLoader.java
new file mode 100644
index 000000000..038fb6084
--- /dev/null
+++ b/core/src/main/java/dagger/internal/ReflectiveLoader.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2013 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+
+import dagger.internal.loaders.ReflectiveAtInjectBinding;
+import dagger.internal.loaders.ReflectiveModuleAdapter;
+import dagger.internal.loaders.ReflectiveStaticInjection;
+
+import static dagger.internal.loaders.GeneratedAdapters.STATIC_INJECTION_SUFFIX;
+
+/**
+ * Handles loading/finding of modules, injection bindings, and static injections by use of a
+ * reflective bindings.
+ *
+ * @deprecated Provided only to work around proguard obfuscation - obsolete in 2.0.
+ */
+@Deprecated
+public final class ReflectiveLoader extends Loader {
+  /**
+   * Obtains a {@link ReflectiveModuleAdapter} for {@code module}.
+   */
+  @SuppressWarnings("unchecked") // cache ensures types match
+  @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<T> type) {
+    return ReflectiveModuleAdapter.create(type);
+  }
+
+  /**
+   * Obtains a {@link ReflectiveAtInjectBinding} for a given key.
+   */
+  @Override public Binding<?> getAtInjectBinding(
+      String key, String className, ClassLoader classLoader, boolean mustHaveInjections) {
+    Class<?> type = loadClass(classLoader, className);
+    if (type.equals(Void.class)) {
+      throw new IllegalStateException(
+          String.format("Could not load class %s needed for binding %s", className, key));
+    }
+    if (type.isInterface()) {
+      return null; // Short-circuit since we can't build reflective bindings for interfaces.
+    }
+    return ReflectiveAtInjectBinding.createFactory(type).create(mustHaveInjections);
+  }
+
+  @Override public StaticInjection getStaticInjection(Class<?> injectedClass) {
+    return ReflectiveStaticInjection.create(injectedClass);
+  }
+}
diff --git a/core/src/main/java/dagger/internal/loaders/ReflectiveAtInjectBinding.java b/core/src/main/java/dagger/internal/loaders/ReflectiveAtInjectBinding.java
index 08f0264c3..d464ec50e 100644
--- a/core/src/main/java/dagger/internal/loaders/ReflectiveAtInjectBinding.java
+++ b/core/src/main/java/dagger/internal/loaders/ReflectiveAtInjectBinding.java
@@ -141,7 +141,46 @@ private ReflectiveAtInjectBinding(String provideKey, String membersKey, boolean
     return provideKey != null ? provideKey : membersKey;
   }
 
-  public static <T> Binding<T> create(Class<T> type, boolean mustHaveInjections) {
+  /**
+   * A factory for creating {@code ReflectiveAtInjectBinding<T>}.
+   */
+  public static class Factory<T> {
+    private final String provideKey;
+    private final String membersKey;
+    private final boolean singleton;
+    private final Class<?> type;
+    private final Field[] fields;
+    private final Constructor<T> constructor;
+    private final int parameterCount;
+    private final Class<?> supertype;
+    private final String[] keys;
+
+    private Factory(String provideKey, String membersKey, boolean singleton,
+        Class<?> type, Field[] fields, Constructor<T> constructor, int parameterCount,
+        Class<?> supertype, String[] keys) {
+      this.provideKey = provideKey;
+      this.membersKey = membersKey;
+      this.singleton = singleton;
+      this.type = type;
+      this.fields = fields;
+      this.constructor = constructor;
+      this.parameterCount = parameterCount;
+      this.supertype = supertype;
+      this.keys = keys;
+    }
+
+    public ReflectiveAtInjectBinding<T> create(boolean mustHaveInjections) {
+      if (mustHaveInjections && constructor == null && fields.length == 0) {
+        throw new InvalidBindingException(type.getName(),
+            "has no injectable members. Do you want to add an injectable constructor?");
+      }
+      return new ReflectiveAtInjectBinding<T>(provideKey, membersKey, singleton,
+          type, fields, constructor, parameterCount,
+          supertype, keys);
+    }
+  }
+
+  public static <T> Factory<T> createFactory(Class<T> type) {
     boolean singleton = type.isAnnotationPresent(Singleton.class);
     List<String> keys = new ArrayList<String>();
 
@@ -180,9 +219,6 @@ private ReflectiveAtInjectBinding(String provideKey, String membersKey, boolean
           injectedConstructor = type.getDeclaredConstructor();
         } catch (NoSuchMethodException ignored) {
         }
-      } else if (mustHaveInjections) {
-        throw new InvalidBindingException(type.getName(),
-            "has no injectable members. Do you want to add an injectable constructor?");
       }
     }
 
@@ -222,7 +258,7 @@ private ReflectiveAtInjectBinding(String provideKey, String membersKey, boolean
     }
 
     String membersKey = Keys.getMembersKey(type);
-    return new ReflectiveAtInjectBinding<T>(provideKey, membersKey, singleton, type,
+    return new Factory<T>(provideKey, membersKey, singleton, type,
         injectedFields.toArray(new Field[injectedFields.size()]), injectedConstructor,
         parameterCount, supertype, keys.toArray(new String[keys.size()]));
   }
diff --git a/core/src/main/java/dagger/internal/loaders/ReflectiveModuleAdapter.java b/core/src/main/java/dagger/internal/loaders/ReflectiveModuleAdapter.java
new file mode 100644
index 000000000..a9c28bada
--- /dev/null
+++ b/core/src/main/java/dagger/internal/loaders/ReflectiveModuleAdapter.java
@@ -0,0 +1,217 @@
+package dagger.internal.loaders;
+
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import dagger.Lazy;
+import dagger.Module;
+import dagger.Provides;
+import dagger.internal.Binding;
+import dagger.internal.BindingsGroup;
+import dagger.internal.Keys;
+import dagger.internal.Linker;
+import dagger.internal.ModuleAdapter;
+import dagger.internal.ProvidesBinding;
+import dagger.internal.SetBinding;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.Set;
+import javax.inject.Provider;
+import javax.inject.Singleton;
+
+
+/**
+ * @deprecated this is in place to temporarily support obfuscation needs and
+ *     will not exist as of Dagger 2.0
+ */
+@Deprecated
+public class ReflectiveModuleAdapter<M> extends ModuleAdapter<M> {
+  public ReflectiveModuleAdapter(Class<M> moduleClass, Module annotation) {
+    super(
+        moduleClass,
+        injectableTypesToKeys(annotation.injects()),
+        annotation.staticInjections(),
+        annotation.overrides(),
+        annotation.includes(),
+        annotation.complete(),
+        annotation.library());
+  }
+
+  private static String[] injectableTypesToKeys(Class<?>[] injectableTypes) {
+    String[] result = new String[injectableTypes.length];
+    for (int i = 0; i < injectableTypes.length; i++) {
+      Class<?> injectableType = injectableTypes[i];
+      result[i] = injectableType.isInterface()
+          ? Keys.get(injectableType)
+          : Keys.getMembersKey(injectableType);
+    }
+    return result;
+  }
+
+  @Override public void getBindings(BindingsGroup bindings, M module) {
+    for (Class<?> c = moduleClass; !c.equals(Object.class); c = c.getSuperclass()) {
+      for (Method method : c.getDeclaredMethods()) {
+        Provides provides = method.getAnnotation(Provides.class);
+        if (provides != null) {
+          Type genericReturnType = method.getGenericReturnType();
+
+          Type typeToCheck = genericReturnType;
+          if (genericReturnType instanceof ParameterizedType) {
+            typeToCheck = ((ParameterizedType) genericReturnType).getRawType();
+          }
+          if (Provider.class.equals(typeToCheck)) {
+            throw new IllegalStateException("@Provides method must not return Provider directly: "
+                + c.getName()
+                + "."
+                + method.getName());
+          }
+          if (Lazy.class.equals(typeToCheck)) {
+            throw new IllegalStateException("@Provides method must not return Lazy directly: "
+                + c.getName()
+                + "."
+                + method.getName());
+          }
+
+          String key = Keys.get(genericReturnType, method.getAnnotations(), method);
+          switch (provides.type()) {
+            case UNIQUE:
+              handleBindings(bindings, module, method, key, library);
+              break;
+            case SET:
+              String setKey = Keys.getSetKey(method.getGenericReturnType(),
+                  method.getAnnotations(), method);
+              handleSetBindings(bindings, module, method, setKey, key, library);
+              break;
+            case SET_VALUES:
+              handleSetBindings(bindings, module, method, key, key, library);
+              break;
+            default:
+              throw new AssertionError("Unknown @Provides type " + provides.type());
+          }
+        }
+      }
+    }
+  }
+
+  private void handleBindings(BindingsGroup bindings, M module, Method method, String key,
+      boolean library) {
+    bindings.contributeProvidesBinding(key,
+        new ReflectiveProvidesBinding<M>(method, key, moduleClass.getName(), module, library));
+  }
+
+  private void handleSetBindings(BindingsGroup bindings, M module, Method method,
+      String setKey, String providerKey, boolean library) {
+    SetBinding.<M>add(bindings, setKey,
+        new ReflectiveProvidesBinding<M>(
+            method, providerKey, moduleClass.getName(), module, library));
+  }
+
+  @Override public M newModule() {
+    try {
+      Constructor<?> constructor = moduleClass.getDeclaredConstructor();
+      constructor.setAccessible(true);
+      return (M)constructor.newInstance();
+    } catch (InvocationTargetException e) {
+      throw new IllegalArgumentException(e.getCause());
+    } catch (NoSuchMethodException e) {
+      throw new IllegalArgumentException("Could not construct " + moduleClass.getName()
+          + " as it lacks an accessible no-args constructor. This module must be passed"
+          + " in as an instance, or an accessible no-args constructor must be added.", e);
+    } catch (InstantiationException e) {
+      throw new IllegalArgumentException("Failed to construct " + moduleClass.getName(), e);
+    } catch (IllegalAccessException e) {
+      throw new AssertionError();
+    }
+  }
+
+  @Override public String toString() {
+    return "ReflectiveModuleAdapter[" + this.moduleClass.getName() + "]";
+  }
+
+  /**
+   * Creates a ReflectiveModuleAdapter or throws an {@code IllegalArgumentException}.
+   */
+  public static <M> ModuleAdapter<M> create(Class<M> moduleClass) {
+    Module annotation = moduleClass.getAnnotation(Module.class);
+    if (annotation == null) {
+      throw new IllegalArgumentException("No @Module on " + moduleClass.getName());
+    }
+    if (!moduleClass.getSuperclass().equals(Object.class)) {
+      throw new IllegalArgumentException(
+          "Modules must not extend from other classes: " + moduleClass.getName());
+    }
+    return new ReflectiveModuleAdapter<M>(moduleClass, annotation);
+  }
+
+  /**
+   * Invokes a method to provide a value. The method's parameters are injected.
+   */
+  private static final class ReflectiveProvidesBinding<T> extends ProvidesBinding<T> {
+    private Binding<?>[] parameters;
+    private final Method method;
+    private final Object instance;
+
+    public ReflectiveProvidesBinding(Method method, String key, String moduleClass,
+        Object instance, boolean library) {
+      super(key, method.isAnnotationPresent(Singleton.class), moduleClass, method.getName());
+      this.method = method;
+      this.instance = instance;
+      method.setAccessible(true);
+      setLibrary(library);
+    }
+
+    @Override public void attach(Linker linker) {
+      Type[] types = method.getGenericParameterTypes();
+      Annotation[][] annotations = method.getParameterAnnotations();
+      parameters = new Binding[types.length];
+      for (int i = 0; i < parameters.length; i++) {
+        String key = Keys.get(types[i], annotations[i], method + " parameter " + i);
+        parameters[i] = linker.requestBinding(key, method, instance.getClass().getClassLoader());
+      }
+    }
+
+    @Override public T get() {
+      Object[] args = new Object[parameters.length];
+      for (int i = 0; i < parameters.length; i++) {
+        args[i] = parameters[i].get();
+      }
+      try {
+        return (T) method.invoke(instance, args);
+      } catch (InvocationTargetException e) {
+        Throwable cause = e.getCause();
+        throw cause instanceof RuntimeException
+            ? (RuntimeException) cause
+            : new RuntimeException(cause);
+      } catch (IllegalAccessException e) {
+        throw new RuntimeException(e);
+      }
+    }
+
+    @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
+      for (Binding<?> binding : parameters) {
+        get.add(binding);
+      }
+    }
+
+    @Override public void injectMembers(T t) {
+      throw new AssertionError("Provides method bindings are not MembersInjectors");
+    }
+  }
+}
diff --git a/core/src/test/java/dagger/ReflectiveLoaderTest.java b/core/src/test/java/dagger/ReflectiveLoaderTest.java
new file mode 100644
index 000000000..c15d0e623
--- /dev/null
+++ b/core/src/test/java/dagger/ReflectiveLoaderTest.java
@@ -0,0 +1,279 @@
+/*
+ * Copyright (C) 2012 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger;
+
+import dagger.internal.Loader;
+import dagger.internal.ReflectiveLoader;
+import javax.inject.Inject;
+import javax.inject.Provider;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static org.fest.assertions.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+/**
+ * @deprecated This exists to test ReflectiveLoader which is obsolete but needed to work around
+ *     proguard obfuscation.
+ */
+@Deprecated
+@RunWith(JUnit4.class)
+public final class ReflectiveLoaderTest {
+  private static final Loader LOADER = new ReflectiveLoader();
+
+  static class TestEntryPoint {
+    @Inject String s;
+  }
+
+  @Module(injects = TestEntryPoint.class)
+  static class ModuleWithEntryPoint {
+  }
+
+  @Test public void childModuleWithEntryPoint() {
+    @Module(includes = ModuleWithEntryPoint.class)
+    class TestModule {
+      @Provides String provideString() {
+        return "injected";
+      }
+    }
+
+    ObjectGraph objectGraph = ObjectGraph.createWith(LOADER, new TestModule());
+    TestEntryPoint entryPoint = objectGraph.get(TestEntryPoint.class);
+    assertThat(entryPoint.s).isEqualTo("injected");
+  }
+
+  static class TestStaticInjection {
+    @Inject static String s;
+  }
+
+  @Module(staticInjections = TestStaticInjection.class)
+  static class ModuleWithStaticInjection {
+  }
+
+  @Test public void childModuleWithStaticInjection() {
+    @Module(includes = ModuleWithStaticInjection.class)
+    class TestModule {
+      @Provides String provideString() {
+        return "injected";
+      }
+    }
+
+    ObjectGraph objectGraph = ObjectGraph.createWith(LOADER, new TestModule());
+    TestStaticInjection.s = null;
+    objectGraph.injectStatics();
+    assertThat(TestStaticInjection.s).isEqualTo("injected");
+  }
+
+  @Module
+  static class ModuleWithBinding {
+    @Provides String provideString() {
+      return "injected";
+    }
+  }
+
+  @Test public void childModuleWithBinding() {
+
+    @Module(
+        injects = TestEntryPoint.class,
+        includes = ModuleWithBinding.class
+    )
+    class TestModule {
+    }
+
+    ObjectGraph objectGraph = ObjectGraph.createWith(LOADER, new TestModule());
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    objectGraph.inject(entryPoint);
+    assertThat(entryPoint.s).isEqualTo("injected");
+  }
+
+  @Module(includes = ModuleWithBinding.class)
+  static class ModuleWithChildModule {
+  }
+
+  @Test public void childModuleWithChildModule() {
+
+    @Module(
+        injects = TestEntryPoint.class,
+        includes = ModuleWithChildModule.class
+    )
+    class TestModule {
+    }
+
+    ObjectGraph objectGraph = ObjectGraph.createWith(LOADER, new TestModule());
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    objectGraph.inject(entryPoint);
+    assertThat(entryPoint.s).isEqualTo("injected");
+  }
+
+  @Module
+  static class ModuleWithConstructor {
+    private final String value;
+
+    ModuleWithConstructor(String value) {
+      this.value = value;
+    }
+
+    @Provides String provideString() {
+      return value;
+    }
+  }
+
+  @Test public void childModuleMissingManualConstruction() {
+    @Module(includes = ModuleWithConstructor.class)
+    class TestModule {
+    }
+
+    try {
+      ObjectGraph.createWith(LOADER, new TestModule());
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void childModuleWithManualConstruction() {
+
+    @Module(
+        injects = TestEntryPoint.class,
+        includes = ModuleWithConstructor.class
+    )
+    class TestModule {
+    }
+
+    ObjectGraph objectGraph = ObjectGraph.createWith(LOADER, new ModuleWithConstructor("a"), new TestModule());
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    objectGraph.inject(entryPoint);
+    assertThat(entryPoint.s).isEqualTo("a");
+  }
+
+  static class A {}
+
+  static class B { @Inject A a; }
+
+  @Module(injects = A.class) public static class TestModuleA {
+    @Provides A a() { return new A(); }
+  }
+
+  @Module(includes = TestModuleA.class, injects = B.class) public static class TestModuleB {}
+
+  @Test public void autoInstantiationOfModules() {
+    // Have to make these non-method-scoped or instantiation errors occur.
+    ObjectGraph objectGraph = ObjectGraph.createWith(LOADER, TestModuleA.class);
+    assertThat(objectGraph.get(A.class)).isNotNull();
+  }
+
+  @Test public void autoInstantiationOfIncludedModules() {
+    // Have to make these non-method-scoped or instantiation errors occur.
+    ObjectGraph objectGraph = ObjectGraph.createWith(LOADER, new TestModuleB()); // TestModuleA auto-created.
+    assertThat(objectGraph.get(A.class)).isNotNull();
+    assertThat(objectGraph.get(B.class).a).isNotNull();
+  }
+
+  static class ModuleMissingModuleAnnotation {}
+
+  @Module(includes = ModuleMissingModuleAnnotation.class)
+  static class ChildModuleMissingModuleAnnotation {}
+
+  @Test
+  public void childModuleMissingModuleAnnotation() {
+    try {
+      ObjectGraph.createWith(LOADER, new ChildModuleMissingModuleAnnotation());
+    } catch (IllegalArgumentException e) {
+      assertThat(e.getMessage())
+          .contains("No @Module on ").contains("ModuleMissingModuleAnnotation");
+    }
+  }
+
+  @Module
+  static class ThreadModule extends Thread {}
+
+  @Test public void moduleExtendingClassThrowsException() {
+    try {
+      ObjectGraph.createWith(LOADER, new ThreadModule());
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e.getMessage()).startsWith("Modules must not extend from other classes: ");
+    }
+  }
+
+  @Test public void provideProviderFails() {
+    @Module
+    class ProvidesProviderModule {
+      @Provides Provider<Object> provideObject() {
+        return null;
+      }
+    }
+    try {
+      ObjectGraph.createWith(LOADER, new ProvidesProviderModule());
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e.getMessage()) //
+          .startsWith("@Provides method must not return Provider directly: ")
+          .endsWith("ProvidesProviderModule.provideObject");
+    }
+  }
+
+  @Test public void provideRawProviderFails() {
+    @Module
+    class ProvidesRawProviderModule {
+      @Provides Provider provideObject() {
+        return null;
+      }
+    }
+    try {
+      ObjectGraph.createWith(LOADER, new ProvidesRawProviderModule());
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e.getMessage()) //
+          .startsWith("@Provides method must not return Provider directly: ")
+          .endsWith("ProvidesRawProviderModule.provideObject");
+    }
+  }
+
+  @Test public void provideLazyFails() {
+    @Module
+    class ProvidesLazyModule {
+      @Provides Lazy<Object> provideObject() {
+        return null;
+      }
+    }
+    try {
+      ObjectGraph.createWith(LOADER, new ProvidesLazyModule());
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e.getMessage()) //
+          .startsWith("@Provides method must not return Lazy directly: ")
+          .endsWith("ProvidesLazyModule.provideObject");
+    }
+  }
+
+  @Test public void provideRawLazyFails() {
+    @Module
+    class ProvidesRawLazyModule {
+      @Provides Lazy provideObject() {
+        return null;
+      }
+    }
+    try {
+      ObjectGraph.createWith(LOADER, new ProvidesRawLazyModule());
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e.getMessage()) //
+          .startsWith("@Provides method must not return Lazy directly: ")
+          .endsWith("ProvidesRawLazyModule.provideObject");
+    }
+  }
+}
diff --git a/core/src/test/java/dagger/internal/TestingLoader.java b/core/src/test/java/dagger/internal/TestingLoader.java
index b364cde05..0767446a6 100644
--- a/core/src/test/java/dagger/internal/TestingLoader.java
+++ b/core/src/test/java/dagger/internal/TestingLoader.java
@@ -37,7 +37,7 @@
       if (type.isInterface()) {
         return null; // Short-circuit since we can't build reflective bindings for interfaces.
       }
-      return ReflectiveAtInjectBinding.create(type, mustHaveInjections);
+      return ReflectiveAtInjectBinding.createFactory(type).create(mustHaveInjections);
     } catch (ClassNotFoundException e) {
       throw new TypeNotPresentException(
           String.format("Could not find %s needed for binding %s", className, key), e);
diff --git a/examples/android-activity-graphs/pom.xml b/examples/android-activity-graphs/pom.xml
index fa533d1a4..8e7a85d51 100644
--- a/examples/android-activity-graphs/pom.xml
+++ b/examples/android-activity-graphs/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.google.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.2.1-SNAPSHOT</version>
+    <version>2.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>android-activity-graphs</artifactId>
diff --git a/examples/android-simple/pom.xml b/examples/android-simple/pom.xml
index 9f81e748f..08225eda7 100644
--- a/examples/android-simple/pom.xml
+++ b/examples/android-simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.google.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.2.1-SNAPSHOT</version>
+    <version>2.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>android-simple</artifactId>
diff --git a/examples/pom.xml b/examples/pom.xml
index 162a1e5b4..41da7c584 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.2.1-SNAPSHOT</version>
+    <version>2.0-SNAPSHOT</version>
   </parent>
 
   <groupId>com.google.dagger.example</groupId>
diff --git a/examples/simple/pom.xml b/examples/simple/pom.xml
index 319cc45ad..679f0dcf1 100644
--- a/examples/simple/pom.xml
+++ b/examples/simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.google.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.2.1-SNAPSHOT</version>
+    <version>2.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>simple</artifactId>
diff --git a/pom.xml b/pom.xml
index 5bf001f76..fd75656f3 100644
--- a/pom.xml
+++ b/pom.xml
@@ -26,7 +26,7 @@
   <groupId>com.google.dagger</groupId>
   <artifactId>dagger-parent</artifactId>
   <packaging>pom</packaging>
-  <version>1.2.1-SNAPSHOT</version>
+  <version>2.0-SNAPSHOT</version>
   <name>Dagger (Parent)</name>
   <description>A fast dependency injector for Android and Java.</description>
   <url>https://github.com/square/dagger</url>
@@ -50,9 +50,9 @@
     <!-- Test Dependencies -->
     <compile-testing.version>0.5</compile-testing.version>
     <fest.version>1.4</fest.version>
-    <junit.version>4.10</junit.version>
+    <junit.version>4.11</junit.version>
     <mockito.version>1.9.5</mockito.version>
-    <truth.version>0.13</truth.version>
+    <truth.version>0.20</truth.version>
   </properties>
 
   <scm>
