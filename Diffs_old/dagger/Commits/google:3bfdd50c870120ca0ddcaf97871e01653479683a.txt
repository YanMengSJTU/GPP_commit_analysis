diff --git a/compiler/pom.xml b/compiler/pom.xml
index cd68d9c2a..d41306c8d 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -92,6 +92,11 @@
       <artifactId>guava-testlib</artifactId>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>com.squareup</groupId>
+      <artifactId>javapoet</artifactId>
+      <version>1.4.0</version>
+    </dependency>
     <dependency>
       <groupId>org.mockito</groupId>
       <artifactId>mockito-core</artifactId>
diff --git a/compiler/src/main/java/dagger/internal/codegen/AnnotationSpecs.java b/compiler/src/main/java/dagger/internal/codegen/AnnotationSpecs.java
new file mode 100644
index 000000000..db7b9cf2f
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/AnnotationSpecs.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.squareup.javapoet.AnnotationSpec;
+
+final class AnnotationSpecs {
+
+  static final AnnotationSpec SUPPRESS_WARNINGS_UNCHECKED = suppressWarnings("unchecked");
+  static final AnnotationSpec SUPPRESS_WARNINGS_RAWTYPES = suppressWarnings("rawtypes");
+
+  private static AnnotationSpec suppressWarnings(String value) {
+    return AnnotationSpec.builder(SuppressWarnings.class).addMember("value", "$S", value).build();
+  }
+
+  private AnnotationSpecs() {}
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java b/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
new file mode 100644
index 000000000..66cfdd59c
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.squareup.javapoet.CodeBlock;
+import java.util.Iterator;
+
+final class CodeBlocks {
+
+  /** Shorthand for a {@link CodeBlock} with a single format and an argument list. */
+  static CodeBlock format(String format, Object... args) {
+    return CodeBlock.builder().add(format, args).build();
+  }
+
+  static CodeBlock makeParametersCodeBlock(Iterable<CodeBlock> codeBlocks) {
+    return join(codeBlocks, ", ");
+  }
+
+  static CodeBlock join(Iterable<CodeBlock> codeBlocks, String delimiter) {
+    CodeBlock.Builder builder = CodeBlock.builder();
+    Iterator<CodeBlock> iterator = codeBlocks.iterator();
+    while (iterator.hasNext()) {
+      builder.add(iterator.next());
+      if (iterator.hasNext()) {
+        builder.add(delimiter);
+      }
+    }
+    return builder.build();
+  }
+
+  private CodeBlocks() {}
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 304df6c2b..379a60236 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -19,8 +19,6 @@
 import com.google.common.collect.ImmutableSet;
 import dagger.Component;
 import dagger.internal.codegen.writer.ClassName;
-import dagger.internal.codegen.writer.ClassWriter;
-import dagger.internal.codegen.writer.FieldWriter;
 import dagger.internal.codegen.writer.JavaWriter;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
@@ -34,7 +32,7 @@
  * @author Gregory Kick
  * @since 2.0
  */
-final class ComponentGenerator extends SourceFileGenerator<BindingGraph> {
+final class ComponentGenerator extends JavaWriterSourceFileGenerator<BindingGraph> {
   private final Types types;
   private final Elements elements;
   private final Key.Factory keyFactory;
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 65419786a..d9d7dcff0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -70,7 +70,7 @@
  * @author Gregory Kick
  * @since 2.0
  */
-final class FactoryGenerator extends SourceFileGenerator<ProvisionBinding> {
+final class FactoryGenerator extends JavaWriterSourceFileGenerator<ProvisionBinding> {
   private final DependencyRequestMapper dependencyRequestMapper;
   private final Diagnostic.Kind nullableValidationType;
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
index 13950bc9b..baad3b393 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
@@ -23,6 +23,7 @@
 import javax.lang.model.element.ElementVisitor;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementKindVisitor6;
 
 import static com.google.common.collect.Iterables.getOnlyElement;
@@ -41,13 +42,19 @@ static FrameworkField createWithTypeFromKey(Class<?> frameworkClass, Key key, St
     ParameterizedTypeName frameworkType =
         ParameterizedTypeName.create(
             ClassName.fromClass(frameworkClass), TypeNames.forTypeMirror(key.type()));
+    com.squareup.javapoet.ParameterizedTypeName javapoetFrameworkType =
+        com.squareup.javapoet.ParameterizedTypeName.get(
+            com.squareup.javapoet.ClassName.get(frameworkClass),
+            com.squareup.javapoet.TypeName.get(key.type()));
     return new AutoValue_FrameworkField(
-        frameworkType, name.endsWith(suffix) ? name : name + suffix);
+        javapoetFrameworkType, frameworkType, name.endsWith(suffix) ? name : name + suffix);
   }
 
   private static FrameworkField createForMapBindingContribution(Key key, String name) {
+    TypeMirror type = MapType.from(key.type()).valueType();
     return new AutoValue_FrameworkField(
-        (ParameterizedTypeName) TypeNames.forTypeMirror(MapType.from(key.type()).valueType()),
+        (com.squareup.javapoet.ParameterizedTypeName) com.squareup.javapoet.TypeName.get(type),
+        (ParameterizedTypeName) TypeNames.forTypeMirror(type),
         name);
   }
 
@@ -112,6 +119,7 @@ public String visitType(TypeElement e, Void p) {
         }
       };
 
+  abstract com.squareup.javapoet.ParameterizedTypeName javapoetFrameworkType();
   abstract ParameterizedTypeName frameworkType();
   abstract String name();
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/JavaPoetSourceFileGenerator.java b/compiler/src/main/java/dagger/internal/codegen/JavaPoetSourceFileGenerator.java
new file mode 100644
index 000000000..745fe7b79
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/JavaPoetSourceFileGenerator.java
@@ -0,0 +1,133 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Optional;
+import com.google.common.base.Throwables;
+import com.google.common.collect.Iterables;
+import com.google.common.io.CharSink;
+import com.google.common.io.CharSource;
+import com.google.googlejavaformat.java.Formatter;
+import com.google.googlejavaformat.java.FormatterException;
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.JavaFile;
+import com.squareup.javapoet.TypeSpec;
+import java.io.IOException;
+import java.io.Writer;
+import javax.annotation.Generated;
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.Element;
+import javax.lang.model.util.Elements;
+import javax.tools.JavaFileObject;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+/**
+ * A template class that provides a framework for properly handling IO while generating source files
+ * from an annotation processor.  Particularly, it makes a best effort to ensure that files that
+ * fail to write successfully are deleted.
+ *
+ * <p>This differs from {@link JavaWriterSourceFileGenerator} only in that it uses JavaPoet for
+ * constructing the source code model. It is intended for this to take on all usages of JavaWriter.
+ *
+ * @param <T> The input type from which source is to be generated.
+ */
+abstract class JavaPoetSourceFileGenerator<T> implements SourceFileGenerator<T> {
+  private static final String GENERATED_COMMENTS = "https://google.github.io/dagger";
+
+  private static final AnnotationSpec GENERATED =
+      AnnotationSpec.builder(Generated.class)
+          .addMember("value", "$S", ComponentProcessor.class.getName())
+          .addMember("comments", "$S", GENERATED_COMMENTS)
+          .build();
+
+  private final Filer filer;
+  private final boolean generatedAnnotationAvailable;
+
+  JavaPoetSourceFileGenerator(Filer filer, Elements elements) {
+    this.filer = checkNotNull(filer);
+    generatedAnnotationAvailable = elements.getTypeElement("javax.annotation.Generated") != null;
+  }
+
+  @Override
+  public final void generate(T input) throws SourceFileGenerationException {
+    ClassName generatedTypeName = nameGeneratedType(input);
+    try {
+      Optional<TypeSpec.Builder> type = write(generatedTypeName, input);
+      if (!type.isPresent()) {
+        return;
+      }
+      JavaFile javaFile = buildJavaFile(generatedTypeName, type.get());
+
+      final JavaFileObject sourceFile = filer.createSourceFile(
+          generatedTypeName.toString(),
+          Iterables.toArray(javaFile.typeSpec.originatingElements, Element.class));
+      try {
+        new Formatter().formatSource(
+            CharSource.wrap(javaFile.toString()),
+            new CharSink() {
+              @Override public Writer openStream() throws IOException {
+                return sourceFile.openWriter();
+              }
+            });
+      } catch (FormatterException e) {
+        throw new SourceFileGenerationException(
+            Optional.of(generatedTypeName), e, getElementForErrorReporting(input));
+      }
+    } catch (Exception e) {
+      // if the code above threw a SFGE, use that
+      Throwables.propagateIfPossible(e, SourceFileGenerationException.class);
+      // otherwise, throw a new one
+      throw new SourceFileGenerationException(
+          Optional.<ClassName>absent(), e, getElementForErrorReporting(input));
+    }
+  }
+
+  private JavaFile buildJavaFile(
+      ClassName generatedTypeName, TypeSpec.Builder typeSpecBuilder) {
+    if (generatedAnnotationAvailable) {
+      typeSpecBuilder.addAnnotation(GENERATED);
+    }
+    JavaFile.Builder javaFileBuilder =
+        JavaFile.builder(generatedTypeName.packageName(), typeSpecBuilder.build())
+            .skipJavaLangImports(true);
+    if (!generatedAnnotationAvailable) {
+      javaFileBuilder.addFileComment(
+          "Generated by %s (%s).", ComponentProcessor.class.getName(), GENERATED_COMMENTS);
+    }
+    return javaFileBuilder.build();
+  }
+
+  /**
+   * Implementations should return the {@link ClassName} for the top-level type to be generated.
+   */
+  abstract ClassName nameGeneratedType(T input);
+
+  /**
+   * Returns an optional element to be used for reporting errors. This returns a single element
+   * rather than a collection to reduce output noise.
+   */
+  abstract Optional<? extends Element> getElementForErrorReporting(T input);
+
+  /**
+   * Returns a {@link TypeSpec.Builder type} to be generated for {@code T}, or {@link
+   * Optional#absent()} if no file should be generated.
+   */
+  // TODO(ronshapiro): write() makes more sense in JavaWriter where all writers are mutable.
+  // consider renaming to something like typeBuilder() which conveys the mutability of the result
+  abstract Optional<TypeSpec.Builder> write(ClassName generatedTypeName, T input);
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/JavaWriterSourceFileGenerator.java b/compiler/src/main/java/dagger/internal/codegen/JavaWriterSourceFileGenerator.java
new file mode 100644
index 000000000..e43b1a5c5
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/JavaWriterSourceFileGenerator.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Function;
+import com.google.common.base.Optional;
+import com.google.common.base.Throwables;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.JavaWriter;
+import dagger.internal.codegen.writer.TypeWriter;
+import java.io.IOException;
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.Element;
+import javax.lang.model.util.Elements;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+/**
+ * A template class that provides a framework for properly handling IO while generating source files
+ * from an annotation processor.  Particularly, it makes a best effort to ensure that files that
+ * fail to write successfully are deleted.
+ *
+ * @param <T> The input type from which source is to be generated.
+ * @author Gregory Kick
+ * @since 2.0
+ */
+abstract class JavaWriterSourceFileGenerator<T> implements SourceFileGenerator<T> {
+  private final Filer filer;
+  private final boolean generatedAnnotationAvailable;
+
+  JavaWriterSourceFileGenerator(Filer filer, Elements elements) {
+    this.filer = checkNotNull(filer);
+    generatedAnnotationAvailable = elements.getTypeElement("javax.annotation.Generated") != null;
+  }
+
+  @Override
+  public final void generate(T input) throws SourceFileGenerationException {
+    ClassName generatedTypeName = nameGeneratedType(input);
+    ImmutableSet<Element> originatingElements =
+        ImmutableSet.<Element>copyOf(getOriginatingElements(input));
+    try {
+      ImmutableSet<JavaWriter> writers = write(generatedTypeName, input);
+      for (JavaWriter javaWriter : writers) {
+        javaWriter.markGenerated(generatedAnnotationAvailable);
+        try {
+          javaWriter.file(filer, originatingElements);
+        } catch (IOException e) {
+          throw new SourceFileGenerationException(getNamesForWriters(javaWriter.getTypeWriters()),
+              e, getElementForErrorReporting(input));
+        }
+      }
+    } catch (Exception e) {
+      // if the code above threw a SFGE, use that
+      Throwables.propagateIfPossible(e, SourceFileGenerationException.class);
+      // otherwise, throw a new one
+      throw new SourceFileGenerationException(ImmutableList.<ClassName>of(), e,
+          getElementForErrorReporting(input));
+    }
+  }
+
+  private static Iterable<ClassName> getNamesForWriters(Iterable<TypeWriter> typeWriters) {
+    return Iterables.transform(typeWriters, new Function<TypeWriter, ClassName>() {
+      @Override public ClassName apply(TypeWriter input) {
+        return input.name();
+      }
+    });
+  }
+
+  /**
+   * Implementations should return the {@link ClassName} for the top-level type to be generated.
+   */
+  abstract ClassName nameGeneratedType(T input);
+
+  /**
+   * Implementations should return {@link Element} instances from which the source is to be
+   * generated.
+   */
+  abstract Iterable<? extends Element> getOriginatingElements(T input);
+
+  /**
+   * Returns an optional element to be used for reporting errors. This returns a single element
+   * rather than a collection to reduce output noise.
+   */
+  abstract Optional<? extends Element> getElementForErrorReporting(T input);
+
+  /**
+   * Returns a set of writers to be generated for {@code T} input.
+   */
+  abstract ImmutableSet<JavaWriter> write(ClassName generatedTypeName, T input);
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
index 432f8f578..1ef674f6b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
@@ -53,7 +53,7 @@
  *
  * @since 2.0
  */
-final class MapKeyGenerator extends SourceFileGenerator<MapKeyCreatorSpecification> {
+final class MapKeyGenerator extends JavaWriterSourceFileGenerator<MapKeyCreatorSpecification> {
 
   /**
    * Specification of the {@link MapKey} annotation and the annotation type to generate.
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index 46d913437..1c9336e96 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -17,36 +17,28 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.common.base.CaseFormat;
-import com.google.common.base.Function;
-import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
-import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import com.squareup.javapoet.TypeVariableName;
 import dagger.MembersInjector;
 import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
-import dagger.internal.codegen.writer.ClassName;
-import dagger.internal.codegen.writer.ClassWriter;
-import dagger.internal.codegen.writer.ConstructorWriter;
-import dagger.internal.codegen.writer.FieldWriter;
-import dagger.internal.codegen.writer.JavaWriter;
-import dagger.internal.codegen.writer.MethodWriter;
-import dagger.internal.codegen.writer.Modifiable;
-import dagger.internal.codegen.writer.ParameterizedTypeName;
-import dagger.internal.codegen.writer.Snippet;
-import dagger.internal.codegen.writer.TypeName;
-import dagger.internal.codegen.writer.TypeNames;
-import dagger.internal.codegen.writer.TypeVariableName;
-import dagger.internal.codegen.writer.VariableWriter;
-import dagger.internal.codegen.writer.VoidName;
 import dagger.producers.Producer;
+import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map.Entry;
 import java.util.Set;
-import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
 import javax.inject.Provider;
 import javax.lang.model.element.Element;
@@ -61,10 +53,12 @@
 import static com.google.auto.common.MoreElements.getPackage;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_RAWTYPES;
+import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
-import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
-import static dagger.internal.codegen.SourceFiles.parameterizedGeneratedTypeNameForBinding;
-import static dagger.internal.codegen.writer.Snippet.makeParametersSnippet;
+import static dagger.internal.codegen.SourceFiles.javapoetMembersInjectorNameForType;
+import static dagger.internal.codegen.SourceFiles.javapoetParameterizedGeneratedTypeNameForBinding;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
@@ -76,7 +70,7 @@
  * @author Gregory Kick
  * @since 2.0
  */
-final class MembersInjectorGenerator extends SourceFileGenerator<MembersInjectionBinding> {
+final class MembersInjectorGenerator extends JavaPoetSourceFileGenerator<MembersInjectionBinding> {
   private final DependencyRequestMapper dependencyRequestMapper;
 
   MembersInjectorGenerator(
@@ -87,74 +81,70 @@
 
   @Override
   ClassName nameGeneratedType(MembersInjectionBinding binding) {
-    return membersInjectorNameForType(binding.bindingElement());
-  }
-
-  @Override
-  Iterable<? extends Element> getOriginatingElements(
-      MembersInjectionBinding binding) {
-    return FluentIterable.from(binding.injectionSites())
-        .transform(new Function<InjectionSite, Element>() {
-          @Override public Element apply(InjectionSite injectionSite) {
-            return injectionSite.element();
-          }
-        })
-        .toSet();
+    return javapoetMembersInjectorNameForType(binding.bindingElement());
   }
 
   @Override
   Optional<? extends Element> getElementForErrorReporting(MembersInjectionBinding binding) {
     return Optional.of(binding.bindingElement());
   }
-  
+
   @Override
-  ImmutableSet<JavaWriter> write(ClassName generatedTypeName, MembersInjectionBinding binding) {
+  Optional<TypeSpec.Builder> write(ClassName generatedTypeName, MembersInjectionBinding binding) {
     // Empty members injection bindings are special and don't need source files.
     if (binding.injectionSites().isEmpty()) {
-      return ImmutableSet.of();
+      return Optional.absent();
     }
-    Set<String> delegateMethods = new HashSet<>();
-
     // We don't want to write out resolved bindings -- we want to write out the generic version.
     checkState(!binding.unresolved().isPresent());
 
-    TypeName injectedTypeName = TypeNames.forTypeMirror(binding.key().type());
-    JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
-
-    ClassWriter injectorWriter = writer.addClass(generatedTypeName.simpleName());
     List<TypeVariableName> typeParameters = Lists.newArrayList();
     for (TypeParameterElement typeParameter : binding.bindingTypeElement().getTypeParameters()) {
-      typeParameters.add(TypeVariableName.fromTypeParameterElement(typeParameter));
+      typeParameters.add(TypeVariableName.get(typeParameter));
     }
-    injectorWriter.addTypeParameters(typeParameters);
-    injectorWriter.addModifiers(PUBLIC, FINAL);
+
+    TypeSpec.Builder injectorTypeBuilder =
+        TypeSpec.classBuilder(generatedTypeName.simpleName())
+            .addModifiers(PUBLIC, FINAL)
+            .addTypeVariables(typeParameters);
+
+    TypeName injectedTypeName = TypeName.get(binding.key().type());
     TypeName implementedType =
-        ParameterizedTypeName.create(MembersInjector.class, injectedTypeName);
-    injectorWriter.addImplementedType(implementedType);
-
-    ConstructorWriter constructorWriter = injectorWriter.addConstructor();
-    constructorWriter.addModifiers(PUBLIC);
-    MethodWriter injectMembersWriter = injectorWriter.addMethod(VoidName.VOID, "injectMembers");
-    injectMembersWriter.addModifiers(PUBLIC);
-    injectMembersWriter.annotate(Override.class);
-    injectMembersWriter.addParameter(injectedTypeName, "instance");
-    injectMembersWriter.body().addSnippet(Joiner.on('\n').join(
-        "if (instance == null) {",
-        "  throw new NullPointerException(\"Cannot inject members into a null reference\");",
-        "}"));
+        ParameterizedTypeName.get(ClassName.get(MembersInjector.class), injectedTypeName);
+    injectorTypeBuilder.addSuperinterface(implementedType);
+
+    MethodSpec.Builder injectMembersBuilder =
+        MethodSpec.methodBuilder("injectMembers")
+            .returns(TypeName.VOID)
+            .addModifiers(PUBLIC)
+            .addAnnotation(Override.class)
+            .addParameter(injectedTypeName, "instance")
+            .addCode("if (instance == null) {")
+            .addStatement(
+                "throw new $T($S)",
+                NullPointerException.class,
+                "Cannot inject members into a null reference")
+            .addCode("}");
 
     ImmutableMap<BindingKey, FrameworkField> fields =
         SourceFiles.generateBindingFieldsForDependencies(dependencyRequestMapper, binding);
 
-    ImmutableMap.Builder<BindingKey, FieldWriter> dependencyFieldsBuilder =
-        ImmutableMap.builder();
-    
+    ImmutableMap.Builder<BindingKey, FieldSpec> dependencyFieldsBuilder = ImmutableMap.builder();
+
+    MethodSpec.Builder constructorBuilder = MethodSpec.constructorBuilder().addModifiers(PUBLIC);
+
     // We use a static create method so that generated components can avoid having
     // to refer to the generic types of the factory.
     // (Otherwise they may have visibility problems referring to the types.)
-    MethodWriter createMethodWriter = injectorWriter.addMethod(implementedType, "create");
-    createMethodWriter.addTypeParameters(typeParameters);
-    createMethodWriter.addModifiers(Modifier.PUBLIC, Modifier.STATIC);
+    MethodSpec.Builder createMethodBuilder =
+        MethodSpec.methodBuilder("create")
+            .returns(implementedType)
+            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
+            .addTypeVariables(typeParameters);
+
+    createMethodBuilder.addCode(
+        "return new $T(", javapoetParameterizedGeneratedTypeNameForBinding(binding));
+    ImmutableList.Builder<CodeBlock> constructorInvocationParameters = ImmutableList.builder();
 
     boolean usesRawFrameworkTypes = false;
     for (Entry<BindingKey, FrameworkField> fieldEntry : fields.entrySet()) {
@@ -166,67 +156,69 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
       boolean useRawFrameworkType =
           !VISIBLE_TO_MEMBERS_INJECTOR.visit(bindingKey.key().type(), binding);
 
-      FieldWriter field =
-          injectorWriter.addField(
-              useRawFrameworkType
-                  ? bindingField.frameworkType().type()
-                  : bindingField.frameworkType(),
-              bindingField.name());
-
-      field.addModifiers(PRIVATE, FINAL);
-      VariableWriter constructorParameter =
-          constructorWriter.addParameter(field.type(), field.name());
-      VariableWriter createMethodParameter =
-          createMethodWriter.addParameter(constructorParameter.type(), constructorParameter.name());
+      String fieldName = bindingField.name();
+      TypeName fieldType =
+          useRawFrameworkType
+              ? bindingField.javapoetFrameworkType().rawType
+              : bindingField.javapoetFrameworkType();
+      FieldSpec.Builder fieldBuilder = FieldSpec.builder(fieldType, fieldName, PRIVATE, FINAL);
+      ParameterSpec.Builder parameterBuilder = ParameterSpec.builder(fieldType, fieldName);
 
       // If we're using the raw type for the field, then suppress the injectMembers method's
       // unchecked-type warning and the field's and the constructor and create-method's
       // parameters' raw-type warnings.
       if (useRawFrameworkType) {
         usesRawFrameworkTypes = true;
-        suppressRawTypesWarning(field);
-        suppressRawTypesWarning(constructorParameter);
-        suppressRawTypesWarning(createMethodParameter);
+        fieldBuilder.addAnnotation(SUPPRESS_WARNINGS_RAWTYPES);
+        parameterBuilder.addAnnotation(SUPPRESS_WARNINGS_RAWTYPES);
       }
+      constructorBuilder.addParameter(parameterBuilder.build());
+      createMethodBuilder.addParameter(parameterBuilder.build());
 
-      constructorWriter.body().addSnippet("assert %s != null;", field.name());
-      constructorWriter.body().addSnippet("this.%1$s = %1$s;", field.name());
+      FieldSpec field = fieldBuilder.build();
+      injectorTypeBuilder.addField(field);
+      constructorBuilder.addStatement("assert $N != null", field);
+      constructorBuilder.addStatement("this.$N = $N", field, field);
       dependencyFieldsBuilder.put(bindingKey, field);
+      constructorInvocationParameters.add(CodeBlocks.format("$N", field));
     }
+    createMethodBuilder.addCode(CodeBlocks.join(constructorInvocationParameters.build(), ", "));
+    createMethodBuilder.addCode(");");
 
-    createMethodWriter
-        .body()
-        .addSnippet(
-            "  return new %s(%s);",
-            parameterizedGeneratedTypeNameForBinding(binding),
-            Joiner.on(", ").join(constructorWriter.parameters().keySet()));
+    injectorTypeBuilder.addMethod(constructorBuilder.build());
+    injectorTypeBuilder.addMethod(createMethodBuilder.build());
 
-    ImmutableMap<BindingKey, FieldWriter> dependencyFields = dependencyFieldsBuilder.build();
+    Set<String> delegateMethods = new HashSet<>();
+    ImmutableMap<BindingKey, FieldSpec> dependencyFields = dependencyFieldsBuilder.build();
+    List<MethodSpec> injectMethodsForSubclasses = new ArrayList<>();
     for (InjectionSite injectionSite : binding.injectionSites()) {
-      injectMembersWriter
-          .body()
-          .addSnippet(
-              visibleToMembersInjector(binding, injectionSite.element())
-                  ? directInjectMemberSnippet(binding, dependencyFields, injectionSite)
-                  : delegateInjectMemberSnippet(dependencyFields, injectionSite));
+      injectMembersBuilder.addCode(
+          visibleToMembersInjector(binding, injectionSite.element())
+              ? directInjectMemberCodeBlock(binding, dependencyFields, injectionSite)
+              : delegateInjectMemberCodeBlock(dependencyFields, injectionSite));
       if (!injectionSite.element().getModifiers().contains(PUBLIC)
           && injectionSite.element().getEnclosingElement().equals(binding.bindingElement())
           && delegateMethods.add(injectionSiteDelegateMethodName(injectionSite.element()))) {
-        writeInjectorMethodForSubclasses(
-            injectorWriter,
-            dependencyFields,
-            typeParameters,
-            injectedTypeName,
-            injectionSite.element(),
-            injectionSite.dependencies());
+        injectMethodsForSubclasses.add(
+            injectorMethodForSubclasses(
+                dependencyFields,
+                typeParameters,
+                injectedTypeName,
+                injectionSite.element(),
+                injectionSite.dependencies()));
       }
     }
-    
+
     if (usesRawFrameworkTypes) {
-      injectMembersWriter.annotate(SuppressWarnings.class).setValue("unchecked");
+      injectMembersBuilder.addAnnotation(SUPPRESS_WARNINGS_UNCHECKED);
+    }
+
+    injectorTypeBuilder.addMethod(injectMembersBuilder.build());
+    for (MethodSpec methodSpec : injectMethodsForSubclasses) {
+      injectorTypeBuilder.addMethod(methodSpec);
     }
 
-    return ImmutableSet.of(writer);
+    return Optional.of(injectorTypeBuilder);
   }
 
   /**
@@ -241,65 +233,72 @@ private static boolean visibleToMembersInjector(
   }
 
   /**
-   * Returns a snippet that directly injects the instance's field or method.
+   * Returns a code block that directly injects the instance's field or method.
    */
-  private Snippet directInjectMemberSnippet(
+  private CodeBlock directInjectMemberCodeBlock(
       MembersInjectionBinding binding,
-      ImmutableMap<BindingKey, FieldWriter> dependencyFields,
+      ImmutableMap<BindingKey, FieldSpec> dependencyFields,
       InjectionSite injectionSite) {
-    return Snippet.format(
-        injectionSite.element().getKind().isField() ? "%s.%s = %s;" : "%s.%s(%s);",
-        getInstanceSnippetWithPotentialCast(
+    return CodeBlocks.format(
+        injectionSite.element().getKind().isField() ? "$L.$L = $L;" : "$L.$L($L);",
+        getInstanceCodeBlockWithPotentialCast(
             injectionSite.element().getEnclosingElement(), binding.bindingElement()),
         injectionSite.element().getSimpleName(),
-        makeParametersSnippet(
-            parameterSnippets(dependencyFields, injectionSite.dependencies(), true)));
+        makeParametersCodeBlock(
+            parameterCodeBlocks(dependencyFields, injectionSite.dependencies(), true)));
   }
 
   /**
-   * Returns a snippet that injects the instance's field or method by calling a static method on the
-   * parent members injector class.
+   * Returns a code block that injects the instance's field or method by calling a static method on
+   * the parent MembersInjector class.
    */
-  private Snippet delegateInjectMemberSnippet(
-      ImmutableMap<BindingKey, FieldWriter> dependencyFields, InjectionSite injectionSite) {
-    return Snippet.format(
-        "%s.%s(%s);",
-        membersInjectorNameForType(
+  private CodeBlock delegateInjectMemberCodeBlock(
+      ImmutableMap<BindingKey, FieldSpec> dependencyFields, InjectionSite injectionSite) {
+    return CodeBlocks.format(
+        "$L.$L($L);",
+        javapoetMembersInjectorNameForType(
             MoreElements.asType(injectionSite.element().getEnclosingElement())),
         injectionSiteDelegateMethodName(injectionSite.element()),
-        makeParametersSnippet(
-            new ImmutableList.Builder<Snippet>()
-                .add(Snippet.format("instance"))
-                .addAll(parameterSnippets(dependencyFields, injectionSite.dependencies(), false))
+        makeParametersCodeBlock(
+            new ImmutableList.Builder<CodeBlock>()
+                .add(CodeBlocks.format("instance"))
+                .addAll(parameterCodeBlocks(dependencyFields, injectionSite.dependencies(), false))
                 .build()));
   }
 
   /**
    * Returns the parameters for injecting a member.
    *
-   * @param passValue if {@code true}, each parameter snippet will be the result of converting the
-   *     field from the framework type ({@link Provider}, {@link Producer}, etc.) to the real value;
-   *     if {@code false}, each parameter snippet will be just the field
+   * @param passValue if {@code true}, each parameter code block will be the result of converting
+   *     the field from the framework type ({@link Provider}, {@link Producer}, etc.) to the real
+   *     value; if {@code false}, each parameter code block will be just the field
    */
-  private ImmutableList<Snippet> parameterSnippets(
-      ImmutableMap<BindingKey, FieldWriter> dependencyFields,
+  private ImmutableList<CodeBlock> parameterCodeBlocks(
+      ImmutableMap<BindingKey, FieldSpec> dependencyFields,
       ImmutableSet<DependencyRequest> dependencies,
       boolean passValue) {
-    ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
+    ImmutableList.Builder<CodeBlock> parameters = ImmutableList.builder();
     for (DependencyRequest dependency : dependencies) {
-      Snippet fieldSnippet =
-          Snippet.format("%s", dependencyFields.get(dependency.bindingKey()).name());
+      CodeBlock fieldCodeBlock =
+          CodeBlocks.format("$L", dependencyFields.get(dependency.bindingKey()).name);
       parameters.add(
-          passValue ? frameworkTypeUsageStatement(fieldSnippet, dependency.kind()) : fieldSnippet);
+          passValue
+              ? frameworkTypeUsageStatement(fieldCodeBlock, dependency.kind())
+              : fieldCodeBlock);
     }
     return parameters.build();
   }
 
-  private Snippet getInstanceSnippetWithPotentialCast(
+  private CodeBlock getInstanceCodeBlockWithPotentialCast(
       Element injectionSiteElement, Element bindingElement) {
-    return (injectionSiteElement.equals(bindingElement))
-        ? Snippet.format("instance")
-        : Snippet.format("((%s)instance)", injectionSiteElement);
+    if (injectionSiteElement.equals(bindingElement)) {
+      return CodeBlocks.format("instance");
+    }
+    TypeName injectionSiteName = TypeName.get(injectionSiteElement.asType());
+    if (injectionSiteName instanceof ParameterizedTypeName) {
+      injectionSiteName = ((ParameterizedTypeName) injectionSiteName).rawType;
+    }
+    return CodeBlocks.format("(($T) instance)", injectionSiteName);
   }
 
   private String injectionSiteDelegateMethodName(Element injectionSiteElement) {
@@ -308,44 +307,42 @@ private String injectionSiteDelegateMethodName(Element injectionSiteElement) {
             CaseFormat.UPPER_CAMEL, injectionSiteElement.getSimpleName().toString());
   }
 
-  private void writeInjectorMethodForSubclasses(
-      ClassWriter injectorWriter,
-      ImmutableMap<BindingKey, FieldWriter> dependencyFields,
+  private MethodSpec injectorMethodForSubclasses(
+      ImmutableMap<BindingKey, FieldSpec> dependencyFields,
       List<TypeVariableName> typeParameters,
       TypeName injectedTypeName,
       Element injectionElement,
       ImmutableSet<DependencyRequest> dependencies) {
-    MethodWriter methodWriter =
-        injectorWriter.addMethod(VoidName.VOID, injectionSiteDelegateMethodName(injectionElement));
-    methodWriter.addModifiers(PUBLIC, STATIC);
-    methodWriter.addParameter(injectedTypeName, "instance");
-    methodWriter.addTypeParameters(typeParameters);
-    ImmutableList.Builder<Snippet> providedParameters = ImmutableList.builder();
+    MethodSpec.Builder methodBuilder =
+        MethodSpec.methodBuilder(injectionSiteDelegateMethodName(injectionElement))
+            .addModifiers(PUBLIC, STATIC)
+            .addParameter(injectedTypeName, "instance")
+            .addTypeVariables(typeParameters);
+    ImmutableList.Builder<CodeBlock> providedParameters = ImmutableList.builder();
     Set<String> parameterNames = new HashSet<>();
     for (DependencyRequest dependency : dependencies) {
-      FieldWriter field = dependencyFields.get(dependency.bindingKey());
-      VariableWriter parameter =
-          methodWriter.addParameter(
-              field.type(),
-              staticInjectMethodDependencyParameterName(parameterNames, dependency, field));
+      FieldSpec field = dependencyFields.get(dependency.bindingKey());
+      ParameterSpec parameter =
+          ParameterSpec.builder(
+                  field.type,
+                  staticInjectMethodDependencyParameterName(parameterNames, dependency, field))
+              .build();
+      methodBuilder.addParameter(parameter);
       providedParameters.add(
-          frameworkTypeUsageStatement(Snippet.format("%s", parameter.name()), dependency.kind()));
+          frameworkTypeUsageStatement(CodeBlocks.format("$N", parameter), dependency.kind()));
     }
     if (injectionElement.getKind().isField()) {
-      methodWriter
-          .body()
-          .addSnippet(
-              "instance.%s = %s;",
-              injectionElement.getSimpleName(),
-              getOnlyElement(providedParameters.build()));
+      methodBuilder.addStatement(
+          "instance.$L = $L",
+          injectionElement.getSimpleName(),
+          getOnlyElement(providedParameters.build()));
     } else {
-      methodWriter
-          .body()
-          .addSnippet(
-              "instance.%s(%s);",
-              injectionElement.getSimpleName(),
-              makeParametersSnippet(providedParameters.build()));
+      methodBuilder.addStatement(
+          "instance.$L($L)",
+          injectionElement.getSimpleName(),
+          makeParametersCodeBlock(providedParameters.build()));
     }
+    return methodBuilder.build();
   }
 
   /**
@@ -356,14 +353,14 @@ private void writeInjectorMethodForSubclasses(
    * @param field the field used to hold the framework type for the dependency
    */
   private String staticInjectMethodDependencyParameterName(
-      Set<String> parameterNames, DependencyRequest dependency, FieldWriter field) {
+      Set<String> parameterNames, DependencyRequest dependency, FieldSpec field) {
     StringBuilder parameterName =
         new StringBuilder(dependency.requestElement().getSimpleName().toString());
     switch (dependency.kind()) {
       case LAZY:
       case INSTANCE:
       case FUTURE:
-        String suffix = ((ParameterizedTypeName) field.type()).type().simpleName();
+        String suffix = ((ParameterizedTypeName) field.type).rawType.simpleName();
         if (parameterName.length() <= suffix.length()
             || !parameterName.substring(parameterName.length() - suffix.length()).equals(suffix)) {
           parameterName.append(suffix);
@@ -380,10 +377,6 @@ private String staticInjectMethodDependencyParameterName(
     return parameterName.toString();
   }
 
-  private void suppressRawTypesWarning(Modifiable modifiable) {
-    modifiable.annotate(SuppressWarnings.class).setValue("rawtypes");
-  }
-
   private static final TypeVisitor<Boolean, MembersInjectionBinding> VISIBLE_TO_MEMBERS_INJECTOR =
       new SimpleTypeVisitor7<Boolean, MembersInjectionBinding>(true) {
         @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
index c6b3344da..f5f33af1b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
@@ -42,7 +42,7 @@
 import static javax.lang.model.element.Modifier.FINAL;
 
 /** Generates a monitoring module for use with production components. */
-final class MonitoringModuleGenerator extends SourceFileGenerator<TypeElement> {
+final class MonitoringModuleGenerator extends JavaWriterSourceFileGenerator<TypeElement> {
   private static final TypeName SET_OF_FACTORIES =
       ParameterizedTypeName.create(
           Set.class, ClassName.fromClass(ProductionComponentMonitor.Factory.class));
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 154372b77..73600608a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -68,7 +68,7 @@
  * @author Jesse Beder
  * @since 2.0
  */
-final class ProducerFactoryGenerator extends SourceFileGenerator<ProductionBinding> {
+final class ProducerFactoryGenerator extends JavaWriterSourceFileGenerator<ProductionBinding> {
   private final DependencyRequestMapper dependencyRequestMapper;
 
   ProducerFactoryGenerator(
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java
index c2620981a..05c4f3a6d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java
@@ -36,6 +36,7 @@
  * @since 2.0
  */
 final class SourceFileGenerationException extends Exception {
+  // TODO(ronshapiro): remove these unused values
   private final ImmutableSet<ClassName> generatedClassNames;
   private final Optional<? extends Element> associatedElement;
 
@@ -55,6 +56,15 @@
     this(generatedClassNames, cause, Optional.of(associatedElement));
   }
 
+  SourceFileGenerationException(
+      Optional<com.squareup.javapoet.ClassName> generatedClassName,
+      Throwable cause,
+      Optional<? extends Element> associatedElement) {
+    super(createMessage(generatedClassName, cause.getMessage()), cause);
+    this.generatedClassNames = ImmutableSet.of();
+    this.associatedElement = checkNotNull(associatedElement);
+  }
+
   public ImmutableSet<ClassName> generatedClassNames() {
     return generatedClassNames;
   }
@@ -71,6 +81,15 @@ private static String createMessage(Iterable<ClassName> generatedClassNames, Str
         message);
   }
 
+  private static String createMessage(
+      Optional<com.squareup.javapoet.ClassName> generatedClassName, String message) {
+    return String.format("Could not generate %s: %s.",
+        generatedClassName.isPresent()
+            ? generatedClassName.get()
+            : "unknown file",
+        message);
+  }
+
   void printMessageTo(Messager messager) {
     if (associatedElement.isPresent()) {
       messager.printMessage(ERROR, getMessage(), associatedElement.get());
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
index 4dc35ca2a..ddb889f34 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
@@ -15,90 +15,14 @@
  */
 package dagger.internal.codegen;
 
-import com.google.common.base.Function;
-import com.google.common.base.Optional;
-import com.google.common.base.Throwables;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Iterables;
-import dagger.internal.codegen.writer.ClassName;
-import dagger.internal.codegen.writer.JavaWriter;
-import dagger.internal.codegen.writer.TypeWriter;
-import java.io.IOException;
-import javax.annotation.processing.Filer;
-import javax.lang.model.element.Element;
-import javax.lang.model.util.Elements;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-
 /**
- * A template class that provides a framework for properly handling IO while generating source files
- * from an annotation processor.  Particularly, it makes a best effort to ensure that files that
- * fail to write successfully are deleted.
+ * A template for types that generate source files from an annotation processor.
  *
  * @param <T> The input type from which source is to be generated.
  * @author Gregory Kick
  * @since 2.0
  */
-abstract class SourceFileGenerator<T> {
-  private final Filer filer;
-  private final boolean generatedAnnotationAvailable;
-
-  SourceFileGenerator(Filer filer, Elements elements) {
-    this.filer = checkNotNull(filer);
-    generatedAnnotationAvailable = elements.getTypeElement("javax.annotation.Generated") != null;
-  }
-
-  final void generate(T input) throws SourceFileGenerationException {
-    ClassName generatedTypeName = nameGeneratedType(input);
-    ImmutableSet<Element> originatingElements =
-        ImmutableSet.<Element>copyOf(getOriginatingElements(input));
-    try {
-      ImmutableSet<JavaWriter> writers = write(generatedTypeName, input);
-      for (JavaWriter javaWriter : writers) {
-        javaWriter.markGenerated(generatedAnnotationAvailable);
-        try {
-          javaWriter.file(filer, originatingElements);
-        } catch (IOException e) {
-          throw new SourceFileGenerationException(getNamesForWriters(javaWriter.getTypeWriters()),
-              e, getElementForErrorReporting(input));
-        }
-      }
-    } catch (Exception e) {
-      // if the code above threw a SFGE, use that
-      Throwables.propagateIfPossible(e, SourceFileGenerationException.class);
-      // otherwise, throw a new one
-      throw new SourceFileGenerationException(ImmutableList.<ClassName>of(), e,
-          getElementForErrorReporting(input));
-    }
-  }
-
-  private static Iterable<ClassName> getNamesForWriters(Iterable<TypeWriter> typeWriters) {
-    return Iterables.transform(typeWriters, new Function<TypeWriter, ClassName>() {
-      @Override public ClassName apply(TypeWriter input) {
-        return input.name();
-      }
-    });
-  }
-
-  /**
-   * Implementations should return the {@link ClassName} for the top-level type to be generated.
-   */
-  abstract ClassName nameGeneratedType(T input);
-
-  /**
-   * Implementations should return {@link Element} instances from which the source is to be
-   * generated.
-   */
-  abstract Iterable<? extends Element> getOriginatingElements(T input);
-
-  /**
-   * Returns an optional element to be used for reporting errors. This returns a single element
-   * rather than a collection to reduce output noise.
-   */
-  abstract Optional<? extends Element> getElementForErrorReporting(T input);
-
-  /**
-   */
-  abstract ImmutableSet<JavaWriter> write(ClassName generatedTypeName, T input);
+interface SourceFileGenerator<T> {
+  /** Generates a source file to be compiled for {@code T}. */
+  void generate(T input) throws SourceFileGenerationException;
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index d5612ccaf..6701a5d84 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -16,6 +16,8 @@
 import com.google.common.base.CaseFormat;
 import com.google.common.base.Function;
 import com.google.common.base.Functions;
+import com.google.common.base.Joiner;
+import com.google.common.base.Optional;
 import com.google.common.collect.ComparisonChain;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
@@ -25,6 +27,7 @@
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Ordering;
+import com.squareup.javapoet.CodeBlock;
 import dagger.internal.DoubleCheckLazy;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.ParameterizedTypeName;
@@ -50,6 +53,9 @@
  * @since 2.0
  */
 class SourceFiles {
+
+  private static final Joiner CLASS_FILE_NAME_JOINER = Joiner.on('$');
+
   /**
    * Sorts {@link DependencyRequest} instances in an order likely to reflect their logical
    * importance.
@@ -195,7 +201,27 @@ static Snippet frameworkTypeUsageStatement(Snippet frameworkTypeMemberSelect,
         throw new AssertionError();
     }
   }
-  
+
+  static CodeBlock frameworkTypeUsageStatement(
+      CodeBlock frameworkTypeMemberSelect, DependencyRequest.Kind dependencyKind) {
+    switch (dependencyKind) {
+      case LAZY:
+        return CodeBlocks.format(
+            "$T.create($L)",
+            com.squareup.javapoet.ClassName.get(DoubleCheckLazy.class),
+            frameworkTypeMemberSelect);
+      case INSTANCE:
+      case FUTURE:
+        return CodeBlocks.format("$L.get()", frameworkTypeMemberSelect);
+      case PROVIDER:
+      case PRODUCER:
+      case MEMBERS_INJECTOR:
+        return CodeBlocks.format("$L", frameworkTypeMemberSelect);
+      default:
+        throw new AssertionError();
+    }
+  }
+
   /**
    * Returns the generated factory or members injector name for a binding.
    */
@@ -238,52 +264,118 @@ static ClassName generatedClassNameForBinding(Binding binding) {
   static TypeName parameterizedGeneratedTypeNameForBinding(Binding binding) {
     return generatedClassNameForBinding(binding).withTypeParameters(bindingTypeParameters(binding));
   }
-  
-  private static ImmutableList<TypeName> bindingTypeParameters(Binding binding)
+
+  /**
+   * Returns the generated factory or members injector name for a binding.
+   */
+  static com.squareup.javapoet.ClassName javapoetGeneratedClassNameForBinding(Binding binding) {
+    switch (binding.bindingType()) {
+      case PROVISION:
+      case PRODUCTION:
+        ContributionBinding contribution = (ContributionBinding) binding;
+        checkArgument(!contribution.isSyntheticBinding());
+        com.squareup.javapoet.ClassName enclosingClassName =
+            com.squareup.javapoet.ClassName.get(contribution.bindingTypeElement());
+        switch (contribution.bindingKind()) {
+          case INJECTION:
+          case PROVISION:
+          case IMMEDIATE:
+          case FUTURE_PRODUCTION:
+            return enclosingClassName
+                .topLevelClassName()
+                .peerClass(
+                    classFileName(enclosingClassName)
+                        + "_"
+                        + factoryPrefix(contribution)
+                        + "Factory");
+
+          default:
+            throw new AssertionError();
+        }
+
+      case MEMBERS_INJECTION:
+        return javapoetMembersInjectorNameForType(binding.bindingTypeElement());
+
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  static com.squareup.javapoet.TypeName javapoetParameterizedGeneratedTypeNameForBinding(
+      Binding binding) {
+    com.squareup.javapoet.ClassName className = javapoetGeneratedClassNameForBinding(binding);
+    ImmutableList<com.squareup.javapoet.TypeName> typeParameters =
+        javapoetBindingTypeParameters(binding);
+    if (typeParameters.isEmpty()) {
+      return className;
+    } else {
+      return com.squareup.javapoet.ParameterizedTypeName.get(
+          className,
+          FluentIterable.from(typeParameters).toArray(com.squareup.javapoet.TypeName.class));
+    }
+  }
+
+  private static Optional<TypeMirror> typeMirrorForBindingTypeParameters(Binding binding)
       throws AssertionError {
-    TypeMirror bindingType;
     switch (binding.bindingType()) {
       case PROVISION:
       case PRODUCTION:
         ContributionBinding contributionBinding = (ContributionBinding) binding;
         if (contributionBinding.contributionType().isMultibinding()) {
-          return ImmutableList.of();
+          return Optional.absent();
         }
         switch (contributionBinding.bindingKind()) {
           case INJECTION:
-            bindingType = contributionBinding.key().type();
-            break;
-            
+            return Optional.of(contributionBinding.key().type());
+
           case PROVISION:
             // For provision bindings, we parameterize creation on the types of
             // the module, not the types of the binding.
             // Consider: Module<A, B, C> { @Provides List<B> provideB(B b) { .. }}
             // The binding is just parameterized on <B>, but we need all of <A, B, C>.
-            bindingType = contributionBinding.bindingTypeElement().asType();
-            break;
-            
+            return Optional.of(contributionBinding.bindingTypeElement().asType());
+
           case IMMEDIATE:
           case FUTURE_PRODUCTION:
             // TODO(beder): Can these be treated just like PROVISION?
             throw new UnsupportedOperationException();
             
           default:
-            return ImmutableList.of();
+            return Optional.absent();
         }
-        break;
 
       case MEMBERS_INJECTION:
-        bindingType = binding.key().type();
-        break;
+        return Optional.of(binding.key().type());
 
       default:
         throw new AssertionError();
     }
-    TypeName bindingTypeName = TypeNames.forTypeMirror(bindingType);
+  }
+
+  private static ImmutableList<TypeName> bindingTypeParameters(Binding binding) {
+    Optional<TypeMirror> typeMirror = typeMirrorForBindingTypeParameters(binding);
+    if (!typeMirror.isPresent()) {
+      return ImmutableList.of();
+    }
+    TypeName bindingTypeName = TypeNames.forTypeMirror(typeMirror.get());
     return bindingTypeName instanceof ParameterizedTypeName
         ? ((ParameterizedTypeName) bindingTypeName).parameters()
         : ImmutableList.<TypeName>of();
   }
+
+  private static ImmutableList<com.squareup.javapoet.TypeName> javapoetBindingTypeParameters(
+      Binding binding) {
+    Optional<TypeMirror> typeMirror = typeMirrorForBindingTypeParameters(binding);
+    if (!typeMirror.isPresent()) {
+      return ImmutableList.of();
+    }
+    com.squareup.javapoet.TypeName bindingTypeName =
+        com.squareup.javapoet.TypeName.get(typeMirror.get());
+    return bindingTypeName instanceof com.squareup.javapoet.ParameterizedTypeName
+        ? ImmutableList.copyOf(
+            ((com.squareup.javapoet.ParameterizedTypeName) bindingTypeName).typeArguments)
+        : ImmutableList.<com.squareup.javapoet.TypeName>of();
+  }
   
   static ClassName membersInjectorNameForType(TypeElement typeElement) {
     ClassName injectedClassName = ClassName.fromTypeElement(typeElement);
@@ -292,6 +384,19 @@ static ClassName membersInjectorNameForType(TypeElement typeElement) {
         .peerNamed(injectedClassName.classFileName() + "_MembersInjector");
   }
 
+  static com.squareup.javapoet.ClassName javapoetMembersInjectorNameForType(
+      TypeElement typeElement) {
+    com.squareup.javapoet.ClassName injectedClassName =
+        com.squareup.javapoet.ClassName.get(typeElement);
+    return injectedClassName
+        .topLevelClassName()
+        .peerClass(classFileName(injectedClassName) + "_MembersInjector");
+  }
+
+  static String classFileName(com.squareup.javapoet.ClassName className) {
+    return CLASS_FILE_NAME_JOINER.join(className.simpleNames());
+  }
+
   static ClassName generatedMonitoringModuleName(TypeElement componentElement) {
     ClassName componentName = ClassName.fromTypeElement(componentElement);
     return componentName
diff --git a/compiler/src/test/java/dagger/internal/codegen/GeneratedLines.java b/compiler/src/test/java/dagger/internal/codegen/GeneratedLines.java
index 08473a98f..0a37c2294 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GeneratedLines.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GeneratedLines.java
@@ -23,4 +23,9 @@
       "@Generated("
           + "comments = \"https://google.github.io/dagger\", "
           + "value = \"dagger.internal.codegen.ComponentProcessor\")";
+
+  public static final String GENERATED_ANNOTATION_JAVAPOET =
+      "@Generated("
+          + "value = \"dagger.internal.codegen.ComponentProcessor\", "
+          + "comments = \"https://google.github.io/dagger\")";
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
index 5c58ad5f7..2d0a1bf74 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
@@ -34,6 +34,7 @@
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION_JAVAPOET;
 import static javax.tools.StandardLocation.CLASS_OUTPUT;
 
 @RunWith(JUnit4.class)
@@ -226,7 +227,7 @@ public void parentClass_injectedMembersInSupertype() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION,
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class GenericClass_MembersInjector<A, B>",
         "    implements MembersInjector<GenericClass<A, B>> {",
         "  private final Provider<A> aProvider;",
@@ -239,6 +240,11 @@ public void parentClass_injectedMembersInSupertype() {
         "    this.bProvider = bProvider;",
         "  }",
         "",
+        "  public static <A, B> MembersInjector<GenericClass<A, B>> create(",
+        "      Provider<A> aProvider, Provider<B> bProvider) {",
+        "    return new GenericClass_MembersInjector<A, B>(aProvider, bProvider);",
+        "  }",
+        "",
         "  @Override",
         "  public void injectMembers(GenericClass<A, B> instance) {",
         "    if (instance == null) {",
@@ -248,11 +254,6 @@ public void parentClass_injectedMembersInSupertype() {
         "    instance.register(bProvider.get());",
         "  }",
         "",
-        "  public static <A, B> MembersInjector<GenericClass<A, B>> create(",
-        "      Provider<A> aProvider, Provider<B> bProvider) {",
-        "    return new GenericClass_MembersInjector<A, B>(aProvider, bProvider);",
-        "  }",
-        "",
         "  public static <A, B> void injectA(GenericClass<A, B> instance, Provider<A> aProvider) {",
         "    instance.a = aProvider.get();",
         "  }",
@@ -319,7 +320,7 @@ public void parentClass_injectedMembersInSupertype() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION,
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class Child_MembersInjector<T>",
         "    implements MembersInjector<Child<T>> {",
         "  private final Provider<T> tAndXProvider;",
@@ -336,23 +337,23 @@ public void parentClass_injectedMembersInSupertype() {
         "    this.a2Provider = a2Provider;",
         "  }",
         "",
+        "  public static <T> MembersInjector<Child<T>> create(",
+        "      Provider<T> tAndXProvider, Provider<A> aAndYProvider, Provider<A2> a2Provider) {",
+        "    return new Child_MembersInjector<T>(tAndXProvider, aAndYProvider, a2Provider);",
+        "  }",
+        "",
         "  @Override",
         "  public void injectMembers(Child<T> instance) {",
         "    if (instance == null) {",
         "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
         "    }",
-        "    ((test.Parent) instance).x = tAndXProvider.get();",
-        "    ((test.Parent) instance).y = aAndYProvider.get();",
-        "    ((test.Parent) instance).a2 = a2Provider.get();",
+        "    ((Parent) instance).x = tAndXProvider.get();",
+        "    ((Parent) instance).y = aAndYProvider.get();",
+        "    ((Parent) instance).a2 = a2Provider.get();",
         "    instance.a = aAndYProvider.get();",
         "    instance.t = tAndXProvider.get();",
         "  }",
         "",
-        "  public static <T> MembersInjector<Child<T>> create(",
-        "      Provider<T> tAndXProvider, Provider<A> aAndYProvider, Provider<A2> a2Provider) {",
-        "    return new Child_MembersInjector<T>(tAndXProvider, aAndYProvider, a2Provider);",
-        "  }",
-        "",
         "  public static <T> void injectA(Child<T> instance, Provider<A> aProvider) {",
         "    instance.a = aProvider.get();",
         "  }",
@@ -391,7 +392,7 @@ public void parentClass_injectedMembersInSupertype() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION,
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class FieldInjection_MembersInjector",
         "    implements MembersInjector<FieldInjection> {",
         "  private final Provider<String> stringProvider;",
@@ -401,6 +402,10 @@ public void parentClass_injectedMembersInSupertype() {
         "    this.stringProvider = stringProvider;",
         "  }",
         "",
+        "  public static MembersInjector<FieldInjection> create(Provider<String> stringProvider) {",
+        "    return new FieldInjection_MembersInjector(stringProvider);",
+        "  }",
+        "",
         "  @Override",
         "  public void injectMembers(FieldInjection instance) {",
         "    if (instance == null) {",
@@ -411,10 +416,6 @@ public void parentClass_injectedMembersInSupertype() {
         "    instance.stringProvider = stringProvider;",
         "  }",
         "",
-        "  public static MembersInjector<FieldInjection> create(Provider<String> stringProvider) {",
-        "    return new FieldInjection_MembersInjector(stringProvider);",
-        "  }",
-        "",
         "  public static void injectString(",
         "      FieldInjection instance, Provider<String> stringProvider) {",
         "    instance.string = stringProvider.get();",
@@ -461,7 +462,7 @@ public void parentClass_injectedMembersInSupertype() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION,
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class MethodInjection_MembersInjector",
         "     implements MembersInjector<MethodInjection> {",
         "",
@@ -472,6 +473,11 @@ public void parentClass_injectedMembersInSupertype() {
         "    this.stringProvider = stringProvider;",
         "  }",
         "",
+        "  public static MembersInjector<MethodInjection> create(",
+        "      Provider<String> stringProvider) {",
+        "    return new MethodInjection_MembersInjector(stringProvider);",
+        "  }",
+        "",
         "  @Override",
         "  public void injectMembers(MethodInjection instance) {",
         "    if (instance == null) {",
@@ -483,11 +489,6 @@ public void parentClass_injectedMembersInSupertype() {
         "        stringProvider);",
         "  }",
         "",
-        "  public static MembersInjector<MethodInjection> create(",
-        "      Provider<String> stringProvider) {",
-        "    return new MethodInjection_MembersInjector(stringProvider);",
-        "  }",
-        "",
         "  public static void injectNoArgs(MethodInjection instance) {",
         "    instance.noArgs();",
         "  }",
@@ -540,7 +541,7 @@ public void mixedMemberInjection() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION,
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class MixedMemberInjection_MembersInjector",
         "    implements MembersInjector<MixedMemberInjection> {",
         "",
@@ -556,6 +557,13 @@ public void mixedMemberInjection() {
         "    this.objectAndOProvider = objectAndOProvider;",
         "  }",
         "",
+        "  public static MembersInjector<MixedMemberInjection> create(",
+        "      Provider<String> stringAndSProvider,",
+        "      Provider<Object> objectAndOProvider) {",
+        "    return new MixedMemberInjection_MembersInjector(",
+        "        stringAndSProvider, objectAndOProvider);",
+        "  }",
+        "",
         "  @Override",
         "  public void injectMembers(MixedMemberInjection instance) {",
         "    if (instance == null) {",
@@ -567,12 +575,6 @@ public void mixedMemberInjection() {
         "    instance.setObject(objectAndOProvider.get());",
         "  }",
         "",
-        "  public static MembersInjector<MixedMemberInjection> create(",
-        "      Provider<String> stringAndSProvider,",
-        "      Provider<Object> objectAndOProvider) {",
-        "    return new MixedMemberInjection_MembersInjector(",
-        "        stringAndSProvider, objectAndOProvider);",
-        "  }",
         "  public static void injectString(",
         "      MixedMemberInjection instance, Provider<String> stringProvider) {",
         "    instance.string = stringProvider.get();",
@@ -620,7 +622,7 @@ public void mixedMemberInjection() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION,
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class AllInjections_MembersInjector ",
         "    implements MembersInjector<AllInjections> {",
         "",
@@ -631,6 +633,10 @@ public void mixedMemberInjection() {
         "    this.sProvider = sProvider;",
         "  }",
         "",
+        "  public static MembersInjector<AllInjections> create(Provider<String> sProvider) {",
+        "      return new AllInjections_MembersInjector(sProvider);",
+        "  }",
+        "",
         "  @Override",
         "  public void injectMembers(AllInjections instance) {",
         "    if (instance == null) {",
@@ -640,10 +646,6 @@ public void mixedMemberInjection() {
         "    instance.s(sProvider.get());",
         "  }",
         "",
-        "  public static MembersInjector<AllInjections> create(Provider<String> sProvider) {",
-        "      return new AllInjections_MembersInjector(sProvider);",
-        "  }",
-        "",
         "  public static void injectS(AllInjections instance, Provider<String> sProvider) {",
         "    instance.s = sProvider.get();",
         "  }",
@@ -677,7 +679,7 @@ public void mixedMemberInjection() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION,
+        GENERATED_ANNOTATION_JAVAPOET,
         "public final class B_MembersInjector implements MembersInjector<B> {",
         "  private final Provider<String> sProvider;",
         "",
@@ -686,6 +688,10 @@ public void mixedMemberInjection() {
         "    this.sProvider = sProvider;",
         "  }",
         "",
+        "  public static MembersInjector<B> create(Provider<String> sProvider) {",
+        "      return new B_MembersInjector(sProvider);",
+        "  }",
+        "",
         "  @Override",
         "  public void injectMembers(B instance) {",
         "    if (instance == null) {",
@@ -694,9 +700,6 @@ public void mixedMemberInjection() {
         "    instance.s = sProvider.get();",
         "  }",
         "",
-        "  public static MembersInjector<B> create(Provider<String> sProvider) {",
-        "      return new B_MembersInjector(sProvider);",
-        "  }",
         "  public static void injectS(B instance, Provider<String> sProvider) {",
         "    instance.s = sProvider.get();",
         "  }",
@@ -737,31 +740,29 @@ public void simpleComponentWithNesting() {
           "import dagger.MembersInjector;",
           "import javax.annotation.Generated;",
           "import javax.inject.Provider;",
-          "import test.OuterType.A;",
-          "import test.OuterType.B;",
           "",
-        GENERATED_ANNOTATION,
-          "public final class OuterType$B_MembersInjector implements MembersInjector<B> {",
-          "  private final Provider<A> aProvider;",
+          GENERATED_ANNOTATION_JAVAPOET,
+          "public final class OuterType$B_MembersInjector implements MembersInjector<OuterType.B> {",
+          "  private final Provider<OuterType.A> aProvider;",
           "",
-          "  public OuterType$B_MembersInjector(Provider<A> aProvider) {",
+          "  public OuterType$B_MembersInjector(Provider<OuterType.A> aProvider) {",
           "    assert aProvider != null;",
           "    this.aProvider = aProvider;",
           "  }",
           "",
+          "  public static MembersInjector<OuterType.B> create(Provider<OuterType.A> aProvider) {",
+          "    return new OuterType$B_MembersInjector(aProvider);",
+          "  }",
+          "",
           "  @Override",
-          "  public void injectMembers(B instance) {",
+          "  public void injectMembers(OuterType.B instance) {",
           "    if (instance == null) {",
           "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
           "    }",
           "    instance.a = aProvider.get();",
           "  }",
           "",
-          "  public static MembersInjector<B> create(Provider<A> aProvider) {",
-          "    return new OuterType$B_MembersInjector(aProvider);",
-          "  }",
-          "",
-          "  public static void injectA(B instance, Provider<A> aProvider) {",
+          "  public static void injectA(OuterType.B instance, Provider<OuterType.A> aProvider) {",
           "    instance.a = aProvider.get();",
           "  }",
           "}");
@@ -804,31 +805,29 @@ public void componentWithNestingAndGeneratedType() {
             "import dagger.MembersInjector;",
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
-            "import test.OuterType.A;",
-            "import test.OuterType.B;",
             "",
-            GENERATED_ANNOTATION,
-            "public final class OuterType$B_MembersInjector implements MembersInjector<B> {",
-            "  private final Provider<A> aProvider;",
+            GENERATED_ANNOTATION_JAVAPOET,
+            "public final class OuterType$B_MembersInjector implements MembersInjector<OuterType.B> {",
+            "  private final Provider<OuterType.A> aProvider;",
             "",
-            "  public OuterType$B_MembersInjector(Provider<A> aProvider) {",
+            "  public OuterType$B_MembersInjector(Provider<OuterType.A> aProvider) {",
             "    assert aProvider != null;",
             "    this.aProvider = aProvider;",
             "  }",
             "",
+            "  public static MembersInjector<OuterType.B> create(Provider<OuterType.A> aProvider) {",
+            "    return new OuterType$B_MembersInjector(aProvider);",
+            "  }",
+            "",
             "  @Override",
-            "  public void injectMembers(B instance) {",
+            "  public void injectMembers(OuterType.B instance) {",
             "    if (instance == null) {",
             "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
             "    }",
             "    instance.a = aProvider.get();",
             "  }",
             "",
-            "  public static MembersInjector<B> create(Provider<A> aProvider) {",
-            "    return new OuterType$B_MembersInjector(aProvider);",
-            "  }",
-            "",
-            "  public static void injectA(B instance, Provider<A> aProvider) {",
+            "  public static void injectA(OuterType.B instance, Provider<OuterType.A> aProvider) {",
             "    instance.a = aProvider.get();",
             "  }",
             "}");
