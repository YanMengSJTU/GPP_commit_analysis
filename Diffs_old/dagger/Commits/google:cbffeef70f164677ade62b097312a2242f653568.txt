diff --git a/compiler/pom.xml b/compiler/pom.xml
index b052e91d9..8b7120a5b 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -94,7 +94,7 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>org.truth0</groupId>
+      <groupId>com.google.truth</groupId>
       <artifactId>truth</artifactId>
       <scope>test</scope>
     </dependency>
diff --git a/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java b/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java
index 4d6b46c9a..f7b67d6fd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java
@@ -15,20 +15,17 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Objects;
-import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Maps;
-import java.lang.annotation.Annotation;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
-import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
@@ -43,22 +40,6 @@
  * @author Gregory Kick
  */
 final class AnnotationMirrors {
-  /**
-   * An alternative to {@link Element#getAnnotation} that returns an {@link AnnotationMirror} rather
-   * than the weird, half-implementation returned by that method.
-   */
-  static Optional<AnnotationMirror> getAnnotationMirror(Element element,
-      Class<? extends Annotation> annotationType) {
-    String annotationName = annotationType.getName();
-    for (AnnotationMirror annotationMirror : element.getAnnotationMirrors()) {
-      if (MoreElements.asType(annotationMirror.getAnnotationType().asElement())
-          .getQualifiedName().contentEquals(annotationName)) {
-        return Optional.of(annotationMirror);
-      }
-    }
-    return Optional.absent();
-  }
-
   /**
    * Takes a {@link Map} like that returned from {@link Elements#getElementValuesWithDefaults} and
    * key it by the member name rather than the {@link ExecutableElement}.
@@ -81,6 +62,7 @@
         simplifyAnnotationValueMap(elements.getElementValuesWithDefaults(annotationMirror));
     ImmutableList.Builder<TypeMirror> builder = ImmutableList.builder();
 
+    @SuppressWarnings("unchecked") // that's the whole point of this method
     List<? extends AnnotationValue> typeValues =
         (List<? extends AnnotationValue>) valueMap.get(attributeName).getValue();
     for (AnnotationValue typeValue : typeValues) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/Binding.java b/compiler/src/main/java/dagger/internal/codegen/Binding.java
index 89dbc6bac..7d34dc270 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Binding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Binding.java
@@ -16,7 +16,7 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.MoreElements;
-import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
@@ -52,14 +52,15 @@ public TypeElement visitType(TypeElement e, Void p) {
     }, null);
   }
 
-  /** The list of {@link DependencyRequest dependencies} required to satisfy this binding. */
-  abstract ImmutableList<DependencyRequest> dependencies();
+  /** The set of {@link DependencyRequest dependencies} required to satisfy this binding. */
+  abstract ImmutableSet<DependencyRequest> dependencies();
 
   /** Returns the {@link #dependencies()} indexed by {@link Key}. */
-  ImmutableSetMultimap<Key, DependencyRequest> dependenciesByKey() {
-    ImmutableSetMultimap.Builder<Key, DependencyRequest> builder = ImmutableSetMultimap.builder();
+  ImmutableSetMultimap<FrameworkKey, DependencyRequest> dependenciesByKey() {
+    ImmutableSetMultimap.Builder<FrameworkKey, DependencyRequest> builder =
+        ImmutableSetMultimap.builder();
     for (DependencyRequest dependency : dependencies()) {
-      builder.put(dependency.key(), dependency);
+      builder.put(FrameworkKey.forDependencyRequest(dependency), dependency);
     }
     return builder.build();
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 62fabbf5b..b551c51be 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -15,14 +15,15 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
-import com.google.common.collect.LinkedHashMultimap;
-import com.google.common.collect.Maps;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.MultimapBuilder;
 import com.google.common.collect.Queues;
 import com.google.common.collect.SetMultimap;
 import com.google.common.collect.Sets;
@@ -33,7 +34,6 @@
 import java.util.Deque;
 import java.util.LinkedHashSet;
 import java.util.List;
-import java.util.Map;
 import java.util.Queue;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
@@ -43,9 +43,10 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
-import static dagger.internal.codegen.AnnotationMirrors.getAnnotationMirror;
-import static dagger.internal.codegen.DependencyRequest.Kind.MEMBERS_INJECTOR;
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.type.TypeKind.VOID;
 
 /**
  * The logical representation of a {@link Component} definition.
@@ -63,6 +64,11 @@
    */
   abstract TypeElement componentDefinitionType();
 
+  /**
+   *  The set of component dependencies listed in {@link Component#dependencies}.
+   */
+  abstract ImmutableSet<TypeElement> dependencies();
+
   /**
    * The list of {@link DependencyRequest} instances whose sources are methods on the component
    * definition type.  These are the user-requested dependencies.
@@ -137,6 +143,8 @@ ComponentDescriptor create(TypeElement componentDefinitionType) {
           getAnnotationMirror(componentDefinitionType, Component.class).get();
       ImmutableSet<TypeElement> moduleTypes = MoreTypes.asTypeElements(types,
           ConfigurationAnnotations.getComponentModules(elements, componentMirror));
+      ImmutableSet<TypeElement> componentDependencyTypes = MoreTypes.asTypeElements(types,
+          ConfigurationAnnotations.getComponentDependencies(elements, componentMirror));
       ImmutableSet<TypeElement> transitiveModules = getTransitiveModules(moduleTypes);
 
       ProvisionBinding componentBinding =
@@ -147,12 +155,28 @@ ComponentDescriptor create(TypeElement componentDefinitionType) {
               .put(componentBinding.providedKey(), componentBinding);
 
 
+      for (TypeElement componentDependency : componentDependencyTypes) {
+        ProvisionBinding componentDependencyBinding =
+            provisionBindingFactory.forComponent(componentDependency);
+        bindingIndexBuilder.put(
+            componentDependencyBinding.providedKey(), componentDependencyBinding);
+        List<ExecutableElement> dependencyMethods =
+            ElementFilter.methodsIn(elements.getAllMembers(componentDependency));
+        for (ExecutableElement dependencyMethod : dependencyMethods) {
+          if (isComponentProvisionMethod(dependencyMethod)) {
+            ProvisionBinding componentMethodBinding =
+                provisionBindingFactory.forComponentMethod(dependencyMethod);
+            bindingIndexBuilder.put(componentMethodBinding.providedKey(), componentMethodBinding);
+          }
+        }
+      }
+
       for (TypeElement module : transitiveModules) {
         // traverse the modules, collect the bindings
         List<ExecutableElement> moduleMethods =
             ElementFilter.methodsIn(elements.getAllMembers(module));
         for (ExecutableElement moduleMethod : moduleMethods) {
-          if (moduleMethod.getAnnotation(Provides.class) != null) {
+          if (isAnnotationPresent(moduleMethod, Provides.class)) {
             ProvisionBinding providesMethodBinding =
                 provisionBindingFactory.forProvidesMethod(moduleMethod);
             bindingIndexBuilder.put(providesMethodBinding.providedKey(), providesMethodBinding);
@@ -191,65 +215,104 @@ ComponentDescriptor create(TypeElement componentDefinitionType) {
         }
       }
 
-      SetMultimap<Key, ProvisionBinding> resolvedProvisionBindings = LinkedHashMultimap.create();
-      Map<Key, MembersInjectionBinding> resolvedMembersInjectionBindings = Maps.newLinkedHashMap();
-      // TODO(gak): we're really going to need to test this ordering
-      ImmutableSet.Builder<FrameworkKey> resolutionOrder = ImmutableSet.builder();
-
-      for (DependencyRequest requestToResolve = requestsToResolve.pollLast();
-          requestToResolve != null;
-          requestToResolve = requestsToResolve.pollLast()) {
-        Key key = requestToResolve.key();
-        if (requestToResolve.kind().equals(MEMBERS_INJECTOR)) {
-          if (!resolvedMembersInjectionBindings.containsKey(key)) {
-            Optional<MembersInjectionBinding> binding =
-                injectBindingRegistry.getMembersInjectionBindingForKey(key);
-            if (binding.isPresent()) {
-              requestsToResolve.addAll(binding.get().dependencySet());
-              resolvedMembersInjectionBindings.put(key, binding.get());
+      ImmutableSetMultimap.Builder<Key, ProvisionBinding> resolvedProvisionBindings =
+          ImmutableSetMultimap.builder();
+      ImmutableMap.Builder<Key, MembersInjectionBinding> resolvedMembersInjectionBindings =
+          ImmutableMap.builder();
+      SetMultimap<FrameworkKey, Binding> resolvedBindings =
+          MultimapBuilder.linkedHashKeys().linkedHashSetValues().build();
+
+      ImmutableList<DependencyRequest> interfaceRequests = interfaceRequestsBuilder.build();
+
+      for (DependencyRequest interfaceRequest : interfaceRequests) {
+        resolveRequest(interfaceRequest, explicitBindings, resolvedBindings,
+            resolvedProvisionBindings, resolvedMembersInjectionBindings);
+      }
+
+      return new AutoValue_ComponentDescriptor(
+          componentDefinitionType,
+          componentDependencyTypes,
+          interfaceRequests,
+          transitiveModules,
+          resolvedProvisionBindings.build(),
+          resolvedMembersInjectionBindings.build(),
+          ImmutableList.copyOf(resolvedBindings.keySet()));
+    }
+
+    private void resolveRequest(DependencyRequest request,
+        ImmutableSetMultimap<Key, ProvisionBinding> explicitBindings,
+        SetMultimap<FrameworkKey, Binding> resolvedBindings,
+        ImmutableSetMultimap.Builder<Key, ProvisionBinding> resolvedProvisionsBindingBuilder,
+        ImmutableMap.Builder<Key, MembersInjectionBinding> resolvedMembersIjectionBindingsBuilder) {
+      FrameworkKey frameworkKey = FrameworkKey.forDependencyRequest(request);
+      Key requestKey = request.key();
+      if (resolvedBindings.containsKey(frameworkKey)) {
+        return;
+      }
+      switch (request.kind()) {
+        case INSTANCE:
+        case LAZY:
+        case PROVIDER:
+          // First, check for explicit keys (those from modules and components)
+          ImmutableSet<ProvisionBinding> explicitBindingsForKey =
+              explicitBindings.get(requestKey);
+          if (explicitBindingsForKey.isEmpty()) {
+            // no explicit binding, look it up
+            Optional<ProvisionBinding> provisionBinding =
+                injectBindingRegistry.getProvisionBindingForKey(requestKey);
+            if (provisionBinding.isPresent()) {
+              // found a binding, resolve its deps and then mark it resolved
+              for (DependencyRequest dependency : Iterables.concat(
+                  provisionBinding.get().dependencies(),
+                  provisionBinding.get().memberInjectionRequest().asSet())) {
+                resolveRequest(dependency, explicitBindings, resolvedBindings,
+                    resolvedProvisionsBindingBuilder, resolvedMembersIjectionBindingsBuilder);
+              }
+              resolvedBindings.put(frameworkKey, provisionBinding.get());
+              resolvedProvisionsBindingBuilder.put(requestKey, provisionBinding.get());
             } else {
-              // check and generate.
+              throw new UnsupportedOperationException(
+                  "@Injected classes that weren't run with the compoenent processor are "
+                      + "(briefly) unsupported: " + requestKey);
+
             }
-          }
-        } else { // all other requests are provision requests
-          if (!resolvedProvisionBindings.containsKey(key)) {
-            ImmutableSet<ProvisionBinding> explicitBindingsForKey = explicitBindings.get(key);
-            if (explicitBindingsForKey.isEmpty()) {
-              Optional<ProvisionBinding> injectBinding =
-                  injectBindingRegistry.getProvisionBindingForKey(key);
-              if (injectBinding.isPresent()) {
-                requestsToResolve.addAll(injectBinding.get().dependencies());
-                resolvedProvisionBindings.put(key, injectBinding.get());
-                if (injectBinding.get().requiresMemberInjection()) {
-                  DependencyRequest forMembersInjectedType =
-                      dependencyRequestFactory.forMembersInjectedType(
-                          injectBinding.get().providedKey().type());
-                  requestsToResolve.add(forMembersInjectedType);
-                }
-              } else {
-                // TODO(gak): support this
-                throw new UnsupportedOperationException(
-                    "@Injected classes that weren't run with the compoenent processor are "
-                        + "(briefly) unsupported: " + key);
+          } else {
+            // we found explicit bindings. resolve the deps and them mark them resolved
+            for (ProvisionBinding explicitBinding : explicitBindingsForKey) {
+              for (DependencyRequest dependency : explicitBinding.dependencies()) {
+                resolveRequest(dependency, explicitBindings, resolvedBindings,
+                    resolvedProvisionsBindingBuilder, resolvedMembersIjectionBindingsBuilder);
               }
-            } else {
-              resolvedProvisionBindings.putAll(key, explicitBindingsForKey);
             }
-            for (ProvisionBinding binding : explicitBindingsForKey) {
-              requestsToResolve.addAll(binding.dependencies());
+            resolvedBindings.putAll(frameworkKey, explicitBindingsForKey);
+            resolvedProvisionsBindingBuilder.putAll(requestKey, explicitBindingsForKey);
+          }
+          break;
+        case MEMBERS_INJECTOR:
+          // no explicit deps for members injection, so just look it up
+          Optional<MembersInjectionBinding> membersInjectionBinding =
+              injectBindingRegistry.getMembersInjectionBindingForKey(requestKey);
+          if (membersInjectionBinding.isPresent()) {
+            // found a binding, resolve its deps and then mark it resolved
+            for (DependencyRequest dependency : membersInjectionBinding.get().dependencies()) {
+              resolveRequest(dependency, explicitBindings, resolvedBindings,
+                  resolvedProvisionsBindingBuilder, resolvedMembersIjectionBindingsBuilder);
             }
+            resolvedBindings.put(frameworkKey, membersInjectionBinding.get());
+            resolvedMembersIjectionBindingsBuilder.put(requestKey, membersInjectionBinding.get());
+          } else {
+            // TOOD(gak): make an implicit injector for cases where we need one, but it has no
+            // members
           }
-        }
-        resolutionOrder.add(FrameworkKey.forDependencyRequest(requestToResolve));
+          break;
+        default:
+          throw new AssertionError();
       }
+    }
 
-      return new AutoValue_ComponentDescriptor(
-          componentDefinitionType,
-          interfaceRequestsBuilder.build(),
-          moduleTypes,
-          ImmutableSetMultimap.copyOf(resolvedProvisionBindings),
-          ImmutableMap.copyOf(resolvedMembersInjectionBindings),
-          resolutionOrder.build().asList().reverse());
+    private static boolean isComponentProvisionMethod(ExecutableElement method) {
+      return method.getParameters().isEmpty()
+          && !method.getReturnType().getKind().equals(VOID);
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index bf5c18465..3fbea2496 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -15,12 +15,12 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreTypes;
 import com.google.common.base.CaseFormat;
 import com.google.common.base.Function;
 import com.google.common.base.Functions;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
-import com.google.common.collect.ImmutableBiMap;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
@@ -28,7 +28,9 @@
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
 import dagger.Component;
+import dagger.Factory;
 import dagger.MembersInjector;
 import dagger.internal.InstanceFactory;
 import dagger.internal.ScopedProvider;
@@ -43,9 +45,11 @@
 import dagger.internal.codegen.writer.Snippet;
 import dagger.internal.codegen.writer.StringLiteral;
 import dagger.internal.codegen.writer.TypeName;
-import dagger.internal.codegen.writer.TypeReferences;
+import dagger.internal.codegen.writer.VoidName;
+import dagger.internal.codegen.writer.TypeNames;
 import dagger.internal.codegen.writer.VoidName;
 import java.util.List;
+import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
 import javax.annotation.Generated;
@@ -60,6 +64,7 @@
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static dagger.internal.codegen.DependencyRequest.Kind.MEMBERS_INJECTOR;
 import static dagger.internal.codegen.ProvisionBinding.Kind.COMPONENT;
+import static dagger.internal.codegen.ProvisionBinding.Kind.COMPONENT_PROVISION;
 import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
@@ -69,6 +74,7 @@
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
 import static javax.lang.model.type.TypeKind.VOID;
 
 /**
@@ -105,45 +111,104 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
 
   @Override
   JavaWriter write(ClassName componentName, ComponentDescriptor input)  {
-    JavaWriter writer = JavaWriter.inPackage(componentName.packageName());
+    ClassName componentDefinitionTypeName =
+        ClassName.fromTypeElement(input.componentDefinitionType());
 
+    JavaWriter writer = JavaWriter.inPackage(componentName.packageName());
     ClassWriter componentWriter = writer.addClass(componentName.simpleName());
     componentWriter.annotate(Generated.class).setValue(ComponentProcessor.class.getCanonicalName());
     componentWriter.addModifiers(PUBLIC, FINAL);
-    componentWriter.addImplementedType(input.componentDefinitionType());
+    componentWriter.addImplementedType(componentDefinitionTypeName);
+
+    ClassWriter builderWriter = componentWriter.addNestedClass("Builder");
+    builderWriter.addModifiers(PUBLIC, STATIC, FINAL);
+
+    builderWriter.addConstructor().addModifiers(PRIVATE);
+
+    MethodWriter builderFactoryMethod = componentWriter.addMethod(builderWriter, "builder");
+    builderFactoryMethod.addModifiers(PUBLIC, STATIC);
+    builderFactoryMethod.body().addSnippet("return new %s();", builderWriter.name());
 
     ImmutableSetMultimap<Key, ProvisionBinding> resolvedProvisionBindings =
         input.resolvedProvisionBindings();
     ImmutableMap<Key, MembersInjectionBinding> resolvedMembersInjectionBindings =
         input.resolvedMembersInjectionBindings();
 
-    ImmutableBiMap<Key, String> providerNames =
+    ImmutableMap<Key, String> providerNames =
         generateProviderNamesForBindings(resolvedProvisionBindings);
-    ImmutableBiMap<Key, String> membersInjectorNames =
+    Map<Key, FieldWriter> providerFields = Maps.newHashMap();
+    ImmutableMap<Key, String> membersInjectorNames =
         generateMembersInjectorNamesForBindings(resolvedMembersInjectionBindings);
+    Map<Key, FieldWriter> membersInjectorFields = Maps.newHashMap();
 
-    ImmutableBiMap<TypeElement, String> moduleNames =
-        ImmutableBiMap.copyOf(Maps.asMap(input.moduleDependencies(), Functions.compose(
-            CaseFormat.UPPER_CAMEL.converterTo(LOWER_CAMEL),
-            new Function<TypeElement, String>() {
-              @Override public String apply(TypeElement input) {
-                return input.getSimpleName().toString();
-              }
-            })));
+    // the full set of types that calling code uses to construct a component instance
+    ImmutableMap<TypeElement, String> componentContributionNames =
+        ImmutableMap.copyOf(Maps.asMap(
+            Sets.union(input.moduleDependencies(), input.dependencies()),
+            Functions.compose(
+                CaseFormat.UPPER_CAMEL.converterTo(LOWER_CAMEL),
+                new Function<TypeElement, String>() {
+                  @Override public String apply(TypeElement input) {
+                    return input.getSimpleName().toString();
+                  }
+                })));
 
     ConstructorWriter constructorWriter = componentWriter.addConstructor();
-    constructorWriter.addModifiers(PUBLIC);
-    for (Entry<TypeElement, String> entry : moduleNames.entrySet()) {
-      componentWriter.addField(entry.getKey(), entry.getValue())
-          .addModifiers(PRIVATE, FINAL);
-      constructorWriter.addParameter(entry.getKey(), entry.getValue());
+    constructorWriter.addModifiers(PRIVATE);
+    constructorWriter.addParameter(builderWriter, "builder");
+    constructorWriter.body().addSnippet("assert builder != null;");
+
+    MethodWriter buildMethod = builderWriter.addMethod(componentDefinitionTypeName, "build");
+    buildMethod.addModifiers(PUBLIC);
+
+    boolean requiresBuilder = false;
+
+    Map<TypeElement, FieldWriter> componentContributionFields = Maps.newHashMap();
+
+    for (Entry<TypeElement, String> entry : componentContributionNames.entrySet()) {
+      TypeElement contributionElement = entry.getKey();
+      String contributionName = entry.getValue();
+      FieldWriter contributionField =
+          componentWriter.addField(contributionElement, contributionName);
+      contributionField.addModifiers(PRIVATE, FINAL);
+      componentContributionFields.put(contributionElement, contributionField);
+      FieldWriter builderField = builderWriter.addField(contributionElement, contributionName);
+      builderField.addModifiers(PRIVATE);
       constructorWriter.body()
-          .addSnippet("if (%s == null) {", entry.getValue())
+          .addSnippet("this.%1$s = builder.%1$s;", contributionField.name());
+      MethodWriter builderMethod = builderWriter.addMethod(builderWriter, contributionName);
+      builderMethod.addModifiers(PUBLIC);
+      builderMethod.addParameter(contributionElement, contributionName);
+      builderMethod.body()
+          .addSnippet("if (%s == null) {", contributionName)
           .addSnippet("  throw new NullPointerException(%s);",
-              StringLiteral.forValue(entry.getValue()))
+              StringLiteral.forValue(contributionName))
           .addSnippet("}")
-          .addSnippet("this.%1$s = %1$s;", entry.getValue());
+          .addSnippet("this.%s = %s;", builderField.name(), contributionName)
+          .addSnippet("return this;");
+      if (Util.getNoArgsConstructor(contributionElement) == null) {
+        requiresBuilder = true;
+        buildMethod.body()
+            .addSnippet("if (%s == null) {", builderField.name())
+            .addSnippet("  throw new IllegalStateException(\"%s must be set\");",
+                builderField.name())
+            .addSnippet("}");
+      } else {
+        buildMethod.body()
+            .addSnippet("if (%s == null) {", builderField.name())
+            .addSnippet("  this.%s = new %s();",
+                builderField.name(), ClassName.fromTypeElement(contributionElement))
+            .addSnippet("}");
+      }
+    }
 
+    buildMethod.body().addSnippet("return new %s(this);", componentWriter.name());
+
+    if (!requiresBuilder) {
+      MethodWriter factoryMethod = componentWriter.addMethod(componentDefinitionTypeName, "create");
+      factoryMethod.addModifiers(PUBLIC, STATIC);
+      // TODO(gak): replace this with something that doesn't allocate a builder
+      factoryMethod.body().addSnippet("return builder().build();");
     }
 
     for (Entry<Key, String> providerEntry : providerNames.entrySet()) {
@@ -151,20 +216,23 @@ JavaWriter write(ClassName componentName, ComponentDescriptor input)  {
       // TODO(gak): provide more elaborate information about which requests relate
       TypeName providerTypeReferece = ParameterizedTypeName.create(
           ClassName.fromClass(Provider.class),
-          TypeReferences.forTypeMirror(key.type()));
+          TypeNames.forTypeMirror(key.type()));
       FieldWriter providerField =
           componentWriter.addField(providerTypeReferece, providerEntry.getValue());
       providerField.addModifiers(PRIVATE, FINAL);
+      providerFields.put(key, providerField);
     }
-    for (Entry<Key, String> providerEntry : membersInjectorNames.entrySet()) {
-      Key key = providerEntry.getKey();
+
+    for (Entry<Key, String> membersInjectorEntry : membersInjectorNames.entrySet()) {
+      Key key = membersInjectorEntry.getKey();
       // TODO(gak): provide more elaborate information about which requests relate
       TypeName membersInjectorTypeReferece = ParameterizedTypeName.create(
           ClassName.fromClass(MembersInjector.class),
-          TypeReferences.forTypeMirror(key.type()));
+          TypeNames.forTypeMirror(key.type()));
       FieldWriter membersInjectorField =
-          componentWriter.addField(membersInjectorTypeReferece, providerEntry.getValue());
+          componentWriter.addField(membersInjectorTypeReferece, membersInjectorEntry.getValue());
       membersInjectorField.addModifiers(PRIVATE, FINAL);
+      membersInjectorFields.put(key, membersInjectorField);
     }
 
     for (FrameworkKey frameworkKey : input.initializationOrdering()) {
@@ -175,24 +243,24 @@ JavaWriter write(ClassName componentName, ComponentDescriptor input)  {
           ImmutableList.Builder<Snippet> setFactoryParameters = ImmutableList.builder();
           for (ProvisionBinding binding : bindings) {
             setFactoryParameters.add(initializeFactoryForBinding(
-                binding, moduleNames, providerNames,membersInjectorNames));
+                binding, componentContributionFields, providerFields, membersInjectorFields));
           }
           constructorWriter.body().addSnippet("this.%s = %s.create(%n%s);",
-              providerNames.get(key),
+              providerFields.get(key).name(),
               ClassName.fromClass(SetFactory.class),
               Snippet.makeParametersSnippet(setFactoryParameters.build()));
         } else {
           ProvisionBinding binding = Iterables.getOnlyElement(bindings);
           constructorWriter.body().addSnippet("this.%s = %s;",
-              providerNames.get(key),
+              providerFields.get(key).name(),
               initializeFactoryForBinding(
-                  binding, moduleNames, providerNames, membersInjectorNames));
+                  binding, componentContributionFields, providerFields, membersInjectorFields));
         }
       } else if (frameworkKey.frameworkClass().equals(MembersInjector.class)) {
         constructorWriter.body().addSnippet("this.%s = %s;",
-            membersInjectorNames.get(key),
+            membersInjectorFields.get(key).name(),
             initializeMembersInjectorForBinding(resolvedMembersInjectionBindings.get(key),
-                providerNames, membersInjectorNames));
+                providerFields, membersInjectorFields));
       } else {
         throw new IllegalStateException(
             "unknown framework class: " + frameworkKey.frameworkClass());
@@ -208,23 +276,21 @@ JavaWriter write(ClassName componentName, ComponentDescriptor input)  {
       interfaceMethod.annotate(Override.class);
       interfaceMethod.addModifiers(PUBLIC);
       if (interfaceRequest.kind().equals(MEMBERS_INJECTOR)) {
-        String membersInjectorName = membersInjectorNames.get(interfaceRequest.key());
+        String membersInjectorName = membersInjectorFields.get(interfaceRequest.key()).name();
         VariableElement parameter = Iterables.getOnlyElement(requestElement.getParameters());
         Name parameterName = parameter.getSimpleName();
         interfaceMethod.addParameter(
-            TypeReferences.forTypeMirror(parameter.asType()), parameterName.toString());
+            TypeNames.forTypeMirror(parameter.asType()), parameterName.toString());
         interfaceMethod.body()
             .addSnippet("%s.injectMembers(%s);", membersInjectorName, parameterName);
         if (!requestElement.getReturnType().getKind().equals(VOID)) {
           interfaceMethod.body().addSnippet("return %s;", parameterName);
         }
       } else {
-        // provision requests
-        String providerName = providerNames.get(interfaceRequest.key());
-
-        // look up the provider in the Key->name map and invoke.  Done.
+        // look up the provider in the Key->field map and invoke.  Done.
         interfaceMethod.body().addSnippet("return %s;",
-            frameworkTypeUsageStatement(providerName, interfaceRequest.kind()));
+            frameworkTypeUsageStatement(providerFields.get(interfaceRequest.key()).name(),
+                interfaceRequest.kind()));
       }
     }
 
@@ -232,59 +298,70 @@ JavaWriter write(ClassName componentName, ComponentDescriptor input)  {
   }
 
   private Snippet initializeFactoryForBinding(ProvisionBinding binding,
-      ImmutableBiMap<TypeElement, String> moduleNames,
-      ImmutableBiMap<Key, String> providerNames,
-      ImmutableBiMap<Key, String> membersInjectorNames) {
+      Map<TypeElement, FieldWriter> contributionFields,
+      Map<Key, FieldWriter> providerFields,
+      Map<Key, FieldWriter> membersInjectorFields) {
     if (binding.bindingKind().equals(COMPONENT)) {
       return Snippet.format("%s.<%s>create(this)",
           ClassName.fromClass(InstanceFactory.class),
-          TypeReferences.forTypeMirror(binding.providedKey().type()));
+          TypeNames.forTypeMirror(binding.providedKey().type()));
+    } else if (binding.bindingKind().equals(COMPONENT_PROVISION)) {
+      return Snippet.format(Joiner.on('\n').join(
+          "new %s<%2$s>() {",
+          "  @Override public %2$s get() {",
+          "    return %3$s.%4$s();",
+          "  }",
+          "}"),
+          ClassName.fromClass(Factory.class),
+          TypeNames.forTypeMirror(binding.providedKey().type()),
+          contributionFields.get(binding.bindingTypeElement()).name(),
+          binding.bindingElement().getSimpleName().toString());
     } else {
       List<String> parameters = Lists.newArrayListWithCapacity(binding.dependencies().size() + 1);
       if (binding.bindingKind().equals(PROVISION)) {
-        parameters.add(moduleNames.get(binding.bindingTypeElement()));
+        parameters.add(contributionFields.get(binding.bindingTypeElement()).name());
       }
-      if (binding.requiresMemberInjection()) {
-        String membersInjectorName =
-            membersInjectorNames.get(keyFactory.forType(binding.providedKey().type()));
-        if (membersInjectorName != null) {
-          parameters.add(membersInjectorName);
+      if (binding.memberInjectionRequest().isPresent()) {
+        FieldWriter membersInjectorField =
+            membersInjectorFields.get(keyFactory.forType(binding.providedKey().type()));
+        if (membersInjectorField != null) {
+          parameters.add(membersInjectorField.name());
         } else {
           throw new UnsupportedOperationException("Non-generated MembersInjector");
         }
       }
       parameters.addAll(
-          getDependencyParameters(binding.dependencies(), providerNames, membersInjectorNames));
+          getDependencyParameters(binding.dependencies(), providerFields, membersInjectorFields));
       return binding.scope().isPresent()
           ? Snippet.format("%s.create(new %s(%s))",
               ClassName.fromClass(ScopedProvider.class),
-              factoryNameForProvisionBinding(binding).toString(),
+              factoryNameForProvisionBinding(binding),
               Joiner.on(", ").join(parameters))
           : Snippet.format("new %s(%s)",
-              factoryNameForProvisionBinding(binding).toString(),
+              factoryNameForProvisionBinding(binding),
               Joiner.on(", ").join(parameters));
     }
   }
 
   private static Snippet initializeMembersInjectorForBinding(
       MembersInjectionBinding binding,
-      ImmutableBiMap<Key, String> providerNames,
-      ImmutableBiMap<Key, String> membersInjectorNames) {
+      Map<Key, FieldWriter> providerFields,
+      Map<Key, FieldWriter> membersInjectorFields) {
     List<String> parameters = getDependencyParameters(binding.dependencySet(),
-        providerNames, membersInjectorNames);
+        providerFields, membersInjectorFields);
     return Snippet.format("new %s(%s)",
        membersInjectorNameForMembersInjectionBinding(binding).toString(),
         Joiner.on(", ").join(parameters));
   }
 
   private static List<String> getDependencyParameters(Iterable<DependencyRequest> dependencies,
-      ImmutableBiMap<Key, String> providerNames,
-      ImmutableBiMap<Key, String> membersInjectorNames) {
+      Map<Key, FieldWriter> providerFields,
+      Map<Key, FieldWriter> membersInjectorFields) {
     ImmutableList.Builder<String> parameters = ImmutableList.builder();
     for (DependencyRequest dependency : dependencies) {
         parameters.add(dependency.kind().equals(MEMBERS_INJECTOR)
-            ? membersInjectorNames.get(dependency.key())
-            : providerNames.get(dependency.key()));
+            ? membersInjectorFields.get(dependency.key()).name()
+            : providerFields.get(dependency.key()).name());
     }
     return parameters.build();
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcesssingStep.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
similarity index 74%
rename from compiler/src/main/java/dagger/internal/codegen/ComponentProcesssingStep.java
rename to compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
index 4404fee2a..e94c48348 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcesssingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -16,6 +16,7 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.MoreElements;
+import com.google.auto.common.SuperficialValidation;
 import dagger.Component;
 import dagger.internal.codegen.ComponentDescriptor.Factory;
 import java.util.Set;
@@ -30,13 +31,13 @@
  *
  * @author Gregory Kick
  */
-final class ComponentProcesssingStep implements ProcessingStep {
+final class ComponentProcessingStep implements ProcessingStep {
   private final Messager messager;
   private final ComponentValidator componentValidator;
   private final ComponentDescriptor.Factory componentDescriptorFactory;
   private final ComponentGenerator componentGenerator;
 
-  ComponentProcesssingStep(
+  ComponentProcessingStep(
       Messager messager,
       ComponentValidator componentValidator,
       Factory componentDescriptorFactory,
@@ -52,16 +53,18 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
     Set<? extends Element> componentElements = roundEnv.getElementsAnnotatedWith(Component.class);
 
     for (Element element : componentElements) {
-      TypeElement componentTypeElement = MoreElements.asType(element);
-      ValidationReport<TypeElement> report =
-          componentValidator.validate(componentTypeElement);
-      report.printMessagesTo(messager);
+      if (SuperficialValidation.validateElement(element)) {
+        TypeElement componentTypeElement = MoreElements.asType(element);
+        ValidationReport<TypeElement> report =
+            componentValidator.validate(componentTypeElement);
+        report.printMessagesTo(messager);
 
-      if (report.isClean()) {
-        try {
-          componentGenerator.generate(componentDescriptorFactory.create(componentTypeElement));
-        } catch (SourceFileGenerationException e) {
-          e.printMessageTo(messager);
+        if (report.isClean()) {
+          try {
+            componentGenerator.generate(componentDescriptorFactory.create(componentTypeElement));
+          } catch (SourceFileGenerationException e) {
+            e.printMessageTo(messager);
+          }
         }
       }
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 0b74b2a5f..a13950504 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -27,14 +27,12 @@
 import javax.annotation.processing.Messager;
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.annotation.processing.RoundEnvironment;
-import javax.annotation.processing.SupportedSourceVersion;
 import javax.inject.Inject;
+import javax.lang.model.SourceVersion;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
-import static javax.lang.model.SourceVersion.RELEASE_6;
-
 /**
  * The annotation processor responsible for generating the classes that drive the Dagger 2.0
  * implementation.
@@ -44,7 +42,6 @@
  * @author Gregory Kick
  * @since 2.0
  */
-@SupportedSourceVersion(RELEASE_6)
 public final class ComponentProcessor extends AbstractProcessor {
   private ImmutableList<ProcessingStep> processingSteps;
 
@@ -57,6 +54,11 @@
         Provides.class.getName());
   }
 
+  @Override
+  public SourceVersion getSupportedSourceVersion() {
+    return SourceVersion.latestSupported();
+  }
+
   @Override
   public synchronized void init(ProcessingEnvironment processingEnv) {
     super.init(processingEnv);
@@ -104,13 +106,13 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
             injectionSiteFactory,
             membersInjectorGenerator,
             injectBindingRegistry),
-        new ModuleProcesssingStep(
+        new ModuleProcessingStep(
             messager,
             moduleValidator,
             providesMethodValidator,
             provisionBindingFactory,
             factoryGenerator),
-        new ComponentProcesssingStep(
+        new ComponentProcessingStep(
             messager,
             componentValidator,
             componentDescriptorFactory,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
index efc358d37..b625a09e8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
@@ -26,8 +26,8 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleTypeVisitor6;
 
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.common.base.Preconditions.checkState;
-import static dagger.internal.codegen.AnnotationMirrors.getAnnotationMirror;
 import static javax.lang.model.element.ElementKind.CLASS;
 import static javax.lang.model.element.ElementKind.INTERFACE;
 import static javax.lang.model.element.Modifier.ABSTRACT;
diff --git a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
index 1bcb1b57d..1449649e7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -41,6 +41,15 @@
     return getAttributeAsListOfTypes(elements, componentAnnotation, MODULES_ATTRIBUTE);
   }
 
+  private static final String DEPENDENCIES_ATTRIBUTE = "dependencies";
+
+  static ImmutableList<TypeMirror> getComponentDependencies(Elements elements,
+      AnnotationMirror componentAnnotation) {
+    checkNotNull(elements);
+    checkNotNull(componentAnnotation);
+    return getAttributeAsListOfTypes(elements, componentAnnotation, DEPENDENCIES_ATTRIBUTE);
+  }
+
   private static final String INCLUDES_ATTRIBUTE = "includes";
 
   static ImmutableList<TypeMirror> getModuleIncludes(Elements elements,
@@ -50,5 +59,14 @@
     return getAttributeAsListOfTypes(elements, moduleAnnotation, INCLUDES_ATTRIBUTE);
   }
 
+  private static final String INJECTS_ATTRIBUTE = "injects";
+
+  static ImmutableList<TypeMirror> getModuleInjects(Elements elements,
+      AnnotationMirror moduleAnnotation) {
+    checkNotNull(elements);
+    checkNotNull(moduleAnnotation);
+    return getAttributeAsListOfTypes(elements, moduleAnnotation, INJECTS_ATTRIBUTE);
+  }
+
   private ConfigurationAnnotations() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index 7c61d5143..013830eb8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -19,7 +19,7 @@
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import dagger.Lazy;
 import dagger.MembersInjector;
@@ -76,7 +76,7 @@
       this.keyFactory = keyFactory;
     }
 
-    ImmutableList<DependencyRequest> forRequiredVariables(
+    ImmutableSet<DependencyRequest> forRequiredVariables(
         List<? extends VariableElement> variables) {
       return FluentIterable.from(variables)
           .transform(new Function<VariableElement, DependencyRequest>() {
@@ -84,7 +84,7 @@
               return forRequiredVariable(input);
             }
           })
-          .toList();
+          .toSet();
     }
 
     DependencyRequest forRequiredVariable(VariableElement variableElement) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 814314114..8331d0094 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -106,5 +106,8 @@
   static final String PROVIDES_METHOD_NOT_IN_MODULE =
       "@Provides methods can only be present within a @Module";
 
+  static final String PROVIDES_METHOD_WITH_SAME_NAME =
+      "Cannot have more than one @Provides method with the same name in a single module";
+
   private ErrorMessages() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 29f763fd3..8aafacd97 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreTypes;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
@@ -30,7 +31,7 @@
 import dagger.internal.codegen.writer.ParameterizedTypeName;
 import dagger.internal.codegen.writer.Snippet;
 import dagger.internal.codegen.writer.TypeName;
-import dagger.internal.codegen.writer.TypeReferences;
+import dagger.internal.codegen.writer.TypeNames;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map.Entry;
@@ -78,7 +79,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
 
   @Override
   JavaWriter write(ClassName generatedTypeName, ProvisionBinding binding) {
-    TypeName providedTypeName = TypeReferences.forTypeMirror(binding.providedKey().type());
+    TypeName providedTypeName = TypeNames.forTypeMirror(binding.providedKey().type());
     JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
 
     ClassWriter factoryWriter = writer.addClass(generatedTypeName.simpleName());
@@ -103,7 +104,7 @@ JavaWriter write(ClassName generatedTypeName, ProvisionBinding binding) {
           .addSnippet("this.module = module;");
     }
 
-    if (binding.requiresMemberInjection()) {
+    if (binding.memberInjectionRequest().isPresent()) {
       ParameterizedTypeName membersInjectorType = ParameterizedTypeName.create(
           MembersInjector.class, providedTypeName);
       factoryWriter.addField(membersInjectorType, "membersInjector").addModifiers(PRIVATE, FINAL);
@@ -121,12 +122,12 @@ JavaWriter write(ClassName generatedTypeName, ProvisionBinding binding) {
       if (nameEntry.getKey().frameworkClass().equals(Provider.class)) {
         ParameterizedTypeName providerType = ParameterizedTypeName.create(
             ClassName.fromClass(Provider.class),
-            TypeReferences.forTypeMirror(nameEntry.getKey().key().type()));
+            TypeNames.forTypeMirror(nameEntry.getKey().key().type()));
         field = factoryWriter.addField(providerType, nameEntry.getValue());
       } else if (nameEntry.getKey().frameworkClass().equals(MembersInjector.class)) {
         ParameterizedTypeName membersInjectorType = ParameterizedTypeName.create(
             ClassName.fromClass(MembersInjector.class),
-            TypeReferences.forTypeMirror(nameEntry.getKey().key().type()));
+            TypeNames.forTypeMirror(nameEntry.getKey().key().type()));
         field = factoryWriter.addField(membersInjectorType, nameEntry.getValue());
       } else {
         throw new IllegalStateException();
@@ -160,7 +161,7 @@ JavaWriter write(ClassName generatedTypeName, ProvisionBinding binding) {
         default:
           throw new AssertionError();
       }
-    } else if (binding.requiresMemberInjection()) {
+    } else if (binding.memberInjectionRequest().isPresent()) {
       getMethodWriter.body().addSnippet("%1$s instance = new %1$s(%2$s);",
           providedTypeName, parametersSnippet);
       getMethodWriter.body().addSnippet("membersInjector.injectMembers(instance);");
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkKey.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkKey.java
index afb4c0280..ba4f0d003 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkKey.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkKey.java
@@ -16,6 +16,7 @@
 package dagger.internal.codegen;
 
 import com.google.auto.value.AutoValue;
+import com.google.common.base.Function;
 import dagger.MembersInjector;
 import javax.inject.Provider;
 
@@ -30,6 +31,14 @@
  */
 @AutoValue
 abstract class FrameworkKey {
+  static final Function<DependencyRequest, FrameworkKey> REQUEST_TO_FRAMEWORK_KEY =
+      new Function<DependencyRequest, FrameworkKey>() {
+        @Override public FrameworkKey apply(DependencyRequest input) {
+          return forDependencyRequest(input);
+        }
+      };
+
+  // TODO(gak): maybe just put this on DependencyRequest?
   static FrameworkKey forDependencyRequest(DependencyRequest dependencyRequest) {
     final Class<?> frameworkClass;
     switch (dependencyRequest.kind()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisInjectBinding.java b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisInjectBinding.java
index 2d8350157..cbda5a496 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisInjectBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisInjectBinding.java
@@ -30,6 +30,7 @@
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.TypeMirror;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static dagger.internal.codegen.Util.getApplicationSupertype;
 
 /**
@@ -43,7 +44,7 @@
 
   private GraphAnalysisInjectBinding(String provideKey, String membersKey,
       TypeElement type, List<String> keys, String supertypeKey) {
-    super(provideKey, membersKey, type.getAnnotation(Singleton.class) != null,
+    super(provideKey, membersKey, isAnnotationPresent(type, Singleton.class),
         type.getQualifiedName().toString());
     this.type = type;
     this.keys = keys;
@@ -113,11 +114,11 @@ static GraphAnalysisInjectBinding create(TypeElement type, boolean mustHaveInjec
   }
 
   private static boolean hasAtInject(Element enclosed) {
-    return enclosed.getAnnotation(Inject.class) != null;
+    return isAnnotationPresent(enclosed, Inject.class);
   }
 
   private static boolean hasAtSingleton(Element enclosed) {
-    return enclosed.getAnnotation(Singleton.class) != null;
+    return isAnnotationPresent(enclosed, Singleton.class);
   }
 
   @Override public void attach(Linker linker) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
index c42fa09f9..ca305c7fa 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
@@ -58,6 +58,7 @@
 import javax.tools.JavaFileManager;
 import javax.tools.StandardLocation;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static dagger.Provides.Type.SET;
 import static dagger.Provides.Type.SET_VALUES;
 import static dagger.internal.codegen.Util.className;
@@ -337,8 +338,8 @@ void collectIncludesRecursively(
     private final Binding<?>[] parameters;
 
     protected ProviderMethodBinding(String provideKey, ExecutableElement method, boolean library) {
-      super(provideKey, method.getAnnotation(Singleton.class) != null,
-          className(method), method.getSimpleName().toString());
+      super(provideKey, isAnnotationPresent(method, Singleton.class), className(method),
+          method.getSimpleName().toString());
       this.method = method;
       this.parameters = new Binding[method.getParameters().size()];
       setLibrary(library);
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
index cf01552cc..b222ff37b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
@@ -16,6 +16,7 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.SuperficialValidation;
 import com.google.auto.service.AutoService;
 import com.squareup.javawriter.JavaWriter;
 import dagger.MembersInjector;
@@ -25,7 +26,6 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collection;
 import java.util.EnumSet;
 import java.util.Iterator;
 import java.util.LinkedHashSet;
@@ -44,11 +44,11 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.tools.Diagnostic;
 import javax.tools.JavaFileObject;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static dagger.internal.Keys.isPlatformType;
 import static dagger.internal.codegen.AdapterJavadocs.bindingTypeDocs;
 import static dagger.internal.codegen.Util.adapterName;
@@ -67,8 +67,8 @@
 import static javax.lang.model.element.Modifier.STATIC;
 
 /**
- * Generates an implementation of {@link Binding} that injects the
- * {@literal @}{@code Inject}-annotated members of a class.
+ * Generates an implementation of {@link Binding} that injects the {@literal @}{@code Inject}
+ * -annotated members of a class.
  */
 @AutoService(Processor.class)
 @SupportedAnnotationTypes("javax.inject.Inject")
@@ -86,12 +86,7 @@
     for (Iterator<String> i = remainingTypeNames.iterator(); i.hasNext();) {
       InjectedClass injectedClass = createInjectedClass(i.next());
       // Verify that we have access to all types to be injected on this pass.
-      boolean missingDependentClasses =
-          !allTypesExist(injectedClass.fields)
-          || (injectedClass.constructor != null && !allTypesExist(injectedClass.constructor
-              .getParameters()))
-          || !allTypesExist(injectedClass.staticFields);
-      if (!missingDependentClasses) {
+      if (SuperficialValidation.validateElement(injectedClass.type)) {
         try {
           generateInjectionsForClass(injectedClass);
         } catch (IOException e) {
@@ -116,19 +111,6 @@ private void generateInjectionsForClass(InjectedClass injectedClass) throws IOEx
     }
   }
 
-  /**
-   * Return true if all element types are currently available in this code
-   * generation pass. Unavailable types will be of kind {@link TypeKind#ERROR}.
-   */
-  private boolean allTypesExist(Collection<? extends Element> elements) {
-    for (Element element : elements) {
-      if (element.asType().getKind() == TypeKind.ERROR) {
-        return false;
-      }
-    }
-    return true;
-  }
-
   private Set<String> findInjectedClassNames(RoundEnvironment env) {
     // First gather the set of classes that have @Inject-annotated members.
     Set<String> injectedTypeNames = new LinkedHashSet<String>();
@@ -412,7 +394,7 @@ private void writeInjectAdapterConstructor(JavaWriter writer, ExecutableElement
         ? JavaWriter.stringLiteral(GeneratorKeys.get(type.asType()))
         : null;
     String membersKey = JavaWriter.stringLiteral(GeneratorKeys.rawMembersKey(type.asType()));
-    boolean singleton = type.getAnnotation(Singleton.class) != null;
+    boolean singleton = isAnnotationPresent(type, Singleton.class);
     writer.emitStatement("super(%s, %s, %s, %s.class)",
         key, membersKey, (singleton ? "IS_SINGLETON" : "NOT_SINGLETON"), strippedTypeName);
     writer.endMethod();
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index e4fb2586e..836d33cca 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -47,7 +47,7 @@ void registerProvisionBinding(ProvisionBinding binding) {
 
   void registerMembersInjectionBinding(MembersInjectionBinding binding) {
     MembersInjectionBinding previousValue = membersInjectionBindingsByKey.put(
-        keyFactory.forType(binding.injectedType().asType()), binding);
+        keyFactory.forType(binding.bindingElement().asType()), binding);
     checkState(previousValue == null);
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java b/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java
index 1ce9f028e..c5b689a64 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java
@@ -28,6 +28,7 @@
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.util.ElementFilter;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS;
 import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_GENERIC_CLASS;
 import static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_INNER_CLASS;
@@ -92,7 +93,7 @@
         ElementFilter.constructorsIn(enclosingElement.getEnclosedElements()))
             .filter(new Predicate<ExecutableElement>() {
               @Override public boolean apply(ExecutableElement input) {
-                return input.getAnnotation(Inject.class) != null;
+                return isAnnotationPresent(input, Inject.class);
               }
             });
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
index ae47595bf..1a0959c3c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
@@ -16,6 +16,7 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.MoreElements;
+import com.google.auto.common.SuperficialValidation;
 import com.google.common.base.Function;
 import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableSet;
@@ -25,7 +26,6 @@
 import java.util.Set;
 import javax.annotation.processing.Messager;
 import javax.annotation.processing.RoundEnvironment;
-import javax.annotation.processing.SupportedSourceVersion;
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
@@ -33,8 +33,6 @@
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.util.ElementKindVisitor6;
 
-import static javax.lang.model.SourceVersion.RELEASE_6;
-
 /**
  * An annotation processor for generating Dagger implementation code based on the {@link Inject}
  * annotation.
@@ -42,8 +40,7 @@
  * @author Gregory Kick
  * @since 2.0
  */
-@SupportedSourceVersion(RELEASE_6)
-public final class InjectProcessingStep implements ProcessingStep {
+final class InjectProcessingStep implements ProcessingStep {
   private final Messager messager;
   private final InjectConstructorValidator constructorValidator;
   private final InjectFieldValidator fieldValidator;
@@ -82,48 +79,52 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
     final ImmutableSet.Builder<InjectionSite> memberInjectionSites = ImmutableSet.builder();
 
     for (Element injectElement : roundEnv.getElementsAnnotatedWith(Inject.class)) {
-      injectElement.accept(
-          new ElementKindVisitor6<Void, Void>() {
-            @Override
-            public Void visitExecutableAsConstructor(ExecutableElement constructorElement, Void v) {
-              ValidationReport<ExecutableElement> report =
-                  constructorValidator.validate(constructorElement);
-
-              report.printMessagesTo(messager);
-
-              if (report.isClean()) {
-                provisions.add(provisionBindingFactory.forInjectConstructor(constructorElement));
+      if (SuperficialValidation.validateElement(injectElement)) {
+        injectElement.accept(
+            new ElementKindVisitor6<Void, Void>() {
+              @Override
+              public Void visitExecutableAsConstructor(
+                  ExecutableElement constructorElement, Void v) {
+                ValidationReport<ExecutableElement> report =
+                    constructorValidator.validate(constructorElement);
+
+                report.printMessagesTo(messager);
+
+                if (report.isClean()) {
+                  provisions.add(provisionBindingFactory.forInjectConstructor(constructorElement));
+                }
+
+                return null;
               }
 
-              return null;
-            }
+              @Override
+              public Void visitVariableAsField(VariableElement fieldElement, Void p) {
+                ValidationReport<VariableElement> report = fieldValidator.validate(fieldElement);
 
-            @Override
-            public Void visitVariableAsField(VariableElement fieldElement, Void p) {
-              ValidationReport<VariableElement> report = fieldValidator.validate(fieldElement);
+                report.printMessagesTo(messager);
 
-              report.printMessagesTo(messager);
+                if (report.isClean()) {
+                  memberInjectionSites.add(injectionSiteFactory.forInjectField(fieldElement));
+                }
 
-              if (report.isClean()) {
-                memberInjectionSites.add(injectionSiteFactory.forInjectField(fieldElement));
+                return null;
               }
 
-              return null;
-            }
+              @Override
+              public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
+                ValidationReport<ExecutableElement> report =
+                    methodValidator.validate(methodElement);
 
-            @Override
-            public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
-              ValidationReport<ExecutableElement> report = methodValidator.validate(methodElement);
+                report.printMessagesTo(messager);
 
-              report.printMessagesTo(messager);
+                if (report.isClean()) {
+                  memberInjectionSites.add(injectionSiteFactory.forInjectMethod(methodElement));
+                }
 
-              if (report.isClean()) {
-                memberInjectionSites.add(injectionSiteFactory.forInjectMethod(methodElement));
+                return null;
               }
-
-              return null;
-            }
-          }, null);
+            }, null);
+      }
     }
 
     ImmutableListMultimap<TypeElement, InjectionSite> membersInjectionsByType =
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
index 04c017d78..c1769865e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
@@ -26,6 +26,7 @@
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkNotNull;
 
 /**
@@ -77,7 +78,7 @@
     return FluentIterable.from(annotations)
         .filter(new Predicate<AnnotationMirror>() {
           @Override public boolean apply(AnnotationMirror input) {
-            return input.getAnnotationType().asElement().getAnnotation(annotationType) != null;
+            return isAnnotationPresent(input.getAnnotationType().asElement(), annotationType);
           }
         })
         .toSet();
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 3effcc6fe..e52e337e5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Function;
@@ -106,6 +107,14 @@ private TypeElement getSetElement() {
       return elements.getTypeElement(Set.class.getCanonicalName());
     }
 
+    Key forComponentMethod(ExecutableElement componentMethod) {
+      checkNotNull(componentMethod);
+      checkArgument(componentMethod.getKind().equals(METHOD));
+      TypeMirror returnType = normalize(componentMethod.getReturnType());
+      Optional<AnnotationMirror> qualifier = getQualifier(componentMethod);
+      return new AutoValue_Key(rewrap(qualifier), MoreTypes.equivalence().wrap(returnType));
+    }
+
     Key forProvidesMethod(ExecutableElement e) {
       checkNotNull(e);
       checkArgument(e.getKind().equals(METHOD));
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index 97557f890..d55980e7c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -20,13 +20,11 @@
 import com.google.common.base.Function;
 import com.google.common.collect.ComparisonChain;
 import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.ImmutableSortedSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Ordering;
-import java.util.List;
+import java.util.Set;
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
@@ -34,6 +32,7 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 
@@ -45,7 +44,9 @@
  * @since 2.0
  */
 @AutoValue
-abstract class MembersInjectionBinding {
+abstract class MembersInjectionBinding extends Binding {
+  @Override abstract TypeElement bindingElement();
+
   /**
    * Creates a {@link MembersInjectionBinding} for the given bindings.
    *
@@ -61,32 +62,23 @@ static MembersInjectionBinding create(Iterable<InjectionSite> injectionSites) {
           }
         })
         .toSet());
-    return new AutoValue_MembersInjectionBinding(injectedTypeElement, injectionSiteSet);
+    ImmutableSet<DependencyRequest> dependencies = FluentIterable.from(injectionSiteSet)
+        .transformAndConcat(new Function<InjectionSite, Set<DependencyRequest>>() {
+          @Override public Set<DependencyRequest> apply(InjectionSite input) {
+            return input.dependencies();
+          }
+        })
+        .toSet();
+    return new AutoValue_MembersInjectionBinding(
+        dependencies, injectedTypeElement, injectionSiteSet);
   }
 
-  /** The type on which members are injected. */
-  abstract TypeElement injectedType();
-
   /** The set of individual sites where {@link Inject} is applied. */
   abstract ImmutableSortedSet<InjectionSite> injectionSites();
 
   /** The total set of dependencies required by all injection sites. */
   final ImmutableSet<DependencyRequest> dependencySet() {
-    return FluentIterable.from(injectionSites())
-        .transformAndConcat(new Function<InjectionSite, List<DependencyRequest>>() {
-          @Override public List<DependencyRequest> apply(InjectionSite input) {
-            return input.dependencies();
-          }
-        })
-        .toSet();
-  }
-
-  ImmutableSetMultimap<Key, DependencyRequest> dependenciesByKey() {
-    ImmutableSetMultimap.Builder<Key, DependencyRequest> builder = ImmutableSetMultimap.builder();
-    for (DependencyRequest dependency : dependencySet()) {
-      builder.put(dependency.key(), dependency);
-    }
-    return builder.build();
+    return ImmutableSet.copyOf(dependencies());
   }
 
   private static final Ordering<InjectionSite> INJECTION_ORDERING =
@@ -121,7 +113,7 @@ private int targetIndexInEnclosing(InjectionSite injectionSite)  {
 
     abstract Element element();
 
-    abstract ImmutableList<DependencyRequest> dependencies();
+    abstract ImmutableSet<DependencyRequest> dependencies();
 
     static final class Factory {
       private final DependencyRequest.Factory dependencyRequestFactory;
@@ -133,7 +125,7 @@ private int targetIndexInEnclosing(InjectionSite injectionSite)  {
       InjectionSite forInjectMethod(ExecutableElement methodElement) {
         checkNotNull(methodElement);
         checkArgument(methodElement.getKind().equals(ElementKind.METHOD));
-        checkArgument(methodElement.getAnnotation(Inject.class) != null);
+        checkArgument(isAnnotationPresent(methodElement, Inject.class));
         return new AutoValue_MembersInjectionBinding_InjectionSite(Kind.METHOD, methodElement,
             dependencyRequestFactory.forRequiredVariables(methodElement.getParameters()));
       }
@@ -141,9 +133,9 @@ InjectionSite forInjectMethod(ExecutableElement methodElement) {
       InjectionSite forInjectField(VariableElement fieldElement) {
         checkNotNull(fieldElement);
         checkArgument(fieldElement.getKind().equals(ElementKind.FIELD));
-        checkArgument(fieldElement.getAnnotation(Inject.class) != null);
+        checkArgument(isAnnotationPresent(fieldElement, Inject.class));
         return new AutoValue_MembersInjectionBinding_InjectionSite(Kind.FIELD, fieldElement,
-            ImmutableList.of(dependencyRequestFactory.forRequiredVariable(fieldElement)));
+            ImmutableSet.of(dependencyRequestFactory.forRequiredVariable(fieldElement)));
       }
     }
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index ab000fc98..773903b45 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -15,8 +15,6 @@
  */
 package dagger.internal.codegen;
 
-import dagger.internal.codegen.writer.VoidName;
-
 import com.google.auto.common.MoreElements;
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;
@@ -35,7 +33,8 @@
 import dagger.internal.codegen.writer.MethodWriter;
 import dagger.internal.codegen.writer.ParameterizedTypeName;
 import dagger.internal.codegen.writer.Snippet;
-import dagger.internal.codegen.writer.TypeReferences;
+import dagger.internal.codegen.writer.TypeNames;
+import dagger.internal.codegen.writer.VoidName;
 import java.util.Map.Entry;
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
@@ -45,6 +44,7 @@
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
+
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static javax.lang.model.element.Modifier.FINAL;
@@ -86,12 +86,12 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
 
   @Override
   Optional<? extends Element> getElementForErrorReporting(MembersInjectionBinding binding) {
-    return Optional.of(binding.injectedType());
+    return Optional.of(binding.bindingElement());
   }
 
   @Override
   JavaWriter write(ClassName injectorClassName, MembersInjectionBinding binding) {
-    ClassName injectedClassName = ClassName.fromTypeElement(binding.injectedType());
+    ClassName injectedClassName = ClassName.fromTypeElement(binding.bindingElement());
 
     JavaWriter writer = JavaWriter.inPackage(injectedClassName.packageName());
 
@@ -114,7 +114,7 @@ JavaWriter write(ClassName injectorClassName, MembersInjectionBinding binding) {
         "}"));
 
 
-    Optional<TypeElement> supertype = supertype(binding.injectedType());
+    Optional<TypeElement> supertype = supertype(binding.bindingElement());
     if (supertype.isPresent()) {
       ParameterizedTypeName supertypeMemebersInjectorType = ParameterizedTypeName.create(
           MembersInjector.class, ClassName.fromTypeElement(supertype.get()));
@@ -139,12 +139,12 @@ JavaWriter write(ClassName injectorClassName, MembersInjectionBinding binding) {
       if (nameEntry.getKey().frameworkClass().equals(Provider.class)) {
         ParameterizedTypeName providerType = ParameterizedTypeName.create(
             ClassName.fromClass(Provider.class),
-            TypeReferences.forTypeMirror(nameEntry.getKey().key().type()));
+            TypeNames.forTypeMirror(nameEntry.getKey().key().type()));
         field = injectorWriter.addField(providerType, nameEntry.getValue());
       } else if (nameEntry.getKey().frameworkClass().equals(MembersInjector.class)) {
         ParameterizedTypeName membersInjectorType = ParameterizedTypeName.create(
             ClassName.fromClass(MembersInjector.class),
-            TypeReferences.forTypeMirror(nameEntry.getKey().key().type()));
+            TypeNames.forTypeMirror(nameEntry.getKey().key().type()));
         field = injectorWriter.addField(membersInjectorType, nameEntry.getValue());
       } else {
         throw new IllegalStateException();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
index 593f8db81..ba3328a71 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
@@ -61,6 +61,7 @@
 import javax.tools.Diagnostic;
 import javax.tools.JavaFileObject;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static dagger.Provides.Type.SET;
 import static dagger.Provides.Type.SET_VALUES;
 import static dagger.internal.codegen.AdapterJavadocs.bindingTypeDocs;
@@ -80,8 +81,8 @@
 import static javax.lang.model.element.Modifier.STATIC;
 
 /**
- * Generates an implementation of {@link ModuleAdapter} that includes a binding
- * for each {@code @Provides} method of a target class.
+ * Generates an implementation of {@link ModuleAdapter} that includes a binding for each
+ * {@code @Provides} method of a target class.
  */
 @AutoService(Processor.class)
 @SupportedAnnotationTypes({ "*" })
@@ -466,7 +467,7 @@ private void generateProvidesAdapter(JavaWriter writer, ExecutableElement provid
 
     writer.emitEmptyLine();
     writer.beginMethod(null, className, EnumSet.of(PUBLIC), moduleType, "module");
-    boolean singleton = providerMethod.getAnnotation(Singleton.class) != null;
+    boolean singleton = isAnnotationPresent(providerMethod, Singleton.class);
     String key = JavaWriter.stringLiteral(GeneratorKeys.get(providerMethod));
     writer.emitStatement("super(%s, %s, %s, %s)",
         key, (singleton ? "IS_SINGLETON" : "NOT_SINGLETON"),
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleProcesssingStep.java b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
similarity index 59%
rename from compiler/src/main/java/dagger/internal/codegen/ModuleProcesssingStep.java
rename to compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
index bc49fc7eb..0dca93377 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleProcesssingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
@@ -16,6 +16,7 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.MoreElements;
+import com.google.auto.common.SuperficialValidation;
 import com.google.common.base.Function;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
@@ -31,6 +32,7 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.ElementFilter;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static javax.lang.model.element.ElementKind.METHOD;
 
 /**
@@ -40,14 +42,15 @@
  * @author Gregory Kick
  * @since 2.0
  */
-public final class ModuleProcesssingStep implements ProcessingStep {
+final class ModuleProcessingStep implements ProcessingStep {
   private final Messager messager;
   private final ModuleValidator moduleValidator;
   private final ProvidesMethodValidator providesMethodValidator;
   private final ProvisionBinding.Factory provisionBindingFactory;
   private final FactoryGenerator factoryGenerator;
+  private final Set<Element> processedModuleElements = Sets.newLinkedHashSet();
 
-  ModuleProcesssingStep(
+  ModuleProcessingStep(
       Messager messager,
       ModuleValidator moduleValidator,
       ProvidesMethodValidator providesMethodValidator,
@@ -78,47 +81,50 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
     ImmutableSet<ExecutableElement> validProvidesMethods = validProvidesMethodsBuilder.build();
 
     // process each module
-    for (Element moduleElement : roundEnv.getElementsAnnotatedWith(Module.class)) {
-      ValidationReport<TypeElement> report =
-          moduleValidator.validate(MoreElements.asType(moduleElement));
-      report.printMessagesTo(messager);
+    for (Element moduleElement :
+        Sets.difference(roundEnv.getElementsAnnotatedWith(Module.class), processedModuleElements)) {
+      if (SuperficialValidation.validateElement(moduleElement)) {
+        ValidationReport<TypeElement> report =
+            moduleValidator.validate(MoreElements.asType(moduleElement));
+        report.printMessagesTo(messager);
 
-      if (report.isClean()) {
-        ImmutableSet.Builder<ExecutableElement> moduleProvidesMethodsBuilder =
-            ImmutableSet.builder();
-        List<ExecutableElement> moduleMethods =
-            ElementFilter.methodsIn(moduleElement.getEnclosedElements());
-        for (ExecutableElement methodElement : moduleMethods) {
-          if (methodElement.getAnnotation(Provides.class) != null) {
-            moduleProvidesMethodsBuilder.add(methodElement);
+        if (report.isClean()) {
+          ImmutableSet.Builder<ExecutableElement> moduleProvidesMethodsBuilder =
+              ImmutableSet.builder();
+          List<ExecutableElement> moduleMethods =
+              ElementFilter.methodsIn(moduleElement.getEnclosedElements());
+          for (ExecutableElement methodElement : moduleMethods) {
+            if (isAnnotationPresent(methodElement, Provides.class)) {
+              moduleProvidesMethodsBuilder.add(methodElement);
+            }
           }
-        }
-        ImmutableSet<ExecutableElement> moduleProvidesMethods =
-            moduleProvidesMethodsBuilder.build();
+          ImmutableSet<ExecutableElement> moduleProvidesMethods =
+              moduleProvidesMethodsBuilder.build();
 
-        if (Sets.difference(moduleProvidesMethods, validProvidesMethods).isEmpty()) {
-          // all of the provides methods in this module are valid!
-          // time to generate some factories!
-          ImmutableSet<ProvisionBinding> bindings = FluentIterable.from(moduleProvidesMethods)
-              .transform(new Function<ExecutableElement, ProvisionBinding>() {
-                @Override
-                public ProvisionBinding apply(ExecutableElement providesMethod) {
-                  return provisionBindingFactory.forProvidesMethod(providesMethod);
-                }
-              })
-              .toSet();
+          if (Sets.difference(moduleProvidesMethods, validProvidesMethods).isEmpty()) {
+            // all of the provides methods in this module are valid!
+            // time to generate some factories!
+            ImmutableSet<ProvisionBinding> bindings = FluentIterable.from(moduleProvidesMethods)
+                .transform(new Function<ExecutableElement, ProvisionBinding>() {
+                  @Override
+                  public ProvisionBinding apply(ExecutableElement providesMethod) {
+                    return provisionBindingFactory.forProvidesMethod(providesMethod);
+                  }
+                })
+                .toSet();
 
-          try {
-            for (ProvisionBinding binding : bindings) {
-              factoryGenerator.generate(binding);
+            try {
+              for (ProvisionBinding binding : bindings) {
+                factoryGenerator.generate(binding);
+              }
+            } catch (SourceFileGenerationException e) {
+              e.printMessageTo(messager);
             }
-          } catch (SourceFileGenerationException e) {
-            e.printMessageTo(messager);
           }
         }
+        processedModuleElements.add(moduleElement);
       }
     }
-
     return false;
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
index 58c549dfc..bbec9ccb9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
@@ -15,8 +15,18 @@
  */
 package dagger.internal.codegen;
 
+import com.google.common.collect.ImmutableListMultimap;
 import dagger.Module;
+import dagger.Provides;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map.Entry;
+import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.ElementFilter;
+
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_WITH_SAME_NAME;
 
 /**
  * A {@link Validator} for {@link Module}s.
@@ -28,7 +38,23 @@
   @Override
   public ValidationReport<TypeElement> validate(TypeElement subject) {
     ValidationReport.Builder<TypeElement> builder = ValidationReport.Builder.about(subject);
-    // TODO(gak): port the module validation
+    List<ExecutableElement> moduleMethods = ElementFilter.methodsIn(subject.getEnclosedElements());
+    ImmutableListMultimap.Builder<String, ExecutableElement> providesMethodsByName =
+        ImmutableListMultimap.builder();
+    for (ExecutableElement moduleMethod : moduleMethods) {
+      if (isAnnotationPresent(moduleMethod, Provides.class)) {
+        providesMethodsByName.put(moduleMethod.getSimpleName().toString(), moduleMethod);
+      }
+    }
+    for (Entry<String, Collection<ExecutableElement>> entry :
+        providesMethodsByName.build().asMap().entrySet()) {
+      if (entry.getValue().size() > 1) {
+        for (ExecutableElement offendingMethod : entry.getValue()) {
+          builder.addItem(PROVIDES_METHOD_WITH_SAME_NAME, offendingMethod);
+        }
+      }
+    }
+    // TODO(gak): port the dagger 1 module validation
     return builder.build();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MoreTypes.java b/compiler/src/main/java/dagger/internal/codegen/MoreTypes.java
deleted file mode 100644
index 396be1849..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/MoreTypes.java
+++ /dev/null
@@ -1,329 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.auto.common.MoreElements;
-import com.google.common.base.Equivalence;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.ImmutableSet.Builder;
-import java.util.Iterator;
-import java.util.List;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.ArrayType;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.ErrorType;
-import javax.lang.model.type.ExecutableType;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.type.TypeVariable;
-import javax.lang.model.type.TypeVisitor;
-import javax.lang.model.type.WildcardType;
-import javax.lang.model.util.SimpleElementVisitor6;
-import javax.lang.model.util.SimpleTypeVisitor6;
-import javax.lang.model.util.Types;
-
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
-import static javax.lang.model.type.TypeKind.ARRAY;
-import static javax.lang.model.type.TypeKind.DECLARED;
-import static javax.lang.model.type.TypeKind.EXECUTABLE;
-import static javax.lang.model.type.TypeKind.TYPEVAR;
-import static javax.lang.model.type.TypeKind.WILDCARD;
-
-/**
- * Utilities related to {@link TypeMirror} instances.
- *
- * @author Gregory Kick
- * @since 2.0
- */
-final class MoreTypes {
-  private static final Equivalence<TypeMirror> TYPE_EQUIVALENCE = new Equivalence<TypeMirror>() {
-    @Override
-    protected boolean doEquivalent(TypeMirror a, TypeMirror b) {
-      return MoreTypes.equal(a, b);
-    }
-
-    @Override
-    protected int doHash(TypeMirror t) {
-      return MoreTypes.hash(t);
-    }
-  };
-
-  static Equivalence<TypeMirror> equivalence() {
-    return TYPE_EQUIVALENCE;
-  }
-
-  private static final TypeVisitor<Boolean, TypeMirror> EQUAL_VISITOR =
-      new SimpleTypeVisitor6<Boolean, TypeMirror>() {
-        @Override
-        protected Boolean defaultAction(TypeMirror a, TypeMirror b) {
-          return a.getKind().equals(b.getKind());
-        }
-
-        @Override
-        public Boolean visitArray(ArrayType a, TypeMirror m) {
-          if (m.getKind().equals(ARRAY)) {
-            ArrayType b = (ArrayType) m;
-            return equal(a.getComponentType(), b.getComponentType());
-          }
-          return false;
-        }
-
-        @Override
-        public Boolean visitDeclared(DeclaredType a, TypeMirror m) {
-          if (m.getKind().equals(DECLARED)) {
-            DeclaredType b = (DeclaredType) m;
-            return a.asElement().equals(b.asElement())
-                && equal(a.getEnclosingType(), a.getEnclosingType())
-                && equalLists(a.getTypeArguments(), b.getTypeArguments());
-
-          }
-          return false;
-        }
-
-        @Override
-        public Boolean visitError(ErrorType a, TypeMirror m) {
-          return a.equals(m);
-        }
-
-        @Override
-        public Boolean visitExecutable(ExecutableType a, TypeMirror m) {
-          if (m.getKind().equals(EXECUTABLE)) {
-            ExecutableType b = (ExecutableType) m;
-            return equalLists(a.getParameterTypes(), b.getParameterTypes())
-                && equal(a.getReturnType(), b.getReturnType())
-                && equalLists(a.getThrownTypes(), b.getThrownTypes())
-                && equalLists(a.getTypeVariables(), b.getTypeVariables());
-          }
-          return false;
-        }
-
-        @Override
-        public Boolean visitTypeVariable(TypeVariable a, TypeMirror m) {
-          if (m.getKind().equals(TYPEVAR)) {
-            TypeVariable b = (TypeVariable) m;
-            return equal(a.getUpperBound(), b.getUpperBound())
-                && equal(a.getLowerBound(), b.getLowerBound());
-          }
-          return false;
-        }
-
-        @Override
-        public Boolean visitWildcard(WildcardType a, TypeMirror m) {
-          if (m.getKind().equals(WILDCARD)) {
-            WildcardType b = (WildcardType) m;
-            return equal(a.getExtendsBound(), b.getExtendsBound())
-                && equal(a.getSuperBound(), b.getSuperBound());
-          }
-          return false;
-        }
-
-        @Override
-        public Boolean visitUnknown(TypeMirror a, TypeMirror p) {
-          throw new UnsupportedOperationException();
-        }
-      };
-
-  static boolean equal(TypeMirror a, TypeMirror b) {
-    return (a == b) || (a != null && b != null && a.accept(EQUAL_VISITOR, b));
-  }
-
-  private static boolean equalLists(List<? extends TypeMirror> a, List<? extends TypeMirror> b) {
-    int size = a.size();
-    if (size != b.size()) {
-      return false;
-    }
-    // Use iterators in case the Lists aren't RandomAccess
-    Iterator<? extends TypeMirror> aIterator = a.iterator();
-    Iterator<? extends TypeMirror> bIterator = b.iterator();
-    while (aIterator.hasNext()) {
-      if (!bIterator.hasNext()) {
-        return false;
-      }
-      TypeMirror nextMirrorA = aIterator.next();
-      TypeMirror nextMirrorB = bIterator.next();
-      if (!equal(nextMirrorA, nextMirrorB)) {
-        return false;
-      }
-    }
-    return !aIterator.hasNext();
-  }
-
-  private static final int HASH_SEED = 17;
-  private static final int HASH_MULTIPLIER = 31;
-
-  private static final TypeVisitor<Integer, Void> HASH_VISITOR =
-      new SimpleTypeVisitor6<Integer, Void>() {
-          int hashKind(int seed, TypeMirror t) {
-            int result = seed * HASH_MULTIPLIER;
-            result += t.getKind().hashCode();
-            return result;
-          }
-
-          @Override
-          protected Integer defaultAction(TypeMirror e, Void p) {
-            return hashKind(HASH_SEED, e);
-          }
-
-          @Override
-          public Integer visitArray(ArrayType t, Void v) {
-            int result = hashKind(HASH_SEED, t);
-            result *= HASH_MULTIPLIER;
-            result += t.getComponentType().accept(this, null);
-            return result;
-          }
-
-          @Override
-          public Integer visitDeclared(DeclaredType t, Void v) {
-            int result = hashKind(HASH_SEED, t);
-            result *= HASH_MULTIPLIER;
-            result += t.asElement().hashCode();
-            result *= HASH_MULTIPLIER;
-            result += t.getEnclosingType().accept(this, null);
-            result *= HASH_MULTIPLIER;
-            result += hashList(t.getTypeArguments());
-            return result;
-          }
-
-          @Override
-          public Integer visitExecutable(ExecutableType t, Void p) {
-            int result = hashKind(HASH_SEED, t);
-            result *= HASH_MULTIPLIER;
-            result += hashList(t.getParameterTypes());
-            result *= HASH_MULTIPLIER;
-            result += t.getReturnType().accept(this, null);
-            result *= HASH_MULTIPLIER;
-            result += hashList(t.getThrownTypes());
-            result *= HASH_MULTIPLIER;
-            result += hashList(t.getTypeVariables());
-            return result;
-          }
-
-          @Override
-          public Integer visitTypeVariable(TypeVariable t, Void p) {
-            int result = hashKind(HASH_SEED, t);
-            result *= HASH_MULTIPLIER;
-            result += t.getLowerBound().accept(this, null);
-            result *= HASH_MULTIPLIER;
-            result += t.getUpperBound().accept(this, null);
-            return result;
-          }
-
-          @Override
-          public Integer visitWildcard(WildcardType t, Void p) {
-            int result = hashKind(HASH_SEED, t);
-            result *= HASH_MULTIPLIER;
-            result += (t.getExtendsBound() == null) ? 0 : t.getExtendsBound().accept(this, null);
-            result *= HASH_MULTIPLIER;
-            result += (t.getSuperBound() == null) ? 0 : t.getSuperBound().accept(this, null);
-            return result;
-          }
-
-          @Override
-          public Integer visitUnknown(TypeMirror t, Void p) {
-            throw new UnsupportedOperationException();
-          }
-      };
-
-  static int hashList(List<? extends TypeMirror> mirrors) {
-    int result = HASH_SEED;
-    for (TypeMirror mirror : mirrors) {
-      result *= HASH_MULTIPLIER;
-      result += hash(mirror);
-    }
-    return result;
-  }
-
-  static int hash(TypeMirror mirror) {
-    return mirror == null ? 0 : mirror.accept(HASH_VISITOR, null);
-  }
-
-  /**
-   * Returns the set of {@linkplain TypeElement types} that are referenced by the given
-   * {@link TypeMirror}.
-   */
-  static ImmutableSet<TypeElement> referencedTypes(TypeMirror type) {
-    checkNotNull(type);
-    ImmutableSet.Builder<TypeElement> elements = ImmutableSet.builder();
-    type.accept(new SimpleTypeVisitor6<Void, ImmutableSet.Builder<TypeElement>>() {
-      @Override
-      public Void visitArray(ArrayType t, Builder<TypeElement> p) {
-        t.getComponentType().accept(this, p);
-        return null;
-      }
-
-      @Override
-      public Void visitDeclared(DeclaredType t, Builder<TypeElement> p) {
-        p.add(MoreElements.asType(t.asElement()));
-        for (TypeMirror typeArgument : t.getTypeArguments()) {
-          typeArgument.accept(this, p);
-        }
-        return null;
-      }
-
-      @Override
-      public Void visitTypeVariable(TypeVariable t, Builder<TypeElement> p) {
-        t.getLowerBound().accept(this, p);
-        t.getUpperBound().accept(this, p);
-        return null;
-      }
-
-      @Override
-      public Void visitWildcard(WildcardType t, Builder<TypeElement> p) {
-        TypeMirror extendsBound = t.getExtendsBound();
-        if (extendsBound != null) {
-          extendsBound.accept(this, p);
-        }
-        TypeMirror superBound = t.getSuperBound();
-        if (superBound != null) {
-          superBound.accept(this, p);
-        }
-        return null;
-      }
-    }, elements);
-    return elements.build();
-  }
-
-  static TypeElement asTypeElement(Types types, TypeMirror mirror) {
-    checkNotNull(types);
-    checkNotNull(mirror);
-    Element element = types.asElement(mirror);
-    checkArgument(element != null);
-    return element.accept(new SimpleElementVisitor6<TypeElement, Void>() {
-      @Override
-      protected TypeElement defaultAction(Element e, Void p) {
-        throw new IllegalArgumentException();
-      }
-
-      @Override public TypeElement visitType(TypeElement e, Void p) {
-        return e;
-      }
-    }, null);
-  }
-
-  static ImmutableSet<TypeElement> asTypeElements(Types types,
-      Iterable<? extends TypeMirror> mirrors) {
-    checkNotNull(types);
-    checkNotNull(mirrors);
-    ImmutableSet.Builder<TypeElement> builder = ImmutableSet.builder();
-    for (TypeMirror mirror : mirrors) {
-      builder.add(asTypeElement(types, mirror));
-    }
-    return builder.build();
-  }
-
-  private MoreTypes() {}
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
index c7d9a2c6d..bd83613cf 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
@@ -28,6 +28,7 @@
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_ABSTRACT;
@@ -72,7 +73,7 @@ private TypeElement getSetElement() {
     checkArgument(providesAnnotation != null);
 
     Element enclosingElement = providesMethodElement.getEnclosingElement();
-    if (enclosingElement.getAnnotation(Module.class) == null) {
+    if (!isAnnotationPresent(enclosingElement, Module.class)) {
       builder.addItem(PROVIDES_METHOD_NOT_IN_MODULE,
           providesMethodElement);
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index c3276c1f7..0d02cb879 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -18,7 +18,6 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Optional;
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import dagger.Component;
@@ -33,6 +32,7 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.Sets.immutableEnumSet;
@@ -59,6 +59,8 @@
     PROVISION,
     /** Represents the implicit binding to the component. */
     COMPONENT,
+    /** Represents a binding from a provision method on a component dependency. */
+    COMPONENT_PROVISION,
   }
 
   /**
@@ -76,8 +78,8 @@
   /** The scope in which the binding declares the {@link #providedKey()}. */
   abstract Optional<AnnotationMirror> scope();
 
-  /** Returns {@code true} if this provision binding requires members to be injected implicitly. */
-  abstract boolean requiresMemberInjection();
+  /** If this provision requires members injeciton, this will be the corresonding request. */
+  abstract Optional<DependencyRequest> memberInjectionRequest();
 
   private static ImmutableSet<Provides.Type> SET_BINDING_TYPES = immutableEnumSet(SET, SET_VALUES);
 
@@ -117,7 +119,7 @@ static boolean isSetBindingCollection(Iterable<ProvisionBinding> bindings) {
     ProvisionBinding forInjectConstructor(ExecutableElement constructorElement) {
       checkNotNull(constructorElement);
       checkArgument(constructorElement.getKind().equals(CONSTRUCTOR));
-      checkArgument(constructorElement.getAnnotation(Inject.class) != null);
+      checkArgument(isAnnotationPresent(constructorElement, Inject.class));
       Key key = keyFactory.forInjectConstructor(constructorElement);
       checkArgument(!key.qualifier().isPresent());
       return new AutoValue_ProvisionBinding(
@@ -127,25 +129,25 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement) {
           Provides.Type.UNIQUE,
           key,
           getScopeAnnotation(constructorElement.getEnclosingElement()),
-          requiresMemeberInjection(
+          membersInjectionRequest(
               MoreElements.asType(constructorElement.getEnclosingElement())));
     }
 
     private static final ImmutableSet<ElementKind> MEMBER_KINDS =
         Sets.immutableEnumSet(METHOD, FIELD);
 
-    private boolean requiresMemeberInjection(TypeElement type) {
+    private Optional<DependencyRequest> membersInjectionRequest(TypeElement type) {
       if (!types.isSameType(elements.getTypeElement(Object.class.getCanonicalName()).asType(),
           type.getSuperclass())) {
-        return true;
+        return Optional.of(dependencyRequestFactory.forMembersInjectedType(type.asType()));
       }
       for (Element enclosedElement : type.getEnclosedElements()) {
         if (MEMBER_KINDS.contains(enclosedElement.getKind())
-            && (enclosedElement.getAnnotation(Inject.class) != null)) {
-          return true;
+            && (isAnnotationPresent(enclosedElement, Inject.class))) {
+          return Optional.of(dependencyRequestFactory.forMembersInjectedType(type.asType()));
         }
       }
-      return false;
+      return Optional.absent();
     }
 
     ProvisionBinding forProvidesMethod(ExecutableElement providesMethod) {
@@ -160,7 +162,7 @@ ProvisionBinding forProvidesMethod(ExecutableElement providesMethod) {
           providesAnnotation.type(),
           keyFactory.forProvidesMethod(providesMethod),
           getScopeAnnotation(providesMethod),
-          false);
+          Optional.<DependencyRequest>absent());
     }
 
     ProvisionBinding forComponent(TypeElement componentDefinitionType) {
@@ -169,12 +171,26 @@ ProvisionBinding forComponent(TypeElement componentDefinitionType) {
       checkArgument(componentAnnotation != null);
       return new AutoValue_ProvisionBinding(
           componentDefinitionType,
-          ImmutableList.<DependencyRequest>of(),
+          ImmutableSet.<DependencyRequest>of(),
           Kind.COMPONENT,
           Provides.Type.UNIQUE,
           keyFactory.forType(componentDefinitionType.asType()),
           Optional.<AnnotationMirror>absent(),
-          false);
+          Optional.<DependencyRequest>absent());
+    }
+
+    ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
+      checkNotNull(componentMethod);
+      checkArgument(componentMethod.getKind().equals(METHOD));
+      checkArgument(componentMethod.getParameters().isEmpty());
+      return new AutoValue_ProvisionBinding(
+          componentMethod,
+          ImmutableSet.<DependencyRequest>of(),
+          Kind.COMPONENT_PROVISION,
+          Provides.Type.UNIQUE,
+          keyFactory.forComponentMethod(componentMethod),
+          getScopeAnnotation(componentMethod),
+          Optional.<DependencyRequest>absent());
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 5152f027d..1863d7b57 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -15,18 +15,15 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreTypes;
 import com.google.common.base.CaseFormat;
 import com.google.common.base.Function;
-import com.google.common.collect.BiMap;
 import com.google.common.collect.ComparisonChain;
 import com.google.common.collect.FluentIterable;
-import com.google.common.collect.HashBiMap;
-import com.google.common.collect.ImmutableBiMap;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
-import com.google.common.collect.ImmutableSortedMap;
 import com.google.common.collect.ImmutableSortedSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
@@ -182,9 +179,9 @@
   }
 
   // TODO(gak): this needs to suck less
-  static ImmutableBiMap<Key, String> generateProviderNamesForBindings(
+  static ImmutableMap<Key, String> generateProviderNamesForBindings(
       SetMultimap<Key, ProvisionBinding> bindings) {
-    BiMap<Key, String> providerNames = HashBiMap.create(bindings.size());
+    ImmutableMap.Builder<Key, String> providerNames = ImmutableMap.builder();
     for (Entry<Key, Collection<ProvisionBinding>> entry : bindings.asMap().entrySet()) {
       Collection<ProvisionBinding> bindingsForKey = entry.getValue();
       final String name;
@@ -213,17 +210,28 @@ public String visitType(TypeElement e, Void p) {
       }
       providerNames.put(entry.getKey(), name);
     }
-    // return the map so that it is sorted by name
-    return ImmutableBiMap.copyOf(ImmutableSortedMap.copyOf(providerNames.inverse())).inverse();
+    Ordering<Entry<?, String>> entryValueOrdering =
+        Ordering.natural().onResultOf(new Function<Entry<?, String>, String>() {
+          @Override
+          public String apply(Entry<?, String> input) {
+            return input.getValue();
+          }
+        });
+    ImmutableMap.Builder<Key, String> sortedProviderNames = ImmutableMap.builder();
+    for (Entry<Key, String> providerNameEntry :
+      entryValueOrdering.sortedCopy(providerNames.build().entrySet())) {
+      sortedProviderNames.put(providerNameEntry);
+    }
+    return sortedProviderNames.build();
   }
 
-  static ImmutableBiMap<Key, String> generateMembersInjectorNamesForBindings(
+  static ImmutableMap<Key, String> generateMembersInjectorNamesForBindings(
       Map<Key, MembersInjectionBinding> bindings) {
-    return ImmutableBiMap.copyOf(Maps.transformValues(bindings,
+    return ImmutableMap.copyOf(Maps.transformValues(bindings,
         new Function<MembersInjectionBinding, String>() {
           @Override public String apply(MembersInjectionBinding input) {
             return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL,
-                input.injectedType().getSimpleName().toString()) + "MembersInjector";
+                input.bindingElement().getSimpleName().toString()) + "MembersInjector";
           }
         }));
   }
@@ -258,7 +266,7 @@ static ClassName factoryNameForProvisionBinding(ProvisionBinding binding) {
   }
 
   static ClassName membersInjectorNameForMembersInjectionBinding(MembersInjectionBinding binding) {
-    ClassName injectedClassName = ClassName.fromTypeElement(binding.injectedType());
+    ClassName injectedClassName = ClassName.fromTypeElement(binding.bindingElement());
     return injectedClassName.topLevelClassName().peerNamed(
         injectedClassName.classFileName() + "$$MembersInjector");
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ValidationProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ValidationProcessor.java
index 904761cd1..75cf77a40 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ValidationProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ValidationProcessor.java
@@ -40,20 +40,21 @@
 import javax.lang.model.element.TypeElement;
 import javax.tools.Diagnostic;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static dagger.internal.codegen.Util.elementToString;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.ElementKind.METHOD;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 
 /**
- * Checks for errors that are not directly related to modules and
- *  {@code @Inject} annotated elements.
+ * Checks for errors that are not directly related to modules and {@code @Inject} annotated
+ * elements.
  *
- *  <p> Warnings for invalid use of qualifier annotations can be suppressed
- *  with @SuppressWarnings("qualifiers")
+ * <p>Warnings for invalid use of qualifier annotations can be suppressed with
+ * @SuppressWarnings("qualifiers")
  *
- *  <p> Warnings for invalid use of scoping annotations can be suppressed
- *  with @SuppressWarnings("scoping")
+ * <p>Warnings for invalid use of scoping annotations can be suppressed with
+ * @SuppressWarnings("scoping")
  */
 @AutoService(Processor.class)
 @SupportedAnnotationTypes({ "*" })
@@ -80,16 +81,16 @@
   }
 
   private void validateProvides(Element element) {
-    if (element.getAnnotation(Provides.class) != null
+    if (isAnnotationPresent(element, Provides.class)
         && Util.getAnnotation(Module.class, element.getEnclosingElement()) == null) {
       error("@Provides methods must be declared in modules: " + elementToString(element), element);
     }
   }
 
   private void validateQualifiers(Element element, Map<Element, Element> parametersToTheirMethods) {
-    boolean suppressWarnings =
-        element.getAnnotation(SuppressWarnings.class) != null && Arrays.asList(
-            element.getAnnotation(SuppressWarnings.class).value()).contains("qualifiers");
+    boolean suppressWarnings = isAnnotationPresent(element, SuppressWarnings.class)
+       && Arrays.asList(element.getAnnotation(SuppressWarnings.class).value())
+           .contains("qualifiers");
     int numberOfQualifiersOnElement = 0;
     for (AnnotationMirror annotation : element.getAnnotationMirrors()) {
       if (annotation.getAnnotationType().asElement().getAnnotation(Qualifier.class) == null) {
@@ -132,9 +133,8 @@ private void validateQualifiers(Element element, Map<Element, Element> parameter
   }
 
   private void validateScoping(Element element) {
-    boolean suppressWarnings =
-        element.getAnnotation(SuppressWarnings.class) != null && Arrays.asList(
-            element.getAnnotation(SuppressWarnings.class).value()).contains("scoping");
+    boolean suppressWarnings = isAnnotationPresent(element, SuppressWarnings.class)
+        && Arrays.asList(element.getAnnotation(SuppressWarnings.class).value()).contains("scoping");
     int numberOfScopingAnnotationsOnElement = 0;
     for (AnnotationMirror annotation : element.getAnnotationMirrors()) {
       if (annotation.getAnnotationType().asElement().getAnnotation(Scope.class) == null) {
@@ -187,7 +187,7 @@ private void addAllEnclosed(
   }
 
   private boolean isProvidesMethod(Element element) {
-    return element.getKind() == METHOD && element.getAnnotation(Provides.class) != null;
+    return element.getKind() == METHOD && isAnnotationPresent(element, Provides.class);
   }
 
   /**
@@ -196,7 +196,7 @@ private boolean isProvidesMethod(Element element) {
    */
   private boolean isProvidesMethodParameter(
       Element parameter, Map<Element, Element> parametersToTheirMethods) {
-    return parametersToTheirMethods.get(parameter).getAnnotation(Provides.class) != null;
+    return isAnnotationPresent(parametersToTheirMethods.get(parameter), Provides.class);
   }
 
   /**
@@ -206,7 +206,7 @@ private boolean isProvidesMethodParameter(
   private boolean isInjectableConstructorParameter(
       Element parameter, Map<Element, Element> parametersToTheirMethods) {
     return parametersToTheirMethods.get(parameter).getKind() == CONSTRUCTOR
-        && parametersToTheirMethods.get(parameter).getAnnotation(Inject.class) != null;
+        && isAnnotationPresent(parametersToTheirMethods.get(parameter), Inject.class);
   }
 
   private void error(String msg, Element element) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/AnnotationWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/AnnotationWriter.java
index 82ee2034b..2da3420cc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/AnnotationWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/AnnotationWriter.java
@@ -3,7 +3,6 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
 import java.io.IOException;
 import java.util.Map.Entry;
 import java.util.Set;
@@ -32,8 +31,7 @@ public void setMember(String name, String value) {
   }
 
   @Override
-  public Appendable write(Appendable appendable, CompilationUnitContext context)
-      throws IOException {
+  public Appendable write(Appendable appendable, Context context) throws IOException {
     appendable.append('@');
     annotationName.write(appendable, context);
     if (!memberMap.isEmpty()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ArrayTypeName.java b/compiler/src/main/java/dagger/internal/codegen/writer/ArrayTypeName.java
new file mode 100644
index 000000000..537c7baed
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ArrayTypeName.java
@@ -0,0 +1,38 @@
+package dagger.internal.codegen.writer;
+
+import java.io.IOException;
+import java.util.Set;
+
+final class ArrayTypeName implements TypeName {
+  private final TypeName componentType;
+
+  ArrayTypeName(TypeName componentType) {
+    this.componentType = componentType;
+  }
+
+  @Override
+  public Set<ClassName> referencedClasses() {
+    return componentType.referencedClasses();
+  }
+
+  @Override
+  public Appendable write(Appendable appendable, Context context) throws IOException {
+    return componentType.write(appendable, context).append("[]");
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    return (obj instanceof ArrayTypeName)
+        & this.componentType.equals(((ArrayTypeName) obj).componentType);
+  }
+
+  @Override
+  public int hashCode() {
+    return componentType.hashCode();
+  }
+
+  @Override
+  public String toString() {
+    return Writables.writeToString(this);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/BlockWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/BlockWriter.java
index 50bfe2dfc..230a66c95 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/BlockWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/BlockWriter.java
@@ -3,7 +3,6 @@
 import com.google.common.base.Function;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.Lists;
-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
 import java.io.IOException;
 import java.util.List;
 import java.util.Set;
@@ -30,8 +29,7 @@ boolean isEmpty() {
   }
 
   @Override
-  public Appendable write(Appendable appendable, CompilationUnitContext context)
-      throws IOException {
+  public Appendable write(Appendable appendable, Context context) throws IOException {
     for (Snippet snippet : snippets) {
       appendable.append('\n');
       snippet.write(appendable, context);
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ClassName.java b/compiler/src/main/java/dagger/internal/codegen/writer/ClassName.java
index 8e89fe184..64ffc70e7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ClassName.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ClassName.java
@@ -23,7 +23,6 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -48,7 +47,7 @@
  *
  * @since 2.0
  */
-public final class ClassName implements Comparable<ClassName>, TypeName {
+public final class ClassName implements TypeName, Comparable<ClassName> {
   private String fullyQualifiedName = null;
   private final String packageName;
   /* From top to bottom.  E.g.: this field will contian ["A", "B"] for pgk.A.B.C */
@@ -226,8 +225,7 @@ public String toString() {
   }
 
   @Override
-  public Appendable write(Appendable appendable, CompilationUnitContext context)
-      throws IOException {
+  public Appendable write(Appendable appendable, Context context) throws IOException {
     appendable.append(context.sourceReferenceForClassName(this));
     return appendable;
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
index ffe8c8f18..27cda36ed 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
@@ -5,15 +5,15 @@
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
 import java.io.IOException;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.TypeMirror;
 
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PROTECTED;
@@ -21,17 +21,15 @@
 
 public final class ClassWriter extends TypeWriter {
   private final List<TypeWriter> nestedTypeWriters;
-  private final List<FieldWriter> fieldWriters;
+  private final Map<String, FieldWriter> fieldWriters;
   private final List<ConstructorWriter> constructorWriters;
-  private final List<MethodWriter> methodWriters;
   private final List<TypeVariableName> typeVariables;
 
   ClassWriter(ClassName className) {
     super(className);
     this.nestedTypeWriters = Lists.newArrayList();
-    this.fieldWriters = Lists.newArrayList();
+    this.fieldWriters = Maps.newLinkedHashMap();
     this.constructorWriters = Lists.newArrayList();
-    this.methodWriters = Lists.newArrayList();
     this.typeVariables = Lists.newArrayList();
   }
 
@@ -44,20 +42,22 @@ public void addImplementedType(TypeElement typeElement) {
   }
 
   public FieldWriter addField(Class<?> type, String name) {
-    FieldWriter fieldWriter = new FieldWriter(ClassName.fromClass(type), name);
-    fieldWriters.add(fieldWriter);
-    return fieldWriter;
+    return addField(ClassName.fromClass(type), name);
   }
 
   public FieldWriter addField(TypeElement type, String name) {
-    FieldWriter fieldWriter = new FieldWriter(ClassName.fromTypeElement(type), name);
-    fieldWriters.add(fieldWriter);
-    return fieldWriter;
+    return addField(ClassName.fromTypeElement(type), name);
   }
 
   public FieldWriter addField(TypeName type, String name) {
-    FieldWriter fieldWriter = new FieldWriter(type, name);
-    fieldWriters.add(fieldWriter);
+    String candidateName = name;
+    int differentiator = 1;
+    while (fieldWriters.containsKey(candidateName)) {
+      candidateName = name + differentiator;
+      differentiator++;
+    }
+    FieldWriter fieldWriter = new FieldWriter(type, candidateName);
+    fieldWriters.put(candidateName, fieldWriter);
     return fieldWriter;
   }
 
@@ -73,35 +73,15 @@ public ClassWriter addNestedClass(String name) {
     return innerClassWriter;
   }
 
-  public MethodWriter addMethod(TypeWriter returnType, String name) {
-    MethodWriter methodWriter = new MethodWriter(returnType.name, name);
-    methodWriters.add(methodWriter);
-    return methodWriter;
-  }
-
-  public MethodWriter addMethod(TypeMirror returnType, String name) {
-    MethodWriter methodWriter =
-        new MethodWriter(TypeReferences.forTypeMirror(returnType), name);
-    methodWriters.add(methodWriter);
-    return methodWriter;
-  }
-
-  public MethodWriter addMethod(TypeName returnType, String name) {
-    MethodWriter methodWriter = new MethodWriter(returnType, name);
-    methodWriters.add(methodWriter);
-    return methodWriter;
-  }
-
-  public MethodWriter addMethod(Class<?> returnType, String name) {
-    MethodWriter methodWriter =
-        new MethodWriter(ClassName.fromClass(returnType), name);
-    methodWriters.add(methodWriter);
-    return methodWriter;
-  }
-
   @Override
-  public Appendable write(Appendable appendable, CompilationUnitContext context)
-      throws IOException {
+  public Appendable write(Appendable appendable, Context context) throws IOException {
+    context = context.createSubcontext(FluentIterable.from(nestedTypeWriters)
+        .transform(new Function<TypeWriter, ClassName>() {
+          @Override public ClassName apply(TypeWriter input) {
+            return input.name;
+          }
+        })
+        .toSet());
     writeAnnotations(appendable, context);
     writeModifiers(appendable).append("class ").append(name.simpleName());
     if (!typeVariables.isEmpty()) {
@@ -122,22 +102,25 @@ public Appendable write(Appendable appendable, CompilationUnitContext context)
         implementedTypesIterator.next().write(appendable, context);
       }
     }
-    appendable.append(" {\n");
-    for (VariableWriter fieldWriter : fieldWriters) {
+    appendable.append(" {");
+    if (!fieldWriters.isEmpty()) {
+      appendable.append('\n');
+    }
+    for (VariableWriter fieldWriter : fieldWriters.values()) {
       fieldWriter.write(new IndentingAppendable(appendable), context).append("\n");
     }
-    appendable.append('\n');
     for (ConstructorWriter constructorWriter : constructorWriters) {
+      appendable.append('\n');
       if (!isDefaultConstructor(constructorWriter)) {
         constructorWriter.write(new IndentingAppendable(appendable), context);
       }
     }
-    appendable.append('\n');
     for (MethodWriter methodWriter : methodWriters) {
+      appendable.append('\n');
       methodWriter.write(new IndentingAppendable(appendable), context);
     }
-    appendable.append('\n');
     for (TypeWriter nestedTypeWriter : nestedTypeWriters) {
+      appendable.append('\n');
       nestedTypeWriter.write(new IndentingAppendable(appendable), context);
     }
     appendable.append("}\n");
@@ -156,8 +139,8 @@ private boolean isDefaultConstructor(ConstructorWriter constructorWriter) {
   @Override
   public Set<ClassName> referencedClasses() {
     Iterable<? extends HasClassReferences> concat =
-        Iterables.concat(nestedTypeWriters, fieldWriters, constructorWriters, methodWriters,
-            implementedTypes, supertype.asSet(), annotations);
+        Iterables.concat(nestedTypeWriters, fieldWriters.values(), constructorWriters,
+            methodWriters, implementedTypes, supertype.asSet(), annotations);
     return FluentIterable.from(concat)
         .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
           @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ConstructorWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/ConstructorWriter.java
index cbdb6108b..08997ef23 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ConstructorWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ConstructorWriter.java
@@ -5,7 +5,6 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
 import java.io.IOException;
 import java.util.Iterator;
 import java.util.Map;
@@ -68,8 +67,7 @@ private VariableWriter addParameter(ClassName type, String name) {
   }
 
   @Override
-  public Appendable write(Appendable appendable, CompilationUnitContext context)
-      throws IOException {
+  public Appendable write(Appendable appendable, Context context) throws IOException {
     writeModifiers(appendable).append(name).append('(');
     Iterator<VariableWriter> parameterWritersIterator = parameterWriters.values().iterator();
     if (parameterWritersIterator.hasNext()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/FieldWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/FieldWriter.java
index 0d2565774..4477f92d7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/FieldWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/FieldWriter.java
@@ -5,7 +5,6 @@
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
 import java.io.IOException;
 import java.util.Set;
 
@@ -21,9 +20,12 @@ public void setInitializer(Snippet initializer) {
     this.initializer = Optional.of(initializer);
   }
 
+  public void setInitializer(String initializer, Object... args) {
+    this.initializer = Optional.of(Snippet.format(initializer, args));
+  }
+
   @Override
-  public Appendable write(Appendable appendable, CompilationUnitContext context)
-      throws IOException {
+  public Appendable write(Appendable appendable, Context context) throws IOException {
     super.write(appendable, context);
     if (initializer.isPresent()) {
       appendable.append(" = ");
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/HasTypeName.java b/compiler/src/main/java/dagger/internal/codegen/writer/HasTypeName.java
new file mode 100644
index 000000000..30a76fc44
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/HasTypeName.java
@@ -0,0 +1,5 @@
+package dagger.internal.codegen.writer;
+
+interface HasTypeName {
+  TypeName name();
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java
index ce610f63d..f777100c1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java
@@ -3,21 +3,20 @@
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;
 import com.google.common.collect.FluentIterable;
+import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
 import java.io.IOException;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
 
 public class InterfaceWriter extends TypeWriter {
   private final List<TypeVariableName> typeVariables;
-  private final List<MethodWriter> methodWriters;
   private final List<TypeWriter> nestedTypeWriters;
 
   InterfaceWriter(ClassName name) {
     super(name);
     this.typeVariables = Lists.newArrayList();
-    this.methodWriters = Lists.newArrayList();
     this.nestedTypeWriters = Lists.newArrayList();
   }
 
@@ -26,19 +25,41 @@ public void addTypeVariable(TypeVariableName typeVariable) {
   }
 
   @Override
-  public Appendable write(Appendable appendable, CompilationUnitContext context) throws IOException {
-    writeModifiers(appendable).append("class ").append(name.simpleName());
+  public Appendable write(Appendable appendable, Context context) throws IOException {
+    context = context.createSubcontext(FluentIterable.from(nestedTypeWriters)
+        .transform(new Function<TypeWriter, ClassName>() {
+          @Override public ClassName apply(TypeWriter input) {
+            return input.name;
+          }
+        })
+        .toSet());
+    writeAnnotations(appendable, context);
+    writeModifiers(appendable).append("interface ").append(name.simpleName());
     if (!typeVariables.isEmpty()) {
       appendable.append('<');
       Joiner.on(", ").appendTo(appendable, typeVariables);
       appendable.append('>');
     }
-    appendable.append(" {\n");
+    if (supertype.isPresent()) {
+      appendable.append(" extends ");
+      supertype.get().write(appendable, context);
+    }
+    Iterator<TypeName> implementedTypesIterator = implementedTypes.iterator();
+    if (implementedTypesIterator.hasNext()) {
+      appendable.append(" implements ");
+      implementedTypesIterator.next().write(appendable, context);
+      while (implementedTypesIterator.hasNext()) {
+        appendable.append(", ");
+        implementedTypesIterator.next().write(appendable, context);
+      }
+    }
+    appendable.append(" {");
     for (MethodWriter methodWriter : methodWriters) {
+      appendable.append('\n');
       methodWriter.write(new IndentingAppendable(appendable), context);
     }
-    appendable.append('\n');
     for (TypeWriter nestedTypeWriter : nestedTypeWriters) {
+      appendable.append('\n');
       nestedTypeWriter.write(new IndentingAppendable(appendable), context);
     }
     appendable.append("}\n");
@@ -47,7 +68,11 @@ public Appendable write(Appendable appendable, CompilationUnitContext context) t
 
   @Override
   public Set<ClassName> referencedClasses() {
-    return FluentIterable.from(nestedTypeWriters)
+    @SuppressWarnings("unchecked")
+    Iterable<? extends HasClassReferences> concat =
+        Iterables.concat(nestedTypeWriters, methodWriters, implementedTypes, supertype.asSet(),
+            annotations);
+    return FluentIterable.from(concat)
         .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
           @Override
           public Set<ClassName> apply(HasClassReferences input) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
index ff5570cb5..f57e354b3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
@@ -10,7 +10,10 @@
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Ordering;
+import com.google.common.collect.Sets;
+import com.google.common.escape.Escapers;
 import com.google.common.io.Closer;
+import dagger.internal.codegen.writer.Writable.Context;
 import java.io.IOException;
 import java.util.List;
 import java.util.Set;
@@ -110,19 +113,27 @@ public Appendable write(Appendable appendable) throws IOException {
         .addAll(explicitImports)
         .addAll(classNames)
         .build();
+    ImmutableSet<ClassName> typeNames = FluentIterable.from(typeWriters)
+        .transform(new Function<TypeWriter, ClassName>() {
+          @Override public ClassName apply(TypeWriter input) {
+            return input.name;
+          }
+        })
+        .toSet();
     for (ClassName className : importCandidates) {
       if (!(className.packageName().equals(packageName)
               && !className.enclosingClassName().isPresent())
           && !(className.packageName().equals("java.lang")
-              && className.enclosingSimpleNames().isEmpty())) {
+              && className.enclosingSimpleNames().isEmpty())
+          && !typeNames.contains(className.topLevelClassName())) {
         Optional<ClassName> importCandidate = Optional.of(className);
         while (importCandidate.isPresent()
             && importedClassIndex.containsKey(importCandidate.get().simpleName())) {
           importCandidate = importCandidate.get().enclosingClassName();
         }
         if (importCandidate.isPresent()) {
-          appendable.append("import ").append(className.canonicalName()).append(";\n");
-          importedClassIndex.put(className.simpleName(), className);
+          appendable.append("import ").append(importCandidate.get().canonicalName()).append(";\n");
+          importedClassIndex.put(importCandidate.get().simpleName(), importCandidate.get());
         }
       }
     }
@@ -130,11 +141,11 @@ public Appendable write(Appendable appendable) throws IOException {
     appendable.append('\n');
 
     CompilationUnitContext context =
-        new CompilationUnitContext(ImmutableSet.copyOf(importedClassIndex.values()));
+        new CompilationUnitContext(packageName, ImmutableSet.copyOf(importedClassIndex.values()));
 
     // write types
     for (TypeWriter typeWriter : typeWriters) {
-      typeWriter.write(appendable, context).append('\n');
+      typeWriter.write(appendable, context.createSubcontext(typeNames)).append('\n');
     }
     return appendable;
   }
@@ -168,33 +179,58 @@ public String toString() {
     }
   }
 
-  final class CompilationUnitContext {
-    private final ImmutableSortedSet<ClassName> importedClasses;
 
-    CompilationUnitContext(ImmutableSet<ClassName> importedClasses) {
-      this.importedClasses =
-          ImmutableSortedSet.copyOf(Ordering.natural().reverse(), importedClasses);
+  static final class CompilationUnitContext implements Writable.Context {
+    private final String packageName;
+    private final ImmutableSortedSet<ClassName> visibleClasses;
+
+    CompilationUnitContext(String packageName, Set<ClassName> visibleClasses) {
+      this.packageName = packageName;
+      this.visibleClasses =
+          ImmutableSortedSet.copyOf(Ordering.natural().reverse(), visibleClasses);
+    }
+
+    @Override
+    public Context createSubcontext(Set<ClassName> newTypes) {
+      return new CompilationUnitContext(packageName, Sets.union(visibleClasses, newTypes));
     }
 
-    String sourceReferenceForClassName(ClassName className) {
+    @Override
+    public String sourceReferenceForClassName(ClassName className) {
       if (isImported(className)) {
         return className.simpleName();
       }
       Optional<ClassName> enclosingClassName = className.enclosingClassName();
       while (enclosingClassName.isPresent()) {
         if (isImported(enclosingClassName.get())) {
-          return className.canonicalName()
-              .substring(enclosingClassName.get().canonicalName().length() + 1);
+          return enclosingClassName.get().simpleName()
+              + className.canonicalName()
+                  .substring(enclosingClassName.get().canonicalName().length());
         }
         enclosingClassName = enclosingClassName.get().enclosingClassName();
       }
       return className.canonicalName();
     }
 
+    private boolean collidesWithVisibleClass(ClassName className) {
+      return collidesWithVisibleClass(className.simpleName());
+    }
+
+    private boolean collidesWithVisibleClass(String simpleName) {
+      return FluentIterable.from(visibleClasses)
+          .transform(new Function<ClassName, String>() {
+            @Override public String apply(ClassName input) {
+              return input.simpleName();
+            }
+          })
+          .contains(simpleName);
+    }
+
     private boolean isImported(ClassName className) {
       return (packageName.equals(className.packageName())
-              && !className.enclosingClassName().isPresent()) // need to account for scope & hiding
-          || importedClasses.contains(className)
+              && !className.enclosingClassName().isPresent()
+              && !collidesWithVisibleClass(className)) // need to account for scope & hiding
+          || visibleClasses.contains(className)
           || (className.packageName().equals("java.lang")
               && className.enclosingSimpleNames().isEmpty());
     }
@@ -202,10 +238,10 @@ private boolean isImported(ClassName className) {
     private static final String JAVA_IDENTIFIER_REGEX =
         "\\p{javaJavaIdentifierStart}\\p{javaJavaIdentifierPart}*";
 
-    String compressTypesWithin(String snippet) {
-
+    @Override
+    public String compressTypesWithin(String snippet) {
       // TODO(gak): deal with string literals
-      for (ClassName importedClass : importedClasses) {
+      for (ClassName importedClass : visibleClasses) {
         snippet = snippet.replace(importedClass.canonicalName(), importedClass.simpleName());
       }
       Pattern samePackagePattern = Pattern.compile(
@@ -213,7 +249,9 @@ String compressTypesWithin(String snippet) {
       Matcher matcher = samePackagePattern.matcher(snippet);
       StringBuffer buffer = new StringBuffer();
       while (matcher.find()) {
-        matcher.appendReplacement(buffer, "$1$2");
+        matcher.appendReplacement(buffer, collidesWithVisibleClass(matcher.group(1))
+            ? Escapers.builder().addEscape('$', "\\$").build().escape(matcher.group())
+            : "$1$2");
       }
       matcher.appendTail(buffer);
       return buffer.toString();
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java
index 29d672768..d8d71c8e9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java
@@ -6,11 +6,11 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
 import java.io.IOException;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Set;
+import javax.lang.model.element.TypeElement;
 
 import static com.google.common.base.Preconditions.checkArgument;
 
@@ -32,6 +32,10 @@ public VariableWriter addParameter(Class<?> type, String name) {
     return addParameter(ClassName.fromClass(type), name);
   }
 
+  public VariableWriter addParameter(TypeElement type, String name) {
+    return addParameter(ClassName.fromTypeElement(type), name);
+  }
+
   public VariableWriter addParameter(TypeWriter type, String name) {
     return addParameter(type.name, name);
   }
@@ -54,8 +58,7 @@ public BlockWriter body() {
   }
 
   @Override
-  public Appendable write(Appendable appendable, CompilationUnitContext context)
-      throws IOException {
+  public Appendable write(Appendable appendable, Context context) throws IOException {
     writeAnnotations(appendable, context);
     writeModifiers(appendable);
     returnType.write(appendable, context);
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Modifiable.java b/compiler/src/main/java/dagger/internal/codegen/writer/Modifiable.java
index 86ec45eda..9840ef830 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/Modifiable.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/Modifiable.java
@@ -1,7 +1,7 @@
 package dagger.internal.codegen.writer;
 
 import com.google.common.collect.Lists;
-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
+import dagger.internal.codegen.writer.Writable.Context;
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.util.EnumSet;
@@ -36,8 +36,7 @@ Appendable writeModifiers(Appendable appendable) throws IOException {
     return appendable;
   }
 
-  Appendable writeAnnotations(Appendable appendable, CompilationUnitContext context)
-      throws IOException {
+  Appendable writeAnnotations(Appendable appendable, Context context) throws IOException {
     for (AnnotationWriter annotationWriter : annotations) {
       annotationWriter.write(appendable, context).append('\n');
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/NullName.java b/compiler/src/main/java/dagger/internal/codegen/writer/NullName.java
new file mode 100644
index 000000000..4336f94e5
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/NullName.java
@@ -0,0 +1,24 @@
+package dagger.internal.codegen.writer;
+
+import com.google.common.collect.ImmutableSet;
+import java.io.IOException;
+import java.util.Set;
+
+enum NullName implements TypeName {
+  NULL;
+
+  @Override
+  public Set<ClassName> referencedClasses() {
+    return ImmutableSet.of();
+  }
+
+  @Override
+  public Appendable write(Appendable appendable, Context context) throws IOException {
+    return appendable.append("null");
+  }
+
+  @Override
+  public String toString() {
+    return "null";
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ParameterizedTypeName.java b/compiler/src/main/java/dagger/internal/codegen/writer/ParameterizedTypeName.java
index 6e620a7eb..ec7547b26 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ParameterizedTypeName.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ParameterizedTypeName.java
@@ -1,9 +1,8 @@
 package dagger.internal.codegen.writer;
 
-import com.google.common.base.Joiner;
+import com.google.common.base.Objects;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
 import java.io.IOException;
 import java.util.Iterator;
 import java.util.Set;
@@ -31,8 +30,7 @@
   }
 
   @Override
-  public Appendable write(Appendable appendable, CompilationUnitContext context)
-      throws IOException {
+  public Appendable write(Appendable appendable, Context context) throws IOException {
     appendable.append(context.sourceReferenceForClassName(type));
     Iterator<? extends TypeName> parameterIterator = parameters.iterator();
     verify(parameterIterator.hasNext(), type.toString());
@@ -46,11 +44,25 @@ public Appendable write(Appendable appendable, CompilationUnitContext context)
     return appendable;
   }
 
+  @Override
+  public boolean equals(Object obj) {
+    if (obj instanceof ParameterizedTypeName) {
+      ParameterizedTypeName that = (ParameterizedTypeName) obj;
+      return this.type.equals(that.type)
+          && this.parameters.equals(that.parameters);
+    } else {
+      return false;
+    }
+  }
+
+  @Override
+  public int hashCode() {
+    return Objects.hashCode(type, parameters);
+  }
+
   @Override
   public String toString() {
-    StringBuilder builder = new StringBuilder(type.toString()).append('<');
-    Joiner.on(", ").appendTo(builder, parameters);
-    return builder.append('>').toString();
+    return Writables.writeToString(this);
   }
 
   public static ParameterizedTypeName create(ClassName className,
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/PrimitiveName.java b/compiler/src/main/java/dagger/internal/codegen/writer/PrimitiveName.java
index d2d50b5aa..bc57c3904 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/PrimitiveName.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/PrimitiveName.java
@@ -2,7 +2,6 @@
 
 import com.google.common.base.Ascii;
 import com.google.common.collect.ImmutableSet;
-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
 import java.io.IOException;
 import java.util.Set;
 import javax.lang.model.type.PrimitiveType;
@@ -21,8 +20,7 @@ public String toString() {
   }
 
   @Override
-  public Appendable write(Appendable appendable, CompilationUnitContext context)
-      throws IOException {
+  public Appendable write(Appendable appendable, Context context) throws IOException {
     return appendable.append(toString());
   }
 
@@ -48,4 +46,32 @@ static PrimitiveName forTypeMirror(PrimitiveType mirror) {
         throw new AssertionError();
     }
   }
+
+  static PrimitiveName forClass(Class<?> primitiveClass) {
+    if (boolean.class.equals(primitiveClass)) {
+      return BOOLEAN;
+    }
+    if (byte.class.equals(primitiveClass)) {
+      return BYTE;
+    }
+    if (short.class.equals(primitiveClass)) {
+      return SHORT;
+    }
+    if (int.class.equals(primitiveClass)) {
+      return INT;
+    }
+    if (long.class.equals(primitiveClass)) {
+      return LONG;
+    }
+    if (char.class.equals(primitiveClass)) {
+      return CHAR;
+    }
+    if (float.class.equals(primitiveClass)) {
+      return FLOAT;
+    }
+    if (double.class.equals(primitiveClass)) {
+      return DOUBLE;
+    }
+    throw new IllegalArgumentException(primitiveClass + " is not a primitive type");
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java b/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java
index 9968a7383..cbd0af712 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java
@@ -3,7 +3,6 @@
 import com.google.common.base.Function;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
 import java.io.IOException;
 import java.util.Iterator;
 import java.util.List;
@@ -44,8 +43,7 @@ public String toString() {
   }
 
   @Override
-  public Appendable write(Appendable appendable, CompilationUnitContext context)
-      throws IOException {
+  public Appendable write(Appendable appendable, Context context) throws IOException {
     return appendable.append(context.compressTypesWithin(value));
   }
 
@@ -59,6 +57,9 @@ public static Snippet format(String format, Object... args) {
       if (arg instanceof TypeName) {
         types.add((TypeName) arg);
       }
+      if (arg instanceof HasTypeName) {
+        types.add(((HasTypeName) arg).name());
+      }
     }
     return new Snippet(value, types.build());
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/TypeReferences.java b/compiler/src/main/java/dagger/internal/codegen/writer/TypeNames.java
similarity index 56%
rename from compiler/src/main/java/dagger/internal/codegen/writer/TypeReferences.java
rename to compiler/src/main/java/dagger/internal/codegen/writer/TypeNames.java
index 4960e356b..ba6a2ec71 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/TypeReferences.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/TypeNames.java
@@ -5,12 +5,14 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.NoType;
+import javax.lang.model.type.NullType;
 import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.type.WildcardType;
 import javax.lang.model.util.SimpleTypeVisitor6;
 
-public class TypeReferences {
+public class TypeNames {
   static Function<TypeMirror, TypeName> FOR_TYPE_MIRROR =
       new Function<TypeMirror, TypeName>() {
         @Override public TypeName apply(TypeMirror input) {
@@ -18,6 +20,18 @@
         }
       };
 
+  public static TypeName forClass(Class<?> clazz) {
+    if (clazz.isPrimitive()) {
+      return PrimitiveName.forClass(clazz);
+    } else if (void.class.equals(clazz)) {
+      return VoidName.VOID;
+    } else if (clazz.isArray()) {
+      return new ArrayTypeName(forClass(clazz.getComponentType()));
+    } else {
+      return ClassName.fromClass(clazz);
+    }
+  }
+
   public static TypeName forTypeMirror(TypeMirror mirror) {
     return mirror.accept(new SimpleTypeVisitor6<TypeName, Void>() {
       @Override
@@ -26,8 +40,8 @@ protected TypeName defaultAction(TypeMirror e, Void p) {
       }
 
       @Override
-      public TypeName visitArray(ArrayType t, Void p) {
-        return super.visitArray(t, p);
+      public ArrayTypeName visitArray(ArrayType t, Void p) {
+        return new ArrayTypeName(t.getComponentType().accept(this, null));
       }
 
       @Override
@@ -40,14 +54,31 @@ public TypeName visitDeclared(DeclaredType t, Void p) {
       }
 
       @Override
-      public TypeName visitPrimitive(PrimitiveType t, Void p) {
+      public PrimitiveName visitPrimitive(PrimitiveType t, Void p) {
         return PrimitiveName.forTypeMirror(t);
       }
 
       @Override
-      public TypeName visitWildcard(WildcardType t, Void p) {
+      public WildcardName visitWildcard(WildcardType t, Void p) {
         return WildcardName.forTypeMirror(t);
       }
+
+      @Override
+      public NullName visitNull(NullType t, Void p) {
+        return NullName.NULL;
+      }
+
+      @Override
+      public TypeName visitNoType(NoType t, Void p) {
+        switch (t.getKind()) {
+          case VOID:
+            return VoidName.VOID;
+          case PACKAGE:
+            throw new IllegalArgumentException();
+          default:
+            throw new IllegalStateException();
+        }
+      }
     }, null);
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/TypeVariableName.java b/compiler/src/main/java/dagger/internal/codegen/writer/TypeVariableName.java
index e47f42cc3..662bc2aeb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/TypeVariableName.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/TypeVariableName.java
@@ -2,7 +2,6 @@
 
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
 import java.io.IOException;
 import java.util.Set;
 
@@ -34,8 +33,7 @@ public String name() {
   }
 
   @Override
-  public Appendable write(Appendable appendable, CompilationUnitContext context)
-      throws IOException {
+  public Appendable write(Appendable appendable, Context context) throws IOException {
     appendable.append(name);
     if (extendsBound.isPresent()) {
       appendable.append(' ');
@@ -50,14 +48,7 @@ public Appendable write(Appendable appendable, CompilationUnitContext context)
 
   @Override
   public String toString() {
-    StringBuilder builder = new StringBuilder(name);
-    if (extendsBound.isPresent()) {
-      builder.append(' ').append(extendsBound.get());
-    }
-    if (superBound.isPresent()) {
-      builder.append(' ').append(superBound.get());
-    }
-    return builder.toString();
+    return Writables.writeToString(this);
   }
 
   static TypeVariableName named(String name) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java
index a49e765cc..9405aca75 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java
@@ -3,20 +3,54 @@
 import com.google.common.base.Optional;
 import com.google.common.collect.Lists;
 import java.util.List;
+import javax.lang.model.type.TypeMirror;
 
 
 /**
  * Only named types. Doesn't cover anonymous inner classes.
  */
 public abstract class TypeWriter /* ha ha */ extends Modifiable
-    implements Writable, TypeName {
+    implements Writable, HasTypeName, HasClassReferences {
   final ClassName name;
   Optional<TypeName> supertype;
   final List<TypeName> implementedTypes;
+  final List<MethodWriter> methodWriters;
 
   TypeWriter(ClassName name) {
     this.name = name;
     this.supertype = Optional.absent();
     this.implementedTypes = Lists.newArrayList();
+    this.methodWriters = Lists.newArrayList();
+  }
+
+  @Override
+  public TypeName name() {
+    return name;
+  }
+
+  public MethodWriter addMethod(TypeWriter returnType, String name) {
+    MethodWriter methodWriter = new MethodWriter(returnType.name, name);
+    methodWriters.add(methodWriter);
+    return methodWriter;
+  }
+
+  public MethodWriter addMethod(TypeMirror returnType, String name) {
+    MethodWriter methodWriter =
+        new MethodWriter(TypeNames.forTypeMirror(returnType), name);
+    methodWriters.add(methodWriter);
+    return methodWriter;
+  }
+
+  public MethodWriter addMethod(TypeName returnType, String name) {
+    MethodWriter methodWriter = new MethodWriter(returnType, name);
+    methodWriters.add(methodWriter);
+    return methodWriter;
+  }
+
+  public MethodWriter addMethod(Class<?> returnType, String name) {
+    MethodWriter methodWriter =
+        new MethodWriter(ClassName.fromClass(returnType), name);
+    methodWriters.add(methodWriter);
+    return methodWriter;
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java
index 5d2cf2a2f..53339127c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java
@@ -1,6 +1,5 @@
 package dagger.internal.codegen.writer;
 
-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
 import java.io.IOException;
 import java.util.Set;
 
@@ -23,8 +22,7 @@ public String name() {
   }
 
   @Override
-  public Appendable write(Appendable appendable, CompilationUnitContext context)
-      throws IOException {
+  public Appendable write(Appendable appendable, Context context) throws IOException {
     writeModifiers(appendable);
     type.write(appendable, context);
     return appendable.append(' ').append(name);
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/VoidName.java b/compiler/src/main/java/dagger/internal/codegen/writer/VoidName.java
index c6f36098c..3215d0581 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/VoidName.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/VoidName.java
@@ -1,7 +1,6 @@
 package dagger.internal.codegen.writer;
 
 import com.google.common.collect.ImmutableSet;
-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
 import java.io.IOException;
 import java.util.Set;
 
@@ -19,8 +18,7 @@ public String toString() {
   }
 
   @Override
-  public Appendable write(Appendable appendable, CompilationUnitContext context)
-      throws IOException {
+  public Appendable write(Appendable appendable, Context context) throws IOException {
     return appendable.append("void");
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/WildcardName.java b/compiler/src/main/java/dagger/internal/codegen/writer/WildcardName.java
index f881235c5..c4fab1dd7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/WildcardName.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/WildcardName.java
@@ -2,12 +2,11 @@
 
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
 import java.io.IOException;
 import java.util.Set;
 import javax.lang.model.type.WildcardType;
 
-import static dagger.internal.codegen.writer.TypeReferences.FOR_TYPE_MIRROR;
+import static dagger.internal.codegen.writer.TypeNames.FOR_TYPE_MIRROR;
 
 public class WildcardName implements TypeName {
   private final Optional<TypeName> extendsBound;
@@ -38,8 +37,16 @@ static WildcardName forTypeMirror(WildcardType mirror) {
   }
 
   @Override
-  public Appendable write(Appendable appendable, CompilationUnitContext context)
-      throws IOException {
-    return null;
+  public Appendable write(Appendable appendable, Context context) throws IOException {
+    appendable.append('?');
+    if (extendsBound.isPresent()) {
+      appendable.append(" extends ");
+      extendsBound.get().write(appendable, context);
+    }
+    if (superBound.isPresent()) {
+      appendable.append(" super ");
+      superBound.get().write(appendable, context);
+    }
+    return appendable;
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Writable.java b/compiler/src/main/java/dagger/internal/codegen/writer/Writable.java
index 7d3808c7b..2ef319744 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/Writable.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/Writable.java
@@ -1,8 +1,14 @@
 package dagger.internal.codegen.writer;
 
-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
 import java.io.IOException;
+import java.util.Set;
 
 interface Writable {
-  Appendable write(Appendable appendable, CompilationUnitContext context) throws IOException;
+  interface Context {
+    String sourceReferenceForClassName(ClassName className);
+    String compressTypesWithin(String snippet);
+    Context createSubcontext(Set<ClassName> newTypes);
+  }
+
+  Appendable write(Appendable appendable, Context context) throws IOException;
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Writables.java b/compiler/src/main/java/dagger/internal/codegen/writer/Writables.java
index 379540a91..8db7a2f6c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/Writables.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/Writables.java
@@ -1,18 +1,45 @@
 package dagger.internal.codegen.writer;
 
-import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
+import dagger.internal.codegen.writer.Writable.Context;
 import java.io.IOException;
+import java.util.Set;
 
 final class Writables {
   static Writable toStringWritable(final Object object) {
     return new Writable() {
       @Override
-      public Appendable write(Appendable appendable, CompilationUnitContext ignored)
-          throws IOException {
+      public Appendable write(Appendable appendable, Context context) throws IOException {
         return appendable.append(object.toString());
       }
     };
   }
 
+  private static Context DEFAULT_CONTEXT = new Context() {
+    @Override
+    public String sourceReferenceForClassName(ClassName className) {
+      return className.canonicalName();
+    }
+
+    @Override
+    public String compressTypesWithin(String snippet) {
+      return snippet;
+    }
+
+    @Override
+    public Context createSubcontext(Set<ClassName> newTypes) {
+      throw new UnsupportedOperationException();
+    }
+  };
+
+  static String writeToString(Writable writable) {
+    StringBuilder builder = new StringBuilder();
+    try {
+      writable.write(builder, DEFAULT_CONTEXT);
+    } catch (IOException e) {
+      throw new AssertionError("StringBuilder doesn't throw IOException", e);
+    }
+    return builder.toString();
+  }
+
   private Writables() {}
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index a8a67c51d..de78e852e 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -22,9 +22,9 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+import static com.google.common.truth.Truth.assert_;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static org.truth0.Truth.ASSERT;
 
 @RunWith(JUnit4.class)
 public class ComponentProcessorTest {
@@ -36,7 +36,7 @@
         "",
         "@Component",
         "final class NotAComponent {}");
-    ASSERT.about(javaSource()).that(componentFile)
+    assert_().about(javaSource()).that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining("interface");
@@ -52,7 +52,7 @@
         "enum NotAComponent {",
         "  INSTANCE",
         "}");
-    ASSERT.about(javaSource()).that(componentFile)
+    assert_().about(javaSource()).that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining("interface");
@@ -66,7 +66,7 @@
         "",
         "@Component",
         "@interface NotAComponent {}");
-    ASSERT.about(javaSource()).that(componentFile)
+    assert_().about(javaSource()).that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining("interface");
@@ -80,7 +80,7 @@
         "",
         "@Component(modules = Object.class)",
         "interface NotAComponent {}");
-    ASSERT.about(javaSource()).that(componentFile)
+    assert_().about(javaSource()).that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining("module");
@@ -122,23 +122,44 @@
         "public final class Dagger_SimpleComponent implements SimpleComponent {",
         "  private final Provider<SomeInjectableType> someInjectableTypeProvider;",
         "",
-        "  public Dagger_SimpleComponent() {",
+        "  private Dagger_SimpleComponent(Builder builder) {",
+        "    assert builder != null;",
         "    this.someInjectableTypeProvider = new SomeInjectableType$$Factory();",
         "  }",
         "",
-        "  @Override public SomeInjectableType someInjectableType() {",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static SimpleComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  @Override",
+        "  public SomeInjectableType someInjectableType() {",
         "    return someInjectableTypeProvider.get();",
         "  }",
         "",
-        "  @Override public Lazy<SomeInjectableType> lazySomeInjectableType() {",
+        "  @Override",
+        "  public Lazy<SomeInjectableType> lazySomeInjectableType() {",
         "    return DoubleCheckLazy.create(someInjectableTypeProvider);",
         "  }",
         "",
-        "  @Override public Provider<SomeInjectableType> someInjectableTypeProvider() {",
+        "  @Override",
+        "  public Provider<SomeInjectableType> someInjectableTypeProvider() {",
         "    return someInjectableTypeProvider;",
         "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public SimpleComponent build() {",
+        "      return new Dagger_SimpleComponent(this);",
+        "    }",
+        "  }",
         "}");
-    ASSERT.about(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
+    assert_().about(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
@@ -184,24 +205,45 @@
         "public final class Dagger_SimpleComponent implements SimpleComponent {",
         "  private final Provider<SomeInjectableType> someInjectableTypeProvider;",
         "",
-        "  public Dagger_SimpleComponent() {",
+        "  private Dagger_SimpleComponent(Builder builder) {",
+        "    assert builder != null;",
         "    this.someInjectableTypeProvider =",
         "        ScopedProvider.create(new SomeInjectableType$$Factory());",
         "  }",
         "",
-        "  @Override public SomeInjectableType someInjectableType() {",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static SimpleComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  @Override",
+        "  public SomeInjectableType someInjectableType() {",
         "    return someInjectableTypeProvider.get();",
         "  }",
         "",
-        "  @Override public Lazy<SomeInjectableType> lazySomeInjectableType() {",
+        "  @Override",
+        "  public Lazy<SomeInjectableType> lazySomeInjectableType() {",
         "    return DoubleCheckLazy.create(someInjectableTypeProvider);",
         "  }",
         "",
-        "  @Override public Provider<SomeInjectableType> someInjectableTypeProvider() {",
+        "  @Override",
+        "  public Provider<SomeInjectableType> someInjectableTypeProvider() {",
         "    return someInjectableTypeProvider;",
         "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public SimpleComponent build() {",
+        "      return new Dagger_SimpleComponent(this);",
+        "    }",
+        "  }",
         "}");
-    ASSERT.about(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
+    assert_().about(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
@@ -284,19 +326,40 @@
         "  private final Provider<A> aProvider;",
         "  private final MembersInjector<B> bMembersInjector;",
         "",
-        "  public Dagger_OuterType$SimpleComponent() {",
+        "  private Dagger_OuterType$SimpleComponent(Builder builder) {",
+        "    assert builder != null;",
         "    this.aProvider = new OuterType$A$$Factory();",
         "    this.bMembersInjector = new OuterType$B$$MembersInjector(aProvider);",
         "  }",
         "",
-        "  @Override public A a() {",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static SimpleComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  @Override",
+        "  public A a() {",
         "    return aProvider.get();",
         "  }",
-        "  @Override public void inject(B b) {",
+        "",
+        "  @Override",
+        "  public void inject(B b) {",
         "    bMembersInjector.injectMembers(b);",
         "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public SimpleComponent build() {",
+        "      return new Dagger_OuterType$SimpleComponent(this);",
+        "    }",
+        "  }",
         "}");
-     ASSERT.about(javaSources()).that(ImmutableList.of(nestedTypesFile))
+    assert_().about(javaSources()).that(ImmutableList.of(nestedTypesFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(aFactory, bMembersInjector, generatedComponent);
@@ -360,27 +423,147 @@
         "  private final Provider<B> bProvider;",
         "  private final Provider<C> cProvider;",
         "",
-        "  public Dagger_TestComponent(TestModule testModule) {",
-        "    if (testModule == null) {",
-        "      throw new NullPointerException(\"testModule\");",
-        "    }",
-        "    this.testModule = testModule;",
+        "  private Dagger_TestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    this.testModule = builder.testModule;",
         "    this.cProvider = new C$$Factory();",
         "    this.bProvider = new TestModule$$BFactory(testModule, cProvider);",
         "    this.aProvider = new A$$Factory(bProvider);",
         "  }",
         "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
         "  @Override public A a() {",
         "    return aProvider.get();",
         "  }",
+        "",
+        "  public static final class Builder {",
+        "    private TestModule testModule;",
+        "",
+        "    private Builder() {}",
+        "",
+        "    public TestComponent build() {",
+        "      if (testModule == null) {",
+        "        this.testModule = new TestModule();",
+        "      }",
+        "      return new Dagger_TestComponent(this);",
+        "    }",
+        "",
+        "    public Builder testModule(TestModule testModule) {",
+        "      if (testModule == null) {",
+        "        throw new NullPointerException(\"testModule\");",
+        "      }",
+        "      this.testModule = testModule;",
+        "      return this;",
+        "    }",
+        "  }",
         "}");
-    ASSERT.about(javaSources())
+    assert_().about(javaSources())
         .that(ImmutableList.of(aFile, bFile, cFile, moduleFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
   }
 
+  @Test public void transitiveModuleDeps() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module(includes = DepModule.class)",
+        "final class TestModule {",
+        "}");
+    JavaFileObject depModuleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module",
+        "final class DepModule {",
+        "}");
+
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = TestModule.class)",
+        "interface TestComponent {",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.Dagger_TestComponent",
+        "package test;",
+        "",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_TestComponent implements TestComponent {",
+        "  private final TestModule testModule;",
+        "  private final DepModule depModule;",
+        "",
+        "  private Dagger_TestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    this.testModule = builder.testModule;",
+        "    this.depModule = builder.depModule;",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private TestModule testModule;",
+        "    private DepModule depModule;",
+        "",
+        "    private Builder() {}",
+        "",
+        "    public TestComponent build() {",
+        "      if (testModule == null) {",
+        "        this.testModule = new TestModule();",
+        "      }",
+        "      if (depModule == null) {",
+        "        this.depModule = new DepModule();",
+        "      }",
+        "      return new Dagger_TestComponent(this);",
+        "    }",
+        "",
+        "    public Builder testModule(TestModule testModule) {",
+        "      if (testModule == null) {",
+        "        throw new NullPointerException(\"testModule\");",
+        "      }",
+        "      this.testModule = testModule;",
+        "      return this;",
+        "    }",
+        "",
+        "    public Builder depModule(DepModule depModule) {",
+        "      if (depModule == null) {",
+        "        throw new NullPointerException(\"depModule\");",
+        "      }",
+        "      this.depModule = depModule;",
+        "      return this;",
+        "    }",
+        "  }",
+        "}");
+    assert_().about(javaSources())
+        .that(ImmutableList.of(moduleFile, depModuleFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+
   @Test public void setBindings() {
     JavaFileObject emptySetModuleFile = JavaFileObjects.forSourceLines("test.EmptySetModule",
         "package test;",
@@ -435,25 +618,62 @@
         "  private final SetModule setModule;",
         "  private final Provider<Set<String>> setOfStringProvider;",
         "",
-        "  public Dagger_TestComponent(EmptySetModule emptySetModule, SetModule setModule) {",
-        "    if (emptySetModule == null) {",
-        "      throw new NullPointerException(\"emptySetModule\");",
-        "    }",
-        "    this.emptySetModule = emptySetModule;",
-        "    if (setModule == null) {",
-        "      throw new NullPointerException(\"setModule\");",
-        "    }",
-        "    this.setModule = setModule;",
+        "  private Dagger_TestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    this.emptySetModule = builder.emptySetModule;",
+        "    this.setModule = builder.setModule;",
         "    this.setOfStringProvider = SetFactory.create(",
-        "        new EmptySetModule$$EmptySetFactory(emptySetModule),",
-        "        new SetModule$$StringFactory(setModule));",
+        "    new EmptySetModule$$EmptySetFactory(emptySetModule), new SetModule$$StringFactory(setModule));",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
         "  }",
         "",
-        "  @Override public Set<String> strings() {",
+        "  @Override",
+        "  public Set<String> strings() {",
         "    return setOfStringProvider.get();",
         "  }",
+        "",
+        "  public static final class Builder {",
+        "    private EmptySetModule emptySetModule;",
+        "    private SetModule setModule;",
+        "",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public TestComponent build() {",
+        "      if (emptySetModule == null) {",
+        "        this.emptySetModule = new EmptySetModule();",
+        "      }",
+        "      if (setModule == null) {",
+        "        this.setModule = new SetModule();",
+        "      }",
+        "      return new Dagger_TestComponent(this);",
+        "    }",
+        "",
+        "    public Builder emptySetModule(EmptySetModule emptySetModule) {",
+        "      if (emptySetModule == null) {",
+        "        throw new NullPointerException(\"emptySetModule\");",
+        "      }",
+        "      this.emptySetModule = emptySetModule;",
+        "      return this;",
+        "    }",
+        "",
+        "    public Builder setModule(SetModule setModule) {",
+        "      if (setModule == null) {",
+        "        throw new NullPointerException(\"setModule\");",
+        "      }",
+        "      this.setModule = setModule;",
+        "      return this;",
+        "    }",
+        "  }",
         "}");
-    ASSERT.about(javaSources())
+    assert_().about(javaSources())
         .that(ImmutableList.of(emptySetModuleFile, setModuleFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -504,12 +724,21 @@
         "  private final Provider<SomeInjectableType> someInjectableTypeProvider;",
         "  private final MembersInjector<SomeInjectedType> someInjectedTypeMembersInjector;",
         "",
-        "  public Dagger_SimpleComponent() {",
+        "  private Dagger_SimpleComponent(Builder builder) {",
+        "    assert builder != null;",
         "    this.someInjectableTypeProvider = new SomeInjectableType$$Factory();",
-        "    this.someInjectedTypeMembersInjector = ",
+        "    this.someInjectedTypeMembersInjector =",
         "        new SomeInjectedType$$MembersInjector(someInjectableTypeProvider);",
         "  }",
         "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static SimpleComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
         "  @Override public void inject(SomeInjectedType instance) {",
         "    someInjectedTypeMembersInjector.injectMembers(instance);",
         "  }",
@@ -518,8 +747,16 @@
         "    someInjectedTypeMembersInjector.injectMembers(instance);",
         "    return instance;",
         "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {}",
+        "",
+        "    public SimpleComponent build() {",
+        "      return new Dagger_SimpleComponent(this);",
+        "    }",
+        "  }",
         "}");
-    ASSERT.about(javaSources())
+    assert_().about(javaSources())
         .that(ImmutableList.of(injectableTypeFile, injectedTypeFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -560,17 +797,36 @@
         "  private final Provider<SimpleComponent> simpleComponentProvider;",
         "  private final Provider<SomeInjectableType> someInjectableTypeProvider;",
         "",
-        "  public Dagger_SimpleComponent() {",
+        "  private Dagger_SimpleComponent(Builder builder) {",
+        "    assert builder != null;",
         "    this.simpleComponentProvider = InstanceFactory.<SimpleComponent>create(this);",
         "    this.someInjectableTypeProvider =",
         "        new SomeInjectableType$$Factory(simpleComponentProvider);",
         "  }",
         "",
-        "  @Override public SomeInjectableType someInjectableType() {",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static SimpleComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  @Override",
+        "  public SomeInjectableType someInjectableType() {",
         "    return someInjectableTypeProvider.get();",
         "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public SimpleComponent build() {",
+        "      return new Dagger_SimpleComponent(this);",
+        "    }",
+        "  }",
         "}");
-    ASSERT.about(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
+    assert_().about(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
@@ -617,22 +873,373 @@
         "  private final Provider<SomeInjectedType> someInjectedTypeProvider;",
         "  private final MembersInjector<SomeInjectedType> someInjectedTypeMembersInjector;",
         "",
-        "  public Dagger_SimpleComponent() {",
+        "  private Dagger_SimpleComponent(Builder builder) {",
+        "    assert builder != null;",
         "    this.someInjectableTypeProvider = new SomeInjectableType$$Factory();",
-        "    this.someInjectedTypeMembersInjector = ",
+        "    this.someInjectedTypeMembersInjector =",
         "        new SomeInjectedType$$MembersInjector(someInjectableTypeProvider);",
-        "    this.someInjectedTypeProvider = ",
+        "    this.someInjectedTypeProvider =",
         "        new SomeInjectedType$$Factory(someInjectedTypeMembersInjector);",
         "  }",
         "",
-        "  @Override public SomeInjectedType createAndInject() {",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static SimpleComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  @Override",
+        "  public SomeInjectedType createAndInject() {",
         "    return someInjectedTypeProvider.get();",
         "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public SimpleComponent build() {",
+        "      return new Dagger_SimpleComponent(this);",
+        "    }",
+        "  }",
         "}");
-    ASSERT.about(javaSources())
+    assert_().about(javaSources())
         .that(ImmutableList.of(injectableTypeFile, injectedTypeFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
   }
+
+  @Test public void componentDependency() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject A() {}",
+        "}");
+    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class B {",
+        "  @Inject B(A a) {}",
+        "}");
+    JavaFileObject aComponentFile = JavaFileObjects.forSourceLines("test.AComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface AComponent {",
+        "  A a();",
+        "}");
+    JavaFileObject bComponentFile = JavaFileObjects.forSourceLines("test.AComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(dependencies = AComponent.class)",
+        "interface BComponent {",
+        "  B b();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.Dagger_BComponent",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_BComponent implements BComponent {",
+        "  private final AComponent aComponent;",
+        "  private final Provider<A> aProvider;",
+        "  private final Provider<B> bProvider;",
+        "",
+        "  private Dagger_BComponent(Builder builder) {  ",
+        "    assert builder != null;",
+        "    this.aComponent = builder.aComponent;",
+        "    this.aProvider = new Factory<A>() {",
+        "      @Override public A get() {",
+        "        return aComponent.a();",
+        "      }",
+        "    };",
+        "    this.bProvider = new B$$Factory(aProvider);",
+        "  }",
+        "",
+        "  public static Builder builder() {  ",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  @Override",
+        "  public B b() {  ",
+        "    return bProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private AComponent aComponent;",
+        "  ",
+        "    private Builder() {  ",
+        "    }",
+        "  ",
+        "    public BComponent build() {  ",
+        "      if (aComponent == null) {",
+        "        throw new IllegalStateException(\"aComponent must be set\");",
+        "      }",
+        "      return new Dagger_BComponent(this);",
+        "    }",
+        "  ",
+        "    public Builder aComponent(AComponent aComponent) {  ",
+        "      if (aComponent == null) {",
+        "        throw new NullPointerException(\"aComponent\");",
+        "      }",
+        "      this.aComponent = aComponent;",
+        "      return this;",
+        "    }",
+        "  }",
+        "}");
+    assert_().about(javaSources())
+        .that(ImmutableList.of(aFile, bFile, aComponentFile, bComponentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+
+  @Test public void moduleNameCollision() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "public final class A {}");
+    JavaFileObject otherAFile = JavaFileObjects.forSourceLines("other.test.A",
+        "package other.test;",
+        "",
+        "public final class A {}");
+
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "public final class TestModule {",
+        "  @Provides A a() { return null; }",
+        "}");
+    JavaFileObject otherModuleFile = JavaFileObjects.forSourceLines("other.test.TestModule",
+        "package other.test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "public final class TestModule {",
+        "  @Provides A a() { return null; }",
+        "}");
+
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = {TestModule.class, other.test.TestModule.class})",
+        "interface TestComponent {",
+        "  A a();",
+        "  other.test.A otherA();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.Dagger_TestComponent",
+        "package test;",
+        "",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "import other.test.A;",
+        "import other.test.TestModule;",
+        "import other.test.TestModule$$AFactory;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_TestComponent implements TestComponent {",
+        "  private final test.TestModule testModule;",
+        "  private final TestModule testModule1;",
+        "  private final Provider<test.A> aProvider;",
+        "  private final Provider<A> aProvider1;",
+        "",
+        "  private Dagger_TestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    this.testModule = builder.testModule;",
+        "    this.testModule1 = builder.testModule1;",
+        "    this.aProvider = new test.TestModule$$AFactory(testModule);",
+        "    this.aProvider1 = new TestModule$$AFactory(testModule1);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  @Override public test.A a() {",
+        "    return aProvider.get();",
+        "  }",
+        "",
+        "  @Override public A otherA() {",
+        "    return aProvider1.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private test.TestModule testModule;",
+        "    private TestModule testModule1;",
+        "",
+        "    private Builder() {}",
+        "",
+        "    public TestComponent build() {",
+        "      if (testModule == null) {",
+        "        this.testModule = new test.TestModule();",
+        "      }",
+        "      if (testModule1 == null) {",
+        "        this.testModule1 = new TestModule();",
+        "      }",
+        "      return new Dagger_TestComponent(this);",
+        "    }",
+        "",
+        "    public Builder testModule(test.TestModule testModule) {",
+        "      if (testModule == null) {",
+        "        throw new NullPointerException(\"testModule\");",
+        "      }",
+        "      this.testModule = testModule;",
+        "      return this;",
+        "    }",
+        "",
+        "    public Builder testModule(TestModule testModule) {",
+        "      if (testModule == null) {",
+        "        throw new NullPointerException(\"testModule\");",
+        "      }",
+        "      this.testModule1 = testModule;",
+        "      return this;",
+        "    }",
+        "  }",
+        "}");
+    assert_().about(javaSources())
+        .that(ImmutableList.of(aFile, otherAFile, moduleFile, otherModuleFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+
+  @Test public void resolutionOrder() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject A(B b) {}",
+        "}");
+    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class B {",
+        "  @Inject B(C c) {}",
+        "}");
+    JavaFileObject cFile = JavaFileObjects.forSourceLines("test.C",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class C {",
+        "  @Inject C() {}",
+        "}");
+    JavaFileObject xFile = JavaFileObjects.forSourceLines("test.X",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class X {",
+        "  @Inject X(C c) {}",
+        "}");
+
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  A a();",
+        "  C c();",
+        "  X x();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.Dagger_TestComponent",
+        "package test;",
+        "",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_TestComponent implements TestComponent {",
+        "  private final Provider<A> aProvider;",
+        "  private final Provider<B> bProvider;",
+        "  private final Provider<C> cProvider;",
+        "  private final Provider<X> xProvider;",
+        "",
+        "  private Dagger_TestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    this.cProvider = new C$$Factory();",
+        "    this.bProvider = new B$$Factory(cProvider);",
+        "    this.aProvider = new A$$Factory(bProvider);",
+        "    this.xProvider = new X$$Factory(cProvider);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  @Override public A a() {",
+        "    return aProvider.get();",
+        "  }",
+        "",
+        "  @Override public C c() {",
+        "    return cProvider.get();",
+        "  }",
+        "",
+        "  @Override public X x() {",
+        "    return xProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {}",
+        "",
+        "    public TestComponent build() {",
+        "      return new Dagger_TestComponent(this);",
+        "    }",
+        "  }",
+        "}");
+    assert_().about(javaSources())
+        .that(ImmutableList.of(aFile, bFile, cFile, xFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java
index cd995838d..ca8f7ec87 100644
--- a/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java
@@ -22,6 +22,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+import static com.google.common.truth.Truth.assert_;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.ErrorMessages.ABSTRACT_INJECT_METHOD;
@@ -36,7 +37,6 @@
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_SCOPES;
 import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_FIELD;
 import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_METHOD;
-import static org.truth0.Truth.ASSERT;
 
 @RunWith(JUnit4.class)
 // TODO(gak): add tests for generation in the default package.
@@ -79,9 +79,10 @@
         "class PrivateConstructor {",
         "  @Inject private PrivateConstructor() {}",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor()).failsToCompile()
-        .withErrorContaining(INJECT_ON_PRIVATE_CONSTRUCTOR)
-        .in(file).onLine(6);
+    assert_().about(javaSource()).that(file)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(INJECT_ON_PRIVATE_CONSTRUCTOR).in(file).onLine(6);
   }
 
   @Test public void injectConstructorOnInnerClass() {
@@ -95,7 +96,9 @@
         "    @Inject InnerClass() {}",
         "  }",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor()).failsToCompile()
+    assert_().about(javaSource()).that(file)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
         .withErrorContaining(INJECT_CONSTRUCTOR_ON_INNER_CLASS).in(file).onLine(7);
   }
 
@@ -108,9 +111,10 @@
         "abstract class AbstractClass {",
         "  @Inject AbstractClass() {}",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor()).failsToCompile()
-        .withErrorContaining(INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS)
-        .in(file).onLine(6);
+    assert_().about(javaSource()).that(file)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS).in(file).onLine(6);
   }
 
   @Test public void injectConstructorOnGenericClass() {
@@ -122,9 +126,10 @@
         "class GenericClass<T> {",
         "  @Inject GenericClass() {}",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor()).failsToCompile()
-        .withErrorContaining(INJECT_CONSTRUCTOR_ON_GENERIC_CLASS)
-        .in(file).onLine(6);
+    assert_().about(javaSource()).that(file)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(INJECT_CONSTRUCTOR_ON_GENERIC_CLASS).in(file).onLine(6);
   }
 
   @Test public void multipleInjectConstructors() {
@@ -138,7 +143,9 @@
         "  TooManyInjectConstructors(int i) {}",
         "  @Inject TooManyInjectConstructors(String s) {}",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor()).failsToCompile()
+    assert_().about(javaSource()).that(file)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
         .withErrorContaining(MULTIPLE_INJECT_CONSTRUCTORS).in(file).onLine(6)
         .and().withErrorContaining(MULTIPLE_INJECT_CONSTRUCTORS).in(file).onLine(8);
   }
@@ -152,7 +159,7 @@
         "class MultipleQualifierConstructorParam {",
         "  @Inject MultipleQualifierConstructorParam(@QualifierA @QualifierB String s) {}",
         "}");
-    ASSERT.about(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))
+    assert_().about(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))
         .processedWith(new ComponentProcessor()).failsToCompile()
         // for whatever reason, javac only reports the error once on the constructor
         .withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6);
@@ -167,7 +174,7 @@
         "@ScopeA @ScopeB class MultipleScopeClass {",
         "  @Inject MultipleScopeClass() {}",
         "}");
-    ASSERT.about(javaSources()).that(ImmutableList.of(file, SCOPE_A, SCOPE_B))
+    assert_().about(javaSources()).that(ImmutableList.of(file, SCOPE_A, SCOPE_B))
         .processedWith(new ComponentProcessor()).failsToCompile()
         .withErrorContaining(MULTIPLE_SCOPES).in(file).onLine(5).atColumn(1)
         .and().withErrorContaining(MULTIPLE_SCOPES).in(file).onLine(5).atColumn(9);
@@ -182,7 +189,9 @@
         "class FinalInjectField {",
         "  @Inject final String s;",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor()).failsToCompile()
+    assert_().about(javaSource()).that(file)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
         .withErrorContaining(FINAL_INJECT_FIELD).in(file).onLine(6);
   }
 
@@ -195,7 +204,9 @@
         "class PrivateInjectField {",
         "  @Inject private String s;",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor()).failsToCompile()
+    assert_().about(javaSource()).that(file)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
         .withErrorContaining(PRIVATE_INJECT_FIELD).in(file).onLine(6);
   }
 
@@ -208,7 +219,7 @@
         "class MultipleQualifierInjectField {",
         "  @Inject @QualifierA @QualifierB String s;",
         "}");
-    ASSERT.about(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))
+    assert_().about(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))
         .processedWith(new ComponentProcessor()).failsToCompile()
         .withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6).atColumn(11)
         .and().withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6).atColumn(23);
@@ -223,7 +234,9 @@
         "abstract class AbstractInjectMethod {",
         "  @Inject abstract void method();",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor()).failsToCompile()
+    assert_().about(javaSource()).that(file)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
         .withErrorContaining(ABSTRACT_INJECT_METHOD).in(file).onLine(6);
   }
 
@@ -236,7 +249,9 @@
         "class PrivateInjectMethod {",
         "  @Inject private void method();",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor()).failsToCompile()
+    assert_().about(javaSource()).that(file)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
         .withErrorContaining(PRIVATE_INJECT_METHOD).in(file).onLine(6);
   }
 
@@ -249,7 +264,9 @@
         "class AbstractInjectMethod {",
         "  @Inject <T> void method();",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor()).failsToCompile()
+    assert_().about(javaSource()).that(file)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
         .withErrorContaining(GENERIC_INJECT_METHOD).in(file).onLine(6);
   }
 
@@ -262,8 +279,9 @@
         "class MultipleQualifierMethodParam {",
         "  @Inject void method(@QualifierA @QualifierB String s) {}",
         "}");
-    ASSERT.about(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))
-        .processedWith(new ComponentProcessor()).failsToCompile()
+    assert_().about(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
         // for whatever reason, javac only reports the error once on the method
         .withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6);
   }
@@ -309,7 +327,7 @@
         "    instance.stringProvider = stringProvider;",
         "  }",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor())
+    assert_().about(javaSource()).that(file).processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(expected);
   }
@@ -358,7 +376,7 @@
         "        stringProvider);",
         "  }",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor())
+    assert_().about(javaSource()).that(file).processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(expected);
   }
@@ -410,7 +428,7 @@
         "    instance.setObject(objectAndOProvider.get());",
         "  }",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor())
+    assert_().about(javaSource()).that(file).processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(expected);
   }
@@ -447,7 +465,7 @@
         "    return new InjectConstructor(sProvider.get());",
         "  }",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor())
+    assert_().about(javaSource()).that(file).processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(expected);
   }
@@ -520,7 +538,7 @@
         "    instance.s(sProvider.get());",
         "  }",
         "}");
-    ASSERT.about(javaSource()).that(file).processedWith(new ComponentProcessor())
+    assert_().about(javaSource()).that(file).processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
         .generatesSources(expectedFactory, expectedMembersInjector);
@@ -563,7 +581,7 @@
         "    return instance;",
         "  }",
         "}");
-    ASSERT.about(javaSources()).that(ImmutableList.of(aFile, bFile))
+    assert_().about(javaSources()).that(ImmutableList.of(aFile, bFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(expectedFactory);
@@ -613,9 +631,194 @@
         "    instance.s = sProvider.get();",
         "  }",
         "}");
-    ASSERT.about(javaSources()).that(ImmutableList.of(aFile, bFile))
+    assert_().about(javaSources()).that(ImmutableList.of(aFile, bFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(expectedMembersInjector);
   }
+
+  @Test
+  public void wildcardDependency() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.InjectConstructor",
+        "package test;",
+        "",
+        "import java.util.List;",
+        "import javax.inject.Inject;",
+        "",
+        "class InjectConstructor {",
+        "  @Inject InjectConstructor(List<? extends Object> objects) {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines(
+        "test.InjectConstructor$$Factory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import java.util.List;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class InjectConstructor$$Factory ",
+        "    implements Factory<InjectConstructor> {",
+        "",
+        "  private final Provider<List<? extends Object>> objectsProvider;",
+        "",
+        "  public InjectConstructor$$Factory(Provider<List<? extends Object>> objectsProvider) {",
+        "    assert objectsProvider != null;",
+        "    this.objectsProvider = objectsProvider;",
+        "  }",
+        "",
+        "  @Override public InjectConstructor get() {",
+        "    return new InjectConstructor(objectsProvider.get());",
+        "  }",
+        "}");
+    assert_().about(javaSource()).that(file).processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test
+  public void basicNameCollision() {
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("other.pkg.Factory",
+        "package other.pkg;",
+        "",
+        "public class Factory {}");
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.InjectConstructor",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import other.pkg.Factory;",
+        "",
+        "class InjectConstructor {",
+        "  @Inject InjectConstructor(Factory factory) {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines(
+        "test.InjectConstructor$$Factory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class InjectConstructor$$Factory ",
+        "    implements Factory<InjectConstructor> {",
+        "",
+        "  private final Provider<other.pkg.Factory> factoryProvider;",
+        "",
+        "  public InjectConstructor$$Factory(Provider<other.pkg.Factory> factoryProvider) {",
+        "    assert factoryProvider != null;",
+        "    this.factoryProvider = factoryProvider;",
+        "  }",
+        "",
+        "  @Override public InjectConstructor get() {",
+        "    return new InjectConstructor(factoryProvider.get());",
+        "  }",
+        "}");
+    assert_().about(javaSources()).that(ImmutableList.of(factoryFile, file))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test
+  public void nestedNameCollision() {
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("other.pkg.Outer",
+        "package other.pkg;",
+        "",
+        "public class Outer {",
+        "  public class Factory {}",
+        "}");
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.InjectConstructor",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import other.pkg.Outer;",
+        "",
+        "class InjectConstructor {",
+        "  @Inject InjectConstructor(Outer.Factory factory) {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines(
+        "test.InjectConstructor$$Factory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "import other.pkg.Outer;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class InjectConstructor$$Factory ",
+        "    implements Factory<InjectConstructor> {",
+        "",
+        "  private final Provider<Outer.Factory> factoryProvider;",
+        "",
+        "  public InjectConstructor$$Factory(Provider<Outer.Factory> factoryProvider) {",
+        "    assert factoryProvider != null;",
+        "    this.factoryProvider = factoryProvider;",
+        "  }",
+        "",
+        "  @Override public InjectConstructor get() {",
+        "    return new InjectConstructor(factoryProvider.get());",
+        "  }",
+        "}");
+    assert_().about(javaSources()).that(ImmutableList.of(factoryFile, file))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
+
+  @Test
+  public void samePackageNameCollision() {
+    JavaFileObject samePackageInterface = JavaFileObjects.forSourceLines("test.CommonName",
+        "package test;",
+        "",
+        "public interface CommonName {}");
+    JavaFileObject differentPackageInterface = JavaFileObjects.forSourceLines(
+        "other.pkg.CommonName",
+        "package other.pkg;",
+        "",
+        "public interface CommonName {}");
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.InjectConstructor",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class InjectConstructor implements CommonName {",
+        "  @Inject InjectConstructor(other.pkg.CommonName otherPackage, CommonName samePackage) {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines(
+        "test.InjectConstructor$$Factory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "import other.pkg.CommonName;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class InjectConstructor$$Factory ",
+        "    implements Factory<InjectConstructor> {",
+        "",
+        "  private final Provider<CommonName> otherPackageProvider;",
+        "  private final Provider<test.CommonName> samePackageProvider;",
+        "",
+        "  public InjectConstructor$$Factory(Provider<CommonName> otherPackageProvider,",
+        "      Provider<test.CommonName> samePackageProvider) {",
+        "    assert otherPackageProvider != null;",
+        "    this.otherPackageProvider = otherPackageProvider;",
+        "    assert samePackageProvider != null;",
+        "    this.samePackageProvider = samePackageProvider;",
+        "  }",
+        "",
+        "  @Override public InjectConstructor get() {",
+        "    return new InjectConstructor(otherPackageProvider.get(), samePackageProvider.get());",
+        "  }",
+        "}");
+    assert_().about(javaSources())
+        .that(ImmutableList.of(samePackageInterface, differentPackageInterface, file))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expected);
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
index 2bd53bbd2..1f3dda556 100644
--- a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreTypes;
 import com.google.common.base.Optional;
 import com.google.common.collect.Iterables;
 import com.google.testing.compile.CompilationRule;
@@ -39,9 +40,9 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+import static com.google.common.truth.Truth.ASSERT;
 import static dagger.Provides.Type.SET;
 import static dagger.Provides.Type.SET_VALUES;
-import static org.truth0.Truth.ASSERT;
 
 /**
  * Tests {@link Key}.
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleProcessorTest.java
index 939777041..c48282c42 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleProcessorTest.java
@@ -22,6 +22,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+import static com.google.common.truth.Truth.ASSERT;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_ABSTRACT;
@@ -33,7 +34,7 @@
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RETURN_SET;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_STATIC;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_TYPE_PARAMETER;
-import static org.truth0.Truth.ASSERT;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_WITH_SAME_NAME;
 
 @RunWith(JUnit4.class)
 public class ModuleProcessorTest {
@@ -412,4 +413,69 @@
         .compilesWithoutError()
         .and().generatesSources(factoryFile);
   }
+
+  @Test public void multipleProvidesMethodsWithSameName() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides Object provide(int i) {",
+        "    return i;",
+        "  }",
+        "",
+        "  @Provides String provide() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    ASSERT.about(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(PROVIDES_METHOD_WITH_SAME_NAME).in(moduleFile).onLine(8)
+        .and().withErrorContaining(PROVIDES_METHOD_WITH_SAME_NAME).in(moduleFile).onLine(12);
+  }
+
+  @Test
+  public void providedTypes() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import java.io.Closeable;",
+        "import java.util.Set;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides String string() {",
+        "    return null;",
+        "  }",
+        "",
+        "  @Provides Set<String> strings() {",
+        "    return null;",
+        "  }",
+        "",
+        "  @Provides Set<? extends Closeable> closeables() {",
+        "    return null;",
+        "  }",
+        "",
+        "  @Provides String[] stringArray() {",
+        "    return null;",
+        "  }",
+        "",
+        "  @Provides int integer() {",
+        "    return 0;",
+        "  }",
+        "",
+        "  @Provides int[] integers() {",
+        "    return null;",
+        "  }",
+        "}");
+    ASSERT.about(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/MoreTypesTest.java b/compiler/src/test/java/dagger/internal/codegen/MoreTypesTest.java
deleted file mode 100644
index 9eeeac329..000000000
--- a/compiler/src/test/java/dagger/internal/codegen/MoreTypesTest.java
+++ /dev/null
@@ -1,271 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.common.base.Function;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.testing.EquivalenceTester;
-import com.google.testing.compile.CompilationRule;
-import java.lang.annotation.Annotation;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.ErrorType;
-import javax.lang.model.type.PrimitiveType;
-import javax.lang.model.type.TypeKind;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.type.TypeVisitor;
-import javax.lang.model.type.WildcardType;
-import javax.lang.model.util.ElementFilter;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static javax.lang.model.type.TypeKind.NONE;
-import static javax.lang.model.type.TypeKind.VOID;
-import static org.truth0.Truth.ASSERT;
-
-@RunWith(JUnit4.class)
-public class MoreTypesTest {
-  @Rule public CompilationRule compilationRule = new CompilationRule();
-
-  @Test
-  public void equivalence() {
-    Types types = compilationRule.getTypes();
-    Elements elements = compilationRule.getElements();
-    TypeMirror objectType = elements.getTypeElement(Object.class.getCanonicalName()).asType();
-    TypeMirror stringType = elements.getTypeElement(String.class.getCanonicalName()).asType();
-    TypeElement mapElement = elements.getTypeElement(Map.class.getCanonicalName());
-    TypeElement setElement = elements.getTypeElement(Set.class.getCanonicalName());
-    DeclaredType mapOfObjectToObjectType =
-        types.getDeclaredType(mapElement, objectType, objectType);
-    TypeMirror mapType = mapElement.asType();
-    WildcardType wildcard = types.getWildcardType(null, null);
-    EquivalenceTester<TypeMirror> tester = EquivalenceTester.<TypeMirror>of(MoreTypes.equivalence())
-        .addEquivalenceGroup(types.getNullType())
-        .addEquivalenceGroup(types.getNoType(NONE))
-        .addEquivalenceGroup(types.getNoType(VOID))
-        .addEquivalenceGroup(objectType)
-        .addEquivalenceGroup(stringType)
-        // Map<K, V>
-        .addEquivalenceGroup(mapType)
-        .addEquivalenceGroup(mapOfObjectToObjectType)
-        // Map<?, ?>
-        .addEquivalenceGroup(types.getDeclaredType(mapElement, wildcard, wildcard))
-        // Map
-        .addEquivalenceGroup(types.erasure(mapType), types.erasure(mapOfObjectToObjectType))
-        .addEquivalenceGroup(types.getDeclaredType(mapElement, objectType, stringType))
-        .addEquivalenceGroup(types.getDeclaredType(mapElement, stringType, objectType))
-        .addEquivalenceGroup(types.getDeclaredType(mapElement, stringType, stringType))
-        .addEquivalenceGroup(wildcard)
-        // ? extends Object
-        .addEquivalenceGroup(types.getWildcardType(objectType, null))
-        // ? extends String
-        .addEquivalenceGroup(types.getWildcardType(stringType, null))
-        // ? super String
-        .addEquivalenceGroup(types.getWildcardType(null, stringType))
-        // Map<String, Map<String, Set<Object>>>
-        .addEquivalenceGroup(types.getDeclaredType(mapElement, stringType,
-            types.getDeclaredType(mapElement, stringType,
-                types.getDeclaredType(setElement, objectType))))
-        .addEquivalenceGroup(FAKE_ERROR_TYPE)
-        ;
-
-    for (TypeKind kind : TypeKind.values()) {
-      if (kind.isPrimitive()) {
-        PrimitiveType primitiveType = types.getPrimitiveType(kind);
-        TypeMirror boxedPrimitiveType = types.boxedClass(primitiveType).asType();
-        tester.addEquivalenceGroup(primitiveType, types.unboxedType(boxedPrimitiveType));
-        tester.addEquivalenceGroup(boxedPrimitiveType);
-        tester.addEquivalenceGroup(types.getArrayType(primitiveType));
-        tester.addEquivalenceGroup(types.getArrayType(boxedPrimitiveType));
-      }
-    }
-
-    ImmutableSet<Class<?>> testClasses = ImmutableSet.of(
-        ExecutableElementsGroupA.class,
-        ExecutableElementsGroupB.class,
-        ExecutableElementsGroupC.class,
-        ExecutableElementsGroupD.class,
-        ExecutableElementsGroupE.class);
-    for (Class<?> testClass : testClasses) {
-      ImmutableList<TypeMirror> equivalenceGroup = FluentIterable.from(
-          elements.getTypeElement(testClass.getCanonicalName()).getEnclosedElements())
-              .transform(new Function<Element, TypeMirror>() {
-                @Override public TypeMirror apply(Element input) {
-                  return input.asType();
-                }
-              })
-              .toList();
-      tester.addEquivalenceGroup(equivalenceGroup);
-    }
-
-    tester.test();
-  }
-
-  @SuppressWarnings("unused")
-  private static final class ExecutableElementsGroupA {
-    ExecutableElementsGroupA() {}
-    void a() {}
-    public static void b() {}
-  }
-
-  @SuppressWarnings("unused")
-  private static final class ExecutableElementsGroupB {
-    ExecutableElementsGroupB(String s) {}
-    void a(String s) {}
-    public static void b(String s) {}
-  }
-
-  @SuppressWarnings("unused")
-  private static final class ExecutableElementsGroupC {
-    ExecutableElementsGroupC() throws Exception {}
-    void a() throws Exception {}
-    public static void b() throws Exception {}
-  }
-
-  @SuppressWarnings("unused")
-  private static final class ExecutableElementsGroupD {
-    ExecutableElementsGroupD() throws RuntimeException {}
-    void a() throws RuntimeException {}
-    public static void b() throws RuntimeException {}
-  }
-
-  @SuppressWarnings("unused")
-  private static final class ExecutableElementsGroupE {
-    <T> ExecutableElementsGroupE() {}
-    <T> void a() {}
-    public static <T> void b() {}
-  }
-
-  @Test public void testReferencedTypes() {
-    Elements elements = compilationRule.getElements();
-    TypeElement testDataElement = elements
-        .getTypeElement(ReferencedTypesTestData.class.getCanonicalName());
-    ImmutableMap<String, VariableElement> fieldIndex =
-        FluentIterable.from(ElementFilter.fieldsIn(testDataElement.getEnclosedElements()))
-            .uniqueIndex(new Function<VariableElement, String>() {
-              @Override public String apply(VariableElement input) {
-                return input.getSimpleName().toString();
-              }
-            });
-
-    TypeElement objectElement =
-        elements.getTypeElement(Object.class.getCanonicalName());
-    TypeElement stringElement =
-        elements.getTypeElement(String.class.getCanonicalName());
-    TypeElement integerElement =
-        elements.getTypeElement(Integer.class.getCanonicalName());
-    TypeElement setElement =
-        elements.getTypeElement(Set.class.getCanonicalName());
-    TypeElement mapElement =
-        elements.getTypeElement(Map.class.getCanonicalName());
-    TypeElement charSequenceElement =
-        elements.getTypeElement(CharSequence.class.getCanonicalName());
-
-    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f1").asType()))
-        .has().exactly(objectElement);
-    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f2").asType()))
-        .has().exactly(setElement, stringElement);
-    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f3").asType()))
-        .has().exactly(mapElement, stringElement, objectElement);
-    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f4").asType()))
-        .has().exactly(integerElement);
-    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f5").asType()))
-        .has().exactly(setElement);
-    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f6").asType()))
-        .has().exactly(setElement, charSequenceElement);
-    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f7").asType()))
-        .has().exactly(mapElement, stringElement, setElement, charSequenceElement);
-    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f8").asType()))
-        .has().exactly(stringElement);
-    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f9").asType()))
-        .has().exactly(stringElement);
-    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f10").asType())).isEmpty();
-    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f11").asType())).isEmpty();
-    ASSERT.that(MoreTypes.referencedTypes(fieldIndex.get("f12").asType()))
-        .has().exactly(setElement, stringElement);
-  }
-
-  @SuppressWarnings("unused") // types used in compiler tests
-  private static final class ReferencedTypesTestData {
-    Object f1;
-    Set<String> f2;
-    Map<String, Object> f3;
-    Integer f4;
-    Set<?> f5;
-    Set<? extends CharSequence> f6;
-    Map<String, Set<? extends CharSequence>> f7;
-    String[] f8;
-    String[][] f9;
-    int f10;
-    int[] f11;
-    Set<? super String> f12;
-  }
-
-
-  private static final ErrorType FAKE_ERROR_TYPE = new ErrorType() {
-    @Override
-    public TypeKind getKind() {
-      return TypeKind.ERROR;
-    }
-
-    @Override
-    public <R, P> R accept(TypeVisitor<R, P> v, P p) {
-      return v.visitError(this, p);
-    }
-
-    @Override
-    public List<? extends TypeMirror> getTypeArguments() {
-      return ImmutableList.of();
-    }
-
-    @Override
-    public TypeMirror getEnclosingType() {
-      return null;
-    }
-
-    @Override
-    public Element asElement() {
-      return null;
-    }
-
-    // JDK8 Compatibility:
-
-    public <A extends Annotation> A[] getAnnotationsByType(Class<A> annotationType) {
-      return null;
-    }
-
-    public <A extends Annotation> A getAnnotation(Class<A> annotationType) {
-      return null;
-    }
-
-    public List<? extends AnnotationMirror> getAnnotationMirrors() {
-      return null;
-    }
-  };
-}
diff --git a/compiler/src/test/java/dagger/internal/codegen/writer/TypeNamesTest.java b/compiler/src/test/java/dagger/internal/codegen/writer/TypeNamesTest.java
new file mode 100644
index 000000000..08a114f84
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/writer/TypeNamesTest.java
@@ -0,0 +1,84 @@
+package dagger.internal.codegen.writer;
+
+import com.google.testing.compile.CompilationRule;
+import java.nio.charset.Charset;
+import java.util.Set;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static org.truth0.Truth.ASSERT;
+
+@RunWith(JUnit4.class)
+public class TypeNamesTest {
+  @Rule public final CompilationRule compilation = new CompilationRule();
+
+  private TypeElement getElement(Class<?> clazz) {
+    return compilation.getElements().getTypeElement(clazz.getCanonicalName());
+  }
+
+  private TypeMirror getType(Class<?> clazz) {
+    return getElement(clazz).asType();
+  }
+
+  @Test
+  public void forTypeMirror_basicTypes() {
+    ASSERT.that(TypeNames.forTypeMirror(getType(Object.class)))
+        .isEqualTo(ClassName.fromClass(Object.class));
+    ASSERT.that(TypeNames.forTypeMirror(getType(Charset.class)))
+        .isEqualTo(ClassName.fromClass(Charset.class));
+    ASSERT.that(TypeNames.forTypeMirror(getType(TypeNamesTest.class)))
+        .isEqualTo(ClassName.fromClass(TypeNamesTest.class));
+  }
+
+  @Test
+  public void forTypeMirror_parameterizedType() {
+    DeclaredType setType =
+        compilation.getTypes().getDeclaredType(getElement(Set.class), getType(Object.class));
+    ASSERT.that(TypeNames.forTypeMirror(setType))
+        .isEqualTo(ParameterizedTypeName.create(Set.class, ClassName.fromClass(Object.class)));
+  }
+
+  @Test
+  public void forTypeMirror_primitive() {
+    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.BOOLEAN)))
+        .isEqualTo(PrimitiveName.BOOLEAN);
+    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.BYTE)))
+        .isEqualTo(PrimitiveName.BYTE);
+    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.SHORT)))
+        .isEqualTo(PrimitiveName.SHORT);
+    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.INT)))
+        .isEqualTo(PrimitiveName.INT);
+    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.LONG)))
+        .isEqualTo(PrimitiveName.LONG);
+    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.CHAR)))
+        .isEqualTo(PrimitiveName.CHAR);
+    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.FLOAT)))
+        .isEqualTo(PrimitiveName.FLOAT);
+    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.DOUBLE)))
+        .isEqualTo(PrimitiveName.DOUBLE);
+  }
+
+  @Test
+  public void forTypeMirror_arrays() {
+    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getArrayType(getType(Object.class))))
+        .isEqualTo(new ArrayTypeName(ClassName.fromClass(Object.class)));
+  }
+
+  @Test
+  public void forTypeMirror_void() {
+    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getNoType(TypeKind.VOID)))
+        .isEqualTo(VoidName.VOID);
+  }
+
+  @Test
+  public void forTypeMirror_null() {
+    ASSERT.that(TypeNames.forTypeMirror(compilation.getTypes().getNullType()))
+        .isEqualTo(NullName.NULL);
+  }
+}
diff --git a/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
index 59aff69f6..3e7cc064e 100644
--- a/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
@@ -23,9 +23,9 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+import static com.google.common.truth.Truth.ASSERT;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
-import static org.truth0.Truth.ASSERT;
 
 @RunWith(JUnit4.class)
 public final class InjectAdapterGenerationTest {
diff --git a/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
index 3bf7a9611..251eb8003 100644
--- a/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
@@ -23,11 +23,11 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+import static com.google.common.truth.Truth.ASSERT;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
 import static java.util.Arrays.asList;
-import static org.truth0.Truth.ASSERT;
 
 @RunWith(JUnit4.class)
 public final class ModuleAdapterGenerationTest {
diff --git a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
index 9f83b1c1a..8c4258c04 100644
--- a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
@@ -23,9 +23,9 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+import static com.google.common.truth.Truth.ASSERT;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static java.util.Arrays.asList;
-import static org.truth0.Truth.ASSERT;
 
 @RunWith(JUnit4.class)
 public final class PrimitiveInjectionTest {
@@ -70,6 +70,7 @@
   JavaFileObject expectedComponent = JavaFileObjects.forSourceLines(
       "test.Dagger_PrimitiveComponent",
       "package test;",
+      "",
       "import javax.annotation.Generated;",
       "import javax.inject.Provider;",
       "",
@@ -78,23 +79,54 @@
       "  private final PrimitiveModule primitiveModule;",
       "  private final Provider<PrimitiveInjectable> primitiveInjectableProvider;",
       "  private final Provider<Integer> primitiveIntProvider;",
-      "  public Dagger_PrimitiveComponent(PrimitiveModule primitiveModule) {",
-      "    if (primitiveModule == null) {",
-      "      throw new NullPointerException(\"primitiveModule\");",
-      "    }",
-      "    this.primitiveModule = primitiveModule;",
+      "",
+      "  private Dagger_PrimitiveComponent(Builder builder) {",
+      "    assert builder != null;",
+      "    this.primitiveModule = builder.primitiveModule;",
       "    this.primitiveIntProvider = new PrimitiveModule$$PrimitiveIntFactory(primitiveModule);",
-      "    this.primitiveInjectableProvider = ",
+      "    this.primitiveInjectableProvider =",
       "        new PrimitiveInjectable$$Factory(primitiveIntProvider);",
       "  }",
+      "",
+      "  public static Builder builder() {",
+      "    return new Builder();",
+      "  }",
+      "",
+      "  public static PrimitiveComponent create() {",
+      "    return builder().build();",
+      "  }",
+      "",
       "  @Override",
       "  public int primitiveInt() {",
       "    return primitiveIntProvider.get();",
       "  }",
+      "",
       "  @Override",
       "  public PrimitiveInjectable primitiveInjectable() {",
       "    return primitiveInjectableProvider.get();",
       "  }",
+      "",
+      "  public static final class Builder {",
+      "    private PrimitiveModule primitiveModule;",
+      "",
+      "    private Builder() {",
+      "    }",
+      "",
+      "    public PrimitiveComponent build() {",
+      "      if (primitiveModule == null) {",
+      "        this.primitiveModule = new PrimitiveModule();",
+      "      }",
+      "      return new Dagger_PrimitiveComponent(this);",
+      "    }",
+      "",
+      "    public Builder primitiveModule(PrimitiveModule primitiveModule) {",
+      "      if (primitiveModule == null) {",
+      "        throw new NullPointerException(\"primitiveModule\");",
+      "      }",
+      "      this.primitiveModule = primitiveModule;",
+      "      return this;",
+      "    }",
+      "  }",
       "}");
 
   @Test public void primitiveArrayTypesAllInjected() {
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/CyclicDependencyTest.java b/compiler/src/test/java/dagger/tests/integration/validation/CyclicDependencyTest.java
index 1afd4d9b6..027a1457f 100644
--- a/compiler/src/test/java/dagger/tests/integration/validation/CyclicDependencyTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/CyclicDependencyTest.java
@@ -23,9 +23,9 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+import static com.google.common.truth.Truth.ASSERT;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
-import static org.truth0.Truth.ASSERT;
 
 @RunWith(JUnit4.class)
 public class CyclicDependencyTest {
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/CyclicModuleIncludesTest.java b/compiler/src/test/java/dagger/tests/integration/validation/CyclicModuleIncludesTest.java
index a152518c1..2a9fd1761 100644
--- a/compiler/src/test/java/dagger/tests/integration/validation/CyclicModuleIncludesTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/CyclicModuleIncludesTest.java
@@ -23,9 +23,9 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+import static com.google.common.truth.Truth.ASSERT;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
-import static org.truth0.Truth.ASSERT;
 
 @RunWith(JUnit4.class)
 public class CyclicModuleIncludesTest {
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/GeneratedTypesNotReadyTest.java b/compiler/src/test/java/dagger/tests/integration/validation/GeneratedTypesNotReadyTest.java
index ad8ca1745..b189201e7 100644
--- a/compiler/src/test/java/dagger/tests/integration/validation/GeneratedTypesNotReadyTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/GeneratedTypesNotReadyTest.java
@@ -32,10 +32,10 @@
 import org.junit.runners.JUnit4;
 
 import static com.google.common.collect.Iterables.concat;
+import static com.google.common.truth.Truth.ASSERT;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
 import static java.util.Arrays.asList;
-import static org.truth0.Truth.ASSERT;
 
 /**
  * Tests that the annotation processor(s) will properly handle the case where
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/LibraryModuleTest.java b/compiler/src/test/java/dagger/tests/integration/validation/LibraryModuleTest.java
index edc8816a4..80d01dc84 100644
--- a/compiler/src/test/java/dagger/tests/integration/validation/LibraryModuleTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/LibraryModuleTest.java
@@ -24,10 +24,10 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+import static com.google.common.truth.Truth.ASSERT;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
-import static org.truth0.Truth.ASSERT;
 
 @RunWith(JUnit4.class)
 public final class LibraryModuleTest {
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/ScopeAnnotationUseTest.java b/compiler/src/test/java/dagger/tests/integration/validation/ScopeAnnotationUseTest.java
index 61b17375a..1d508657b 100644
--- a/compiler/src/test/java/dagger/tests/integration/validation/ScopeAnnotationUseTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/ScopeAnnotationUseTest.java
@@ -23,11 +23,11 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+import static com.google.common.truth.Truth.ASSERT;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
 import static java.util.Arrays.asList;
-import static org.truth0.Truth.ASSERT;
 
 /**
  * Integration tests for the validation processors related to the use
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/SimpleMissingDependencyTest.java b/compiler/src/test/java/dagger/tests/integration/validation/SimpleMissingDependencyTest.java
index 5dfe21f02..4b58d28c8 100644
--- a/compiler/src/test/java/dagger/tests/integration/validation/SimpleMissingDependencyTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/SimpleMissingDependencyTest.java
@@ -23,9 +23,9 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+import static com.google.common.truth.Truth.ASSERT;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
-import static org.truth0.Truth.ASSERT;
 
 @RunWith(JUnit4.class)
 public class SimpleMissingDependencyTest {
diff --git a/core/pom.xml b/core/pom.xml
index c980ca36f..3749c6607 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -48,7 +48,7 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>org.truth0</groupId>
+      <groupId>com.google.truth</groupId>
       <artifactId>truth</artifactId>
       <scope>test</scope>
     </dependency>
diff --git a/core/src/main/java/dagger/Component.java b/core/src/main/java/dagger/Component.java
index 43f33329a..cd676f142 100644
--- a/core/src/main/java/dagger/Component.java
+++ b/core/src/main/java/dagger/Component.java
@@ -63,4 +63,9 @@
    * component implementation.
    */
   Class<?>[] modules() default {};
+
+  /**
+   * A list of types that are to be used as component dependencies.
+   */
+  Class<?>[] dependencies() default {};
 }
diff --git a/core/src/main/java/dagger/internal/MembersInjectors.java b/core/src/main/java/dagger/internal/MembersInjectors.java
new file mode 100644
index 000000000..1b9bc105f
--- /dev/null
+++ b/core/src/main/java/dagger/internal/MembersInjectors.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2014 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import dagger.MembersInjector;
+
+import javax.inject.Inject;
+
+/**
+ * Basic {@link MembersInjector} implementations used by the framework.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+public final class MembersInjectors {
+  /**
+   * Returns a {@link MembersInjector} implementation that injects no members
+   *
+   * <p>Note that there is no verification that the type being injected does not have {@link Inject}
+   * members, so care should be taken to ensure appropriate use.
+   */
+  @SuppressWarnings("unchecked")
+  public static <T> MembersInjector<T> noOp() {
+    return (MembersInjector<T>) NoOpMembersInjector.INSTANCE;
+  }
+
+  private static enum NoOpMembersInjector implements MembersInjector<Object> {
+    INSTANCE;
+
+    @Override public void injectMembers(Object instance) {
+      if (instance == null) {
+        throw new NullPointerException();
+      }
+    }
+  }
+
+  /**
+   * Returns a {@link MembersInjector} that delegates to the {@link MembersInjector} of its
+   * supertype.  This is useful for cases where a type is known not to have its own {@link Inject}
+   * members, but must still inject members on its supertype(s).
+   *
+   * <p>Note that there is no verification that the type being injected does not have {@link Inject}
+   * members, so care should be taken to ensure appropriate use.
+   */
+  @SuppressWarnings("unchecked")
+  public static <T> MembersInjector<T> delegatingTo(MembersInjector<? super T> delegate) {
+    return (MembersInjector<T>) delegate;
+  }
+
+  private MembersInjectors() {}
+}
diff --git a/pom.xml b/pom.xml
index db824124e..615a0cea0 100644
--- a/pom.xml
+++ b/pom.xml
@@ -44,16 +44,16 @@
     <java.version>1.6</java.version>
     <javax.inject.version>1</javax.inject.version>
     <javawriter.version>2.5.0</javawriter.version>
-    <auto.common.version>0.1</auto.common.version>
+    <auto.common.version>1.0-SNAPSHOT</auto.common.version>
     <auto.service.version>1.0-rc1</auto.service.version>
     <guava.version>17.0</guava.version>
 
     <!-- Test Dependencies -->
-    <compile-testing.version>0.5</compile-testing.version>
+    <compile-testing.version>0.6-SNAPSHOT</compile-testing.version>
     <fest.version>1.4</fest.version>
     <junit.version>4.11</junit.version>
     <mockito.version>1.9.5</mockito.version>
-    <truth.version>0.20</truth.version>
+    <truth.version>1.0-SNAPSHOT</truth.version>
   </properties>
 
   <scm>
@@ -133,7 +133,7 @@
         <version>${mockito.version}</version>
       </dependency>
       <dependency>
-        <groupId>org.truth0</groupId>
+        <groupId>com.google.truth</groupId>
         <artifactId>truth</artifactId>
         <version>${truth.version}</version>
       </dependency>
