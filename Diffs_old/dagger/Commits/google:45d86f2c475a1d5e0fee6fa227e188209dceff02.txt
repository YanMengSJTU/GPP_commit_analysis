diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 55121c626..62fabbf5b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -93,7 +93,7 @@
    * The ordering of {@link Key keys} that will allow all of the {@link Factory} and
    * {@link MembersInjector} implementations to initialize properly.
    */
-  abstract ImmutableList<Key> initializationOrdering();
+  abstract ImmutableList<FrameworkKey> initializationOrdering();
 
   static final class Factory {
     private final Elements elements;
@@ -194,7 +194,7 @@ ComponentDescriptor create(TypeElement componentDefinitionType) {
       SetMultimap<Key, ProvisionBinding> resolvedProvisionBindings = LinkedHashMultimap.create();
       Map<Key, MembersInjectionBinding> resolvedMembersInjectionBindings = Maps.newLinkedHashMap();
       // TODO(gak): we're really going to need to test this ordering
-      ImmutableSet.Builder<Key> resolutionOrder = ImmutableSet.builder();
+      ImmutableSet.Builder<FrameworkKey> resolutionOrder = ImmutableSet.builder();
 
       for (DependencyRequest requestToResolve = requestsToResolve.pollLast();
           requestToResolve != null;
@@ -240,7 +240,7 @@ ComponentDescriptor create(TypeElement componentDefinitionType) {
             }
           }
         }
-        resolutionOrder.add(key);
+        resolutionOrder.add(FrameworkKey.forDependencyRequest(requestToResolve));
       }
 
       return new AutoValue_ComponentDescriptor(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index ce3e5535b..6805bab47 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -224,7 +224,7 @@ private void writeMembersInjectorFields(JavaWriter writer,
   }
 
   private void writeConstructor(final JavaWriter writer,
-      ImmutableList<Key> initializationOrdering,
+      ImmutableList<FrameworkKey> initializationOrdering,
       ImmutableSetMultimap<Key, ProvisionBinding> resolvedProvisionBindings,
       ImmutableMap<Key, MembersInjectionBinding> resolvedMembersInjectionBindings,
       ImmutableBiMap<Key, String> providerNames,
@@ -248,17 +248,9 @@ public String apply(TypeElement input) {
       writer.emitStatement("this.%1$s = %1$s", variableName);
     }
 
-    for (Key key : initializationOrdering) {
-      // first members injectors
-      if (resolvedMembersInjectionBindings.containsKey(key)) {
-        writer.emitStatement("this.%s = %s",
-            membersInjectorNames.get(key),
-            initializeMembersInjectorForBinding(writer, resolvedMembersInjectionBindings.get(key),
-                providerNames, membersInjectorNames));
-      }
-
-      // then provisions
-      if (resolvedProvisionBindings.containsKey(key)) {
+    for (FrameworkKey frameworkKey : initializationOrdering) {
+      Key key = frameworkKey.key();
+      if (frameworkKey.frameworkClass().equals(Provider.class)) {
         Set<ProvisionBinding> bindings = resolvedProvisionBindings.get(key);
         if (ProvisionBinding.isSetBindingCollection(bindings)) {
           ImmutableList.Builder<String> setFactoryParameters = ImmutableList.builder();
@@ -276,6 +268,14 @@ public String apply(TypeElement input) {
               initializeFactoryForBinding(
                   writer, binding, moduleNames, providerNames, membersInjectorNames));
         }
+      } else if (frameworkKey.frameworkClass().equals(MembersInjector.class)) {
+        writer.emitStatement("this.%s = %s",
+            membersInjectorNames.get(key),
+            initializeMembersInjectorForBinding(writer, resolvedMembersInjectionBindings.get(key),
+                providerNames, membersInjectorNames));
+      } else {
+        throw new IllegalStateException(
+            "unknown framework class: " + frameworkKey.frameworkClass());
       }
     }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkKey.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkKey.java
new file mode 100644
index 000000000..afb4c0280
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkKey.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.value.AutoValue;
+import dagger.MembersInjector;
+import javax.inject.Provider;
+
+import static com.google.common.base.Preconditions.checkArgument;
+
+/**
+ * A value object that pairs a {@link Key} with a framework class (e.g.: {@link Provider},
+ * {@link MembersInjector}) related to that key.
+ *
+ *  @author Gregory Kick
+ *  @since 2.0
+ */
+@AutoValue
+abstract class FrameworkKey {
+  static FrameworkKey forDependencyRequest(DependencyRequest dependencyRequest) {
+    final Class<?> frameworkClass;
+    switch (dependencyRequest.kind()) {
+      case INSTANCE:
+      case LAZY:
+      case PROVIDER:
+        frameworkClass = Provider.class;
+        break;
+      case MEMBERS_INJECTOR:
+        checkArgument(!dependencyRequest.key().qualifier().isPresent());
+        frameworkClass = MembersInjector.class;
+        break;
+      default:
+        throw new AssertionError();
+    }
+    return new AutoValue_FrameworkKey(dependencyRequest.key(), frameworkClass);
+  }
+
+  abstract Key key();
+  abstract Class<?> frameworkClass();
+}
