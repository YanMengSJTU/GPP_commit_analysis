diff --git a/producers/src/main/java/dagger/producers/monitoring/ProducerTimingRecorder.java b/producers/src/main/java/dagger/producers/monitoring/ProducerTimingRecorder.java
new file mode 100644
index 000000000..071f32cb8
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/monitoring/ProducerTimingRecorder.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.monitoring;
+
+import dagger.producers.Produces;
+import dagger.producers.ProductionComponent;
+
+/**
+ * A hook for recording the timing of the execution of individual
+ * {@linkplain Produces producer methods}. See {@link ProductionComponentTimingRecorder} for how to
+ * install these monitors.
+ *
+ * <p>If any of the recorder's methods throw, then the exception will be logged and processing will
+ * continue unaffected.
+ *
+ * <p>All timings are measured at nanosecond precision, but not necessarily nanosecond resolution.
+ * That is, timings will be reported in nanoseconds, but the timing source will not necessarily
+ * update at nanosecond resolution. For example, {@link System#nanoTime()) would satisfy these
+ * constraints.
+ *
+ * @author Jesse Beder
+ */
+public abstract class ProducerTimingRecorder {
+  /**
+   * Reports that the producer method has finished executing with the given statistics.
+   *
+   * <p>If the producer was skipped due to any of its inputs failing, then this will not be called.
+   *
+   * @param startedNanos the wall-clock time, in nanoseconds, when the producer method started
+   *     executing, measured from when the first method on the
+   *     {@linkplain ProductionComponent production component} was called.
+   * @param durationNanos the wall-clock time, in nanoseconds, that the producer method took to
+   *     execute.
+   */
+  public void recordMethod(long startedNanos, long durationNanos) {}
+
+  /**
+   * Reports that the producer's future has succeeded with the given statistics.
+   *
+   * <p>If the producer was skipped due to any of its inputs failing, then this will not be called.
+   *
+   * @param latencyNanos the wall-clock time, in nanoseconds, of the producer's latency, measured
+   *     from when the producer method started to when the future finished.
+   */
+  public void recordSuccess(long latencyNanos) {}
+
+  /**
+   * Reports that the producer's future has failed with the given statistics.
+   *
+   * @param exception the exception that the future failed with.
+   * @param latencyNanos the wall-clock time, in nanoseconds, of the producer's latency, measured
+   *     from when the producer method started to when the future finished.
+   */
+  public void recordFailure(Throwable exception, long latencyNanos) {}
+
+  /**
+   * Reports that the producer was skipped because one of its inputs failed.
+   *
+   * @param exception the exception that its input failed with. If multiple inputs failed, this
+   *    exception will be chosen arbitrarily from the input failures.
+   */
+  public void recordSkip(Throwable exception) {}
+
+  /** Returns a producer recorder that does nothing. */
+  public static ProducerTimingRecorder noOp() {
+    return NO_OP;
+  }
+
+  private static final ProducerTimingRecorder NO_OP = new ProducerTimingRecorder() {};
+}
diff --git a/producers/src/main/java/dagger/producers/monitoring/ProductionComponentTimingRecorder.java b/producers/src/main/java/dagger/producers/monitoring/ProductionComponentTimingRecorder.java
new file mode 100644
index 000000000..debe06d9a
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/monitoring/ProductionComponentTimingRecorder.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.monitoring;
+
+import dagger.producers.Produces;
+import dagger.producers.ProductionComponent;
+
+/**
+ * A hook for recording timing of the execution of
+ * {@linkplain ProductionComponent production components}. To install a
+ * {@code ProductionComponentTimingRecorder}, contribute to a set binding of
+ * {@code ProductionComponentTimingRecorder.Factory}, and include the {@code TimingMonitorModule} to
+ * the component. The factory will be asked to create one timing recorder for the component, and the
+ * resulting instance will be used to create individual timing recorders for producers.
+ *
+ * <p>If any of these methods throw, then the exception will be logged, and the framework will act
+ * as though a no-op timing recorder was returned.
+ *
+ * @author Jesse Beder
+ */
+public interface ProductionComponentTimingRecorder {
+  /** Returns a timing recorder for an individual {@linkplain Produces producer method}. */
+  ProducerTimingRecorder producerTimingRecorderFor(ProducerToken token);
+
+  public interface Factory {
+    /** Creates a component-specific timing recorder when the component is created. */
+    ProductionComponentTimingRecorder create(Object component);
+  }
+}
diff --git a/producers/src/main/java/dagger/producers/monitoring/TimingProducerMonitor.java b/producers/src/main/java/dagger/producers/monitoring/TimingProducerMonitor.java
new file mode 100644
index 000000000..a4bfa17c1
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/monitoring/TimingProducerMonitor.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.monitoring;
+
+import com.google.common.base.Stopwatch;
+import com.google.common.base.Ticker;
+
+import static java.util.concurrent.TimeUnit.NANOSECONDS;
+
+/**
+ * A monitor that measures the timing of the execution of a producer method, and logs those timings
+ * with the given recorder.
+ */
+final class TimingProducerMonitor extends ProducerMonitor {
+  private final ProducerTimingRecorder recorder;
+  private final Stopwatch stopwatch;
+  private final Stopwatch componentStopwatch;
+  private long startNanos = -1;
+
+  TimingProducerMonitor(
+      ProducerTimingRecorder recorder, Ticker ticker, Stopwatch componentStopwatch) {
+    this.recorder = recorder;
+    this.stopwatch = Stopwatch.createUnstarted(ticker);
+    this.componentStopwatch = componentStopwatch;
+  }
+
+  @Override
+  public void methodStarting() {
+    startNanos = componentStopwatch.elapsed(NANOSECONDS);
+    stopwatch.start();
+  }
+
+  @Override
+  public void methodFinished() {
+    // TODO(beder): Is a system ticker the appropriate way to track CPU time? Should we use
+    // ThreadCpuTicker instead?
+    long durationNanos = stopwatch.elapsed(NANOSECONDS);
+    recorder.recordMethod(startNanos, durationNanos);
+  }
+
+  @Override
+  public void succeeded(Object o) {
+    long latencyNanos = stopwatch.elapsed(NANOSECONDS);
+    recorder.recordSuccess(latencyNanos);
+  }
+
+  @Override
+  public void failed(Throwable t) {
+    if (stopwatch.isRunning()) {
+      long latencyNanos = stopwatch.elapsed(NANOSECONDS);
+      recorder.recordFailure(t, latencyNanos);
+    } else {
+      recorder.recordSkip(t);
+    }
+  }
+}
diff --git a/producers/src/main/java/dagger/producers/monitoring/TimingProductionComponentMonitor.java b/producers/src/main/java/dagger/producers/monitoring/TimingProductionComponentMonitor.java
new file mode 100644
index 000000000..e6ae829a3
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/monitoring/TimingProductionComponentMonitor.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.monitoring;
+
+import com.google.common.base.Stopwatch;
+import com.google.common.base.Ticker;
+
+/**
+ * A monitor that measures the timing of the execution of a production component, and logs those
+ * timings with the given recorder.
+ *
+ * <p>This assumes that the given recorders do not throw or return null; for example, by using
+ * {@link TimingRecorders#delegatingProductionComponentTimingRecorderFactory}.
+ */
+final class TimingProductionComponentMonitor implements ProductionComponentMonitor {
+  private final ProductionComponentTimingRecorder recorder;
+  private final Ticker ticker;
+  private final Stopwatch stopwatch;
+
+  TimingProductionComponentMonitor(ProductionComponentTimingRecorder recorder, Ticker ticker) {
+    this.recorder = recorder;
+    this.ticker = ticker;
+    this.stopwatch = Stopwatch.createStarted(ticker);
+  }
+
+  @Override
+  public ProducerMonitor producerMonitorFor(ProducerToken token) {
+    return new TimingProducerMonitor(recorder.producerTimingRecorderFor(token), ticker, stopwatch);
+  }
+
+  static final class Factory implements ProductionComponentMonitor.Factory {
+    private final ProductionComponentTimingRecorder.Factory recorderFactory;
+    private final Ticker ticker;
+
+    Factory(ProductionComponentTimingRecorder.Factory recorderFactory) {
+      this(recorderFactory, Ticker.systemTicker());
+    }
+
+    Factory(ProductionComponentTimingRecorder.Factory recorderFactory, Ticker ticker) {
+      this.recorderFactory = recorderFactory;
+      this.ticker = ticker;
+    }
+
+    @Override
+    public ProductionComponentMonitor create(Object component) {
+      return new TimingProductionComponentMonitor(recorderFactory.create(component), ticker);
+    }
+  }
+}
diff --git a/producers/src/main/java/dagger/producers/monitoring/TimingRecorders.java b/producers/src/main/java/dagger/producers/monitoring/TimingRecorders.java
new file mode 100644
index 000000000..842a55a36
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/monitoring/TimingRecorders.java
@@ -0,0 +1,343 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.monitoring;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Iterables;
+import java.util.Collection;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+/**
+ * Utility methods relating to timing.
+ *
+ * @author Jesse Beder
+ */
+final class TimingRecorders {
+  private static final Logger logger = Logger.getLogger(TimingRecorders.class.getName());
+
+  /**
+   * Returns a timing recorder factory that delegates to the given factories, and ensures that any
+   * method called on this object, even transitively, does not throw a {@link RuntimeException} or
+   * return null.
+   *
+   * <p>If the delegate recorders throw an {@link Error}, then that will escape this recorder
+   * implementation. Errors are treated as unrecoverable conditions, and may cause the entire
+   * component's execution to fail.
+   */
+  static ProductionComponentTimingRecorder.Factory
+      delegatingProductionComponentTimingRecorderFactory(
+          Collection<ProductionComponentTimingRecorder.Factory> factories) {
+    switch (factories.size()) {
+      case 0:
+        return noOpProductionComponentTimingRecorderFactory();
+      case 1:
+        return new NonThrowingProductionComponentTimingRecorder.Factory(
+            Iterables.getOnlyElement(factories));
+      default:
+        return new DelegatingProductionComponentTimingRecorder.Factory(factories);
+    }
+  }
+
+  /**
+   * A component recorder that delegates to a single recorder, and catches and logs all exceptions
+   * that the delegate throws.
+   */
+  private static final class NonThrowingProductionComponentTimingRecorder
+      implements ProductionComponentTimingRecorder {
+    private final ProductionComponentTimingRecorder delegate;
+
+    NonThrowingProductionComponentTimingRecorder(ProductionComponentTimingRecorder delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override
+    public ProducerTimingRecorder producerTimingRecorderFor(ProducerToken token) {
+      try {
+        ProducerTimingRecorder recorder = delegate.producerTimingRecorderFor(token);
+        return recorder == null
+            ? ProducerTimingRecorder.noOp()
+            : new NonThrowingProducerTimingRecorder(recorder);
+      } catch (RuntimeException e) {
+        logProducerTimingRecorderForException(e, delegate, token);
+        return ProducerTimingRecorder.noOp();
+      }
+    }
+
+    static final class Factory implements ProductionComponentTimingRecorder.Factory {
+      private final ProductionComponentTimingRecorder.Factory delegate;
+
+      Factory(ProductionComponentTimingRecorder.Factory delegate) {
+        this.delegate = delegate;
+      }
+
+      @Override
+      public ProductionComponentTimingRecorder create(Object component) {
+        try {
+          ProductionComponentTimingRecorder recorder = delegate.create(component);
+          return recorder == null
+              ? noOpProductionComponentTimingRecorder()
+              : new NonThrowingProductionComponentTimingRecorder(recorder);
+        } catch (RuntimeException e) {
+          logCreateException(e, delegate, component);
+          return noOpProductionComponentTimingRecorder();
+        }
+      }
+    }
+  }
+
+  /**
+   * A producer recorder that delegates to a single recorder, and catches and logs all exceptions
+   * that the delegate throws.
+   */
+  private static final class NonThrowingProducerTimingRecorder extends ProducerTimingRecorder {
+    private final ProducerTimingRecorder delegate;
+
+    NonThrowingProducerTimingRecorder(ProducerTimingRecorder delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override
+    public void recordMethod(long startedNanos, long durationNanos) {
+      try {
+        delegate.recordMethod(startedNanos, durationNanos);
+      } catch (RuntimeException e) {
+        logProducerTimingRecorderMethodException(e, delegate, "recordMethod");
+      }
+    }
+
+    @Override
+    public void recordSuccess(long latencyNanos) {
+      try {
+        delegate.recordSuccess(latencyNanos);
+      } catch (RuntimeException e) {
+        logProducerTimingRecorderMethodException(e, delegate, "recordSuccess");
+      }
+    }
+
+    @Override
+    public void recordFailure(Throwable exception, long latencyNanos) {
+      try {
+        delegate.recordFailure(exception, latencyNanos);
+      } catch (RuntimeException e) {
+        logProducerTimingRecorderMethodException(e, delegate, "recordFailure");
+      }
+    }
+
+    @Override
+    public void recordSkip(Throwable exception) {
+      try {
+        delegate.recordSkip(exception);
+      } catch (RuntimeException e) {
+        logProducerTimingRecorderMethodException(e, delegate, "recordSkip");
+      }
+    }
+  }
+
+  /**
+   * A component recorder that delegates to several recorders, and catches and logs all exceptions
+   * that the delegates throw.
+   */
+  private static final class DelegatingProductionComponentTimingRecorder
+      implements ProductionComponentTimingRecorder {
+    private final ImmutableList<ProductionComponentTimingRecorder> delegates;
+
+    DelegatingProductionComponentTimingRecorder(
+        ImmutableList<ProductionComponentTimingRecorder> delegates) {
+      this.delegates = delegates;
+    }
+
+    @Override
+    public ProducerTimingRecorder producerTimingRecorderFor(ProducerToken token) {
+      ImmutableList.Builder<ProducerTimingRecorder> recordersBuilder = ImmutableList.builder();
+      for (ProductionComponentTimingRecorder delegate : delegates) {
+        try {
+          ProducerTimingRecorder recorder = delegate.producerTimingRecorderFor(token);
+          if (recorder != null) {
+            recordersBuilder.add(recorder);
+          }
+        } catch (RuntimeException e) {
+          logProducerTimingRecorderForException(e, delegate, token);
+        }
+      }
+      ImmutableList<ProducerTimingRecorder> recorders = recordersBuilder.build();
+      switch (recorders.size()) {
+        case 0:
+          return ProducerTimingRecorder.noOp();
+        case 1:
+          return new NonThrowingProducerTimingRecorder(Iterables.getOnlyElement(recorders));
+        default:
+          return new DelegatingProducerTimingRecorder(recorders);
+      }
+    }
+
+    static final class Factory implements ProductionComponentTimingRecorder.Factory {
+      private final ImmutableList<? extends ProductionComponentTimingRecorder.Factory> delegates;
+
+      Factory(Iterable<? extends ProductionComponentTimingRecorder.Factory> delegates) {
+        this.delegates = ImmutableList.copyOf(delegates);
+      }
+
+      @Override
+      public ProductionComponentTimingRecorder create(Object component) {
+        ImmutableList.Builder<ProductionComponentTimingRecorder> recordersBuilder =
+            ImmutableList.builder();
+        for (ProductionComponentTimingRecorder.Factory delegate : delegates) {
+          try {
+            ProductionComponentTimingRecorder recorder = delegate.create(component);
+            if (recorder != null) {
+              recordersBuilder.add(recorder);
+            }
+          } catch (RuntimeException e) {
+            logCreateException(e, delegate, component);
+          }
+        }
+        ImmutableList<ProductionComponentTimingRecorder> recorders = recordersBuilder.build();
+        switch (recorders.size()) {
+          case 0:
+            return noOpProductionComponentTimingRecorder();
+          case 1:
+            return new NonThrowingProductionComponentTimingRecorder(
+                Iterables.getOnlyElement(recorders));
+          default:
+            return new DelegatingProductionComponentTimingRecorder(recorders);
+        }
+      }
+    }
+  }
+
+  /**
+   * A producer recorder that delegates to several recorders, and catches and logs all exceptions
+   * that the delegates throw.
+   */
+  private static final class DelegatingProducerTimingRecorder extends ProducerTimingRecorder {
+    private final ImmutableList<ProducerTimingRecorder> delegates;
+
+    DelegatingProducerTimingRecorder(ImmutableList<ProducerTimingRecorder> delegates) {
+      this.delegates = delegates;
+    }
+
+    @Override
+    public void recordMethod(long startedNanos, long durationNanos) {
+      for (ProducerTimingRecorder delegate : delegates) {
+        try {
+          delegate.recordMethod(startedNanos, durationNanos);
+        } catch (RuntimeException e) {
+          logProducerTimingRecorderMethodException(e, delegate, "recordMethod");
+        }
+      }
+    }
+
+    @Override
+    public void recordSuccess(long latencyNanos) {
+      for (ProducerTimingRecorder delegate : delegates) {
+        try {
+          delegate.recordSuccess(latencyNanos);
+        } catch (RuntimeException e) {
+          logProducerTimingRecorderMethodException(e, delegate, "recordSuccess");
+        }
+      }
+    }
+
+    @Override
+    public void recordFailure(Throwable exception, long latencyNanos) {
+      for (ProducerTimingRecorder delegate : delegates) {
+        try {
+          delegate.recordFailure(exception, latencyNanos);
+        } catch (RuntimeException e) {
+          logProducerTimingRecorderMethodException(e, delegate, "recordFailure");
+        }
+      }
+    }
+
+    @Override
+    public void recordSkip(Throwable exception) {
+      for (ProducerTimingRecorder delegate : delegates) {
+        try {
+          delegate.recordSkip(exception);
+        } catch (RuntimeException e) {
+          logProducerTimingRecorderMethodException(e, delegate, "recordSkip");
+        }
+      }
+    }
+  }
+
+  /** Returns a recorder factory that returns no-op component recorders. */
+  public static ProductionComponentTimingRecorder.Factory
+      noOpProductionComponentTimingRecorderFactory() {
+    return NO_OP_PRODUCTION_COMPONENT_TIMING_RECORDER_FACTORY;
+  }
+
+  /** Returns a component recorder that returns no-op producer recorders. */
+  public static ProductionComponentTimingRecorder noOpProductionComponentTimingRecorder() {
+    return NO_OP_PRODUCTION_COMPONENT_TIMING_RECORDER;
+  }
+
+  private static final ProductionComponentTimingRecorder.Factory
+      NO_OP_PRODUCTION_COMPONENT_TIMING_RECORDER_FACTORY =
+          new ProductionComponentTimingRecorder.Factory() {
+            @Override
+            public ProductionComponentTimingRecorder create(Object component) {
+              return noOpProductionComponentTimingRecorder();
+            }
+          };
+
+  private static final ProductionComponentTimingRecorder
+      NO_OP_PRODUCTION_COMPONENT_TIMING_RECORDER =
+          new ProductionComponentTimingRecorder() {
+            @Override
+            public ProducerTimingRecorder producerTimingRecorderFor(ProducerToken token) {
+              return ProducerTimingRecorder.noOp();
+            }
+          };
+
+  private static void logCreateException(
+      RuntimeException e, ProductionComponentTimingRecorder.Factory factory, Object component) {
+    logger.log(
+        Level.SEVERE,
+        "RuntimeException while calling ProductionComponentTimingRecorder.Factory.create on"
+            + " factory "
+            + factory
+            + " with component "
+            + component,
+        e);
+  }
+
+  private static void logProducerTimingRecorderForException(
+      RuntimeException e, ProductionComponentTimingRecorder recorder, ProducerToken token) {
+    logger.log(
+        Level.SEVERE,
+        "RuntimeException while calling ProductionComponentTimingRecorder.producerTimingRecorderFor"
+            + "on recorder "
+            + recorder
+            + " with token "
+            + token,
+        e);
+  }
+
+  private static void logProducerTimingRecorderMethodException(
+      RuntimeException e, ProducerTimingRecorder recorder, String method) {
+    logger.log(
+        Level.SEVERE,
+        "RuntimeException while calling ProducerTimingRecorder."
+            + method
+            + " on recorder "
+            + recorder,
+        e);
+  }
+
+  private TimingRecorders() {}
+}
diff --git a/producers/src/test/java/dagger/producers/monitoring/TimingProductionComponentMonitorTest.java b/producers/src/test/java/dagger/producers/monitoring/TimingProductionComponentMonitorTest.java
new file mode 100644
index 000000000..bceecf1aa
--- /dev/null
+++ b/producers/src/test/java/dagger/producers/monitoring/TimingProductionComponentMonitorTest.java
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.monitoring;
+
+import com.google.common.testing.FakeTicker;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
+@RunWith(JUnit4.class)
+public final class TimingProductionComponentMonitorTest {
+  private static final class ProducerClassA {}
+
+  private static final class ProducerClassB {}
+
+  @Mock private ProductionComponentTimingRecorder.Factory productionComponentTimingRecorderFactory;
+  @Mock private ProductionComponentTimingRecorder productionComponentTimingRecorder;
+  @Mock private ProducerTimingRecorder producerTimingRecorderA;
+  @Mock private ProducerTimingRecorder producerTimingRecorderB;
+
+  private FakeTicker ticker;
+  private ProductionComponentMonitor.Factory monitorFactory;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    when(productionComponentTimingRecorderFactory.create(any(Object.class)))
+        .thenReturn(productionComponentTimingRecorder);
+    when(
+            productionComponentTimingRecorder.producerTimingRecorderFor(
+                ProducerToken.create(ProducerClassA.class)))
+        .thenReturn(producerTimingRecorderA);
+    when(
+            productionComponentTimingRecorder.producerTimingRecorderFor(
+                ProducerToken.create(ProducerClassB.class)))
+        .thenReturn(producerTimingRecorderB);
+    ticker = new FakeTicker();
+    monitorFactory =
+        new TimingProductionComponentMonitor.Factory(
+            productionComponentTimingRecorderFactory, ticker);
+  }
+
+  @Test
+  public void normalExecution_success() {
+    ProductionComponentMonitor monitor = monitorFactory.create(new Object());
+    ProducerMonitor producerMonitorA =
+        monitor.producerMonitorFor(ProducerToken.create(ProducerClassA.class));
+    ticker.advance(5000222);
+    producerMonitorA.methodStarting();
+    ticker.advance(1333);
+    producerMonitorA.methodFinished();
+    ticker.advance(40000555);
+    ProducerMonitor producerMonitorB =
+        monitor.producerMonitorFor(ProducerToken.create(ProducerClassB.class));
+    producerMonitorB.methodStarting();
+    ticker.advance(2000777);
+    producerMonitorA.succeeded(new Object());
+    ticker.advance(3000999);
+    producerMonitorB.methodFinished();
+    ticker.advance(100000222);
+    producerMonitorB.succeeded(new Object());
+
+    verify(producerTimingRecorderA).recordMethod(5000222, 1333);
+    verify(producerTimingRecorderA).recordSuccess(1333 + 40000555 + 2000777);
+    verify(producerTimingRecorderB).recordMethod(5000222 + 1333 + 40000555, 2000777 + 3000999);
+    verify(producerTimingRecorderB).recordSuccess(2000777 + 3000999 + 100000222);
+    verifyNoMoreInteractions(producerTimingRecorderA, producerTimingRecorderB);
+  }
+
+  @Test
+  public void normalExecution_failure() {
+    Throwable failureA = new RuntimeException("monkey");
+    Throwable failureB = new RuntimeException("gorilla");
+    ProductionComponentMonitor monitor = monitorFactory.create(new Object());
+    ProducerMonitor producerMonitorA =
+        monitor.producerMonitorFor(ProducerToken.create(ProducerClassA.class));
+    ticker.advance(5000222);
+    producerMonitorA.methodStarting();
+    ticker.advance(1333);
+    producerMonitorA.methodFinished();
+    ticker.advance(40000555);
+    ProducerMonitor producerMonitorB =
+        monitor.producerMonitorFor(ProducerToken.create(ProducerClassB.class));
+    producerMonitorB.methodStarting();
+    ticker.advance(2000777);
+    producerMonitorA.failed(failureA);
+    ticker.advance(3000999);
+    producerMonitorB.methodFinished();
+    ticker.advance(100000222);
+    producerMonitorB.failed(failureB);
+
+    verify(producerTimingRecorderA).recordMethod(5000222, 1333);
+    verify(producerTimingRecorderA).recordFailure(failureA, 1333 + 40000555 + 2000777);
+    verify(producerTimingRecorderB).recordMethod(5000222 + 1333 + 40000555, 2000777 + 3000999);
+    verify(producerTimingRecorderB).recordFailure(failureB, 2000777 + 3000999 + 100000222);
+    verifyNoMoreInteractions(producerTimingRecorderA, producerTimingRecorderB);
+  }
+}
diff --git a/producers/src/test/java/dagger/producers/monitoring/TimingRecordersTest.java b/producers/src/test/java/dagger/producers/monitoring/TimingRecordersTest.java
new file mode 100644
index 000000000..cf54d9670
--- /dev/null
+++ b/producers/src/test/java/dagger/producers/monitoring/TimingRecordersTest.java
@@ -0,0 +1,358 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.monitoring;
+
+import com.google.common.collect.ImmutableList;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
+@RunWith(JUnit4.class)
+public final class TimingRecordersTest {
+  @Mock
+  private ProductionComponentTimingRecorder.Factory mockProductionComponentTimingRecorderFactory;
+
+  @Mock private ProductionComponentTimingRecorder mockProductionComponentTimingRecorder;
+  @Mock private ProducerTimingRecorder mockProducerTimingRecorder;
+
+  @Mock
+  private ProductionComponentTimingRecorder.Factory mockProductionComponentTimingRecorderFactoryA;
+
+  @Mock
+  private ProductionComponentTimingRecorder.Factory mockProductionComponentTimingRecorderFactoryB;
+
+  @Mock
+  private ProductionComponentTimingRecorder.Factory mockProductionComponentTimingRecorderFactoryC;
+
+  @Mock private ProductionComponentTimingRecorder mockProductionComponentTimingRecorderA;
+  @Mock private ProductionComponentTimingRecorder mockProductionComponentTimingRecorderB;
+  @Mock private ProductionComponentTimingRecorder mockProductionComponentTimingRecorderC;
+  @Mock private ProducerTimingRecorder mockProducerTimingRecorderA;
+  @Mock private ProducerTimingRecorder mockProducerTimingRecorderB;
+  @Mock private ProducerTimingRecorder mockProducerTimingRecorderC;
+
+  @Before
+  public void initMocks() {
+    MockitoAnnotations.initMocks(this);
+  }
+
+  @Test
+  public void zeroRecordersReturnsNoOp() {
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.<ProductionComponentTimingRecorder.Factory>of());
+    assertThat(factory).isSameAs(TimingRecorders.noOpProductionComponentTimingRecorderFactory());
+  }
+
+  @Test
+  public void singleRecorder_nullProductionComponentTimingRecorder() {
+    when(mockProductionComponentTimingRecorderFactory.create(any(Object.class))).thenReturn(null);
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(mockProductionComponentTimingRecorderFactory));
+    assertThat(factory.create(new Object()))
+        .isSameAs(TimingRecorders.noOpProductionComponentTimingRecorder());
+  }
+
+  @Test
+  public void singleRecorder_throwingProductionComponentTimingRecorderFactory() {
+    when(mockProductionComponentTimingRecorderFactory.create(any(Object.class)))
+        .thenThrow(new RuntimeException("monkey"));
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(mockProductionComponentTimingRecorderFactory));
+    assertThat(factory.create(new Object()))
+        .isSameAs(TimingRecorders.noOpProductionComponentTimingRecorder());
+  }
+
+  @Test
+  public void singleRecorder_nullProducerTimingRecorder() {
+    when(mockProductionComponentTimingRecorderFactory.create(any(Object.class)))
+        .thenReturn(mockProductionComponentTimingRecorder);
+    when(mockProductionComponentTimingRecorder.producerTimingRecorderFor(any(ProducerToken.class)))
+        .thenReturn(null);
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(mockProductionComponentTimingRecorderFactory));
+    ProductionComponentTimingRecorder recorder = factory.create(new Object());
+    assertThat(recorder.producerTimingRecorderFor(ProducerToken.create(Object.class)))
+        .isSameAs(ProducerTimingRecorder.noOp());
+  }
+
+  @Test
+  public void singleRecorder_throwingProductionComponentTimingRecorder() {
+    when(mockProductionComponentTimingRecorderFactory.create(any(Object.class)))
+        .thenReturn(mockProductionComponentTimingRecorder);
+    when(mockProductionComponentTimingRecorder.producerTimingRecorderFor(any(ProducerToken.class)))
+        .thenThrow(new RuntimeException("monkey"));
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(mockProductionComponentTimingRecorderFactory));
+    ProductionComponentTimingRecorder recorder = factory.create(new Object());
+    assertThat(recorder.producerTimingRecorderFor(ProducerToken.create(Object.class)))
+        .isSameAs(ProducerTimingRecorder.noOp());
+  }
+
+  @Test
+  public void singleRecorder_normalProducerTimingRecorderSuccess() {
+    setUpNormalSingleRecorder();
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(mockProductionComponentTimingRecorderFactory));
+    ProductionComponentTimingRecorder recorder = factory.create(new Object());
+    ProducerTimingRecorder producerTimingRecorder =
+        recorder.producerTimingRecorderFor(ProducerToken.create(Object.class));
+    producerTimingRecorder.recordMethod(15, 42);
+    producerTimingRecorder.recordSuccess(100);
+
+    InOrder order = inOrder(mockProducerTimingRecorder);
+    order.verify(mockProducerTimingRecorder).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorder).recordSuccess(100);
+    verifyNoMoreInteractions(mockProducerTimingRecorder);
+  }
+
+  @Test
+  public void singleRecorder_normalProducerTimingRecorderFailure() {
+    setUpNormalSingleRecorder();
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(mockProductionComponentTimingRecorderFactory));
+    ProductionComponentTimingRecorder recorder = factory.create(new Object());
+    ProducerTimingRecorder producerTimingRecorder =
+        recorder.producerTimingRecorderFor(ProducerToken.create(Object.class));
+    Throwable t = new RuntimeException("monkey");
+    producerTimingRecorder.recordMethod(15, 42);
+    producerTimingRecorder.recordFailure(t, 100);
+
+    InOrder order = inOrder(mockProducerTimingRecorder);
+    order.verify(mockProducerTimingRecorder).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorder).recordFailure(t, 100);
+    verifyNoMoreInteractions(mockProducerTimingRecorder);
+  }
+
+  @Test
+  public void singleRecorder_throwingProducerTimingRecorderSuccess() {
+    setUpNormalSingleRecorder();
+    doThrow(new RuntimeException("monkey"))
+        .when(mockProducerTimingRecorder)
+        .recordMethod(any(Long.class), any(Long.class));
+    doThrow(new RuntimeException("monkey"))
+        .when(mockProducerTimingRecorder)
+        .recordSuccess(any(Long.class));
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(mockProductionComponentTimingRecorderFactory));
+    ProductionComponentTimingRecorder recorder = factory.create(new Object());
+    ProducerTimingRecorder producerTimingRecorder =
+        recorder.producerTimingRecorderFor(ProducerToken.create(Object.class));
+    producerTimingRecorder.recordMethod(15, 42);
+    producerTimingRecorder.recordSuccess(100);
+
+    InOrder order = inOrder(mockProducerTimingRecorder);
+    order.verify(mockProducerTimingRecorder).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorder).recordSuccess(100);
+    verifyNoMoreInteractions(mockProducerTimingRecorder);
+  }
+
+  @Test
+  public void multipleRecorders_nullProductionComponentTimingRecorders() {
+    when(mockProductionComponentTimingRecorderFactoryA.create(any(Object.class))).thenReturn(null);
+    when(mockProductionComponentTimingRecorderFactoryB.create(any(Object.class))).thenReturn(null);
+    when(mockProductionComponentTimingRecorderFactoryC.create(any(Object.class))).thenReturn(null);
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(
+                mockProductionComponentTimingRecorderFactoryA,
+                mockProductionComponentTimingRecorderFactoryB,
+                mockProductionComponentTimingRecorderFactoryC));
+    assertThat(factory.create(new Object()))
+        .isSameAs(TimingRecorders.noOpProductionComponentTimingRecorder());
+  }
+
+  @Test
+  public void multipleRecorders_throwingProductionComponentTimingRecorderFactories() {
+    when(mockProductionComponentTimingRecorderFactoryA.create(any(Object.class)))
+        .thenThrow(new RuntimeException("monkey"));
+    when(mockProductionComponentTimingRecorderFactoryB.create(any(Object.class)))
+        .thenThrow(new RuntimeException("monkey"));
+    when(mockProductionComponentTimingRecorderFactoryC.create(any(Object.class)))
+        .thenThrow(new RuntimeException("monkey"));
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(
+                mockProductionComponentTimingRecorderFactoryA,
+                mockProductionComponentTimingRecorderFactoryB,
+                mockProductionComponentTimingRecorderFactoryC));
+    assertThat(factory.create(new Object()))
+        .isSameAs(TimingRecorders.noOpProductionComponentTimingRecorder());
+  }
+
+  @Test
+  public void multipleRecorders_someNullProductionComponentTimingRecorders() {
+    when(mockProductionComponentTimingRecorderFactoryA.create(any(Object.class)))
+        .thenReturn(mockProductionComponentTimingRecorderA);
+    when(mockProductionComponentTimingRecorderFactoryB.create(any(Object.class))).thenReturn(null);
+    when(mockProductionComponentTimingRecorderFactoryC.create(any(Object.class))).thenReturn(null);
+    when(mockProductionComponentTimingRecorderA.producerTimingRecorderFor(any(ProducerToken.class)))
+        .thenReturn(mockProducerTimingRecorderA);
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(
+                mockProductionComponentTimingRecorderFactoryA,
+                mockProductionComponentTimingRecorderFactoryB,
+                mockProductionComponentTimingRecorderFactoryC));
+    ProductionComponentTimingRecorder recorder = factory.create(new Object());
+    ProducerTimingRecorder producerTimingRecorder =
+        recorder.producerTimingRecorderFor(ProducerToken.create(Object.class));
+
+    producerTimingRecorder.recordMethod(15, 42);
+    producerTimingRecorder.recordSuccess(100);
+
+    InOrder order = inOrder(mockProducerTimingRecorderA);
+    order.verify(mockProducerTimingRecorderA).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorderA).recordSuccess(100);
+    verifyNoMoreInteractions(mockProducerTimingRecorderA);
+  }
+
+  @Test
+  public void multipleRecorders_someThrowingProductionComponentTimingRecorderFactories() {
+    when(mockProductionComponentTimingRecorderFactoryA.create(any(Object.class)))
+        .thenReturn(mockProductionComponentTimingRecorderA);
+    when(mockProductionComponentTimingRecorderFactoryB.create(any(Object.class)))
+        .thenThrow(new RuntimeException("monkey"));
+    when(mockProductionComponentTimingRecorderFactoryC.create(any(Object.class)))
+        .thenThrow(new RuntimeException("monkey"));
+    when(mockProductionComponentTimingRecorderA.producerTimingRecorderFor(any(ProducerToken.class)))
+        .thenReturn(mockProducerTimingRecorderA);
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(
+                mockProductionComponentTimingRecorderFactoryA,
+                mockProductionComponentTimingRecorderFactoryB,
+                mockProductionComponentTimingRecorderFactoryC));
+    ProductionComponentTimingRecorder recorder = factory.create(new Object());
+    ProducerTimingRecorder producerTimingRecorder =
+        recorder.producerTimingRecorderFor(ProducerToken.create(Object.class));
+
+    producerTimingRecorder.recordMethod(15, 42);
+    producerTimingRecorder.recordSuccess(100);
+
+    InOrder order = inOrder(mockProducerTimingRecorderA);
+    order.verify(mockProducerTimingRecorderA).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorderA).recordSuccess(100);
+    verifyNoMoreInteractions(mockProducerTimingRecorderA);
+  }
+
+  @Test
+  public void multipleRecorders_normalProductionComponentTimingRecorderSuccess() {
+    setUpNormalMultipleRecorders();
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(
+                mockProductionComponentTimingRecorderFactoryA,
+                mockProductionComponentTimingRecorderFactoryB,
+                mockProductionComponentTimingRecorderFactoryC));
+    ProductionComponentTimingRecorder recorder = factory.create(new Object());
+    ProducerTimingRecorder producerTimingRecorder =
+        recorder.producerTimingRecorderFor(ProducerToken.create(Object.class));
+
+    producerTimingRecorder.recordMethod(15, 42);
+    producerTimingRecorder.recordSuccess(100);
+
+    InOrder order =
+        inOrder(
+            mockProducerTimingRecorderA, mockProducerTimingRecorderB, mockProducerTimingRecorderC);
+    order.verify(mockProducerTimingRecorderA).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorderB).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorderC).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorderA).recordSuccess(100);
+    order.verify(mockProducerTimingRecorderB).recordSuccess(100);
+    order.verify(mockProducerTimingRecorderC).recordSuccess(100);
+    verifyNoMoreInteractions(
+        mockProducerTimingRecorderA, mockProducerTimingRecorderB, mockProducerTimingRecorderC);
+  }
+
+  @Test
+  public void multipleRecorders_someThrowingProducerTimingRecordersSuccess() {
+    setUpNormalMultipleRecorders();
+    doThrow(new RuntimeException("monkey"))
+        .when(mockProducerTimingRecorderA)
+        .recordMethod(any(Long.class), any(Long.class));
+    doThrow(new RuntimeException("monkey"))
+        .when(mockProducerTimingRecorderB)
+        .recordSuccess(any(Long.class));
+    doThrow(new RuntimeException("monkey"))
+        .when(mockProducerTimingRecorderC)
+        .recordMethod(any(Long.class), any(Long.class));
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(
+                mockProductionComponentTimingRecorderFactoryA,
+                mockProductionComponentTimingRecorderFactoryB,
+                mockProductionComponentTimingRecorderFactoryC));
+    ProductionComponentTimingRecorder recorder = factory.create(new Object());
+    ProducerTimingRecorder producerTimingRecorder =
+        recorder.producerTimingRecorderFor(ProducerToken.create(Object.class));
+
+    producerTimingRecorder.recordMethod(15, 42);
+    producerTimingRecorder.recordSuccess(100);
+
+    InOrder order =
+        inOrder(
+            mockProducerTimingRecorderA, mockProducerTimingRecorderB, mockProducerTimingRecorderC);
+    order.verify(mockProducerTimingRecorderA).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorderB).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorderC).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorderA).recordSuccess(100);
+    order.verify(mockProducerTimingRecorderB).recordSuccess(100);
+    order.verify(mockProducerTimingRecorderC).recordSuccess(100);
+    verifyNoMoreInteractions(
+        mockProducerTimingRecorderA, mockProducerTimingRecorderB, mockProducerTimingRecorderC);
+  }
+
+  private void setUpNormalSingleRecorder() {
+    when(mockProductionComponentTimingRecorderFactory.create(any(Object.class)))
+        .thenReturn(mockProductionComponentTimingRecorder);
+    when(mockProductionComponentTimingRecorder.producerTimingRecorderFor(any(ProducerToken.class)))
+        .thenReturn(mockProducerTimingRecorder);
+  }
+
+  private void setUpNormalMultipleRecorders() {
+    when(mockProductionComponentTimingRecorderFactoryA.create(any(Object.class)))
+        .thenReturn(mockProductionComponentTimingRecorderA);
+    when(mockProductionComponentTimingRecorderFactoryB.create(any(Object.class)))
+        .thenReturn(mockProductionComponentTimingRecorderB);
+    when(mockProductionComponentTimingRecorderFactoryC.create(any(Object.class)))
+        .thenReturn(mockProductionComponentTimingRecorderC);
+    when(mockProductionComponentTimingRecorderA.producerTimingRecorderFor(any(ProducerToken.class)))
+        .thenReturn(mockProducerTimingRecorderA);
+    when(mockProductionComponentTimingRecorderB.producerTimingRecorderFor(any(ProducerToken.class)))
+        .thenReturn(mockProducerTimingRecorderB);
+    when(mockProductionComponentTimingRecorderC.producerTimingRecorderFor(any(ProducerToken.class)))
+        .thenReturn(mockProducerTimingRecorderC);
+  }
+}
