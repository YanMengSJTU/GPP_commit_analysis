diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index a7f69c0f0..c75acbeac 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -86,6 +86,7 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
     MapKeyValidator mapKeyValidator = new MapKeyValidator();
     ModuleValidator producerModuleValidator = new ModuleValidator(
         types, ProducerModule.class, Produces.class);
+    ProducesMethodValidator producesMethodValidator = new ProducesMethodValidator(elements);
 
     Key.Factory keyFactory = new Key.Factory(types, elements);
 
@@ -146,7 +147,8 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
             componentGenerator),
         new ProducerModuleProcessingStep(
             messager,
-            producerModuleValidator));
+            producerModuleValidator,
+            producesMethodValidator));
   }
 
   @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 0f030586c..2cb303478 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -100,35 +100,45 @@
   static final String PROVIDES_METHOD_RETURN_TYPE =
       "@Provides methods must either return a primitive, an array or a declared type.";
 
-  static final String PROVIDES_METHOD_SET_VALUES_RAW_SET =
-      "@Provides methods of type set values cannot return a raw Set";
+  static final String PRODUCES_METHOD_RETURN_TYPE =
+      "@Produces methods must either return a primitive, an array or a declared type, or a"
+      + " ListenableFuture of one of those types.";
+
+  static final String PRODUCES_METHOD_RAW_FUTURE =
+      "@Produces methods cannot return a raw ListenableFuture.";
+
+  static final String BINDING_METHOD_SET_VALUES_RAW_SET =
+      "@%s methods of type set values cannot return a raw Set";
 
   static final String PROVIDES_METHOD_SET_VALUES_RETURN_SET =
       "@Provides methods of type set values must return a Set";
 
-  static final String PROVIDES_METHOD_MUST_RETURN_A_VALUE =
-      "@Provides methods must return a value (not void).";
+  static final String PRODUCES_METHOD_SET_VALUES_RETURN_SET =
+      "@Produces methods of type set values must return a Set or ListenableFuture of Set";
+
+  static final String BINDING_METHOD_MUST_RETURN_A_VALUE =
+      "@%s methods must return a value (not void).";
 
-  static final String PROVIDES_METHOD_ABSTRACT = "@Provides methods cannot be abstract";
+  static final String BINDING_METHOD_ABSTRACT = "@%s methods cannot be abstract";
 
-  static final String PROVIDES_METHOD_STATIC = "@Provides methods cannot be static";
+  static final String BINDING_METHOD_STATIC = "@%s methods cannot be static";
 
-  static final String PROVIDES_METHOD_PRIVATE = "@Provides methods cannot be private";
+  static final String BINDING_METHOD_PRIVATE = "@%s methods cannot be private";
 
-  static final String PROVIDES_METHOD_TYPE_PARAMETER =
-      "@Provides methods may not have type parameters.";
+  static final String BINDING_METHOD_TYPE_PARAMETER =
+      "@%s methods may not have type parameters.";
 
-  static final String PROVIDES_METHOD_NOT_IN_MODULE =
-      "@Provides methods can only be present within a @Module";
+  static final String BINDING_METHOD_NOT_IN_MODULE =
+      "@%s methods can only be present within a @%s";
 
-  static final String PROVIDES_METHOD_NOT_MAP_HAS_MAP_KEY =
-      "@Provides methods of non map type cannot declare a map key";
+  static final String BINDING_METHOD_NOT_MAP_HAS_MAP_KEY =
+      "@%s methods of non map type cannot declare a map key";
 
-  static final String PROVIDES_METHOD_WITH_NO_MAP_KEY =
-      "@Provides methods of type map must declare a map key";
+  static final String BINDING_METHOD_WITH_NO_MAP_KEY =
+      "@%s methods of type map must declare a map key";
 
-  static final String PROVIDES_METHOD_WITH_MULTIPLE_MAP_KEY =
-      "@Provides methods may not have more than one @MapKey-marked annotation";
+  static final String BINDING_METHOD_WITH_MULTIPLE_MAP_KEY =
+      "@%s methods may not have more than one @MapKey-marked annotation";
 
   static final String BINDING_METHOD_WITH_SAME_NAME =
       "Cannot have more than one @%s method with the same name in a single module";
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java
index 20b23ad03..3bbf02585 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java
@@ -17,6 +17,7 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.SuperficialValidation;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
@@ -24,8 +25,11 @@
 import javax.annotation.processing.Messager;
 import javax.annotation.processing.RoundEnvironment;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 
+import static javax.lang.model.element.ElementKind.METHOD;
+
 /**
  * An annotation processor for generating Dagger implementation code based on the
  * {@link ProducerModule} (and {@link Produces}) annotation.
@@ -36,17 +40,36 @@
 final class ProducerModuleProcessingStep implements ProcessingStep {
   private final Messager messager;
   private final ModuleValidator moduleValidator;
+  private final ProducesMethodValidator producesMethodValidator;
   private final Set<Element> processedModuleElements = Sets.newLinkedHashSet();
 
   ProducerModuleProcessingStep(
       Messager messager,
-      ModuleValidator moduleValidator) {
+      ModuleValidator moduleValidator,
+      ProducesMethodValidator producesMethodValidator) {
     this.messager = messager;
     this.moduleValidator = moduleValidator;
+    this.producesMethodValidator = producesMethodValidator;
   }
 
   @Override
   public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
+    // first, check and collect all produces methods
+    ImmutableSet.Builder<ExecutableElement> validProducesMethodsBuilder = ImmutableSet.builder();
+    for (Element producesElement : roundEnv.getElementsAnnotatedWith(Produces.class)) {
+      if (producesElement.getKind().equals(METHOD)) {
+        ExecutableElement producesMethodElement = (ExecutableElement) producesElement;
+        ValidationReport<ExecutableElement> methodReport =
+            producesMethodValidator.validate(producesMethodElement);
+        methodReport.printMessagesTo(messager);
+        if (methodReport.isClean()) {
+          validProducesMethodsBuilder.add(producesMethodElement);
+        }
+      }
+    }
+    @SuppressWarnings("unused")
+    ImmutableSet<ExecutableElement> validProducesMethods = validProducesMethodsBuilder.build();
+
     // process each module
     for (Element moduleElement :
         Sets.difference(roundEnv.getElementsAnnotatedWith(ProducerModule.class),
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
new file mode 100644
index 000000000..24cff39b5
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
@@ -0,0 +1,213 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import java.util.Set;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.ConfigurationAnnotations.getMapKeys;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_MAP_HAS_MAP_KEY;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_STATIC;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_MULTIPLE_MAP_KEY;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_NO_MAP_KEY;
+import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RAW_FUTURE;
+import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RETURN_TYPE;
+import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.STATIC;
+import static javax.lang.model.type.TypeKind.ARRAY;
+import static javax.lang.model.type.TypeKind.DECLARED;
+import static javax.lang.model.type.TypeKind.VOID;
+
+/**
+ * A {@link Validator} for {@link Produces} methods.
+ *
+ * @author Jesse Beder
+ * @since 2.0
+ */
+// TODO(user): Consider unifying this with the ProvidesMethodValidator after Provides.Type and
+// Produces.Type are reconciled.
+final class ProducesMethodValidator implements Validator<ExecutableElement> {
+  private final Elements elements;
+
+  ProducesMethodValidator(Elements elements) {
+    this.elements = checkNotNull(elements);
+  }
+
+  private TypeElement getSetElement() {
+    return elements.getTypeElement(Set.class.getCanonicalName());
+  }
+
+  @Override
+  public ValidationReport<ExecutableElement> validate(ExecutableElement producesMethodElement) {
+    ValidationReport.Builder<ExecutableElement> builder =
+        ValidationReport.Builder.about(producesMethodElement);
+
+    Produces producesAnnotation = producesMethodElement.getAnnotation(Produces.class);
+    checkArgument(producesAnnotation != null);
+
+    Element enclosingElement = producesMethodElement.getEnclosingElement();
+    if (!isAnnotationPresent(enclosingElement, ProducerModule.class)) {
+      builder.addItem(formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE),
+          producesMethodElement);
+    }
+
+    if (!producesMethodElement.getTypeParameters().isEmpty()) {
+      builder.addItem(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER), producesMethodElement);
+    }
+
+    Set<Modifier> modifiers = producesMethodElement.getModifiers();
+    if (modifiers.contains(PRIVATE)) {
+      builder.addItem(formatErrorMessage(BINDING_METHOD_PRIVATE), producesMethodElement);
+    }
+    if (modifiers.contains(STATIC)) {
+      // TODO(gak): why not?
+      builder.addItem(formatErrorMessage(BINDING_METHOD_STATIC), producesMethodElement);
+    }
+    if (modifiers.contains(ABSTRACT)) {
+      builder.addItem(formatErrorMessage(BINDING_METHOD_ABSTRACT), producesMethodElement);
+    }
+
+    TypeMirror returnType = producesMethodElement.getReturnType();
+    TypeKind returnTypeKind = returnType.getKind();
+    if (returnTypeKind.equals(VOID)) {
+      builder.addItem(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE),
+          producesMethodElement);
+    }
+
+    // check mapkey is right
+    if (!producesAnnotation.type().equals(Produces.Type.MAP)
+        && (getMapKeys(producesMethodElement) != null
+            && !getMapKeys(producesMethodElement).isEmpty())) {
+      builder.addItem(formatErrorMessage(BINDING_METHOD_NOT_MAP_HAS_MAP_KEY),
+          producesMethodElement);
+    }
+
+    switch (producesAnnotation.type()) {
+      case UNIQUE: // fall through
+      case SET:
+        validateSingleReturnType(builder, returnType);
+        break;
+      case MAP:
+        validateSingleReturnType(builder, returnType);
+        ImmutableSet<? extends AnnotationMirror> annotationMirrors =
+            getMapKeys(producesMethodElement);
+        switch (annotationMirrors.size()) {
+          case 0:
+            builder.addItem(formatErrorMessage(BINDING_METHOD_WITH_NO_MAP_KEY),
+                producesMethodElement);
+            break;
+          case 1:
+            break;
+          default:
+            builder.addItem(formatErrorMessage(BINDING_METHOD_WITH_MULTIPLE_MAP_KEY),
+                producesMethodElement);
+            break;
+        }
+        break;
+      case SET_VALUES:
+        if (returnTypeKind.equals(DECLARED)
+            && MoreTypes.isTypeOf(ListenableFuture.class, returnType)) {
+          DeclaredType declaredReturnType = MoreTypes.asDeclared(returnType);
+          if (!declaredReturnType.getTypeArguments().isEmpty()) {
+            validateSetType(builder, Iterables.getOnlyElement(
+                declaredReturnType.getTypeArguments()));
+          }
+        } else {
+          validateSetType(builder, returnType);
+        }
+        break;
+      default:
+        throw new AssertionError();
+    }
+
+    return builder.build();
+  }
+
+  private String formatErrorMessage(String msg) {
+    return String.format(msg, Produces.class.getSimpleName());
+  }
+
+  private String formatModuleErrorMessage(String msg) {
+    return String.format(msg, Produces.class.getSimpleName(), ProducerModule.class.getSimpleName());
+  }
+
+  private void validateKeyType(ValidationReport.Builder<? extends Element> reportBuilder,
+      TypeMirror type) {
+    TypeKind kind = type.getKind();
+    if (!(kind.isPrimitive() || kind.equals(DECLARED) || kind.equals(ARRAY))) {
+      reportBuilder.addItem(PRODUCES_METHOD_RETURN_TYPE, reportBuilder.getSubject());
+    }
+  }
+
+  private void validateSingleReturnType(ValidationReport.Builder<? extends Element> reportBuilder,
+      TypeMirror type) {
+    if (type.getKind().equals(DECLARED) && MoreTypes.isTypeOf(ListenableFuture.class, type)) {
+      DeclaredType declaredType = MoreTypes.asDeclared(type);
+      if (declaredType.getTypeArguments().isEmpty()) {
+        reportBuilder.addItem(PRODUCES_METHOD_RAW_FUTURE, reportBuilder.getSubject());
+      } else {
+        validateKeyType(reportBuilder, Iterables.getOnlyElement(declaredType.getTypeArguments()));
+      }
+    } else {
+      validateKeyType(reportBuilder, type);
+    }
+  }
+
+  private void validateSetType(ValidationReport.Builder<? extends Element> reportBuilder,
+      TypeMirror type) {
+    if (!type.getKind().equals(DECLARED)) {
+      reportBuilder.addItem(PRODUCES_METHOD_SET_VALUES_RETURN_SET, reportBuilder.getSubject());
+      return;
+    }
+
+    // TODO(gak): should we allow "covariant return" for set values?
+    DeclaredType declaredType = MoreTypes.asDeclared(type);
+    if (!declaredType.asElement().equals(getSetElement())) {
+      reportBuilder.addItem(PRODUCES_METHOD_SET_VALUES_RETURN_SET, reportBuilder.getSubject());
+    } else if (declaredType.getTypeArguments().isEmpty()) {
+      reportBuilder.addItem(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET),
+          reportBuilder.getSubject());
+    } else {
+      validateSingleReturnType(reportBuilder,
+          Iterables.getOnlyElement(declaredType.getTypeArguments()));
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
index fa4e70d30..1a4161410 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
@@ -34,18 +34,18 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.ConfigurationAnnotations.getMapKeys;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_ABSTRACT;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_MUST_RETURN_A_VALUE;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_NOT_IN_MODULE;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_NOT_MAP_HAS_MAP_KEY;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_PRIVATE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_MAP_HAS_MAP_KEY;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_STATIC;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_MULTIPLE_MAP_KEY;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_NO_MAP_KEY;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_RETURN_TYPE;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RAW_SET;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RETURN_SET;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_STATIC;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_TYPE_PARAMETER;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_WITH_MULTIPLE_MAP_KEY;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_WITH_NO_MAP_KEY;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
@@ -80,37 +80,41 @@ private TypeElement getSetElement() {
 
     Element enclosingElement = providesMethodElement.getEnclosingElement();
     if (!isAnnotationPresent(enclosingElement, Module.class)) {
-      builder.addItem(PROVIDES_METHOD_NOT_IN_MODULE,
+      builder.addItem(formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE),
           providesMethodElement);
     }
     
     if (!providesMethodElement.getTypeParameters().isEmpty()) {
-      builder.addItem(PROVIDES_METHOD_TYPE_PARAMETER, providesMethodElement);
+      builder.addItem(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER),
+          providesMethodElement);
     }
 
     Set<Modifier> modifiers = providesMethodElement.getModifiers();
     if (modifiers.contains(PRIVATE)) {
-      builder.addItem(PROVIDES_METHOD_PRIVATE, providesMethodElement);
+      builder.addItem(formatErrorMessage(BINDING_METHOD_PRIVATE),
+          providesMethodElement);
     }
     if (modifiers.contains(STATIC)) {
       // TODO(gak): why not?
-      builder.addItem(PROVIDES_METHOD_STATIC, providesMethodElement);
+      builder.addItem(formatErrorMessage(BINDING_METHOD_STATIC), providesMethodElement);
     }
     if (modifiers.contains(ABSTRACT)) {
-      builder.addItem(PROVIDES_METHOD_ABSTRACT, providesMethodElement);
+      builder.addItem(formatErrorMessage(BINDING_METHOD_ABSTRACT), providesMethodElement);
     }
 
     TypeMirror returnType = providesMethodElement.getReturnType();
     TypeKind returnTypeKind = returnType.getKind();
     if (returnTypeKind.equals(VOID)) {
-      builder.addItem(PROVIDES_METHOD_MUST_RETURN_A_VALUE, providesMethodElement);
+      builder.addItem(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE),
+          providesMethodElement);
     }
   
     // check mapkey is right
     if (!providesAnnotation.type().equals(Provides.Type.MAP) 
         && (getMapKeys(providesMethodElement) != null
             && getMapKeys(providesMethodElement).size() > 0)) {
-      builder.addItem(PROVIDES_METHOD_NOT_MAP_HAS_MAP_KEY, providesMethodElement);
+      builder.addItem(formatErrorMessage(BINDING_METHOD_NOT_MAP_HAS_MAP_KEY),
+          providesMethodElement);
     }
 
     switch (providesAnnotation.type()) {
@@ -124,12 +128,14 @@ private TypeElement getSetElement() {
             getMapKeys(providesMethodElement);
         switch (annotationMirrors.size()) {
           case 0:
-            builder.addItem(PROVIDES_METHOD_WITH_NO_MAP_KEY, providesMethodElement);
+            builder.addItem(formatErrorMessage(BINDING_METHOD_WITH_NO_MAP_KEY),
+                providesMethodElement);
             break;
           case 1:
             break;
           default:
-            builder.addItem(PROVIDES_METHOD_WITH_MULTIPLE_MAP_KEY, providesMethodElement);
+            builder.addItem(formatErrorMessage(BINDING_METHOD_WITH_MULTIPLE_MAP_KEY),
+                providesMethodElement);
             break;
         }
         break;
@@ -142,7 +148,8 @@ private TypeElement getSetElement() {
           if (!declaredReturnType.asElement().equals(getSetElement())) {
             builder.addItem(PROVIDES_METHOD_SET_VALUES_RETURN_SET, providesMethodElement);
           } else if (declaredReturnType.getTypeArguments().isEmpty()) {
-            builder.addItem(PROVIDES_METHOD_SET_VALUES_RAW_SET, providesMethodElement);
+            builder.addItem(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET),
+                providesMethodElement);
           } else {
             validateKeyType(builder,
                 Iterables.getOnlyElement(declaredReturnType.getTypeArguments()));
@@ -156,6 +163,14 @@ private TypeElement getSetElement() {
     return builder.build();
   }
 
+  private String formatErrorMessage(String msg) {
+    return String.format(msg, Provides.class.getSimpleName());
+  }
+
+  private String formatModuleErrorMessage(String msg) {
+    return String.format(msg, Provides.class.getSimpleName(), Module.class.getSimpleName());
+  }
+
   private void validateKeyType(ValidationReport.Builder<? extends Element> reportBuilder,
       TypeMirror type) {
     TypeKind kind = type.getKind();
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index b5ced7c04..783f2f045 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -25,22 +25,30 @@
 import static com.google.common.truth.Truth.assert_;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_STATIC;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_ABSTRACT;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_MUST_RETURN_A_VALUE;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_NOT_IN_MODULE;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_PRIVATE;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_RETURN_TYPE;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RAW_SET;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RETURN_SET;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_STATIC;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_TYPE_PARAMETER;
 
 @RunWith(JUnit4.class)
 public class ModuleFactoryGeneratorTest {
   // TODO(gak): add tests for invalid combinations of scope and qualifier annotations like we have
   // for @Inject
 
+  private String formatErrorMessage(String msg) {
+    return String.format(msg, "Provides");
+  }
+
+  private String formatModuleErrorMessage(String msg) {
+    return String.format(msg, "Provides", "Module");
+  }
+
   @Test public void providesMethodNotInModule() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
@@ -55,7 +63,7 @@
     assert_().about(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(PROVIDES_METHOD_NOT_IN_MODULE);
+        .withErrorContaining(formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE));
   }
 
   @Test public void providesMethodAbstract() {
@@ -72,7 +80,7 @@
     assert_().about(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(PROVIDES_METHOD_ABSTRACT);
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_ABSTRACT));
   }
 
   @Test public void providesMethodPrivate() {
@@ -91,7 +99,7 @@
     assert_().about(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(PROVIDES_METHOD_PRIVATE);
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_PRIVATE));
   }
 
   @Test public void providesMethodStatic() {
@@ -110,7 +118,7 @@
     assert_().about(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(PROVIDES_METHOD_STATIC);
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_STATIC));
   }
 
   @Test public void providesMethodReturnVoid() {
@@ -127,7 +135,7 @@
     assert_().about(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(PROVIDES_METHOD_MUST_RETURN_A_VALUE);
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE));
   }
 
   @Test public void providesMethodWithTypeParameter() {
@@ -146,7 +154,7 @@
     assert_().about(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(PROVIDES_METHOD_TYPE_PARAMETER);
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER));
   }
 
   @Test public void providesMethodSetValuesWildcard() {
@@ -192,7 +200,7 @@
     assert_().about(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(PROVIDES_METHOD_SET_VALUES_RAW_SET);
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET));
   }
 
   @Test public void providesMethodSetValuesNotASet() {
@@ -330,7 +338,7 @@
         .and().generatesSources(listFactoryFile);
   }
 
-  @Test public void proviesSetElement() {
+  @Test public void providesSetElement() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
@@ -432,12 +440,12 @@
         "    return \"\";",
         "  }",
         "}");
-    String errorMessage = String.format(BINDING_METHOD_WITH_SAME_NAME, "Provides");
     assert_().about(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(errorMessage).in(moduleFile).onLine(8)
-        .and().withErrorContaining(errorMessage).in(moduleFile).onLine(12);
+    .withErrorContaining(formatErrorMessage(BINDING_METHOD_WITH_SAME_NAME)).in(moduleFile).onLine(8)
+        .and().withErrorContaining(formatErrorMessage(BINDING_METHOD_WITH_SAME_NAME))
+        .in(moduleFile).onLine(12);
   }
 
   @Test
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index a3a3eb418..b8c76adb2 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -25,10 +25,313 @@
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_STATIC;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;
+import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RAW_FUTURE;
+import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RETURN_TYPE;
+import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;
 
 @RunWith(JUnit4.class)
 public class ProducerModuleFactoryGeneratorTest {
+  private String formatErrorMessage(String msg) {
+    return String.format(msg, "Produces");
+  }
+
+  private String formatModuleErrorMessage(String msg) {
+    return String.format(msg, "Produces", "ProducerModule");
+  }
+
+  @Test public void producesMethodNotInModule() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.producers.Produces;",
+        "",
+        "final class TestModule {",
+        "  @Produces String produceString() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE));
+  }
+
+  @Test public void producesMethodAbstract() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "@ProducerModule",
+        "abstract class TestModule {",
+        "  @Produces abstract String produceString();",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_ABSTRACT));
+  }
+
+  @Test public void producesMethodPrivate() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces private String produceString() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_PRIVATE));
+  }
+
+  @Test public void producesMethodStatic() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces static String produceString() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_STATIC));
+  }
+
+  @Test public void producesMethodReturnVoid() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces void produceNothing() {}",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE));
+  }
+
+  @Test public void producesMethodReturnRawFuture() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces ListenableFuture produceRaw() {}",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(PRODUCES_METHOD_RAW_FUTURE);
+  }
+
+  @Test public void producesMethodReturnWildcardFuture() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces ListenableFuture<?> produceRaw() {}",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(PRODUCES_METHOD_RETURN_TYPE);
+  }
+
+  @Test public void producesMethodWithTypeParameter() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces <T> String produceString() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER));
+  }
+
+  @Test public void producesMethodSetValuesWildcard() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import static dagger.producers.Produces.Type.SET_VALUES;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "import java.util.Set;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces(type = SET_VALUES) Set<?> produceWildcard() {",
+        "    return null;",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(PRODUCES_METHOD_RETURN_TYPE);
+  }
+
+  @Test public void producesMethodSetValuesRawSet() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import static dagger.producers.Produces.Type.SET_VALUES;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "import java.util.Set;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces(type = SET_VALUES) Set produceSomething() {",
+        "    return null;",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET));
+  }
+
+  @Test public void producesMethodSetValuesNotASet() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import static dagger.producers.Produces.Type.SET_VALUES;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "import java.util.List;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces(type = SET_VALUES) List<String> produceStrings() {",
+        "    return null;",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(PRODUCES_METHOD_SET_VALUES_RETURN_SET);
+  }
+
+  @Test public void producesMethodSetValuesWildcardInFuture() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import static dagger.producers.Produces.Type.SET_VALUES;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "import java.util.Set;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces(type = SET_VALUES) ListenableFuture<Set<?>> produceWildcard() {",
+        "    return null;",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(PRODUCES_METHOD_RETURN_TYPE);
+  }
+
+  @Test public void producesMethodSetValuesFutureRawSet() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import static dagger.producers.Produces.Type.SET_VALUES;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "import java.util.Set;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces(type = SET_VALUES) ListenableFuture<Set> produceSomething() {",
+        "    return null;",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET));
+  }
+
+  @Test public void producesMethodSetValuesFutureNotASet() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import static dagger.producers.Produces.Type.SET_VALUES;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "import java.util.List;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces(type = SET_VALUES) ListenableFuture<List<String>> produceStrings() {",
+        "    return null;",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(PRODUCES_METHOD_SET_VALUES_RETURN_SET);
+  }
+
   @Test public void multipleProducesMethodsWithSameName() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
