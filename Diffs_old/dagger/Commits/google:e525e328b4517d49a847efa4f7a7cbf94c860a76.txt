diff --git a/java/dagger/internal/codegen/ModuleValidator.java b/java/dagger/internal/codegen/ModuleValidator.java
index 0b8e293ea..f1c3d4cc8 100644
--- a/java/dagger/internal/codegen/ModuleValidator.java
+++ b/java/dagger/internal/codegen/ModuleValidator.java
@@ -68,6 +68,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
+import java.util.Optional;
 import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
@@ -94,6 +95,20 @@
       ImmutableSet.of(Subcomponent.class, ProductionSubcomponent.class);
   private static final ImmutableSet<Class<? extends Annotation>> SUBCOMPONENT_BUILDER_TYPES =
       ImmutableSet.of(Subcomponent.Builder.class, ProductionSubcomponent.Builder.class);
+  private static final Optional<Class<?>> ANDROID_PROCESSOR;
+  private static final String CONTRIBUTES_ANDROID_INJECTOR_NAME =
+      "dagger.android.ContributesAndroidInjector";
+  private static final String ANDROID_PROCESSOR_NAME = "dagger.android.processor.AndroidProcessor";
+
+  static {
+    Class<?> clazz;
+    try {
+      clazz = Class.forName(ANDROID_PROCESSOR_NAME, false, ModuleValidator.class.getClassLoader());
+    } catch (ClassNotFoundException ignored) {
+      clazz = null;
+    }
+    ANDROID_PROCESSOR = Optional.ofNullable(clazz);
+  }
 
   private final Types types;
   private final Elements elements;
@@ -140,6 +155,12 @@ void addKnownModules(Collection<TypeElement> modules) {
     ListMultimap<String, ExecutableElement> bindingMethodsByName = ArrayListMultimap.create();
 
     Set<ModuleMethodKind> methodKinds = noneOf(ModuleMethodKind.class);
+    TypeElement contributesAndroidInjectorElement =
+        elements.getTypeElement(CONTRIBUTES_ANDROID_INJECTOR_NAME);
+    TypeMirror contributesAndroidInjector =
+        contributesAndroidInjectorElement != null
+            ? contributesAndroidInjectorElement.asType()
+            : null;
     for (ExecutableElement moduleMethod : methodsIn(module.getEnclosedElements())) {
       if (anyBindingMethodValidator.isBindingMethod(moduleMethod)) {
         builder.addSubreport(anyBindingMethodValidator.validate(moduleMethod));
@@ -151,6 +172,21 @@ void addKnownModules(Collection<TypeElement> modules) {
         methodKinds.add(ModuleMethodKind.ofMethod(moduleMethod));
       }
       allMethodsByName.put(moduleMethod.getSimpleName().toString(), moduleMethod);
+
+      for (AnnotationMirror annotation : moduleMethod.getAnnotationMirrors()) {
+        if (!ANDROID_PROCESSOR.isPresent()
+            && MoreTypes.equivalence()
+                .equivalent(contributesAndroidInjector, annotation.getAnnotationType())) {
+          builder.addSubreport(
+              ValidationReport.about(moduleMethod)
+                  .addError(
+                      String.format(
+                          "@%s was used, but %s was not found on the processor path",
+                          CONTRIBUTES_ANDROID_INJECTOR_NAME, ANDROID_PROCESSOR_NAME))
+                  .build());
+          break;
+        }
+      }
     }
 
     if (methodKinds.containsAll(
diff --git a/javatests/dagger/internal/codegen/MissingAndroidProcessorTest.java b/javatests/dagger/internal/codegen/MissingAndroidProcessorTest.java
new file mode 100644
index 000000000..0f91e0ebf
--- /dev/null
+++ b/javatests/dagger/internal/codegen/MissingAndroidProcessorTest.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class MissingAndroidProcessorTest {
+  @Test
+  public void missingProcessor() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.android.ContributesAndroidInjector;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "interface TestModule {",
+            "  @ContributesAndroidInjector",
+            "  Object o();",
+            "}");
+    JavaFileObject contributesAndroidInjectorStub =
+        JavaFileObjects.forSourceLines(
+            "dagger.android.ContributesAndroidInjector",
+            "package dagger.android;",
+            "",
+            "public @interface ContributesAndroidInjector {}");
+    Compilation compilation = daggerCompiler().compile(module, contributesAndroidInjectorStub);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("dagger.android.processor.AndroidProcessor")
+        .inFile(module)
+        .onLine(9);
+  }
+}
