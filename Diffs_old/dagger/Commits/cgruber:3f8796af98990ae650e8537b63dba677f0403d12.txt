diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index cb0ec0859..210acaa55 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -62,6 +62,7 @@
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.PrimitiveType;
+import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleTypeVisitor6;
@@ -87,6 +88,7 @@
 import static dagger.internal.codegen.ContributionBinding.Kind.IS_SYNTHETIC_KIND;
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_MAP;
 import static dagger.internal.codegen.ContributionType.indexByContributionType;
+import static dagger.internal.codegen.ErrorMessages.CANNOT_INJECT_WILDCARD_TYPE;
 import static dagger.internal.codegen.ErrorMessages.CONTAINS_DEPENDENCY_CYCLE_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.DUPLICATE_SIZE_LIMIT;
 import static dagger.internal.codegen.ErrorMessages.INDENT;
@@ -862,28 +864,46 @@ private void reportProviderMayNotDependOnProducer(Deque<ResolvedRequest> path) {
       reportBuilder.addError(errorMessage.toString(), path.getLast().request().requestElement());
     }
 
-    private void reportMissingBinding(Deque<ResolvedRequest> path) {
-      Key key = path.peek().request().key();
-      BindingKey bindingKey = path.peek().request().bindingKey();
-      boolean requiresContributionMethod = !key.isValidImplicitProvisionKey(types);
-      boolean requiresProvision = doesPathRequireProvisionOnly(path);
-      StringBuilder errorMessage = new StringBuilder();
-      String requiresErrorMessageFormat = requiresContributionMethod
-          ? requiresProvision
+    /**
+     * Descriptive portion of the error message for when the given request has no binding.
+     * Currently, the only other portions of the message are the dependency path, line number and
+     * filename. Not static because it uses the instance field types.
+     */
+    private StringBuilder requiresErrorMessageBase(Deque<ResolvedRequest> path) {
+      DependencyRequest request = path.peek().request();
+      Key key = request.key();
+      String requiresErrorMessageFormat;
+      // TODO(dpb): Check for wildcard injection somewhere else first?
+      if (key.type().getKind().equals(TypeKind.WILDCARD)) {
+        requiresErrorMessageFormat = CANNOT_INJECT_WILDCARD_TYPE;
+      } else {
+        boolean requiresProvision = doesPathRequireProvisionOnly(path);
+        if (!key.isValidImplicitProvisionKey(types)) {
+          requiresErrorMessageFormat = requiresProvision
               ? REQUIRES_PROVIDER_FORMAT
-              : REQUIRES_PROVIDER_OR_PRODUCER_FORMAT
-          : requiresProvision
+              : REQUIRES_PROVIDER_OR_PRODUCER_FORMAT;
+        } else {
+          requiresErrorMessageFormat = requiresProvision
               ? REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT
               : REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_OR_PRODUCER_FORMAT;
-      errorMessage.append(String.format(requiresErrorMessageFormat, keyFormatter.format(key)));
+        }
+      }
+      StringBuilder errorMessage = new StringBuilder(
+          String.format(requiresErrorMessageFormat, keyFormatter.format(key)));
       if (key.isValidMembersInjectionKey()) {
         Optional<MembersInjectionBinding> membersInjectionBinding =
             injectBindingRegistry.getOrFindMembersInjectionBinding(key);
         if (membersInjectionBinding.isPresent()
             && !membersInjectionBinding.get().injectionSites().isEmpty()) {
-          errorMessage.append(" ").append(ErrorMessages.MEMBERS_INJECTION_DOES_NOT_IMPLY_PROVISION);
+          errorMessage.append(" ");
+          errorMessage.append(ErrorMessages.MEMBERS_INJECTION_DOES_NOT_IMPLY_PROVISION);
         }
       }
+      return errorMessage;
+    }
+
+    private void reportMissingBinding(Deque<ResolvedRequest> path) {
+      StringBuilder errorMessage = requiresErrorMessageBase(path);
       ImmutableList<String> printableDependencyPath =
           FluentIterable.from(path)
               .transform(REQUEST_FROM_RESOLVED_REQUEST)
@@ -895,7 +915,8 @@ private void reportMissingBinding(Deque<ResolvedRequest> path) {
           printableDependencyPath.subList(1, printableDependencyPath.size())) {
         errorMessage.append('\n').append(dependency);
       }
-      for (String suggestion : MissingBindingSuggestions.forKey(topLevelGraph(), bindingKey)) {
+      for (String suggestion : MissingBindingSuggestions.forKey(topLevelGraph(),
+          path.peek().request().bindingKey())) {
         errorMessage.append('\n').append(suggestion);
       }
       reportBuilder.addError(errorMessage.toString(), path.getLast().request().requestElement());
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 3737805e0..17b57e416 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -95,6 +95,9 @@
   static final String INJECT_INTO_PRIVATE_CLASS =
       "Dagger does not support injection into private classes";
 
+  static final String CANNOT_INJECT_WILDCARD_TYPE =
+      "Dagger does not support injecting Provider<T>, Lazy<T> or Produced<T> when T is a wildcard "
+          + "type such as <%s>.";
   /*
    * Configuration errors
    *
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index a1650b0b2..635cc5421 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -153,7 +153,7 @@ Key withoutBindingMethod() {
   }
 
   boolean isValidMembersInjectionKey() {
-    return !qualifier().isPresent();
+    return !qualifier().isPresent() && !type().getKind().equals(TypeKind.WILDCARD);
   }
 
   /**
@@ -535,10 +535,11 @@ Key forProductionImplementationExecutor() {
      * {@code Set<Produced<T>>}.
      */
     Optional<Key> implicitSetKeyFromProduced(Key possibleSetOfProducedKey) {
-      if (MoreTypes.isTypeOf(Set.class, possibleSetOfProducedKey.type())) {
+      if (MoreTypes.isType(possibleSetOfProducedKey.type())
+          && MoreTypes.isTypeOf(Set.class, possibleSetOfProducedKey.type())) {
         TypeMirror argType =
             MoreTypes.asDeclared(possibleSetOfProducedKey.type()).getTypeArguments().get(0);
-        if (MoreTypes.isTypeOf(Produced.class, argType)) {
+        if (MoreTypes.isType(argType) && MoreTypes.isTypeOf(Produced.class, argType)) {
           TypeMirror producedArgType = MoreTypes.asDeclared(argType).getTypeArguments().get(0);
           TypeMirror setType = types.getDeclaredType(getSetElement(), producedArgType);
           return Optional.of(possibleSetOfProducedKey.withType(types, setType));
diff --git a/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java b/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java
index 9ec7469a5..91c908c73 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java
@@ -391,4 +391,34 @@ public void duplicateKeys() {
         .in(testModule)
         .onLine(29);
   }
+
+  @Test
+  public void attemptToInjectWildcardGenerics() {
+    JavaFileObject testComponent =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Lazy;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  Lazy<? extends Number> qualifiedNumberLazy();",
+            "  Provider<? super Number> qualifiedNumberProvider();",
+            "}");
+    assertAbout(javaSources())
+        .that(asList(testComponent))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("wildcard type")
+        .in(testComponent)
+        .onLine(9)
+        .and()
+        .withErrorContaining("wildcard type")
+        .in(testComponent)
+        .onLine(10);
+  }
+
 }
