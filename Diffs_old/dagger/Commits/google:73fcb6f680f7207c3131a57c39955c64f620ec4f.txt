diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index b2b19bf2d..0fa05f04a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -171,16 +171,20 @@ ClassName nameGeneratedType(ProductionBinding binding) {
             Snippet.format(fields.get(BindingKey.forDependencyRequest(dependency)).name()),
             dependency.kind()));
       }
-      Snippet invocationSnippet = getInvocationSnippet(binding, parameterSnippets.build());
+      final boolean wrapWithFuture = false;  // since submitToExecutor will create the future
+      Snippet invocationSnippet = getInvocationSnippet(wrapWithFuture, binding,
+          parameterSnippets.build());
       TypeName callableReturnType = returnsFuture ? futureTypeName : providedTypeName;
+      Snippet throwsClause = getThrowsClause(binding.thrownTypes());
       Snippet callableSnippet = Snippet.format(Joiner.on('\n').join(
           "new %1$s<%2$s>() {",
-          "  @Override public %2$s call() {",
-          "    return %3$s;",
+          "  @Override public %2$s call() %3$s{",
+          "    return %4$s;",
           "  }",
           "}"),
           ClassName.fromClass(Callable.class),
           callableReturnType,
+          throwsClause,
           invocationSnippet);
       getMethodWriter.body().addSnippet("%s future = %s.submitToExecutor(%s, executor);",
           ParameterizedTypeName.create(
@@ -212,18 +216,22 @@ ClassName nameGeneratedType(ProductionBinding binding) {
                 dependency.kind()));
           }
         }
-        Snippet invocationSnippet = getInvocationSnippet(binding, parameterSnippets.build());
+        boolean wrapWithFuture = !returnsFuture;  // only wrap if we don't already have a future
+        Snippet invocationSnippet = getInvocationSnippet(wrapWithFuture, binding,
+            parameterSnippets.build());
+        Snippet throwsClause = getThrowsClause(binding.thrownTypes());
         transformSnippet = Snippet.format(Joiner.on('\n').join(
             "new %1$s<%2$s, %3$s>() {",
-            "  @Override public %4$s apply(%2$s %5$s) {",
-            "    return %6$s;",
+            "  @Override public %4$s apply(%2$s %5$s) %6$s{",
+            "    return %7$s;",
             "  }",
             "}"),
-            ClassName.fromClass(returnsFuture ? AsyncFunction.class : Function.class),
+            ClassName.fromClass(AsyncFunction.class),
             asyncDependencyType(asyncDependency),
             providedTypeName,
-            returnsFuture ? futureTypeName : providedTypeName,
+            futureTypeName,
             argName,
+            throwsClause,
             invocationSnippet);
       } else {
         futureSnippet = Snippet.format("%s.<%s>allAsList(%s)",
@@ -238,20 +246,24 @@ ClassName nameGeneratedType(ProductionBinding binding) {
                   }
                 })));
         ImmutableList<Snippet> parameterSnippets = getParameterSnippets(binding, fields, "args");
-        Snippet invocationSnippet = getInvocationSnippet(binding, parameterSnippets);
+        boolean wrapWithFuture = !returnsFuture;  // only wrap if we don't already have a future
+        Snippet invocationSnippet = getInvocationSnippet(wrapWithFuture, binding,
+            parameterSnippets);
         ParameterizedTypeName listOfObject = ParameterizedTypeName.create(
             ClassName.fromClass(List.class), ClassName.fromClass(Object.class));
+        Snippet throwsClause = getThrowsClause(binding.thrownTypes());
         transformSnippet = Snippet.format(Joiner.on('\n').join(
             "new %1$s<%2$s, %3$s>() {",
             "  @SuppressWarnings(\"unchecked\")  // safe by specification",
-            "  @Override public %4$s apply(%2$s args) {",
-            "    return %5$s;",
+            "  @Override public %4$s apply(%2$s args) %5$s{",
+            "    return %6$s;",
             "  }",
             "}"),
-            ClassName.fromClass(returnsFuture ? AsyncFunction.class : Function.class),
+            ClassName.fromClass(AsyncFunction.class),
             listOfObject,
             providedTypeName,
-            returnsFuture ? futureTypeName : providedTypeName,
+            futureTypeName,
+            throwsClause,
             invocationSnippet);
       }
       getMethodWriter.body().addSnippet("return %s.%s(%s, %s, executor);",
@@ -309,11 +321,24 @@ private TypeName asyncDependencyType(DependencyRequest dependency) {
     return snippets.build();
   }
 
-  private Snippet getInvocationSnippet(
-      ProductionBinding binding, ImmutableList<Snippet> parameterSnippets) {
+  /**
+   * Creates a Snippet for the invocation of the producer method from the module.
+   *
+   * @param wrapWithFuture If true, wraps the result of the call to the producer method
+   *        in an immediate future.
+   * @param binding The binding to generate the invocation snippet for.
+   * @param parameterSnippets The snippets for all the parameters to the producer method.
+   */
+  private Snippet getInvocationSnippet(boolean wrapWithFuture, ProductionBinding binding,
+      ImmutableList<Snippet> parameterSnippets) {
     Snippet moduleSnippet = Snippet.format("module.%s(%s)",
         binding.bindingElement().getSimpleName(),
         makeParametersSnippet(parameterSnippets));
+    if (wrapWithFuture) {
+      moduleSnippet = Snippet.format("%s.immediateFuture(%s)",
+          ClassName.fromClass(Futures.class),
+          moduleSnippet);
+    }
     if (binding.productionType().equals(Produces.Type.SET)) {
       if (binding.bindingKind().equals(ProductionBinding.Kind.FUTURE_PRODUCTION)) {
         return Snippet.format("%s.createFutureSingletonSet(%s)",
@@ -328,4 +353,24 @@ private Snippet getInvocationSnippet(
       return moduleSnippet;
     }
   }
+
+  /**
+   * Creates a Snippet for the throws clause.
+   *
+   * @param thrownTypes the list of thrown types.
+   */
+  private Snippet getThrowsClause(List<? extends TypeMirror> thrownTypes) {
+    if (thrownTypes.isEmpty()) {
+      return Snippet.format("");
+    }
+    return Snippet.format("throws %s ",
+        Snippet.makeParametersSnippet(FluentIterable
+            .from(thrownTypes)
+            .transform(new Function<TypeMirror, Snippet>() {
+              @Override public Snippet apply(TypeMirror thrownType) {
+                return Snippet.format("%s", TypeNames.forTypeMirror(thrownType));
+              }
+            })
+            .toList()));
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index 875575b33..0a8e946ec 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -17,10 +17,12 @@
 
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Produces;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.type.TypeMirror;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
@@ -37,9 +39,7 @@
 abstract class ProductionBinding extends ContributionBinding {
   @Override
   ImmutableSet<DependencyRequest> implicitDependencies() {
-    return new ImmutableSet.Builder<DependencyRequest>()
-        .addAll(dependencies())
-        .build();
+    return dependencies();
   }
 
   enum Kind {
@@ -58,6 +58,9 @@
   /** Returns provision type that was used to bind the key. */
   abstract Produces.Type productionType();
 
+  /** Returns the list of types in the throws clause of the method. */
+  abstract ImmutableList<? extends TypeMirror> thrownTypes();
+
   @Override
   BindingType bindingType() {
     switch (productionType()) {
@@ -99,7 +102,8 @@ ProductionBinding forProducesMethod(ExecutableElement producesMethod) {
           dependencies,
           findBindingPackage(key),
           kind,
-          producesAnnotation.type());
+          producesAnnotation.type(),
+          ImmutableList.copyOf(producesMethod.getThrownTypes()));
     }
   }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index a1ae98431..06868a827 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -766,7 +766,7 @@ public void publicModuleNonPublicIncludes() {
     JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule$$ProduceStringFactory",
         "package test;",
         "",
-        "import com.google.common.base.Function;",
+        "import com.google.common.util.concurrent.AsyncFunction;",
         "import com.google.common.util.concurrent.Futures;",
         "import com.google.common.util.concurrent.ListenableFuture;",
         "import dagger.producers.Produced;",
@@ -813,14 +813,14 @@ public void publicModuleNonPublicIncludes() {
         "        Producers.createFutureProduced(bProducer.get());",
         "    return Futures.transform(",
         "        Futures.<Object>allAsList(aProducerFuture, bProducerFuture),",
-        "        new Function<List<Object>, String>() {",
+        "        new AsyncFunction<List<Object>, String>() {",
         "          @SuppressWarnings(\"unchecked\")  // safe by specification",
-        "          @Override public String apply(List<Object> args) {",
-        "            return module.produceString(",
+        "          @Override public ListenableFuture<String> apply(List<Object> args) {",
+        "            return Futures.immediateFuture(module.produceString(",
         "                (Integer) args.get(0),",
         "                (Produced<Double>) args.get(1),",
         "                cProducer,",
-        "                dProvider);",
+        "                dProvider));",
         "          }",
         "        }, executor);",
         "  }",
@@ -888,4 +888,263 @@ public void publicModuleNonPublicIncludes() {
         .compilesWithoutError()
         .and().generatesSources(factoryFile);
   }
+
+  @Test public void singleProducesMethodCheckedException() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "import java.io.IOException;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces ListenableFuture<String> produceString()",
+        "      throws InterruptedException, IOException {",
+        "    return null;",
+        "  }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule$$ProduceStringFactory",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.Futures;",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.Producer;",
+        "import dagger.producers.internal.Producers;",
+        "import java.io.IOException;",
+        "import java.util.concurrent.Callable;",
+        "import java.util.concurrent.Executor;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule$$ProduceStringFactory implements Producer<String> {",
+        "  private final TestModule module;",
+        "  private final Executor executor;",
+        "",
+        "  public TestModule$$ProduceStringFactory(TestModule module, Executor executor) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "    assert executor != null;",
+        "    this.executor = executor;",
+        "  }",
+        "",
+        "  @Override public ListenableFuture<String> get() {",
+        "    ListenableFuture<ListenableFuture<String>> future = Producers.submitToExecutor(",
+        "      new Callable<ListenableFuture<String>>() {",
+        "        @Override public ListenableFuture<String> call()",
+        "            throws InterruptedException, IOException {",
+        "          return module.produceString();",
+        "        }",
+        "      }, executor);",
+        "    return Futures.dereference(future);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
+  @Test public void singleProducesMethodCheckedExceptionNoFuture() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "import java.io.IOException;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces String produceString() throws IOException {",
+        "    return \"\";",
+        "  }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule$$ProduceStringFactory",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.Producer;",
+        "import dagger.producers.internal.Producers;",
+        "import java.io.IOException;",
+        "import java.util.concurrent.Callable;",
+        "import java.util.concurrent.Executor;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule$$ProduceStringFactory implements Producer<String> {",
+        "  private final TestModule module;",
+        "  private final Executor executor;",
+        "",
+        "  public TestModule$$ProduceStringFactory(TestModule module, Executor executor) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "    assert executor != null;",
+        "    this.executor = executor;",
+        "  }",
+        "",
+        "  @Override public ListenableFuture<String> get() {",
+        "    ListenableFuture<String> future = Producers.submitToExecutor(",
+        "      new Callable<String>() {",
+        "        @Override public String call() throws IOException {",
+        "          return module.produceString();",
+        "        }",
+        "      }, executor);",
+        "    return future;",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
+  @Test public void singleProducesMethodCheckedExceptionFuture() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.Produced;",
+        "import dagger.producers.Producer;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "import java.io.IOException;",
+        "import javax.inject.Provider;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces ListenableFuture<String> produceString(",
+        "      int a, Produced<Double> b, Producer<Object> c, Provider<Boolean> d)",
+        "          throws IOException {",
+        "    return null;",
+        "  }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule$$ProduceStringFactory",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.AsyncFunction;",
+        "import com.google.common.util.concurrent.Futures;",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.Produced;",
+        "import dagger.producers.Producer;",
+        "import dagger.producers.internal.Producers;",
+        "import java.io.IOException;",
+        "import java.util.List;",
+        "import java.util.concurrent.Executor;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule$$ProduceStringFactory implements Producer<String> {",
+        "  private final TestModule module;",
+        "  private final Executor executor;",
+        "  private final Producer<Integer> aProducer;",
+        "  private final Producer<Double> bProducer;",
+        "  private final Producer<Object> cProducer;",
+        "  private final Provider<Boolean> dProvider;",
+        "",
+        "  public TestModule$$ProduceStringFactory(",
+        "      TestModule module,",
+        "      Executor executor,",
+        "      Producer<Integer> aProducer,",
+        "      Producer<Double> bProducer,",
+        "      Producer<Object> cProducer,",
+        "      Provider<Boolean> dProvider) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "    assert executor != null;",
+        "    this.executor = executor;",
+        "    assert aProducer != null;",
+        "    this.aProducer = aProducer;",
+        "    assert bProducer != null;",
+        "    this.bProducer = bProducer;",
+        "    assert cProducer != null;",
+        "    this.cProducer = cProducer;",
+        "    assert dProvider != null;",
+        "    this.dProvider = dProvider;",
+        "  }",
+        "",
+        "  @Override public ListenableFuture<String> get() {",
+        "    ListenableFuture<Integer> aProducerFuture = aProducer.get();",
+        "    ListenableFuture<Produced<Double>> bProducerFuture =",
+        "        Producers.createFutureProduced(bProducer.get());",
+        "    return Futures.transform(",
+        "        Futures.<Object>allAsList(aProducerFuture, bProducerFuture),",
+        "        new AsyncFunction<List<Object>, String>() {",
+        "          @SuppressWarnings(\"unchecked\")  // safe by specification",
+        "          @Override public ListenableFuture<String> apply(List<Object> args)",
+        "              throws IOException {",
+        "            return module.produceString(",
+        "                (Integer) args.get(0),",
+        "                (Produced<Double>) args.get(1),",
+        "                cProducer,",
+        "                dProvider);",
+        "          }",
+        "        }, executor);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
+  @Test public void singleProducesMethodCheckedExceptionNoArgsFutureSet() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "import java.io.IOException;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces(type = Produces.Type.SET)",
+        "  ListenableFuture<String> produceString() throws IOException {",
+        "    return null;",
+        "  }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule$$ProduceStringFactory",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.Futures;",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.Producer;",
+        "import dagger.producers.internal.Producers;",
+        "import java.io.IOException;",
+        "import java.util.Set;",
+        "import java.util.concurrent.Callable;",
+        "import java.util.concurrent.Executor;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule$$ProduceStringFactory implements Producer<Set<String>> {",
+        "  private final TestModule module;",
+        "  private final Executor executor;",
+        "",
+        "  public TestModule$$ProduceStringFactory(TestModule module, Executor executor) {  ",
+        "    assert module != null;",
+        "    this.module = module;",
+        "    assert executor != null;",
+        "    this.executor = executor;",
+        "  }",
+        "",
+        "  @Override",
+        "  public ListenableFuture<Set<String>> get() {  ",
+        "    ListenableFuture<ListenableFuture<Set<String>>> future =",
+        "        Producers.submitToExecutor(new Callable<ListenableFuture<Set<String>>>() {",
+        "      @Override public ListenableFuture<Set<String>> call() throws IOException {",
+        "        return Producers.createFutureSingletonSet(module.produceString());",
+        "      }",
+        "    }, executor);",
+        "    return Futures.dereference(future);",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
 }
