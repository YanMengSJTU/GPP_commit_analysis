diff --git a/java/dagger/internal/codegen/ComponentHierarchyValidator.java b/java/dagger/internal/codegen/ComponentHierarchyValidator.java
index 22c657e91..982ed531f 100644
--- a/java/dagger/internal/codegen/ComponentHierarchyValidator.java
+++ b/java/dagger/internal/codegen/ComponentHierarchyValidator.java
@@ -20,11 +20,15 @@
 import static com.google.common.base.Predicates.and;
 import static com.google.common.base.Predicates.in;
 import static com.google.common.base.Predicates.not;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.Scopes.getReadableSource;
 
 import com.google.auto.common.MoreTypes;
+import com.google.common.base.Joiner;
 import com.google.common.base.Predicate;
 import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
 import com.google.common.collect.LinkedHashMultimap;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Multimaps;
@@ -32,6 +36,8 @@
 import com.google.common.collect.Sets;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.model.Scope;
+import java.util.Collection;
+import java.util.Formatter;
 import java.util.Map;
 import javax.inject.Inject;
 import javax.lang.model.element.TypeElement;
@@ -39,6 +45,7 @@
 
 /** Validates the relationships between parent components and subcomponents. */
 final class ComponentHierarchyValidator {
+  private static final Joiner COMMA_SEPARATED_JOINER = Joiner.on(", ");
   private final CompilerOptions compilerOptions;
 
   @Inject
@@ -58,6 +65,7 @@
       validateScopeHierarchy(
           report, componentDescriptor, LinkedHashMultimap.<ComponentDescriptor, Scope>create());
     }
+    validateProductionModuleUniqueness(report, componentDescriptor, LinkedHashMultimap.create());
     return report.build();
   }
 
@@ -154,4 +162,40 @@ private void validateScopeHierarchy(
           subject.typeElement());
     }
   }
+
+  private void validateProductionModuleUniqueness(
+      ValidationReport.Builder<TypeElement> report,
+      ComponentDescriptor componentDescriptor,
+      SetMultimap<ComponentDescriptor, ModuleDescriptor> producerModulesByComponent) {
+    ImmutableSet<ModuleDescriptor> producerModules =
+        componentDescriptor.modules().stream()
+            .filter(module -> module.kind().equals(ModuleKind.PRODUCER_MODULE))
+            .collect(toImmutableSet());
+
+    producerModulesByComponent.putAll(componentDescriptor, producerModules);
+    for (ComponentDescriptor childComponent : componentDescriptor.childComponents()) {
+      validateProductionModuleUniqueness(report, childComponent, producerModulesByComponent);
+    }
+    producerModulesByComponent.removeAll(componentDescriptor);
+
+    SetMultimap<ComponentDescriptor, ModuleDescriptor> repeatedModules =
+        Multimaps.filterValues(producerModulesByComponent, producerModules::contains);
+    if (repeatedModules.isEmpty()) {
+      return;
+    }
+
+    StringBuilder error = new StringBuilder();
+    Formatter formatter = new Formatter(error);
+
+    formatter.format("%s repeats @ProducerModules:", componentDescriptor.typeElement());
+
+    for (Map.Entry<ComponentDescriptor, Collection<ModuleDescriptor>> entry :
+        repeatedModules.asMap().entrySet()) {
+      formatter.format("\n  %s also installs: ", entry.getKey().typeElement());
+      COMMA_SEPARATED_JOINER
+          .appendTo(error, Iterables.transform(entry.getValue(), m -> m.moduleElement()));
+    }
+
+    report.addError(error.toString());
+  }
 }
diff --git a/javatests/dagger/internal/codegen/ComponentHierarchyValidationTest.java b/javatests/dagger/internal/codegen/ComponentHierarchyValidationTest.java
index d8c784ba2..1f232cb3b 100644
--- a/javatests/dagger/internal/codegen/ComponentHierarchyValidationTest.java
+++ b/javatests/dagger/internal/codegen/ComponentHierarchyValidationTest.java
@@ -18,6 +18,7 @@
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.TestUtils.message;
 
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
@@ -124,6 +125,48 @@ public void productionComponents_productionScopeImplicitOnBoth() {
     assertThat(compilation).succeeded();
   }
 
+  @Test
+  public void producerModuleRepeated() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.producers.ProductionComponent;",
+            "",
+            "@ProductionComponent(modules = RepeatedProducerModule.class)",
+            "interface Parent {",
+            "  Child child();",
+            "}");
+    JavaFileObject repeatedModule =
+        JavaFileObjects.forSourceLines(
+            "test.RepeatedProducerModule",
+            "package test;",
+            "",
+            "import dagger.producers.ProducerModule;",
+            "",
+            "@ProducerModule",
+            "interface RepeatedProducerModule {}");
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.producers.ProductionSubcomponent;",
+            "",
+            "@ProductionSubcomponent(modules = RepeatedProducerModule.class)",
+            "interface Child {}");
+    Compilation compilation = daggerCompiler().compile(component, subcomponent, repeatedModule);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.Child repeats @ProducerModules:",
+                "  test.Parent also installs: test.RepeatedProducerModule"))
+        .inFile(component)
+        .onLineContaining("interface Parent");
+  }
+
   @Test
   public void factoryMethodForSubcomponentWithBuilder_isNotAllowed() {
     JavaFileObject module =
