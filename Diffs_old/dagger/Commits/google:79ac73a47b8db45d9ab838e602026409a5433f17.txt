diff --git a/java/dagger/internal/codegen/BindingExpression.java b/java/dagger/internal/codegen/BindingExpression.java
index 22dcdb063..08ff07a55 100644
--- a/java/dagger/internal/codegen/BindingExpression.java
+++ b/java/dagger/internal/codegen/BindingExpression.java
@@ -19,13 +19,19 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.RAWTYPES;
+import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
+import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
+import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_MAP;
+import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_SET;
 import static dagger.internal.codegen.MemberSelect.staticMemberSelect;
 import static javax.lang.model.element.Modifier.PRIVATE;
 
 import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.FieldSpec;
+import java.util.EnumSet;
 import java.util.Optional;
 import javax.lang.model.util.Elements;
 
@@ -62,6 +68,11 @@ CodeBlock getComponentMethodImplementation(DependencyRequest request, ClassName
 
   /** Factory for building a {@link BindingExpression}. */
   static final class Factory {
+    // TODO(user): Consider using PrivateMethodBindingExpression for other/all BEs?
+    private static final ImmutableSet<ContributionBinding.Kind> PRIVATE_METHOD_KINDS =
+        ImmutableSet.copyOf(
+            EnumSet.of(SYNTHETIC_MULTIBOUND_SET, SYNTHETIC_MULTIBOUND_MAP, INJECTION, PROVISION));
+
     private final CompilerOptions compilerOptions;
     private final ClassName componentName;
     private final ComponentBindingExpressions componentBindingExpressions;
@@ -99,14 +110,16 @@ CodeBlock getComponentMethodImplementation(DependencyRequest request, ClassName
     /** Creates a binding expression for a field. */
     BindingExpression forField(ResolvedBindings resolvedBindings) {
       FieldSpec fieldSpec = generateFrameworkField(resolvedBindings, Optional.empty());
-      MemberSelect memberSelect = MemberSelect.localField(componentName, fieldSpec.name);
-      return create(resolvedBindings, Optional.of(fieldSpec), memberSelect);
+      return create(
+          resolvedBindings,
+          MemberSelect.localField(componentName, fieldSpec.name),
+          Optional.of(newFrameworkFieldInitializer(fieldSpec, resolvedBindings)));
     }
 
     /** Creates a binding expression for a static method call. */
     Optional<BindingExpression> forStaticMethod(ResolvedBindings resolvedBindings) {
       return staticMemberSelect(resolvedBindings)
-          .map(memberSelect -> create(resolvedBindings, Optional.empty(), memberSelect));
+          .map(memberSelect -> create(resolvedBindings, memberSelect, Optional.empty()));
     }
 
     /**
@@ -139,71 +152,68 @@ private boolean useRawType(ResolvedBindings resolvedBindings) {
           && !bindingPackage.get().equals(componentName.packageName());
     }
 
+    private FrameworkFieldInitializer newFrameworkFieldInitializer(
+        FieldSpec fieldSpec, ResolvedBindings resolvedBindings) {
+      return new FrameworkFieldInitializer(
+          fieldSpec,
+          resolvedBindings,
+          generatedComponentModel,
+          componentBindingExpressions,
+          componentRequirementFields,
+          compilerOptions,
+          graph,
+          optionalFactories,
+          componentName);
+    }
+
     private BindingExpression create(
         ResolvedBindings resolvedBindings,
-        Optional<FieldSpec> fieldSpec,
-        MemberSelect memberSelect) {
-      FrameworkFieldInitializer frameworkFieldInitializer =
-          new FrameworkFieldInitializer(
-              generatedComponentModel,
-              componentBindingExpressions,
-              componentRequirementFields,
-              resolvedBindings,
-              compilerOptions,
-              graph,
-              optionalFactories,
-              componentName);
+        MemberSelect memberSelect,
+        Optional<FrameworkFieldInitializer> frameworkFieldInitializer) {
       FrameworkInstanceBindingExpression frameworkInstanceBindingExpression =
           FrameworkInstanceBindingExpression.create(
-              resolvedBindings,
-              fieldSpec,
-              generatedComponentModel,
-              memberSelect,
-              frameworkFieldInitializer,
-              types,
-              elements);
+              resolvedBindings, memberSelect, frameworkFieldInitializer, types, elements);
 
       if (!resolvedBindings.bindingType().equals(BindingType.PROVISION)) {
         return frameworkInstanceBindingExpression;
       }
 
-      BindingExpression inlineBindingExpression =
-          inlineProvisionBindingExpression(frameworkInstanceBindingExpression);
+      BindingExpression bindingExpression =
+          new ProviderOrProducerBindingExpression(
+              frameworkInstanceBindingExpression,
+              producerFromProviderBindingExpression(frameworkInstanceBindingExpression));
 
-      // TODO(user): Implement private methods for scoped bindings
-      if (!resolvedBindings.scope().isPresent()) {
-        switch (resolvedBindings.contributionBinding().bindingKind()) {
-          // TODO(user): Consider using PrivateMethodBindingExpression for other/all BEs?
-          case SYNTHETIC_MULTIBOUND_SET:
-          case SYNTHETIC_MULTIBOUND_MAP:
-          case INJECTION:
-          case PROVISION:
-            return new PrivateMethodBindingExpression(
-                resolvedBindings,
-                componentName,
-                generatedComponentModel,
-                inlineBindingExpression,
-                compilerOptions,
-                types,
-                elements);
-          default:
-            break;
-        }
+      BindingExpression inlineBindingExpression =
+          inlineProvisionBindingExpression(bindingExpression);
+
+      if (usePrivateMethod(resolvedBindings)) {
+        return new PrivateMethodBindingExpression(
+            resolvedBindings,
+            componentName,
+            generatedComponentModel,
+            inlineBindingExpression,
+            compilerOptions,
+            types,
+            elements);
       }
+
       return inlineBindingExpression;
     }
 
-    private BindingExpression inlineProvisionBindingExpression(
-        FrameworkInstanceBindingExpression frameworkInstanceBindingExpression) {
-      ResolvedBindings resolvedBindings = frameworkInstanceBindingExpression.resolvedBindings();
-      BindingExpression bindingExpression =
-          new ProviderOrProducerBindingExpression(
-              frameworkInstanceBindingExpression,
-              frameworkInstanceBindingExpression.producerFromProvider(
-                  generateFrameworkField(resolvedBindings, Optional.of(TypeNames.PRODUCER)),
-                  componentName));
+    private FrameworkInstanceBindingExpression producerFromProviderBindingExpression(
+        FrameworkInstanceBindingExpression providerBindingExpression) {
+      ResolvedBindings resolvedBindings = providerBindingExpression.resolvedBindings();
+      FieldSpec producerField =
+          generateFrameworkField(resolvedBindings, Optional.of(TypeNames.PRODUCER));
+      return providerBindingExpression.producerFromProvider(
+          MemberSelect.localField(componentName, producerField.name),
+          newFrameworkFieldInitializer(producerField, resolvedBindings).forProducerFromProvider());
+    }
 
-      ProvisionBinding provisionBinding = (ProvisionBinding) resolvedBindings.contributionBinding();
+    private BindingExpression inlineProvisionBindingExpression(
+        BindingExpression bindingExpression) {
+      ProvisionBinding provisionBinding =
+          (ProvisionBinding) bindingExpression.resolvedBindings().contributionBinding();
       switch (provisionBinding.bindingKind()) {
         case COMPONENT:
           return new ComponentInstanceBindingExpression(
@@ -229,7 +239,7 @@ private BindingExpression inlineProvisionBindingExpression(
           return new SubcomponentBuilderBindingExpression(
               bindingExpression,
               provisionBinding,
-              subcomponentNames.get(resolvedBindings.bindingKey()),
+              subcomponentNames.get(bindingExpression.resolvedBindings().bindingKey()),
               types);
 
         case SYNTHETIC_MULTIBOUND_SET:
@@ -284,5 +294,11 @@ private BindingExpression inlineProvisionBindingExpression(
           return bindingExpression;
       }
     }
+
+    private boolean usePrivateMethod(ResolvedBindings resolvedBindings) {
+      // TODO(user): Implement private methods for scoped bindings
+      return !resolvedBindings.scope().isPresent()
+          && PRIVATE_METHOD_KINDS.contains(resolvedBindings.contributionBinding().bindingKind());
+    }
   }
 }
diff --git a/java/dagger/internal/codegen/FrameworkFieldInitializer.java b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
index 232fa680d..750a69667 100644
--- a/java/dagger/internal/codegen/FrameworkFieldInitializer.java
+++ b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
@@ -56,6 +56,7 @@
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
+import dagger.internal.DelegateFactory;
 import dagger.internal.InstanceFactory;
 import dagger.internal.TypedReleasableReferenceManagerDecorator;
 import dagger.producers.Produced;
@@ -74,9 +75,10 @@
 
 /**
  * An object that can initialize a framework-type component field for a binding. An instance should
- * be created for every field.
+ * be created for each field.
  */
 final class FrameworkFieldInitializer {
+  private final FieldSpec fieldSpec;
   private final GeneratedComponentModel generatedComponentModel;
   private final ComponentBindingExpressions componentBindingExpressions;
   private final ComponentRequirementFields componentRequirementFields;
@@ -87,21 +89,24 @@
   private final boolean isProducerFromProvider;
   private final OptionalFactories optionalFactories;
   private final ClassName componentName;
+  private InitializationState fieldInitializationState = InitializationState.UNINITIALIZED;
 
   FrameworkFieldInitializer(
+      FieldSpec fieldSpec,
+      ResolvedBindings resolvedBindings,
       GeneratedComponentModel generatedComponentModel,
       ComponentBindingExpressions componentBindingExpressions,
       ComponentRequirementFields componentRequirementFields,
-      ResolvedBindings resolvedBindings,
       CompilerOptions compilerOptions,
       BindingGraph graph,
       OptionalFactories optionalFactories,
       ClassName componentName) {
     this(
+        fieldSpec,
+        resolvedBindings,
         generatedComponentModel,
         componentBindingExpressions,
         componentRequirementFields,
-        resolvedBindings,
         compilerOptions,
         graph,
         false,
@@ -110,10 +115,11 @@
   }
 
   private FrameworkFieldInitializer(
+      FieldSpec fieldSpec,
+      ResolvedBindings resolvedBindings,
       GeneratedComponentModel generatedComponentModel,
       ComponentBindingExpressions componentBindingExpressions,
       ComponentRequirementFields componentRequirementFields,
-      ResolvedBindings resolvedBindings,
       CompilerOptions compilerOptions,
       BindingGraph graph,
       boolean isProducerFromProvider,
@@ -128,10 +134,53 @@ private FrameworkFieldInitializer(
     this.optionalFactories = checkNotNull(optionalFactories);
     this.componentName = checkNotNull(componentName);
     this.isProducerFromProvider = isProducerFromProvider;
+    this.fieldSpec = checkNotNull(fieldSpec);
+  }
+
+  /** Adds the field and its initialization code to the component. */
+  void initializeField() {
+    switch (fieldInitializationState) {
+      case UNINITIALIZED:
+        // Change our state in case we are recursively invoked via initializeBindingExpression
+        fieldInitializationState = InitializationState.INITIALIZING;
+        CodeBlock.Builder codeBuilder = CodeBlock.builder();
+        CodeBlock initCode = CodeBlock.of("this.$N = $L;", fieldSpec, getFieldInitialization());
+
+        if (fieldInitializationState == InitializationState.DELEGATED) {
+          // If we were recursively invoked, set the delegate factory as part of our initialization
+          CodeBlock delegateFactoryVariable = CodeBlock.of("$NDelegate", fieldSpec);
+          codeBuilder
+              .add(
+                  "$1T $2L = ($1T) $3N;", DelegateFactory.class, delegateFactoryVariable, fieldSpec)
+              .add(initCode)
+              .add("$L.setDelegatedProvider($N);", delegateFactoryVariable, fieldSpec);
+        } else {
+          codeBuilder.add(initCode);
+        }
+        generatedComponentModel.addInitialization(codeBuilder.build());
+        generatedComponentModel.addField(fieldSpec);
+
+        fieldInitializationState = InitializationState.INITIALIZED;
+        break;
+
+      case INITIALIZING:
+        // We were recursively invoked, so create a delegate factory instead
+        generatedComponentModel.addInitialization(
+            CodeBlock.of("this.$N = new $T<>();", fieldSpec, DelegateFactory.class));
+        fieldInitializationState = InitializationState.DELEGATED;
+        break;
+
+      case DELEGATED:
+      case INITIALIZED:
+        break;
+
+      default:
+        throw new AssertionError("Unhandled initialization state: " + fieldInitializationState);
+    }
   }
 
   /** Returns the expression to use to initialize the field. */
-  CodeBlock getFieldInitialization() {
+  private CodeBlock getFieldInitialization() {
     if (isProducerFromProvider) {
       return FrameworkType.PROVIDER.to(
           DependencyRequest.Kind.PRODUCER,
@@ -629,14 +678,36 @@ private CodeBlock getDependencyExpression(FrameworkDependency frameworkDependenc
 
   FrameworkFieldInitializer forProducerFromProvider() {
     return new FrameworkFieldInitializer(
+        fieldSpec,
+        resolvedBindings,
         generatedComponentModel,
         componentBindingExpressions,
         componentRequirementFields,
-        resolvedBindings,
         compilerOptions,
         graph,
         true,
         optionalFactories,
         componentName);
   }
+
+  /** Initialization state for a factory field. */
+  private enum InitializationState {
+    /** The field is {@code null}. */
+    UNINITIALIZED,
+
+    /**
+     * The field's dependencies are being set up. If the field is needed in this state, use a {@link
+     * DelegateFactory}.
+     */
+    INITIALIZING,
+
+    /**
+     * The field's dependencies are being set up, but the field can be used because it has already
+     * been set to a {@link DelegateFactory}.
+     */
+    DELEGATED,
+
+    /** The field is set to an undelegated factory. */
+    INITIALIZED;
+  }
 }
diff --git a/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
index faec0dc16..78ccd5297 100644
--- a/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
@@ -16,16 +16,12 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
-import static dagger.internal.codegen.TypeNames.DELEGATE_FACTORY;
 
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.FieldSpec;
-import dagger.internal.DelegateFactory;
 import java.util.Optional;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
@@ -33,28 +29,21 @@
 
 /** A binding expression that uses an instance of a {@link FrameworkType}. */
 final class FrameworkInstanceBindingExpression extends BindingExpression {
-  private final Optional<FieldSpec> fieldSpec;
-  private final GeneratedComponentModel generatedComponentModel;
   private final MemberSelect memberSelect;
   private final FrameworkType frameworkType;
-  private final FrameworkFieldInitializer fieldInitializer;
+  private final Optional<FrameworkFieldInitializer> fieldInitializer;
   private final DaggerTypes types;
   private final Elements elements;
-  private InitializationState fieldInitializationState = InitializationState.UNINITIALIZED;
 
   /** Returns a binding expression for a binding. */
   static FrameworkInstanceBindingExpression create(
       ResolvedBindings resolvedBindings,
-      Optional<FieldSpec> fieldSpec,
-      GeneratedComponentModel generatedComponentModel,
       MemberSelect memberSelect,
-      FrameworkFieldInitializer frameworkFieldInitializer,
+      Optional<FrameworkFieldInitializer> frameworkFieldInitializer,
       DaggerTypes types,
       Elements elements) {
     return new FrameworkInstanceBindingExpression(
         resolvedBindings,
-        fieldSpec,
-        generatedComponentModel,
         memberSelect,
         resolvedBindings.bindingType().frameworkType(),
         frameworkFieldInitializer,
@@ -64,17 +53,13 @@ static FrameworkInstanceBindingExpression create(
 
   private FrameworkInstanceBindingExpression(
       ResolvedBindings resolvedBindings,
-      Optional<FieldSpec> fieldSpec,
-      GeneratedComponentModel generatedComponentModel,
       MemberSelect memberSelect,
       FrameworkType frameworkType,
-      FrameworkFieldInitializer fieldInitializer,
+      Optional<FrameworkFieldInitializer> fieldInitializer,
       DaggerTypes types,
       Elements elements) {
     super(resolvedBindings);
-    this.generatedComponentModel = generatedComponentModel;
     this.memberSelect = memberSelect;
-    this.fieldSpec = fieldSpec;
     this.frameworkType = frameworkType;
     this.fieldInitializer = fieldInitializer;
     this.types = types;
@@ -82,15 +67,13 @@ private FrameworkInstanceBindingExpression(
   }
 
   FrameworkInstanceBindingExpression producerFromProvider(
-      FieldSpec fieldSpec, ClassName componentName) {
+      MemberSelect memberSelect, FrameworkFieldInitializer producerFieldInitializer) {
     checkState(frameworkType.equals(FrameworkType.PROVIDER));
     return new FrameworkInstanceBindingExpression(
         resolvedBindings(),
-        Optional.of(fieldSpec),
-        generatedComponentModel,
-        MemberSelect.localField(componentName, fieldSpec.name),
+        memberSelect,
         FrameworkType.PRODUCER,
-        fieldInitializer.forProducerFromProvider(),
+        Optional.of(producerFieldInitializer),
         types,
         elements);
   }
@@ -104,7 +87,7 @@ FrameworkInstanceBindingExpression producerFromProvider(
   @Override
   Expression getDependencyExpression(
       DependencyRequest.Kind requestKind, ClassName requestingClass) {
-    maybeInitializeField();
+    fieldInitializer.ifPresent(FrameworkFieldInitializer::initializeField);
     TypeMirror expressionType =
         isTypeAccessibleFrom(instanceType(), requestingClass.packageName())
                 || isInlinedFactoryCreation()
@@ -134,11 +117,12 @@ private TypeMirror instanceType() {
    * the initialization {@code this.fooProvider = Foo_Factory.create(Bar_Factory.create());}, {@code
    * Bar_Factory} is considered to be inline.
    *
-   * <p>This is used in {@link #getDependencyExpression(Kind, ClassName)} when determining the type
-   * of a factory. Normally if the {@link #instanceType()} is not accessible from the component, the
-   * type of the expression will be a raw {@link javax.inject.Provider}. However, if the factory is
-   * created inline, even if contributed type is not accessible, javac will still be able to
-   * determine the type that is returned from the {@code Foo_Factory.create()} method.
+   * <p>This is used in {@link #getDependencyExpression(DependencyRequest.Kind, ClassName)} when
+   * determining the type of a factory. Normally if the {@link #instanceType()} is not accessible
+   * from the component, the type of the expression will be a raw {@link javax.inject.Provider}.
+   * However, if the factory is created inline, even if contributed type is not accessible, javac
+   * will still be able to determine the type that is returned from the {@code Foo_Factory.create()}
+   * method.
    */
   private boolean isInlinedFactoryCreation() {
     return memberSelect.staticMember();
@@ -148,102 +132,4 @@ private DeclaredType rawFrameworkType() {
     return types.getDeclaredType(
         elements.getTypeElement(resolvedBindings().frameworkClass().getCanonicalName()));
   }
-
-  /**
-   * Returns the name of the binding's underlying field.
-   *
-   * @throws UnsupportedOperationException if no field exists
-   */
-  // TODO(ronshapiro): remove this in favor of $N in a CodeBlock
-  private String fieldName() {
-    checkHasField();
-    return fieldSpec.get().name;
-  }
-
-  /**
-   * Sets the initialization state for the binding's underlying field. Only valid for field types.
-   *
-   * @throws UnsupportedOperationException if no field exists
-   */
-  private void setFieldInitializationState(InitializationState fieldInitializationState) {
-    checkHasField();
-    checkArgument(this.fieldInitializationState.compareTo(fieldInitializationState) < 0);
-    this.fieldInitializationState = fieldInitializationState;
-  }
-
-  private void checkHasField() {
-    if (!fieldSpec.isPresent()) {
-      throw new UnsupportedOperationException();
-    }
-  }
-
-  // Adds our field and initialization of our field to the component.
-  // TODO(user): Move this to the field initializer class
-  private void maybeInitializeField() {
-    if (!fieldSpec.isPresent()) {
-      return;
-    }
-    switch (fieldInitializationState) {
-      case UNINITIALIZED:
-        // Change our state in case we are recursively invoked via initializeBindingExpression
-        setFieldInitializationState(InitializationState.INITIALIZING);
-        CodeBlock.Builder codeBuilder = CodeBlock.builder();
-        CodeBlock initCode =
-            CodeBlock.of(
-                "this.$L = $L;",
-                fieldName(),
-                checkNotNull(fieldInitializer.getFieldInitialization()));
-
-        if (fieldInitializationState == InitializationState.DELEGATED) {
-          // If we were recursively invoked, set the delegate factory as part of our initialization
-          String delegateFactoryVariable = fieldName() + "Delegate";
-          codeBuilder
-              .add("$1T $2L = ($1T) $3L;", DELEGATE_FACTORY, delegateFactoryVariable, fieldName())
-              .add(initCode)
-              .add("$L.setDelegatedProvider($L);", delegateFactoryVariable, fieldName())
-              .build();
-        } else {
-          codeBuilder.add(initCode);
-        }
-        generatedComponentModel.addInitialization(codeBuilder.build());
-        generatedComponentModel.addField(fieldSpec.get());
-
-        setFieldInitializationState(InitializationState.INITIALIZED);
-        break;
-
-      case INITIALIZING:
-        // We were recursively invoked, so create a delegate factory instead
-        generatedComponentModel.addInitialization(
-            CodeBlock.of("this.$L = new $T<>();", fieldName(), DELEGATE_FACTORY));
-        setFieldInitializationState(InitializationState.DELEGATED);
-        break;
-
-      case DELEGATED:
-      case INITIALIZED:
-        break;
-      default:
-        throw new AssertionError("Unhandled initialization state: " + fieldInitializationState);
-    }
-  }
-
-  /** Initialization state for a factory field. */
-  private enum InitializationState {
-    /** The field is {@code null}. */
-    UNINITIALIZED,
-
-    /**
-     * The field's dependencies are being set up. If the field is needed in this state, use a {@link
-     * DelegateFactory}.
-     */
-    INITIALIZING,
-
-    /**
-     * The field's dependencies are being set up, but the field can be used because it has already
-     * been set to a {@link DelegateFactory}.
-     */
-    DELEGATED,
-
-    /** The field is set to an undelegated factory. */
-    INITIALIZED;
-  }
 }
